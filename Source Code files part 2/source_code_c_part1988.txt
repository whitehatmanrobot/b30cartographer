& refNode
    )
    {
        HRESULT hr = S_OK;
    
        if((m_cNodes / CELLSIZE) + 1 > m_cCells)
        {
            hr = Grow();
        }

        if(SUCCEEDED(hr))
        {
            m_cNodes++;
            Set(m_cNodes-1, refNode);
        }

        return hr;
    }

    T RemoveFromTheEnd()
    {
        m_cNodes--;

        T ret = m_pCells[m_cNodes / CELLSIZE]->rgNode[m_cNodes % CELLSIZE];

        Shrink();

        return ret;
    }

    void Set(
        DWORD dwIndex,
        T& refNode
    )
    {
        XOMASSERT(dwIndex < m_cNodes);

        m_pCells[dwIndex / CELLSIZE]->rgNode[dwIndex % CELLSIZE] = refNode;
    }


    T& Get(
        DWORD dwIndex)
    {
        XOMASSERT(dwIndex < m_cNodes);
    
        return m_pCells[dwIndex / CELLSIZE]->rgNode[dwIndex % CELLSIZE];
    }
   
    void Shrink()
    {
        if(m_cCells - ((m_cNodes / CELLSIZE) + 1) > MAXEMPTYCELLS)
        {
            m_cCells--;
            delete m_pCells[m_cCells];
            m_pCells[m_cCells] = NULL;
        }
    }

    struct CELL 
    {
        T rgNode[CELLSIZE];
    };
    
    HRESULT Grow()
    {
        m_pCells[m_cCells] = new CELL;

        if(m_pCells[m_cCells])
        {
            m_cCells++;
            return S_OK;
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    }

    DWORD GetCount()
    {
        return m_cNodes;
    }

protected:


    CELL* m_pCells[MAXCELLS];
    DWORD m_cCells;
    DWORD m_cNodes;
};


#endif // #ifndef _DARRAY_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\inh\cliconn.h ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#ifndef CONNECTION_H_INCLUDED
#define CONNECTION_H_INCLUDED

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CSwitchboard;
class CForwardingConnection;
class CForwardedMessageContext;

/*****************************************************************************

CTCPCntMessageBasedPlugin_PN

Protocol message length definition for presence and notification

*****************************************************************************/
struct CTCPCntMessageBasedPlugin_PN
{
    int operator ()(
        const BYTE* pBuffer,
        DWORD cbBuffer
    ) const
    {
        BASE_MSG_HEADER *pHdr;

        if(cbBuffer < sizeof(BASE_MSG_HEADER))
        {
            return 0;
        }

        pHdr = (BASE_MSG_HEADER *) pBuffer;

        if ((pHdr->dwMsgLen + sizeof(BASE_MSG_HEADER)) > CTCPCnt_RECEIVE_BUFFER_LENGTH)
        {
            if (cbBuffer < CTCPCnt_RECEIVE_BUFFER_LENGTH)
            {
                return 0;
            }
            
            return CTCPCnt_RECEIVE_BUFFER_LENGTH;
        }
        
        if (cbBuffer < (pHdr->dwMsgLen + sizeof(BASE_MSG_HEADER)))
        {
            return 0;
        }

        return (pHdr->dwMsgLen + sizeof(BASE_MSG_HEADER));
    }
};

/*****************************************************************************

CClientConnection

Contains one client connection.  Does message parsing, simple processing 
and validation of messages before calling into the implemention of the logic
behind the message.

*****************************************************************************/
class CClientConnection : public CTCPCntMessageBased<CTCPCntMessageBasedPlugin_PN>
{
public:
    CClientConnection();
    virtual ~CClientConnection();

    HRESULT Init( CSwitchboard *pSwitchboard, CServerSocket *pSocket );
    
    void ProcessCliConnMessage(BYTE *pMsg, DWORD cbEntireMsg);

protected:

    virtual void OnDisconnect(HRESULT hrReason ) 
    {
        // Self Destruct
        Release();
    }

    virtual void ProcessMessage(BYTE *pMsg, DWORD cbEntireMsg);
    
    HRESULT DeferMessage(QWORD qwUserID, BASE_MSG_HEADER *pMsg, DWORD cbEntireMessage);

    // Message handler methods
    typedef void (CClientConnection::*MsgHandler)(
                                      BASE_MSG_HEADER *pMsgHeader,
                                      DWORD cbEntireMsg );

    void ProcessMsgHello(P_HELLO_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgConnectionHealth(P_CONNECTION_HEALTH_MSG *pMsg, DWORD cbEntireMsg);

    void ProcessMsgNotSupported(BASE_MSG_HEADER *pMsg, DWORD cbEntireMsg);

    void ProcessMsgLogonCheck(P_LOGON_CHECK_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgAliveInternal(P_ALIVE_INTERNAL_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgAliveInternal2(P_ALIVE_INTERNAL_2_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgCheckTitleMessages(P_CHECK_TITLE_MESSAGES_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgSync(P_SYNC_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgAdd(P_ADD_2_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgAddAffiliates(P_ADD_AFFILIATES_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgIsAffiliate(P_IS_AFFILIATE_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgQueryAffiliates(P_QUERY_AFFILIATES_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgGetPresenceInfo(P_GET_PRESENCE_INFO_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgDelete(P_DELETE_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgAccept(P_ACCEPT_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgReject(P_REJECT_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgBlock(P_BLOCK_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgUnblock(P_UNBLOCK_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgInvite(P_INVITE_2_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgCancel(P_CANCEL_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgInviteAnswer(P_INVITE_ANSWER_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgNickname(P_NICKNAME_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgState(P_STATE_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgState2(P_STATE_2_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgGetState(P_GET_STATE_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgDeadUser(P_DEAD_USER_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgDeadXBox(P_DEAD_XBOX_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgDeadSG(P_DEAD_SG_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgKick(P_KICK_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgInvalidateUser(P_INVALIDATE_USER_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgWebAlive(P_WEB_ALIVE_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgWebFriends(P_WEB_FRIENDS_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgPeerSession(P_PEER_SESSION_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgPeerSubscribe(P_PEER_SUBSCRIBE_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgPeerSubscribeEx(P_PEER_SUBSCRIBE_EX_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgPeerUnsubscribe(P_PEER_UNSUBSCRIBE_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgTeamListTeams(P_TEAM_LIST_TEAMS_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgTeamListUserTeams(P_TEAM_LIST_USER_TEAMS_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgTeamListMembers(P_TEAM_LIST_MEMBERS_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgTeamCreate(P_TEAM_CREATE_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgTeamDelete(P_TEAM_DELETE_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgTeamRemove(P_TEAM_REMOVE_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgTeamManageTeam(P_TEAM_MANAGE_TEAM_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgTeamManageMember(P_TEAM_MANAGE_MEMBER_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgTeamRecruit(P_TEAM_RECRUIT_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgTeamJoin(P_TEAM_JOIN_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgTeamGetTicket(P_TEAM_GET_TICKET_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgPurgeUser(P_PURGE_USER_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgGetFriendsList(P_GET_FRIENDS_LIST_MSG *pMsg, DWORD cbEntireMsg);

    // Notification handlers
    void ProcessMsgDequeue(Q_DEQUEUE_MSG *pMsg, DWORD cbEntireMsg);

    void ProcessMsgEnumerateMessages(Q_ENUM_MESSAGES_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgGetMessageSummary(Q_MESSAGE_SUMMARY_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgGetMessageDetails(Q_MESSAGE_DETAILS_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgDeleteMessage(Q_DELETE_MESSAGE_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgSendMessage(Q_SEND_MESSAGE_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgRevokeMessage(Q_REVOKE_MESSAGE_EX_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgDeleteUserTitle(Q_DELETE_TITLE_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgEnumerateUserTitles(Q_ENUM_TITLES_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgMessageFlags(Q_MESSAGE_FLAGS_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgEnumSystemMessages(Q_ENUM_SYSTEM_MESSAGES_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgSystemMessageDetails(Q_SYSTEM_MESSAGE_DETAILS_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgDeleteSystemMessage(Q_DELETE_SYSTEM_MESSAGE_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgSendSystemMessage(Q_SEND_SYSTEM_MESSAGE_MSG *pMsg, DWORD cbEntireMsg);

    // Methods for sending replies
    HRESULT SendErrorListReply(
        DWORD dwSeqNum,
        const SGADDR *psgaddr,
        QWORD qwUserID,
        DWORD dwQType,
        HRESULT hrList);

    BOOL m_fSeenHello;
    CSwitchboard *m_pSwitchboard;
    sockaddr_in m_sa;
    char m_pszDesc[MAX_HELLO_DESCRIPTION_LEN + 1];
};

/*****************************************************************************

CClientListener

Listens for incomming client connections and spins off CClientConnection
objects for each accepted connection.

*****************************************************************************/
class CClientListener : 
    public CServerSocketCallback
{
public:
    IMPLEMENT_REFCOUNT;

    CClientListener();
    virtual ~CClientListener();

    HRESULT Init(CSwitchboard *pCSwitchboard);
    void Shutdown();

    // CServerSocketCallback methods
    virtual void OnSocketAccept(
        CServerSocket *pListenSocket,
        CServerSocket *pAcceptedSocket,
        sockaddr_in *pLocalAddr,
        sockaddr_in *pRemoteAddr,
        HRESULT hr,
        QWORD qwCallbackArg );
    
    HRESULT CClientListener::ForwardMessage(
        CClientConnection *pCCliConn,
        QWORD qwUserID,
        BASE_MSG_HEADER *pMsg,
        DWORD cbEntireMsg);

    HRESULT CreateForwardConnection(DWORD dwServerIndex);
    HRESULT RemoveForwardConnection(DWORD dwServerIndex);

    HRESULT ChangeServerList(DWORD *rgdwIndexMap, DWORD cOldServers);

protected:

    HRESULT InitForwarding();

    CForwardingConnection **m_rgpForwardingConnections;
    CCompletionPort *m_pCCompPort;
    CSwitchboard *m_pCSwitchboard;
    CServerSocket *m_pCListenSocket;
};

class CForwardingConnection : public CTCPCntMessageBased<CTCPCntMessageBasedPlugin_PN>
{
public:

    CForwardingConnection() :
        m_dwSeqNum(0),
        m_dwServerIndex(0),
        m_pSwitchboard(NULL),
        m_fSentHello(FALSE)
    {
    }
        
    ~CForwardingConnection();

    HRESULT InitConnect(
        DWORD dwServerIndex,
        CCompletionPort *pCompPort,
        CSwitchboard *pSwitchboard);

    void ChangeServerIndex(DWORD dwNewIndex) { m_dwServerIndex = dwNewIndex; }

    virtual void OnConnect();
    virtual void OnDisconnect(HRESULT hrReason);
    void OnDisconnectInternal(HRESULT hrReason);

    virtual void ProcessMessage(BYTE *pMsg, DWORD cbEntireMsg);
    void ProcessReplyMessage(BYTE *pMsg, DWORD cbEntireMsg);

    DWORD IncrementSequenceNumber() { return ++ m_dwSeqNum; }

    BOOL HasSentHello()
    {
        return m_fSentHello;
    }

protected:

    HRESULT SendMsgHello()
    {
        HRESULT hr = S_OK;
        char szDesc[] = "Forward";
        CTCPCntVarBuffer *pBuffer = g_pBufferPool->GetBuffer(sizeof(P_HELLO_MSG) + 8);
        if (pBuffer == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto lDone;
        }

        P_HELLO_MSG *pMsg = (P_HELLO_MSG *)pBuffer->GetBuffer();

        pMsg->dwMsgType = PMSG_HELLO;
        pMsg->dwMsgLen = pBuffer->GetBufferLength() - sizeof(BASE_MSG_HEADER);
        pMsg->dwSeqNum = IncrementSequenceNumber();
        pMsg->dwProtocolVersion = CURRENT_XPPROTOCOL_VER;
        memcpy(pMsg + 1, szDesc, 8);

        hr = Send(pBuffer);

        m_fSentHello = TRUE;

    lDone:

        SAFE_RELEASE(pBuffer);

        return hr;
    }
    
    CForwardedMessageContext *FindContext(DWORD dwSeqNum);

    sockaddr_in m_sa;
    CSwitchboard *m_pSwitchboard;
    DWORD m_dwSeqNum;
    DWORD m_dwServerIndex;
    BOOL m_fSentHello;
};
#endif  // CONNECTION_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\inh\msgutil.cpp ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#include "stdafx.h"


// wNextPropStart - starting offset for current property, just past the end of the last property
BOOL IsValidProperty( XMSG_PROPERTY* pProperty, const XMSG_DETAILS* pDetails, WORD cbDetails, WORD &wNextPropStart )
{
    WORD wOffsetBase = sizeof( XMSG_DETAILS ) + ( pDetails->wPropCount * sizeof( XMSG_PROPERTY ) );
    LPCSTR psz;
    const XMSG_PROPERTY_BINARY* pBinProp;
    const XMSG_PROPERTY_STRING* pStringProp;
    const XMSG_PROPERTY_ATTACHMENT* pAttachProp;

    switch( XOnlineMessageGetPropType( pProperty->wPropTag ) )
    {
    case XONLINE_MSG_PROP_TYPE_NULL: // The property contains no data
        // we never look at the offset field
        break;

    case XONLINE_MSG_PROP_TYPE_BOOL: // The property contains a bool as a byte
        // only two allowed bit patterns in upper bits; we never look at lower bits
        if( (pProperty->bData != TRUE) && (pProperty->bData != FALSE) ) {
                XomTrace(
                    PresenceDebug,
                    L_ERROR,
                    "IsValidProperty failed - PropTag[%04X] contains non-boolean byte data (%04X)",
                    pProperty->wPropTag,
                    pProperty->wPropOffset );
                return FALSE;
        }
        break;

    case XONLINE_MSG_PROP_TYPE_I1: // The property contains 8-bits of data
        // data in 8 high bits; we never look at low bits
        break;

    case XONLINE_MSG_PROP_TYPE_I2: // The property contains 16-bits of data
        // The property descriptor contains the data so we don't need to look
        // any further.
        break;

    case XONLINE_MSG_PROP_TYPE_I4: // The property contains 32-bits of data
    case XONLINE_MSG_PROP_TYPE_STRING_ID:
        // packed, sequential data only
        if( pProperty->wPropOffset != wNextPropStart ) {
            XomTrace(
                PresenceDebug,
                L_ERROR,
                "IsValidProperty failed - PropTag[%04X] offset begins before previous property ends (%d <= %d)",
                pProperty->wPropTag,
                wOffsetBase + pProperty->wPropOffset,
                wNextPropStart );
            return FALSE;
        }

        if( wOffsetBase + pProperty->wPropOffset + sizeof( DWORD ) > cbDetails )
        {
            XomTrace(
                PresenceDebug,
                L_ERROR,
                "IsValidProperty failed - PropTag[%04X] offset overflows message (%d > %d)",
                pProperty->wPropTag,
                wOffsetBase + pProperty->wPropOffset + sizeof( DWORD ),
                cbDetails);
            return FALSE;
        }

        wNextPropStart = pProperty->wPropOffset + sizeof( DWORD );
        break;

    case XONLINE_MSG_PROP_TYPE_I8: // The property contains 64-bits of data
    case XONLINE_MSG_PROP_TYPE_FILETIME: // The property contains a time value
        // packed, sequential data only
        if( pProperty->wPropOffset != wNextPropStart ) {
            XomTrace(
                PresenceDebug,
                L_ERROR,
                "IsValidProperty failed - PropTag[%04X] offset begins before previous property ends (%d <= %d)",
                pProperty->wPropTag,
                wOffsetBase + pProperty->wPropOffset,
                wNextPropStart );
            return FALSE;
        }

        if( wOffsetBase + pProperty->wPropOffset + sizeof( ULONGLONG ) > cbDetails )
        {
            XomTrace(
                PresenceDebug,
                L_ERROR,
                "IsValidProperty failed - PropTag[%04X] offset overflows message (%d > %d)",
                pProperty->wPropTag,
                wOffsetBase + pProperty->wPropOffset + sizeof( ULONGLONG ),
                cbDetails);
            return FALSE;
        }

        wNextPropStart = pProperty->wPropOffset + sizeof( ULONGLONG );
        break;

    case XONLINE_MSG_PROP_TYPE_STRING: // The property is a NULL-terminated UTF-8 string
        // packed, sequential data only
        if( pProperty->wPropOffset != wNextPropStart ) {
            XomTrace(
                PresenceDebug,
                L_ERROR,
                "IsValidProperty failed - PropTag[%04X] offset begins before previous property ends (%d <= %d)",
                pProperty->wPropTag,
                wOffsetBase + pProperty->wPropOffset,
                wNextPropStart );
            return FALSE;
        }

        pStringProp = (const XMSG_PROPERTY_STRING*)( (BYTE*)pDetails + wOffsetBase + pProperty->wPropOffset );
        if( ((BYTE *) (pStringProp + 1) - (BYTE *) pDetails) + pStringProp->cbString > cbDetails )
        {
            XomTrace(
                PresenceDebug,
                L_ERROR,
                "IsValidProperty failed - PropTag[%04X] offset overflows message (%d > %d)",
                pProperty->wPropTag,
                ((BYTE *) (pStringProp + 1) - (BYTE *) pDetails) + pStringProp->cbString,
                cbDetails);
            return FALSE;
        }

        psz = (LPCSTR) ( pStringProp + 1 ); // skips property header (cbString)
        while( '\0' != *psz )
        {
            if( ((BYTE*) psz - (BYTE*) (pStringProp + 1)) >= pStringProp->cbString )
            {
                XomTrace(
                    PresenceDebug,
                    L_ERROR,
                    "IsValidProperty failed - PropTag[%04X] string does not terminate at stated length (%d)",
                    pProperty->wPropTag,
                    pStringProp->cbString );
                return FALSE;
            }
            psz++;
        }
        psz++; // Include the NULL in the total size

        if( (WORD)( (BYTE*)psz - (BYTE*)( pStringProp + 1 ) ) != pStringProp->cbString )
        {
            XomTrace(
                PresenceDebug,
                L_ERROR,
                "IsValidProperty failed - PropTag[%04X] string size in message doesn't match actual size of string (%d != %d)",
                pProperty->wPropTag,
                (BYTE*)psz - (BYTE*)( pStringProp + 1 ),
                pStringProp->cbString );
            return FALSE;
        }

        wNextPropStart = pProperty->wPropOffset + sizeof( XMSG_PROPERTY_STRING ) + pStringProp->cbString;
        break;

    case XONLINE_MSG_PROP_TYPE_BINARY: // The property contains a size and binary blob
        // packed, sequential data only
        if( pProperty->wPropOffset != wNextPropStart ) {
            XomTrace(
                PresenceDebug,
                L_ERROR,
                "IsValidProperty failed - PropTag[%04X] offset begins before previous property ends (%d <= %d)",
                pProperty->wPropTag,
                wOffsetBase + pProperty->wPropOffset,
                wNextPropStart );
            return FALSE;
        }

        pBinProp = (const XMSG_PROPERTY_BINARY*)( (BYTE*)pDetails + wOffsetBase + pProperty->wPropOffset );
        if( ((BYTE *) (pBinProp + 1) - (BYTE *) pDetails) + pBinProp->cbData > cbDetails )
        {
            XomTrace(
                PresenceDebug,
                L_ERROR,
                "IsValidProperty failed - PropTag[%04X] offset overflows message (%d > %d)",
                pProperty->wPropTag,
                ((BYTE *) (pBinProp + 1) - (BYTE *) pDetails) + pBinProp->cbData,
                cbDetails);
            return FALSE;
        }

        wNextPropStart = pProperty->wPropOffset + sizeof( XMSG_PROPERTY_BINARY ) + pBinProp->cbData;
        break;

    case XONLINE_MSG_PROP_TYPE_ATTACHMENT: // The property contains a reference to XOnline Storage content
        // packed, sequential data only
        if( pProperty->wPropOffset != wNextPropStart ) {
            XomTrace(
                PresenceDebug,
                L_ERROR,
                "IsValidProperty failed - PropTag[%04X] offset begins before previous property ends (%d <= %d)",
                pProperty->wPropTag,
                wOffsetBase + pProperty->wPropOffset,
                wNextPropStart );
            return FALSE;
        }

        pAttachProp = (const XMSG_PROPERTY_ATTACHMENT*)( (BYTE*)pDetails + wOffsetBase + pProperty->wPropOffset );
        if( ((BYTE *) (pAttachProp + 1) - (BYTE *) pDetails) + pAttachProp->cbAttachUrl > cbDetails )
        {
            XomTrace(
                PresenceDebug,
                L_ERROR,
                "IsValidProperty failed - PropTag[%04X] offset overflows message (%d > %d)",
                pProperty->wPropTag,
                ((BYTE *) (pAttachProp + 1) - (BYTE *) pDetails) + pAttachProp->cbAttachUrl,
                cbDetails);
            return FALSE;
        }

        if( 0 != ( XONLINE_MSG_ATTACHMENT_FLAGS_RESERVED & pAttachProp->dwAttachFlags ) )
        {
            XomTrace(
                PresenceDebug,
                L_ERROR,
                "IsValidProperty failed - PropTag[%04X] attachment specifies reserved flags (0x%08X not in 0x%08X)",
                pProperty->wPropTag,
                pAttachProp->dwAttachFlags,
                XONLINE_MSG_ATTACHMENT_FLAGS_RESERVED);
            return FALSE;
        }

        psz = (LPCSTR)( pAttachProp + 1 ); // skips property header (cbAttach, dwAttachFlags, cbAttachUrl)
        while( '\0' != *psz )
        {
            if( ((BYTE*) psz - (BYTE*) (pAttachProp + 1)) >= (WORD) pAttachProp->cbAttachUrl )
            {
                XomTrace(
                    PresenceDebug,
                    L_ERROR,
                    "IsValidProperty failed - PropTag[%04X] URL does not terminate at stated length (%d)",
                    pProperty->wPropTag,
                    pAttachProp->cbAttachUrl );
                return FALSE;
            }
            psz++;
        }
        psz++; // Include the NULL in the total size

        if( (WORD)( (BYTE*)psz - (BYTE*)( pAttachProp + 1 ) ) != pAttachProp->cbAttachUrl )
        {
            XomTrace(
                PresenceDebug,
                L_ERROR,
                "IsValidProperty failed - PropTag[%04X] URL size in message doesn't match actual size of string (%d != %d)",
                pProperty->wPropTag,
                (BYTE*)psz - (BYTE*)( pAttachProp + 1 ),
                pAttachProp->cbAttachUrl);
            return FALSE;
        }

        wNextPropStart = pProperty->wPropOffset + sizeof( XMSG_PROPERTY_ATTACHMENT ) + (WORD) pAttachProp->cbAttachUrl;
        break;

    default:
        // Unknown property type
        XomTrace(
            PresenceDebug,
            L_ERROR,
            "IsValidProperty failed - PropTag[%04X] unknown property type",
            pProperty->wPropTag);
        return FALSE;
    }

    return TRUE;
}

// A simple 256-bit bitmask
class CBitMask256
{
public:
    CBitMask256() { memset( this, 0, sizeof( *this ) ); }

    BOOL IsBitSet( BYTE bit ) const { return 0 != ( m_ull[ bit >> 6 ] & ( (ULONGLONG)1 << ( bit & 0x3F ) ) ); }
    void SetBit( BYTE bit ) { m_ull[ bit >> 6 ] |= ( (ULONGLONG)1 << ( bit & 0x3F ) ); }

private:
    ULONGLONG m_ull[4];
};

BOOL IsValidDetails( const XMSG_DETAILS* pDetails, WORD cbDetails )
{
    if( 0 != cbDetails )
    {
        // Is there enough room for the details header?
        if( cbDetails < sizeof( XMSG_DETAILS ) || 
            cbDetails > XONLINE_MAX_MESSAGE_DETAILS )
        {
            XomTrace(
                PresenceDebug,
                L_ERROR,
                "IsValidDetails failed - cbDetails is too small or too large (%d <= %d <= %d)",
                sizeof( XMSG_DETAILS ),
                cbDetails,
                XONLINE_MAX_MESSAGE_DETAILS);
            return FALSE;
        }

        // Does the size in the details match with the overall size?
        if( cbDetails != pDetails->cbData + sizeof( XMSG_DETAILS ) + ( pDetails->wPropCount * sizeof( XMSG_PROPERTY ) ) )
        {
            XomTrace(
                PresenceDebug,
                L_ERROR,
                "IsValidDetails failed - Size in details doesn't match overall size (%d != %d)",
                cbDetails,
                pDetails->cbData + sizeof( XMSG_DETAILS ) + ( pDetails->wPropCount * sizeof( XMSG_PROPERTY ) ));
            return FALSE;
        }

        // Is there enough room for the property descriptors?
        if( cbDetails < sizeof( XMSG_DETAILS ) + pDetails->wPropCount * sizeof( XMSG_PROPERTY ) )
        {
            XomTrace(
                PresenceDebug,
                L_ERROR,
                "IsValidDetails failed - Message too small for property descriptors (%d < %d)",
                cbDetails,
                sizeof( XMSG_DETAILS ) + pDetails->wPropCount * sizeof( XMSG_PROPERTY ));
            return FALSE;
        }

        // Are there too many properties?  Max is limited by wPropTag which contains a type and ID.  Since
        // no two IDs can be duplicated in the same message, and the ID is a byte, the max number of properties
        // per message is 256.  A property ID of zero is invalid, reducing the max properties to 255.
        if( 255 < pDetails->wPropCount )
        {
            XomTrace(
                PresenceDebug,
                L_ERROR,
                "IsValidDetails failed - Message contains too many properties (%d > 256)",
                pDetails->wPropCount);
            return FALSE;
        }

        // While validating properties, we want to make sure that no single ID is repeated.
        CBitMask256 propIdBitMask;

        // Validate the properties
        XMSG_PROPERTY* pProperties = (XMSG_PROPERTY*)( pDetails + 1 );
        WORD wNextPropStart = 0; // offset for next property
        for( WORD iProperty = 0; iProperty < pDetails->wPropCount; iProperty++ )
        {
            // A property ID of zero is invalid
            if( 0 == XOnlineMessageGetPropId( pProperties[ iProperty ].wPropTag ) )
            {
                XomTrace(
                    PresenceDebug,
                    L_ERROR,
                    "IsValidDetails failed - Message contains invalid prop ID (0)" );
                return FALSE;
            }

            // A property type of zero is invalid
            if( 0 == XOnlineMessageGetPropType( pProperties[ iProperty ].wPropTag ) )
            {
                XomTrace(
                    PresenceDebug,
                    L_ERROR,
                    "IsValidDetails failed - Message contains invalid prop type (0)" );
                return FALSE;
            }

            // Make sure we haven't seen this prop ID before in this set of details
            if( propIdBitMask.IsBitSet( XOnlineMessageGetPropId( pProperties[ iProperty ].wPropTag ) ) )
            {
                XomTrace(
                    PresenceDebug,
                    L_ERROR,
                    "IsValidDetails failed - Message contains prop ID %d more than once",
                    XOnlineMessageGetPropId( pProperties[ iProperty ].wPropTag ) );
                return FALSE;
            }

            // Note the fact that this ID has been seen
            propIdBitMask.SetBit( XOnlineMessageGetPropId( pProperties[ iProperty ].wPropTag ) );

            // Verify this property
            if( !IsValidProperty( &pProperties[ iProperty ], pDetails, cbDetails, wNextPropStart ) )
            {
                return FALSE;
            }
        }

        // after validating properties, wNextPropStart holds summed length of all property data
        // this should match the data byte count
        if( wNextPropStart != pDetails->cbData ) {
            XomTrace(
                PresenceDebug,
                L_ERROR,
                "IsValidDetails failed - Total property data length (%d) does not match message data length (%d)",
                wNextPropStart,
                pDetails->cbData );
            return FALSE;
        }
    }

    return TRUE;
}

BOOL IsValidMessageType( BYTE bMessageType, WORD* pwExpiration )
{
    // If the expiration is zero or greater than the current maximum for this message type, 
    // use the default value.  This allows us to turn down the expiration for a particular 
    // message type without breaking any clients, and allows clients to use 0 when they 
    // don't care about the expiration and want the default.

    for( WORD iType = 0; iType < g_CPresCfg.GetValidMessageTypesLen(); iType++ )
    {
        if( bMessageType == g_CPresCfg.GetValidMessageType(iType) )
        {
            if( 0 == *pwExpiration || 
                *pwExpiration > (WORD) g_CPresCfg.GetMessageTypeExpiration(iType) )
            {
                *pwExpiration = (WORD) g_CPresCfg.GetMessageTypeExpiration(iType);
            }
            return TRUE;
        }
    }
    return FALSE;
}

const BYTE* GetMessageProperty( WORD wPropTag, const XMSG_DETAILS* pDetails )
{
    for( WORD iProp = 0; iProp < pDetails->wPropCount; iProp++ )
    {
        XMSG_PROPERTY* pProp = (XMSG_PROPERTY*)( pDetails + 1 ) + iProp;

        if( wPropTag == pProp->wPropTag )
        {
            switch( XOnlineMessageGetPropType( pProp->wPropTag ) )
            {
            case XONLINE_MSG_PROP_TYPE_NULL: // The property contains no data
                // NOTE: In this case there is no data, but it is important that we don't return NULL so
                // that the caller knows we found the property.
            case XONLINE_MSG_PROP_TYPE_BOOL: // The property contains a bool as a byte
            case XONLINE_MSG_PROP_TYPE_I1: // The property contains 8-bits of data
            case XONLINE_MSG_PROP_TYPE_I2: // The property contains 16-bits of data
                return (const BYTE*) &pProp->wPropOffset;
            default:
                return( (const BYTE*)pDetails + sizeof( XMSG_DETAILS ) + ( pDetails->wPropCount * sizeof( XMSG_PROPERTY ) ) + pProp->wPropOffset );
            }
        }
    }
    return NULL;
}

BOOL ValidateSendMessage( Q_SEND_MESSAGE_MSG *pMsg, DWORD cbEntireMsg, const sockaddr_in* pAddr )
{
    XMSG_DETAILS* pDetails = NULL;

    // Check extended message size
    if( cbEntireMsg < sizeof( Q_SEND_MESSAGE_MSG ) + 
                      pMsg->cRecipients * sizeof( ULONGLONG ) + 
                      pMsg->cbDetails)
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_104,
            "SendMessage from %s:%d (size %d < %d), title=0x%08X",
            inet_ntoa(pAddr->sin_addr),
            ntohs(pAddr->sin_port),
            cbEntireMsg,
            sizeof( Q_SEND_MESSAGE_MSG ) + 
                pMsg->cRecipients * sizeof( ULONGLONG ) +  
                pMsg->cbDetails,
            pMsg->dwSenderTitleID );

        return FALSE;
    }    

    // Validate the message type and set the correct expiration
    if( !IsValidMessageType( pMsg->bMessageType, &pMsg->wExpireMinutes ) )
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_105,
            "SendMessage from %s:%d Bad message type (%d), title=0x%08X",
            inet_ntoa(pAddr->sin_addr),
            ntohs(pAddr->sin_port),
            pMsg->bMessageType,
            pMsg->dwSenderTitleID );

        return FALSE;
    }

    // Validate the message flags
    if( 0 != ( pMsg->dwMessageFlags & ~(XONLINE_MSG_FLAGS_VALID_SEND_MASK) ) )
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_106,
            "SendMessage from %s:%d Bad message flags (0x%08X not in 0x%08X), title=0x%08X",
            inet_ntoa(pAddr->sin_addr),
            ntohs(pAddr->sin_port),
            pMsg->dwMessageFlags,
            XONLINE_MSG_FLAGS_VALID_SEND_MASK,
            pMsg->dwSenderTitleID );

        return FALSE;
    }

    // Non-exportable flag is only allowed on TITLE_CUSTOM messages
    if( 0 != ( pMsg->dwMessageFlags & XONLINE_MSG_FLAG_NON_EXPORTABLE ) &&
        XONLINE_MSG_TYPE_TITLE_CUSTOM != pMsg->bMessageType )
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_107,
            "SendMessage from %s:%d Non-exportable flag only allowed on TITLE_CUSTOM messages, type=%d, title=0x%08X",
            inet_ntoa(pAddr->sin_addr),
            ntohs(pAddr->sin_port),
            pMsg->bMessageType,
            pMsg->dwSenderTitleID );

        return FALSE;
    }

    // Required and recommended flags are only allowed on LIVE_MESSAGE messages
    if( 0 != ( pMsg->dwMessageFlags & ( XONLINE_MSG_FLAG_REQUIRED | XONLINE_MSG_FLAG_RECOMMENDED ) ) &&
        XONLINE_MSG_TYPE_LIVE_MESSAGE != pMsg->bMessageType )
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_108,
            "SendMessage from %s:%d Required and recommended flags only allowed on LIVE_MESSAGE messages, type=%d, title=0x%08X",
            inet_ntoa(pAddr->sin_addr),
            ntohs(pAddr->sin_port),
            pMsg->bMessageType,
            pMsg->dwSenderTitleID );

        return FALSE;
    }

    // Title ID can't be zero
    if( 0 == pMsg->dwSenderTitleID )
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_109,
            "SendMessage from %s:%d invalid title ID (0), title=0x%08X",
            inet_ntoa(pAddr->sin_addr),
            ntohs(pAddr->sin_port),
            pMsg->dwSenderTitleID );

        return FALSE;
    }

    // Validate recipient count
    if( 0 == pMsg->cRecipients )
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_110,
            "SendMessage from %s:%d invalid recipient count (0), title=0x%08X",
            inet_ntoa(pAddr->sin_addr),
            ntohs(pAddr->sin_port),
            pMsg->dwSenderTitleID );

        return FALSE;
    }

    if( pMsg->cRecipients > XONLINE_MAX_MESSAGE_RECIPIENTS )
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_111,
            "SendMessage from %s:%d Too many recipients (%d > %d), title=0x%08X",
            inet_ntoa(pAddr->sin_addr),
            ntohs(pAddr->sin_port),
            pMsg->cRecipients,
            XONLINE_MAX_MESSAGE_RECIPIENTS,
            pMsg->dwSenderTitleID );

        return FALSE;
    }

    // Are we on the right notification server?
    if( (pMsg->qwSenderID != 0) && !g_CPresCfg.CheckDestination( pMsg->qwSenderID ))
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_112,
            "SendMessage from %s:%d for user %I64X sent to the wrong server, title=0x%08X",
            inet_ntoa(pAddr->sin_addr),
            ntohs(pAddr->sin_port),
            pMsg->qwSenderID,
            pMsg->dwSenderTitleID );

        return FALSE;
    }

    pDetails = (XMSG_DETAILS*)( (BYTE*)(pMsg + 1) + pMsg->cRecipients * sizeof(ULONGLONG) );

    // Validate properties
    if( !IsValidDetails( pDetails, pMsg->cbDetails ) )
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_113,
            "SendMessage from %s:%d Message details are invalid, title=0x%08X",
            inet_ntoa(pAddr->sin_addr),
            ntohs(pAddr->sin_port),
            pMsg->dwSenderTitleID );

        return FALSE;
    }

    return TRUE;
}

BOOL ValidateRevokeMessage( const Q_REVOKE_MESSAGE_EX_MSG *pMsg, DWORD cbEntireMsg, const sockaddr_in* pAddr )
{
    const Q_RECIPIENT_RESULT* rgRecips = NULL;
    const BYTE* pbProp = NULL;

    // Check extended message size
    if( cbEntireMsg < sizeof( Q_REVOKE_MESSAGE_EX_MSG ) + 
                      pMsg->cbProp +
                      (pMsg->cRecipients * sizeof( Q_RECIPIENT_RESULT )))
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_114,
            "RevokeMessage from %s:%d (size %d != %d)",
            inet_ntoa(pAddr->sin_addr),
            ntohs(pAddr->sin_port),
            cbEntireMsg,
            sizeof( Q_REVOKE_MESSAGE_EX_MSG ) +
                pMsg->cbProp +
                (pMsg->cRecipients * sizeof( Q_RECIPIENT_RESULT )));

        return FALSE;
    }
    
    rgRecips = (const Q_RECIPIENT_RESULT*)( pMsg + 1 );
    pbProp = (const BYTE*)( (BYTE*)( pMsg + 1 ) + pMsg->cRecipients * sizeof( Q_RECIPIENT_RESULT ) );

    // Validate recipient count
    if( pMsg->cRecipients > XONLINE_MAX_MESSAGE_RECIPIENTS )
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_116,
            "RevokeMessage from %s:%d Too many recipients (%d > %d)",
            inet_ntoa(pAddr->sin_addr),
            ntohs(pAddr->sin_port),
            pMsg->cRecipients,
            XONLINE_MAX_MESSAGE_RECIPIENTS);

        return FALSE;
    }

    // Validate prop size
    if( XONLINE_MAX_MESSAGE_DETAILS < pMsg->cbProp )
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_117,
            "RevokeMessage from %s:%d Prop size is too large (%d > %d)",
            inet_ntoa(pAddr->sin_addr),
            ntohs(pAddr->sin_port),
            pMsg->cbProp,
            XONLINE_MAX_MESSAGE_DETAILS);

        return FALSE;
    }

    // Validate each allowed flag

    // Block sender has some special restrictions
    if( pMsg->dwFlags & XMSG_REVOKE_MESSAGE_EX_FLAG_BLOCK_SENDER )
    {
        // Can't block sender if we don't have one
        if( 0 == ( pMsg->dwFlags & XMSG_REVOKE_MESSAGE_EX_FLAG_USE_SENDER ) )
        {
            XomNtEvent(
                XEVENT_PRESENCE_CODE_118,
                "RevokeMessage from %s:%d Can't block sender if not specified (0x%08X)",
                inet_ntoa(pAddr->sin_addr),
                ntohs(pAddr->sin_port),
                pMsg->dwFlags );

            return FALSE;
        }

        // This should only be used when there is exactly one recipient
        if( 1 != pMsg->cRecipients )
        {
            XomNtEvent(
                XEVENT_PRESENCE_CODE_119,
                "RevokeMessage from %s:%d Can't block sender for more than one recipient (0x%04X)",
                inet_ntoa(pAddr->sin_addr),
                ntohs(pAddr->sin_port),
                pMsg->cRecipients );

            return FALSE;
        }
    }

    // If revoking by ID, the IDs must be non-zero
    if( pMsg->dwFlags & XMSG_REVOKE_MESSAGE_EX_FLAG_USE_ID )
    {
        // Validate recipient count
        if( 0 == pMsg->cRecipients )
        {
            XomNtEvent(
                XEVENT_PRESENCE_CODE_115,
                "RevokeMessage from %s:%d No recipients (0)",
                inet_ntoa(pAddr->sin_addr),
                ntohs(pAddr->sin_port));

            return FALSE;
        }

        for( DWORD iRecip = 0; iRecip < pMsg->cRecipients; iRecip++ )
        {
            if( 0 == rgRecips[ iRecip ].dwMessageID )
            {
                XomNtEvent(
                    XEVENT_PRESENCE_CODE_120,
                    "RevokeMessage from %s:%d Can't revoke by ID when ID is zero (%d)",
                    inet_ntoa(pAddr->sin_addr),
                    ntohs(pAddr->sin_port),
                    iRecip );

                return FALSE;
            }
        }
    }

    // SenderID of 0 not allowed if revoking by sender
    if( ( pMsg->dwFlags & XMSG_REVOKE_MESSAGE_EX_FLAG_USE_SENDER ) && 
        0 == pMsg->qwSenderID )
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_121,
            "RevokeMessage from %s:%d Bad sender id (0)",
            inet_ntoa(pAddr->sin_addr),
            ntohs(pAddr->sin_port));

        return FALSE;
    }

    // Can't have a zero context if revoking by context
    if( ( pMsg->dwFlags & XMSG_REVOKE_MESSAGE_EX_FLAG_USE_CONTEXT ) && 
        0 == pMsg->qwSenderContext )
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_122,
            "RevokeMessage from %s:%d Bad sender context (0)",
            inet_ntoa(pAddr->sin_addr),
            ntohs(pAddr->sin_port));

        return FALSE;
    }

    if( pMsg->dwFlags & XMSG_REVOKE_MESSAGE_EX_FLAG_USE_PROP )
    {
        // USE_PROP implies USE_TYPE
        if( 0 == ( pMsg->dwFlags & XMSG_REVOKE_MESSAGE_EX_FLAG_USE_TYPE ) )
        {
            XomNtEvent(
                XEVENT_PRESENCE_CODE_123,
                "RevokeMessage from %s:%d USE_PROP implies USE_TYPE",
                inet_ntoa(pAddr->sin_addr),
                ntohs(pAddr->sin_port));

            return FALSE;
        }

        // We don't support revoking persistent messages by prop at this time
        if( XONLINE_MSG_TYPE_GAME_INVITE != pMsg->bMessageType )
        {
            XomNtEvent(
                XEVENT_PRESENCE_CODE_124,
                "RevokeMessage from %s:%d Can't revoke persistent message by prop, type (0x%02X)",
                inet_ntoa(pAddr->sin_addr),
                ntohs(pAddr->sin_port),
                pMsg->bMessageType );

            return FALSE;
        }

        // Can't have no prop if revoking by prop
        // NOTE: It is okay if cbProp is zero because we may have a NULL prop type which has no data
        if( 0 == pMsg->wPropTag )
        {
            XomNtEvent(
                XEVENT_PRESENCE_CODE_125,
                "RevokeMessage from %s:%d Bad prop tag (0)",
                inet_ntoa(pAddr->sin_addr),
                ntohs(pAddr->sin_port));

            return FALSE;
        }
    }

    // Can't have a zero type if revoking by type
    if( ( pMsg->dwFlags & XMSG_REVOKE_MESSAGE_EX_FLAG_USE_TYPE ) &&
        0 == pMsg->bMessageType )
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_126,
            "RevokeMessage from %s:%d Bad message type (0)",
            inet_ntoa(pAddr->sin_addr),
            ntohs(pAddr->sin_port));

        return FALSE;
    }

    // One of USE_TYPE or USE_ID must be specified, otherwise we can't know whether the message
    // is persistent or transient.
    if( 0 == ( pMsg->dwFlags & XMSG_REVOKE_MESSAGE_EX_FLAG_USE_ID ) &&
        0 == ( pMsg->dwFlags & XMSG_REVOKE_MESSAGE_EX_FLAG_USE_TYPE ) )
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_127,
            "RevokeMessage from %s:%d One of USE_TYPE or USE_ID must be set (0x%08X)",
            inet_ntoa(pAddr->sin_addr),
            ntohs(pAddr->sin_port),
            pMsg->dwFlags);

        return FALSE;
    }

    if( pMsg->dwFlags & XMSG_REVOKE_MESSAGE_EX_FLAGS_RESERVED )
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_128,
            "RevokeMessage from %s:%d Using reserved flags (0x%08X)",
            inet_ntoa(pAddr->sin_addr),
            ntohs(pAddr->sin_port),
            pMsg->dwFlags);

        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\inh\msgutil.h ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#pragma once


const BYTE* GetMessageProperty( WORD wPropTag, const XMSG_DETAILS* pDetails );

BOOL ValidateSendMessage( Q_SEND_MESSAGE_MSG *pMsg, DWORD cbEntireMsg, const sockaddr_in* pAddr );
BOOL ValidateRevokeMessage( const Q_REVOKE_MESSAGE_EX_MSG *pMsg, DWORD cbEntireMsg, const sockaddr_in* pAddr );

BOOL IsValidDetails( const XMSG_DETAILS* pDetails, WORD cbDetails );
BOOL IsValidMessageType( BYTE bMessageType, WORD* pwExpiration );
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\inh\dheap.h ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#ifndef _DHEAP_H_
#define _DHEAP_H_

#include "darray.h"

template <class T>
class CDHeapNoNotify
{
public:
    void operator()(T v, int nNewPos)
    {
        // Do nothing
    }
};

template <
    class T,
    class COMPARE,
    int CELLSIZE, 
    int MAXCELLS, 
    int MAXEMPTYCELLS,
    class NOTIFYONNEWPOSITION=CDHeapNoNotify>
class CDHeap
{
public:
    
    CDHeap()
    {
        m_Array.InsertBogus();
    }

    HRESULT Insert(
        T node
    )
    {
        HRESULT hr = m_Array.InsertAtTheEnd(node);

        if(SUCCEEDED(hr))
        {
            UpHeap(GetCount());
        }

        return hr;
    }

    T Remove(
        DWORD dwIndex
    )
    {
        dwIndex++;

        XOMASSERT(dwIndex <= GetCount());
    
        T ret = m_Array.Get(dwIndex);

        m_Array.Set(dwIndex, m_Array.Get(GetCount()));
        
        NOTIFYONNEWPOSITION()(m_Array.Get(dwIndex), dwIndex-1);

        m_Array.RemoveFromTheEnd();

        if(GetCount() > 0 && dwIndex < GetCount())
            DownHeap(dwIndex);

        return ret;
    }

    T Peek(
        DWORD dwIndex
    )
    {
        return m_Array.Get(dwIndex+1);
    }

    DWORD GetCount()
    {
        return m_Array.GetCount() - 1;
    }

    void Dump()
    {
        int iCount = GetCount();

        for(int i=1; i <= iCount; i++)
        {
            printf("%d(%d) ", m_Array.Get(i).v, m_Array.Get(i).pos);
        }
        printf("\n");
    }

protected:

    void UpHeap(
        DWORD dwIndex
    )
    {
        T v = m_Array.Get(dwIndex);

        while(dwIndex > 1 && COMPARE()(m_Array.Get(dwIndex / 2), v) < 0)
        {
            m_Array.Set(dwIndex, m_Array.Get(dwIndex / 2));
    
            NOTIFYONNEWPOSITION()(m_Array.Get(dwIndex), dwIndex-1);

            dwIndex /= 2;
        }

        m_Array.Set(dwIndex, v);

        NOTIFYONNEWPOSITION()(m_Array.Get(dwIndex), dwIndex-1);
    }

    void DownHeap(
        DWORD dwIndex
    )
    {
        T v = m_Array.Get(dwIndex);
    
        DWORD dwSize = GetCount();

        while(dwIndex <= dwSize / 2)
        {
            DWORD j = dwIndex * 2;

            if(j < dwSize && COMPARE()(m_Array.Get(j),m_Array.Get(j+1)) < 0)
            {
                j++;
            }

            if(COMPARE()(v, m_Array.Get(j)) >= 0)
            {
                break;
            }

            m_Array.Set(dwIndex, m_Array.Get(j));

            NOTIFYONNEWPOSITION()(m_Array.Get(dwIndex), dwIndex-1);

            dwIndex = j;
        }

        m_Array.Set(dwIndex, v);

        NOTIFYONNEWPOSITION()(m_Array.Get(dwIndex), dwIndex-1);
    }
    
    typedef CDArray <T, CELLSIZE, MAXCELLS, MAXEMPTYCELLS> ARRAY;

    ARRAY m_Array;
};

#endif // #ifndef _DHEAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\inh\pconn.h ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#ifndef PCONN_H_INCLUDED
#define PCONN_H_INCLUDED

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

struct RecipientFriendInfo
{
    QWORD qwUserID;
    Q_SEND_MESSAGE_ADDENDUM addendum;
};

class CPresConnectionCallback;
class CSendMessageContext;
class CSendMessageInternalContext;
class CSendMessageExternalContext;
class SendMessageReplyHandler;
class CPresenceInfoContext;
class CPConnReceiveContext;

typedef CTCPCntMessageBased<CTCPCntMessageBasedPlugin_PN> CPresBaseConnection;



/*****************************************************************************

CPresConnection

Contains one presence server  peer connection.  Does reply parsing, simple 
processing and validation of replies before calling into the implemention of 
the logic behind the reply.

*****************************************************************************/
class CPresConnection : public CPresBaseConnection
{
public:
    CPresConnection(DWORD dwIndex);
    virtual ~CPresConnection();

    HRESULT InitAccept(
        CServerSocket *pSocket,
        CPresConnectionCallback *pCallback,
        CSwitchboard *pCSwitchboard);

    HRESULT InitConnect(
        sockaddr_in *pAddr,
        CCompletionPort *pCompPort,
        CPresConnectionCallback *pCallback,
        CSwitchboard *pCSwitchboard);

    HRESULT SendInternal(CTCPCntBuffer *pBuffer)
    {
        g_Counters.IncrementValue32(XPPERF_SERVER_PCONN_MSGS_SEND_COUNT, 1);
        g_Counters.IncrementValue32(XPPERF_SERVER_PCONN_MSGS_SEND_RATE, 1);
        g_Counters.IncrementValue32(XPPERF_SERVER_PCONN_BYTES_SEND_COUNT, pBuffer->GetBufferLength());
        g_Counters.IncrementValue32(XPPERF_SERVER_PCONN_BYTES_SEND_RATE, pBuffer->GetBufferLength());       

        // call base class method.
        HRESULT hr = CPresBaseConnection::Send(pBuffer);

        // check to see if the output buffers are full.
        if (hr == HRESULT_FROM_WIN32(WSAENOBUFS))
        {
            char *szOut = NULL;

            if (pBuffer->GetBufferLength() < 0x7FFFFFFF / 3)
            {                
                szOut = new char[3 * pBuffer->GetBufferLength() + 1];
            }
            if (szOut != NULL)
            {
                BYTE *pBuf = pBuffer->GetBuffer();
                DWORD i;
                for (i = 0; i < pBuffer->GetBufferLength(); i++)
                {
                    BYTE high = pBuf[i] / 16;
                    BYTE low = pBuf[i] % 16;
                    
                    szOut[3 * i] = (high > 9) ? high - 10 + 'A' : high + '0';
                    szOut[3 * i + 1] = (low > 9) ? low - 10 + 'A' : low + '0';
                    szOut[3 * i + 2] = ' ';
                }

                szOut[3 * i] = '\0';
            }

            sockaddr_in *saLocal = g_CPresCfg.GetPresServerAddr(m_dwPresServerIndex);
            sockaddr_in *saPeer = g_CPresCfg.GetPresServerPeerAddr(m_dwPresServerIndex);
            
            XomNtEvent(XEVENT_PRESENCE_COMM_43,
                "CPresConnection::Send() outbound buffer list full.  sending from %s to %s.  buffer = %s",
                (saLocal == NULL) ? "*INVALID LOCAL INDEX*" : inet_ntoa(saLocal->sin_addr),
                (saPeer == NULL) ? "*INVALID PEER INDEX*" : inet_ntoa(saPeer->sin_addr),
                (szOut == NULL) ? "could not allocate" : szOut);

            delete[] szOut;
            
            hr = XONLINE_E_NOTIFICATION_SEND_FAILED;
        }

        return hr;
    }

    virtual HRESULT Send(CTCPCntBuffer* pBuffer )
    {
        // local shortcut
        if (m_dwPresServerIndex == g_CPresCfg.GetMyPresServerIndex())
        {
            // ProcessMessage() will wrap the buffer in an incoming CPConnReceiveContext object.  This object will be posted
            // to switchboard exactly as if it had come in over the wire.
            ProcessMessage(pBuffer->GetBuffer(), pBuffer->GetBufferLength());
            return S_OK;
        }

        if (pBuffer->GetBufferLength() > CTCPCnt_RECEIVE_BUFFER_LENGTH)
        {
            // message is too big for the receiving PConn to handle.  we need to break it up.
            DWORD dwBytesLeft = pBuffer->GetBufferLength();
            DWORD dwStart = 0;
            HRESULT hr = S_OK;
            
            CTCPCntVarBuffer *pTempBuffer = g_pBufferPool->GetBuffer(CTCPCnt_RECEIVE_BUFFER_LENGTH);
            if (pTempBuffer == NULL)
            {
                return E_OUTOFMEMORY;
            }

            // send the first chunk.
            memcpy(pTempBuffer->GetBuffer(), pBuffer->GetBuffer(), CTCPCnt_RECEIVE_BUFFER_LENGTH);
            hr = SendInternal(pTempBuffer);
            SAFE_RELEASE(pTempBuffer);
            if (FAILED(hr))
            {
                return hr;
            }

            dwBytesLeft -= CTCPCnt_RECEIVE_BUFFER_LENGTH;
            dwStart += CTCPCnt_RECEIVE_BUFFER_LENGTH;

            // send the rest of the chunks.
            while (dwBytesLeft > 0)
            {
                pTempBuffer = g_pBufferPool->GetBuffer(CTCPCnt_RECEIVE_BUFFER_LENGTH);
                if (pTempBuffer == NULL)
                {
                    return E_OUTOFMEMORY;
                }

                // prepend a continuation header on to each additional chunk.
                BASE_MSG_HEADER *pHeader = (BASE_MSG_HEADER *)pTempBuffer->GetBuffer();
                pHeader->dwMsgLen = min(dwBytesLeft, CTCPCnt_RECEIVE_BUFFER_LENGTH - sizeof(BASE_MSG_HEADER));
                pHeader->dwMsgType = PMSG_CONTINUATION;
                pHeader->dwSeqNum = ((BASE_MSG_HEADER *)pBuffer->GetBuffer())->dwSeqNum;
                memcpy(&(pHeader->sgaddr), &(((BASE_MSG_HEADER *)pBuffer->GetBuffer())->sgaddr), sizeof(SGADDR));
                memcpy(pHeader + 1, pBuffer->GetBuffer() + dwStart, pHeader->dwMsgLen);

                pTempBuffer->Resize(pHeader->dwMsgLen + sizeof(BASE_MSG_HEADER));

                dwBytesLeft -= pHeader->dwMsgLen;
                dwStart += pHeader->dwMsgLen;                

                hr = SendInternal(pTempBuffer);
                SAFE_RELEASE(pTempBuffer);
                if (FAILED(hr))
                {
                    return hr;
                }
            }

            return hr;
        }
        else
        {
            // just send it.
            return SendInternal(pBuffer);
        }

    }

    
    HRESULT SendMsgHello();

    HRESULT SendPreMigrationMessage(QWORD qwUserID);
    HRESULT SendFullMigrationMessage(CPresence *pCPresence);

    HRESULT SendMsgAnnounce(
        QWORD qwDestUserID, 
        DWORD dwTitleID,
        LPCSTR pszGamerTag,
        DWORD cSourceUserIDs, 
        const QWORD *rgqwSourceUserIDs);

    HRESULT SendMsgSubscribed(
        QWORD qwDestUserID, 
        DWORD cSourceUserIDs, 
        const QWORD *rgqwSourceUserIDs);

    HRESULT SendMsgUnsubscribe(
        QWORD qwSourceUserID, 
        DWORD cDestUserIDs, 
        const QWORD *rgqwDestUserIDs);

    HRESULT SendMsgAdded(
        QWORD qwUserID,
        QWORD qwBuddyID,
        DWORD dwVersion,
        WORD cbBuddyAcctName,
        LPCSTR szBuddyAcctName);

    HRESULT SendMsgAccepted(
        QWORD qwUserID,
        QWORD qwBuddyID,
        DWORD dwVersion,
        WORD cbBuddyAcctName,
        LPCSTR szBuddyAcctName);

    HRESULT SendMsgRemoved(
        QWORD qwUserID,
        QWORD qwBuddyID,
        DWORD dwVersion);

    HRESULT SendMsgInviteAnswer(
        QWORD qwUserID,
        QWORD qwHostID,
        QWORD qwMatchSessionID,
        WORD wAnswer);

    HRESULT SendAddAffiliates(
        QWORD qwDestUserID,
        DWORD dwTitleID,
        DWORD dwListFlags,
        WORD cwAffiliates,
        QWORD *pqwAffiliates);

    HRESULT SendGetPresenceInfo(
        DWORD dwContext,
        QWORD qwUserID,
        DWORD cdwPUIDs,
        QWORD *rgPUIDs);

    HRESULT SendMsgWebAnnounce(
        QWORD qwDestUserID, 
        DWORD cSourceUserIDs, 
        const QWORD *rgqwSourceUserIDs);

    HRESULT SendMsgWebSubscribed(
        QWORD qwDestUserID, 
        DWORD cSourceUserIDs, 
        const QWORD *rgqwSourceUserIDs);

    HRESULT SendMsgWebUnsubscribe(
        QWORD qwSourceUserID, 
        DWORD cDestUserIDs, 
        const QWORD *rgqwDestUserIDs);

    HRESULT SendMsgWatchStart(
        QWORD qwDestUserID, 
        DWORD cSourceUserIDs, 
        const QWORD *rgqwSourceUserIDs);

    HRESULT SendMsgWatchStop(
        QWORD qwDestUserID, 
        DWORD cSourceUserIDs, 
        const QWORD *rgqwSourceUserIDs);

    HRESULT QueuePresence(
        CPresence *pCPresence, 
        const QWORD *rgqwBuddyIDs, 
        DWORD cBuddyIDs );

    HRESULT QueuePresenceOffline(
        CPresence *pCPresence,
        DWORD cdwDestUsers,
        QWORD *rgqwDestUserIDs);

    HRESULT QueueListChange(
        QWORD qwUserID,
        DWORD dwVersion,
        QWORD qwTargetID,
        WORD wOperationID,
        HRESULT hrOp,
        WORD cbTargetAcctName,
        LPCSTR szTargetAcctName);

    HRESULT QueueInviteAnswer(
        QWORD qwUserID,
        QWORD qwHostID,
        QWORD qwMatchSessionID,
        FILETIME ftSent,
        WORD wAnswer);

    HRESULT QueueDeleteMessage(
        QWORD qwUserID,
        DWORD dwMessageID,
        BOOL fBlockSender);

    HRESULT SendWebPresence(
        QWORD qwUserID,
        QWORD qwFriendID,
        DWORD dwFriendState,
        DWORD dwFriendTitleID,
        WORD cbTitleStuff,
        BYTE *pbTitleStuff);

    HRESULT QueuePeerPresence(
        CPresence *pCPresence, 
        const QWORD *rgqwUserIDs, 
        DWORD cUserIDs);

    HRESULT QueuePeerPresenceOffline(
        CPresence *pCPresence,
        DWORD cdwDestUsers,
        QWORD *rgqwDestUserIDs);

    HRESULT QueuePresence2(
        CPresence *pCPresence, 
        const QWORD *rgqwUserIDs, 
        DWORD cUserIDs );

    HRESULT QueuePresence2Offline(
        CPresence *pCPresence,
        DWORD cdwDestUsers,
        QWORD *rgqwDestUserIDs);

    HRESULT SendSendMessage(
        const Q_SEND_MESSAGE_MSG* pMessage,
        WORD cRecipients,
        const QWORD* rgqwRecipients,
        const BYTE* pbDetails,
        const Q_SEND_MESSAGE_ADDENDUM* rgAddendum,
        SendMessageReplyHandler* pCCtx );

    HRESULT SendEmptySendReply(DWORD dwContext, HRESULT hr);

    HRESULT SendEmptyReply(DWORD dwMsgType, WORD cbSize, HRESULT hr);

    HRESULT SendRevokeMessage(
        const Q_REVOKE_MESSAGE_EX_MSG* pMessage,
        WORD cRecipients,
        const Q_RECIPIENT_RESULT* pRecipients,
        const BYTE* pbProp );

    void CheckTimeouts();

    HRESULT ChangeServerIndex(DWORD *rgdwIndexMap, DWORD cOldServers);
    HRESULT ReleaseSendMessageContexts();
    HRESULT ClearSendMessageContextVisitedFlags();

    DWORD IncrementSequenceNumber() { return ++m_dwSeqNum; }

    void CPresConnection::ProcessPConnMessage(BYTE *pMsg, DWORD cbEntireMsg);
    
protected:
    virtual void OnConnect();
    virtual void OnDisconnect(HRESULT hrReason );
    
    virtual void ProcessMessage(BYTE *pMsg, DWORD cbEntireMsg);
    HRESULT DeferMessage(QWORD qwUserID, BASE_MSG_HEADER *pMsg, DWORD cbEntireMsg);

    // Message handler methods
    typedef void (CPresConnection::*MsgHandler)( BASE_MSG_HEADER *pMsgHeader, DWORD cbEntireMsg );

    void ProcessMsgHello(P_HELLO_MSG *pMsg, DWORD cbEntireMsg);

    void ProcessMsgNotSupported(BASE_MSG_HEADER *pMsg, DWORD cbEntireMsg);

    void ProcessMsgAnnounce(P_ANNOUNCE_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgSubscribed(P_SUBSCRIBED_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgUnsubscribe(P_UNSUBSCRIBE_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgAdded(P_ADDED_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgAccepted(P_ACCEPTED_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgRemoved(P_REMOVED_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgInviteAnswerPeer(P_INVITE_ANSWER_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgAddAffiliates(P_ADD_AFFILIATES_MSG * pMsg, DWORD cbEntireMsg);
    void ProcessMsgGetPresenceInfo(P_GET_PRESENCE_INFO_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgPresenceInfoReply(P_GET_PRESENCE_INFO_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgWebAnnounce(P_WEB_ANNOUNCE_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgWebSubscribed(P_WEB_SUBSCRIBED_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgWebUnsubscribe(P_WEB_UNSUBSCRIBE_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgWatchStart(P_WATCH_START_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgWatchStop(P_WATCH_STOP_MSG *pMsg, DWORD cbEntireMsg);

    void ProcessMsgQAdd(Q_ADD_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgWebUserInfo(Q_WEB_USER_INFO_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgWebPresence(Q_WEB_PRESENCE_MSG *pMsg, DWORD cbEntireMsg);
    void ProcessMsgSendMessage( Q_SEND_MESSAGE_MSG* pMsg, DWORD cbEntireMsg );
    void ProcessMsgDeleteMessage( Q_DELETE_MESSAGE_MSG* pMsg, DWORD cbEntireMsg );
    void ProcessMsgRevokeMessage( Q_REVOKE_MESSAGE_EX_MSG* pMsg, DWORD cbEntireMsg );

    void ProcessMsgUserPreMigration(P_USER_PRE_MIGRATION_MSG *pMsg, DWORD cbEntireMsg );
    void ProcessMsgUserFullMigration(P_USER_FULL_MIGRATION_MSG *pMsg, DWORD cbEntireMsg );

    void ProcessMsgAck( BASE_ACK_MSG *pMsg, DWORD cbEntireMsg );
    void ProcessMsgSendReply( Q_SEND_MESSAGE_INTERNAL_REPLY_MSG *pMsg, DWORD cbEntireMsg ); 

    BOOL m_fSeenHello;
    DWORD m_dwPresServerIndex;
    DWORD m_dwSeqNum;     // Sending
    DWORD m_dwLastSeqNum; // Receiving
    CSwitchboard *m_pCSwitchboard;
    CPresConnectionCallback *m_pCallback;
    sockaddr_in m_sa;
    char m_pszDesc[MAX_HELLO_DESCRIPTION_LEN + 1];

    CPConnReceiveContext *m_pCCtx;

    SendMessageReplyHandler *m_pCSendMessageListHead;
    SendMessageReplyHandler *m_pCSendMessageListTail;
};

/*****************************************************************************

CPresConnectionCallback

Callback interface for presence server peer connections.

*****************************************************************************/
class CPresConnectionCallback
{
public:
    virtual void OnConnect(CPresConnection *pCConn) = 0;
    virtual void OnDisconnect(CPresConnection *pCConn) = 0;
};

/*****************************************************************************

CXPCluster

Contains all presence server peer connections.  Builds messages and dispatches 
them to the appropriate presence server(s).

*****************************************************************************/
class CXPCluster : 
    public CPresConnectionCallback,
    public CServerSocketCallback
{
public:
    CXPCluster();

    ~CXPCluster();

    IMPLEMENT_REFCOUNT;

    HRESULT Init(CSwitchboard *pCSwitchboard);
    void Shutdown();

    void PeriodicHeartbeat();

    HRESULT SendPreMigrationMessage(QWORD qwUserID);
    HRESULT SendFullMigrationMessage(CPresence *pCPresence);

    HRESULT SendMsgAnnounce(
        QWORD qwDestUserID, 
        DWORD dwTitleID,
        LPCSTR pszGamerTag,
        DWORD cSourceUserIDs, 
        const QWORD *rgqwSourceUserIDs,
        BOOL fUseAltServer = FALSE);

    HRESULT SendMsgSubscribed(
        QWORD qwDestUserID, 
        DWORD cSourceUserIDs, 
        const QWORD *rgqwSourceUserIDs);

    HRESULT SendMsgUnsubscribe(
        QWORD qwSourceUserID, 
        DWORD cDestUserIDs, 
        const QWORD *rgqwDestUserIDsIn,
        BOOL fUseAltServer = FALSE);

    HRESULT SendMsgAdded(
        QWORD qwUserID,
        QWORD qwBuddyID,
        DWORD dwVersion,
        WORD cbBuddyAcctName,
        LPCSTR szBuddyAcctName);

    HRESULT SendMsgAccepted(
        QWORD qwUserID,
        QWORD qwBuddyID,
        DWORD dwVersion,
        WORD cbBuddyAcctName,
        LPCSTR szBuddyAcctName);

    HRESULT SendMsgRemoved(
        QWORD qwUserID,
        QWORD qwBuddyID,
        DWORD dwVersion);

    HRESULT SendMsgInviteAnswer(
        QWORD qwUserID,
        QWORD qwHostID,
        QWORD qwMatchSessionID,
        WORD wAnswer);

    HRESULT SendAddAffiliates(
        WORD cwAffiliates,
        QWORD *pqwAffiliates,
        DWORD dwTitleID,
        DWORD dwListFlag,
        QWORD qwUserID);

    HRESULT SendGetPresenceInfo(CPresenceInfoContext *pCCtx, BOOL fUseAltServer = FALSE);

    HRESULT SendMsgWebAnnounce(
        QWORD qwDestUserID, 
        DWORD cSourceUserIDs, 
        const QWORD *rgqwSourceUserIDs);

    HRESULT SendMsgWebSubscribed(
        QWORD qwDestUserID, 
        DWORD cSourceUserIDs, 
        const QWORD *rgqwSourceUserIDs);

    HRESULT SendMsgWebUnsubscribe(
        QWORD qwSourceUserID, 
        DWORD cDestUserIDs, 
        const QWORD *rgqwDestUserIDs);

    HRESULT SendMsgWatchStart(
        QWORD qwDestUserID, 
        DWORD cSourceUserIDs, 
        const QWORD *rgqwSourceUserIDsIn,
        BOOL fUseAltServer = FALSE);

    HRESULT SendMsgWatchStop(
        QWORD qwDestUserID, 
        DWORD cSourceUserIDs, 
        const QWORD *rgqwSourceUserIDsIn,
        BOOL fUseAltServer = FALSE);

    HRESULT QueuePresence(
        CPresence *pCPresence, 
        const QWORD *rgqwBuddyIDsIn, 
        DWORD cBuddyIDs);

    HRESULT QueuePresenceOffline(
        CPresence *pCPresence,
        DWORD cdwDestUsers,
        QWORD* rgqwDestUserIDs);

    HRESULT QueueListChange(
        QWORD qwUserID,
        DWORD dwVersion,
        QWORD qwTargetID,
        WORD wOperationID,
        HRESULT hrOp,
        WORD cbTargetAcctName,
        LPCSTR szTargetAcctName);

    HRESULT QueueInviteAnswer(
        QWORD qwUserID,
        QWORD qwHostID,
        QWORD qwMatchSessionID,
        FILETIME ftSent,
        WORD wAnswer);

    HRESULT QueueDeleteMessage(
        QWORD qwUserID,
        DWORD dwMessageID,
        BOOL fBlockSender);

    HRESULT SendDeadUser(
        SGADDR *psgaddr,
        QWORD qwUserID);

    HRESULT QueueWebPresence(
        CPresence *pCPresence, 
        const QWORD *rgqwBuddyIDsIn, 
        DWORD cBuddyIDs);

    HRESULT SendWebPresence(
        QWORD qwUserID,
        QWORD qwFriendID,
        DWORD dwFriendState,
        DWORD dwFriendTitleID,
        WORD cbTitleStuff,
        BYTE *pbTitleStuff);

    HRESULT QueuePeerPresence(
        CPresence *pCPresence, 
        const QWORD *rgqwUserIDsIn, 
        DWORD cMemberIDs,
        BOOL fSendToXbox = TRUE,
        BOOL fSendToXenon = TRUE);

    HRESULT QueuePeerPresenceOffline(
        CPresence *pCPresence,
        DWORD cdwDestUsers,
        QWORD* rgqwDestUserIDs,
        BOOL fSendToXbox = TRUE,
        BOOL fSendToXenon = TRUE);

    HRESULT SendSendMessage(
        const Q_SEND_MESSAGE_MSG* pMessage,
        const QWORD* rgqwRecipients,
        const BYTE* pbDetails,
        const Q_SEND_MESSAGE_ADDENDUM* rgAddendum,
        SendMessageReplyHandler* pCCtx,
        BOOL fUseAltServer = FALSE);

    HRESULT SendRevokeMessage(
        const Q_REVOKE_MESSAGE_EX_MSG* pMessage,
        const Q_RECIPIENT_RESULT* pRecipients,
        const BYTE* pbProp,
        BOOL fUseAltServer = FALSE);

    // CServerSocketCallback methods
    virtual void OnSocketAccept(
        CServerSocket *pListenSocket,
        CServerSocket *pAcceptedSocket,
        sockaddr_in *pLocalAddr,
        sockaddr_in *pRemoteAddr,
        HRESULT hr,
        QWORD qwCallbackArg );
    
    // CPresConnectionCallback methods
    virtual void OnConnect(CPresConnection *pCConn);

    virtual void OnDisconnect(CPresConnection *pCConn);
    void OnDisconnectInternal(CPresConnection *pCConn);

    HRESULT Status(DWORD dwRequestId, CXomControlResponseInterface* pResponseInterface);
    HRESULT ResetConnection(DWORD dwIndex);

    HRESULT ChangeServerList(DWORD *rgdwIndexMap, DWORD cOldServers);

    HRESULT ForwardMessage(CTCPCntBuffer *pBuffer, QWORD qwUserID)
    {
        DWORD dwAltServer = g_CPresCfg.MapUserToPresSrv(qwUserID, TRUE);
        if (dwAltServer == g_CPresCfg.GetMyPresServerIndex())
        {
            return E_UNEXPECTED;
        }

        if (m_rgCPConnInfo[dwAltServer].pCPresConn == NULL)
        {
            return XONLINE_E_NOTIFICATION_SEND_FAILED;
        }
        
        m_rgCPConnInfo[dwAltServer].pCPresConn->Send(pBuffer);

        return S_OK;
    }

protected:

    HRESULT AttemptConnections();

    void SortUsersByDestination(DWORD cUsers, QWORD *rgqwUsersSrc, BOOL fAlt);

    // Persistant per-connection information
    struct CPConnInfo
    {
        ~CPConnInfo()
        {
            SAFE_RELEASE(pCPresConn);
        }
        
        CPresConnection *pCPresConn;
        BOOL fInit;
        BOOL fConnected;
    };

    CCompletionPort *m_pCCompPort;
    CServerSocket *m_pCListenSocket;
    CPConnInfo *m_rgCPConnInfo;
    CSwitchboard *m_pCSwitchboard;
    DWORD m_dwLastConnAttempt;
};

#endif  // PCONN_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\inh\perfctrs.cpp ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#include "stdafx.h"

//////////////////////////////////////////////////////////////////////////////

CXPPerfCounters g_Counters;

//////////////////////////////////////////////////////////////////////////////
enum XPPC_TYPES
{
    XPPC_DWORD = 1,
    XPPC_QWORD = 2
};

struct PERFCOUNTER
{
    XPPC_TYPES ctrType;
    DWORD dwPerfType;
    DWORD dwDataSize;
    DWORD dwPerfIndex;
    LONG lDataScale;
    BYTE *pbPerfCtrData;
};

#define DWORD_AVERAGE( INDEX ) \
{ XPPC_DWORD, PERF_AVERAGE_TIMER, sizeof(DWORD), INDEX, 0, NULL }

#define DWORD_BASE( INDEX ) \
{ XPPC_DWORD, PERF_AVERAGE_BASE, sizeof(DWORD), INDEX, 0, NULL }

#define DWORD_COUNTER( INDEX ) \
{ XPPC_DWORD, PERF_COUNTER_RAWCOUNT, sizeof(DWORD), INDEX, 0, NULL }

#define DWORD_RATE( INDEX ) \
{ XPPC_DWORD, PERF_COUNTER_COUNTER, sizeof(DWORD), INDEX, 0, NULL }

#define QWORD_AVERAGE( INDEX ) \
{ XPPC_QWORD, PERF_AVERAGE_BULK, sizeof(QWORD), INDEX, 0, NULL }

#define QWORD_COUNTER( INDEX ) \
{ XPPC_QWORD, PERF_COUNTER_LARGE_RAWCOUNT, sizeof(QWORD), INDEX, 0, NULL }

#define QWORD_RATE( INDEX ) \
{ XPPC_QWORD, PERF_COUNTER_BULK_COUNT, sizeof(QWORD), INDEX, 0,  NULL }

//////////////////////////////////////////////////////////////////////////////
PERFCOUNTER s_ServerPerfCtrs [] =
{
#include "presperf.cpp"
};

#define NUM_SERVER_PERF_COUNTERS (ARRAY_ELEMENTS(s_ServerPerfCtrs))

//////////////////////////////////////////////////////////////////////////////
CXPPerfCounters::CXPPerfCounters() :
m_hServerPerfObj( NULL )
{
}

//////////////////////////////////////////////////////////////////////////////
CXPPerfCounters::~CXPPerfCounters()
{
}

//////////////////////////////////////////////////////////////////////////////
HRESULT CXPPerfCounters::Init()
{
    BYTE *pbServCtrsStart = NULL;
    
    XOMASSERT( NULL == m_hServerPerfObj );
    
    // Create the server perf object and associated counters
    m_hServerPerfObj = CreatePerfObject(
        XPPERF_SERVER_OBJECT,
        0,
        (void **) &pbServCtrsStart );
    
    if( NULL == m_hServerPerfObj )
    {
        XomNtEvent(XEVENT_PRESENCE_CONFIG_26, "Error creating perf counter object.  Attempting to delete stale perf objects to recover.");
        
        DestroyAllPerfObjects();
        
        // try again.
        m_hServerPerfObj = CreatePerfObject(
            XPPERF_SERVER_OBJECT,
            0,
            (void **) &pbServCtrsStart );

        if (NULL == m_hServerPerfObj)
        {
            // give up.
            return E_UNEXPECTED;
        }
    }
    
    for( DWORD dwCtr = 0; dwCtr < NUM_SERVER_PERF_COUNTERS; dwCtr++ )
    {
        DWORD dwCounterDataOffset = CreatePerfCounter(
            s_ServerPerfCtrs[ dwCtr ].dwPerfType,
            s_ServerPerfCtrs[ dwCtr ].lDataScale,
            s_ServerPerfCtrs[ dwCtr ].dwDataSize,
            m_hServerPerfObj,
            s_ServerPerfCtrs[ dwCtr ].dwPerfIndex,
            NULL );
        
        XOMASSERT( 0xffffffff != dwCounterDataOffset );
        
        s_ServerPerfCtrs[ dwCtr ].pbPerfCtrData = pbServCtrsStart + dwCounterDataOffset;
        
        // Zero every counter on startup
        ZeroMemory(
            s_ServerPerfCtrs[ dwCtr ].pbPerfCtrData,
            s_ServerPerfCtrs[ dwCtr ].dwDataSize );
    }    
    
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
DWORD CXPPerfCounters::GetCurrentValue32(DWORD dwCounterID)
{
    
    DWORD dwCounterIndex = ( ( dwCounterID - XPPERF_SERVER_OBJECT ) / 2 ) - 1;
    
    XOMASSERT( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    XOMASSERT( XPPC_DWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );
    
    return( *(DWORD *) s_ServerPerfCtrs[ dwCounterIndex ].pbPerfCtrData );
}

//////////////////////////////////////////////////////////////////////////////
void CXPPerfCounters::SetCurrentValue32(DWORD dwCounterID, DWORD dwVal)
{
    DWORD dwCounterIndex = ( ( dwCounterID - XPPERF_SERVER_OBJECT ) / 2 ) - 1;
    
    XOMASSERT( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    XOMASSERT( XPPC_DWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );

    // No need for thread safety
    //InterlockedExchange(
    //    (LONG *) s_ServerPerfCtrs[ dwCounterIndex ].pbPerfCtrData,
    //    (LONG) dwVal );

    *(DWORD *) s_ServerPerfCtrs[ dwCounterIndex ].pbPerfCtrData = dwVal;
}

//////////////////////////////////////////////////////////////////////////////
void CXPPerfCounters::IncrementValue32(DWORD dwCounterID, DWORD dwAmount)
{
    DWORD dwCounterIndex = ( ( dwCounterID - XPPERF_SERVER_OBJECT ) / 2 ) - 1;
    
    XOMASSERT( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    XOMASSERT( XPPC_DWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );
    
    // No need for thread safety
    //InterlockedExchangeAdd(
    //    (LONG *) s_ServerPerfCtrs[ dwCounterIndex ].pbPerfCtrData,
    //    (LONG) dwAmount );

    *(DWORD *) s_ServerPerfCtrs[ dwCounterIndex ].pbPerfCtrData += dwAmount;
}

//////////////////////////////////////////////////////////////////////////////
void CXPPerfCounters::DecrementValue32(DWORD dwCounterID, DWORD dwAmount)
{

    DWORD dwCounterIndex = ( ( dwCounterID - XPPERF_SERVER_OBJECT ) / 2 ) - 1;
    
    XOMASSERT( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    XOMASSERT( XPPC_DWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );
    
    // No need for thread safety
    //InterlockedExchangeAdd(
    //    (LONG *) s_ServerPerfCtrs[ dwCounterIndex ].pbPerfCtrData,
    //    - (LONG) dwAmount );
    *(DWORD *) s_ServerPerfCtrs[ dwCounterIndex ].pbPerfCtrData -= dwAmount;
}

//////////////////////////////////////////////////////////////////////////////
void CXPPerfCounters::SafeIncrement32(DWORD dwCounterID)
{
    DWORD dwCounterIndex = ( ( dwCounterID - XPPERF_SERVER_OBJECT ) / 2 ) - 1;
    
    XOMASSERT( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    XOMASSERT( XPPC_DWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );
    
    InterlockedIncrement((LONG *) s_ServerPerfCtrs[ dwCounterIndex ].pbPerfCtrData);
}

//////////////////////////////////////////////////////////////////////////////
void CXPPerfCounters::SafeDecrement32(DWORD dwCounterID)
{
    DWORD dwCounterIndex = ( ( dwCounterID - XPPERF_SERVER_OBJECT ) / 2 ) - 1;
    
    XOMASSERT( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    XOMASSERT( XPPC_DWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );
    
    InterlockedDecrement((LONG *) s_ServerPerfCtrs[ dwCounterIndex ].pbPerfCtrData);
}

//////////////////////////////////////////////////////////////////////////////
void CXPPerfCounters::TrackSuccessfulMessage(DWORD dwServerCounterID)
{
    // Increment the specific counter
    IncrementValue32(dwServerCounterID, 1);
    
    // Assume a rate counter after the count counter
    IncrementValue32(dwServerCounterID + 2, 1);

    // Increment the total counter
    IncrementValue32(XPPERF_SERVER_TOTAL_MSGS_COUNTER, 1);
    
    IncrementValue32(XPPERF_SERVER_TOTAL_MSGS_RATE, 1);
}

//////////////////////////////////////////////////////////////////////////////
void CXPPerfCounters::TrackFailureMessage(DWORD dwServerCounterID)
{
    // Increment the total failure counter
    IncrementValue32( XPPERF_SERVER_FAILED_MSGS_COUNTER, 1 );
    
    IncrementValue32( XPPERF_SERVER_FAILED_MSGS_RATE, 1 );   
}

//////////////////////////////////////////////////////////////////////////////
QWORD CXPPerfCounters::GetCurrentValue64(DWORD dwCounterID)
{
    DWORD dwCounterIndex = ( ( dwCounterID - XPPERF_SERVER_OBJECT ) / 2 ) - 1;
    
    XOMASSERT( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    XOMASSERT( XPPC_QWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );
    
    return( *(QWORD *) s_ServerPerfCtrs[ dwCounterIndex ].pbPerfCtrData );
}

//////////////////////////////////////////////////////////////////////////////
void CXPPerfCounters::SetCurrentValue64(DWORD dwCounterID, QWORD qwVal )
{

    DWORD dwCounterIndex = ( ( dwCounterID - XPPERF_SERVER_OBJECT ) / 2 ) - 1;
    
    XOMASSERT( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    XOMASSERT( XPPC_QWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );
    
    *(QWORD *) s_ServerPerfCtrs[ dwCounterIndex ].pbPerfCtrData = qwVal;
}

//////////////////////////////////////////////////////////////////////////////
void CXPPerfCounters::IncrementValue64(DWORD dwCounterID, QWORD qwAmount)
{
    DWORD dwCounterIndex = ( ( dwCounterID - XPPERF_SERVER_OBJECT ) / 2 ) - 1;
    
    XOMASSERT( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    XOMASSERT( XPPC_QWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );
    
    *(QWORD *) s_ServerPerfCtrs[ dwCounterIndex ].pbPerfCtrData += qwAmount;
}

//////////////////////////////////////////////////////////////////////////////
void CXPPerfCounters::DecrementValue64(DWORD dwCounterID, QWORD qwAmount)
{
    DWORD dwCounterIndex = ( ( dwCounterID - XPPERF_SERVER_OBJECT ) / 2 ) - 1;
    
    XOMASSERT( dwCounterIndex < NUM_SERVER_PERF_COUNTERS );
    XOMASSERT( XPPC_QWORD == s_ServerPerfCtrs[ dwCounterIndex ].ctrType );
    
    *(QWORD *) s_ServerPerfCtrs[ dwCounterIndex ].pbPerfCtrData -= qwAmount;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\inh\perfctrs.h ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#ifndef PERFCTRS_H_INCLUDED
#define PERFCTRS_H_INCLUDED

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//////////////////////////////////////////////////////////////////////////////
class CXPPerfCounters
{
public:
    CXPPerfCounters();
    ~CXPPerfCounters();

    HRESULT Init();

    //
    // DWORD counter manipulation routines
    //
    DWORD GetCurrentValue32(DWORD dwCounterID);

    void SetCurrentValue32(DWORD dwCounterID, DWORD dwVal);

    void IncrementValue32(DWORD dwCounterID, DWORD dwAmount);

    void DecrementValue32(DWORD dwCounterID, DWORD dwAmount);

    void SafeIncrement32(DWORD dwCounterID);

    void SafeDecrement32(DWORD dwCounterID);

    void TrackSuccessfulMessage(DWORD dwServerCounterID);

    void TrackFailureMessage(DWORD dwServerCounterID);

    //
    // QWORD counter manipulation routines
    //
    QWORD GetCurrentValue64(DWORD dwCounterID);

    void SetCurrentValue64(DWORD dwCounterID, QWORD qwVal);

    void IncrementValue64(DWORD dwCounterID, QWORD qwAmount);

    void DecrementValue64(DWORD dwCounterID, QWORD qwAmount);

private:
    HANDLE m_hServerPerfObj;
};

extern CXPPerfCounters g_Counters;


#endif  // PERFCTRS_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\inh\presconfig.cpp ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#include "stdafx.h"

CPresenceConfig g_CPresCfg;

/*****************************************************************************

CPresenceConfig::Init

Initialize the config object

*****************************************************************************/
HRESULT CPresenceConfig::Init()
{
    HRESULT hr = S_OK;

    hr = m_pConfig.CoCreateInstance(__uuidof(ConfigInterop));
    if (FAILED(hr))
    {
        XomNtEvent( XEVENT_PRESENCE_CONFIG_27, "CPresenceConfig::Init() - Failed to CoCreate ConfigInterop object, hr=0x%08X", hr );
        goto lDone;
    }

    //  Setup notification handler
    m_pConfigListener = new CPresConfigListener();
    if (m_pConfigListener != NULL)
    {
        hr = m_pConfig->putref_ConfigListener(m_pConfigListener);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    if (FAILED(hr))
    {
        XomNtEvent( XEVENT_PRESENCE_CONFIG_28, "CPresenceConfig::Init() - Failed to register Config Listener object, hr=0x%08X", hr );
        goto lDone;
    }

    hr = Load();

lDone:
    return hr;
}

HRESULT CPresenceConfig::Reload(struct ISettingChangeEventArgs * eventArgs)
{
    CComBSTR SettingChange;
    CComBSTR bsValueNew = CComBSTR(NULL);
    HRESULT hr = S_OK;
    DWORD dwValue;

    if (eventArgs == NULL)
    {
        hr = E_POINTER;
        goto lDone;
    }

    hr = eventArgs->get_Setting(&SettingChange);
    if (FAILED(hr))
    {
        goto lDone;
    }

    hr = eventArgs->get_ValueNew(&bsValueNew);
    if (FAILED(hr))
    {
        goto lDone;
    }

    //
    // Setting_presence_UserIndexSize
    //
    if (SettingChange == Setting_presence_UserIndexSize)
    {
        dwValue = GetDWORDSetting(Setting_presence_UserIndexSize, bsValueNew);
        hr = g_CPresenceUserIndex.Resize(dwValue);
        if (SUCCEEDED(hr))
        {
            m_dwUserIndexSize = dwValue;
        }
    }

    //
    // Setting_presence_XBoxIndexSize
    //
    else if (SettingChange == Setting_presence_XBoxIndexSize)
    {
        dwValue = GetDWORDSetting(Setting_presence_XBoxIndexSize, bsValueNew);
        hr = g_CPresenceXBoxIndex.Resize(dwValue);
        if (SUCCEEDED(hr))
        {
            m_dwXBoxIndexSize = dwValue;
        }
    }

    //
    // Setting_presence_SGIndexSize
    //
    else if (SettingChange == Setting_presence_SGIndexSize)
    {
        dwValue = GetDWORDSetting(Setting_presence_SGIndexSize, bsValueNew);
        hr = g_CPresenceSGIndex.Resize(dwValue);
        if (SUCCEEDED(hr))
        {
            m_dwSGIndexSize = dwValue;
        }
    }

    //
    // Setting_presence_ConcurrentSQLThreads
    //
    else if (SettingChange == Setting_presence_ConcurrentSQLThreads)
    {
        dwValue = GetDWORDSetting(Setting_presence_ConcurrentSQLThreads, bsValueNew);
        hr = m_pSwitchboard->GetProfileStore()->ResizeCompPort(m_dwNumSQLThreads, dwValue);
        if (SUCCEEDED(hr))
        {
            m_dwConcurrentSQLThreads = dwValue;
        }
    }

    //
    // Setting_presence_NumSQLThreads
    //
    else if (SettingChange == Setting_presence_NumSQLThreads)
    {
        dwValue = GetDWORDSetting(Setting_presence_NumSQLThreads, bsValueNew);
        hr = m_pSwitchboard->GetProfileStore()->ResizeCompPort(dwValue, m_dwConcurrentSQLThreads);
        if (SUCCEEDED(hr))
        {
            m_dwNumSQLThreads = dwValue;
        }
    }

    //
    // Setting_presence_HeartbeatDelay
    //
    else if (SettingChange == Setting_presence_HeartbeatDelay)
    {
        m_dwHeartbeatDelay = GetDWORDSetting(Setting_presence_HeartbeatDelay, bsValueNew);
    }

    //
    // Setting_presence_MaxQValsPerHeartbeat
    //
    else if (SettingChange == Setting_presence_MaxQValsPerHeartbeat)
    {
        m_dwMaxQValsPerHeartbeat = GetDWORDSetting(Setting_presence_MaxQValsPerHeartbeat, bsValueNew);
    }

    //
    // Setting_presence_PresUserCleanupDelay
    //
    else if (SettingChange == Setting_presence_PresUserCleanupDelay)
    {
        m_dwPresUserCleanupDelay = GetDWORDSetting(Setting_presence_PresUserCleanupDelay, bsValueNew);
    }

    //
    // Setting_presence_IdleQValsCheck
    //
    else if (SettingChange == Setting_presence_IdleQValsCheck)
    {
        m_dwIdleQValsCheck = GetDWORDSetting(Setting_presence_IdleQValsCheck, bsValueNew);
    }

    //
    // Setting_presence_QValRetryDelays
    //
    else if (SettingChange == Setting_presence_QValRetryDelays)
    {
        GetDWORDArraySetting(Setting_presence_QValRetryDelays, &m_dwQValRetryDelaysLen, m_rgdwQValRetryDelays, bsValueNew);
    }

    //
    // Setting_presence_WebUserTimeout
    //
    else if (SettingChange == Setting_presence_WebUserTimeout)
    {
        m_dwWebUserTimeout = GetDWORDSetting(Setting_presence_WebUserTimeout, bsValueNew);
    }

    //
    // Setting_presence_DeadSgOnFailedQVal
    //
    else if (SettingChange == Setting_presence_DeadSgOnFailedQVal)
    {
        m_dwDeadSgOnFailedQVal = GetDWORDSetting(Setting_presence_DeadSgOnFailedQVal, bsValueNew);
    }

    //
    // Setting_presence_StartNumPoolBuffers
    //
    else if (SettingChange == Setting_presence_StartNumPoolBuffers)
    {
        m_dwStartNumPoolBuffers = GetDWORDSetting(Setting_presence_StartNumPoolBuffers, bsValueNew);
    }

    //
    // Setting_presence_MaxNumPoolBuffers
    //
    else if (SettingChange == Setting_presence_MaxNumPoolBuffers)
    {
        m_dwMaxNumPoolBuffers = GetDWORDSetting(Setting_presence_MaxNumPoolBuffers, bsValueNew);
    }

    //
    // Setting_presence_PoolBufferSize
    //
    else if (SettingChange == Setting_presence_PoolBufferSize)
    {
        m_dwPoolBufferSize = GetDWORDSetting(Setting_presence_PoolBufferSize, bsValueNew);
    }

    //
    // Setting_presence_MaxPresenceUsers
    //
    else if (SettingChange == Setting_presence_MaxPresenceUsers)
    {
        m_dwMaxPresenceUsers = GetDWORDSetting(Setting_presence_MaxPresenceUsers, bsValueNew);
    }

    //
    // Setting_presence_MaxRichPresenceBytes
    //
    else if (SettingChange == Setting_presence_MaxRichPresenceBytes)
    {
        m_dwMaxRichPresenceBytes = GetDWORDSetting(Setting_presence_MaxRichPresenceBytes, bsValueNew);
    }

    //
    // Setting_presence_ExpirationCheckInterval
    //
    else if (SettingChange == Setting_presence_ExpirationCheckInterval)
    {
        m_dwExpirationCheckInterval = GetDWORDSetting(Setting_presence_ExpirationCheckInterval, bsValueNew);
    }

    //
    // Setting_presence_MessageTimeout
    //
    else if (SettingChange == Setting_presence_MessageTimeout)
    {
        m_dwMessageTimeout = GetDWORDSetting(Setting_presence_MessageTimeout, bsValueNew);
    }

    //
    // Setting_presence_MessageTimeout
    //
    else if (SettingChange == Setting_presence_MessagingDailySends)
    {
        m_dwMessagingDailySends = GetDWORDSetting(Setting_presence_MessagingDailySends, bsValueNew);
    }

    //
    // Setting_presence_MessageTimeout
    //
    else if (SettingChange == Setting_presence_MessagingDailyRecipients)
    {
        m_dwMessagingDailyRecipients= GetDWORDSetting(Setting_presence_MessagingDailyRecipients, bsValueNew);
    }

    //
    // Setting_presence_BucketReloadDelay
    //
    else if (SettingChange == Setting_presence_BucketReloadDelay)
    {
        m_dwBucketReloadDelay = GetDWORDSetting(Setting_presence_BucketReloadDelay, bsValueNew);
    }

    //
    // Setting_presence_ValidMessageTypes
    //
    else if (SettingChange == Setting_presence_ValidMessageTypes)
    {
        GetDWORDArraySetting(Setting_presence_ValidMessageTypes, &m_dwValidMessageTypesLen, m_rgdwValidMessageTypes, bsValueNew);
    }

    //
    // Setting_presence_MessageTypeExpiration
    //
    else if (SettingChange == Setting_presence_MessageTypeExpiration)
    {
        GetDWORDArraySetting(Setting_presence_MessageTypeExpiration, &m_dwMessageTypeExpirationsLen, m_rgdwMessageTypeExpirations, bsValueNew);
    }

    //
    // Setting_presence_QueryAffiliatesOkToPeerSubscribe
    //
    else if (SettingChange == Setting_presence_QueryAffiliatesOkToPeerSubscribe)
    {
        m_fQueryAfffiliatesOkToPeerSubscribe = GetDWORDSetting(Setting_presence_QueryAffiliatesOkToPeerSubscribe, bsValueNew);
    }

    //
    // Setting_presence_AffiliatesEncounteredListSize
    //
    else if (SettingChange == Setting_presence_AffiliatesEncounteredListSize)
    {
        m_dwAffiliatesEncounteredListSize = GetDWORDSetting(Setting_presence_AffiliatesEncounteredListSize, bsValueNew);
        g_rgdwMaxAffiliates[X_AFFILIATE_ENCOUNTERED_INDEX] = m_dwAffiliatesEncounteredListSize;
    }

    //
    // Setting_presence_AffiliatesCompletedGameListSize
    //
    else if (SettingChange == Setting_presence_AffiliatesCompletedGameListSize)
    {
        m_dwAffiliatesCompletedGameListSize = GetDWORDSetting(Setting_presence_AffiliatesCompletedGameListSize, bsValueNew);
        g_rgdwMaxAffiliates[X_AFFILIATE_COMPLETED_GAME_INDEX] = m_dwAffiliatesCompletedGameListSize;
    }

    //
    // Setting_presence_AffiliatesPositiveFeedbackListSize
    //
    else if (SettingChange == Setting_presence_AffiliatesPositiveFeedbackListSize)
    {
        m_dwAffiliatesPositiveFeedbackListSize = GetDWORDSetting(Setting_presence_AffiliatesPositiveFeedbackListSize, bsValueNew);
        g_rgdwMaxAffiliates[X_AFFILIATE_POSITIVE_FEEDBACK_INDEX] = m_dwAffiliatesPositiveFeedbackListSize;
    }

    //
    // Setting_presence_AffiliatesNegativeFeedbackListSize
    //
    else if (SettingChange == Setting_presence_AffiliatesNegativeFeedbackListSize)
    {
        m_dwAffiliatesNegativeFeedbackListSize = GetDWORDSetting(Setting_presence_AffiliatesNegativeFeedbackListSize, bsValueNew);
        g_rgdwMaxAffiliates[X_AFFILIATE_NEGATIVE_FEEDBACK_INDEX] = m_dwAffiliatesNegativeFeedbackListSize;
    }

       //
    // Setting_presence_AffiliatesAvoidingMeListSize
    //
    else if (SettingChange == Setting_presence_AffiliatesAvoidingMeListSize)
    {
        m_dwAffiliatesAvoidingMeListSize = GetDWORDSetting(Setting_presence_AffiliatesAvoidingMeListSize, bsValueNew);
        g_rgdwMaxAffiliates[X_AFFILIATE_AVOIDING_ME_INDEX] = m_dwAffiliatesAvoidingMeListSize;
    }

       //
    // Setting_presence_AffiliatesFavoritesListSize
    //
    else if (SettingChange == Setting_presence_AffiliatesFavoritesListSize)
    {
        m_dwAffiliatesFavoritesListSize = GetDWORDSetting(Setting_presence_AffiliatesFavoritesListSize, bsValueNew);
        g_rgdwMaxAffiliates[X_AFFILIATE_FAVORITES_INDEX] = m_dwAffiliatesFavoritesListSize;
    }

       //
    // Setting_global_protocolVersion
    //
    else if (SettingChange == Setting_global_protocolVersion)
    {
        m_dwProtocolVersion = GetDWORDSetting(Setting_global_protocolVersion, bsValueNew);
    }

       //
    // Setting_presence_ContextDurationAlertLimit
    //
    else if (SettingChange == Setting_presence_ContextDurationAlertLimit)
    {
        m_dwContextDurationAlertLimit = GetDWORDSetting(Setting_presence_ContextDurationAlertLimit, bsValueNew);
    }

       //
    // Setting_presence_StateBitsNotifyWhitelist
    //
    else if (SettingChange == Setting_presence_StateBitsNotifyWhitelist)
    {
        m_dwStateBitsNotifyWhitelist = GetDWORDSetting(Setting_presence_StateBitsNotifyWhitelist, bsValueNew);
    }

       //
    // Setting_presence_EnableRichPresence
    //
    else if (SettingChange == Setting_presence_EnableRichPresence)
    {
        m_fEnableRichPresence = GetDWORDSetting(Setting_presence_EnableRichPresence, bsValueNew);
    }

       //
    // Setting_presence_StoreStateInVelocity
    //
    else if (SettingChange == Setting_presence_StoreStateInVelocity)
    {
        m_fStoreStateInVelocity = GetDWORDSetting(Setting_presence_StoreStateInVelocity, bsValueNew);
        if (m_fStoreStateInVelocity)
        {
            g_VelocityProxy.Init();
        }
        else
        {
            g_VelocityProxy.Close();
        }
    }

       //
    // Setting_presence_WelcomeToXboxLiveMessage
    //
    else if (SettingChange == Setting_presence_WelcomeToXboxLiveMessage)
    {
        m_dwWelcomeToXboxLiveMessage = GetDWORDSetting(Setting_presence_WelcomeToXboxLiveMessage, bsValueNew);
    }

       //
    // Setting_presence_WelcomeToNewConsoleMessage
    //
    else if (SettingChange == Setting_presence_WelcomeToNewConsoleMessage)
    {
        m_dwWelcomeToNewConsoleMessage = GetDWORDSetting(Setting_presence_WelcomeToNewConsoleMessage, bsValueNew);
    }
    else
    {
            // ignore any other settings.
    }

lDone:

    return hr;
}

/*****************************************************************************

CPresenceConfig::Load

(Re)load the configuration

*****************************************************************************/
HRESULT CPresenceConfig::LoadSettings()
{
    // settings that require extra work to take effect
    m_dwSGQValSendPort = GetDWORDSetting(Setting_presence_SGQValSendPort);
    m_dwSGQValRecvPort = GetDWORDSetting(Setting_presence_SGQValRecvPort);
    m_dwUserIndexSize = GetDWORDSetting(Setting_presence_UserIndexSize);
    m_dwXBoxIndexSize = GetDWORDSetting(Setting_presence_XBoxIndexSize);
    m_dwSGIndexSize = GetDWORDSetting(Setting_presence_SGIndexSize);
    m_dwConcurrentSQLThreads = GetDWORDSetting(Setting_presence_ConcurrentSQLThreads);
    m_dwNumSQLThreads = GetDWORDSetting(Setting_presence_NumSQLThreads);
    m_dwPeerPort = GetDWORDSetting(Setting_presence_PeerPort);

    // simple settings
    m_dwHeartbeatDelay = GetDWORDSetting(Setting_presence_HeartbeatDelay);
    m_dwMaxQValsPerHeartbeat = GetDWORDSetting(Setting_presence_MaxQValsPerHeartbeat);
    m_dwPresUserCleanupDelay = GetDWORDSetting(Setting_presence_PresUserCleanupDelay);
    m_dwIdleQValsCheck = GetDWORDSetting(Setting_presence_IdleQValsCheck);
    GetDWORDArraySetting(Setting_presence_QValRetryDelays, &m_dwQValRetryDelaysLen, m_rgdwQValRetryDelays);
    m_dwWebUserTimeout = GetDWORDSetting(Setting_presence_WebUserTimeout);
    m_dwDeadSgOnFailedQVal = GetDWORDSetting(Setting_presence_DeadSgOnFailedQVal);
    m_dwStartNumPoolBuffers = GetDWORDSetting(Setting_presence_StartNumPoolBuffers);
    m_dwMaxNumPoolBuffers = GetDWORDSetting(Setting_presence_MaxNumPoolBuffers);
    m_dwPoolBufferSize = GetDWORDSetting(Setting_presence_PoolBufferSize);
    m_dwMaxPresenceUsers = GetDWORDSetting(Setting_presence_MaxPresenceUsers);
    m_dwMaxRichPresenceBytes = GetDWORDSetting(Setting_presence_MaxRichPresenceBytes);
    m_dwExpirationCheckInterval = GetDWORDSetting(Setting_presence_ExpirationCheckInterval);
    m_dwMessageTimeout = GetDWORDSetting(Setting_presence_MessageTimeout);
    m_dwMessagingDailySends = GetDWORDSetting(Setting_presence_MessagingDailySends);
    m_dwMessagingDailyRecipients = GetDWORDSetting(Setting_presence_MessagingDailyRecipients);
    m_dwBucketReloadDelay = GetDWORDSetting(Setting_presence_BucketReloadDelay);
    GetDWORDArraySetting(Setting_presence_ValidMessageTypes, &m_dwValidMessageTypesLen, m_rgdwValidMessageTypes);
    GetDWORDArraySetting(Setting_presence_MessageTypeExpiration, &m_dwMessageTypeExpirationsLen, m_rgdwMessageTypeExpirations);
    m_fQueryAfffiliatesOkToPeerSubscribe = GetDWORDSetting(Setting_presence_QueryAffiliatesOkToPeerSubscribe);
    m_dwAffiliatesEncounteredListSize = GetDWORDSetting(Setting_presence_AffiliatesEncounteredListSize);
    m_dwAffiliatesCompletedGameListSize = GetDWORDSetting(Setting_presence_AffiliatesCompletedGameListSize);
    m_dwAffiliatesPositiveFeedbackListSize = GetDWORDSetting(Setting_presence_AffiliatesPositiveFeedbackListSize);
    m_dwAffiliatesNegativeFeedbackListSize = GetDWORDSetting(Setting_presence_AffiliatesNegativeFeedbackListSize);
    m_dwAffiliatesAvoidingMeListSize = GetDWORDSetting(Setting_presence_AffiliatesAvoidingMeListSize);
    m_dwAffiliatesFavoritesListSize = GetDWORDSetting(Setting_presence_AffiliatesFavoritesListSize);
    m_dwProtocolVersion = GetDWORDSetting(Setting_global_protocolVersion);
    m_dwContextDurationAlertLimit = GetDWORDSetting(Setting_presence_ContextDurationAlertLimit);
    m_dwStateBitsNotifyWhitelist = GetDWORDSetting(Setting_presence_StateBitsNotifyWhitelist);
    m_fEnableRichPresence = GetDWORDSetting(Setting_presence_EnableRichPresence);
    m_fStoreStateInVelocity = GetDWORDSetting(Setting_presence_StoreStateInVelocity);
    m_dwWelcomeToNewConsoleMessage = GetDWORDSetting(Setting_presence_WelcomeToNewConsoleMessage);
    m_dwWelcomeToXboxLiveMessage = GetDWORDSetting(Setting_presence_WelcomeToXboxLiveMessage);

    if (m_dwMaxRichPresenceBytes > MAX_TITLE_DATA_BYTES)
    {
        XomNtEvent( XEVENT_PRESENCE_CONFIG_29, "CPresenceConfig::Load() - Configured Max RichPresence State data is greater than what the SG protocol allows. See usage of MAX_TITLE_DATA_BYTES. Maximum allowed setting is ", MAX_TITLE_DATA_BYTES );
    }

    return S_OK;
}

HRESULT CPresenceConfig::Load()
{
    HRESULT hr = S_OK;

    hr = LoadSettings();
    if (FAILED(hr))
    {
        XomNtEvent( XEVENT_PRESENCE_CONFIG_30, "CPresenceConfig::Load() - Failed to load Settings, hr=0x%08X", hr );
        goto lDone;
    }

    hr = LoadXonWatchIPs();
    if (FAILED(hr))
    {
        XomNtEvent( XEVENT_PRESENCE_CONFIG_31, "CPresenceConfig::Load() - Failed to load XonWatchIPs, hr=0x%08X", hr );
        goto lDone;
    }

    hr = LoadPresenceServers();
    if( FAILED( hr ) )
    {
        XomNtEvent( XEVENT_PRESENCE_CONFIG_32, "CPresenceConfig::Load() - Failed to load Presence servers, hr=0x%08X", hr );
        goto lDone;
    }

    hr = LoadBucketMap();
    if (FAILED(hr))
    {
        XomNtEvent( XEVENT_PRESENCE_CONFIG_33, "CPresenceConfig::Load() - Failed to load bucket map, hr=0x%08X", hr );
        goto lDone;
    }

    hr = LoadNPDBInfo();
    if (FAILED(hr))
    {
        XomNtEvent( XEVENT_PRESENCE_CONFIG_34, "CPresenceConfig::Load() - Failed to load npdb info, hr=0x%08X", hr );
        goto lDone;
    }

lDone:
    return hr;
}

/*****************************************************************************

CPresenceConfig::GetDWORDSetting

Get a DWORD settting

*****************************************************************************/
DWORD CPresenceConfig::GetDWORDSetting(CComBSTR Setting, CComBSTR bsSetting)
{
    DWORD dwRetVal = 0;
    HRESULT hr = S_OK;

    if (bsSetting == NULL)
    {
        hr = m_pConfig->GetSetting( Setting, &bsSetting );
    }

    if( FAILED( hr ) || (bsSetting == NULL))
    {
        XomNtEvent( XEVENT_PRESENCE_CONFIG_35, "CPresenceConfig::GetDWORDSetting() - Config.GetSetting failed, hr=0x%08X", hr );

        return 0;
    }

    if( ( L'0' == bsSetting[ 0 ] ) && ( L'x' == bsSetting[ 1 ] ) )
    {
        if( 0 >= swscanf( bsSetting, L"%x", &dwRetVal ) )
        {
            dwRetVal = 0;
        }
    }
    else
    {
        dwRetVal = (DWORD) _wtoi(bsSetting);
    }

    return dwRetVal;
}

/*****************************************************************************

GetDWORDArraySetting

*****************************************************************************/
void CPresenceConfig::GetDWORDArraySetting(
    CComBSTR Setting,
    DWORD *pdwLen,
    DWORD *rgdwVal,
    CComBSTR bsSetting)
{
    // BUGBUG put in a new array, then swap

    LPCWSTR wszRead;
    int iRet;
    HRESULT hr = S_OK;

    if (bsSetting == NULL)
    {
        // Get the string to parse
        hr = m_pConfig->GetSetting( Setting, &bsSetting );
    }

    if( FAILED( hr ) || (bsSetting == NULL))
    {
        XomNtEvent( XEVENT_PRESENCE_CONFIG_36, "CPresenceConfig::GetDWORDArraySetting() - Config.GetSetting failed, hr=0x%08X", hr );

        *pdwLen = 0;
        return;
    }

    wszRead = bsSetting;
    *pdwLen = 0;
    for (;;)
    {
        // Check the size limit
        if (*pdwLen >= P_MAX_DWORD_ARRAY)
        {
            break;
        }

        // Try to get an element
        if( ( '0' == wszRead[ 0 ] ) && ( 'x' == wszRead[ 1 ] ) )
        {
            iRet = swscanf(wszRead, L"%x", rgdwVal + *pdwLen);
        }
        else
        {
            iRet = swscanf(wszRead, L"%d", rgdwVal + *pdwLen);
        }

        // Did we get anything
        if (iRet != 1)
        {
            break;
        }

        // Next element
        *pdwLen = *pdwLen + 1;

        while ((*wszRead != '\0') && (*wszRead != ','))
        {
            wszRead++;
        }

        while ((*wszRead == ',') || (*wszRead == ' ') || (*wszRead == '\t'))
        {
            wszRead++;
        }
    }

}

/*****************************************************************************

CPresenceConfig::LoadXonWatchIPs

Load the list of valid XonWatch IP addresses

*****************************************************************************/
HRESULT CPresenceConfig::LoadXonWatchIPs()
{
    HRESULT hr = S_OK;
    CComBSTR bsXonWatchIPs;
    WCHAR *wszAddr;
    WCHAR *wszRead;
    DWORD dwIndex = 0;
    HOSTENT *pHE = NULL;

    hr = m_pConfig->GetSetting( Setting_presence_XonWatchIPs, &bsXonWatchIPs );
    if( FAILED( hr ) )
    {
        XomNtEvent( XEVENT_PRESENCE_CONFIG_37, "CPresenceConfig::LoadXonWatchIPs() - Config.GetSetting failed, hr=0x%08X", hr );
        goto lDone;
    }

    wszAddr = bsXonWatchIPs;
    wszRead = bsXonWatchIPs;

    while (*wszRead != L'\0')
    {
        XonWatchIP *pNew = new XonWatchIP[m_cXonWatchIPs + 1];
        memcpy(pNew, m_psXonWatchIPs, m_cXonWatchIPs * sizeof(XonWatchIP));
        delete[] m_psXonWatchIPs;
        m_psXonWatchIPs = pNew;

        while ((*wszRead != L',') && (*wszRead != L'\0'))
        {
            wszRead++;
        }
        if (*wszRead == ',')
        {
            *wszRead = '\0';
            wszRead++;
        }

        // Get the address
        pHE = gethostbyname( CW2A(wszAddr ) );
        if( NULL == pHE )
        {
            hr = HRESULT_FROM_WIN32( WSAGetLastError() );
            goto lDone;
        }

        memset(&(m_psXonWatchIPs[dwIndex].inaIP), 0, sizeof(in_addr));
        memcpy(&(m_psXonWatchIPs[dwIndex].inaIP), pHE->h_addr, pHE->h_length);

        while ((*wszRead == ' ') || (*wszRead == '\t'))
        {
            wszRead++;
        }
        wszAddr = wszRead;

        while ((*wszRead != ';') && (*wszRead != '\0'))
        {
            wszRead++;
        }
        if (*wszRead == ';')
        {
            *wszRead = '\0';
            wszRead++;
        }

        // Get the mask
        pHE = gethostbyname( CW2A(wszAddr) );
        if( NULL == pHE )
        {
            hr = HRESULT_FROM_WIN32( WSAGetLastError() );
            goto lDone;
        }

        memset(&(m_psXonWatchIPs[dwIndex].inaMask), 0, sizeof(in_addr));
        memcpy(&(m_psXonWatchIPs[dwIndex].inaMask), pHE->h_addr, pHE->h_length);

        while ((*wszRead == ' ') || (*wszRead == '\t'))
        {
            wszRead++;
        }
        wszAddr = wszRead;

        m_cXonWatchIPs++;
        dwIndex++;
    }

lDone:
    return hr;
}

/*****************************************************************************

CPresenceConfig::LoadPresenceServers

Load the list of all Presence servers

*****************************************************************************/
HRESULT CPresenceConfig::LoadPresenceServers()
{
    HRESULT hr = S_OK;
    BSTR* pbstr = NULL;
    SAFEARRAY* pArray = NULL;

    hr = m_pConfig->GetServerListByInterface( Interface_xpserver, &pArray );
    if( FAILED( hr ) )
    {
        XomNtEvent( XEVENT_PRESENCE_CONFIG_38, "CPresenceConfig::LoadPresenceServers() - GetServerListByInterface failed, hr=0x%08X", hr );
        goto lDone;
    }

    hr = SafeArrayAccessData( pArray, (void**) &pbstr );
    if( FAILED( hr ) )
    {
        XomNtEvent( XEVENT_PRESENCE_CONFIG_39, "CPresenceConfig::LoadPresenceServers() - SafeArrayAccessData failed, hr=0x%08X", hr );
        goto lDone;
    }

    for( DWORD iServer = 0; iServer < pArray->rgsabound->cElements; iServer++ )
    {
        if( FAILED( AddServer( pbstr[ iServer ], m_cPresServers ) ) )
        {
            XomNtEvent( XEVENT_PRESENCE_CONFIG_40, "CPresenceConfig::LoadPresenceServers() - AddServer failed, hr=0x%08X", hr );
            goto lDone;
        }
        m_cPresServers++;
    }

    if (m_dwMyIndex == P_NOT_FOUND)
    {
        XomNtEvent( XEVENT_PRESENCE_CONFIG_INVALID_SERVER, "CPresenceConfig::LoadPresenceServers() - no server list entry mapped to the local machine.");
        hr = E_UNEXPECTED;
        goto lDone;
    }

    SafeArrayUnaccessData( pArray );
    pbstr = NULL;

    SafeArrayDestroy( pArray );
    pArray = NULL;

lDone:
    if( NULL != pbstr )
    {
        SafeArrayUnaccessData( pArray );
        pbstr = NULL;
    }
    if( NULL != pArray )
    {
        SafeArrayDestroy( pArray );
        pArray = NULL;
    }

    return hr;
}


HRESULT CPresenceConfig::LoadVelocityServers()
{
    HRESULT hr = S_OK;
    WORD * pwPorts = NULL;
    long lLow, lHigh, lIdx;
    CComPtr<IInterfaceInfo> pInterfaceInfo;

    if (m_psrgVelocityServers != NULL)
    {
        SafeArrayDestroy(m_psrgVelocityServers);
        m_psrgVelocityServers = NULL;
    }

    if (m_psrgVelocityPorts != NULL)
    {
        SafeArrayDestroy(m_psrgVelocityPorts);
        m_psrgVelocityPorts = NULL;
    }

    hr = m_pConfig->GetServerListByInterface( Interface_XNotiCache, &m_psrgVelocityServers );
    if( FAILED( hr ) )
    {
        goto lDone;
    }

    hr = SafeArrayGetLBound(m_psrgVelocityServers, 1, &lLow);
    if (FAILED(hr))
    {
        goto lDone;
    }

    hr = SafeArrayGetUBound(m_psrgVelocityServers, 1, &lHigh);
    if (FAILED(hr))
    {
        goto lDone;
    }

    SAFEARRAYBOUND rgsabound;
    rgsabound.lLbound = 0;
    rgsabound.cElements = lHigh - lLow + 1;
    m_psrgVelocityPorts = SafeArrayCreate(VT_UI2, 1, &rgsabound);

    if (m_psrgVelocityPorts == NULL)
    {
        goto lDone;
    }

    hr = SafeArrayAccessData(m_psrgVelocityPorts, (void HUGEP**)&pwPorts);
    if (FAILED(hr))
    {
        pwPorts = NULL;
        goto lDone;
    }

    for (lIdx=lLow; lIdx <=lHigh; lIdx++)
    {
        CComBSTR bstrServer;

        hr = SafeArrayGetElement(m_psrgVelocityServers, &lIdx, (void *)&bstrServer);
        if (FAILED(hr))
        {
            goto lDone;
        }

        hr = m_pConfig->GetInterface(bstrServer, Interface_XNotiCache, &pInterfaceInfo);
        if (FAILED(hr))
        {
            goto lDone;
        }

        LONG lPort;
        hr = pInterfaceInfo->get_Port(&lPort);
        if (FAILED(hr))
        {
            goto lDone;
        }

        pwPorts[lIdx - lLow] = (WORD)lPort;
    }

    SafeArrayUnaccessData(m_psrgVelocityPorts);
    pwPorts = NULL;

lDone:

    if( FAILED( hr ) )
    {
        if (m_psrgVelocityServers != NULL)
        {
            SafeArrayDestroy(m_psrgVelocityServers);
            m_psrgVelocityServers = NULL;
        }
        if (pwPorts != NULL)
        {
            SafeArrayUnaccessData(m_psrgVelocityPorts);
        }
        if (m_psrgVelocityPorts != NULL)
        {
            SafeArrayDestroy(m_psrgVelocityPorts);
            m_psrgVelocityPorts = NULL;
        }
    }

    return hr;
}


/*****************************************************************************

CPresenceConfig::IsValidOnWatchAddr

Returns true if the given address is valid for XonWatch operations

*****************************************************************************/
BOOL CPresenceConfig::IsValidOnWatchAddr(IN_ADDR inaddr)
{
    DWORD dwIndex = 0;

    for (dwIndex = 0; dwIndex < m_cXonWatchIPs; dwIndex++)
    {
        if ((inaddr.S_un.S_addr & m_psXonWatchIPs[dwIndex].inaMask.S_un.S_addr) ==
            m_psXonWatchIPs[dwIndex].inaIP.S_un.S_addr)
        {
            return TRUE;
        }
    }

    return FALSE;
}

HRESULT CPresenceConfig::LoadNPDBInfo()
{
    HRESULT hr = S_OK;

    hr = m_pConfig->get_NpdbConnectionString(&m_bsNPDBConnectionString);
    if (FAILED(hr))
    {
        goto lDone;
    }

lDone:

    return hr;
}

/*****************************************************************************

CPresenceConfig::MapUserToPresSrv

Map a user to a presence server

*****************************************************************************/
DWORD CPresenceConfig::MapUserToPresSrv(QWORD qwUserID, BOOL fAlt)
{
    if (qwUserID == 0)
    {
        // There are a couple valid cases where this function gets called for puid 0.
        // Reenable this assert if there are problems with pconn messages going to the wrong servers.
        // XOMASSERT(FALSE);
        XomNtEvent(XEVENT_PRESENCE_CODE_192, "MapUserToPresSrv called for puid = 0 !!");

        // Since we removed P_NO_ALT_SERVER, we dont want to return P_NOT_FOUND anymore either.
        // There may have been some code that depended on the two values being the same.  By returning
        // the local server index, we can ensure that nobody will try to pass 0xFFFFFFFF as an array index when
        // trying to send or forward to another server.  This may result in a local shortcut message that ends up
        // returning E_NO_SUCH_USER when FindPresence() is called for user 0.
        return GetMyPresServerIndex();
    }

    DWORD dwHash = HashPUID(qwUserID);
    DWORD dwRet = m_rgBucketMap[dwHash].dwServerIndex;

    if (fAlt)
    {
        DWORD dwAlt = m_rgBucketMap[dwHash].dwNextServerIndex;
        dwRet = ((dwRet == dwAlt) || (!m_rgBucketMap[dwHash].fAltServerValid)) ? dwRet : dwAlt;
    }

    return dwRet;
}

/*****************************************************************************

CPresenceConfig::GetPresServerName

Get a Presence server name by index

*****************************************************************************/
CComBSTR CPresenceConfig::GetPresServerName(DWORD dwIndex)
{
    if (dwIndex >= m_cPresServers)
    {
        return CComBSTR(L"NULL");
    }
    else
    {
        return m_rgPresServers[dwIndex].bstrInterfaceName;
    }
}

/*****************************************************************************

CPresenceConfig::GetPresServerAddr

Get a Presence server address by index

*****************************************************************************/
sockaddr_in *CPresenceConfig::GetPresServerAddr(DWORD dwIndex)
{
    if (dwIndex >= m_cPresServers)
    {
        return NULL;
    }
    else
    {
        return &(m_rgPresServers[dwIndex].sa);
    }
}

/*****************************************************************************

CPresenceConfig::GetPresServerPeerAddr

Get a Presence server peer address by index

*****************************************************************************/
sockaddr_in *CPresenceConfig::GetPresServerPeerAddr(DWORD dwIndex)
{
    if (dwIndex >= m_cPresServers)
    {
        return NULL;
    }
    else
    {
        return &(m_rgPresServers[dwIndex].saPeer);
    }
}

/*****************************************************************************

CPresenceConfig::GetPresServerAddr

Return FALSE if we shouldn't be receiving messages for this user

*****************************************************************************/
BOOL CPresenceConfig::CheckDestination(QWORD qwUserID)
{
    if (qwUserID == 0)
    {
        XOMASSERT(FALSE);
        XomNtEvent(XEVENT_PRESENCE_CODE_193, "CheckDestination called for puid = 0 !!");
        return FALSE;
    }

    DWORD dwHash = HashPUID(qwUserID);

    if ((m_dwMyIndex == m_rgBucketMap[dwHash].dwNextServerIndex) ||
        (m_dwMyIndex == m_rgBucketMap[dwHash].dwServerIndex))
    {
        return TRUE;
    }

    return FALSE;
}


HRESULT CPresenceConfig::ChangeBucketMap(
    DWORD dwBucket,
    CComBSTR bsCurrentServer,
    CComBSTR bsNextServer,
    DATE dtStart,
    BOOL fMine)
{
    HRESULT hr = S_OK;

    if (dwBucket > m_dwBucketCount)
    {
        hr = E_INVALIDARG;
        goto lDone;
    }

    DWORD dwNewCurrentServer = GetServerByName(bsCurrentServer);
    DWORD dwNewNextServer = GetServerByName(bsNextServer);

    if ((dwNewCurrentServer == m_rgBucketMap[dwBucket].dwNextServerIndex) && (dwNewNextServer == dwNewCurrentServer))
    {
        // migration is done.
        hr = S_FALSE;

        if (fMine)
        {
            // local server needs to wait to be sure everyone else is notified first.
            goto lDone;
        }
    }
    else if (dwNewCurrentServer != m_rgBucketMap[dwBucket].dwServerIndex)
    {
        // changing the current server is bad.
        hr = E_INVALIDARG;
        XomNtEvent(XEVENT_PRESENCE_CONFIG_45, "CPresenceConfig::ChangeBucketMap(bucket = %d, newCurrent = %s): current server changed before next server.", dwBucket, CW2A(bsCurrentServer));
        goto lDone;
    }

    if ((dwNewNextServer != m_rgBucketMap[dwBucket].dwNextServerIndex) && fMine)
    {
        // we dont use this alt server until the time hits.
        m_rgBucketMap[dwBucket].fAltServerValid = FALSE;
    }

    m_rgBucketMap[dwBucket].dtStart = dtStart;
    m_rgBucketMap[dwBucket].dwNextServerIndex = GetServerByName(bsNextServer);
    m_rgBucketMap[dwBucket].dwServerIndex = GetServerByName(bsCurrentServer);

lDone:

    return hr;
}

/*****************************************************************************

CPresenceConfig::LoadBucketMap

Load the bucket map from the database

*****************************************************************************/
HRESULT CPresenceConfig::LoadBucketMap()
{
    DWORD dwNow = GetTickCount();

    // Only execute if we're stale
    if ((m_dwLastBucketLoad != 0) &&
        ((dwNow - m_dwLastBucketLoad) < m_dwBucketReloadDelay))
    {
        return S_OK;
    }

    HRESULT hr = S_OK;

    DWORD cBuckets;
    PresServerBucketConfig *rgBucketMap = NULL;
    PresServerBucketConfig *rgOldBucketMap = NULL;

    hr = m_pConfig->GetBucketCount( Interface_xpserver, &cBuckets );
    if( FAILED( hr ) )
    {
        XomNtEvent( XEVENT_PRESENCE_CONFIG_46, "CPresenceConfig::LoadBucketMap() - Config.GetPartitionCount failed, hr=0x%08X", hr );
        goto lDone;
    }

    rgBucketMap = new PresServerBucketConfig[ cBuckets ];
    for( DWORD iBucket = 0; iBucket < cBuckets; iBucket++ )
    {
        CComPtr<IBucketServer> pServer;
        CComBSTR bsCurrentServer;
        CComBSTR bsNextServer;
        DATE dtMigrationStart;

        hr = m_pConfig->GetBucketServer( Interface_xpserver, iBucket, &pServer );
        if( FAILED( hr ) )
        {
            XomNtEvent( XEVENT_PRESENCE_CONFIG_47, "CPresenceConfig::LoadBucketMap() - Config.GetBucketServer failed, hr=0x%08X", hr );
            goto lDone;
        }

        hr = pServer->get_CurrentServerName( &bsCurrentServer );
        if( FAILED( hr ) )
        {
            XomNtEvent( XEVENT_PRESENCE_CONFIG_48, "CPresenceConfig::LoadBucketMap() - IBucketServer.CurrentServer failed, hr=0x%08X", hr );
            goto lDone;
        }

        hr = pServer->get_NextServerName( &bsNextServer );
        if( FAILED( hr ) )
        {
            XomNtEvent( XEVENT_PRESENCE_CONFIG_49, "CPresenceConfig::LoadBucketMap() - IBucketServer.NextServer failed, hr=0x%08X", hr );
            goto lDone;
        }

        hr = pServer->get_NextServerStart( &dtMigrationStart );
        if( FAILED( hr ) )
        {
            XomNtEvent( XEVENT_PRESENCE_CONFIG_50, "CPresenceConfig::LoadBucketMap() - IBucketServer.NextServerStart failed, hr=0x%08X", hr );
            goto lDone;
        }

        rgBucketMap[ iBucket ].dwServerIndex = GetServerByName( bsCurrentServer );
        rgBucketMap[ iBucket ].dwNextServerIndex = GetServerByName( bsNextServer );
        rgBucketMap[ iBucket ].dtStart = dtMigrationStart;
        rgBucketMap[ iBucket ].cBucketUsers = 0;
        rgBucketMap[ iBucket ].fAltServerValid = TRUE;
    }

    // Replace the old map
    rgOldBucketMap = m_rgBucketMap;
    m_dwBucketCount = cBuckets;
    m_rgBucketMap = rgBucketMap;
    rgBucketMap = NULL;

    m_dwLastBucketLoad = dwNow;

lDone:

    if (rgBucketMap != NULL)
    {
        delete[] rgBucketMap;
    }
    if (rgOldBucketMap != NULL)
    {
        delete[] rgOldBucketMap;
    }

    return hr;
}

/*****************************************************************************

CPresenceConfig::HashPUID

Hash a PUID

*****************************************************************************/
DWORD CPresenceConfig::HashPUID(QWORD qwPUID)
{
    qwPUID = GET_PUID_BITS(qwPUID);
    // NOTE: make sure this is always the same as GetBucketNum() defined in Config.cs
    return (DWORD)(qwPUID % m_dwBucketCount);
}

/*****************************************************************************

CPresenceConfig::GetServerByName

Get a server by interface name

*****************************************************************************/
DWORD CPresenceConfig::GetServerByName(BSTR m_bstrInterfaceName)
{
    DWORD dwIndex;

    for (dwIndex = 0; dwIndex < m_cPresServers; dwIndex++)
    {
        if (m_rgPresServers[dwIndex].bstrInterfaceName == m_bstrInterfaceName)
        {
            return dwIndex;
        }
    }
    return P_NOT_FOUND;
}

/*****************************************************************************

CPresenceConfig::GetHostAddrs

Get the local IP addresses

*****************************************************************************/
HRESULT CPresenceConfig::GetHostAddrs(in_addr *rgsaAddrs, DWORD *pcAddrs)
{
    HRESULT hr = S_OK;
    int iRet= 0;
    DWORD dwIndex;
    CHAR szLocalHost [INTERNET_MAX_HOST_NAME_LENGTH];
    LPHOSTENT phe = NULL;

    // Get the local hostname
    iRet = gethostname(szLocalHost, INTERNET_MAX_HOST_NAME_LENGTH);
    if (iRet != 0)
    {
        hr = HRESULT_FROM_WIN32(WSAGetLastError());
        goto lDone;
    }

    // Resolve hostname for local address
    phe = gethostbyname((LPSTR)szLocalHost);
    if (phe == NULL)
    {
        hr = HRESULT_FROM_WIN32(WSAGetLastError());
        goto lDone;
    }

    for (dwIndex = 0; (phe->h_addr_list[dwIndex] != NULL) && (dwIndex < *pcAddrs); dwIndex++)
    {
        memcpy(rgsaAddrs + dwIndex, phe->h_addr_list[dwIndex], sizeof(in_addr));
    }

    *pcAddrs = dwIndex;

lDone:

    if (FAILED(hr))
    {
        pcAddrs = 0;
    }

    return hr;
}

/*****************************************************************************

CPresenceConfig::AddServer

Add a new presence server

*****************************************************************************/
HRESULT CPresenceConfig::AddServer(BSTR bstrServerName, DWORD dwServerIndex)
{
    HRESULT hr = S_OK;
    DWORD dwIndex;
    CComPtr<IInterfaceInfo> pInterfaceInfo;
    CComBSTR bsIPAddress;
    long lPort;
    HOSTENT *pHE = NULL;
    in_addr rgsaAddrs[8];
    DWORD cAddrs = ARRAY_ELEMENTS(rgsaAddrs);

    // Figure out our local addresses
    hr = GetHostAddrs(rgsaAddrs, &cAddrs);
    if (FAILED(hr))
    {
        goto lDone;
    }

    if (dwServerIndex >= P_MAX_P_SERVERS)
    {
        return E_FAIL;
    }

    m_rgPresServers[dwServerIndex].bstrInterfaceName = bstrServerName;

    // Build a socket address for the signature server
    memset (&(m_rgPresServers[dwServerIndex].sa), 0, sizeof(sockaddr_in));
    m_rgPresServers[dwServerIndex].sa.sin_family = AF_INET;
    memset (&(m_rgPresServers[dwServerIndex].saPeer), 0, sizeof(sockaddr_in));
    m_rgPresServers[dwServerIndex].saPeer.sin_family = AF_INET;

    hr = m_pConfig->GetInterface(bstrServerName, Interface_xpserver, &pInterfaceInfo);
    if (FAILED(hr))
    {
        goto lDone;
    }

    hr = pInterfaceInfo->get_IPAddressString(&bsIPAddress);
    if (FAILED(hr))
    {
        goto lDone;
    }

    hr = pInterfaceInfo->get_Port(&lPort);
    if (FAILED(hr))
    {
        goto lDone;
    }

    pHE = gethostbyname( CW2A(bsIPAddress) );
    if( NULL == pHE )
    {
        hr = HRESULT_FROM_WIN32( WSAGetLastError() );
        goto lDone;
    }

    memcpy( &(m_rgPresServers[dwServerIndex].sa.sin_addr), pHE->h_addr, pHE->h_length );
    m_rgPresServers[dwServerIndex].sa.sin_port = htons( (WORD)lPort );
    memcpy( &(m_rgPresServers[dwServerIndex].saPeer.sin_addr), pHE->h_addr, pHE->h_length );
    m_rgPresServers[dwServerIndex].saPeer.sin_port = htons( (WORD)m_dwPeerPort );

    // Is it me?
    for (dwIndex = 0; dwIndex < cAddrs; dwIndex++)
    {
        if (rgsaAddrs[dwIndex].s_addr == m_rgPresServers[dwServerIndex].sa.sin_addr.s_addr)
        {
            m_dwMyIndex = dwServerIndex;
            break;
        }
    }

lDone:
    return hr;
}

HRESULT CPresenceConfig::ChangeServerList(DWORD cServers, CComBSTR *rgbsServers)
{
    HRESULT hr = S_OK;
    DWORD *rgdwIndexMap = NULL;
    PresServerConfig *rgNewPresServers = NULL;
    DWORD dwOldServer = 0;
    DWORD dwNewServer = 0;

    // build a translation map for the indices
    rgdwIndexMap = new DWORD[m_cPresServers];
    if (rgdwIndexMap == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    for (dwOldServer = 0; dwOldServer < m_cPresServers; dwOldServer++)
    {
        rgdwIndexMap[dwOldServer] = 0xFFFFFFFF;
        for (dwNewServer = 0; dwNewServer < cServers; dwNewServer++)
        {
            if (rgbsServers[dwNewServer] == m_rgPresServers[dwOldServer].bstrInterfaceName)
            {
                rgdwIndexMap[dwOldServer] = dwNewServer;
            }
        }
    }

    // make a new connection list and copy over any old connections that still remain.
    rgNewPresServers = new PresServerConfig[cServers];
    if (rgNewPresServers == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    for (dwOldServer = 0; dwOldServer < m_cPresServers; dwOldServer++)
    {
        if (rgdwIndexMap[dwOldServer] != 0xFFFFFFFF)
        {
            rgNewPresServers[rgdwIndexMap[dwOldServer]].bstrInterfaceName = m_rgPresServers[dwOldServer].bstrInterfaceName;
            memcpy(&(rgNewPresServers[rgdwIndexMap[dwOldServer]].sa), &(m_rgPresServers[dwOldServer].sa), sizeof(sockaddr_in));
            memcpy(&(rgNewPresServers[rgdwIndexMap[dwOldServer]].saPeer), &(m_rgPresServers[dwOldServer].saPeer), sizeof(sockaddr_in));
        }
    }

    // copy back over the real list
    for (m_cPresServers = 0; m_cPresServers < cServers; m_cPresServers++)
    {
        m_rgPresServers[m_cPresServers].bstrInterfaceName = rgNewPresServers[m_cPresServers].bstrInterfaceName;
        memcpy(&(m_rgPresServers[m_cPresServers].sa), &(rgNewPresServers[m_cPresServers].sa), sizeof(sockaddr_in));
        memcpy(&(m_rgPresServers[m_cPresServers].saPeer), &(rgNewPresServers[m_cPresServers].saPeer), sizeof(sockaddr_in));
    }

    // update my server index
    m_dwMyIndex = rgdwIndexMap[m_dwMyIndex];

    // make new connections
    for (dwNewServer = 0; dwNewServer < cServers; dwNewServer++)
    {
        if (rgNewPresServers[dwNewServer].bstrInterfaceName.Length() == 0)
        {
            hr = AddServer(rgbsServers[dwNewServer], dwNewServer);
            if (FAILED(hr))
            {
                goto lDone;
            }
        }
    }

    // rearrange the bucket map
    for (DWORD dwBucket = 0; dwBucket < m_dwBucketCount; dwBucket++)
    {
        m_rgBucketMap[dwBucket].dwServerIndex = rgdwIndexMap[m_rgBucketMap[dwBucket].dwServerIndex];
        m_rgBucketMap[dwBucket].dwNextServerIndex = rgdwIndexMap[m_rgBucketMap[dwBucket].dwNextServerIndex];
    }

    // update PConn (dwOldServer contains the count of the old server list.)
    hr = m_pSwitchboard->GetPCluser()->ChangeServerList(rgdwIndexMap, dwOldServer);

    // update CliConn forwarding servers.
    hr = m_pSwitchboard->GetClientListener()->ChangeServerList(rgdwIndexMap, dwOldServer);

lDone:

    SAFE_ARRAYDELETE(rgdwIndexMap);
    SAFE_ARRAYDELETE(rgNewPresServers);

    return hr;
}


// CPresConfigListener notification handlers

HRESULT __stdcall CPresConfigListener::SettingChange (
    struct ISettingChangeEventArgs * e )
{
    HRESULT hr = S_OK;
    HANDLE hevtWait = INVALID_HANDLE_VALUE;
    CSettingsChangeContext *pCCtx = NULL;

    XomNtEvent(XEVENT_PRESENCE_INFO_6, "CPresConfigListener::SettingChange() called.");

    if (m_pSwitchboard == NULL)
    {
        hr = E_UNEXPECTED;
        XomNtEvent(XEVENT_PRESENCE_CODE_194, "CPresConfigListener::SettingChange() called when m_pSwitchboard == NULL.");
        goto lDone;
    }

    pCCtx = new CSettingsChangeContext();
    if (pCCtx == NULL)
    {
        hr = E_OUTOFMEMORY;
        XomNtEvent(XEVENT_PRESENCE_CODE_195, "CPresConfigListener::SettingChange() could not allocate settings change context.");
        goto lDone;
    }

    hevtWait = CreateEvent(NULL, TRUE, FALSE, NULL);
    if ((hevtWait == NULL) || (hevtWait == INVALID_HANDLE_VALUE))
    {
        hr = E_OUTOFMEMORY;
        XomNtEvent(XEVENT_PRESENCE_CODE_196, "CPresConfigListener::SettingChange() could not allocate wait event.");
        goto lDone;
    }

    pCCtx->m_eventArgs = e;
    pCCtx->m_hevtFinished = hevtWait;

    hr = m_pSwitchboard->PostCompletion(pCCtx);
    if (FAILED(hr))
    {
        XomNtEvent(XEVENT_PRESENCE_CODE_197, "CPresConfigListener::SettingChange() could not post completion.");
        goto lDone;
    }

    // this thread blocks until switchboard has processed the setting change.
    if (WAIT_OBJECT_0 != WaitForSingleObject(hevtWait, INFINITE))
    {
        hr = E_UNEXPECTED;
        XomNtEvent(XEVENT_PRESENCE_CODE_198, "CPresConfigListener::SettingChange() failed while waiting for completion.");
        goto lDone;
    }

    hr = pCCtx->m_hr;

lDone:

    SAFE_RELEASE(pCCtx);
    SAFE_CLOSEHANDLE(hevtWait);

    return hr;
}

HRESULT __stdcall CPresConfigListener::InterfaceBucketChange (
    struct IInterfaceBucketChangeEventArgs * e )
{
    HRESULT hr = S_OK;
    CComBSTR InterfaceChange = Interface_None;
    CInterfaceBucketChangeContext *pCCtx = NULL;
    IBucketServer *ibsNew = NULL;
    CComBSTR bsCurrentServer;
    CComBSTR bsNextServer;

    if (m_pSwitchboard == NULL)
    {
        hr = E_UNEXPECTED;
        XomNtEvent(XEVENT_PRESENCE_CODE_199, "CPresConfigListener::InterfaceBucketChange() called when m_pSwitchboard == NULL.");
        goto lDone;
    }

    if (e == NULL)
    {
        hr = E_POINTER;
        XomNtEvent(XEVENT_PRESENCE_CODE_200, "CPresConfigListener::InterfaceBucketChange() called with e == NULL.");
        goto lDone;
    }

    hr = e->get_Interface(&InterfaceChange);
    if (FAILED(hr))
    {
        XomNtEvent(XEVENT_PRESENCE_INFO_7, "CPresConfigListener::InterfaceBucketChange(): could not obtain interface.  hr = 0x%X.", hr);
        goto lDone;
    }

    if (InterfaceChange != Interface_xpserver)
    {
        // NOTE: dont return an error here.  it will cause the change to get rejected, preventing the real owner from handling the change.
        XomNtEvent(XEVENT_PRESENCE_INFO_8, "CPresConfigListener::InterfaceBucketChange(): interface not xpserver -- ignoring.");
        goto lDone;
    }

    pCCtx = new CInterfaceBucketChangeContext(m_pSwitchboard);
    if (pCCtx == NULL)
    {
        hr = E_OUTOFMEMORY;
        XomNtEvent(XEVENT_PRESENCE_INFO_9, "CPresConfigListener::InterfaceBucketChange(): could not create context.");
        goto lDone;
    }

    hr = e->get_Bucket(&(pCCtx->m_dwBucket));
    if (FAILED(hr))
    {
        XomNtEvent(XEVENT_PRESENCE_INFO_10, "CPresConfigListener::InterfaceBucketChange(): could not obtain bucket id.  hr = 0x%X.", hr);
        goto lDone;
    }

    hr = e->get_ValueNew(&ibsNew);
    if (FAILED(hr))
    {
        XomNtEvent(XEVENT_PRESENCE_INFO_11, "CPresConfigListener::InterfaceBucketChange(): could not obtain new value.  hr = 0x%X.", hr);
        goto lDone;
    }

    hr = ibsNew->get_CurrentServerName( &(pCCtx->m_bsCurrentServer) );
    if( FAILED( hr ) )
    {
        XomNtEvent(XEVENT_PRESENCE_INFO_12, "CPresConfigListener::InterfaceBucketChange(): could not obtain current server name.  hr = 0x%X.", hr);
        goto lDone;
    }

    hr = ibsNew->get_NextServerName( &(pCCtx->m_bsNextServer) );
    if( FAILED( hr ) )
    {
        XomNtEvent(XEVENT_PRESENCE_INFO_13, "CPresConfigListener::InterfaceBucketChange(): could not obtain next server name.  hr = 0x%X.", hr);
        goto lDone;
    }

    hr = ibsNew->get_NextServerStart( &(pCCtx->m_dtStart) );
    if( FAILED( hr ) )
    {
        XomNtEvent(XEVENT_PRESENCE_INFO_14, "CPresConfigListener::InterfaceBucketChange(): could not obtain next server start time.  hr = 0x%X.", hr);
        goto lDone;
    }

    hr = m_pSwitchboard->PostCompletion(pCCtx);
    if( FAILED( hr ) )
    {
        XomNtEvent(XEVENT_PRESENCE_INFO_15, "CPresConfigListener::InterfaceBucketChange(): could not post completion.  hr = 0x%X.", hr);
        goto lDone;
    }


lDone:

    if (FAILED(hr))
    {
        SAFE_RELEASE(pCCtx);
    }

    return hr;
}

HRESULT __stdcall CPresConfigListener::ServerListChange(
    struct IServerListChangeEventArgs * e )
{
    HRESULT hr = S_OK;
    CComBSTR InterfaceChange = Interface_None;
    CServerListChangeContext *pCCtx = NULL;
    BSTR* pbstr = NULL;
    SAFEARRAY* pArray = NULL;

    if (m_pSwitchboard == NULL)
    {
        hr = E_UNEXPECTED;
        XomNtEvent(XEVENT_PRESENCE_CODE_489, "CPresConfigListener::ServerListChange() called when m_pSwitchboard == NULL.");
        goto lDone;
    }

    if (e == NULL)
    {
        hr = E_POINTER;
        XomNtEvent(XEVENT_PRESENCE_CODE_490, "CPresConfigListener::ServerListChange() called with e == NULL.");
        goto lDone;
    }

    hr = e->get_Interface(&InterfaceChange);
    if (FAILED(hr))
    {
        XomNtEvent(XEVENT_PRESENCE_INFO_22, "CPresConfigListener::ServerListChange(): could not obtain interface.  hr = 0x%X.", hr);
        goto lDone;
    }

    if (InterfaceChange != Interface_xpserver)
    {
        // NOTE: dont return an error here.  it will cause the change to get rejected, preventing the real owner from handling the change.
        XomNtEvent(XEVENT_PRESENCE_INFO_23, "CPresConfigListener::ServerListChange(): interface not xpserver -- ignoring.");
        goto lDone;
    }

    pCCtx = new CServerListChangeContext(m_pSwitchboard);
    if (pCCtx == NULL)
    {
        hr = E_OUTOFMEMORY;
        XomNtEvent(XEVENT_PRESENCE_INFO_24, "CPresConfigListener::ServerListChange(): could not create context.");
        goto lDone;
    }

    hr = e->get_ValueNew(&pArray);
    if (FAILED(hr))
    {
        XomNtEvent(XEVENT_PRESENCE_INFO_25, "CPresConfigListener::ServerListChange(): could not obtain new server list.  hr = 0x%X.", hr);
        goto lDone;
    }

    hr = SafeArrayAccessData( pArray, (void**) &pbstr );
    if( FAILED( hr ) )
    {
        XomNtEvent( XEVENT_PRESENCE_CONFIG_92, "CPresenceConfig::ServerListChange() - SafeArrayAccessData failed, hr=0x%08X", hr );
        goto lDone;
    }

    pCCtx->m_cServers = pArray->rgsabound->cElements;
    pCCtx->m_rgbsServers = new CComBSTR[pCCtx->m_cServers];
    if (pCCtx->m_rgbsServers == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    for( DWORD iServer = 0; iServer < pArray->rgsabound->cElements; iServer++ )
    {
        pCCtx->m_rgbsServers[iServer] = CComBSTR(pbstr[iServer]);
    }

    SafeArrayUnaccessData( pArray );
    pbstr = NULL;

    SafeArrayDestroy( pArray );
    pArray = NULL;

    m_pSwitchboard->PostCompletion(pCCtx);

lDone:
    if( NULL != pbstr )
    {
        SafeArrayUnaccessData( pArray );
        pbstr = NULL;
    }
    if( NULL != pArray )
    {
        SafeArrayDestroy( pArray );
        pArray = NULL;
    }

    if (FAILED(hr))
    {
        SAFE_RELEASE(pCCtx);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\inh\pconn.cpp ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#include "stdafx.h"

#define PCONN_HELLO_DESC "XPServer"
#define PCONN_HELLO_DESC_LEN sizeof(PCONN_HELLO_DESC)

/*****************************************************************************

CompareUsersByPresDest

Compare user pointers by destination presence server.  
Used by the bsearch and qsort libary routines.

*****************************************************************************/
static int __cdecl CompareUsersByPresDest( const void *pCLeft, const void *pCRight )
{
    int iDestLeft = (int) g_CPresCfg.MapUserToPresSrv(*((const QWORD *)pCLeft), FALSE);
    int iDestRight = (int) g_CPresCfg.MapUserToPresSrv(*(const QWORD *)pCRight, FALSE);

    if (iDestLeft != iDestRight)
    {
        // sort by destination first.
        return iDestRight - iDestLeft;
    }
    else
    {
        // secondary sort on client type.
        return GET_PUID_CLIENT_TYPE(*((const QWORD *)pCRight)) - GET_PUID_CLIENT_TYPE(*((const QWORD *)pCLeft));
    }
}

/*****************************************************************************

CompareUsersByAltPresDest

Compare user pointers by alternate destination presence server.  
Used by the bsearch and qsort libary routines.

*****************************************************************************/
static int __cdecl CompareUsersByAltPresDest( const void *pCLeft, const void *pCRight )
{
    int iDestLeft = (int) g_CPresCfg.MapUserToPresSrv(*((const QWORD *)pCLeft), TRUE);
    int iDestRight = (int) g_CPresCfg.MapUserToPresSrv(*(const QWORD *)pCRight, TRUE);

    if (iDestLeft != iDestRight)
    {
        // sort by destination first.
        return iDestRight - iDestLeft;
    }
    else
    {
        // secondary sort on client type.
        return GET_PUID_CLIENT_TYPE(*((const QWORD *)pCRight)) - GET_PUID_CLIENT_TYPE(*((const QWORD *)pCLeft));
    }
}


/*****************************************************************************

CompareRecipientResultsByPresDest

Compare user pointers by destination notification server.  
Used by the bsearch and qsort libary routines.

*****************************************************************************/
static int __cdecl CompareRecipientResultsByPresDest( const void *pCLeft, const void *pCRight )
{
    int iDestLeft = (int) g_CPresCfg.MapUserToPresSrv(((const Q_RECIPIENT_RESULT *)pCLeft)->qwUserID, FALSE);
    int iDestRight = (int) g_CPresCfg.MapUserToPresSrv(((const Q_RECIPIENT_RESULT *)pCRight)->qwUserID, FALSE);

    return iDestRight - iDestLeft;
}

/*****************************************************************************

CompareRecipientResultsByAltPresDest

Compare user pointers by alternate destination notification server.  
Used by the bsearch and qsort libary routines.

*****************************************************************************/
static int __cdecl CompareRecipientResultsByAltPresDest( const void *pCLeft, const void *pCRight )
{
    int iDestLeft = (int) g_CPresCfg.MapUserToPresSrv(((const Q_RECIPIENT_RESULT *)pCLeft)->qwUserID, TRUE);
    int iDestRight = (int) g_CPresCfg.MapUserToPresSrv(((const Q_RECIPIENT_RESULT *)pCRight)->qwUserID, TRUE);

    return iDestRight - iDestLeft;
}

/*****************************************************************************

SortRecipientResultsByDestination

Sort an array of users by destination machine

*****************************************************************************/
void SortRecipientResultsByDestination(DWORD cUsers, Q_RECIPIENT_RESULT* pInfo, BOOL fAlt = FALSE)
{
    if (!fAlt)
    {
        qsort( pInfo, cUsers, sizeof(*pInfo), CompareRecipientResultsByPresDest);
    }
    else
    {
        qsort( pInfo, cUsers, sizeof(*pInfo), CompareRecipientResultsByAltPresDest);
    }
}


/*****************************************************************************

CompareRecipientFriendInfoByPresDest

Compare user pointers by destination notification server.  
Used by the bsearch and qsort libary routines.

*****************************************************************************/
static int __cdecl CompareRecipientFriendInfoByPresDest( const void *pCLeft, const void *pCRight )
{
    int iDestLeft = (int) g_CPresCfg.MapUserToPresSrv(((const RecipientFriendInfo *)pCLeft)->qwUserID, FALSE);
    int iDestRight = (int) g_CPresCfg.MapUserToPresSrv(((const RecipientFriendInfo *)pCRight)->qwUserID, FALSE);

    return iDestRight - iDestLeft;
}

/*****************************************************************************

CompareRecipientFriendInfoByAltPresDest

Compare user pointers by alternative destination notification server.  
Used by the bsearch and qsort libary routines.

*****************************************************************************/
static int __cdecl CompareRecipientFriendInfoByAltPresDest( const void *pCLeft, const void *pCRight )
{
    int iDestLeft = (int) g_CPresCfg.MapUserToPresSrv(((const RecipientFriendInfo *)pCLeft)->qwUserID, TRUE);
    int iDestRight = (int) g_CPresCfg.MapUserToPresSrv(((const RecipientFriendInfo *)pCRight)->qwUserID, TRUE);

    return iDestRight - iDestLeft;
}

/*****************************************************************************

SortRecipientFriendInfoByDestination

Sort an array of users by destination machine

*****************************************************************************/
void SortRecipientFriendInfoByDestination( DWORD cUsers, RecipientFriendInfo* pInfo, BOOL fAlt = FALSE)
{
    if (!fAlt)
    {
        qsort( pInfo, cUsers, sizeof(*pInfo), CompareRecipientFriendInfoByPresDest );
    }
    else
    {
        qsort( pInfo, cUsers, sizeof(*pInfo), CompareRecipientFriendInfoByAltPresDest );
    }
}

/*****************************************************************************

CPresConnection::CPresConnection

Constructor

*****************************************************************************/
CPresConnection::CPresConnection(DWORD dwIndex) :
    CPresBaseConnection(10240),
    m_fSeenHello(FALSE),
    m_dwPresServerIndex(dwIndex),
    m_dwSeqNum(1),
    m_dwLastSeqNum((DWORD)~0),
    m_pCallback(NULL),
    m_pCSwitchboard(NULL),
    m_pCCtx(NULL),
    m_pCSendMessageListHead(NULL),
    m_pCSendMessageListTail(NULL)
{
    memset(&m_sa, 0, sizeof(sockaddr_in));
    m_pszDesc[0] = '\0';
    g_Counters.IncrementValue32(XPPERF_SERVER_PRES_CONNECTIONS_COUNTER, 1);
}

/*****************************************************************************

CPresConnection::~CPresConnection

Destructor

*****************************************************************************/
CPresConnection::~CPresConnection()
{
    SAFE_RELEASE(m_pCSwitchboard);

    g_Counters.DecrementValue32(XPPERF_SERVER_PRES_CONNECTIONS_COUNTER, 1);
    g_Counters.IncrementValue32(XPPERF_SERVER_DROPPED_PRES_CONNECTIONS_COUNTER, 1);
    g_Counters.IncrementValue32(XPPERF_SERVER_DROPPED_PRES_CONNECTIONS_RATE, 1);
}

/*****************************************************************************

CPresConnection::InitAccept

Initializer, must be called before first use.

*****************************************************************************/
HRESULT CPresConnection::InitAccept(
    CServerSocket *pSocket,
    CPresConnectionCallback *pCallback,
    CSwitchboard *pCSwitchboard)
{
    HRESULT hr = S_OK;

    // Validate arguments
    if((NULL == pSocket) || (NULL == pCallback))
    {
        return E_INVALIDARG;
    }
 
    // Set references
    XOMASSERT(NULL == m_pCallback);
    m_pCallback = pCallback;

    XOMASSERT(NULL == m_pCSwitchboard);
    m_pCSwitchboard = pCSwitchboard;
    pCSwitchboard->AddRef();
    
    hr = pSocket->GetPeerAddress( &m_sa );
    if (FAILED(hr))
    {
        goto lDone;
    }

    hr = Attach(pSocket);
    if (FAILED(hr))
    {
        goto lDone;
    }

    hr = SendMsgHello();
    if (FAILED(hr))
    {
        goto lDone;
    }
    
lDone:
    return hr;
}

/*****************************************************************************

CPresConnection::InitConnect

Initializer for new connections, must be called before first use.

*****************************************************************************/
HRESULT CPresConnection::InitConnect(
    sockaddr_in *pAddr,
    CCompletionPort *pCompPort,
    CPresConnectionCallback *pCallback,
    CSwitchboard *pCSwitchboard)
{
    HRESULT hr = S_OK;
    CServerSocket *pSock = NULL;

    // Validate arguments
    if((NULL == pCompPort) || 
       (NULL == pAddr) || 
       (NULL == pCallback))
    {
        hr = E_INVALIDARG;
        goto lDone;
    }
    
    // Set references
    XOMASSERT(NULL == m_pCallback);
    m_pCallback = pCallback;

    XOMASSERT(NULL == m_pCSwitchboard);
    m_pCSwitchboard = pCSwitchboard;
    pCSwitchboard->AddRef();

    // Store off the destination address for future use
    memcpy(&m_sa, pAddr, sizeof(sockaddr_in));

    // Create a new TCP socket for use by this connection
    hr = CServerSocket::CreateInstance(&pSock, pCompPort, pCompPort);
    if(FAILED(hr))
    {
        XomNtEvent(XEVENT_PRESENCE_CODE_129, "CPresConnection::Init failed to create CServerSocket instance (%X)", hr);
        goto lDone;
    }

    // Bind it to a local address
    sockaddr_in saBind;
    memset(&saBind, 0, sizeof(saBind));

    saBind.sin_family = AF_INET;

    hr = pSock->Init( IPPROTO_TCP, &saBind, TRUE );
    if( FAILED( hr ) )
    {
        XomNtEvent(XEVENT_PRESENCE_CODE_130, "CPresConnection::Init failed to init CServerSocket object (%X)", hr);
        goto lDone;
    }
    
    // Start the connecting process
    hr = AttachAndConnect(pSock, &m_sa);
    if(FAILED(hr))
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_131,
            "CPresConnection::Init failed to initiate connect for server @ %s:%d (%X)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port ),
            hr);
        goto lDone;
    }

lDone:

    SAFE_RELEASE( pSock );
    
    return hr;
}

/*****************************************************************************

CPresConnection::SendMsgHello

Sends a Hello message.

*****************************************************************************/
HRESULT CPresConnection::SendMsgHello() 
{
    HRESULT hr = S_OK;
    P_HELLO_MSG *pHelloMsg = NULL;
    CTCPCntVarBuffer *pCHelloBuffer = NULL;

    if (m_dwPresServerIndex == g_CPresCfg.GetMyPresServerIndex())
    {
        // NOTE: When this object connects, it will create a buddy object representing the receive connection for any
        // sends we do on this one.  Since this is the local connection, we dont actually send anything on it -- we just
        // loopback to this same object.  However, when the buddy PConn object gets created, it will send us a hello,
        // because it's m_dwPresServerIndex is equal to -1 (all receive PConn objects have this).  So by not sending
        // a hello message here, we accomplish two things.  First, we dont run into duplicate hellos, since everything
        // we send on this object gets reflected back at us.  And, second, we never initialize the buddy to this object,
        // so anything else that might get sent there will fail.
        goto lDone;
    }

    // Send a hello message to the Q server (will be sent once we connect)
    pCHelloBuffer = g_pBufferPool->GetBuffer(sizeof(P_HELLO_MSG) + PCONN_HELLO_DESC_LEN);
    if (pCHelloBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pHelloMsg = (P_HELLO_MSG *) pCHelloBuffer->GetBuffer();

    pHelloMsg->dwMsgType = PMSG_HELLO;
    pHelloMsg->dwSeqNum = 0;
    pHelloMsg->sgaddr = sgaddrIgnore;
    pHelloMsg->dwProtocolVersion = CURRENT_XQPROTOCOL_VER;
    memcpy((char *)(pHelloMsg + 1), PCONN_HELLO_DESC, PCONN_HELLO_DESC_LEN);
    pHelloMsg->dwMsgLen = sizeof(P_HELLO_MSG) + PCONN_HELLO_DESC_LEN - sizeof(BASE_MSG_HEADER);

    hr = Send(pCHelloBuffer);
    if(FAILED(hr))
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_132,
            "CPresConnection::Init failed to send HELLO to server @ %s:%d (%X)", 
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port ),
            hr);
        goto lDone;
    }

lDone:

    SAFE_RELEASE(pCHelloBuffer);

    return hr;
}


HRESULT CPresConnection::SendPreMigrationMessage(QWORD qwUserID)
{
    HRESULT hr = S_OK;
    CTCPCntVarBuffer *pCBuffer = NULL;
    P_USER_PRE_MIGRATION_MSG *pMsg = NULL;

    // Make sure we have a connection to send to
    if (!IsConnected())
    {
        hr = HRESULT_FROM_WIN32(WSAENOTCONN);
        goto lDone;
    }

    // Allocate a buffer object
    pCBuffer = g_pBufferPool->GetBuffer(sizeof(P_USER_PRE_MIGRATION_MSG));
    if (pCBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pMsg = (P_USER_PRE_MIGRATION_MSG *)pCBuffer->GetBuffer();

    pMsg->dwMsgType = PMSG_USER_PRE_MIGRATION;
    pMsg->dwMsgLen = sizeof(P_USER_PRE_MIGRATION_MSG) - sizeof(BASE_MSG_HEADER);
    pMsg->dwSeqNum = ++m_dwSeqNum;
    pMsg->sgaddr = sgaddrIgnore;
    pMsg->qwUserID = qwUserID;

    // Send the message
    hr = Send(pCBuffer);
    if(FAILED(hr))
    {
        goto lDone;
    }

lDone:

    SAFE_RELEASE(pCBuffer);

    return hr;
}

HRESULT CPresConnection::SendFullMigrationMessage(CPresence *pCPresence)
{
    HRESULT hr = S_OK;
    CTCPCntVarBuffer *pCBuffer = NULL;
    P_USER_FULL_MIGRATION_MSG *pMsg = NULL;

    // Make sure we have a connection to send to
    if (!IsConnected())
    {
        hr = HRESULT_FROM_WIN32(WSAENOTCONN);
        goto lDone;
    }

    // calculate max size
    DWORD cbSize = 
        sizeof(P_USER_FULL_MIGRATION_MSG) + 
        sizeof(P_ONLINE_PRESENCE_RECORD_MSG) +
        (sizeof(QWORD) * MAX_BUDDIES) +
        (sizeof(QWORD) * MAX_BLOCKS) +
        (sizeof(QWORD) * MAX_PEER_SUBSCRIPTIONS) +
        (sizeof(QWORD) * XONLINE_MAX_MESSAGE_RECIPIENTS) +
        (sizeof(QWORD) * MAX_WATCHES) +
        MAX_TITLE_STATE_BYTES + g_CPresCfg.GetMaxRichPresenceBytes();

    for (DWORD iQType = 0; iQType < PQUEUE_NUM_TYPES; iQType++)
    {
        // NOTE: using MAX_TRANSIENT_MESSAGES for each queue type for lack of a better value.
        cbSize += (MAX_TRANSIENT_MESSAGES * (sizeof(P_QUEUE_ITEM_MSG) + g_QSchemas[iQType].dwMaxDataSize));
    }

    // Allocate a buffer object
    pCBuffer = g_pBufferPool->GetBuffer(cbSize);
    if (pCBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pMsg = (P_USER_FULL_MIGRATION_MSG *)pCBuffer->GetBuffer();

    pMsg->dwMsgType = PMSG_USER_FULL_MIGRATION;
    pMsg->dwSeqNum = ++m_dwSeqNum;
    pMsg->sgaddr = sgaddrIgnore;

    hr = pCPresence->Serialize(pMsg, &cbSize);
    if (FAILED(hr))
    {
        goto lDone;
    }

    pCBuffer->Resize(cbSize);
    pMsg->dwMsgLen = cbSize - sizeof(BASE_MSG_HEADER);    
    pMsg->dwNow = GetTickCount();

    // Send the message
    hr = Send(pCBuffer);
    if(FAILED(hr))
    {
        goto lDone;
    }

lDone:

    SAFE_RELEASE(pCBuffer);

    return hr;
}



/*****************************************************************************

CPresConnection::SendMsgAnnounce

Sends an Annouce message.

*****************************************************************************/
HRESULT CPresConnection::SendMsgAnnounce(
    QWORD qwDestUserID, 
    DWORD dwTitleID,
    LPCSTR pszGamerTag,
    DWORD cSourceUserIDs, 
    const QWORD *rgqwSourceUserIDs)
{
    HRESULT hr = S_OK;
    DWORD cbMsg = 0;
    CTCPCntVarBuffer *pCAnnounceBuffer = NULL;
    BYTE *pbWork = NULL;
    P_ANNOUNCE_MSG *pMsgAnnounce = NULL;

    // Make sure we have a connection to send to
    if (!IsConnected())
    {
        hr = HRESULT_FROM_WIN32(WSAENOTCONN);
        goto lDone;
    }

    // Calculate the total message size
    cbMsg = sizeof(P_ANNOUNCE_MSG) + (cSourceUserIDs * sizeof(QWORD));

    // Allocate a buffer object
    pCAnnounceBuffer = g_pBufferPool->GetBuffer(cbMsg);
    if (pCAnnounceBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Fill in the base message fields
    pbWork = pCAnnounceBuffer->GetBuffer();
    pMsgAnnounce = (P_ANNOUNCE_MSG *)pbWork;
    pbWork += sizeof(P_ANNOUNCE_MSG);

    pMsgAnnounce->dwMsgType = PMSG_ANNOUNCE;
    pMsgAnnounce->dwMsgLen = cbMsg - sizeof(BASE_MSG_HEADER);
    pMsgAnnounce->dwSeqNum = ++m_dwSeqNum;
    pMsgAnnounce->sgaddr = sgaddrIgnore;
    pMsgAnnounce->qwDestUserID = qwDestUserID;
    pMsgAnnounce->dwTitleID = dwTitleID;
    memcpy(pMsgAnnounce->szGamerTag, pszGamerTag, XONLINE_GAMERTAG_SIZE);
    pMsgAnnounce->fAlert = FALSE;
    pMsgAnnounce->cSourceUserIDs = (WORD) cSourceUserIDs;

    // Fill in the source user ids
    memcpy(pbWork, rgqwSourceUserIDs, cSourceUserIDs * sizeof(QWORD));  

    // Send the message
    hr = Send(pCAnnounceBuffer);
    if(FAILED(hr))
    {
        goto lDone;
    }

lDone:

    SAFE_RELEASE(pCAnnounceBuffer);

    return hr;
}

/*****************************************************************************

CPresConnection::SendMsgSubscribed

Sends a Subscribed message.

*****************************************************************************/
HRESULT CPresConnection::SendMsgSubscribed(
    QWORD qwDestUserID, 
    DWORD cSourceUserIDs, 
    const QWORD *rgqwSourceUserIDs)
{
    HRESULT hr = S_OK;
    DWORD cbMsg = 0;
    CTCPCntVarBuffer *pCSubscribedBuffer = NULL;
    BYTE *pbWork = NULL;
    P_SUBSCRIBED_MSG *pMsgSubscribed = NULL;

    // Make sure we have a connection to send to
    if (!IsConnected())
    {
        hr = HRESULT_FROM_WIN32(WSAENOTCONN);
        goto lDone;
    }

    // Calculate the total message size
    cbMsg = sizeof(P_SUBSCRIBED_MSG) + (cSourceUserIDs * sizeof(QWORD));

    // Allocate a buffer object
    pCSubscribedBuffer = g_pBufferPool->GetBuffer(cbMsg);
    if (pCSubscribedBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Fill in the base message fields
    pbWork = pCSubscribedBuffer->GetBuffer();
    pMsgSubscribed = (P_SUBSCRIBED_MSG *)pbWork;
    pbWork += sizeof(P_SUBSCRIBED_MSG);

    pMsgSubscribed->dwMsgType = PMSG_SUBSCRIBED;
    pMsgSubscribed->dwMsgLen = cbMsg - sizeof(BASE_MSG_HEADER);
    pMsgSubscribed->dwSeqNum = ++m_dwSeqNum;
    pMsgSubscribed->sgaddr = sgaddrIgnore;
    pMsgSubscribed->qwDestUserID = qwDestUserID;
    pMsgSubscribed->cSourceUserIDs = (WORD) cSourceUserIDs;

    // Fill in the source user ids
    memcpy(pbWork, rgqwSourceUserIDs, cSourceUserIDs * sizeof(QWORD));  

    // Send the message
    hr = Send(pCSubscribedBuffer);
    if(FAILED(hr))
    {
        goto lDone;
    }

lDone:

    SAFE_RELEASE(pCSubscribedBuffer);

    return hr;
}

/*****************************************************************************

CPresConnection::SendMsgUnsubscribe

Sends an Unsubscribe message.

*****************************************************************************/
HRESULT CPresConnection::SendMsgUnsubscribe(
    QWORD qwSourceUserID, 
    DWORD cDestUserIDs, 
    const QWORD *rgqwDestUserIDs)
{
    HRESULT hr = S_OK;
    DWORD cbMsg = 0;
    CTCPCntVarBuffer *pCUnsubscribeBuffer = NULL;
    BYTE *pbWork = NULL;
    P_UNSUBSCRIBE_MSG *pMsgUnsubscribe = NULL;

    // Make sure we have a connection to send to
    if (!IsConnected())
    {
        hr = HRESULT_FROM_WIN32(WSAENOTCONN);
        goto lDone;
    }

    // Calculate the total message size
    cbMsg = sizeof(P_UNSUBSCRIBE_MSG) + (cDestUserIDs * sizeof(QWORD));

    // Allocate a buffer object
    pCUnsubscribeBuffer = g_pBufferPool->GetBuffer(cbMsg);
    if (pCUnsubscribeBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Fill in the base message fields
    pbWork = pCUnsubscribeBuffer->GetBuffer();
    pMsgUnsubscribe = (P_UNSUBSCRIBE_MSG *)pbWork;
    pbWork += sizeof(P_UNSUBSCRIBE_MSG);

    pMsgUnsubscribe->dwMsgType = PMSG_UNSUBSCRIBE;
    pMsgUnsubscribe->dwMsgLen = cbMsg - sizeof(BASE_MSG_HEADER);
    pMsgUnsubscribe->dwSeqNum = ++m_dwSeqNum;
    pMsgUnsubscribe->sgaddr = sgaddrIgnore;
    pMsgUnsubscribe->qwSourceUserID = qwSourceUserID;
    pMsgUnsubscribe->cDestUserIDs = (WORD) cDestUserIDs;

    // Fill in the source user ids
    memcpy(pbWork, rgqwDestUserIDs, cDestUserIDs * sizeof(QWORD));  

    // Send the message
    hr = Send(pCUnsubscribeBuffer);
    if(FAILED(hr))
    {
        goto lDone;
    }

lDone:

    SAFE_RELEASE(pCUnsubscribeBuffer);

    return hr;
}

/*****************************************************************************

CPresConnection::SendMsgAdded

Sends an Added message.

*****************************************************************************/
HRESULT CPresConnection::SendMsgAdded(
    QWORD qwUserID,
    QWORD qwBuddyID,
    DWORD dwVersion,
    WORD cbBuddyAcctName,
    LPCSTR szBuddyAcctName)
{
    HRESULT hr = S_OK;
    DWORD cbMsg = 0;
    CTCPCntVarBuffer *pCAddedBuffer = NULL;
    BYTE *pbWork = NULL;
    P_ADDED_MSG *pMsgAdded = NULL;

    // Make sure we have a connection to send to
    if (!IsConnected())
    {
        hr = HRESULT_FROM_WIN32(WSAENOTCONN);
        goto lDone;
    }

    // Calculate the total message size
    cbMsg = sizeof(P_ADDED_MSG) + cbBuddyAcctName;

    // Allocate a buffer object
    pCAddedBuffer = g_pBufferPool->GetBuffer(cbMsg);
    if (pCAddedBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Fill in the base message fields
    pbWork = pCAddedBuffer->GetBuffer();
    pMsgAdded = (P_ADDED_MSG *)pbWork;
    pbWork += sizeof(P_ADDED_MSG);

    pMsgAdded->dwMsgType = PMSG_ADDED;
    pMsgAdded->dwMsgLen = cbMsg - sizeof(BASE_MSG_HEADER);
    pMsgAdded->dwSeqNum = ++m_dwSeqNum;
    pMsgAdded->sgaddr = sgaddrIgnore;
    pMsgAdded->qwUserID = qwUserID;
    pMsgAdded->qwBuddyID = qwBuddyID;
    pMsgAdded->dwVersion = dwVersion;
    pMsgAdded->cbBuddyAcctName = cbBuddyAcctName;

    // Fill in the buddy account name
    memcpy(pbWork, szBuddyAcctName, cbBuddyAcctName);  

    // Send the message
    hr = Send(pCAddedBuffer);
    if(FAILED(hr))
    {
        goto lDone;
    }

lDone:

    SAFE_RELEASE(pCAddedBuffer);

    return hr;
}

/*****************************************************************************

CPresConnection::SendMsgAccepted

Sends an Accepted message.

*****************************************************************************/
HRESULT CPresConnection::SendMsgAccepted(
    QWORD qwUserID,
    QWORD qwBuddyID,
    DWORD dwVersion,
    WORD cbBuddyAcctName,
    LPCSTR szBuddyAcctName)
{
    HRESULT hr = S_OK;
    DWORD cbMsg = 0;
    CTCPCntVarBuffer *pCAcceptedBuffer = NULL;
    BYTE *pbWork = NULL;
    P_ACCEPTED_MSG *pMsgAccepted = NULL;

    // Make sure we have a connection to send to
    if (!IsConnected())
    {
        hr = HRESULT_FROM_WIN32(WSAENOTCONN);
        goto lDone;
    }

    // Calculate the total message size
    cbMsg = sizeof(P_ACCEPTED_MSG) + cbBuddyAcctName;

    // Allocate a buffer object
    pCAcceptedBuffer = g_pBufferPool->GetBuffer(cbMsg);
    if (pCAcceptedBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Fill in the base message fields
    pbWork = pCAcceptedBuffer->GetBuffer();
    pMsgAccepted = (P_ACCEPTED_MSG *)pbWork;
    pbWork += sizeof(P_ACCEPTED_MSG);

    pMsgAccepted->dwMsgType = PMSG_ACCEPTED;
    pMsgAccepted->dwMsgLen = cbMsg - sizeof(BASE_MSG_HEADER);
    pMsgAccepted->dwSeqNum = ++m_dwSeqNum;
    pMsgAccepted->sgaddr = sgaddrIgnore;
    pMsgAccepted->qwUserID = qwUserID;
    pMsgAccepted->qwBuddyID = qwBuddyID;
    pMsgAccepted->dwVersion = dwVersion;
    pMsgAccepted->cbBuddyAcctName = cbBuddyAcctName;

    // Fill in the buddy account name
    memcpy(pbWork, szBuddyAcctName, cbBuddyAcctName);  

    // Send the message
    hr = Send(pCAcceptedBuffer);
    if(FAILED(hr))
    {
        goto lDone;
    }

lDone:

    SAFE_RELEASE(pCAcceptedBuffer);

    return hr;
}

/*****************************************************************************

CPresConnection::SendMsgRemoved

Sends a Removed message.

*****************************************************************************/
HRESULT CPresConnection::SendMsgRemoved(
    QWORD qwUserID,
    QWORD qwBuddyID,
    DWORD dwVersion)
{
    HRESULT hr = S_OK;
    CTCPCntVarBuffer *pCRemovedBuffer = NULL;
    P_REMOVED_MSG *pMsgRemoved = NULL;

    // Make sure we have a connection to send to
    if (!IsConnected())
    {
        hr = HRESULT_FROM_WIN32(WSAENOTCONN);
        goto lDone;
    }

    // Allocate a buffer object
    pCRemovedBuffer = g_pBufferPool->GetBuffer(sizeof(P_REMOVED_MSG));
    if (pCRemovedBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Fill in the base message fields
    pMsgRemoved = (P_REMOVED_MSG *) pCRemovedBuffer->GetBuffer();

    pMsgRemoved->dwMsgType = PMSG_REMOVED;
    pMsgRemoved->dwMsgLen = sizeof(P_REMOVED_MSG) - sizeof(BASE_MSG_HEADER);
    pMsgRemoved->dwSeqNum = ++m_dwSeqNum;
    pMsgRemoved->sgaddr = sgaddrIgnore;
    pMsgRemoved->qwUserID = qwUserID;
    pMsgRemoved->qwBuddyID = qwBuddyID;
    pMsgRemoved->dwVersion = dwVersion;

    // Send the message
    hr = Send(pCRemovedBuffer);
    if(FAILED(hr))
    {
        goto lDone;
    }

lDone:

    SAFE_RELEASE(pCRemovedBuffer);

    return hr;
}


/*****************************************************************************

CPresConnection::SendMsgInviteAnswer

Sends an Invitation Answer message

*****************************************************************************/
HRESULT CPresConnection::SendMsgInviteAnswer(
    QWORD qwUserID,
    QWORD qwHostID,
    QWORD qwMatchSessionID,
    WORD wAnswer)
{
    HRESULT hr = S_OK;
    CTCPCntVarBuffer *pCInviteAnsBuffer = NULL;
    P_INVITE_ANSWER_MSG *pMsgInviteAns = NULL;

    // Make sure we have a connection to send to
    if (!IsConnected())
    {
        hr = HRESULT_FROM_WIN32(WSAENOTCONN);
        goto lDone;
    }

    // Allocate a buffer object
    pCInviteAnsBuffer = g_pBufferPool->GetBuffer(sizeof(P_INVITE_ANSWER_MSG));
    if (pCInviteAnsBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Fill in the base message fields
    pMsgInviteAns = (P_INVITE_ANSWER_MSG *) pCInviteAnsBuffer->GetBuffer();

    pMsgInviteAns->dwMsgType = PMSG_INVITE_ANSWER;
    pMsgInviteAns->dwMsgLen = sizeof(P_INVITE_ANSWER_MSG) - sizeof(BASE_MSG_HEADER);
    pMsgInviteAns->dwSeqNum = ++m_dwSeqNum;
    pMsgInviteAns->sgaddr = sgaddrIgnore;
    pMsgInviteAns->qwUserID = qwUserID;
    pMsgInviteAns->qwHostID = qwHostID;
    pMsgInviteAns->qwMatchSessionID = qwMatchSessionID;
    pMsgInviteAns->wAnswer = wAnswer;

    // Send the message
    hr = Send(pCInviteAnsBuffer);
    if(FAILED(hr))
    {
        goto lDone;
    }

lDone:

    SAFE_RELEASE(pCInviteAnsBuffer);

    return hr;
}

/*****************************************************************************

CPresConnection::SendAddAffiliates

Sends a AddAffiliates message.

*****************************************************************************/
HRESULT CPresConnection::SendAddAffiliates(
    QWORD qwDestUserID,
    DWORD dwTitleID,
    DWORD dwListFlags,
    WORD cwAffiliates,
    QWORD *pqwAffiliates)
{
    HRESULT hr = S_OK;
    CTCPCntVarBuffer *pBuffer = NULL;

    // Make sure we have a connection to send to
    if (!IsConnected())
    {
        hr = HRESULT_FROM_WIN32(WSAENOTCONN);
        goto lDone;
    }
    
    pBuffer = g_pBufferPool->GetBuffer(sizeof(P_ADD_AFFILIATES_MSG) + (cwAffiliates * sizeof(QWORD)));
    if (pBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Fill in the base message fields
    P_ADD_AFFILIATES_MSG *pMsg = (P_ADD_AFFILIATES_MSG *)pBuffer->GetBuffer();

    pMsg->dwMsgType = PMSG_ADD_AFFILIATES;
    pMsg->dwMsgLen = sizeof(P_ADD_AFFILIATES_MSG) + (cwAffiliates * sizeof(QWORD)) - sizeof(BASE_MSG_HEADER);
    pMsg->dwSeqNum = ++m_dwSeqNum;
    pMsg->sgaddr = sgaddrIgnore;
    pMsg->cwAffiliates = cwAffiliates;
    pMsg->dwListFlag = dwListFlags;
    pMsg->dwTitleID = dwTitleID;
    pMsg->qwSenderID = qwDestUserID;

    memcpy(pMsg + 1, pqwAffiliates, cwAffiliates * sizeof(QWORD));  

    // Send the message
    hr = Send(pBuffer);
    if(FAILED(hr))
    {
        goto lDone;
    }

lDone:

    SAFE_RELEASE(pBuffer);

    return hr;
}

/*****************************************************************************

CPresConnection::SendGetPresenceInfo

Sends a SendGetPresenceInfo message.

*****************************************************************************/
HRESULT CPresConnection::SendGetPresenceInfo(
    DWORD dwContext,
    QWORD qwUserID,
    DWORD cdwPUIDs,
    QWORD * rgPUIDs)
{
    HRESULT hr = S_OK;
    CTCPCntVarBuffer *pBuffer = NULL;

    // Make sure we have a connection to send to
    if (!IsConnected())
    {
        hr = HRESULT_FROM_WIN32(WSAENOTCONN);
        goto lDone;
    }
    
    pBuffer = g_pBufferPool->GetBuffer(sizeof(P_GET_PRESENCE_INFO_MSG) + (cdwPUIDs * sizeof(QWORD)));
    if (pBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Fill in the base message fields
    P_GET_PRESENCE_INFO_MSG *pMsg = (P_GET_PRESENCE_INFO_MSG *)pBuffer->GetBuffer();

    pMsg->dwMsgType = PMSG_GET_PRESENCE_INFO;
    pMsg->dwMsgLen = sizeof(P_GET_PRESENCE_INFO_MSG) + (cdwPUIDs * sizeof(QWORD)) - sizeof(BASE_MSG_HEADER);
    pMsg->dwSeqNum = ++m_dwSeqNum;
    pMsg->sgaddr = sgaddrIgnore;
    pMsg->qwSenderID = qwUserID;
    pMsg->dwContext = dwContext;
    pMsg->cdwUsers = cdwPUIDs;

    memcpy(pMsg + 1, rgPUIDs, cdwPUIDs * sizeof(QWORD));  

    // Send the message
    hr = Send(pBuffer);
    if(FAILED(hr))
    {
        goto lDone;
    }

lDone:

    SAFE_RELEASE(pBuffer);

    return hr;
}

/*****************************************************************************

CPresConnection::SendMsgWatchStart

Sends an Watch Start message.

*****************************************************************************/
HRESULT CPresConnection::SendMsgWatchStart(
    QWORD qwDestUserID, 
    DWORD cSourceUserIDs, 
    const QWORD *rgqwSourceUserIDs)
{
    HRESULT hr = S_OK;
    DWORD cbMsg = 0;
    CTCPCntVarBuffer *pCMsgBuffer = NULL;
    BYTE *pbWork = NULL;
    P_WATCH_START_MSG *pMsg = NULL;

    // Make sure we have a connection to send to
    if (!IsConnected())
    {
        hr = HRESULT_FROM_WIN32(WSAENOTCONN);
        goto lDone;
    }

    // Calculate the total message size
    cbMsg = sizeof(P_WATCH_START_MSG) + (cSourceUserIDs * sizeof(QWORD));

    // Allocate a buffer object
    pCMsgBuffer = g_pBufferPool->GetBuffer(cbMsg);
    if (pCMsgBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Fill in the base message fields
    pbWork = pCMsgBuffer->GetBuffer();
    pMsg = (P_WATCH_START_MSG *)pbWork;
    pbWork += sizeof(P_WATCH_START_MSG);

    pMsg->dwMsgType = PMSG_WATCH_START;
    pMsg->dwMsgLen = cbMsg - sizeof(BASE_MSG_HEADER);
    pMsg->dwSeqNum = ++m_dwSeqNum;
    pMsg->sgaddr = sgaddrIgnore;
    pMsg->qwDestUserID = qwDestUserID;
    pMsg->cSourceUserIDs = (WORD) cSourceUserIDs;

    // Fill in the source user ids
    memcpy(pbWork, rgqwSourceUserIDs, cSourceUserIDs * sizeof(QWORD));  

    // Send the message
    hr = Send(pCMsgBuffer);
    if(FAILED(hr))
    {
        goto lDone;
    }

lDone:

    SAFE_RELEASE(pCMsgBuffer);

    return hr;
}

/*****************************************************************************

CPresConnection::SendMsgWatchStop

Sends an Watch Stop message.

*****************************************************************************/
HRESULT CPresConnection::SendMsgWatchStop(
    QWORD qwDestUserID, 
    DWORD cSourceUserIDs, 
    const QWORD *rgqwSourceUserIDs)
{
    HRESULT hr = S_OK;
    DWORD cbMsg = 0;
    CTCPCntVarBuffer *pCMsgBuffer = NULL;
    BYTE *pbWork = NULL;
    P_WATCH_STOP_MSG *pMsg = NULL;

    // Make sure we have a connection to send to
    if (!IsConnected())
    {
        hr = HRESULT_FROM_WIN32(WSAENOTCONN);
        goto lDone;
    }

    // Calculate the total message size
    cbMsg = sizeof(P_WATCH_STOP_MSG) + (cSourceUserIDs * sizeof(QWORD));

    // Allocate a buffer object
    pCMsgBuffer = g_pBufferPool->GetBuffer(cbMsg);
    if (pCMsgBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Fill in the base message fields
    pbWork = pCMsgBuffer->GetBuffer();
    pMsg = (P_WATCH_STOP_MSG *)pbWork;
    pbWork += sizeof(P_WATCH_STOP_MSG);

    pMsg->dwMsgType = PMSG_WATCH_STOP;
    pMsg->dwMsgLen = cbMsg - sizeof(BASE_MSG_HEADER);
    pMsg->dwSeqNum = ++m_dwSeqNum;
    pMsg->sgaddr = sgaddrIgnore;
    pMsg->qwDestUserID = qwDestUserID;
    pMsg->cSourceUserIDs = (WORD) cSourceUserIDs;

    // Fill in the source user ids
    memcpy(pbWork, rgqwSourceUserIDs, cSourceUserIDs * sizeof(QWORD));  

    // Send the message
    hr = Send(pCMsgBuffer);
    if(FAILED(hr))
    {
        goto lDone;
    }

lDone:

    SAFE_RELEASE(pCMsgBuffer);

    return hr;
}

/*****************************************************************************

CPresConnection::QueuePresence

Sends the given user's presence to the destination buddies' notification 
queues.  Assumes all of the given buddies are on the destination server.

*****************************************************************************/
HRESULT CPresConnection::QueuePresence(
    CPresence *pCPresence, 
    const QWORD *rgqwBuddyIDs, 
    DWORD cBuddyIDs )
{
    HRESULT hr = S_OK;
    DWORD cbMsg = 0;
    CTCPCntVarBuffer *pCAddBuffer = NULL;
    BYTE *pbWork = NULL;
    Q_ADD_MSG *pMsgAdd = NULL;
    P_PRESENCE_ITEM *pPresItem = NULL;

    // Make sure we have a connection to send to
    if (!IsConnected())
    {
        hr = HRESULT_FROM_WIN32(WSAENOTCONN);
        goto lDone;
    }

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Sending Presence: Src=%I64X NumDest=%d Dest0=%I64X Title=%d State=0x%x Match=%I64X TitleStuffLen=%d",
        pCPresence->GetUserID(),
        cBuddyIDs,
        rgqwBuddyIDs[0],
        pCPresence->GetLastSeenTitleID(),
        pCPresence->GetState(),
        pCPresence->GetMatchSessionID(),
        pCPresence->GetTitleStuffLen());

    // Calculate the total message size
    cbMsg = 
        sizeof(Q_ADD_MSG) 
        + (cBuddyIDs * sizeof(QWORD)) 
        + sizeof(P_PRESENCE_ITEM)
        + pCPresence->GetTitleStuffLen();

    // Add the nickname for older titles
    if (pCPresence->GetTitleStuffLen() <= MAX_NOT_TITLE_STATE_BYTES)
    {
       cbMsg += pCPresence->GetNicknameLen();
    }

    // Allocate a buffer object
    pCAddBuffer = g_pBufferPool->GetBuffer(cbMsg);
    if (pCAddBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Fill in the base message fields
    pbWork = pCAddBuffer->GetBuffer();
    pMsgAdd = (Q_ADD_MSG *)pbWork;
    pbWork += sizeof(Q_ADD_MSG);

    pMsgAdd->dwMsgType = QMSG_ADD;
    pMsgAdd->dwMsgLen = cbMsg - sizeof(BASE_MSG_HEADER);
    pMsgAdd->dwSeqNum = ++m_dwSeqNum;
    pMsgAdd->sgaddr = sgaddrIgnore;

    // Fill in the static add fields
    pMsgAdd->wQType = PQUEUE_PRESENCE;
    pMsgAdd->wUserCount = (WORD)cBuddyIDs;

    // Fill in the list of users to add it to
    memcpy(pbWork, rgqwBuddyIDs, cBuddyIDs * sizeof(QWORD));
    pbWork += cBuddyIDs * sizeof(QWORD);

    // Fill in the Presence Item
    pPresItem = (P_PRESENCE_ITEM *) pbWork;
    pbWork += sizeof(P_PRESENCE_ITEM);

    pPresItem->qwBuddyID = pCPresence->GetUserID();
    pPresItem->dwTitleID = pCPresence->GetLastSeenTitleID();
    pPresItem->dwState = pCPresence->GetState();
    pPresItem->qwMatchSessionID = pCPresence->GetMatchSessionID();

    // Split extended title into the old nickname field
    XOMASSERT(MAX_TITLE_STATE_BYTES == (MAX_NOT_TITLE_STATE_BYTES + MAX_NOT_NICKNAME_BYTES));
    if (pCPresence->GetTitleStuffLen() > MAX_NOT_TITLE_STATE_BYTES)
    {
        pPresItem->cbNickname = (WORD) pCPresence->GetTitleStuffLen() - MAX_NOT_TITLE_STATE_BYTES;
        pPresItem->cbTitleStuff = (WORD) MAX_NOT_TITLE_STATE_BYTES;

        // Fill in the nickname into the presence item
        memcpy(pbWork, pCPresence->GetTitleStuff() + MAX_NOT_TITLE_STATE_BYTES, pCPresence->GetTitleStuffLen() - MAX_NOT_TITLE_STATE_BYTES);
        pbWork += (pCPresence->GetTitleStuffLen() - MAX_NOT_TITLE_STATE_BYTES);

        // Fill in the title stuff into the presence item
        memcpy(pbWork, pCPresence->GetTitleStuff(), MAX_NOT_TITLE_STATE_BYTES); 
    }
    else
    {
        pPresItem->cbNickname = (WORD) pCPresence->GetNicknameLen();
        pPresItem->cbTitleStuff = (WORD) pCPresence->GetTitleStuffLen();

        // Fill in the nickname into the presence item
        if (pCPresence->GetNicknameLen() > 0)
        {
            memcpy(pbWork, pCPresence->GetNickname(), pCPresence->GetNicknameLen());
            pbWork += pCPresence->GetNicknameLen();
        }

        // Fill in the title stuff into the presence item
        memcpy(pbWork, pCPresence->GetTitleStuff(), pCPresence->GetTitleStuffLen());
    }


    // Send the message
    hr = Send(pCAddBuffer);
    if(FAILED(hr))
    {
        goto lDone;
    }

lDone:
    if(SUCCEEDED(hr))
    {
        g_Counters.IncrementValue32(XPPERF_SERVER_PRESENCE_NOT_COUNTER, 1);
        g_Counters.IncrementValue32(XPPERF_SERVER_PRESENCE_NOT_RATE, 1);
    }

    SAFE_RELEASE(pCAddBuffer);

    return hr;
}

/*****************************************************************************

CPresConnection::QueuePresenceOffline

Sends the given user's presence to the destination buddies' notification 
queues.  Assumes all of the given buddies are on the destination server.

*****************************************************************************/
HRESULT CPresConnection::QueuePresenceOffline(
    CPresence *pCPresence,
    DWORD cdwDestUsers,
    QWORD *rgqwDestUserIDs)
{
    HRESULT hr = S_OK;
    DWORD cbMsg = 0;
    CTCPCntVarBuffer *pCAddBuffer = NULL;
    BYTE *pbWork = NULL;
    Q_ADD_MSG *pMsgAdd = NULL;
    P_PRESENCE_ITEM *pPresItem = NULL;

    // Make sure we have a connection to send to
    if (!IsConnected())
    {
        hr = HRESULT_FROM_WIN32(WSAENOTCONN);
        goto lDone;
    }

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Sending Presence: Src=%I64X NumDest=%d Dest0=%I64X",
        pCPresence->GetUserID(),
        cdwDestUsers,
        rgqwDestUserIDs[0]);

    // Calculate the total message size
    cbMsg = 
        sizeof(Q_ADD_MSG) 
        + (cdwDestUsers * sizeof(QWORD)) 
        + sizeof(P_PRESENCE_ITEM);

    // Allocate a buffer object
    pCAddBuffer = g_pBufferPool->GetBuffer(cbMsg);
    if (pCAddBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Fill in the base message fields
    pbWork = pCAddBuffer->GetBuffer();
    pMsgAdd = (Q_ADD_MSG *)pbWork;
    pbWork += sizeof(Q_ADD_MSG);

    pMsgAdd->dwMsgType = QMSG_ADD;
    pMsgAdd->dwMsgLen = cbMsg - sizeof(BASE_MSG_HEADER);
    pMsgAdd->dwSeqNum = ++m_dwSeqNum;
    pMsgAdd->sgaddr = sgaddrIgnore;

    // Fill in the static add fields
    pMsgAdd->wQType = PQUEUE_PRESENCE;
    pMsgAdd->wUserCount = (WORD)cdwDestUsers;

    // Fill in the list of users to add it to
    memcpy(pbWork, rgqwDestUserIDs, cdwDestUsers * sizeof(QWORD));
    pbWork += cdwDestUsers * sizeof(QWORD);

    // Fill in the Presence Item
    pPresItem = (P_PRESENCE_ITEM *) pbWork;
    pbWork += sizeof(P_PRESENCE_ITEM);

    pPresItem->qwBuddyID = pCPresence->GetUserID();
    pPresItem->dwTitleID = 0;
    pPresItem->dwState = 0;
    pPresItem->qwMatchSessionID = 0;
    pPresItem->cbNickname = 0;
    pPresItem->cbTitleStuff = 0;

    // Send the message
    hr = Send(pCAddBuffer);
    if(FAILED(hr))
    {
        goto lDone;
    }

lDone:
    if(SUCCEEDED(hr))
    {
        g_Counters.IncrementValue32(XPPERF_SERVER_PRESENCE_NOT_COUNTER, 1);
        g_Counters.IncrementValue32(XPPERF_SERVER_PRESENCE_NOT_RATE, 1);
    }

    SAFE_RELEASE(pCAddBuffer);

    return hr;
}

/*****************************************************************************

CPresConnection::QueueListChange

Sends a list change notificatin to the given user's notification queue.  
Assumes they are on the destination server.

*****************************************************************************/
HRESULT CPresConnection::QueueListChange(
    QWORD qwUserID,
    DWORD dwVersion,
    QWORD qwTargetID,
    WORD wOperationID,
    HRESULT hrOp,
    WORD cbTargetAcctName,
    LPCSTR szTargetAcctName)
{
    HRESULT hr = S_OK;
    DWORD cbMsg = 0;
    CTCPCntVarBuffer *pCAddBuffer = NULL;
    BYTE *pbWork = NULL;
    Q_ADD_MSG *pMsgAdd = NULL;
    P_LIST_CHANGE_ITEM *pListChangeItem = NULL;

    // Make sure we have a connection to send to
    if (!IsConnected())
    {
        hr = HRESULT_FROM_WIN32(WSAENOTCONN);
        goto lDone;
    }

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Sending List Change: User=%I64X Ver=%d Target=%I64X Op=%d hr=0x%x",
        qwUserID,
        dwVersion,
        qwTargetID,
        wOperationID,
        hrOp);

    // Make sure the destination user is non-zero
    if (0 == qwUserID)
    {
        hr = S_OK; // Ignore
        goto lDone;
    }

    // Calculate the total message size
    cbMsg = 
        sizeof(Q_ADD_MSG) 
        + (sizeof(QWORD)) 
        + sizeof(P_LIST_CHANGE_ITEM) 
        + cbTargetAcctName;

    // Allocate a buffer object
    pCAddBuffer = g_pBufferPool->GetBuffer(cbMsg);
    if (pCAddBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Fill in the base message fields
    pbWork = pCAddBuffer->GetBuffer();
    pMsgAdd = (Q_ADD_MSG *)pbWork;
    pbWork += sizeof(Q_ADD_MSG);

    pMsgAdd->dwMsgType = QMSG_ADD;
    pMsgAdd->dwMsgLen = cbMsg - sizeof(BASE_MSG_HEADER);
    pMsgAdd->dwSeqNum = ++m_dwSeqNum;
    pMsgAdd->sgaddr = sgaddrIgnore;

    // Fill in the static add fields
    if (wOperationID != PLIST_BUDDY_ADDED)
    {
        pMsgAdd->wQType = PQUEUE_LIST_CHANGE;
    }
    else
    {
        // Buddy requests from others go into a different queue
        pMsgAdd->wQType = PQUEUE_BUDDY_REQ;
    }
    pMsgAdd->wUserCount = 1;

    // Fill in the list of users to add it to
    memcpy(pbWork, &qwUserID, sizeof(QWORD));
    pbWork += sizeof(QWORD);

    // Fill in the Presence Item
    pListChangeItem = (P_LIST_CHANGE_ITEM *) pbWork;
    pbWork += sizeof(P_LIST_CHANGE_ITEM);

    pListChangeItem->dwListVersion = dwVersion;
    pListChangeItem->qwTargetID = qwTargetID;
    pListChangeItem->wOperationID = wOperationID;
    pListChangeItem->hr = hrOp;
    pListChangeItem->cbTargetAcctName = cbTargetAcctName;

    // Fill in the account name into the presence item
    memcpy(pbWork, szTargetAcctName, cbTargetAcctName);

    // Send the message
    hr = Send(pCAddBuffer);
    if(FAILED(hr))
    {
        goto lDone;
    }

lDone:
    if(SUCCEEDED(hr))
    {
        g_Counters.IncrementValue32(XPPERF_SERVER_LIST_CHANGE_NOT_COUNTER, 1);
        g_Counters.IncrementValue32(XPPERF_SERVER_LIST_CHANGE_NOT_RATE, 1);
    }

    SAFE_RELEASE(pCAddBuffer);

    return hr;
}

/*****************************************************************************

CPresConnection::QueueDeleteMessage

Delete a message for a given user.
Assumes the user is on the destination server.

*****************************************************************************/
HRESULT CPresConnection::QueueDeleteMessage(
    QWORD qwUserID,
    DWORD dwMessageID,
    BOOL fBlockSender)
{
    HRESULT hr = S_OK;
    CTCPCntVarBuffer *pCBuffer = NULL;
    Q_DELETE_MESSAGE_MSG *pMsg = NULL;

    // Make sure we have a connection to send to
    if (!IsConnected())
    {
        hr = HRESULT_FROM_WIN32(WSAENOTCONN);
        goto lDone;
    }

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Deleting Message: User=%I64X MessageID=%u",
        qwUserID,
        dwMessageID);

    // Allocate a buffer object
    pCBuffer = g_pBufferPool->GetBuffer( sizeof( *pMsg ) );
    if (pCBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Fill in the base message fields
    pMsg = (Q_DELETE_MESSAGE_MSG*) pCBuffer->GetBuffer();

    // Set the base fields
    pMsg->dwMsgType = QMSG_DELETE_MESSAGE;
    pMsg->dwMsgLen = sizeof( *pMsg ) - sizeof( BASE_MSG_HEADER );
    pMsg->dwSeqNum = ++m_dwSeqNum;
    pMsg->sgaddr = sgaddrIgnore;

    // Set the message fields
    pMsg->qwUserID = qwUserID;
    pMsg->dwMessageID = dwMessageID;
    pMsg->dwFlags = fBlockSender ? XMSG_DELETE_MESSAGE_FLAG_BLOCK_SENDER : 0;

    // Send the message
    hr = Send(pCBuffer);
    if( FAILED( hr ) )
    {
        goto lDone;
    }

lDone:
    if(SUCCEEDED(hr))
    {
//        g_Counters.IncrementValue32(XPPERF_SERVER_INVITATION_NOT_COUNTER, 1);
//        g_Counters.IncrementValue32(XPPERF_SERVER_INVITATION_NOT_RATE, 1);
    }

    SAFE_RELEASE(pCBuffer);

    return hr;
}

/*****************************************************************************

CPresConnection::QueueInviteAnswer

Sends an invitation answer notifications to the given host's notification 
queue.  Assumes they are on the destination server.

*****************************************************************************/
HRESULT CPresConnection::QueueInviteAnswer(
    QWORD qwUserID,
    QWORD qwHostID,
    QWORD qwMatchSessionID,
    FILETIME ftSent,
    WORD wAnswer)
{
    HRESULT hr = S_OK;
    DWORD cbMsg = 0;
    CTCPCntVarBuffer *pCAddBuffer = NULL;
    BYTE *pbWork = NULL;
    Q_ADD_MSG *pMsgAdd = NULL;
    P_INVITATION_ANSWER_ITEM *pInvAnsItem = NULL;

    // Make sure we have a connection to send to
    if (!IsConnected())
    {
        hr = HRESULT_FROM_WIN32(WSAENOTCONN);
        goto lDone;
    }

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Sending Invite Ans: User=%I64X Host=%I64X Match=%I64X Answer=%d",
        qwUserID,
        qwHostID,
        qwMatchSessionID,
        wAnswer);

    // Calculate the total message size
    cbMsg = 
        sizeof(Q_ADD_MSG) 
        + sizeof(QWORD) 
        + sizeof(P_INVITATION_ANSWER_ITEM);

    // Allocate a buffer object
    pCAddBuffer = g_pBufferPool->GetBuffer(cbMsg);
    if (pCAddBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Fill in the base message fields
    pbWork = pCAddBuffer->GetBuffer();
    pMsgAdd = (Q_ADD_MSG *)pbWork;
    pbWork += sizeof(Q_ADD_MSG);

    pMsgAdd->dwMsgType = QMSG_ADD;
    pMsgAdd->dwMsgLen = cbMsg - sizeof(BASE_MSG_HEADER);
    pMsgAdd->dwSeqNum = ++m_dwSeqNum;
    pMsgAdd->sgaddr = sgaddrIgnore;

    // Fill in the static add fields
    pMsgAdd->wQType = PQUEUE_INVITE_ANSWER;
    pMsgAdd->wUserCount = 1;

    // Fill in the list of users to add it to
    memcpy(pbWork, &qwHostID, sizeof(QWORD));
    pbWork += sizeof(QWORD);

    // Fill in the Invitation Answer Item
    pInvAnsItem = (P_INVITATION_ANSWER_ITEM *) pbWork;
    pbWork += sizeof(P_INVITATION_ANSWER_ITEM);

    pInvAnsItem->qwInviteeID = qwUserID;
    pInvAnsItem->qwMatchSessionID = qwMatchSessionID;
    pInvAnsItem->ftSent = ftSent;
    pInvAnsItem->wAnswer = wAnswer;

    // Send the message
    hr = Send(pCAddBuffer);
    if(FAILED(hr))
    {
        goto lDone;
    }

lDone:
    if(SUCCEEDED(hr))
    {
        g_Counters.IncrementValue32(XPPERF_SERVER_INV_ANSWER_NOT_COUNTER, 1);
        g_Counters.IncrementValue32(XPPERF_SERVER_INV_ANSWER_NOT_RATE, 1);
    }

    SAFE_RELEASE(pCAddBuffer);

    return hr;
}

/*****************************************************************************

CPresConnection::QueuePeerPresence

Send presence information to a peer

*****************************************************************************/
HRESULT CPresConnection::QueuePeerPresence(
    CPresence *pCPresence, 
    const QWORD *rgqwUserIDs, 
    DWORD cUserIDs)
{
    HRESULT hr = S_OK;
    DWORD cbMsg = 0;
    CTCPCntVarBuffer *pCAddBuffer = NULL;
    BYTE *pbWork = NULL;
    Q_ADD_MSG *pMsgAdd = NULL;
    P_PEER_PRESENCE_ITEM *pPresItem = NULL;

    // Make sure we have a connection to send to
    if (!IsConnected())
    {
        hr = HRESULT_FROM_WIN32(WSAENOTCONN);
        goto lDone;
    }

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Sending Peer Presence: Src=%I64X NumDest=%d Dest0=%I64X Title=%d State=0x%x Match=%I64X TitleStuffLen=%d",
        pCPresence->GetUserID(),
        cUserIDs,
        rgqwUserIDs[0],
        pCPresence->GetLastSeenTitleID(),
        pCPresence->GetState(),
        pCPresence->GetMatchSessionID(),
        pCPresence->GetTitleStuffLen());

    // Calculate the total message size
    cbMsg = 
        sizeof(Q_ADD_MSG) 
        + (cUserIDs * sizeof(QWORD)) 
        + sizeof(P_PEER_PRESENCE_ITEM)
        + pCPresence->GetTitleStuffLen();

    // Allocate a buffer object
    pCAddBuffer = g_pBufferPool->GetBuffer(cbMsg);
    if (pCAddBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Fill in the base message fields
    pbWork = pCAddBuffer->GetBuffer();
    pMsgAdd = (Q_ADD_MSG *)pbWork;
    pbWork += sizeof(Q_ADD_MSG);

    pMsgAdd->dwMsgType = QMSG_ADD;
    pMsgAdd->dwMsgLen = cbMsg - sizeof(BASE_MSG_HEADER);
    pMsgAdd->dwSeqNum = ++m_dwSeqNum;
    pMsgAdd->sgaddr = sgaddrIgnore;

    // Fill in the static add fields
    pMsgAdd->wQType = PQUEUE_PEER_PRESENCE;
    pMsgAdd->wUserCount = (WORD)cUserIDs;

    // Fill in the list of users to add it to
    memcpy(pbWork, rgqwUserIDs, cUserIDs * sizeof(QWORD));
    pbWork += cUserIDs * sizeof(QWORD);

    // Fill in the Presence Item
    pPresItem = (P_PEER_PRESENCE_ITEM *) pbWork;
    pbWork += sizeof(P_PEER_PRESENCE_ITEM);

    pPresItem->qwUserID = pCPresence->GetUserID();
    pPresItem->dwTitleID = pCPresence->GetLastSeenTitleID();
    pPresItem->dwState = pCPresence->GetState();
    pPresItem->qwMatchSessionID = pCPresence->GetMatchSessionID();
    pPresItem->cbTitleStuff = (WORD) pCPresence->GetTitleStuffLen();

    // Fill in the title stuff into the presence item
    memcpy(pbWork, pCPresence->GetTitleStuff(), pCPresence->GetTitleStuffLen());

    // Send the message
    hr = Send(pCAddBuffer);
    if(FAILED(hr))
    {
        goto lDone;
    }

lDone:
    if(SUCCEEDED(hr))
    {
        //g_Counters.IncrementValue32(XPPERF_SERVER_PRESENCE_NOT_COUNTER, 1);
        //g_Counters.IncrementValue32(XPPERF_SERVER_PRESENCE_NOT_RATE, 1);
    }

    SAFE_RELEASE(pCAddBuffer);

    return hr;
}

/*****************************************************************************

CPresConnection::QueuePeerPresenceOffline

Send offline presence information to a peer

*****************************************************************************/
HRESULT CPresConnection::QueuePeerPresenceOffline (
    CPresence *pCPresence,
    DWORD cdwDestUsers,
    QWORD *rgqwDestUserIDs)
{
    HRESULT hr = S_OK;
    DWORD cbMsg = 0;
    CTCPCntVarBuffer *pCAddBuffer = NULL;
    BYTE *pbWork = NULL;
    Q_ADD_MSG *pMsgAdd = NULL;
    P_PEER_PRESENCE_ITEM *pPresItem = NULL;

    // Make sure we have a connection to send to
    if (!IsConnected())
    {
        hr = HRESULT_FROM_WIN32(WSAENOTCONN);
        goto lDone;
    }

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Sending Offline Peer Presence: Src=%I64X NumDest=%d Dest0=%I64X",
        pCPresence->GetUserID(),
        cdwDestUsers,
        rgqwDestUserIDs[0]);

    // Calculate the total message size
    cbMsg = 
        sizeof(Q_ADD_MSG) 
        + cdwDestUsers * sizeof(QWORD)
        + sizeof(P_PEER_PRESENCE_ITEM);

    // Allocate a buffer object
    pCAddBuffer = g_pBufferPool->GetBuffer(cbMsg);
    if (pCAddBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Fill in the base message fields
    pbWork = pCAddBuffer->GetBuffer();
    pMsgAdd = (Q_ADD_MSG *)pbWork;
    pbWork += sizeof(Q_ADD_MSG);

    pMsgAdd->dwMsgType = QMSG_ADD;
    pMsgAdd->dwMsgLen = cbMsg - sizeof(BASE_MSG_HEADER);
    pMsgAdd->dwSeqNum = ++m_dwSeqNum;
    pMsgAdd->sgaddr = sgaddrIgnore;

    // Fill in the static add fields
    pMsgAdd->wQType = PQUEUE_PEER_PRESENCE;
    pMsgAdd->wUserCount = (WORD)cdwDestUsers;

    // Fill in the list of users to add it to
    memcpy(pbWork, rgqwDestUserIDs, cdwDestUsers * sizeof(QWORD));
    pbWork += cdwDestUsers * sizeof(QWORD);

    // Fill in the Presence Item
    pPresItem = (P_PEER_PRESENCE_ITEM *) pbWork;
    pbWork += sizeof(P_PEER_PRESENCE_ITEM);

    pPresItem->qwUserID = pCPresence->GetUserID();
    pPresItem->dwTitleID = 0;
    pPresItem->dwState = 0;
    pPresItem->qwMatchSessionID = 0;
    pPresItem->cbTitleStuff = 0;

    // Send the message
    hr = Send(pCAddBuffer);
    if(FAILED(hr))
    {
        goto lDone;
    }

lDone:
    if(SUCCEEDED(hr))
    {
        //g_Counters.IncrementValue32(XPPERF_SERVER_PRESENCE_NOT_COUNTER, 1);
        //g_Counters.IncrementValue32(XPPERF_SERVER_PRESENCE_NOT_RATE, 1);
    }

    SAFE_RELEASE(pCAddBuffer);

    return hr;
}

/*****************************************************************************

CPresConnection::QueuePresence2

Sends the given user's presence to the destination buddies' notification 
queues.  Assumes all of the given buddies are on the destination server.

*****************************************************************************/
HRESULT CPresConnection::QueuePresence2(
    CPresence *pCPresence, 
    const QWORD *rgqwUserIDs, 
    DWORD cUserIDs )
{
    HRESULT hr = S_OK;
    DWORD cbMsg = 0;
    CTCPCntVarBuffer *pCAddBuffer = NULL;
    BYTE *pbWork = NULL;
    Q_ADD_MSG *pMsgAdd = NULL;
    P_PRESENCE_2_ITEM *pPresItem = NULL;

    // Make sure we have a connection to send to
    if (!IsConnected())
    {
        hr = HRESULT_FROM_WIN32(WSAENOTCONN);
        goto lDone;
    }

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Sending Presence2: Src=%I64X NumDest=%d Dest0=%I64X Title=%d State=0x%x Match=%I64X RPDataLen=%d",
        pCPresence->GetUserID(),
        cUserIDs,
        rgqwUserIDs[0],
        pCPresence->GetLastSeenTitleID(),
        pCPresence->GetState(),
        pCPresence->GetMatchSessionID(),
        pCPresence->GetRichPresenceLen());

    // Calculate the total message size
    cbMsg = 
        sizeof(Q_ADD_MSG) 
        + (cUserIDs * sizeof(QWORD)) 
        + sizeof(P_PRESENCE_2_ITEM)
        + pCPresence->GetRichPresenceLen();

    // Allocate a buffer object
    pCAddBuffer = g_pBufferPool->GetBuffer(cbMsg);
    if (pCAddBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Fill in the base message fields
    pbWork = pCAddBuffer->GetBuffer();
    pMsgAdd = (Q_ADD_MSG *)pbWork;
    pbWork += sizeof(Q_ADD_MSG);

    pMsgAdd->dwMsgType = QMSG_ADD;
    pMsgAdd->dwMsgLen = cbMsg - sizeof(BASE_MSG_HEADER);
    pMsgAdd->dwSeqNum = ++m_dwSeqNum;
    pMsgAdd->sgaddr = sgaddrIgnore;

    // Fill in the static add fields
    pMsgAdd->wQType = PQUEUE_PRESENCE_2;
    pMsgAdd->wUserCount = (WORD)cUserIDs;

    // Fill in the list of users to add it to
    memcpy(pbWork, rgqwUserIDs, cUserIDs * sizeof(QWORD));
    pbWork += cUserIDs * sizeof(QWORD);

    // Fill in the Presence Item
    pPresItem = (P_PRESENCE_2_ITEM *) pbWork;
    pbWork += sizeof(P_PRESENCE_2_ITEM);

    pPresItem->qwUserID = pCPresence->GetUserID();
    pPresItem->dwTitleID = pCPresence->GetLastSeenTitleID();
    pPresItem->dwState = pCPresence->GetState();
    pPresItem->qwMatchSessionID = pCPresence->GetMatchSessionID();
    pPresItem->mtUserTime = pCPresence->GetUserStateChanged();
    
    // Add rich presence state for Xenon presence
    pPresItem->cbRichPresence = 0;   // This gets filled in on the FD when the string is formatted. 
    pPresItem->cbData = (WORD)pCPresence->GetRichPresenceLen();
    
    // Fill in the rich presence state data into the presence item
    if (pCPresence->GetRichPresenceLen() > 0)
    {
        memcpy(pbWork, pCPresence->GetRichPresenceData(), pCPresence->GetRichPresenceLen());
    }

    // Send the message
    hr = Send(pCAddBuffer);
    if(FAILED(hr))
    {
        goto lDone;
    }

lDone:
    if(SUCCEEDED(hr))
    {
        g_Counters.IncrementValue32(XPPERF_SERVER_PRESENCE_NOT_COUNTER, 1);
        g_Counters.IncrementValue32(XPPERF_SERVER_PRESENCE_NOT_RATE, 1);
    }

    SAFE_RELEASE(pCAddBuffer);

    return hr;
}

/*****************************************************************************

CPresConnection::QueuePresence2Offline

Sends the given user's offline presence to the destination buddies' notification 
queues.  Assumes all of the given buddies are on the destination server.

*****************************************************************************/
HRESULT CPresConnection::QueuePresence2Offline(
    CPresence *pCPresence,
    DWORD cdwDestUsers,
    QWORD *rgqwDestUserIDs)
{
    HRESULT hr = S_OK;
    DWORD cbMsg = 0;
    CTCPCntVarBuffer *pCAddBuffer = NULL;
    BYTE *pbWork = NULL;
    Q_ADD_MSG *pMsgAdd = NULL;
    P_PRESENCE_2_ITEM *pPresItem = NULL;

    // Make sure we have a connection to send to
    if (!IsConnected())
    {
        hr = HRESULT_FROM_WIN32(WSAENOTCONN);
        goto lDone;
    }

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Sending Presence2Offline: Src=%I64X NumDest=%d Dest0=%I64X",
        pCPresence->GetUserID(),
        cdwDestUsers,
        rgqwDestUserIDs[0]);
    
    // Calculate the total message size
    cbMsg = 
        sizeof(Q_ADD_MSG) 
        + (cdwDestUsers * sizeof(QWORD)) 
        + sizeof(P_PRESENCE_2_ITEM);

    // Allocate a buffer object
    pCAddBuffer = g_pBufferPool->GetBuffer(cbMsg);
    if (pCAddBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Fill in the base message fields
    pbWork = pCAddBuffer->GetBuffer();
    pMsgAdd = (Q_ADD_MSG *)pbWork;
    pbWork += sizeof(Q_ADD_MSG);

    pMsgAdd->dwMsgType = QMSG_ADD;
    pMsgAdd->dwMsgLen = cbMsg - sizeof(BASE_MSG_HEADER);
    pMsgAdd->dwSeqNum = ++m_dwSeqNum;
    pMsgAdd->sgaddr = sgaddrIgnore;

    // Fill in the static add fields
    pMsgAdd->wQType = PQUEUE_PRESENCE_2;
    pMsgAdd->wUserCount = (WORD)cdwDestUsers;

    // Fill in the list of users to add it to
    memcpy(pbWork, rgqwDestUserIDs, cdwDestUsers * sizeof(QWORD));
    pbWork += cdwDestUsers * sizeof(QWORD);

    // Fill in the Presence Item
    pPresItem = (P_PRESENCE_2_ITEM *) pbWork;
    pbWork += sizeof(P_PRESENCE_2_ITEM);

    pPresItem->qwUserID = pCPresence->GetUserID();
    pPresItem->dwTitleID = pCPresence->GetLastSeenTitleID();
    pPresItem->dwState = 0;
    pPresItem->qwMatchSessionID = 0;
    pPresItem->mtUserTime = pCPresence->GetUserStateChanged();
    
    // Add rich presence state for Xenon presence
    pPresItem->cbRichPresence = 0;   // This gets filled in on the FD when the string is formatted. 
    pPresItem->cbData = 0;
    
    // Send the message
    hr = Send(pCAddBuffer);
    if(FAILED(hr))
    {
        goto lDone;
    }

lDone:
    if(SUCCEEDED(hr))
    {
        g_Counters.IncrementValue32(XPPERF_SERVER_PRESENCE_NOT_COUNTER, 1);
        g_Counters.IncrementValue32(XPPERF_SERVER_PRESENCE_NOT_RATE, 1);
    }

    SAFE_RELEASE(pCAddBuffer);

    return hr;
}


/*****************************************************************************

CPresConnection::SendSendMessage

Sends messages to the given users' notification server.
Assumes all of the given recipients are on the destination server.

*****************************************************************************/
HRESULT CPresConnection::SendSendMessage(
    const Q_SEND_MESSAGE_MSG* pMessage,
    WORD cRecipients,
    const QWORD* rgqwRecipients,
    const BYTE* pbDetails,
    const Q_SEND_MESSAGE_ADDENDUM* rgAddendum,
    SendMessageReplyHandler* pCCtx )
{
    HRESULT hr = S_OK;
    DWORD cbMsg = 0;
    CTCPCntVarBuffer* pCAddBuffer = NULL;
    BYTE* pbWork = NULL;
    Q_SEND_MESSAGE_MSG* pSendMessage = NULL;

    // Make sure we have a connection to send to
    if ( !IsConnected() )
    {
        hr = HRESULT_FROM_WIN32( WSAENOTCONN );
        goto lDone;
    }

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Sending Message: User=%I64X Title=0x%08X NumRecips=%d Recip0=%I64X seq=%d srv=%d",
        pMessage->qwSenderID,
        pMessage->dwSenderTitleID,
        cRecipients,
        rgqwRecipients[0], 
        m_dwSeqNum + 1,
        m_dwPresServerIndex );

    // Calculate the total message size
    cbMsg = 
        sizeof( Q_SEND_MESSAGE_MSG ) 
        + ( cRecipients * sizeof( QWORD ) )
        + pMessage->cbDetails;

    if( NULL != rgAddendum )
    {
        cbMsg += cRecipients * sizeof( Q_SEND_MESSAGE_ADDENDUM );
    }

    // Allocate a buffer object
    pCAddBuffer = g_pBufferPool->GetBuffer( cbMsg );
    if( NULL == pCAddBuffer )
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Fill in the base message fields
    pbWork = pCAddBuffer->GetBuffer();
    pSendMessage = (Q_SEND_MESSAGE_MSG *) pbWork;
    pbWork += sizeof( Q_SEND_MESSAGE_MSG );

    // Copy over the base message
    memcpy( pSendMessage, pMessage, sizeof( Q_SEND_MESSAGE_MSG ) );
    pSendMessage->dwMsgType = QMSG_SEND_MESSAGE;
    pSendMessage->dwMsgLen = cbMsg - sizeof( BASE_MSG_HEADER );
    pSendMessage->dwSeqNum = ++m_dwSeqNum;

    // Copy over the recipients
    memcpy( pbWork, rgqwRecipients, cRecipients * sizeof( *rgqwRecipients ) );
    pbWork += cRecipients * sizeof( *rgqwRecipients );

    // Overwrite the original number of recipients with the correct number for this server
    pSendMessage->cRecipients = cRecipients;

    // Copy over the message details
    memcpy( pbWork, pbDetails, pMessage->cbDetails );
    pbWork += pMessage->cbDetails;

    // Copy over the fSenderIsFriend array, if applicable
    if( NULL != rgAddendum )
    {
        memcpy( pbWork, rgAddendum, cRecipients * sizeof( Q_SEND_MESSAGE_ADDENDUM ) );
    }

    // Add the message to the tail of the list of waiting replies
    pCCtx->AddRef();
    pCCtx->m_pPerServerInfo[ m_dwPresServerIndex ].m_dwSeqNum = m_dwSeqNum;
    pCCtx->m_pPerServerInfo[ m_dwPresServerIndex ].m_pCNext = NULL;

    if( NULL == m_pCSendMessageListHead )
    {
        m_pCSendMessageListHead = pCCtx;
    }
    else
    {
        XOMASSERT( NULL != m_pCSendMessageListTail );
        m_pCSendMessageListTail->m_pPerServerInfo[ m_dwPresServerIndex ].m_pCNext = pCCtx;
    }
    m_pCSendMessageListTail = pCCtx;

    // Send the message
    hr = Send( pCAddBuffer );
    if( FAILED( hr ) )
    {
        goto lDone;
    }

lDone:
    SAFE_RELEASE( pCAddBuffer );

    return hr;
}

HRESULT CPresConnection::SendEmptySendReply(DWORD dwContext, HRESULT hr)
{
    CTCPCntVarBuffer*   pCBuffer = NULL;
    HRESULT             hrSend = S_OK;
    
    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "CPresConnection::SendEmptySendReply for Seq %d, hr=0x%08X",
        dwContext,
        hr );
    
    pCBuffer = g_pBufferPool->GetBuffer(sizeof(Q_SEND_MESSAGE_INTERNAL_REPLY_MSG));
    if (NULL == pCBuffer)
    {
        hrSend = E_OUTOFMEMORY;
        goto lDone;
    }

    Q_SEND_MESSAGE_INTERNAL_REPLY_MSG *pMsg = (Q_SEND_MESSAGE_INTERNAL_REPLY_MSG *)pCBuffer->GetBuffer();
    ZeroMemory(pMsg, sizeof(Q_SEND_MESSAGE_INTERNAL_REPLY_MSG));

    pMsg->dwMsgType = QMSG_SEND_MESSAGE_REPLY;
    pMsg->dwMsgLen = sizeof(Q_SEND_MESSAGE_INTERNAL_REPLY_MSG) - sizeof(BASE_MSG_HEADER);
    pMsg->dwSeqNum = ++m_dwSeqNum;
    pMsg->dwContext = dwContext;
    pMsg->hr = hr;

    hrSend = Send(pCBuffer);

lDone:
    SAFE_RELEASE( pCBuffer );

    return hrSend;
}

HRESULT CPresConnection::SendEmptyReply(DWORD dwMsgType, WORD cbSize, HRESULT hr)
{
    CTCPCntVarBuffer*   pCBuffer = NULL;
    HRESULT             hrSend = S_OK;

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "CPresConnection::SendEmptyReply Type=%d, size=%d, hr=0x%08X",
        dwMsgType,
        cbSize,
        hr );

    if (cbSize < sizeof(BASE_MSG_HEADER) + sizeof(HRESULT))
    {
        hrSend = E_INVALIDARG;
        goto lDone;
    }
    
    pCBuffer = g_pBufferPool->GetBuffer(cbSize);
    if (NULL == pCBuffer)
    {
        hrSend = E_OUTOFMEMORY;
        goto lDone;
    }

    BASE_MSG_HEADER *pMsg = (BASE_MSG_HEADER *)pCBuffer->GetBuffer();
    ZeroMemory(pMsg, cbSize);

    pMsg->dwMsgType = dwMsgType;
    pMsg->dwMsgLen = cbSize - sizeof(BASE_MSG_HEADER);
    pMsg->dwSeqNum = ++m_dwSeqNum;
    *((HRESULT *)(pMsg+1)) = hr;

    hrSend = Send(pCBuffer);

lDone:
    SAFE_RELEASE( pCBuffer );

    return hrSend;
}

/*****************************************************************************

CPresConnection::SendRevokeMessage

Sends revoke messages to the given users' notification server.
Assumes all of the given recipients are on the destination server.

*****************************************************************************/
HRESULT CPresConnection::SendRevokeMessage(
    const Q_REVOKE_MESSAGE_EX_MSG* pMessage,
    WORD cRecipients,
    const Q_RECIPIENT_RESULT* pRecipients,
    const BYTE* pbProp )
{
    HRESULT hr = S_OK;
    DWORD cbMsg = 0;
    CTCPCntVarBuffer* pCBuffer = NULL;
    BYTE* pbWork = NULL;
    Q_REVOKE_MESSAGE_EX_MSG* pMessageOutgoing = NULL;

    // Make sure we have a connection to send to
    if ( !IsConnected() )
    {
        hr = HRESULT_FROM_WIN32( WSAENOTCONN );
        goto lDone;
    }

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Sending RevokeMessage: User=%I64X NumRecips=%d Recip0=%I64X seq=%d srv=%d",
        pMessage->qwSenderID,
        cRecipients,
        pRecipients[ 0 ].qwUserID,
        m_dwSeqNum + 1,
        m_dwPresServerIndex );

    // Calculate the total message size
    cbMsg = 
        sizeof( Q_REVOKE_MESSAGE_EX_MSG ) 
        + ( cRecipients * sizeof( *pRecipients ) )
        + pMessage->cbProp;

    // Allocate a buffer object
    pCBuffer = g_pBufferPool->GetBuffer( cbMsg );
    if( NULL == pCBuffer )
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Fill in the base message fields
    pbWork = pCBuffer->GetBuffer();
    pMessageOutgoing = (Q_REVOKE_MESSAGE_EX_MSG*) pbWork;
    pbWork = (BYTE*)( pMessageOutgoing + 1 );

    // Copy over the base message
    memcpy( pMessageOutgoing, pMessage, sizeof( *pMessageOutgoing ) );
    pMessageOutgoing->dwMsgLen = cbMsg - sizeof( BASE_MSG_HEADER );
    pMessageOutgoing->dwSeqNum = ++m_dwSeqNum;

    // Copy over the recipients
    memcpy( pbWork, pRecipients, cRecipients * sizeof( *pRecipients ) );
    pbWork += cRecipients * sizeof( *pRecipients );

    // Copy over the property data
    memcpy( pbWork, pbProp, pMessage->cbProp );
    pbWork += pMessage->cbProp;

    // Overwrite the original number of recipients with the correct number for this server
    pMessageOutgoing->cRecipients = cRecipients;

    // Send the message
    hr = Send( pCBuffer );
    if( FAILED( hr ) )
    {
        goto lDone;
    }

lDone:
    SAFE_RELEASE( pCBuffer );

    return hr;
}



/*****************************************************************************

CPresConnection::CheckTimeouts

Check for timed out requests

*****************************************************************************/
void CPresConnection::CheckTimeouts()
{
    DWORD dwNow = GetTickCount(); // No sense calling this repeatedly

    {
        SendMessageReplyHandler *pCVictim = NULL;

        while ((m_pCSendMessageListHead != NULL) &&
               ((dwNow - m_pCSendMessageListHead->m_dwSendTime) >= 
                g_CPresCfg.GetMessageTimeout()))
        {
            // Remove the head of the list
            pCVictim = m_pCSendMessageListHead;
            m_pCSendMessageListHead = m_pCSendMessageListHead->m_pPerServerInfo[ m_dwPresServerIndex ].m_pCNext;
            if (pCVictim == m_pCSendMessageListTail)
            {
                m_pCSendMessageListTail = NULL;
            }
            pCVictim->m_pPerServerInfo[ m_dwPresServerIndex ].m_pCNext = NULL;

            XomNtEvent( XEVENT_PRESENCE_CODE_133, "CQueueConnection::CheckTimeouts - Timing out message send - seq=%d sent=%d now=%d srv=%d", 
               pCVictim->m_pPerServerInfo[ m_dwPresServerIndex ].m_dwSeqNum,
               pCVictim->m_dwSendTime,
               dwNow,
               m_dwPresServerIndex );

            // Insert fail records for all recipients on this server in the reply.  There may be multiple 
            // replies since we may have sent to multiple Notification servers.  Add this one on to the 
            // actual reply held in pCCtx.
            Q_RECIPIENT_RESULT* pRecipientResults = new Q_RECIPIENT_RESULT[pCVictim->m_pPerServerInfo[ m_dwPresServerIndex ].m_cRecipients];
            if (pRecipientResults == NULL)
            {
                continue;
            }

            for( WORD iRecipient = 0; iRecipient < pCVictim->m_pPerServerInfo[ m_dwPresServerIndex ].m_cRecipients; iRecipient++ )
            {
                pRecipientResults[iRecipient].qwUserID = pCVictim->m_rgqwRecipients[ pCVictim->m_pPerServerInfo[ m_dwPresServerIndex ].m_wStartRecipIndex + iRecipient ];
                pRecipientResults[iRecipient].hrRecipient = HRESULT_FROM_WIN32(ERROR_TIMEOUT);
            }

            pCVictim->HandleSendReply(
                pCVictim->m_pPerServerInfo[ m_dwPresServerIndex ].m_cRecipients,
                pRecipientResults,
                HRESULT_FROM_WIN32(ERROR_TIMEOUT));
            
            delete[] pRecipientResults;
        }
    }
}

HRESULT CPresConnection::ChangeServerIndex(DWORD *rgdwIndexMap, DWORD cOldServers)
{
    HRESULT hr = S_OK;
    SendMessageReplyHandler *pCCtx = m_pCSendMessageListHead;

    m_dwPresServerIndex = rgdwIndexMap[m_dwPresServerIndex];
    
    while (pCCtx != NULL)
    {
        if (!pCCtx->m_fVisitedForServerListChange)
        {
            pCCtx->m_fVisitedForServerListChange = TRUE;

            SendMessageReplyHandler::PerServerInfo *rgNewPerServerInfo = new SendMessageReplyHandler::PerServerInfo[g_CPresCfg.GetNumPresServers()];
            if (rgNewPerServerInfo == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto lDone;
            }

            for (DWORD dwOldIndex = 0; dwOldIndex < cOldServers; dwOldIndex++)
            {
                if (rgdwIndexMap[dwOldIndex] != 0xFFFFFFFF)
                {
                    rgNewPerServerInfo[rgdwIndexMap[dwOldIndex]].m_pCNext = pCCtx->m_pPerServerInfo[dwOldIndex].m_pCNext;
                    rgNewPerServerInfo[rgdwIndexMap[dwOldIndex]].m_dwSeqNum = pCCtx->m_pPerServerInfo[dwOldIndex].m_dwSeqNum;
                    rgNewPerServerInfo[rgdwIndexMap[dwOldIndex]].m_wStartRecipIndex = pCCtx->m_pPerServerInfo[dwOldIndex].m_wStartRecipIndex;
                    rgNewPerServerInfo[rgdwIndexMap[dwOldIndex]].m_cRecipients = pCCtx->m_pPerServerInfo[dwOldIndex].m_cRecipients;
                }
            }

            SAFE_ARRAYDELETE(pCCtx->m_pPerServerInfo);
            pCCtx->m_pPerServerInfo = rgNewPerServerInfo;
        }

        pCCtx = pCCtx->m_pPerServerInfo[m_dwPresServerIndex].m_pCNext;
    }
    
lDone:
    return hr;
}

HRESULT CPresConnection::ReleaseSendMessageContexts()
{
    // this is only called when we're removing this server.
    
    while (m_pCSendMessageListHead != NULL)
    {
        m_pCSendMessageListHead->Release();
        m_pCSendMessageListHead->HandleSendReply(0, NULL, E_UNEXPECTED);
        m_pCSendMessageListHead = m_pCSendMessageListHead->m_pPerServerInfo[m_dwPresServerIndex].m_pCNext;
    }

    return S_OK;
}

HRESULT CPresConnection::ClearSendMessageContextVisitedFlags()
{
    for (SendMessageReplyHandler *pCCtx = m_pCSendMessageListHead; pCCtx != NULL; pCCtx = pCCtx->m_pPerServerInfo[m_dwPresServerIndex].m_pCNext)
    {
        pCCtx->m_fVisitedForServerListChange = FALSE;
    }

    return S_OK;
}
    
/*****************************************************************************

CPresConnection::OnConnect

Called by the base class when the connection completes

*****************************************************************************/
void CPresConnection::OnConnect()
{
    if (m_pCallback != NULL)
    {
        m_pCallback->OnConnect(this);
    }
    else
    {
        XOMASSERT(FALSE);
    }
}

/*****************************************************************************

CPresConnection::OnDisconnect

Called by the base class when the connection is lost

*****************************************************************************/
void CPresConnection::OnDisconnect(HRESULT hrReason ) 
{
    if (m_dwPresServerIndex == 0xFFFFFFFF)
    {
        XomNtEvent(
            XEVENT_PRESENCE_COMM_9,
            "CPresConnection::OnDisconnect(): server %d lost a receive connection  Check other PresINH boxes for a corresponding disconnect.  hr = 0x%08X",
            g_CPresCfg.GetMyPresServerIndex(),
            hrReason);
    }
    else
    {
        XomNtEvent(
            XEVENT_PRESENCE_COMM_10,
            "CPresConnection::OnDisconnect(): server %d lost connection to server %d.  hr = 0x%08X",
            g_CPresCfg.GetMyPresServerIndex(),
            m_dwPresServerIndex,
            hrReason);
    }

    SAFE_DELETE(m_pCCtx);
    
    if (m_pCallback != NULL)
    {
        m_pCallback->OnDisconnect(this);
    }
    else
    {
        XOMASSERT(FALSE);
    }
}

/*****************************************************************************

CPresConnection::ProcessMessage

Receives a message from the connection object and posts a completion to switchboard for handling.

*****************************************************************************/
void CPresConnection::ProcessMessage(BYTE *pMsg, DWORD cbEntireMsg)
{
    if ((m_pCSwitchboard == NULL) || (pMsg == NULL))
    {
        XOMASSERT(FALSE);
        return;
    }

    // support for message fragmenting.  we have to decode the message header here.
    BASE_MSG_HEADER *pHeader = (BASE_MSG_HEADER *)pMsg;
    if (pHeader->dwMsgType == PMSG_CONTINUATION)
    {
        // this is a continuation of an existing request.  use the held context for it.
        if ((m_pCCtx == NULL) || 
            (((BASE_MSG_HEADER *)(m_pCCtx->m_pMsg))->dwSeqNum != pHeader->dwSeqNum))
        {
            // mismatched continuation!  how does this happen??
            XomNtEvent(
                XEVENT_PRESENCE_COMM_14,
                "Mismatched continuation message for type 0x%X from peer @ %s:%d", 
                m_pCCtx == NULL ? 0 : ((BASE_MSG_HEADER *)(m_pCCtx->m_pMsg))->dwMsgType, 
                inet_ntoa(m_sa.sin_addr), 
                ntohs(m_sa.sin_port));

            XOMASSERT(FALSE);
            
            delete m_pCCtx;
            m_pCCtx = NULL;
            return;
        }

        // skip over the continuation header
        pMsg += sizeof(BASE_MSG_HEADER);
        cbEntireMsg -= sizeof(BASE_MSG_HEADER);
    }
    else
    {
        // we dont want to mess with the global data structures on a connection thread.  wrap the request in a context.

        XOMASSERT(m_pCCtx == NULL);
        if (m_pCCtx != NULL)
        {
            XomNtEvent(
                XEVENT_PRESENCE_COMM_14,
                "Expected continuation message for type 0x%X, total size = %d bytes, received size = %d bytes from peer @ %s:%d", 
                ((BASE_MSG_HEADER *)(m_pCCtx->m_pMsg))->dwMsgType, 
                m_pCCtx->m_cbEntireMsg,
                (DWORD)(m_pCCtx->m_pWrite - m_pCCtx->m_pMsg),
                inet_ntoa(m_sa.sin_addr), 
                ntohs(m_sa.sin_port));

            delete m_pCCtx;
            m_pCCtx = NULL;
            
            Disconnect(E_UNEXPECTED);
        }

        m_pCCtx = new CPConnReceiveContext(this);
        if (m_pCCtx == NULL)
        {
            return;
        }

        // make a buffer to hold the whole message.
        m_pCCtx->m_cbEntireMsg = pHeader->dwMsgLen + sizeof(BASE_MSG_HEADER);
        m_pCCtx->m_pMsg = new BYTE[m_pCCtx->m_cbEntireMsg];
        if (m_pCCtx->m_pMsg == NULL)
        {
            delete m_pCCtx;
            m_pCCtx = NULL;
        }
        m_pCCtx->m_pWrite = m_pCCtx->m_pMsg;
    }

    // copy this portion of the message.
    XOMASSERT(m_pCCtx->m_cbEntireMsg - (m_pCCtx->m_pWrite - m_pCCtx->m_pMsg) >= cbEntireMsg);
    memcpy(m_pCCtx->m_pWrite, pMsg, cbEntireMsg);
    m_pCCtx->m_pWrite += cbEntireMsg;

    if ((DWORD)(m_pCCtx->m_pWrite - m_pCCtx->m_pMsg) == m_pCCtx->m_cbEntireMsg)
    {
        // we have the whole messsage, post it now.
        m_pCSwitchboard->PostCompletion(m_pCCtx);
        m_pCCtx = NULL;
    }
    // else hold on to the context for further fragments.

}

HRESULT CPresConnection::DeferMessage(QWORD qwUserID, BASE_MSG_HEADER *pMsg, DWORD cbEntireMsg)
{
    XomTrace(PresenceDebug, L_NORMAL, "DeferMessage(user = %I64X, type = %d, seq = %d, size = %d)", qwUserID, pMsg->dwMsgType, pMsg->dwSeqNum, cbEntireMsg);
    
    HRESULT hr = S_OK;
    
    CPConnReceiveContext *pCCtx = new CPConnReceiveContext(this);
    if (pCCtx == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }
    
    pCCtx->m_cbEntireMsg = cbEntireMsg;
    pCCtx->m_pMsg = new BYTE[cbEntireMsg];
    if (pCCtx->m_pMsg == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;        
    }
    
    memcpy(pCCtx->m_pMsg, pMsg, cbEntireMsg);
    
    hr = g_CPresenceUserIndex.QueueDeferredRequest(qwUserID, pCCtx);

lDone:

    if (FAILED(hr))
    {
        XomNtEvent(XEVENT_PRESENCE_CODE_134, "DeferMessage(user = %I64X, type = %d, seq = %d, size = %d) failed.  hr = 0x%X", qwUserID, pMsg->dwMsgType, pMsg->dwSeqNum, cbEntireMsg, hr);
        SAFE_RELEASE(pCCtx);
    }

    return hr;
}

/*****************************************************************************

CPresConnection::ProcessPConnMessage

Validates the reply message type, then calls the appropriate message handler.

*****************************************************************************/
void CPresConnection::ProcessPConnMessage(BYTE *pMsg, DWORD cbEntireMsg)
{
    if ((m_pCSwitchboard == NULL) || (pMsg == NULL))
    {
        XOMASSERT(FALSE);
        return;
    }

#ifdef ICECAP_BUILD
    StartProfile(PROFILE_THREADLEVEL, PROFILE_CURRENTID);
#endif

    g_Counters.IncrementValue32(XPPERF_SERVER_PCONN_MSGS_RECV_COUNT, 1);
    g_Counters.IncrementValue32(XPPERF_SERVER_PCONN_MSGS_RECV_RATE, 1);
    g_Counters.IncrementValue32(XPPERF_SERVER_PCONN_BYTES_RECV_COUNT, cbEntireMsg);
    g_Counters.IncrementValue32(XPPERF_SERVER_PCONN_BYTES_RECV_RATE, cbEntireMsg);

    struct MessageHandlers
    {
        DWORD dwMsgType;
        DWORD dwMinSize;
        MsgHandler pfnMsgHandler;
    };
    
    static MessageHandlers s_PMsgHandlers[1 + PMSG_MAX_REQ_TYPE - PMSG_MIN_REQ_TYPE] =
    {
        { PMSG_HELLO,              sizeof(P_HELLO_MSG),              (MsgHandler) &CPresConnection::ProcessMsgHello },
        { PMSG_ALIVE,              sizeof(P_ALIVE_MSG),              (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { PMSG_SYNC,               sizeof(P_SYNC_MSG),               (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { PMSG_REFRESH,            sizeof(P_REFRESH_MSG),            (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { PMSG_ADD,                sizeof(P_ADD_MSG),                (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { PMSG_DELETE,             sizeof(P_DELETE_MSG),             (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { PMSG_ACCEPT,             sizeof(P_ACCEPT_MSG),             (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { PMSG_REJECT,             sizeof(P_REJECT_MSG),             (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { PMSG_BLOCK,              sizeof(P_BLOCK_MSG),              (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { PMSG_UNBLOCK,            sizeof(P_UNBLOCK_MSG),            (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { PMSG_INVITE,             sizeof(P_INVITE_MSG),             (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { PMSG_CANCEL,             sizeof(P_CANCEL_MSG),             (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { PMSG_INVITE_ANSWER,      sizeof(P_INVITE_ANSWER_MSG),      (MsgHandler) &CPresConnection::ProcessMsgInviteAnswerPeer },
        { PMSG_NICKNAME,           sizeof(P_NICKNAME_MSG),           (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { PMSG_STATE,              sizeof(P_STATE_MSG),              (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { PMSG_DEAD_XBOX,          sizeof(P_DEAD_XBOX_MSG),          (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { PMSG_DEAD_SG,            sizeof(P_DEAD_SG_MSG),            (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { PMSG_ANNOUNCE,           sizeof(P_ANNOUNCE_MSG),           (MsgHandler) &CPresConnection::ProcessMsgAnnounce },
        { PMSG_SUBSCRIBED,         sizeof(P_SUBSCRIBED_MSG),         (MsgHandler) &CPresConnection::ProcessMsgSubscribed },
        { PMSG_UNSUBSCRIBE,        sizeof(P_UNSUBSCRIBE_MSG),        (MsgHandler) &CPresConnection::ProcessMsgUnsubscribe },
        { PMSG_ADDED,              sizeof(P_ADDED_MSG),              (MsgHandler) &CPresConnection::ProcessMsgAdded },
        { PMSG_ACCEPTED,           sizeof(P_ACCEPTED_MSG),           (MsgHandler) &CPresConnection::ProcessMsgAccepted },
        { PMSG_REMOVED,            sizeof(P_REMOVED_MSG),            (MsgHandler) &CPresConnection::ProcessMsgRemoved },
        { PMSG_KICK,               sizeof(P_KICK_MSG),               (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { PMSG_DEAD_USER,          sizeof(P_DEAD_USER_MSG),          (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { PMSG_ALIVE_INTERNAL,     sizeof(P_ALIVE_INTERNAL_MSG),     (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { PMSG_WEB_FRIENDS,        sizeof(P_WEB_FRIENDS_MSG),        (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { PMSG_WEB_ALIVE,          sizeof(P_WEB_ALIVE_MSG),          (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { PMSG_WEB_ANNOUNCE,       sizeof(P_WEB_ANNOUNCE_MSG),       (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { PMSG_WEB_SUBSCRIBED,     sizeof(P_WEB_SUBSCRIBED_MSG),     (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { PMSG_WEB_UNSUBSCRIBE,    sizeof(P_WEB_UNSUBSCRIBE_MSG),    (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { PMSG_PEER_SESSION,       sizeof(P_PEER_SESSION_MSG),       (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { PMSG_TEAM_LIST_TEAMS,    sizeof(P_TEAM_LIST_TEAMS_MSG),    (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { PMSG_TEAM_LIST_MEMBERS,  sizeof(P_TEAM_LIST_MEMBERS_MSG),  (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { PMSG_TEAM_CREATE,        sizeof(P_TEAM_CREATE_MSG),        (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { PMSG_TEAM_DELETE,        sizeof(P_TEAM_DELETE_MSG),        (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { PMSG_TEAM_REMOVE,        sizeof(P_TEAM_REMOVE_MSG),        (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { PMSG_TEAM_MANAGE_TEAM,   sizeof(P_TEAM_MANAGE_TEAM_MSG),   (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { PMSG_TEAM_MANAGE_MEMBER, sizeof(P_TEAM_MANAGE_MEMBER_MSG), (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { PMSG_TEAM_RECRUIT,       sizeof(P_TEAM_RECRUIT_MSG),       (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { PMSG_TEAM_JOIN,          sizeof(P_TEAM_JOIN_MSG),          (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { PMSG_TEAM_GET_TICKET,    sizeof(P_TEAM_GET_TICKET_MSG),    (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { PMSG_PEER_SUBSCRIBE,     sizeof(P_PEER_SUBSCRIBE_MSG),     (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { PMSG_PEER_UNSUBSCRIBE,   sizeof(P_PEER_UNSUBSCRIBE_MSG),   (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { PMSG_WATCH_START,        sizeof(P_WATCH_START_MSG),        (MsgHandler) &CPresConnection::ProcessMsgWatchStart },
        { PMSG_WATCH_STOP,         sizeof(P_WATCH_STOP_MSG),         (MsgHandler) &CPresConnection::ProcessMsgWatchStop },
        { PMSG_ADD_2,              sizeof(P_ADD_2_MSG),              (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { PMSG_INVITE_2,           sizeof(P_INVITE_2_MSG),           (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { PMSG_ALIVE_INTERNAL,     sizeof(P_ALIVE_INTERNAL_MSG),     (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { PMSG_STATE_2,            sizeof(P_STATE_2_MSG),            (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { PMSG_GET_STATE,          sizeof(P_GET_STATE_MSG),          (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { PMSG_TEAM_CREATE_XE,     sizeof(P_TEAM_CREATE_MSG),        (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { PMSG_TEAM_MANAGE_TEAM_XE,sizeof(P_TEAM_MANAGE_TEAM_MSG),   (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { PMSG_ADD_AFFILIATES,     sizeof(P_ADD_AFFILIATES_MSG),     (MsgHandler) &CPresConnection::ProcessMsgAddAffiliates },
        { PMSG_IS_AFFILIATE,       sizeof(P_IS_AFFILIATE_MSG),       (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { PMSG_QUERY_AFFILIATES,   sizeof(P_QUERY_AFFILIATES_MSG),   (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { PMSG_GET_PRESENCE_INFO,  sizeof(P_GET_PRESENCE_INFO_MSG),  (MsgHandler) &CPresConnection::ProcessMsgGetPresenceInfo },
        { PMSG_PRESENCE_INFO_REPLY,sizeof(P_GET_PRESENCE_INFO_MSG),  (MsgHandler) &CPresConnection::ProcessMsgPresenceInfoReply },
        { PMSG_INVALIDATE_USER,    sizeof(P_INVALIDATE_USER_MSG),    (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { PMSG_FIND_USER,          sizeof(P_FIND_USER_MSG),          (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { PMSG_CHECK_TITLE_MESSAGES,  sizeof(P_CHECK_TITLE_MESSAGES_MSG),   (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { PMSG_TEAM_LIST_USER_TEAMS,  sizeof(P_TEAM_LIST_USER_TEAMS_MSG),   (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { PMSG_USER_PRE_MIGRATION,    sizeof(P_USER_PRE_MIGRATION_MSG),     (MsgHandler) &CPresConnection::ProcessMsgUserPreMigration },
        { PMSG_USER_FULL_MIGRATION,   sizeof(P_USER_FULL_MIGRATION_MSG),    (MsgHandler) &CPresConnection::ProcessMsgUserFullMigration },
        { PMSG_LOGON_CHECK,  sizeof(P_LOGON_CHECK_MSG),    (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { PMSG_FIND_USERS,          sizeof(P_FIND_USERS_MSG),          (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { PMSG_ALIVE_INTERNAL_2,     sizeof(P_ALIVE_INTERNAL_2_MSG),     (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { PMSG_PEER_SUBSCRIBE_EX,     sizeof(P_PEER_SUBSCRIBE_EX_MSG),     (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { PMSG_PURGE_USER,     sizeof(P_PURGE_USER_MSG),     (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { PMSG_GET_FRIENDS_LIST,     sizeof(P_GET_FRIENDS_LIST_MSG),     (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
        { PMSG_CONTINUATION,     sizeof(BASE_MSG_HEADER),     (MsgHandler) &CPresConnection::ProcessMsgNotSupported },
    };

    static MessageHandlers s_QMsgHandlers[ 1 + QMSG_MAX_REQ_TYPE - QMSG_MIN_REQ_TYPE ] =
    {
        { QMSG_HELLO,                 sizeof( Q_HELLO_MSG ),                 (MsgHandler) &CPresConnection::ProcessMsgHello         },
        { QMSG_USER_INFO,             sizeof( Q_USER_INFO_MSG ),             (MsgHandler) &CPresConnection::ProcessMsgNotSupported  },
        { QMSG_ADD,                   sizeof( Q_ADD_MSG ),                   (MsgHandler) &CPresConnection::ProcessMsgQAdd          },
        { QMSG_DELETE,                sizeof( Q_DELETE_MSG ),                (MsgHandler) &CPresConnection::ProcessMsgNotSupported  },
        { QMSG_DELETE_MATCHES,        sizeof( Q_DELETE_MATCHES_MSG ),        (MsgHandler) &CPresConnection::ProcessMsgNotSupported  },
        { QMSG_DEAD_XBOX,             sizeof( Q_DEAD_XBOX_MSG ),             (MsgHandler) &CPresConnection::ProcessMsgNotSupported  },
        { QMSG_DEAD_SG,               sizeof( Q_DEAD_SG_MSG ),               (MsgHandler) &CPresConnection::ProcessMsgNotSupported  },
        { QMSG_LIST,                  sizeof( Q_LIST_MSG ),                  (MsgHandler) &CPresConnection::ProcessMsgNotSupported  },
        { QMSG_DEQUEUE,               sizeof( Q_DEQUEUE_MSG ),               (MsgHandler) &CPresConnection::ProcessMsgNotSupported  },
        { QMSG_DEAD_USER,             sizeof( Q_DEAD_USER_MSG ),             (MsgHandler) &CPresConnection::ProcessMsgNotSupported  },
        { QMSG_WEB_USER_INFO,         sizeof( Q_WEB_USER_INFO_MSG ),         (MsgHandler) &CPresConnection::ProcessMsgNotSupported   },
        { QMSG_WEB_PRESENCE,          sizeof( Q_WEB_PRESENCE_MSG ),          (MsgHandler) &CPresConnection::ProcessMsgNotSupported   },
        { QMSG_WEB_LIST,              sizeof( Q_WEB_LIST_MSG ),              (MsgHandler) &CPresConnection::ProcessMsgNotSupported  },

        // Message handlers for Messaging
        { QMSG_ENUM_MESSAGES,         sizeof( Q_ENUM_MESSAGES_MSG ),         (MsgHandler) &CPresConnection::ProcessMsgNotSupported  },
        { QMSG_MESSAGE_SUMMARY,       sizeof( Q_MESSAGE_SUMMARY_MSG ),       (MsgHandler) &CPresConnection::ProcessMsgNotSupported  },
        { QMSG_MESSAGE_DETAILS,       sizeof( Q_MESSAGE_DETAILS_MSG ),       (MsgHandler) &CPresConnection::ProcessMsgNotSupported  },
        { QMSG_DELETE_MESSAGE,        sizeof( Q_DELETE_MESSAGE_MSG ),        (MsgHandler) &CPresConnection::ProcessMsgDeleteMessage },
        { QMSG_SEND_MESSAGE,          sizeof( Q_SEND_MESSAGE_MSG ),          (MsgHandler) &CPresConnection::ProcessMsgSendMessage   },
        { QMSG_REVOKE_MESSAGE,        sizeof( Q_REVOKE_MESSAGE_MSG ),        (MsgHandler) &CPresConnection::ProcessMsgNotSupported  },
        { QMSG_DELETE_TITLE,          sizeof( Q_DELETE_TITLE_MSG ),          (MsgHandler) &CPresConnection::ProcessMsgNotSupported  },
        { QMSG_ENUM_TITLES,           sizeof( Q_ENUM_TITLES_MSG ),           (MsgHandler) &CPresConnection::ProcessMsgNotSupported  },
        { QMSG_MESSAGE_FLAGS,         sizeof( Q_MESSAGE_FLAGS_MSG ),         (MsgHandler) &CPresConnection::ProcessMsgNotSupported  },
        { QMSG_ENUM_SYSTEM_MESSAGES,  sizeof( Q_ENUM_SYSTEM_MESSAGES_MSG ),  (MsgHandler) &CPresConnection::ProcessMsgNotSupported  },
        { QMSG_SYSTEM_MESSAGE_DETAILS,sizeof( Q_SYSTEM_MESSAGE_DETAILS_MSG ),(MsgHandler) &CPresConnection::ProcessMsgNotSupported  },
        { QMSG_DELETE_SYSTEM_MESSAGE, sizeof( Q_DELETE_SYSTEM_MESSAGE_MSG ), (MsgHandler) &CPresConnection::ProcessMsgNotSupported  },
        { QMSG_SEND_SYSTEM_MESSAGE,   sizeof( Q_SEND_SYSTEM_MESSAGE_MSG ),   (MsgHandler) &CPresConnection::ProcessMsgNotSupported  },
        { QMSG_REVOKE_MESSAGE_EX,     sizeof( Q_REVOKE_MESSAGE_EX_MSG ),     (MsgHandler) &CPresConnection::ProcessMsgRevokeMessage },
        { QMSG_ENUM_MESSAGES_2,       sizeof( Q_ENUM_MESSAGES_2_MSG ),       (MsgHandler) &CPresConnection::ProcessMsgNotSupported  },
        { QMSG_MESSAGE_SUMMARY_2,     sizeof( Q_MESSAGE_SUMMARY_2_MSG ),     (MsgHandler) &CPresConnection::ProcessMsgNotSupported  },
    };
    
    BASE_MSG_HEADER *pMsgHeader = (BASE_MSG_HEADER *) pMsg;
    DWORD dwMsgType = pMsgHeader->dwMsgType;

    // Check for hello
    if((dwMsgType != PMSG_HELLO) && (dwMsgType != QMSG_HELLO) && (!m_fSeenHello))
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_199,
            "Client @ %s:%d didn't send a hello",
            inet_ntoa(m_sa.sin_addr), 
            ntohs(m_sa.sin_port));

        Disconnect(E_INVALIDARG);
        goto lDone;
    }

    // TODO: find a way to make everything work and keep the sequence numbering.
    // DWORD dwSeqNum = pMsgHeader->dwSeqNum;
    // removed the sequence number checks.  these cause problems for deferred messages and possibly for local shortcuts.
    // 
    // // Check the sequence number
    // if ((dwSeqNum <= m_dwLastSeqNum) && (m_dwLastSeqNum != ~0))
    // {
    //     XomNtEvent(
    //         XEVENT_PRESENCE_HACK_200, 
    //         "Seqence number %d <= %d from peer @ %s:%d", 
    //         dwSeqNum,
    //         m_dwLastSeqNum,
    //         inet_ntoa(m_sa.sin_addr), 
    //         ntohs(m_sa.sin_port));
    //     Disconnect(E_INVALIDARG);
    //     goto lDone;
    // }
    // 
    // m_dwLastSeqNum = dwSeqNum;
    
    if (dwMsgType == MSGTYPE_ACK)
    {
        ProcessMsgAck( (BASE_ACK_MSG *) pMsgHeader, cbEntireMsg );
    }
    if((dwMsgType >= PMSG_HELLO) && (dwMsgType <= PMSG_MAX_REQ_TYPE))
    {
        // Make sure we have the right table entry
        XOMASSERT(s_PMsgHandlers[dwMsgType - PMSG_HELLO].dwMsgType == dwMsgType);
        
        // Minimum size check
        if (cbEntireMsg < s_PMsgHandlers[dwMsgType - PMSG_HELLO].dwMinSize)
        {
            XomNtEvent(
                XEVENT_PRESENCE_HACK_201,
                "Type 0x%X from peer @ %s:%d (size %d < %d)",
                dwMsgType, 
                inet_ntoa(m_sa.sin_addr), 
                ntohs(m_sa.sin_port),
                cbEntireMsg,
                s_PMsgHandlers[dwMsgType - PMSG_HELLO].dwMinSize);

            Disconnect(E_INVALIDARG);
            goto lDone;
        }
        
        // Run the message handler
        (this->*s_PMsgHandlers[ dwMsgType - PMSG_HELLO ].pfnMsgHandler)(
            pMsgHeader,
            cbEntireMsg );
    }
    // NOTE: using >= here generates compiler warning C4296, because QMSG_HELLO = 0.  we fake out the compiler by expanding.
    else if(((dwMsgType > QMSG_HELLO) || (dwMsgType == QMSG_HELLO)) && (dwMsgType <= QMSG_MAX_REQ_TYPE))
    {
        // Make sure we have the right table entry
        XOMASSERT(s_QMsgHandlers[dwMsgType - QMSG_HELLO].dwMsgType == dwMsgType);
        
        // Minimum size check
        if (cbEntireMsg < s_QMsgHandlers[dwMsgType - QMSG_HELLO].dwMinSize)
        {
            XomNtEvent(
                XEVENT_PRESENCE_HACK_202,
                "Type 0x%X from peer @ %s:%d (size %d < %d)",
                dwMsgType, 
                inet_ntoa(m_sa.sin_addr), 
                ntohs(m_sa.sin_port),
                cbEntireMsg,
                s_QMsgHandlers[dwMsgType - QMSG_HELLO].dwMinSize);

            Disconnect(E_INVALIDARG);
            goto lDone;
        }
        
        // Run the message handler
        (this->*s_QMsgHandlers[ dwMsgType - QMSG_HELLO ].pfnMsgHandler)(
            pMsgHeader,
            cbEntireMsg );
    }
    else if ((dwMsgType >= QMSG_MIN_REPLY_TYPE) && (dwMsgType <= QMSG_MAX_REPLY_TYPE))
    {
        switch( pMsgHeader->dwMsgType )
        {
        case QMSG_SEND_MESSAGE_REPLY:
            ProcessMsgSendReply( (Q_SEND_MESSAGE_INTERNAL_REPLY_MSG*) pMsgHeader, cbEntireMsg );
            break;
        case QMSG_DELETE_MESSAGE_REPLY:
        case QMSG_REVOKE_MESSAGE_REPLY:
            // We don't do anything with these replies
            break;

        default:
            XomNtEvent( 
                XEVENT_PRESENCE_CODE_135,
                "CPresConnection::ProcessMessage - unknown message type: %u.", 
                pMsgHeader->dwMsgType);
            break;
        }
    }
    else
    {
        XomNtEvent( 
            XEVENT_PRESENCE_CODE_136,
            "CPresConnection::ProcessMessage - unknown message type: %u.", 
            pMsgHeader->dwMsgType);
    }
    
lDone:

#ifdef ICECAP_BUILD
    StopProfile(PROFILE_THREADLEVEL, PROFILE_CURRENTID);
#endif

    return;
}

/*****************************************************************************

CPresConnection::ProcessMsgHello

Hello messages.

*****************************************************************************/
void CPresConnection::ProcessMsgHello( P_HELLO_MSG *pMsg, DWORD cbEntireMsg )
{
    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pCSwitchboard != NULL);

    HRESULT hr = S_OK;
    DWORD cchDesc = 0;

    // Only accept the current version of the protocol
    if( pMsg->dwProtocolVersion != CURRENT_XPPROTOCOL_VER )
    {
        XomNtEvent(
            XEVENT_PRESENCE_COMM_11,
            "Invalid message from peer: Hello from peer @ %s:%d using bad protocol ver 0x%X",
            inet_ntoa(m_sa.sin_addr), 
            ntohs(m_sa.sin_port), 
            pMsg->dwProtocolVersion);

        hr = E_INVALIDARG;
        goto lDone;
    }
    
    // Only allow one Hello
    if(m_fSeenHello)
    {
        XomNtEvent(
            XEVENT_PRESENCE_COMM_12,  
            "Invalid message from peer: Hello from peer @ %s:%d duplicate hello",
            inet_ntoa(m_sa.sin_addr), 
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }
    
    // Rest of hello message is descriptive string - grab a copy
    cchDesc = cbEntireMsg - sizeof(P_HELLO_MSG);
    
    if( cchDesc > MAX_HELLO_DESCRIPTION_LEN )
    {
        XomNtEvent(
            XEVENT_PRESENCE_COMM_13,  
            "Invalid message from peer: Hello from peer @ %s:%d using bad description length %d",
            inet_ntoa( m_sa.sin_addr ), 
            ntohs(m_sa.sin_port), 
            cchDesc);

        hr = E_INVALIDARG;
        goto lDone;
    }
    
    memcpy (m_pszDesc, (char *)( pMsg + 1 ), cchDesc);

    m_pszDesc[ cchDesc ] = '\0';

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Hello from peer %s:%d desc = %s",
        inet_ntoa(m_sa.sin_addr), 
        ntohs(m_sa.sin_port),
        m_pszDesc);
    
    m_fSeenHello = TRUE;
 
lDone:
    
    // Keep track of things
    if( SUCCEEDED( hr ) )
    {
        g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_HELLO_MSGS_COUNTER );
    }
    else
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_HELLO_MSGS_COUNTER );

        XomNtEvent( 
            XEVENT_PRESENCE_CODE_137, 
            "CPresConnection::ProcessMsgHello failed hr=0x%X", 
            hr);
        // Always disconnect on hello error
        Disconnect(hr);
    }
}

/*****************************************************************************

CPresConnection::ProcessMsgNotSupported

Messages not supported or implemented via peer connections.

*****************************************************************************/
void CPresConnection::ProcessMsgNotSupported(BASE_MSG_HEADER *pMsg, DWORD cbEntireMsg)
{
    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pCSwitchboard != NULL);

    // Report it, then disconnect
    XomNtEvent(
            XEVENT_PRESENCE_COMM_14,
            "Unsupported message type 0x%X from peer @ %s:%d", 
            pMsg->dwMsgType, 
            inet_ntoa(m_sa.sin_addr), 
            ntohs(m_sa.sin_port));

    HRESULT hr = E_INVALIDARG;

    Disconnect(hr);
}


/*****************************************************************************

CPresConnection::ProcessMsgAnnounce

Process Annouce messages.

*****************************************************************************/
void CPresConnection::ProcessMsgAnnounce(P_ANNOUNCE_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_ANNOUNCE_PEER_TIME_AVERAGE, XPPERF_SERVER_ANNOUNCE_PEER_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pCSwitchboard != NULL);

    HRESULT hr = S_OK;

    if(0 == pMsg->qwDestUserID)
    {
        XomNtEvent(
            XEVENT_PRESENCE_COMM_15,
            "Announce from peer @ %s:%d Bad user id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    if(cbEntireMsg != sizeof(P_ANNOUNCE_MSG) + (pMsg->cSourceUserIDs * sizeof(QWORD)))
    {
        XomNtEvent(
            XEVENT_PRESENCE_COMM_16,
            "Announce from peer @ %s:%d (size %d < %d)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            cbEntireMsg,
            sizeof(P_ANNOUNCE_MSG) + (pMsg->cSourceUserIDs * sizeof(QWORD)));

        hr = E_INVALIDARG;
        Disconnect(hr);
        goto lDone;
    }

    // Ensure the gamertag is null terminated, since we are about
    //  to pass it around as a null terminated string
    pMsg->szGamerTag[XONLINE_GAMERTAG_SIZE - 1] = '\0';
    
    hr = m_pCSwitchboard->Announce(
        pMsg->qwDestUserID,
        pMsg->dwTitleID,
        pMsg->szGamerTag,
        pMsg->cSourceUserIDs,
        (QWORD *)(pMsg + 1));

lDone:

    if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(*((QWORD *)(pMsg + 1)), pMsg, cbEntireMsg);
    }
    
    // Keep track of things
    if(SUCCEEDED(hr))
    {
        g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_ANNOUNCE_MSGS_COUNTER );
    }
    else
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_ANNOUNCE_MSGS_COUNTER );

        XomNtEvent( 
            XEVENT_PRESENCE_CODE_138,
            "CPresConnection::ProcessMsgAnnounce failed dest=%I64X hr=0x%X",
            pMsg->qwDestUserID,
            hr);
    }
}

/*****************************************************************************

CPresConnection::ProcessMsgSubscribed

Process Subscribed messages.

*****************************************************************************/
void CPresConnection::ProcessMsgSubscribed(P_SUBSCRIBED_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_SUBSCRIBED_PEER_TIME_AVERAGE, XPPERF_SERVER_SUBSCRIBED_PEER_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pCSwitchboard != NULL);

    HRESULT hr = S_OK;

    if(0 == pMsg->qwDestUserID)
    {
       XomNtEvent(
            XEVENT_PRESENCE_COMM_17,
            "Subscribed from peer @ %s:%d Bad user id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    if(cbEntireMsg != sizeof(P_SUBSCRIBED_MSG) + ( pMsg->cSourceUserIDs * sizeof(QWORD)))
    {
        XomNtEvent(
            XEVENT_PRESENCE_COMM_18,
            "Subscribed from peer @ %s:%d (size %d < %d)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            cbEntireMsg,
            sizeof(P_SUBSCRIBED_MSG) + ( pMsg->cSourceUserIDs * sizeof(QWORD) ) );

        hr = E_INVALIDARG;
        Disconnect(hr);
        goto lDone;
    }

    hr = m_pCSwitchboard->Subscribed(
        pMsg->qwDestUserID,
        pMsg->cSourceUserIDs,
        (QWORD *)(pMsg + 1));

lDone:

    if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(pMsg->qwDestUserID, pMsg, cbEntireMsg);
    }
    else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
    {
        // need to forward this to the alt server.
        CTCPCntVarBuffer *pBuffer = g_pBufferPool->GetBuffer(cbEntireMsg);
        if (pBuffer == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            memcpy(pBuffer->GetBuffer(), pMsg, cbEntireMsg);

            hr = m_pCSwitchboard->GetPCluser()->ForwardMessage(pBuffer, pMsg->qwDestUserID);

            SAFE_RELEASE(pBuffer);
        }
    }
    
    
    // Keep track of things
    if( SUCCEEDED(hr) )
    {
        g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_SUBSCRIBE_MSGS_COUNTER );
    }
    else
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_SUBSCRIBE_MSGS_COUNTER );
    }    
}

/*****************************************************************************

CPresConnection::ProcessMsgUnsubscribe

Process Unsubscribe messages.

*****************************************************************************/
void CPresConnection::ProcessMsgUnsubscribe(P_UNSUBSCRIBE_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_UNSUBSCRIBE_PEER_TIME_AVERAGE, XPPERF_SERVER_UNSUBSCRIBE_PEER_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pCSwitchboard != NULL);

    HRESULT hr = S_OK;

    if(0 == pMsg->qwSourceUserID)
    {
        XomNtEvent(
            XEVENT_PRESENCE_COMM_19,
            "Unsubscribe from peer @ %s:%d Bad user id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    if(cbEntireMsg < sizeof(P_UNSUBSCRIBE_MSG) + ( pMsg->cDestUserIDs * sizeof(QWORD)))
    {
        XomNtEvent(
            XEVENT_PRESENCE_COMM_20,
            "Unsubscribe from peer @ %s:%d (size %d < %d)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            cbEntireMsg,
            sizeof(P_UNSUBSCRIBE_MSG) + (pMsg->cDestUserIDs * sizeof(QWORD)));

        hr = E_INVALIDARG;
        Disconnect(hr);
        goto lDone;
    }

    hr = m_pCSwitchboard->Unsubscribe(
        pMsg->qwSourceUserID,
        pMsg->cDestUserIDs,
        (QWORD *)(pMsg + 1));

lDone:

    // NOTE:  the user causing the deferment should be swapped to the front
    if(hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(*(QWORD *)(pMsg + 1), pMsg, cbEntireMsg);
    }
    
    // Keep track of things
    if(SUCCEEDED(hr))
    {
        g_Counters.TrackSuccessfulMessage(XPPERF_SERVER_UNSUBSCRIBE_MSGS_COUNTER);
    }
    else
    {
        g_Counters.TrackFailureMessage(XPPERF_SERVER_UNSUBSCRIBE_MSGS_COUNTER);

        XomNtEvent( 
            XEVENT_PRESENCE_CODE_139,
            "CPresConnection::ProcessMsgUnsubscribe failed src=%I64X hr=0x%X",
            pMsg->qwSourceUserID,
            hr);
    }
}

/*****************************************************************************

CPresConnection::ProcessMsgAdded

Process Added messages.

*****************************************************************************/
void CPresConnection::ProcessMsgAdded(P_ADDED_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_ADDED_PEER_TIME_AVERAGE, XPPERF_SERVER_ADDED_PEER_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pCSwitchboard != NULL);

    HRESULT hr = S_OK;

    if((0 == pMsg->qwUserID) || (0 == pMsg->qwBuddyID))
    {
        XomNtEvent(
            XEVENT_PRESENCE_COMM_21,
            "Added from peer @ %s:%d Bad user id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    if(cbEntireMsg < sizeof(P_ADDED_MSG) + pMsg->cbBuddyAcctName)
    {
        XomNtEvent(
            XEVENT_PRESENCE_COMM_22,
            "Added from peer @ %s:%d (size %d < %d)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            cbEntireMsg,
            sizeof(P_ADDED_MSG) + pMsg->cbBuddyAcctName);

        hr = E_INVALIDARG;
        Disconnect(hr);
        goto lDone;
    }

    hr = m_pCSwitchboard->Added(
        pMsg->qwUserID,
        pMsg->qwBuddyID,
        pMsg->dwVersion,
        pMsg->cbBuddyAcctName,
        (LPCSTR)(pMsg + 1));

lDone:

    if(hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(pMsg->qwUserID, pMsg, cbEntireMsg);
    }
    else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
    {
        // need to forward this to the alt server.
        CTCPCntVarBuffer *pBuffer = g_pBufferPool->GetBuffer(cbEntireMsg);
        if (pBuffer == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            memcpy(pBuffer->GetBuffer(), pMsg, cbEntireMsg);

            hr = m_pCSwitchboard->GetPCluser()->ForwardMessage(pBuffer, pMsg->qwUserID);

            SAFE_RELEASE(pBuffer);
        }
    }
    
    
    // Keep track of things
    if(SUCCEEDED(hr))
    {
        g_Counters.TrackSuccessfulMessage(XPPERF_SERVER_ADDED_MSGS_COUNTER);
    }
    else
    {
        g_Counters.TrackFailureMessage(XPPERF_SERVER_ADDED_MSGS_COUNTER);

        if (hr != HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER))
        {
            XomNtEvent( 
                XEVENT_PRESENCE_CODE_140, 
                "CPresConnection::ProcessMsgAdded failed hr=0x%X", 
                hr);
        }
    }
}

/*****************************************************************************

CPresConnection::ProcessMsgAccepted

Process Accepted messages.

*****************************************************************************/
void CPresConnection::ProcessMsgAccepted(P_ACCEPTED_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_ACCEPTED_PEER_TIME_AVERAGE, XPPERF_SERVER_ACCEPTED_PEER_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pCSwitchboard != NULL);

    HRESULT hr = S_OK;

    if((0 == pMsg->qwUserID) || (0 == pMsg->qwBuddyID))
    {
        XomNtEvent(
            XEVENT_PRESENCE_COMM_23,
            "Accepted from peer @ %s:%d Bad user id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    if(cbEntireMsg < sizeof(P_ACCEPTED_MSG) + pMsg->cbBuddyAcctName)
    {
        XomNtEvent(
            XEVENT_PRESENCE_COMM_24,
            "Accepted from peer @ %s:%d (size %d < %d)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            cbEntireMsg,
            sizeof(P_ACCEPTED_MSG) + pMsg->cbBuddyAcctName);

        hr = E_INVALIDARG;
        Disconnect(hr);
        goto lDone;
    }

    hr = m_pCSwitchboard->Accepted(
        pMsg->qwUserID,
        pMsg->qwBuddyID,
        pMsg->dwVersion,
        pMsg->cbBuddyAcctName,
        (LPCSTR)(pMsg + 1));

lDone:

    if(hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(pMsg->qwUserID, pMsg, cbEntireMsg);
    }
    else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
    {
        // need to forward this to the alt server.
        CTCPCntVarBuffer *pBuffer = g_pBufferPool->GetBuffer(cbEntireMsg);
        if (pBuffer == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            memcpy(pBuffer->GetBuffer(), pMsg, cbEntireMsg);

            hr = m_pCSwitchboard->GetPCluser()->ForwardMessage(pBuffer, pMsg->qwUserID);

            SAFE_RELEASE(pBuffer);
        }
    }
    
    // Keep track of things
    if(SUCCEEDED(hr))
    {
        g_Counters.TrackSuccessfulMessage(XPPERF_SERVER_ACCEPTED_MSGS_COUNTER);
    }
    else
    {
        g_Counters.TrackFailureMessage(XPPERF_SERVER_ACCEPTED_MSGS_COUNTER);

        if (hr != HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER))
        {
            XomNtEvent( 
                XEVENT_PRESENCE_CODE_141,
                "CPresConnection::ProcessMsgAccepted failed hr=0x%X", 
                hr);
        }
    }
}

/*****************************************************************************

CPresConnection::ProcessMsgRemoved

Process Removed messages.

*****************************************************************************/
void CPresConnection::ProcessMsgRemoved(P_REMOVED_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_REMOVED_PEER_TIME_AVERAGE, XPPERF_SERVER_REMOVED_PEER_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pCSwitchboard != NULL);

    HRESULT hr = S_OK;

    if((0 == pMsg->qwUserID) || (0 == pMsg->qwBuddyID))
    {
        XomNtEvent(
            XEVENT_PRESENCE_COMM_25,
            "Removed from peer @ %s:%d Bad user id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    hr = m_pCSwitchboard->Removed(
        pMsg->qwUserID,
        pMsg->qwBuddyID,
        pMsg->dwVersion);

lDone:

    if(hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(pMsg->qwUserID, pMsg, cbEntireMsg);
    }
    else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
    {
        // need to forward this to the alt server.
        CTCPCntVarBuffer *pBuffer = g_pBufferPool->GetBuffer(cbEntireMsg);
        if (pBuffer == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            memcpy(pBuffer->GetBuffer(), pMsg, cbEntireMsg);

            hr = m_pCSwitchboard->GetPCluser()->ForwardMessage(pBuffer, pMsg->qwUserID);

            SAFE_RELEASE(pBuffer);
        }
    }
    
    
    // Keep track of things
    if(SUCCEEDED(hr))
    {
        g_Counters.TrackSuccessfulMessage(XPPERF_SERVER_REMOVED_MSGS_COUNTER);
    }
    else
    {
        g_Counters.TrackFailureMessage(XPPERF_SERVER_REMOVED_MSGS_COUNTER);

        XomNtEvent( 
            XEVENT_PRESENCE_CODE_142,
            "CPresConnection::ProcessMsgRemoved failed hr=0x%X", 
            hr);
    }
}


/*****************************************************************************

CPresConnection::ProcessMsgInviteAnswer

Process Invitation Answer messages.

*****************************************************************************/
void CPresConnection::ProcessMsgInviteAnswerPeer(P_INVITE_ANSWER_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_INVITE_ANSWER_PEER_TIME_AVERAGE, XPPERF_SERVER_INVITE_ANSWER_PEER_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pCSwitchboard != NULL);

    HRESULT hr = S_OK;

    if ((0 == pMsg->qwUserID) || (0 == pMsg->qwHostID))
    {
        XomNtEvent(
            XEVENT_PRESENCE_COMM_26,
            "InviteAnswer from peer @ %s:%d Bad user id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    if (0 == pMsg->qwMatchSessionID)
    {
        XomNtEvent(
            XEVENT_PRESENCE_COMM_27,
            "InviteAnswer from peer @ %s:%d Session id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    hr = m_pCSwitchboard->InviteAnswerPeer(
        pMsg->qwUserID,
        pMsg->qwHostID,
        pMsg->qwMatchSessionID,
        pMsg->wAnswer);

lDone:

    if(hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(pMsg->qwHostID, pMsg, cbEntireMsg);
    }
    else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
    {
        // need to forward this to the alt server.
        CTCPCntVarBuffer *pBuffer = g_pBufferPool->GetBuffer(cbEntireMsg);
        if (pBuffer == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            memcpy(pBuffer->GetBuffer(), pMsg, cbEntireMsg);

            hr = m_pCSwitchboard->GetPCluser()->ForwardMessage(pBuffer, pMsg->qwHostID);

            SAFE_RELEASE(pBuffer);
        }
    }
    
    
    // Keep track of things
    if(SUCCEEDED(hr))
    {
        // Don't double count
        //g_Counters.TrackSuccessfulMessage(XPPERF_SERVER_ANSWER_INV_MSGS_COUNTER);
    }
    else
    {
        // Don't double count
        //g_Counters.TrackFailureMessage(XPPERF_SERVER_ANSWER_INV_MSGS_COUNTER);

        XomNtEvent( 
            XEVENT_PRESENCE_CODE_143,
            "CPresConnection::ProcessMsgInviteAnswer failed hr=0x%X", 
            hr);
    }
}

/*****************************************************************************

CPresConnection::ProcessMsgAddAffiliates

Process AddAffiliates messages.

*****************************************************************************/
void CPresConnection::ProcessMsgAddAffiliates(P_ADD_AFFILIATES_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_ADD_AFFILIATES_CLIENT_TIME_AVERAGE, XPPERF_SERVER_ADD_AFFILIATES_CLIENT_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pCSwitchboard != NULL);

    HRESULT hr = S_OK;
    
    // must have users to add
    if (0 == pMsg->cwAffiliates)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_203,
            "AddAffiliates from client @ %s:%d Zero Affiliates",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    if (pMsg->cwAffiliates > X_ADD_AFFILIATE_MAX)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_204,
            "AddAffiliates from client @ %s:%d Too many Affiliates(%d)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->cwAffiliates);

        hr = E_INVALIDARG;
        goto lDone;
    }

    // can only add to one list at a time.
    if (pMsg->dwListFlag & (pMsg->dwListFlag - 1))
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_205,
            "AddAffiliates from client @ %s:%d Multiple list bits set",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // TODO: is this check valid/important?
    // only encountered or completed game players can be batch added
    if ((1 < pMsg->cwAffiliates) &&
        (pMsg->dwListFlag != X_AFFILIATE_INDEX_TO_FLAG(X_AFFILIATE_COMPLETED_GAME_INDEX)) &&
        (pMsg->dwListFlag != X_AFFILIATE_INDEX_TO_FLAG(X_AFFILIATE_ENCOUNTERED_INDEX)))
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_206,
            "AddAffiliates from client @ %s:%d batch add for invalid affiliate type (0x%X)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->dwListFlag);

        hr = E_INVALIDARG;
        goto lDone;
    }

    // UserID of 0 not allowed
    if(0 == pMsg->qwSenderID)
    {
         XomNtEvent(
            XEVENT_PRESENCE_HACK_207,
            "AddAffiliates from client @ %s:%d Bad user id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // message size must equal size of advertised data
    if (pMsg->dwMsgLen != sizeof(P_ADD_AFFILIATES_MSG) - sizeof(BASE_MSG_HEADER) + (pMsg->cwAffiliates * sizeof(ULONGLONG)))
    {
         XomNtEvent(
            XEVENT_PRESENCE_HACK_208,
            "AddAffiliates from client @ %s:%d failed data size check -- dwMsgLen(%d), cwAffiliates(%d)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->dwMsgLen,
            pMsg->cwAffiliates);

        hr = E_INVALIDARG;
        goto lDone;
    }
    
    // Can't be your own affiliate
    ULONGLONG *pqwAffiliates = (ULONGLONG *)(pMsg + 1);
    for (WORD i = 0; i < pMsg->cwAffiliates; i++)
    {
        if(pMsg->qwSenderID == pqwAffiliates[i])
        {
            XomNtEvent(
                XEVENT_PRESENCE_HACK_209,
                "AddAffiliates from client @ %s:%d SenderID equals AffiliateID (%I64X)",
                inet_ntoa(m_sa.sin_addr),
                ntohs(m_sa.sin_port),
                pMsg->qwSenderID);

            hr = E_INVALIDARG;
            goto lDone;
        }
    }

    // Everything looks cool, send it on to the switchboard
    hr = m_pCSwitchboard->AddAffiliates(
        sgaddrIgnore,
        pMsg->qwSenderID,
        pMsg->dwListFlag,
        pMsg->dwTitleID,
        pMsg->cwAffiliates,
        pqwAffiliates);

    // LineType|MachinePUID|SG IP|SG SPI|UserPUID|AffiliatePUID|hr
    for (WORD i = 0; i < pMsg->cwAffiliates; i++)
    {
        XomLog(
            PresenceLog,
            "ADD_AFFILIATES|%I64X|%X|%X|%I64X|%I64X|%X",
            pMsg->sgaddr.qwXboxID,
            pMsg->sgaddr.inaSg,
            pMsg->sgaddr.dwSpiSg,
            pMsg->qwSenderID,
            pqwAffiliates[i],
            hr);
    }
    
lDone:
    
    if(hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(pMsg->qwSenderID, pMsg, cbEntireMsg);
    }
    else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
    {
        // need to forward this to the alt server.
        CTCPCntVarBuffer *pBuffer = g_pBufferPool->GetBuffer(cbEntireMsg);
        if (pBuffer == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            memcpy(pBuffer->GetBuffer(), pMsg, cbEntireMsg);

            hr = m_pCSwitchboard->GetPCluser()->ForwardMessage(pBuffer, pMsg->qwSenderID);

            SAFE_RELEASE(pBuffer);
        }
    }
    
    
    // Keep track of things
    if(FAILED(hr))
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_ADD_AFFILIATES_MSGS_COUNTER );

        XomNtEvent( 
            XEVENT_PRESENCE_CODE_144, 
            "CClientConnection::ProcessMsgAddAffiliates failed user=%I64X hr=0x%X",
            pMsg->qwSenderID,
            hr);
    }

    // success tracked on callback.    
}

/*****************************************************************************

CPresConnection::ProcessMsgGetPresenceInfo

Process GetPresenceInfo messages.

*****************************************************************************/
void CPresConnection::ProcessMsgGetPresenceInfo(P_GET_PRESENCE_INFO_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_GET_PRESENCE_INFO_PEER_TIME_AVERAGE, XPPERF_SERVER_GET_PRESENCE_INFO_PEER_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pCSwitchboard != NULL);

    HRESULT hr = S_OK;

    if(0 == pMsg->qwSenderID)
    {
        XomNtEvent(
            XEVENT_PRESENCE_COMM_28,
            "GetPresenceInfo from peer @ %s:%d Bad user id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    if(0 == pMsg->dwContext)
    {
        XomNtEvent(
            XEVENT_PRESENCE_COMM_29,
            "GetPresenceInfo from peer @ %s:%d Bad context id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    if(0 == pMsg->cdwUsers)
    {
        XomNtEvent(
            XEVENT_PRESENCE_COMM_30,
            "GetPresenceInfo from peer @ %s:%d cdwUsers = 0",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    // figure out the maximum reasonable number of users to get info for.
    DWORD dwMaxUsers = 0; 
    for (DWORD dwList = 0; dwList < NUM_STORED_AFFILIATE_LISTS; dwList++)
    {
        dwMaxUsers += g_rgdwMaxAffiliates[dwList];
    }
    dwMaxUsers += MAX_BUDDIES;
    dwMaxUsers += MAX_BLOCKS;
    dwMaxUsers += MAX_PEER_SUBSCRIPTIONS;

    if(pMsg->cdwUsers > dwMaxUsers)
    {
        XomNtEvent(
            XEVENT_PRESENCE_COMM_31,
            "GetPresenceInfo from peer @ %s:%d cdwUsers = %d (max = %d)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->cdwUsers,
            dwMaxUsers);

        hr = E_INVALIDARG;
        goto lDone;
    }

    if(cbEntireMsg != sizeof(P_GET_PRESENCE_INFO_MSG) + (pMsg->cdwUsers * sizeof(QWORD)))
    {
        XomNtEvent(
            XEVENT_PRESENCE_COMM_32,
            "GetPresenceInfo from peer @ %s:%d (size %d != %d)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            cbEntireMsg,
            sizeof(P_GET_PRESENCE_INFO_MSG) + (pMsg->cdwUsers * sizeof(QWORD)));

        hr = E_INVALIDARG;
        Disconnect(hr);
        goto lDone;
    }

    hr = m_pCSwitchboard->GetPresenceInfo(
        pMsg->dwContext,
        pMsg->qwSenderID,
        pMsg->cdwUsers,
        (QWORD *)(pMsg + 1),
        TRUE,
        this);

lDone:

    // NOTE: the user causing the deferment should be swapped to the front
    if(hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(*(QWORD *)(pMsg + 1), pMsg, cbEntireMsg);
    }
    
    // Keep track of things
    if(SUCCEEDED(hr))
    {
        g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_GET_PRESENCE_INFO_MSGS_COUNTER );
    }
    else
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_GET_PRESENCE_INFO_MSGS_COUNTER );

        XomNtEvent( 
            XEVENT_PRESENCE_CODE_145,
            "CPresConnection::GetPresenceInfo failed hr=0x%X", 
            hr);
    }
}

/*****************************************************************************

CPresConnection::ProcessMsgPresenceInfoReply

Process PresenceInfoReply messages.

*****************************************************************************/
void CPresConnection::ProcessMsgPresenceInfoReply(P_GET_PRESENCE_INFO_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_GET_PRESENCE_INFO_PEER_TIME_AVERAGE, XPPERF_SERVER_GET_PRESENCE_INFO_PEER_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pCSwitchboard != NULL);

    HRESULT hr = S_OK;

    if(0 == pMsg->qwSenderID)
    {
        XomNtEvent(
            XEVENT_PRESENCE_COMM_33,
            "PresenceInfoReply from peer @ %s:%d Bad user id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    if(0 == pMsg->dwContext)
    {
        XomNtEvent(
            XEVENT_PRESENCE_COMM_34,
            "PresenceInfoReply from peer @ %s:%d Bad context id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    if(0 == pMsg->cdwUsers)
    {
        XomNtEvent(
            XEVENT_PRESENCE_COMM_35,
            "PresenceInfoReply from peer @ %s:%d numAffiliates = 0",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    if(cbEntireMsg < sizeof(P_GET_PRESENCE_INFO_MSG) + (pMsg->cdwUsers * sizeof(P_PRESENCE_INFO_DATA_MSG)))
    {
        XomNtEvent(
            XEVENT_PRESENCE_COMM_36,
            "PresenceInfoReply from peer @ %s:%d (size %d < %d)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            cbEntireMsg,
            sizeof(P_GET_PRESENCE_INFO_MSG) + (pMsg->cdwUsers * sizeof(P_PRESENCE_INFO_DATA_MSG)));

        hr = E_INVALIDARG;
        Disconnect(hr);
        goto lDone;
    }

    hr = m_pCSwitchboard->PresenceInfoReply(
        pMsg->dwContext,
        pMsg->qwSenderID,
        pMsg->cdwUsers,
        (P_PRESENCE_INFO_DATA_MSG *)(pMsg + 1));

lDone:
    // Keep track of things
    if (FAILED(hr))
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_GET_PRESENCE_INFO_MSGS_COUNTER );

        XomNtEvent( 
            XEVENT_PRESENCE_CODE_146,
            "CPresConnection::PresenceInfoReply failed hr=0x%X", 
            hr);
    }
}

/*****************************************************************************

CPresConnection::ProcessMsgWatchStart

Process Watch Start messages.

*****************************************************************************/
void CPresConnection::ProcessMsgWatchStart(P_WATCH_START_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_WATCH_START_PEER_TIME_AVERAGE, XPPERF_SERVER_WATCH_START_PEER_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pCSwitchboard != NULL);

    HRESULT hr = S_OK;

    if(0 == pMsg->qwDestUserID)
    {
        XomNtEvent(
            XEVENT_PRESENCE_COMM_37,
            "Watch Start from peer @ %s:%d Bad user id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    if(cbEntireMsg != sizeof(P_WATCH_START_MSG) + (pMsg->cSourceUserIDs * sizeof(QWORD)))
    {
        XomNtEvent(
            XEVENT_PRESENCE_COMM_38,
            "Watch Start from peer @ %s:%d (size %d < %d)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            cbEntireMsg,
            sizeof(P_WATCH_START_MSG) + (pMsg->cSourceUserIDs * sizeof(QWORD)));

        hr = E_INVALIDARG;
        Disconnect(hr);
        goto lDone;
    }

    hr = m_pCSwitchboard->WatchStart(
        pMsg->qwDestUserID,
        pMsg->cSourceUserIDs,
        (QWORD *)(pMsg + 1));

lDone:

    // NOTE: the user causing the deferment should be swapped to the front
    if(hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(*(QWORD *)(pMsg + 1), pMsg, cbEntireMsg);
    }
    
    // Keep track of things
    if(SUCCEEDED(hr))
    {
        //g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_WEB_ANNOUNCE_MSGS_COUNTER );
    }
    else
    {
        //g_Counters.TrackFailureMessage( XPPERF_SERVER_WEB_ANNOUNCE_MSGS_COUNTER );

        XomNtEvent( 
            XEVENT_PRESENCE_CODE_147,
            "CPresConnection::ProcessMsgWatchStart failed hr=0x%X", 
            hr);
    }
}

/*****************************************************************************

CPresConnection::ProcessMsgWatchStop

Process Watch Stop messages.

*****************************************************************************/
void CPresConnection::ProcessMsgWatchStop(P_WATCH_STOP_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_WATCH_STOP_PEER_TIME_AVERAGE, XPPERF_SERVER_WATCH_STOP_PEER_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pCSwitchboard != NULL);

    HRESULT hr = S_OK;

    if(0 == pMsg->qwDestUserID)
    {
        XomNtEvent(
            XEVENT_PRESENCE_COMM_39,
            "Watch Stop from peer @ %s:%d Bad user id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    if(cbEntireMsg != sizeof(P_WATCH_STOP_MSG) + (pMsg->cSourceUserIDs * sizeof(QWORD)))
    {
        XomNtEvent(
            XEVENT_PRESENCE_COMM_40,
            "Watch Stop from peer @ %s:%d (size %d < %d)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            cbEntireMsg,
            sizeof(P_WATCH_STOP_MSG) + (pMsg->cSourceUserIDs * sizeof(QWORD)));

        hr = E_INVALIDARG;
        Disconnect(hr);
        goto lDone;
    }

    hr = m_pCSwitchboard->WatchStop(
        pMsg->qwDestUserID,
        pMsg->cSourceUserIDs,
        (QWORD *)(pMsg + 1));

lDone:

    // NOTE: the user causing the deferment should be swapped to the front
    if(hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(*(QWORD *)(pMsg + 1), pMsg, cbEntireMsg);
    }
    
    // Keep track of things
    if(SUCCEEDED(hr))
    {
        //g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_WEB_ANNOUNCE_MSGS_COUNTER );
    }
    else
    {
        //g_Counters.TrackFailureMessage( XPPERF_SERVER_WEB_ANNOUNCE_MSGS_COUNTER );

        XomNtEvent( 
            XEVENT_PRESENCE_CODE_148,
            "CPresConnection::ProcessMsgWatchStop failed hr=0x%X", 
            hr);
    }
}

/*****************************************************************************

CPresConnection::ProcessMsgQAdd

Process QAdd messages.

*****************************************************************************/
void CPresConnection::ProcessMsgQAdd(Q_ADD_MSG *pMsg, DWORD cbEntireMsg)
{
    CScopeTimer scope( XPPERF_SERVER_ADD_PRESENCE_TIME_AVERAGE, XPPERF_SERVER_ADD_PRESENCE_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pCSwitchboard != NULL);

    HRESULT hr = S_OK;
    DWORD dwIndex = 0;
    QWORD *pqwUserIDs = NULL;
    DWORD cbUserIDs;
    DWORD cbData = 0;
    BYTE *pbData = NULL;
    DWORD dwNewItemID;

    // Make sure the QType is valid
    if(pMsg->wQType >= PQUEUE_NUM_TYPES)
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_149,
            "Add from pres @ %s:%d Bad queue type (%d)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->wQType);

        hr = E_INVALIDARG;
        goto lDone;
    }
    
    // Enforce that they sent at least one user id
    if(0 == pMsg->wUserCount)
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_150,
            "Add from pres @ %s:%d Bad user count (%d)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->wUserCount);

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Another check of the message size, make sure it can hold all of the destination users
    if(cbEntireMsg < (sizeof(Q_ADD_MSG) + (pMsg->wUserCount * sizeof(QWORD))))
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_151,
            "Add from pres @ %s:%d (size %d < %d)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            cbEntireMsg,
            sizeof(Q_ADD_MSG) + (pMsg->wUserCount * sizeof(QWORD)));

        hr = E_INVALIDARG;
        Disconnect(hr);
        goto lDone;
    }
    
    // Point to variable length portions of message
    pqwUserIDs = (QWORD *)(pMsg + 1);
    cbUserIDs = pMsg->wUserCount * sizeof(QWORD);
    cbData = cbEntireMsg - sizeof(Q_ADD_MSG) - cbUserIDs;
    pbData = (BYTE *)(pMsg + 1);
    pbData += pMsg->wUserCount * sizeof(QWORD);
    
    // Add the item to all designated users' Qs
    for(dwIndex = 0; dwIndex < pMsg->wUserCount; dwIndex++)
    {   
        HRESULT hrInner = S_OK;
        
        // UserID zero is invalid
        if(0 == pqwUserIDs[dwIndex])
        {
            XomNtEvent(
                XEVENT_PRESENCE_CODE_152,
                "Add from pres @ %s:%d Bad user id (0) at index %d",
                inet_ntoa( m_sa.sin_addr ),
                ntohs( m_sa.sin_port ),
                dwIndex);
            
            hrInner = E_INVALIDARG;
            goto lDone;
        }
        
        // Everything looks cool, send it on to the switchboard
        hrInner = m_pCSwitchboard->AddToQ(
            &pMsg->sgaddr,
            pqwUserIDs[dwIndex],
            pMsg->wQType,
            cbData,
            pbData,
            &dwNewItemID );

        XomTrace(
            PresenceDebug,
            L_NORMAL,
            "Add from %s:%d sg %X spi %X xb %I64X user %I64X type %d item id %d hr=%X",
            inet_ntoa(m_sa.sin_addr), 
            ntohs(m_sa.sin_port), 
            pMsg->sgaddr.inaSg,
            pMsg->sgaddr.dwSpiSg,
            pMsg->sgaddr.qwXboxID,
            pqwUserIDs[dwIndex],
            pMsg->wQType,
            SUCCEEDED(hrInner) ? dwNewItemID : 0,
            hrInner);

        if (FAILED(hrInner))
        {
            // need to make a copy of this message, but only for this particular user.
            CTCPCntVarBuffer *pBuffer = g_pBufferPool->GetBuffer(sizeof(Q_ADD_MSG) + sizeof(QWORD) + cbData);
            if (pBuffer == NULL)
            {
                // set the outer hr here.  we're pretty much screwed, so we'll bail.
                hr = E_OUTOFMEMORY;
                goto lDone;
            }
            else
            {
                Q_ADD_MSG *pNewMsg = (Q_ADD_MSG *)pBuffer->GetBuffer();
                
                memcpy(pBuffer->GetBuffer(), pMsg, sizeof(Q_ADD_MSG));
                pNewMsg->dwMsgLen = sizeof(Q_ADD_MSG) + sizeof(QWORD) + cbData - sizeof(BASE_MSG_HEADER);
                pNewMsg->wUserCount = 1;

                memcpy(pBuffer->GetBuffer() + sizeof(Q_ADD_MSG), &(pqwUserIDs[dwIndex]), sizeof(QWORD));
                memcpy(pBuffer->GetBuffer() + sizeof(Q_ADD_MSG) + sizeof(QWORD), pbData, cbData);
            }
            
            if (hrInner == XONLINE_E_PRESENCE_USER_MIGRATED)
            {
                // need to forward this QAdd to the alt server.
                hrInner = m_pCSwitchboard->GetPCluser()->ForwardMessage(pBuffer, pqwUserIDs[dwIndex]);
            }
            else if (hrInner == XONLINE_E_PRESENCE_DEFER_REQUEST)
            {
                // put the message on the deferred user's queue.
                hrInner = DeferMessage(pqwUserIDs[dwIndex], (BASE_MSG_HEADER *)pBuffer->GetBuffer(), sizeof(Q_ADD_MSG) + sizeof(QWORD) + cbData);
            }
            else if (hrInner == HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER))
            {
                // user just doesnt have a base record.  this is nonfatal.
                hrInner = S_OK;
            }
            
            SAFE_RELEASE(pBuffer);

            if (FAILED(hrInner))
            {
                // still failed?  bail out.
                hr = hrInner;
                goto lDone;
            }
        }
    }
    
lDone:

    // Keep track of things
    if(SUCCEEDED(hr) || (hr == HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER)))
    {
        g_Counters.TrackSuccessfulMessage(
            XPPERF_SERVER_Q_ADD_MSGS_COUNTER);
    }
    else
    {
        g_Counters.TrackFailureMessage(XPPERF_SERVER_Q_ADD_MSGS_COUNTER);

        XomNtEvent( 
                XEVENT_PRESENCE_CODE_153,  
                "CPresConnection::ProcessMsgAdd failed hr=0x%X", 
                hr);
    }
}

/*****************************************************************************

CPresConnection::ProcessMsgSendMessage

Process a message send from another Notification server.  Messages start at the
sender's server and are propagated to each recipient's server where they arrive
through this method.  We assume here that the original server did most of the
validation and only do a minimal amount here.

*****************************************************************************/
void CPresConnection::ProcessMsgSendMessage( Q_SEND_MESSAGE_MSG *pMsg, DWORD cbEntireMsg )
{
    CScopeTimer scope( XPPERF_SERVER_SEND_MESSAGE_PEER_TIME_AVERAGE, XPPERF_SERVER_SEND_MESSAGE_PEER_TIME_BASE );

    XOMASSERT( pMsg != NULL );
    XOMASSERT( m_pCSwitchboard != NULL );

    HRESULT hr = S_OK;
    Q_SEND_MESSAGE_ADDENDUM* rgAddendum = NULL;
    XMSG_DETAILS* pDetails = NULL;

    // Check extended message size now that it is safe to access the base message structure
    if( cbEntireMsg < sizeof( Q_SEND_MESSAGE_MSG ) + 
                      pMsg->cRecipients * sizeof( ULONGLONG ) + 
                      pMsg->cbDetails)
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_154,
            "SendMessage from peer @ %s:%d (size %d < %d)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            cbEntireMsg,
            sizeof( Q_SEND_MESSAGE_MSG ) + 
                pMsg->cRecipients * sizeof( ULONGLONG ) +  
                pMsg->cbDetails );

        hr = E_INVALIDARG;
        Disconnect(hr);
        goto lDone;
    }    

    // Check for special friend info from Presence.  When messages come from Presence, we need to know if the
    // sender and each recipient are friends in order to set V1-style friend invite notifications.  Presence
    // passes us this information by appending an array of BOOL values for each recipient to the end of the
    // normal SendMessage protocol.
    if( cbEntireMsg == sizeof( Q_SEND_MESSAGE_MSG ) + 
                      pMsg->cRecipients * sizeof( ULONGLONG ) + 
                      pMsg->cbDetails + 
                      pMsg->cRecipients * sizeof( Q_SEND_MESSAGE_ADDENDUM ))
    {
        rgAddendum = (Q_SEND_MESSAGE_ADDENDUM *)( (BYTE*)(pMsg + 1) + pMsg->cRecipients * sizeof(ULONGLONG) + pMsg->cbDetails);
    }    

    for( int iRecip = 0; iRecip < pMsg->cRecipients; iRecip++ )
    {
        ULONGLONG* rgqwRecips = (ULONGLONG*)( pMsg + 1 );

        // Are we on the right notification server?
        if( !g_CPresCfg.CheckDestination( rgqwRecips[ iRecip ] ))
        {
            XomNtEvent(
                XEVENT_PRESENCE_CODE_155,
                "SendMessage from peer @ %s:%d to %I64X sent to the wrong server",
                inet_ntoa( m_sa.sin_addr ),
                ntohs( m_sa.sin_port ),
                rgqwRecips[iRecip]);

            hr = E_INVALIDARG;
            goto lDone;
        }
    }

    pDetails = (XMSG_DETAILS*)( (BYTE*)( pMsg + 1 ) + pMsg->cRecipients * sizeof( ULONGLONG ) );

    // Everything looks cool, send it on to the switchboard
    hr = m_pCSwitchboard->SendMessageInternal(
        pMsg,
        (ULONGLONG*)( pMsg + 1 ),
        (BYTE*) pDetails,
        rgAddendum,
        this,
        pMsg->dwSeqNum,
        NULL );

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "SendMessage from peer %s:%d sender %I64X title %x type %hx expire %hx cbDetails %hd cRecipients %hd flags %x hr=%X",
        inet_ntoa( m_sa.sin_addr ), 
        ntohs( m_sa.sin_port ),
        pMsg->qwSenderID,
        pMsg->dwSenderTitleID,
        pMsg->bMessageType,
        pMsg->wExpireMinutes,
        pMsg->cbDetails,
        pMsg->cRecipients,
        pMsg->dwMessageFlags,
        hr );

lDone:

    // NOTE: the user causing the deferment should be swapped to the front
    if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(*(QWORD *)(pMsg + 1), pMsg, cbEntireMsg);
    }

    // Keep track of things
    if( FAILED( hr ) )
    {
        HRESULT hrResp;

        g_Counters.TrackFailureMessage( XPPERF_SERVER_SEND_MESSAGE_MSGS_COUNTER );

        XomNtEvent( 
            XEVENT_PRESENCE_CODE_156, 
            "CPresConnection::ProcessMsgSendMessage failed user=%I64X hr=0x%X",
            pMsg->qwSenderID,
            hr );

        hrResp = SendEmptySendReply(pMsg->dwSeqNum, hr);
        if( FAILED( hrResp ) )
        {
            // Disconnect if we fail to send a response
            Disconnect( hr );
            hr = hrResp;
        }
    }

    // Success counter incremented on DB callback
}

/*****************************************************************************

CPresConnection::ProcessMsgDeleteMessage

Process a message delete from a Presence server.

*****************************************************************************/
void CPresConnection::ProcessMsgDeleteMessage( Q_DELETE_MESSAGE_MSG *pMsg, DWORD cbEntireMsg )
{
    CScopeTimer scope( XPPERF_SERVER_DELETE_MESSAGE_PRESENCE_TIME_AVERAGE, XPPERF_SERVER_DELETE_MESSAGE_PRESENCE_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pCSwitchboard != NULL);

    HRESULT hr = S_OK;

    // UserID of 0 not allowed
    if(0 == pMsg->qwUserID)
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_157,
            "DeleteMessage from peer @ %s:%d Bad user id (0)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port));

        hr = E_INVALIDARG;
        goto lDone;
    }

    if( 0 != ( pMsg->dwFlags & ~(XMSG_DELETE_MESSAGE_FLAG_BLOCK_SENDER) ) )
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_158,
            "DeleteMessage from peer @ %s:%d user %I64X msg %X Invalid flags (0x%08X)",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->qwUserID,
            pMsg->dwMessageID,
            pMsg->dwFlags);

        hr = E_INVALIDARG;
        goto lDone;
    }
 
    // Message ID from failed send not allowed
    if( pMsg->dwMessageID & XONLINE_MSG_ID_SEND_FAILED )
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_159,
            "DeleteMessage from peer @ %s:%d user %I64X msg %X Bad message ID",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->qwUserID,
            pMsg->dwMessageID);

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Are we on the right notification server?
    if (!g_CPresCfg.CheckDestination(pMsg->qwUserID))
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_160,
            "DeleteMessage from peer @ %s:%d for user %I64X msg %X sent to the wrong server",
            inet_ntoa(m_sa.sin_addr),
            ntohs(m_sa.sin_port),
            pMsg->qwUserID,
            pMsg->dwMessageID);

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Everything looks cool, send it on to the switchboard
    hr = m_pCSwitchboard->DeleteMessage(
        TRUE, // from Presence
        pMsg->qwUserID,
        pMsg->dwMessageID,
        pMsg->dwFlags,
        this,
        pMsg->dwSeqNum);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "DeleteMessage from peer %s:%d user %I64X msg %X hr=%X",
        inet_ntoa(m_sa.sin_addr), 
        ntohs(m_sa.sin_port),
        pMsg->qwUserID,
        pMsg->dwMessageID,
        hr);

lDone:

    if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(pMsg->qwUserID, pMsg, cbEntireMsg);
    }
    else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
    {
        // need to forward this to the alt server.
        CTCPCntVarBuffer *pBuffer = g_pBufferPool->GetBuffer(cbEntireMsg);
        if (pBuffer == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            memcpy(pBuffer->GetBuffer(), pMsg, cbEntireMsg);

            hr = m_pCSwitchboard->GetPCluser()->ForwardMessage(pBuffer, pMsg->qwUserID);

            SAFE_RELEASE(pBuffer);
        }
    }
    

    // Keep track of things
    if( FAILED(hr) )
    {
        HRESULT hrResp;

        // If the operation succeeds we will log it upon completion where we have more information available
        // (missing information is represented by zeroes here to keep the log format consistent).
        XomLog( PresenceLog, "DEL|%X:%X|%I64X|%X|%X|%X",
            ntohl( m_sa.sin_addr.S_un.S_addr ), 
            ntohs( m_sa.sin_port ),
            pMsg->qwUserID,
            pMsg->dwMessageID,
            pMsg->dwFlags,
            hr );

        g_Counters.TrackFailureMessage( XPPERF_SERVER_DELETE_MESSAGE_MSGS_FROM_PRES_COUNTER );

        XomNtEvent( 
            XEVENT_PRESENCE_CODE_161, 
            "CPresConnection::ProcessMsgDeleteMessage failed user=%I64X hr=0x%X",
            pMsg->qwUserID,
            hr);

        hrResp = SendEmptyReply( 
            QMSG_DELETE_MESSAGE_REPLY, 
            sizeof( Q_DELETE_MESSAGE_REPLY_MSG ), 
            hr);
        if (FAILED(hrResp))
        {
            // Disconnect if we fail to send a response
            Disconnect(hr);
            hr = hrResp;
        }
    }

    // Success counter incremented on DB callback
}


/*****************************************************************************

CPresConnection::ProcessMsgRevokeMessage

Process a revoke message from another Notification server.  Revoke messages
start at any given Notification server and are propagated to each recipient's 
server where they arrive through this method.

*****************************************************************************/
void CPresConnection::ProcessMsgRevokeMessage( Q_REVOKE_MESSAGE_EX_MSG* pMsg, DWORD cbEntireMsg )
{
    CScopeTimer scope( XPPERF_SERVER_REVOKE_MESSAGE_PEER_TIME_AVERAGE, XPPERF_SERVER_REVOKE_MESSAGE_PEER_TIME_BASE );

    XOMASSERT(pMsg != NULL);
    XOMASSERT(m_pCSwitchboard != NULL);

    HRESULT hr = S_OK;
    const BYTE* pbProp;
    Q_RECIPIENT_RESULT* pRecipients = NULL;

    if( !ValidateRevokeMessage( pMsg, cbEntireMsg, &m_sa ) )
    {
        hr = E_INVALIDARG;
        goto lDone;
    }

    pRecipients = (Q_RECIPIENT_RESULT*)( pMsg + 1 );
    pbProp = (const BYTE*)( (BYTE*)( pMsg + 1 ) + pMsg->cRecipients * sizeof( *pRecipients ) );

    for( int iRecip = 0; iRecip < pMsg->cRecipients; iRecip++ )
    {
        // Are we on the right notification server?
        if( !g_CPresCfg.CheckDestination( pRecipients[ iRecip ].qwUserID ))
        {
            XomNtEvent(
                XEVENT_PRESENCE_CODE_162,
                "RevokeMessage from peer %s:%d for user %I64X sent to the wrong server",
                inet_ntoa(m_sa.sin_addr),
                ntohs(m_sa.sin_port),
                pMsg->qwSenderID);

            hr = E_INVALIDARG;
            goto lDone;
        }
    }

    // Everything looks cool, send it on to the switchboard
    hr = m_pCSwitchboard->RevokeMessageInternal(
        pMsg,
        pRecipients,
        pbProp );

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "RevokeMessage from peer %s:%d sender %I64X context %I64X cRecipients %hd dwFlags %hd wPropTag %hd cbProp %hd",
        inet_ntoa(m_sa.sin_addr), 
        ntohs(m_sa.sin_port),
        pMsg->qwSenderID,
        pMsg->qwSenderContext,
        pMsg->cRecipients,
        pMsg->dwFlags,
        pMsg->wPropTag,
        pMsg->cbProp,
        hr );

lDone:

    // NOTE: the user causing the deferment should be swapped to the front
    if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
    {
        hr = DeferMessage(pRecipients[0].qwUserID, pMsg, cbEntireMsg);
    }

    if( FAILED( hr ) )
    {
        XomNtEvent( 
            XEVENT_PRESENCE_CODE_163, 
            "CPresConnection::ProcessMsgRevokeMessage failed user=%I64X hr=0x%X",
            pMsg->qwSenderID,
            hr );
    }

    // No response is expected
}


void CPresConnection::ProcessMsgUserPreMigration(P_USER_PRE_MIGRATION_MSG *pMsg, DWORD cbEntireMsg )
{
    HRESULT hr = S_OK;

    if (cbEntireMsg != sizeof(P_USER_PRE_MIGRATION_MSG))
    {
        hr = E_INVALIDARG;
        XomNtEvent(XEVENT_PRESENCE_CODE_164, "ProcessMsgUserPreMigration failed size check (%d != %d)", cbEntireMsg, sizeof(P_USER_PRE_MIGRATION_MSG));
        goto lDone;
    }

    if (pMsg->qwUserID == 0)
    {
        hr = E_INVALIDARG;
        XomNtEvent(XEVENT_PRESENCE_CODE_165, "ProcessMsgUserPreMigration failed. qwUserID = 0");
        goto lDone;
    }

    if (g_CPresCfg.MapUserToPresSrv(pMsg->qwUserID, TRUE) != g_CPresCfg.GetMyPresServerIndex())
    {
        hr = E_UNEXPECTED;
        XomNtEvent(XEVENT_PRESENCE_CODE_166, "ProcessMsgUserPreMigration sent to the wrong server (%d) for user %I64X", g_CPresCfg.GetMyPresServerIndex(), pMsg->qwUserID);
        goto lDone;
    }

    hr = m_pCSwitchboard->UserPreMigration(pMsg->qwUserID);
    if (FAILED(hr))
    {
        XomNtEvent(XEVENT_PRESENCE_CODE_167, "ProcessMsgUserPreMigration failed hr = 0x%X", hr);
    }

lDone:

    return;

}

void CPresConnection::ProcessMsgUserFullMigration(P_USER_FULL_MIGRATION_MSG *pMsg, DWORD cbEntireMsg )
{
    HRESULT hr = S_OK;

    if (cbEntireMsg < sizeof(P_USER_FULL_MIGRATION_MSG))
    {
        hr = E_INVALIDARG;
        XomNtEvent(XEVENT_PRESENCE_CODE_168, "ProcessMsgUserFullMigration failed size check (%d < %d)", cbEntireMsg, sizeof(P_USER_FULL_MIGRATION_MSG));
        goto lDone;
    }

    if (pMsg->qwUserID == 0)
    {
        hr = E_INVALIDARG;
        XomNtEvent(XEVENT_PRESENCE_CODE_169, "ProcessMsgUserFullMigration failed. qwUserID = 0");
        goto lDone;
    }

    if (g_CPresCfg.MapUserToPresSrv(pMsg->qwUserID, TRUE) != g_CPresCfg.GetMyPresServerIndex())
    {
        hr = E_UNEXPECTED;
        XomNtEvent(XEVENT_PRESENCE_CODE_170, "ProcessMsgUserFullMigration sent to the wrong server (%d) for user %I64X", g_CPresCfg.GetMyPresServerIndex(), pMsg->qwUserID);
        goto lDone;
    }

    hr = m_pCSwitchboard->UserFullMigration(pMsg, cbEntireMsg);
    if (FAILED(hr))
    {
        XomNtEvent(XEVENT_PRESENCE_CODE_171, "ProcessMsgUserFullMigration failed hr = 0x%X", hr);
    }

lDone:

    return;

}



/*****************************************************************************

CPresConnection::ProcessMsgAck

Process Ack reply messages.

*****************************************************************************/
void CPresConnection::ProcessMsgAck( BASE_ACK_MSG *pMsg, DWORD cbEntireMsg )
{
    XOMASSERT(m_pCallback != NULL);

    if( cbEntireMsg != sizeof(BASE_ACK_MSG) )
    {
        XomNtEvent( 
            XEVENT_PRESENCE_CODE_172,
            "Bad ack message from server @ %s:%d (size %d != %d)",
            inet_ntoa( m_sa.sin_addr ),
            ntohs( m_sa.sin_port ),
            cbEntireMsg,
            sizeof(BASE_ACK_MSG) );

        return;
    }

    XomTrace(
        PresenceDebug, 
        L_NORMAL, 
        "Ack from %s:%d user=%I64X seq=%d hr=%X",
        inet_ntoa( m_sa.sin_addr ), 
        ntohs( m_sa.sin_port ),
        pMsg->qwAckUserID,
        pMsg->dwAckSeqNum,
        pMsg->hrAck );

    // else
    {
        XomNtEvent( 
            XEVENT_PRESENCE_CODE_173,
            "Ack contained unexpected message type from server @ %s:%d type=%d user=%I64X seq=%d hr=%X",
            inet_ntoa( m_sa.sin_addr ),
            ntohs( m_sa.sin_port ),
            pMsg->dwAckMsgType,
            pMsg->qwAckUserID,
            pMsg->dwAckSeqNum,
            pMsg->hrAck );

        return;
    }
}

/*****************************************************************************

CPresConnection::ProcessMsgSendReply

Process send reply messages from the Notification server.

*****************************************************************************/
void CPresConnection::ProcessMsgSendReply( Q_SEND_MESSAGE_INTERNAL_REPLY_MSG *pMsg, DWORD cbEntireMsg )
{
    XOMASSERT( m_pCallback != NULL );

    SendMessageReplyHandler *pCCtx = NULL;
    SendMessageReplyHandler *pCPrev = NULL;

    if( cbEntireMsg < sizeof( Q_SEND_MESSAGE_INTERNAL_REPLY_MSG ) ||
        cbEntireMsg != sizeof( Q_SEND_MESSAGE_INTERNAL_REPLY_MSG ) + pMsg->cRecipients * sizeof( Q_RECIPIENT_RESULT ) )
    {
        XomNtEvent( 
            XEVENT_PRESENCE_CODE_174,
            "Bad send reply from server @ %s:%d (size %d != %d)",
            inet_ntoa( m_sa.sin_addr ),
            ntohs( m_sa.sin_port ),
            cbEntireMsg,
            sizeof( Q_SEND_MESSAGE_INTERNAL_REPLY_MSG ) + pMsg->cRecipients * sizeof( Q_RECIPIENT_RESULT ) );
        return;
    }

    XomTrace(
        PresenceDebug, 
        L_NORMAL, 
        "Send Message reply from peer %s:%d seq=%d hr=%X srv=%d",
        inet_ntoa( m_sa.sin_addr ), 
        ntohs( m_sa.sin_port ),
        pMsg->dwSeqNum,
        pMsg->hr,
        m_dwPresServerIndex );

    // Match it with its context
    pCCtx = m_pCSendMessageListHead;

    while ( NULL != pCCtx && 
            pCCtx->m_pPerServerInfo[ m_dwPresServerIndex ].m_dwSeqNum != pMsg->dwContext)
    {
        pCPrev = pCCtx;
        pCCtx = pCCtx->m_pPerServerInfo[ m_dwPresServerIndex ].m_pCNext;
    }
    if( NULL == pCCtx )
    {
        XomNtEvent( 
            XEVENT_PRESENCE_CODE_175,
            "Mismatched send message reply from peer @ %s:%d type=%d seq=%d",
            inet_ntoa( m_sa.sin_addr ),
            ntohs( m_sa.sin_port ),
            pMsg->dwMsgType,
            pMsg->dwSeqNum );
        return;
    }

    // We have a match, remove it from the list
    if( NULL != pCPrev )
    {
        pCPrev->m_pPerServerInfo[ m_dwPresServerIndex ].m_pCNext = pCCtx->m_pPerServerInfo[ m_dwPresServerIndex ].m_pCNext;
    }
    else
    {
        XOMASSERT( pCCtx == m_pCSendMessageListHead );
        m_pCSendMessageListHead = pCCtx->m_pPerServerInfo[ m_dwPresServerIndex ].m_pCNext;   
    }
    if( m_pCSendMessageListTail == pCCtx )
    {
        m_pCSendMessageListTail = pCPrev;
    }
    pCCtx->m_pPerServerInfo[ m_dwPresServerIndex ].m_pCNext = NULL;

    // no longer held by the PConn object.
    pCCtx->Release();

    // NOTE: This may free the context if it is the last send reply, don't touch it after this.
    pCCtx->HandleSendReply( pMsg->cRecipients, (Q_RECIPIENT_RESULT*)( pMsg + 1 ), pMsg->hr);
}

/*****************************************************************************

CXPCluster::CXPCluster

Constructor

*****************************************************************************/
CXPCluster::CXPCluster() :
    m_pCCompPort(NULL),
    m_pCListenSocket(NULL),
    m_rgCPConnInfo(NULL),
    m_pCSwitchboard(NULL),
    m_dwLastConnAttempt(0)
{
}

/*****************************************************************************

CXPCluster::~CXPCluster

Destructor

*****************************************************************************/
CXPCluster::~CXPCluster()
{
    Shutdown();
}

/*****************************************************************************

CXPCluster::Init

Initializer, must be called before first use.

*****************************************************************************/
HRESULT CXPCluster::Init(CSwitchboard *pCSwitchboard)
{
    HRESULT hr = S_OK;
    DWORD dwIndex;
    sockaddr_in sa;

    // Create worker threads to deal with incoming network traffic
    hr = CCompletionPort::CreateInstance(
        0,  // dwConcurrancy
        1,  // dwThreadPoolSize
        THREAD_PRIORITY_NORMAL,
        &m_pCCompPort );

    if(FAILED(hr))
    {
        XomNtEvent(XEVENT_PRESENCE_CONFIG_22, "Unrecoverable failure while initializing: CCompPort::CreateInstance failed (%X)", hr);
        goto lDone;
    }
    
    XOMASSERT( NULL == m_pCSwitchboard );
    m_pCSwitchboard = pCSwitchboard;
    m_pCSwitchboard->AddRef();

    // Init our array of server connections
    m_rgCPConnInfo = new CPConnInfo[g_CPresCfg.GetNumPresServers()];
    if (m_rgCPConnInfo == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    for (dwIndex = 0; dwIndex < g_CPresCfg.GetNumPresServers(); dwIndex++)
    {
        m_rgCPConnInfo[dwIndex].pCPresConn = NULL;
        m_rgCPConnInfo[dwIndex].fInit = TRUE;
        m_rgCPConnInfo[dwIndex].fConnected = FALSE;
    }

    // Create our listening socket on the designated completion port
    hr = CServerSocket::CreateInstance(&m_pCListenSocket, m_pCCompPort, m_pCCompPort);
    if(FAILED(hr))
    {
       XomNtEvent(XEVENT_PRESENCE_CONFIG_23, "Unrecoverable failure while initializing: CServSocket::CreateInstance failed (%X)", hr);
       goto lDone;
    }
    
    memset(&sa, 0, sizeof(sa));
    
    sa.sin_family = AF_INET;
    sa.sin_port = htons(g_CPresCfg.GetPeerPort());
    
    hr = m_pCListenSocket->Init(IPPROTO_TCP, &sa, TRUE);
    if(FAILED(hr))
    {
        XomNtEvent(XEVENT_PRESENCE_CONFIG_24, "Unrecoverable failure while initializing: CServSocket::Init failed (%X)", hr);
        goto lDone;
    }
    
    hr = m_pCListenSocket->Listen(SOMAXCONN);
    if(FAILED(hr))
    {
        XomNtEvent(XEVENT_PRESENCE_CONFIG_25, "Unrecoverable failure while initializing: CServSocket::Listen failed (%X)", hr);
        goto lDone;
    }
    
    hr = m_pCListenSocket->Accept(this, 0x12345678);
    if( FAILED( hr ) )
    {
        goto lDone;
    }

    // Connect up
    hr = AttemptConnections();

    hr = S_OK;
    
lDone:
    return hr;
}

/*****************************************************************************

CXPCluster::Shutdown

Deinitializer, called to clean up.

*****************************************************************************/
void CXPCluster::Shutdown()
{
    SAFE_SHUTRELEASE(m_pCCompPort);
    SAFE_RELEASE(m_pCSwitchboard);

    if (m_rgCPConnInfo != NULL)
    {
        delete[] m_rgCPConnInfo;
        m_rgCPConnInfo = NULL;
    }
}

/*****************************************************************************

CXPCluster::PeriodicHeartbeat

Called periodicly on service heartbeat.  Does maintainence such as 
reattempting connections.

*****************************************************************************/
void CXPCluster::PeriodicHeartbeat()
{
    HRESULT hr;

    hr = AttemptConnections();
}

HRESULT CXPCluster::SendPreMigrationMessage(QWORD qwUserID)
{
    HRESULT hr = S_OK;
    
    DWORD dwAltServer = g_CPresCfg.MapUserToPresSrv(qwUserID, TRUE);
    if (dwAltServer == g_CPresCfg.GetMyPresServerIndex())
    {
        // migrating back to ourselves?
        hr = E_UNEXPECTED;
        goto lDone;
    }

    if (m_rgCPConnInfo[dwAltServer].pCPresConn == NULL)
    {
        hr = HRESULT_FROM_WIN32(WSAENOTCONN);
        goto lDone;
    }

    hr = m_rgCPConnInfo[dwAltServer].pCPresConn->SendPreMigrationMessage(qwUserID);
    
lDone:

    return hr;
}

HRESULT CXPCluster::SendFullMigrationMessage(CPresence *pCPresence)
{
    HRESULT hr = S_OK;

    if (pCPresence == NULL)
    {
        hr = E_POINTER;
        goto lDone;
    }
    
    DWORD dwAltServer = g_CPresCfg.MapUserToPresSrv(pCPresence->GetUserID(), TRUE);
    if (dwAltServer == g_CPresCfg.GetMyPresServerIndex())
    {
        // migrating back to ourselves?
        hr = E_UNEXPECTED;
        goto lDone;
    }

    if (m_rgCPConnInfo[dwAltServer].pCPresConn == NULL)
    {
        hr = HRESULT_FROM_WIN32(WSAENOTCONN);
        goto lDone;
    }

    hr = m_rgCPConnInfo[dwAltServer].pCPresConn->SendFullMigrationMessage(pCPresence);
    
lDone:

    return hr;
}

/*****************************************************************************

CXPCluster::SendMsgAnnounce

Sends an Annouce message to the sources

*****************************************************************************/
HRESULT CXPCluster::SendMsgAnnounce(
    QWORD qwDestUserID, 
    DWORD dwTitleID,
    LPCSTR pszGamerTag,
    DWORD cSourceUserIDs, 
    const QWORD *rgqwSourceUserIDsIn,
    BOOL fUseAltServer)
{
    XOMASSERT(m_pCSwitchboard != NULL);
    XOMASSERT(m_rgCPConnInfo != NULL);

    HRESULT hr = S_OK;
    HRESULT hrRange = S_OK;
    DWORD dwServer = 0;
    DWORD cUsersLeft = 0;
    const QWORD *rgqwUsersStart = NULL;
    QWORD rgqwSourceUserIDs[MAX_BUDDIES];

    // Sort the incomming array by destination
    if (cSourceUserIDs > MAX_BUDDIES)
    {
        // Overflow, drop the extra
        XOMASSERT(FALSE);
        cSourceUserIDs = MAX_BUDDIES;
    }
    memcpy(rgqwSourceUserIDs, rgqwSourceUserIDsIn, cSourceUserIDs * sizeof(QWORD));

    SortUsersByDestination(cSourceUserIDs, rgqwSourceUserIDs, fUseAltServer);

    // Process the sorted array
    cUsersLeft = cSourceUserIDs;
    rgqwUsersStart = rgqwSourceUserIDs;
    DWORD cUsersInRange = 0;
 
    while (cUsersLeft > 0)
    {
        // Set the start of the next range
        rgqwUsersStart = rgqwUsersStart + cUsersInRange;
        cUsersInRange = 1;

        // What server is this range on?
        dwServer = g_CPresCfg.MapUserToPresSrv(rgqwUsersStart[0], fUseAltServer);

        // Figure out how large this range is
        while ((cUsersInRange < cUsersLeft) &&
            (dwServer == g_CPresCfg.MapUserToPresSrv(rgqwUsersStart[cUsersInRange], fUseAltServer)))
        {
            cUsersInRange++;
        }

        // Send the range
        if (m_rgCPConnInfo[dwServer].fConnected)
        {
            hrRange = m_rgCPConnInfo[dwServer].pCPresConn->SendMsgAnnounce(
                qwDestUserID,
                dwTitleID,
                pszGamerTag,
                cUsersInRange,
                rgqwUsersStart);                    
        }
        else
        {
            hrRange = HRESULT_FROM_WIN32(WSAENOTCONN);
        }

        if(FAILED(hrRange))
        {
            hr = hrRange;

            // Connectivity loss logged via another check
            if (hrRange != HRESULT_FROM_WIN32(WSAENOTCONN))
            {
                XomNtEvent( 
                    XEVENT_PRESENCE_CODE_176,
                    "CXPCluster::SendMsgAnnounce to server %d failed hr=0x%X",
                    dwServer,
                    hrRange);
            }
        }

        // Mark off the ones we sent         
        cUsersLeft -= cUsersInRange;
    }
    
    return hr;
}

/*****************************************************************************

CXPCluster::SendMsgSubscribed

Sends a Subscribed message back to the destination.

*****************************************************************************/
HRESULT CXPCluster::SendMsgSubscribed(
    QWORD qwDestUserID, 
    DWORD cSourceUserIDs, 
    const QWORD *rgqwSourceUserIDs)
{
    XOMASSERT(m_pCSwitchboard != NULL);
    XOMASSERT(m_rgCPConnInfo != NULL);

    HRESULT hr = S_OK;
    DWORD dwServer = 0;    

    // Figure out what server to send to
    dwServer = g_CPresCfg.MapUserToPresSrv(qwDestUserID, FALSE);

    // Send it
    if (m_rgCPConnInfo[dwServer].fConnected)
    {
        hr = m_rgCPConnInfo[dwServer].pCPresConn->SendMsgSubscribed(
            qwDestUserID,
            cSourceUserIDs,
            rgqwSourceUserIDs);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(WSAENOTCONN);
    }

    if(FAILED(hr) && (hr != HRESULT_FROM_WIN32(WSAENOTCONN)))
    {
        XomNtEvent( 
            XEVENT_PRESENCE_CODE_177,
            "CXPCluster::SendMsgSubscribed to server %d failed hr=0x%X",
            dwServer,
            hr);
    }
            
    return hr;
}

/*****************************************************************************

CXPCluster::SendMsgUnsubscribe

Sends an Unsubscribe message.

*****************************************************************************/
HRESULT CXPCluster::SendMsgUnsubscribe(
    QWORD qwSourceUserID, 
    DWORD cDestUserIDs, 
    const QWORD *rgqwDestUserIDsIn,
    BOOL fUseAltServer)
{
    XOMASSERT(m_pCSwitchboard != NULL);
    XOMASSERT(m_rgCPConnInfo != NULL);

    HRESULT hr = S_OK;
    HRESULT hrRange = S_OK;
    DWORD dwServer = 0;
    DWORD cUsersLeft = 0;
    const QWORD *rgqwUsersStart = NULL;
    QWORD rgqwDestUserIDs[MAX_BUDDIES];

    // Sort the incomming array by destination
    if (cDestUserIDs > MAX_BUDDIES)
    {
        // Overflow, drop the extra
        XOMASSERT(FALSE);
        cDestUserIDs = MAX_BUDDIES;
    }
    memcpy(rgqwDestUserIDs, rgqwDestUserIDsIn, cDestUserIDs * sizeof(QWORD));

    SortUsersByDestination(cDestUserIDs, rgqwDestUserIDs, fUseAltServer);

    // Process the sorted array
    cUsersLeft = cDestUserIDs;
    rgqwUsersStart = rgqwDestUserIDs;
    DWORD cUsersInRange = 0;
 
    while (cUsersLeft > 0)
    {
        // Set the start of the next range
        rgqwUsersStart = rgqwUsersStart + cUsersInRange;
        cUsersInRange = 1;

        // What server is this range on?
        dwServer = g_CPresCfg.MapUserToPresSrv(rgqwUsersStart[0], fUseAltServer);

        // Figure out how large this range is
        while ((cUsersInRange < cUsersLeft) &&
            (dwServer == g_CPresCfg.MapUserToPresSrv(rgqwUsersStart[cUsersInRange], fUseAltServer)))
        {
            cUsersInRange++;
        }

        // Send the range
        if (m_rgCPConnInfo[dwServer].fConnected)
        {
            hrRange = m_rgCPConnInfo[dwServer].pCPresConn->SendMsgUnsubscribe(
                qwSourceUserID,
                cUsersInRange,
                rgqwUsersStart);
        }
        else
        {
            hrRange = HRESULT_FROM_WIN32(WSAENOTCONN);
        }
        
        if(FAILED(hrRange))
        {
            hr = hrRange;

            // Connectivity loss logged via another check
            if (hrRange != HRESULT_FROM_WIN32(WSAENOTCONN))
            {
                XomNtEvent( 
                    XEVENT_PRESENCE_CODE_178,
                    "CXPCluster::SendMsgUnsubscribe to server %d failed hr=0x%X",
                    dwServer,
                    hrRange);
            }
        }

        // Mark off the ones we sent         
        cUsersLeft -= cUsersInRange;
    }
        
    return hr;
}

/*****************************************************************************

CXPCluster::SendMsgAdded

Sends an Added message.

*****************************************************************************/
HRESULT CXPCluster::SendMsgAdded(
    QWORD qwUserID,
    QWORD qwBuddyID,
    DWORD dwVersion,
    WORD cbBuddyAcctName,
    LPCSTR szBuddyAcctName)
{
    XOMASSERT(m_pCSwitchboard != NULL);
    XOMASSERT(m_rgCPConnInfo != NULL);

    HRESULT hr = S_OK;
    DWORD dwServer = 0;

    // Figure out what server to send to
    dwServer = g_CPresCfg.MapUserToPresSrv(qwUserID, FALSE);

    // Send it
    if (m_rgCPConnInfo[dwServer].fConnected)
    {
        hr = m_rgCPConnInfo[dwServer].pCPresConn->SendMsgAdded(
            qwUserID,
            qwBuddyID,
            dwVersion,
            cbBuddyAcctName,
            szBuddyAcctName);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(WSAENOTCONN);
    }

    if(FAILED(hr) && (hr != HRESULT_FROM_WIN32(WSAENOTCONN)))
    {
        XomNtEvent( 
            XEVENT_PRESENCE_CODE_179,
            "CXPCluster::SendMsgAdded to server %d failed hr=0x%X",
            dwServer,
            hr);
    }
            
    return hr;
}

/*****************************************************************************

CXPCluster::SendMsgAccepted

Sends an Accepted message.

*****************************************************************************/
HRESULT CXPCluster::SendMsgAccepted(
    QWORD qwUserID,
    QWORD qwBuddyID,
    DWORD dwVersion,
    WORD cbBuddyAcctName,
    LPCSTR szBuddyAcctName)
{
    XOMASSERT(m_pCSwitchboard != NULL);
    XOMASSERT(m_rgCPConnInfo != NULL);

    HRESULT hr = S_OK;
    DWORD dwServer = 0;
 
    // Figure out what server to send to
    dwServer = g_CPresCfg.MapUserToPresSrv(qwUserID, FALSE);

    // Send it
    if (m_rgCPConnInfo[dwServer].fConnected)
    {
        hr = m_rgCPConnInfo[dwServer].pCPresConn->SendMsgAccepted(
            qwUserID,
            qwBuddyID,
            dwVersion,
            cbBuddyAcctName,
            szBuddyAcctName);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(WSAENOTCONN);
    }

    if(FAILED(hr) && (hr != HRESULT_FROM_WIN32(WSAENOTCONN)))
    {
        XomNtEvent( 
            XEVENT_PRESENCE_CODE_180,
            "CXPCluster::SendMsgAccepted to server %d failed hr=0x%X",
            dwServer,
            hr);
    }
        
    return hr;
}

/*****************************************************************************

CXPCluster::SendMsgRemoved

Sends a Removed message.

*****************************************************************************/
HRESULT CXPCluster::SendMsgRemoved(
    QWORD qwUserID,
    QWORD qwBuddyID,
    DWORD dwVersion)
{
    XOMASSERT(m_pCSwitchboard != NULL);
    XOMASSERT(m_rgCPConnInfo != NULL);

    HRESULT hr = S_OK;
    DWORD dwServer = 0;

    // Figure out what server to send to
    dwServer = g_CPresCfg.MapUserToPresSrv(qwUserID, FALSE);

    // Send it
    if (m_rgCPConnInfo[dwServer].fConnected)
    {
        hr = m_rgCPConnInfo[dwServer].pCPresConn->SendMsgRemoved(
            qwUserID,
            qwBuddyID,
            dwVersion);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(WSAENOTCONN);
    }
        
    return hr;
}

/*****************************************************************************

CXPCluster::SendMsgInviteAnswer

Sends an Invitation Answer message.

*****************************************************************************/
HRESULT CXPCluster::SendMsgInviteAnswer(
    QWORD qwUserID,
    QWORD qwHostID,
    QWORD qwMatchSessionID,
    WORD wAnswer)
{
    XOMASSERT(m_pCSwitchboard != NULL);
    XOMASSERT(m_rgCPConnInfo != NULL);

    HRESULT hr = S_OK;
    DWORD dwServer = 0;

    // Figure out what server to send to
    // Unlike other messages, this is sent to the Host's presence server
    // CONSIDER: Use a different message type for clairity
    dwServer = g_CPresCfg.MapUserToPresSrv(qwHostID, FALSE);

    // Send it
    if (m_rgCPConnInfo[dwServer].fConnected)
    {
        hr = m_rgCPConnInfo[dwServer].pCPresConn->SendMsgInviteAnswer(
            qwUserID,
            qwHostID,
            qwMatchSessionID,
            wAnswer);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(WSAENOTCONN);
    }
        
    return hr;
}

/*****************************************************************************

CXPCluster::SendAddAffiliates

Sends a AddAffiliates message to the sources

*****************************************************************************/
HRESULT CXPCluster::SendAddAffiliates(
    WORD cwAffiliates,
    QWORD *pqwAffiliates,
    DWORD dwTitleID,
    DWORD dwListFlag,
    QWORD qwUserID)
{
    XOMASSERT(m_pCSwitchboard != NULL);
    XOMASSERT(m_rgCPConnInfo != NULL);

    HRESULT hr = S_OK;

    SortUsersByDestination((DWORD)cwAffiliates, pqwAffiliates, FALSE);

    // Process the sorted array
    DWORD cUsersLeft = cwAffiliates;
    QWORD *rgqwUsersStart = pqwAffiliates;
    DWORD cUsersInRange = 0;

    while (cUsersLeft > 0)
    {
        // Set the start of the next range
        rgqwUsersStart += cUsersInRange;
        cUsersInRange = 1;

        // What server is this range on?
        DWORD dwServer = g_CPresCfg.MapUserToPresSrv(rgqwUsersStart[0], FALSE);
        HRESULT hrRange = S_OK;

        // Figure out how large this range is
        while ((cUsersInRange < cUsersLeft) &&
            (dwServer == g_CPresCfg.MapUserToPresSrv(rgqwUsersStart[cUsersInRange], FALSE)))
        {
            cUsersInRange++;
        }

        // Send the range
        if (m_rgCPConnInfo[dwServer].fConnected)
        {
            for (DWORD dwAdd = 0; dwAdd < cUsersInRange; dwAdd++)
            {
                hrRange = m_rgCPConnInfo[dwServer].pCPresConn->SendAddAffiliates(
                    rgqwUsersStart[dwAdd],
                    dwTitleID,
                    dwListFlag,
                    1,
                    &qwUserID);
                if (FAILED(hrRange))
                {
                    break;
                }
            }
        }
        else
        {
            hrRange = HRESULT_FROM_WIN32(WSAENOTCONN);
        }

        if(FAILED(hrRange))
        {
            hr = hrRange;

            // Connectivity loss logged via another check
            if (hrRange != HRESULT_FROM_WIN32(WSAENOTCONN))
            {
                XomNtEvent( 
                    XEVENT_PRESENCE_CODE_181,
                    "CXPCluster::SendQueryAffiliatesInternal to server %d failed hr=0x%X",
                    dwServer,
                    hrRange);
            }
        }

        // Mark off the ones we sent         
        cUsersLeft -= cUsersInRange;
    }

    return hr;
}

/*****************************************************************************

CXPCluster::SendGetPresenceInfo

Sends a GetPresenceInfo message to the sources

*****************************************************************************/
HRESULT CXPCluster::SendGetPresenceInfo(CPresenceInfoContext *pCCtx, BOOL fUseAltServer)
{
    XOMASSERT(m_pCSwitchboard != NULL);
    XOMASSERT(m_rgCPConnInfo != NULL);

    HRESULT hr = S_OK;

    SortUsersByDestination(pCCtx->m_cdwPUIDs, pCCtx->m_rgPUIDs, fUseAltServer);

    // Process the sorted array
    DWORD cUsersLeft = pCCtx->m_cdwPUIDs;
    QWORD *rgqwUsersStart = pCCtx->m_rgPUIDs;
    DWORD cUsersInRange = 0;

    while (cUsersLeft > 0)
    {
        // Set the start of the next range
        rgqwUsersStart += cUsersInRange;
        cUsersInRange = 1;

        // What server is this range on?
        DWORD dwServer = g_CPresCfg.MapUserToPresSrv(rgqwUsersStart[0], fUseAltServer);
        HRESULT hrRange = S_OK;

        // Figure out how large this range is
        while ((cUsersInRange < cUsersLeft) &&
            (dwServer == g_CPresCfg.MapUserToPresSrv(rgqwUsersStart[cUsersInRange], fUseAltServer)))
        {
            cUsersInRange++;
        }

        // Send the range
        if (m_rgCPConnInfo[dwServer].fConnected)
        {
            // NOTE: presence info reply packets get big.  so to avoid maxxing the receive buffer, we slice up
            // the user range into multiple packets.
            DWORD cMaxUsersPerSend = (CTCPCnt_RECEIVE_BUFFER_LENGTH - sizeof(P_GET_PRESENCE_INFO_MSG)) / (sizeof(P_PRESENCE_INFO_DATA_MSG) + MAX_TITLE_STATE_BYTES + g_CPresCfg.GetMaxRichPresenceBytes());
            QWORD *rgqwBatchStart = rgqwUsersStart;
            DWORD cUsersToBatch = cUsersInRange;
            
            while (cUsersToBatch > 0)
            {
                DWORD cUsersInBatch = (cUsersToBatch > cMaxUsersPerSend) ? cMaxUsersPerSend : cUsersToBatch;
                                    
                HRESULT hrBatch = m_rgCPConnInfo[dwServer].pCPresConn->SendGetPresenceInfo(
                    pCCtx->m_dwContextID,
                    pCCtx->m_qwUserID,
                    cUsersInBatch,
                    rgqwBatchStart);
        
                cUsersToBatch -= cUsersInBatch;
                rgqwBatchStart += cUsersInBatch;
        
                if (FAILED(hrBatch))
                {
                    hrRange = hrBatch;
                }
                else
                {
                    pCCtx->m_cPendingServerReplies++;
                }
            }
        }
        else
        {
            hrRange = HRESULT_FROM_WIN32(WSAENOTCONN);
        }

        if(FAILED(hrRange))
        {
            hr = hrRange;

            // Connectivity loss logged via another check
            if (hrRange != HRESULT_FROM_WIN32(WSAENOTCONN))
            {
                XomNtEvent( 
                    XEVENT_PRESENCE_CODE_182,
                    "CXPCluster::SendGetPresenceInfo to server %d failed hr=0x%X",
                    dwServer,
                    hrRange);
            }
        }

        // Mark off the ones we sent         
        cUsersLeft -= cUsersInRange;
    }

    if (pCCtx->m_cPendingServerReplies == 0)
    {
        // this can only happen if we fail to send all messages.
        
        g_pCPresenceInfoContextQueue->Remove(pCCtx);
        pCCtx->m_cPendingServerReplies = 1;
        pCCtx->ApplyPresenceData(0, NULL);
    }
    
    return hr;
}

/*****************************************************************************

CXPCluster::SendMsgWatchStart

Sends an Watch Start message.

*****************************************************************************/
HRESULT CXPCluster::SendMsgWatchStart(
    QWORD qwDestUserID, 
    DWORD cSourceUserIDs, 
    const QWORD *rgqwSourceUserIDsIn,
    BOOL fUseAltServer)
{
    XOMASSERT(m_pCSwitchboard != NULL);
    XOMASSERT(m_rgCPConnInfo != NULL);

    HRESULT hr = S_OK;
    HRESULT hrRange = S_OK;
    DWORD dwServer = 0;
    DWORD cUsersLeft = 0;
    const QWORD *rgqwUsersStart = NULL;
    QWORD rgqwSourceUserIDs[MAX_WATCHES];

    // Sort the incomming array by destination
    if (cSourceUserIDs > MAX_WATCHES)
    {
        // Overflow, drop the extra
        XOMASSERT(FALSE);
        cSourceUserIDs = MAX_WATCHES;
    }
    memcpy(rgqwSourceUserIDs, rgqwSourceUserIDsIn, cSourceUserIDs * sizeof(QWORD));

    SortUsersByDestination(cSourceUserIDs, rgqwSourceUserIDs, fUseAltServer);

    // Process the sorted array
    cUsersLeft = cSourceUserIDs;
    rgqwUsersStart = rgqwSourceUserIDs;
    DWORD cUsersInRange = 0;
 
    while (cUsersLeft > 0)
    {
        // Set the start of the next range
        rgqwUsersStart = rgqwUsersStart + cUsersInRange;
        cUsersInRange = 1;

        // What server is this range on?
        dwServer = g_CPresCfg.MapUserToPresSrv(rgqwUsersStart[0], fUseAltServer);

        // Figure out how large this range is
        while ((cUsersInRange < cUsersLeft) &&
            (dwServer == g_CPresCfg.MapUserToPresSrv(rgqwUsersStart[cUsersInRange], fUseAltServer)))
        {
            cUsersInRange++;
        }

        // Send the range
        if (m_rgCPConnInfo[dwServer].fConnected)
        {
            hrRange = m_rgCPConnInfo[dwServer].pCPresConn->SendMsgWatchStart(
                qwDestUserID,
                cUsersInRange,
                rgqwUsersStart);
        }
        else
        {
            hrRange = HRESULT_FROM_WIN32(WSAENOTCONN);
        }

        if(FAILED(hrRange))
        {
            hr = hrRange;

            // Connectivity loss logged via another check
            if (hrRange != HRESULT_FROM_WIN32(WSAENOTCONN))
            {
                XomNtEvent( 
                    XEVENT_PRESENCE_CODE_183,
                    "CXPCluster::SendMsgWatchStart to server %d failed hr=0x%X",
                    dwServer,
                    hrRange);
            }
        }

        // Mark off the ones we sent         
        cUsersLeft -= cUsersInRange;
    }
    
    return hr;
}

/*****************************************************************************

CXPCluster::SendMsgWatchStop

Sends an Watch Stop message.

*****************************************************************************/
HRESULT CXPCluster::SendMsgWatchStop(
    QWORD qwDestUserID, 
    DWORD cSourceUserIDs, 
    const QWORD *rgqwSourceUserIDsIn,
    BOOL fUseAltServer)
{
    XOMASSERT(m_pCSwitchboard != NULL);
    XOMASSERT(m_rgCPConnInfo != NULL);

    HRESULT hr = S_OK;
    HRESULT hrRange = S_OK;
    DWORD dwServer = 0;
    DWORD cUsersLeft = 0;
    const QWORD *rgqwUsersStart = NULL;
    QWORD rgqwSourceUserIDs[MAX_WATCHES];

    // Sort the incomming array by destination
    if (cSourceUserIDs > MAX_WATCHES)
    {
        // Overflow, drop the extra
        XOMASSERT(FALSE);
        cSourceUserIDs = MAX_WATCHES;
    }
    memcpy(rgqwSourceUserIDs, rgqwSourceUserIDsIn, cSourceUserIDs * sizeof(QWORD));

    SortUsersByDestination(cSourceUserIDs, rgqwSourceUserIDs, fUseAltServer);

    // Process the sorted array
    cUsersLeft = cSourceUserIDs;
    rgqwUsersStart = rgqwSourceUserIDs;
    DWORD cUsersInRange = 0;
 
    while (cUsersLeft > 0)
    {
        // Set the start of the next range
        rgqwUsersStart = rgqwUsersStart + cUsersInRange;
        cUsersInRange = 1;

        // What server is this range on?
        dwServer = g_CPresCfg.MapUserToPresSrv(rgqwUsersStart[0], fUseAltServer);

        // Figure out how large this range is
        while ((cUsersInRange < cUsersLeft) &&
            (dwServer == g_CPresCfg.MapUserToPresSrv(rgqwUsersStart[cUsersInRange], fUseAltServer)))
        {
            cUsersInRange++;
        }

        // Send the range
        if (m_rgCPConnInfo[dwServer].fConnected)
        {
            hrRange = m_rgCPConnInfo[dwServer].pCPresConn->SendMsgWatchStop(
                qwDestUserID,
                cUsersInRange,
                rgqwUsersStart);
        }
        else
        {
            hrRange = HRESULT_FROM_WIN32(WSAENOTCONN);
        }

        if(FAILED(hrRange))
        {
            hr = hrRange;

            // Connectivity loss logged via another check
            if (hrRange != HRESULT_FROM_WIN32(WSAENOTCONN))
            {
                XomNtEvent( 
                    XEVENT_PRESENCE_CODE_184,
                    "CXPCluster::SendMsgWatchStop to server %d failed hr=0x%X",
                    dwServer,
                    hrRange);
            }
        }

        // Mark off the ones we sent         
        cUsersLeft -= cUsersInRange;
    }
    
    return hr;
}

/*****************************************************************************

CXPCluster::OnSocketAccept

Callback from listening socket, used to accept new connections.

*****************************************************************************/
void CXPCluster::OnSocketAccept(
     CServerSocket *pCListenSocket,
     CServerSocket *pCAcceptedSocket,
     sockaddr_in *pLocalAddr,
     sockaddr_in *pRemoteAddr,
     HRESULT hrIn,
     QWORD qwCallbackArg )
{
    XOMASSERT(m_pCSwitchboard != NULL);
    XOMASSERT(m_pCListenSocket != NULL);
    XOMASSERT(m_rgCPConnInfo != NULL);

    HRESULT hr = hrIn;

    CPresConnection *pCConnection = NULL;

    // Check the incomming HRESULT
    if(HRESULT_FROM_WIN32( ERROR_OPERATION_ABORTED) == hr)
    {
        // Most likely case is that we're shutting down
        hr = S_OK;

        goto lDone;
    }
    else if (FAILED(hr))
    {
        goto lDone;
    }
    
    XOMASSERT( m_pCListenSocket == pCListenSocket );
    
    // Before anything else happens, accept a new connection
    hr = m_pCListenSocket->Accept( this, 0x12345678 );
    if(FAILED(hr))
    {
        XomNtEvent(XEVENT_PRESENCE_CODE_185, "Error accepting new peer hr=%X", hr );
        goto lDone;
    }
    
    XOMASSERT( NULL != pCAcceptedSocket );
    
    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Peer connected addr=%s:%d",
        inet_ntoa( pRemoteAddr->sin_addr ), 
        ntohs( pRemoteAddr->sin_port ));
    
    // Allocate a new connection management class
    pCConnection = new CPresConnection(0xFFFFFFFF);
    if( NULL == pCConnection )
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Hand over control of the socket to the connection class
    hr = pCConnection->InitAccept(pCAcceptedSocket, this, m_pCSwitchboard);
    if( FAILED( hr ) )
    {
        goto lDone;
    }

    pCConnection = NULL;
            
lDone:
    SAFE_RELEASE(pCConnection);
}

/*****************************************************************************

CXPCluster::OnConnect

Connect callback from one of the connection objects.  Used to do bookkeeping
on the connection object array.

*****************************************************************************/
void CXPCluster::OnConnect(CPresConnection *pCConn)
{
    XOMASSERT(m_rgCPConnInfo != NULL);

    DWORD dwIndex;

    // Find the connection pointer in the array
    // CONSIDER: Pass an index to the connection object to avoid this
    dwIndex = 0;
    while (dwIndex < g_CPresCfg.GetNumPresServers()) 
    {
        if (m_rgCPConnInfo[dwIndex].pCPresConn == pCConn)
        {
            // Fire an event

            if (!m_rgCPConnInfo[dwIndex].fInit)
            {
                
                XomNtEvent(
                    XEVENT_PRESENCE_INFO_4,
                    "Reconnected to index %d addr %S",
                    dwIndex,
                    g_CPresCfg.GetPresServerName(dwIndex).m_str);
            }
            else
            {
                XomNtEvent(
                    XEVENT_PRESENCE_INFO_5,
                    "Connected to index %d addr %S",
                    dwIndex,
                    g_CPresCfg.GetPresServerName(dwIndex).m_str);
            }

            pCConn->SendMsgHello();

            // Update the bookkepping
            m_rgCPConnInfo[dwIndex].fInit = FALSE;
            m_rgCPConnInfo[dwIndex].fConnected = TRUE;
            return;
        }

        dwIndex++;
    }
}

/*****************************************************************************

CXPCluster::OnDisconnect

Drop callback from one of the connection objects.  Used to do bookkeeping
on the connection object array.

*****************************************************************************/
void CXPCluster::OnDisconnect(CPresConnection *pCConn)
{
    // move this to switchboard thread.

    CPConnDisconnectContext *pCCtx = new CPConnDisconnectContext();
    if (pCCtx != NULL)
    {
        AddRef();
        pCConn->AddRef();
        pCCtx->m_pCCluster = this;
        pCCtx->m_pCConn = pCConn;
        
        HRESULT hr = m_pCSwitchboard->PostCompletion(pCCtx);
        if (FAILED(hr))
        {
            SAFE_RELEASE(pCCtx);
        }
    }   
}
void CXPCluster::OnDisconnectInternal(CPresConnection *pCConn)
{
    XOMASSERT(m_rgCPConnInfo != NULL);

    DWORD dwIndex;

    // Find the connection pointer in the array
    // CONSIDER: Pass an index to the connection object to avoid this
    dwIndex = 0;
    while (dwIndex < g_CPresCfg.GetNumPresServers()) 
    {
        if (m_rgCPConnInfo[dwIndex].pCPresConn == pCConn)
        {
            // Fire an event if we lost a connection (but not failed to connect)
            if (m_rgCPConnInfo[dwIndex].fConnected)
            {
                XomNtEvent(
                    XEVENT_PRESENCE_COMM_41,
                    "Disconnected index %d addr %S",
                    dwIndex,
                    g_CPresCfg.GetPresServerName(dwIndex).m_str);
            }
            else if (m_rgCPConnInfo[dwIndex].fInit)
            {
                XomNtEvent(
                    XEVENT_PRESENCE_COMM_42,
                    "Disconnected index %d addr %S",
                    dwIndex,
                    g_CPresCfg.GetPresServerName(dwIndex).m_str);
            }

            // Update the bookkepping
            SAFE_RELEASE(m_rgCPConnInfo[dwIndex].pCPresConn);
            m_rgCPConnInfo[dwIndex].fInit = FALSE;
            m_rgCPConnInfo[dwIndex].fConnected = FALSE;
            return;
        }

        dwIndex++;
    }
}

/*****************************************************************************

CXPCluster::QueuePresence

Sends the given user's presence to the destination buddies' notification queues
reguardless of where they reside.

*****************************************************************************/
HRESULT CXPCluster::QueuePresence(
    CPresence *pCPresence, 
    const QWORD *rgqwBuddyIDsIn, 
    DWORD cBuddyIDs )
{
    XOMASSERT(m_rgCPConnInfo != NULL);

    HRESULT hr = S_OK;
    HRESULT hrRange = S_OK;
    DWORD dwIndex = 0;
    DWORD dwServer = 0;
    DWORD dwClientType = 0;
    DWORD cBuddyIDsLeft = 0;
    QWORD *rgqwBuddyIDsStart = NULL;
    QWORD rgqwBuddyIDs[MAX_BUDDIES];

    if (FALSE == pCPresence->CanSharePresence(TRUE))
    {
        // We aren't sharing!
        XomTrace(
            PresenceDebug,
            L_NORMAL,
            "QueuePresence: user=%I64X has insufficient privileges to Queue Presence.",
            pCPresence->GetUserID()
            );
            
        return S_OK;
    }
    
    // Sort the incomming array by destination
    if (cBuddyIDs > MAX_BUDDIES)
    {
        // Overflow, drop the extra
        XOMASSERT(FALSE);
        cBuddyIDs = MAX_BUDDIES;
    }

    memcpy(rgqwBuddyIDs, rgqwBuddyIDsIn, cBuddyIDs * sizeof(QWORD));

    SortUsersByDestination(cBuddyIDs, rgqwBuddyIDs, dwIndex != 0);

    // Process the sorted array
    cBuddyIDsLeft = cBuddyIDs;
    rgqwBuddyIDsStart = rgqwBuddyIDs;
    DWORD cBuddyIDsInRange = 0;
 
    while (cBuddyIDsLeft > 0)
    {
        // Set the start of the next range
        rgqwBuddyIDsStart = rgqwBuddyIDsStart + cBuddyIDsInRange;
        cBuddyIDsInRange = 1;

        // What server is this range on?
        dwServer = g_CPresCfg.MapUserToPresSrv(rgqwBuddyIDsStart[0], FALSE);
        dwClientType = GET_PUID_CLIENT_TYPE(rgqwBuddyIDsStart[0]);

        // Figure out how large this range is
        while ((cBuddyIDsInRange < cBuddyIDsLeft) &&
            (dwServer == g_CPresCfg.MapUserToPresSrv(rgqwBuddyIDsStart[cBuddyIDsInRange], FALSE)) &&
            (dwClientType == GET_PUID_CLIENT_TYPE(rgqwBuddyIDsStart[cBuddyIDsInRange])))
        {
            cBuddyIDsInRange++;
        }

        // clear extra bits in the puids
        for (DWORD iPuid = 0; iPuid < cBuddyIDsInRange; iPuid++)
        {
            rgqwBuddyIDsStart[iPuid] = GET_PUID_BITS(rgqwBuddyIDsStart[iPuid]);
        }

        hrRange = S_OK;

        // Send the range
        if ((dwClientType == PRES_CLIENT_TYPE_XBOX) || (dwClientType == PRES_CLIENT_TYPE_UNKNOWN))
        {                
            if (m_rgCPConnInfo[dwServer].fConnected)
            {
                hrRange = m_rgCPConnInfo[dwServer].pCPresConn->QueuePresence(pCPresence, rgqwBuddyIDsStart, cBuddyIDsInRange);   
            }
            else
            {
                hrRange = HRESULT_FROM_WIN32(WSAENOTCONN);
            }  
        }
        if (SUCCEEDED(hrRange) && ((dwClientType == PRES_CLIENT_TYPE_XENON) || (dwClientType == PRES_CLIENT_TYPE_UNKNOWN)))
        {
            if (m_rgCPConnInfo[dwServer].fConnected)
            {
                hrRange = m_rgCPConnInfo[dwServer].pCPresConn->QueuePresence2(pCPresence, rgqwBuddyIDsStart, cBuddyIDsInRange);   
            }
            else
            {
                hrRange = HRESULT_FROM_WIN32(WSAENOTCONN);
            }  
        }

        if(FAILED(hrRange))
        {
            hr = hrRange;

                // Connectivity loss logged via another check
            if ((hrRange != HRESULT_FROM_WIN32(WSAENOTCONN)) &&
                // user we're queueing to has logged off
                (hrRange != HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER)))
            {
                XomNtEvent( 
                    XEVENT_PRESENCE_CODE_186,
                    "CXPCluster::QueuePresence to server %d failed hr=0x%X",
                    dwServer,
                    hrRange);
            }
        }

        // Mark off the ones we sent         
        cBuddyIDsLeft -= cBuddyIDsInRange;
    }

    return hr;
}

/*****************************************************************************

CXPCluster::QueuePresenceOffline

Sends the given user's offline presence to the destination buddies' notification queues
reguardless of where they reside.

*****************************************************************************/
HRESULT CXPCluster::QueuePresenceOffline(
    CPresence *pCPresence,
    DWORD cdwDestUsers,
    QWORD* rgqwDestUserIDs)
{
    XOMASSERT(m_rgCPConnInfo != NULL);

    HRESULT hr = S_OK;
    HRESULT hrRange = S_OK;
    DWORD dwServer = 0;
    DWORD dwClientType = 0;
    DWORD cBuddyIDsLeft = 0;
    QWORD *rgqwBuddyIDsStart = NULL;
    QWORD rgqwBuddyIDs[MAX_BUDDIES];

    // Sort the incomming array by destination
    if (cdwDestUsers > MAX_BUDDIES)
    {
        // Overflow, drop the extra
        XOMASSERT(FALSE);
        cdwDestUsers = MAX_BUDDIES;
    }

    memcpy(rgqwBuddyIDs, rgqwDestUserIDs, cdwDestUsers * sizeof(QWORD));

    SortUsersByDestination(cdwDestUsers, rgqwBuddyIDs, FALSE);

    // Process the sorted array
    cBuddyIDsLeft = cdwDestUsers;
    rgqwBuddyIDsStart = rgqwBuddyIDs;
    DWORD cBuddyIDsInRange = 0;
 
    while (cBuddyIDsLeft > 0)
    {
        // Set the start of the next range
        rgqwBuddyIDsStart = rgqwBuddyIDsStart + cBuddyIDsInRange;
        cBuddyIDsInRange = 1;

        // What server is this range on?
        dwServer = g_CPresCfg.MapUserToPresSrv(rgqwBuddyIDsStart[0], FALSE);
        dwClientType = GET_PUID_CLIENT_TYPE(rgqwBuddyIDsStart[0]);

        // Figure out how large this range is
        while ((cBuddyIDsInRange < cBuddyIDsLeft) &&
            (dwServer == g_CPresCfg.MapUserToPresSrv(rgqwBuddyIDsStart[cBuddyIDsInRange], FALSE)) &&
            (dwClientType == GET_PUID_CLIENT_TYPE(rgqwBuddyIDsStart[cBuddyIDsInRange])))
        {
            cBuddyIDsInRange++;
        }

        // clear extra bits in the puids
        for (DWORD iPuid = 0; iPuid < cBuddyIDsInRange; iPuid++)
        {
            rgqwBuddyIDsStart[iPuid] = GET_PUID_BITS(rgqwBuddyIDsStart[iPuid]);
        }

        hrRange = S_OK;

        // Send the range
        if ((dwClientType == PRES_CLIENT_TYPE_XBOX) || (dwClientType == PRES_CLIENT_TYPE_UNKNOWN))
        {                
            if (m_rgCPConnInfo[dwServer].fConnected)
            {
                hrRange = m_rgCPConnInfo[dwServer].pCPresConn->QueuePresenceOffline(pCPresence, cBuddyIDsInRange, rgqwBuddyIDsStart);   
            }
            else
            {
                hrRange = HRESULT_FROM_WIN32(WSAENOTCONN);
            }  
        }
        if (SUCCEEDED(hrRange) && ((dwClientType == PRES_CLIENT_TYPE_XENON) || (dwClientType == PRES_CLIENT_TYPE_UNKNOWN)))
        {
            if (m_rgCPConnInfo[dwServer].fConnected)
            {
                hrRange = m_rgCPConnInfo[dwServer].pCPresConn->QueuePresence2Offline(pCPresence, cBuddyIDsInRange, rgqwBuddyIDsStart);   
            }
            else
            {
                hrRange = HRESULT_FROM_WIN32(WSAENOTCONN);
            }  
        }

        if(FAILED(hrRange))
        {
            hr = hrRange;

                // Connectivity loss logged via another check
            if ((hrRange != HRESULT_FROM_WIN32(WSAENOTCONN)) &&
                // user we're queueing to has logged off
                (hrRange != HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER)))
            {
                XomNtEvent( 
                    XEVENT_PRESENCE_CODE_187,
                    "CXPCluster::QueuePresenceOffline to server %d failed hr=0x%X",
                    dwServer,
                    hrRange);
            }
        }

        // Mark off the ones we sent         
        cBuddyIDsLeft -= cBuddyIDsInRange;
    }

    return hr;
}

/*****************************************************************************

CXPCluster::QueueListChange

Sends a list change notificatin to the given user's notification queue 
reguardless of where he resides.

*****************************************************************************/
HRESULT CXPCluster::QueueListChange(
    QWORD qwUserID,
    DWORD dwVersion,
    QWORD qwTargetID,
    WORD wOperationID,
    HRESULT hrOp,
    WORD cbTargetAcctName,
    LPCSTR szTargetAcctName)
{
    XOMASSERT(m_rgCPConnInfo != NULL);

    HRESULT hr = S_OK;
    DWORD dwServer = 0;

    // Figure out what server to send to
    dwServer = g_CPresCfg.MapUserToPresSrv(qwUserID, FALSE);

    // Make sure we have a connection to send to
    if (m_rgCPConnInfo[dwServer].fConnected)
    {
        // Send it
        hr = m_rgCPConnInfo[dwServer].pCPresConn->QueueListChange(
            qwUserID,
            dwVersion,
            qwTargetID,
            wOperationID,
            hrOp,
            cbTargetAcctName,
            szTargetAcctName);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(WSAENOTCONN);
    }
        
    return hr;
}

/*****************************************************************************

CXPCluster::QueueDeleteMessage

Delete a message for the given user regardless of where they reside.

*****************************************************************************/
HRESULT CXPCluster::QueueDeleteMessage(
    QWORD qwUserID,
    DWORD dwMessageID,
    BOOL fBlockSender)
{
    XOMASSERT(m_rgCPConnInfo != NULL);

    HRESULT hr = S_OK;
    DWORD dwServer = 0;

    // Figure out what server to send to
    dwServer = g_CPresCfg.MapUserToPresSrv( qwUserID, FALSE );

    // Make sure we have a connection to send to
    if( m_rgCPConnInfo[ dwServer ].fConnected )
    {
        // Send it
        hr = m_rgCPConnInfo[ dwServer ].pCPresConn->QueueDeleteMessage( qwUserID, dwMessageID, fBlockSender );
    }
    else
    {
        hr = HRESULT_FROM_WIN32( WSAENOTCONN );
    }
     
    return hr;
}

/*****************************************************************************

CXPCluster::QueueInviteAnswer

Sends an invitation answer notifications to the given host's notification 
queue reguardless of where he resides.

*****************************************************************************/
HRESULT CXPCluster::QueueInviteAnswer(
    QWORD qwUserID,
    QWORD qwHostID,
    QWORD qwMatchSessionID,
    FILETIME ftSent,
    WORD wAnswer)
{
    XOMASSERT(m_rgCPConnInfo != NULL);

    HRESULT hr = S_OK;
    DWORD dwServer = 0;

    // Figure out what server to send to
    dwServer = g_CPresCfg.MapUserToPresSrv(qwHostID, FALSE);

    // Make sure we have a connection to send to
    if( m_rgCPConnInfo[ dwServer ].fConnected )
    {
        // Send it
        hr = m_rgCPConnInfo[dwServer].pCPresConn->QueueInviteAnswer(
            qwUserID,
            qwHostID,
            qwMatchSessionID,
            ftSent,
            wAnswer);
    }
    else
    {
        hr = HRESULT_FROM_WIN32( WSAENOTCONN );
    }
    
    if(FAILED(hr))
    {
        goto lDone;
    }

lDone:
        
    return hr;
}

/*****************************************************************************

CXPCluster::QueuePeerPresence

Send presence information to a peer

*****************************************************************************/
HRESULT CXPCluster::QueuePeerPresence(
    CPresence *pCPresence, 
    const QWORD *rgqwUserIDsIn, 
    DWORD cUserIDs,
    BOOL fSendToXbox,
    BOOL fSendToXenon)
{
    XOMASSERT(m_rgCPConnInfo != NULL);

    HRESULT hr = S_OK;
    HRESULT hrRange = S_OK;
    DWORD dwServer = 0;
    DWORD dwClientType = 0;
    DWORD cUserIDsLeft = 0;
    QWORD *rgqwUserIDsStart = NULL;
    QWORD rgqwUserIDs[MAX_WATCHES];

    
    if (FALSE == pCPresence->CanSharePresence(FALSE))
    {
        // We aren't sharing!
        XomTrace(
            PresenceDebug,
            L_NORMAL,
            "QueuePeerPresence: user=%I64X has insufficient privileges to Queue Presence.",
            pCPresence->GetUserID()
            );
            
        return S_OK;
    }    

    // Sort the incomming array by destination
    if (cUserIDs > MAX_WATCHES)
    {
        // Overflow, drop the extra
        XOMASSERT(FALSE);
        cUserIDs = MAX_WATCHES;
    }
    memcpy(rgqwUserIDs, rgqwUserIDsIn, cUserIDs * sizeof(QWORD));

    SortUsersByDestination(cUserIDs, rgqwUserIDs, FALSE);

    // Process the sorted array
    cUserIDsLeft = cUserIDs;
    rgqwUserIDsStart = rgqwUserIDs;
    DWORD cUserIDsInRange = 0;
 
    while (cUserIDsLeft > 0)
    {
        // Set the start of the next range
        rgqwUserIDsStart = rgqwUserIDsStart + cUserIDsInRange;
        cUserIDsInRange = 1;

        // What server is this range on?
        dwServer = g_CPresCfg.MapUserToPresSrv(rgqwUserIDsStart[0], FALSE);
        dwClientType = GET_PUID_CLIENT_TYPE(rgqwUserIDsStart[0]);

        // Figure out how large this range is
        while ((cUserIDsInRange < cUserIDsLeft) &&
            (dwServer == g_CPresCfg.MapUserToPresSrv(rgqwUserIDsStart[cUserIDsInRange], FALSE)) &&
            (dwClientType == GET_PUID_CLIENT_TYPE(rgqwUserIDsStart[cUserIDsInRange])))
        {
            cUserIDsInRange++;
        }

        // clear extra bits in the puids
        for (DWORD iPuid = 0; iPuid < cUserIDsInRange; iPuid++)
        {
            rgqwUserIDsStart[iPuid] = GET_PUID_BITS(rgqwUserIDsStart[iPuid]);
        }

        hrRange = S_OK;

        // Send the range
        if ((dwClientType == PRES_CLIENT_TYPE_XBOX) || (dwClientType == PRES_CLIENT_TYPE_UNKNOWN))
        {                
            if (!fSendToXbox)
            {
                g_Counters.IncrementValue32(XPPERF_SERVER_FILTERED_NOTIFICATIONS_RATE, cUserIDsInRange);
            }
            else if (m_rgCPConnInfo[dwServer].fConnected)
            {
                hrRange = m_rgCPConnInfo[dwServer].pCPresConn->QueuePeerPresence(pCPresence, rgqwUserIDsStart, cUserIDsInRange);   
            }
            else
            {
                hrRange = HRESULT_FROM_WIN32(WSAENOTCONN);
            }  
        }
        if (SUCCEEDED(hrRange) && ((dwClientType == PRES_CLIENT_TYPE_XENON) || (dwClientType == PRES_CLIENT_TYPE_UNKNOWN)))
        {
            if (!fSendToXenon)
            {
                g_Counters.IncrementValue32(XPPERF_SERVER_FILTERED_NOTIFICATIONS_RATE, cUserIDsInRange);
            }
            else if (m_rgCPConnInfo[dwServer].fConnected)
            {
                hrRange = m_rgCPConnInfo[dwServer].pCPresConn->QueuePresence2(pCPresence, rgqwUserIDsStart, cUserIDsInRange);   
            }
            else
            {
                hrRange = HRESULT_FROM_WIN32(WSAENOTCONN);
            }  
        }

        if(FAILED(hrRange))
        {
            hr = hrRange;

                // Connectivity loss logged via another check
            if ((hrRange != HRESULT_FROM_WIN32(WSAENOTCONN)) &&
                // user we're queueing to has logged off
                (hrRange != HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER)))
            {
                XomNtEvent( 
                    XEVENT_PRESENCE_CODE_188,
                    "CXPCluster::QueuePeerPresence to server %d failed hr=0x%X",
                    dwServer,
                    hrRange);
            }
        }

        // Mark off the ones we sent         
        cUserIDsLeft -= cUserIDsInRange;
    }
        
    return hr;
}

/*****************************************************************************

CXPCluster::QueuePeerPresenceOffline

Send offline presence information to a team member

*****************************************************************************/
HRESULT CXPCluster::QueuePeerPresenceOffline(
    CPresence *pCPresence,
    DWORD cdwDestUsers,
    QWORD *rgqwDestUserIDs,
    BOOL fSendToXbox,
    BOOL fSendToXenon)
{
    XOMASSERT(m_rgCPConnInfo != NULL);

    HRESULT hr = S_OK;
    HRESULT hrRange = S_OK;
    DWORD dwServer = 0;
    DWORD dwClientType = 0;
    DWORD cUserIDsLeft = 0;
    QWORD *rgqwUserIDsStart = NULL;
    QWORD rgqwUserIDs[MAX_WATCHES];

    // Sort the incomming array by destination
    if (cdwDestUsers > MAX_WATCHES)
    {
        // Overflow, drop the extra
        XOMASSERT(FALSE);
        cdwDestUsers = MAX_WATCHES;
    }
    memcpy(rgqwUserIDs, rgqwDestUserIDs, cdwDestUsers * sizeof(QWORD));

    SortUsersByDestination(cdwDestUsers, rgqwUserIDs, FALSE);

    // Process the sorted array
    cUserIDsLeft = cdwDestUsers;
    rgqwUserIDsStart = rgqwUserIDs;
    DWORD cUserIDsInRange = 0;
 
    while (cUserIDsLeft > 0)
    {
        // Set the start of the next range
        rgqwUserIDsStart = rgqwUserIDsStart + cUserIDsInRange;
        cUserIDsInRange = 1;

        // What server is this range on?
        dwServer = g_CPresCfg.MapUserToPresSrv(rgqwUserIDsStart[0], FALSE);
        dwClientType = GET_PUID_CLIENT_TYPE(rgqwUserIDsStart[0]);

        // Figure out how large this range is
        while ((cUserIDsInRange < cUserIDsLeft) &&
            (dwServer == g_CPresCfg.MapUserToPresSrv(rgqwUserIDsStart[cUserIDsInRange], FALSE)) &&
            (dwClientType == GET_PUID_CLIENT_TYPE(rgqwUserIDsStart[cUserIDsInRange])))
        {
            cUserIDsInRange++;
        }

        // clear extra bits in the puids
        for (DWORD iPuid = 0; iPuid < cUserIDsInRange; iPuid++)
        {
            rgqwUserIDsStart[iPuid] = GET_PUID_BITS(rgqwUserIDsStart[iPuid]);
        }

        hrRange = S_OK;

        // Send the range
        if (fSendToXbox && ((dwClientType == PRES_CLIENT_TYPE_XBOX) || (dwClientType == PRES_CLIENT_TYPE_UNKNOWN)))
        {                
            if (m_rgCPConnInfo[dwServer].fConnected)
            {
                hrRange = m_rgCPConnInfo[dwServer].pCPresConn->QueuePeerPresenceOffline(pCPresence, cUserIDsInRange, rgqwUserIDsStart);   
            }
            else
            {
                hrRange = HRESULT_FROM_WIN32(WSAENOTCONN);
            }  
        }
        if (fSendToXenon && SUCCEEDED(hrRange) && ((dwClientType == PRES_CLIENT_TYPE_XENON) || (dwClientType == PRES_CLIENT_TYPE_UNKNOWN)))
        {
            if (m_rgCPConnInfo[dwServer].fConnected)
            {
                hrRange = m_rgCPConnInfo[dwServer].pCPresConn->QueuePresence2Offline(pCPresence, cUserIDsInRange, rgqwUserIDsStart);   
            }
            else
            {
                hrRange = HRESULT_FROM_WIN32(WSAENOTCONN);
            }  
        }
        
        if(FAILED(hrRange))
        {
            hr = hrRange;

                // Connectivity loss logged via another check
            if ((hrRange != HRESULT_FROM_WIN32(WSAENOTCONN)) &&
                // user we're queueing to has logged off
                (hrRange != HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER)))
            {
                XomNtEvent( 
                    XEVENT_PRESENCE_CODE_189,
                    "CXPCluster::QueuePeerPresenceOffline to server %d failed hr=0x%X",
                    dwServer,
                    hrRange);
            }
        }

        // Mark off the ones we sent         
        cUserIDsLeft -= cUserIDsInRange;
    }
        
    return hr;
}


/*****************************************************************************

CXPCluster::Status

Display status on all connections

*****************************************************************************/
HRESULT CXPCluster::Status(DWORD dwRequestId, CXomControlResponseInterface* pResponseInterface)
{
    XOMASSERT(m_rgCPConnInfo != NULL);

    HRESULT hr = S_OK;
    DWORD dwIndex = 0;

    pResponseInterface->WriteResponse(dwRequestId, 
        (BYTE*)"Presence Server Connection Status:\r\n", (DWORD) -1);

    for (dwIndex = 0; dwIndex < g_CPresCfg.GetNumPresServers(); dwIndex++)
    {
        LPSTR szStatus = NULL;

        if (dwIndex == (DWORD) g_CPresCfg.GetMyPresServerIndex())
        {
            szStatus = "local";
        }
        else if (m_rgCPConnInfo[dwIndex].pCPresConn == NULL)
        {
            szStatus = "**DISCONNECTED**";
        }
        else if (m_rgCPConnInfo[dwIndex].fConnected)
        {
            szStatus = "connected";
        }
        else
        {
            szStatus = "**CONNECTING**";
        }
        
        XomWriteFormattedResponse(
            pResponseInterface,
            dwRequestId,
            "%d) %S %s\r\n",
            dwIndex,
            (WCHAR *)(BSTR)g_CPresCfg.GetPresServerName(dwIndex),
            szStatus);        
    }
    
    pResponseInterface->WriteResponse(dwRequestId, 
            (BYTE*)"\r\n", (DWORD) -1);
    return hr;
}

/*****************************************************************************

CXPCluster::ResetConnections

Reset all connections

*****************************************************************************/
HRESULT CXPCluster::ResetConnection(DWORD dwIndex)
{
    HRESULT hr = S_OK;

    if (dwIndex == -1)
    {
        for (DWORD i = 0; i < g_CPresCfg.GetNumPresServers(); i++)
        {
            if (m_rgCPConnInfo[i].pCPresConn != NULL)
            {
                m_rgCPConnInfo[i].pCPresConn->Disconnect(S_OK);
            }
        }
    }
    else if (dwIndex >= g_CPresCfg.GetNumPresServers())
    {
        hr = E_INVALIDARG;
    }
    else if (m_rgCPConnInfo[dwIndex].pCPresConn != NULL)
    {
        m_rgCPConnInfo[dwIndex].pCPresConn->Disconnect(S_OK);
    }

    return hr;
}

HRESULT CXPCluster::ChangeServerList(DWORD *rgdwIndexMap, DWORD cOldServers)
{
    HRESULT hr = S_OK;

    // make a new server list
    CPConnInfo *rgNewPConnInfo = new CPConnInfo[g_CPresCfg.GetNumPresServers()];
    if (rgNewPConnInfo == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // initialize everything.
    for (DWORD dwIndex = 0; dwIndex < g_CPresCfg.GetNumPresServers(); dwIndex++)
    {
        rgNewPConnInfo[dwIndex].pCPresConn = NULL;
        rgNewPConnInfo[dwIndex].fInit = TRUE;
        rgNewPConnInfo[dwIndex].fConnected = FALSE;
    }

    // clean up anything we're no longer using
    for (DWORD dwIndex = 0; dwIndex < cOldServers; dwIndex++)
    {
        if (rgdwIndexMap[dwIndex] == 0xFFFFFFFF)
        {
            if (m_rgCPConnInfo[dwIndex].pCPresConn != NULL)
            {
                m_rgCPConnInfo[dwIndex].pCPresConn->ReleaseSendMessageContexts();
                m_rgCPConnInfo[dwIndex].pCPresConn->Disconnect(S_OK);
            }
        }
    }

    // copy over anything we're still using
    for (DWORD dwIndex = 0; dwIndex < cOldServers; dwIndex++)
    {
        if (rgdwIndexMap[dwIndex] != 0xFFFFFFFF)
        {
            memcpy(&(rgNewPConnInfo[rgdwIndexMap[dwIndex]]), &(m_rgCPConnInfo[dwIndex]), sizeof(CPConnInfo));
            if (m_rgCPConnInfo[dwIndex].pCPresConn != NULL)
            {
                m_rgCPConnInfo[dwIndex].pCPresConn->AddRef();
                m_rgCPConnInfo[dwIndex].pCPresConn->ChangeServerIndex(rgdwIndexMap, cOldServers);
            }
        }
    }

    // switch to the new list.
    SAFE_ARRAYDELETE(m_rgCPConnInfo);
    m_rgCPConnInfo = rgNewPConnInfo;
    rgNewPConnInfo = NULL;

    // clean up visited flags for send message reply handler contexts.
    for (DWORD dwIndex = 0; dwIndex < g_CPresCfg.GetNumPresServers(); dwIndex++)
    {
        if (m_rgCPConnInfo[dwIndex].pCPresConn != NULL)
        {
            m_rgCPConnInfo[dwIndex].pCPresConn->ClearSendMessageContextVisitedFlags();
        }
    }

lDone:

    SAFE_ARRAYDELETE(rgNewPConnInfo);

    return hr;
}


/*****************************************************************************

CXPCluster::SendSendMessage

Sends a message from the sender's notification server to each recipient's
notification server.

*****************************************************************************/
HRESULT CXPCluster::SendSendMessage(
    const Q_SEND_MESSAGE_MSG* pMessage,
    const QWORD *rgqwRecipients,
    const BYTE* pbDetails,
    const Q_SEND_MESSAGE_ADDENDUM* rgAddendum,
    SendMessageReplyHandler* pCCtx,
    BOOL fUseAltServer)
{
    XOMASSERT( NULL != m_rgCPConnInfo );

    HRESULT hr = S_OK;
    DWORD dwServer = 0;
    WORD cRecipientsLeft = pMessage->cRecipients;
    WORD cRecipientsInRange = 0;
    RecipientFriendInfo rgRecipientInfo[ XONLINE_MAX_MESSAGE_RECIPIENTS ];
    const QWORD* pqwRecipientStart = NULL;
    const Q_SEND_MESSAGE_ADDENDUM* pAddendumStart = NULL;
    WORD iRecipient = 0;

    // Sort the incoming array by destination
    if( cRecipientsLeft > XONLINE_MAX_MESSAGE_RECIPIENTS )
    {
        // Overflow, drop the extra
        XOMASSERT( FALSE );
        cRecipientsLeft = XONLINE_MAX_MESSAGE_RECIPIENTS;
    }

    if( NULL != rgAddendum )
    {
        // Copy the separate recipient arrays over into one so that we can sort them together
        for( iRecipient = 0; iRecipient < cRecipientsLeft; iRecipient++ )
        {
            rgRecipientInfo[ iRecipient ].qwUserID = rgqwRecipients[ iRecipient ];
            rgRecipientInfo[ iRecipient ].addendum.fFriend = rgAddendum[ iRecipient ].fFriend;
            rgRecipientInfo[ iRecipient ].addendum.qwWebID = rgAddendum[ iRecipient ].qwWebID;
        }
        SortRecipientFriendInfoByDestination( cRecipientsLeft, rgRecipientInfo, fUseAltServer );

        // Now copy the recipients back out in sorted order for use below and when we receive
        // replies.
        for( iRecipient = 0; iRecipient < cRecipientsLeft; iRecipient++ )
        {
            pCCtx->m_rgqwRecipients[ iRecipient ] = rgRecipientInfo[ iRecipient ].qwUserID;
            pCCtx->m_rgAddendum[ iRecipient ].fFriend = rgRecipientInfo[ iRecipient ].addendum.fFriend;
            pCCtx->m_rgAddendum[ iRecipient ].qwWebID = rgRecipientInfo[ iRecipient ].addendum.qwWebID;
        }
    }
    else
    {
        memcpy( pCCtx->m_rgqwRecipients, rgqwRecipients, pMessage->cRecipients * sizeof( *rgqwRecipients ) );
        SortUsersByDestination( pMessage->cRecipients, pCCtx->m_rgqwRecipients, fUseAltServer );
    }

    // Process the sorted array
    pqwRecipientStart = pCCtx->m_rgqwRecipients;
    pAddendumStart = NULL == rgAddendum ? NULL : pCCtx->m_rgAddendum;
    iRecipient = 0;
    
    // Allocate structures needed to manage invidual server sends
    pCCtx->m_pPerServerInfo = new SendMessageReplyHandler::PerServerInfo[ g_CPresCfg.GetNumPresServers() ];
    if( NULL == pCCtx->m_pPerServerInfo )
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    while( 0 < cRecipientsLeft )
    {
        HRESULT hrRange = S_OK;

        // Set the start of the next range
        pqwRecipientStart = pqwRecipientStart + cRecipientsInRange;
        pAddendumStart = NULL == rgAddendum ? NULL : pAddendumStart + cRecipientsInRange;
        cRecipientsInRange = 1;

        // What server is this range on?
        dwServer = g_CPresCfg.MapUserToPresSrv( pqwRecipientStart[ 0 ], fUseAltServer );

        // Figure out how large this range is
        while( ( cRecipientsInRange < cRecipientsLeft ) &&
               ( dwServer == g_CPresCfg.MapUserToPresSrv( pqwRecipientStart[ cRecipientsInRange ], fUseAltServer ) ) )
        {
            cRecipientsInRange++;
        }

        // We expect a reply from this range. 
        pCCtx->m_lSendCount++;
        
        // Send the range
        if( m_rgCPConnInfo[ dwServer ].fConnected )
        {            
            pCCtx->m_pPerServerInfo[ dwServer ].m_wStartRecipIndex = iRecipient;
            pCCtx->m_pPerServerInfo[ dwServer ].m_cRecipients = cRecipientsInRange;

            hrRange = m_rgCPConnInfo[ dwServer ].pCPresConn->SendSendMessage(
                pMessage,
                cRecipientsInRange,
                pqwRecipientStart,
                pbDetails,
                pAddendumStart,
                pCCtx );  
        }
        else
        {
            hrRange = HRESULT_FROM_WIN32( WSAENOTCONN );
        }  

        if( FAILED( hrRange ) )
        {
            // Connectivity loss logged via another check
            if( hrRange != HRESULT_FROM_WIN32( WSAENOTCONN ) )
            {
                XomNtEvent( 
                    XEVENT_PRESENCE_CODE_190,
                    "CXPCluster::SendSendMessage to server %d failed hr=0x%X",
                    dwServer,
                    hrRange );
            }

            // Insert fail records for all recipients on this server in the reply.  There may be multiple 
            // replies since we may have sent to multiple Notification servers.  Add this one on to the 
            // actual reply held in pCCtx.
            Q_RECIPIENT_RESULT* pRecipientResults = new Q_RECIPIENT_RESULT[cRecipientsInRange];
            if (pRecipientResults != NULL)
            {
                for( WORD iRecipientInner = 0; iRecipientInner < cRecipientsInRange; iRecipientInner++ )
                {
                    pRecipientResults[iRecipientInner].qwUserID = pqwRecipientStart[ iRecipientInner ];
                    pRecipientResults[iRecipientInner].hrRecipient = hrRange;
                }

                pCCtx->HandleSendReply(
                    cRecipientsInRange,
                    pRecipientResults,
                    hrRange);

                delete[] pRecipientResults;
            }
            else
            {
                pCCtx->m_lSendCount--;
            }
        }

        // Mark off the ones we sent         
        cRecipientsLeft = cRecipientsLeft - cRecipientsInRange;
        iRecipient = iRecipient + cRecipientsInRange;
    }

lDone:
    
    return hr;
}

/*****************************************************************************

CXPCluster::SendRevokeMessage

Sends Revoke messages from the server they arrive on to each recipient's
notification server.


*****************************************************************************/
HRESULT CXPCluster::SendRevokeMessage(
    const Q_REVOKE_MESSAGE_EX_MSG* pMessage,
    const Q_RECIPIENT_RESULT* pRecipients,
    const BYTE* pbProp,
    BOOL fUseAltServer)
{
    XOMASSERT( NULL != m_rgCPConnInfo );

    HRESULT hr = S_OK;
    WORD cRecipientsLeft = pMessage->cRecipients;
    WORD cRecipientsInRange = 0;
    Q_RECIPIENT_RESULT rgRecipientsSorted[ XONLINE_MAX_MESSAGE_RECIPIENTS ];
    const Q_RECIPIENT_RESULT* pRecipientStart = NULL;

    // Sort the incoming array by destination
    if( cRecipientsLeft > XONLINE_MAX_MESSAGE_RECIPIENTS )
    {
        // Overflow, drop the extra
        XOMASSERT( FALSE );
        cRecipientsLeft = XONLINE_MAX_MESSAGE_RECIPIENTS;
    }

    memcpy( rgRecipientsSorted, pRecipients, cRecipientsLeft * sizeof( *pRecipients ) );
    SortRecipientResultsByDestination( cRecipientsLeft, rgRecipientsSorted, fUseAltServer );

    // Process the sorted array
    pRecipientStart = rgRecipientsSorted;
    
    while( 0 < cRecipientsLeft )
    {
        HRESULT hrRange = S_OK;
        DWORD dwServer = 0;

        // Set the start of the next range
        pRecipientStart = pRecipientStart + cRecipientsInRange;
        cRecipientsInRange = 1;

        // What server is this range on?
        dwServer = g_CPresCfg.MapUserToPresSrv( pRecipientStart[ 0 ].qwUserID, fUseAltServer );

        // Figure out how large this range is
        while( ( cRecipientsInRange < cRecipientsLeft ) &&
               ( dwServer == g_CPresCfg.MapUserToPresSrv( pRecipientStart[ cRecipientsInRange ].qwUserID, fUseAltServer ) ) )
        {
            cRecipientsInRange++;
        }

        // Send the range
        if( m_rgCPConnInfo[ dwServer ].fConnected )
        {            
            hrRange = m_rgCPConnInfo[ dwServer ].pCPresConn->SendRevokeMessage(
                pMessage,
                cRecipientsInRange,
                pRecipientStart,
                pbProp );
        }
        else
        {
            hrRange = HRESULT_FROM_WIN32( WSAENOTCONN );
        }  

        if( FAILED( hrRange ) )
        {
            // Connectivity loss logged via another check
            if( hrRange != HRESULT_FROM_WIN32( WSAENOTCONN ) )
            {
                XomNtEvent( 
                    XEVENT_PRESENCE_CODE_191,
                    "CXPCluster::SendRevokeMessage to server %d failed hr=0x%X",
                    dwServer,
                    hrRange );
            }
        }

        // Mark off the ones we sent         
        cRecipientsLeft = cRecipientsLeft - cRecipientsInRange;
    }
        
    return hr;
}


/*****************************************************************************

CXPCluster::AttemptConnections

Attempt to reestablish connections with disconnected qservers.

*****************************************************************************/
HRESULT CXPCluster::AttemptConnections()
{
    XOMASSERT(m_rgCPConnInfo != NULL);

    HRESULT hr = S_OK;
    DWORD dwIndex;
    DWORD dwNow = GetTickCount();

    if ((m_dwLastConnAttempt != 0) && (dwNow - m_dwLastConnAttempt < 5000))
    {
        return S_OK;
    }

    m_dwLastConnAttempt = dwNow;

    for (dwIndex = 0; dwIndex < g_CPresCfg.GetNumPresServers(); dwIndex++)
    {

        // If disconnected and not connectiong
        if (m_rgCPConnInfo[dwIndex].pCPresConn == NULL)
        {
            // Make a new connection to the designated Presence server
            m_rgCPConnInfo[dwIndex].pCPresConn = new CPresConnection(dwIndex);
            if(NULL == m_rgCPConnInfo[dwIndex].pCPresConn)
            {
                hr = E_OUTOFMEMORY;
                goto lDone;
            }

            hr = m_rgCPConnInfo[dwIndex].pCPresConn->InitConnect(
                g_CPresCfg.GetPresServerPeerAddr(dwIndex),
                m_pCCompPort,
                this,
                m_pCSwitchboard);

            if(FAILED(hr))
            {
                SAFE_RELEASE(m_rgCPConnInfo[dwIndex].pCPresConn);
            }
        }
    }

lDone:
    return hr;
}

/*****************************************************************************

CXPCluster::SortUsersByDestination

Sort an array of users by destination machine

*****************************************************************************/
void CXPCluster::SortUsersByDestination(DWORD cUsers, QWORD *rgqwUsers, BOOL fAlt)
{
    if (!fAlt && (cUsers < 3))
    {
        // No gain by sorting
        return;
    }

    if (!fAlt)
    {
        qsort(rgqwUsers, cUsers, sizeof(QWORD), CompareUsersByPresDest);
    }
    else
    {
        qsort(rgqwUsers, cUsers, sizeof(QWORD), CompareUsersByAltPresDest);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\inh\presconfig.h ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#pragma once

#define P_MAX_DWORD_ARRAY 25
#define P_MAX_P_SERVERS 100
#define P_NOT_FOUND 0xFFFFFFFF

class CPresenceConfig;
class CSwitchboard;

struct PresServerConfig
{
    CComBSTR bstrInterfaceName;
    sockaddr_in sa;
    sockaddr_in saPeer;
};

struct PresServerBucketConfig
{
    DWORD cBucketUsers;
    DWORD dwServerIndex;
    DWORD dwNextServerIndex;
    DATE dtStart;
    BOOL fAltServerValid;
};


class CPresConfigListener : public CConfigListenerBase
{

    IMPLEMENT_REFCOUNT_COM

public:

    CPresConfigListener() :
        m_pSwitchboard(NULL)
    { }

    virtual ~CPresConfigListener()
    {
    }

    STDMETHODIMP QueryInterface( REFIID riid, void** ppObj )
    {
        HRESULT hr;

        if(ppObj == NULL)
            return E_POINTER;

        if(riid == IID_IUnknown)
        {
            *ppObj = (void*)(IUnknown*)this;
            hr = S_OK;
            AddRef();
        }
        else if (riid == _uuidof(IConfigListener))
        {
            *ppObj = (void*)(IConfigListener*)this;
            hr = S_OK;
            AddRef();
        }
        else
            hr = E_NOINTERFACE;

        return hr;
    }

    HRESULT RegisterSwitchboard(CSwitchboard *pSwitchboard)
    {
        if (pSwitchboard == NULL)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_201, "CPresConfigListener::RegisterSwitchboard() called with pSwitchboard == NULL.");
            return E_POINTER;
        }
        if (m_pSwitchboard != NULL)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_202, "CPresConfigListener::RegisterSwitchboard() called when m_pSwitchboard != NULL.");
            return E_UNEXPECTED;
        }

        m_pSwitchboard = pSwitchboard;
        return S_OK;
    }

    virtual HRESULT __stdcall SettingChange (
        /*[in]*/ struct ISettingChangeEventArgs * e );

    virtual HRESULT __stdcall InterfaceBucketChange (
        /*[in]*/ struct IInterfaceBucketChangeEventArgs * e );

    virtual HRESULT __stdcall ServerListChange (
        /*[in]*/ struct IServerListChangeEventArgs * e );

protected:

    CSwitchboard *m_pSwitchboard;
};


// NOTE:  all queries to Config from within presence are cached through this class.  DO NOT make any attempts to
//            bypass this class, or modify this cache from any thread other than switchboard.
class CPresenceConfig
{
public:
    CPresenceConfig() :
        m_dwLastBucketLoad(0),
        m_dwMyIndex(P_NOT_FOUND),
        m_pConfigListener(NULL),
        m_pSwitchboard(NULL),
        m_psrgVelocityServers(NULL),
        m_psrgVelocityPorts(NULL),
        m_dwWelcomeToXboxLiveMessage(0),
        m_dwWelcomeToNewConsoleMessage(0)
    {}
    ~CPresenceConfig()
    {
        Shutdown();
    }

    HRESULT RegisterSwitchboard(CSwitchboard *pSwitchboard)
    {
        if (pSwitchboard == NULL)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_203, "CPresConfig::RegisterSwitchboard() called with pSwitchboard == NULL.");
            return E_POINTER;
        }
        if (m_pSwitchboard != NULL)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_204, "CPresConfig::RegisterSwitchboard() called when m_pSwitchboard != NULL.");
            return E_UNEXPECTED;
        }

        m_pSwitchboard = pSwitchboard;

        return m_pConfigListener->RegisterSwitchboard(pSwitchboard);
    }

    DWORD GetHeartbeatDelay() { return m_dwHeartbeatDelay; }
    DWORD GetMaxQValsPerHeartbeat() { return m_dwMaxQValsPerHeartbeat; }
    DWORD GetPresUserCleanupDelay() { return m_dwPresUserCleanupDelay; }
    DWORD GetIdleQValsCheck() { return m_dwIdleQValsCheck; }
    u_short GetSGQValSendPort() { return (u_short) m_dwSGQValSendPort; }
    u_short GetSGQValRecvPort() { return (u_short) m_dwSGQValRecvPort; }
    DWORD *GetQValRetryDelays() { return m_rgdwQValRetryDelays; }
    DWORD GetQValRetryDelaysLen() { return m_dwQValRetryDelaysLen; }
    DWORD GetUserIndexSize() { return m_dwUserIndexSize; }
    DWORD GetXBoxIndexSize() { return m_dwXBoxIndexSize; }
    DWORD GetSGIndexSize() { return m_dwSGIndexSize; }
    DWORD GetWebUserTimeout() { return m_dwWebUserTimeout; }
    DWORD GetDeadSgOnFailedQVal() { return m_dwDeadSgOnFailedQVal; }
    DWORD GetConcurrentSQLThreads() { return m_dwConcurrentSQLThreads; }
    DWORD GetNumSQLThreads() { return m_dwNumSQLThreads; }
    DWORD GetStartNumPoolBuffers() { return m_dwStartNumPoolBuffers; }
    DWORD GetMaxNumPoolBuffers() { return m_dwMaxNumPoolBuffers; }
    DWORD GetPoolBufferSize() { return m_dwPoolBufferSize; }
    DWORD GetMaxPresenceUsers() { return m_dwMaxPresenceUsers; }
    DWORD GetMaxRichPresenceBytes() { return m_dwMaxRichPresenceBytes; }
    DWORD GetExpirationCheckInterval() { return m_dwExpirationCheckInterval; }
    WORD GetPeerPort() { return (WORD) m_dwPeerPort; }
    DWORD GetMessageTimeout() { return (WORD) m_dwMessageTimeout; }
    DWORD GetStateBitsNotifyWhitelist() { return m_dwStateBitsNotifyWhitelist; }
    BOOL GetEnableRichPresence() { return m_fEnableRichPresence; }
    BOOL GetStoreStateInVelocity() { return m_fStoreStateInVelocity; }
    DWORD GetWelcomeToXboxLiveMessage() { return m_dwWelcomeToXboxLiveMessage; }
    DWORD GetWelcomeToNewConsoleMessage() { return m_dwWelcomeToNewConsoleMessage; }

    DWORD GetValidMessageType(DWORD dwType)
    {
        if (dwType > m_dwValidMessageTypesLen)
        {
            return 0xFFFFFFFF;
        }
        else
        {
            return m_rgdwValidMessageTypes[dwType];
        }
    }
    DWORD GetValidMessageTypesLen() { return m_dwValidMessageTypesLen; }
    DWORD GetMessageTypeExpiration(DWORD dwType)
    {
        if (dwType > m_dwValidMessageTypesLen)
        {
            return 43200; // 30 days
        }
        else
        {
            return m_rgdwMessageTypeExpirations[dwType];
        }
    }
    DWORD GetMessageTypeExpirationsLen() { return m_dwMessageTypeExpirationsLen; }

    DWORD GetMessagingDailySends() { return m_dwMessagingDailySends; }
    DWORD GetMessagingDailyRecipients() { return m_dwMessagingDailyRecipients; }

    BOOL GetQueryAffiliatesOkToPeerSubscribe() { return m_fQueryAfffiliatesOkToPeerSubscribe; }

    DWORD GetAffiliatesEncounteredListSize() { return m_dwAffiliatesEncounteredListSize; }
    DWORD GetAffiliatesCompletedGameListSize() { return m_dwAffiliatesCompletedGameListSize; }
    DWORD GetAffiliatesPositiveFeedbackListSize() { return m_dwAffiliatesPositiveFeedbackListSize; }
    DWORD GetAffiliatesNegativeFeedbackListSize() { return m_dwAffiliatesNegativeFeedbackListSize; }
    DWORD GetAffiliatesAvoidingMeListSize() { return m_dwAffiliatesAvoidingMeListSize; }
    DWORD GetAffiliatesFavoritesListSize() { return m_dwAffiliatesFavoritesListSize; }

    DWORD GetProtocolVersion() {return m_dwProtocolVersion; }

    DWORD GetContextDurationAlertLimit() { return m_dwContextDurationAlertLimit; }

    HRESULT Init();
    void Shutdown()
    {
        if (m_pConfig && m_pConfigListener)
        {
            m_pConfig->putref_ConfigListener(NULL);
            m_pConfigListener->Release();
            m_pConfigListener = NULL;
        }
        if (m_pConfig)
        {
            m_pConfig.Release();
            m_pConfig = NULL;
        }
    }

    CComBSTR GetWebStoreApplicationName(CComBSTR virtualInterface)
    {
        long siteId;
        IVirtualInterfaceInfo *piVII = NULL;
        CComBSTR bstrWBAName;

        HRESULT hr = m_pConfig->get_SiteId(&siteId);
        if (FAILED(hr))
        {
            goto lDone;
        }

        hr = m_pConfig->GetVirtualInterface(virtualInterface, siteId, &piVII);
        if (FAILED(hr) || (piVII == NULL))
        {
            goto lDone;
        }

        hr = piVII->get_WebstoreApp(&bstrWBAName);
        if (FAILED(hr))
        {
            goto lDone;
        }

    lDone:

        if (piVII != NULL)
        {
            piVII->Release();
        }

        return bstrWBAName;
    }

    HRESULT Reload(struct ISettingChangeEventArgs * eventArgs);
    HRESULT ChangeBucketMap(DWORD dwBucket, CComBSTR bsCurrentServer, CComBSTR bsNextServer, DATE dtStart, BOOL fMine);
    HRESULT LoadBucketMap();

    HRESULT ChangeServerList(DWORD cServers, CComBSTR *rgbsServers);

    CComBSTR GetBucketCurrentServerName(DWORD dwBucket)
    {
        return m_rgPresServers[m_rgBucketMap[dwBucket].dwServerIndex].bstrInterfaceName;
    }

    CComBSTR GetBucketNextServerName(DWORD dwBucket)
    {
        return m_rgPresServers[m_rgBucketMap[dwBucket].dwNextServerIndex].bstrInterfaceName;
    }

    DWORD GetBucketCurrentServerIndex(DWORD dwBucket)
    {
        return m_rgBucketMap[dwBucket].dwServerIndex;
    }

    DWORD GetBucketNextServerIndex(DWORD dwBucket)
    {
        return m_rgBucketMap[dwBucket].dwNextServerIndex;
    }

    DWORD GetBucketCount() { return m_dwBucketCount; }

    DWORD GetBucketUserCount(DWORD dwBucket)
    {
        return m_rgBucketMap[dwBucket].cBucketUsers;
    }

    void AddBucketUser(QWORD qwUserID)
    {
        m_rgBucketMap[HashPUID(qwUserID)].cBucketUsers++;
    }

    void RemoveBucketUser(QWORD qwUserID)
    {
        m_rgBucketMap[HashPUID(qwUserID)].cBucketUsers--;
    }

    BOOL IsBucketMine(DWORD dwBucket)
    {
        return (m_rgBucketMap[dwBucket].dwServerIndex == m_dwMyIndex);
    }

    void CompleteBucketMigration(DWORD dwBucket)
    {
        m_pConfig->CompleteMigration(Interface_xpserver, dwBucket);
    }

    void SetBucketValidAltServerFlag(DWORD dwBucket, BOOL fValid)
    {
        m_rgBucketMap[dwBucket].fAltServerValid = fValid;
    }

    BOOL IsValidOnWatchAddr(IN_ADDR inaddr);

    DWORD MapUserToPresSrv(QWORD qwUserID, BOOL fAlt);
    DWORD GetNumPresServers() { return m_cPresServers; }
    CComBSTR GetPresServerName(DWORD dwIndex);
    sockaddr_in *GetPresServerAddr(DWORD dwIndex);
    sockaddr_in *GetPresServerPeerAddr(DWORD dwIndex);
    DWORD GetMyPresServerIndex() { return m_dwMyIndex; }
    BOOL CheckDestination(QWORD qwUserID);
    DWORD HashPUID(QWORD qwPUID);

    CComBSTR& GetNPDBConnectionString() { return m_bsNPDBConnectionString; }

    SAFEARRAY * GetVelocityServers()
    {
        return m_psrgVelocityServers;
    }

    SAFEARRAY * GetVelocityPorts()
    {
        return m_psrgVelocityPorts;
    }

    HRESULT LoadVelocityServers();


protected:

    HRESULT Load();
    HRESULT LoadSettings();
    HRESULT LoadXonWatchIPs();
    HRESULT LoadPresenceServers();
    HRESULT LoadNPDBInfo();

    DWORD GetDWORDSetting(CComBSTR Setting, CComBSTR bsValue = CComBSTR(NULL));
    void GetDWORDArraySetting(CComBSTR Setting, DWORD *pdwLen, DWORD *rgdwVal, CComBSTR bsValue = CComBSTR(NULL));

    DWORD GetServerByName(BSTR m_bstrInterfaceName);
    HRESULT GetHostAddrs(in_addr *rgsaAddrs, DWORD *pcAddrs);
    HRESULT AddServer(BSTR bstrInterfaceName, DWORD dwServerIndex);

    CComPtr<IConfig> m_pConfig;
    CPresConfigListener *m_pConfigListener;
    CSwitchboard *m_pSwitchboard;

    DWORD m_dwHeartbeatDelay;
    DWORD m_dwMaxQValsPerHeartbeat;
    DWORD m_dwPresUserCleanupDelay;
    DWORD m_dwIdleQValsCheck;
    DWORD m_dwSGQValSendPort;
    DWORD m_dwSGQValRecvPort;
    DWORD m_rgdwQValRetryDelays[P_MAX_DWORD_ARRAY];
    DWORD m_dwQValRetryDelaysLen;
    DWORD m_dwUserIndexSize;
    DWORD m_dwXBoxIndexSize;
    DWORD m_dwSGIndexSize;
    DWORD m_dwWebUserTimeout;
    DWORD m_dwDeadSgOnFailedQVal;
    DWORD m_dwConcurrentSQLThreads;
    DWORD m_dwNumSQLThreads;
    DWORD m_dwStartNumPoolBuffers;
    DWORD m_dwMaxNumPoolBuffers;
    DWORD m_dwPoolBufferSize;
    DWORD m_dwMaxPresenceUsers;
    DWORD m_dwMaxRichPresenceBytes;
    DWORD m_dwExpirationCheckInterval;
    DWORD m_dwPeerPort;
    DWORD m_dwMessageTimeout;
    DWORD m_dwBucketReloadDelay;
    DWORD m_rgdwValidMessageTypes[P_MAX_DWORD_ARRAY];
    DWORD m_dwValidMessageTypesLen;
    DWORD m_rgdwMessageTypeExpirations[P_MAX_DWORD_ARRAY];
    DWORD m_dwMessageTypeExpirationsLen;
    DWORD m_dwMessagingDailySends;
    DWORD m_dwMessagingDailyRecipients;
    BOOL m_fQueryAfffiliatesOkToPeerSubscribe;
    DWORD m_dwAffiliatesEncounteredListSize;
    DWORD m_dwAffiliatesCompletedGameListSize;
    DWORD m_dwAffiliatesPositiveFeedbackListSize;
    DWORD m_dwAffiliatesNegativeFeedbackListSize;
    DWORD m_dwAffiliatesAvoidingMeListSize;
    DWORD m_dwAffiliatesFavoritesListSize;
    DWORD m_dwProtocolVersion;
    DWORD m_dwContextDurationAlertLimit;
    DWORD m_dwStateBitsNotifyWhitelist;
    DWORD m_fEnableRichPresence;
    DWORD m_fStoreStateInVelocity;
    DWORD m_dwWelcomeToXboxLiveMessage;
    DWORD m_dwWelcomeToNewConsoleMessage;

    struct XonWatchIP {
        in_addr inaIP;
        in_addr inaMask;
    };

    DWORD m_cXonWatchIPs;
    XonWatchIP *m_psXonWatchIPs;

    // Bucket info
    DWORD m_dwLastBucketLoad;
    DWORD m_dwBucketCount;
    PresServerBucketConfig *m_rgBucketMap;

    // Server info
    DWORD m_cPresServers;
    DWORD m_dwMyIndex;
    PresServerConfig m_rgPresServers[P_MAX_P_SERVERS];

    CComBSTR m_bsNPDBConnectionString;

    // velocity info
    SAFEARRAY *m_psrgVelocityServers;
    SAFEARRAY *m_psrgVelocityPorts;
};

extern CPresenceConfig g_CPresCfg;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\inh\profilestore.h ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#ifndef PROFILESTORE_H_INCLUDED
#define PROFILESTORE_H_INCLUDED

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CLocalContext;
class CSwitchboard;
class CAliveContext;
class CSyncContext;
class CAddBuddyContext;
class CAddAffiliatesContext;
class CIsAffiliateContext;
class CQueryAffiliatesContext;
class CStoreAffiliatesContext;
class CAcceptBuddyContext;
class CRejectBuddyContext;
class CDeleteBuddyContext;
class CBlockContext;
class CUnblockContext;
class CClearAllBlocksContext;
class CSetFlushTicketsContext;
class CGetFriendsListContext;
class CLoadOfflinePresenceContext;
class CTeamCreateContext;
class CTeamDeleteContext;
class CTeamRemoveContext;
class CTeamManageTeamContext;
class CTeamManageMemberContext;
class CTeamRecruitContext;
class CTeamJoinContext;
class CTeamListTeamsContext;
class CTeamListUserTeamsContext;
class CTeamListMembersContext;
class CTeamGetTicketContext;
class CEnumerateMessagesContext;
class CGetMessageSummaryContext;
class CGetMessageDetailsContext;
class CDeleteMessageContext;
class CSendMessageInternalContext;
class CRevokeMessageContext;
class CDeleteUserTitleContext;
class CEnumerateUserTitlesContext;
class CMessageFlagsContext;
class CUnblockUsersContext;
class CEnumSystemMessagesContext;
class CSystemMessageDetailsContext;
class CDeleteSystemMessageContext;
class CSendSystemMessageContext;
class CBlockUsersContext;

#define XPROFILE_NO_RESULT ~0

/*****************************************************************************

CProfileStore

Main object for the profile store

*****************************************************************************/
class CProfileStore 
{
public:
    CProfileStore(CSwitchboard *pCSwitchboard);
    ~CProfileStore();

    HRESULT Init();
    
    HRESULT ResizeCompPort(DWORD dwMaxThreads, DWORD dwConcurrentThreads);
    static DWORD WINAPI CompPortShutdownThread(LPVOID pThis);

    HRESULT SendToSqlThread( CLocalContext* pCCtx );

    HRESULT SetFlushTickets(QWORD qwUserID);

    HRESULT TeamListTeams(
        QWORD qwUserID,
        DWORD dwTitleID,
        DWORD cTeamIDs,
	    QWORD *pqwTeamIDs,
        CClientConnection *pCReplyConn,
        DWORD dwSeqNum);

    HRESULT TeamListUserTeams(
        QWORD qwUserID,
        DWORD dwTitleID,
        CClientConnection *pCReplyConn,
        DWORD dwSeqNum);

    HRESULT TeamListMembers(
        QWORD qwUserID,
        DWORD dwTitleID,
        QWORD qwTeamID,
        BOOL fShowRecruits,
        CClientConnection *pCReplyConn,
        DWORD dwSeqNum);

    HRESULT TeamCreate(
        QWORD qwUserID,
        DWORD dwTitleID,
        DWORD dwMaxMembers,
        DWORD cbTeamName,
        LPCWSTR wszTeamName,
        DWORD cbTeamDescription,
        LPCWSTR wszTeamDescription,
        DWORD cbTeamMotto,
        LPCWSTR wszTeamMotto,
        DWORD cbTeamURL,
        LPCWSTR wszTeamURL,
        DWORD cbTeamData,
        BYTE *pbTeamData,
        DWORD cbCreatorData,
        BYTE *pbCreatorData,
        BOOL fXenon,
        CClientConnection *pCReplyConn,
        DWORD dwSeqNum);

    HRESULT TeamDelete(
        QWORD qwUserID,
        DWORD dwTitleID,
        QWORD qwTeamID,
        CClientConnection *pCReplyConn,
        DWORD dwSeqNum);

    HRESULT TeamRemove(
        ULONGLONG qwUserID,
        DWORD dwTitleID,
        ULONGLONG qwTeamID,
        ULONGLONG qwMemberID,
        CClientConnection *pCReplyConn,
        DWORD dwSeqNum);

    HRESULT TeamManageTeam(
        QWORD qwUserID,
        DWORD dwTitleID,
        QWORD qwTeamID,
        DWORD cbTeamName,
        LPCWSTR wszTeamName,
        DWORD cbTeamDescription,
        LPCWSTR wszTeamDescription,
        DWORD cbTeamMotto,
        LPCWSTR wszTeamMotto,
        DWORD cbTeamURL,
        LPCWSTR wszTeamURL,
        DWORD cbTeamData,
        BYTE *pbTeamData,
        BOOL fXenon,
        CClientConnection *pCReplyConn,
        DWORD dwSeqNum);

    HRESULT TeamManageMember(
        ULONGLONG qwUserID,
        DWORD dwTitleID,
        ULONGLONG qwTeamID,
        ULONGLONG qwMemberID,
        DWORD dwMemberPriv,
        DWORD cbMemberData,
        BYTE *pbMemberData,
        CClientConnection *pCReplyConn,
        DWORD dwSeqNum);

    HRESULT TeamRecruit(
        ULONGLONG qwUserID,
        DWORD dwTitleID,
        ULONGLONG qwTeamID,
        ULONGLONG qwMemberID,
        LPCSTR szMemberName,
        DWORD dwMemberPriv,
        DWORD dwMessageFlags,
        LPCSTR szSenderName,
        WORD cbDetails,
        const BYTE* pbDetails,
        DWORD cbMemberData,
        const BYTE *pbMemberData,
        CClientConnection *pCReplyConn,
        DWORD dwSeqNum);

    HRESULT TeamJoin(
        QWORD qwUserID,
        DWORD dwTitleID,
        QWORD qwTeamID,
        DWORD dwRecruitMsgID,
        BYTE bAnswer,
        CClientConnection *pCReplyConn,
        DWORD dwSeqNum);

    HRESULT TeamGetTicket(
        QWORD qwUserID,
        DWORD dwTitleID,
        CClientConnection *pCReplyConn,
        DWORD dwSeqNum);

    // Calls from SQL thread pool
    void StoreAlive(CAliveContext *pCCtx);
    HRESULT StoreSync(CSyncContext *pCCtx);
    HRESULT StoreAddBuddy(CAddBuddyContext *pCCtx);
    HRESULT StoreAddAffiliates(CAddAffiliatesContext *pCCtx);
    HRESULT StoreIsAffiliate(CIsAffiliateContext *pCCtx);
    HRESULT StoreQueryAffiliates(CQueryAffiliatesContext *pCCtx);
    HRESULT StoreStoreAffiliates(CStoreAffiliatesContext *pCCtx);
    HRESULT StoreAcceptBuddy(CAcceptBuddyContext *pCCtx);
    HRESULT StoreRejectBuddy(CRejectBuddyContext *pCCtx);
    HRESULT StoreDeleteBuddy(CDeleteBuddyContext *pCCtx);

    HRESULT StoreBlock(CBlockContext *pCCtx);
    HRESULT StoreUnblock(CUnblockContext *pCCtx);
    HRESULT StoreClearAllBlocks(CClearAllBlocksContext *pCCtx);

    HRESULT StoreSetFlushTickets(CSetFlushTicketsContext *pCCtx);

    HRESULT StoreGetOfflinePresence(CLoadOfflinePresenceContext *pCCtx);
    
    HRESULT StoreTeamListTeams(CTeamListTeamsContext *pCCtx);
    HRESULT StoreTeamListUserTeams(CTeamListUserTeamsContext *pCCtx);
    HRESULT StoreTeamListMembers(CTeamListMembersContext *pCCtx);
    HRESULT StoreTeamCreate(CTeamCreateContext *pCCtx);
    HRESULT StoreTeamDelete(CTeamDeleteContext *pCCtx);
    HRESULT StoreTeamRemove(CTeamRemoveContext *pCCtx);
    HRESULT StoreTeamManageTeam(CTeamManageTeamContext *pCCtx);
    HRESULT StoreTeamManageMember(CTeamManageMemberContext *pCCtx);
    HRESULT StoreTeamRecruit(CTeamRecruitContext *pCCtx);
    HRESULT StoreTeamJoin(CTeamJoinContext *pCCtx);
    HRESULT StoreTeamGetTicket(CTeamGetTicketContext *pCCtx);
    
    // Calls from SQL thread pool
    void StoreEnumerateMessages(CEnumerateMessagesContext *pCCtx);
    void StoreGetMessageSummary(CGetMessageSummaryContext *pCCtx);
    void StoreGetMessageDetails(CGetMessageDetailsContext *pCCtx);
    void StoreDeleteMessage(CDeleteMessageContext *pCCtx);
    void StoreSendMessage(CSendMessageInternalContext *pCCtx);
    void StoreRevokeMessage(CRevokeMessageContext *pCCtx);
    void StoreDeleteUserTitle(CDeleteUserTitleContext *pCCtx);
    void StoreEnumerateUserTitles(CEnumerateUserTitlesContext *pCCtx);
    void StoreMessageFlags(CMessageFlagsContext *pCCtx);
    void StoreUnblockUsers( CUnblockUsersContext* pCCtx );
    void StoreEnumSystemMessages( CEnumSystemMessagesContext* pCCtx );
    void StoreGetSystemMessageDetails( CSystemMessageDetailsContext* pCCtx );
    void StoreDeleteSystemMessage( CDeleteSystemMessageContext* pCCtx );
    void StoreSendSystemMessage( CSendSystemMessageContext* pCCtx );
    void StoreBlockUser(CBlockUsersContext* pCCtx);

protected:

    // PUID Generation
    HRESULT GetNextTeamPUID(QWORD qwUserID, QWORD *pqwTeamPUID);

    // System message ID generation
    HRESULT GetNextSystemMessageID( DWORD* pdwNextID ); 

    // Webstore helpers
    LONG GetUserBucket(QWORD qwUserID);
    LONG GetTeamBucket(QWORD qwTeamID);
    LONG GetTeamNameBucket(LPWSTR wszName);
    LONG GetBucketCount();
    void CannonizeName(LPWSTR wszName);

    // Private commands
    HRESULT SProcAddBuddy(
        QWORD qwUserID, 
        QWORD qwBuddyID,
        LPCSTR szBuddyAcctName, 
        DWORD *pdwVersion,
        IWSTDTC *piDTC);

    HRESULT SProcAddedBuddy(
        QWORD qwUserID, 
        QWORD qwBuddyID,
        LPCSTR szBuddyAcctName, 
        DWORD *pdwVersion,
        LPSTR szUserAcctName,
        DWORD *pcbUserAcctName,
        IWSTDTC *piDTC);

    HRESULT SProcAcceptBuddy(
        QWORD qwUserID, 
        QWORD qwBuddyID,
        DWORD *pdwVersion,
        LPSTR szUserAcctName,
        DWORD *pcbUserAcctName,
        IWSTDTC *piDTC);

    HRESULT SProcAcceptedBuddy(
        QWORD qwUserID, 
        QWORD qwBuddyID,
        DWORD *pdwVersion,
        LPSTR szUserAcctName,
        DWORD *pcbUserAcctName,
        IWSTDTC *piDTC);

    HRESULT SProcRejectBuddy(
        QWORD qwUserID, 
        QWORD qwBuddyID,
        BOOL fNever,
        DWORD *pdwVersion,
        IWSTDTC *piDTC);

    HRESULT SProcRejectedBuddy(
        QWORD qwUserID, 
        QWORD qwBuddyID,
        DWORD *pdwVersion,
        IWSTDTC *piDTC);

    HRESULT SProcDeleteBuddy(
        QWORD qwUserID, 
        QWORD qwBuddyID,
        DWORD *pdwVersion,
        IWSTDTC *piDTC);

    HRESULT SProcLoadAffiliates(
        QWORD qwUserID,
        DWORD dwFlags,
        CAffiliatesList *pAffiliatesList);

    HRESULT SProcCropAffiliates(
        QWORD qwUserID,
        DWORD dwFlags,
        MSGTIME mtDateUpdated);

    HRESULT SProcAddAffiliates(
        QWORD qwUserID,
        CAffiliatesList **rgpAffiliates,
        MSGTIME mtAffiliatesLoaded);

    HRESULT SProcGetUserIDByName(
        LPSTR szAccountName, 
        QWORD *pqwUserID);

    HRESULT SProcGetAccountNameByID(
        QWORD qwUserID, 
        LPSTR szAccountName, 
        DWORD *pcbAccountName);

    HRESULT SProcUpdateNameOthers(
        QWORD qwUserID,
        LPCSTR szAccountName);

    HRESULT SProcUpdateNameSelf(
        QWORD qwUserID,
        LPCSTR szAccountName);

    HRESULT UpdateNameAll(
        QWORD qwUserID,
        LPCSTR szAccountName);

    HRESULT SProcInsertUser(
        QWORD qwUserID,
        LPCSTR szAccountName,
        DWORD dwTitleID);

    HRESULT SProcClearFlushTickets(
        QWORD qwUserID);

    HRESULT SProcTeamPUIDGen( 
        DWORD dwBlockSize, 
        QWORD *pqwStart);

    HRESULT SProcGetTeamNameByID(
        QWORD qwTeamID, 
        LPWSTR wszTeamName, 
        DWORD *pcbTeamName);

    HRESULT SProcGetUserTeams(
        DWORD dwTitleID,
        QWORD qwUserID,
        BOOL fShowRecruits,
        DWORD *pcTeams,
        P_REPLY_USER_TEAM *rgqwTeams);

    HRESULT SProcGetTeamListTeam(
        DWORD dwTitleID,
        QWORD qwTeamID,
        CTCPCntVarBuffer **ppReply);

    HRESULT SProcGetTeamListMembers(
        DWORD dwTitleID,
        QWORD qwTeamID,
        BOOL fShowRecruits,
        DWORD *pcMembers,
        QWORD *pqwMembers,
        CTCPCntVarBuffer **ppReply);

    HRESULT SProcTeamCreateTeam(
        QWORD qwTeamID,
        DWORD dwTitleID,
        DWORD dwMaxMebers,
        LPCWSTR wszTeamName,
        LPCWSTR wszTeamDescription,
        LPCWSTR wszTeamMotto,
        LPCWSTR wszTeamURL,
        BYTE *pbTeamData,
        DWORD cbTeamData,
        QWORD qwCreatorUserID,
        LPCSTR szCreatorName,
        BYTE *pbCreatorData,
        DWORD cbCreatorData,
        IWSTDTC *piDTC);

    HRESULT SProcTeamCreateUser(
        QWORD qwUserID,
        DWORD dwTitleID,
        QWORD qwTeamID,
        LPCWSTR wszTeamName,
        IWSTDTC *piDTC);

    HRESULT SProcTeamCreateName(
        DWORD dwTitleID,
        QWORD qwTeamID,
        LPCWSTR wszTeamName,
        IWSTDTC *piDTC);

    HRESULT SProcTeamDeleteTeam(
        QWORD qwTeamID,
        QWORD qwUserID,
        DWORD *pcPendMembers,
        QWORD *rgqwPendMembers,
        IWSTDTC *piDTC);

    HRESULT SProcTeamDeleteUser(
        QWORD qwTeamID,
        IWSTDTC *piDTC);

    HRESULT SProcTeamDeleteName(
        QWORD qwTeamID,
        LPCWSTR wszTeamName,
        BOOL fRename,
        IWSTDTC *piDTC);

    HRESULT SProcTeamRemoveTeam(
        QWORD qwTeamID,
        QWORD qwUserID,
        QWORD qwMemberID,
        BOOL fMember,
        IWSTDTC *piDTC);

    HRESULT SProcTeamRemoveUser(
        QWORD qwUserID,
        QWORD qwTeamID,
        BOOL fMember,
        IWSTDTC *piDTC);

    HRESULT SProcTeamRecruitTeam(
        DWORD dwTitleID,
        QWORD qwTeamID,
        QWORD qwUserID,
        QWORD qwMemberID,
        LPCSTR szMemberName,
        DWORD dwMemberPriv,
        BYTE *pbMemberData,
        DWORD cbMemberData,
        LPSTR szTeamName, 
        DWORD *pcbTeamName,
        IWSTDTC *piDTC);

    HRESULT SProcTeamRecruitUser(
        QWORD qwUserID,
        DWORD dwTitleID,
        QWORD qwTeamID,
        LPCSTR szTeamName,
        QWORD qwRecruiterID,
        IWSTDTC *piDTC);

    HRESULT SProcTeamJoinTeam(
        QWORD qwTeamID,
        QWORD qwMemberID,
        IWSTDTC *piDTC);

    HRESULT SProcTeamJoinUser(
        QWORD qwUserID,
        QWORD qwTeamID,
        IWSTDTC *piDTC);

    HRESULT SProcTeamManageTeam(
        QWORD qwUserID,
        DWORD dwTitleID,
        QWORD qwTeamID,
        LPCWSTR wszTeamName,
        LPCWSTR wszTeamDescription,
        LPCWSTR wszTeamMotto,
        LPCWSTR wszTeamURL,
        BYTE *pbTeamData,
        DWORD cbTeamData,
        LPWSTR wszOldTeamName, 
        DWORD *pcbOldTeamName,
        IWSTDTC *piDTC);

    HRESULT SProcRenameTeam(
        QWORD qwTeamID,
        LPCWSTR wszTeamName,
        IWSTDTC *piDTC);

    void SProcAlive(
        CAliveContext *pCCtx, 
        BOOL* pfNameChanged, 
        BOOL* pfNeedMessagingWrite);

public:
    HRESULT SProcMessagingUserInit(
        CAliveContext* pCCtx);

protected:

    CSwitchboard *m_pCSwitchboard;
    CCompletionPort *m_pCCompPort;
    CCompletionPort *m_pOldCompPort;

    CComPtr<IWSTStore>      m_piWSTStore;
    CComPtr<IWSTCommand>    m_piCommand;
    CComPtr<IWSTHash>       m_piHash;

    QWORD m_qwNextTeamPUID;
    DWORD m_cTeamPUIDLeft;
    CRITICAL_SECTION m_csTeamPUIDGen;   
    DWORD m_dwNextSystemMessageID; // The next ID to use for system messages
    DWORD m_dwStopSystemMessageID; // The last ID + 1 to use for system messages
};

#endif  // PROFILESTORE_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\inh\sgcomm.cpp ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#include "stdafx.h"

/*****************************************************************************

CSGCommunicator::CSGCommunicator

Constructor

*****************************************************************************/
CSGCommunicator::CSGCommunicator() :
    m_pCCompPort(NULL),
    m_pCSwitchboard(NULL),
    m_pCQFlagsSocket(NULL),
    m_dwMaxDatagram(0)
{
}

/*****************************************************************************

CSGCommunicator::~CSGCommunicator

Destructor

*****************************************************************************/
CSGCommunicator::~CSGCommunicator()
{
    XomTrace( PresenceDebug, L_NORMAL, "CSGCommunicator::~CSGCommunicator()" );
    Shutdown();
}

/*****************************************************************************

CSGCommunicator::Init

Initializer, must be called before first use.

*****************************************************************************/
HRESULT CSGCommunicator::Init(CSwitchboard *pCSwitchboard)
{
    XOMASSERT(m_pCCompPort == NULL);
    XOMASSERT(pCSwitchboard != NULL);
    XOMASSERT(m_pCSwitchboard == NULL);

    HRESULT hr = S_OK;
    sockaddr_in sa;
    
    XomTrace( PresenceDebug, L_NORMAL, "CSGCommunicator::Init()" );

    // Create worker threads to deal with incoming network traffic
    hr = CCompletionPort::CreateInstance(
        0,  // dwConcurrancy
        1,  // dwThreadPoolSize
        THREAD_PRIORITY_NORMAL,
        &m_pCCompPort );

    if(FAILED(hr))
    {
        XomNtEvent(XEVENT_PRESENCE_CONFIG_60, "Unrecoverable failure while initializing: CCompPort::CreateInstance failed (%X)", hr);
        goto lDone;
    }

    m_pCSwitchboard = pCSwitchboard;
    m_pCSwitchboard->AddRef();

    // Create a socket to send and receive messages
    hr = CServerSocket::CreateInstance(&m_pCQFlagsSocket, m_pCCompPort, m_pCCompPort);
    if(FAILED(hr))
    {
        XomNtEvent(
            XEVENT_PRESENCE_CONFIG_61,  
            "CServSocket::CreateInstance failed for m_pCQFlagsSocket hr=%X", 
            hr);
        goto lDone;
    }
    
    memset(&sa, 0, sizeof(sa));
    sa.sin_family = AF_INET;
    sa.sin_port = htons( g_CPresCfg.GetSGQValRecvPort() );
    
    hr = m_pCQFlagsSocket->Init(IPPROTO_UDP, &sa, FALSE);
    if(FAILED(hr))
    {
        XomNtEvent(
            XEVENT_PRESENCE_CONFIG_62, 
            "m_pCSendSocket->Init failed hr=%X", 
            hr );
        goto lDone;
    }

    // Figure out the max datagram size
    hr = m_pCQFlagsSocket->GetMaxMessageSize(&m_dwMaxDatagram);
    if(FAILED(hr))
    {
        XomNtEvent(
            XEVENT_PRESENCE_CONFIG_63, 
            "m_pCQFlagsSocket->GetMaxMessageSize failed hr=%X", 
            hr );
        goto lDone;
    }

    // make 2 buffers, so one can always be on the socket.
    m_pbRecvBuffer1 = new BYTE[m_dwMaxDatagram];
    if( NULL == m_pbRecvBuffer1 )
    {
        XomNtEvent(
            XEVENT_PRESENCE_CONFIG_64, 
            "CSGCommunicator::Init - failed allocating receive buffer" );
        hr = E_OUTOFMEMORY;
        goto lDone;
    }
        
    m_pbRecvBuffer2 = new BYTE[m_dwMaxDatagram];
    if( NULL == m_pbRecvBuffer2 )
    {
        XomNtEvent(
            XEVENT_PRESENCE_CONFIG_65, 
            "CSGCommunicator::Init - failed allocating receive buffer" );
        hr = E_OUTOFMEMORY;
        goto lDone;
    }
        
    // Queue up a receive from to start listening
    hr = m_pCQFlagsSocket->ReceiveFrom(m_pbRecvBuffer1, m_dwMaxDatagram, this, (QWORD) m_pbRecvBuffer1);
    if(FAILED(hr))
    {
        XomNtEvent(
            XEVENT_PRESENCE_CONFIG_66, 
            "m_pCQFlagsSocket->ReceiveFrom failed hr=%X", 
            hr );
        goto lDone;
    }


lDone:


    return hr;
}

/*****************************************************************************

CSGCommunicator::Shutdown

Deinitializer

*****************************************************************************/
void CSGCommunicator::Shutdown()
{
    XomTrace( PresenceDebug, L_NORMAL, "CSGCommunicator::Shutdown()" );

    // XENON: There is a problem here that needs to be fixed in Xenon.  If everything were working correctly,
    // calling Release on the socket would be enough for it to clean up and properly close itself.  However, 
    // I/O completion ports do not tell us when they shutdown that we need to free any outstanding I/O context.
    // As a result, there is a still an oustanding I/O context with a reference on the socket, so it will never
    // go to zero and clean itself up.  Note that for the same reason we are also leaking a receive buffer
    // that we allocate in this file.  The solution is for the servhlp layer to track outstanding I/O contexts
    // (probably in the CompPort layer), so that they can be freed when the completion port is shutdown.  For
    // now, we close the socket here to make sure it gets closed.  Multiple calls to Close are safe.
    SAFE_SHUTRELEASE(m_pCCompPort);
    
    if( NULL != m_pCQFlagsSocket )
    {
        m_pCQFlagsSocket->Close();
        m_pCQFlagsSocket->Release();
        m_pCQFlagsSocket = NULL;
    }

    SAFE_ARRAYDELETE(m_pbRecvBuffer1);
    SAFE_ARRAYDELETE(m_pbRecvBuffer2);
    SAFE_RELEASE(m_pCSwitchboard);
}

/*****************************************************************************

CSGCommunicator::OnSocketSendTo

Callback from sockets.

*****************************************************************************/
void CSGCommunicator::OnSocketSendTo(
    BYTE *pbBufferSent,
    DWORD cbToSend,
    DWORD cbSent,
    HRESULT hr,
    QWORD qwCallbackArg )
{

    if (pbBufferSent != NULL)
    {
        delete[] pbBufferSent;
    }
}

/*****************************************************************************

CSGCommunicator::OnSocketReceiveFrom

Callback from sockets.

*****************************************************************************/
void CSGCommunicator::OnSocketReceiveFrom(
    BYTE *pbFilledInBuffer,
    DWORD cbRead,
    sockaddr_in *pFilledInFrom,
    HRESULT hrCallback,
    QWORD qwCallbackArg )
{
    BYTE *pbRecvBuffer = NULL;
    HRESULT hr;
    CSgMsgHdr *pSgMsgHdr;
    CSgMsgSetQValsRep *pCSgMsgSetQValsRep;

    XOMASSERT((pbFilledInBuffer == m_pbRecvBuffer1) || (pbFilledInBuffer == m_pbRecvBuffer2));
    XOMASSERT(pFilledInFrom != NULL);
    XOMASSERT(m_pCQFlagsSocket != NULL);
    XOMASSERT(m_pCSwitchboard != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "CSGCommunicator::OnSocketReceiveFrom() - %s:%d, cbRead=%d, hr=0x%08X", 
        inet_ntoa( pFilledInFrom->sin_addr ), 
        ntohs( pFilledInFrom->sin_port ),
        cbRead,
        hrCallback );

    if(HRESULT_FROM_WIN32(ERROR_OPERATION_ABORTED) == hrCallback)
    {
        // Shutting down
        hr = S_OK;
        goto lDone;
    }

    // swap buffers.
    if (pbFilledInBuffer == m_pbRecvBuffer1)
    {
        pbRecvBuffer = m_pbRecvBuffer2;
    }
    else
    {
        pbRecvBuffer = m_pbRecvBuffer1;
    }

    // First thing, requeue request so we can keep going.
    do
    {
        hr = m_pCQFlagsSocket->ReceiveFrom(pbRecvBuffer, m_dwMaxDatagram, this, NULL);
    
        // If a previous receive in this socket resulted in an ICMP "Port Unreachable" message,
        // WSARecvFrom will fail returning WSAECONNRESET. We must handle this error and retry.

        if(FAILED(hr))
        {
            XomTrace(
                PresenceDebug,
                L_NORMAL, 
                "m_pCQFlagsSocket->ReceiveFrom failed, hr = 0x%08x", 
                hr);
        }

    } while (FAILED(hr) && HRESULT_FACILITY(hr) == FACILITY_WIN32 && HRESULT_CODE(hr) == WSAECONNRESET);

    if(FAILED(hr))
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_404, 
            "CSGCommunicator::OnSocketReceiveFrom() - ReceiveFrom failed to submit new receive, hr=0x%08X", 
            hr );

        // NOTE: Even if we fail to post a new receive, we will still process the current one.
    }


    // If the current receive failed, skip processing it.
    if( FAILED( hrCallback ) )
    {
        // NOTE: This occurs in testing when the test app crashes because test apps act like their own SG by manipulating
        // their SGADDR.  The SendTo call below ends up causing an ICMP message to be received through this handler.

        // Call DeadSg if the INI file says we should
        if((0 != g_CPresCfg.GetDeadSgOnFailedQVal()) ||
            (hrCallback == HRESULT_FROM_WIN32(ERROR_PORT_UNREACHABLE)))
        {
            XomNtEvent(
                XEVENT_PRESENCE_CODE_405, 
                "SG @ %s:%d QVal send failed hr=0x%08X, calling Switchboard->DeadSg on this IP",
                inet_ntoa(pFilledInFrom->sin_addr), 
                ntohs(pFilledInFrom->sin_port),
                hrCallback);

            CDeadSGContext *pCCtx = new CDeadSGContext(m_pCSwitchboard);
            if (pCCtx != NULL)
            {
                pCCtx->m_sgaddr.inaSg = pFilledInFrom->sin_addr;
                pCCtx->m_sgaddr.dwSpiSg = 0;
                pCCtx->m_sgaddr.qwXboxID = 0;                

                m_pCSwitchboard->PostCompletion(pCCtx);
            }
        }
        else
        {
            XomNtEvent(
                XEVENT_PRESENCE_CODE_406, 
                "SG @ %s:%d QVal send failed hr=0x%08X",
                inet_ntoa(pFilledInFrom->sin_addr), 
                ntohs(pFilledInFrom->sin_port),
                hrCallback);
        }

        goto lDone;
    }

    // Parse the incomming message
    // CONSIDER: move this logic out of this function
    if (cbRead < sizeof(CSgMsgHdr))
    {
        // Log it and drop it on the floor
        XomNtEvent(
            XEVENT_PRESENCE_CODE_407, 
            "SG @ %s:%d sent datagram smaller than header %d < %d",
            inet_ntoa(pFilledInFrom->sin_addr), 
            ntohs(pFilledInFrom->sin_port),
            cbRead,
            sizeof(CSgMsgHdr));

        goto lDone;
    }

    pSgMsgHdr = (CSgMsgHdr *) pbFilledInBuffer;

    // Ignore these message type(s)
    if (pSgMsgHdr->_wType == SGMSG_TYPE_KICK_REP)
    {
        goto lDone;
    }

    if (pSgMsgHdr->_wType != SGMSG_TYPE_SET_QVALS_REP)
    {
        // Log it and drop it on the floor
        XomNtEvent(
            XEVENT_PRESENCE_CODE_408, 
            "SG @ %s:%d sent unexpected message type %d", 
            inet_ntoa(pFilledInFrom->sin_addr), 
            ntohs(pFilledInFrom->sin_port),
            pSgMsgHdr->_wType);

        goto lDone;
    }

    if (pSgMsgHdr->_cbEnt != cbRead)
    {
        // Log it and drop it on the floor
        XomNtEvent(
            XEVENT_PRESENCE_CODE_409, 
            "SG @ %s:%d sent message with incorrect size %d != %d",
            inet_ntoa(pFilledInFrom->sin_addr), 
            ntohs(pFilledInFrom->sin_port),
            pSgMsgHdr->_cbEnt,
            cbRead);

        goto lDone;
    }

    if (pSgMsgHdr->_cbEnt != sizeof(CSgMsgSetQValsRep))
    {
        // Log it and drop it on the floor
        XomNtEvent(
            XEVENT_PRESENCE_CODE_410, 
            "SG @ %s:%d sent CSgMsgSetQValsRep too small %d < %d", 
            inet_ntoa(pFilledInFrom->sin_addr), 
            ntohs(pFilledInFrom->sin_port),
            pSgMsgHdr->_cbEnt,
            sizeof(CSgMsgSetQValsRep));

        goto lDone;
    }

    // We know we're dealing with a QVals reply, so extract the contents and
    // pass onto the switchboard

    pCSgMsgSetQValsRep = (CSgMsgSetQValsRep *) pSgMsgHdr;

    XomTrace(PresenceDebug, L_NORMAL, "SGComm:OnSocketRecv() got QValReply from user %I64X context = %X, fNotFound = %d, fNoSuchUser = %d",
        pCSgMsgSetQValsRep->_qwUserId,
        pCSgMsgSetQValsRep->_dwContext,
        pCSgMsgSetQValsRep->_fNotFound,
        pCSgMsgSetQValsRep->_fNoSuchUser);        

    CSetQValsReplyContext *pCCtx = new CSetQValsReplyContext(m_pCSwitchboard);
    if (pCCtx != NULL)
    {
        memcpy(&(pCCtx->m_sgaddr), &(pCSgMsgSetQValsRep->_sgaddr), sizeof(SGADDR));
        pCCtx->m_qwUserId = pCSgMsgSetQValsRep->_qwUserId;
        pCCtx->m_dwContext = pCSgMsgSetQValsRep->_dwContext;
        pCCtx->m_fNotFound = pCSgMsgSetQValsRep->_fNotFound;
        pCCtx->m_fNoSuchUser = pCSgMsgSetQValsRep->_fNoSuchUser;

        m_pCSwitchboard->PostCompletion(pCCtx);
    }

lDone:

    return;

}

/*****************************************************************************

CSGCommunicator::SendQVals

Sends a UDP SET_QFLAGS message to the given SG

*****************************************************************************/
HRESULT CSGCommunicator::SendQVals(
    const SGADDR *psgaddr,
    QWORD qwUserID,
    DWORD cdwQVals,
    const DWORD *pdwQVals,
    DWORD dwSeqQVals,
    BOOL fPush)
{
    if (m_pCQFlagsSocket == NULL)
    {
        XOMASSERT(FALSE);
        return E_UNEXPECTED;
    }

    HRESULT hr = S_OK;

    // Build the destination address
    sockaddr_in saddrDest;
    
    memset( &saddrDest, 0, sizeof( saddrDest ) );
    saddrDest.sin_family = AF_INET;
    saddrDest.sin_addr.S_un.S_addr = psgaddr->inaSg.S_un.S_addr;
    saddrDest.sin_port = htons( g_CPresCfg.GetSGQValSendPort() );

    // Build the message
    BYTE               *rgbBuffer = NULL;
    CSgMsgSetQValsReq  *pMsg;


    rgbBuffer = new BYTE[sizeof(CSgMsgSetQValsReq) + (QVAL_COUNT * sizeof(DWORD))];
    if(rgbBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Set the core message
    pMsg = (CSgMsgSetQValsReq *) rgbBuffer;
    
    pMsg->_wType = (WORD) (fPush ? SGMSG_TYPE_SET_QVALS_PUSH : SGMSG_TYPE_SET_QVALS_LAZY);
    pMsg->_cbEnt = (WORD) (sizeof(CSgMsgSetQValsReq) + (cdwQVals * sizeof(DWORD)));
    memcpy(&(pMsg->_sgaddr), psgaddr, sizeof(SGADDR));
    pMsg->_qwUserId = qwUserID;
    pMsg->_dwContext = dwSeqQVals;

    // Set the QVals
    memcpy(rgbBuffer + sizeof(CSgMsgSetQValsReq), pdwQVals, cdwQVals * sizeof(DWORD));
    
    // Send the message message to the given IP:port
    hr = m_pCQFlagsSocket->SendTo(
        rgbBuffer,
        pMsg->_cbEnt,
        &saddrDest,
        this,
        1);
    if( SUCCEEDED( hr ) )
    {
        // Completion port owns the buffer now
        rgbBuffer = NULL;
    }
    
lDone:
    if (FAILED(hr))
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_411,
            "SendQVals SendTo failed hr=0x%X)", 
            hr);
    }
    
    SAFE_ARRAYDELETE( rgbBuffer );

    return hr;
}

/*****************************************************************************

CSGCommunicator::SendKick

Sends a UDP SGMSG_TYPE_KICK_REQ message to the given SG

*****************************************************************************/
HRESULT CSGCommunicator::SendKick(
    const SGADDR *psgaddr)
{
    if (m_pCQFlagsSocket == NULL)
    {
        XOMASSERT(FALSE);
        return E_UNEXPECTED;
    }

    HRESULT hr = S_OK;

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Send SendKick: sg %X spi %X xb %I64X",
        psgaddr->inaSg,
        psgaddr->dwSpiSg,
        psgaddr->qwXboxID);

    // Build the destination address
    sockaddr_in saddrDest;
    
    memset( &saddrDest, 0, sizeof( saddrDest ) );
    saddrDest.sin_family = AF_INET;
    saddrDest.sin_addr.S_un.S_addr = psgaddr->inaSg.S_un.S_addr;
    saddrDest.sin_port = htons( g_CPresCfg.GetSGQValSendPort() );

    // Build the message
    BYTE               *rgbBuffer = NULL;
    CSgMsgSetQValsReq  *pMsg;


    rgbBuffer = new BYTE[sizeof(CSgMsgKickReq)];
    if(rgbBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Set the core message
    pMsg = (CSgMsgSetQValsReq *) rgbBuffer;
    
    pMsg->_wType = (WORD) SGMSG_TYPE_KICK_REQ;
    pMsg->_cbEnt = (WORD) sizeof(CSgMsgKickReq);;
    memcpy(&(pMsg->_sgaddr), psgaddr, sizeof(SGADDR));
    
    // Send the message message to the given IP:port
    hr = m_pCQFlagsSocket->SendTo(
        rgbBuffer,
        pMsg->_cbEnt,
        &saddrDest,
        this,
        1);
    if( SUCCEEDED( hr ) )
    {
        // Completion port owns the buffer now
        rgbBuffer = NULL;
    }
    
lDone:
    if (FAILED(hr))
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_412,
            "SendKick SendTo failed hr=0x%X)", 
            hr);
    }
    
    SAFE_ARRAYDELETE( rgbBuffer );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\inh\profilestore.cpp ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#include "stdafx.h"
#include "wststore_i.c"
#include "wststoreidl_i.c"

VelocityProxy g_VelocityProxy;

/*****************************************************************************

ErrorCallback

OLEDB Error callback function.

*****************************************************************************/
HRESULT ErrorCallback(HRESULT hr, LPCSTR szInfo)
{
    XomNtEvent(XEVENT_PRESENCE_COMM_44, "OLEDB error: %s", szInfo);

    return hr;
}

/*****************************************************************************

CProfileStore::CProfileStore

Constuctor

*****************************************************************************/
CProfileStore::CProfileStore(CSwitchboard *pCSwitchboard) :
    m_pCSwitchboard(pCSwitchboard),
    m_pCCompPort(NULL),
    m_pOldCompPort(NULL),
    m_piWSTStore(NULL),
    m_piCommand(NULL),
    m_piHash(NULL),
    m_qwNextTeamPUID(0),
    m_cTeamPUIDLeft(0),
    m_dwNextSystemMessageID(0),
    m_dwStopSystemMessageID(0)
{
    InitializeCriticalSection(&m_csTeamPUIDGen);
}

/*****************************************************************************

CProfileStore::~CProfileStore

Destuctor

*****************************************************************************/
CProfileStore::~CProfileStore()
{
    SAFE_SHUTRELEASE( m_pCCompPort );
    DeleteCriticalSection(&m_csTeamPUIDGen);
}

/*****************************************************************************

CProfileStore::Init

Intialize the profile store interface

*****************************************************************************/
HRESULT CProfileStore::Init()
{
    HRESULT hr = S_OK;
    CComPtr<IWSTProperties> piWSTProp;
    DBPROP DBProp;
    DBPROPSET DBPropSet;

    // Setup our Webstore interfaces
    if (!m_piWSTStore)
    {
        // create the store
        hr = m_piWSTStore.CoCreateInstance(CLSID_WSTStore, 0, CLSCTX_SERVER);
        if(FAILED(hr))
        {
            XomNtEvent(XEVENT_PRESENCE_CONFIG_51, "Unrecoverable failure while initializing: m_piWSTStore.CoCreateInstance failed for profile store (%X)", hr );
            goto lDone;
        }
    }

    // Init the store
    hr = m_piWSTStore->Initialize(g_CPresCfg.GetWebStoreApplicationName(VirtualInterface_uodb));
    if(FAILED(hr))
    {
        XomNtEvent(XEVENT_PRESENCE_CONFIG_52, "Unrecoverable failure while initializing: m_piWSTStore->Initialize failed for profile store (%X)", hr );
        goto lDone;
    }

    // Get the hash interface
    hr = m_piWSTStore->QueryInterface(&m_piHash);
    if (FAILED(hr))
    {
        XomNtEvent(XEVENT_PRESENCE_CONFIG_53, "Unrecoverable failure while initializing: m_piWSTStore->QueryInterface(&m_piHash) failed for profile store (%X)", hr );
        goto lDone;
    }

    // Get the command interface
    hr = m_piWSTStore->QueryInterface(&m_piCommand);
    if (FAILED(hr))
    {
        XomNtEvent(XEVENT_PRESENCE_CONFIG_54, "Unrecoverable failure while initializing: m_piWSTStore->QueryInterface(&m_piCommand) failed for profile store (%X)", hr );
        goto lDone;
    }

    // Set the sequential access property
    hr = m_piWSTStore->QueryInterface(&piWSTProp);
    if (FAILED(hr))
    {
        XomNtEvent(XEVENT_PRESENCE_CONFIG_55, "Unrecoverable failure while initializing: m_piWSTStore->QueryInterface(&piWSTProp) failed for profile store (%X)", hr );
        goto lDone;
    }

    VariantInit(&DBProp.vValue);
    DBProp.dwPropertyID       = DBPROP_ACCESSORDER;
    DBProp.dwOptions          = DBPROPOPTIONS_REQUIRED;
    DBProp.dwStatus           = 0;
    DBProp.colid              = DB_NULLID;
    DBProp.vValue.vt          = VT_I4;
    V_I4(&DBProp.vValue)      = DBPROPVAL_AO_SEQUENTIAL;

    DBPropSet.rgProperties    = &DBProp;
    DBPropSet.guidPropertySet = DBPROPSET_ROWSET;
    DBPropSet.cProperties     = 1;

    hr = piWSTProp->SetProperties(
        IID_ICommandProperties,
        1,
        &DBPropSet);
    if (FAILED(hr))
    {
        XomNtEvent(XEVENT_PRESENCE_CONFIG_56, "Unrecoverable failure while initializing: piWSTProp->SetProperties failed for profile store (%X)", hr );
        goto lDone;
    }

    // Create worker threads to deal with incoming network traffic
    hr = CCompletionPort::CreateInstance(
        g_CPresCfg.GetConcurrentSQLThreads(),
        g_CPresCfg.GetNumSQLThreads(),
        THREAD_PRIORITY_NORMAL,
        &m_pCCompPort );
    if(FAILED(hr))
    {
        XomNtEvent(XEVENT_PRESENCE_CONFIG_57, "Unrecoverable failure while initializing: CCompPort::CreateInstance failed for profile store (%X)", hr );
        goto lDone;
    }

lDone:
    return hr;
}

HRESULT CProfileStore::ResizeCompPort(DWORD dwMaxThreads, DWORD dwConcurrentThreads)
{
    HRESULT hr = S_OK;

    if (m_pOldCompPort != NULL)
    {
        hr = E_UNEXPECTED;
        XomNtEvent(XEVENT_PRESENCE_CODE_254, "CProfileStore::ResizeCompPort() called when another resize is still in progress.");

        // skip error handler and just exit.
        return hr;
    }

    // backup old comp port.
    m_pOldCompPort = m_pCCompPort;

    // make a new comp port with the new parameters.
    m_pCCompPort = NULL;
    hr = CCompletionPort::CreateInstance(
        dwConcurrentThreads,
        dwMaxThreads,
        THREAD_PRIORITY_NORMAL,
        &m_pCCompPort );
    if(FAILED(hr))
    {
        m_pCCompPort = m_pOldCompPort;
        m_pOldCompPort = NULL;

        XomNtEvent(XEVENT_PRESENCE_CONFIG_58, "CProfileStore::ResizeCompPort(): CCompPort::CreateInstance failed for profile store (%X)", hr );
        goto lDone;
    }

    // now we have to shut down the old port.  we cant do this on switchboard's thread.
    DWORD dwThreadID = 0;
    HANDLE hThread = CreateThread(NULL, 0, CompPortShutdownThread, (LPVOID)this, 0, &dwThreadID);
    if ((hThread == NULL) || (hThread == INVALID_HANDLE_VALUE))
    {
        hr = E_POINTER;
        XomNtEvent(
            XEVENT_PRESENCE_CONFIG_59,
            "CProfileStore::ResizeCompPort(): could not create shutdown thread for old compport.  Potentially leaking %d threads.",
            g_CPresCfg.GetNumSQLThreads());

        goto lDone;
    }

    // NOTE: the hThread handle is leaked.  the following line may be safe, and may fix the leak.
    // CloseHandle(hThread);

lDone:

    return hr;
}

DWORD WINAPI CProfileStore::CompPortShutdownThread(LPVOID lpVoid)
{
    CProfileStore *pThis = (CProfileStore *)lpVoid;
    if (pThis != NULL)
    {
        SAFE_SHUTRELEASE(pThis->m_pOldCompPort);
    }

    return 0;
}


/*****************************************************************************

CProfileStore::SendToSqlThread

Post a work item into the SQL thread pool.

*****************************************************************************/
HRESULT CProfileStore::SendToSqlThread( CLocalContext* pCCtx )
{
    XOMASSERT(m_pCCompPort != NULL);

    pCCtx->SetPostData( CLocalContext::PostSql );

     // Send it over to the SQL thread pool
    return m_pCCompPort->PostCompletion( pCCtx );
}


/*****************************************************************************

CProfileStore::SetFlushTickets

Send a message to the storage thread pool to set the flush ticket flag for a
given user.

*****************************************************************************/
HRESULT CProfileStore::SetFlushTickets(QWORD qwUserID)
{
    XOMASSERT(m_pCCompPort != NULL);

    HRESULT hr = S_OK;
    CSetFlushTicketsContext *pCCtx;

    // Create a context object
    pCCtx = new CSetFlushTicketsContext(m_pCSwitchboard, this);
    if (pCCtx == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Populate the context object
    pCCtx->m_qwUserID = qwUserID;

    // Send it over to the SQL thread pool
    hr = SendToSqlThread( pCCtx );
    if (FAILED(hr))
    {
        goto lDone;
    }

lDone:
    return hr;
}

/*****************************************************************************

CProfileStore::TeamListTeams

Send a message to the storage thread pool to list information on a set of teams

*****************************************************************************/
HRESULT CProfileStore::TeamListTeams(
    QWORD qwUserID,
    DWORD dwTitleID,
    DWORD cTeamIDs,
    QWORD *pqwTeamIDs,
    CClientConnection *pCReplyConn,
    DWORD dwSeqNum)
{
    XOMASSERT(m_pCCompPort != NULL);

    HRESULT hr = S_OK;
    CTeamListTeamsContext *pCCtx;

    // Create a context object
    pCCtx = new CTeamListTeamsContext(m_pCSwitchboard, this);
    if (pCCtx == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Populate the context object
    pCCtx->m_fProcessed = FALSE;
    pCCtx->m_qwUserID = qwUserID;
    pCCtx->m_dwTitleID = dwTitleID;
    pCCtx->m_cTeamIDs = cTeamIDs;
    pCCtx->m_pCReplyConn = pCReplyConn;
    pCCtx->m_dwSeqNum = dwSeqNum;
    pCReplyConn->AddRef();

    memcpy(pCCtx->m_rgqwTeamIDs, pqwTeamIDs, cTeamIDs * sizeof(QWORD));

    // Send it over to the SQL thread pool
    hr = SendToSqlThread( pCCtx );
    if (FAILED(hr))
    {
        goto lDone;
    }

lDone:
    return hr;

}

/*****************************************************************************

CProfileStore::TeamListTeams

Send a message to the storage thread pool to list information on a set of teams

*****************************************************************************/
HRESULT CProfileStore::TeamListUserTeams(
    QWORD qwUserID,
    DWORD dwTitleID,
    CClientConnection *pCReplyConn,
    DWORD dwSeqNum)
{
    XOMASSERT(m_pCCompPort != NULL);

    HRESULT hr = S_OK;
    CTeamListUserTeamsContext *pCCtx;

    // Create a context object
    pCCtx = new CTeamListUserTeamsContext(m_pCSwitchboard, this);
    if (pCCtx == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Populate the context object
    pCCtx->m_fProcessed = FALSE;
    pCCtx->m_qwUserID = qwUserID;
    pCCtx->m_dwTitleID = dwTitleID;
    pCCtx->m_pCReplyConn = pCReplyConn;
    pCCtx->m_dwSeqNum = dwSeqNum;
    pCReplyConn->AddRef();

    // Send it over to the SQL thread pool
    hr = SendToSqlThread( pCCtx );
    if (FAILED(hr))
    {
        goto lDone;
    }

lDone:
    return hr;

}

/*****************************************************************************

CProfileStore::TeamListMembers

Send a message to the storage thread pool to list the membes of a team

*****************************************************************************/
HRESULT CProfileStore::TeamListMembers(
    QWORD qwUserID,
    DWORD dwTitleID,
    QWORD qwTeamID,
    BOOL fShowRecruits,
    CClientConnection *pCReplyConn,
    DWORD dwSeqNum)
{
   XOMASSERT(m_pCCompPort != NULL);

    HRESULT hr = S_OK;
    CTeamListMembersContext *pCCtx;

    // Create a context object
    pCCtx = new CTeamListMembersContext(m_pCSwitchboard, this);
    if (pCCtx == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Populate the context object
    pCCtx->m_fProcessed = FALSE;
    pCCtx->m_qwUserID = qwUserID;
    pCCtx->m_dwTitleID = dwTitleID;
    pCCtx->m_qwTeamID = qwTeamID;
    pCCtx->m_fShowRecruits = fShowRecruits;
    pCCtx->m_pCReplyConn = pCReplyConn;
    pCCtx->m_dwSeqNum = dwSeqNum;
    pCReplyConn->AddRef();

    // Send it over to the SQL thread pool
    hr = SendToSqlThread( pCCtx );
    if (FAILED(hr))
    {
        goto lDone;
    }

lDone:
    return hr;
}

/*****************************************************************************

CProfileStore::TeamCreate

Send a message to the storage thread pool to create a team

*****************************************************************************/
HRESULT CProfileStore::TeamCreate(
    QWORD qwUserID,
    DWORD dwTitleID,
    DWORD dwMaxMembers,
    DWORD cbTeamName,
    LPCWSTR wszTeamName,
    DWORD cbTeamDescription,
    LPCWSTR wszTeamDescription,
    DWORD cbTeamMotto,
    LPCWSTR wszTeamMotto,
    DWORD cbTeamURL,
    LPCWSTR wszTeamURL,
    DWORD cbTeamData,
    BYTE *pbTeamData,
    DWORD cbCreatorData,
    BYTE *pbCreatorData,
    BOOL fXenon,
    CClientConnection *pCReplyConn,
    DWORD dwSeqNum)
{
    XOMASSERT(m_pCCompPort != NULL);

    HRESULT hr = S_OK;
    CTeamCreateContext *pCCtx;

    // Create a context object
    pCCtx = new CTeamCreateContext(m_pCSwitchboard, this);
    if (pCCtx == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Populate the context object
    pCCtx->m_fProcessed = FALSE;
    pCCtx->m_qwUserID = qwUserID;
    pCCtx->m_dwTitleID = dwTitleID;
    pCCtx->m_dwMaxMembers = dwMaxMembers;
    pCCtx->m_cbTeamName = cbTeamName;
    pCCtx->m_cbTeamDescription = cbTeamDescription;
    pCCtx->m_cbTeamMotto = cbTeamMotto;
    pCCtx->m_cbTeamURL = cbTeamURL;
    pCCtx->m_cbTeamData = cbTeamData;
    pCCtx->m_cbCreatorData = cbCreatorData;
    pCCtx->m_fXenon = fXenon;
    pCCtx->m_pCReplyConn = pCReplyConn;
    pCCtx->m_dwSeqNum = dwSeqNum;
    pCReplyConn->AddRef();

    memcpy(pCCtx->m_wszTeamName, wszTeamName, cbTeamName);
    memcpy(pCCtx->m_wszTeamDescription, wszTeamDescription, cbTeamDescription);
    memcpy(pCCtx->m_wszTeamMotto, wszTeamMotto, cbTeamMotto);
    memcpy(pCCtx->m_wszTeamURL, wszTeamURL, cbTeamURL);
    memcpy(pCCtx->m_pbTeamData, pbTeamData, cbTeamData);
    memcpy(pCCtx->m_pbCreatorData, pbCreatorData, cbCreatorData);

    // Send it over to the SQL thread pool
    hr = SendToSqlThread( pCCtx );
    if (FAILED(hr))
    {
        goto lDone;
    }

lDone:
    return hr;
}

/*****************************************************************************

CProfileStore::TeamDelete

Send a message to the storage thread pool to delete a team

*****************************************************************************/
HRESULT CProfileStore::TeamDelete(
    QWORD qwUserID,
    DWORD dwTitleID,
    QWORD qwTeamID,
    CClientConnection *pCReplyConn,
    DWORD dwSeqNum)
{
    XOMASSERT(m_pCCompPort != NULL);

    HRESULT hr = S_OK;
    CTeamDeleteContext *pCCtx;

    // Create a context object
    pCCtx = new CTeamDeleteContext(m_pCSwitchboard, this);
    if (pCCtx == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Populate the context object
    pCCtx->m_fProcessed = FALSE;
    pCCtx->m_qwUserID = qwUserID;
    pCCtx->m_dwTitleID = dwTitleID;
    pCCtx->m_qwTeamID = qwTeamID;
    pCCtx->m_pCReplyConn = pCReplyConn;
    pCCtx->m_dwSeqNum = dwSeqNum;
    pCReplyConn->AddRef();

    // Send it over to the SQL thread pool
    hr = SendToSqlThread( pCCtx );
    if (FAILED(hr))
    {
        goto lDone;
    }

lDone:
    return hr;
}

/*****************************************************************************

CProfileStore::TeamRemove

Send a message to the storage thread pool to remove a member from a team

*****************************************************************************/
HRESULT CProfileStore::TeamRemove(
    ULONGLONG qwUserID,
    DWORD dwTitleID,
    ULONGLONG qwTeamID,
    ULONGLONG qwMemberID,
    CClientConnection *pCReplyConn,
    DWORD dwSeqNum)
{
    XOMASSERT(m_pCCompPort != NULL);

    HRESULT hr = S_OK;
    CTeamRemoveContext *pCCtx;

    // Create a context object
    pCCtx = new CTeamRemoveContext(m_pCSwitchboard, this);
    if (pCCtx == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Populate the context object
    pCCtx->m_fProcessed = FALSE;
    pCCtx->m_qwUserID = qwUserID;
    pCCtx->m_dwTitleID = dwTitleID;
    pCCtx->m_qwTeamID = qwTeamID;
    pCCtx->m_qwMemberID = qwMemberID;
    pCCtx->m_pCReplyConn = pCReplyConn;
    pCCtx->m_dwSeqNum = dwSeqNum;
    pCReplyConn->AddRef();

    // Send it over to the SQL thread pool
    hr = SendToSqlThread( pCCtx );
    if (FAILED(hr))
    {
        goto lDone;
    }

lDone:
    return hr;
}

/*****************************************************************************

CProfileStore::TeamManageTeam

Send a message to the storage thread pool to manage a team

*****************************************************************************/
HRESULT CProfileStore::TeamManageTeam(
    QWORD qwUserID,
    DWORD dwTitleID,
    QWORD qwTeamID,
    DWORD cbTeamName,
    LPCWSTR wszTeamName,
    DWORD cbTeamDescription,
    LPCWSTR wszTeamDescription,
    DWORD cbTeamMotto,
    LPCWSTR wszTeamMotto,
    DWORD cbTeamURL,
    LPCWSTR wszTeamURL,
    DWORD cbTeamData,
    BYTE *pbTeamData,
    BOOL fXenon,
    CClientConnection *pCReplyConn,
    DWORD dwSeqNum)
{
    XOMASSERT(m_pCCompPort != NULL);

    HRESULT hr = S_OK;
    CTeamManageTeamContext *pCCtx;

    // Create a context object
    pCCtx = new CTeamManageTeamContext(m_pCSwitchboard, this);
    if (pCCtx == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Populate the context object
    pCCtx->m_fProcessed = FALSE;
    pCCtx->m_qwUserID = qwUserID;
    pCCtx->m_dwTitleID = dwTitleID;
    pCCtx->m_qwTeamID = qwTeamID;
    pCCtx->m_cbTeamName = cbTeamName;
    pCCtx->m_cbTeamDescription = cbTeamDescription;
    pCCtx->m_cbTeamMotto = cbTeamMotto;
    pCCtx->m_cbTeamURL = cbTeamURL;
    pCCtx->m_cbTeamData = cbTeamData;
    pCCtx->m_fXenon = fXenon;
    pCCtx->m_pCReplyConn = pCReplyConn;
    pCCtx->m_dwSeqNum = dwSeqNum;
    pCReplyConn->AddRef();

    memcpy(pCCtx->m_wszTeamName, wszTeamName, cbTeamName);
    memcpy(pCCtx->m_wszTeamDescription, wszTeamDescription, cbTeamDescription);
    memcpy(pCCtx->m_wszTeamMotto, wszTeamMotto, cbTeamMotto);
    memcpy(pCCtx->m_wszTeamURL, wszTeamURL, cbTeamURL);
    memcpy(pCCtx->m_pbTeamData, pbTeamData, cbTeamData);

    // Send it over to the SQL thread pool
    hr = SendToSqlThread( pCCtx );
    if (FAILED(hr))
    {
        goto lDone;
    }

lDone:
    return hr;
}

/*****************************************************************************

CProfileStore::TeamManageMember

Send a message to the storage thread pool to manage a team member

*****************************************************************************/
HRESULT CProfileStore::TeamManageMember(
    ULONGLONG qwUserID,
    DWORD dwTitleID,
    ULONGLONG qwTeamID,
    ULONGLONG qwMemberID,
    DWORD dwMemberPriv,
    DWORD cbMemberData,
    BYTE *pbMemberData,
    CClientConnection *pCReplyConn,
    DWORD dwSeqNum)
{
    XOMASSERT(m_pCCompPort != NULL);

    HRESULT hr = S_OK;
    CTeamManageMemberContext *pCCtx;

    // Create a context object
    pCCtx = new CTeamManageMemberContext(m_pCSwitchboard, this);
    if (pCCtx == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Populate the context object
    pCCtx->m_fProcessed = FALSE;
    pCCtx->m_qwUserID = qwUserID;
    pCCtx->m_dwTitleID = dwTitleID;
    pCCtx->m_qwTeamID = qwTeamID;
    pCCtx->m_qwMemberID = qwMemberID;
    pCCtx->m_dwMemberPriv = dwMemberPriv;
    pCCtx->m_cbMemberData = cbMemberData;
    pCCtx->m_pCReplyConn = pCReplyConn;
    pCCtx->m_dwSeqNum = dwSeqNum;
    pCReplyConn->AddRef();

    memcpy(pCCtx->m_pbMemberData, pbMemberData, cbMemberData);

    // Send it over to the SQL thread pool
    hr = SendToSqlThread( pCCtx );
    if (FAILED(hr))
    {
        goto lDone;
    }

lDone:
    return hr;
}


/*****************************************************************************

CProfileStore::TeamRecruit

Send a message to the storage thread pool to recruit to a team

*****************************************************************************/
HRESULT CProfileStore::TeamRecruit(
    ULONGLONG qwUserID,
    DWORD dwTitleID,
    ULONGLONG qwTeamID,
    ULONGLONG qwMemberID,
    LPCSTR szMemberName,
    DWORD dwMemberPriv,
    DWORD dwMessageFlags,
    LPCSTR szSenderName,
    WORD cbDetails,
    const BYTE* pbDetails,
    DWORD cbMemberData,
    const BYTE *pbMemberData,
    CClientConnection *pCReplyConn,
    DWORD dwSeqNum)
{
    XOMASSERT(m_pCCompPort != NULL);

    HRESULT hr = S_OK;
    CTeamRecruitContext *pCCtx;

    // Create a context object
    pCCtx = new CTeamRecruitContext(m_pCSwitchboard, this);
    if (pCCtx == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Populate the context object
    pCCtx->m_fProcessed = FALSE;
    pCCtx->m_qwUserID = qwUserID;
    pCCtx->m_dwTitleID = dwTitleID;
    pCCtx->m_qwTeamID = qwTeamID;
    pCCtx->m_qwMemberID = qwMemberID;
    pCCtx->m_dwMemberPriv = dwMemberPriv;
    pCCtx->m_dwMessageFlags = dwMessageFlags;
    pCCtx->m_cbDetails = cbDetails;
    pCCtx->m_cbMemberData = cbMemberData;
    pCCtx->m_pCReplyConn = pCReplyConn;
    pCCtx->m_dwSeqNum = dwSeqNum;
    pCReplyConn->AddRef();

    if (szMemberName != NULL)
    {
        strncpy(pCCtx->m_szMemberName, szMemberName, XONLINE_GAMERTAG_SIZE);
        pCCtx->m_szMemberName[XONLINE_GAMERTAG_SIZE - 1] ='\0';
    }
    if (szSenderName != NULL)
    {
        strncpy(pCCtx->m_szSenderName, szSenderName, XONLINE_GAMERTAG_SIZE);
        pCCtx->m_szSenderName[XONLINE_GAMERTAG_SIZE - 1] ='\0';
    }
    memcpy(pCCtx->m_rgbDetails, pbDetails, cbDetails);
    memcpy(pCCtx->m_pbMemberData, pbMemberData, cbMemberData);

    // Send it over to the SQL thread pool
    hr = SendToSqlThread( pCCtx );
    if (FAILED(hr))
    {
        goto lDone;
    }

lDone:
    return hr;
}

/*****************************************************************************

CProfileStore::TeamJoin

Send a message to the storage thread pool to join a team

*****************************************************************************/
HRESULT CProfileStore::TeamJoin(
    QWORD qwUserID,
    DWORD dwTitleID,
    QWORD qwTeamID,
    DWORD dwRecruitMsgID,
    BYTE bAnswer,
    CClientConnection *pCReplyConn,
    DWORD dwSeqNum)
{
    XOMASSERT(m_pCCompPort != NULL);

    HRESULT hr = S_OK;
    CTeamJoinContext *pCCtx;

    // Create a context object
    pCCtx = new CTeamJoinContext(m_pCSwitchboard, this);
    if (pCCtx == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Populate the context object
    pCCtx->m_fProcessed = FALSE;
    pCCtx->m_qwUserID = qwUserID;
    pCCtx->m_dwTitleID = dwTitleID;
    pCCtx->m_qwTeamID = qwTeamID;
    pCCtx->m_dwRecruitMsgID = dwRecruitMsgID;
    pCCtx->m_bAnswer = bAnswer;
    pCCtx->m_pCReplyConn = pCReplyConn;
    pCCtx->m_dwSeqNum = dwSeqNum;
    pCReplyConn->AddRef();

    // Send it over to the SQL thread pool
    hr = SendToSqlThread( pCCtx );
    if (FAILED(hr))
    {
        goto lDone;
    }

lDone:
    return hr;
}

/*****************************************************************************

CProfileStore::TeamGetTicket

Send a message to the storage thread pool to get team membership

*****************************************************************************/
HRESULT CProfileStore::TeamGetTicket(
    QWORD qwUserID,
    DWORD dwTitleID,
    CClientConnection *pCReplyConn,
    DWORD dwSeqNum)
{
    XOMASSERT(m_pCCompPort != NULL);

    HRESULT hr = S_OK;
    CTeamGetTicketContext *pCCtx;

    // Create a context object
    pCCtx = new CTeamGetTicketContext(m_pCSwitchboard, this);
    if (pCCtx == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Populate the context object
    pCCtx->m_fProcessed = FALSE;
    pCCtx->m_qwUserID = qwUserID;
    pCCtx->m_dwTitleID = dwTitleID;
    pCCtx->m_pCReplyConn = pCReplyConn;
    pCCtx->m_dwSeqNum = dwSeqNum;
    pCReplyConn->AddRef();

    // Send it over to the SQL thread pool
    hr = SendToSqlThread( pCCtx );
    if (FAILED(hr))
    {
        goto lDone;
    }

lDone:
    return hr;
}

/*****************************************************************************

CProfileStore::StoreAlive

Load the given user's profile from the store.  This includes their buddy and
blocked lists.  The result is sent back via the switchboard's completion port
to a callback function.

*****************************************************************************/
void CProfileStore::StoreAlive(CAliveContext *pCCtx)
{
    BOOL fNameChanged;
    BOOL fNeedMessagingWrite;

    fNameChanged = FALSE;
    fNeedMessagingWrite = FALSE;

    // Start by calling the Alive stored procedure.  This does the read-only portion
    // of the overall Alive process.
    SProcAlive( pCCtx, &fNameChanged, &fNeedMessagingWrite );

    // We went to the database. Some context values have been filled that we should
    //  record in the Presence record
    pCCtx->m_fWentToStore = TRUE;

    // There are a variety of circumstances where the initial Alive informs us that we have
    // more work to do (usually because there is a write involved that could not be performed
    // by the initial read-only stored procedure).

    if( FAILED( pCCtx->m_hrStore ) )
    {
        // Report the hr and if it came from the stored proc
        switch( pCCtx->m_hrStore )
        {
        case XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT:
            // continue with checks for changed name and system messages
            break;

        case XONLINE_E_NOTIFICATION_FLUSH_TICKETS:
            // clear flush tickets flag for user
            (void) SProcClearFlushTickets(pCCtx->m_qwUserID);
            goto lDone;

        default:
            XomNtEvent(XEVENT_PRESENCE_CODE_255, "SProcAlive failed hr=%X", pCCtx->m_hrStore );
            goto lDone;
        }
    }

    if( fNameChanged )
    {
        // I'm intentionally ignoreing the return code because this is a
        // best effort.  If we fail we'll do this again next Alive
        UpdateNameAll(
            pCCtx->m_qwUserID,
            pCCtx->m_szAccountName);
    }

    if( fNeedMessagingWrite )
    {
        // This is best-effort.  It is allowed to fail under failover scenarios and should not impede the
        // overall Alive process.
        HRESULT hr = SProcMessagingUserInit(pCCtx);

        // Checking for new system messages may have added messages to the user's queue.  If the return value is
        // one of the known ones, it trumps whatever older result we got from SProcAlive.
        if( XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT == hr ||
            XONLINE_S_LOGON_USER_HAS_MESSAGE == hr ||
            XONLINE_S_LOGON_USER_MESSAGE_ENUMERATION_NEEDED == hr )
        {
            pCCtx->m_hrStore = hr;
        }
    }

lDone:
    (void) m_pCSwitchboard->PostCompletion(pCCtx);
}

/*****************************************************************************

CProfileStore::SProcAlive

Call the alive stored procedure.

*****************************************************************************/
void CProfileStore::SProcAlive(CAliveContext *pCCtx, BOOL* pfNameChanged, BOOL* pfNeedMessagingWrite)
{
    XOMASSERT(m_pCSwitchboard != NULL);
    XOMASSERT(pCCtx != NULL);
    XOMASSERT(pfNameChanged != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Going to SQL for SProcAlive");

    HRESULT hr = S_OK;
    CComPtr<IMultipleResults> piResults = NULL;
    CWSODBWResult CResults(ErrorCallback);
    DWORD dwIndex = 0;
    BYTE *pbWrite = NULL;
    DWORD cRows = 0;
    DWORD cBuddies = 0;
    DWORD cBlocks = 0;
    DWORD cbAcctName = 0;

    CBuddyListEntry *rgCBuddyList = NULL;

    CTCPCntVarBuffer *pCReplyBuddies = NULL;
    P_REPLY_BUDDY *pReplyBuddiesWork = NULL;
    DWORD cbReplyBuddies = 0;

    CTCPCntVarBuffer *pCReplyBlocks = NULL;
    P_REPLY_BLOCK *pReplyBlocksWork = NULL;
    DWORD cbReplyBlocks = 0;

    ULONGLONG* pqwNeverList = NULL;
    WORD cNeverList = 0;

    // Parameter structures
    struct sAliveParams_t {
        INT iRet;
        QWORD qwUserID;
        QWORD qwXboxID;
        DWORD dwBuddyListVersion;
        DWORD dwBlockListVersion;
        DWORD dwTitleID;
        DWORD dwAltTitleID1;
        DWORD dwAltTitleID2;
        DWORD dwAltTitleID3;
        DWORD dwAltTitleID4;
        DWORD dwTitleRegion;
        BOOL fNameChanged;
        BOOL fNeedMessagingWrite;
        CHAR szAcctName[MAX_ACCTNAME_BYTES];
    } sAliveParams;

    static WSTCOMMANDPARAM rgwstcpAliveParams[] = {
        {1,  DBPARAMIO_OUTPUT, DBTYPE_I4,  sizeof(sAliveParams.iRet),               offsetof(sAliveParams_t, iRet),               NULL},
        {2,  DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sAliveParams.qwUserID),           offsetof(sAliveParams_t, qwUserID),           NULL},
        {3,  DBPARAMIO_INPUT,  DBTYPE_STR, sizeof(sAliveParams.szAcctName),         offsetof(sAliveParams_t, szAcctName),         NULL},
        {4,  DBPARAMIO_INPUT,  DBTYPE_I4,  sizeof(sAliveParams.dwBuddyListVersion), offsetof(sAliveParams_t, dwBuddyListVersion), NULL},
        {5,  DBPARAMIO_INPUT,  DBTYPE_I4,  sizeof(sAliveParams.dwBlockListVersion), offsetof(sAliveParams_t, dwBlockListVersion), NULL},
        {6,  DBPARAMIO_INPUT,  DBTYPE_I4,  sizeof(sAliveParams.dwTitleID),          offsetof(sAliveParams_t, dwTitleID),          NULL},
        {7,  DBPARAMIO_INPUT,  DBTYPE_I4,  sizeof(sAliveParams.dwAltTitleID1),      offsetof(sAliveParams_t, dwAltTitleID1),      NULL},
        {8,  DBPARAMIO_INPUT,  DBTYPE_I4,  sizeof(sAliveParams.dwAltTitleID2),      offsetof(sAliveParams_t, dwAltTitleID2),      NULL},
        {9,  DBPARAMIO_INPUT,  DBTYPE_I4,  sizeof(sAliveParams.dwAltTitleID3),      offsetof(sAliveParams_t, dwAltTitleID3),      NULL},
        {10, DBPARAMIO_INPUT,  DBTYPE_I4,  sizeof(sAliveParams.dwAltTitleID4),      offsetof(sAliveParams_t, dwAltTitleID4),      NULL},
        {11, DBPARAMIO_INPUT,  DBTYPE_I4,  sizeof(sAliveParams.dwTitleRegion),      offsetof(sAliveParams_t, dwTitleRegion),      NULL},
        {12, DBPARAMIO_OUTPUT, DBTYPE_I1,  sizeof(sAliveParams.fNameChanged),       offsetof(sAliveParams_t, fNameChanged),       NULL},
        {13, DBPARAMIO_OUTPUT, DBTYPE_I1,  sizeof(sAliveParams.fNeedMessagingWrite),offsetof(sAliveParams_t, fNeedMessagingWrite),NULL},
        {14,  DBPARAMIO_INPUT, DBTYPE_I8,  sizeof(sAliveParams.qwXboxID),           offsetof(sAliveParams_t, qwXboxID),           NULL},
    };

    WSTCOMMANDINFO wstciAliveParams = {
        sizeof(sAliveParams),
        &sAliveParams,
        ARRAY_ELEMENTS(rgwstcpAliveParams),
        rgwstcpAliveParams
    };

    static WCHAR wszAliveCmd[] = L"{ ? = call p_pres_alive (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?) }";

    // Binding structures
    struct sVersions_t {
        DWORD dwBuddyListVersion;
        DWORD dwBlockListVersion;
        QWORD qwUserWebID;
        BYTE fSubscribedAlerts;
        BYTE rgbPrivileges[XONLINE_NUM_PRIVILEGE_BYTES];
        DWORD dwFirstLogon;
    } sVersions = {0, 0};

    struct sBuddyListEntry_t {
        QWORD qwUserID;
        QWORD qwUserWebID;
        BYTE bStatus;
        CHAR szAcctName[MAX_ACCTNAME_BYTES];
    } sBuddyListEntry;

    struct sBlockListEntry_t {
        QWORD qwUserID;
    } sBlockListEntry;

    struct sNeverListEntry_t {
        QWORD qwUserID;
    } sNeverListEntry;

    // Set the parameters
    sAliveParams.iRet = XPROFILE_NO_RESULT;
    sAliveParams.qwUserID = pCCtx->m_qwUserID;
    sAliveParams.qwXboxID = pCCtx->m_sgaddr.qwXboxID;
    sAliveParams.dwBuddyListVersion = 0;
    sAliveParams.dwBlockListVersion = pCCtx->m_dwClientBlockListVersion;
    sAliveParams.dwTitleID = pCCtx->m_dwTitleID;
    sAliveParams.dwAltTitleID1 = pCCtx->m_dwAltTitleID1;
    sAliveParams.dwAltTitleID2 = pCCtx->m_dwAltTitleID2;
    sAliveParams.dwAltTitleID3 = pCCtx->m_dwAltTitleID3;
    sAliveParams.dwAltTitleID4 = pCCtx->m_dwAltTitleID4;
    sAliveParams.dwTitleRegion = pCCtx->m_dwTitleRegion;
    sAliveParams.fNameChanged = FALSE;
    sAliveParams.fNeedMessagingWrite = FALSE;
    strncpy(sAliveParams.szAcctName, pCCtx->m_szAccountName, MAX_ACCTNAME_BYTES);
    sAliveParams.szAcctName[MAX_ACCTNAME_BYTES - 1] = '\0';

    // Execute the proc
    hr = m_piCommand->Execute(
        WRITETHENREAD_COMMANDTYPE,
        GetUserBucket(pCCtx->m_qwUserID),
        wszAliveCmd,
        &wstciAliveParams,
        (IUnknown **)&piResults,
        NULL,
        DBGUID_DEFAULT,
        IID_IMultipleResults);
    if (FAILED(hr))
    {
        // Run the error through the OLEBD wrapper to get details
        CResults.GetErrorHandler()->HandleError(hr, "SProcAlive Failed to execute stored proc");
        goto lDone;
    }

    // Check for a return
    if((sAliveParams.iRet != XPROFILE_NO_RESULT) && (FAILED((HRESULT)sAliveParams.iRet)))
    {
        hr = (DWORD) sAliveParams.iRet;
        goto lDone;
    }

    // Attach the wrapper
    hr = CResults.SetResults(piResults);
    piResults = NULL;
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Get the version stamps
    {
        static DBBINDING _bind[] = {
            WSBIND(1, offsetof(sVersions_t, dwBuddyListVersion), DBTYPE_I4, 0),
            WSBIND(2, offsetof(sVersions_t, dwBlockListVersion), DBTYPE_I4, 0),
            WSBIND(3, offsetof(sVersions_t, qwUserWebID), DBTYPE_I8, 0),
            WSBIND(4, offsetof(sVersions_t, fSubscribedAlerts), DBTYPE_I1, 0),
            WSBIND(5, offsetof(sVersions_t, rgbPrivileges), DBTYPE_BYTES, XONLINE_NUM_PRIVILEGE_BYTES),
            WSBIND(6, offsetof(sVersions_t, dwFirstLogon), DBTYPE_I4, 0)
        };

        hr = CResults.SetBindings(_bind, ARRAY_ELEMENTS(_bind));
        if(FAILED(hr))
        {
            goto lDone;
        }
    }

    cRows = 1;

    hr = CResults.GetRows(&cRows, &sVersions, sizeof(sVersions_t));
    if(FAILED(hr))
    {
        goto lDone;
    }

    hr = CResults.NextRowsetResult();
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Check for a return
    if((sAliveParams.iRet != XPROFILE_NO_RESULT) && (FAILED((HRESULT)sAliveParams.iRet)))
    {
        hr = (DWORD) sAliveParams.iRet;
        goto lDone;
    }

    // Get the buddy list if non-zero
    if (0 != sVersions.dwBuddyListVersion)
    {
        // Count first
        {
            static DBBINDING _bind[] = {
                WSBIND(1, 0, DBTYPE_I4, 0),
            };

            hr = CResults.SetBindings(_bind, ARRAY_ELEMENTS(_bind));
            if(FAILED(hr))
            {
                goto lDone;
            }
        }

        cRows = 1;

        hr = CResults.GetRows(&cRows, &cBuddies, sizeof(DWORD));
        if(FAILED(hr))
        {
            goto lDone;
        }

        hr = CResults.NextRowsetResult();
        if (FAILED(hr))
        {
            goto lDone;
        }

        // Check for a return
        if((sAliveParams.iRet != XPROFILE_NO_RESULT) && (FAILED((HRESULT)sAliveParams.iRet)))
        {
            hr = (DWORD) sAliveParams.iRet;
            goto lDone;
        }

        if (cBuddies > MAX_BUDDIES)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_256, "p_pres_alive returned too many friends (t_users.i_friend_list_len=%d) for user %I64X.",
                cBuddies,
                pCCtx->m_qwUserID);

            cBuddies = MAX_BUDDIES;
        }

        if (cBuddies != 0)
        {

            // Use the count to allocate memory
            rgCBuddyList = new CBuddyListEntry[cBuddies];
            if (rgCBuddyList == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto lDone;
            }

            // Allocate a reply block if it's being sent
            if (pCCtx->m_dwClientBuddyListVersion != sVersions.dwBuddyListVersion)
            {
                pCReplyBuddies = CTCPCntVarBuffer::CreateInstance((sizeof(P_REPLY_BUDDY) + MAX_ACCTNAME_BYTES) * cBuddies);
                if (pCReplyBuddies == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    goto lDone;
                }

                pbWrite = pCReplyBuddies->GetBuffer();
            }
            else
            {
                pbWrite = NULL;
            }

            // Bind
            {
                static DBBINDING _bind[] = {
                    WSBIND(1, offsetof(sBuddyListEntry_t, qwUserID), DBTYPE_I8, 0),
                    WSBIND(2, offsetof(sBuddyListEntry_t, szAcctName), DBTYPE_STR, MAX_ACCTNAME_BYTES),
                    WSBIND(3, offsetof(sBuddyListEntry_t, bStatus), DBTYPE_I1, 0)
                };

                hr = CResults.SetBindings(_bind, ARRAY_ELEMENTS(_bind));
                if(FAILED(hr))
                {
                    goto lDone;
                }
            }

            // Get the rows
            dwIndex = 0;
            for(;;)
            {
                cRows = 1;

                hr = CResults.GetRows(&cRows, &sBuddyListEntry, sizeof(sBuddyListEntry_t));
                if(FAILED(hr))
                {
                    goto lDone;
                }

                if (cRows > 0)
                {
                    if (dwIndex >= cBuddies)
                    {
                        // Unexpected number of rows
                        XomNtEvent(XEVENT_PRESENCE_CODE_257, "p_pres_alive returned too many friends entries (count (t_xprof_friend_lists)>=%d) for user %I64X.",
                            dwIndex,
                            pCCtx->m_qwUserID);

                        break;
                    }

                    cbAcctName = strlen(sBuddyListEntry.szAcctName) + 1;
                    if (cbAcctName > MAX_ACCTNAME_BYTES)
                    {
                        hr = E_FAIL;
                        goto lDone;
                    }

                    rgCBuddyList[dwIndex].Initialize();
                    rgCBuddyList[dwIndex].SetStatus(sBuddyListEntry.bStatus);
                    rgCBuddyList[dwIndex].SetBuddyID(sBuddyListEntry.qwUserID);
                    rgCBuddyList[dwIndex].SetSubscribed(FALSE);

                    if (pbWrite != NULL)
                    {
                        pReplyBuddiesWork = (P_REPLY_BUDDY *)pbWrite;

                        pReplyBuddiesWork->bStatus = sBuddyListEntry.bStatus;
                        pReplyBuddiesWork->qwBuddyID = sBuddyListEntry.qwUserID;
                        pReplyBuddiesWork->cbAcctName = (WORD) cbAcctName;
                        memcpy(pbWrite + sizeof(P_REPLY_BUDDY), sBuddyListEntry.szAcctName, cbAcctName);

                        cbReplyBuddies += sizeof(P_REPLY_BUDDY) + cbAcctName;
                        pbWrite += sizeof(P_REPLY_BUDDY) + cbAcctName;
                    }

                    dwIndex++;
                }
                else
                {
                    // No rows left to process
                    break;
                }
            }

            if (dwIndex != cBuddies)
            {
                // Unexpected number of rows
                hr = E_FAIL;
                goto lDone;
            }

            // Resize down the buffer
            if (pCReplyBuddies != NULL)
            {
                pCReplyBuddies = pCReplyBuddies->Resize(cbReplyBuddies);
            }
        }

        hr = CResults.NextRowsetResult();
        if (FAILED(hr))
        {
            goto lDone;
        }
    }
    else
    {
        cBuddies = 0;
        rgCBuddyList = NULL;

        pCReplyBuddies = NULL;
        cbReplyBuddies = 0;
    }

    // Check for a return
    if((sAliveParams.iRet != XPROFILE_NO_RESULT) && (FAILED((HRESULT)sAliveParams.iRet)))
    {
        hr = (DWORD) sAliveParams.iRet;
        goto lDone;
    }

    // Get the block list if more recent
    if (pCCtx->m_dwClientBlockListVersion != sVersions.dwBlockListVersion)
    {
        // Count first
        {
            static DBBINDING _bind[] = {
                WSBIND(1, 0, DBTYPE_I4, 0)
            };

            hr = CResults.SetBindings(_bind, ARRAY_ELEMENTS(_bind));
            if(FAILED(hr))
            {
                goto lDone;
            }
        }

        cRows = 1;

        hr = CResults.GetRows(&cRows, &cBlocks, sizeof(DWORD));
        if(FAILED(hr))
        {
            goto lDone;
        }

        hr = CResults.NextRowsetResult();
        if (FAILED(hr))
        {
            goto lDone;
        }

        // Check for a return
        if((sAliveParams.iRet != XPROFILE_NO_RESULT) && (FAILED((HRESULT)sAliveParams.iRet)))
        {
            hr = (DWORD) sAliveParams.iRet;
            goto lDone;
        }

        if (cBlocks > MAX_BLOCKS)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_258, "p_pres_alive returned too many mutes (t_users.i_lockout_list_len=%d) for user %I64X.",
                cBlocks,
                pCCtx->m_qwUserID);

            cBlocks = MAX_BLOCKS;
        }

        if (cBlocks != 0)
        {
            // Allocate a reply block
            pCReplyBlocks = CTCPCntVarBuffer::CreateInstance((sizeof(P_REPLY_BLOCK) + MAX_ACCTNAME_BYTES) * cBlocks);
            if (pCReplyBlocks == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto lDone;
            }

            // Bind
            {
                static DBBINDING _bind[] = {
                    WSBIND(1, offsetof(sBlockListEntry_t, qwUserID), DBTYPE_I8, 0)
                };

                hr = CResults.SetBindings(_bind, ARRAY_ELEMENTS(_bind));
                if(FAILED(hr))
                {
                    goto lDone;
                }
            }

            // Get the rows
            dwIndex = 0;
            pbWrite = pCReplyBlocks->GetBuffer();
            for(;;)
            {
                cRows = 1;

                hr = CResults.GetRows(&cRows, &sBlockListEntry, sizeof(sBlockListEntry_t));
                if(FAILED(hr))
                {
                    goto lDone;
                }

                if (cRows > 0)
                {
                    if (dwIndex >= cBlocks)
                    {
                        // Unexpected number of rows
                        XomNtEvent(XEVENT_PRESENCE_CODE_259, "p_pres_alive returned too many mute entries (count (t_xprof_lockout_lists)>=%d) for user %I64X.",
                            dwIndex,
                            pCCtx->m_qwUserID);

                        break;
                    }

                    pReplyBlocksWork = (P_REPLY_BLOCK *)pbWrite;
                    pReplyBlocksWork->qwBlockID = sBlockListEntry.qwUserID;

                    cbReplyBlocks += sizeof(P_REPLY_BLOCK);
                    pbWrite += sizeof(P_REPLY_BLOCK);

                    dwIndex++;
                }
                else
                {
                    // No rows left to process
                    break;
                }
            }

            if (dwIndex != cBlocks)
            {
                // Unexpected number of rows
                hr = E_FAIL;
                goto lDone;
            }

            // Resize down the buffer
            pCReplyBlocks = pCReplyBlocks->Resize(cbReplyBlocks);
        }

        hr = CResults.NextRowsetResult();
        if (FAILED(hr))
        {
            goto lDone;
        }
    }
    else
    {
        cBlocks = 0;

        pCReplyBlocks = NULL;
        cbReplyBlocks = 0;
    }

    // Check for a return
    if((sAliveParams.iRet != XPROFILE_NO_RESULT) && (FAILED((HRESULT)sAliveParams.iRet)))
    {
        hr = (DWORD) sAliveParams.iRet;
        goto lDone;
    }

    // Count first
    {
        static DBBINDING _bind[] = {
            WSBIND(1, 0, DBTYPE_I2, 0)
        };

        hr = CResults.SetBindings(_bind, ARRAY_ELEMENTS(_bind));
        if(FAILED(hr))
        {
            goto lDone;
        }
    }

    cRows = 1;

    hr = CResults.GetRows(&cRows, &cNeverList, sizeof(DWORD));
    if(FAILED(hr))
    {
        goto lDone;
    }

    hr = CResults.NextRowsetResult();
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Check for a return
    if((sAliveParams.iRet != XPROFILE_NO_RESULT) && (FAILED((HRESULT)sAliveParams.iRet)))
    {
        hr = (DWORD) sAliveParams.iRet;
        goto lDone;
    }

    if (cNeverList != 0)
    {
        // Allocate a place to hold the list
        pqwNeverList = new ULONGLONG[ cNeverList ];
        if (pqwNeverList == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto lDone;
        }

        // Bind
        {
            static DBBINDING _bind[] = {
                WSBIND(1, offsetof(sNeverListEntry_t, qwUserID), DBTYPE_I8, 0)
            };

            hr = CResults.SetBindings(_bind, ARRAY_ELEMENTS(_bind));
            if(FAILED(hr))
            {
                goto lDone;
            }
        }

        // Get the rows
        dwIndex = 0;
        for(;;)
        {
            cRows = 1;

            hr = CResults.GetRows(&cRows, &sNeverListEntry, sizeof(sNeverListEntry_t));
            if(FAILED(hr))
            {
                goto lDone;
            }

            if (cRows > 0)
            {
                if (dwIndex >= cNeverList)
                {
                    // Unexpected number of rows
                    hr = E_FAIL;
                    goto lDone;
                }

                pqwNeverList[ dwIndex ] = sNeverListEntry.qwUserID;

                dwIndex++;
            }
            else
            {
                // No rows left to process
                break;
            }
        }

        hr = CResults.NextRowsetResult();
        if (FAILED(hr))
        {
            goto lDone;
        }

        // Check for a return
        if((sAliveParams.iRet != XPROFILE_NO_RESULT) && (FAILED((HRESULT)sAliveParams.iRet)))
        {
            hr = (DWORD) sAliveParams.iRet;
            goto lDone;
        }
    }

    hr = CResults.CleanUpResult();
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Final check for a return
    if (sAliveParams.iRet == XPROFILE_NO_RESULT)
    {
        hr = E_FAIL;
    }
    else
    {
        hr = (DWORD) sAliveParams.iRet;
    }

lDone:

    pCCtx->m_eState = CAliveContext::AliveState_StoreComplete;
    pCCtx->m_hrStore = hr;
    *pfNameChanged = sAliveParams.fNameChanged;
    *pfNeedMessagingWrite = sAliveParams.fNeedMessagingWrite;

    if (FAILED(hr))
    {
        // Failed cleanup allocations

        if (rgCBuddyList != NULL)
        {
            delete[] rgCBuddyList;
        }

        if( NULL != pqwNeverList )
        {
            delete[] pqwNeverList;
        }

        SAFE_RELEASE(pCReplyBuddies);

        SAFE_RELEASE(pCReplyBlocks);

        // Set the output parameters for failure
        pCCtx->m_dwBuddyListVersion = 0;
        pCCtx->m_cBuddies = 0;
        pCCtx->m_rgCBuddyList = NULL;

        pCCtx->m_dwBlockListVersion = 0;
        pCCtx->m_cBlocks = 0;

        pCCtx->m_pCReplyBuddies = NULL;
        pCCtx->m_pCReplyBlocks = NULL;

        pCCtx->m_pqwNeverList = NULL;
        pCCtx->m_cNeverList = 0;

        pCCtx->m_qwUserWebID = 0;
        memset(pCCtx->m_rgbPrivileges, 0, sizeof(pCCtx->m_rgbPrivileges));
    }
    else
    {
        // Success, set the output parameters
        pCCtx->m_dwBuddyListVersion = sVersions.dwBuddyListVersion;
        pCCtx->m_cBuddies = cBuddies;
        pCCtx->m_rgCBuddyList = rgCBuddyList;

        pCCtx->m_dwBlockListVersion = sVersions.dwBlockListVersion;
        pCCtx->m_cBlocks = cBlocks;

        pCCtx->m_pCReplyBuddies = pCReplyBuddies;
        pCCtx->m_pCReplyBlocks = pCReplyBlocks;

        pCCtx->m_pqwNeverList = pqwNeverList;
        pCCtx->m_cNeverList = cNeverList;

        pCCtx->m_qwUserWebID = sVersions.qwUserWebID;
        pCCtx->m_dwFirstLogon = sVersions.dwFirstLogon;

        memcpy(pCCtx->m_rgbPrivileges, sVersions.rgbPrivileges, sizeof(pCCtx->m_rgbPrivileges));
    }
}

/*****************************************************************************

CProfileStore::SProcMessagingUserInit

Call the Messaging user init stored procedure.

*****************************************************************************/
HRESULT CProfileStore::SProcMessagingUserInit(CAliveContext *pCCtx)
{
    XOMASSERT(m_pCSwitchboard != NULL);
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Going to SQL for SProcMessagingUserInit");

    HRESULT hr = S_OK;
    CComPtr<IRowset> piRowset = NULL;
    CWSODBWResult CResults(ErrorCallback);

    // Parameter structures
    struct sParams_t
    {
        INT iRet;
        QWORD qwUserID;
        DWORD dwTitleID;
        DWORD dwAltTitleID1;
        DWORD dwAltTitleID2;
        DWORD dwAltTitleID3;
        DWORD dwAltTitleID4;
        DWORD dwTitleRegion;
        QWORD qwXboxID;
    } sParams;

    static WSTCOMMANDPARAM rgwstcpParams[] =
    {
        {1,  DBPARAMIO_OUTPUT, DBTYPE_I4,  sizeof(sParams.iRet),               offsetof(sParams_t, iRet),               NULL},
        {2,  DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwUserID),           offsetof(sParams_t, qwUserID),           NULL},
        {3,  DBPARAMIO_INPUT,  DBTYPE_I4,  sizeof(sParams.dwTitleID),          offsetof(sParams_t, dwTitleID),          NULL},
        {4,  DBPARAMIO_INPUT,  DBTYPE_I4,  sizeof(sParams.dwAltTitleID1),      offsetof(sParams_t, dwAltTitleID1),      NULL},
        {5,  DBPARAMIO_INPUT,  DBTYPE_I4,  sizeof(sParams.dwAltTitleID2),      offsetof(sParams_t, dwAltTitleID2),      NULL},
        {6,  DBPARAMIO_INPUT,  DBTYPE_I4,  sizeof(sParams.dwAltTitleID3),      offsetof(sParams_t, dwAltTitleID3),      NULL},
        {7,  DBPARAMIO_INPUT,  DBTYPE_I4,  sizeof(sParams.dwAltTitleID4),      offsetof(sParams_t, dwAltTitleID4),      NULL},
        {8,  DBPARAMIO_INPUT,  DBTYPE_I4,  sizeof(sParams.dwTitleRegion),      offsetof(sParams_t, dwTitleRegion),      NULL},
        {9,  DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwXboxID),           offsetof(sParams_t, qwXboxID),           NULL},
    };

    WSTCOMMANDINFO wstciParams =
    {
        sizeof(sParams),
        &sParams,
        ARRAY_ELEMENTS(rgwstcpParams),
        rgwstcpParams
    };

    static WCHAR wszCmd[] = L"{ ? = call p_xmsg_user_init (?, ?, ?, ?, ?, ?, ?, ?) }";

    // Set the parameters
    sParams.iRet = XPROFILE_NO_RESULT;
    sParams.qwUserID = pCCtx->m_qwUserID;
    sParams.dwTitleID = pCCtx->m_dwTitleID;
    sParams.dwAltTitleID1 = pCCtx->m_dwAltTitleID1;
    sParams.dwAltTitleID2 = pCCtx->m_dwAltTitleID2;
    sParams.dwAltTitleID3 = pCCtx->m_dwAltTitleID3;
    sParams.dwAltTitleID4 = pCCtx->m_dwAltTitleID4;
    sParams.dwTitleRegion = pCCtx->m_dwTitleRegion;
    sParams.qwXboxID      = pCCtx->m_sgaddr.qwXboxID;

    // Execute the proc
    hr = m_piCommand->Execute(
        WRITEONLY_COMMANDTYPE,
        GetUserBucket(pCCtx->m_qwUserID),
        wszCmd,
        &wstciParams,
        (IUnknown **)&piRowset,
        NULL,
        DBGUID_DEFAULT,
        IID_IRowset);
    if( FAILED( hr ) )
    {
        // Run the error through the OLEBD wrapper to get details
        CResults.GetErrorHandler()->HandleError(hr, "SProcMessagingUserInit Failed to execute stored proc");
        goto lDone;
    }

    // OLE DB won't populate our return value until we release the results
    piRowset = NULL;

    // Check for a return
    if( XPROFILE_NO_RESULT != sParams.iRet )
    {
        hr = (HRESULT) sParams.iRet;
        goto lDone;
    }

lDone:
    return hr;
}

/*****************************************************************************

CProfileStore::StoreSync

Load the given user's profile from the store.  This includes their buddy and
blocked lists.  The result is sent back via the switchboard's completion port
to a callback function.

*****************************************************************************/
HRESULT CProfileStore::StoreSync(CSyncContext *pCCtx)
{
    XOMASSERT(m_pCSwitchboard != NULL);
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Going to SQL for StoreSync");

    HRESULT hr = S_OK;
    CComPtr<IMultipleResults> piResults = NULL;
    CWSODBWResult CResults(ErrorCallback);
    DWORD dwIndex;
    BYTE *pbWrite;
    DWORD cRows;
    DWORD cBuddies = 0;
    DWORD cBlocks = 0;
    DWORD cbAcctName = 0;

    CBuddyListEntry *rgCBuddyList = NULL;

    CTCPCntVarBuffer *pCReplyBuddies = NULL;
    P_REPLY_BUDDY *pReplyBuddiesWork = NULL;
    DWORD cbReplyBuddies = 0;

    CTCPCntVarBuffer *pCReplyBlocks = NULL;
    P_REPLY_BLOCK *pReplyBlocksWork = NULL;
    DWORD cbReplyBlocks = 0;

    // Parameter structures
    struct sSyncParams_t {
        INT iRet;
        QWORD qwUserID;
        DWORD dwBuddyListVersion;
        DWORD dwBlockListVersion;
    } sSyncParams;

    static WSTCOMMANDPARAM rgwstcpSyncParams[] = {
        {1, DBPARAMIO_OUTPUT, DBTYPE_I4,  sizeof(sSyncParams.iRet), offsetof(sSyncParams_t, iRet), NULL},
        {2, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sSyncParams.qwUserID), offsetof(sSyncParams_t, qwUserID), NULL},
        {3, DBPARAMIO_INPUT,  DBTYPE_I4,  sizeof(sSyncParams.dwBuddyListVersion), offsetof(sSyncParams_t, dwBuddyListVersion), NULL},
        {4, DBPARAMIO_INPUT,  DBTYPE_I4,  sizeof(sSyncParams.dwBlockListVersion), offsetof(sSyncParams_t, dwBlockListVersion), NULL}
    };

    WSTCOMMANDINFO wstciSyncParams = {
        sizeof(sSyncParams),
        &sSyncParams,
        ARRAY_ELEMENTS(rgwstcpSyncParams),
        rgwstcpSyncParams
    };

    static WCHAR wszSyncCmd[] = L"{ ? = call p_pres_sync (?, ?, ?) }";

    // Binding structures
    struct sVersions_t {
        DWORD dwBuddyListVersion;
        DWORD dwBlockListVersion;
    } sVersions = {0, 0};

    struct sBuddyListEntry_t {
        QWORD qwUserID;
        BYTE bStatus;
        CHAR szAcctName[MAX_ACCTNAME_BYTES];
    } sBuddyListEntry;

    struct sBlockListEntry_t {
        QWORD qwUserID;
    } sBlockListEntry;

    // Set the parameters
    sSyncParams.iRet = XPROFILE_NO_RESULT;
    sSyncParams.qwUserID = pCCtx->m_qwUserID;
    sSyncParams.dwBuddyListVersion = 0;
    sSyncParams.dwBlockListVersion = pCCtx->m_dwClientBlockListVersion;

    // Execute the proc
    hr = m_piCommand->Execute(
        WRITETHENREAD_COMMANDTYPE,
        GetUserBucket(pCCtx->m_qwUserID),
        wszSyncCmd,
        &wstciSyncParams,
        (IUnknown **)&piResults,
        NULL,
        DBGUID_DEFAULT,
        IID_IMultipleResults);
    if (FAILED(hr))
    {
        // Run the error through the OLEBD wrapper to get details
        CResults.GetErrorHandler()->HandleError(hr, "StoreSync Failed to execute stored proc");
        goto lDone;
    }

    // Check for a return
    if((sSyncParams.iRet != XPROFILE_NO_RESULT) && (FAILED((HRESULT)sSyncParams.iRet)))
    {
        hr = (DWORD) sSyncParams.iRet;
        goto lDone;
    }

    // Attach the wrapper
    hr = CResults.SetResults(piResults);
    piResults = NULL;
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Get the version stamps
    {
        static DBBINDING _bind[] = {
            WSBIND(1, offsetof(sVersions_t, dwBuddyListVersion), DBTYPE_I4, 0),
            WSBIND(2, offsetof(sVersions_t, dwBlockListVersion), DBTYPE_I4, 0)
        };

        hr = CResults.SetBindings(_bind, ARRAY_ELEMENTS(_bind));
        if(FAILED(hr))
        {
            goto lDone;
        }
    }

    cRows = 1;

    hr = CResults.GetRows(&cRows, &sVersions, sizeof(sVersions_t));
    if(FAILED(hr))
    {
        goto lDone;
    }

    hr = CResults.NextRowsetResult();
    if(FAILED(hr))
    {
        goto lDone;
    }

    // Check for a return
    if((sSyncParams.iRet != XPROFILE_NO_RESULT) && (FAILED((HRESULT)sSyncParams.iRet)))
    {
        hr = (DWORD) sSyncParams.iRet;
        goto lDone;
    }

    // Get the buddy list if more recent
    if (pCCtx->m_dwClientBuddyListVersion != sVersions.dwBuddyListVersion)
    {
        // Count first
        {
            static DBBINDING _bind[] = {
                WSBIND(1, 0, DBTYPE_I4, 0),
            };

            hr = CResults.SetBindings(_bind, ARRAY_ELEMENTS(_bind));
            if(FAILED(hr))
            {
                goto lDone;
            }
        }

        cRows = 1;

        hr = CResults.GetRows(&cRows, &cBuddies, sizeof(DWORD));
        if(FAILED(hr))
        {
            goto lDone;
        }

        hr = CResults.NextRowsetResult();
        if(FAILED(hr))
        {
            goto lDone;
        }

        // Check for a return
        if((sSyncParams.iRet != XPROFILE_NO_RESULT) && (FAILED((HRESULT)sSyncParams.iRet)))
        {
            hr = (DWORD) sSyncParams.iRet;
            goto lDone;
        }

        if (cBuddies > MAX_BUDDIES)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_260, "p_pres_sync returned too many friends (t_users.i_friend_list_len=%d) for user %I64X.",
                cBuddies,
                pCCtx->m_qwUserID);

            cBuddies = MAX_BUDDIES;
        }

        if (cBuddies != 0)
        {
            // Use the count to allocate memory
            rgCBuddyList = new CBuddyListEntry[cBuddies];
            if (rgCBuddyList == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto lDone;
            }

            pCReplyBuddies = CTCPCntVarBuffer::CreateInstance((sizeof(P_REPLY_BUDDY) + MAX_ACCTNAME_BYTES) * cBuddies);
            if (pCReplyBuddies == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto lDone;
            }

            // Bind
            {
                static DBBINDING _bind[] = {
                    WSBIND(1, offsetof(sBuddyListEntry_t, qwUserID), DBTYPE_I8, 0),
                    WSBIND(2, offsetof(sBuddyListEntry_t, szAcctName), DBTYPE_STR, MAX_ACCTNAME_BYTES),
                    WSBIND(3, offsetof(sBuddyListEntry_t, bStatus), DBTYPE_I1, 0)
                };

                hr = CResults.SetBindings(_bind, ARRAY_ELEMENTS(_bind));
                if(FAILED(hr))
                {
                    goto lDone;
                }
            }

            // Get the rows
            dwIndex = 0;
            pbWrite = pCReplyBuddies->GetBuffer();
            for(;;)
            {
                cRows = 1;

                hr = CResults.GetRows(&cRows, &sBuddyListEntry, sizeof(sBuddyListEntry_t));
                if(FAILED(hr))
                {
                    goto lDone;
                }

                if (cRows > 0)
                {
                    if (dwIndex >= cBuddies)
                    {
                        // Unexpected number of rows
                        XomNtEvent(XEVENT_PRESENCE_CODE_261, "p_pres_sync returned too many friends entries (count (t_xprof_friend_lists)>=%d) for user %I64X.",
                            dwIndex,
                            pCCtx->m_qwUserID);

                        break;
                    }

                    cbAcctName = strlen(sBuddyListEntry.szAcctName) + 1;
                    if (cbAcctName > MAX_ACCTNAME_BYTES)
                    {
                        hr = E_FAIL;
                        goto lDone;
                    }

                    rgCBuddyList[dwIndex].Initialize();
                    rgCBuddyList[dwIndex].SetStatus(sBuddyListEntry.bStatus);
                    rgCBuddyList[dwIndex].SetBuddyID(sBuddyListEntry.qwUserID);
                    rgCBuddyList[dwIndex].SetSubscribed(FALSE);

                    pReplyBuddiesWork = (P_REPLY_BUDDY *)pbWrite;

                    pReplyBuddiesWork->bStatus = sBuddyListEntry.bStatus;
                    pReplyBuddiesWork->qwBuddyID = sBuddyListEntry.qwUserID;
                    pReplyBuddiesWork->cbAcctName = (WORD) cbAcctName;
                    memcpy(pbWrite + sizeof(P_REPLY_BUDDY), sBuddyListEntry.szAcctName, cbAcctName);

                    cbReplyBuddies += sizeof(P_REPLY_BUDDY) + cbAcctName;
                    pbWrite += sizeof(P_REPLY_BUDDY) + cbAcctName;
                    dwIndex++;
                }
                else
                {
                    // No rows left to process
                    break;
                }
            }

            // Resize down the buffer
            pCReplyBuddies = pCReplyBuddies->Resize(cbReplyBuddies);
        }

        hr = CResults.NextRowsetResult();
        if(FAILED(hr))
        {
            goto lDone;
        }
    }
    else
    {
        cBuddies = 0;
        rgCBuddyList = NULL;

        pCReplyBuddies = NULL;
        cbReplyBuddies = 0;
    }

    // Check for a return
    if((sSyncParams.iRet != XPROFILE_NO_RESULT) && (FAILED((HRESULT)sSyncParams.iRet)))
    {
        hr = (DWORD) sSyncParams.iRet;
        goto lDone;
    }

    // Get the block list if more recent
    if (pCCtx->m_dwClientBlockListVersion != sVersions.dwBlockListVersion)
    {
        // Count first
        {
            static DBBINDING _bind[] = {
                WSBIND(1, 0, DBTYPE_I4, 0),
            };

            hr = CResults.SetBindings(_bind, ARRAY_ELEMENTS(_bind));
            if(FAILED(hr))
            {
                goto lDone;
            }
        }

        cRows = 1;

        hr = CResults.GetRows(&cRows, &cBlocks, sizeof(DWORD));
        if(FAILED(hr))
        {
            goto lDone;
        }

        hr = CResults.NextRowsetResult();
        if(FAILED(hr))
        {
            goto lDone;
        }

        // Check for a return
        if((sSyncParams.iRet != XPROFILE_NO_RESULT) && (FAILED((HRESULT)sSyncParams.iRet)))
        {
            hr = (DWORD) sSyncParams.iRet;
            goto lDone;
        }

        if (cBlocks > MAX_BLOCKS)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_262, "p_pres_sync returned too many mutes (t_users.i_lockout_list_len=%d) for user %I64X.",
                cBlocks,
                pCCtx->m_qwUserID);

            cBlocks = MAX_BLOCKS;
        }

        if (cBlocks != 0)
        {
            // Use the count to allocate memory
            pCReplyBlocks = CTCPCntVarBuffer::CreateInstance((sizeof(P_REPLY_BLOCK) + MAX_ACCTNAME_BYTES) * cBlocks);
            if (pCReplyBlocks == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto lDone;
            }

            // Bind
            {
                static DBBINDING _bind[] = {
                    WSBIND(1, offsetof(sBlockListEntry_t, qwUserID), DBTYPE_I8, 0)
                };

                hr = CResults.SetBindings(_bind, ARRAY_ELEMENTS(_bind));
                if(FAILED(hr))
                {
                    goto lDone;
                }
            }

            // Get the rows
            dwIndex = 0;
            pbWrite = pCReplyBlocks->GetBuffer();
            for(;;)
            {
                cRows = 1;

                hr = CResults.GetRows(&cRows, &sBlockListEntry, sizeof(sBlockListEntry_t));
                if(FAILED(hr))
                {
                    goto lDone;
                }

                if (cRows > 0)
                {
                    if (dwIndex >= cBlocks)
                    {
                        // Unexpected number of rows
                        XomNtEvent(XEVENT_PRESENCE_CODE_263, "p_pres_sync returned too many mute entries (count (t_xprof_lockout_lists)>=%d) for user %I64X.",
                            dwIndex,
                            pCCtx->m_qwUserID);

                        break;
                    }

                    pReplyBlocksWork = (P_REPLY_BLOCK *)pbWrite;
                    pReplyBlocksWork->qwBlockID = sBlockListEntry.qwUserID;

                    cbReplyBlocks += sizeof(P_REPLY_BLOCK);
                    pbWrite += sizeof(P_REPLY_BLOCK);

                    dwIndex++;
                }
                else
                {
                    // No rows left to process
                    break;
                }
            }

            // Resize down the buffer
            pCReplyBlocks = pCReplyBlocks->Resize(cbReplyBlocks);
        }
    }
    else
    {
        cBlocks = 0;

        pCReplyBlocks = NULL;
        cbReplyBlocks = 0;
    }

    hr = CResults.CleanUpResult();
    if(FAILED(hr))
    {
        goto lDone;
    }

    // Final check for a return
    if (sSyncParams.iRet == XPROFILE_NO_RESULT)
    {
        hr = E_FAIL;
    }
    else
    {
        hr = (DWORD) sSyncParams.iRet;
    }

lDone:

    pCCtx->m_fProcessed = TRUE;
    pCCtx->m_hr = hr;

    if (FAILED(hr))
    {
        // Failed cleanup allocations

        if (rgCBuddyList != NULL)
        {
            delete[] rgCBuddyList;
        }

        SAFE_RELEASE(pCReplyBuddies);

        SAFE_RELEASE(pCReplyBlocks);

        // Set the output parameters for failure
        pCCtx->m_dwBuddyListVersion = 0;
        pCCtx->m_cBuddies = 0;
        pCCtx->m_rgCBuddyList = NULL;

        pCCtx->m_dwBlockListVersion = 0;
        pCCtx->m_cBlocks = 0;

        pCCtx->m_pCReplyBuddies = NULL;
        pCCtx->m_pCReplyBlocks = NULL;

        // Report the hr and if it came from the stored proc
        if(sSyncParams.iRet != XPROFILE_NO_RESULT)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_264, "p_pres_sync returned failure hr=%X", hr );
        }
        else
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_265, "StoreSync failed hr=%X", hr );
        }
    }
    else
    {
        // Success, set the output parameters
        pCCtx->m_dwBuddyListVersion = sVersions.dwBuddyListVersion;
        pCCtx->m_cBuddies = cBuddies;
        pCCtx->m_rgCBuddyList = rgCBuddyList;

        pCCtx->m_dwBlockListVersion = sVersions.dwBlockListVersion;
        pCCtx->m_cBlocks = cBlocks;

        pCCtx->m_pCReplyBuddies = pCReplyBuddies;
        pCCtx->m_pCReplyBlocks = pCReplyBlocks;
    }

    hr = m_pCSwitchboard->PostCompletion(pCCtx);
    XOMASSERT(SUCCEEDED(hr));

    // Operation HRESULT returned via the context object
    return S_OK;
}

/*****************************************************************************

CProfileStore::StoreAddBuddy

Add a user to the given user's buddy list.  The result is sent back via the
switchboard's completion port to a callback function.

*****************************************************************************/
HRESULT CProfileStore::StoreAddBuddy(CAddBuddyContext *pCCtx)
{
    XOMASSERT(m_pCSwitchboard != NULL);
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Going to SQL for StoreAddBuddy");

    HRESULT hr = S_OK;
    CComPtr<IWSTDTC> piDTC = NULL;

    // CONSIDER: Reduce worst case number of DB round trips
    if (pCCtx->m_qwBuddyID == 0)
    {
        // Translate the account name to a user id if required
        hr = SProcGetUserIDByName(
            pCCtx->m_szBuddyAccountName,
            &(pCCtx->m_qwBuddyID));
        if (FAILED(hr))
        {
            goto lDone;
        }
    }

    if (pCCtx->m_cbUserAccountName == 0)
    {
        hr = SProcGetAccountNameByID(
            pCCtx->m_qwUserID,
            pCCtx->m_szUserAccountName,
            &(pCCtx->m_cbUserAccountName));
        if (FAILED(hr))
        {
            goto lDone;
        }
    }

    // Check to see if I'm adding myself
    if (pCCtx->m_qwUserID == pCCtx->m_qwBuddyID)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_211,
            "StoreAdd UserID equals BuddyID (%I64X)",
            pCCtx->m_qwUserID);

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Transact both list updates to make sure the lists are in sync
    hr = m_piCommand->GetDTC(&piDTC);
    if (FAILED(hr))
    {
        goto lDone;
    }

    hr = piDTC->BeginTransaction(ISOLATIONLEVEL_READCOMMITTED);
    if (FAILED(hr))
    {
        piDTC = NULL;
        goto lDone;
    }

    // Lower Id first
    if (pCCtx->m_qwUserID < pCCtx->m_qwBuddyID)
    {
        // Translate the user id into an account name if needed
        if (pCCtx->m_cbBuddyAccountName == 0)
        {
            hr = SProcGetAccountNameByID(
                pCCtx->m_qwBuddyID,
                pCCtx->m_szBuddyAccountName,
                &(pCCtx->m_cbBuddyAccountName));
            if (FAILED(hr))
            {
                goto lDone;
            }
        }

        // Try to add the buddy to the adder
        hr = SProcAddBuddy(
            pCCtx->m_qwUserID,
            pCCtx->m_qwBuddyID,
            pCCtx->m_szBuddyAccountName,
            &(pCCtx->m_dwUserBuddyListVersion),
            piDTC);
        if (FAILED(hr))
        {
            goto lDone;
        }

        // Try to add the buddy to the addie
        hr = SProcAddedBuddy(
            pCCtx->m_qwBuddyID,
            pCCtx->m_qwUserID,
            pCCtx->m_szUserAccountName,
            &(pCCtx->m_dwBuddyBuddyListVersion),
            pCCtx->m_szBuddyAccountName,
            &(pCCtx->m_cbBuddyAccountName),
            piDTC);
        if (FAILED(hr))
        {
            goto lDone;
        }
    }
    else
    {
        // Try to add the buddy to the addie
        hr = SProcAddedBuddy(
            pCCtx->m_qwBuddyID,
            pCCtx->m_qwUserID,
            pCCtx->m_szUserAccountName,
            &(pCCtx->m_dwBuddyBuddyListVersion),
            pCCtx->m_szBuddyAccountName,
            &(pCCtx->m_cbBuddyAccountName),
            piDTC);
        if (FAILED(hr))
        {
            goto lDone;
        }

        // Try to add the buddy to the adder
        hr = SProcAddBuddy(
            pCCtx->m_qwUserID,
            pCCtx->m_qwBuddyID,
            pCCtx->m_szBuddyAccountName,
            &(pCCtx->m_dwUserBuddyListVersion),
            piDTC);
        if (FAILED(hr))
        {
            goto lDone;
        }
    }

    // If there are no failures commit and release the transaction
    hr = piDTC->CommitTransaction();
    if (FAILED(hr))
    {
        goto lDone;
    }
    piDTC = NULL;

lDone:

    // If piDTC is not NULL assume failure and rollback
    if (piDTC != NULL)
    {
        piDTC->AbortTransaction();
        piDTC = NULL;
    }

    if (FAILED(hr))
    {
        pCCtx->m_dwBuddyBuddyListVersion = 0;
        pCCtx->m_dwUserBuddyListVersion = 0;

        if ((hr == HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER)) || // mistyped name
            (hr == HRESULT_FROM_WIN32(ERROR_USER_EXISTS)) || // already a friend
            (hr == DB_E_INTEGRITYVIOLATION) || // dtc rollback
            (hr == XONLINE_E_NOTIFICATION_BLOCKED) || // never list
            (hr == XONLINE_E_NOTIFICATION_LIST_FULL) || // full list
            (hr == XONLINE_E_NOTIFICATION_OTHER_LIST_FULL)) // other list is full
        {
            // Expected error cases, just debug spew
            XomTrace(
                PresenceDebug,
                L_NORMAL,
                "StoreAddBuddy expected error hr=%X UserId=%I64X UserName=%s BuddyId=%I64X BuddyName=%s",
                hr,
                pCCtx->m_qwUserID,
                pCCtx->m_szUserAccountName,
                pCCtx->m_qwBuddyID,
                pCCtx->m_szBuddyAccountName);
        }
        else
        {
            XomNtEvent(
                XEVENT_PRESENCE_CODE_266,
                "StoreAddBuddy failed hr=%X UserId=%I64X UserName=%s BuddyId=%I64X BuddyName=%s",
                hr,
                pCCtx->m_qwUserID,
                pCCtx->m_szUserAccountName,
                pCCtx->m_qwBuddyID,
                pCCtx->m_szBuddyAccountName);
        }
    }

    pCCtx->m_fProcessed = TRUE;
    pCCtx->m_hr = hr;

    hr = m_pCSwitchboard->PostCompletion(pCCtx);
    XOMASSERT(SUCCEEDED(hr));

    // Operation HRESULT returned via the context object
    return S_OK;
}

/*****************************************************************************

CProfileStore::StoreAddAffiliates

Add users to the given user's affiliates list.  The result is sent back via the
switchboard's completion port to a callback function.

*****************************************************************************/
HRESULT CProfileStore::StoreAddAffiliates(CAddAffiliatesContext *pCCtx)
{
    XOMASSERT(m_pCSwitchboard != NULL);
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Going to SQL for StoreAddAffiliates");

    HRESULT hr = S_OK;

    for (DWORD dwList = 0; dwList < NUM_STORED_AFFILIATE_LISTS; dwList++)
    {
        hr = SProcLoadAffiliates(pCCtx->m_qwUserID, X_AFFILIATE_INDEX_TO_FLAG(dwList), pCCtx->m_prgAffiliateLists[dwList]);
        if (FAILED(hr))
        {
            goto lDone;
        }
    }

lDone:

    pCCtx->m_fProcessed = TRUE;
    pCCtx->m_hr = hr;

    hr = m_pCSwitchboard->PostCompletion(pCCtx);
    XOMASSERT(SUCCEEDED(hr));

    // Operation HRESULT returned via the context object
    return S_OK;
}

/*****************************************************************************

CProfileStore::StoreIsAffiliate

load the given user's affiliates list.  The result is sent back via the
switchboard's completion port to a callback function.

*****************************************************************************/
HRESULT CProfileStore::StoreIsAffiliate(CIsAffiliateContext *pCCtx)
{
    XOMASSERT(m_pCSwitchboard != NULL);
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Going to SQL for StoreIsAffiliate");

    HRESULT hr = S_OK;

    for (DWORD dwList = 0; dwList < NUM_STORED_AFFILIATE_LISTS; dwList++)
    {
        hr = SProcLoadAffiliates(pCCtx->m_qwUserID, X_AFFILIATE_INDEX_TO_FLAG(dwList), pCCtx->m_prgAffiliateLists[dwList]);
        if (FAILED(hr))
        {
            goto lDone;
        }
    }

lDone:

    pCCtx->m_fProcessed = TRUE;
    pCCtx->m_hr = hr;

    hr = m_pCSwitchboard->PostCompletion(pCCtx);
    XOMASSERT(SUCCEEDED(hr));

    // Operation HRESULT returned via the context object
    return S_OK;
}

/*****************************************************************************

CProfileStore::StoreQueryAffiliates

load the given user's affiliates list.  The result is sent back via the
switchboard's completion port to a callback function.

*****************************************************************************/
HRESULT CProfileStore::StoreQueryAffiliates(CQueryAffiliatesContext *pCCtx)
{
    XOMASSERT(m_pCSwitchboard != NULL);
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Going to SQL for StoreQueryAffiliates");

    HRESULT hr = S_OK;

    for (DWORD dwList = 0; dwList < NUM_STORED_AFFILIATE_LISTS; dwList++)
    {
        hr = SProcLoadAffiliates(pCCtx->m_qwUserID, X_AFFILIATE_INDEX_TO_FLAG(dwList), pCCtx->m_prgAffiliateLists[dwList]);
        if (FAILED(hr))
        {
            goto lDone;
        }
    }

lDone:

    pCCtx->m_eState = CQueryAffiliatesContext::QueryAffiliates_ListLoaded;
    pCCtx->m_hr = hr;

    hr = m_pCSwitchboard->PostCompletion(pCCtx);
    XOMASSERT(SUCCEEDED(hr));

    // Operation HRESULT returned via the context object
    return S_OK;
}

HRESULT CProfileStore::StoreStoreAffiliates(CStoreAffiliatesContext *pCCtx)
{
    XOMASSERT(m_pCSwitchboard != NULL);
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Going to SQL for StoreStoreAffiliates");

    pCCtx->m_hr = SProcAddAffiliates(pCCtx->m_qwUserID, pCCtx->m_prgAffiliateLists, pCCtx->m_mtAffiliatesLoaded);

    pCCtx->m_fProcessed = TRUE;
    return m_pCSwitchboard->PostCompletion(pCCtx);
}


/*****************************************************************************

CProfileStore::StoreAcceptBuddy

Accept a request to add a user to the given user's buddy list.  The result is
sent back via the switchboard's completion port to a callback function.

*****************************************************************************/
HRESULT CProfileStore::StoreAcceptBuddy(CAcceptBuddyContext *pCCtx)
{
    XOMASSERT(m_pCSwitchboard != NULL);
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Going to SQL for StoreAcceptBuddy");

    HRESULT hr = S_OK;
    CComPtr<IWSTDTC> piDTC = NULL;

    // Transact both list updates to make sure the lists are in sync
    hr = m_piCommand->GetDTC(&piDTC);
    if (FAILED(hr))
    {
        goto lDone;
    }

    hr = piDTC->BeginTransaction(ISOLATIONLEVEL_READCOMMITTED);
    if (FAILED(hr))
    {
        piDTC = NULL;
        goto lDone;
    }

    // Lower Id first
    if (pCCtx->m_qwUserID < pCCtx->m_qwBuddyID)
    {
        // Try to accept the accepter
        hr = SProcAcceptBuddy(
            pCCtx->m_qwUserID,
            pCCtx->m_qwBuddyID,
            &(pCCtx->m_dwUserBuddyListVersion),
            pCCtx->m_szUserAccountName,
            &(pCCtx->m_cbUserAccountName),
            piDTC);
        if (FAILED(hr))
        {
            goto lDone;
        }

        // Try to accept the acceptie
        hr = SProcAcceptedBuddy(
            pCCtx->m_qwBuddyID,
            pCCtx->m_qwUserID,
            &(pCCtx->m_dwBuddyBuddyListVersion),
            pCCtx->m_szBuddyAccountName,
            &(pCCtx->m_cbBuddyAccountName),
            piDTC);
        if (FAILED(hr))
        {
            goto lDone;
        }
    }
    else
    {
        // Try to accept the acceptie
        hr = SProcAcceptedBuddy(
            pCCtx->m_qwBuddyID,
            pCCtx->m_qwUserID,
            &(pCCtx->m_dwBuddyBuddyListVersion),
            pCCtx->m_szBuddyAccountName,
            &(pCCtx->m_cbBuddyAccountName),
            piDTC);
        if (FAILED(hr))
        {
            goto lDone;
        }

        // Try to accept the accepter
        hr = SProcAcceptBuddy(
            pCCtx->m_qwUserID,
            pCCtx->m_qwBuddyID,
            &(pCCtx->m_dwUserBuddyListVersion),
            pCCtx->m_szUserAccountName,
            &(pCCtx->m_cbUserAccountName),
            piDTC);
        if (FAILED(hr))
        {
            goto lDone;
        }
    }

    // If there are no failures commit and release the transaction
    hr = piDTC->CommitTransaction();
    if (FAILED(hr))
    {
        goto lDone;
    }
    piDTC = NULL;

lDone:

    // If piDTC is not NULL assume failure and rollback
    if (piDTC != NULL)
    {
        piDTC->AbortTransaction();
        piDTC = NULL;
    }

    if (FAILED(hr))
    {
        pCCtx->m_dwBuddyBuddyListVersion = 0;
        pCCtx->m_dwUserBuddyListVersion = 0;

        if ((hr == HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER)) || // no more request
            (hr == DB_E_INTEGRITYVIOLATION) || // dtc rollback
            (hr == HRESULT_FROM_WIN32(ERROR_USER_EXISTS))) // already accepted
        {
            // Expected error cases, just debug spew
            XomTrace(
                PresenceDebug,
                L_NORMAL,
                "StoreAcceptBuddy expected error hr=%X UserId=%I64X BuddyId=%I64X",
                hr,
                pCCtx->m_qwUserID,
                pCCtx->m_qwBuddyID);
        }
        else
        {
            XomNtEvent(
            XEVENT_PRESENCE_CODE_267,
            "StoreAcceptBuddy failed hr=%X UserId=%I64X BuddyId=%I64X",
            hr,
            pCCtx->m_qwUserID,
            pCCtx->m_qwBuddyID);
        }
    }

    pCCtx->m_fProcessed = TRUE;
    pCCtx->m_hr = hr;

    hr = m_pCSwitchboard->PostCompletion(pCCtx);
    XOMASSERT(SUCCEEDED(hr));

    // Operation HRESULT returned via the context object
    return S_OK;
}

/*****************************************************************************

CProfileStore::StoreRejectBuddy

Reject a request to add a user to the given user's buddy list.  The result is
sent back via the switchboard's completion port to a callback function.

*****************************************************************************/
HRESULT CProfileStore::StoreRejectBuddy(CRejectBuddyContext *pCCtx)
{
    XOMASSERT(m_pCSwitchboard != NULL);
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Going to SQL for StoreRejectBuddy");

    HRESULT hr = S_OK;
    CComPtr<IWSTDTC> piDTC = NULL;

    // Transact both list updates to make sure the lists are in sync
    hr = m_piCommand->GetDTC(&piDTC);
    if (FAILED(hr))
    {
        goto lDone;
    }

    hr = piDTC->BeginTransaction(ISOLATIONLEVEL_READCOMMITTED);
    if (FAILED(hr))
    {
        piDTC = NULL;
        goto lDone;
    }

    // Lower Id first
    if (pCCtx->m_qwUserID < pCCtx->m_qwBuddyID)
    {
        // Try to reject the rejecter
        hr = SProcRejectBuddy(
            pCCtx->m_qwUserID,
            pCCtx->m_qwBuddyID,
            pCCtx->m_fNever,
            &(pCCtx->m_dwUserBuddyListVersion),
            piDTC);
        if (FAILED(hr))
        {
            goto lDone;
        }

        // Try to reject the rejectie
        hr = SProcRejectedBuddy(
            pCCtx->m_qwBuddyID,
            pCCtx->m_qwUserID,
            &(pCCtx->m_dwBuddyBuddyListVersion),
            piDTC);
        if (FAILED(hr))
        {
            goto lDone;
        }
    }
    else
    {
        // Try to reject the rejectie
        hr = SProcRejectedBuddy(
            pCCtx->m_qwBuddyID,
            pCCtx->m_qwUserID,
            &(pCCtx->m_dwBuddyBuddyListVersion),
            piDTC);
        if (FAILED(hr))
        {
            goto lDone;
        }

        // Try to reject the rejecter
        hr = SProcRejectBuddy(
            pCCtx->m_qwUserID,
            pCCtx->m_qwBuddyID,
            pCCtx->m_fNever,
            &(pCCtx->m_dwUserBuddyListVersion),
            piDTC);
        if (FAILED(hr))
        {
            goto lDone;
        }
    }

    // If there are no failures commit and release the transaction
    hr = piDTC->CommitTransaction();
    if (FAILED(hr))
    {
        goto lDone;
    }
    piDTC = NULL;

lDone:

    // If piDTC is not NULL assume failure and rollback
    if (piDTC != NULL)
    {
        piDTC->AbortTransaction();
        piDTC = NULL;
    }

    if (FAILED(hr))
    {
        pCCtx->m_dwBuddyBuddyListVersion = 0;
        pCCtx->m_dwUserBuddyListVersion = 0;

        if (hr == DB_E_INTEGRITYVIOLATION)  // dtc rollback
        {
            // just trace
            XomTrace(
                PresenceDebug,
                L_NORMAL,
                "StoreRejectBuddy expected error hr=%X UserId=%I64X BuddyId=%I64X Never=%d",
                hr,
                pCCtx->m_qwUserID,
                pCCtx->m_qwBuddyID,
                pCCtx->m_fNever);
        }
        else
        {
            XomNtEvent(
                XEVENT_PRESENCE_CODE_268,
                "StoreRejectBuddy failed hr=%X UserId=%I64X BuddyId=%I64X Never=%d",
                hr,
                pCCtx->m_qwUserID,
                pCCtx->m_qwBuddyID,
                pCCtx->m_fNever);
        }
    }

    pCCtx->m_fProcessed = TRUE;
    pCCtx->m_hr = hr;

    hr = m_pCSwitchboard->PostCompletion(pCCtx);
    XOMASSERT(SUCCEEDED(hr));

    // Operation HRESULT returned via the context object
    return S_OK;
}

/*****************************************************************************

CProfileStore::StoreDeleteBuddy

Delete a user from the given user's buddy list.  The result is sent back via
the switchboard's completion port to a callback function.

*****************************************************************************/
HRESULT CProfileStore::StoreDeleteBuddy(CDeleteBuddyContext *pCCtx)
{
    XOMASSERT(m_pCSwitchboard != NULL);
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Going to SQL for StoreDeleteBuddy");

    HRESULT hr = S_OK;
    BOOL fEmptyDelete = FALSE;

    CComPtr<IWSTDTC> piDTC = NULL;

    // Transact both list updates to make sure the lists are in sync
    hr = m_piCommand->GetDTC(&piDTC);
    if (FAILED(hr))
    {
        goto lDone;
    }

    hr = piDTC->BeginTransaction(ISOLATIONLEVEL_READCOMMITTED);
    if (FAILED(hr))
    {
        piDTC = NULL;
        goto lDone;
    }

    // Lower Id first
    if (pCCtx->m_qwUserID < pCCtx->m_qwBuddyID)
    {
        // Try to delete it from the user's list
        hr = SProcDeleteBuddy(
            pCCtx->m_qwUserID,
            pCCtx->m_qwBuddyID,
            &(pCCtx->m_dwUserBuddyListVersion),
            piDTC);
        if (FAILED(hr))
        {
            goto lDone;
        }
        else if (hr == S_FALSE)
        {
            fEmptyDelete = TRUE;
        }

        // Try to delete it from the buddy's list
        hr = SProcDeleteBuddy(
            pCCtx->m_qwBuddyID,
            pCCtx->m_qwUserID,
            &(pCCtx->m_dwBuddyBuddyListVersion),
            piDTC);
        // Ignore bad user ids on the buddy end
        if (hr == HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER))
        {
            hr = S_OK;
        }
        if (FAILED(hr))
        {
            goto lDone;
        }
    }
    else
    {
        // Try to delete it from the buddy's list
        hr = SProcDeleteBuddy(
            pCCtx->m_qwBuddyID,
            pCCtx->m_qwUserID,
            &(pCCtx->m_dwBuddyBuddyListVersion),
            piDTC);
        // Ignore bad user ids on the buddy end
        if (hr == HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER))
        {
            hr = S_OK;
        }
        if (FAILED(hr))
        {
            goto lDone;
        }

        // Try to delete it from the user's list
        hr = SProcDeleteBuddy(
            pCCtx->m_qwUserID,
            pCCtx->m_qwBuddyID,
            &(pCCtx->m_dwUserBuddyListVersion),
            piDTC);
        if (FAILED(hr))
        {
            goto lDone;
        }
        else if (hr == S_FALSE)
        {
            fEmptyDelete = TRUE;
        }
    }

    // If there are no failures commit and release the transaction
    hr = piDTC->CommitTransaction();
    if (FAILED(hr))
    {
        goto lDone;
    }
    piDTC = NULL;

    // Set final status
    if (!fEmptyDelete)
    {
        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }

lDone:

    // If piDTC is not NULL assume failure and rollback
    if (piDTC != NULL)
    {
        piDTC->AbortTransaction();
        piDTC = NULL;
    }

    if (FAILED(hr))
    {
        pCCtx->m_dwBuddyBuddyListVersion = 0;
        pCCtx->m_dwUserBuddyListVersion = 0;

        if (hr == DB_E_INTEGRITYVIOLATION) // dtc rollback
        {
            // just trace
            XomTrace(
                PresenceDebug,
                L_NORMAL,
                "StoreDeleteBuddy expected error hr=%X UserId=%I64X BuddyId=%I64X",
                hr,
                pCCtx->m_qwUserID,
                pCCtx->m_qwBuddyID);
        }
        else
        {
            XomNtEvent(
                XEVENT_PRESENCE_CODE_269,
                "StoreDeleteBuddy failed hr=%X UserId=%I64X BuddyId=%I64X",
                hr,
                pCCtx->m_qwUserID,
                pCCtx->m_qwBuddyID);
        }
    }

    pCCtx->m_fProcessed = TRUE;
    pCCtx->m_hr = hr;

    hr = m_pCSwitchboard->PostCompletion(pCCtx);
    XOMASSERT(SUCCEEDED(hr));

    return S_OK;
}

/*****************************************************************************

CProfileStore::StoreBlock

Add a user to the given user's block list.  The result is sent back via the
switchboard's completion port to a callback function.

*****************************************************************************/
HRESULT CProfileStore::StoreBlock(CBlockContext *pCCtx)
{
    XOMASSERT(m_pCSwitchboard != NULL);
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Going to SQL for StoreBlock");

    HRESULT hr = S_OK;
    CComPtr<IRowset> piRowset = NULL;
    CWSODBWResult CResults(ErrorCallback);
    DWORD cRows = 0;

    // Parameter structures
    struct sParams_t {
        INT iRet;
        QWORD qwUserID;
        QWORD qwBlockID;
    } sParams;

    static WSTCOMMANDPARAM rgwstcpParams[] = {
        {1, DBPARAMIO_OUTPUT, DBTYPE_I4,  sizeof(sParams.iRet), offsetof(sParams_t, iRet), NULL},
        {2, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwUserID), offsetof(sParams_t, qwUserID), NULL},
        {3, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwBlockID), offsetof(sParams_t, qwBlockID), NULL}
    };

    WSTCOMMANDINFO wstciParams = {
        sizeof(sParams),
        &sParams,
        ARRAY_ELEMENTS(rgwstcpParams),
        rgwstcpParams
    };

    static WCHAR wszCmd[] = L"{ ? = call p_pres_add_lockout (?, ?) }";

    // Set the parameters
    sParams.iRet = XPROFILE_NO_RESULT;
    sParams.qwUserID = pCCtx->m_qwUserID;
    sParams.qwBlockID = pCCtx->m_qwBlockID;

    // Execute the proc
    hr = m_piCommand->Execute(
        WRITEONLY_COMMANDTYPE,
        GetUserBucket(pCCtx->m_qwUserID),
        wszCmd,
        &wstciParams,
        (IUnknown **)&piRowset,
        NULL,
        DBGUID_DEFAULT,
        IID_IRowset);
    if (FAILED(hr))
    {
        // Run the error through the OLEBD wrapper to get details
        CResults.GetErrorHandler()->HandleError(hr, "StoreBlock failed to execute stored proc");
        goto lDone;
    }

    // Check for a return
    if((sParams.iRet != XPROFILE_NO_RESULT) && (FAILED((HRESULT)sParams.iRet)))
    {
        hr = (DWORD) sParams.iRet;
        goto lDone;
    }

    // Attach the wrapper
    hr = CResults.InitializeWithIRowset(piRowset);
    piRowset = NULL;
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Get the resulting version number
    {
        static DBBINDING _bind[] = {
           WSBIND(1, 0, DBTYPE_I4, 0),
        };

        hr = CResults.SetBindings(_bind, ARRAY_ELEMENTS(_bind));
        if(FAILED(hr))
        {
            goto lDone;
        }
    }

    cRows = 1;

    hr = CResults.GetRows(&cRows, &(pCCtx->m_dwBlockListVersion), sizeof(DWORD));
    if(FAILED(hr))
    {
        goto lDone;
    }

    hr = CResults.Clear();
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Get final return code
    if (sParams.iRet == XPROFILE_NO_RESULT)
    {
        hr = E_FAIL;
    }
    else
    {
        hr = (DWORD) sParams.iRet;
    }

lDone:

    // If failed, report the hr and if it came from the stored proc
    if (FAILED(hr))
    {
        pCCtx->m_dwBlockListVersion = 0;

        if(sParams.iRet != XPROFILE_NO_RESULT)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_270, "p_pres_add_lockout returned failure UserID=%I64X BlockID=%I64X hr=%X", pCCtx->m_qwUserID, pCCtx->m_qwBlockID, hr);
        }
        else
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_271, "StoreBlock failed UserID=%I64X BlockID=%I64X hr=%X", pCCtx->m_qwUserID, pCCtx->m_qwBlockID, hr);
        }
    }

    pCCtx->m_fProcessed = TRUE;
    pCCtx->m_hr = hr;

    hr = m_pCSwitchboard->PostCompletion(pCCtx);
    XOMASSERT(SUCCEEDED(hr));

    return S_OK;
}

/*****************************************************************************

CProfileStore::StoreUnblock

Remove a user from the given user's block list.  The result is sent back via
the switchboard's completion port to a callback function.

*****************************************************************************/
HRESULT CProfileStore::StoreUnblock(CUnblockContext *pCCtx)
{
    XOMASSERT(m_pCSwitchboard != NULL);
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Going to SQL for StoreUnblock");

    HRESULT hr = S_OK;
    CComPtr<IRowset> piRowset = NULL;
    CWSODBWResult CResults(ErrorCallback);
    DWORD cRows = 0;

    // Parameter structures
    struct sParams_t {
        INT iRet;
        QWORD qwUserID;
        QWORD qwBlockID;
    } sParams;

    static WSTCOMMANDPARAM rgwstcpParams[] = {
        {1, DBPARAMIO_OUTPUT, DBTYPE_I4,  sizeof(sParams.iRet), offsetof(sParams_t, iRet), NULL},
        {2, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwUserID), offsetof(sParams_t, qwUserID), NULL},
        {3, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwBlockID), offsetof(sParams_t, qwBlockID), NULL}
    };

    WSTCOMMANDINFO wstciParams = {
        sizeof(sParams),
        &sParams,
        ARRAY_ELEMENTS(rgwstcpParams),
        rgwstcpParams
    };

    static WCHAR wszCmd[] = L"{ ? = call p_pres_delete_lockout (?, ?) }";

    // Set the parameters
    sParams.iRet = XPROFILE_NO_RESULT;
    sParams.qwUserID = pCCtx->m_qwUserID;
    sParams.qwBlockID = pCCtx->m_qwBlockID;

    hr = m_piCommand->Execute(
        WRITEONLY_COMMANDTYPE,
        GetUserBucket(pCCtx->m_qwUserID),
        wszCmd,
        &wstciParams,
        (IUnknown **)&piRowset,
        NULL,
        DBGUID_DEFAULT,
        IID_IRowset);
    if (FAILED(hr))
    {
        // Run the error through the OLEBD wrapper to get details
        CResults.GetErrorHandler()->HandleError(hr, "StoreUnblock failed to execute stored proc");
        goto lDone;
    }

    // Check for a return
    if((sParams.iRet != XPROFILE_NO_RESULT) && (FAILED((HRESULT)sParams.iRet)))
    {
        hr = (DWORD) sParams.iRet;
        goto lDone;
    }

    // Attach the wrapper
    hr = CResults.InitializeWithIRowset(piRowset);
    piRowset = NULL;
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Get the resulting version number
    {
        static DBBINDING _bind[] = {
           WSBIND(1, 0, DBTYPE_I4, 0),
        };

        hr = CResults.SetBindings(_bind, ARRAY_ELEMENTS(_bind));
        if(FAILED(hr))
        {
            goto lDone;
        }
    }

    cRows = 1;

    hr = CResults.GetRows(&cRows, &(pCCtx->m_dwBlockListVersion), sizeof(DWORD));
    if(FAILED(hr))
    {
        goto lDone;
    }

    hr = CResults.Clear();
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Get final return code
    if (sParams.iRet == XPROFILE_NO_RESULT)
    {
        hr = E_FAIL;
    }
    else
    {
        hr = (DWORD) sParams.iRet;
    }

lDone:

    // If failed, report the hr and if it came from the stored proc
    if (FAILED(hr))
    {
        pCCtx->m_dwBlockListVersion = 0;

        if(sParams.iRet != XPROFILE_NO_RESULT)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_272, "p_pres_delete_lockout returned failure UserID=%I64X BlockID=%I64X hr=%X", pCCtx->m_qwUserID, pCCtx->m_qwBlockID, hr);
        }
        else
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_273, "StoreUnblock failed UserID=%I64X BlockID=%I64X hr=%X", pCCtx->m_qwUserID, pCCtx->m_qwBlockID, hr);
        }
    }

    pCCtx->m_fProcessed = TRUE;
    pCCtx->m_hr = hr;

    hr = m_pCSwitchboard->PostCompletion(pCCtx);
    XOMASSERT(SUCCEEDED(hr));

    return S_OK;
}

/*****************************************************************************

CProfileStore::StoreClearAllBlocks

Clear all entries from the given user's block list.  The result is sent back
via the switchboard's completion port to a callback function.

*****************************************************************************/
HRESULT CProfileStore::StoreClearAllBlocks(CClearAllBlocksContext *pCCtx)
{
    XOMASSERT(m_pCSwitchboard != NULL);
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Going to SQL for StoreClearAllBlocks");

    HRESULT hr = S_OK;
    CComPtr<IRowset> piRowset = NULL;
    CWSODBWResult CResults(ErrorCallback);
    DWORD cRows = 0;

    // Parameter structures
    struct sParams_t {
        INT iRet;
        QWORD qwUserID;
        QWORD qwBlockID;
    } sParams;

    static WSTCOMMANDPARAM rgwstcpParams[] = {
        {1, DBPARAMIO_OUTPUT, DBTYPE_I4,  sizeof(sParams.iRet), offsetof(sParams_t, iRet), NULL},
        {2, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwUserID), offsetof(sParams_t, qwUserID), NULL}
    };

    WSTCOMMANDINFO wstciParams = {
        sizeof(sParams),
        &sParams,
        ARRAY_ELEMENTS(rgwstcpParams),
        rgwstcpParams
    };

    static WCHAR wszCmd[] = L"{ ? = call p_pres_clear_lockout_list (?) }";

    // Set the parameters
    sParams.iRet = XPROFILE_NO_RESULT;
    sParams.qwUserID = pCCtx->m_qwUserID;

    // Execute the proc
    hr = m_piCommand->Execute(
        WRITEONLY_COMMANDTYPE,
        GetUserBucket(pCCtx->m_qwUserID),
        wszCmd,
        &wstciParams,
        (IUnknown **)&piRowset,
        NULL,
        DBGUID_DEFAULT,
        IID_IRowset);
    if (FAILED(hr))
    {
        // Run the error through the OLEBD wrapper to get details
        CResults.GetErrorHandler()->HandleError(hr, "StoreClearAllBlocks failed to execute stored proc");
        goto lDone;
    }

    // Check for a return
    if((sParams.iRet != XPROFILE_NO_RESULT) && (FAILED((HRESULT)sParams.iRet)))
    {
        hr = (DWORD) sParams.iRet;
        goto lDone;
    }

    // Attach the wrapper
    hr = CResults.InitializeWithIRowset(piRowset);
    piRowset = NULL;
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Get the resulting version number
    {
        static DBBINDING _bind[] = {
           WSBIND(1, 0, DBTYPE_I4, 0),
        };

        hr = CResults.SetBindings(_bind, ARRAY_ELEMENTS(_bind));
        if(FAILED(hr))
        {
            goto lDone;
        }
    }

    cRows = 1;

    hr = CResults.GetRows(&cRows, &(pCCtx->m_dwBlockListVersion), sizeof(DWORD));
    if(FAILED(hr))
    {
        goto lDone;
    }

    hr = CResults.Clear();
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Get final return code
    if (sParams.iRet == XPROFILE_NO_RESULT)
    {
        hr = E_FAIL;
    }
    else
    {
        hr = (DWORD) sParams.iRet;
    }

lDone:

    // If failed, report the hr and if it came from the stored proc
    if (FAILED(hr))
    {
        pCCtx->m_dwBlockListVersion = 0;

        if(sParams.iRet != XPROFILE_NO_RESULT)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_274, "p_pres_clear_lockout_list  returned failure UserID=%I64X hr=%X", pCCtx->m_qwUserID, hr);
        }
        else
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_275, "ClearAllBlocks failed UserID=%I64X hr=%X", pCCtx->m_qwUserID, hr);
        }
    }

    pCCtx->m_fProcessed = TRUE;
    pCCtx->m_hr = hr;

    hr = m_pCSwitchboard->PostCompletion(pCCtx);
    XOMASSERT(SUCCEEDED(hr));

    return S_OK;
}

/*****************************************************************************

CProfileStore::StoreSetFlushTickets

Sets the flush ticket flag for a given user.

*****************************************************************************/
HRESULT CProfileStore::StoreSetFlushTickets(CSetFlushTicketsContext *pCCtx)
{
    XOMASSERT(m_pCSwitchboard != NULL);
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Going to SQL for StoreSetFlushTickets");

    HRESULT hr = S_OK;
    CComPtr<IRowset> piRowset = NULL;
    CWSODBWResult CResults(ErrorCallback);

    // Parameter structures
    struct sParams_t {
        INT iRet;
        QWORD qwUserID;
    } sParams;

    static WSTCOMMANDPARAM rgwstcpParams[] = {
        {1, DBPARAMIO_OUTPUT, DBTYPE_I4,  sizeof(sParams.iRet), offsetof(sParams_t, iRet), NULL},
        {2, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwUserID), offsetof(sParams_t, qwUserID), NULL}
    };

    WSTCOMMANDINFO wstciParams = {
        sizeof(sParams),
        &sParams,
        ARRAY_ELEMENTS(rgwstcpParams),
        rgwstcpParams
    };

    static WCHAR wszCmd[] = L"{ ? = call p_pres_set_flush_tickets ( ? ) }";

    // Set the parameters
    sParams.iRet = XPROFILE_NO_RESULT;
    sParams.qwUserID = pCCtx->m_qwUserID;

    // Execute the proc
    hr = m_piCommand->Execute(
        WRITEONLY_COMMANDTYPE,
        GetUserBucket(pCCtx->m_qwUserID),
        wszCmd,
        &wstciParams,
        (IUnknown **)&piRowset,
        NULL,
        DBGUID_DEFAULT,
        IID_IRowset);
    if (FAILED(hr))
    {
        // Run the error through the OLEBD wrapper to get details
        CResults.GetErrorHandler()->HandleError(hr, "SetFlushTickets failed to execute stored proc");
        goto lDone;
    }

    // should be no results
    piRowset = NULL;

    // Get final return code
    if (sParams.iRet == XPROFILE_NO_RESULT)
    {
        hr = E_FAIL;
    }
    else
    {
        hr = (DWORD) sParams.iRet;
    }

lDone:

    pCCtx->m_hr = hr;

    // If failed, report the hr and if it came from the stored proc
    if (FAILED(hr))
    {
        if(sParams.iRet != XPROFILE_NO_RESULT)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_276, "p_pres_set_flush_tickets returned failure UserID=%I64X hr=%X", pCCtx->m_qwUserID, hr);
        }
        else
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_277, "StoreSetFlushTickets failed UserID=%I64X hr=%X", pCCtx->m_qwUserID, hr);
        }
    }

    SAFE_RELEASE( pCCtx );

    // Operation HRESULT returned via the context object
    return S_OK;
}

/*****************************************************************************

CProfileStore::LoadOfflinePresence

Gets the offline presence information for a user

*****************************************************************************/
HRESULT CProfileStore::StoreGetOfflinePresence(CLoadOfflinePresenceContext *pCCtx)
{
    XOMASSERT(m_pCSwitchboard != NULL);
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Going to SQL for StoreGetOfflinePresence");

    HRESULT hr = S_OK;
    CComPtr<IMultipleResults> piResults = NULL;
    CWSODBWResult CResults(ErrorCallback);
    DWORD dwIndex = 0;
    DWORD cRows = 0;
    DWORD cBuddies = 0;
    DWORD cNevers = 0;

    CBuddyListEntry *rgCBuddyList = NULL;
    QWORD *rgNeverList = NULL;

    // Parameter structures
    struct sWebAliveParams_t {
        INT iRet;
        QWORD qwUserID;
    } sWebAliveParams;

    static WSTCOMMANDPARAM rgwstcpWebAliveParams[] = {
        {1, DBPARAMIO_OUTPUT, DBTYPE_I4,  sizeof(sWebAliveParams.iRet), offsetof(sWebAliveParams_t, iRet), NULL},
        {2, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sWebAliveParams.qwUserID), offsetof(sWebAliveParams_t, qwUserID), NULL}
    };

    WSTCOMMANDINFO wstciWebAliveParams = {
        sizeof(sWebAliveParams),
        &sWebAliveParams,
        ARRAY_ELEMENTS(rgwstcpWebAliveParams),
        rgwstcpWebAliveParams
    };

    static WCHAR wszWebAliveCmd[] = L"{ ? = call p_pres_load_offline (?) }";

    // Binding structures
    struct sVersionLen_t {
        DWORD dwBuddyListVersion;
        DWORD dwBuddyListLen;
        CHAR szGamertag[XONLINE_GAMERTAG_SIZE];
        QWORD qwWebID;
        BYTE fSubscribedAlerts;
        BYTE rgbPrivileges[XONLINE_NUM_PRIVILEGE_BYTES];
    } sVersionLen = {0};

    struct sBuddyListEntry_t {
        QWORD qwUserID;
        BYTE bStatus;
    } sBuddyListEntry = {0};

    // Set the parameters
    sWebAliveParams.iRet = XPROFILE_NO_RESULT;
    sWebAliveParams.qwUserID = pCCtx->m_qwUserID;

    // Execute the proc
    hr = m_piCommand->Execute(
        WRITETHENREAD_COMMANDTYPE,
        GetUserBucket(pCCtx->m_qwUserID),
        wszWebAliveCmd,
        &wstciWebAliveParams,
        (IUnknown **)&piResults,
        NULL,
        DBGUID_DEFAULT,
        IID_IMultipleResults);
    if (FAILED(hr))
    {
        // Run the error through the OLEBD wrapper to get details
        CResults.GetErrorHandler()->HandleError(hr, "StoreWebAlive Failed to execute stored proc");
        goto lDone;
    }

    // Check for a return
    if((sWebAliveParams.iRet != XPROFILE_NO_RESULT) && (FAILED((HRESULT)sWebAliveParams.iRet)))
    {
        hr = (DWORD) sWebAliveParams.iRet;
        goto lDone;
    }

    // Attach the wrapper
    hr = CResults.SetResults(piResults);
    piResults = NULL;
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Get the version and length
    {
        static DBBINDING _bind[] = {
            WSBIND(1, offsetof(sVersionLen_t, dwBuddyListVersion), DBTYPE_I4, 0),
            WSBIND(2, offsetof(sVersionLen_t, dwBuddyListLen), DBTYPE_I4, 0),
            WSBIND(3, offsetof(sVersionLen_t, szGamertag), DBTYPE_STR, 0),
            WSBIND(4, offsetof(sVersionLen_t, qwWebID), DBTYPE_I8, 0),
            WSBIND(5, offsetof(sVersionLen_t, fSubscribedAlerts), DBTYPE_I1, 0),
            WSBIND(6, offsetof(sVersionLen_t, rgbPrivileges), DBTYPE_BYTES, XONLINE_NUM_PRIVILEGE_BYTES)
        };

        hr = CResults.SetBindings(_bind, ARRAY_ELEMENTS(_bind));
        if(FAILED(hr))
        {
            goto lDone;
        }
    }

    cRows = 1;

    hr = CResults.GetRows(&cRows, &sVersionLen, sizeof(sVersionLen_t));
    if(FAILED(hr))
    {
        goto lDone;
    }

    hr = CResults.NextRowsetResult();
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Check for a return
    if((sWebAliveParams.iRet != XPROFILE_NO_RESULT) && (FAILED((HRESULT)sWebAliveParams.iRet)))
    {
        hr = (DWORD) sWebAliveParams.iRet;
        goto lDone;
    }

    cBuddies = sVersionLen.dwBuddyListLen;

    if (cBuddies > MAX_BUDDIES)
    {
        XomNtEvent(XEVENT_PRESENCE_CODE_278, "p_pres_load_offline returned too many friends (t_users.i_friend_list_len=%d) for user %I64X.",
            cBuddies,
            pCCtx->m_qwUserID);

        cBuddies = MAX_BUDDIES;
    }

    if (cBuddies != 0)
    {
        // Use the count to allocate memory
        rgCBuddyList = new CBuddyListEntry[cBuddies];
        if (rgCBuddyList == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto lDone;
        }


        // Bind
        {
            static DBBINDING _bind[] = {
                WSBIND(1, offsetof(sBuddyListEntry_t, qwUserID), DBTYPE_I8, 0),
                WSBIND(2, offsetof(sBuddyListEntry_t, bStatus), DBTYPE_I1, 0)
            };

            hr = CResults.SetBindings(_bind, ARRAY_ELEMENTS(_bind));
            if(FAILED(hr))
            {
                goto lDone;
            }
        }

        // Get the rows
        dwIndex = 0;
        for(;;)
        {
            cRows = 1;

            hr = CResults.GetRows(&cRows, &sBuddyListEntry, sizeof(sBuddyListEntry_t));
            if(FAILED(hr))
            {
                goto lDone;
            }

            if (cRows > 0)
            {
                if (dwIndex >= cBuddies)
                {
                    // Unexpected number of rows
                    XomNtEvent(XEVENT_PRESENCE_CODE_279, "p_pres_load_offline returned too many friends entries (count (t_xprof_friend_lists)>=%d) for user %I64X.",
                        dwIndex,
                        pCCtx->m_qwUserID);

                    break;
                }

                rgCBuddyList[dwIndex].Initialize();
                rgCBuddyList[dwIndex].SetStatus(sBuddyListEntry.bStatus);
                rgCBuddyList[dwIndex].SetBuddyID(sBuddyListEntry.qwUserID);
                rgCBuddyList[dwIndex].SetSubscribed(FALSE);

                dwIndex++;
            }
            else
            {
                // No rows left to process
                break;
            }
        }

        if (dwIndex != cBuddies)
        {
            hr = E_UNEXPECTED;
            goto lDone;
        }

        hr = CResults.NextRowsetResult();
        if (FAILED(hr))
        {
            goto lDone;
        }
    }
    else
    {
        cBuddies = 0;
        rgCBuddyList = NULL;
    }

    {
        static DBBINDING _bind[] = {
            WSBIND(1, 0, DBTYPE_I4, 0)
        };

        hr = CResults.SetBindings(_bind, ARRAY_ELEMENTS(_bind));
        if(FAILED(hr))
        {
            goto lDone;
        }
    }
    cRows = 1;

    hr = CResults.GetRows(&cRows, &cNevers, sizeof(DWORD));
    if(FAILED(hr))
    {
        goto lDone;
    }

    hr = CResults.NextRowsetResult();
    if (FAILED(hr))
    {
        goto lDone;
    }

    if (cNevers > 0)
    {
        rgNeverList = new QWORD[cNevers];
        if (rgNeverList == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto lDone;
        }

        // Bind
        {
            static DBBINDING _bind[] = {
                WSBIND(1, 0, DBTYPE_I8, 0)
            };

            hr = CResults.SetBindings(_bind, ARRAY_ELEMENTS(_bind));
            if(FAILED(hr))
            {
                goto lDone;
            }
        }

        // Get the rows
        dwIndex = 0;
        for(;;)
        {
            cRows = 1;

            hr = CResults.GetRows(&cRows, &rgNeverList[dwIndex], sizeof(QWORD));
            if(FAILED(hr))
            {
                goto lDone;
            }

            if (cRows > 0)
            {
                if (dwIndex >= cNevers)
                {
                    // Unexpected number of rows
                    hr = E_FAIL;
                    goto lDone;
                }

                dwIndex++;
            }
            else
            {
                // No rows left to process
                break;
            }
        }

        if (dwIndex != cNevers)
        {
            hr = E_UNEXPECTED;
            goto lDone;
        }

        hr = CResults.NextRowsetResult();
        if (FAILED(hr))
        {
            goto lDone;
        }
    }

    hr = CResults.CleanUpResult();
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Final check for a return
    if (sWebAliveParams.iRet == XPROFILE_NO_RESULT)
    {
        hr = E_FAIL;
    }
    else
    {
        hr = (DWORD) sWebAliveParams.iRet;
    }

lDone:

    pCCtx->m_fProcessed = TRUE;
    pCCtx->m_hr = hr;

    if (FAILED(hr))
    {
        // Failed cleanup allocations

        if (rgCBuddyList != NULL)
        {
            delete[] rgCBuddyList;
        }
        if (rgNeverList != NULL)
        {
            delete[] rgNeverList;
        }

        // Set the output parameters for failure
        pCCtx->m_dwBuddyListVersion = 0;
        pCCtx->m_cBuddies = 0;
        pCCtx->m_rgCBuddyList = NULL;
        pCCtx->m_cNevers = 0;
        pCCtx->m_rgNevers = NULL;
        pCCtx->m_qwWebID = 0;
        pCCtx->m_szGamerTag[0] = '\0';
        memset(pCCtx->m_rgbPrivileges, 0, sizeof(pCCtx->m_rgbPrivileges));

        // Report the hr and if it came from the stored proc
        if(sWebAliveParams.iRet != XPROFILE_NO_RESULT)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_280, "p_pres_load_offline for user %I64X returned failure hr=%X", pCCtx->m_qwUserID, hr );
        }
        else
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_281, "StoreGetOfflinePresence for user %I64X failed hr=%X", pCCtx->m_qwUserID, hr );
        }
    }
    else
    {
        // Success, set the output parameters
        pCCtx->m_dwBuddyListVersion = sVersionLen.dwBuddyListVersion;
        pCCtx->m_cBuddies = cBuddies;
        pCCtx->m_rgCBuddyList = rgCBuddyList;
        pCCtx->m_cNevers = cNevers;
        pCCtx->m_rgNevers = rgNeverList;
        pCCtx->m_qwWebID = sVersionLen.qwWebID;
        memcpy(pCCtx->m_rgbPrivileges, sVersionLen.rgbPrivileges, sizeof(pCCtx->m_rgbPrivileges));

        // InvalidateUser gets called on a gamertag change.  in that case, we'll pass the old gamertag in the context object,
        // and it will not match the new one retrieved from the database.  when this happenes, we need to update the friends
        // and team members of this user to reflect the new gamertag.
        if ((pCCtx->m_szGamerTag[0] != '\0') && (0 != strncmp(pCCtx->m_szGamerTag, sVersionLen.szGamertag, XONLINE_GAMERTAG_SIZE)))
        {
            hr = UpdateNameAll(pCCtx->m_qwUserID, sVersionLen.szGamertag);
            if (FAILED(hr))
            {
                XomNtEvent(XEVENT_PRESENCE_CODE_282, "StoreGetOfflinePresence(): failed to update new gamertag for user %I64X, old gt [%s], new gt [%s], hr=%d",
                    pCCtx->m_qwUserID,
                    pCCtx->m_szGamerTag,
                    sVersionLen.szGamertag,
                    hr);
            }
        }

        memcpy(pCCtx->m_szGamerTag, sVersionLen.szGamertag, XONLINE_GAMERTAG_SIZE);
    }

    hr = m_pCSwitchboard->PostCompletion(pCCtx);
    XOMASSERT(SUCCEEDED(hr));

    // Operation HRESULT returned via the context object
    return S_OK;
}

/*****************************************************************************

CProfileStore::StoreTeamCreate

Creates the given team

*****************************************************************************/
HRESULT CProfileStore::StoreTeamCreate(CTeamCreateContext *pCCtx)
{
    XOMASSERT(m_pCSwitchboard != NULL);
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Going to SQL for StoreTeamCreate");

    HRESULT hr = S_OK;
    CComPtr<IWSTDTC> piDTC = NULL;


    // Translate the creator id into a name
    hr = SProcGetAccountNameByID(
        pCCtx->m_qwUserID,
        pCCtx->m_szCreatorName,
        &(pCCtx->m_cbCreatorName));
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Generate a PUID
    hr = GetNextTeamPUID(pCCtx->m_qwUserID, &(pCCtx->m_qwTeamID));
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Transact team updates to make sure everything stays in sync
    hr = m_piCommand->GetDTC(&piDTC);
    if (FAILED(hr))
    {
        goto lDone;
    }

    hr = piDTC->BeginTransaction(ISOLATIONLEVEL_READCOMMITTED);
    if (FAILED(hr))
    {
        piDTC = NULL;
        goto lDone;
    }

    // Create the team
    hr = SProcTeamCreateTeam(
        pCCtx->m_qwTeamID,
        pCCtx->m_dwTitleID,
        pCCtx->m_dwMaxMembers,
        pCCtx->m_wszTeamName,
        pCCtx->m_wszTeamDescription,
        pCCtx->m_wszTeamMotto,
        pCCtx->m_wszTeamURL,
        pCCtx->m_pbTeamData,
        pCCtx->m_cbTeamData,
        pCCtx->m_qwUserID,
        pCCtx->m_szCreatorName,
        pCCtx->m_pbCreatorData,
        pCCtx->m_cbCreatorData,
        piDTC);
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Make sure the team name is unique
    if (pCCtx->m_fXenon)
    {
        hr = SProcTeamCreateName(
            0xFFFFFFFF,
            pCCtx->m_qwTeamID,
            pCCtx->m_wszTeamName,
            piDTC);
    }
    else
    {
        hr = SProcTeamCreateName(
            pCCtx->m_dwTitleID,
            pCCtx->m_qwTeamID,
            pCCtx->m_wszTeamName,
            piDTC);
    }
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Record the creator as a member
    hr = SProcTeamCreateUser(
        pCCtx->m_qwUserID,
        pCCtx->m_dwTitleID,
        pCCtx->m_qwTeamID,
        pCCtx->m_wszTeamName,
        piDTC);
    if (FAILED(hr))
    {
        goto lDone;
    }

    // If there are no failures commit and release the transaction
    hr = piDTC->CommitTransaction();
    if (FAILED(hr))
    {
        goto lDone;
    }
    piDTC = NULL;

lDone:

    // If piDTC is not NULL assume failure and rollback
    if (piDTC != NULL)
    {
        piDTC->AbortTransaction();
        piDTC = NULL;
    }

    if (FAILED(hr))
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_283,
            "StoreTeamCreate failed hr=%X UserId=%I64X TitleId=%d TeamName=%S",
            hr,
            pCCtx->m_qwUserID,
            pCCtx->m_dwTitleID,
            pCCtx->m_wszTeamName);
    }

    pCCtx->m_fProcessed = TRUE;
    pCCtx->m_hr = hr;

    hr = m_pCSwitchboard->PostCompletion(pCCtx);
    XOMASSERT(SUCCEEDED(hr));

    // Operation HRESULT returned via the context object
    return S_OK;
}

/*****************************************************************************

CProfileStore::StoreTeamListTeams

List information on a set of teams

*****************************************************************************/
HRESULT CProfileStore::StoreTeamListTeams(CTeamListTeamsContext *pCCtx)
{
    XOMASSERT(m_pCSwitchboard != NULL);
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Going to SQL for StoreTeamListTeams");

    HRESULT hr = S_OK;
    DWORD dwIndex = 0;

    // If the list is empty, subsitute the user puid
    if (pCCtx->m_cTeamIDs == 0)
    {
        pCCtx->m_cTeamIDs = 1;
        pCCtx->m_rgqwTeamIDs[0] = pCCtx->m_qwUserID;
    }

    // If the first id is a user, expand it out
    if ((pCCtx->m_cTeamIDs > 0) &&
        ((pCCtx->m_rgqwTeamIDs[0] & 0xFFFF000000000000) != 0xFEFE000000000000))
    {
        P_REPLY_USER_TEAM   rgUserTeams[MAX_TEAMS];

        hr = SProcGetUserTeams(
            pCCtx->m_dwTitleID,
            pCCtx->m_rgqwTeamIDs[0],
            FALSE,
            &(pCCtx->m_cTeamIDs),
            rgUserTeams);
        if (FAILED(hr))
        {
            goto lDone;
        }

        for (dwIndex = 0; dwIndex < pCCtx->m_cTeamIDs; dwIndex++)
        {
            pCCtx->m_rgqwTeamIDs[dwIndex] = rgUserTeams[dwIndex].qwTeamID;
        }
    }

    pCCtx->m_cReplies = 0;

    for (dwIndex = 0; dwIndex < pCCtx->m_cTeamIDs; dwIndex++)
    {
        hr = SProcGetTeamListTeam(
            pCCtx->m_dwTitleID,
            pCCtx->m_rgqwTeamIDs[dwIndex],
            &(pCCtx->m_rgpReplies[dwIndex]));
        if (hr == XONLINE_E_TEAMS_TEAM_NOT_FOUND)
        {
            P_REPLY_TEAM *psReplyTeam = NULL;

            pCCtx->m_rgpReplies[dwIndex] = CTCPCntVarBuffer::CreateInstance(
                sizeof(P_REPLY_TEAM));
            if (pCCtx->m_rgpReplies[dwIndex] == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto lDone;
            }

            psReplyTeam = (P_REPLY_TEAM *) pCCtx->m_rgpReplies[dwIndex]->GetBuffer();

            psReplyTeam->qwTeamID = pCCtx->m_rgqwTeamIDs[dwIndex];
            psReplyTeam->dwNumMembers = 0;
            psReplyTeam->cbTeamName =  0;
            psReplyTeam->cbTeamDescription = 0;
            psReplyTeam->cbTeamMotto = 0;
            psReplyTeam->cbTeamURL = 0;
            psReplyTeam->cbTeamData = 0;
            memset(&(psReplyTeam->ftCreated), 0, sizeof(FILETIME));

            hr = S_OK;
        }
        else if (FAILED(hr))
        {
            goto lDone;
        }

        pCCtx->m_cReplies++;
    }

lDone:
    if (FAILED(hr))
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_284,
            "StoreTeamListTeams failed hr=%X UserId=%I64X TitleId=%d",
            hr,
            pCCtx->m_qwUserID,
            pCCtx->m_dwTitleID);

        // Clear any replies on failure
        for (dwIndex = 0; dwIndex < pCCtx->m_cReplies; dwIndex++)
        {
            SAFE_RELEASE(pCCtx->m_rgpReplies[dwIndex]);
        }
        pCCtx->m_cReplies = 0;
    }

    pCCtx->m_fProcessed = TRUE;
    pCCtx->m_hr = hr;

    hr = m_pCSwitchboard->PostCompletion(pCCtx);
    XOMASSERT(SUCCEEDED(hr));

    // Operation HRESULT returned via the context object
    return S_OK;
}


/*****************************************************************************

CProfileStore::StoreTeamListUserTeams

List information on a set of teams

*****************************************************************************/
HRESULT CProfileStore::StoreTeamListUserTeams(CTeamListUserTeamsContext *pCCtx)
{
    XOMASSERT(m_pCSwitchboard != NULL);
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Going to SQL for StoreTeamListUserTeams");

    HRESULT hr = S_OK;

    hr = SProcGetUserTeams(
        pCCtx->m_dwTitleID,
        pCCtx->m_qwUserID,
        TRUE,
        &(pCCtx->m_cTeams),
        pCCtx->m_rgUserTeams);
    if (FAILED(hr))
    {
        goto lDone;
    }

lDone:
    if (FAILED(hr))
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_285,
            "StoreTeamListUserTeams failed hr=%X UserId=%I64X TitleId=%d",
            hr,
            pCCtx->m_qwUserID,
            pCCtx->m_dwTitleID);

        pCCtx->m_cTeams = 0;
    }

    pCCtx->m_fProcessed = TRUE;
    pCCtx->m_hr = hr;

    hr = m_pCSwitchboard->PostCompletion(pCCtx);
    XOMASSERT(SUCCEEDED(hr));

    // Operation HRESULT returned via the context object
    return S_OK;
}


/*****************************************************************************

CProfileStore::StoreTeamListMembers

List the membership of a team

*****************************************************************************/
HRESULT CProfileStore::StoreTeamListMembers(CTeamListMembersContext *pCCtx)
{
    XOMASSERT(m_pCSwitchboard != NULL);
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Going to SQL for StoreTeamListMembers");

    HRESULT hr = S_OK;


    hr = SProcGetTeamListMembers(
        pCCtx->m_dwTitleID,
        pCCtx->m_qwTeamID,
        pCCtx->m_fShowRecruits,
        &(pCCtx->m_cMembers),
        pCCtx->m_rgqwMemberIDs,
        &(pCCtx->m_pReply));
    if (FAILED(hr))
    {
        goto lDone;
    }

lDone:
    if (FAILED(hr))
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_286,
            "StoreTeamListMembers failed hr=%X UserId=%I64X TitleId=%d TeamId=%I64X",
            hr,
            pCCtx->m_qwUserID,
            pCCtx->m_dwTitleID,
            pCCtx->m_qwTeamID);
    }

    pCCtx->m_fProcessed = TRUE;
    pCCtx->m_hr = hr;

    hr = m_pCSwitchboard->PostCompletion(pCCtx);
    XOMASSERT(SUCCEEDED(hr));

    // Operation HRESULT returned via the context object
    return S_OK;
}

/*****************************************************************************

CProfileStore::StoreTeamDelete

Deletes the given team

*****************************************************************************/
HRESULT CProfileStore::StoreTeamDelete(CTeamDeleteContext *pCCtx)
{
XOMASSERT(m_pCSwitchboard != NULL);
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Going to SQL for StoreTeamDelete");

    HRESULT hr = S_OK;
    WCHAR wszTeamName[MAX_TEAM_NAME_CHAR];
    DWORD cbTeamName = 0;
    CComPtr<IWSTDTC> piDTC = NULL;

    // Get the name of the team so we can clear the reverse lookup
    hr = SProcGetTeamNameByID(
        pCCtx->m_qwTeamID,
        wszTeamName,
        &cbTeamName);
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Transact team updates to make sure everything stays in sync
    hr = m_piCommand->GetDTC(&piDTC);
    if (FAILED(hr))
    {
        goto lDone;
    }

    hr = piDTC->BeginTransaction(ISOLATIONLEVEL_READCOMMITTED);
    if (FAILED(hr))
    {
        piDTC = NULL;
        goto lDone;
    }

    // Update the team records
    hr = SProcTeamDeleteTeam(
        pCCtx->m_qwTeamID,
        pCCtx->m_qwUserID,
        &(pCCtx->m_cMemberIDs),
        pCCtx->m_rgqwMemberIDs,
        piDTC);
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Update the name records
    hr = SProcTeamDeleteName(
        pCCtx->m_qwTeamID,
        wszTeamName,
        FALSE,
        piDTC);
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Update the user records
    hr = SProcTeamDeleteUser(
        pCCtx->m_qwTeamID,
        piDTC);
    if (FAILED(hr))
    {
        goto lDone;
    }

    // If there are no failures commit and release the transaction
    hr = piDTC->CommitTransaction();
    if (FAILED(hr))
    {
        goto lDone;
    }
    piDTC = NULL;

lDone:

    // If piDTC is not NULL assume failure and rollback
    if (piDTC != NULL)
    {
        piDTC->AbortTransaction();
        piDTC = NULL;
    }

    if (FAILED(hr))
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_287,
            "StoreTeamRemove failed hr=%X UserId=%I64X TitleId=%d TeamId=%I64X",
            hr,
            pCCtx->m_qwUserID,
            pCCtx->m_dwTitleID,
            pCCtx->m_qwTeamID);
    }

    pCCtx->m_fProcessed = TRUE;
    pCCtx->m_hr = hr;

    hr = m_pCSwitchboard->PostCompletion(pCCtx);
    XOMASSERT(SUCCEEDED(hr));

    // Operation HRESULT returned via the context object
    return S_OK;
}

/*****************************************************************************

CProfileStore::StoreTeamRemove

Removes a member from the given team

*****************************************************************************/
HRESULT CProfileStore::StoreTeamRemove(CTeamRemoveContext *pCCtx)
{
    XOMASSERT(m_pCSwitchboard != NULL);
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Going to SQL for StoreTeamRemove");

    HRESULT hr = S_OK;
    CComPtr<IWSTDTC> piDTC = NULL;

    // Transact team updates to make sure everything stays in sync
    hr = m_piCommand->GetDTC(&piDTC);
    if (FAILED(hr))
    {
        goto lDone;
    }

    hr = piDTC->BeginTransaction(ISOLATIONLEVEL_READCOMMITTED);
    if (FAILED(hr))
    {
        piDTC = NULL;
        goto lDone;
    }


    // Update the team records
    hr = SProcTeamRemoveTeam(
        pCCtx->m_qwTeamID,
        pCCtx->m_qwUserID,
        pCCtx->m_qwMemberID,
        TRUE,
        piDTC);
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Update the user records
    hr = SProcTeamRemoveUser(
        pCCtx->m_qwMemberID,
        pCCtx->m_qwTeamID,
        TRUE,
        piDTC);
    if (FAILED(hr))
    {
        goto lDone;
    }

    // If there are no failures commit and release the transaction
    hr = piDTC->CommitTransaction();
    if (FAILED(hr))
    {
        goto lDone;
    }
    piDTC = NULL;

lDone:

    // If piDTC is not NULL assume failure and rollback
    if (piDTC != NULL)
    {
        piDTC->AbortTransaction();
        piDTC = NULL;
    }

    if (FAILED(hr))
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_288,
            "StoreTeamRemove failed hr=%X UserId=%I64X TitleId=%d TeamId=%I64X MemberId=%I64X",
            hr,
            pCCtx->m_qwUserID,
            pCCtx->m_dwTitleID,
            pCCtx->m_qwTeamID,
            pCCtx->m_qwMemberID);
    }

    pCCtx->m_fProcessed = TRUE;
    pCCtx->m_hr = hr;

    hr = m_pCSwitchboard->PostCompletion(pCCtx);
    XOMASSERT(SUCCEEDED(hr));

    // Operation HRESULT returned via the context object
    return S_OK;
}

/*****************************************************************************

CProfileStore::StoreTeamManageTeam

Manage a team

*****************************************************************************/
HRESULT CProfileStore::StoreTeamManageTeam(CTeamManageTeamContext *pCCtx)
{
    XOMASSERT(m_pCSwitchboard != NULL);
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Going to SQL for StoreTeamManageTeam");

    HRESULT hr = S_OK;
    WCHAR wszOldTeamName[MAX_TEAM_NAME_CHAR];
    DWORD cbOldTeamName = 0;
    CComPtr<IWSTDTC> piDTC = NULL;

    // Transact team updates to make sure everything stays in sync
    hr = m_piCommand->GetDTC(&piDTC);
    if (FAILED(hr))
    {
        goto lDone;
    }

    hr = piDTC->BeginTransaction(ISOLATIONLEVEL_READCOMMITTED);
    if (FAILED(hr))
    {
        piDTC = NULL;
        goto lDone;
    }

    // Update the team record
    hr = SProcTeamManageTeam(
        pCCtx->m_qwUserID,
        pCCtx->m_dwTitleID,
        pCCtx->m_qwTeamID,
        pCCtx->m_wszTeamName,
        pCCtx->m_wszTeamDescription,
        pCCtx->m_wszTeamMotto,
        pCCtx->m_wszTeamURL,
        pCCtx->m_pbTeamData,
        pCCtx->m_cbTeamData,
        wszOldTeamName,
        &cbOldTeamName,
        piDTC);
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Do we need to update the team name?
    if (hr == S_FALSE)
    {
        // Recreate the name entry
        hr = SProcTeamDeleteName(
            pCCtx->m_qwTeamID,
            wszOldTeamName,
            TRUE,
            piDTC);
        if (FAILED(hr))
        {
            goto lDone;
        }

        if (pCCtx->m_fXenon)
        {
            hr = SProcTeamCreateName(
                0xFFFFFFFF,
                pCCtx->m_qwTeamID,
                pCCtx->m_wszTeamName,
                piDTC);
        }
        else
        {
            hr = SProcTeamCreateName(
                pCCtx->m_dwTitleID,
                pCCtx->m_qwTeamID,
                pCCtx->m_wszTeamName,
                piDTC);
        }
        if (FAILED(hr))
        {
            goto lDone;
        }

        // Update all the other datebase entries
        hr = SProcRenameTeam(
            pCCtx->m_qwTeamID,
            pCCtx->m_wszTeamName,
            piDTC);
        if (FAILED(hr))
        {
            goto lDone;
        }
    }

    // If there are no failures commit and release the transaction
    hr = piDTC->CommitTransaction();
    if (FAILED(hr))
    {
        goto lDone;
    }
    piDTC = NULL;

lDone:

    // If piDTC is not NULL assume failure and rollback
    if (piDTC != NULL)
    {
        piDTC->AbortTransaction();
        piDTC = NULL;
    }

    if (FAILED(hr))
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_289,
            "StoreTeamManageTeam failed hr=%X UserId=%I64X TitleId=%d TeamId=%I64X",
            hr,
            pCCtx->m_qwUserID,
            pCCtx->m_dwTitleID,
            pCCtx->m_qwTeamID);
    }

    pCCtx->m_fProcessed = TRUE;
    pCCtx->m_hr = hr;

    hr = m_pCSwitchboard->PostCompletion(pCCtx);
    XOMASSERT(SUCCEEDED(hr));

    // Operation HRESULT returned via the context object
    return S_OK;
}

/*****************************************************************************

CProfileStore::StoreTeamManageMember

Manage a team member

*****************************************************************************/
HRESULT CProfileStore::StoreTeamManageMember(CTeamManageMemberContext *pCCtx)
{
    HRESULT hr = S_OK;
    CComPtr<IRowset> piRowset = NULL;
    CWSODBWResult CResults(ErrorCallback);

    // Parameter structures
    struct sParams_t {
        INT iRet;
        DWORD dwTitleID;
        QWORD qwTeamID;
        QWORD qwUserID;
        QWORD qwMemberID;
        CHAR szMemberName[MAX_ACCTNAME_BYTES];
        DWORD dwMemberPriv;
        BYTE rgbMemberData[MAX_TEAM_MEMBER_DATA_BYTES];
    } sParams;

    WSTCOMMANDPARAM rgwstcpParams[] = {
        {1, DBPARAMIO_OUTPUT, DBTYPE_I4,  sizeof(sParams.iRet), offsetof(sParams_t, iRet), NULL},
        {2, DBPARAMIO_INPUT,  DBTYPE_I4,  sizeof(sParams.dwTitleID), offsetof(sParams_t, dwTitleID), NULL},
        {3, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwTeamID), offsetof(sParams_t, qwTeamID), NULL},
        {4, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwUserID), offsetof(sParams_t, qwUserID), NULL},
        {5, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwMemberID), offsetof(sParams_t, qwMemberID), NULL},
        {6, DBPARAMIO_INPUT,  DBTYPE_I4,  sizeof(sParams.dwMemberPriv), offsetof(sParams_t, dwMemberPriv), NULL},
        {7, DBPARAMIO_INPUT,  DBTYPE_BYTES, pCCtx->m_cbMemberData, offsetof(sParams_t, rgbMemberData), NULL}
    };

    WSTCOMMANDINFO wstciParams = {
        sizeof(sParams),
        &sParams,
        ARRAY_ELEMENTS(rgwstcpParams),
        rgwstcpParams
    };

    static WCHAR wszCmd[] = L"{ ? = call p_team_manage_member (?, ?, ?, ?, ?, ?) }";

    // Set the parameters
    sParams.iRet = XPROFILE_NO_RESULT;
    sParams.dwTitleID = pCCtx->m_dwTitleID;
    sParams.qwTeamID = pCCtx->m_qwTeamID;
    sParams.qwUserID = pCCtx->m_qwUserID;
    sParams.qwMemberID = pCCtx->m_qwMemberID;
    sParams.dwMemberPriv = pCCtx->m_dwMemberPriv;
    memset(sParams.rgbMemberData, 0, MAX_TEAM_MEMBER_DATA_BYTES);
    memcpy(sParams.rgbMemberData, pCCtx->m_pbMemberData, pCCtx->m_cbMemberData);

    // Execute the proc
    hr = m_piCommand->Execute(
        WRITEONLY_COMMANDTYPE,
        GetTeamBucket(pCCtx->m_qwTeamID),
        wszCmd,
        &wstciParams,
        (IUnknown **)&piRowset,
        NULL,
        DBGUID_DEFAULT,
        IID_IRowset);
    if (FAILED(hr))
    {
        // Run the error through the OLEBD wrapper to get details
        CResults.GetErrorHandler()->HandleError(hr, "SProcTeamManageMember failed to execute stored proc");
        goto lDone;
    }

    // Should be no rowsets comming back
    piRowset = NULL;

    // Get final return code
    if (sParams.iRet == XPROFILE_NO_RESULT)
    {
        hr = E_FAIL;
    }
    else
    {
        hr = (DWORD) sParams.iRet;
    }

lDone:

    // If failed, report the hr and if it came from the stored proc
    if (FAILED(hr))
    {
        if(sParams.iRet != XPROFILE_NO_RESULT)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_290, "p_team_manage_member  returned failure TeamID=%I64X TitleID=%d MemberID=%I64X hr=0x%X",
                pCCtx->m_qwTeamID,
                pCCtx->m_dwTitleID,
                pCCtx->m_qwMemberID,
                hr);
        }
        else
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_291, "StoreTeamManageMember failed TeamID=%I64X TitleID=%d MemberID=%I64X hr=0x%X",
                pCCtx->m_qwTeamID,
                pCCtx->m_dwTitleID,
                pCCtx->m_qwMemberID,
                hr);
        }
    }

    pCCtx->m_fProcessed = TRUE;
    pCCtx->m_hr = hr;

    hr = m_pCSwitchboard->PostCompletion(pCCtx);
    XOMASSERT(SUCCEEDED(hr));

    // Operation HRESULT returned via the context object
    return S_OK;
}

/*****************************************************************************

CProfileStore::StoreTeamRecruit

Recruits a user to a team

*****************************************************************************/
HRESULT CProfileStore::StoreTeamRecruit(CTeamRecruitContext *pCCtx)
{
    XOMASSERT(m_pCSwitchboard != NULL);
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Going to SQL for StoreTeamRecruit");

    HRESULT hr = S_OK;
    CComPtr<IWSTDTC> piDTC = NULL;
    DWORD cbMemberName = 0;
    DWORD cbTeamName = 0;
    CHAR szTeamName[MAX_TEAM_NAME_BYTES];

    if (pCCtx->m_qwMemberID == 0)
    {
        // Translate the member name into an id
        hr = SProcGetUserIDByName(
            pCCtx->m_szMemberName,
            &(pCCtx->m_qwMemberID));
        if (FAILED(hr))
        {
            goto lDone;
        }
    }
    else
    {
        // Translate the member id into a name
        hr = SProcGetAccountNameByID(
            pCCtx->m_qwMemberID,
            pCCtx->m_szMemberName,
            &cbMemberName);
        if (FAILED(hr))
        {
            goto lDone;
        }
    }

    // Transact team updates to make sure everything stays in sync
    hr = m_piCommand->GetDTC(&piDTC);
    if (FAILED(hr))
    {
        goto lDone;
    }

    hr = piDTC->BeginTransaction(ISOLATIONLEVEL_READCOMMITTED);
    if (FAILED(hr))
    {
        piDTC = NULL;
        goto lDone;
    }

    // Update the team records
    hr = SProcTeamRecruitTeam(
        pCCtx->m_dwTitleID,
        pCCtx->m_qwTeamID,
        pCCtx->m_qwUserID,
        pCCtx->m_qwMemberID,
        pCCtx->m_szMemberName,
        pCCtx->m_dwMemberPriv,
        pCCtx->m_pbMemberData,
        pCCtx->m_cbMemberData,
        szTeamName,
        &cbTeamName,
        piDTC);
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Update the user records
    hr = SProcTeamRecruitUser(
        pCCtx->m_qwMemberID,
        pCCtx->m_dwTitleID,
        pCCtx->m_qwTeamID,
        szTeamName,
        pCCtx->m_qwUserID,
        piDTC);
    if (FAILED(hr))
    {
        goto lDone;
    }

    // If there are no failures commit and release the transaction
    hr = piDTC->CommitTransaction();
    if (FAILED(hr))
    {
        goto lDone;
    }
    piDTC = NULL;

lDone:

    // If piDTC is not NULL assume failure and rollback
    if (piDTC != NULL)
    {
        piDTC->AbortTransaction();
        piDTC = NULL;
    }

    if (hr == HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER))
    {
        hr =  XONLINE_E_TEAMS_USER_NOT_FOUND;
    }
    else if (FAILED(hr))
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_292,
            "StoreTeamRecruit failed hr=%X UserId=%I64X MemberId=%I64X TitleId=%d TeamId=%I64X",
            hr,
            pCCtx->m_qwUserID,
            pCCtx->m_qwMemberID,
            pCCtx->m_dwTitleID,
            pCCtx->m_qwTeamID);
    }

    pCCtx->m_fProcessed = TRUE;
    pCCtx->m_hr = hr;

    hr = m_pCSwitchboard->PostCompletion(pCCtx);
    XOMASSERT(SUCCEEDED(hr));

    // Operation HRESULT returned via the context object
    return S_OK;
}

/*****************************************************************************

CProfileStore::StoreTeamJoin

Accpet or reject recruitment to a team

*****************************************************************************/
HRESULT CProfileStore::StoreTeamJoin(CTeamJoinContext *pCCtx)
{
    XOMASSERT(m_pCSwitchboard != NULL);
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Going to SQL for StoreTeamJoin");

    HRESULT hr = S_OK;
    CComPtr<IWSTDTC> piDTC = NULL;

    // Transact team updates to make sure everything stays in sync
    hr = m_piCommand->GetDTC(&piDTC);
    if (FAILED(hr))
    {
        goto lDone;
    }

    hr = piDTC->BeginTransaction(ISOLATIONLEVEL_READCOMMITTED);
    if (FAILED(hr))
    {
        piDTC = NULL;
        goto lDone;
    }

    if (pCCtx->m_bAnswer == 1)
    {
        // Update the team records
        hr = SProcTeamJoinTeam(
            pCCtx->m_qwTeamID,
            pCCtx->m_qwUserID,
            piDTC);
        if (FAILED(hr))
        {
            goto lDone;
        }

        // Update the user records
        hr = SProcTeamJoinUser(
            pCCtx->m_qwUserID,
            pCCtx->m_qwTeamID,
            piDTC);
        if (FAILED(hr))
        {
            goto lDone;
        }
    }
    else
    {
        // Update the team records
        hr = SProcTeamRemoveTeam(
            pCCtx->m_qwTeamID,
            pCCtx->m_qwUserID,
            pCCtx->m_qwUserID,
            FALSE,
            piDTC);
        if (FAILED(hr))
        {
            goto lDone;
        }

        // Update the user records
        hr = SProcTeamRemoveUser(
            pCCtx->m_qwUserID,
            pCCtx->m_qwTeamID,
            FALSE,
            piDTC);
        if (FAILED(hr))
        {
            goto lDone;
        }
    }

    // If there are no failures commit and release the transaction
    hr = piDTC->CommitTransaction();
    if (FAILED(hr))
    {
        goto lDone;
    }
    piDTC = NULL;

lDone:

    // If piDTC is not NULL assume failure and rollback
    if (piDTC != NULL)
    {
        piDTC->AbortTransaction();
        piDTC = NULL;
    }

    if (FAILED(hr))
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_293,
            "StoreTeamJoin failed hr=%X UserId=%I64X TitleId=%d TeamId=%I64X",
            hr,
            pCCtx->m_qwUserID,
            pCCtx->m_dwTitleID,
            pCCtx->m_qwTeamID);
    }

    pCCtx->m_fProcessed = TRUE;
    pCCtx->m_hr = hr;

    hr = m_pCSwitchboard->PostCompletion(pCCtx);
    XOMASSERT(SUCCEEDED(hr));

    // Operation HRESULT returned via the context object
    return S_OK;
}

/*****************************************************************************

CProfileStore::StoreTeamGetTicket

Get a ticket containing the teams a user is in

*****************************************************************************/
HRESULT CProfileStore::StoreTeamGetTicket(CTeamGetTicketContext *pCCtx)
{
    XOMASSERT(m_pCSwitchboard != NULL);
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Going to SQL for StoreTeamGetTicket");

    HRESULT hr = S_OK;

    pCCtx->m_cTeamIDs = 0;
    pCCtx->m_rgqwTeamIDs[0] = 0;

    P_REPLY_USER_TEAM   rgUserTeams[MAX_TEAMS];

    hr = SProcGetUserTeams(
        pCCtx->m_dwTitleID,
        pCCtx->m_qwUserID,
        FALSE,
        &(pCCtx->m_cTeamIDs),
        rgUserTeams);
    if (FAILED(hr))
    {
        goto lDone;
    }

    for (DWORD dwIndex = 0; dwIndex < pCCtx->m_cTeamIDs; dwIndex++)
    {
        pCCtx->m_rgqwTeamIDs[dwIndex] = rgUserTeams[dwIndex].qwTeamID;
    }

lDone:
    if (FAILED(hr))
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_294,
            "StoreTeamGetTicket failed hr=%X UserId=%I64X TitleId=%d",
            hr,
            pCCtx->m_qwUserID,
            pCCtx->m_dwTitleID);

        pCCtx->m_cTeamIDs = 0;
        pCCtx->m_rgqwTeamIDs[0] = 0;
    }

    pCCtx->m_fProcessed = TRUE;
    pCCtx->m_hr = hr;

    hr = m_pCSwitchboard->PostCompletion(pCCtx);
    XOMASSERT(SUCCEEDED(hr));

    // Operation HRESULT returned via the context object
    return S_OK;
}

/*****************************************************************************

CProfileStore::StoreEnumerateMessages

Enumerate the specified user's message queue.  The result is sent back via
the switchboard's completion port to a callback function.

*****************************************************************************/
void CProfileStore::StoreEnumerateMessages(CEnumerateMessagesContext *pCCtx)
{
    XOMASSERT(m_pCSwitchboard != NULL);
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Going to SQL for StoreEnumerateMessages");

    HRESULT hr = S_OK;
    CComPtr<IRowset> piRowset = NULL;
    CWSODBWResult CResults(ErrorCallback);
    DWORD cRows = 0;

    BYTE *pbWrite = NULL;

    // Parameter structures
    struct sParams_t {
        INT iRet;
        QWORD qwUserID;
    } sParams;

    static WSTCOMMANDPARAM rgwstcpParams[] = {
        {1, DBPARAMIO_OUTPUT, DBTYPE_I4,  sizeof(sParams.iRet), offsetof(sParams_t, iRet), NULL},
        {2, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwUserID), offsetof(sParams_t, qwUserID), NULL},
    };

    WSTCOMMANDINFO wstciParams = {
        sizeof(sParams),
        &sParams,
        ARRAY_ELEMENTS(rgwstcpParams),
        rgwstcpParams
    };

    static WCHAR wszCmd[] = L"{ ? = call p_xmsg_user_message_enumerate( ? ) }";

    // Set the parameters
    sParams.iRet = S_OK;
    sParams.qwUserID = pCCtx->m_qwUserID;

    // Execute the proc
    hr = m_piCommand->Execute(
        WRITETHENREAD_COMMANDTYPE,
        GetUserBucket(pCCtx->m_qwUserID),
        wszCmd,
        &wstciParams,
        (IUnknown **)&piRowset,
        NULL,
        DBGUID_DEFAULT,
        IID_IRowset);
    if (FAILED(hr))
    {
        // Run the error through the OLEDB wrapper to get details
        CResults.GetErrorHandler()->HandleError(hr, "StoreEnumerateMessages Failed to execute stored proc");
        goto lDone;
    }

    // Attach the wrapper
    hr = CResults.InitializeWithIRowset(piRowset);
    if (FAILED(hr))
    {
        goto lDone;
    }

    struct sEntry_t {
        DWORD dwMessageID;
        BYTE bMessageType;
        DWORD dwMessageFlags;
        QWORD qwSenderID;
        DWORD dwSenderTitleID;
        QWORD qwSenderContext;
        CHAR szSenderName[ XONLINE_GAMERTAG_SIZE ];
        WCHAR szSubject[ XONLINE_MAX_SUBJECT_SIZE ];
        DATE dtSentTime;
        WORD wExpireMinutes;
        WORD cbDetails;
    } sEntry;

    // The reply buffer was already allocated for us by the switchboard, just get a pointer to the part we want
    XOMASSERT( pCCtx->m_pCReply );

    pbWrite = pCCtx->m_pCReply->GetBuffer() + sizeof(Q_ENUM_MESSAGES_REPLY_MSG);

    // Bind
    {
        static DBBINDING _bind[] = {
            WSBIND(1, offsetof(sEntry_t, dwMessageID),     DBTYPE_I4, 0),
            WSBIND(2, offsetof(sEntry_t, bMessageType),    DBTYPE_I1, 0),
            WSBIND(3, offsetof(sEntry_t, dwMessageFlags),  DBTYPE_I4, 0),
            WSBIND(4, offsetof(sEntry_t, qwSenderID),      DBTYPE_I8, 0),
            WSBIND(5, offsetof(sEntry_t, dwSenderTitleID), DBTYPE_I4, 0),
            WSBIND(6, offsetof(sEntry_t, qwSenderContext), DBTYPE_I8, 0),
            WSBIND(7, offsetof(sEntry_t, szSenderName),    DBTYPE_STR, XONLINE_GAMERTAG_SIZE),
            WSBIND(8, offsetof(sEntry_t, szSubject),       DBTYPE_WSTR, XONLINE_MAX_SUBJECT_SIZE),
            WSBIND(9, offsetof(sEntry_t, dtSentTime),      DBTYPE_DATE, 0),
            WSBIND(10, offsetof(sEntry_t, wExpireMinutes),  DBTYPE_I2, 0),
            WSBIND(11, offsetof(sEntry_t, cbDetails),       DBTYPE_I2, 0),
        };

        hr = CResults.SetBindings(_bind, ARRAY_ELEMENTS(_bind));
        if(FAILED(hr))
        {
            goto lDone;
        }
    }

    // Get the rows
    WORD iRow;
    for( iRow = 0; iRow < MAX_PERSISTENT_MESSAGES; iRow++ )
    {
        cRows = 1;

        hr = CResults.GetRows(&cRows, &sEntry, sizeof(sEntry_t));
        if(FAILED(hr))
        {
            goto lDone;
        }

        if (cRows > 0)
        {
            Q_MESSAGE_SUMMARY *pReplyWork = NULL;
            Q_MESSAGE_SUMMARY_2 *pReply2Work = NULL;

            if (sEntry.bMessageType > pCCtx->m_bMaxKnownMsgType)
            {
                // dont write any messages that are newer schema than the caller can handle.
                iRow--;
                continue;
            }

            if (pCCtx->m_dwMsgType == QMSG_ENUM_MESSAGES_2)
            {
                pReply2Work = (Q_MESSAGE_SUMMARY_2 *)pbWrite + iRow;
                pReplyWork = (Q_MESSAGE_SUMMARY *)pReply2Work;
            }
            else
            {
                pReplyWork = (Q_MESSAGE_SUMMARY *)pbWrite + iRow;
            }

            pReplyWork->dwMessageID = sEntry.dwMessageID;
            pReplyWork->bMessageType = sEntry.bMessageType;
            pReplyWork->dwMessageFlags = sEntry.dwMessageFlags;
            pReplyWork->qwSenderID = sEntry.qwSenderID;
            memcpy( pReplyWork->szSenderName, sEntry.szSenderName, sizeof( pReplyWork->szSenderName ) );
            pReplyWork->dwSenderTitleID = sEntry.dwSenderTitleID;
            pReplyWork->qwSenderContext = sEntry.qwSenderContext;

            SYSTEMTIME systime;
            ::VariantTimeToSystemTime( sEntry.dtSentTime, &systime );

            FILETIME filetime;
            ::SystemTimeToFileTime( &systime, &filetime );

            pReplyWork->mtSentTime = FileTimeToMsgTime( &filetime );

            pReplyWork->wExpireMinutes = sEntry.wExpireMinutes;
            pReplyWork->cbDetails = sEntry.cbDetails;

            if (pCCtx->m_dwMsgType == QMSG_ENUM_MESSAGES_2)
            {
                memcpy( pReply2Work->szSubject, sEntry.szSubject, sizeof( pReply2Work->szSubject ) );
            }
        }
        else
        {
            // No rows left to process
            break;
        }
    }

    // The switchboard will resize the buffer down to its correct size once it adds transient messages,
    // we don't need to touch it here.

    hr = CResults.Clear();
    if (FAILED(hr))
    {
        goto lDone;
    }

    // OLE DB won't populate the return code until the rowset is released.  Webstore may or may not do the same, let's be safe.
    piRowset = NULL;

    // Check for a return
    if(FAILED((HRESULT)sParams.iRet))
    {
        hr = (DWORD) sParams.iRet;
        goto lDone;
    }

    // Success, set the output parameters
    pbWrite = pCCtx->m_pCReply->GetBuffer();
    ((Q_ENUM_MESSAGES_REPLY_MSG*)pbWrite)->cMessages = iRow;

lDone:
    pCCtx->m_fProcessed = TRUE;
    pCCtx->m_hr = hr;

    // If failed, report the hr and if it came from the stored proc
    if (FAILED(hr))
    {
        if(sParams.iRet != S_OK)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_295, "p_xmsg_user_message_enumerate returned failure hr=%X", hr );
        }
        else
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_296, "StoreEnumerateMessages failed hr=%X", hr );
        }
    }

    hr = m_pCSwitchboard->PostCompletion(pCCtx);
    XOMASSERT(SUCCEEDED(hr));
}

/*****************************************************************************

CProfileStore::StoreGetMessageSummary

Get summary information for the specified user message.  The result is sent
back via the switchboard's completion port to a callback function.

*****************************************************************************/
void CProfileStore::StoreGetMessageSummary(CGetMessageSummaryContext *pCCtx)
{
    XOMASSERT(m_pCSwitchboard != NULL);
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Going to SQL for StoreGetMessageSummary");

    HRESULT hr = S_OK;
    CComPtr<IRowset> piRowset = NULL;
    CWSODBWResult CResults(ErrorCallback);
    DWORD cRows = 0;

    CTCPCntVarBuffer *pCReply = NULL;
    BYTE *pbWrite = NULL;

    // Parameter structures
    struct sParams_t {
        INT iRet;
        QWORD qwUserID;
        DWORD dwMessageID;
    } sParams;

    static WSTCOMMANDPARAM rgwstcpParams[] = {
        {1, DBPARAMIO_OUTPUT, DBTYPE_I4,  sizeof(sParams.iRet), offsetof(sParams_t, iRet), NULL},
        {2, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwUserID), offsetof(sParams_t, qwUserID), NULL},
        {3, DBPARAMIO_INPUT,  DBTYPE_I4,  sizeof(sParams.dwMessageID), offsetof(sParams_t, dwMessageID), NULL},
    };

    WSTCOMMANDINFO wstciParams = {
        sizeof(sParams),
        &sParams,
        ARRAY_ELEMENTS(rgwstcpParams),
        rgwstcpParams
    };

    static WCHAR wszCmd[] = L"{ ? = call p_xmsg_user_message_summary( ?, ? ) }";

    // Set the parameters
    sParams.iRet = S_OK;
    sParams.qwUserID = pCCtx->m_qwUserID;
    sParams.dwMessageID = pCCtx->m_dwMessageID;

    // Execute the proc
    hr = m_piCommand->Execute(
        WRITETHENREAD_COMMANDTYPE,
        GetUserBucket(pCCtx->m_qwUserID),
        wszCmd,
        &wstciParams,
        (IUnknown **)&piRowset,
        NULL,
        DBGUID_DEFAULT,
        IID_IRowset);
    if (FAILED(hr))
    {
        // Run the error through the OLEDB wrapper to get details
        CResults.GetErrorHandler()->HandleError(hr, "StoreGetMessageSummary Failed to execute stored proc");
        goto lDone;
    }

    // Attach the wrapper
    hr = CResults.InitializeWithIRowset(piRowset);
    if (FAILED(hr))
    {
        goto lDone;
    }

    struct sEntry_t {
        DWORD dwMessageID;
        BYTE bMessageType;
        DWORD dwMessageFlags;
        QWORD qwSenderID;
        DWORD dwSenderTitleID;
        QWORD qwSenderContext;
        CHAR szSenderName[ XONLINE_GAMERTAG_SIZE ];
        WCHAR szSubject[ XONLINE_MAX_SUBJECT_SIZE ];
        DATE dtSentTime;
        WORD wExpireMinutes;
        WORD cbDetails;
    } sEntry;

    // Bind
    {
        static DBBINDING _bind[] = {
            WSBIND(1, offsetof(sEntry_t, dwMessageID),     DBTYPE_I4,   0),
            WSBIND(2, offsetof(sEntry_t, bMessageType),    DBTYPE_I1,   0),
            WSBIND(3, offsetof(sEntry_t, dwMessageFlags),  DBTYPE_I4,   0),
            WSBIND(4, offsetof(sEntry_t, qwSenderID),      DBTYPE_I8,   0),
            WSBIND(5, offsetof(sEntry_t, dwSenderTitleID), DBTYPE_I4,   0),
            WSBIND(6, offsetof(sEntry_t, qwSenderContext), DBTYPE_I8,   0),
            WSBIND(7, offsetof(sEntry_t, szSenderName),    DBTYPE_STR,  XONLINE_GAMERTAG_SIZE),
            WSBIND(8, offsetof(sEntry_t, szSubject),       DBTYPE_WSTR,  XONLINE_MAX_SUBJECT_SIZE),
            WSBIND(9, offsetof(sEntry_t, dtSentTime),      DBTYPE_DATE, 0),
            WSBIND(10, offsetof(sEntry_t, wExpireMinutes), DBTYPE_I2,   0),
            WSBIND(11, offsetof(sEntry_t, cbDetails),      DBTYPE_I2,   0),
        };

        hr = CResults.SetBindings(_bind, ARRAY_ELEMENTS(_bind));
        if(FAILED(hr))
        {
            goto lDone;
        }
    }

    // Get the rows
    cRows = 1;

    hr = CResults.GetRows(&cRows, &sEntry, sizeof(sEntry_t));
    if(FAILED(hr))
    {
        goto lDone;
    }

    if (cRows <= 0)
    {
        XomTrace( PresenceDebug, L_ERROR, "p_xmsg_user_message_summary returned message not found" );
        hr = XONLINE_E_MESSAGE_INVALID_MESSAGE_ID; // Message not found
        goto lDone;
    }

    hr = CResults.Clear();
    if (FAILED(hr))
    {
        goto lDone;
    }

    // OLE DB won't populate the return code until the rowset is released.  Webstore may or may not do the same, let's be safe.
    piRowset = NULL;

    // Check for a return
    if(FAILED((HRESULT)sParams.iRet))
    {
        hr = (DWORD) sParams.iRet;
        goto lDone;
    }

    if (sEntry.bMessageType > pCCtx->m_bMaxKnownMsgType)
    {
        XomTrace(
            PresenceDebug,
            L_ERROR,
            "p_xmsg_user_message_summary message cannot be consumed by caller.  msgtype = %d, max specified = %d",
            sEntry.bMessageType,
            pCCtx->m_bMaxKnownMsgType);

        hr = XONLINE_E_MESSAGE_INVALID_MESSAGE_ID; // Message not found
        goto lDone;
    }

    DWORD dwBufferSize = sizeof( Q_MESSAGE_SUMMARY_REPLY_MSG );
    if (pCCtx->m_dwMsgType == QMSG_MESSAGE_SUMMARY_2)
    {
        dwBufferSize = sizeof( Q_MESSAGE_SUMMARY_2_REPLY_MSG );
    }

    // Allocate a buffer for the response
    pCReply = CTCPCntVarBuffer::CreateInstance( dwBufferSize );
    if (pCReply == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pbWrite = pCReply->GetBuffer();

    Q_MESSAGE_SUMMARY_REPLY_MSG *pReplyWork = (Q_MESSAGE_SUMMARY_REPLY_MSG *)pbWrite;
    Q_MESSAGE_SUMMARY_2_REPLY_MSG *pReply2Work = (Q_MESSAGE_SUMMARY_2_REPLY_MSG *)pbWrite;

    pReplyWork->summary.dwMessageID = sEntry.dwMessageID;
    pReplyWork->summary.bMessageType = sEntry.bMessageType;
    pReplyWork->summary.dwMessageFlags = sEntry.dwMessageFlags;
    pReplyWork->summary.qwSenderID = sEntry.qwSenderID;
    memcpy( pReplyWork->summary.szSenderName, sEntry.szSenderName, sizeof( pReplyWork->summary.szSenderName ) );
    pReplyWork->summary.dwSenderTitleID = sEntry.dwSenderTitleID;
    pReplyWork->summary.qwSenderContext = sEntry.qwSenderContext;

    SYSTEMTIME systime;
    ::VariantTimeToSystemTime( sEntry.dtSentTime, &systime );

    FILETIME filetime;
    ::SystemTimeToFileTime( &systime, &filetime );

    pReplyWork->summary.mtSentTime = FileTimeToMsgTime( &filetime );

    pReplyWork->summary.wExpireMinutes = sEntry.wExpireMinutes;
    pReplyWork->summary.cbDetails = sEntry.cbDetails;

    if (pCCtx->m_dwMsgType == QMSG_MESSAGE_SUMMARY_2)
    {
        memcpy( pReply2Work->summary.szSubject, sEntry.szSubject, sizeof( pReply2Work->summary.szSubject ) );
    }

    // Success, set the output parameters
    pCCtx->m_pCReply = pCReply;

lDone:
    pCCtx->m_fProcessed = TRUE;
    pCCtx->m_hr = hr;

    // If failed, report the hr and if it came from the stored proc
    if (FAILED(hr))
    {
        // Failed cleanup allocations
        SAFE_RELEASE(pCReply);

        pCCtx->m_pCReply = NULL;

        if( XONLINE_E_MESSAGE_INVALID_MESSAGE_ID != hr )
        {
            if(sParams.iRet != S_OK)
            {
                XomNtEvent(XEVENT_PRESENCE_CODE_297, "p_xmsg_user_message_summary returned failure hr=%X", hr );
            }
            else
            {
                XomNtEvent(XEVENT_PRESENCE_CODE_298, "StoreGetMessageSummary failed hr=%X", hr );
            }
        }
    }

    hr = m_pCSwitchboard->PostCompletion(pCCtx);
    XOMASSERT(SUCCEEDED(hr));
}

/*****************************************************************************

CProfileStore::StoreGetMessageDetails

Get extended information for the specified user message.  The result is sent
back via the switchboard's completion port to a callback function.

*****************************************************************************/
void CProfileStore::StoreGetMessageDetails(CGetMessageDetailsContext *pCCtx)
{
    XOMASSERT(m_pCSwitchboard != NULL);
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Going to SQL for StoreGetMessageDetails");

    HRESULT hr = S_OK;
    CComPtr<IRowset> piRowset = NULL;
    CWSODBWResult CResults(ErrorCallback);
    DWORD cRows = 0;

    CTCPCntVarBuffer *pCReply = NULL;
    BYTE *pbWrite = NULL;

    // Parameter structures
    struct sParams_t {
        INT iRet;
        QWORD qwUserID;
        DWORD dwMessageID;
        DWORD dwSetFlags;
        DWORD dwUnsetFlags;
    } sParams;

    static WSTCOMMANDPARAM rgwstcpParams[] = {
        {1, DBPARAMIO_OUTPUT, DBTYPE_I4,  sizeof(sParams.iRet), offsetof(sParams_t, iRet), NULL},
        {2, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwUserID), offsetof(sParams_t, qwUserID), NULL},
        {3, DBPARAMIO_INPUT,  DBTYPE_I4,  sizeof(sParams.dwMessageID), offsetof(sParams_t, dwMessageID), NULL},
        {4, DBPARAMIO_INPUT,  DBTYPE_I4,  sizeof(sParams.dwSetFlags), offsetof(sParams_t, dwSetFlags), NULL},
        {5, DBPARAMIO_INPUT,  DBTYPE_I4,  sizeof(sParams.dwUnsetFlags), offsetof(sParams_t, dwUnsetFlags), NULL},
    };

    WSTCOMMANDINFO wstciParams = {
        sizeof(sParams),
        &sParams,
        ARRAY_ELEMENTS(rgwstcpParams),
        rgwstcpParams
    };

    static WCHAR wszCmd[] = L"{ ? = call p_xmsg_user_message_details( ?, ?, ?, ? ) }";

    // Set the parameters
    sParams.iRet = S_OK;
    sParams.qwUserID = pCCtx->m_qwUserID;
    sParams.dwMessageID = pCCtx->m_dwMessageID;
    sParams.dwSetFlags = pCCtx->m_dwSetFlags;
    sParams.dwUnsetFlags = pCCtx->m_dwUnsetFlags;

    // Execute the proc
    hr = m_piCommand->Execute(
        WRITETHENREAD_COMMANDTYPE,
        GetUserBucket(pCCtx->m_qwUserID),
        wszCmd,
        &wstciParams,
        (IUnknown **)&piRowset,
        NULL,
        DBGUID_DEFAULT,
        IID_IRowset);
    if (FAILED(hr))
    {
        // Run the error through the OLEDB wrapper to get details
        CResults.GetErrorHandler()->HandleError(hr, "StoreGetMessageDetails Failed to execute stored proc");
        goto lDone;
    }

    // Attach the wrapper
    hr = CResults.InitializeWithIRowset(piRowset);
    if (FAILED(hr))
    {
        goto lDone;
    }

    struct sEntry_t {
        DWORD dwMessageID;
        BYTE bMessageType;
        DWORD dwMessageFlags;
        QWORD qwSenderID;
        DWORD dwSenderTitleID;
        QWORD qwSenderContext;
        CHAR szSenderName[ XONLINE_GAMERTAG_SIZE ];
        DATE dtSentTime;
        WORD wExpireMinutes;
        WORD cbDetails;
        BYTE pbDetails[ XONLINE_MAX_MESSAGE_DETAILS ];
    } sEntry;

    // Bind
    {
        static DBBINDING _bind[] = {
            WSBIND(1, offsetof(sEntry_t, dwMessageID),     DBTYPE_I4,   0),
            WSBIND(2, offsetof(sEntry_t, bMessageType),    DBTYPE_I1,   0),
            WSBIND(3, offsetof(sEntry_t, dwMessageFlags),  DBTYPE_I4,   0),
            WSBIND(4, offsetof(sEntry_t, qwSenderID),      DBTYPE_I8,   0),
            WSBIND(5, offsetof(sEntry_t, dwSenderTitleID), DBTYPE_I4,   0),
            WSBIND(6, offsetof(sEntry_t, qwSenderContext), DBTYPE_I8,   0),
            WSBIND(7, offsetof(sEntry_t, szSenderName),    DBTYPE_STR,  XONLINE_GAMERTAG_SIZE),
            WSBIND(8, offsetof(sEntry_t, dtSentTime),      DBTYPE_DATE, 0),
            WSBIND(9, offsetof(sEntry_t, wExpireMinutes),  DBTYPE_I2,   0),
            WSBIND(10, offsetof(sEntry_t, cbDetails),       DBTYPE_I2,   0),
            WSBIND(11, offsetof(sEntry_t, pbDetails),      DBTYPE_BYTES, XONLINE_MAX_MESSAGE_DETAILS),
        };

        hr = CResults.SetBindings(_bind, ARRAY_ELEMENTS(_bind));
        if(FAILED(hr))
        {
            goto lDone;
        }
    }

    // Get the rows
    cRows = 1;

    hr = CResults.GetRows(&cRows, &sEntry, sizeof(sEntry_t));
    if(FAILED(hr))
    {
        goto lDone;
    }

    if (cRows <= 0)
    {
        XomTrace( PresenceDebug, L_ERROR, "p_xmsg_user_message_details returned message not found" );
        hr = XONLINE_E_MESSAGE_INVALID_MESSAGE_ID; // Message not found
        goto lDone;
    }

    hr = CResults.Clear();
    if (FAILED(hr))
    {
        goto lDone;
    }

    // OLE DB won't populate the return code until the rowset is released.  Webstore may or may not do the same, let's be safe.
    piRowset = NULL;

    // Check for a return
    if(FAILED((HRESULT)sParams.iRet))
    {
        hr = (DWORD) sParams.iRet;
        goto lDone;
    }

    // Protect ourselves from bad data
    sEntry.cbDetails = (WORD) min( sEntry.cbDetails, XONLINE_MAX_MESSAGE_DETAILS );

    pCReply = CTCPCntVarBuffer::CreateInstance( sizeof(Q_MESSAGE_DETAILS_REPLY_MSG) + sEntry.cbDetails );
    if (pCReply == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pbWrite = pCReply->GetBuffer();

    Q_MESSAGE_DETAILS_REPLY_MSG *pReplyWork = (Q_MESSAGE_DETAILS_REPLY_MSG *)pbWrite;

    pReplyWork->summary.dwMessageID = sEntry.dwMessageID;
    pReplyWork->summary.bMessageType = sEntry.bMessageType;
    pReplyWork->summary.dwMessageFlags = sEntry.dwMessageFlags;
    pReplyWork->summary.qwSenderID = sEntry.qwSenderID;
    memcpy( pReplyWork->summary.szSenderName, sEntry.szSenderName, sizeof( pReplyWork->summary.szSenderName ) );
    pReplyWork->summary.dwSenderTitleID = sEntry.dwSenderTitleID;
    pReplyWork->summary.qwSenderContext = sEntry.qwSenderContext;

    SYSTEMTIME systime;
    ::VariantTimeToSystemTime( sEntry.dtSentTime, &systime );

    FILETIME filetime;
    ::SystemTimeToFileTime( &systime, &filetime );

    pReplyWork->summary.mtSentTime = FileTimeToMsgTime( &filetime );

    pReplyWork->summary.wExpireMinutes = sEntry.wExpireMinutes;
    pReplyWork->summary.cbDetails = sEntry.cbDetails;

    memcpy( pReplyWork + 1, sEntry.pbDetails, sEntry.cbDetails );

    // Success, set the output parameters
    pCCtx->m_pCReply = pCReply;

lDone:
    pCCtx->m_fProcessed = TRUE;
    pCCtx->m_hr = hr;

    // If failed, report the hr and if it came from the stored proc
    if (FAILED(hr))
    {
        // Failed cleanup allocations
        SAFE_RELEASE(pCReply);

        pCCtx->m_pCReply = NULL;

        if( XONLINE_E_MESSAGE_INVALID_MESSAGE_ID != hr )
        {
            if(sParams.iRet != S_OK)
            {
                XomNtEvent(XEVENT_PRESENCE_CODE_299, "p_xmsg_user_message_details returned failure hr=%X", hr );
            }
            else
            {
                XomNtEvent(XEVENT_PRESENCE_CODE_300, "StoreGetMessageDetails failed hr=%X", hr );
            }
        }
    }

    hr = m_pCSwitchboard->PostCompletion(pCCtx);
    XOMASSERT(SUCCEEDED(hr));
}

/*****************************************************************************

CProfileStore::StoreDeleteMessage

Delete the specified user message.  The result is sent back via the
switchboard's completion port to a callback function.

*****************************************************************************/
void CProfileStore::StoreDeleteMessage(CDeleteMessageContext *pCCtx)
{
    XOMASSERT(m_pCSwitchboard != NULL);
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Going to SQL for StoreDeleteMessage");

    HRESULT hr = S_OK;
    CComPtr<IRowset> piRowset = NULL;

    // Parameter structures
    struct sParams_t {
        INT iRet;
        QWORD qwUserID;
        DWORD dwMessageID;
        BOOL fBlockSender;
        QWORD qwSenderID;
    } sParams;

    static WSTCOMMANDPARAM rgwstcpParams[] = {
        {1, DBPARAMIO_OUTPUT, DBTYPE_I4,  sizeof(sParams.iRet),         offsetof(sParams_t, iRet),         NULL},
        {2, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwUserID),     offsetof(sParams_t, qwUserID),     NULL},
        {3, DBPARAMIO_INPUT,  DBTYPE_I4,  sizeof(sParams.dwMessageID),  offsetof(sParams_t, dwMessageID),  NULL},
        {4, DBPARAMIO_INPUT,  DBTYPE_I1,  sizeof(sParams.fBlockSender), offsetof(sParams_t, fBlockSender), NULL},
        {5, DBPARAMIO_OUTPUT, DBTYPE_I8,  sizeof(sParams.qwSenderID),   offsetof(sParams_t, qwSenderID),   NULL},
    };

    WSTCOMMANDINFO wstciParams = {
        sizeof(sParams),
        &sParams,
        ARRAY_ELEMENTS(rgwstcpParams),
        rgwstcpParams
    };

    static WCHAR wszCmd[] = L"{ ? = call p_xmsg_user_message_delete( ?, ?, ?, ? ) }";

    // Set the parameters
    sParams.iRet = S_OK;
    sParams.qwUserID = pCCtx->m_qwUserID;
    sParams.dwMessageID = pCCtx->m_dwMessageID;
    sParams.fBlockSender = pCCtx->m_dwFlags & XMSG_DELETE_MESSAGE_FLAG_BLOCK_SENDER;
    sParams.qwSenderID = 0;

    // Execute the proc
    hr = m_piCommand->Execute(
        WRITEONLY_COMMANDTYPE,
        GetUserBucket(pCCtx->m_qwUserID),
        wszCmd,
        &wstciParams,
        (IUnknown **)&piRowset,
        NULL,
        DBGUID_DEFAULT,
        IID_IRowset);

    // OLE DB won't populate the return code until the rowset is released.  Webstore may or may not do the same, let's be safe.
    piRowset = NULL;

    if (FAILED(hr))
    {
        // Run the error through the OLEDB wrapper to get details
        CWSODBWResult CResults(ErrorCallback);
        CResults.GetErrorHandler()->HandleError(hr, "StoreDeleteMessage Failed to execute stored proc");
        goto lDone;
    }

    // Check for a return
    if(FAILED((HRESULT)sParams.iRet))
    {
        hr = (DWORD) sParams.iRet;
        goto lDone;
    }

    if( S_FALSE == (HRESULT)sParams.iRet )
    {
        XomTrace( PresenceDebug, L_ERROR, "p_xmsg_user_message_delete returned message not found" );
        hr = XONLINE_E_MESSAGE_INVALID_MESSAGE_ID;
        goto lDone;
    }

    pCCtx->m_qwSenderID = sParams.qwSenderID;

lDone:
    pCCtx->m_fProcessed = TRUE;
    pCCtx->m_hr = hr;

    // If failed, report the hr and if it came from the stored proc
    if( FAILED( hr ) && XONLINE_E_MESSAGE_INVALID_MESSAGE_ID != hr )
    {
        if(sParams.iRet != S_OK)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_301, "p_xmsg_user_message_delete returned failure hr=%X", hr );
        }
        else
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_302, "StoreDeleteMessage failed hr=%X", hr );
        }
    }

    hr = m_pCSwitchboard->PostCompletion(pCCtx);
    XOMASSERT(SUCCEEDED(hr));
}

/*****************************************************************************

CProfileStore::StoreSendMessage

Send a user-to-user message.  The result is sent back via the switchboard's
completion port to a callback function.

*****************************************************************************/
void CProfileStore::StoreSendMessage(CSendMessageInternalContext *pCCtx)
{
    XOMASSERT(m_pCSwitchboard != NULL);
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Going to SQL for StoreSendMessage");

    HRESULT hr = S_OK;
    CComPtr<IRowset> piRowset = NULL;
    BOOL fSomeFailed = FALSE;

    // Parameter structures
    struct sParams_t {
        INT iRet;
        QWORD qwSenderID;
        QWORD qwRecipientID;
        DWORD dwSenderTitleID;
        QWORD qwSenderContext;
        BYTE  bMessageType;
        DWORD dwMessageFlags;
        CHAR  szSenderName[XONLINE_GAMERTAG_SIZE];
        WCHAR szSubject[64];    // database size is bigger than XONLINE_MAX_SUBJECT_SIZE, but not this big.. It will truncate
        WORD  wExpireMinutes;
        WORD  cbDetails;
        BYTE  pbDetails[ XONLINE_MAX_MESSAGE_DETAILS ];
        DWORD dwMessageID;
    } sParams;

    // NOTE: This can't be static since it has dynamically written members and can be used by multiple threads at once
    WSTCOMMANDPARAM rgwstcpParams[] =
    {
        { 1,  DBPARAMIO_OUTPUT, DBTYPE_I4,    sizeof(sParams.iRet),                 offsetof(sParams_t, iRet),             NULL, NULL },
        { 2,  DBPARAMIO_INPUT,  DBTYPE_I8,    sizeof(sParams.qwSenderID),           offsetof(sParams_t, qwSenderID),       NULL, NULL },
        { 3,  DBPARAMIO_INPUT,  DBTYPE_I8,    sizeof(sParams.qwRecipientID),        offsetof(sParams_t, qwRecipientID),    NULL, NULL },
        { 4,  DBPARAMIO_INPUT,  DBTYPE_I4,    sizeof(sParams.dwSenderTitleID),      offsetof(sParams_t, dwSenderTitleID),  NULL, NULL },
        { 5,  DBPARAMIO_INPUT,  DBTYPE_I8,    sizeof(sParams.qwSenderContext),      offsetof(sParams_t, qwSenderContext),  NULL, NULL },
        { 6,  DBPARAMIO_INPUT,  DBTYPE_I1,    sizeof(sParams.bMessageType),         offsetof(sParams_t, bMessageType),     NULL, NULL },
        { 7,  DBPARAMIO_INPUT,  DBTYPE_I4,    sizeof(sParams.dwMessageFlags),       offsetof(sParams_t, dwMessageFlags),   NULL, NULL },
        { 8,  DBPARAMIO_INPUT,  DBTYPE_STR,   sizeof(sParams.szSenderName),         offsetof(sParams_t, szSenderName),     NULL, NULL },
        { 9,  DBPARAMIO_INPUT,  DBTYPE_WSTR,  sizeof(sParams.szSubject),            offsetof(sParams_t, szSubject),        NULL, NULL },
        { 10, DBPARAMIO_INPUT,  DBTYPE_I2,    sizeof(sParams.wExpireMinutes),       offsetof(sParams_t, wExpireMinutes),   NULL, NULL },
        { 11, DBPARAMIO_INPUT,  DBTYPE_I2,    sizeof(sParams.cbDetails),            offsetof(sParams_t, cbDetails),        NULL, NULL },
        { 12, DBPARAMIO_INPUT,  DBTYPE_BYTES, 0, /* dynamically written */          offsetof(sParams_t, pbDetails),        NULL, NULL },
        { 13, DBPARAMIO_OUTPUT, DBTYPE_I4,    sizeof(sParams.dwMessageID),          offsetof(sParams_t, dwMessageID),      NULL, NULL },
    };
    XOMASSERT( 0 == rgwstcpParams[ 11 ].paramSize ); // Make sure the location we overwrite stays up to date
    rgwstcpParams[ 11 ].paramSize = min( XONLINE_MAX_MESSAGE_DETAILS, max( pCCtx->m_Message.cbDetails, 1 ) );

    WSTCOMMANDINFO wstciParams = {
        sizeof(sParams),
        &sParams,
        ARRAY_ELEMENTS(rgwstcpParams),
        rgwstcpParams
    };

    static WCHAR wszCmd[] = L"{ ? = call p_xmsg_user_message_send( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? ) }";

    // Set the parameters that are the same for each recipient
    sParams.qwSenderID = pCCtx->m_Message.qwSenderID;
    sParams.dwSenderTitleID = pCCtx->m_Message.dwSenderTitleID;
    sParams.qwSenderContext = pCCtx->m_Message.qwSenderContext;
    sParams.bMessageType = pCCtx->m_Message.bMessageType;
    sParams.dwMessageFlags = pCCtx->m_Message.dwMessageFlags;
    strncpy( sParams.szSenderName, pCCtx->m_Message.szSenderName, sizeof( pCCtx->m_Message.szSenderName ) );
    sParams.szSenderName[ sizeof( pCCtx->m_Message.szSenderName ) ] = '\0';
    sParams.szSubject[0] = '\0';
    sParams.wExpireMinutes = pCCtx->m_Message.wExpireMinutes;
    sParams.cbDetails = pCCtx->m_Message.cbDetails;
    memcpy( sParams.pbDetails, pCCtx->m_rgbDetails, min( XONLINE_MAX_MESSAGE_DETAILS, pCCtx->m_Message.cbDetails ) );

    // Get the subject field from the text property, if any
    if (pCCtx->m_Message.cbDetails > 0)
    {
        XMSG_PROPERTY_STRING *pData;
        XOMASSERT(XOnlineMessageGetPropType(XONLINE_MSG_PROP_TEXT) == XONLINE_MSG_PROP_TYPE_STRING);

        pData = (XMSG_PROPERTY_STRING *)GetMessageProperty( XONLINE_MSG_PROP_TEXT, (XMSG_DETAILS *)pCCtx->m_rgbDetails );

        if (NULL != pData)
        {
            // Dillemma: We want to translate enough of the text to fill the string subject in the DB, but don't want to
            //  allocate 4K of stack space to hold the entire string. szSubject is defined as "big enough" and we will
            //  translate 64 bytes of data, which could result in 32 unicode chars, or 64 ascii chars.
            int cch = MultiByteToWideChar(CP_UTF8, 0, (LPCSTR)(pData + 1), min(pData->cbString, 64), sParams.szSubject, sizeof(sParams.szSubject)/sizeof(WCHAR));
            sParams.szSubject[cch - 1] = '\0';  // ensure it is NULL terminated
        }
    }

    // Sending a zero sized binary doesn't go over too well, so if it is zero length, we bump the size up to 1
    // above when rgwstcpParams is set up, and then place a single zero in the buffer here.
    if( 0 == pCCtx->m_Message.cbDetails )
    {
        sParams.pbDetails[ 0 ] = 0;
    }

    // Send the message to each recipient
    for( DWORD iRecipient = 0; iRecipient < pCCtx->m_Message.cRecipients - pCCtx->m_cForwardIDs; iRecipient++ )
    {
        // check for an earlier error.
        hr = pCCtx->m_RecipientResults[iRecipient].hrRecipient;
        if (FAILED(hr))
        {
            fSomeFailed = TRUE;
        }
        else
        {
            // Set the parameters that change per recipient
            sParams.iRet = S_OK;
            sParams.qwRecipientID = pCCtx->m_rgqwRecipientIDs[ iRecipient ];
            sParams.dwMessageID = 0;

            // Execute the proc
            hr = m_piCommand->Execute(
                WRITEONLY_COMMANDTYPE,
                GetUserBucket(pCCtx->m_rgqwRecipientIDs[ iRecipient ]),
                wszCmd,
                &wstciParams,
                (IUnknown **)&piRowset,
                NULL,
                DBGUID_DEFAULT,
                IID_IRowset);

            // OLE DB won't populate the return code until the rowset is released.  Webstore may or may not do the same, let's be safe.
            piRowset = NULL;

            if (FAILED(hr))
            {
                // Run the error through the OLEDB wrapper to get details
                CWSODBWResult CResults(ErrorCallback);
                CResults.GetErrorHandler()->HandleError(hr, "StoreSendMessage Failed to execute stored proc");

                XomNtEvent( XEVENT_PRESENCE_CODE_303, "StoreSendMessage failed hr=%X, user=%I64X", hr, sParams.qwRecipientID );

                // Note the failure for this recipient
                pCCtx->m_RecipientResults[ iRecipient ].hrRecipient = hr;
                fSomeFailed = TRUE;
            }
            else if( FAILED((HRESULT)sParams.iRet) )
            {
                if( (HRESULT)sParams.iRet != XONLINE_E_MESSAGE_SENDER_BLOCKED &&
                    (HRESULT)sParams.iRet != XONLINE_E_MESSAGE_USER_OPTED_OUT )
                {
                    XomNtEvent( XEVENT_PRESENCE_CODE_304, "p_xmsg_user_message_send returned failure hr=%X, user=%I64X", (HRESULT)sParams.iRet, sParams.qwRecipientID );
                }
                else
                {
                    XomTrace( PresenceDebug, L_ERROR, "p_xmsg_user_message_send returned failure hr=%X, user=%I64X", (HRESULT)sParams.iRet, sParams.qwRecipientID );
                }

                // Note the failure for this recipient
                pCCtx->m_RecipientResults[ iRecipient ].hrRecipient = (HRESULT)sParams.iRet;
                fSomeFailed = TRUE;
            }
            else
            {
                // If it succeeded, we got the message ID back
                pCCtx->m_RecipientResults[ iRecipient ].dwMessageID = sParams.dwMessageID;
            }
        }

        pCCtx->m_RecipientResults[ iRecipient ].qwUserID = pCCtx->m_rgqwRecipientIDs[ iRecipient ];
    }

    // NOTE: The overall call will always succeed by the time we get to this function, but individual
    // failures will be noted per recipient.  If there is any failure we will return S_FALSE.
    if( fSomeFailed )
    {
        hr = S_FALSE;
    }
    else
    {
        hr = S_OK;
    }

    pCCtx->m_eState = CSendMessageInternalContext::SendMessageState_Complete;
    pCCtx->m_hr = hr;

    // If failed, report the hr and if it came from the stored proc
    if (FAILED(hr))
    {
        if(sParams.iRet != S_OK)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_305, "p_xmsg_user_message_send returned failure hr=%X", hr );
        }
        else
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_306, "StoreSendMessage failed hr=%X", hr );
        }
    }

    // Call directly into the next state of the machine, since it is also served by the SQL Threadpool
    hr = m_pCSwitchboard->PostCompletion(pCCtx);

    XOMASSERT(SUCCEEDED(hr));
}


/*****************************************************************************

CProfileStore::StoreRevokeMessage

Revoke a user-to-user message.  The result is sent back via the switchboard's
completion port to a callback function.

*****************************************************************************/
void CProfileStore::StoreRevokeMessage( CRevokeMessageContext *pCCtx )
{
    XOMASSERT(m_pCSwitchboard != NULL);
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Going to SQL for StoreRevokeMessage");

    HRESULT hr = S_OK;
    CComPtr<IRowset> piRowset = NULL;

    // Parameter structures
    struct sParams_t {
        INT iRet;
        QWORD qwSenderID;
        QWORD qwRecipientID;
        QWORD qwSenderContext;
        DWORD dwMessageID;
        DWORD dwFlags;
        BYTE bMessageType;
        DWORD dwRetMessageID;
    } sParams;

    static WSTCOMMANDPARAM rgwstcpParams[] = {
        { 1,  DBPARAMIO_OUTPUT, DBTYPE_I4, sizeof(sParams.iRet),            offsetof(sParams_t, iRet),            NULL },
        { 2,  DBPARAMIO_INPUT,  DBTYPE_I8, sizeof(sParams.qwSenderID),      offsetof(sParams_t, qwSenderID),      NULL },
        { 3,  DBPARAMIO_INPUT,  DBTYPE_I8, sizeof(sParams.qwRecipientID),   offsetof(sParams_t, qwRecipientID),   NULL },
        { 4,  DBPARAMIO_INPUT,  DBTYPE_I8, sizeof(sParams.qwSenderContext), offsetof(sParams_t, qwSenderContext), NULL },
        { 5,  DBPARAMIO_INPUT,  DBTYPE_I4, sizeof(sParams.dwMessageID),     offsetof(sParams_t, dwMessageID),     NULL },
        { 6,  DBPARAMIO_INPUT,  DBTYPE_I4, sizeof(sParams.dwFlags),         offsetof(sParams_t, dwFlags),         NULL },
        { 7,  DBPARAMIO_INPUT,  DBTYPE_I1, sizeof(sParams.bMessageType),    offsetof(sParams_t, bMessageType),    NULL },
        { 8,  DBPARAMIO_OUTPUT, DBTYPE_I4, sizeof(sParams.dwRetMessageID),  offsetof(sParams_t, dwRetMessageID),  NULL },
    };

    WSTCOMMANDINFO wstciParams = {
        sizeof(sParams),
        &sParams,
        ARRAY_ELEMENTS(rgwstcpParams),
        rgwstcpParams
    };

    static WCHAR wszCmd[] = L"{ ? = call p_xmsg_user_message_revoke( ?, ?, ?, ?, ?, ?, ? ) }";

    // Set the parameters that are the same for each recipient
    sParams.iRet = S_OK;
    sParams.qwSenderID = pCCtx->m_Message.qwSenderID;
    sParams.bMessageType = pCCtx->m_Message.bMessageType;
    sParams.qwSenderContext = pCCtx->m_Message.qwSenderContext;
    sParams.dwFlags = pCCtx->m_Message.dwFlags;

    // Revoke the message from each recipient
    for( DWORD iRecipient = 0; iRecipient < pCCtx->m_Message.cRecipients; iRecipient++ )
    {
        // Message ID from failed send not allowed
        if( pCCtx->m_rgRecipients[ iRecipient ].dwMessageID & XONLINE_MSG_ID_SEND_FAILED )
        {
            // The caller has handed us the failed result of a send for this recipient.  We won't
            // fail the whole call over it, but let them know some failed in the reply HRESULT.
            pCCtx->m_hrRecipient[ iRecipient ] = XONLINE_E_MESSAGE_INVALID_MESSAGE_ID;
            continue;
        }

        // Set the parameters that change per recipient
        sParams.iRet = S_OK;
        sParams.qwRecipientID = pCCtx->m_rgRecipients[ iRecipient ].qwUserID;
        sParams.dwMessageID = pCCtx->m_rgRecipients[ iRecipient ].dwMessageID;

        // Execute the proc
        hr = m_piCommand->Execute(
            WRITEONLY_COMMANDTYPE,
            GetUserBucket( pCCtx->m_rgRecipients[ iRecipient ].qwUserID ),
            wszCmd,
            &wstciParams,
            (IUnknown **)&piRowset,
            NULL,
            DBGUID_DEFAULT,
            IID_IRowset);

        // OLE DB won't populate the return code or output values until the rowset is released.  Webstore may or may not do the same, let's be safe.
        piRowset = NULL;

        if (FAILED(hr))
        {
            // Run the error through the OLEDB wrapper to get details
            CWSODBWResult CResults(ErrorCallback);
            CResults.GetErrorHandler()->HandleError(hr, "StoreRevokeMessage Failed to execute stored proc");

            XomNtEvent( XEVENT_PRESENCE_CODE_307, "StoreRevokeMessage failed hr=%X, user=%I64X", hr, sParams.qwRecipientID );

            // Note the failure for this recipient
            pCCtx->m_hrRecipient[ iRecipient ] = hr;
        }
        else if( FAILED((HRESULT)sParams.iRet) )
        {
            XomNtEvent( XEVENT_PRESENCE_CODE_308, "p_xmsg_user_message_revoke returned failure hr=%X, user=%I64X", (HRESULT)sParams.iRet, sParams.qwRecipientID );

            // Note the failure for this recipient
            pCCtx->m_hrRecipient[ iRecipient ] = (HRESULT)sParams.iRet;
        }
        else if( S_FALSE == ((HRESULT)sParams.iRet) )
        {
            XomTrace( PresenceDebug, L_WARNING, "p_xmsg_user_message_revoke found no message to revoke, returning XONLINE_E_MESSAGE_INVALID_MESSAGE_ID, user=%I64X", sParams.qwRecipientID );

            // Note the failure for this recipient
            pCCtx->m_hrRecipient[ iRecipient ] = XONLINE_E_MESSAGE_INVALID_MESSAGE_ID;
        }
        else
        {
            XOMASSERT( 0 == pCCtx->m_rgRecipients[ iRecipient ].dwMessageID || sParams.dwRetMessageID == pCCtx->m_rgRecipients[ iRecipient ].dwMessageID );
            XOMASSERT( 0 != sParams.dwRetMessageID );

            // Note the message ID we found so that we can send a QVal on it
            pCCtx->m_rgRecipients[ iRecipient ].dwMessageID = sParams.dwRetMessageID;
            pCCtx->m_hrRecipient[ iRecipient ] = S_OK;
        }
    }

    pCCtx->m_fProcessed = TRUE;

    hr = m_pCSwitchboard->PostCompletion(pCCtx);
    XOMASSERT(SUCCEEDED(hr));
}

/*****************************************************************************

CProfileStore::StoreDeleteUserTitle

Delete a title from a user's list of owned titles.  The result is sent back
via the switchboard's completion port to a callback function.

*****************************************************************************/
void CProfileStore::StoreDeleteUserTitle(CDeleteUserTitleContext *pCCtx)
{
    XOMASSERT(m_pCSwitchboard != NULL);
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Going to SQL for StoreDeleteUserTitle");

    HRESULT hr = S_OK;
    CComPtr<IRowset> piRowset = NULL;

    // Parameter structures
    struct sParams_t {
        INT iRet;
        QWORD qwUserID;
        DWORD dwTitleID;
    } sParams;

    static WSTCOMMANDPARAM rgwstcpParams[] = {
        {1, DBPARAMIO_OUTPUT, DBTYPE_I4,  sizeof(sParams.iRet), offsetof(sParams_t, iRet), NULL},
        {2, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwUserID), offsetof(sParams_t, qwUserID), NULL},
        {3, DBPARAMIO_INPUT,  DBTYPE_I4,  sizeof(sParams.dwTitleID), offsetof(sParams_t, dwTitleID), NULL},
    };

    WSTCOMMANDINFO wstciParams = {
        sizeof(sParams),
        &sParams,
        ARRAY_ELEMENTS(rgwstcpParams),
        rgwstcpParams
    };

    static WCHAR wszCmd[] = L"{ ? = call p_xmsg_user_title_delete( ?, ? ) }";

    // Set the parameters
    sParams.iRet = S_OK;
    sParams.qwUserID = pCCtx->m_qwUserID;
    sParams.dwTitleID = pCCtx->m_dwTitleID;

    // Execute the proc
    hr = m_piCommand->Execute(
        WRITEONLY_COMMANDTYPE,
        GetUserBucket(pCCtx->m_qwUserID),
        wszCmd,
        &wstciParams,
        (IUnknown **)&piRowset,
        NULL,
        DBGUID_DEFAULT,
        IID_IRowset);

    // OLE DB won't populate the return code until the rowset is released.  Webstore may or may not do the same, let's be safe.
    piRowset = NULL;

    if (FAILED(hr))
    {
        // Run the error through the OLEDB wrapper to get details
        CWSODBWResult CResults(ErrorCallback);
        CResults.GetErrorHandler()->HandleError(hr, "StoreDeleteUserTitle Failed to execute stored proc");
        goto lDone;
    }

    // Check for a return
    if(FAILED((HRESULT)sParams.iRet))
    {
        hr = (DWORD) sParams.iRet;
        goto lDone;
    }
    else if( S_FALSE == (HRESULT)sParams.iRet )
    {
        XomTrace( PresenceDebug, L_ERROR, "p_xmsg_user_title_delete returned title not found" );
        hr = XONLINE_E_MESSAGE_INVALID_TITLE_ID;
        goto lDone;
    }

lDone:
    pCCtx->m_fProcessed = TRUE;
    pCCtx->m_hr = hr;

    // If failed, report the hr and if it came from the stored proc
    if( FAILED( hr ) && XONLINE_E_MESSAGE_INVALID_TITLE_ID != hr )
    {
        if(sParams.iRet != S_OK)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_309, "p_xmsg_user_title_delete returned failure hr=%X", hr );
        }
        else
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_310, "StoreDeleteUserTitle failed hr=%X", hr );
        }
    }

    hr = m_pCSwitchboard->PostCompletion(pCCtx);
    XOMASSERT(SUCCEEDED(hr));
}

/*****************************************************************************

CProfileStore::StoreEnumerateUserTitles

Enumerate a user's list of owned titles.  The result is sent back via the
switchboard's completion port to a callback function.

*****************************************************************************/
void CProfileStore::StoreEnumerateUserTitles(CEnumerateUserTitlesContext *pCCtx)
{
    XOMASSERT(m_pCSwitchboard != NULL);
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Going to SQL for StoreEnumerateUserTitles");

    HRESULT hr = S_OK;
    CComPtr<IRowset> piRowset = NULL;
    CWSODBWResult CResults(ErrorCallback);
    DWORD cRows = 0;

    CTCPCntVarBuffer *pCReply = NULL;
    DWORD cbReply = 0;
    BYTE *pbWrite = NULL;
    WORD cTitles = 0;

    // Parameter structures
    struct sParams_t {
        INT iRet;
        QWORD qwUserID;
    } sParams;

    static WSTCOMMANDPARAM rgwstcpParams[] = {
        {1, DBPARAMIO_OUTPUT, DBTYPE_I4,  sizeof(sParams.iRet), offsetof(sParams_t, iRet), NULL},
        {2, DBPARAMIO_INPUT, DBTYPE_I8,  sizeof(sParams.qwUserID), offsetof(sParams_t, qwUserID), NULL},
    };

    WSTCOMMANDINFO wstciParams = {
        sizeof(sParams),
        &sParams,
        ARRAY_ELEMENTS(rgwstcpParams),
        rgwstcpParams
    };

    static WCHAR wszCmd[] = L"{ ? = call p_xmsg_user_title_enumerate( ? ) }";

    // Set the parameters
    sParams.iRet = S_OK;
    sParams.qwUserID = pCCtx->m_qwUserID;

    // Execute the proc
    hr = m_piCommand->Execute(
        WRITETHENREAD_COMMANDTYPE,
        GetUserBucket(pCCtx->m_qwUserID),
        wszCmd,
        &wstciParams,
        (IUnknown **)&piRowset,
        NULL,
        DBGUID_DEFAULT,
        IID_IRowset);
    if (FAILED(hr))
    {
        // Run the error through the OLEDB wrapper to get details
        CResults.GetErrorHandler()->HandleError(hr, "StoreEnumerateUserTitles Failed to execute stored proc");
        goto lDone;
    }

    // Attach the wrapper
    hr = CResults.InitializeWithIRowset(piRowset);
    if (FAILED(hr))
    {
        goto lDone;
    }

    struct sEntry_t {
        DWORD dwTitleID;
        DATE  dtLastLogon;
        DWORD dwFlags;
    } sEntry;

    // Allocate a reply buffer
    pCReply = CTCPCntVarBuffer::CreateInstance( sizeof(Q_ENUM_TITLES_REPLY_MSG) + ( sizeof( Q_USER_TITLE ) * MAX_RETURNED_USER_TITLES ) );
    if (pCReply == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    cbReply = sizeof(Q_ENUM_TITLES_REPLY_MSG);
    pbWrite = pCReply->GetBuffer() + sizeof(Q_ENUM_TITLES_REPLY_MSG);

    // Bind
    {
        static DBBINDING _bind[] = {
            WSBIND(1, offsetof(sEntry_t, dwTitleID),   DBTYPE_I4, 0),
            WSBIND(2, offsetof(sEntry_t, dtLastLogon), DBTYPE_DATE, 0),
            WSBIND(3, offsetof(sEntry_t, dwFlags),     DBTYPE_I4, 0),
        };

        hr = CResults.SetBindings(_bind, ARRAY_ELEMENTS(_bind));
        if(FAILED(hr))
        {
            goto lDone;
        }
    }

    // Get the rows
    for(DWORD iRow = 0; iRow < MAX_RETURNED_USER_TITLES; iRow++)
    {
        cRows = 1;

        hr = CResults.GetRows(&cRows, &sEntry, sizeof(sEntry_t));
        if(FAILED(hr))
        {
            goto lDone;
        }

        if (cRows > 0)
        {
            Q_USER_TITLE* pUserTitle = (Q_USER_TITLE*) pbWrite;

            pUserTitle->dwTitleID = sEntry.dwTitleID;
            pUserTitle->dwFlags = sEntry.dwFlags;

            SYSTEMTIME systime;
            ::VariantTimeToSystemTime( sEntry.dtLastLogon, &systime );
            ::SystemTimeToFileTime( &systime, &pUserTitle->ftLastLogon );

            cbReply += sizeof( *pUserTitle );
            pbWrite += sizeof( *pUserTitle );
            cTitles++;
        }
        else
        {
            // No rows left to process
            break;
        }
    }

    // Resize the final buffer down to the correct size
    pCReply = pCReply->Resize( cbReply );
    if (pCReply == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    hr = CResults.Clear();
    if (FAILED(hr))
    {
        goto lDone;
    }

    // OLE DB won't populate the return code until the rowset is released.  Webstore may or may not do the same, let's be safe.
    piRowset = NULL;

    // Check for a return
    if(FAILED((HRESULT)sParams.iRet))
    {
        hr = (DWORD) sParams.iRet;
        goto lDone;
    }

    // Success, set the output parameters
    pbWrite = pCReply->GetBuffer();
    ((Q_ENUM_TITLES_REPLY_MSG*)pbWrite)->cTitles = cTitles;
    pCCtx->m_pCReply = pCReply;

lDone:
    pCCtx->m_fProcessed = TRUE;
    pCCtx->m_hr = hr;

    // If failed, report the hr and if it came from the stored proc
    if (FAILED(hr))
    {
        // Failed cleanup allocations
        SAFE_RELEASE(pCReply);

        pCCtx->m_pCReply = NULL;

        if(sParams.iRet != S_OK)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_311, "p_xmsg_user_title_enumerate returned failure hr=%X", hr );
        }
        else
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_312, "StoreEnumerateUserTitles failed hr=%X", hr );
        }
    }

    hr = m_pCSwitchboard->PostCompletion(pCCtx);
    XOMASSERT(SUCCEEDED(hr));
}

/*****************************************************************************

CProfileStore::StoreMessageFlags

Change the flags of the specified user message.  The result is sent back via the
switchboard's completion port to a callback function.

*****************************************************************************/
void CProfileStore::StoreMessageFlags(CMessageFlagsContext *pCCtx)
{
    XOMASSERT(m_pCSwitchboard != NULL);
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Going to SQL for StoreMessageFlags");

    HRESULT hr = S_OK;
    CComPtr<IRowset> piRowset = NULL;

    // Parameter structures
    struct sParams_t {
        INT iRet;
        QWORD qwUserID;
        DWORD dwMessageID;
        DWORD dwSetFlags;
        DWORD dwUnsetFlags;
    } sParams;

    static WSTCOMMANDPARAM rgwstcpParams[] = {
        {1, DBPARAMIO_OUTPUT, DBTYPE_I4,  sizeof(sParams.iRet), offsetof(sParams_t, iRet), NULL},
        {2, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwUserID), offsetof(sParams_t, qwUserID), NULL},
        {3, DBPARAMIO_INPUT,  DBTYPE_I4,  sizeof(sParams.dwMessageID), offsetof(sParams_t, dwMessageID), NULL},
        {4, DBPARAMIO_INPUT,  DBTYPE_I4,  sizeof(sParams.dwSetFlags), offsetof(sParams_t, dwSetFlags), NULL},
        {5, DBPARAMIO_INPUT,  DBTYPE_I4,  sizeof(sParams.dwUnsetFlags), offsetof(sParams_t, dwUnsetFlags), NULL},
    };

    WSTCOMMANDINFO wstciParams = {
        sizeof(sParams),
        &sParams,
        ARRAY_ELEMENTS(rgwstcpParams),
        rgwstcpParams
    };

    static WCHAR wszCmd[] = L"{ ? = call p_xmsg_user_message_modify_flags( ?, ?, ?, ? ) }";

    // Set the parameters
    sParams.iRet = S_OK;
    sParams.qwUserID = pCCtx->m_qwUserID;
    sParams.dwMessageID = pCCtx->m_dwMessageID;
    sParams.dwSetFlags = pCCtx->m_dwSetFlags;
    sParams.dwUnsetFlags = pCCtx->m_dwUnsetFlags;

    // Execute the proc
    hr = m_piCommand->Execute(
        WRITEONLY_COMMANDTYPE,
        GetUserBucket(pCCtx->m_qwUserID),
        wszCmd,
        &wstciParams,
        (IUnknown **)&piRowset,
        NULL,
        DBGUID_DEFAULT,
        IID_IRowset);

    // OLE DB won't populate the return code until the rowset is released.  Webstore may or may not do the same, let's be safe.
    piRowset = NULL;

    if (FAILED(hr))
    {
        // Run the error through the OLEDB wrapper to get details
        CWSODBWResult CResults(ErrorCallback);
        CResults.GetErrorHandler()->HandleError(hr, "StoreDeleteMessage Failed to execute stored proc");
        goto lDone;
    }

    // Check for a return
    if(FAILED((HRESULT)sParams.iRet))
    {
        hr = (DWORD) sParams.iRet;
        goto lDone;
    }

    if( S_FALSE == (HRESULT)sParams.iRet )
    {
        XomTrace( PresenceDebug, L_ERROR, "p_xmsg_user_message_modify_flags returned message not found" );
        hr = XONLINE_E_MESSAGE_INVALID_MESSAGE_ID;
        goto lDone;
    }

lDone:
    pCCtx->m_fProcessed = TRUE;
    pCCtx->m_hr = hr;

    // If failed, report the hr and if it came from the stored proc
    if( FAILED( hr ) && XONLINE_E_MESSAGE_INVALID_MESSAGE_ID != hr )
    {
        if(sParams.iRet != S_OK)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_313, "p_xmsg_user_message_modify_flags returned failure hr=%X", hr );
        }
        else
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_314, "StoreMessageFlags failed hr=%X", hr );
        }
    }

    hr = m_pCSwitchboard->PostCompletion(pCCtx);
    XOMASSERT(SUCCEEDED(hr));
}

/*****************************************************************************

CProfileStore::StoreUnblockUsers

Remove specified users from a given user's never list.

*****************************************************************************/
void CProfileStore::StoreUnblockUsers( CUnblockUsersContext* pCCtx )
{
    XOMASSERT( pCCtx != NULL );

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Going to SQL for StoreUnblockUsers" );

    CComPtr<IRowset> piRowset = NULL;

    // Parameter structures
    struct sParams_t {
        INT iRet;
        QWORD qwUserID;
        QWORD qwBlockID;
    } sParams;

    static WSTCOMMANDPARAM rgwstcpParams[] = {
        { 1,  DBPARAMIO_OUTPUT, DBTYPE_I4,    sizeof(sParams.iRet),                 offsetof(sParams_t, iRet),             NULL },
        { 2,  DBPARAMIO_INPUT,  DBTYPE_I8,    sizeof(sParams.qwUserID),             offsetof(sParams_t, qwUserID),         NULL },
        { 3,  DBPARAMIO_INPUT,  DBTYPE_I8,    sizeof(sParams.qwBlockID),            offsetof(sParams_t, qwBlockID),        NULL },
    };

    WSTCOMMANDINFO wstciParams = {
        sizeof(sParams),
        &sParams,
        ARRAY_ELEMENTS(rgwstcpParams),
        rgwstcpParams
    };

    static WCHAR wszCmd[] = L"{ ? = call p_xmsg_user_unblock_user( ?, ? ) }";

    // Set the parameters that are the same for each recipient
    sParams.qwUserID = pCCtx->m_qwUserID;

    // Unblock the specified users
    for( WORD iUser = 0; iUser < pCCtx->m_cUsersToUnblock; iUser++ )
    {
        HRESULT hr = S_OK;

        // Set the parameters that change per user
        sParams.iRet = S_OK;
        sParams.qwBlockID = pCCtx->m_rgqwUsersToUnblock[ iUser ];

        // Execute the proc
        hr = m_piCommand->Execute(
            WRITEONLY_COMMANDTYPE,
            GetUserBucket( pCCtx->m_qwUserID ),
            wszCmd,
            &wstciParams,
            (IUnknown **)&piRowset,
            NULL,
            DBGUID_DEFAULT,
            IID_IRowset);

        // OLE DB won't populate the return code until the rowset is released.  Webstore may or may not do the same, let's be safe.
        piRowset = NULL;

        if( FAILED( hr ) )
        {
            // Run the error through the OLEDB wrapper to get details
            CWSODBWResult CResults( ErrorCallback );
            CResults.GetErrorHandler()->HandleError( hr, "StoreUnblockUsers Failed to execute stored proc" );

            XomNtEvent( XEVENT_PRESENCE_CODE_315, "StoreUnblockUsers failed hr=%X", hr );
        }
        else if( FAILED( (HRESULT) sParams.iRet ) )
        {
            XomNtEvent( XEVENT_PRESENCE_CODE_316, "p_xmsg_user_unblock_user returned failure hr=%X", hr );
        }
    }

    SAFE_RELEASE( pCCtx );
}

/*****************************************************************************

CProfileStore::StoreBlockUser

Add specified sender to a given user's never list.

*****************************************************************************/
void CProfileStore::StoreBlockUser( CBlockUsersContext* pCCtx )
{
    XOMASSERT( pCCtx != NULL );

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Going to SQL for StoreBlockUser" );

    HRESULT hr = S_OK;
    CComPtr<IRowset> piRowset = NULL;

    // Parameter structures
    struct sParams_t {
        INT iRet;
        QWORD qwUserID;
        QWORD qwBlockID;
    } sParams;

    static WSTCOMMANDPARAM rgwstcpParams[] = {
        { 1,  DBPARAMIO_OUTPUT, DBTYPE_I4,    sizeof(sParams.iRet),                 offsetof(sParams_t, iRet),             NULL },
        { 2,  DBPARAMIO_INPUT,  DBTYPE_I8,    sizeof(sParams.qwUserID),             offsetof(sParams_t, qwUserID),         NULL },
        { 3,  DBPARAMIO_INPUT,  DBTYPE_I8,    sizeof(sParams.qwBlockID),            offsetof(sParams_t, qwBlockID),        NULL },
    };

    WSTCOMMANDINFO wstciParams = {
        sizeof(sParams),
        &sParams,
        ARRAY_ELEMENTS(rgwstcpParams),
        rgwstcpParams
    };

    static WCHAR wszCmd[] = L"{ ? = call p_xmsg_user_block_user( ?, ? ) }";

    // Block the specified user
    sParams.iRet = S_OK;
    sParams.qwBlockID = pCCtx->m_qwSenderID;
    sParams.qwUserID = pCCtx->m_qwRecipientID;

    // Execute the proc
    hr = m_piCommand->Execute(
        WRITEONLY_COMMANDTYPE,
        GetUserBucket( pCCtx->m_qwRecipientID ),
        wszCmd,
        &wstciParams,
        (IUnknown **)&piRowset,
        NULL,
        DBGUID_DEFAULT,
        IID_IRowset);

    // OLE DB won't populate the return code until the rowset is released.  Webstore may or may not do the same, let's be safe.
    piRowset = NULL;

    if( FAILED( hr ) )
    {
        // Run the error through the OLEDB wrapper to get details
        CWSODBWResult CResults( ErrorCallback );
        CResults.GetErrorHandler()->HandleError( hr, "StoreBlockUser Failed to execute stored proc" );

        XomNtEvent( XEVENT_PRESENCE_CODE_317, "StoreBlockUser failed hr=%X", hr );
    }
    else if( FAILED( (HRESULT) sParams.iRet ) )
    {
        XomNtEvent( XEVENT_PRESENCE_CODE_318, "p_xmsg_user_block_user returned failure hr=%X", hr );
    }

    SAFE_RELEASE( pCCtx );
}


/*****************************************************************************

CProfileStore::StoreEnumSystemMessages

Enumerate the system messages for a particular title (or system-wide messages
if the specified title ID is zero).

*****************************************************************************/
void CProfileStore::StoreEnumSystemMessages( CEnumSystemMessagesContext* pCCtx )
{
    XOMASSERT(m_pCSwitchboard != NULL);
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Going to SQL for StoreEnumSystemMessages");

    HRESULT hr = S_OK;
    CComPtr<IRowset> piRowset = NULL;
    CWSODBWResult CResults(ErrorCallback);
    DWORD cRows = 0;

    CTCPCntVarBuffer *pCReply = NULL;
    DWORD cbReply = 0;
    BYTE *pbWrite = NULL;
    DWORD cMessages = 0;

    // Parameter structures
    struct sParams_t
    {
        INT iRet;
        DWORD dwTitleID;
    } sParams;

    static WSTCOMMANDPARAM rgwstcpParams[] =
    {
        {1, DBPARAMIO_OUTPUT, DBTYPE_I4,  sizeof(sParams.iRet),      offsetof(sParams_t, iRet),      NULL},
        {2, DBPARAMIO_INPUT,  DBTYPE_I4,  sizeof(sParams.dwTitleID), offsetof(sParams_t, dwTitleID), NULL},
    };

    WSTCOMMANDINFO wstciParams =
    {
        sizeof(sParams),
        &sParams,
        ARRAY_ELEMENTS(rgwstcpParams),
        rgwstcpParams
    };

    static WCHAR wszCmd[] = L"{ ? = call p_xmsg_system_message_enumerate( ? ) }";

    // Set the parameters
    sParams.iRet = S_OK;
    sParams.dwTitleID = pCCtx->m_dwTitleID;

    // Execute the proc
    hr = m_piCommand->Execute(
        WRITETHENREAD_COMMANDTYPE,
        ANY_PARTITION, // All partitions have the same system message data
        wszCmd,
        &wstciParams,
        (IUnknown **)&piRowset,
        NULL,
        DBGUID_DEFAULT,
        IID_IRowset);
    if (FAILED(hr))
    {
        // Run the error through the OLEDB wrapper to get details
        CResults.GetErrorHandler()->HandleError(hr, "StoreEnumSystemMessages Failed to execute stored proc");
        goto lDone;
    }

    // Attach the wrapper
    hr = CResults.InitializeWithIRowset(piRowset);
    if (FAILED(hr))
    {
        goto lDone;
    }

    struct sEntry_t
    {
        DWORD dwRegion;
        DWORD dwMessageID;
        BYTE bMessageType;
        DWORD dwMessageFlags;
        DWORD dwSenderTitleID;
        QWORD qwSenderContext;
        CHAR szSenderName[XONLINE_GAMERTAG_SIZE];
        DATE dtSentTime;
        WORD wExpireMinutes;
        WORD cbDetails;
        WCHAR wszDescription[XMSG_SYSTEM_MESSAGE_DESCRIPTION_LEN];
    } sEntry;

    // Allocate a reply buffer
    pCReply = CTCPCntVarBuffer::CreateInstance( sizeof( Q_ENUM_SYSTEM_MESSAGES_REPLY_MSG ) + ( sizeof( Q_SYSTEM_MESSAGE_SUMMARY ) * MAX_RETURNED_SYSTEM_MSGS ) );
    if( NULL == pCReply )
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    cbReply = sizeof( Q_ENUM_SYSTEM_MESSAGES_REPLY_MSG );
    pbWrite = pCReply->GetBuffer() + sizeof( Q_ENUM_SYSTEM_MESSAGES_REPLY_MSG );

    // Bind
    {
        static DBBINDING _bind[] =
        {
            WSBIND(1,  offsetof(sEntry_t, dwRegion),        DBTYPE_I4,   0),
            WSBIND(2,  offsetof(sEntry_t, dwMessageID),     DBTYPE_I4,   0),
            WSBIND(3,  offsetof(sEntry_t, bMessageType),    DBTYPE_I1,   0),
            WSBIND(4,  offsetof(sEntry_t, dwMessageFlags),  DBTYPE_I4,   0),
            WSBIND(5,  offsetof(sEntry_t, dwSenderTitleID), DBTYPE_I4,   0),
            WSBIND(6,  offsetof(sEntry_t, qwSenderContext), DBTYPE_I8,   0),
            WSBIND(7,  offsetof(sEntry_t, szSenderName),    DBTYPE_STR,  XONLINE_GAMERTAG_SIZE),
            WSBIND(8,  offsetof(sEntry_t, dtSentTime),      DBTYPE_DATE, 0),
            WSBIND(9,  offsetof(sEntry_t, wExpireMinutes),  DBTYPE_I2,   0),
            WSBIND(10, offsetof(sEntry_t, cbDetails),       DBTYPE_I2,   0),
            WSBIND(11, offsetof(sEntry_t, wszDescription),  DBTYPE_WSTR,  XMSG_SYSTEM_MESSAGE_DESCRIPTION_LEN),
        };

        hr = CResults.SetBindings(_bind, ARRAY_ELEMENTS(_bind));
        if(FAILED(hr))
        {
            goto lDone;
        }
    }

    // Get the rows
    for( DWORD iRow = 0; iRow < MAX_RETURNED_SYSTEM_MSGS; iRow++ )
    {
        cRows = 1;

        hr = CResults.GetRows( &cRows, &sEntry, sizeof( sEntry_t ) );
        if( FAILED( hr ) )
        {
            goto lDone;
        }

        if( cRows > 0 )
        {
            Q_SYSTEM_MESSAGE_SUMMARY* pSummary = (Q_SYSTEM_MESSAGE_SUMMARY*) pbWrite;

            pSummary->dwRegion = sEntry.dwRegion;
            pSummary->dwMessageID = sEntry.dwMessageID;
            pSummary->bMessageType = sEntry.bMessageType;
            pSummary->dwMessageFlags = sEntry.dwMessageFlags;
            pSummary->dwTitleID = sEntry.dwSenderTitleID;
            pSummary->qwSenderContext = sEntry.qwSenderContext;

            // NOTE: The szSenderName of a message summary intentionally does not contain space for the NULL
            memcpy( pSummary->szSenderName, sEntry.szSenderName, sizeof( pSummary->szSenderName ) );

            int cch = WideCharToMultiByte(CP_UTF8, 0, sEntry.wszDescription, sizeof(sEntry.wszDescription)/sizeof(WCHAR), pSummary->szDescription, sizeof(pSummary->szDescription), NULL, NULL);
            pSummary->szDescription[cch-1] = '\0';

            SYSTEMTIME systime;
            ::VariantTimeToSystemTime( sEntry.dtSentTime, &systime );
            ::SystemTimeToFileTime( &systime, &pSummary->ftSentTime );

            pSummary->wExpireMinutes = sEntry.wExpireMinutes;
            pSummary->cbDetails = sEntry.cbDetails;

            cbReply += sizeof( *pSummary );
            pbWrite += sizeof( *pSummary );
            cMessages++;
        }
        else
        {
            // No rows left to process
            break;
        }
    }

    // Resize the final buffer down to the correct size
    pCReply = pCReply->Resize( cbReply );
    if( NULL == pCReply )
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    hr = CResults.Clear();
    if( FAILED( hr ) )
    {
        goto lDone;
    }

    // OLE DB won't populate the return code until the rowset is released.  Webstore may or may not do the same, let's be safe.
    piRowset = NULL;

    // Check for a return
    if(FAILED((HRESULT)sParams.iRet))
    {
        hr = (DWORD) sParams.iRet;
        goto lDone;
    }

    // Success, set the output parameters
    pbWrite = pCReply->GetBuffer();
    ((Q_ENUM_SYSTEM_MESSAGES_REPLY_MSG*)pbWrite)->cMessages = (WORD) cMessages;
    ((Q_ENUM_SYSTEM_MESSAGES_REPLY_MSG*)pbWrite)->hr = S_OK;
    pCCtx->m_pCReply = pCReply;

lDone:
    pCCtx->m_fProcessed = TRUE;
    pCCtx->m_hr = hr;

    // If failed, report the hr and if it came from the stored proc
    if( FAILED( hr ) )
    {
        // Failed cleanup allocations
        SAFE_RELEASE( pCReply );

        pCCtx->m_pCReply = NULL;

        if( S_OK != sParams.iRet )
        {
            XomNtEvent( XEVENT_PRESENCE_CODE_319, "p_xmsg_system_message_enumerate returned failure hr=%X", hr );
        }
        else
        {
            XomNtEvent( XEVENT_PRESENCE_CODE_320, "StoreEnumSystemMessages failed hr=%X", hr );
        }
    }

    hr = m_pCSwitchboard->PostCompletion( pCCtx );
    XOMASSERT( SUCCEEDED( hr ) );
}

/*****************************************************************************

CProfileStore::StoreGetSystemMessageDetails

Gets details for a system message.

*****************************************************************************/
void CProfileStore::StoreGetSystemMessageDetails( CSystemMessageDetailsContext* pCCtx )
{
    XOMASSERT(m_pCSwitchboard != NULL);
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Going to SQL for StoreGetSystemMessageDetails");

    HRESULT hr = S_OK;
    CComPtr<IRowset> piRowset = NULL;
    CWSODBWResult CResults(ErrorCallback);
    DWORD cRows = 0;

    CTCPCntVarBuffer *pCReply = NULL;
    BYTE *pbWrite = NULL;

    // Parameter structures
    struct sParams_t {
        INT iRet;
        DWORD dwTitleID;
        DWORD dwMessageID;
    } sParams;

    static WSTCOMMANDPARAM rgwstcpParams[] =
    {
        {1, DBPARAMIO_OUTPUT, DBTYPE_I4,  sizeof(sParams.iRet),        offsetof(sParams_t, iRet),        NULL},
        {2, DBPARAMIO_INPUT,  DBTYPE_I4,  sizeof(sParams.dwTitleID),   offsetof(sParams_t, dwTitleID),   NULL},
        {3, DBPARAMIO_INPUT,  DBTYPE_I4,  sizeof(sParams.dwMessageID), offsetof(sParams_t, dwMessageID), NULL},
    };

    WSTCOMMANDINFO wstciParams =
    {
        sizeof(sParams),
        &sParams,
        ARRAY_ELEMENTS(rgwstcpParams),
        rgwstcpParams
    };

    static WCHAR wszCmd[] = L"{ ? = call p_xmsg_system_message_details( ?, ? ) }";

    // Set the parameters
    sParams.iRet = S_OK;
    sParams.dwTitleID = pCCtx->m_dwTitleID;
    sParams.dwMessageID = pCCtx->m_dwMessageID;

    // Execute the proc
    hr = m_piCommand->Execute(
        WRITETHENREAD_COMMANDTYPE,
        ANY_PARTITION, // All partitions have the same system message data
        wszCmd,
        &wstciParams,
        (IUnknown **)&piRowset,
        NULL,
        DBGUID_DEFAULT,
        IID_IRowset);
    if (FAILED(hr))
    {
        // Run the error through the OLEDB wrapper to get details
        CResults.GetErrorHandler()->HandleError(hr, "StoreGetSystemMessageDetails Failed to execute stored proc");
        goto lDone;
    }

    // Attach the wrapper
    hr = CResults.InitializeWithIRowset( piRowset );
    if( FAILED( hr ) )
    {
        goto lDone;
    }

    struct sEntry_t
    {
        DWORD dwRegion;
        DWORD dwMessageID;
        BYTE bMessageType;
        DWORD dwMessageFlags;
        DWORD dwSenderTitleID;
        QWORD qwSenderContext;
        CHAR szSenderName[ XONLINE_GAMERTAG_SIZE ];
        DATE dtSentTime;
        WORD wExpireMinutes;
        WORD cbDetails;
        WCHAR wszDescription[ XMSG_SYSTEM_MESSAGE_DESCRIPTION_LEN ];
        BYTE pbDetails[ XONLINE_MAX_MESSAGE_DETAILS ];
    } sEntry;

    // Bind
    {
        static DBBINDING _bind[] = {
            WSBIND(1,  offsetof(sEntry_t, dwRegion),        DBTYPE_I4,    0),
            WSBIND(2,  offsetof(sEntry_t, dwMessageID),     DBTYPE_I4,    0),
            WSBIND(3,  offsetof(sEntry_t, bMessageType),    DBTYPE_I1,    0),
            WSBIND(4,  offsetof(sEntry_t, dwMessageFlags),  DBTYPE_I4,    0),
            WSBIND(5,  offsetof(sEntry_t, dwSenderTitleID), DBTYPE_I4,    0),
            WSBIND(6,  offsetof(sEntry_t, qwSenderContext), DBTYPE_I8,    0),
            WSBIND(7,  offsetof(sEntry_t, szSenderName),    DBTYPE_STR,   XONLINE_GAMERTAG_SIZE),
            WSBIND(8,  offsetof(sEntry_t, dtSentTime),      DBTYPE_DATE,  0),
            WSBIND(9,  offsetof(sEntry_t, wExpireMinutes),  DBTYPE_I2,    0),
            WSBIND(10, offsetof(sEntry_t, cbDetails),       DBTYPE_I2,    0),
            WSBIND(11, offsetof(sEntry_t, wszDescription),  DBTYPE_WSTR,  XMSG_SYSTEM_MESSAGE_DESCRIPTION_LEN),
            WSBIND(12, offsetof(sEntry_t, pbDetails),       DBTYPE_BYTES, XONLINE_MAX_MESSAGE_DETAILS),
        };

        hr = CResults.SetBindings( _bind, ARRAY_ELEMENTS( _bind ) );
        if( FAILED( hr ) )
        {
            goto lDone;
        }
    }

    // Get the rows
    cRows = 1;

    hr = CResults.GetRows( &cRows, &sEntry, sizeof( sEntry_t ) );
    if( FAILED( hr ) )
    {
        goto lDone;
    }

    if( cRows <= 0 )
    {
        XomTrace( PresenceDebug, L_ERROR, "p_xmsg_system_message_details returned message not found" );
        hr = XONLINE_E_MESSAGE_INVALID_MESSAGE_ID; // Message not found
        goto lDone;
    }

    hr = CResults.Clear();
    if( FAILED( hr ) )
    {
        goto lDone;
    }

    // OLE DB won't populate the return code until the rowset is released.  Webstore may or may not do the same, let's be safe.
    piRowset = NULL;

    // Check for a return
    if(FAILED((HRESULT)sParams.iRet))
    {
        hr = (DWORD) sParams.iRet;
        goto lDone;
    }

    // Protect ourselves from bad data
    sEntry.cbDetails = (WORD) min( sEntry.cbDetails, XONLINE_MAX_MESSAGE_DETAILS );

    pCReply = CTCPCntVarBuffer::CreateInstance( sizeof( Q_SYSTEM_MESSAGE_DETAILS_REPLY_MSG ) + sEntry.cbDetails );
    if( NULL == pCReply )
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pbWrite = pCReply->GetBuffer();
    Q_SYSTEM_MESSAGE_DETAILS_REPLY_MSG* pReplyWork = (Q_SYSTEM_MESSAGE_DETAILS_REPLY_MSG*) pbWrite;

    pReplyWork->summary.dwRegion = sEntry.dwRegion;
    pReplyWork->summary.dwMessageID = sEntry.dwMessageID;
    pReplyWork->summary.bMessageType = sEntry.bMessageType;
    pReplyWork->summary.dwMessageFlags = sEntry.dwMessageFlags;
    pReplyWork->summary.dwTitleID = sEntry.dwSenderTitleID;
    pReplyWork->summary.qwSenderContext = sEntry.qwSenderContext;

    // NOTE: The szSenderName of a message summary intentionally does not contain space for the NULL
    memcpy( pReplyWork->summary.szSenderName, sEntry.szSenderName, sizeof( pReplyWork->summary.szSenderName ) );

    int cch = WideCharToMultiByte(CP_UTF8, 0, sEntry.wszDescription, sizeof(sEntry.wszDescription)/sizeof(WCHAR), pReplyWork->summary.szDescription, sizeof(pReplyWork->summary.szDescription), NULL, NULL);
    pReplyWork->summary.szDescription[cch-1] = '\0';

    SYSTEMTIME systime;
    ::VariantTimeToSystemTime( sEntry.dtSentTime, &systime );
    ::SystemTimeToFileTime( &systime, &pReplyWork->summary.ftSentTime );

    pReplyWork->summary.wExpireMinutes = sEntry.wExpireMinutes;
    pReplyWork->summary.cbDetails = sEntry.cbDetails;

    memcpy( pReplyWork + 1, sEntry.pbDetails, sEntry.cbDetails );

    // Success, set the output parameters
    pReplyWork->hr = S_OK;
    pCCtx->m_pCReply = pCReply;

lDone:
    pCCtx->m_fProcessed = TRUE;
    pCCtx->m_hr = hr;

    // If failed, report the hr and if it came from the stored proc
    if( FAILED( hr ) )
    {
        // Failed cleanup allocations
        SAFE_RELEASE( pCReply );

        pCCtx->m_pCReply = NULL;

        if( XONLINE_E_MESSAGE_INVALID_MESSAGE_ID != hr )
        {
            if( S_OK != sParams.iRet )
            {
                XomNtEvent( XEVENT_PRESENCE_CODE_321, "p_xmsg_system_message_details returned failure hr=%X", hr );
            }
            else
            {
                XomNtEvent( XEVENT_PRESENCE_CODE_322, "StoreGetSystemMessageDetails failed hr=%X", hr );
            }
        }
    }

    hr = m_pCSwitchboard->PostCompletion( pCCtx );
    XOMASSERT( SUCCEEDED( hr ) );
}

/*****************************************************************************

CProfileStore::StoreDeleteSystemMessage

Deletes a system message.

*****************************************************************************/
void CProfileStore::StoreDeleteSystemMessage( CDeleteSystemMessageContext* pCCtx )
{
    XOMASSERT(m_pCSwitchboard != NULL);
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Going to SQL for StoreDeleteSystemMessage");

    HRESULT hr = S_OK;
    CComPtr<IRowset> piRowset = NULL;

    // Parameter structures
    struct sParams_t
    {
        INT iRet;
        DWORD dwTitleID;
        DWORD dwMessageID;
        DWORD dwFlags;
    } sParams;

    static WSTCOMMANDPARAM rgwstcpParams[] = {
        {1, DBPARAMIO_OUTPUT, DBTYPE_I4,  sizeof(sParams.iRet),        offsetof(sParams_t, iRet),        NULL},
        {2, DBPARAMIO_INPUT,  DBTYPE_I4,  sizeof(sParams.dwTitleID),   offsetof(sParams_t, dwTitleID),   NULL},
        {3, DBPARAMIO_INPUT,  DBTYPE_I4,  sizeof(sParams.dwMessageID), offsetof(sParams_t, dwMessageID), NULL},
        {4, DBPARAMIO_INPUT,  DBTYPE_I4,  sizeof(sParams.dwFlags),     offsetof(sParams_t, dwFlags),     NULL},
    };

    WSTCOMMANDINFO wstciParams =
    {
        sizeof(sParams),
        &sParams,
        ARRAY_ELEMENTS(rgwstcpParams),
        rgwstcpParams
    };

    static WCHAR wszCmd[] = L"{ ? = call p_xmsg_system_message_delete( ?, ?, ? ) }";

    // Set the parameters
    sParams.iRet = S_OK;
    sParams.dwTitleID = pCCtx->m_dwTitleID;
    sParams.dwMessageID = pCCtx->m_dwMessageID;
    sParams.dwFlags = pCCtx->m_dwFlags;

    // Execute the proc
    hr = m_piCommand->Execute(
        WRITETHENREAD_COMMANDTYPE,
        ALL_DATABASES, // All partitions have the same system message data
        wszCmd,
        &wstciParams,
        (IUnknown **)&piRowset,
        NULL,
        DBGUID_DEFAULT,
        IID_IRowset);

    // OLE DB won't populate the return code until the rowset is released.  Webstore may or may not do the same, let's be safe.
    piRowset = NULL;

    if (FAILED(hr))
    {
        // Run the error through the OLEDB wrapper to get details
        CWSODBWResult CResults(ErrorCallback);
        CResults.GetErrorHandler()->HandleError(hr, "StoreDeleteSystemMessage Failed to execute stored proc");
        goto lDone;
    }

    // Check for a return
    if( FAILED( (HRESULT) sParams.iRet ) )
    {
        hr = (HRESULT) sParams.iRet;
        goto lDone;
    }
    else if( S_FALSE == (HRESULT) sParams.iRet )
    {
        XomTrace( PresenceDebug, L_ERROR, "p_xmsg_system_message_delete returned message not found" );
        hr = XONLINE_E_MESSAGE_INVALID_MESSAGE_ID;
        goto lDone;
    }

lDone:
    pCCtx->m_fProcessed = TRUE;
    pCCtx->m_hr = hr;

    // If failed, report the hr and if it came from the stored proc
    if( FAILED( hr ) && XONLINE_E_MESSAGE_INVALID_MESSAGE_ID != hr )
    {
        if( S_OK != sParams.iRet )
        {
            XomNtEvent( XEVENT_PRESENCE_CODE_323, "p_xmsg_system_message_delete returned failure hr=%X", hr );
        }
        else
        {
            XomNtEvent( XEVENT_PRESENCE_CODE_324, "StoreDeleteSystemMessage failed hr=%X", hr );
        }
    }

    hr = m_pCSwitchboard->PostCompletion( pCCtx );
    XOMASSERT( SUCCEEDED( hr ) );
}

/*****************************************************************************

CProfileStore::StoreSendSystemMessage

Sends a system message.

*****************************************************************************/
void CProfileStore::StoreSendSystemMessage( CSendSystemMessageContext* pCCtx )
{
    XOMASSERT(m_pCSwitchboard != NULL);
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Going to SQL for StoreSendSystemMessage");

    HRESULT hr = S_OK;
    CComPtr<IRowset> piRowset = NULL;

    // Parameter structures
    struct sParams_t
    {
        INT iRet;
        DWORD dwSenderTitleID;
        DWORD dwRegion;
        QWORD qwSenderContext;
        BYTE  bMessageType;
        DWORD dwMessageFlags;
        CHAR  szSenderName[ XONLINE_GAMERTAG_SIZE ];
        DATE  dtSentTime;
        WORD  wExpireMinutes;
        WORD  cbDetails;
        BYTE  pbDetails[ XONLINE_MAX_MESSAGE_DETAILS ];
        WCHAR wszDescription[ XMSG_SYSTEM_MESSAGE_DESCRIPTION_LEN ];
        DWORD dwMessageID;
    } sParams;

    // NOTE: This can't be static since it has dynamically written members and can be used by multiple threads at once
    WSTCOMMANDPARAM rgwstcpParams[] =
    {
        { 1,  DBPARAMIO_OUTPUT, DBTYPE_I4,    sizeof(sParams.iRet),                 offsetof(sParams_t, iRet),             NULL, NULL },
        { 2,  DBPARAMIO_INPUT,  DBTYPE_I4,    sizeof(sParams.dwSenderTitleID),      offsetof(sParams_t, dwSenderTitleID),  NULL, NULL },
        { 3,  DBPARAMIO_INPUT,  DBTYPE_I4,    sizeof(sParams.dwRegion),             offsetof(sParams_t, dwRegion),         NULL, NULL },
        { 4,  DBPARAMIO_INPUT,  DBTYPE_I8,    sizeof(sParams.qwSenderContext),      offsetof(sParams_t, qwSenderContext),  NULL, NULL },
        { 5,  DBPARAMIO_INPUT,  DBTYPE_I1,    sizeof(sParams.bMessageType),         offsetof(sParams_t, bMessageType),     NULL, NULL },
        { 6,  DBPARAMIO_INPUT,  DBTYPE_I4,    sizeof(sParams.dwMessageFlags),       offsetof(sParams_t, dwMessageFlags),   NULL, NULL },
        { 7,  DBPARAMIO_INPUT,  DBTYPE_STR,   sizeof(sParams.szSenderName),         offsetof(sParams_t, szSenderName),     NULL, NULL },
        { 8,  DBPARAMIO_INPUT,  DBTYPE_DATE,  sizeof(sParams.dtSentTime),           offsetof(sParams_t, dtSentTime),       NULL, NULL },
        { 9,  DBPARAMIO_INPUT,  DBTYPE_I2,    sizeof(sParams.wExpireMinutes),       offsetof(sParams_t, wExpireMinutes),   NULL, NULL },
        { 10, DBPARAMIO_INPUT,  DBTYPE_I2,    sizeof(sParams.cbDetails),            offsetof(sParams_t, cbDetails),        NULL, NULL },
        { 11, DBPARAMIO_INPUT,  DBTYPE_BYTES, 0, /* dynamically written */          offsetof(sParams_t, pbDetails),        NULL, NULL },
        { 12, DBPARAMIO_INPUT,  DBTYPE_WSTR,  sizeof(sParams.wszDescription),       offsetof(sParams_t, wszDescription),   NULL, NULL },
        { 13, DBPARAMIO_INPUT,  DBTYPE_I4,    sizeof(sParams.dwMessageID),          offsetof(sParams_t, dwMessageID),      NULL, NULL },
    };
    XOMASSERT( 0 == rgwstcpParams[ 10 ].paramSize ); // Make sure the location we overwrite stays up to date
    rgwstcpParams[ 10 ].paramSize = min( XONLINE_MAX_MESSAGE_DETAILS, max( pCCtx->m_Message.cbDetails, 1 ) );

    WSTCOMMANDINFO wstciParams =
    {
        sizeof(sParams),
        &sParams,
        ARRAY_ELEMENTS(rgwstcpParams),
        rgwstcpParams
    };

    static WCHAR wszCmd[] = L"{ ? = call p_xmsg_system_message_send( ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ? ) }";

    // Set the parameters
    sParams.iRet = S_OK;

    // Get the next system message ID (after iRet is set to S_OK for good error spew below)
    hr = GetNextSystemMessageID( &sParams.dwMessageID );
    if( FAILED( hr ) )
    {
        // Function will spew any events
        goto lDone;
    }

    sParams.dwSenderTitleID = pCCtx->m_Message.dwTitleID;
    sParams.dwRegion = pCCtx->m_Message.dwRegion;
    sParams.qwSenderContext = pCCtx->m_Message.qwSenderContext;
    sParams.bMessageType = pCCtx->m_Message.bMessageType;
    sParams.dwMessageFlags = pCCtx->m_Message.dwMessageFlags;

    // NOTE: szSenderName is intentionally sized not to include the NULL, so here we have to copy it to a new place and add one.
    strncpy( sParams.szSenderName, pCCtx->m_Message.szSenderName, sizeof( pCCtx->m_Message.szSenderName ) );
    sParams.szSenderName[ sizeof( pCCtx->m_Message.szSenderName ) ] = '\0';

    int cch = MultiByteToWideChar(CP_UTF8, 0, (LPCSTR)pCCtx->m_Message.szDescription, sizeof(pCCtx->m_Message.szDescription), sParams.wszDescription, sizeof(sParams.wszDescription)/sizeof(WCHAR));
    sParams.wszDescription[cch - 1] = '\0';  // ensure it is NULL terminated

    SYSTEMTIME systime;
    FileTimeToSystemTime( &pCCtx->m_Message.ftSentTime, &systime );
    SystemTimeToVariantTime( &systime, &sParams.dtSentTime );

    sParams.wExpireMinutes = pCCtx->m_Message.wExpireMinutes;
    sParams.cbDetails = pCCtx->m_Message.cbDetails;
    memcpy( sParams.pbDetails, pCCtx->m_rgbDetails, min( XONLINE_MAX_MESSAGE_DETAILS, pCCtx->m_Message.cbDetails ) );

    // Sending a zero sized binary doesn't go over too well, so if it is zero length, we bump the size up to 1
    // above when rgwstcpParams is set up, and then place a single zero in the buffer here.
    if( 0 == pCCtx->m_Message.cbDetails )
    {
        sParams.pbDetails[ 0 ] = 0;
    }

    // Execute the proc
    hr = m_piCommand->Execute(
        WRITEONLY_COMMANDTYPE,
        ALL_DATABASES, // All partitions have the same system message data
        wszCmd,
        &wstciParams,
        (IUnknown **)&piRowset,
        NULL,
        DBGUID_DEFAULT,
        IID_IRowset);

    // OLE DB won't populate the return code until the rowset is released.  Webstore may or may not do the same, let's be safe.
    piRowset = NULL;

    if (FAILED(hr))
    {
        // Run the error through the OLEDB wrapper to get details
        CWSODBWResult CResults(ErrorCallback);
        CResults.GetErrorHandler()->HandleError(hr, "StoreSendSystemMessage Failed to execute stored proc");
        goto lDone;
    }

    // Check for a return
    if( FAILED( (HRESULT) sParams.iRet ) )
    {
        hr = (HRESULT) sParams.iRet;
        goto lDone;
    }

    pCCtx->m_dwMessageID = sParams.dwMessageID;

lDone:
    pCCtx->m_fProcessed = TRUE;
    pCCtx->m_hr = hr;

    // If failed, report the hr and if it came from the stored proc
    if( FAILED( hr ) )
    {
        if( S_OK != sParams.iRet )
        {
            XomNtEvent( XEVENT_PRESENCE_CODE_325, "p_xmsg_system_message_send returned failure hr=%X", hr );
        }
        else
        {
            XomNtEvent( XEVENT_PRESENCE_CODE_326, "StoreSendSystemMessage failed hr=%X", hr );
        }
    }

    hr = m_pCSwitchboard->PostCompletion( pCCtx );
    XOMASSERT( SUCCEEDED( hr ) );
}


/*****************************************************************************

CProfileStore::GetNextSystemMessageID

Function to get the next system message ID to use.  Loads a block of system
message IDs from the store if necessary.

*****************************************************************************/
HRESULT CProfileStore::GetNextSystemMessageID( DWORD* pdwNextID )
{
    HRESULT hr = S_OK;

    // NOTE: At startup both values will be zero, so we will enter
    // the 'if' and load IDs.  On subsequent calls we will load new IDs
    // when we run out of them.
    if( m_dwNextSystemMessageID == m_dwStopSystemMessageID )
    {
        // Doing this allows only the first CallProc call to have to do any parsing
        static CWSProcCache cache;

        CODBWSession ses;

        // Connect to the NPDB database
        hr = ses.InitializeEx( g_CPresCfg.GetNPDBConnectionString() );
        if( FAILED( hr ) )
        {
            XomNtEvent( XEVENT_PRESENCE_CODE_327, "Failed to connect to the NPDB database, connstr='%S'.  Error code = 0x%08X.",
            (WCHAR *)(BSTR)g_CPresCfg.GetNPDBConnectionString(),
            hr );
            goto lDone;
        }

        // Get the next block of system message IDs
        hr = ses.CallProc( &cache, L"{ %T = CALL dbo.p_xmsg_system_messages_get_ids;1 }" );
        if( FAILED( hr ) )
        {
            XomNtEvent( XEVENT_PRESENCE_CODE_328, "The error 0x%08X was returned by database npdb when calling p_xmsgs_system_messages_get_ids.",
                hr);
            goto lDone;
        }

        // Process the result set.
        if( !ses.IsRowset() )
        {
            XomNtEvent( XEVENT_PRESENCE_CODE_329, "The database did not return a rowset when trying to retrieve new system message IDs." );
            hr = E_UNEXPECTED;
            goto lDone;
        }

        // Set up bindings
        static DBBINDING rgBinders[] =
        {
            WSBIND2 ( 1, 0,   DBTYPE_I4,    sizeof(long),   DBPART_VALUE,   0,  0),
            WSBIND2 ( 2, 4,   DBTYPE_I4,    sizeof(long),   DBPART_VALUE,   0,  0),
        };

        hr = ses.SetBindings( rgBinders, sizeof( rgBinders ) / sizeof( DBBINDING ) );
        if( FAILED( hr ) )
        {
            XomNtEvent( XEVENT_PRESENCE_CODE_330, "SetBindings failed with error = 0x%08X.",
                hr );
            goto lDone;
        }

        // Get the IDs out of the returned rowset
        ULONG ulRows = 1;

        struct IDInfo
        {
            DWORD m_dwNextID;
            DWORD m_dwStopID;
        } idinfo;

        hr = ses.GetRows( &ulRows, &idinfo, sizeof( idinfo ) );
        if( S_OK != hr ) // Failure or S_FALSE is an error
        {
            XomNtEvent( XEVENT_PRESENCE_CODE_331, "GetRows failed with error = 0x%08X.",
                hr );
            if( SUCCEEDED( hr ) )
            {
                hr = E_UNEXPECTED;
            }
            goto lDone;
        }

        // Set the local values to the returned block of message IDs
        m_dwNextSystemMessageID = idinfo.m_dwNextID;
        m_dwStopSystemMessageID = idinfo.m_dwStopID;

        XomTrace( PresenceDebug, L_NORMAL, "CProfileStore::GetNextSystemMessageID - Got new system message ID block from NPDB, [0x%08X,0x%08X]", m_dwNextSystemMessageID, m_dwStopSystemMessageID );
    }

    *pdwNextID = m_dwNextSystemMessageID | XONLINE_MSG_ID_SYSTEM_MESSAGE;
    m_dwNextSystemMessageID = ( m_dwNextSystemMessageID + 1 ) & XONLINE_MSG_ID_BASE_MASK;

    XomTrace( PresenceDebug, L_NORMAL, "CProfileStore::GetNextSystemMessageID - Using system message ID [0x%08X]", *pdwNextID );

lDone:
    return hr;
}

/*****************************************************************************

CProfileStore::GetNextTeamPUID

Get the next team PUID

*****************************************************************************/
HRESULT CProfileStore::GetNextTeamPUID(QWORD qwUserID, QWORD *pqwTeamPUID)
{
    HRESULT hr = S_OK;

    *pqwTeamPUID = 0;

    EnterCriticalSection(&m_csTeamPUIDGen);

    if (m_cTeamPUIDLeft > 0)
    {
        // Return next PUID
        *pqwTeamPUID = m_qwNextTeamPUID;
        m_qwNextTeamPUID++;
        m_cTeamPUIDLeft--;
    }
    else
    {
        XomTrace(
            PresenceDebug,
            L_NORMAL,
            "Getting a new batch of PUIDs");


        hr = SProcTeamPUIDGen(256, &m_qwNextTeamPUID);
        if (SUCCEEDED(hr))
        {
            m_cTeamPUIDLeft = 256;
            *pqwTeamPUID = m_qwNextTeamPUID;
            m_qwNextTeamPUID++;
            m_cTeamPUIDLeft--;
        }
    }

    LeaveCriticalSection(&m_csTeamPUIDGen);

    return hr;
}


/*****************************************************************************

CProfileStore::GetUserBucket

Maps a user PUID into a bucket

*****************************************************************************/
LONG CProfileStore::GetUserBucket(QWORD qwUserID)
{
    LONG lRet = 0;
    LARGE_INTEGER liHash;
    HRESULT hr = S_OK;

    liHash.QuadPart = qwUserID;
    hr = m_piHash->HashLARGEINTEGER(liHash, &lRet);
    if (FAILED(hr))
    {
        XomNtEvent(XEVENT_PRESENCE_CODE_332, "GetUserBucket failed UserID=%I64X hr=%X", qwUserID, hr);
    }

    return lRet;
}

/*****************************************************************************

CProfileStore::GetTeamBucket

Maps a team PUID into a bucket

*****************************************************************************/
LONG CProfileStore::GetTeamBucket(QWORD qwTeamID)
{
    LONG lRet = 0;
    LARGE_INTEGER liHash;
    HRESULT hr = S_OK;

    liHash.QuadPart = qwTeamID;
    hr = m_piHash->HashLARGEINTEGER(liHash, &lRet);
    if (FAILED(hr))
    {
        XomNtEvent(XEVENT_PRESENCE_CODE_333, "GetTeamBucket failed TeamID=%I64X hr=%X", qwTeamID, hr);
    }

    return lRet;
}


/*****************************************************************************

CProfileStore::GetTeamNameBucket

Maps a team name into a bucket

*****************************************************************************/
LONG CProfileStore::GetTeamNameBucket(LPWSTR wszName)
{
    LONG lRet = 0;
    HRESULT hr = S_OK;

    hr = m_piHash->HashBSTR(wszName, &lRet);
    if (FAILED(hr))
    {
        XomNtEvent(XEVENT_PRESENCE_CODE_334, "GetTeamNameBucket failed TeamName=%S hr=%X", wszName, hr);
    }

    return lRet;
}

/*****************************************************************************

CProfileStore::GetTeamBucket

Get the total number of Webstore buckets

*****************************************************************************/
LONG CProfileStore::GetBucketCount()
{
    LONG lRet = 0;
    HRESULT hr = S_OK;

    hr = m_piHash->GetCount(&lRet);
    if (FAILED(hr))
    {
        XomNtEvent(XEVENT_PRESENCE_CODE_335, "GetBucketCount failed hr=%X", hr);
    }

    return lRet;
}

/*****************************************************************************

CProfileStore::CannonizeName

Strip the spaces out of a name

*****************************************************************************/
void CProfileStore::CannonizeName(LPWSTR wszName)
{
    LPWSTR wszRead = wszName;
    LPWSTR wszWrite = wszName;

    while (*wszRead != L'\0')
    {
        if (*wszRead >= L'A' && *wszRead <= L'Z')
        {
            *wszWrite = *wszRead + (L'a' - L'A');
            wszWrite++;
        }
        else if (*wszRead != L' ')
        {
            *wszWrite = *wszRead;
            wszWrite++;
        }
        wszRead++;
    }
    *wszWrite = L'\0';
}

/*****************************************************************************

CProfileStore::SProcAddBuddy

Calls the p_pres_add_friend stored procedure optionaly under a transaction.
The result is returned via the return code.  On success, the resulting list
version number is set.  If nothing was deleted S_FALSE is returned.

*****************************************************************************/
HRESULT CProfileStore::SProcAddBuddy(
    QWORD qwUserID,
    QWORD qwBuddyID,
    LPCSTR szBuddyAcctName,
    DWORD *pdwVersion,
    IWSTDTC *piDTC)
{
    // Check parameters
    if (pdwVersion == NULL)
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    CComPtr<IRowset> piRowset = NULL;
    CWSODBWResult CResults(ErrorCallback);
    DWORD cRows = 0;

    // Parameter structures
    struct sParams_t {
        INT iRet;
        QWORD qwUserID;
        QWORD qwBuddyID;
        CHAR szBuddyAcctName[MAX_ACCTNAME_BYTES];
    } sParams;

    static WSTCOMMANDPARAM rgwstcpParams[] = {
        {1, DBPARAMIO_OUTPUT, DBTYPE_I4,  sizeof(sParams.iRet), offsetof(sParams_t, iRet), NULL},
        {2, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwUserID), offsetof(sParams_t, qwUserID), NULL},
        {3, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwBuddyID), offsetof(sParams_t, qwBuddyID), NULL},
        {4, DBPARAMIO_INPUT,  DBTYPE_STR, sizeof(sParams.szBuddyAcctName), offsetof(sParams_t, szBuddyAcctName), NULL}
    };

    WSTCOMMANDINFO wstciParams = {
        sizeof(sParams),
        &sParams,
        ARRAY_ELEMENTS(rgwstcpParams),
        rgwstcpParams
    };

    static WCHAR wszCmd[] = L"{ ? = call p_pres_add_friend (?, ?, ?) }";

    // Set the parameters
    sParams.iRet = XPROFILE_NO_RESULT;
    sParams.qwUserID = qwUserID;
    sParams.qwBuddyID = qwBuddyID;
    strncpy(sParams.szBuddyAcctName, szBuddyAcctName, MAX_ACCTNAME_BYTES);
    sParams.szBuddyAcctName[MAX_ACCTNAME_BYTES - 1] = '\0';

    // Execute the proc
    hr = m_piCommand->Execute(
        WRITEONLY_COMMANDTYPE,
        GetUserBucket(qwUserID),
        wszCmd,
        &wstciParams,
        (IUnknown **)&piRowset,
        piDTC,
        DBGUID_DEFAULT,
        IID_IRowset);
    if (FAILED(hr))
    {
        // Run the error through the OLEBD wrapper to get details
        CResults.GetErrorHandler()->HandleError(hr, "SProcAddBuddy failed to execute stored proc");
        goto lDone;
    }

    // Check for a return
    if((sParams.iRet != XPROFILE_NO_RESULT) && (FAILED((HRESULT)sParams.iRet)))
    {
        hr = (DWORD) sParams.iRet;
        goto lDone;
    }

    // Attach the wrapper
    hr = CResults.InitializeWithIRowset(piRowset);
    piRowset = NULL;
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Check for a return
    if((sParams.iRet != XPROFILE_NO_RESULT) && (FAILED((HRESULT)sParams.iRet)))
    {
        hr = (DWORD) sParams.iRet;
        goto lDone;
    }

    // Get the resulting version number
    {
        static DBBINDING _bind[] = {
            WSBIND(1, 0, DBTYPE_I4, 0),
        };

        hr = CResults.SetBindings(_bind, ARRAY_ELEMENTS(_bind));
        if(FAILED(hr))
        {
            goto lDone;
        }
    }

    cRows = 1;

    hr = CResults.GetRows(&cRows, pdwVersion, sizeof(DWORD));
    if(FAILED(hr))
    {
        goto lDone;
    }

    hr = CResults.Clear();
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Get final return code
    if (sParams.iRet == XPROFILE_NO_RESULT)
    {
        hr = E_FAIL;
    }
    else
    {
        hr = (DWORD) sParams.iRet;
    }

lDone:

    // If failed, report the hr and if it came from the stored proc
    if ( FAILED(hr) &&
        (hr != HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER)) &&
        (hr != XONLINE_E_NOTIFICATION_BLOCKED) &&
        (hr != XONLINE_E_NOTIFICATION_LIST_FULL) &&
        (hr != HRESULT_FROM_WIN32(ERROR_USER_EXISTS)))
    {
        if(sParams.iRet != XPROFILE_NO_RESULT)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_336, "p_pres_add_friend returned failure UserID=%I64X BuddyID=%I64X hr=%X", qwUserID, qwBuddyID, hr);
        }
        else
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_337, "SProcAddBuddy failed UserID=%I64X BuddyID=%I64X hr=%X", qwUserID, qwBuddyID, hr);
        }

        *pdwVersion = 0;
    }

    return hr;
}

/*****************************************************************************

CProfileStore::SProcAddedBuddy

Calls the p_pres_added_friend stored procedure optionaly under a transaction.
The result is returned via the return code.  On success, the resulting list
version number is set.  If nothing was deleted S_FALSE is returned.

*****************************************************************************/
HRESULT CProfileStore::SProcAddedBuddy(
    QWORD qwUserID,
    QWORD qwBuddyID,
    LPCSTR szBuddyAcctName,
    DWORD *pdwVersion,
    LPSTR szUserAcctName,
    DWORD *pcbUserAcctName,
    IWSTDTC *piDTC)
{
    // Check parameters
    if (pdwVersion == NULL)
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    CComPtr<IRowset> piRowset = NULL;
    CWSODBWResult CResults(ErrorCallback);
    DWORD cRows = 0;
    DWORD cbAcctName = 0;

    // Parameter structures
    struct sParams_t {
        INT iRet;
        QWORD qwUserID;
        QWORD qwBuddyID;
        CHAR szBuddyAcctName[MAX_ACCTNAME_BYTES + 1];
    } sParams;

    static WSTCOMMANDPARAM rgwstcpParams[] = {
        {1, DBPARAMIO_OUTPUT, DBTYPE_I4,  sizeof(sParams.iRet), offsetof(sParams_t, iRet), NULL},
        {2, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwUserID), offsetof(sParams_t, qwUserID), NULL},
        {3, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwBuddyID), offsetof(sParams_t, qwBuddyID), NULL},
        {4, DBPARAMIO_INPUT,  DBTYPE_STR, sizeof(sParams.szBuddyAcctName), offsetof(sParams_t, szBuddyAcctName), NULL}
    };

    WSTCOMMANDINFO wstciParams = {
        sizeof(sParams),
        &sParams,
        ARRAY_ELEMENTS(rgwstcpParams),
        rgwstcpParams
    };

    static WCHAR wszCmd[] = L"{ ? = call p_pres_added_friend (?, ?, ?) }";

    // Output structure
    struct sRet_t {
        DWORD dwVersion;
        CHAR szAcctName[MAX_ACCTNAME_BYTES];
    } sRet;

    // Set the parameters
    sParams.iRet = XPROFILE_NO_RESULT;
    sParams.qwUserID = qwUserID;
    sParams.qwBuddyID = qwBuddyID;
    strncpy(sParams.szBuddyAcctName, szBuddyAcctName, MAX_ACCTNAME_BYTES);
    sParams.szBuddyAcctName[MAX_ACCTNAME_BYTES - 1] = '\0';
    memset(&sRet, 0, sizeof(sRet));

    // Execute the proc
    hr = m_piCommand->Execute(
        WRITEONLY_COMMANDTYPE,
        GetUserBucket(qwUserID),
        wszCmd,
        &wstciParams,
        (IUnknown **)&piRowset,
        piDTC,
        DBGUID_DEFAULT,
        IID_IRowset);
    if (FAILED(hr))
    {
        // Run the error through the OLEBD wrapper to get details
        CResults.GetErrorHandler()->HandleError(hr, "SProcAddedBuddy failed to execute stored proc");
        goto lDone;
    }

    // Check for a return
    if((sParams.iRet != XPROFILE_NO_RESULT) && (FAILED((HRESULT)sParams.iRet)))
    {
        hr = (DWORD) sParams.iRet;
        goto lDone;
    }

    // Attach the wrapper
    hr = CResults.InitializeWithIRowset(piRowset);
    piRowset = NULL;
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Check for a return
    if((sParams.iRet != XPROFILE_NO_RESULT) && (FAILED((HRESULT)sParams.iRet)))
    {
        hr = (DWORD) sParams.iRet;
        goto lDone;
    }

    // Get the resulting version number and user name
    {
        static DBBINDING _bind[] = {
            WSBIND(1, offsetof(sRet_t, dwVersion), DBTYPE_I4, 0),
            WSBIND(2, offsetof(sRet_t, szAcctName), DBTYPE_STR, MAX_ACCTNAME_BYTES),
        };

        hr = CResults.SetBindings(_bind, ARRAY_ELEMENTS(_bind));
        if(FAILED(hr))
        {
            goto lDone;
        }
    }

    cRows = 1;

    memset(&sRet, 0, sizeof(sRet));
    hr = CResults.GetRows(&cRows, &sRet, sizeof(sRet));
    if(FAILED(hr))
    {
        goto lDone;
    }

    *pdwVersion = sRet.dwVersion;
    cbAcctName = strlen(sRet.szAcctName) + 1;
    if (cbAcctName > MAX_ACCTNAME_BYTES)
    {
        hr = E_FAIL;
        goto lDone;
    }
    *pcbUserAcctName = cbAcctName;
    memcpy(szUserAcctName, sRet.szAcctName, cbAcctName);

    hr = CResults.Clear();
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Get final return code
    if (sParams.iRet == XPROFILE_NO_RESULT)
    {
        hr = E_FAIL;
    }
    else
    {
        hr = (DWORD) sParams.iRet;
    }

lDone:

    // If failed, report the hr and if it came from the stored proc
    if ( FAILED(hr) &&
        (hr != HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER)) &&
        (hr != XONLINE_E_NOTIFICATION_BLOCKED) &&
        (hr != XONLINE_E_NOTIFICATION_OTHER_LIST_FULL) &&
        (hr != DB_E_INTEGRITYVIOLATION) &&
        (hr != HRESULT_FROM_WIN32(ERROR_USER_EXISTS)))
    {
        if(sParams.iRet != XPROFILE_NO_RESULT)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_338, "p_pres_added_friend returned failure UserID=%I64X BuddyID=%I64X hr=%X", qwUserID, qwBuddyID, hr);
        }
        else
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_339, "SProcAddedBuddy failed UserID=%I64X BuddyID=%I64X hr=%X", qwUserID, qwBuddyID, hr);
        }

        *pdwVersion = 0;
    }

    return hr;
}

/*****************************************************************************

CProfileStore::SProcAcceptBuddy

Calls the p_pres_accept_friend stored procedure optionaly under a transaction.
The result is returned via the return code.  On success, the resulting list
version number is set.

*****************************************************************************/
HRESULT CProfileStore::SProcAcceptBuddy(
    QWORD qwUserID,
    QWORD qwBuddyID,
    DWORD *pdwVersion,
    LPSTR szUserAcctName,
    DWORD *pcbUserAcctName,
    IWSTDTC *piDTC)
{
    // Check parameters
    if ( (pdwVersion == NULL) || (pcbUserAcctName == NULL) )
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    CComPtr<IRowset> piRowset = NULL;
    CWSODBWResult CResults(ErrorCallback);
    DWORD cRows = 0;
    DWORD cbAcctName = 0;

    // Parameter structures
    struct sParams_t {
        INT iRet;
        QWORD qwUserID;
        QWORD qwBuddyID;
    } sParams;

    static WSTCOMMANDPARAM rgwstcpParams[] = {
        {1, DBPARAMIO_OUTPUT, DBTYPE_I4,  sizeof(sParams.iRet), offsetof(sParams_t, iRet), NULL},
        {2, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwUserID), offsetof(sParams_t, qwUserID), NULL},
        {3, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwBuddyID), offsetof(sParams_t, qwBuddyID), NULL}
    };

    WSTCOMMANDINFO wstciParams = {
        sizeof(sParams),
        &sParams,
        ARRAY_ELEMENTS(rgwstcpParams),
        rgwstcpParams
    };

    static WCHAR wszCmd[] = L"{ ? = call p_pres_accept_friend (?, ?) }";

    // Output structure
    struct sRet_t {
        DWORD dwVersion;
        CHAR szAcctName[MAX_ACCTNAME_BYTES + 1];
    } sRet;

    // Set the parameters
    sParams.iRet = XPROFILE_NO_RESULT;
    sParams.qwUserID = qwUserID;
    sParams.qwBuddyID = qwBuddyID;

    // Execute the proc
    hr = m_piCommand->Execute(
        WRITEONLY_COMMANDTYPE,
        GetUserBucket(qwUserID),
        wszCmd,
        &wstciParams,
        (IUnknown **)&piRowset,
        piDTC,
        DBGUID_DEFAULT,
        IID_IRowset);
    if (FAILED(hr))
    {
        // Run the error through the OLEBD wrapper to get details
        CResults.GetErrorHandler()->HandleError(hr, "SProcAcceptBuddy failed to execute stored proc");
        goto lDone;
    }

    // Check for a return
    if((sParams.iRet != XPROFILE_NO_RESULT) && (FAILED((HRESULT)sParams.iRet)))
    {
        hr = (DWORD) sParams.iRet;
        goto lDone;
    }

    // Attach the wrapper
    hr = CResults.InitializeWithIRowset(piRowset);
    piRowset = NULL;
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Get the resulting version number and user name
    {
        static DBBINDING _bind[] = {
            WSBIND(1, offsetof(sRet_t, dwVersion), DBTYPE_I4, 0),
            WSBIND(2, offsetof(sRet_t, szAcctName), DBTYPE_STR, MAX_ACCTNAME_BYTES),
        };

        hr = CResults.SetBindings(_bind, ARRAY_ELEMENTS(_bind));
        if(FAILED(hr))
        {
            goto lDone;
        }
    }

    cRows = 1;

    memset(&sRet, 0, sizeof(sRet));
    hr = CResults.GetRows(&cRows, &sRet, sizeof(sRet));
    if(FAILED(hr))
    {
        goto lDone;
    }

    *pdwVersion = sRet.dwVersion;
    cbAcctName = strlen(sRet.szAcctName) + 1;
    if (cbAcctName > MAX_ACCTNAME_BYTES)
    {
        hr = E_FAIL;
        goto lDone;
    }
    *pcbUserAcctName = cbAcctName;
    memcpy(szUserAcctName, sRet.szAcctName, cbAcctName);

    hr = CResults.Clear();
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Get final return code
    if (sParams.iRet == XPROFILE_NO_RESULT)
    {
        hr = E_FAIL;
    }
    else
    {
        hr = (DWORD) sParams.iRet;
    }

lDone:

    // If failed, report the hr and if it came from the stored proc
    if (FAILED(hr))
    {
        if ((hr != HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER)) && // no more request
            (hr != HRESULT_FROM_WIN32(ERROR_USER_EXISTS))) // already accepted
        {
            if(sParams.iRet != XPROFILE_NO_RESULT)
            {
                XomNtEvent(XEVENT_PRESENCE_CODE_340, "p_pres_accept_friend returned failure UserID=%I64X BuddyID=%I64X hr=%X", qwUserID, qwBuddyID, hr);
            }
            else
            {
                XomNtEvent(XEVENT_PRESENCE_CODE_341, "SProcAcceptBuddy failed UserID=%I64X BuddyID=%I64X hr=%X", qwUserID, qwBuddyID, hr);
            }
        }

        *pdwVersion = 0;
    }

    return hr;
}

/*****************************************************************************

CProfileStore::SProcAcceptedBuddy

Calls the p_pres_accepted_friend stored procedure optionaly under a transaction.
The result is returned via the return code.  On success, the resulting list
version number is set and the user's account name is also output.

*****************************************************************************/
HRESULT CProfileStore::SProcAcceptedBuddy(
    QWORD qwUserID,
    QWORD qwBuddyID,
    DWORD *pdwVersion,
    LPSTR szUserAcctName,
    DWORD *pcbUserAcctName,
    IWSTDTC *piDTC)
{
    // Check parameters
    if ( (pdwVersion == NULL) || (pcbUserAcctName == NULL) )
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    CComPtr<IRowset> piRowset = NULL;
    CWSODBWResult CResults(ErrorCallback);
    DWORD cRows = 0;
    DWORD cbAcctName = 0;

    // Parameter structures
    struct sParams_t {
        INT iRet;
        QWORD qwUserID;
        QWORD qwBuddyID;
    } sParams;

    static WSTCOMMANDPARAM rgwstcpParams[] = {
        {1, DBPARAMIO_OUTPUT, DBTYPE_I4,  sizeof(sParams.iRet), offsetof(sParams_t, iRet), NULL},
        {2, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwUserID), offsetof(sParams_t, qwUserID), NULL},
        {3, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwBuddyID), offsetof(sParams_t, qwBuddyID), NULL}
    };

    WSTCOMMANDINFO wstciParams = {
        sizeof(sParams),
        &sParams,
        ARRAY_ELEMENTS(rgwstcpParams),
        rgwstcpParams
    };

    static WCHAR wszCmd[] = L"{ ? = call p_pres_accepted_friend (?, ?) }";

    // Output structure
    struct sRet_t {
        DWORD dwVersion;
        CHAR szAcctName[MAX_ACCTNAME_BYTES + 1];
    } sRet;

    // Set the parameters
    sParams.iRet = XPROFILE_NO_RESULT;
    sParams.qwUserID = qwUserID;
    sParams.qwBuddyID = qwBuddyID;
    memset(&sRet, 0, sizeof(sRet));

    // Execute the proc
    hr = m_piCommand->Execute(
        WRITEONLY_COMMANDTYPE,
        GetUserBucket(qwUserID),
        wszCmd,
        &wstciParams,
        (IUnknown **)&piRowset,
        piDTC,
        DBGUID_DEFAULT,
        IID_IRowset);
    if (FAILED(hr))
    {
        // Run the error through the OLEBD wrapper to get details
        CResults.GetErrorHandler()->HandleError(hr, "SProcAcceptedBuddy failed to execute stored proc");
        goto lDone;
    }

    // Check for a return
    if((sParams.iRet != XPROFILE_NO_RESULT) && (FAILED((HRESULT)sParams.iRet)))
    {
        hr = (DWORD) sParams.iRet;
        goto lDone;
    }

    // Attach the wrapper
    hr = CResults.InitializeWithIRowset(piRowset);
    piRowset = NULL;
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Get the resulting version number and user name
    {
        static DBBINDING _bind[] = {
            WSBIND(1, offsetof(sRet_t, dwVersion), DBTYPE_I4, 0),
            WSBIND(2, offsetof(sRet_t, szAcctName), DBTYPE_STR, MAX_ACCTNAME_BYTES),
        };

        hr = CResults.SetBindings(_bind, ARRAY_ELEMENTS(_bind));
        if(FAILED(hr))
        {
            goto lDone;
        }
    }

    cRows = 1;

    memset(&sRet, 0, sizeof(sRet));
    hr = CResults.GetRows(&cRows, &sRet, sizeof(sRet));
    if(FAILED(hr))
    {
        goto lDone;
    }

    *pdwVersion = sRet.dwVersion;
    cbAcctName = strlen(sRet.szAcctName) + 1;
    if (cbAcctName > MAX_ACCTNAME_BYTES)
    {
        hr = E_FAIL;
        goto lDone;
    }
    *pcbUserAcctName = cbAcctName;
    memcpy(szUserAcctName, sRet.szAcctName, cbAcctName);

    hr = CResults.Clear();
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Get final return code
    if (sParams.iRet == XPROFILE_NO_RESULT)
    {
        hr = E_FAIL;
    }
    else
    {
        hr = (DWORD) sParams.iRet;
    }

lDone:

    // If failed, report the hr and if it came from the stored proc
    if (FAILED(hr))
    {
        if ((hr != HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER)) && // no more request
            (hr != HRESULT_FROM_WIN32(ERROR_USER_EXISTS))) // already accepted
        {
            if(sParams.iRet != XPROFILE_NO_RESULT)
            {
                XomNtEvent(XEVENT_PRESENCE_CODE_342, "p_pres_accepted_friend returned failure UserID=%I64X BuddyID=%I64X hr=%X", qwUserID, qwBuddyID, hr);
            }
            else
            {
                XomNtEvent(XEVENT_PRESENCE_CODE_343, "SProcAcceptedBuddy failed UserID=%I64X BuddyID=%I64X hr=%X", qwUserID, qwBuddyID, hr);
            }
        }

        *pdwVersion = 0;
    }

    return hr;
}

/*****************************************************************************

CProfileStore::SProcRejectBuddy

Calls the p_pres_reject_friend stored procedure optionaly under a transaction.
The result is returned via the return code.  On success, the resulting list
version number is set.

*****************************************************************************/
HRESULT CProfileStore::SProcRejectBuddy(
    QWORD qwUserID,
    QWORD qwBuddyID,
    BOOL fNever,
    DWORD *pdwVersion,
    IWSTDTC *piDTC)
{
    // Check parameters
    if (pdwVersion == NULL)
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    CComPtr<IRowset> piRowset = NULL;
    CWSODBWResult CResults(ErrorCallback);
    DWORD cRows = 0;

    // Parameter structures
    struct sParams_t {
        INT iRet;
        QWORD qwUserID;
        QWORD qwBuddyID;
        BOOL fNever;
    } sParams;

    static WSTCOMMANDPARAM rgwstcpParams[] = {
        {1, DBPARAMIO_OUTPUT, DBTYPE_I4,  sizeof(sParams.iRet), offsetof(sParams_t, iRet), NULL},
        {2, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwUserID), offsetof(sParams_t, qwUserID), NULL},
        {3, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwBuddyID), offsetof(sParams_t, qwBuddyID), NULL},
        {4, DBPARAMIO_INPUT,  DBTYPE_I1,  sizeof(sParams.fNever), offsetof(sParams_t, fNever), NULL}
    };

    WSTCOMMANDINFO wstciParams = {
        sizeof(sParams),
        &sParams,
        ARRAY_ELEMENTS(rgwstcpParams),
        rgwstcpParams
    };

    static WCHAR wszCmd[] = L"{ ? = call p_pres_reject_friend (?, ?, ?) }";

    // Set the parameters
    sParams.iRet = XPROFILE_NO_RESULT;
    sParams.qwUserID = qwUserID;
    sParams.qwBuddyID = qwBuddyID;
    sParams.fNever = fNever;

    // Execute the proc
    hr = m_piCommand->Execute(
        WRITEONLY_COMMANDTYPE,
        GetUserBucket(qwUserID),
        wszCmd,
        &wstciParams,
        (IUnknown **)&piRowset,
        piDTC,
        DBGUID_DEFAULT,
        IID_IRowset);
    if (FAILED(hr))
    {
        // Run the error through the OLEBD wrapper to get details
        CResults.GetErrorHandler()->HandleError(hr, "SProcRejectBuddy failed to execute stored proc");
        goto lDone;
    }

    // Check for a return
    if((sParams.iRet != XPROFILE_NO_RESULT) && (FAILED((HRESULT)sParams.iRet)))
    {
        hr = (DWORD) sParams.iRet;
        goto lDone;
    }

    // Attach the wrapper
    hr = CResults.InitializeWithIRowset(piRowset);
    piRowset = NULL;
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Get the resulting version number
    {
        static DBBINDING _bind[] = {
            WSBIND(1, 0, DBTYPE_I4, 0),
        };

        hr = CResults.SetBindings(_bind, ARRAY_ELEMENTS(_bind));
        if(FAILED(hr))
        {
            goto lDone;
        }
    }

    cRows = 1;

    hr = CResults.GetRows(&cRows, pdwVersion, sizeof(DWORD));
    if(FAILED(hr))
    {
        goto lDone;
    }

    hr = CResults.Clear();
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Get final return code
    if (sParams.iRet == XPROFILE_NO_RESULT)
    {
        hr = E_FAIL;
    }
    else
    {
        hr = (DWORD) sParams.iRet;
    }

lDone:

    // If failed, report the hr and if it came from the stored proc
    if (FAILED(hr))
    {
        if(sParams.iRet != XPROFILE_NO_RESULT)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_344, "p_pres_reject_friend returned failure UserID=%I64X BuddyID=%I64X Never=%d hr=%X", qwUserID, qwBuddyID, fNever, hr);
        }
        else
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_345, "SProcRejectBuddy failed UserID=%I64X BuddyID=%I64X Never=%d hr=%X", qwUserID, qwBuddyID, fNever, hr);
        }

        *pdwVersion = 0;
    }

    return hr;
}

/*****************************************************************************

CProfileStore::SProcRejectedBuddy

Calls the p_pres_rejected_friend stored procedure optionaly under a transaction.
The result is returned via the return code.  On success, the resulting list
version number is set.

*****************************************************************************/
HRESULT CProfileStore::SProcRejectedBuddy(
    QWORD qwUserID,
    QWORD qwBuddyID,
    DWORD *pdwVersion,
    IWSTDTC *piDTC)
{
    // Check parameters
    if (pdwVersion == NULL)
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    CComPtr<IRowset> piRowset = NULL;
    CWSODBWResult CResults(ErrorCallback);
    DWORD cRows = 0;

    // Parameter structures
    struct sParams_t {
        INT iRet;
        QWORD qwUserID;
        QWORD qwBuddyID;
    } sParams;

    static WSTCOMMANDPARAM rgwstcpParams[] = {
        {1, DBPARAMIO_OUTPUT, DBTYPE_I4,  sizeof(sParams.iRet), offsetof(sParams_t, iRet), NULL},
        {2, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwUserID), offsetof(sParams_t, qwUserID), NULL},
        {3, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwBuddyID), offsetof(sParams_t, qwBuddyID), NULL}
    };

    WSTCOMMANDINFO wstciParams = {
        sizeof(sParams),
        &sParams,
        ARRAY_ELEMENTS(rgwstcpParams),
        rgwstcpParams
    };

    static WCHAR wszCmd[] = L"{ ? = call p_pres_rejected_friend (?, ?) }";

    // Set the parameters
    sParams.iRet = XPROFILE_NO_RESULT;
    sParams.qwUserID = qwUserID;
    sParams.qwBuddyID = qwBuddyID;

    // Execute the proc
    hr = m_piCommand->Execute(
        WRITEONLY_COMMANDTYPE,
        GetUserBucket(qwUserID),
        wszCmd,
        &wstciParams,
        (IUnknown **)&piRowset,
        piDTC,
        DBGUID_DEFAULT,
        IID_IRowset);
    if (FAILED(hr))
    {
        // Run the error through the OLEBD wrapper to get details
        CResults.GetErrorHandler()->HandleError(hr, "SProcRejectedBuddy failed to execute stored proc");
        goto lDone;
    }

    // Check for a return
    if((sParams.iRet != XPROFILE_NO_RESULT) && (FAILED((HRESULT)sParams.iRet)))
    {
        hr = (DWORD) sParams.iRet;
        goto lDone;
    }

    // Attach the wrapper
    hr = CResults.InitializeWithIRowset(piRowset);
    piRowset = NULL;
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Get the resulting version number
    {
        static DBBINDING _bind[] = {
            WSBIND(1, 0, DBTYPE_I4, 0),
        };

        hr = CResults.SetBindings(_bind, ARRAY_ELEMENTS(_bind));
        if(FAILED(hr))
        {
            goto lDone;
        }
    }

    cRows = 1;

    hr = CResults.GetRows(&cRows, pdwVersion, sizeof(DWORD));
    if(FAILED(hr))
    {
        goto lDone;
    }

    hr = CResults.Clear();
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Get final return code
    if (sParams.iRet == XPROFILE_NO_RESULT)
    {
        hr = E_FAIL;
    }
    else
    {
        hr = (DWORD) sParams.iRet;
    }

lDone:

    // If failed, report the hr and if it came from the stored proc
    if (FAILED(hr))
    {
        if(sParams.iRet != XPROFILE_NO_RESULT)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_346, "p_pres_rejected_friend returned failure UserID=%I64X BuddyID=%I64X hr=%X", qwUserID, qwBuddyID, hr);
        }
        else
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_347, "SProcRejectedBuddy failed UserID=%I64X BuddyID=%I64X hr=%X", qwUserID, qwBuddyID, hr);
        }

        *pdwVersion = 0;
    }

    return hr;
}

/*****************************************************************************

CProfileStore::SProcDeleteBuddy

Calls the p_pres_delete_friend stored procedure optionaly under a transaction.
The result is returned via the return code.  On success, the resulting list
version number is set.  If nothing was deleted S_FALSE is returned.

*****************************************************************************/
HRESULT CProfileStore::SProcDeleteBuddy(
    QWORD qwUserID,
    QWORD qwBuddyID,
    DWORD *pdwVersion,
    IWSTDTC *piDTC)
{
    // Check parameters
    if (pdwVersion == NULL)
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    CComPtr<IRowset> piRowset = NULL;
    CWSODBWResult CResults(ErrorCallback);
    DWORD cRows = 0;

    // Parameter structures
    struct sParams_t {
        INT iRet;
        QWORD qwUserID;
        QWORD qwBuddyID;
    } sParams;

    static WSTCOMMANDPARAM rgwstcpParams[] = {
        {1, DBPARAMIO_OUTPUT, DBTYPE_I4,  sizeof(sParams.iRet), offsetof(sParams_t, iRet), NULL},
        {2, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwUserID), offsetof(sParams_t, qwUserID), NULL},
        {3, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwBuddyID), offsetof(sParams_t, qwBuddyID), NULL}
    };

    WSTCOMMANDINFO wstciParams = {
        sizeof(sParams),
        &sParams,
        ARRAY_ELEMENTS(rgwstcpParams),
        rgwstcpParams
    };

    static WCHAR wszCmd[] = L"{ ? = call p_pres_delete_friend (?, ?) }";

    // Set the parameters
    sParams.iRet = XPROFILE_NO_RESULT;
    sParams.qwUserID = qwUserID;
    sParams.qwBuddyID = qwBuddyID;

    // Execute the proc
    hr = m_piCommand->Execute(
        WRITEONLY_COMMANDTYPE,
        GetUserBucket(qwUserID),
        wszCmd,
        &wstciParams,
        (IUnknown **)&piRowset,
        piDTC,
        DBGUID_DEFAULT,
        IID_IRowset);
    if (FAILED(hr))
    {
        // Run the error through the OLEBD wrapper to get details
        CResults.GetErrorHandler()->HandleError(hr, "SProcDeleteBuddy failed to execute stored proc");
        goto lDone;
    }

    // Check for a return
    if((sParams.iRet != XPROFILE_NO_RESULT) && (FAILED((HRESULT)sParams.iRet)))
    {
        hr = (DWORD) sParams.iRet;
        goto lDone;
    }

    // Attach the wrapper
    hr = CResults.InitializeWithIRowset(piRowset);
    piRowset = NULL;
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Get the resulting version number
    {
        static DBBINDING _bind[] = {
            WSBIND(1, 0, DBTYPE_I4, 0),
        };

        hr = CResults.SetBindings(_bind, ARRAY_ELEMENTS(_bind));
        if(FAILED(hr))
        {
            goto lDone;
        }
    }

    cRows = 1;

    hr = CResults.GetRows(&cRows, pdwVersion, sizeof(DWORD));
    if(FAILED(hr))
    {
        goto lDone;
    }

    hr = CResults.Clear();
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Get final return code
    if (sParams.iRet == XPROFILE_NO_RESULT)
    {
        hr = E_FAIL;
    }
    else
    {
        hr = (DWORD) sParams.iRet;
    }

lDone:

    // If failed, report the hr and if it came from the stored proc
    if (FAILED(hr))
    {
        if(sParams.iRet != XPROFILE_NO_RESULT)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_348, "p_pres_delete_friend returned failure UserID=%I64X BuddyID=%I64X hr=%X", qwUserID, qwBuddyID, hr);
        }
        else
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_349, "SProcDeleteBuddy failed UserID=%I64X BuddyID=%I64X hr=%X", qwUserID, qwBuddyID, hr);
        }

        *pdwVersion = 0;
    }

    return hr;
}

/*****************************************************************************

CProfileStore::SProcLoadAfiiliates

Calls the p_pres_load_affiliates stored procedure to load the affiliates lists.

*****************************************************************************/
HRESULT CProfileStore::SProcLoadAffiliates(
    QWORD qwUserID,
    DWORD dwListFlag,
    CAffiliatesList *pAffiliatesList)
{
    if (pAffiliatesList == NULL)
    {
        return E_INVALIDARG;
    }

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Going to SQL for SProcLoadAffiliates");

    HRESULT hr = S_OK;
    CComPtr<IRowset> piRowset = NULL;
    CWSODBWResult CResults(ErrorCallback);

    // Parameter structures
    struct sParams_t {
        INT iRet;
        QWORD qwUserID;
        DWORD dwListFlag;
    } sParams = {0};

    struct AffiliateRow
    {
        QWORD qwAffiliateID;
        DWORD dwTitleID;
        DATE dtDateUpdated;
    }
    sRow = {0};

    static WSTCOMMANDPARAM rgwstcpParams[] = {
        {1, DBPARAMIO_OUTPUT, DBTYPE_I4,  sizeof(sParams.iRet), offsetof(sParams_t, iRet), NULL},
        {2, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwUserID), offsetof(sParams_t, qwUserID), NULL},
        {3, DBPARAMIO_INPUT,  DBTYPE_I4, sizeof(sParams.dwListFlag), offsetof(sParams_t, dwListFlag), NULL}
    };

    WSTCOMMANDINFO wstciParams = {
        sizeof(sParams),
        &sParams,
        ARRAY_ELEMENTS(rgwstcpParams),
        rgwstcpParams
    };

    static WCHAR wszCmd[] = L"{ ? = call p_pres_load_affiliates (?, ?) }";

    // Set the parameters
    sParams.iRet = XPROFILE_NO_RESULT;
    sParams.qwUserID = qwUserID;
    sParams.dwListFlag = dwListFlag;

    // Execute the proc
    hr = m_piCommand->Execute(
        WRITETHENREAD_COMMANDTYPE,
        GetUserBucket(qwUserID),
        wszCmd,
        &wstciParams,
        (IUnknown **)&piRowset,
        NULL,
        DBGUID_DEFAULT,
        IID_IRowset);
    if (FAILED(hr))
    {
        // Run the error through the OLEBD wrapper to get details
        CResults.GetErrorHandler()->HandleError(hr, "SProcLoadAffiliates failed to execute stored proc");
        goto lDone;
    }

    // Check for a return
    if((sParams.iRet != XPROFILE_NO_RESULT) && (FAILED((HRESULT)sParams.iRet)))
    {
        hr = (DWORD) sParams.iRet;
        goto lDone;
    }

    // Attach the wrapper
    hr = CResults.InitializeWithIRowset(piRowset);
    piRowset = NULL;
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Bind
    {
        static DBBINDING _bind[] = {
            WSBIND(1, offsetof(AffiliateRow, qwAffiliateID), DBTYPE_I8, 0),
            WSBIND(2, offsetof(AffiliateRow, dwTitleID), DBTYPE_I4, 0),
            WSBIND(3, offsetof(AffiliateRow, dtDateUpdated), DBTYPE_DATE, 0)
        };

        hr = CResults.SetBindings(_bind, ARRAY_ELEMENTS(_bind));
        if(FAILED(hr))
        {
            goto lDone;
        }
    }

    DWORD cAffiliates;
    for (cAffiliates = 0; cAffiliates < pAffiliatesList->dwAlloc; cAffiliates++)
    {
        DWORD cRows = 1;

        hr = CResults.GetRows(&cRows, &sRow, sizeof(AffiliateRow));
        if(FAILED(hr))
        {
            goto lDone;
        }

        if (cRows != 1)
        {
            break;
        }

        pAffiliatesList->rgAffiliates[cAffiliates].qwAffiliateID = sRow.qwAffiliateID;
        pAffiliatesList->rgAffiliates[cAffiliates].dwTitleID = sRow.dwTitleID;

        SYSTEMTIME st;
        VariantTimeToSystemTime(sRow.dtDateUpdated, &st);
        FILETIME ft;
        SystemTimeToFileTime(&st, &ft);
        pAffiliatesList->rgAffiliates[cAffiliates].mtDateUpdated = FileTimeToMsgTime(&ft);
    }

    hr = CResults.Clear();
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Get final return code
    if (sParams.iRet == XPROFILE_NO_RESULT)
    {
        hr = E_FAIL;
    }
    else
    {
        hr = (DWORD) sParams.iRet;
    }


    if (cAffiliates == pAffiliatesList->dwAlloc)
    {
        hr = SProcCropAffiliates(
            qwUserID,
            dwListFlag,
            pAffiliatesList->rgAffiliates[pAffiliatesList->dwAlloc - 1].mtDateUpdated);
        if (FAILED(hr))
        {
            goto lDone;
        }
    }

    pAffiliatesList->dwSize = cAffiliates;

lDone:

    // If failed, report the hr and if it came from the stored proc
    if (FAILED(hr))
    {
        pAffiliatesList->dwSize = 0;

        if(sParams.iRet != XPROFILE_NO_RESULT)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_350, "p_pres_load_affiliates  returned failure UserID=%I64X hr=%X", qwUserID, hr);
        }
        else
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_351, "SProcLoadAffiliates failed UserID=%I64X hr=%X", qwUserID, hr);
        }
    }

    return hr;

}

/*****************************************************************************

CProfileStore::SProcCropAfiiliates

Calls the p_pres_crop_affiliates stored procedure to crop an affiliates list.

*****************************************************************************/
HRESULT CProfileStore::SProcCropAffiliates(
        QWORD qwUserID,
        DWORD dwFlags,
        MSGTIME mtDateUpdated)
{
    // Check parameters
    if (qwUserID == 0)
    {
        return E_INVALIDARG;
    }

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Going to SQL for SProcCropAffiliates");

    HRESULT hr = S_OK;
    CComPtr<IRowset> piRowset = NULL;
    CWSODBWResult CResults(ErrorCallback);

    // Parameter structures
    struct sParams_t {
        INT iRet;
        QWORD qwUserID;
        DWORD dwFlags;
        DATE dtDateUpdated;
    } sParams = {0};

    static WSTCOMMANDPARAM rgwstcpParams[] = {
        {1, DBPARAMIO_OUTPUT, DBTYPE_I4,  sizeof(sParams.iRet), offsetof(sParams_t, iRet), NULL},
        {2, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwUserID), offsetof(sParams_t, qwUserID), NULL},
        {3, DBPARAMIO_INPUT,  DBTYPE_I4, sizeof(sParams.dwFlags), offsetof(sParams_t, dwFlags), NULL},
        {4, DBPARAMIO_INPUT,  DBTYPE_DATE,  sizeof(sParams.dtDateUpdated), offsetof(sParams_t, dtDateUpdated), NULL}
    };

    WSTCOMMANDINFO wstciParams = {
        sizeof(sParams),
        &sParams,
        ARRAY_ELEMENTS(rgwstcpParams),
        rgwstcpParams
    };

    static WCHAR wszCmd[] = L"{ ? = call p_pres_crop_affiliates (?, ?, ?) }";

    QWORD ft = MsgTimeToFileTimeQW(mtDateUpdated);
    SYSTEMTIME st;
    FileTimeToSystemTime( (FILETIME *)&ft, &st );
    SystemTimeToVariantTime( &st, &sParams.dtDateUpdated );

    // Set the parameters
    sParams.iRet = XPROFILE_NO_RESULT;
    sParams.qwUserID = qwUserID;
    sParams.dwFlags = dwFlags;

    // Execute the proc
    hr = m_piCommand->Execute(
        WRITEONLY_COMMANDTYPE,
        GetUserBucket(qwUserID),
        wszCmd,
        &wstciParams,
        (IUnknown **)&piRowset,
        NULL,
        DBGUID_DEFAULT,
        IID_IRowset);
    if (FAILED(hr))
    {
        // Run the error through the OLEBD wrapper to get details
        CResults.GetErrorHandler()->HandleError(hr, "SProcCropAffiliates failed to execute stored proc");
        goto lDone;
    }

    // Should be no rowsets comming back
    piRowset = NULL;

    // Get final return code
    if (sParams.iRet == XPROFILE_NO_RESULT)
    {
        hr = E_FAIL;
    }
    else
    {
        hr = (DWORD) sParams.iRet;
    }

lDone:

    // If failed, report the hr and if it came from the stored proc
    if (FAILED(hr))
    {
        if(sParams.iRet != XPROFILE_NO_RESULT)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_352, "p_pres_crop_affiliates returned failure UserID=%I64X hr=%X", qwUserID, hr);
        }
        else
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_353, "SProcCropAffiliates failed UserID=%I64X hr=%X", qwUserID, hr);
        }
    }

    return hr;
}

/*****************************************************************************

CProfileStore::SProcAddAfiiliates

Calls the p_pres_add_affiliates stored procedure to insert new affiliates.

*****************************************************************************/
HRESULT CProfileStore::SProcAddAffiliates(
        QWORD qwUserID,
        CAffiliatesList **rgpAffiliates,
        MSGTIME mtAffiliatesLoaded)
{
    // Check parameters
    if ((qwUserID == 0) ||
        (rgpAffiliates == NULL))
    {
        return E_INVALIDARG;
    }

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Going to SQL for SProcAddAffiliates");

    HRESULT hr = S_OK;
    CComPtr<IRowset> piRowset = NULL;
    CWSODBWResult CResults(ErrorCallback);

// there are 6 lists containing affiliates, each of which will be sent as an xml row of the format:
// <a xuid="0000000000000000" title="00000000" list="00000000" date="2007-03-03 23:34:06"/> .
#define SPROC_ADD_AFFILIATES_XML_FORMAT "<a xuid=\"%I64d\" title=\"%d\" list=\"%d\" date=\"%d-%d-%d %d:%d:%d\"/>"
#define SPROC_ADD_AFFILIATES_MAX_CHARS_PER_ROW 100

    DWORD dwSprocAddAffiliatesSize = 0;
    for (DWORD iList = 0; iList < NUM_STORED_AFFILIATE_LISTS; iList++)
    {
        dwSprocAddAffiliatesSize += rgpAffiliates[iList]->dwSize;
    }
    dwSprocAddAffiliatesSize *= SPROC_ADD_AFFILIATES_MAX_CHARS_PER_ROW;

    // Parameter structures
    struct sParams_t {
        INT iRet;
        QWORD qwUserID;
        WORD wHashBucket;
        CHAR szXml[1];
    };

    BYTE *pBuf = new BYTE[dwSprocAddAffiliatesSize + sizeof(sParams_t)];
    if (pBuf == NULL)
    {
        return E_OUTOFMEMORY;
    }

    sParams_t *psParams = (sParams_t *)pBuf;

    static WCHAR wszCmd[] = L"{ ? = call p_pres_add_affiliates (?, ?, ?) }";

    // Set the parameters
    psParams->iRet = XPROFILE_NO_RESULT;
    psParams->qwUserID = qwUserID;
    psParams->wHashBucket = (WORD)GetUserBucket(qwUserID);

    CHAR *pchWrite = psParams->szXml;
    for (DWORD iList = 0; iList < NUM_STORED_AFFILIATE_LISTS; iList++)
    {
        for (DWORD iAffiliate = 0; iAffiliate < rgpAffiliates[iList]->dwSize; iAffiliate++)
        {
            // skip anything that hasnt changed since we loaded.
            if (rgpAffiliates[iList]->rgAffiliates[iAffiliate].mtDateUpdated < mtAffiliatesLoaded)
            {
                continue;
            }

            QWORD ft = MsgTimeToFileTimeQW(rgpAffiliates[iList]->rgAffiliates[iAffiliate].mtDateUpdated);
            SYSTEMTIME st;
            FileTimeToSystemTime( (FILETIME *)&ft, &st );

            DWORD dwWrite = sprintf(
                pchWrite,
                SPROC_ADD_AFFILIATES_XML_FORMAT,
                rgpAffiliates[iList]->rgAffiliates[iAffiliate].qwAffiliateID,
                rgpAffiliates[iList]->rgAffiliates[iAffiliate].dwTitleID,
                X_AFFILIATE_INDEX_TO_FLAG(iList),
                st.wYear,
                st.wMonth,
                st.wDay,
                st.wHour,
                st.wMinute,
                st.wSecond);

            pchWrite += dwWrite;
        }
    }

    *pchWrite = '\0';

    static WSTCOMMANDPARAM rgwstcpParams[] = {
        {1, DBPARAMIO_OUTPUT, DBTYPE_I4,  sizeof(psParams->iRet), offsetof(sParams_t, iRet), NULL},
        {2, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(psParams->qwUserID), offsetof(sParams_t, qwUserID), NULL},
        {3, DBPARAMIO_INPUT,  DBTYPE_I2,  sizeof(psParams->wHashBucket), offsetof(sParams_t, wHashBucket), NULL},
        {4, DBPARAMIO_INPUT,  DBTYPE_STR,  (DWORD)(pchWrite + 1 - psParams->szXml), offsetof(sParams_t, szXml), NULL}
    };

    WSTCOMMANDINFO wstciParams = {
        (DWORD)(pchWrite - psParams->szXml) + sizeof(sParams_t),
        psParams,
        ARRAY_ELEMENTS(rgwstcpParams),
        rgwstcpParams
    };

    if (pchWrite == psParams->szXml)
    {
        // no changed affiliates?  just exit.
        goto lDone;
    }

    // Execute the proc
    hr = m_piCommand->Execute(
        WRITEONLY_COMMANDTYPE,
        GetUserBucket(qwUserID),
        wszCmd,
        &wstciParams,
        (IUnknown **)&piRowset,
        NULL,
        DBGUID_DEFAULT,
        IID_IRowset);
    if (FAILED(hr))
    {
        // Run the error through the OLEBD wrapper to get details
        CResults.GetErrorHandler()->HandleError(hr, "SProcAddAffiliates failed to execute stored proc");
        goto lDone;
    }

    // Should be no rowsets comming back
    piRowset = NULL;

    // Get final return code
    if (psParams->iRet == XPROFILE_NO_RESULT)
    {
        hr = E_FAIL;
    }
    else
    {
        hr = (DWORD) psParams->iRet;
    }

lDone:

    // If failed, report the hr and if it came from the stored proc
    if (FAILED(hr))
    {
        if(psParams->iRet != XPROFILE_NO_RESULT)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_354, "p_pres_add_affiliates returned failure UserID=%I64X hr=%X", qwUserID, hr);
        }
        else
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_355, "SProcAddAffiliates failed UserID=%I64X hr=%X", qwUserID, hr);
        }
    }

    delete pBuf;

    return hr;
}


/*****************************************************************************

CProfileStore::SProcGetUserIDByName

Calls the p_pres_get_user_puids stored procedure to get the given user's id via
their account name.

*****************************************************************************/
HRESULT CProfileStore::SProcGetUserIDByName(LPSTR szAccountName, QWORD *pqwUserID)
{
    // Check parameters
    if ((szAccountName == NULL) || (szAccountName[0] == '\0') ||
        (pqwUserID == NULL))
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    CComPtr<IMultipleResults> piResults = NULL;
    CWSODBWResult CResults(ErrorCallback);
    DWORD cRows = 0;

    // Parameter structures
    struct sParams_t {
        CHAR szAcctName[MAX_ACCTNAME_BYTES];
    } sParams;

    static WSTCOMMANDPARAM rgwstcpParams[] = {
        {1, DBPARAMIO_INPUT,  DBTYPE_STR, sizeof(sParams.szAcctName), offsetof(sParams_t, szAcctName), NULL}
    };

    WSTCOMMANDINFO wstciParams = {
        sizeof(sParams),
        &sParams,
        ARRAY_ELEMENTS(rgwstcpParams),
        rgwstcpParams
    };

    static WCHAR wszCmd[] = L"{ call p_pres_get_user_puids (?) }";

    // Binding structure
    struct sUserIDs_t {
        QWORD qwUserID;
        CHAR szAcctName[MAX_ACCTNAME_BYTES];
    } sUserIDs;

    // Set the parameters
    strncpy(sParams.szAcctName, szAccountName, MAX_ACCTNAME_BYTES);
    sParams.szAcctName[MAX_ACCTNAME_BYTES - 1] = '\0';

    // Execute the procs
    hr = m_piCommand->Execute(
        WRITETHENREAD_COMMANDTYPE,
        ALL_DATABASES,
        wszCmd,
        &wstciParams,
        (IUnknown **)&piResults,
        NULL,
        DBGUID_DEFAULT,
        IID_IRowset);
    if (FAILED(hr))
    {
        // Run the error through the OLEBD wrapper to get details
        CResults.GetErrorHandler()->HandleError(hr, "SProcGetUserIDByName failed to execute stored proc");
        goto lDone;
    }

    // Catch NULL response
    if (piResults == NULL)
    {
        // The user was not found
        hr = HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
        goto lDone;
    }


    // Attach the wrapper
    hr = CResults.SetResults(piResults);
    piResults = NULL;
    if (FAILED(hr))
    {
        goto lDone;
    }

    static DBBINDING _bind[] = {
        WSBIND(1, offsetof(sUserIDs_t, qwUserID), DBTYPE_I8, 0),
        WSBIND(2, offsetof(sUserIDs_t, szAcctName), DBTYPE_STR, MAX_ACCTNAME_BYTES),
    };

    // Look through the rowsets for a non-zero UserID
    memset(&sUserIDs, 0, sizeof(sUserIDs));

    while ((sUserIDs.qwUserID == 0) && CResults.IsRowset())
    {
        hr = CResults.SetBindings(_bind, ARRAY_ELEMENTS(_bind));
        if(FAILED(hr))
        {
            goto lDone;
        }

        cRows = 1;

        memset(&sUserIDs, 0, sizeof(sUserIDs));

        hr = CResults.GetRows(&cRows, &sUserIDs, sizeof(sUserIDs));
        if(FAILED(hr))
        {
            goto lDone;
        }

        hr = CResults.NextRowsetResult();
        if (FAILED(hr))
        {
            goto lDone;
        }
    }

    *pqwUserID = sUserIDs.qwUserID;


    // #12729: Copy the name back to correct capitalization issues
    strncpy(szAccountName, sUserIDs.szAcctName, MAX_ACCTNAME_BYTES);
    szAccountName[MAX_ACCTNAME_BYTES - 1] = '\0';


    // Cleanup any remaining rowsets
    hr = CResults.CleanUpResult();
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Did we find him?
    if (*pqwUserID == 0)
    {
        // The user was not found
        hr = HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
    }

lDone:

    // If failed, report the hr and if it came from the stored proc
    if (FAILED(hr) && (hr != HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER)))
    {
        XomNtEvent(XEVENT_PRESENCE_CODE_356, "SProcGetUserIDByName failed AcctName=%s hr=%X", szAccountName, hr);
        *pqwUserID = 0;
    }
    else if (SUCCEEDED(hr))
    {
        // Don't propigate OLEDB success codes
        hr = S_OK;
    }

    return hr;
}


/*****************************************************************************

CProfileStore::SProcGetAccountNameByID

Calls the p_pres_get_user_name stored procedure to get the given user's
account name via their user id.

*****************************************************************************/
HRESULT CProfileStore::SProcGetAccountNameByID(QWORD qwUserID, LPSTR szAccountName, DWORD *pcbAccountName)
{
    // Check parameters
    if ((qwUserID == 0) ||
        (szAccountName == NULL) ||
        (pcbAccountName == NULL))
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    CComPtr<IRowset> piRowset = NULL;
    CWSODBWResult CResults(ErrorCallback);
    DWORD cRows = 0;

    // Parameter structures
    struct sParams_t {
        INT iRet;
        QWORD qwUserID;
    } sParams;

    static WSTCOMMANDPARAM rgwstcpParams[] = {
        {1, DBPARAMIO_OUTPUT, DBTYPE_I4,  sizeof(sParams.iRet), offsetof(sParams_t, iRet), NULL},
        {2, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwUserID), offsetof(sParams_t, qwUserID), NULL}
    };

    WSTCOMMANDINFO wstciParams = {
        sizeof(sParams),
        &sParams,
        ARRAY_ELEMENTS(rgwstcpParams),
        rgwstcpParams
    };

    static WCHAR wszCmd[] = L"{ ? = call p_pres_get_user_name (?) }";

    // Set the parameters
    sParams.iRet = XPROFILE_NO_RESULT;
    sParams.qwUserID = qwUserID;

    // Execute the proc
    hr = m_piCommand->Execute(
        WRITETHENREAD_COMMANDTYPE,
        GetUserBucket(qwUserID),
        wszCmd,
        &wstciParams,
        (IUnknown **)&piRowset,
        NULL,
        DBGUID_DEFAULT,
        IID_IRowset);
    if (FAILED(hr))
    {
        // Run the error through the OLEBD wrapper to get details
        CResults.GetErrorHandler()->HandleError(hr, "SProcGetAccountNameByID failed to execute stored proc");
        goto lDone;
    }

    // Attach the wrapper
    hr = CResults.InitializeWithIRowset(piRowset);
    piRowset = NULL;
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Check for a return
    if((sParams.iRet != XPROFILE_NO_RESULT) && (FAILED((HRESULT)sParams.iRet)))
    {
        hr = (DWORD) sParams.iRet;
        goto lDone;
    }


    {
        static DBBINDING _bind[] = {
            WSBIND(1, 0, DBTYPE_STR, MAX_ACCTNAME_BYTES)
        };

        hr = CResults.SetBindings(_bind, ARRAY_ELEMENTS(_bind));
        if(FAILED(hr))
        {
            goto lDone;
        }
    }

    cRows = 1;

    hr = CResults.GetRows(&cRows, szAccountName, MAX_ACCTNAME_BYTES);
    if(FAILED(hr))
    {
        goto lDone;
    }

    szAccountName[MAX_ACCTNAME_BYTES - 1] = '\0';
    *pcbAccountName = strlen(szAccountName) + 1;
    szAccountName[*pcbAccountName - 1] = '\0';

    hr = CResults.Clear();
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Get final return code
    if (sParams.iRet == XPROFILE_NO_RESULT)
    {
        hr = E_FAIL;
    }
    else
    {
        hr = (DWORD) sParams.iRet;
    }

lDone:

    // If failed, report the hr and if it came from the stored proc
    if (FAILED(hr))
    {
        if(sParams.iRet != XPROFILE_NO_RESULT)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_357, "p_pres_get_user_name  returned failure UserID=%I64X hr=%X", qwUserID, hr);
        }
        else
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_358, "SProcGetAccountNameByID failed UserID=%I64X hr=%X", qwUserID, hr);
        }

        if (pcbAccountName != NULL)
        {
            *pcbAccountName = 0;
        }
        if (szAccountName != NULL)
        {
            szAccountName[0] = '\0';
        }
    }

    return hr;
}

/*****************************************************************************

CProfileStore::SProcUpdateNameOthers

Calls the p_pres_update_name_other stored procedure on each physical parition

*****************************************************************************/
HRESULT CProfileStore::SProcUpdateNameOthers(
    QWORD qwUserID,
    LPCSTR szAccountName)
{
    // Check parameters
    if ((qwUserID == 0) ||
        (szAccountName == NULL))
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    CComPtr<IRowset> piRowset = NULL;
    CWSODBWResult CResults(ErrorCallback);

    // Parameter structures
    struct sParams_t {
        INT iRet;
        QWORD qwUserID;
        CHAR szAcctName[MAX_ACCTNAME_BYTES];
    } sParams;

    static WSTCOMMANDPARAM rgwstcpParams[] = {
        {1, DBPARAMIO_OUTPUT, DBTYPE_I4,  sizeof(sParams.iRet), offsetof(sParams_t, iRet), NULL},
        {2, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwUserID), offsetof(sParams_t, qwUserID), NULL},
        {3, DBPARAMIO_INPUT,  DBTYPE_STR, sizeof(sParams.szAcctName), offsetof(sParams_t, szAcctName), NULL},
    };

    WSTCOMMANDINFO wstciParams = {
        sizeof(sParams),
        &sParams,
        ARRAY_ELEMENTS(rgwstcpParams),
        rgwstcpParams
    };

    static WCHAR wszCmd[] = L"{ ? = call p_pres_update_name_other (?, ?) }";

    // Set the parameters
    sParams.iRet = XPROFILE_NO_RESULT;
    sParams.qwUserID = qwUserID;
    strncpy(sParams.szAcctName, szAccountName, MAX_ACCTNAME_BYTES);
    sParams.szAcctName[MAX_ACCTNAME_BYTES - 1] = '\0';

    // Execute the proc
    hr = m_piCommand->Execute(
        WRITEONLY_COMMANDTYPE,
        ALL_DATABASES,
        wszCmd,
        &wstciParams,
        (IUnknown **)&piRowset,
        NULL,
        DBGUID_DEFAULT,
        IID_IRowset);
    if (FAILED(hr))
    {
        // Run the error through the OLEBD wrapper to get details
        CResults.GetErrorHandler()->HandleError(hr, "SProcUpdateNameOthers failed to execute stored proc");
        goto lDone;
    }

    // Should be no rowsets comming back
    piRowset = NULL;

    // Get final return code
    if (sParams.iRet == XPROFILE_NO_RESULT)
    {
        hr = E_FAIL;
    }
    else
    {
        hr = (DWORD) sParams.iRet;
    }

lDone:

    // If failed, report the hr and if it came from the stored proc
    if (FAILED(hr))
    {
        if(sParams.iRet != XPROFILE_NO_RESULT)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_359, "p_pres_update_name_other  returned failure UserID=%I64X hr=%X", qwUserID, hr);
        }
        else
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_360, "SProcUpdateNameOthers failed UserID=%I64X hr=%X", qwUserID, hr);
        }
    }

    return hr;
}

/*****************************************************************************

CProfileStore::SProcUpdateNameSelf

Calls the p_pres_update_name_self stored procedure to update our own name so
we won't trigger the name change ritual again.

*****************************************************************************/
HRESULT CProfileStore::SProcUpdateNameSelf(
        QWORD qwUserID,
        LPCSTR szAccountName)
{
    // Check parameters
    if ((qwUserID == 0) ||
        (szAccountName == NULL))
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    CComPtr<IRowset> piRowset = NULL;
    CWSODBWResult CResults(ErrorCallback);

    // Parameter structures
    struct sParams_t {
        INT iRet;
        QWORD qwUserID;
        CHAR szAcctName[MAX_ACCTNAME_BYTES];
    } sParams;

    static WSTCOMMANDPARAM rgwstcpParams[] = {
        {1, DBPARAMIO_OUTPUT, DBTYPE_I4,  sizeof(sParams.iRet), offsetof(sParams_t, iRet), NULL},
        {2, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwUserID), offsetof(sParams_t, qwUserID), NULL},
        {3, DBPARAMIO_INPUT,  DBTYPE_STR, sizeof(sParams.szAcctName), offsetof(sParams_t, szAcctName), NULL},
    };

    WSTCOMMANDINFO wstciParams = {
        sizeof(sParams),
        &sParams,
        ARRAY_ELEMENTS(rgwstcpParams),
        rgwstcpParams
    };

    static WCHAR wszCmd[] = L"{ ? = call p_pres_update_name_self (?, ?) }";

    // Set the parameters
    sParams.iRet = XPROFILE_NO_RESULT;
    sParams.qwUserID = qwUserID;
    strncpy(sParams.szAcctName, szAccountName, MAX_ACCTNAME_BYTES);
    sParams.szAcctName[MAX_ACCTNAME_BYTES - 1] = '\0';

    // Execute the proc
    hr = m_piCommand->Execute(
        WRITEONLY_COMMANDTYPE,
        GetUserBucket(qwUserID),
        wszCmd,
        &wstciParams,
        (IUnknown **)&piRowset,
        NULL,
        DBGUID_DEFAULT,
        IID_IRowset);
    if (FAILED(hr))
    {
        // Run the error through the OLEBD wrapper to get details
        CResults.GetErrorHandler()->HandleError(hr, "SProcGetAccountNameByID failed to execute stored proc");
        goto lDone;
    }

    // Should be no rowsets comming back
    piRowset = NULL;

    // Get final return code
    if (sParams.iRet == XPROFILE_NO_RESULT)
    {
        hr = E_FAIL;
    }
    else
    {
        hr = (DWORD) sParams.iRet;
    }

lDone:

    // If failed, report the hr and if it came from the stored proc
    if (FAILED(hr))
    {
        if(sParams.iRet != XPROFILE_NO_RESULT)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_361, "p_pres_update_name_self  returned failure UserID=%I64X BuddyID=%I64X hr=%X", qwUserID, hr);
        }
        else
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_362, "SProcUpdateNameSelf failed UserID=%I64X BuddyID=%I64X hr=%X", qwUserID, hr);
        }
    }

    return hr;
}

/*****************************************************************************

CProfileStore::UpdateNameAll

Updates a given user's name in their record and all of their buddies' records.

*****************************************************************************/
HRESULT CProfileStore::UpdateNameAll(
        QWORD qwUserID,
        LPCSTR szAccountName)
{
    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Updating user %I64X to name %s",
        qwUserID,
        szAccountName);

    HRESULT hr = S_OK;


    hr = SProcUpdateNameOthers(qwUserID, szAccountName);
    if (FAILED(hr))
    {
        // We'll try again next Alive/logon
        goto lDone;
    }

    // Update ourself
    hr = SProcUpdateNameSelf(qwUserID, szAccountName);
    if (FAILED(hr))
    {
        // We'll try again next Alive/logon
        goto lDone;
    }

lDone:

    return hr;
}

/*****************************************************************************

CProfileStore::SProcInsertUser

Calls the p_pres_insert_user stored procedure to insert a new user.

*****************************************************************************/
HRESULT CProfileStore::SProcInsertUser(
    QWORD qwUserID,
    LPCSTR szAccountName,
    DWORD dwTitleID)
{
    // Check parameters
    if ((qwUserID == 0) ||
        (szAccountName == NULL))
    {
        return E_INVALIDARG;
    }

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Going to SQL for SProcInsertUser");

    HRESULT hr = S_OK;
    CComPtr<IRowset> piRowset = NULL;
    CWSODBWResult CResults(ErrorCallback);
    LONG lBucket;

    // Parameter structures
    struct sParams_t {
        INT iRet;
        WORD wBucket;
        QWORD qwUserID;
        DWORD dwTitleID;
        CHAR szAcctName[MAX_ACCTNAME_BYTES];
    } sParams;

    static WSTCOMMANDPARAM rgwstcpParams[] = {
        {1, DBPARAMIO_OUTPUT, DBTYPE_I4,  sizeof(sParams.iRet), offsetof(sParams_t, iRet), NULL},
        {2, DBPARAMIO_INPUT,  DBTYPE_I2,  sizeof(sParams.wBucket), offsetof(sParams_t, wBucket), NULL},
        {3, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwUserID), offsetof(sParams_t, qwUserID), NULL},
        {4, DBPARAMIO_INPUT,  DBTYPE_STR, sizeof(sParams.szAcctName), offsetof(sParams_t, szAcctName), NULL},
        {5, DBPARAMIO_INPUT,  DBTYPE_I4,  sizeof(sParams.dwTitleID), offsetof(sParams_t, dwTitleID), NULL}
    };

    WSTCOMMANDINFO wstciParams = {
        sizeof(sParams),
        &sParams,
        ARRAY_ELEMENTS(rgwstcpParams),
        rgwstcpParams
    };

    static WCHAR wszCmd[] = L"{ ? = call p_pres_insert_user (?, ?, ?, ?) }";

    // Get the bucket number
    lBucket = GetUserBucket(qwUserID);

    // Set the parameters
    sParams.iRet = XPROFILE_NO_RESULT;
    sParams.wBucket = (WORD)lBucket;
    sParams.qwUserID = qwUserID;
    strncpy(sParams.szAcctName, szAccountName, MAX_ACCTNAME_BYTES);
    sParams.dwTitleID = dwTitleID;
    sParams.szAcctName[MAX_ACCTNAME_BYTES - 1] = '\0';

    // Execute the proc
    hr = m_piCommand->Execute(
        WRITEONLY_COMMANDTYPE,
        lBucket,
        wszCmd,
        &wstciParams,
        (IUnknown **)&piRowset,
        NULL,
        DBGUID_DEFAULT,
        IID_IRowset);
    if (FAILED(hr))
    {
        // Run the error through the OLEBD wrapper to get details
        CResults.GetErrorHandler()->HandleError(hr, "SProcInsertUser failed to execute stored proc");
        goto lDone;
    }

    // Should be no rowsets comming back
    piRowset = NULL;

    // Get final return code
    if (sParams.iRet == XPROFILE_NO_RESULT)
    {
        hr = E_FAIL;
    }
    else
    {
        hr = (DWORD) sParams.iRet;
    }

lDone:

    // If failed, report the hr and if it came from the stored proc
    if (FAILED(hr))
    {
        if(sParams.iRet != XPROFILE_NO_RESULT)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_363, "p_pres_insert_user  returned failure UserID=%I64X hr=%X", qwUserID, hr);
        }
        else
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_364, "SProcInsertUser failed UserID=%I64X BuddyID=%I64X hr=%X", qwUserID, hr);
        }
    }

    return hr;
}

/*****************************************************************************

CProfileStore::SProcClearFlushTickets

Calls the p_pres_clear_flush_tickets stored procedure to clear the user's
flush tickets bit.

*****************************************************************************/
HRESULT CProfileStore::SProcClearFlushTickets(
    QWORD qwUserID)
{
    // Check parameters
    if (qwUserID == 0)
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    CComPtr<IRowset> piRowset = NULL;
    CWSODBWResult CResults(ErrorCallback);

    // Parameter structures
    struct sParams_t {
        INT iRet;
        QWORD qwUserID;
    } sParams;

    static WSTCOMMANDPARAM rgwstcpParams[] = {
        {1, DBPARAMIO_OUTPUT, DBTYPE_I4,  sizeof(sParams.iRet), offsetof(sParams_t, iRet), NULL},
        {2, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwUserID), offsetof(sParams_t, qwUserID), NULL},
    };

    WSTCOMMANDINFO wstciParams = {
        sizeof(sParams),
        &sParams,
        ARRAY_ELEMENTS(rgwstcpParams),
        rgwstcpParams
    };

    static WCHAR wszCmd[] = L"{ ? = call p_pres_clear_flush_tickets ( ? ) }";

    // Set the parameters
    sParams.iRet = XPROFILE_NO_RESULT;
    sParams.qwUserID = qwUserID;

    // Execute the proc
    hr = m_piCommand->Execute(
        WRITEONLY_COMMANDTYPE,
        GetUserBucket(qwUserID),
        wszCmd,
        &wstciParams,
        (IUnknown **)&piRowset,
        NULL,
        DBGUID_DEFAULT,
        IID_IRowset);
    if (FAILED(hr))
    {
        // Run the error through the OLEBD wrapper to get details
        CResults.GetErrorHandler()->HandleError(hr, "SProcClearFlushTickets failed to execute stored proc");
        goto lDone;
    }

    // Should be no rowsets comming back
    piRowset = NULL;

    // Get final return code
    if (sParams.iRet == XPROFILE_NO_RESULT)
    {
        hr = E_FAIL;
    }
    else
    {
        hr = (DWORD) sParams.iRet;
    }

lDone:

    // If failed, report the hr and if it came from the stored proc
    if (FAILED(hr))
    {
        if(sParams.iRet != XPROFILE_NO_RESULT)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_365, "p_pres_clear_flush_tickets  returned failure UserID=%I64X hr=%X", qwUserID, hr);
        }
        else
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_366, "SProcClearFlushTickets failed UserID=%I64X hr=%X", qwUserID, hr);
        }
    }

    return hr;
}

/*****************************************************************************

CProfileStore::SProcTeamPUIDGen

Calls the p_team_get_next_id stored procedure

*****************************************************************************/
HRESULT CProfileStore::SProcTeamPUIDGen(DWORD dwBlockSize, QWORD *pqwStart)
{
    // Doing this allows only the first CallProc call to have to do any parsing
    static CWSProcCache cache;

    HRESULT hr = S_OK;

    CODBWSession ses;

    int dwBucket = 0; // take puids from bucket 0

    // Connect to the NPDB database
    hr = ses.InitializeEx( g_CPresCfg.GetNPDBConnectionString() );
    if( FAILED( hr ) )
    {
        goto lDone;
    }

    // Get the next block of team puids
    hr = ses.CallProc( &cache, L"{ %T = CALL p_team_get_next_id;1 ( %I, %I, %-Q) }",
        dwBucket,
        dwBlockSize);
    if( FAILED( hr ) )
    {
        goto lDone;
    }

    hr = ses.GetStatus();
    if( FAILED( hr ) )
    {
        goto lDone;
    }

    QWORD qwStart = *((QWORD *) ses.GetParam(4));

    *pqwStart = qwStart;

lDone:

    // If failed, report the hr and if it came from the stored proc
    if (FAILED(hr))
    {
        XomNtEvent(XEVENT_PRESENCE_CODE_367, "SProcTeamPUIDGen failed Bucket=%d BlockSize=%d hr=0x%X",
            dwBucket,
            dwBlockSize,
            hr);
    }

    return hr;
}


/*****************************************************************************

CProfileStore::SProcGetTeamNameByID

Calls the p_team_get_team_name stored procedure to get the given team's
name from its id.

*****************************************************************************/
HRESULT CProfileStore::SProcGetTeamNameByID(
    QWORD qwTeamID,
    LPWSTR wszTeamName,
    DWORD *pcbTeamName)
{
    // Check parameters
    if ((qwTeamID == 0) ||
        (wszTeamName == NULL) ||
        (pcbTeamName == NULL))
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    CComPtr<IRowset> piRowset = NULL;
    CWSODBWResult CResults(ErrorCallback);
    DWORD cRows = 0;

    // Parameter structures
    struct sParams_t {
        INT iRet;
        QWORD qwTeamID;
    } sParams;

    static WSTCOMMANDPARAM rgwstcpParams[] = {
        {1, DBPARAMIO_OUTPUT, DBTYPE_I4,  sizeof(sParams.iRet), offsetof(sParams_t, iRet), NULL},
        {2, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwTeamID), offsetof(sParams_t, qwTeamID), NULL}
    };

    WSTCOMMANDINFO wstciParams = {
        sizeof(sParams),
        &sParams,
        ARRAY_ELEMENTS(rgwstcpParams),
        rgwstcpParams
    };

    static WCHAR wszCmd[] = L"{ ? = call p_team_get_team_name (?) }";

    // Set the parameters
    sParams.iRet = XPROFILE_NO_RESULT;
    sParams.qwTeamID = qwTeamID;

    // Execute the proc
    hr = m_piCommand->Execute(
        WRITETHENREAD_COMMANDTYPE,
        GetTeamBucket(qwTeamID),
        wszCmd,
        &wstciParams,
        (IUnknown **)&piRowset,
        NULL,
        DBGUID_DEFAULT,
        IID_IRowset);
    if (FAILED(hr))
    {
        // Run the error through the OLEBD wrapper to get details
        CResults.GetErrorHandler()->HandleError(hr, "SProcGetTeamNameByID failed to execute stored proc");
        goto lDone;
    }

    // Check for a return
    if((sParams.iRet != XPROFILE_NO_RESULT) && (FAILED((HRESULT)sParams.iRet)))
    {
        hr = (DWORD) sParams.iRet;
        goto lDone;
    }

    // Attach the wrapper
    hr = CResults.InitializeWithIRowset(piRowset);
    piRowset = NULL;
    if (FAILED(hr))
    {
        goto lDone;
    }

    {
        static DBBINDING _bind[] = {
            WSBIND(1, 0, DBTYPE_WSTR, MAX_TEAM_NAME_BYTES)
        };

        hr = CResults.SetBindings(_bind, ARRAY_ELEMENTS(_bind));
        if(FAILED(hr))
        {
            goto lDone;
        }
    }

    cRows = 1;

    memset(wszTeamName, 0, MAX_TEAM_NAME_BYTES);
    hr = CResults.GetRows(&cRows, wszTeamName, MAX_TEAM_NAME_BYTES);
    if(FAILED(hr))
    {
        goto lDone;
    }

    wszTeamName[MAX_TEAM_NAME_CHAR - 1] = L'\0';
    *pcbTeamName = (wcslen(wszTeamName) + 1) * 2;

    hr = CResults.Clear();
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Get final return code
    if (sParams.iRet == XPROFILE_NO_RESULT)
    {
        hr = E_FAIL;
    }
    else
    {
        hr = (DWORD) sParams.iRet;
    }

lDone:

    // If failed, report the hr and if it came from the stored proc
    if (FAILED(hr))
    {
        if(sParams.iRet != XPROFILE_NO_RESULT)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_368, "p_team_get_team_name  returned failure TeamID=%I64X hr=%X", qwTeamID, hr);
        }
        else
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_369, "SProcGetTeamNameByID failed TeamID=%I64X hr=%X", qwTeamID, hr);
        }

        if (pcbTeamName != NULL)
        {
            *pcbTeamName = 0;
        }
        if (wszTeamName != NULL)
        {
            wszTeamName[0] = L'\0';
        }
    }

    return hr;
}

/*****************************************************************************

CProfileStore::SProcGetUserTeams

Calls the p_team_get_user_teams stored procedure to get the given users teams
for a given title id.

*****************************************************************************/
HRESULT CProfileStore::SProcGetUserTeams(
    DWORD dwTitleID,
    QWORD qwUserID,
    BOOL fShowRecruits,
    DWORD *pcTeams,
    P_REPLY_USER_TEAM *rgTeams)
{
    // Check parameters
    if ((dwTitleID == 0) ||
        (qwUserID == 0) ||
        (pcTeams == NULL) ||
        (rgTeams == NULL))
    {
        return E_INVALIDARG;
    }
    *pcTeams = 0;

    HRESULT hr = S_OK;
    CComPtr<IRowset> piRowset = NULL;
    CWSODBWResult CResults(ErrorCallback);
    DWORD cRows = 0;

    // Parameter structures
    struct sParams_t {
        INT iRet;
        QWORD qwUserID;
        DWORD dwTitleID;
        BOOL fShowRecruits;
    } sParams;

    static WSTCOMMANDPARAM rgwstcpParams[] = {
        {1, DBPARAMIO_OUTPUT, DBTYPE_I4,  sizeof(sParams.iRet), offsetof(sParams_t, iRet), NULL},
        {2, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwUserID), offsetof(sParams_t, qwUserID), NULL},
        {3, DBPARAMIO_INPUT,  DBTYPE_I4,  sizeof(sParams.dwTitleID), offsetof(sParams_t, dwTitleID), NULL},
        {4, DBPARAMIO_INPUT,  DBTYPE_I1,  sizeof(sParams.fShowRecruits), offsetof(sParams_t, fShowRecruits), NULL}
    };

    WSTCOMMANDINFO wstciParams = {
        sizeof(sParams),
        &sParams,
        ARRAY_ELEMENTS(rgwstcpParams),
        rgwstcpParams
    };

    static WCHAR wszCmd[] = L"{ ? = call p_team_get_user_teams (?, ?, ?) }";

    // Set the parameters
    sParams.iRet = XPROFILE_NO_RESULT;
    sParams.qwUserID = qwUserID;
    sParams.dwTitleID = dwTitleID;
    sParams.fShowRecruits = fShowRecruits;

    // Execute the proc
    hr = m_piCommand->Execute(
        WRITETHENREAD_COMMANDTYPE,
        GetUserBucket(qwUserID),
        wszCmd,
        &wstciParams,
        (IUnknown **)&piRowset,
        NULL,
        DBGUID_DEFAULT,
        IID_IRowset);
    if (FAILED(hr))
    {
        // Run the error through the OLEBD wrapper to get details
        CResults.GetErrorHandler()->HandleError(hr, "SProcGetUserTeams failed to execute stored proc");
        goto lDone;
    }

    // Check for a return
    if((sParams.iRet != XPROFILE_NO_RESULT) && (FAILED((HRESULT)sParams.iRet)))
    {
        hr = (DWORD) sParams.iRet;
        goto lDone;
    }

    // Attach the wrapper
    hr = CResults.InitializeWithIRowset(piRowset);
    piRowset = NULL;
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Binding structure
    struct sUserTeamEntry_t {
        QWORD qwTeamID;
        BOOL fMember;
        WCHAR wszTeamName[MAX_TEAM_NAME_CHAR];
    } sUserTeamEntry;

    // Bind
    {
        static DBBINDING _bind[] = {
            WSBIND(1, offsetof(sUserTeamEntry_t, qwTeamID), DBTYPE_I8, 0),
            WSBIND(2, offsetof(sUserTeamEntry_t, fMember), DBTYPE_UI1, 0),
            WSBIND(3, offsetof(sUserTeamEntry_t, wszTeamName), DBTYPE_WSTR, MAX_TEAM_NAME_BYTES),
        };

        hr = CResults.SetBindings(_bind, ARRAY_ELEMENTS(_bind));
        if(FAILED(hr))
        {
            goto lDone;
        }
    }

    for (;;)
    {
        cRows = 1;
        memset(&rgTeams[*pcTeams], 0, sizeof(P_REPLY_USER_TEAM));

        hr = CResults.GetRows(&cRows,  &sUserTeamEntry, sizeof(sUserTeamEntry));
        if(FAILED(hr))
        {
            goto lDone;
        }

        if (cRows == 1)
        {
            rgTeams[*pcTeams].qwTeamID= sUserTeamEntry.qwTeamID;
            rgTeams[*pcTeams].fMember= sUserTeamEntry.fMember;
            memcpy(rgTeams[*pcTeams].wszTeamName, sUserTeamEntry.wszTeamName, MAX_TEAM_NAME_BYTES);

            *pcTeams += 1;
        }
        else
        {
            break;
        }

        if (*pcTeams >= XONLINE_MAX_TEAM_COUNT)
        {
            break;
        }
    }

    hr = CResults.Clear();
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Get final return code
    if (sParams.iRet == XPROFILE_NO_RESULT)
    {
        hr = E_FAIL;
    }
    else
    {
        hr = (DWORD) sParams.iRet;
    }

lDone:

    // If failed, report the hr and if it came from the stored proc
    if (FAILED(hr))
    {
        if(sParams.iRet != XPROFILE_NO_RESULT)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_370, "p_team_get_user_teams  returned failure UserID=%I64X TitleID=%d hr=%X", qwUserID, dwTitleID, hr);
        }
        else
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_371, "SProcGetUserTeams failed UserID=%I64X TitleID=%d hr=%X", qwUserID, dwTitleID, hr);
        }

        *pcTeams = 0;
    }

    return hr;
}

/*****************************************************************************

CProfileStore::SProcGetTeamListTeam

Calls the p_team_list_team stored procedure

*****************************************************************************/
HRESULT CProfileStore::SProcGetTeamListTeam(
    DWORD dwTitleID,
    QWORD qwTeamID,
    CTCPCntVarBuffer **ppReply)
{
    // Check parameters
    if ((qwTeamID == 0) ||
        (qwTeamID == 0) ||
        (ppReply == NULL))
    {
        return E_INVALIDARG;
    }
    *ppReply = NULL;

    HRESULT hr = S_OK;
    CComPtr<IRowset> piRowset = NULL;
    CWSODBWResult CResults(ErrorCallback);
    DWORD cRows = 0;
    CTCPCntVarBuffer *pReply = NULL;
    BYTE *pbWrite = NULL;
    P_REPLY_TEAM *psReplyTeam = NULL;
    SYSTEMTIME systime;

    // Parameter structures
    struct sParams_t {
        INT iRet;
        DWORD dwTitleID;
        QWORD qwTeamID;
    } sParams;

    static WSTCOMMANDPARAM rgwstcpParams[] = {
        {1, DBPARAMIO_OUTPUT, DBTYPE_I4,  sizeof(sParams.iRet), offsetof(sParams_t, iRet), NULL},
        {2, DBPARAMIO_INPUT,  DBTYPE_I4,  sizeof(sParams.dwTitleID), offsetof(sParams_t, dwTitleID), NULL},
        {3, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwTeamID), offsetof(sParams_t, qwTeamID), NULL}
    };

    WSTCOMMANDINFO wstciParams = {
        sizeof(sParams),
        &sParams,
        ARRAY_ELEMENTS(rgwstcpParams),
        rgwstcpParams
    };

    static WCHAR wszCmd[] = L"{ ? = call p_team_list_team (?, ?) }";

    // Binding structure
    struct sTeamListEntry_t {
        WCHAR wszTeamName[MAX_TEAM_NAME_CHAR];
        DWORD dwNumMembers;
        WCHAR wszTeamDescription[MAX_TEAM_DESCRIPTION_CHAR];
        WCHAR wszTeamMotto[MAX_TEAM_MOTTO_CHAR];
        WCHAR wszTeamURL[MAX_TEAM_URL_CHAR];
        DWORD cbTeamData;
        BYTE pbTeamData[MAX_TEAM_DATA_BYTES];
        DATE dtCreate;
    } sTeamListEntry;

    // Set the parameters
    sParams.iRet = XPROFILE_NO_RESULT;
    sParams.dwTitleID = dwTitleID;
    sParams.qwTeamID = qwTeamID;

    // Execute the proc
    hr = m_piCommand->Execute(
        WRITETHENREAD_COMMANDTYPE,
        GetTeamBucket(qwTeamID),
        wszCmd,
        &wstciParams,
        (IUnknown **)&piRowset,
        NULL,
        DBGUID_DEFAULT,
        IID_IRowset);
    if (FAILED(hr))
    {
        // Run the error through the OLEBD wrapper to get details
        CResults.GetErrorHandler()->HandleError(hr, "SProcGetTeamListTeam failed to execute stored proc");
        goto lDone;
    }

    // Check for a return
    if((sParams.iRet != XPROFILE_NO_RESULT) && (FAILED((HRESULT)sParams.iRet)))
    {
        hr = (DWORD) sParams.iRet;
        goto lDone;
    }

    // Attach the wrapper
    hr = CResults.InitializeWithIRowset(piRowset);
    piRowset = NULL;
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Bind
    {
        static DBBINDING _bind[] = {
            WSBIND(1, offsetof(sTeamListEntry_t, wszTeamName), DBTYPE_WSTR, MAX_TEAM_NAME_BYTES),
            WSBIND(2, offsetof(sTeamListEntry_t, dwNumMembers), DBTYPE_I4, 0),
            WSBIND(3, offsetof(sTeamListEntry_t, wszTeamDescription), DBTYPE_WSTR, MAX_TEAM_DESCRIPTION_BYTES),
            WSBIND(4, offsetof(sTeamListEntry_t, wszTeamMotto), DBTYPE_WSTR, MAX_TEAM_MOTTO_BYTES),
            WSBIND(5, offsetof(sTeamListEntry_t, wszTeamURL), DBTYPE_WSTR, MAX_TEAM_URL_BYTES),
            WSBIND2(6, offsetof(sTeamListEntry_t, pbTeamData), DBTYPE_BYTES, MAX_TEAM_DATA_BYTES, DBPART_VALUE | DBPART_LENGTH, offsetof(sTeamListEntry_t, cbTeamData), 0),
            WSBIND(7, offsetof(sTeamListEntry_t, dtCreate), DBTYPE_DATE, 0)
        };

        hr = CResults.SetBindings(_bind, ARRAY_ELEMENTS(_bind));
        if(FAILED(hr))
        {
            goto lDone;
        }
    }

    cRows = 1;

    memset(&sTeamListEntry, 0, sizeof(sTeamListEntry));
    hr = CResults.GetRows(&cRows, &sTeamListEntry, sizeof(sTeamListEntry));
    if(FAILED(hr))
    {
        goto lDone;
    }

    // Build the results as a team response

    pReply = CTCPCntVarBuffer::CreateInstance(
        sizeof(P_REPLY_TEAM) +
        MAX_TEAM_NAME_BYTES +
        MAX_TEAM_DESCRIPTION_BYTES +
        MAX_TEAM_MOTTO_BYTES +
        MAX_TEAM_URL_BYTES +
        MAX_TEAM_DATA_BYTES);
    if (pReply == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pbWrite = pReply->GetBuffer();

    psReplyTeam = (P_REPLY_TEAM *) pbWrite;
    pbWrite += sizeof(P_REPLY_TEAM);

    psReplyTeam->qwTeamID = qwTeamID;
    psReplyTeam->dwNumMembers = sTeamListEntry.dwNumMembers;
    psReplyTeam->cbTeamName =  (WORD) (wcslen(sTeamListEntry.wszTeamName) + 1) * sizeof(WCHAR);
    psReplyTeam->cbTeamDescription = (WORD) (wcslen(sTeamListEntry.wszTeamDescription) + 1) * sizeof(WCHAR);
    psReplyTeam->cbTeamMotto = (WORD) (wcslen(sTeamListEntry.wszTeamMotto) + 1) * sizeof(WCHAR);
    psReplyTeam->cbTeamURL = (WORD) (wcslen(sTeamListEntry.wszTeamURL) + 1) * sizeof(WCHAR);
    psReplyTeam->cbTeamData = (WORD) sTeamListEntry.cbTeamData;
    VariantTimeToSystemTime( sTeamListEntry.dtCreate, &systime );
    SystemTimeToFileTime( &systime, &(psReplyTeam->ftCreated) );

    memcpy(pbWrite, sTeamListEntry.wszTeamName, psReplyTeam->cbTeamName);
    pbWrite += psReplyTeam->cbTeamName;
    memcpy(pbWrite, sTeamListEntry.wszTeamDescription, psReplyTeam->cbTeamDescription);
    pbWrite += psReplyTeam->cbTeamDescription;
    memcpy(pbWrite, sTeamListEntry.wszTeamMotto, psReplyTeam->cbTeamMotto);
    pbWrite += psReplyTeam->cbTeamMotto;
    memcpy(pbWrite, sTeamListEntry.wszTeamURL, psReplyTeam->cbTeamURL);
    pbWrite += psReplyTeam->cbTeamURL;
    memcpy(pbWrite, sTeamListEntry.pbTeamData, psReplyTeam->cbTeamData);
    pbWrite += psReplyTeam->cbTeamData;

    pReply->Resize(pbWrite - pReply->GetBuffer());

    hr = CResults.Clear();
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Get final return code
    if (sParams.iRet == XPROFILE_NO_RESULT)
    {
        hr = E_FAIL;
    }
    else
    {
        hr = (DWORD) sParams.iRet;
    }

    // Caller takes over our reference
    *ppReply = pReply;
    pReply = NULL;

lDone:

    if (pReply != NULL)
    {
        pReply->Release();
    }

    // If failed, report the hr and if it came from the stored proc
    if (FAILED(hr))
    {
        if(sParams.iRet != XPROFILE_NO_RESULT)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_372, "p_team_list_team  returned failure TeamID=%I64X hr=%X", qwTeamID, hr);
        }
        else
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_373, "SProcGetTeamListTeam failed TeamID=%I64X hr=%X", qwTeamID, hr);
        }
    }

    return hr;
}

/*****************************************************************************

CProfileStore::SProcGetTeamListMembers

Calls the p_team_list_members stored procedure

*****************************************************************************/
HRESULT CProfileStore::SProcGetTeamListMembers(
    DWORD dwTitleID,
    QWORD qwTeamID,
    BOOL fShowRecruits,
    DWORD *pcMembers,
    QWORD *pqwMembers,
    CTCPCntVarBuffer **ppReply)
{
    // Check parameters
    if ((qwTeamID == 0) ||
        (qwTeamID == NULL) ||
        (ppReply == NULL))
    {
        return E_INVALIDARG;
    }
    *pcMembers = 0;
    *ppReply = NULL;

    HRESULT hr = S_OK;
    CComPtr<IRowset> piRowset = NULL;
    CWSODBWResult CResults(ErrorCallback);
    DWORD cRows = 0;
    CTCPCntVarBuffer *pReply = NULL;
    BYTE *pbWrite = NULL;
    P_REPLY_TEAM_MEMBER *psReplyMember = NULL;
    SYSTEMTIME systime;
    DWORD cMembers = 0;

    // Parameter structures
    struct sParams_t {
        INT iRet;
        DWORD dwTitleID;
        QWORD qwTeamID;
        BOOL fShowRecruits;
    } sParams;

    static WSTCOMMANDPARAM rgwstcpParams[] = {
        {1, DBPARAMIO_OUTPUT, DBTYPE_I4,  sizeof(sParams.iRet), offsetof(sParams_t, iRet), NULL},
        {2, DBPARAMIO_INPUT,  DBTYPE_I4,  sizeof(sParams.dwTitleID), offsetof(sParams_t, dwTitleID), NULL},
        {3, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwTeamID), offsetof(sParams_t, qwTeamID), NULL},
        {4, DBPARAMIO_INPUT,  DBTYPE_I1,  sizeof(sParams.fShowRecruits), offsetof(sParams_t, fShowRecruits), NULL}
    };

    WSTCOMMANDINFO wstciParams = {
        sizeof(sParams),
        &sParams,
        ARRAY_ELEMENTS(rgwstcpParams),
        rgwstcpParams
    };

    static WCHAR wszCmd[] = L"{ ? = call p_team_list_members (?, ?, ?) }";

    // Binding structure
    struct sMemberListEntry_t {
        QWORD qwMemberID;
        CHAR szMemberName[MAX_ACCTNAME_BYTES];
        BOOL fMember;
        DWORD dwPrivileges;
        DATE dtMemberSince;
        DWORD cbMemberData;
        BYTE pbMemberData[MAX_TEAM_MEMBER_DATA_BYTES];
    } sMemberListEntry;

    // Set the parameters
    sParams.iRet = XPROFILE_NO_RESULT;
    sParams.dwTitleID = dwTitleID;
    sParams.qwTeamID = qwTeamID;
    sParams.fShowRecruits = fShowRecruits;

    // Execute the proc
    hr = m_piCommand->Execute(
        WRITETHENREAD_COMMANDTYPE,
        GetTeamBucket(qwTeamID),
        wszCmd,
        &wstciParams,
        (IUnknown **)&piRowset,
        NULL,
        DBGUID_DEFAULT,
        IID_IRowset);
    if (FAILED(hr))
    {
        // Run the error through the OLEBD wrapper to get details
        CResults.GetErrorHandler()->HandleError(hr, "SProcGetTeamListTeam failed to execute stored proc");
        goto lDone;
    }

    // Check for a return
    if((sParams.iRet != XPROFILE_NO_RESULT) && (FAILED((HRESULT)sParams.iRet)))
    {
        hr = (DWORD) sParams.iRet;
        goto lDone;
    }

    // Attach the wrapper
    hr = CResults.InitializeWithIRowset(piRowset);
    piRowset = NULL;
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Bind
    {
        static DBBINDING _bind[] = {
            WSBIND(1, offsetof(sMemberListEntry_t, qwMemberID), DBTYPE_I8, 0),
            WSBIND(2, offsetof(sMemberListEntry_t, szMemberName), DBTYPE_STR, MAX_ACCTNAME_BYTES),
            WSBIND(3, offsetof(sMemberListEntry_t, fMember), DBTYPE_UI1, 0),
            WSBIND(4, offsetof(sMemberListEntry_t, dwPrivileges), DBTYPE_I4, 0),
            WSBIND(5, offsetof(sMemberListEntry_t, dtMemberSince), DBTYPE_DATE, 0),
            WSBIND2(6, offsetof(sMemberListEntry_t, pbMemberData), DBTYPE_BYTES, MAX_TEAM_DATA_BYTES, DBPART_VALUE | DBPART_LENGTH, offsetof(sMemberListEntry_t, cbMemberData), 0),
        };

        hr = CResults.SetBindings(_bind, ARRAY_ELEMENTS(_bind));
        if(FAILED(hr))
        {
            goto lDone;
        }
    }

    // Build the results as a team response
    pReply = CTCPCntVarBuffer::CreateInstance(
        ((sizeof(P_REPLY_TEAM_MEMBER) +
         MAX_ACCTNAME_BYTES +
         MAX_TEAM_MEMBER_DATA_BYTES)) * XONLINE_MAX_TEAM_MEMBER_COUNT);
    if (pReply == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pbWrite = pReply->GetBuffer();

    for (;;)
    {

        cRows = 1;

        memset(&sMemberListEntry, 0, sizeof(sMemberListEntry));
        hr = CResults.GetRows(&cRows, &sMemberListEntry, sizeof(sMemberListEntry));
        if(FAILED(hr))
        {
            goto lDone;
        }

        if (cRows == 1)
        {

            psReplyMember = (P_REPLY_TEAM_MEMBER *) pbWrite;
            pbWrite += sizeof(P_REPLY_TEAM_MEMBER);

            psReplyMember->qwMemberID = sMemberListEntry.qwMemberID;
            psReplyMember->cbMemberName =  (BYTE) (strlen(sMemberListEntry.szMemberName) + 1);
            psReplyMember->fMember = (BOOL) (sMemberListEntry.fMember != 0);
            psReplyMember->dwMemberPriv = sMemberListEntry.dwPrivileges;
            psReplyMember->cbMemberData = (WORD) sMemberListEntry.cbMemberData;
            VariantTimeToSystemTime( sMemberListEntry.dtMemberSince, &systime );
            SystemTimeToFileTime( &systime, &(psReplyMember->ftJoined) );

            memcpy(pbWrite, sMemberListEntry.szMemberName, psReplyMember->cbMemberName);
            pbWrite += psReplyMember->cbMemberName;
            memcpy(pbWrite, sMemberListEntry.pbMemberData, psReplyMember->cbMemberData);
            pbWrite += psReplyMember->cbMemberData;

            pqwMembers[cMembers] = sMemberListEntry.qwMemberID;

            cMembers++;
        }
        else
        {
            break;
        }
    }

    pReply->Resize(pbWrite - pReply->GetBuffer());

    hr = CResults.Clear();
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Get final return code
    if (sParams.iRet == XPROFILE_NO_RESULT)
    {
        hr = E_FAIL;
    }
    else
    {
        hr = (DWORD) sParams.iRet;
    }

    // Caller takes over our reference
    *ppReply = pReply;
    pReply = NULL;

    *pcMembers = cMembers;

lDone:

    if (pReply != NULL)
    {
        pReply->Release();
    }

    // If failed, report the hr and if it came from the stored proc
    if (FAILED(hr))
    {
        if(sParams.iRet != XPROFILE_NO_RESULT)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_374, "p_team_list_members  returned failure TeamID=%I64X hr=%X", qwTeamID, hr);
        }
        else
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_375, "SProcGetTeamListMembers failed TeamID=%I64X hr=%X", qwTeamID, hr);
        }
    }

    return hr;
}


/*****************************************************************************

CProfileStore::SProcTeamCreateTeam

Calls the p_team_create_team stored procedure

*****************************************************************************/
HRESULT CProfileStore::SProcTeamCreateTeam(
    QWORD qwTeamID,
    DWORD dwTitleID,
    DWORD dwMaxMembers,
    LPCWSTR wszTeamName,
    LPCWSTR wszTeamDescription,
    LPCWSTR wszTeamMotto,
    LPCWSTR wszTeamURL,
    BYTE *pbTeamData,
    DWORD cbTeamData,
    QWORD qwCreatorUserID,
    LPCSTR szCreatorName,
    BYTE *pbCreatorData,
    DWORD cbCreatorData,
    IWSTDTC *piDTC)
{
    // Check parameters
    if ((qwCreatorUserID == 0) ||
        (qwTeamID == 0) ||
        (wszTeamName == NULL) ||
        (szCreatorName == NULL))
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    CComPtr<IRowset> piRowset = NULL;
    CWSODBWResult CResults(ErrorCallback);
    LONG lBucket;

    // Parameter structures
    struct sParams_t {
        INT iRet;
        DWORD dwTitleID;
        QWORD qwTeamID;
        DWORD dwMaxMembers;
        WCHAR wszTeamName[MAX_TEAM_NAME_CHAR];
        WCHAR wszTeamDescription[MAX_TEAM_DESCRIPTION_CHAR];
        WCHAR wszTeamMotto[MAX_TEAM_MOTTO_CHAR];
        WCHAR wszTeamURL[MAX_TEAM_URL_CHAR];
        BYTE rgbTeamData[MAX_TEAM_DATA_BYTES];
        QWORD qwCreatorID;
        CHAR szCreatorName[MAX_ACCTNAME_BYTES];
        BYTE rgbCreatorData[MAX_TEAM_MEMBER_DATA_BYTES];
        WORD wBucket;
    } sParams;

    WSTCOMMANDPARAM rgwstcpParams[] = {
        {1, DBPARAMIO_OUTPUT, DBTYPE_I4,  sizeof(sParams.iRet), offsetof(sParams_t, iRet), NULL},
        {2, DBPARAMIO_INPUT,  DBTYPE_I4,  sizeof(sParams.dwTitleID), offsetof(sParams_t, dwTitleID), NULL},
        {3, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwTeamID), offsetof(sParams_t, qwTeamID), NULL},
        {4, DBPARAMIO_INPUT,  DBTYPE_I4,  sizeof(sParams.dwMaxMembers), offsetof(sParams_t, dwMaxMembers), NULL},
        {5, DBPARAMIO_INPUT,  DBTYPE_WSTR, sizeof(sParams.wszTeamName), offsetof(sParams_t, wszTeamName), NULL},
        {6, DBPARAMIO_INPUT,  DBTYPE_WSTR, sizeof(sParams.wszTeamDescription), offsetof(sParams_t, wszTeamDescription), NULL},
        {7, DBPARAMIO_INPUT,  DBTYPE_WSTR, sizeof(sParams.wszTeamMotto), offsetof(sParams_t, wszTeamMotto), NULL},
        {8, DBPARAMIO_INPUT,  DBTYPE_WSTR, sizeof(sParams.wszTeamURL), offsetof(sParams_t, wszTeamURL), NULL},
        {9, DBPARAMIO_INPUT,  DBTYPE_BYTES, cbTeamData, offsetof(sParams_t, rgbTeamData), NULL},
        {10, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwCreatorID), offsetof(sParams_t, qwCreatorID), NULL},
        {11, DBPARAMIO_INPUT,  DBTYPE_STR, sizeof(sParams.szCreatorName), offsetof(sParams_t, szCreatorName), NULL},
        {12, DBPARAMIO_INPUT,  DBTYPE_BYTES, cbCreatorData, offsetof(sParams_t, rgbCreatorData), NULL},
        {13, DBPARAMIO_INPUT,  DBTYPE_I2,  sizeof(sParams.wBucket), offsetof(sParams_t, wBucket), NULL}
    };

    WSTCOMMANDINFO wstciParams = {
        sizeof(sParams),
        &sParams,
        ARRAY_ELEMENTS(rgwstcpParams),
        rgwstcpParams
    };

    static WCHAR wszCmd[] = L"{ ? = call p_team_create_team (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?) }";

    // Get the bucket number
    lBucket = GetTeamBucket(qwTeamID);

    // Set the parameters
    sParams.iRet = XPROFILE_NO_RESULT;
    sParams.qwTeamID = qwTeamID;
    sParams.dwTitleID = dwTitleID;
    sParams.dwMaxMembers = dwMaxMembers;
    wcsncpy(sParams.wszTeamName, wszTeamName, MAX_TEAM_NAME_CHAR);
    sParams.wszTeamName[MAX_TEAM_NAME_CHAR - 1] = L'\0';
    wcsncpy(sParams.wszTeamDescription, wszTeamDescription, MAX_TEAM_DESCRIPTION_CHAR);
    sParams.wszTeamDescription[MAX_TEAM_DESCRIPTION_CHAR - 1] = L'\0';
    wcsncpy(sParams.wszTeamMotto, wszTeamMotto, MAX_TEAM_MOTTO_CHAR);
    sParams.wszTeamMotto[MAX_TEAM_MOTTO_CHAR - 1] = L'\0';
    wcsncpy(sParams.wszTeamURL, wszTeamURL, MAX_TEAM_URL_CHAR);
    sParams.wszTeamURL[MAX_TEAM_URL_CHAR - 1] = L'\0';
    memset(sParams.rgbTeamData, 0, MAX_TEAM_DATA_BYTES);
    memcpy(sParams.rgbTeamData, pbTeamData, cbTeamData);
    sParams.qwCreatorID = qwCreatorUserID;
    strncpy(sParams.szCreatorName, szCreatorName, MAX_ACCTNAME_BYTES);
    memset(sParams.rgbCreatorData, 0, MAX_TEAM_MEMBER_DATA_BYTES);
    memcpy(sParams.rgbCreatorData, pbCreatorData, cbCreatorData);
    sParams.wBucket = (WORD)lBucket;

    // Execute the proc
    hr = m_piCommand->Execute(
        WRITEONLY_COMMANDTYPE,
        lBucket,
        wszCmd,
        &wstciParams,
        (IUnknown **)&piRowset,
        piDTC,
        DBGUID_DEFAULT,
        IID_IRowset);
    if (FAILED(hr))
    {
        // Run the error through the OLEBD wrapper to get details
        CResults.GetErrorHandler()->HandleError(hr, "SProcTeamCreateTeam failed to execute stored proc");
        goto lDone;
    }

    // Should be no rowsets comming back
    piRowset = NULL;

    // Get final return code
    if (sParams.iRet == XPROFILE_NO_RESULT)
    {
        hr = E_FAIL;
    }
    else
    {
        hr = (DWORD) sParams.iRet;
    }

lDone:

    // If failed, report the hr and if it came from the stored proc
    if (FAILED(hr))
    {
        if(sParams.iRet != XPROFILE_NO_RESULT)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_376, "p_team_create_team  returned failure TeamID=%I64X TitleID=%d CreatorID=%I64X  TeamName=%S hr=0x%X",
                qwTeamID,
                dwTitleID,
                qwCreatorUserID,
                wszTeamName,
                hr);
        }
        else
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_377, "SProcTeamCreateTeam failed TeamID=%I64X TitleID=%d CreatorID=%I64X  TeamName=%S hr=0x%X",
                qwTeamID,
                dwTitleID,
                qwCreatorUserID,
                wszTeamName,
                hr);
        }
    }

    return hr;
}

/*****************************************************************************

CProfileStore::SProcTeamCreateUser

Calls the p_team_create_user stored procedure

*****************************************************************************/
HRESULT CProfileStore::SProcTeamCreateUser(
    QWORD qwUserID,
    DWORD dwTitleID,
    QWORD qwTeamID,
    LPCWSTR wszTeamName,
    IWSTDTC *piDTC)
{
    // Check parameters
    if (qwUserID == 0)
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    CComPtr<IRowset> piRowset = NULL;
    CWSODBWResult CResults(ErrorCallback);

    // Parameter structures
    struct sParams_t {
        INT iRet;
        QWORD qwUserID;
        DWORD dwTitleID;
        QWORD qwTeamID;
        WCHAR wszTeamName[MAX_TEAM_NAME_CHAR];
        WORD wBucket;
    } sParams;

    static WSTCOMMANDPARAM rgwstcpParams[] = {
        {1, DBPARAMIO_OUTPUT, DBTYPE_I4,  sizeof(sParams.iRet), offsetof(sParams_t, iRet), NULL},
        {2, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwUserID), offsetof(sParams_t, qwUserID), NULL},
        {3, DBPARAMIO_INPUT,  DBTYPE_I4,  sizeof(sParams.dwTitleID), offsetof(sParams_t, dwTitleID), NULL},
        {4, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwTeamID), offsetof(sParams_t, qwTeamID), NULL},
        {5, DBPARAMIO_INPUT,  DBTYPE_WSTR, sizeof(sParams.wszTeamName), offsetof(sParams_t, wszTeamName), NULL},
        {6, DBPARAMIO_INPUT,  DBTYPE_I2, sizeof(sParams.wBucket), offsetof(sParams_t, wBucket), NULL}
    };

    WSTCOMMANDINFO wstciParams = {
        sizeof(sParams),
        &sParams,
        ARRAY_ELEMENTS(rgwstcpParams),
        rgwstcpParams
    };

    static WCHAR wszCmd[] = L"{ ? = call p_team_create_user ( ?, ?, ?, ?, ?) }";

    // Set the parameters
    sParams.iRet = XPROFILE_NO_RESULT;
    sParams.qwUserID = qwUserID;
    sParams.dwTitleID = dwTitleID;
    sParams.qwTeamID = qwTeamID;
    wcsncpy(sParams.wszTeamName, wszTeamName, MAX_TEAM_NAME_CHAR);
    sParams.wszTeamName[MAX_TEAM_NAME_CHAR - 1] = L'\0';
    sParams.wBucket = (WORD)GetUserBucket(qwUserID);

    // Execute the proc
    hr = m_piCommand->Execute(
        WRITEONLY_COMMANDTYPE,
        GetUserBucket(qwUserID),
        wszCmd,
        &wstciParams,
        (IUnknown **)&piRowset,
        piDTC,
        DBGUID_DEFAULT,
        IID_IRowset);
    if (FAILED(hr))
    {
        // Run the error through the OLEBD wrapper to get details
        CResults.GetErrorHandler()->HandleError(hr, "SProcTeamCreateUser failed to execute stored proc");
        goto lDone;
    }

    // Should be no rowsets comming back
    piRowset = NULL;

    // Get final return code
    if (sParams.iRet == XPROFILE_NO_RESULT)
    {
        hr = E_FAIL;
    }
    else
    {
        hr = (DWORD) sParams.iRet;
    }

lDone:

    // If failed, report the hr and if it came from the stored proc
    if (FAILED(hr))
    {
        if(sParams.iRet != XPROFILE_NO_RESULT)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_378, "p_team_create_user  returned failure UserID=%I64X TeamID=%I64X hr=%X",
                qwUserID,
                qwTeamID,
                hr);
        }
        else
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_379, "SProcTeamCreateUser failed UserID=%I64X TeamID=%I64X hr=%X",
                qwUserID,
                qwTeamID,
                hr);
        }
    }

    return hr;
}

/*****************************************************************************

CProfileStore::SProcTeamCreateName

Calls the p_team_create_name stored procedure

*****************************************************************************/
HRESULT CProfileStore::SProcTeamCreateName(
    DWORD dwTitleID,
    QWORD qwTeamID,
    LPCWSTR wszTeamName,
    IWSTDTC *piDTC)
{
    // Check parameters
    if (wszTeamName == NULL)
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    CComPtr<IRowset> piRowset = NULL;
    CWSODBWResult CResults(ErrorCallback);

    // Parameter structures
    struct sParams_t {
        INT iRet;
        DWORD dwTitleID;
        WCHAR wszCannonizedTeamName[MAX_TEAM_NAME_CHAR];
        WCHAR wszTeamName[MAX_TEAM_NAME_CHAR];
        QWORD qwTeamID;
        WORD wBucket;
    } sParams;

    static WSTCOMMANDPARAM rgwstcpParams[] = {
        {1, DBPARAMIO_OUTPUT, DBTYPE_I4,  sizeof(sParams.iRet), offsetof(sParams_t, iRet), NULL},
        {2, DBPARAMIO_INPUT,  DBTYPE_I4,  sizeof(sParams.dwTitleID), offsetof(sParams_t, dwTitleID), NULL},
        {3, DBPARAMIO_INPUT,  DBTYPE_WSTR, sizeof(sParams.wszCannonizedTeamName), offsetof(sParams_t, wszCannonizedTeamName), NULL},
        {4, DBPARAMIO_INPUT,  DBTYPE_WSTR, sizeof(sParams.wszTeamName), offsetof(sParams_t, wszTeamName), NULL},
        {5, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwTeamID), offsetof(sParams_t, qwTeamID), NULL},
        {6, DBPARAMIO_INPUT,  DBTYPE_I2,  sizeof(sParams.wBucket), offsetof(sParams_t, wBucket), NULL}
    };

    WSTCOMMANDINFO wstciParams = {
        sizeof(sParams),
        &sParams,
        ARRAY_ELEMENTS(rgwstcpParams),
        rgwstcpParams
    };

    static WCHAR wszCmd[] = L"{ ? = call p_team_create_name ( ?, ?, ?, ?, ? ) }";

    // Set the parameters
    sParams.iRet = XPROFILE_NO_RESULT;
    sParams.dwTitleID = dwTitleID;
    wcsncpy(sParams.wszCannonizedTeamName, wszTeamName, MAX_TEAM_NAME_CHAR);
    sParams.wszCannonizedTeamName[MAX_TEAM_NAME_CHAR - 1] = L'\0';
    CannonizeName(sParams.wszCannonizedTeamName);
    wcsncpy(sParams.wszTeamName, wszTeamName, MAX_TEAM_NAME_CHAR);
    sParams.wszTeamName[MAX_TEAM_NAME_CHAR - 1] = L'\0';
    sParams.qwTeamID = qwTeamID;
    sParams.wBucket = (WORD) GetTeamNameBucket(sParams.wszCannonizedTeamName);

    // Execute the proc
    hr = m_piCommand->Execute(
        WRITEONLY_COMMANDTYPE,
        sParams.wBucket,
        wszCmd,
        &wstciParams,
        (IUnknown **)&piRowset,
        piDTC,
        DBGUID_DEFAULT,
        IID_IRowset);
    if (FAILED(hr))
    {
        // Run the error through the OLEBD wrapper to get details
        CResults.GetErrorHandler()->HandleError(hr, "SProcTeamCreateName failed to execute stored proc");
        goto lDone;
    }

    // Should be no rowsets comming back
    piRowset = NULL;

    // Get final return code
    if (sParams.iRet == XPROFILE_NO_RESULT)
    {
        hr = E_FAIL;
    }
    else
    {
        hr = (DWORD) sParams.iRet;
    }

lDone:

    // If failed, report the hr and if it came from the stored proc
    if (FAILED(hr))
    {
        if(sParams.iRet != XPROFILE_NO_RESULT)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_380, "p_team_create_name  returned failure TeamName=%S TeamID=%I64X hr=%X",
                wszTeamName,
                qwTeamID,
                hr);
        }
        else
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_381, "SProcTeamCreateName failed TeamName=%S TeamID=%I64X hr=%X",
                wszTeamName,
                qwTeamID,
                hr);
        }
    }

    return hr;
}

/*****************************************************************************

CProfileStore::SProcTeamDeleteTeam

Calls the p_team_delete_team stored procedure

*****************************************************************************/
HRESULT CProfileStore::SProcTeamDeleteTeam(
    QWORD qwTeamID,
    QWORD qwUserID,
    DWORD *pcPendMembers,
    QWORD *rgqwPendMembers,
    IWSTDTC *piDTC)
{
    // Check parameters
    if ((qwTeamID == 0) &&
        (pcPendMembers != NULL) &&
        (rgqwPendMembers != NULL))
    {
        return E_INVALIDARG;
    }

    *pcPendMembers = 0;

    HRESULT hr = S_OK;
    CComPtr<IRowset> piRowset = NULL;
    CWSODBWResult CResults(ErrorCallback);
    DWORD cRows = 0;

    // Parameter structures
    struct sParams_t {
        INT iRet;
        QWORD qwTeamID;
        QWORD qwUserID;
    } sParams;

    static WSTCOMMANDPARAM rgwstcpParams[] = {
        {1, DBPARAMIO_OUTPUT, DBTYPE_I4,  sizeof(sParams.iRet), offsetof(sParams_t, iRet), NULL},
        {2, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwTeamID), offsetof(sParams_t, qwTeamID), NULL},
        {3, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwUserID), offsetof(sParams_t, qwUserID), NULL}
    };

    WSTCOMMANDINFO wstciParams = {
        sizeof(sParams),
        &sParams,
        ARRAY_ELEMENTS(rgwstcpParams),
        rgwstcpParams
    };

    static WCHAR wszCmd[] = L"{ ? = call p_team_delete_team (?, ?) }";

    // Set the parameters
    sParams.iRet = XPROFILE_NO_RESULT;
    sParams.qwTeamID = qwTeamID;
    sParams.qwUserID = qwUserID;

    // Execute the proc
    hr = m_piCommand->Execute(
        WRITEONLY_COMMANDTYPE,
        GetTeamBucket(qwTeamID),
        wszCmd,
        &wstciParams,
        (IUnknown **)&piRowset,
        piDTC,
        DBGUID_DEFAULT,
        IID_IRowset);
    if (FAILED(hr))
    {
        // Run the error through the OLEBD wrapper to get details
        CResults.GetErrorHandler()->HandleError(hr, "SProcTeamDeleteTeam failed to execute stored proc");
        goto lDone;
    }

    // Check for a return
    if((sParams.iRet != XPROFILE_NO_RESULT) && (FAILED((HRESULT)sParams.iRet)))
    {
        hr = (DWORD) sParams.iRet;
        goto lDone;
    }

    // Attach the wrapper
    hr = CResults.InitializeWithIRowset(piRowset);
    piRowset = NULL;
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Bind
    {
        static DBBINDING _bind[] = {
            WSBIND(1, 0, DBTYPE_I8, 0)
        };

        hr = CResults.SetBindings(_bind, ARRAY_ELEMENTS(_bind));
        if(FAILED(hr))
        {
            goto lDone;
        }
    }

    for (;;)
    {

        cRows = 1;

        rgqwPendMembers[*pcPendMembers] = 0;
        hr = CResults.GetRows(&cRows, rgqwPendMembers + *pcPendMembers, sizeof(QWORD));
        if(FAILED(hr))
        {
            goto lDone;
        }

        *pcPendMembers += cRows;

        if ((cRows != 1) || (*pcPendMembers == XONLINE_MAX_TEAM_MEMBER_COUNT))
        {
            break;
        }
    }

    hr = CResults.Clear();
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Get final return code
    if (sParams.iRet == XPROFILE_NO_RESULT)
    {
        hr = E_FAIL;
    }
    else
    {
        hr = (DWORD) sParams.iRet;
    }


    // Should be no rowsets comming back
    piRowset = NULL;

    // Get final return code
    if (sParams.iRet == XPROFILE_NO_RESULT)
    {
        hr = E_FAIL;
    }
    else
    {
        hr = (DWORD) sParams.iRet;
    }

lDone:

    // If failed, report the hr and if it came from the stored proc
    if (FAILED(hr))
    {
        if(sParams.iRet != XPROFILE_NO_RESULT)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_382, "p_team_delete_team  returned failure TeamID=%I64X hr=0x%X",
                qwTeamID,
                hr);
        }
        else
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_383, "SProcTeamDeleteTeam failed TeamID=%I64X hr=0x%X",
                qwTeamID,
                hr);
        }
    }

    return hr;
}

/*****************************************************************************

CProfileStore::SProcTeamDeleteUser

Calls the p_team_delete_user stored procedure

*****************************************************************************/
HRESULT CProfileStore::SProcTeamDeleteUser(
    QWORD qwTeamID,
    IWSTDTC *piDTC)
{
    HRESULT hr = S_OK;
    CComPtr<IRowset> piRowset = NULL;
    CWSODBWResult CResults(ErrorCallback);

    // Parameter structures
    struct sParams_t {
        INT iRet;
        QWORD qwTeamID;
    } sParams;

    static WSTCOMMANDPARAM rgwstcpParams[] = {
        {1, DBPARAMIO_OUTPUT, DBTYPE_I4,  sizeof(sParams.iRet), offsetof(sParams_t, iRet), NULL},
        {2, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwTeamID), offsetof(sParams_t, qwTeamID), NULL},
    };

    WSTCOMMANDINFO wstciParams = {
        sizeof(sParams),
        &sParams,
        ARRAY_ELEMENTS(rgwstcpParams),
        rgwstcpParams
    };

    static WCHAR wszCmd[] = L"{ ? = call p_team_delete_user ( ?) }";

    // Set the parameters
    sParams.iRet = XPROFILE_NO_RESULT;
    sParams.qwTeamID = qwTeamID;

    // Execute the proc
    hr = m_piCommand->Execute(
        WRITEONLY_COMMANDTYPE,
        ALL_DATABASES,
        wszCmd,
        &wstciParams,
        (IUnknown **)&piRowset,
        piDTC,
        DBGUID_DEFAULT,
        IID_IRowset);
    if (FAILED(hr))
    {
        // Run the error through the OLEBD wrapper to get details
        CResults.GetErrorHandler()->HandleError(hr, "SProcTeamDeleteUser failed to execute stored proc");
        goto lDone;
    }

    // Should be no rowsets comming back
    piRowset = NULL;

    // Get final return code
    if (sParams.iRet == XPROFILE_NO_RESULT)
    {
        hr = E_FAIL;
    }
    else
    {
        hr = (DWORD) sParams.iRet;
    }

lDone:

    // If failed, report the hr and if it came from the stored proc
    if (FAILED(hr))
    {
        if(sParams.iRet != XPROFILE_NO_RESULT)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_384, "p_team_delete_user  returned failure TeamID=%I64X hr=%X",
                qwTeamID,
                hr);
        }
        else
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_385, "SProcTeamDeleteUser failed TeamID=%I64X hr=%X",
                qwTeamID,
                hr);
        }
    }

    return hr;
}

/*****************************************************************************

CProfileStore::SProcTeamDeleteName

Calls the p_team_delete_name stored procedure

*****************************************************************************/
HRESULT CProfileStore::SProcTeamDeleteName(
    QWORD qwTeamID,
    LPCWSTR wszTeamName,
    BOOL fRename,
    IWSTDTC *piDTC)
{
    // Check parameters
    if (wszTeamName == NULL)
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    CComPtr<IRowset> piRowset = NULL;
    CWSODBWResult CResults(ErrorCallback);
    WCHAR wszCannonizedTeamName[MAX_TEAM_NAME_CHAR];
    LONG lBucket = 0;

    // Parameter structures
    struct sParams_t {
        INT iRet;
        QWORD qwTeamID;
        BOOL fRename;
    } sParams;

    static WSTCOMMANDPARAM rgwstcpParams[] = {
        {1, DBPARAMIO_OUTPUT, DBTYPE_I4,  sizeof(sParams.iRet), offsetof(sParams_t, iRet), NULL},
        {2, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwTeamID), offsetof(sParams_t, qwTeamID), NULL},
        {3, DBPARAMIO_INPUT,  DBTYPE_I1,  sizeof(sParams.fRename), offsetof(sParams_t, fRename), NULL},
    };

    WSTCOMMANDINFO wstciParams = {
        sizeof(sParams),
        &sParams,
        ARRAY_ELEMENTS(rgwstcpParams),
        rgwstcpParams
    };

    static WCHAR wszCmd[] = L"{ ? = call p_team_delete_name ( ?, ?) }";

    // Figure out the bucket
    wcsncpy(wszCannonizedTeamName, wszTeamName, MAX_TEAM_NAME_CHAR);
    wszCannonizedTeamName[MAX_TEAM_NAME_CHAR - 1] = '\0';
    CannonizeName(wszCannonizedTeamName);
    lBucket = GetTeamNameBucket(wszCannonizedTeamName);


    // Set the parameters
    sParams.iRet = XPROFILE_NO_RESULT;
    sParams.qwTeamID = qwTeamID;
    sParams.fRename = fRename;

    // Execute the proc
    hr = m_piCommand->Execute(
        WRITEONLY_COMMANDTYPE,
        lBucket,
        wszCmd,
        &wstciParams,
        (IUnknown **)&piRowset,
        piDTC,
        DBGUID_DEFAULT,
        IID_IRowset);
    if (FAILED(hr))
    {
        // Run the error through the OLEBD wrapper to get details
        CResults.GetErrorHandler()->HandleError(hr, "SProcTeamDeleteName failed to execute stored proc");
        goto lDone;
    }

    // Should be no rowsets comming back
    piRowset = NULL;

    // Get final return code
    if (sParams.iRet == XPROFILE_NO_RESULT)
    {
        hr = E_FAIL;
    }
    else
    {
        hr = (DWORD) sParams.iRet;
    }

lDone:

    // If failed, report the hr and if it came from the stored proc
    if (FAILED(hr))
    {
        if(sParams.iRet != XPROFILE_NO_RESULT)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_386, "p_team_delete_name  returned failure TeamName=%S TeamID=%I64X hr=%X",
                wszTeamName,
                qwTeamID,
                hr);
        }
        else
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_387, "SProcTeamDeleteName failed TeamName=%S TeamID=%I64X hr=%X",
                wszTeamName,
                qwTeamID,
                hr);
        }
    }

    return hr;
}

/*****************************************************************************

CProfileStore::SProcTeamRemoveTeam

Calls the p_team_remove_team stored procedure

*****************************************************************************/
HRESULT CProfileStore::SProcTeamRemoveTeam(
    QWORD qwTeamID,
    QWORD qwUserID,
    QWORD qwMemberID,
    BOOL fMember,
    IWSTDTC *piDTC)
{
    // Check parameters
    if ((qwMemberID == 0) ||
        (qwUserID == 0) ||
        (qwTeamID == 0))
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    CComPtr<IRowset> piRowset = NULL;
    CWSODBWResult CResults(ErrorCallback);

    // Parameter structures
    struct sParams_t {
        INT iRet;
        QWORD qwTeamID;
        QWORD qwUserID;
        QWORD qwMemberID;
        BOOL fMember;
    } sParams;

    static WSTCOMMANDPARAM rgwstcpParams[] = {
        {1, DBPARAMIO_OUTPUT, DBTYPE_I4,  sizeof(sParams.iRet), offsetof(sParams_t, iRet), NULL},
        {2, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwTeamID), offsetof(sParams_t, qwTeamID), NULL},
        {3, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwUserID), offsetof(sParams_t, qwUserID), NULL},
        {4, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwMemberID), offsetof(sParams_t, qwMemberID), NULL},
        {5, DBPARAMIO_INPUT,  DBTYPE_I1,  sizeof(sParams.fMember), offsetof(sParams_t, fMember), NULL}
    };

    WSTCOMMANDINFO wstciParams = {
        sizeof(sParams),
        &sParams,
        ARRAY_ELEMENTS(rgwstcpParams),
        rgwstcpParams
    };

    static WCHAR wszCmd[] = L"{ ? = call p_team_remove_team (?, ?, ?, ?) }";

    // Set the parameters
    sParams.iRet = XPROFILE_NO_RESULT;
    sParams.qwTeamID = qwTeamID;
    sParams.qwMemberID = qwMemberID;
    sParams.qwUserID = qwUserID;
    sParams.fMember = fMember;

    // Execute the proc
    hr = m_piCommand->Execute(
        WRITEONLY_COMMANDTYPE,
        GetTeamBucket(qwTeamID),
        wszCmd,
        &wstciParams,
        (IUnknown **)&piRowset,
        piDTC,
        DBGUID_DEFAULT,
        IID_IRowset);
    if (FAILED(hr))
    {
        // Run the error through the OLEBD wrapper to get details
        CResults.GetErrorHandler()->HandleError(hr, "SProcTeamRemoveTeam failed to execute stored proc");
        goto lDone;
    }

    // Should be no rowsets comming back
    piRowset = NULL;

    // Get final return code
    if (sParams.iRet == XPROFILE_NO_RESULT)
    {
        hr = E_FAIL;
    }
    else
    {
        hr = (DWORD) sParams.iRet;
    }

lDone:

    // If failed, report the hr and if it came from the stored proc
    if (FAILED(hr))
    {
        if(sParams.iRet != XPROFILE_NO_RESULT)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_388, "p_team_remove_team  returned failure TeamID=%I64X UserID=%I64X MemberID=%I64X hr=0x%X",
                qwTeamID,
                qwUserID,
                qwMemberID,
                hr);
        }
        else
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_389, "SProcTeamRemoveTeam failed TeamID=%I64X UserID=%I64X MemberID=%I64X hr=0x%X",
                qwTeamID,
                qwUserID,
                qwMemberID,
                hr);
        }
    }

    return hr;
}

/*****************************************************************************

CProfileStore::SProcTeamRemoveUser

Calls the p_team_remove_user stored procedure

*****************************************************************************/
HRESULT CProfileStore::SProcTeamRemoveUser(
    QWORD qwUserID,
    QWORD qwTeamID,
    BOOL fMember,
    IWSTDTC *piDTC)
{
    HRESULT hr = S_OK;
    CComPtr<IRowset> piRowset = NULL;
    CWSODBWResult CResults(ErrorCallback);

    // Parameter structures
    struct sParams_t {
        INT iRet;
        QWORD qwUserID;
        QWORD qwTeamID;
        BOOL fMember;
    } sParams;

    static WSTCOMMANDPARAM rgwstcpParams[] = {
        {1, DBPARAMIO_OUTPUT, DBTYPE_I4,  sizeof(sParams.iRet), offsetof(sParams_t, iRet), NULL},
        {2, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwUserID), offsetof(sParams_t, qwUserID), NULL},
        {3, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwTeamID), offsetof(sParams_t, qwTeamID), NULL},
        {4, DBPARAMIO_INPUT,  DBTYPE_I1,  sizeof(sParams.fMember), offsetof(sParams_t, fMember), NULL}
    };

    WSTCOMMANDINFO wstciParams = {
        sizeof(sParams),
        &sParams,
        ARRAY_ELEMENTS(rgwstcpParams),
        rgwstcpParams
    };

    static WCHAR wszCmd[] = L"{ ? = call p_team_remove_user ( ?, ?, ?) }";

    // Set the parameters
    sParams.iRet = XPROFILE_NO_RESULT;
    sParams.qwUserID = qwUserID;
    sParams.qwTeamID = qwTeamID;
    sParams.fMember = fMember;

    // Execute the proc
    hr = m_piCommand->Execute(
        WRITEONLY_COMMANDTYPE,
        GetUserBucket(qwUserID),
        wszCmd,
        &wstciParams,
        (IUnknown **)&piRowset,
        piDTC,
        DBGUID_DEFAULT,
        IID_IRowset);
    if (FAILED(hr))
    {
        // Run the error through the OLEBD wrapper to get details
        CResults.GetErrorHandler()->HandleError(hr, "SProcTeamRemoveUser failed to execute stored proc");
        goto lDone;
    }

    // Should be no rowsets comming back
    piRowset = NULL;

    // Get final return code
    if (sParams.iRet == XPROFILE_NO_RESULT)
    {
        hr = E_FAIL;
    }
    else
    {
        hr = (DWORD) sParams.iRet;
    }

lDone:

    // If failed, report the hr and if it came from the stored proc
    if (FAILED(hr))
    {
        if(sParams.iRet != XPROFILE_NO_RESULT)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_390, "p_team_remove_user  returned failure UserID=%I64X TeamID=%I64X hr=%X",
                qwUserID,
                qwTeamID,
                hr);
        }
        else
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_391, "SProcTeamRemoveUser failed UserID=%I64X TeamID=%I64X hr=%X",
                qwUserID,
                qwTeamID,
                hr);
        }
    }

    return hr;
}

/*****************************************************************************

CProfileStore::SProcTeamRecruitTeam

Calls the p_team_recruit_team stored procedure

*****************************************************************************/
HRESULT CProfileStore::SProcTeamRecruitTeam(
    DWORD dwTitleID,
    QWORD qwTeamID,
    QWORD qwUserID,
    QWORD qwMemberID,
    LPCSTR szMemberName,
    DWORD dwMemberPriv,
    BYTE *pbMemberData,
    DWORD cbMemberData,
    LPSTR szTeamName,
    DWORD *pcbTeamName,
    IWSTDTC *piDTC)
{
    // Check parameters
    if ((qwMemberID == 0) ||
        (qwTeamID == 0) ||
        (szMemberName == NULL) ||
        (szTeamName == NULL) ||
        (pcbTeamName == NULL))
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    CComPtr<IRowset> piRowset = NULL;
    CWSODBWResult CResults(ErrorCallback);
    DWORD cRows = 0;

    // Parameter structures
    struct sParams_t {
        INT iRet;
        DWORD dwTitleID;
        QWORD qwTeamID;
        QWORD qwUserID;
        QWORD qwMemberID;
        CHAR szMemberName[MAX_ACCTNAME_BYTES];
        DWORD dwMemberPriv;
        BYTE rgbMemberData[MAX_TEAM_MEMBER_DATA_BYTES];
    } sParams;

    WSTCOMMANDPARAM rgwstcpParams[] = {
        {1, DBPARAMIO_OUTPUT, DBTYPE_I4,  sizeof(sParams.iRet), offsetof(sParams_t, iRet), NULL},
        {2, DBPARAMIO_INPUT,  DBTYPE_I4,  sizeof(sParams.dwTitleID), offsetof(sParams_t, dwTitleID), NULL},
        {3, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwTeamID), offsetof(sParams_t, qwTeamID), NULL},
        {4, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwUserID), offsetof(sParams_t, qwUserID), NULL},
        {5, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwMemberID), offsetof(sParams_t, qwMemberID), NULL},
        {6, DBPARAMIO_INPUT,  DBTYPE_STR, sizeof(sParams.szMemberName), offsetof(sParams_t, szMemberName), NULL},
        {7, DBPARAMIO_INPUT,  DBTYPE_I4,  sizeof(sParams.dwMemberPriv), offsetof(sParams_t, dwMemberPriv), NULL},
        {8, DBPARAMIO_INPUT,  DBTYPE_BYTES, cbMemberData, offsetof(sParams_t, rgbMemberData), NULL},
    };

    WSTCOMMANDINFO wstciParams = {
        sizeof(sParams),
        &sParams,
        ARRAY_ELEMENTS(rgwstcpParams),
        rgwstcpParams
    };

    static WCHAR wszCmd[] = L"{ ? = call p_team_recruit_team (?, ?, ?, ?, ?, ?, ?) }";

    // Set the parameters
    sParams.iRet = XPROFILE_NO_RESULT;
    sParams.qwTeamID = qwTeamID;
    sParams.dwTitleID = dwTitleID;
    sParams.qwUserID = qwUserID;
    sParams.qwMemberID = qwMemberID;
    strncpy(sParams.szMemberName, szMemberName, MAX_ACCTNAME_BYTES);
    sParams.dwMemberPriv = dwMemberPriv;
    memset(sParams.rgbMemberData, 0, MAX_TEAM_MEMBER_DATA_BYTES);
    memcpy(sParams.rgbMemberData, pbMemberData, cbMemberData);

    // Execute the proc
    hr = m_piCommand->Execute(
        WRITEONLY_COMMANDTYPE,
        GetTeamBucket(qwTeamID),
        wszCmd,
        &wstciParams,
        (IUnknown **)&piRowset,
        piDTC,
        DBGUID_DEFAULT,
        IID_IRowset);
    if (FAILED(hr))
    {
        // Run the error through the OLEBD wrapper to get details
        CResults.GetErrorHandler()->HandleError(hr, "SProcTeamRecruitTeam failed to execute stored proc");
        goto lDone;
    }

    // Check for a return
    if((sParams.iRet != XPROFILE_NO_RESULT) && (FAILED((HRESULT)sParams.iRet)))
    {
        hr = (DWORD) sParams.iRet;
        goto lDone;
    }

    // Attach the wrapper
    hr = CResults.InitializeWithIRowset(piRowset);
    piRowset = NULL;
    if (FAILED(hr))
    {
        goto lDone;
    }

    {
        static DBBINDING _bind[] = {
            WSBIND(1, 0, DBTYPE_STR, MAX_ACCTNAME_BYTES)
        };

        hr = CResults.SetBindings(_bind, ARRAY_ELEMENTS(_bind));
        if(FAILED(hr))
        {
            goto lDone;
        }
    }

    cRows = 1;

    hr = CResults.GetRows(&cRows, szTeamName, MAX_ACCTNAME_BYTES);
    if(FAILED(hr))
    {
        goto lDone;
    }

    szTeamName[MAX_TEAM_NAME_BYTES - 1] = '\0';
    *pcbTeamName = strlen(szTeamName) + 1;
    szTeamName[*pcbTeamName - 1] = '\0';

    hr = CResults.Clear();
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Get final return code
    if (sParams.iRet == XPROFILE_NO_RESULT)
    {
        hr = E_FAIL;
    }
    else
    {
        hr = (DWORD) sParams.iRet;
    }

lDone:

    // If failed, report the hr and if it came from the stored proc
    if (FAILED(hr))
    {
        if(sParams.iRet != XPROFILE_NO_RESULT)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_392, "p_team_recruit_team  returned failure TeamID=%I64X TitleID=%d MemberID=%I64X hr=0x%X",
                qwTeamID,
                dwTitleID,
                qwMemberID,
                hr);
        }
        else
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_393, "SProcTeamRecruitTeam failed TeamID=%I64X TitleID=%d MemberID=%I64X hr=0x%X",
                qwTeamID,
                dwTitleID,
                qwMemberID,
                hr);
        }

        if (pcbTeamName != NULL)
        {
            *pcbTeamName = 0;
        }
        if (szTeamName != NULL)
        {
            szTeamName[0] = '\0';
        }
    }

    return hr;
}

/*****************************************************************************

CProfileStore::SProcTeamRecruitUser

Calls the p_team_recruit_user stored procedure

*****************************************************************************/
HRESULT CProfileStore::SProcTeamRecruitUser(
    QWORD qwUserID,
    DWORD dwTitleID,
    QWORD qwTeamID,
    LPCSTR szTeamName,
    QWORD qwRecruiterID,
    IWSTDTC *piDTC)
{
    // Check parameters
    if (szTeamName == NULL)
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    CComPtr<IRowset> piRowset = NULL;
    CWSODBWResult CResults(ErrorCallback);

    // Parameter structures
    struct sParams_t {
        INT iRet;
        QWORD qwUserID;
        DWORD dwTitleID;
        QWORD qwTeamID;
        CHAR szTeamName[MAX_TEAM_NAME_BYTES];
        QWORD qwRecruiterID;
        WORD wBucket;
    } sParams;

    static WSTCOMMANDPARAM rgwstcpParams[] = {
        {1, DBPARAMIO_OUTPUT, DBTYPE_I4,  sizeof(sParams.iRet), offsetof(sParams_t, iRet), NULL},
        {2, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwUserID), offsetof(sParams_t, qwUserID), NULL},
        {3, DBPARAMIO_INPUT,  DBTYPE_I4,  sizeof(sParams.dwTitleID), offsetof(sParams_t, dwTitleID), NULL},
        {4, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwTeamID), offsetof(sParams_t, qwTeamID), NULL},
        {5, DBPARAMIO_INPUT,  DBTYPE_STR, sizeof(sParams.szTeamName), offsetof(sParams_t, szTeamName), NULL},
        {6, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwRecruiterID), offsetof(sParams_t, qwRecruiterID), NULL},
        {7, DBPARAMIO_INPUT,  DBTYPE_I2,  sizeof(sParams.wBucket), offsetof(sParams_t, wBucket), NULL},
    };

    WSTCOMMANDINFO wstciParams = {
        sizeof(sParams),
        &sParams,
        ARRAY_ELEMENTS(rgwstcpParams),
        rgwstcpParams
    };

    static WCHAR wszCmd[] = L"{ ? = call p_team_recruit_user ( ?, ?, ?, ?, ?, ?) }";

    // Set the parameters
    sParams.iRet = XPROFILE_NO_RESULT;
    sParams.qwUserID = qwUserID;
    sParams.dwTitleID = dwTitleID;
    sParams.qwTeamID = qwTeamID;
    sParams.qwRecruiterID = qwRecruiterID;
    strncpy(sParams.szTeamName, szTeamName, MAX_TEAM_NAME_BYTES);
    sParams.wBucket = (WORD)GetUserBucket(qwUserID);

    // Execute the proc
    hr = m_piCommand->Execute(
        WRITEONLY_COMMANDTYPE,
        GetUserBucket(qwUserID),
        wszCmd,
        &wstciParams,
        (IUnknown **)&piRowset,
        piDTC,
        DBGUID_DEFAULT,
        IID_IRowset);
    if (FAILED(hr))
    {
        // Run the error through the OLEBD wrapper to get details
        CResults.GetErrorHandler()->HandleError(hr, "SProcTeamRecruitUser failed to execute stored proc");
        goto lDone;
    }

    // Should be no rowsets comming back
    piRowset = NULL;

    // Get final return code
    if (sParams.iRet == XPROFILE_NO_RESULT)
    {
        hr = E_FAIL;
    }
    else
    {
        hr = (DWORD) sParams.iRet;
    }

lDone:

    // If failed, report the hr and if it came from the stored proc
    if (FAILED(hr))
    {
        if(sParams.iRet != XPROFILE_NO_RESULT)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_394, "p_team_recruit_user  returned failure UserID=%I64X TitleID=%d TeamID=%I64X hr=%X",
                qwUserID,
                dwTitleID,
                qwTeamID,
                hr);
        }
        else
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_395, "SProcTeamRecruitUser failed UserID=%I64X TitleID=%d TeamID=%I64X hr=%X",
                qwUserID,
                dwTitleID,
                qwTeamID,
                hr);
        }
    }

    return hr;
}

/*****************************************************************************

CProfileStore::SProcTeamJoinTeam

Calls the p_team_join_team stored procedure

*****************************************************************************/
HRESULT CProfileStore::SProcTeamJoinTeam(
    QWORD qwTeamID,
    QWORD qwMemberID,
    IWSTDTC *piDTC)
{
    // Check parameters
    if ((qwMemberID == 0) ||
        (qwTeamID == 0))
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    CComPtr<IRowset> piRowset = NULL;
    CWSODBWResult CResults(ErrorCallback);

    // Parameter structures
    struct sParams_t {
        INT iRet;
        QWORD qwTeamID;
        QWORD qwMemberID;
    } sParams;

    static WSTCOMMANDPARAM rgwstcpParams[] = {
        {1, DBPARAMIO_OUTPUT, DBTYPE_I4,  sizeof(sParams.iRet), offsetof(sParams_t, iRet), NULL},
        {2, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwTeamID), offsetof(sParams_t, qwTeamID), NULL},
        {3, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwMemberID), offsetof(sParams_t, qwMemberID), NULL},
    };

    WSTCOMMANDINFO wstciParams = {
        sizeof(sParams),
        &sParams,
        ARRAY_ELEMENTS(rgwstcpParams),
        rgwstcpParams
    };

    static WCHAR wszCmd[] = L"{ ? = call p_team_join_team (?, ?) }";

    // Set the parameters
    sParams.iRet = XPROFILE_NO_RESULT;
    sParams.qwTeamID = qwTeamID;
    sParams.qwMemberID = qwMemberID;

    // Execute the proc
    hr = m_piCommand->Execute(
        WRITEONLY_COMMANDTYPE,
        GetTeamBucket(qwTeamID),
        wszCmd,
        &wstciParams,
        (IUnknown **)&piRowset,
        piDTC,
        DBGUID_DEFAULT,
        IID_IRowset);
    if (FAILED(hr))
    {
        // Run the error through the OLEBD wrapper to get details
        CResults.GetErrorHandler()->HandleError(hr, "SProcTeamJoinTeam failed to execute stored proc");
        goto lDone;
    }

    // Should be no rowsets comming back
    piRowset = NULL;

    // Get final return code
    if (sParams.iRet == XPROFILE_NO_RESULT)
    {
        hr = E_FAIL;
    }
    else
    {
        hr = (DWORD) sParams.iRet;
    }

lDone:

    // If failed, report the hr and if it came from the stored proc
    if (FAILED(hr))
    {
        if(sParams.iRet != XPROFILE_NO_RESULT)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_396, "p_team_join_team  returned failure TeamID=%I64X MemberID=%I64X hr=0x%X",
                qwTeamID,
                qwMemberID,
                hr);
        }
        else
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_397, "SProcTeamJoinTeam failed TeamID=%I64X MemberID=%I64X hr=0x%X",
                qwTeamID,
                qwMemberID,
                hr);
        }
    }

    return hr;
}

/*****************************************************************************

CProfileStore::SProcTeamJoinUser

Calls the p_team_join_user stored procedure

*****************************************************************************/
HRESULT CProfileStore::SProcTeamJoinUser(
    QWORD qwUserID,
    QWORD qwTeamID,
    IWSTDTC *piDTC)
{
    HRESULT hr = S_OK;
    CComPtr<IRowset> piRowset = NULL;
    CWSODBWResult CResults(ErrorCallback);

    // Parameter structures
    struct sParams_t {
        INT iRet;
        QWORD qwUserID;
        QWORD qwTeamID;
    } sParams;

    static WSTCOMMANDPARAM rgwstcpParams[] = {
        {1, DBPARAMIO_OUTPUT, DBTYPE_I4,  sizeof(sParams.iRet), offsetof(sParams_t, iRet), NULL},
        {2, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwUserID), offsetof(sParams_t, qwUserID), NULL},
        {3, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwTeamID), offsetof(sParams_t, qwTeamID), NULL},
    };

    WSTCOMMANDINFO wstciParams = {
        sizeof(sParams),
        &sParams,
        ARRAY_ELEMENTS(rgwstcpParams),
        rgwstcpParams
    };

    static WCHAR wszCmd[] = L"{ ? = call p_team_join_user ( ?, ?) }";

    // Set the parameters
    sParams.iRet = XPROFILE_NO_RESULT;
    sParams.qwUserID = qwUserID;
    sParams.qwTeamID = qwTeamID;

    // Execute the proc
    hr = m_piCommand->Execute(
        WRITEONLY_COMMANDTYPE,
        GetUserBucket(qwUserID),
        wszCmd,
        &wstciParams,
        (IUnknown **)&piRowset,
        piDTC,
        DBGUID_DEFAULT,
        IID_IRowset);
    if (FAILED(hr))
    {
        // Run the error through the OLEBD wrapper to get details
        CResults.GetErrorHandler()->HandleError(hr, "SProcTeamJoinUser failed to execute stored proc");
        goto lDone;
    }

    // Should be no rowsets comming back
    piRowset = NULL;

    // Get final return code
    if (sParams.iRet == XPROFILE_NO_RESULT)
    {
        hr = E_FAIL;
    }
    else
    {
        hr = (DWORD) sParams.iRet;
    }

lDone:

    // If failed, report the hr and if it came from the stored proc
    if (FAILED(hr))
    {
        if(sParams.iRet != XPROFILE_NO_RESULT)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_398, "p_team_join_user  returned failure UserID=%I64X TeamID=%I64X hr=%X",
                qwUserID,
                qwTeamID,
                hr);
        }
        else
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_399, "SProcTeamJoinUser failed UserID=%I64X TeamID=%I64X hr=%X",
                qwUserID,
                qwTeamID,
                hr);
        }
    }

    return hr;
}

/*****************************************************************************

CProfileStore::SProcTeamManageTeam

Calls the p_team_manage_team stored procedure

*****************************************************************************/
HRESULT CProfileStore::SProcTeamManageTeam(
    QWORD qwUserID,
    DWORD dwTitleID,
    QWORD qwTeamID,
    LPCWSTR wszTeamName,
    LPCWSTR wszTeamDescription,
    LPCWSTR wszTeamMotto,
    LPCWSTR wszTeamURL,
    BYTE *pbTeamData,
    DWORD cbTeamData,
    LPWSTR wszOldTeamName,
    DWORD *pcbOldTeamName,
    IWSTDTC *piDTC)
{
    HRESULT hr = S_OK;
    CComPtr<IRowset> piRowset = NULL;
    CWSODBWResult CResults(ErrorCallback);
    DWORD cRows = 0;

    // Parameter structures
    struct sParams_t {
        INT iRet;
        DWORD dwTitleID;
        QWORD qwTeamID;
        QWORD qwUserID;
        WCHAR wszTeamName[MAX_TEAM_NAME_CHAR];
        WCHAR wszTeamDescription[MAX_TEAM_DESCRIPTION_CHAR];
        WCHAR wszTeamMotto[MAX_TEAM_MOTTO_CHAR];
        WCHAR wszTeamURL[MAX_TEAM_URL_CHAR];
        BYTE rgbTeamData[MAX_TEAM_DATA_BYTES];
    } sParams;

    WSTCOMMANDPARAM rgwstcpParams[] = {
        {1, DBPARAMIO_OUTPUT, DBTYPE_I4,  sizeof(sParams.iRet), offsetof(sParams_t, iRet), NULL},
        {2, DBPARAMIO_INPUT,  DBTYPE_I4,  sizeof(sParams.dwTitleID), offsetof(sParams_t, dwTitleID), NULL},
        {3, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwTeamID), offsetof(sParams_t, qwTeamID), NULL},
        {4, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwUserID), offsetof(sParams_t, qwUserID), NULL},
        {5, DBPARAMIO_INPUT,  DBTYPE_WSTR, sizeof(sParams.wszTeamName), offsetof(sParams_t, wszTeamName), NULL},
        {6, DBPARAMIO_INPUT,  DBTYPE_WSTR, sizeof(sParams.wszTeamDescription), offsetof(sParams_t, wszTeamDescription), NULL},
        {7, DBPARAMIO_INPUT,  DBTYPE_WSTR, sizeof(sParams.wszTeamMotto), offsetof(sParams_t, wszTeamMotto), NULL},
        {8, DBPARAMIO_INPUT,  DBTYPE_WSTR, sizeof(sParams.wszTeamURL), offsetof(sParams_t, wszTeamURL), NULL},
        {9, DBPARAMIO_INPUT,  DBTYPE_BYTES, cbTeamData, offsetof(sParams_t, rgbTeamData), NULL}
    };

    WSTCOMMANDINFO wstciParams = {
        sizeof(sParams),
        &sParams,
        ARRAY_ELEMENTS(rgwstcpParams),
        rgwstcpParams
    };

    static WCHAR wszCmd[] = L"{ ? = call p_team_manage_team (?, ?, ?, ?, ?, ?, ?, ?) }";

    // Set the parameters
    sParams.iRet = XPROFILE_NO_RESULT;
    sParams.dwTitleID = dwTitleID;
    sParams.qwTeamID = qwTeamID;
    sParams.qwUserID = qwUserID;
    wcsncpy(sParams.wszTeamName, wszTeamName, MAX_TEAM_NAME_CHAR);
    sParams.wszTeamName[MAX_TEAM_NAME_CHAR - 1] = L'\0';
    wcsncpy(sParams.wszTeamDescription, wszTeamDescription, MAX_TEAM_DESCRIPTION_CHAR);
    sParams.wszTeamDescription[MAX_TEAM_DESCRIPTION_CHAR - 1] = L'\0';
    wcsncpy(sParams.wszTeamMotto, wszTeamMotto, MAX_TEAM_MOTTO_CHAR);
    sParams.wszTeamMotto[MAX_TEAM_MOTTO_CHAR - 1] = L'\0';
    wcsncpy(sParams.wszTeamURL, wszTeamURL, MAX_TEAM_URL_CHAR);
    sParams.wszTeamURL[MAX_TEAM_URL_CHAR - 1] = L'\0';
    memset(sParams.rgbTeamData, 0, MAX_TEAM_DATA_BYTES);
    memcpy(sParams.rgbTeamData, pbTeamData, cbTeamData);

    // Execute the proc
    hr = m_piCommand->Execute(
        WRITEONLY_COMMANDTYPE,
        GetTeamBucket(qwTeamID),
        wszCmd,
        &wstciParams,
        (IUnknown **)&piRowset,
        piDTC,
        DBGUID_DEFAULT,
        IID_IRowset);
    if (FAILED(hr))
    {
        // Run the error through the OLEBD wrapper to get details
        CResults.GetErrorHandler()->HandleError(hr, "SProcTeamManageTeam failed to execute stored proc");
        goto lDone;
    }

    // Check for a return
    if((sParams.iRet != XPROFILE_NO_RESULT) && (FAILED((HRESULT)sParams.iRet)))
    {
        hr = (DWORD) sParams.iRet;
        goto lDone;
    }

    // Attach the wrapper
    hr = CResults.InitializeWithIRowset(piRowset);
    piRowset = NULL;
    if (FAILED(hr))
    {
        goto lDone;
    }

    {
        static DBBINDING _bind[] = {
            WSBIND(1, 0, DBTYPE_WSTR, MAX_TEAM_NAME_BYTES)
        };

        hr = CResults.SetBindings(_bind, ARRAY_ELEMENTS(_bind));
        if(FAILED(hr))
        {
            goto lDone;
        }
    }

    cRows = 1;

    memset(wszOldTeamName, 0, MAX_TEAM_NAME_BYTES);
    hr = CResults.GetRows(&cRows, wszOldTeamName, MAX_TEAM_NAME_BYTES);
    if(FAILED(hr))
    {
        goto lDone;
    }

    wszOldTeamName[MAX_TEAM_NAME_CHAR - 1] = L'\0';
    *pcbOldTeamName = (wcslen(wszOldTeamName) + 1) * 2;

    hr = CResults.Clear();
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Get final return code
    if (sParams.iRet == XPROFILE_NO_RESULT)
    {
        hr = E_FAIL;
    }
    else
    {
        hr = (DWORD) sParams.iRet;
    }

lDone:

    // If failed, report the hr and if it came from the stored proc
    if (FAILED(hr))
    {
        if(sParams.iRet != XPROFILE_NO_RESULT)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_400, "p_team_manage_team  returned failure TeamID=%I64X TitleID=%d hr=0x%X",
                qwTeamID,
                dwTitleID,
                hr);
        }
        else
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_401, "SProcTeamManageTeam failed TeamID=%I64X TitleID=%d hr=0x%X",
                qwTeamID,
                dwTitleID,
                hr);
        }

        if (pcbOldTeamName != NULL)
        {
            *pcbOldTeamName = 0;
        }
        if (wszOldTeamName != NULL)
        {
            wszOldTeamName[0] = L'\0';
        }
    }

    return hr;
}

/*****************************************************************************

CProfileStore::SProcRenameTeam

Calls the p_xprof_rename_team stored procedure on each physical parition

*****************************************************************************/
HRESULT CProfileStore::SProcRenameTeam(
    QWORD qwTeamID,
    LPCWSTR wszTeamName,
    IWSTDTC *piDTC)
{
    // Check parameters
    if ((qwTeamID == 0) ||
        (wszTeamName == NULL))
    {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    CComPtr<IRowset> piRowset = NULL;
    CWSODBWResult CResults(ErrorCallback);

    // Parameter structures
    struct sParams_t {
        INT iRet;
        QWORD qwTeamID;
        WCHAR wszTeamName[MAX_TEAM_NAME_CHAR];
    } sParams;

    static WSTCOMMANDPARAM rgwstcpParams[] = {
        {1, DBPARAMIO_OUTPUT, DBTYPE_I4,  sizeof(sParams.iRet), offsetof(sParams_t, iRet), NULL},
        {2, DBPARAMIO_INPUT,  DBTYPE_I8,  sizeof(sParams.qwTeamID), offsetof(sParams_t, qwTeamID), NULL},
        {3, DBPARAMIO_INPUT,  DBTYPE_WSTR, sizeof(sParams.wszTeamName), offsetof(sParams_t, wszTeamName), NULL}
    };

    WSTCOMMANDINFO wstciParams = {
        sizeof(sParams),
        &sParams,
        ARRAY_ELEMENTS(rgwstcpParams),
        rgwstcpParams
    };

    static WCHAR wszCmd[] = L"{ ? = call p_xprof_rename_team (?, ?) }";

    // Set the parameters
    sParams.iRet = XPROFILE_NO_RESULT;
    sParams.qwTeamID = qwTeamID;
    wcsncpy(sParams.wszTeamName, wszTeamName, MAX_TEAM_NAME_CHAR);
    sParams.wszTeamName[MAX_TEAM_NAME_CHAR - 1] = L'\0';

    // Execute the proc
    hr = m_piCommand->Execute(
        WRITEONLY_COMMANDTYPE,
        ALL_DATABASES,
        wszCmd,
        &wstciParams,
        (IUnknown **)&piRowset,
        piDTC,
        DBGUID_DEFAULT,
        IID_IRowset);
    if (FAILED(hr))
    {
        // Run the error through the OLEBD wrapper to get details
        CResults.GetErrorHandler()->HandleError(hr, "SProcRenameTeam failed to execute stored proc");
        goto lDone;
    }

    // Should be no rowsets comming back
    piRowset = NULL;

    // Get final return code
    if (sParams.iRet == XPROFILE_NO_RESULT)
    {
        hr = E_FAIL;
    }
    else
    {
        hr = (DWORD) sParams.iRet;
    }

lDone:

    // If failed, report the hr and if it came from the stored proc
    if (FAILED(hr))
    {
        if(sParams.iRet != XPROFILE_NO_RESULT)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_402, "p_xprof_rename_team  returned failure TeamID=%I64X hr=%X", qwTeamID, hr);
        }
        else
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_403, "SProcRenameTeam failed TeamID=%I64X hr=%X", qwTeamID, hr);
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\inh\presence.cpp ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#include "stdafx.h"

CPresenceUserIndex g_CPresenceUserIndex;
CPresenceXBoxIndex g_CPresenceXBoxIndex;
CPresenceSGIndex g_CPresenceSGIndex;
CTicklePriQueue g_CTicklePriQueue;

// used when zero is a special value.  if zero is passed, zero is returned.  otherwise, zero is never returned.
#define ZeroProtectedTimeShift(dwOldTime, dwShift) (((dwOldTime) == 0) ? 0 : ((((dwOldTime) + (dwShift)) == 0) ? 1 : ((dwOldTime) + (dwShift))))

DWORD g_rgdwMaxAffiliates[NUM_STORED_AFFILIATE_LISTS] = {
    100,    // encountered
    500,    // completed game
    500,    // positive feedback
    500,    // negative feedback
    500,    // avoiding me
    100     // favorites
};

/*****************************************************************************

CompareBuddies

Compare two buddy entries by BuddyID.  Used by the bsearch and qsort libary
routines.

*****************************************************************************/
static int __cdecl CompareBuddies( const void *pCLeft, const void *pCRight )
{
    if (((CBuddyListEntry *)pCLeft)->GetBuddyID() <
        ((CBuddyListEntry *)pCRight)->GetBuddyID())
    {
        return -1;
    }
    else if (((CBuddyListEntry *)pCLeft)->GetBuddyID() >
        ((CBuddyListEntry *)pCRight)->GetBuddyID())
    {
        return 1;
    }
    else
    {
        return 0;
    }
}


/*****************************************************************************

CompareQWORD

Compare two QWORD pointers.  Used by the bsearch and qsort libary routines.

*****************************************************************************/
static int __cdecl CompareQWORD( const void *pCLeft, const void *pCRight )
{
    if (*((const QWORD *)pCLeft) <
        *((const QWORD *)pCRight) )
    {
        return -1;
    }
    else if (*((const QWORD *)pCLeft) >
        *((const QWORD *)pCRight) )
    {
        return 1;
    }
    else
    {
        return 0;
    }
}

/*****************************************************************************

CUserList::CUserList

Constructor

*****************************************************************************/
CUserList::CUserList() :
    m_cUsers(0),
    m_rgqwUsers(NULL)
{
}

/*****************************************************************************

CUserList::CUserList

Destructor

*****************************************************************************/
CUserList::~CUserList()
{
    Clear();
}

/*****************************************************************************

CUserList::Add

Add a user to the list

*****************************************************************************/
HRESULT CUserList::Add(QWORD qwUserId)
{
    // Make sure we have enough room
    QWORD *rgqwNew = NULL;
    QWORD *pqwInsert = NULL;
    QWORD *pqwEnd = NULL;

    // Resize the current allocation
    rgqwNew = new QWORD[m_cUsers + 1];
    if (rgqwNew == NULL)
    {
        return E_OUTOFMEMORY;
    }
    memcpy(rgqwNew, m_rgqwUsers, m_cUsers * sizeof(QWORD));
    delete[] m_rgqwUsers;
    m_rgqwUsers = rgqwNew;

    // Look for the insertion position
    pqwInsert = m_rgqwUsers;
    pqwEnd = m_rgqwUsers + m_cUsers;
    while ((pqwInsert < pqwEnd) && (GET_PUID_BITS(*pqwInsert) < GET_PUID_BITS(qwUserId)))
    {
        pqwInsert++;
    }

    // Insert it if not in the list
    if ((pqwInsert == pqwEnd) || (GET_PUID_BITS(*pqwInsert) != GET_PUID_BITS(qwUserId)))
    {
        // Move down for room
        memmove(pqwInsert + 1, pqwInsert, ((BYTE *)pqwEnd) - ((BYTE *)pqwInsert));

        // Set the new item key and increment the count
        *pqwInsert = qwUserId;
        m_cUsers++;
    }
    else
    {
        // already in the list
        return S_FALSE;
    }

    return S_OK;
}

/*****************************************************************************

CUserList::Remove

Remove a user from the list

*****************************************************************************/
HRESULT CUserList::Remove(QWORD qwUserId)
{
    QWORD *pqwUser = NULL;

    if (m_rgqwUsers == NULL)
    {
        return S_FALSE;
    }

    // Try to find them in the list
    pqwUser = (QWORD *) bsearch(
        &qwUserId,
        m_rgqwUsers,
        m_cUsers,
        sizeof(QWORD),
        CompareBuddies);  //buddies are QWORDs.

    if (pqwUser == NULL)
    {
        return S_FALSE;
    }

    // Found, if last invitee turn off the lights else remove
    if (m_cUsers == 1)
    {
        m_cUsers = 0;
        delete[] m_rgqwUsers;
        m_rgqwUsers = NULL;
    }
    else
    {
        // Move everyone else up
        m_cUsers--;
        QWORD *pqwEnd = m_rgqwUsers + m_cUsers;

        memmove(pqwUser, pqwUser+1, ((BYTE *)pqwEnd) - ((BYTE *)pqwUser));
    }

    return S_OK;
}

/*****************************************************************************

CUserList::Update

Update the list of users to a new list, outputing the lists of added and
removed users

*****************************************************************************/
HRESULT CUserList::Replace(DWORD cNew, const QWORD *pqwNew, DWORD *pcAdd, QWORD *rgqwAdd, DWORD *pcSub, QWORD *rgqwSub)
{
    QWORD *rgqwNew = NULL;
    DWORD dwIndexNew = 0;
    DWORD dwIndexOld = 0;

    if (cNew > 0)
    {
        // Copy to a new location for the user list
        rgqwNew = new QWORD[cNew];
        if (rgqwNew == NULL)
        {
            return E_OUTOFMEMORY;
        }

        memcpy(rgqwNew, pqwNew, cNew * sizeof(QWORD));

        // Sort the new user list
        qsort((void *)rgqwNew, cNew, sizeof(QWORD), CompareBuddies);

        // Figure out the diff lists
        *pcAdd = 0;
        *pcSub = 0;

        while ((dwIndexNew < cNew) && (dwIndexOld < m_cUsers))
        {
            if (GET_PUID_BITS(m_rgqwUsers[dwIndexOld]) == GET_PUID_BITS(rgqwNew[dwIndexNew]))
            {
                // User stays
                dwIndexNew++;
                dwIndexOld++;
            }
            else if (GET_PUID_BITS(m_rgqwUsers[dwIndexOld]) < GET_PUID_BITS(rgqwNew[dwIndexNew]))
            {
                // User removed
                rgqwSub[*pcSub] = m_rgqwUsers[dwIndexOld];
                *pcSub += 1;
                dwIndexOld++;
            }
            else
            {
                // User added
                rgqwAdd[*pcAdd] = rgqwNew[dwIndexNew];
                *pcAdd += 1;
                dwIndexNew++;
            }
        }
        while (dwIndexOld < m_cUsers)
        {
            // User removed
            rgqwSub[*pcSub] = m_rgqwUsers[dwIndexOld];
            *pcSub += 1;
            dwIndexOld++;
        }
        while (dwIndexNew < cNew)
        {
            // User added
            rgqwAdd[*pcAdd] = rgqwNew[dwIndexNew];
            *pcAdd += 1;
            dwIndexNew++;
        }
    }
    else
    {
        // Add everyone to the removed list
        memcpy(rgqwSub, m_rgqwUsers, m_cUsers * sizeof(QWORD));
        *pcSub = m_cUsers;
    }

    // Set the new list
    delete[] m_rgqwUsers;
    m_cUsers = cNew;
    m_rgqwUsers = rgqwNew;

    return S_OK;
}

HRESULT CUserList::Update(DWORD cAdd, QWORD *rgqwAdd, DWORD cSub, QWORD *rgqwSub)
{
    DWORD iCurrent = 0;
    DWORD iAdd = 0;
    DWORD iSub = 0;
    DWORD cNew = 0;
    
    // make space assuming that all of the adds are valid and all of the subs are invalid.
    QWORD *rgqwNew = new QWORD[m_cUsers + cAdd];
    if (rgqwNew == NULL)
    {
        return E_OUTOFMEMORY;
    }

    // sort the add and sub lists
    qsort((void *)rgqwSub, cSub, sizeof(QWORD), CompareBuddies);
    qsort((void *)rgqwAdd, cAdd, sizeof(QWORD), CompareBuddies);

    // skip any leading subs
    while ((iSub < cSub) && ((m_cUsers == 0) || (GET_PUID_BITS(m_rgqwUsers[0]) > GET_PUID_BITS(rgqwSub[iSub]))))
    {
        iSub++;
    }

    // add any leading adds
    while ((iAdd < cAdd) && ((m_cUsers == 0) || (GET_PUID_BITS(m_rgqwUsers[0]) > GET_PUID_BITS(rgqwAdd[iAdd]))))
    {
            rgqwNew[cNew] = rgqwAdd[iAdd];
            cNew++;
            iAdd++;
    }

    // merge the three lists
    while (iCurrent < m_cUsers)
    {
        // skip anything in the sub list
        while ((iSub < cSub) && (iCurrent < m_cUsers) && (GET_PUID_BITS(m_rgqwUsers[iCurrent]) == GET_PUID_BITS(rgqwSub[iSub])))
        {
            iCurrent++;
            iSub++;
        }

        if (iCurrent >= m_cUsers)
        {
            break;
        }

        if (iAdd < cAdd)
        {
            if (GET_PUID_BITS(m_rgqwUsers[iCurrent]) == GET_PUID_BITS(rgqwAdd[iAdd]))
            {
                rgqwNew[cNew] = m_rgqwUsers[iCurrent];
                cNew++;
                iCurrent++;
                iAdd++;
            }
            else if (GET_PUID_BITS(m_rgqwUsers[iCurrent]) < GET_PUID_BITS(rgqwAdd[iAdd]))
            {
                rgqwNew[cNew] = m_rgqwUsers[iCurrent];
                cNew++;
                iCurrent++;
            }
            else
            {
                rgqwNew[cNew] = rgqwAdd[iAdd];
                cNew++;
                iAdd++;
            }
        }
        else
        {
            rgqwNew[cNew] = m_rgqwUsers[iCurrent];
            cNew++;
            iCurrent++;
        }
    }

    // add any remaining adds.
    while (iAdd < cAdd)
    {
        rgqwNew[cNew] = rgqwAdd[iAdd];
        cNew++;
        iAdd++;
    }
    
    // Set the new list
    delete[] m_rgqwUsers;
    m_cUsers = cNew;
    m_rgqwUsers = rgqwNew;

    return S_OK;
}


/*****************************************************************************

CUserList::Clear

Clear the list of all entries

*****************************************************************************/
void CUserList::Clear()
{
    m_cUsers = 0;

    if (m_rgqwUsers != NULL)
    {
        delete[] m_rgqwUsers;
        m_rgqwUsers = NULL;
    }
}

/*****************************************************************************

CUserList::IsPresent

Return true if a user is in the list

*****************************************************************************/
BOOL CUserList::IsPresent(QWORD qwUserId)
{
    QWORD *pqwUser = NULL;

    // See if there is a pending invite
    if (m_rgqwUsers != NULL)
    {
        // Try to find them in the list
        pqwUser = (QWORD *) bsearch(
            &qwUserId,
            m_rgqwUsers,
            m_cUsers,
            sizeof(QWORD),
            CompareBuddies);
    }

    return (pqwUser != NULL);
}

/*****************************************************************************

CQueueItem::SelfDestruct

Removes the item from all indexes and frees it back to the system.

*****************************************************************************/
void CQueueItem::SelfDestruct()
{
    // Remove ourself from our queue
    m_pCQueue->RemoveItem(this);

    // Poof (payload is freed with metadata)
    delete this;
}

/*****************************************************************************

CQueueItem::GetNextV1InQ

Returns the next V1-compatible item in the queue.

*****************************************************************************/
CQueueItem* CQueueItem::GetNextV1InQ()
{
    if( m_pCQueue->GetType() != PQUEUE_TRANSIENT_MSGS )
    {
        return m_pCQNext;
    }
    else
    {
        CQueueItem* pItem = m_pCQNext;
        while( NULL != pItem )
        {
            // V1 items have V1 data on them and should only be returned if
            // they haven't been dequeued before.
            if( NULL != pItem->GetV1Data() && !pItem->IsDequeued() )
            {
                break;
            }
            pItem = pItem->GetNextInQ();
        }
        return pItem;
    }
}

/*****************************************************************************

CQueueItem::GetV1DataSize

Returns the V1-compatible data size

*****************************************************************************/
DWORD CQueueItem::GetV1DataSize()
{
    if( m_pCQueue->GetType() != PQUEUE_TRANSIENT_MSGS )
    {
        return m_cbData;
    }
    else
    {
        return sizeof( P_INVITATION_ITEM );
    }
}

/*****************************************************************************

CQueueItem::GetV1Data

Returns the V1-compatible data

*****************************************************************************/
const BYTE* CQueueItem::GetV1Data()
{
    if( m_pCQueue->GetType() != PQUEUE_TRANSIENT_MSGS )
    {
        return m_pbData;
    }
    else
    {
        if( ((Q_MESSAGE_SUMMARY*)m_pbData)->dwMessageFlags & XONLINE_MSG_FLAG_SENDER_IS_FRIEND )
        {
            // V1-compatible data is stored at the end
            return m_pbData + m_cbData - sizeof( P_INVITATION_ITEM );
        }
        else
        {
            return NULL;
        }
    }
}

/*****************************************************************************

CQueueItem::SetDequeued

This item has been dequeued, do the right thing with it

*****************************************************************************/
void CQueueItem::SetDequeued()
{
    if( m_pCQueue->GetType() != PQUEUE_TRANSIENT_MSGS )
    {
        SelfDestruct();
    }
    else
    {
        // This is a V1-style invite that should not appear again for
        // the duration of this logon, but that should reappear if the user
        // logs on again.
        m_fDequeued = TRUE;
    }
}

/*****************************************************************************

CQueue::~CQueue

Destructor

*****************************************************************************/
CQueue::~CQueue()
{
    // Remove all the items from the queue
    while (m_pCQueueList != NULL)
    {
        m_pCQueueList->SelfDestruct();
    }
}

HRESULT CQueue::DeSerialize(P_QUEUE_ITEM_MSG *pMsg, DWORD *pdwSize, DWORD dwTimeShift)
{
    HRESULT hr = S_OK;
    DWORD cbRead = 0;
    
    if ((pMsg == NULL) || (pdwSize == NULL))
    {
        hr = E_POINTER;
        goto lDone;
    }


    while (*pdwSize > cbRead)
    {
        P_QUEUE_ITEM_MSG *pQItem = (P_QUEUE_ITEM_MSG *)((BYTE *)pMsg + cbRead);

        cbRead += sizeof(P_QUEUE_ITEM_MSG);

        if (*pdwSize < cbRead)
        {
            cbRead -= sizeof(P_QUEUE_ITEM_MSG);
            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            goto lDone;
        }

        if (pQItem->dwQueueType != m_dwQueueType)
        {
            cbRead -= sizeof(P_QUEUE_ITEM_MSG);
            break;
        }
        
        cbRead += pQItem->cbData;
        
        if (*pdwSize < cbRead)
        {
            cbRead -= (sizeof(P_QUEUE_ITEM_MSG) + pQItem->cbData);
            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            goto lDone;
        }

        // TRICK: Allocate both the metadata and payload at once
        CQueueItem *pCNewItem = new (new BYTE[sizeof(CQueueItem) + pQItem->cbData]) CQueueItem;
        if (pCNewItem == NULL)
        {
            return E_OUTOFMEMORY;
        }

        pCNewItem->m_dwItemID = pQItem->dwItemID;
        pCNewItem->m_dwTimestamp = ZeroProtectedTimeShift(pQItem->dwTimestamp, dwTimeShift);
        pCNewItem->m_fDequeued = pQItem->fDequeued;
        pCNewItem->m_cbData = pQItem->cbData;
        memcpy(pCNewItem->m_pbData, pQItem + 1, pQItem->cbData);

        // Set the pointer back to daddy
        pCNewItem->m_pCQueue = this;

        // Add it to the end of the queue
        pCNewItem->m_pCQNext = NULL;
        pCNewItem->m_pCQBack = m_pCQueueTail;
        if (m_pCQueueTail == NULL)
        {
            m_pCQueueList = pCNewItem;
        }
        else
        {
            m_pCQueueTail->m_pCQNext = pCNewItem;
        }
        m_pCQueueTail = pCNewItem;

        // Count it
        m_dwQueueLength++;

        g_Counters.IncrementValue32(XPPERF_SERVER_QUEUE_ITEMS_TOTAL, 1);
        if (m_dwQueueType == PQUEUE_PRESENCE)
        {
            g_Counters.IncrementValue32(XPPERF_SERVER_PRESENCE_QUEUE_ITEMS_TOTAL, 1);
        }
        else if (m_dwQueueType == PQUEUE_PRESENCE_2)
        {
            g_Counters.IncrementValue32(XPPERF_SERVER_PRESENCE2_QUEUE_ITEMS_TOTAL, 1);
        }

    }


lDone:

    *pdwSize = cbRead;

    return hr;
}


/*****************************************************************************

CQueue::AddItem

Creates a new item and adds to the Queue

Returns S_FALSE if the item added generated a QVal change

*****************************************************************************/
HRESULT CQueue::AddItem(
    DWORD dwItemID,
    DWORD cbData,
    const BYTE *pbData)
{
    HRESULT hrRet = S_OK;
    CQueueItem *pCNewItem;

    const Q_SCHEMA &s = g_QSchemas[ m_dwQueueType ];

    // Enforce Q schema data size rules
    if(cbData < s.dwMinDataSize)
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_205,
            "CQueue::AddItem data too small (0x%x < 0x%x)",
            cbData,
            s.dwMinDataSize);
        return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }
    else if(cbData > s.dwMaxDataSize)
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_206,
            "CQueue::AddItem data too large (0x%x > 0x%x)",
            cbData,
            s.dwMaxDataSize);
        return HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
    }

    // Duplicate detection
    if(!s.fAllowDups)
    {
        XOMASSERT(s.dwDupAttrOffset + s.dwDupAttrLen <= cbData);

        CQueueItem *pCDup;
        CQueueItem *pCVictim;

        pCDup = m_pCQueueList;

        while (pCDup != NULL)
        {
            // Do we have a match?
            if (memcmp(pbData + s.dwDupAttrOffset,
                       pCDup->m_pbData + s.dwDupAttrOffset,
                       s.dwDupAttrLen) == 0)
            {
                // Last item wins
                pCVictim = pCDup;
                pCDup = pCDup->m_pCQNext;
                pCVictim->SelfDestruct();

                // there can be only one!
                break;
            }
            else
            {
                // Next
                pCDup = pCDup->m_pCQNext;
            }
        }

    }

    // If our queue is full delete the oldest item
    while( m_dwQueueLength >= s.dwMaxItems )
    {
        DeleteOldestItem();
    }

    // Create and populate it
    // TRICK: Allocate both the metadata and payload at once
    pCNewItem = new (new BYTE[sizeof(CQueueItem) + cbData]) CQueueItem;
    if (pCNewItem == NULL)
    {
        return E_OUTOFMEMORY;
    }

    pCNewItem->m_dwItemID = dwItemID;
    pCNewItem->m_dwTimestamp = GetTickCount();
    pCNewItem->m_fDequeued = FALSE;
    pCNewItem->m_cbData = cbData;
    memcpy(pCNewItem->m_pbData, pbData, cbData);

    // Set the pointer back to daddy
    pCNewItem->m_pCQueue = this;

    // Add it to the end of the queue
    pCNewItem->m_pCQNext = NULL;
    pCNewItem->m_pCQBack = m_pCQueueTail;
    if (m_pCQueueTail == NULL)
    {
        m_pCQueueList = pCNewItem;
    }
    else
    {
        m_pCQueueTail->m_pCQNext = pCNewItem;
    }
    m_pCQueueTail = pCNewItem;

    // Count it
    m_dwQueueLength++;
    m_pCPresence->m_pOnlinePresence->m_dwTotalQLength++;

    g_Counters.IncrementValue32(XPPERF_SERVER_QUEUE_ITEMS_TOTAL, 1);
    if (m_dwQueueType == PQUEUE_PRESENCE)
    {
        g_Counters.IncrementValue32(XPPERF_SERVER_PRESENCE_QUEUE_ITEMS_TOTAL, 1);
    }
    else if (m_dwQueueType == PQUEUE_PRESENCE_2)
    {
        g_Counters.IncrementValue32(XPPERF_SERVER_PRESENCE2_QUEUE_ITEMS_TOTAL, 1);
    }

    if (0 == (m_pCPresence->m_pOnlinePresence->m_rgdwQVals[QVAL_INDEX(QVAL_QFLAGS) + 1] & QFLAG_MASK(m_dwQueueType)))
    {
        // Push this if it's the first QVal changed
        if (m_pCPresence->m_pOnlinePresence->m_rgdwQVals[QVAL_INDEX(QVAL_QFLAGS) + 1] == 0)
        {
            m_pCPresence->m_fPushQVals = TRUE;
        }

        // Mark a QFlags change
        m_pCPresence->m_pOnlinePresence->m_dwSeqQVals++;

        m_pCPresence->m_pOnlinePresence->m_rgdwQVals[QVAL_INDEX(QVAL_QFLAGS)] =
            QVAL_QFLAGS |
            (m_pCPresence->m_pOnlinePresence->m_dwSeqQVals << QVAL_SEQ_SHIFT);

        m_pCPresence->m_pOnlinePresence->m_rgdwQVals[QVAL_INDEX(QVAL_QFLAGS) + 1] |= QFLAG_MASK(m_dwQueueType);

        hrRet = S_FALSE;
    }

    //g_Counters.IncrementValue64( m_dwQueueType, XPPERF_QUEUE_LENGTH_COUNTER, 1 );

    return hrRet;
}

/*****************************************************************************

CQueue::AddXMsgItem

Creates a new item and adds to the Queue

Returns S_FALSE if the item added generated a QVal change

*****************************************************************************/
HRESULT CQueue::AddXMsgItem(
    DWORD dwItemID,
    BYTE fSenderIsFriend,
    const Q_SEND_MESSAGE_MSG* pSendMessage,
    const BYTE* pbDetails)         // size is in pSendMessage
{
    HRESULT hrRet = S_OK;
    CQueueItem *pCNewItem;
    const Q_SCHEMA &s = g_QSchemas[ m_dwQueueType ];
    QWORD qwSessionID = 0;

    DWORD cbData = sizeof( Q_MESSAGE_SUMMARY ) + pSendMessage->cbDetails;
    if( fSenderIsFriend )
    {
        cbData += sizeof( P_INVITATION_ITEM );
    }

    // Enforce Q schema data size rules
    if(cbData < s.dwMinDataSize)
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_207,
            "CQueue::AddXMsgItem data too small (0x%x < 0x%x)",
            cbData,
            s.dwMinDataSize);
        return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }
    else if(cbData > s.dwMaxDataSize)
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_208,
            "CQueue::AddXMsgItem data too large (0x%x > 0x%x)",
            cbData,
            s.dwMaxDataSize);
        return HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
    }

    // Look for the required session ID property
    const BYTE* pbProp = GetMessageProperty( XONLINE_MSG_PROP_SESSION_ID,  (const XMSG_DETAILS*) pbDetails );
    if( NULL != pbProp )
    {
        qwSessionID = *(QWORD*)pbProp;
    }
    if( 0 == qwSessionID )
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_209,
            "CQueue::AddXMsgItem session ID property 0 or not found");
        return E_INVALIDARG;
    }

    // Create and populate it
    // TRICK: Allocate both the metadata and payload at once
    pCNewItem = new (new BYTE[sizeof(CQueueItem) + cbData]) CQueueItem;
    if (pCNewItem == NULL)
    {
        return E_OUTOFMEMORY;
    }

    pCNewItem->m_cbData = cbData;

    SYSTEMTIME systime;
    GetSystemTime( &systime );

    FILETIME filetime;
    SystemTimeToFileTime( &systime, &filetime );

    Q_MESSAGE_SUMMARY* pMessageSummary = (Q_MESSAGE_SUMMARY*) pCNewItem->m_pbData;
    pMessageSummary->dwMessageID = dwItemID;
    pMessageSummary->bMessageType = pSendMessage->bMessageType;
    pMessageSummary->dwMessageFlags = pSendMessage->dwMessageFlags;
    if( fSenderIsFriend )
    {
        pMessageSummary->dwMessageFlags |= XONLINE_MSG_FLAG_SENDER_IS_FRIEND;
    }
    pMessageSummary->qwSenderID = pSendMessage->qwSenderID;
    pMessageSummary->qwSenderContext = pSendMessage->qwSenderContext;
    memcpy( pMessageSummary->szSenderName, pSendMessage->szSenderName, sizeof( pMessageSummary->szSenderName ) );
    pMessageSummary->dwSenderTitleID = pSendMessage->dwSenderTitleID;
    pMessageSummary->mtSentTime = FileTimeToMsgTime( &filetime );
    pMessageSummary->wExpireMinutes = pSendMessage->wExpireMinutes;
    pMessageSummary->cbDetails = pSendMessage->cbDetails;

    // Copy over the extended properties
    memcpy( pMessageSummary + 1, pbDetails, pSendMessage->cbDetails );

    if( fSenderIsFriend )
    {
        P_INVITATION_ITEM* pInviteItem = (P_INVITATION_ITEM*)( (BYTE*)( pMessageSummary + 1 ) + pSendMessage->cbDetails );
        pInviteItem->qwHostID = pSendMessage->qwSenderID;
        pInviteItem->qwMatchSessionID = qwSessionID;
        pInviteItem->dwTitleID = pSendMessage->dwSenderTitleID;
        pInviteItem->ftSent = filetime;
    }

    pCNewItem->m_dwItemID = dwItemID;
    pCNewItem->m_dwTimestamp = GetTickCount();
    pCNewItem->m_fDequeued = FALSE;

    // Set the pointer back to daddy
    pCNewItem->m_pCQueue = this;

    // Add it to the end of the queue
    pCNewItem->m_pCQNext = NULL;
    pCNewItem->m_pCQBack = m_pCQueueTail;
    if (m_pCQueueTail == NULL)
    {
        m_pCQueueList = pCNewItem;
    }
    else
    {
        m_pCQueueTail->m_pCQNext = pCNewItem;
    }
    m_pCQueueTail = pCNewItem;

    // Count it
    m_dwQueueLength++;
    m_pCPresence->m_pOnlinePresence->m_dwTotalQLength++;

    g_Counters.IncrementValue32(XPPERF_SERVER_QUEUE_ITEMS_TOTAL, 1);
    if (m_dwQueueType == PQUEUE_PRESENCE)
    {
        g_Counters.IncrementValue32(XPPERF_SERVER_PRESENCE_QUEUE_ITEMS_TOTAL, 1);
    }
    else if (m_dwQueueType == PQUEUE_PRESENCE_2)
    {
        g_Counters.IncrementValue32(XPPERF_SERVER_PRESENCE2_QUEUE_ITEMS_TOTAL, 1);
    }

    // If our queue is full delete the oldest item
    // NOTE: This is done after the new item is added because we don't want deleting this item
    // to take us to zero items and delete the user object.
    while( m_dwQueueLength > s.dwMaxItems )
    {
        DeleteOldestItem();
    }

    // The switchboard will set up the QVals since it has to do it for persistent messages anyway

    // Tell the caller to send qvals
    hrRet = S_FALSE;

    //g_Counters.IncrementValue64( m_dwQueueType, XPPERF_QUEUE_LENGTH_COUNTER, 1 );

    return hrRet;
}

/*****************************************************************************

CQueue::DeleteExpiredItems

Deletes expired items from the queue.

Returns S_FALSE if any items were deleted generating a QVal change

*****************************************************************************/
HRESULT CQueue::DeleteExpiredItems(
    DWORD dwTime)
{
    BOOL fDeletedItems = FALSE;
    CQueueItem *pCOldest;

    // Oldest item must be at the front of the list since we add to the end
    pCOldest = m_pCQueueList;
    while( NULL != pCOldest )
    {
        if( dwTime - pCOldest->GetTimestamp() > ( INVITE_EXPIRATION_MINUTES * 60000 ) )
        {
            CQueueItem* pCVictim;

            fDeletedItems = TRUE;

            pCVictim = pCOldest;
            pCOldest = pCOldest->m_pCQNext;
            m_pCQueueList = pCOldest;

            // This is part of a larger operation, set the QVals, but don't send them yet
            m_pCPresence->SetXMsgDeleteQVals(
                pCVictim->m_dwItemID,
                FALSE );

            //g_Counters.IncrementValue32(
            //    m_dwQueueType,
            //    XPPERF_QUEUE_EXPIRED_MESSAGES_DELETED_COUNTER,
            //    1 );

            // NOTE: This could destroy the whole user object along with this CQueue.  That
            // will only happen if the queue is completely empty, meaning pCOldest has become
            // NULL on this iteration and we will exit the while loop.
            pCVictim->SelfDestruct();
        }
        else
        {
            // Since the oldest items are at the front of the list, we can stop when we
            // find one that isn't expired.
            break;
        }
    }

    if( fDeletedItems )
    {
        return S_FALSE;
    }
    else
    {
        return S_OK;
    }
}

/*****************************************************************************

CQueue::DeleteItemByItemID

Deletes an item with the given ItemID from the given queue

*****************************************************************************/
HRESULT CQueue::DeleteItemByItemID(
    DWORD dwItemID)
{
    BOOL fItemFound = FALSE;
    CQueueItem *pCWork;

    if (m_pCQueueList != NULL)
    {
        pCWork = m_pCQueueList;

        while ((pCWork != NULL) && (pCWork->m_dwItemID < dwItemID))
        {
            pCWork = pCWork->m_pCQNext;
        }

        if ((pCWork != NULL) && (pCWork->m_dwItemID == dwItemID))
        {
            // NOTE: This call may delete the whole CUser object and this queue, don't
            // access any members after this.
            pCWork->SelfDestruct();
            fItemFound = TRUE;
        }
    }

    if( !fItemFound )
    {
        return S_FALSE;
    }
    else
    {
        return S_OK;
    }
}

/*****************************************************************************

CQueue::DeleteXMsgBySource

Deletes all messages of a given type from a given source

*****************************************************************************/
HRESULT CQueue::DeleteXMsgBySource(
    QWORD qwSender,
    QWORD qwContext,
    BYTE bType)
{
    BOOL fItemFound = FALSE;
    CQueueItem *pCWork;
    CQueueItem *pCVictim;

    if (m_pCQueueList != NULL)
    {
        pCWork = m_pCQueueList;

        while (pCWork != NULL)
        {
            const Q_MESSAGE_SUMMARY* pMsgSummary = (Q_MESSAGE_SUMMARY*)pCWork->GetData();

            if ((pMsgSummary->bMessageType == bType) &&
                (pMsgSummary->qwSenderID == qwSender) &&
                (pMsgSummary->qwSenderContext == qwContext))
            {
                // This is part of a larger operation, set the QVals, but don't send them yet
                m_pCPresence->SetXMsgDeleteQVals(
                    pCWork->m_dwItemID,
                    FALSE );

                pCVictim = pCWork;
                pCWork = pCWork->m_pCQNext;
                pCVictim->SelfDestruct();
                fItemFound = TRUE;
            }
            else
            {
                pCWork = pCWork->m_pCQNext;
            }
        }
    }

    if( !fItemFound )
    {
        return S_FALSE;
    }
    else
    {
        return S_OK;
    }
}

/*****************************************************************************

CQueue::ListItems

List items from the queue
*****************************************************************************/
HRESULT CQueue::ListItems(
    BOOL fV1ItemsOnly,
    DWORD dwStartItemID,
    DWORD* pcMaxItems,        // Specifies the max size on the way in, and the actual size on the way out
    DWORD* pcbMaxItemDataSize,// Specifies the max size on the way in, and the actual size on the way out
    CQueueItem** ppFirstItem,
    DWORD* pdwNextItemID,
    DWORD* pcItemsLeft)
{
    HRESULT hr = S_OK;
    CQueueItem *pCStart = NULL;
    CQueueItem *pCWork = NULL;
    DWORD dwItemsSkipped = 0;
    DWORD dwItemsToSend = 0;
    DWORD dwItemDataToSend = 0;
    BOOL fSizeOk = FALSE;
    DWORD dwNextItemID = 0;
    DWORD dwItemsLeft = 0;

    // Figure out who all we can skip becaue they're too old
    pCStart = m_pCQueueList;
    while ((pCStart != NULL) &&
           (pCStart->m_dwItemID < dwStartItemID))
    {
        pCStart = pCStart->m_pCQNext;
        dwItemsSkipped++;
    }

    // If we are doing V1 items only, skip any initial non-V1 items in the queue
    if( fV1ItemsOnly )
    {
        while( NULL != pCStart && ( NULL == pCStart->GetV1Data() || pCStart->IsDequeued() ) )
        {
            pCStart = pCStart->m_pCQNext;
        }
    }

    // Figure out what all we are sending within the given limits
    pCWork = pCStart;
    while ((pCWork != NULL) &&
           (dwItemsToSend < *pcMaxItems))
    {
        // Do we have room for this item?
        if (dwItemDataToSend + pCWork->m_cbData <= *pcbMaxItemDataSize)
        {
            if( !fV1ItemsOnly || ( NULL != pCWork->GetV1Data() && !pCWork->IsDequeued() ) )
            {
                dwItemsToSend++;
                dwItemDataToSend += fV1ItemsOnly ? pCWork->GetV1DataSize() : pCWork->m_cbData;
            }
            pCWork = pCWork->m_pCQNext;
        }
        else
        {
            // Nope, punt out
            break;
        }
    }

    fSizeOk = ((dwItemsToSend >= 1) || (pCStart == NULL));

    // Figure out the items left
    if (pCWork != NULL)
    {
        if( fV1ItemsOnly )
        {
            while( NULL != pCWork )
            {
                if( NULL != pCWork->GetV1Data() && !pCWork->IsDequeued() )
                {
                    if( 0 == dwNextItemID )
                    {
                        dwNextItemID = pCWork->m_dwItemID;
                    }
                    dwItemsLeft++;
                }
                pCWork = pCWork->m_pCQNext;
            }
        }
        else
        {
            dwNextItemID = pCWork->m_dwItemID;
            dwItemsLeft = m_dwQueueLength - dwItemsSkipped - dwItemsToSend;
        }
    }

    *ppFirstItem = pCStart;
    *pcMaxItems = dwItemsToSend;
    *pdwNextItemID = dwNextItemID;
    *pcItemsLeft = dwItemsLeft;
    *pcbMaxItemDataSize = dwItemDataToSend;

    if( !fSizeOk )
    {
        hr = HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER );
    }

    return hr;
}

/*****************************************************************************

CQueue::GetItem

Get the specified item from the queue

*****************************************************************************/
CQueueItem* CQueue::GetItem(
    DWORD dwItemID)
{
    CQueueItem* pItemCursor;

    // Find the item
    pItemCursor = m_pCQueueList;

    while( NULL != pItemCursor &&
           pItemCursor->m_dwItemID < dwItemID )
    {
        pItemCursor = pItemCursor->m_pCQNext;
    }

    if( NULL == pItemCursor ||
        pItemCursor->m_dwItemID != dwItemID )
    {
        // Item not found
        return NULL;
    }

    return pItemCursor;
}

/*****************************************************************************

CQueue::RemoveItem

Removes an item from the queue, but does not delete it

*****************************************************************************/
void CQueue::RemoveItem(CQueueItem *pCItem)
{
    // Fix up the item behind me
    if (pCItem->m_pCQBack != NULL)
    {
        pCItem->m_pCQBack->m_pCQNext = pCItem->m_pCQNext;
    }
    else
    {
        // Go back to the index
        m_pCQueueList = pCItem->m_pCQNext;
    }

    // Fix up the item in front of me
    if (pCItem->m_pCQNext != NULL)
    {
        pCItem->m_pCQNext->m_pCQBack = pCItem->m_pCQBack;
    }
    else
    {
        m_pCQueueTail = pCItem->m_pCQBack;
    }

    // Count it
    m_dwQueueLength--;
    m_pCPresence->m_pOnlinePresence->m_dwTotalQLength--;

    g_Counters.DecrementValue32(XPPERF_SERVER_QUEUE_ITEMS_TOTAL, 1);
    if (m_dwQueueType == PQUEUE_PRESENCE)
    {
        g_Counters.DecrementValue32(XPPERF_SERVER_PRESENCE_QUEUE_ITEMS_TOTAL, 1);
    }
    else if (m_dwQueueType == PQUEUE_PRESENCE_2)
    {
        g_Counters.DecrementValue32(XPPERF_SERVER_PRESENCE2_QUEUE_ITEMS_TOTAL, 1);
    }

    if (m_dwQueueLength == 0)
    {

        if ((m_pCPresence->m_pOnlinePresence->m_rgdwQVals[QVAL_INDEX(QVAL_QFLAGS) + 1] & QFLAG_MASK(m_dwQueueType)))
        {
            // Mark a QFlag change
            m_pCPresence->m_pOnlinePresence->m_dwSeqQVals++;

            XomTrace(
                PresenceDebug,
                L_NORMAL,
                "RemoveItem clearing QFlag since all items removed User=%I64X Type=%d NewSeq=%X",
                m_pCPresence->GetUserID(),
                m_dwQueueType,
                m_pCPresence->m_pOnlinePresence->m_dwSeqQVals);

            m_pCPresence->m_pOnlinePresence->m_rgdwQVals[QVAL_INDEX(QVAL_QFLAGS)] =
                QVAL_QFLAGS |
                (m_pCPresence->m_pOnlinePresence->m_dwSeqQVals << QVAL_SEQ_SHIFT);

            m_pCPresence->m_pOnlinePresence->m_rgdwQVals[QVAL_INDEX(QVAL_QFLAGS) + 1] &= ~(QFLAG_MASK(m_dwQueueType));
        }

        // NOTE: XMsg QVals are handled by the layers above calling this function
    }

    //g_Counters.DecrementValue64( m_dwQueueType, XPPERF_QUEUE_LENGTH_COUNTER, 1 );

    pCItem->m_pCQNext = NULL;
    pCItem->m_pCQBack = NULL;
}

/*****************************************************************************

CQueue::DeleteOldestItem

Deletes the oldest item from the queue

*****************************************************************************/
void CQueue::DeleteOldestItem()
{
    CQueueItem *pCOldest;

    // Oldest item must be at the front of the list since we add to the end
    if (m_pCQueueList != NULL)
    {
        pCOldest = m_pCQueueList;

        m_pCQueueList = pCOldest->m_pCQNext;

        // This is part of a larger operation, set the QVals, but don't send them yet
        m_pCPresence->SetXMsgDeleteQVals(
            pCOldest->m_dwItemID,
            FALSE );

        // NOTE: This could destroy the user object if it deletes the last item in the
        // queue and the user is offline.
        pCOldest->SelfDestruct();

        //g_Counters.IncrementValue32(
        //        m_dwQueueType,
        //        XPPERF_QUEUE_ADD_OLDEST_DISCARDED_COUNTER,
        //        1 );
    }
}

/*****************************************************************************

CQueue::Clear

Clears all items from the queue

*****************************************************************************/
void CQueue::Clear()
{
    CQueueItem *pCWork;

    pCWork = m_pCQueueList;

    while( NULL != pCWork )
    {
        CQueueItem *pCVictim;

        pCVictim = pCWork;
        pCWork = pCWork->m_pCQNext;

        if( PQUEUE_TRANSIENT_MSGS != m_dwQueueType )
        {
            // For all but the Message queue, clear means delete
            m_pCQueueList = pCWork;
            pCVictim->SelfDestruct();
        }
        else
        {
            // For the Message queue, we only want to reset the dequeued items
            // so that they show up again if the user comes back online.
            pCVictim->ResetDequeued();
        }
    }
}

/*****************************************************************************

CPresence constructor

Initializes all member variables and tracks session start time

*****************************************************************************/
CPresence::CPresence(CSwitchboard *pSwitchboard) :
    m_pSwitchboard(pSwitchboard),
    m_qwUserID(0),
    m_qwNonce(0),
    m_dwLastActive(0),
    m_qwWebID(0),
    m_mtUserStateChanged(0),
    m_dwLastSeenTitleID(0),
    m_dwState(0),
    m_cBuddies(0),
    m_dwBuddyListVersion(0xFFFFFFFF),
    m_rgCBuddyList(NULL),
    m_pCPresenceNext(NULL),
    m_pCPresenceBack(NULL),
    m_cbAcctName(0),
    m_cNeverList(0),
    m_rgqwNeverList(NULL),
    m_dwFlags(0),
    m_pOnlinePresence(NULL),
    m_pCBucketChangeCtx(NULL),
    m_pDeferredQueue(NULL),
    m_mtMessageThrottle(0),
    m_cMessagesToday(0),
    m_cRecipientsToday(0)
{
    m_szAcctName[0] = '\0';
    
    g_Counters.SafeIncrement32(XPPERF_SERVER_TOTAL_USERS_COUNTER);
}


/*****************************************************************************

CPresence destructor

*****************************************************************************/
CPresence::~CPresence()
{
    if (m_pOnlinePresence)
    {
        RecordPlayStop();
        RecordUserKilled();
        DeleteInvite();
    }

    if (m_rgCBuddyList != NULL)
    {
        delete[] m_rgCBuddyList;
    }

    delete[] m_rgqwNeverList;
    m_rgqwNeverList = NULL;
    m_cNeverList = 0;

    delete m_pOnlinePresence;

    SAFE_RELEASE(m_pCBucketChangeCtx);

    while (m_pDeferredQueue)
    {
        CContextQueueNode *pVictim = m_pDeferredQueue;
        m_pDeferredQueue = pVictim->m_pNext;
        delete pVictim;
    }

    g_CPresCfg.RemoveBucketUser(m_qwUserID);

    g_Counters.SafeDecrement32(XPPERF_SERVER_TOTAL_USERS_COUNTER);
}

ULONG CPresence::AddRef()
{
    return (ULONG) InterlockedIncrement(&(m_refcountvalue.lRefCount));
}

ULONG CPresence::Release()
{
    LONG lCount = InterlockedDecrement(&(m_refcountvalue.lRefCount));

    if (m_fMigrationInProgress)
    {
        // TODO:  check references.  find a way to identify when no contexts are left.  if no contexts are referencing, send the migration data and release the record altogether.

        LONG lZeroRefCount = 1; // CPresenceUserIndex holds a reference always.
        if (HasOnlineRecord() && IsOnline())
        {
            lZeroRefCount += 2; //CPresenceXboxIndex and CPresenceSGIndex have references when the user is online.
        }

        if (lCount == lZeroRefCount)
        {
            m_fMarkedForMigration = FALSE;
            m_fMigrationInProgress = FALSE;
            m_pSwitchboard->GetPCluser()->SendFullMigrationMessage(this);

            // at this point, the user is not ours anymore.
            if (HasOnlineRecord() && IsOnline())
            {
                SelfDestruct();
                g_Counters.SafeDecrement32(XPPERF_SERVER_ACTIVE_USERS_COUNTER);
            }
            
            g_CPresenceUserIndex.RemovePresence(this);
        }
    }        
    else if(lCount == 0)
    {
        // really no references.
        delete this;
    }

    return (ULONG) lCount;
} 

COnlinePresence::COnlinePresence(CPresence *pCPresence) :
    m_dwTitleID(0),
    m_dwClientVersion(0),
    m_dwAltTitleID1(0),
    m_dwAltTitleID2(0),
    m_dwAltTitleID3(0),
    m_dwAltTitleID4(0),
    m_dwTitleVersion(0),
    m_dwTitleRegion(0),
    m_ipportXbox(0),
    m_dwAliveTime(0),
    m_dwTitleStart(0),
    m_dwPlayStart(0),
    m_dwAuthDataFlags(0),
    m_qwMatchSessionID(0),
    m_cbTitleStuff(0),
    m_cbRichPresence(0),
    m_cbPresenceData(0),
    m_pPresenceData(NULL),
    m_cbNickname(0),        
    m_wDequeues(0),
    m_wStates(0),
    m_dwBlockListVersion(0xFFFFFFFF),
    m_pCInvitation(NULL),
    m_prgAffiliateLists(NULL),
    m_mtAffiliatesLoaded(0),
    m_dwNextXMsgItemID( 1 | XONLINE_MSG_ID_TRANSIENT_MESSAGE ),
    m_dwNextItemID(1),
    m_dwSeqQVals(1),
    m_dwSeqXMsgAddQVal(1),
    m_dwSeqXMsgDeleteQVal(1),
    m_dwPQueueIndex((DWORD)~0),
    m_dwTimeScheduled(0),
    m_dwTickleCount(0),
    m_pCXBoxNext(NULL),
    m_pCXBoxBack(NULL),
    m_pCSGNext(NULL),
    m_pCSGBack(NULL),
    m_dwTotalQLength(0),
    m_qwVersionFlags(0),
    m_pCPresence(pCPresence)
{
    memset(&m_xnaddr, 0, sizeof(XNADDR));
    memset(&m_xkid, 0, sizeof(XNKID));
    memset(&m_xnkey, 0, sizeof(XNKEY));
    memset(&m_ipaXbox, 0, sizeof(IN_ADDR));
    memset(&m_sgaddr, 0, sizeof(SGADDR));
    memset( m_rgbNickname, 0, sizeof(m_rgbNickname) );
    memset(m_szLocale, 0, XONLINE_PRESENCE_LOCALE_SIZE);

    DWORD dwIndex;
    for (dwIndex = 0; dwIndex < PQUEUE_NUM_TYPES; dwIndex++)
    {
        m_rgCQueues[dwIndex].SetType(dwIndex);
        m_rgCQueues[dwIndex].SetUser(pCPresence);
    }

    // Init QVals
    ZeroMemory(m_rgdwQVals, sizeof(DWORD) * QVAL_COUNT);
    m_rgdwQVals[ QVAL_INDEX( QVAL_QFLAGS ) ] = QVAL_QFLAGS | (m_dwSeqQVals << QVAL_SEQ_SHIFT);
    m_rgdwQVals[ QVAL_INDEX( QVAL_NEW_GAME_INVITE ) ] = QVAL_NEW_GAME_INVITE | (m_dwSeqQVals << QVAL_SEQ_SHIFT);
    m_rgdwQVals[ QVAL_INDEX( QVAL_NEW_MSG_IDS ) ] = QVAL_NEW_MSG_IDS | (m_dwSeqXMsgAddQVal << QVAL_SEQ_SHIFT);
    m_rgdwQVals[ QVAL_INDEX( QVAL_NEW_MSG_DATA ) ] = QVAL_NEW_MSG_DATA | (m_dwSeqXMsgAddQVal << QVAL_SEQ_SHIFT);
    m_rgdwQVals[ QVAL_INDEX( QVAL_MSG_DELETED ) ] = QVAL_MSG_DELETED | (m_dwSeqXMsgDeleteQVal << QVAL_SEQ_SHIFT);

}

COnlinePresence::~COnlinePresence()
{
    if (m_prgAffiliateLists)
    {
        m_pCPresence->StoreAffiliates();
    }

    if (m_pPresenceData)
    {
        delete m_pPresenceData;
    }
}

HRESULT CPresence::Serialize(P_USER_FULL_MIGRATION_MSG * pMsg, DWORD * pdwSize)
{
    HRESULT hr = S_OK;
    DWORD dwSize = 0;
    
    if ((pMsg == NULL) || (pdwSize == NULL))
    {
        hr = E_POINTER;
        goto lDone;
    }

    if (*pdwSize < sizeof(P_USER_FULL_MIGRATION_MSG))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto lDone;
    }

    // versioning
    pMsg->dwVersion = XONLINE_PRESENCE_FULL_MIGRATION_VERSION;
    pMsg->dwMigrationFlags = 0;

    // base record
    pMsg->qwUserID = m_qwUserID;
    pMsg->qwNonce = m_qwNonce;
    pMsg->dwLastActive = m_dwLastActive;
    pMsg->mtUserStateChanged = m_mtUserStateChanged;
    pMsg->dwLastSeenTitleID = m_dwLastSeenTitleID;
    pMsg->dwFlags = m_dwFlags;
    pMsg->qwWebID = m_qwWebID;
    pMsg->dwState = m_dwState;
    pMsg->cMessagesToday = m_cMessagesToday;
    pMsg->cRecipientsToday = m_cRecipientsToday;
    pMsg->mtMessageThrottle = m_mtMessageThrottle;
    pMsg->cBuddies = m_cBuddies;
    pMsg->cNeverList = m_cNeverList;
    pMsg->dwBuddyListVersion = m_dwBuddyListVersion;
    pMsg->cWatchers = m_CWatcherList.GetCount();
    pMsg->cbAcctName = m_cbAcctName;
    memcpy(pMsg->szAcctName, m_szAcctName, MAX_ACCTNAME_BYTES);
    pMsg->fOnlineRecordExists = (m_pOnlinePresence != NULL);
    dwSize = sizeof(P_USER_FULL_MIGRATION_MSG);

    if (*pdwSize - dwSize < (pMsg->cBuddies * sizeof(QWORD)))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto lDone;
    }
    QWORD *rgBuddies = (QWORD *)((BYTE *)pMsg + dwSize);
    for (DWORD iBuddy = 0; iBuddy < pMsg->cBuddies; iBuddy++)
    {
        rgBuddies[iBuddy] = GetBuddy(iBuddy)->qwData;
    }
    dwSize += (pMsg->cBuddies * sizeof(QWORD));

    if (*pdwSize - dwSize < (pMsg->cNeverList * sizeof(QWORD)))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto lDone;
    }
    QWORD *rgNevers = (QWORD *)((BYTE *)pMsg + dwSize);
    memcpy(rgNevers, m_rgqwNeverList, pMsg->cNeverList * sizeof(QWORD));
    dwSize += (pMsg->cNeverList * sizeof(QWORD));
    
    if (*pdwSize - dwSize < (pMsg->cWatchers * sizeof(QWORD)))
    {
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto lDone;
    }
    QWORD *rgWatchers = (QWORD *)((BYTE *)pMsg + dwSize);
    memcpy(rgWatchers, m_CWatcherList.GetUsers(), pMsg->cWatchers * sizeof(QWORD));
    dwSize += (pMsg->cWatchers * sizeof(QWORD));

    if (m_pOnlinePresence != NULL)
    {
        if (*pdwSize - dwSize < sizeof(P_ONLINE_PRESENCE_RECORD_MSG))
        {
            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            goto lDone;            
        }
                
        P_ONLINE_PRESENCE_RECORD_MSG *pORMsg = (P_ONLINE_PRESENCE_RECORD_MSG *)((BYTE *)pMsg + dwSize);

        memcpy(&(pORMsg->sgaddr), &(m_pOnlinePresence->m_sgaddr), sizeof(SGADDR));
        pORMsg->dwClientVersion = m_pOnlinePresence->m_dwClientVersion;
        pORMsg->dwTitleID = m_pOnlinePresence->m_dwTitleID;
        pORMsg->dwAltTitleID1 = m_pOnlinePresence->m_dwAltTitleID1;
        pORMsg->dwAltTitleID2 = m_pOnlinePresence->m_dwAltTitleID2;
        pORMsg->dwAltTitleID3 = m_pOnlinePresence->m_dwAltTitleID3;
        pORMsg->dwAltTitleID4 = m_pOnlinePresence->m_dwAltTitleID4;
        pORMsg->dwTitleVersion = m_pOnlinePresence->m_dwTitleVersion;
        pORMsg->dwTitleRegion = m_pOnlinePresence->m_dwTitleRegion;
        memcpy(&(pORMsg->xnaddr), &(m_pOnlinePresence->m_xnaddr), sizeof(XNADDR));
        memcpy(&(pORMsg->xkid), &(m_pOnlinePresence->m_xkid), sizeof(XNKID));
        memcpy(&(pORMsg->xnkey), &(m_pOnlinePresence->m_xnkey), sizeof(XNKEY));
        memcpy(&(pORMsg->ipaXbox), &(m_pOnlinePresence->m_ipaXbox), sizeof(IN_ADDR));
        pORMsg->ipportXbox = m_pOnlinePresence->m_ipportXbox;
        pORMsg->dwAliveTime = m_pOnlinePresence->m_dwAliveTime;
        pORMsg->dwPlayStart = m_pOnlinePresence->m_dwPlayStart;
        pORMsg->dwTitleStart = m_pOnlinePresence->m_dwTitleStart;
        pORMsg->dwAuthDataFlags = m_pOnlinePresence->m_dwAuthDataFlags;
        memcpy(pORMsg->szLocale, m_pOnlinePresence->m_szLocale, XONLINE_PRESENCE_LOCALE_SIZE);
        pORMsg->qwVersionFlags = m_pOnlinePresence->m_qwVersionFlags;
        pORMsg->qwMatchSessionID = m_pOnlinePresence->m_qwMatchSessionID;
        pORMsg->cbTitleStuff = m_pOnlinePresence->m_cbTitleStuff;
        pORMsg->cbRichPresence = m_pOnlinePresence->m_cbRichPresence;
        pORMsg->cbPresenceData = m_pOnlinePresence->m_cbPresenceData;
        pORMsg->cbNickname = m_pOnlinePresence->m_cbNickname;
        memcpy(pORMsg->rgbNickname, m_pOnlinePresence->m_rgbNickname, MAX_NICKNAME_BYTES);
        pORMsg->wDequeues = m_pOnlinePresence->m_wDequeues;
        pORMsg->wStates = m_pOnlinePresence->m_wStates;

        if (GetInvite() == NULL)
        {
            pORMsg->dwInviteTitleID = 0;
            pORMsg->qwInviteSessionID = 0;
            ZeroMemory(&(pORMsg->ftInviteSent), sizeof(FILETIME));
            pORMsg->cInvitees = 0;            
        }
        else
        {
            pORMsg->dwInviteTitleID = GetInvite()->dwTitleID;
            pORMsg->qwInviteSessionID = GetInvite()->qwMatchSessionID;
            memcpy(&(pORMsg->ftInviteSent), &(GetInvite()->ftSent), sizeof(FILETIME));
            pORMsg->cInvitees = GetInvite()->cInvitees;
        }
        
        pORMsg->dwBlockListVersion = m_pOnlinePresence->m_dwBlockListVersion;
        pORMsg->cWatches = m_pOnlinePresence->m_CWatchingList.GetCount();
        pORMsg->dwNextXMsgItemID = m_pOnlinePresence->m_dwNextXMsgItemID;
        pORMsg->dwSeqQVals = m_pOnlinePresence->m_dwSeqQVals;
        pORMsg->dwSeqXMsgAddQVal = m_pOnlinePresence->m_dwSeqXMsgAddQVal;
        pORMsg->dwSeqXMsgDeleteQVal = m_pOnlinePresence->m_dwSeqXMsgDeleteQVal;
        memcpy(pORMsg->rgdwQVals, m_pOnlinePresence->m_rgdwQVals, sizeof(DWORD) * QVAL_COUNT);
        pORMsg->dwTotalQLength = m_pOnlinePresence->m_dwTotalQLength;
        pORMsg->dwNextItemID = m_pOnlinePresence->m_dwNextItemID;

        dwSize += sizeof(P_ONLINE_PRESENCE_RECORD_MSG);

        if (GetInvite() != NULL)
        {
            if (*pdwSize - dwSize < (pORMsg->cInvitees * sizeof(QWORD)))
            {
                hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
                goto lDone;
            }
            QWORD *rgInvitees = (QWORD *)((BYTE *)pMsg + dwSize);
            memcpy(rgInvitees, GetInvite()->rgqwInvitees, pORMsg->cInvitees * sizeof(QWORD));
            dwSize += (pORMsg->cInvitees * sizeof(QWORD));
        }

        if (*pdwSize - dwSize < (pORMsg->cWatches * sizeof(QWORD)))
        {
            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            goto lDone;
        }
        QWORD *rgWatches = (QWORD *)((BYTE *)pMsg + dwSize);
        memcpy(rgWatches, m_pOnlinePresence->m_CWatchingList.GetUsers(), pORMsg->cWatches * sizeof(QWORD));
        dwSize += (pORMsg->cWatches * sizeof(QWORD));

        if (*pdwSize - dwSize < pORMsg->cbPresenceData)
        {
            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            goto lDone;
        }
        memcpy((BYTE *)pMsg + dwSize, m_pOnlinePresence->m_pPresenceData, pORMsg->cbPresenceData);
        dwSize += pORMsg->cbPresenceData;

        // queues
        for (DWORD iQueueType = 0; iQueueType < PQUEUE_NUM_TYPES; iQueueType++)
        {            
            for (CQueueItem *pQItem = m_pOnlinePresence->m_rgCQueues[iQueueType].GetFirstInQ(); pQItem != NULL; pQItem = pQItem->GetNextInQ())
            {
                if (*pdwSize - dwSize < sizeof(P_QUEUE_ITEM_MSG) + pQItem->GetDataSize())
                {
                    hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
                    goto lDone;
                }
                
                P_QUEUE_ITEM_MSG *pQIMsg = (P_QUEUE_ITEM_MSG *)((BYTE *)pMsg + dwSize);
                pQIMsg->dwQueueType = iQueueType;
                pQIMsg->dwItemID = pQItem->GetItemID();
                pQIMsg->dwTimestamp = pQItem->GetTimestamp();
                pQIMsg->fDequeued = pQItem->IsDequeued();
                pQIMsg->cbData = pQItem->GetDataSize();
                memcpy(pQIMsg + 1, pQItem->GetData(), pQIMsg->cbData);

                dwSize += sizeof(P_QUEUE_ITEM_MSG) + pQIMsg->cbData;
            }
        }
        
    }

    *pdwSize = dwSize;

lDone:

    return hr;
}

HRESULT CPresence::DeSerialize(P_USER_FULL_MIGRATION_MSG * pMsg, DWORD dwSize)
{
    HRESULT hr = S_OK;

    if (pMsg == NULL)
    {
        hr = E_POINTER;
        goto lDone;
    }

    DWORD cbRead = sizeof(P_USER_FULL_MIGRATION_MSG);
    if (dwSize < cbRead)
    {
        hr = E_INVALIDARG;
        goto lDone;
    }

    if (pMsg->dwVersion != XONLINE_PRESENCE_FULL_MIGRATION_VERSION)
    {
        hr = E_INVALIDARG;
        goto lDone;
    }
    
    DWORD dwTimeShift = GetTickCount() - pMsg->dwNow;
    
    m_qwNonce = pMsg->qwNonce;
    m_dwLastActive = ZeroProtectedTimeShift(pMsg->dwLastActive, dwTimeShift);
    m_mtUserStateChanged = pMsg->mtUserStateChanged;
    m_dwLastSeenTitleID = pMsg->dwLastSeenTitleID;
    m_dwFlags = pMsg->dwFlags;
    m_qwWebID = pMsg->qwWebID;
    m_dwState = pMsg->dwState;
    m_cMessagesToday = 0;
    m_cRecipientsToday = 0;
    m_mtMessageThrottle = 0;
    m_cBuddies = pMsg->cBuddies;
    m_cNeverList = pMsg->cNeverList;
    m_dwBuddyListVersion = pMsg->dwBuddyListVersion;
    m_cbAcctName = pMsg->cbAcctName;
    memcpy(m_szAcctName, pMsg->szAcctName, MAX_ACCTNAME_BYTES);


    if (m_cBuddies > 0)
    {
        QWORD *rgBuddies = (QWORD *)((BYTE *)pMsg + cbRead);
        
        cbRead += m_cBuddies * sizeof(QWORD);
        
        if (dwSize < cbRead)
        {
            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            goto lDone;
        }
                
        m_rgCBuddyList = new CBuddyListEntry[m_cBuddies];
        if (m_rgCBuddyList == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto lDone;
        }
        
        for (DWORD iBuddy = 0; iBuddy < m_cBuddies; iBuddy++)
        {
            m_rgCBuddyList[iBuddy].qwData = rgBuddies[iBuddy];
            if (m_rgCBuddyList[iBuddy].IsSubscribed())
            {
                g_Counters.IncrementValue32(XPPERF_SERVER_SUBSCRIPTIONS_TOTAL, 1);
            }
        }
    }

    if (m_cNeverList > 0)
    {
        QWORD *rgNevers = (QWORD *)((BYTE *)pMsg + cbRead);

        cbRead += m_cNeverList * sizeof(QWORD);

        if (dwSize < cbRead)
        {
            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            goto lDone;
        }
                
        m_rgqwNeverList = new QWORD[m_cNeverList];
        if (m_rgqwNeverList == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto lDone;
        }

        memcpy(m_rgqwNeverList, rgNevers, m_cNeverList * sizeof(QWORD));
    }

    if (pMsg->cWatchers > 0)
    {
        QWORD *rgWatchers = (QWORD *)((BYTE *)pMsg + cbRead);

        cbRead += pMsg->cWatchers * sizeof(QWORD);
        
        if (dwSize < cbRead)
        {
            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            goto lDone;
        }
                
        for (DWORD iWatcher = 0; iWatcher < pMsg->cWatchers; iWatcher++)
        {
            hr = AddWatcher(rgWatchers[iWatcher]);
        }
    }

    if (pMsg->fOnlineRecordExists)
    {
        P_ONLINE_PRESENCE_RECORD_MSG *pORMsg = (P_ONLINE_PRESENCE_RECORD_MSG *)((BYTE *)pMsg + cbRead);

        cbRead += sizeof(P_ONLINE_PRESENCE_RECORD_MSG);

        if (dwSize < cbRead)
        {
            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            goto lDone;
        }

        hr = CreateOnlineRecord(
            &(pORMsg->sgaddr),
            pORMsg->dwClientVersion,
            pORMsg->dwAuthDataFlags,
            pORMsg->dwTitleID,
            pORMsg->dwTitleVersion,
            pORMsg->dwTitleRegion,
            pORMsg->xnaddr,
            pORMsg->xkid,
            pORMsg->xnkey,
            pORMsg->ipaXbox,
            pORMsg->ipportXbox,
            pORMsg->szLocale,
            pORMsg->qwVersionFlags);
        if(FAILED(hr))
        {
            goto lDone;
        }

        // CreateOnlineRecord modifies m_fMarkedForDelete.  We override that by recopying dwFlags.
        m_dwFlags = pMsg->dwFlags;

        if (0 != memcmp(&(pORMsg->sgaddr.inaSg), &(sgaddrIgnore.inaSg), sizeof(IN_ADDR)))
        {
            g_CPresenceXBoxIndex.AddPresence(this);
            g_CPresenceSGIndex.AddPresence(this);
        }

        m_pOnlinePresence->m_dwAltTitleID1 = pORMsg->dwAltTitleID1;
        m_pOnlinePresence->m_dwAltTitleID2 = pORMsg->dwAltTitleID2;
        m_pOnlinePresence->m_dwAltTitleID3 = pORMsg->dwAltTitleID3;
        m_pOnlinePresence->m_dwAltTitleID4 = pORMsg->dwAltTitleID4;
        m_pOnlinePresence->m_dwAliveTime = ZeroProtectedTimeShift(pORMsg->dwAliveTime, dwTimeShift);
        m_pOnlinePresence->m_dwPlayStart = ZeroProtectedTimeShift(pORMsg->dwPlayStart, dwTimeShift);
        m_pOnlinePresence->m_dwTitleStart = ZeroProtectedTimeShift(pORMsg->dwTitleStart, dwTimeShift);
        m_pOnlinePresence->m_qwMatchSessionID = pORMsg->qwMatchSessionID;
        m_pOnlinePresence->m_cbTitleStuff = pORMsg->cbTitleStuff;
        m_pOnlinePresence->m_cbRichPresence = pORMsg->cbRichPresence;
        m_pOnlinePresence->m_cbPresenceData = pORMsg->cbPresenceData;
        m_pOnlinePresence->m_cbNickname = pORMsg->cbNickname;
        memcpy(m_pOnlinePresence->m_rgbNickname, pORMsg->rgbNickname, MAX_NICKNAME_BYTES);
        m_pOnlinePresence->m_wDequeues = pORMsg->wDequeues;
        m_pOnlinePresence->m_wStates = pORMsg->wStates;
        m_pOnlinePresence->m_dwBlockListVersion = pORMsg->dwBlockListVersion;
        m_pOnlinePresence->m_dwNextXMsgItemID = pORMsg->dwNextXMsgItemID;
        m_pOnlinePresence->m_dwSeqQVals = pORMsg->dwSeqQVals;
        m_pOnlinePresence->m_dwSeqXMsgAddQVal = pORMsg->dwSeqXMsgAddQVal;
        m_pOnlinePresence->m_dwSeqXMsgDeleteQVal = pORMsg->dwSeqXMsgDeleteQVal;
        memcpy(m_pOnlinePresence->m_rgdwQVals, pORMsg->rgdwQVals, QVAL_COUNT * sizeof(DWORD));
        m_pOnlinePresence->m_dwTotalQLength = pORMsg->dwTotalQLength;
        m_pOnlinePresence->m_dwNextItemID = pORMsg->dwNextItemID;

        if (pORMsg->cInvitees > 0)
        {
            QWORD *rgInvitees = (QWORD *)((BYTE *)pMsg + cbRead);
            
            cbRead += pORMsg->cInvitees * sizeof(QWORD);
            
            if (dwSize < cbRead)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
                goto lDone;
            }

            hr = CreateInvite(
                pORMsg->dwInviteTitleID,
                pORMsg->qwInviteSessionID,
                pORMsg->cInvitees,
                rgInvitees);

            memcpy(&(m_pOnlinePresence->m_pCInvitation->ftSent), &(pORMsg->ftInviteSent), sizeof(FILETIME));
        }

        if (pORMsg->cWatches > 0)
        {
            QWORD *rgWatches = (QWORD *)((BYTE *)pMsg + cbRead);

            cbRead += pORMsg->cWatches * sizeof(QWORD);
            
            if (dwSize < cbRead)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
                goto lDone;
            }
                    
            for (DWORD iWatch = 0; iWatch < pORMsg->cWatches; iWatch++)
            {
                hr = AddWatch(rgWatches[iWatch]);
            }
        }

        if (pORMsg->cbPresenceData > 0)
        {
            BYTE *pPresenceData = (BYTE *)pMsg + cbRead;

            cbRead += pORMsg->cbPresenceData;
            
            if (dwSize < cbRead)
            {
                hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
                goto lDone;
            }

            m_pOnlinePresence->m_pPresenceData = new BYTE[pORMsg->cbPresenceData];
            if (m_pOnlinePresence->m_pPresenceData == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto lDone;
            }
            
            memcpy(m_pOnlinePresence->m_pPresenceData, pPresenceData, pORMsg->cbPresenceData);
        }

        for (DWORD iQueueType = 0; iQueueType < PQUEUE_NUM_TYPES; iQueueType++)
        {
            DWORD cbReadQueue = dwSize - cbRead;
            hr = m_pOnlinePresence->m_rgCQueues[iQueueType].DeSerialize((P_QUEUE_ITEM_MSG *)((BYTE *)pMsg + cbRead), &cbReadQueue, dwTimeShift);

            cbRead += cbReadQueue;
        }
    }

    if (cbRead < dwSize)
    {
        hr = E_UNEXPECTED;
    }
    
lDone:

    if (FAILED(hr))
    {
        XomNtEvent(XEVENT_PRESENCE_CODE_210, "CPresence::DeSerialize() failed for user %I64X, hr = 0x%X", m_qwUserID, hr);
    }

    return hr;        
}

void CPresence::MarkForMigration(CInterfaceBucketChangeContext *pCCtx)
{
    m_fMarkedForMigration = TRUE;
    m_pCBucketChangeCtx = pCCtx;
    pCCtx->AddRef();
}

void CPresence::ReleaseMigrationContext()
{
    SAFE_RELEASE(m_pCBucketChangeCtx);
}

HRESULT CPresence::AddDeferredContext(CLocalContext * pCCtx)
{
    CContextQueueNode *pNode = new CContextQueueNode();
    if (pNode == NULL)
    {
        return E_OUTOFMEMORY;
    }

    pNode->m_pNext = m_pDeferredQueue;
    pNode->m_pCCtx = pCCtx;
    pCCtx->AddRef();
    m_pDeferredQueue = pNode;

    return S_OK;
}

void CPresence::ProcessDeferredQueue(CContextQueueNode * pNode)
{
    if (pNode == NULL)
    {
        return;
    }

    // recursive reverse order.
    ProcessDeferredQueue(pNode->m_pNext);

    // process the context like switchboard would.
    pNode->m_pCCtx->SetPostData(CLocalContext::PostSwitchboard);
    pNode->m_pCCtx->OnIoCompletion(NO_ERROR, 0, NULL, pNode->m_pCCtx);

    pNode->m_pCCtx->Release();

    delete pNode;
}
void CPresence::ProcessDeferredQueue()
{
    ProcessDeferredQueue(m_pDeferredQueue);
    m_pDeferredQueue = NULL;
}

/*****************************************************************************

CPresence::SelfDestruct

Removes the user presence all indexes and frees it back to the system.

*****************************************************************************/
void CPresence::SelfDestruct()
{
    // Remove ourself from our secondary indexes
    g_CPresenceXBoxIndex.RemovePresence(this);
    g_CPresenceSGIndex.RemovePresence(this);

    // remove from the tickle priqueue
    g_CTicklePriQueue.DropObject(this);

    // Remove ourself from our main index
    //g_CPresenceUserIndex.RemovePresence(this);

    // just delete the online record.
    delete m_pOnlinePresence;
    m_pOnlinePresence = NULL;

    // since we're keeping this around now, lets not try to delete it again.
    m_fMarkedForDelete = FALSE;
    m_fMarkedForDeadSG = FALSE;
}

/*****************************************************************************

CPresence::Alive

Updates core presence information, keeping external indexes updated.  Happens
when an Alive message arrives while a user's presence is still in memory.

*****************************************************************************/
HRESULT CPresence::Alive(
    const SGADDR *psgaddr,
    DWORD dwClientVersion,
    QWORD qwNonce,
    DWORD dwAuthDataFlags,
    DWORD dwTitleID,
    DWORD dwAltTitleID1,
    DWORD dwAltTitleID2,
    DWORD dwAltTitleID3,
    DWORD dwAltTitleID4,
    DWORD dwTitleVersion,
    DWORD dwTitleRegion,
    XNADDR xnaddr,
    XNKID xkid,
    XNKEY xnkey,
    IN_ADDR ipaXbox,
    WORD ipportXbox,
    DWORD cbAcctName,
    LPCSTR szAcctName,
    BYTE *szLocale,
    QWORD qwVersionFlags)
{
    CQueueItem* pCWork;
    BOOL fSetQVals = FALSE;

    if (m_pOnlinePresence == NULL)
    {
        HRESULT hr = CreateOnlineRecord(
            psgaddr,
            dwClientVersion,
            dwAuthDataFlags,
            dwTitleID,
            dwTitleVersion,
            dwTitleRegion,
            xnaddr,
            xkid,
            xnkey,
            ipaXbox,
            ipportXbox,
            szLocale,
            qwVersionFlags);
        if(FAILED(hr))
        {
            return hr;
        }

        // Add it to the indexes
        g_CPresenceXBoxIndex.AddPresence(this);
        g_CPresenceSGIndex.AddPresence(this);
    }

    RecordUserKilled();

    m_qwNonce = qwNonce;
    m_pOnlinePresence->m_dwClientVersion = dwClientVersion;
    m_pOnlinePresence->m_dwTitleID = dwTitleID;
    m_pOnlinePresence->m_dwAltTitleID1 = dwAltTitleID1;
    m_pOnlinePresence->m_dwAltTitleID2 = dwAltTitleID2;
    m_pOnlinePresence->m_dwAltTitleID3 = dwAltTitleID3;
    m_pOnlinePresence->m_dwAltTitleID4 = dwAltTitleID4;
    m_pOnlinePresence->m_dwTitleVersion = dwTitleVersion;
    m_pOnlinePresence->m_dwTitleRegion = dwTitleRegion;
    m_pOnlinePresence->m_xnaddr = xnaddr;
    m_pOnlinePresence->m_xkid = xkid;
    m_pOnlinePresence->m_xnkey = xnkey;
    m_pOnlinePresence->m_ipaXbox = ipaXbox;
    m_pOnlinePresence->m_ipportXbox = ipportXbox;
    memcpy(m_pOnlinePresence->m_szLocale, szLocale, XONLINE_PRESENCE_LOCALE_SIZE);
    m_pOnlinePresence->m_qwVersionFlags = qwVersionFlags;

    // Initialize all QVal sequence numbers to 1
    m_pOnlinePresence->m_dwSeqQVals = 1;
    m_pOnlinePresence->m_dwSeqXMsgAddQVal = 1;
    m_pOnlinePresence->m_dwSeqXMsgDeleteQVal = 1;

    SetAuthDataFlags(dwAuthDataFlags);

    // Init QVals
    ZeroMemory(m_pOnlinePresence->m_rgdwQVals, sizeof(DWORD) * QVAL_COUNT);
    m_pOnlinePresence->m_rgdwQVals[ QVAL_INDEX( QVAL_QFLAGS ) ] = QVAL_QFLAGS | (m_pOnlinePresence->m_dwSeqQVals << QVAL_SEQ_SHIFT);
    m_pOnlinePresence->m_rgdwQVals[ QVAL_INDEX( QVAL_NEW_GAME_INVITE ) ] = QVAL_NEW_GAME_INVITE | (m_pOnlinePresence->m_dwSeqQVals << QVAL_SEQ_SHIFT);
    m_pOnlinePresence->m_rgdwQVals[ QVAL_INDEX( QVAL_NEW_MSG_IDS ) ] = QVAL_NEW_MSG_IDS | (m_pOnlinePresence->m_dwSeqXMsgAddQVal << QVAL_SEQ_SHIFT);
    m_pOnlinePresence->m_rgdwQVals[ QVAL_INDEX( QVAL_NEW_MSG_DATA ) ] = QVAL_NEW_MSG_DATA | (m_pOnlinePresence->m_dwSeqXMsgAddQVal << QVAL_SEQ_SHIFT);
    m_pOnlinePresence->m_rgdwQVals[ QVAL_INDEX( QVAL_MSG_DELETED ) ] = QVAL_MSG_DELETED | (m_pOnlinePresence->m_dwSeqXMsgDeleteQVal << QVAL_SEQ_SHIFT);

    if (memcmp(&m_pOnlinePresence->m_sgaddr, psgaddr, sizeof(SGADDR)) != 0)
    {
        g_CPresenceXBoxIndex.RemovePresence(this);
        g_CPresenceSGIndex.RemovePresence(this);
        memcpy(&m_pOnlinePresence->m_sgaddr, psgaddr, sizeof(SGADDR));
        g_CPresenceXBoxIndex.AddPresence(this);
        g_CPresenceSGIndex.AddPresence(this);
    }

    m_fMarkedForDelete = FALSE;
    m_fMarkedForDeadSG = FALSE;

    m_cbAcctName = cbAcctName;
    strncpy(m_szAcctName, szAcctName, MAX_ACCTNAME_BYTES);
    m_szAcctName[MAX_ACCTNAME_BYTES - 1] = '\0';

    // Look through any existing messages and eliminate any that are from blocked senders
    if( 0 != m_cNeverList )
    {
        pCWork = m_pOnlinePresence->m_rgCQueues[ PQUEUE_TRANSIENT_MSGS ].GetFirstInQ();
        while( NULL != pCWork )
        {
            Q_MESSAGE_SUMMARY* pMsg = (Q_MESSAGE_SUMMARY*) pCWork->GetData();

            if( IsUserBlocked( pMsg->qwSenderID ) )
            {
                CQueueItem *pCVictim = pCWork;
                pCWork = pCWork->GetNextInQ();
                pCVictim->SelfDestruct();
            }
            else
            {
                pCWork = pCWork->GetNextInQ();
            }
        }
    }

    // If there are any V1 invites, we need to set the V1 QVals as if Presence just
    // repopulated them.
    pCWork = m_pOnlinePresence->m_rgCQueues[ PQUEUE_TRANSIENT_MSGS ].GetFirstInQ();
    while( NULL != pCWork )
    {
        // See if this is an item that would produce a V1 new invite QVal
        if( NULL != pCWork->GetV1Data() && !pCWork->IsDequeued() )
        {
            XomTrace(
                PresenceDebug,
                L_NORMAL,
                "SetOnline populating QVals for existing invite items User=%I64X Type=%d NewSeq=%X",
                m_qwUserID,
                PQUEUE_INVITE,
                m_pOnlinePresence->m_dwSeqQVals + 2);

            fSetQVals = TRUE;

            // This is the first change, so push it
            m_fPushQVals = TRUE;

            // Mark a QFlags change
            m_pOnlinePresence->m_dwSeqQVals++;

            m_pOnlinePresence->m_rgdwQVals[QVAL_INDEX(QVAL_QFLAGS)] =
                QVAL_QFLAGS |
                (m_pOnlinePresence->m_dwSeqQVals << QVAL_SEQ_SHIFT);

            m_pOnlinePresence->m_rgdwQVals[QVAL_INDEX(QVAL_QFLAGS) + 1] |= QFLAG_MASK(PQUEUE_INVITE);

            m_pOnlinePresence->m_dwSeqQVals++;

            m_pOnlinePresence->m_rgdwQVals[QVAL_INDEX(QVAL_NEW_GAME_INVITE)] =
                QVAL_NEW_GAME_INVITE |
                QVAL_BOOL_MASK |
                (m_pOnlinePresence->m_dwSeqQVals << QVAL_SEQ_SHIFT);

            break;
        }

        pCWork = pCWork->GetNextInQ();
    }

    if( fSetQVals )
    {
        SendQVals();
    }

    RecordUserAlive();

    return S_OK;
}

HRESULT CPresence::WebAlive()
{
    HRESULT hr = S_OK;

    // make sure the user has an online record, even if only a stub.
    if (!HasOnlineRecord())
    {
        SGADDR sgaddr = {0};
        XNADDR xnaddr = {0};
        XNKID xkid = {0};
        XNKEY xnkey = {0};
        IN_ADDR ipaXbox = {0};
        
        hr = CreateOnlineRecord(
            &sgaddr,
            0,
            0,
            0,
            0,
            0,
            xnaddr,
            xkid,
            xnkey,
            ipaXbox,
            0,
            (BYTE*)"",
            0);
    }

    // mark last seen time for the web.
    SetLastWebTime();

    return hr;    
}


/*****************************************************************************

CPresence::SetBuddyList

Updates the buddy alist.  The object array passed in is taken over by the
CPresence object.

*****************************************************************************/
HRESULT CPresence::SetBuddyList(
        DWORD cBuddies,
        DWORD dwBuddyListVersion,
        CBuddyListEntry *rgCBuddyList
        )
{
    if (m_rgCBuddyList != NULL)
    {
        DWORD iNewBuddy = 0;
        for (DWORD iOldBuddy = 0; iOldBuddy < m_cBuddies; iOldBuddy++)
        {
            while ((iNewBuddy < cBuddies) && (rgCBuddyList[iNewBuddy].GetBuddyID() < m_rgCBuddyList[iOldBuddy].GetBuddyID()))
            {
                iNewBuddy++;
            }
            if ((iNewBuddy < cBuddies) && (rgCBuddyList[iNewBuddy].GetBuddyID() == m_rgCBuddyList[iOldBuddy].GetBuddyID()))
            {
                // transfer the extra bits.
                memcpy(&(rgCBuddyList[iNewBuddy]), &(m_rgCBuddyList[iOldBuddy]), sizeof(CBuddyListEntry));
            }
        }
        
        delete [] m_rgCBuddyList;
    }
    m_cBuddies = (WORD)cBuddies;
    m_dwBuddyListVersion = dwBuddyListVersion;
    m_rgCBuddyList = rgCBuddyList;

    if (g_CPresCfg.GetStoreStateInVelocity())
    {
        CStoreFriendsListContext *pCCtx = new CStoreFriendsListContext(
            m_pSwitchboard,
            GetUserID(),
            m_dwBuddyListVersion,
            m_cBuddies,
            m_rgCBuddyList,
            CanShareFriendsList(FALSE),
            CanShareFriendsList(TRUE));

        m_pSwitchboard->GetProfileStore()->SendToSqlThread(pCCtx);
    }

    return S_OK;
}

/*****************************************************************************

CPresence::SetState

Updates state information

*****************************************************************************/
DWORD CPresence::SetState(
    DWORD dwState,
    DWORD dwTitleID,
    QWORD qwMatchSessionID,
    DWORD  cbTitleStuff,
    const BYTE *rgbTitleStuff,
    WORD cbRichPresence,
    const P_RICH_PRESENCE *pRichPresence,
    WORD cbMemcacheData,
    BYTE *pMemcacheData,
    DWORD dwStateChange)
{
    DWORD dwOldState = m_dwState;
    
    XOMASSERT(m_pOnlinePresence != NULL);
    if (m_pOnlinePresence == NULL)
    {
        XomNtEvent(XEVENT_PRESENCE_CODE_211, "NULL online presence record accessed for user %I64X", GetUserID());
        return dwOldState;
    }

    if (dwTitleID != m_pOnlinePresence->m_dwTitleID)
    {
        RecordTitleChange(dwTitleID, FALSE, FALSE);
        
        // We don't have any data on titleversion if it is switched without a relog
        m_pOnlinePresence->m_dwTitleVersion = 0;
    }

    if (((dwState & P_STATE_MASK_PLAYING) == P_STATE_MASK_PLAYING) && (dwTitleID != 0) && (qwMatchSessionID != 0))
    {
        RecordPlayStart(dwState, dwTitleID, qwMatchSessionID);
    }
    else
    {
        RecordPlayStop();
    }

    // alive will call SetState to mark the user online and cloaked.  we dont want this looking like a user-initiated cloak.
    if (m_dwState & P_STATE_MASK_ONLINE)
    {
        // If the user is not cloaked, update their state changed timestamp if their state changed
        if ((dwState & P_STATE_MASK_CLOAKED) == 0)
        {        
            if (((m_dwState & P_STATE_MASK_USER_STATE) != (dwState & P_STATE_MASK_USER_STATE)) ||   // new state
                (dwTitleID != m_dwLastSeenTitleID) ||   // new title
                (m_dwState & P_STATE_MASK_CLOAKED))     // uncloaking
            {
                // Client changed the user state.. reset the timer.
                SetUserStateChanged();
                SetLastSeenTitleID(dwTitleID);
            }
        }

        if ((dwState & P_STATE_MASK_CLOAKED) && !(m_dwState & P_STATE_MASK_CLOAKED))
        {
            // cloaking now.
            SetUserStateChanged();
            SetLastSeenTitleID(dwTitleID);
        }
    }

    if ( (dwState & P_STATE_MASK_GUESTS) != (m_dwState & P_STATE_MASK_GUESTS) )
    {
        RecordGuestChange(dwTitleID, m_dwState, dwState);
    }
    
    m_pOnlinePresence->m_wStates++;    
    m_dwState = dwState;
    m_pOnlinePresence->m_dwTitleID = dwTitleID;
    m_pOnlinePresence->m_qwMatchSessionID = qwMatchSessionID;

    // For now, we assume the region cannot change after logon. This is required
    //  for system message enumeration. 
    // m_pOnlinePresence->m_dwTitleRegion = 0;

    if ((cbTitleStuff > 0) && !(m_dwState & P_STATE_MASK_CLOAKED))
    {
        if (cbTitleStuff > m_pOnlinePresence->m_cbPresenceData)
        {
            // We should only ever allocate one 32byte buffer
            //  for v1 state data, however there may be scenarios
            //  where a v1 client boots a xenon client while a
            //  larger buffer is already allocated.
            if (NULL != m_pOnlinePresence->m_pPresenceData)
            {
                delete[] m_pOnlinePresence->m_pPresenceData;
                m_pOnlinePresence->m_pPresenceData = NULL;
            }

            // Only allocate in blocks of 32 bytes to defend against
            //  needing to reallocate too often, and to ensure that
            //  memory doesn't fragment too badly.
            m_pOnlinePresence->m_cbPresenceData = (cbTitleStuff + 31) / 32 * 32;

            m_pOnlinePresence->m_pPresenceData = new BYTE[m_pOnlinePresence->m_cbPresenceData];
        }

        memcpy(m_pOnlinePresence->m_pPresenceData, rgbTitleStuff, cbTitleStuff);

        m_pOnlinePresence->m_cbTitleStuff = cbTitleStuff;

    }
    else
    {
        m_pOnlinePresence->m_cbTitleStuff = 0;
    }

    if ((cbRichPresence > 0) && !(m_dwState & P_STATE_MASK_CLOAKED))
    {
        if (cbRichPresence > m_pOnlinePresence->m_cbPresenceData)
        {
            // There is no need to realloc here, since the old data
            //  is obsolete anyway. We just free and allocate fresh
            //  for simplicity
            if (NULL != m_pOnlinePresence->m_pPresenceData)
            {
                delete[] m_pOnlinePresence->m_pPresenceData;
                m_pOnlinePresence->m_pPresenceData = NULL;
            }

            // Only allocate in blocks of 32 bytes to defend against
            //  needing to reallocate too often, and to ensure that
            //  memory doesn't fragment too badly.
            m_pOnlinePresence->m_cbPresenceData = (cbRichPresence + 31) / 32 * 32;

            m_pOnlinePresence->m_pPresenceData = new BYTE[m_pOnlinePresence->m_cbPresenceData];
        }

        memcpy(m_pOnlinePresence->m_pPresenceData, pRichPresence, cbRichPresence);

        m_pOnlinePresence->m_cbRichPresence = cbRichPresence;
    }
    else
    {
        m_pOnlinePresence->m_cbRichPresence = 0;    
    }

    if (g_CPresCfg.GetStoreStateInVelocity())
    {
        DWORD dwStoreState = GetState();
        if ((!IsOnline()) || (dwStoreState & P_STATE_MASK_CLOAKED) )
        {
            dwStoreState = 0;

            if (!(dwStateChange & P_STATE_MASK_CLOAKED))
            {
                // we're cloaked, and that hasnt changed.  mark no change.
                dwStateChange = 0;
            }
        }

        if (dwStateChange)
        {
            CStoreStateContext *pCCtx = new CStoreStateContext(
                m_pSwitchboard,
                GetUserID(),
                (CHAR *)GetAcctName(),
                GetLastSeenTitleID(),
                GetUserStateChanged(),
                GetMatchSessionID(),
                dwStoreState,
                CanSharePresence(FALSE),
                CanSharePresence(TRUE),
                cbMemcacheData,
                pMemcacheData,
                dwStateChange);

            m_pSwitchboard->GetProfileStore()->SendToSqlThread(pCCtx);
        }
    }
    
    // TODO: Perf counters for count and average presence data size.

    return dwOldState;
}

/*****************************************************************************

CPresence::SetNickname

Updates nickname information

*****************************************************************************/
void CPresence::SetNickname(
    DWORD cbNickname,
    const BYTE *pbNickname)
{
    XOMASSERT(m_pOnlinePresence != NULL);
    if (m_pOnlinePresence == NULL)
    {
        XomNtEvent(XEVENT_PRESENCE_CODE_212, "NULL online presence record accessed for user %I64X", GetUserID());
        return;
    }

    if (cbNickname <= sizeof(m_pOnlinePresence->m_rgbNickname))
    {
        m_pOnlinePresence->m_cbNickname = cbNickname;
        memcpy(m_pOnlinePresence->m_rgbNickname, pbNickname, cbNickname);
    }
}

/*****************************************************************************

CPresence::SetOffline

Wipes out a user's online presence in response to a DeadXbox or DeadSG message

*****************************************************************************/
void CPresence::SetOffline()
{
    XOMASSERT(m_pOnlinePresence != NULL);
    if (m_pOnlinePresence == NULL)
    {
        XomNtEvent(XEVENT_PRESENCE_CODE_213, "NULL online presence record accessed for user %I64X", GetUserID());
        return;
    }

    RecordPlayStop();
    RecordUserKilled();

    // Clear out their state
    m_dwState = P_STATE_MASK_NONE;
    m_pOnlinePresence->m_qwMatchSessionID = 0;
    m_pOnlinePresence->m_cbTitleStuff = 0;
    m_pOnlinePresence->m_cbNickname = 0;

    // Clean up lingering RP data, if any (BUG #13622)
    m_pOnlinePresence->m_cbPresenceData = 0;
    m_pOnlinePresence->m_cbTitleStuff = 0;
    m_pOnlinePresence->m_cbRichPresence = 0;
    if (NULL != m_pOnlinePresence->m_pPresenceData)
    {
        delete[] m_pOnlinePresence->m_pPresenceData;
        m_pOnlinePresence->m_pPresenceData = NULL;
    }

    // Clear any queues that need clearing
    ClearAllQs();

    // Remove ourself from the tickle priority queue
    (void) g_CTicklePriQueue.DropObject(this); // Ignore failure
    m_pOnlinePresence->m_dwTickleCount = 0;

    // Remove from secondary indexes
    g_CPresenceXBoxIndex.RemovePresence(this);
    g_CPresenceSGIndex.RemovePresence(this);

    // Clear out part of the SGAddr so future requests don't match
    memset(&(m_pOnlinePresence->m_sgaddr.inaSg), 0, sizeof(IN_ADDR));

    if (g_CPresCfg.GetStoreStateInVelocity())
    {
        CStoreStateContext *pCCtx = new CStoreStateContext(
            m_pSwitchboard,
            GetUserID(),
            (CHAR *)GetAcctName(),
            GetLastSeenTitleID(),
            GetUserStateChanged(),
            GetMatchSessionID(),
            GetState(),
            CanSharePresence(FALSE),
            CanSharePresence(TRUE),
            0,
            NULL,
            0xFFFFFFFF);

        m_pSwitchboard->GetProfileStore()->SendToSqlThread(pCCtx);
    }
}

/*****************************************************************************

CPresence::AddBuddy

Add a buddy to the internal list

*****************************************************************************/
HRESULT CPresence::AddBuddy(QWORD qwBuddyID, DWORD dwStatus, DWORD dwVersion)
{
    DWORD dwInsertIndex = 0;

    // Look for the insertion position
    while ((dwInsertIndex < m_cBuddies) && (m_rgCBuddyList[dwInsertIndex].GetBuddyID() < GET_PUID_BITS(qwBuddyID)))
    {
        dwInsertIndex++;
    }

    if ((dwInsertIndex == m_cBuddies) ||
        (m_rgCBuddyList[dwInsertIndex].GetBuddyID() != GET_PUID_BITS(qwBuddyID)))
    {
        if (m_cBuddies >= MAX_BUDDIES)
        {
            // not refreshing an existing buddy, and we have the max num of buddies.
            XomNtEvent(XEVENT_PRESENCE_CODE_214, "CPresence::AddBuddy() called for user=%I64X adding buddy=%I64X when user already has the maximum number of friends.",
                m_qwUserID,
                qwBuddyID);
                
            return E_FAIL;
        }
        
        // Resize the current allocation
        CBuddyListEntry *pCNew = new CBuddyListEntry[m_cBuddies + 1];
        if (pCNew == NULL)
        {
            return E_OUTOFMEMORY;
        }
        memcpy(pCNew, m_rgCBuddyList, dwInsertIndex * sizeof(CBuddyListEntry));
        memcpy(pCNew + dwInsertIndex + 1, m_rgCBuddyList + dwInsertIndex, (m_cBuddies - dwInsertIndex) * sizeof(CBuddyListEntry));
        delete[] m_rgCBuddyList;
        m_rgCBuddyList = pCNew;
        m_cBuddies++;
    }
    // else update in place
    
    // Set the item payload
    m_rgCBuddyList[dwInsertIndex].Initialize();
    m_rgCBuddyList[dwInsertIndex].SetBuddyID(qwBuddyID);
    m_rgCBuddyList[dwInsertIndex].SetStatus(dwStatus);
    m_rgCBuddyList[dwInsertIndex].SetSubscribed(FALSE);
    m_rgCBuddyList[dwInsertIndex].SetClientType(GET_PUID_CLIENT_TYPE(qwBuddyID));
    m_rgCBuddyList[dwInsertIndex].SetClientBeta(IS_PUID_CLIENT_BETA(qwBuddyID));

    // Update the list version
    if (dwVersion == (m_dwBuddyListVersion + 1))
    {
        m_dwBuddyListVersion = dwVersion;
    }
    else
    {
        // Might have missed something, force a trip to the database on the next alive
        m_dwBuddyListVersion = 0xFFFFFFFF;
    }

    if (g_CPresCfg.GetStoreStateInVelocity())
    {
        CStoreFriendsListContext *pCCtx = new CStoreFriendsListContext(
            m_pSwitchboard,
            GetUserID(),
            m_dwBuddyListVersion,
            m_cBuddies,
            m_rgCBuddyList,
            CanShareFriendsList(FALSE),
            CanShareFriendsList(TRUE));

        m_pSwitchboard->GetProfileStore()->SendToSqlThread(pCCtx);
    }

    return S_OK;
}

/*****************************************************************************

CPresence::RemoveBuddy

Remove a buddy from the internal list

*****************************************************************************/
HRESULT CPresence::RemoveBuddy(QWORD qwBuddyID, DWORD dwVersion)
{
    CBuddyListEntry *pCBuddy = NULL;
    DWORD dwBuddyIndex = 0;

    if ((m_rgCBuddyList == NULL) || (m_cBuddies == 0))
    {
        return HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
    }

    // Assume the buddy list is sorted and use a binary search to find the buddy
    pCBuddy = (CBuddyListEntry *) bsearch(
        &qwBuddyID,
        m_rgCBuddyList,
        m_cBuddies,
        sizeof(CBuddyListEntry),
        CompareBuddies);

    if (pCBuddy == NULL)
    {
        return HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
    }

    // Calculate the buddy index
    dwBuddyIndex = (((BYTE *)pCBuddy) - ((BYTE*)m_rgCBuddyList)) / sizeof(CBuddyListEntry);

    // Move everyone below the entry up and decriment the count
    memmove(
        m_rgCBuddyList + dwBuddyIndex,
        m_rgCBuddyList + dwBuddyIndex + 1,
        (m_cBuddies - dwBuddyIndex - 1) * sizeof(CBuddyListEntry));

    m_cBuddies--;

    // Update the list version
    if (dwVersion == (m_dwBuddyListVersion + 1))
    {
        m_dwBuddyListVersion = dwVersion;
    }
    else
    {
        // Might have missed something, force a trip to the database on the next alive
        m_dwBuddyListVersion = 0xFFFFFFFF;
    }

    if (g_CPresCfg.GetStoreStateInVelocity())
    {
        CStoreFriendsListContext *pCCtx = new CStoreFriendsListContext(
            m_pSwitchboard,
            GetUserID(),
            m_dwBuddyListVersion,
            m_cBuddies,
            m_rgCBuddyList,
            CanShareFriendsList(FALSE),
            CanShareFriendsList(TRUE));

        m_pSwitchboard->GetProfileStore()->SendToSqlThread(pCCtx);
    }

    return S_OK;
}


/*****************************************************************************

CPresence::IsUserAffiliate

Determines if a user is an affiliate of this user

*****************************************************************************/
HRESULT CPresence::IsUserAffiliate(QWORD qwUserID, DWORD * pdwFlags)
{
    XOMASSERT(m_pOnlinePresence != NULL);
    if (m_pOnlinePresence == NULL)
    {
        XomNtEvent(XEVENT_PRESENCE_CODE_215, "NULL online presence record accessed for user %I64X", GetUserID());
        return HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
    }

    DWORD rgIndices[NUM_STORED_AFFILIATE_LISTS];

    HRESULT hr = IsUserAffiliate(qwUserID, pdwFlags, rgIndices);
    if (FAILED(hr))
    {
        goto lDone;
    }

    if (NULL != FindBuddy(qwUserID))
    {
        *pdwFlags |= X_AFFILIATE_INDEX_TO_FLAG(X_AFFILIATE_FRIEND_INDEX);
    }

    if (IsUserBlocked(qwUserID))
    {
        *pdwFlags |= X_AFFILIATE_INDEX_TO_FLAG(X_AFFILIATE_BLOCK_INDEX);
    }

lDone:

    return hr;
}
/*****************************************************************************

CPresence::IsUserAffiliate

Determines if a user is an affiliate of this user

*****************************************************************************/
HRESULT CPresence::IsUserAffiliate(QWORD qwUserID, DWORD *pdwFlags, DWORD *rgIndices)
{
    XOMASSERT(m_pOnlinePresence != NULL);
    if (m_pOnlinePresence == NULL)
    {
        XomNtEvent(XEVENT_PRESENCE_CODE_216, "NULL online presence record accessed for user %I64X", GetUserID());
        return HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
    }

    XOMASSERT(m_pOnlinePresence->m_prgAffiliateLists);

    if ((pdwFlags == NULL) || (rgIndices == NULL))
    {
        return E_INVALIDARG;
    }

    *pdwFlags = 0;

    // TODO: having the lists sorted by userID here might help.  TBD if that makes sense elsewhere.

    for (DWORD dwListIndex = 0; dwListIndex < NUM_STORED_AFFILIATE_LISTS; dwListIndex++)
    {
        rgIndices[dwListIndex] = 0xFFFFFFFF;

        for (DWORD iAffiliate = 0; iAffiliate < m_pOnlinePresence->m_prgAffiliateLists[dwListIndex]->dwSize; iAffiliate++)
        {
            if (m_pOnlinePresence->m_prgAffiliateLists[dwListIndex]->rgAffiliates[iAffiliate].qwAffiliateID == qwUserID)
            {
                *pdwFlags |= X_AFFILIATE_INDEX_TO_FLAG(dwListIndex);
                rgIndices[dwListIndex] = iAffiliate;
                break;
            }
        }
    }

    return (*pdwFlags != 0) ? S_OK : S_FALSE;
}

/*****************************************************************************

CPresence::SetAffiliates

Initialize the internal list

*****************************************************************************/
HRESULT CPresence::SetAffiliates(CAffiliatesList **pAffiliatesLists)
{
    HRESULT hr = S_OK;
    
    XOMASSERT(m_pOnlinePresence != NULL);
    if (m_pOnlinePresence == NULL)
    {
        XomNtEvent(XEVENT_PRESENCE_CODE_217, "NULL online presence record accessed for user %I64X", GetUserID());
        hr = HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
        goto lDone;
    }

    XOMASSERT(m_pOnlinePresence->m_prgAffiliateLists == NULL);

    // resise lists to fit the actual data
    for (DWORD dwList = 0; dwList < NUM_STORED_AFFILIATE_LISTS; dwList++)
    {
        if (pAffiliatesLists[dwList]->dwSize < pAffiliatesLists[dwList]->dwAlloc)
        {
            CAffiliatesListEntry *pNew = NULL;
            
            if (pAffiliatesLists[dwList]->dwSize != 0)
            {
                pNew = new CAffiliatesListEntry[pAffiliatesLists[dwList]->dwSize];
                if (pNew == NULL)
                {
                    hr = E_OUTOFMEMORY;
                    goto lDone;
                }
                memcpy(pNew, pAffiliatesLists[dwList]->rgAffiliates, pAffiliatesLists[dwList]->dwSize * sizeof(CAffiliatesListEntry));
            }

            delete[] pAffiliatesLists[dwList]->rgAffiliates;
            pAffiliatesLists[dwList]->rgAffiliates = pNew;
            pAffiliatesLists[dwList]->dwAlloc = pAffiliatesLists[dwList]->dwSize;
        }
    }

    m_pOnlinePresence->m_prgAffiliateLists = pAffiliatesLists;

    // note the time lists were loaded.
    FILETIME ft;
    SYSTEMTIME st;
    GetSystemTime(&st);
    SystemTimeToFileTime(&st, &ft);
    m_pOnlinePresence->m_mtAffiliatesLoaded = FileTimeToMsgTime(&ft);
    
lDone:
    
    return hr;;
}

/*****************************************************************************

CPresence::GetAffiliates

returns access to the internal list

*****************************************************************************/
HRESULT CPresence::GetAffiliates(DWORD dwListFlag, CAffiliatesList *pAffiliates)
{
    XOMASSERT(m_pOnlinePresence != NULL);
    if (m_pOnlinePresence == NULL)
    {
        XomNtEvent(XEVENT_PRESENCE_CODE_218, "NULL online presence record accessed for user %I64X", GetUserID());
        return HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
    }

    XOMASSERT(m_pOnlinePresence->m_prgAffiliateLists);

    HRESULT hr = S_OK;

    if (pAffiliates == NULL)
    {
        hr = E_INVALIDARG;
        goto lDone;
    }

    CAffiliatesList *pList = m_pOnlinePresence->m_prgAffiliateLists[X_AFFILIATE_FLAG_TO_INDEX(dwListFlag)];
    if (pList == NULL)
    {
        hr = E_UNEXPECTED;
        goto lDone;
    }

    pAffiliates->rgAffiliates = new CAffiliatesListEntry[pList->dwSize];
    if (pAffiliates->rgAffiliates == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pAffiliates->dwSize = pList->dwSize;
    pAffiliates->dwAlloc = pList->dwSize;
    memcpy(pAffiliates->rgAffiliates, pList->rgAffiliates, pAffiliates->dwSize * sizeof(CAffiliatesListEntry));

lDone:

    if (FAILED(hr))
    {
        if (pAffiliates != NULL)
        {
            delete[] pAffiliates->rgAffiliates;
            pAffiliates->rgAffiliates = NULL;
            pAffiliates->dwAlloc = 0;
            pAffiliates->dwSize = 0;
        }
    }

    return hr;
}


/*****************************************************************************

CPresence::AddAffiliates

Add affiliates to the internal list

*****************************************************************************/
HRESULT CPresence::AddAffiliates(DWORD dwListFlag, DWORD dwTitleID, MSGTIME mtDateUpdated, WORD cAffiliates, QWORD *pqwAffiliates)
{
    XOMASSERT(m_pOnlinePresence != NULL);
    if (m_pOnlinePresence == NULL)
    {
        XomNtEvent(XEVENT_PRESENCE_CODE_219, "NULL online presence record accessed for user %I64X", GetUserID());
        return HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
    }

    XOMASSERT(m_pOnlinePresence->m_prgAffiliateLists);

    CAffiliatesList *pList = m_pOnlinePresence->m_prgAffiliateLists[X_AFFILIATE_FLAG_TO_INDEX(dwListFlag)];
    if (pList == NULL)
    {
        return E_UNEXPECTED;
    }

    DWORD dwListIndex = X_AFFILIATE_FLAG_TO_INDEX(dwListFlag);

    CAffiliatesListEntry *pNew = NULL;

    // special filters per affiliate
    for (DWORD iNew = 0; iNew < cAffiliates; iNew++)
    {
        DWORD rgIndices[NUM_STORED_AFFILIATE_LISTS];
        DWORD dwExistFlags = 0;
        IsUserAffiliate(pqwAffiliates[iNew], &dwExistFlags, rgIndices);

        DWORD iExisting = rgIndices[dwListIndex];

        // already exists in this list?
        if (dwExistFlags & dwListFlag)
        {
            // update the entry
            pList->rgAffiliates[iExisting].dwTitleID = dwTitleID;
            pList->rgAffiliates[iExisting].mtDateUpdated = mtDateUpdated;

            // dont add this one again
            QWORD qwTemp = pqwAffiliates[iNew];
            pqwAffiliates[iNew] = pqwAffiliates[cAffiliates - 1];
            pqwAffiliates[cAffiliates - 1] = qwTemp;
            cAffiliates--;  // reduce the size of the set
            iNew--;  // decrement the loop counter
        }
        else if ((dwExistFlags & X_AFFILIATE_INDEX_TO_FLAG(X_AFFILIATE_NEGATIVE_FEEDBACK_INDEX)) &&
            (dwListFlag == X_AFFILIATE_INDEX_TO_FLAG(X_AFFILIATE_POSITIVE_FEEDBACK_INDEX)))
        {
            // we like this guy now.  remove him from the negative list by copying the last entry overtop of him.
            m_pOnlinePresence->m_prgAffiliateLists[X_AFFILIATE_NEGATIVE_FEEDBACK_INDEX]->dwSize--;
            memcpy(&(m_pOnlinePresence->m_prgAffiliateLists[X_AFFILIATE_NEGATIVE_FEEDBACK_INDEX]->rgAffiliates[rgIndices[X_AFFILIATE_NEGATIVE_FEEDBACK_INDEX]]),
                &(m_pOnlinePresence->m_prgAffiliateLists[X_AFFILIATE_NEGATIVE_FEEDBACK_INDEX]->rgAffiliates[m_pOnlinePresence->m_prgAffiliateLists[X_AFFILIATE_NEGATIVE_FEEDBACK_INDEX]->dwSize]),
                sizeof(CAffiliatesListEntry));
        }
        else if ((dwExistFlags & X_AFFILIATE_INDEX_TO_FLAG(X_AFFILIATE_POSITIVE_FEEDBACK_INDEX)) &&
            (dwListFlag == X_AFFILIATE_INDEX_TO_FLAG(X_AFFILIATE_NEGATIVE_FEEDBACK_INDEX)))
        {
            // we like this guy now.  remove him from the negative list by copying the last entry overtop of him.
            m_pOnlinePresence->m_prgAffiliateLists[X_AFFILIATE_POSITIVE_FEEDBACK_INDEX]->dwSize--;
            memcpy(&(m_pOnlinePresence->m_prgAffiliateLists[X_AFFILIATE_POSITIVE_FEEDBACK_INDEX]->rgAffiliates[rgIndices[X_AFFILIATE_POSITIVE_FEEDBACK_INDEX]]),
                &(m_pOnlinePresence->m_prgAffiliateLists[X_AFFILIATE_POSITIVE_FEEDBACK_INDEX]->rgAffiliates[m_pOnlinePresence->m_prgAffiliateLists[X_AFFILIATE_POSITIVE_FEEDBACK_INDEX]->dwSize]),
                sizeof(CAffiliatesListEntry));
        }
    }

    // now the add list has only the new affiliates
    if (cAffiliates > 0)
    {
        DWORD cMaxAffiliates = g_rgdwMaxAffiliates[dwListIndex];

        // is there room to hold everything?
        if (cAffiliates + pList->dwSize <= pList->dwAlloc)
        {
            // do nothing
        }
        else if (cAffiliates + pList->dwSize <= cMaxAffiliates)
        {
            pNew = new CAffiliatesListEntry[cAffiliates + pList->dwSize];
            if (pNew == NULL)
            {
                return E_OUTOFMEMORY;
            }
            memcpy(pNew, pList->rgAffiliates, pList->dwSize * sizeof(CAffiliatesListEntry));
            delete[] pList->rgAffiliates;
            pList->rgAffiliates = pNew;
            pList->dwAlloc = pList->dwSize + cAffiliates;
        }
        else
        {
            // is there any space left?
            if (pList->dwAlloc < cMaxAffiliates)
            {
                // allocate the max space
                pNew = new CAffiliatesListEntry[cMaxAffiliates];
                if (pNew == NULL)
                {
                    return E_OUTOFMEMORY;
                }
                memcpy(pNew, pList->rgAffiliates, pList->dwSize * sizeof(CAffiliatesListEntry));
                delete[] pList->rgAffiliates;
                pList->rgAffiliates = pNew;
                pList->dwAlloc = cMaxAffiliates;
            }

            // TODO:  here we'd like the lists sorted by date.
            // expire affiliates to make room
            while (cAffiliates > (cMaxAffiliates - pList->dwSize))
            {
                DWORD iOldest = 0;
                for (DWORD iExpire = 1; iExpire < pList->dwSize; iExpire++)
                {
                    if (pList->rgAffiliates[iExpire].mtDateUpdated < pList->rgAffiliates[iOldest].mtDateUpdated)
                    {
                        iOldest = iExpire;
                    }
                }

                pList->dwSize--;
                memcpy(&(pList->rgAffiliates[iOldest]), &(pList->rgAffiliates[pList->dwSize]), sizeof(CAffiliatesListEntry));
            }
        }

        for (DWORD iNew = 0; iNew < cAffiliates; iNew++)
        {
            pList->rgAffiliates[pList->dwSize + iNew].dwTitleID = dwTitleID;
            pList->rgAffiliates[pList->dwSize + iNew].qwAffiliateID = pqwAffiliates[iNew];
            pList->rgAffiliates[pList->dwSize + iNew].mtDateUpdated = mtDateUpdated;
        }

        pList->dwSize += cAffiliates;
    }

    return S_OK;
}

void CPresence::StoreAffiliates()
{
    if (HasOnlineRecord() && IsAffiliatesListLoaded())
    {    
        // make a context to write the affiliates back to sql.
        CStoreAffiliatesContext *pCCtx = new CStoreAffiliatesContext(GetSwitchboard(), GetSwitchboard()->GetProfileStore());
        if (pCCtx != NULL)
        {
            pCCtx->m_qwUserID = GetUserID();
            
            // transfer ownership of the affiliates list to the context.
            pCCtx->m_mtAffiliatesLoaded = m_pOnlinePresence->m_mtAffiliatesLoaded;
            pCCtx->m_prgAffiliateLists = m_pOnlinePresence->m_prgAffiliateLists;
            m_pOnlinePresence->m_prgAffiliateLists = NULL;

            // give the context a reference to this user.
            pCCtx->m_pCPresence = this;
            AddRef();

            pCCtx->m_pCProfileStore->SendToSqlThread(pCCtx);
        }
        else
        {
            // couldnt allocate a context?  just delete the affiliates.
            
            for (DWORD dwIndex = 0; dwIndex < NUM_STORED_AFFILIATE_LISTS; dwIndex++)
            {
                delete m_pOnlinePresence->m_prgAffiliateLists[dwIndex];
            }

            delete[] m_pOnlinePresence->m_prgAffiliateLists;
            m_pOnlinePresence->m_prgAffiliateLists = NULL;            
        }
    }
}

/*****************************************************************************

CPresence::SubscribeBuddy

Sets the given buddy as subscribed

*****************************************************************************/
HRESULT CPresence::SubscribeBuddy(QWORD qwBuddyID)
{
    CBuddyListEntry *pCBuddy = NULL;

    if ((m_rgCBuddyList == NULL) || (m_cBuddies == 0))
    {
        return HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
    }

    // Assume the buddy list is sorted and use a binary search to find the buddy
    pCBuddy = (CBuddyListEntry *) bsearch(
        &qwBuddyID,
        m_rgCBuddyList,
        m_cBuddies,
        sizeof(CBuddyListEntry),
        CompareBuddies);

    if (pCBuddy == NULL)
    {
        return HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
    }

    if (!pCBuddy->IsSubscribed())
    {
        g_Counters.IncrementValue32(XPPERF_SERVER_SUBSCRIPTIONS_TOTAL, 1);
    }

    pCBuddy->SetSubscribed(TRUE);
    pCBuddy->SetClientType(GET_PUID_CLIENT_TYPE(qwBuddyID));
    pCBuddy->SetClientBeta(IS_PUID_CLIENT_BETA(qwBuddyID));

    return S_OK;
}

/*****************************************************************************

CPresence::UnsubscribeBuddy

Sets the given buddy as unsubscribed

*****************************************************************************/
HRESULT CPresence::UnsubscribeBuddy(QWORD qwBuddyID)
{
    CBuddyListEntry *pCBuddy = NULL;

    if ((m_rgCBuddyList == NULL) || (m_cBuddies == 0))
    {
        return HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
    }

    // Assume the buddy list is sorted and use a binary search to find the buddy
    pCBuddy = (CBuddyListEntry *) bsearch(
        &qwBuddyID,
        m_rgCBuddyList,
        m_cBuddies,
        sizeof(CBuddyListEntry),
        CompareBuddies);

    if (pCBuddy == NULL)
    {
        return HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
    }

    if (pCBuddy->IsSubscribed())
    {
        g_Counters.DecrementValue32(XPPERF_SERVER_SUBSCRIPTIONS_TOTAL, 1);
    }

    pCBuddy->SetSubscribed(FALSE);
    pCBuddy->SetClientType(0);
    pCBuddy->SetClientBeta(0);

    return S_OK;
}


/*****************************************************************************

CPresence::IsAcceptedBuddy

Returns TRUE if the given BuddyID is an accepted buddy.

*****************************************************************************/
BOOL CPresence::IsAcceptedBuddy(QWORD qwBuddyID)
{
    CBuddyListEntry *pCBuddy = NULL;

    // we treat ourself as a friend.
    if (GET_PUID_BITS(qwBuddyID) == GetUserID())
    {
        return TRUE;
    }

    if ((m_rgCBuddyList == NULL) || (m_cBuddies == 0))
    {
        return FALSE;
    }

    // Assume the buddy list is sorted and use a binary search to find the buddy
    pCBuddy = (CBuddyListEntry *) bsearch(
        &qwBuddyID,
        m_rgCBuddyList,
        m_cBuddies,
        sizeof(CBuddyListEntry),
        CompareBuddies);

    if (pCBuddy == NULL)
    {
        return FALSE;
    }

    return (pCBuddy->GetStatus() == P_BUDDY_STATUS_OK);
}


/*****************************************************************************

CPresence::FindBuddy

Find a particular buddy

*****************************************************************************/
CBuddyListEntry *CPresence::FindBuddy(QWORD qwBuddyID)
{
    CBuddyListEntry *pCBuddy = NULL;

    if ((m_rgCBuddyList == NULL) || (m_cBuddies == 0))
    {
        return NULL;
    }

    // Assume the buddy list is sorted and use a binary search to find the buddy
    pCBuddy = (CBuddyListEntry *) bsearch(
        &qwBuddyID,
        m_rgCBuddyList,
        m_cBuddies,
        sizeof(CBuddyListEntry),
        CompareBuddies);

    return pCBuddy;
}


/*****************************************************************************

CPresence::CreateInvite

Create a new invitation

*****************************************************************************/
HRESULT CPresence::CreateInvite(
    DWORD dwTitleID,
    QWORD qwMatchSessionID,
    DWORD cInvitees,
    const QWORD *rgqwInvitees)
{
    XOMASSERT(m_pOnlinePresence != NULL);
    if (m_pOnlinePresence == NULL)
    {
        XomNtEvent(XEVENT_PRESENCE_CODE_220, "NULL online presence record accessed for user %I64X", GetUserID());
        return HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
    }

    if (cInvitees > XONLINE_MAX_MESSAGE_RECIPIENTS)
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_210,
            "CPresence::CreateInvite() called with too many invitees (%d) user=%I64X.",
            cInvitees,
            m_qwUserID);

        return E_FAIL;
    }
    
    CInvitation *pCInvitation;

    // Delete any outstanding invite
    DeleteInvite();

    // Allocate memory for it
    // TRICK: Allocate the invitee array with the main structure
    pCInvitation = new (new BYTE[sizeof(CInvitation) + (cInvitees * sizeof(QWORD))]) CInvitation;
    if (pCInvitation == NULL)
    {
        return E_OUTOFMEMORY;
    }

    pCInvitation->dwTitleID = dwTitleID;
    pCInvitation->qwMatchSessionID = qwMatchSessionID;
    GetSystemTimeAsFileTime(&(pCInvitation->ftSent));
    pCInvitation->cInvitees = cInvitees;
    memcpy(pCInvitation->rgqwInvitees, rgqwInvitees, cInvitees * sizeof(QWORD));

    // Sort the list for easy searching
    qsort((void *)pCInvitation->rgqwInvitees, cInvitees, sizeof(QWORD), CompareQWORD);

    m_pOnlinePresence->m_pCInvitation = pCInvitation;

    return S_OK;
}


/*****************************************************************************

CPresence::DeleteInvite

Delete the pending invitation

*****************************************************************************/
void CPresence::DeleteInvite()
{
    XOMASSERT(m_pOnlinePresence != NULL);
    if (m_pOnlinePresence == NULL)
    {
        XomNtEvent(XEVENT_PRESENCE_CODE_221, "NULL online presence record accessed for user %I64X", GetUserID());
        return;
    }

    if (m_pOnlinePresence->m_pCInvitation != NULL)
    {
        delete m_pOnlinePresence->m_pCInvitation;
        m_pOnlinePresence->m_pCInvitation = NULL;
    }
}

/*****************************************************************************

CPresence::AddInvitee

Add an Invitee to an invitation.

*****************************************************************************/
HRESULT CPresence::AddInvitee(QWORD qwInviteeID)
{
    XOMASSERT(m_pOnlinePresence != NULL);
    if (m_pOnlinePresence == NULL)
    {
        XomNtEvent(XEVENT_PRESENCE_CODE_222, "NULL online presence record accessed for user %I64X", GetUserID());
        return HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
    }

    if (m_pOnlinePresence->m_pCInvitation == NULL)
    {
        XOMASSERT(FALSE);
        return E_UNEXPECTED;
    }

    // Make sure we have enough room
    HRESULT hr = S_OK;
    BYTE *pCNew = NULL;
    QWORD *pqwInsert = NULL;
    DWORD dwInsertIndex = 0;

    // Resize the current allocation
    pCNew = new BYTE[(m_pOnlinePresence->m_pCInvitation->cInvitees + 1) * sizeof(QWORD) + sizeof(CInvitation)];
    if (pCNew == NULL)
    {
        return E_OUTOFMEMORY;
    }
    memcpy(pCNew, m_pOnlinePresence->m_pCInvitation, sizeof(CInvitation) + m_pOnlinePresence->m_pCInvitation->cInvitees * sizeof(QWORD));
    delete[] m_pOnlinePresence->m_pCInvitation;
    m_pOnlinePresence->m_pCInvitation = new (pCNew) CInvitation;

    // Look for the insertion position
    pqwInsert = m_pOnlinePresence->m_pCInvitation->rgqwInvitees;
    dwInsertIndex = 0;
    while ((dwInsertIndex < m_pOnlinePresence->m_pCInvitation->cInvitees) && (*pqwInsert < qwInviteeID))
    {
        pqwInsert++;
        dwInsertIndex++;
    }

    if ((*pqwInsert != qwInviteeID) && (m_pOnlinePresence->m_pCInvitation->cInvitees == XONLINE_MAX_MESSAGE_RECIPIENTS))
    {
        // not refreshing an existing invite, and we have the max num of recipients.
        XomNtEvent(XEVENT_PRESENCE_CODE_223, "CPresence::AddInvitee() called for user=%I64X adding invitee=%I64X when user already has the maximum number of invitees.",
            m_qwUserID,
            qwInviteeID);
            
        return E_FAIL;
    }
    
    // Insert it if not in the list
    if ((dwInsertIndex == m_pOnlinePresence->m_pCInvitation->cInvitees) || (*pqwInsert != qwInviteeID))
    {
        // Move down for room
        memmove(pqwInsert + 1, pqwInsert, (m_pOnlinePresence->m_pCInvitation->cInvitees - dwInsertIndex) * sizeof(QWORD));

        // Set the new item key and increment the count
        *pqwInsert = qwInviteeID;
        m_pOnlinePresence->m_pCInvitation->cInvitees++;
    }
    else
    {
        // else already in the list
        hr = S_FALSE;
    }

    // Update the timestamp
    GetSystemTimeAsFileTime(&(m_pOnlinePresence->m_pCInvitation->ftSent));

    return hr;
}

/*****************************************************************************

CPresence::RemoveInvitee

Remove an Invitee from an invitation.  If they are the last invitee, the
invitation is deleted.  Returns S_FALSE if the delete was empty.

*****************************************************************************/
HRESULT CPresence::RemoveInvitee(QWORD qwInviteeID)
{
    XOMASSERT(m_pOnlinePresence != NULL);
    if (m_pOnlinePresence == NULL)
    {
        XomNtEvent(XEVENT_PRESENCE_CODE_224, "NULL online presence record accessed for user %I64X", GetUserID());
        return HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
    }

    DWORD dwIndex = 0;
    QWORD *pqwInvitee;

    // See if there is a pending invite
    if (m_pOnlinePresence->m_pCInvitation == NULL)
    {
        return S_FALSE;
    }

    // Try to find them in the list
    pqwInvitee = (QWORD *) bsearch(
        &qwInviteeID,
        m_pOnlinePresence->m_pCInvitation->rgqwInvitees,
        m_pOnlinePresence->m_pCInvitation->cInvitees,
        sizeof(QWORD),
        CompareQWORD);

    if (pqwInvitee == NULL)
    {
        return S_FALSE;
    }

    dwIndex = (((BYTE *)pqwInvitee) - ((BYTE *)m_pOnlinePresence->m_pCInvitation->rgqwInvitees)) / sizeof(QWORD);


    // Found, if last invitee turn off the lights else remove
    if (m_pOnlinePresence->m_pCInvitation->cInvitees == 1)
    {
        DeleteInvite();
    }
    else
    {
        // Move everyone else up
        m_pOnlinePresence->m_pCInvitation->cInvitees--;
        memmove(pqwInvitee, pqwInvitee+1, (m_pOnlinePresence->m_pCInvitation->cInvitees - dwIndex) * sizeof(QWORD));
    }

    return S_OK;
}

/*****************************************************************************

CPresence::IsInvited

Determine if the given user is an invitee.

*****************************************************************************/
BOOL CPresence::IsInvited(QWORD qwUserID)
{
    if (m_pOnlinePresence == NULL)
    {
        return FALSE;
    }

    QWORD *pqwInvitee;

    // See if there is a pending invite
    if (m_pOnlinePresence->m_pCInvitation == NULL)
    {
        return FALSE;
    }

    // Try to find them in the list
    pqwInvitee = (QWORD *) bsearch(
        &qwUserID,
        m_pOnlinePresence->m_pCInvitation->rgqwInvitees,
        m_pOnlinePresence->m_pCInvitation->cInvitees,
        sizeof(QWORD),
        CompareQWORD);

    return (pqwInvitee != NULL);
}

/*****************************************************************************

CPresence::RecordUserAlive

Utility method that is called during Alive message processing

*****************************************************************************/
void CPresence::RecordUserAlive()
{
    XOMASSERT(m_pOnlinePresence);
    if (m_pOnlinePresence == NULL)
    {
        XomNtEvent(XEVENT_PRESENCE_CODE_225, "NULL online presence record accessed for user %I64X", GetUserID());
        return;
    }

    if (m_pOnlinePresence->m_dwAliveTime != 0) return;

    m_pOnlinePresence->m_dwAliveTime = GetTickCount();
    if (m_pOnlinePresence->m_dwAliveTime == 0)
    {
        // Zero is special, increment by one tick
        m_pOnlinePresence->m_dwAliveTime = 1;
    }

    SetLastActiveTime();

    g_Counters.SafeIncrement32(XPPERF_SERVER_ACTIVE_USERS_COUNTER);

    RecordTitleChange(m_pOnlinePresence->m_dwTitleID, TRUE, FALSE);
}

/*****************************************************************************

CPresence::RecordUserKilled

Utility method that is paired up with RecordUserAlive calls in order to
properly track the end of online logon sessions.

*****************************************************************************/
void CPresence::RecordUserKilled()
{
    XOMASSERT(m_pOnlinePresence);
    if (m_pOnlinePresence == NULL)
    {
        XomNtEvent(XEVENT_PRESENCE_CODE_226, "NULL online presence record accessed for user %I64X", GetUserID());
        return;
    }

    DWORD dwDiff = 0;

    if (m_pOnlinePresence->m_dwAliveTime != 0)
    {
        g_Counters.SafeDecrement32(XPPERF_SERVER_ACTIVE_USERS_COUNTER);

        // Keep track of things
        dwDiff = GetTickCount() - m_pOnlinePresence->m_dwAliveTime;

        g_Counters.IncrementValue64(
            XPPERF_SERVER_USER_SESSION_TIME_AVERAGE,
            dwDiff);

        g_Counters.IncrementValue32(
            XPPERF_SERVER_USER_SESSION_TIME_BASE,
            1);

        m_pOnlinePresence->m_dwAliveTime = 0;

        // LineType|MachinePUID|Nonce|SG IP|SG SPI|UserPUID|TitleID|TitleVer|TitleRegion|Xbox IP|Xbox port|Duration(ms)
        XomLog(
            PresenceLog,
            "KIA|%I64X|%I64X|%X|%X|%I64X|%X|%X|%X|%X|%X|%X",
            m_pOnlinePresence->m_sgaddr.qwXboxID,
            m_qwNonce,
            m_pOnlinePresence->m_sgaddr.inaSg,
            m_pOnlinePresence->m_sgaddr.dwSpiSg,
            m_qwUserID,
            m_pOnlinePresence->m_dwTitleID,
            m_pOnlinePresence->m_dwTitleVersion,
            m_pOnlinePresence->m_dwTitleRegion,
            m_pOnlinePresence->m_ipaXbox,
            m_pOnlinePresence->m_ipportXbox,
            dwDiff);

        RecordTitleChange(m_pOnlinePresence->m_dwTitleID, FALSE, TRUE);
            
    }
}

/*****************************************************************************

CPresence::RecordUserAlive

Utility method that is called when state is set to playing

*****************************************************************************/
void CPresence::RecordPlayStart(DWORD dwState, DWORD dwTitleID, QWORD qwSessionID)
{
    XOMASSERT(m_pOnlinePresence != NULL);
    if (m_pOnlinePresence == NULL)
    {
        XomNtEvent(XEVENT_PRESENCE_CODE_227, "NULL online presence record accessed for user %I64X", GetUserID());
        return;
    }

    // Are we not playing?
    if (m_pOnlinePresence->m_dwPlayStart == 0)
    {
        // Mark the start of play
        m_pOnlinePresence->m_dwPlayStart = GetTickCount();
        if (m_pOnlinePresence->m_dwPlayStart == 0)
        {
            // zero is magic, add a tick
            m_pOnlinePresence->m_dwPlayStart = 1;
        }

        // LineType|MachinePUID|TitleID|UserPUID|State|SessionID
        XomLog(
            PresenceLog,
            "SESSTART|%I64X|%X|%I64X|%X|%I64X",
            m_pOnlinePresence->m_sgaddr.qwXboxID,
            dwTitleID,
            m_qwUserID,
            dwState,
            qwSessionID);
        XomLog(
            Reporting,
            "SESSTART|%I64X|%X|%I64X|%X|%I64X",
            m_pOnlinePresence->m_sgaddr.qwXboxID,
            dwTitleID,
            m_qwUserID,
            dwState,
            qwSessionID);
    }
}

/*****************************************************************************

CPresence::RecordPlayStop

Utility method that is paired up with RecordPlayStart calls in order to
properly track the end of playing state sessions.

*****************************************************************************/
void CPresence::RecordPlayStop()
{
    XOMASSERT(m_pOnlinePresence != NULL);
    if (m_pOnlinePresence == NULL)
    {
        XomNtEvent(XEVENT_PRESENCE_CODE_228, "NULL online presence record accessed for user %I64X", GetUserID());
        return;
    }

    if ((m_dwState & P_STATE_MASK_ONLINE) && !(m_dwState & P_STATE_MASK_CLOAKED))
    {
        SetUserStateChanged();
    }

    DWORD dwDiff = 0;

    // Were we playing?
    if (m_pOnlinePresence->m_dwPlayStart != 0)
    {
        // Mark the end of play
        dwDiff = GetTickCount() - m_pOnlinePresence->m_dwPlayStart;

        // LineType|MachinePUID|TitleID|UserPUID|State|SessionID|Duration(ms)
        XomLog(
            PresenceLog,
            "SESEND|%I64X|%X|%I64X|%X|%I64X|%X",
            m_pOnlinePresence->m_sgaddr.qwXboxID,
            m_pOnlinePresence->m_dwTitleID,
            m_qwUserID,
            m_dwState,
            m_pOnlinePresence->m_qwMatchSessionID,
            dwDiff);
        XomLog(
            Reporting,
            "SESEND|%I64X|%X|%I64X|%X|%I64X|%X",
            m_pOnlinePresence->m_sgaddr.qwXboxID,
            m_pOnlinePresence->m_dwTitleID,
            m_qwUserID,
            m_dwState,
            m_pOnlinePresence->m_qwMatchSessionID,
            dwDiff);
        
        m_pOnlinePresence->m_dwPlayStart = 0;
    }
}


/*****************************************************************************

CPresence::RecordTitleChange

Utility method that logs to reporting when the title changes on an Xbox360 console

*****************************************************************************/
void CPresence::RecordTitleChange(DWORD dwTitleID, BOOL fAlive, BOOL fKill)
{
    XOMASSERT(m_pOnlinePresence != NULL);
    if (m_pOnlinePresence == NULL)
    {
        XomNtEvent(XEVENT_PRESENCE_CODE_229, "NULL online presence record accessed for user %I64X", GetUserID());
        return;
    }

    DWORD dwDiff = 0;

    // If this is a STATE message, the titleIds are different
    if (dwTitleID != m_pOnlinePresence->m_dwTitleID)
    {    
        if ( (m_pOnlinePresence->m_dwTitleID != 0)
            // && (m_pOnlinePresence->m_dwTitleID != XONLINE_XBOX_DASH_TITLE_ID)
            // && (m_pOnlinePresence->m_dwTitleID != XONLINE_XENON_DASH_TITLE_ID) 
            )
        {
            fKill = TRUE;            
        }
        
        if ( (dwTitleID != 0)
            // && (dwTitleID != XONLINE_XBOX_DASH_TITLE_ID)
            // && (dwTitleID != XONLINE_XENON_DASH_TITLE_ID) 
            )
        {
            fAlive = TRUE;            
        }    
    }

    if (fKill)
    {
        // Stop any session currently in progress
        RecordPlayStop();
        
        // Mark the end of the title
        dwDiff = GetTickCount() - m_pOnlinePresence->m_dwTitleStart;
        
        // LineType|MachinePUID|TitleID|UserPUID|State|Xbox IP|Xbox port|SessKey|Duration(ms)|States|Dequeues
        XomLog(
            PresenceLog,
            "TITLEND|%I64X|%X|%I64X|%X|%X|%X|%X|%X|%X|%X",
            m_pOnlinePresence->m_sgaddr.qwXboxID,
            m_pOnlinePresence->m_dwTitleID,
            m_qwUserID,
            m_dwState,
            m_pOnlinePresence->m_ipaXbox,
            m_pOnlinePresence->m_ipportXbox,
            m_pOnlinePresence->m_dwTitleStart,
            dwDiff,
            m_pOnlinePresence->m_wStates,
            m_pOnlinePresence->m_wDequeues);
        XomLog(
            Reporting,
            "TITLEND|%I64X|%X|%I64X|%X|%X|%X|%X|%X|%X|%X",
            m_pOnlinePresence->m_sgaddr.qwXboxID,
            m_pOnlinePresence->m_dwTitleID,
            m_qwUserID,
            m_dwState,
            m_pOnlinePresence->m_ipaXbox,
            m_pOnlinePresence->m_ipportXbox,
            m_pOnlinePresence->m_dwTitleStart,
            dwDiff,
            m_pOnlinePresence->m_wStates,
            m_pOnlinePresence->m_wDequeues);
        
        m_pOnlinePresence->m_dwTitleStart = 0;
        m_pOnlinePresence->m_wStates = 0;
        m_pOnlinePresence->m_wDequeues = 0;
    }
    
    if (fAlive)
    {
        // Mark the start of play
        m_pOnlinePresence->m_dwTitleStart = GetTickCount();
        
        // LineType|MachinePUID|TitleID|UserPUID|State|Xbox IP|Xbox port|SessKey
        XomLog(
            PresenceLog,
            "TITLESTART|%I64X|%X|%I64X|%X|%X|%X|%X",
            m_pOnlinePresence->m_sgaddr.qwXboxID,
            dwTitleID,
            m_qwUserID,
            m_dwState,
            m_pOnlinePresence->m_ipaXbox,
            m_pOnlinePresence->m_ipportXbox,
            m_pOnlinePresence->m_dwTitleStart);
        XomLog(
            Reporting,
            "TITLESTART|%I64X|%X|%I64X|%X|%X|%X|%X",
            m_pOnlinePresence->m_sgaddr.qwXboxID,
            dwTitleID,
            m_qwUserID,
            m_dwState,
            m_pOnlinePresence->m_ipaXbox,
            m_pOnlinePresence->m_ipportXbox,
            m_pOnlinePresence->m_dwTitleStart);
    }
}

/*****************************************************************************

CPresence::RecordGuestChange

Utility method that is called when the number of guests change for a title

*****************************************************************************/
void CPresence::RecordGuestChange(DWORD dwTitleID, DWORD oldState, DWORD newState)
{
    XOMASSERT(m_pOnlinePresence != NULL);
    if (m_pOnlinePresence == NULL)
    {
        XomNtEvent(XEVENT_PRESENCE_CODE_230, "NULL online presence record accessed for user %I64X", GetUserID());
        return;
    }

    DWORD dwOldGuests = (oldState & P_STATE_MASK_GUESTS) >> 5;
    DWORD dwNewGuests = (newState & P_STATE_MASK_GUESTS) >> 5;
    
    // LineType|MachinePUID|TitleID|UserPUID|State|OldGuests|NewGuests
    XomLog(
        PresenceLog,
        "GUESTCHG|%I64X|%X|%I64X|%X|%X|%X",
        m_pOnlinePresence->m_sgaddr.qwXboxID,
        m_pOnlinePresence->m_dwTitleID,
        m_qwUserID,
        m_dwState,
        dwOldGuests,
        dwNewGuests);
    XomLog(
        Reporting,
        "GUESTCHG|%I64X|%X|%I64X|%X|%X|%X",
        m_pOnlinePresence->m_sgaddr.qwXboxID,
        m_pOnlinePresence->m_dwTitleID,
        m_qwUserID,
        m_dwState,
        dwOldGuests,
        dwNewGuests);
}

/*****************************************************************************

CPresence::SetNeverList

Refresh the in-memory list with new values from the data store.

*****************************************************************************/
void CPresence::SetNeverList( WORD cUsers, QWORD* rgqwUsers )
{
    // Free any previous list
    if( NULL != m_rgqwNeverList )
    {
        delete[] m_rgqwNeverList;
    }

    m_cNeverList = cUsers;
    m_rgqwNeverList = rgqwUsers;
}

/*****************************************************************************

CPresence::IsUserBlocked

Checks if this user has blocked the passed in user from sending messages to them.

*****************************************************************************/
BOOL CPresence::IsUserBlocked( QWORD qwUserID )
{
    for( WORD iUser = 0; iUser < m_cNeverList; iUser++ )
    {
        if( qwUserID == m_rgqwNeverList[ iUser ] )
        {
            return TRUE;
        }
    }

    return FALSE;
}

/*****************************************************************************

CPresence::BlockUser

Adds a user to another user's in-memory block list.

*****************************************************************************/
void CPresence::BlockUser( QWORD qwUserID )
{
    // Don't allow blocking PUID zero
    if( 0 == qwUserID )
    {
        return;
    }

    // Make sure they aren't already on the list
    if( IsUserBlocked( qwUserID ) )
    {
        return;
    }

    // Re-allocate the block list
    QWORD* rgqwBlockList = new QWORD[ m_cNeverList + 1 ];
    if( NULL == rgqwBlockList )
    {
        return;
    }

    memcpy( rgqwBlockList, m_rgqwNeverList, m_cNeverList * sizeof( *m_rgqwNeverList ) );
    rgqwBlockList[ m_cNeverList ] = qwUserID;
    m_cNeverList++;

    QWORD* rgqwOldList = m_rgqwNeverList;
    m_rgqwNeverList = rgqwBlockList;
    rgqwBlockList = NULL;

    delete[] rgqwOldList;
}

/*****************************************************************************

CPresence::UnblockUsers

Removes blocked users from the in-memory list.

*****************************************************************************/
void CPresence::UnblockUsers( const QWORD* rgqwUsers, WORD cUsers )
{
    for( WORD iUnblock = 0; iUnblock < cUsers; iUnblock++ )
    {
        for( WORD iUser = 0; iUser < m_cNeverList; iUser++ )
        {
            if( rgqwUsers[ iUnblock ] == m_rgqwNeverList[ iUser ] )
            {
                // Delete this blocked user by moving everything else up one and decrementing the count
                memmove(
                    &m_rgqwNeverList[ iUser ],
                    &m_rgqwNeverList[ iUser + 1 ],
                    ( m_cNeverList - iUser - 1 ) * sizeof( *m_rgqwNeverList ) );

                m_cNeverList--;
                break;
            }
        }
    }
}

/*****************************************************************************

CPresence::AddItem

Creates a new item and adds to the given Queue

Returns S_FALSE if the item added is the only one in the queue

*****************************************************************************/
HRESULT CPresence::AddItem(
    DWORD dwQType,
    DWORD cbData,
    const BYTE *pbData,
    DWORD *pdwItemID)
{
    XOMASSERT(m_pOnlinePresence)
    if (m_pOnlinePresence == NULL)
    {
        XomNtEvent(XEVENT_PRESENCE_CODE_231, "NULL online presence record accessed for user %I64X", GetUserID());
        return HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
    }

    HRESULT hr = S_OK;

    if (dwQType >= PQUEUE_NUM_TYPES ||
        dwQType == PQUEUE_INVITE ||
        dwQType == PQUEUE_TRANSIENT_MSGS )
    {
        return E_INVALIDARG;
    }

    // Assign an ItemID
    *pdwItemID = m_pOnlinePresence->m_dwNextItemID;
    m_pOnlinePresence->m_dwNextItemID++;

    hr = m_pOnlinePresence->m_rgCQueues[dwQType].AddItem(
        *pdwItemID,
        cbData,
        pbData
    );
    if( S_FALSE == hr )
    {
        SendQVals();
    }

    return hr;
}

/*****************************************************************************

CPresence::AddXMsgItem

Add a new transient message to the user's queue

Returns S_FALSE if the item added is the only one in the queue

*****************************************************************************/
HRESULT CPresence::AddXMsgItem(
    const Q_SEND_MESSAGE_MSG* pSendMessage,
    BYTE fSenderIsFriend,
    const BYTE* pbProperties,         // size is in pSendMessage
    DWORD *pdwItemID)
{
    XOMASSERT(m_pOnlinePresence)
    if (m_pOnlinePresence == NULL)
    {
        XomNtEvent(XEVENT_PRESENCE_CODE_232, "NULL online presence record accessed for user %I64X", GetUserID());
        return HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
    }

    HRESULT hr = S_OK;

    // Assign an ItemID
    *pdwItemID = m_pOnlinePresence->m_dwNextXMsgItemID;

    m_pOnlinePresence->m_dwNextXMsgItemID = ( ( m_pOnlinePresence->m_dwNextXMsgItemID + 1 ) & XONLINE_MSG_ID_BASE_MASK ) | XONLINE_MSG_ID_TRANSIENT_MESSAGE;

    hr = m_pOnlinePresence->m_rgCQueues[ PQUEUE_TRANSIENT_MSGS ].AddXMsgItem(
        *pdwItemID,
        fSenderIsFriend,
        pSendMessage,
        pbProperties
    );

    if( S_FALSE == hr )
    {
        SetXMsgAddQVals(
            pSendMessage,
            fSenderIsFriend,
            *pdwItemID );
    }

    return hr;
}

/*****************************************************************************

CPresence::ResetV1InviteQFlag

All of the V1 invites for this user have been dequeued, reset the QFlag

*****************************************************************************/
void CPresence::ResetV1InviteQFlag()
{
    XOMASSERT(m_pOnlinePresence)
    if (m_pOnlinePresence == NULL)
    {
        XomNtEvent(XEVENT_PRESENCE_CODE_233, "NULL online presence record accessed for user %I64X", GetUserID());
        return;
    }

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Resetting V1 Invite QFlag, all items gone or dequeued User=%I64X Type=%d NewSeq=%X",
        m_qwUserID,
        PQUEUE_INVITE,
        m_pOnlinePresence->m_dwSeqQVals + 2);

    if( m_pOnlinePresence->m_rgdwQVals[ QVAL_INDEX(QVAL_QFLAGS) + 1] & QFLAG_MASK(PQUEUE_INVITE) )
    {
        // Mark a QFlag change
        m_pOnlinePresence->m_dwSeqQVals++;

        m_pOnlinePresence->m_rgdwQVals[QVAL_INDEX(QVAL_QFLAGS)] =
            QVAL_QFLAGS |
            (m_pOnlinePresence->m_dwSeqQVals << QVAL_SEQ_SHIFT);

        m_pOnlinePresence->m_rgdwQVals[QVAL_INDEX(QVAL_QFLAGS) + 1] &= ~(QFLAG_MASK(PQUEUE_INVITE));
    }

    // Mark no new items possible
    m_pOnlinePresence->m_dwSeqQVals++;

    m_pOnlinePresence->m_rgdwQVals[QVAL_INDEX(QVAL_NEW_GAME_INVITE)] =
        QVAL_NEW_GAME_INVITE |
        (m_pOnlinePresence->m_dwSeqQVals << QVAL_SEQ_SHIFT);
}

/*****************************************************************************

CPresence::SetXMsgAddQVals

A new message has arrived for this user, set the appropriate QVals

Returns S_FALSE if the item added is the only one in the queue

*****************************************************************************/
void CPresence::SetXMsgAddQVals(
    const Q_SEND_MESSAGE_MSG* pNewMessage,
    BOOL fSenderIsFriend,
    DWORD dwItemID)
{
    XOMASSERT(m_pOnlinePresence);
    if (m_pOnlinePresence == NULL)
    {
        XomNtEvent(XEVENT_PRESENCE_CODE_234, "NULL online presence record accessed for user %I64X", GetUserID());
        return;
    }

    // Always push new item notifications
    m_fPushQVals = TRUE;

    // For V1 compatibility, if the sender is a friend then we need to set the QFlag for PQUEUE_INVITE
    // and populate the invite QVal.
    if( fSenderIsFriend )
    {
        XomTrace(
            PresenceDebug,
            L_NORMAL,
            "Setting V1 Invite QFlag User=%I64X Type=%d NewSeq=%X",
            m_qwUserID,
            PQUEUE_INVITE,
            m_pOnlinePresence->m_dwSeqQVals + 2);

        if( 0 == ( m_pOnlinePresence->m_rgdwQVals[QVAL_INDEX(QVAL_QFLAGS) + 1] & QFLAG_MASK(PQUEUE_INVITE) ) )
        {
            // Mark a QFlags change
            m_pOnlinePresence->m_dwSeqQVals++;

            m_pOnlinePresence->m_rgdwQVals[QVAL_INDEX(QVAL_QFLAGS)] =
                QVAL_QFLAGS |
                (m_pOnlinePresence->m_dwSeqQVals << QVAL_SEQ_SHIFT);

            m_pOnlinePresence->m_rgdwQVals[QVAL_INDEX(QVAL_QFLAGS) + 1] |= QFLAG_MASK(PQUEUE_INVITE);
        }

        m_pOnlinePresence->m_dwSeqQVals++;

        m_pOnlinePresence->m_rgdwQVals[QVAL_INDEX(QVAL_NEW_GAME_INVITE)] =
            QVAL_NEW_GAME_INVITE |
            QVAL_BOOL_MASK |
            (m_pOnlinePresence->m_dwSeqQVals << QVAL_SEQ_SHIFT);
    }

    // We use two QVals of stacked information when a message is added.  The first QVal contains 3 DWORDs
    // which are the message IDs of the 3 most recently added messages.  The second QVal contains additional
    // data about the messages such as their type and relevant flags.  Also, some titles will want to handle
    // only messages sent from their title, whereas others will want to handle all messages.  Rather than
    // have another two QVals for this, there is a special message flag used to indicate that
    // a particular message is for the current title.

    // Set up the new message notification data
    Q_MESSAGE_NOTIFICATION msgnot;
    msgnot.dwTypeAndFlags = pNewMessage->bMessageType << 24;
    msgnot.dwTypeAndFlags |= ( pNewMessage->dwMessageFlags & XONLINE_MSG_FLAGS_TITLE_RESERVED ) >> 8;
    if( HIWORD(m_pOnlinePresence->m_dwTitleID) == HIWORD(pNewMessage->dwSenderTitleID) )
    {
        msgnot.dwTypeAndFlags |= XONLINE_MSG_NOTIFICATION_FLAG_SAME_PUBLISHER;
    }
    if( fSenderIsFriend )
    {
        msgnot.dwTypeAndFlags |= XONLINE_MSG_NOTIFICATION_FLAG_INVITE_FROM_FRIEND;
    }
    if( pNewMessage->dwMessageFlags & XONLINE_MSG_FLAG_HAS_VOICE )
    {
        msgnot.dwTypeAndFlags |= XONLINE_MSG_NOTIFICATION_FLAG_HAS_VOICE;
    }
    if( pNewMessage->dwMessageFlags & XONLINE_MSG_FLAG_HAS_TEXT )
    {
        msgnot.dwTypeAndFlags |= XONLINE_MSG_NOTIFICATION_FLAG_HAS_TEXT;
    }

    if( m_pOnlinePresence->m_dwTitleID == pNewMessage->dwSenderTitleID )
    {
        msgnot.dwTypeAndFlags |= XONLINE_MSG_NOTIFICATION_FLAG_SAME_TITLE;
    }
    else if( 0 != m_pOnlinePresence->m_dwAltTitleID1 && m_pOnlinePresence->m_dwAltTitleID1 == pNewMessage->dwSenderTitleID ||
             0 != m_pOnlinePresence->m_dwAltTitleID2 && m_pOnlinePresence->m_dwAltTitleID2 == pNewMessage->dwSenderTitleID ||
             0 != m_pOnlinePresence->m_dwAltTitleID3 && m_pOnlinePresence->m_dwAltTitleID3 == pNewMessage->dwSenderTitleID ||
             0 != m_pOnlinePresence->m_dwAltTitleID4 && m_pOnlinePresence->m_dwAltTitleID4 == pNewMessage->dwSenderTitleID )
    {
        msgnot.dwTypeAndFlags |= XONLINE_MSG_NOTIFICATION_FLAG_ALT_TITLE;
    }

    // Mark a new item
    m_pOnlinePresence->m_dwSeqXMsgAddQVal++;

    // Always mark a change of the master sequence number since this is used to match up replies
    m_pOnlinePresence->m_dwSeqQVals++;

    // The sequence is used by the client to know how many new messages have arrived.  If the number is
    // less than 3, then the metadata can be retrieved directly using the data values without enumerating.
    m_pOnlinePresence->m_rgdwQVals[QVAL_INDEX(QVAL_NEW_MSG_IDS)] = QVAL_NEW_MSG_IDS | (m_pOnlinePresence->m_dwSeqXMsgAddQVal << QVAL_SEQ_SHIFT);
    m_pOnlinePresence->m_rgdwQVals[QVAL_INDEX(QVAL_NEW_MSG_DATA)] = QVAL_NEW_MSG_DATA | (m_pOnlinePresence->m_dwSeqXMsgAddQVal << QVAL_SEQ_SHIFT);

    // Shift out the oldest message ID and insert the new one
    m_pOnlinePresence->m_rgdwQVals[QVAL_INDEX(QVAL_NEW_MSG_IDS) + 3] = m_pOnlinePresence->m_rgdwQVals[QVAL_INDEX(QVAL_NEW_MSG_IDS) + 2];
    m_pOnlinePresence->m_rgdwQVals[QVAL_INDEX(QVAL_NEW_MSG_IDS) + 2] = m_pOnlinePresence->m_rgdwQVals[QVAL_INDEX(QVAL_NEW_MSG_IDS) + 1];
    m_pOnlinePresence->m_rgdwQVals[QVAL_INDEX(QVAL_NEW_MSG_IDS) + 1] = dwItemID;

    // Shift out the oldest message data and insert the new one
    m_pOnlinePresence->m_rgdwQVals[QVAL_INDEX(QVAL_NEW_MSG_DATA) + 3] = m_pOnlinePresence->m_rgdwQVals[QVAL_INDEX(QVAL_NEW_MSG_DATA) + 2];
    m_pOnlinePresence->m_rgdwQVals[QVAL_INDEX(QVAL_NEW_MSG_DATA) + 2] = m_pOnlinePresence->m_rgdwQVals[QVAL_INDEX(QVAL_NEW_MSG_DATA) + 1];
    m_pOnlinePresence->m_rgdwQVals[QVAL_INDEX(QVAL_NEW_MSG_DATA) + 1] = *((DWORD*)&msgnot);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Setting Messaging Add QVal User=%I64X Msg=0x%08X SameTitle=%d FromFriend=%d AddSeq=%X MainSeq=%X",
       m_qwUserID,
       dwItemID,
       m_pOnlinePresence->m_dwTitleID == pNewMessage->dwSenderTitleID,
       fSenderIsFriend,
       m_pOnlinePresence->m_dwSeqXMsgAddQVal,
       m_pOnlinePresence->m_dwSeqQVals);

    SendQVals();
}

/*****************************************************************************

CPresence::SetXMsgDeleteQVals

A message has been deleted for this user, set the appropriate QVals

*****************************************************************************/
void CPresence::SetXMsgDeleteQVals(
    DWORD dwItemID,
    BOOL fSendNow,
    BOOL fPushQVals)
{
    XOMASSERT (m_pOnlinePresence);
	if (m_pOnlinePresence == NULL)
    {
        XomNtEvent(XEVENT_PRESENCE_CODE_235, "NULL online presence record accessed for user %I64X", GetUserID());
        return;
    }

    // Always push delete notifications
    m_fPushQVals = fPushQVals;

    // Mark a new item
    m_pOnlinePresence->m_dwSeqXMsgDeleteQVal++;

    // Always mark a change of the master sequence number since this is used to match up replies
    m_pOnlinePresence->m_dwSeqQVals++;

    // The sequence is used by the client to know how many new messages have arrived.  If the number is
    // less than 3, then the metadata can be retrieved directly using the data values without enumerating.
    m_pOnlinePresence->m_rgdwQVals[QVAL_INDEX(QVAL_MSG_DELETED)] =
        QVAL_MSG_DELETED | (m_pOnlinePresence->m_dwSeqXMsgDeleteQVal << QVAL_SEQ_SHIFT);

    // Shift out the oldest message ID and insert the new one
    m_pOnlinePresence->m_rgdwQVals[QVAL_INDEX(QVAL_MSG_DELETED) + 3] = m_pOnlinePresence->m_rgdwQVals[QVAL_INDEX(QVAL_MSG_DELETED) + 2];
    m_pOnlinePresence->m_rgdwQVals[QVAL_INDEX(QVAL_MSG_DELETED) + 2] = m_pOnlinePresence->m_rgdwQVals[QVAL_INDEX(QVAL_MSG_DELETED) + 1];
    m_pOnlinePresence->m_rgdwQVals[QVAL_INDEX(QVAL_MSG_DELETED) + 1] = dwItemID;

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Setting Messaging Delete QVal User=%I64X Msg=0x%08X DelSeq=%X MainSeq=%X",
       m_qwUserID,
       dwItemID,
       m_pOnlinePresence->m_dwSeqXMsgDeleteQVal,
       m_pOnlinePresence->m_dwSeqQVals);

    if( fSendNow )
    {
        SendQVals();
    }
}

/*****************************************************************************

CPresence::DeleteXMsgItem

Deletes an item with the given ItemID

*****************************************************************************/
HRESULT CPresence::DeleteXMsgItem(
    DWORD dwItemID)
{
    HRESULT hr;

    XOMASSERT (m_pOnlinePresence);
	if (m_pOnlinePresence == NULL)
    {
        XomNtEvent(XEVENT_PRESENCE_CODE_236, "NULL online presence record accessed for user %I64X", GetUserID());
        hr = HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
		goto lDone;
    }

    hr = m_pOnlinePresence->m_rgCQueues[ PQUEUE_TRANSIENT_MSGS ].DeleteItemByItemID( dwItemID );
    if( S_FALSE == hr )
    {
        hr = XONLINE_E_MESSAGE_INVALID_MESSAGE_ID; // Message not found
    }

lDone:
    return hr;
}

/*****************************************************************************

CPresence::DeleteExpiredMessages

Deletes any invites that have expired

*****************************************************************************/
void CPresence::DeleteExpiredMessages( DWORD dwTime )
{
    if (m_pOnlinePresence == NULL)
    {
        return;
    }

    BOOL fOnline = IsOnline();

    // NOTE: Deleting expired items may delete all items, which if we are not online
    // will completely clean up the user object such that it isn't safe to call
    // SendQVals.  The online state is therefore saved ahead of time and SendQVals is
    // only called if we are online.

    if( S_FALSE == m_pOnlinePresence->m_rgCQueues[ PQUEUE_TRANSIENT_MSGS ].DeleteExpiredItems( dwTime ) &&
        fOnline)
    {
        SendQVals();
    }
}

/*****************************************************************************

CPresence::ListItems

Lists the items in the given queue

*****************************************************************************/
HRESULT CPresence::ListItems(
    BOOL fV1ItemsOnly,
    DWORD dwQType,
    DWORD dwStartItemID,
    DWORD* pcMaxItems,        // Specifies the max size on the way in, and the actual size on the way out
    DWORD* pcbMaxItemDataSize,// Specifies the max size on the way in, and the actual size on the way out
    CQueueItem** ppFirstItem,
    DWORD* pdwNextItemID,
    DWORD* pcItemsLeft)
{
    XOMASSERT(m_pOnlinePresence);
    if (m_pOnlinePresence == NULL)
    {
        XomNtEvent(XEVENT_PRESENCE_CODE_237, "NULL online presence record accessed for user %I64X", GetUserID());
        return HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
    }

    HRESULT hr = S_OK;

    if (dwQType >= PQUEUE_NUM_TYPES)
    {
        return E_INVALIDARG;
    }

    if ( (dwQType == PQUEUE_PRESENCE) || (dwQType == PQUEUE_PEER_PRESENCE) || (dwQType == PQUEUE_PRESENCE_2) )
    {
        m_pOnlinePresence->m_wDequeues++;
    }

    hr = m_pOnlinePresence->m_rgCQueues[dwQType].ListItems(
        fV1ItemsOnly,
        dwStartItemID,
        pcMaxItems,
        pcbMaxItemDataSize,
        ppFirstItem,
        pdwNextItemID,
        pcItemsLeft);

    return hr;
}

/*****************************************************************************

CPresence::GetItem

Gets the specified item in the given queue

*****************************************************************************/
CQueueItem* CPresence::GetItem(
    DWORD dwQType,
    DWORD dwItemID)
{
    XOMASSERT(m_pOnlinePresence);
    if (m_pOnlinePresence == NULL)
    {
        XomNtEvent(XEVENT_PRESENCE_CODE_238, "NULL online presence record accessed for user %I64X", GetUserID());
        return NULL;
    }

    if (dwQType >= PQUEUE_NUM_TYPES)
    {
        return NULL;
    }

    return m_pOnlinePresence->m_rgCQueues[ dwQType ].GetItem(
        dwItemID);
}

/*****************************************************************************

CPresence::ClearAllQs

Clears all of the queues

*****************************************************************************/
void CPresence::ClearAllQs()
{
    XOMASSERT(m_pOnlinePresence);
    if (m_pOnlinePresence == NULL)
    {
        XomNtEvent(XEVENT_PRESENCE_CODE_239, "NULL online presence record accessed for user %I64X", GetUserID());
        return;
    }

    DWORD dwIndex;

    for (dwIndex = 0; dwIndex < PQUEUE_NUM_TYPES; dwIndex++)
    {
        m_pOnlinePresence->m_rgCQueues[dwIndex].Clear();
    }
}

/*****************************************************************************

CPresence::HasTransientMessages

Checks if this user has transient messages

*****************************************************************************/
BOOL CPresence::HasTransientMessages()
{
    XOMASSERT(m_pOnlinePresence);
    if (m_pOnlinePresence == NULL)
    {
        XomNtEvent(XEVENT_PRESENCE_CODE_240, "NULL online presence record accessed for user %I64X", GetUserID());
        return FALSE;
    }

    // If the user is offline and they have no transient messages in their
    // queues waiting for them to come online, then free their record from memory.
    return( 0 != m_pOnlinePresence->m_rgCQueues[ PQUEUE_TRANSIENT_MSGS ].GetLength());
}

/*****************************************************************************

CPresence::SendQVals

Send QVals if appropriate

*****************************************************************************/
void CPresence::SendQVals()
{
    if( !IsOnline() )
    {
        // If we're not online, then we don't need to send QVals
        return;
    }

    XOMASSERT(m_pOnlinePresence);
    if (m_pOnlinePresence == NULL)
    {
        XomNtEvent(XEVENT_PRESENCE_CODE_241, "NULL online presence record accessed for user %I64X", GetUserID());
        return;
    }

    if (GetPQueueIndex() != (DWORD)~0)
    {
        // already expecting a dequeue from this client.
        return;
    }

    if( m_pOnlinePresence->m_dwTickleCount >= g_CPresCfg.GetQValRetryDelaysLen() )
    {
        // The user hasn't responded after our maximum number of QVal attempts, clean them up
        XomTrace( PresenceDebug, L_ERROR,
            "CPresence::SendQVals - user %I64X hasn't responded after %u retries, marking for deadsg",
            m_qwUserID,
            m_pOnlinePresence->m_dwTickleCount );

        // we call MarkForDeadSG() here so that we can defer the user cleanup to usermaintenance.  otherwise,
        // we might try to kill a lot of users here when called from periodicheartbeat.  since usermaintenance has
        // throttle controls to avoid overloading the switchboard, its safer to let it do any potential bulk deleting.
        MarkForDeadSG();
        return;
    }

    XomTrace( PresenceDebug, L_NORMAL,
        "CPresence::SendQVals: sg %X spi %X xb %I64X User=%I64X Seq=%X Push=%u Try=%u",
        m_pOnlinePresence->m_sgaddr.inaSg,
        m_pOnlinePresence->m_sgaddr.dwSpiSg,
        m_pOnlinePresence->m_sgaddr.qwXboxID,
        m_qwUserID,
        m_pOnlinePresence->m_dwSeqQVals,
        m_fPushQVals,
        m_pOnlinePresence->m_dwTickleCount );

    // QVals changed, send them down
    (void) m_pSwitchboard->GetSGComm()->SendQVals(
        &m_pOnlinePresence->m_sgaddr,
        m_qwUserID,
        QVAL_COUNT,
        m_pOnlinePresence->m_rgdwQVals,
        m_pOnlinePresence->m_dwSeqQVals,
        m_fPushQVals);
    // Ignore failure, we can try later...

    if (m_pOnlinePresence->m_dwPQueueIndex == ~0)
    {
        // Schedule it for the next time
        HRESULT hr = g_CTicklePriQueue.Insert( this );
        if (FAILED(hr))
        {
            XomNtEvent(
                XEVENT_PRESENCE_CODE_242,
                "Failure to reschedule tickle hr=%X",
                hr);
        }

        // Do this after we insert because insert reads it
        m_pOnlinePresence->m_dwTickleCount++;
    }
}

/*****************************************************************************

CPresence::SetQValsReply

Handle a QVals Reply from the SG

*****************************************************************************/
void CPresence::SetQValsReply( DWORD dwSeqNum )
{
    XOMASSERT(m_pOnlinePresence);
    if (m_pOnlinePresence == NULL)
    {
        XomNtEvent(XEVENT_PRESENCE_CODE_243, "NULL online presence record accessed for user %I64X", GetUserID());
        return;
    }

    // If the sequence number is up to date
    if( dwSeqNum == m_pOnlinePresence->m_dwSeqQVals )
    {
        // Stop the tickles for this user
        g_CTicklePriQueue.DropObject( this );

        // Clear the push flag
        m_fPushQVals = FALSE;
    }
    
    // Reset the tickle count even if this is a stale reply.  the sg may be slow, but its still there.
    m_pOnlinePresence->m_dwTickleCount = 0;
}

/*****************************************************************************

CPresence::SetPrivileges

Translate the raw privilege bits into flags we care about

*****************************************************************************/
void CPresence::SetPrivileges(BYTE rgbPrivileges[XONLINE_NUM_PRIVILEGE_BYTES])
{
// Helper macro for testing privilege bits given a BYTE array
#define TEST_PRIVILEGE(privs, id)       ( 0 != (privs[id / 8] & (BYTE)(1 << (id % 8))) )

    m_PrivMultiplayer                   = TEST_PRIVILEGE(rgbPrivileges, XPRIVILEGE_MULTIPLAYER_SESSIONS);
    m_PrivCommunications                = TEST_PRIVILEGE(rgbPrivileges, XPRIVILEGE_COMMUNICATIONS);
    m_PrivCommunicationsFriendsOnly     = TEST_PRIVILEGE(rgbPrivileges, XPRIVILEGE_COMMUNICATIONS_FRIENDS_ONLY);
    m_PrivPresence                      = TEST_PRIVILEGE(rgbPrivileges, XPRIVILEGE_PRESENCE);
    m_PrivPresenceFriendsOnly           = TEST_PRIVILEGE(rgbPrivileges, XPRIVILEGE_PRESENCE_FRIENDS_ONLY);
    m_PrivFriendsList                   = TEST_PRIVILEGE(rgbPrivileges, XPRIVILEGE_SHARE_FRIENDS_LIST);
    m_PrivFriendsListFriendsOnly        = TEST_PRIVILEGE(rgbPrivileges, XPRIVILEGE_SHARE_FRIENDS_LIST_FRIENDS_ONLY);

#undef TEST_PRIVILEGE
}

/*****************************************************************************

CPresenceUserIndex::CPresenceUserIndex

Constructor

*****************************************************************************/
CPresenceUserIndex::CPresenceUserIndex() :
    m_cBuckets(0),
    m_rgpCUserHashTable(NULL)
{}

/*****************************************************************************

CPresenceUserIndex::~CPresenceUserIndex

Destructor

*****************************************************************************/
CPresenceUserIndex::~CPresenceUserIndex()
{
    if (m_rgpCUserHashTable != NULL)
    {
        // NOTE: this does not delete the presence objects, it only deletes the pointers to them.
        delete[] m_rgpCUserHashTable;
    }
}

/*****************************************************************************

CPresenceUserIndex::CPresenceUserIndex

Initializer

*****************************************************************************/
HRESULT CPresenceUserIndex::Init()
{
    HRESULT hr = S_OK;

    // Get the number of buckets
    m_cBuckets = g_CPresCfg.GetUserIndexSize();
    if (m_cBuckets <= 0)
    {
        hr = E_INVALIDARG;
        goto lDone;
    }

    m_rgpCUserHashTable = new CPresence *[m_cBuckets];
    if (m_rgpCUserHashTable == 0)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    memset(m_rgpCUserHashTable, 0, sizeof(CPresence *) * m_cBuckets);


lDone:
    return hr;
}

// NOTE: this DELETEs presence records.  Only use this when the service is exiting!
void CPresenceUserIndex::Shutdown()
{
    for (DWORD dwBucket = 0; dwBucket < m_cBuckets; dwBucket++)
    {
        for (CPresence *pCPresence = m_rgpCUserHashTable[dwBucket]; pCPresence != NULL; )
        {
            CPresence *pVictim = pCPresence;
            pCPresence = pCPresence->m_pCPresenceNext;

            if (pVictim->HasOnlineRecord())
            {
                pVictim->SetOffline();                
                pVictim->SelfDestruct();
            }

            RemovePresence(pVictim);
        }
    }
}

HRESULT CPresenceUserIndex::Resize(DWORD dwNewSize)
{
    HRESULT hr = S_OK;

    // backup the old buckets
    DWORD cOldBuckets = m_cBuckets;
    CPresence **ppOldHashTable = m_rgpCUserHashTable;
    
    // Get the new number of buckets
    if (dwNewSize <= 0)
    {
        hr = E_INVALIDARG;
        goto lDone;
    }

    // create a new table
    m_rgpCUserHashTable = new CPresence *[dwNewSize];
    if (m_rgpCUserHashTable == 0)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }
    
    memset(m_rgpCUserHashTable, 0, sizeof(CPresence *) * dwNewSize);

    // update the new bucket size so that Hash() calculates the new bucket id.
    m_cBuckets = dwNewSize;

    // iterate through the old buckets
    for (DWORD iOldBucket = 0; iOldBucket < cOldBuckets; iOldBucket++)
    {
        while (ppOldHashTable[iOldBucket] != NULL)
        {
            CPresence *pRelocate = ppOldHashTable[iOldBucket];
            ppOldHashTable[iOldBucket] = pRelocate->m_pCPresenceNext;

            // insert into the new table.
            AddPresence(pRelocate);

            // AddPresence() increments the refcount, but we're really only moving the same reference.
            pRelocate->Release();
        }
    }

    delete[] ppOldHashTable;
    
lDone:

    if (FAILED(hr))
    {
        m_rgpCUserHashTable = ppOldHashTable;
        m_cBuckets = cOldBuckets;
    }
    
    return hr;
}

/*****************************************************************************

CPresenceUserIndex::CreatePresence

Creates a presence object and adds it to the primary and secondary indexes

*****************************************************************************/
HRESULT CPresenceUserIndex::CreatePresence(
        CSwitchboard *pSwitchboard,
        QWORD qwUserID,
        QWORD qwNonce,
        DWORD cbAcctName,
        LPCSTR szAcctName,
        QWORD qwWebID,
        CPresence **ppCPresence)
{
    CPresence *pCNewPresence;

    // Create a new presence oject
    pCNewPresence = new CPresence(pSwitchboard);
    if (pCNewPresence == NULL)
    {
        return E_OUTOFMEMORY;
    }

    // Populate it
    pCNewPresence->m_qwUserID = qwUserID;
    pCNewPresence->m_qwNonce = qwNonce;
    pCNewPresence->m_cbAcctName = cbAcctName;
    strncpy(pCNewPresence->m_szAcctName, szAcctName, MAX_ACCTNAME_BYTES);
    pCNewPresence->m_szAcctName[MAX_ACCTNAME_BYTES - 1] = '\0';
    pCNewPresence->m_qwWebID = qwWebID;


    // Add it to the indexes
    AddPresence(pCNewPresence);

    // Send a reference back to the caller
    *ppCPresence = pCNewPresence;

    return S_OK;
}

/*****************************************************************************

CPresenceUserIndex::AddPresence

Adds a presence to the index.

*****************************************************************************/
HRESULT CPresenceUserIndex::AddPresence(CPresence *pCPresence)
{
    DWORD dwBucket;
    CPresence *pCBucket;

    dwBucket = Hash(pCPresence->m_qwUserID);

    pCBucket = m_rgpCUserHashTable[dwBucket];

    if (pCBucket != NULL)
    {
        pCPresence->m_pCPresenceNext = pCBucket;
        pCBucket->m_pCPresenceBack = pCPresence;

    }
    pCPresence->m_pCPresenceBack = NULL;
    m_rgpCUserHashTable[dwBucket] = pCPresence;

    pCPresence->AddRef();

    g_CPresCfg.AddBucketUser(pCPresence->m_qwUserID);

    return S_OK;
}

/*****************************************************************************

CPresenceUserIndex::RemovePresence

Removes a presence from the index, but does not delete it

*****************************************************************************/
void CPresenceUserIndex::RemovePresence(CPresence *pCPresence)
{
    DWORD dwHash = Hash(pCPresence->m_qwUserID);
    BOOL fRelease = TRUE;

    // Fix up the item behind me
    if (pCPresence->m_pCPresenceBack != NULL)
    {
        pCPresence->m_pCPresenceBack->m_pCPresenceNext = pCPresence->m_pCPresenceNext;
    }
    else if (m_rgpCUserHashTable[dwHash] == pCPresence)
    {
        // Go back to the index
        m_rgpCUserHashTable[dwHash] = pCPresence->m_pCPresenceNext;
    }
    else
    {
        // no parent, and not equal to the head of the list.  it must not be in the list at all.
        fRelease = FALSE;
    }

    // Fix up the item in front of me
    if (pCPresence->m_pCPresenceNext != NULL)
    {
        pCPresence->m_pCPresenceNext->m_pCPresenceBack = pCPresence->m_pCPresenceBack;
    }

    // Mark the removed item as not in the list
    pCPresence->m_pCPresenceNext = NULL;
    pCPresence->m_pCPresenceBack = NULL;

    if (fRelease)
    {
        pCPresence->Release();
    }
}

/*****************************************************************************

CPresenceUserIndex::FindPresence

Uses the index to find a CPresence object by UserID

*****************************************************************************/
HRESULT CPresenceUserIndex::FindPresence(QWORD qwUserID, CPresence **ppCPresence, BOOL fOverride)
{
    DWORD dwBucket;
    HRESULT hr = S_OK;

    if (ppCPresence == NULL)
    {
        return E_POINTER;
    }

    dwBucket = Hash(qwUserID);

    *ppCPresence = m_rgpCUserHashTable[dwBucket];
    while (*ppCPresence != NULL)
    {
        if ((*ppCPresence)->m_qwUserID == qwUserID)
        {
            if (!fOverride)
            {
                if ((*ppCPresence)->IsMigrationInProgress())
                {
                    // rejected.  alt server owns this user.
                    XomTrace(PresenceDebug, L_NORMAL, "FindPresence(%I64X) rejected due to migration in progress.", qwUserID);
                    hr = XONLINE_E_PRESENCE_USER_MIGRATED;
                    goto lDone;
                }

                if ((*ppCPresence)->IsMigrationPending())
                {
                    // deferred.  we dont have the data to process anything for this user yet.
                    XomTrace(PresenceDebug, L_NORMAL, "FindPresence(%I64X) rejected due to migration pending.", qwUserID);
                    hr = XONLINE_E_PRESENCE_DEFER_REQUEST;
                    goto lDone;
                }
            }
            
            (*ppCPresence)->AddRef();
            goto lDone;
        }
        else
        {
            *ppCPresence = (*ppCPresence)->m_pCPresenceNext;
        }
    }

    // didnt find him?
    DWORD dwAltServer = g_CPresCfg.MapUserToPresSrv(qwUserID, TRUE);
    if (dwAltServer != g_CPresCfg.GetMyPresServerIndex())
    {
        // not found here, he belongs to the alt server.
        hr = XONLINE_E_PRESENCE_USER_MIGRATED;
    }
    else
    {
        // he just doesnt have a base record.
        hr = HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
    }

lDone:

    if (FAILED(hr))
    {
        *ppCPresence = NULL;
    }
    
    return hr;
}

HRESULT CPresenceUserIndex::QueueDeferredRequest(QWORD qwUserID, CLocalContext * pCCtx)
{
    DWORD dwBucket = Hash(qwUserID);
    CPresence *pCPresence = m_rgpCUserHashTable[dwBucket];

    while (pCPresence != NULL)
    {
        if (pCPresence->GetUserID() == qwUserID)
        {
            pCPresence->AddDeferredContext(pCCtx);
            return S_OK;
        }
        else
        {
            pCPresence = pCPresence->m_pCPresenceNext;
        }
    }

    return HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
}

/*****************************************************************************

CPresenceUserIndex::Hash

Hash function for the index

*****************************************************************************/
DWORD CPresenceUserIndex::Hash(QWORD qwUserID)
{
    qwUserID = GET_PUID_BITS(qwUserID);
    return (LODWORD(qwUserID) ^ HIDWORD(qwUserID)) % m_cBuckets;
}

/*****************************************************************************

CPresenceXBoxIndex::CPresenceXBoxIndex

Constructor

*****************************************************************************/
CPresenceXBoxIndex::CPresenceXBoxIndex() :
    m_cBuckets(0),
    m_rgpCPresenceXBoxHashTable(NULL)

{
}

/*****************************************************************************

CPresenceXBoxIndex::~CPresenceXBoxIndex

Destructor

*****************************************************************************/
CPresenceXBoxIndex::~CPresenceXBoxIndex()
{
    if (m_rgpCPresenceXBoxHashTable != NULL)
    {
        // NOTE: this does not delete the presence objects, it only deletes the pointers to them.
        delete[] m_rgpCPresenceXBoxHashTable;
    }
}


/*****************************************************************************

CPresenceXBoxIndex::Init

Initializer

*****************************************************************************/
HRESULT CPresenceXBoxIndex::Init()
{
    HRESULT hr = S_OK;

    // Get the number of buckets
    m_cBuckets = g_CPresCfg.GetXBoxIndexSize();
    if (m_cBuckets <= 0)
    {
        hr = E_INVALIDARG;
        goto lDone;
    }

    m_rgpCPresenceXBoxHashTable = new CPresence *[m_cBuckets];
    if (m_rgpCPresenceXBoxHashTable == 0)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    memset(m_rgpCPresenceXBoxHashTable, 0, sizeof(CPresence *) * m_cBuckets);

lDone:
    return hr;
}

HRESULT CPresenceXBoxIndex::Resize(DWORD dwNewSize)
{
    HRESULT hr = S_OK;

    // backup the old buckets
    DWORD cOldBuckets = m_cBuckets;
    CPresence **ppOldHashTable = m_rgpCPresenceXBoxHashTable;
    
    // Get the new number of buckets
    if (dwNewSize <= 0)
    {
        hr = E_INVALIDARG;
        goto lDone;
    }

    // create a new table
    m_rgpCPresenceXBoxHashTable = new CPresence *[dwNewSize];
    if (m_rgpCPresenceXBoxHashTable == 0)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }
    
    memset(m_rgpCPresenceXBoxHashTable, 0, sizeof(CPresence *) * dwNewSize);

    // update the new bucket size so that Hash() calculates the new bucket id.
    m_cBuckets = dwNewSize;

    // iterate through the old buckets
    for (DWORD iOldBucket = 0; iOldBucket < cOldBuckets; iOldBucket++)
    {
        while (ppOldHashTable[iOldBucket] != NULL)
        {
            CPresence *pRelocate = ppOldHashTable[iOldBucket];
            ppOldHashTable[iOldBucket] = pRelocate->m_pCPresenceNext;

            // insert into the new table.
            AddPresence(pRelocate);

            // AddPresence() increments the refcount, but we're really only moving the same reference.
            pRelocate->Release();
        }
    }

    delete[] ppOldHashTable;
    
lDone:

    if (FAILED(hr))
    {
        m_rgpCPresenceXBoxHashTable = ppOldHashTable;
        m_cBuckets = cOldBuckets;
    }
    
    return hr;
}

/*****************************************************************************

CPresenceXBoxIndex::AddPresence

Adds a presence to the index.

*****************************************************************************/
void CPresenceXBoxIndex::AddPresence(CPresence *pCPresence)
{
    DWORD dwBucket;
    CPresence *pCBucket;

    dwBucket = Hash(&(pCPresence->m_pOnlinePresence->m_sgaddr));

    pCBucket = m_rgpCPresenceXBoxHashTable[dwBucket];

    if (pCBucket != NULL)
    {
        pCPresence->m_pOnlinePresence->m_pCXBoxNext = pCBucket;
        pCBucket->m_pOnlinePresence->m_pCXBoxBack = pCPresence;

    }
    pCPresence->m_pOnlinePresence->m_pCXBoxBack = NULL;
    m_rgpCPresenceXBoxHashTable[dwBucket] = pCPresence;

    pCPresence->AddRef();
}

/*****************************************************************************

CPresenceXBoxIndex::RemovePresence

Removes a presence from the index, but does not delete it

*****************************************************************************/
void CPresenceXBoxIndex::RemovePresence(CPresence *pCPresence)
{
    DWORD dwHash = Hash(&(pCPresence->m_pOnlinePresence->m_sgaddr));
    BOOL fRelease = TRUE;

    // Fix up the item behind me
    if (pCPresence->m_pOnlinePresence->m_pCXBoxBack != NULL)
    {
        pCPresence->m_pOnlinePresence->m_pCXBoxBack->m_pOnlinePresence->m_pCXBoxNext = pCPresence->m_pOnlinePresence->m_pCXBoxNext;
    }
    else if (m_rgpCPresenceXBoxHashTable[dwHash] == pCPresence)
    {
        // Go back to the index
        m_rgpCPresenceXBoxHashTable[dwHash] = pCPresence->m_pOnlinePresence->m_pCXBoxNext;
    }
    else
    {
        // no parent, and not equal to the head of the list.  it must not be in the list at all.
        fRelease = FALSE;
    }

    // Fix up the item in front of me
    if (pCPresence->m_pOnlinePresence->m_pCXBoxNext != NULL)
    {
        pCPresence->m_pOnlinePresence->m_pCXBoxNext->m_pOnlinePresence->m_pCXBoxBack = pCPresence->m_pOnlinePresence->m_pCXBoxBack;
    }

    // Mark the removed item as not in the list
    pCPresence->m_pOnlinePresence->m_pCXBoxNext = NULL;
    pCPresence->m_pOnlinePresence->m_pCXBoxBack = NULL;

    if (fRelease)
    {
        pCPresence->Release();
    }
}

/*****************************************************************************

CPresenceXBoxIndex::Hash

Hash function for the index

*****************************************************************************/
DWORD CPresenceXBoxIndex::Hash(const SGADDR *psgaddr)
{
    return (psgaddr->inaSg.S_un.S_addr + psgaddr->dwSpiSg)  % m_cBuckets;
}

/*****************************************************************************

CPresenceSGIndex::CPresenceSGIndex

Constructor

*****************************************************************************/
CPresenceSGIndex::CPresenceSGIndex() :
    m_cBuckets(0),
    m_rgpCPresenceSGHashTable(NULL)

{
}

/*****************************************************************************

CPresenceSGIndex::~CPresenceSGIndex

Destructor

*****************************************************************************/
CPresenceSGIndex::~CPresenceSGIndex()
{
    if (m_rgpCPresenceSGHashTable != NULL)
    {
        // NOTE: this does not delete the presence objects, it only deletes the pointers to them.
        delete[] m_rgpCPresenceSGHashTable;
    }
}

/*****************************************************************************

CPresenceSGIndex::Init

Initializer

*****************************************************************************/
HRESULT CPresenceSGIndex::Init()
{
    HRESULT hr = S_OK;

    // Get the number of buckets
    m_cBuckets = g_CPresCfg.GetSGIndexSize();
    if (m_cBuckets <= 0)
    {
        hr = E_INVALIDARG;
        goto lDone;
    }

    m_rgpCPresenceSGHashTable = new CPresence *[m_cBuckets];
    if (m_rgpCPresenceSGHashTable == 0)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    memset(m_rgpCPresenceSGHashTable, 0, sizeof(CPresence *) * m_cBuckets);

lDone:
    return hr;
}

HRESULT CPresenceSGIndex::Resize(DWORD dwNewSize)
{
    HRESULT hr = S_OK;

    // backup the old buckets
    DWORD cOldBuckets = m_cBuckets;
    CPresence **ppOldHashTable = m_rgpCPresenceSGHashTable;
    
    // Get the new number of buckets
    if (dwNewSize <= 0)
    {
        hr = E_INVALIDARG;
        goto lDone;
    }

    // create a new table
    m_rgpCPresenceSGHashTable = new CPresence *[dwNewSize];
    if (m_rgpCPresenceSGHashTable == 0)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }
    
    memset(m_rgpCPresenceSGHashTable, 0, sizeof(CPresence *) * dwNewSize);

    // update the new bucket size so that Hash() calculates the new bucket id.
    m_cBuckets = dwNewSize;

    // iterate through the old buckets
    for (DWORD iOldBucket = 0; iOldBucket < cOldBuckets; iOldBucket++)
    {
        while (ppOldHashTable[iOldBucket] != NULL)
        {
            CPresence *pRelocate = ppOldHashTable[iOldBucket];
            ppOldHashTable[iOldBucket] = pRelocate->m_pCPresenceNext;

            // insert into the new table.
            AddPresence(pRelocate);

            // AddPresence() increments the refcount, but we're really only moving the same reference.
            pRelocate->Release();
        }
    }

    delete[] ppOldHashTable;
    
lDone:

    if (FAILED(hr))
    {
        m_rgpCPresenceSGHashTable = ppOldHashTable;
        m_cBuckets = cOldBuckets;
    }
    
    return hr;
}

/*****************************************************************************

CPresenceSGIndex::AddPresence

Adds a presence to the index.

*****************************************************************************/
void CPresenceSGIndex::AddPresence(CPresence *pCPresence)
{
    DWORD dwBucket;
    CPresence *pCBucket;

    dwBucket = Hash(&(pCPresence->m_pOnlinePresence->m_sgaddr));

    pCBucket = m_rgpCPresenceSGHashTable[dwBucket];

    if (pCBucket != NULL)
    {
        pCPresence->m_pOnlinePresence->m_pCSGNext = pCBucket;
        pCBucket->m_pOnlinePresence->m_pCSGBack = pCPresence;

    }
    pCPresence->m_pOnlinePresence->m_pCSGBack = NULL;
    m_rgpCPresenceSGHashTable[dwBucket] = pCPresence;

    pCPresence->AddRef();
}

/*****************************************************************************

CPresenceSGIndex::RemovePresence

Removes a presence from the index, but does not delete it

*****************************************************************************/
void CPresenceSGIndex::RemovePresence(CPresence *pCPresence)
{
    DWORD dwHash = Hash(&(pCPresence->m_pOnlinePresence->m_sgaddr));
    BOOL fRelease = TRUE;
    
    // Fix up the item behind me
    if (pCPresence->m_pOnlinePresence->m_pCSGBack != NULL)
    {
        pCPresence->m_pOnlinePresence->m_pCSGBack->m_pOnlinePresence->m_pCSGNext = pCPresence->m_pOnlinePresence->m_pCSGNext;
    }
    else if (m_rgpCPresenceSGHashTable[dwHash] == pCPresence)
    {
        // Go back to the index
        m_rgpCPresenceSGHashTable[dwHash] = pCPresence->m_pOnlinePresence->m_pCSGNext;
    }
    else
    {
        // no parent, and not equal to the head of the list.  it must not be in the list at all.
        fRelease = FALSE;
    }

    // Fix up the item in front of me
    if (pCPresence->m_pOnlinePresence->m_pCSGNext != NULL)
    {
        pCPresence->m_pOnlinePresence->m_pCSGNext->m_pOnlinePresence->m_pCSGBack = pCPresence->m_pOnlinePresence->m_pCSGBack;
    }

    // Mark the removed item as not in the list
    pCPresence->m_pOnlinePresence->m_pCSGNext = NULL;
    pCPresence->m_pOnlinePresence->m_pCSGBack = NULL;

    if (fRelease)
    {
        pCPresence->Release();
    }
}

/*****************************************************************************

CPresenceSGIndex::Hash

Hash function for the index

*****************************************************************************/
DWORD CPresenceSGIndex::Hash(const SGADDR *psgaddr)
{
    return psgaddr->inaSg.S_un.S_addr % m_cBuckets;
}

/*****************************************************************************

CTicklePriQueue::Insert

Insert an item into the priority queue with the given execute time

*****************************************************************************/
HRESULT CTicklePriQueue::Insert(CPresence* pObject)
{
    HRESULT hr = S_OK;
    DWORD dwTime = 0;

    if(pObject->GetPQueueIndex() != ~0)
    {
        // Object was already scheduled. Remove it from the queue using the
        // index stored in the object itself.

        CPresence* pThrowAway;

        pThrowAway = m_CHeap.Remove(pObject->GetPQueueIndex());

        if(pThrowAway != pObject)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_244, "m_CHeap.Remove != pObject");
            goto lDone;
        }
    }

    // Set the new time scheduled on this object + up to 25% to avoid patterns
    dwTime = g_CPresCfg.GetQValRetryDelays()[pObject->GetTickleCount()];
    dwTime += rand() % (dwTime / 4);
    dwTime += GetTickCount();

    pObject->SetTimeScheduled(dwTime);

    // Reinsert it into the queue
    hr = m_CHeap.Insert(pObject);
    if (FAILED(hr))
    {
        pObject->SetTimeScheduled((DWORD)~0);
    }

lDone:
    return hr;
}

/*****************************************************************************

CTicklePriQueue::Remove

Remove an item from into the priority queue at the given index

*****************************************************************************/
HRESULT CTicklePriQueue::Remove(DWORD dwIndex, CPresence** ppObject )
{
    *ppObject = m_CHeap.Remove(dwIndex);

    // Mark this object as "not in the queue".

    (*ppObject)->SetPQueueIndex((DWORD)~0);

    return S_OK;
}

/*****************************************************************************

CTicklePriQueue::DropObject

Remove an item from into the priority queue given its pointer

*****************************************************************************/
HRESULT CTicklePriQueue::DropObject(CPresence* pObject)
{
    DWORD dwIndex = pObject->GetPQueueIndex();
    CPresence* pDrop;

    if(dwIndex != ~0)
    {
        pDrop = m_CHeap.Remove(dwIndex);

        XOMASSERT(pDrop == pObject);

        // Mark this object as "not in the queue"
        pObject->SetPQueueIndex((DWORD)~0);

        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\inh\StdAfx.cpp ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\inh\sgcomm.h ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#ifndef SGCOMM_H_INCLUDED
#define SGCOMM_H_INCLUDED

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CSwitchboard;

/*****************************************************************************

CSGCommunicator

Listens for messages from SGs and sends messages to SGs

*****************************************************************************/
class CSGCommunicator : 
    public CServerSocketCallback
{
public:
    IMPLEMENT_REFCOUNT;

    CSGCommunicator();
    virtual ~CSGCommunicator();

    HRESULT Init(CSwitchboard *pCSwitchboard);
    void Shutdown();

    // CServerSocketCallback methods
    virtual void OnSocketSendTo(
        BYTE *pbBufferSent,
        DWORD cbToSend,
        DWORD cbSent,
        HRESULT hr,
        QWORD qwCallbackArg );
    
    virtual void OnSocketReceiveFrom(
        BYTE *pbFilledInBuffer,
        DWORD cbRead,
        sockaddr_in *pFilledInFrom,
        HRESULT hr,
        QWORD qwCallbackArg );

    // Send methods
    HRESULT SendQVals(
        const SGADDR *psgaddr,
        QWORD qwUserID,
        DWORD cdwQVals,
        const DWORD *pdwQVals,
        DWORD dwSeqQVals,
        BOOL fPush);

    HRESULT SendKick(
        const SGADDR *psgaddr);

protected:

    CCompletionPort *m_pCCompPort;
    CSwitchboard *m_pCSwitchboard;
    CServerSocket *m_pCQFlagsSocket;
    DWORD m_dwMaxDatagram;
    BYTE *m_pbRecvBuffer1;
    BYTE *m_pbRecvBuffer2;
};


#endif  // SGCOMM_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\inh\presence.h ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#ifndef __PRESENCE_H_INCLUDED
#define __PRESENCE_H_INCLUDED

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CSwitchboard;
class CPresence;
class CPresenceUserIndex;
class CPresenceXBoxIndex;
class CPresenceSGIndex;
class CQueueItem; 
class CQueue;
class CTicklePriQueue;
class CLocalContext;
class CQueryAffiliatesContext;
class CInterfaceBucketChangeContext;

extern CPresenceUserIndex g_CPresenceUserIndex;
extern CPresenceXBoxIndex g_CPresenceXBoxIndex;
extern CPresenceSGIndex g_CPresenceSGIndex;
extern CTicklePriQueue g_CTicklePriQueue;

// TODO: make max sizes for affiliates regions configurable from xmgmtc.
extern DWORD g_rgdwMaxAffiliates[];

#define MAX_NICKNAME_BYTES 24
#define MAX_WATCHES 5000

// our puids always start with 0x0009xxxx.  we're using some of the unused high bits for status and subscribed.
#define PRES_PUID_MASK ((QWORD)(0x000FFFFFFFFFFFFF))
#define PRES_PUID_SHIFT 0
#define PRES_STATUS_MASK ((QWORD)(0x6000000000000000))
#define PRES_STATUS_SHIFT 61
#define PRES_SUBSCRIBED_MASK ((QWORD)(0x8000000000000000))
#define PRES_SUBSCRIBED_SHIFT 63
#define PRES_CLIENT_TYPE_MASK ((QWORD)(0x1C00000000000000))
#define PRES_CLIENT_TYPE_SHIFT 58
#define PRES_CLIENT_TYPE_UNKNOWN 0
#define PRES_CLIENT_TYPE_XBOX 1
#define PRES_CLIENT_TYPE_XENON 2
#define PRES_CLIENT_BETA_MASK ((QWORD)(0x0200000000000000))
#define PRES_CLIENT_BETA_SHIFT 57
#define PRES_PEER_SUBSCRIBED_MASK ((QWORD)(0x0100000000000000))
#define PRES_PEER_SUBSCRIBED_SHIFT 56

#define GET_PUID_BITS(puid) (((puid) & PRES_PUID_MASK) >> PRES_PUID_SHIFT)

#define GET_PUID_CLIENT_TYPE(puid) (DWORD)(((puid) & PRES_CLIENT_TYPE_MASK) >> PRES_CLIENT_TYPE_SHIFT)
#define SET_PUID_CLIENT_TYPE(puid, type) \
{ \
    if (g_CPresCfg.GetProtocolVersion() > 2) \
    { \
        (puid) &= ~PRES_CLIENT_TYPE_MASK; \
        (puid) |= (((QWORD)(type) << PRES_CLIENT_TYPE_SHIFT) & PRES_CLIENT_TYPE_MASK); \
    } \
}

#define IS_PUID_CLIENT_BETA(puid) (DWORD)(((puid) & PRES_CLIENT_BETA_MASK) >> PRES_CLIENT_BETA_SHIFT)
#define SET_PUID_CLIENT_BETA(puid, beta) \
{ \
    if (g_CPresCfg.GetProtocolVersion() > 2) \
    { \
        (puid) &= ~PRES_CLIENT_BETA_MASK; \
        (puid) |= (((QWORD)(beta) << PRES_CLIENT_BETA_SHIFT) & PRES_CLIENT_BETA_MASK); \
    } \
}

/*****************************************************************************

CUserList

A list of users

*****************************************************************************/
class CUserList
{
public:


    CUserList();
    ~CUserList();

    HRESULT Add(QWORD qwUserId);
    HRESULT Remove(QWORD qwUserId);
    HRESULT Replace(DWORD cNew, const QWORD *pqwNew, DWORD *pcAdd, QWORD *rgqwAdd, DWORD *pcSub, QWORD *rgqwSub);
    HRESULT Update(DWORD cAdd, QWORD *rgqwAdd, DWORD cSub, QWORD *rgqwSub);
    void Clear();

    BOOL IsPresent(QWORD qwUserId);
    DWORD GetCount() { return m_cUsers; }
    QWORD *GetUsers() { return m_rgqwUsers; }

protected:
    DWORD m_cUsers;
    QWORD *m_rgqwUsers;
};

/*****************************************************************************

CBuddyListEntry

A buddy list entry

*****************************************************************************/
class CBuddyListEntry
{
public:

    CBuddyListEntry() : qwData (0) {};

    void Initialize() { qwData = 0; }
    
    QWORD GetBuddyID() { return (qwData & PRES_PUID_MASK) >> PRES_PUID_SHIFT; }
    void SetBuddyID(QWORD qwBuddyID)
    {
        qwData &= ~PRES_PUID_MASK;
        qwData |= ( (qwBuddyID << PRES_PUID_SHIFT) & PRES_PUID_MASK );
    }
    
    DWORD GetStatus() { return (DWORD)((qwData & PRES_STATUS_MASK) >> PRES_STATUS_SHIFT); }
    void SetStatus(DWORD dwStatus)
    {
        qwData &= ~PRES_STATUS_MASK;
        qwData |= ( (((QWORD)dwStatus) << PRES_STATUS_SHIFT) & PRES_STATUS_MASK );
    }
    
    BOOL IsSubscribed() { return (BOOL)((qwData & PRES_SUBSCRIBED_MASK) >> PRES_SUBSCRIBED_SHIFT); }
    void SetSubscribed(BOOL fSubscribed)
    {
        qwData &= ~PRES_SUBSCRIBED_MASK;
        qwData |= ( (((QWORD)fSubscribed) << PRES_SUBSCRIBED_SHIFT) & PRES_SUBSCRIBED_MASK );
    }

    BOOL IsPeerSubscribed() { return (BOOL)((qwData & PRES_PEER_SUBSCRIBED_MASK) >> PRES_PEER_SUBSCRIBED_SHIFT); }
    void SetPeerSubscribed(BOOL fSubscribed)
    {
        qwData &= ~PRES_PEER_SUBSCRIBED_MASK;
        qwData |= ( (((QWORD)fSubscribed) << PRES_PEER_SUBSCRIBED_SHIFT) & PRES_PEER_SUBSCRIBED_MASK );
    }

    DWORD GetClientType() { return (DWORD)GET_PUID_CLIENT_TYPE(qwData); }
    void SetClientType(DWORD dwClientType) { SET_PUID_CLIENT_TYPE(qwData, dwClientType); }

    BOOL IsClientBeta() { return (DWORD)IS_PUID_CLIENT_BETA(qwData); }
    void SetClientBeta(DWORD dwClientType) { SET_PUID_CLIENT_BETA(qwData, dwClientType); }

    QWORD qwData;
};

/*****************************************************************************

CAffiliatesListEntry

An affiliates list entry

*****************************************************************************/
class CAffiliatesListEntry
{
public:

    QWORD qwAffiliateID;
    DWORD dwTitleID;
    MSGTIME mtDateUpdated;
};

class CAffiliatesList
{
public:
    
    CAffiliatesList() :
        dwAlloc(0),
        dwSize(0),
        rgAffiliates(NULL)
    { 
    }

    ~CAffiliatesList()
    {
        delete[] rgAffiliates;
    }
    
    DWORD dwAlloc;
    DWORD dwSize;
    CAffiliatesListEntry *rgAffiliates;
};

/*****************************************************************************

CInvitation

A game invitation

*****************************************************************************/
class CInvitation
{
public:

    void * __cdecl operator new(size_t len, void *pvPlacement)
    {
//        XomTrace(PresenceDebug, L_LOW, "placement new() constructing %d bytes at address 0x%0X", len, pvPlacement);

        return pvPlacement;
    }

    void __cdecl operator delete(void *pv, void *pvPlacement)
    {
//        XomTrace(PresenceDebug, L_LOW, "placement delete() freeing address 0x%0X", pvPlacement);

        XFree(pvPlacement);
    }
    
    void * __cdecl operator new(size_t len) { return ::new BYTE[len]; }
    void __cdecl operator delete(void *pv) { ::delete(pv); }

    CInvitation()
    {
        rgqwInvitees = (QWORD *)(this + 1);
    }

    DWORD dwTitleID;
    QWORD qwMatchSessionID;
    FILETIME ftSent;
    DWORD cInvitees;
    QWORD *rgqwInvitees;
};

/*****************************************************************************

CQueueItem

An item in a Queue

*****************************************************************************/

class CQueueItem 
{
friend CQueue;

public:
    
    void * __cdecl operator new(size_t len, void *pvPlacement)
    {
//        XomTrace(PresenceDebug, L_LOW, "placement new() constructing %d bytes at address 0x%0X", len, pvPlacement);

        return pvPlacement;
    }

    void __cdecl operator delete(void *pv, void *pvPlacement)
    {
//        XomTrace(PresenceDebug, L_LOW, "placement delete() freeing address 0x%0X", pvPlacement);

        XFree(pvPlacement);
    }
    
    void * __cdecl operator new(size_t len) { return ::new BYTE[len]; }
    void __cdecl operator delete(void *pv) { ::delete(pv); }

    CQueueItem()
    {
        m_pbData = (BYTE *)(this + 1);
    }
    
    void SelfDestruct();

    DWORD GetItemID() { return m_dwItemID; }
    DWORD GetTimestamp() { return m_dwTimestamp; }
    const BYTE *GetData() { return m_pbData; }
    DWORD GetDataSize() { return m_cbData; }
    CQueueItem *GetNextInQ() { return m_pCQNext; }
    CQueue* GetQueue() { return m_pCQueue; }

    const BYTE *GetV1Data();
    DWORD GetV1DataSize();
    CQueueItem *GetNextV1InQ();

    void SetDequeued();
    BOOL IsDequeued() { return m_fDequeued; }
    void ResetDequeued() { m_fDequeued = FALSE; }

protected:
    // Core data
    DWORD m_dwItemID;
    DWORD m_dwTimestamp;
    BOOL  m_fDequeued;
    DWORD m_cbData;
    BYTE *m_pbData;

    // Main Queue List
    CQueueItem *m_pCQNext;
    CQueueItem *m_pCQBack;

    // Pointer back to container
    CQueue *m_pCQueue;
};

/*****************************************************************************

CQueue

A Queue of a given type for a given user

*****************************************************************************/

class CQueue
{
    friend CQueueItem;
public:
    CQueue() : 
        m_dwQueueLength(0),
        m_dwQueueType(0),
        m_pCQueueList(NULL),
        m_pCQueueTail(NULL),
        m_pCPresence(NULL)
        { 
        }
    ~CQueue();

    HRESULT DeSerialize(P_QUEUE_ITEM_MSG *pMsg, DWORD *pdwSize, DWORD dwTimeShift = 0);

    void SetType(DWORD dwQueueType) { m_dwQueueType = dwQueueType; }
    DWORD GetType() { return m_dwQueueType; }
    DWORD GetLength() { return m_dwQueueLength; }
    void SetUser(CPresence *pCPresence) { m_pCPresence = pCPresence; }
    CPresence *GetUser() { return m_pCPresence; }
    CQueueItem *GetFirstInQ() { return m_pCQueueList; }

    HRESULT AddItem(
        DWORD dwItemID,
        DWORD cbData,
        const BYTE *pbData
        );

    HRESULT AddXMsgItem(
        DWORD dwItemID,
        BYTE fSenderIsFriend,
        const Q_SEND_MESSAGE_MSG* pSendMessage,
        const BYTE* pbProperties          // size is in pSendMessage
        );

    HRESULT DeleteExpiredItems( DWORD dwTime );

    HRESULT DeleteItemByItemID(
        DWORD dwItemID);

    HRESULT DeleteXMsgBySource(
        QWORD qwSender,
        QWORD qwContext,
        BYTE bType);

    HRESULT ListItems(
        BOOL fV1ItemsOnly,
        DWORD dwStartItemID,
        DWORD* pcMaxItems,        // Specifies the max size on the way in, and the actual size on the way out
        DWORD* pcbMaxItemDataSize,// Specifies the max size on the way in, and the actual size on the way out
        CQueueItem** ppFirstItem,
        DWORD* pdwNextItemID,
        DWORD* pcItemsLeft);

    CQueueItem* GetItem(
        DWORD dwItemID);

    void DeleteOldestItem();

    void Clear();

protected:

    void RemoveItem(CQueueItem *pCItem);

    // Core data
    DWORD m_dwQueueLength;
    DWORD m_dwQueueType;
    CQueueItem *m_pCQueueList;
    CQueueItem *m_pCQueueTail;

    // Pointer back to container
    CPresence *m_pCPresence;
};

class CContextQueueNode
{
public:
    CContextQueueNode *m_pNext;
    CLocalContext *m_pCCtx;
};

/*****************************************************************************

COnlinePresence

Holds info on a user's online presence

*****************************************************************************/
class COnlinePresence
{
friend CPresence;
friend CQueue;
friend CPresenceUserIndex;
friend CPresenceXBoxIndex;
friend CPresenceSGIndex;

public:
    COnlinePresence(CPresence *pCPresence);
    ~COnlinePresence();        
    
protected:

    SGADDR m_sgaddr;
    DWORD m_dwClientVersion;
    DWORD m_dwTitleID;
    DWORD m_dwAltTitleID1;
    DWORD m_dwAltTitleID2;
    DWORD m_dwAltTitleID3;
    DWORD m_dwAltTitleID4;
    DWORD m_dwTitleVersion;
    DWORD m_dwTitleRegion;
    XNADDR m_xnaddr;
    XNKID m_xkid;
    XNKEY m_xnkey;
    IN_ADDR m_ipaXbox;
    WORD m_ipportXbox;
    DWORD m_dwAliveTime;
    DWORD m_dwPlayStart;
    DWORD m_dwTitleStart;
    DWORD m_dwAuthDataFlags;
    BYTE m_szLocale[XONLINE_PRESENCE_LOCALE_SIZE];
    QWORD m_qwVersionFlags;

    // State info
    QWORD m_qwMatchSessionID;
    DWORD m_cbTitleStuff;
    DWORD m_cbRichPresence;
    DWORD m_cbPresenceData;
    BYTE *m_pPresenceData;
    DWORD m_cbNickname;
    BYTE m_rgbNickname[MAX_NICKNAME_BYTES];

    // Reporting data
    WORD m_wDequeues;
    WORD m_wStates;
    
    //Affiliate lists
    CAffiliatesList **m_prgAffiliateLists;
    MSGTIME m_mtAffiliatesLoaded;
    
    // Invitation info
    CInvitation *m_pCInvitation;

    // Block list info (Mute List)
    DWORD m_dwBlockListVersion;

    // Watch lists
    CUserList m_CWatchingList;

    // Messaging members
    DWORD m_dwNextXMsgItemID;

    // QVals
    DWORD m_dwSeqQVals;
    DWORD m_dwSeqXMsgAddQVal;
    DWORD m_dwSeqXMsgDeleteQVal;
    DWORD m_rgdwQVals[QVAL_COUNT];

    // Tickle Priority Queue fields
    DWORD m_dwPQueueIndex;
    DWORD m_dwTimeScheduled;
    DWORD m_dwTickleCount;

    // XBox Hash Chain
    CPresence *m_pCXBoxNext;
    CPresence *m_pCXBoxBack;

    // SG Hash Chain
    CPresence *m_pCSGNext;
    CPresence *m_pCSGBack;

    // The user's actual Queues
    DWORD m_dwTotalQLength;
    DWORD m_dwNextItemID;
    CQueue m_rgCQueues[PQUEUE_NUM_TYPES];

    CPresence *m_pCPresence;

private:
    COnlinePresence();
};

/*****************************************************************************

CPresence

Holds info on a user's presence

*****************************************************************************/
class CPresence
{
friend CQueue;
friend CPresenceUserIndex;
friend CPresenceXBoxIndex;
friend CPresenceSGIndex;

protected:
    CRefCountValue m_refcountvalue;
    ~CPresence();

public:
    ULONG AddRef();
    ULONG Release();

    CPresence(CSwitchboard *pSwitchboard);

    void SelfDestruct();

    HRESULT Serialize(P_USER_FULL_MIGRATION_MSG *pMsg, DWORD *pdwSize);
    HRESULT DeSerialize(P_USER_FULL_MIGRATION_MSG *pMsg, DWORD dwSize);

    // accesses variable declared in IMPLEMENT_REFCOUNT macro.
    LONG GetRefCount()
    {
        return m_refcountvalue.lRefCount;
    }

    CSwitchboard *GetSwitchboard() { return m_pSwitchboard; }

    HRESULT Alive(
        const SGADDR *psgaddr,
        DWORD dwClientVersion,
        QWORD qwNonce,
        DWORD dwAuthDataFlags,
        DWORD dwTitleID,
        DWORD dwAltTitleID1,
        DWORD dwAltTitleID2,
        DWORD dwAltTitleID3,
        DWORD dwAltTitleID4,
        DWORD dwTitleVersion,
        DWORD dwTitleRegion,
        XNADDR xnaddr,
        XNKID xkid,
        XNKEY xnkey,
        IN_ADDR ipaXbox,
        WORD ipportXbox,
        DWORD cbAcctName,
        LPCSTR szAcctName,
        BYTE *szLocale,
        QWORD qwVersionFlags);

    HRESULT WebAlive();

    HRESULT SetBuddyList(
        DWORD cBuddies,
        DWORD dwBuddyListVersion,
        CBuddyListEntry *rgCBuddyList
        );

    DWORD SetState(
        DWORD dwState,
        DWORD dwTitleID,
        QWORD qwMatchSessionID,
        DWORD  cbTitleStuff,
        const BYTE *rgbTitleStuff,
        WORD cbRichPresence,
        const P_RICH_PRESENCE *pRichPresence,
        WORD cbMemcacheData,
        BYTE *pMemcacheData,
        DWORD dwStateChange);   

    void SetNickname(
        DWORD cbNickname,
        const BYTE *pbNickname);

    void SetOffline();

    QWORD GetUserID() { return m_qwUserID; }
    DWORD GetTitleID() { return m_pOnlinePresence ? m_pOnlinePresence->m_dwTitleID : 0; }
    DWORD GetTitleVersion() { return m_pOnlinePresence ? m_pOnlinePresence->m_dwTitleVersion : 0; }
    DWORD GetTitleRegion() { return m_pOnlinePresence ? m_pOnlinePresence->m_dwTitleRegion : 0; }
    const SGADDR* GetSGAddr() 
    {
        static SGADDR sgNull = {0};
        return m_pOnlinePresence ? &m_pOnlinePresence->m_sgaddr : &sgNull;
    }
    
    QWORD GetNonce() { return m_qwNonce; }
    XNADDR GetXNADDR()
    {
        if (m_pOnlinePresence)
        {
            return m_pOnlinePresence->m_xnaddr;
        }
        else
        {
            XNADDR ret = {0};
            return ret;
        }
    }
    XNKID GetXNKID()
    {
        if (m_pOnlinePresence)
        {
            return m_pOnlinePresence->m_xkid; 
        }
        else
        {
            XNKID ret = {0};
            return ret;
        }
    }
    XNKEY GetXNKEY()
    { 
        if (m_pOnlinePresence)    
        {
           return m_pOnlinePresence->m_xnkey;
        }
        else
        {
            XNKEY ret = {0};
            return ret;
        }
    }

    DWORD GetClientVersionDWORD() { return m_pOnlinePresence ? m_pOnlinePresence->m_dwClientVersion : 0; }
    QWORD GetVersionFlags() { return m_pOnlinePresence->m_qwVersionFlags; }
    
    BOOL CanClientIgnoreFriendStateNotifications() 
    {
        if (!HasOnlineRecord() || !IsOnline())
        {
            // only online clients really matter.  we could return true or false here.
            return FALSE;
        }

        XBOX_LIBRARY_VERSION xlv = DWORD_TO_CLIENTVERSION(GetClientVersionDWORD());

        if (IS_PC_MACHINE_PUID(m_pOnlinePresence->m_sgaddr.qwXboxID))
        {
            // panorama handles notification filtering at major version 2.
            return (xlv.wMajorVersion >= 2);
        }
        
        if (IS_XENON_MACHINE_PUID(m_pOnlinePresence->m_sgaddr.qwXboxID) &&
            (m_pOnlinePresence->m_dwAuthDataFlags & XONLINE_AUTHDATA_FLAGS_ISXENONBACKCOMPAT) == 0)
        {
            // xenon client handles notification filtering after build 6686.
            return (xlv.wBuildNumber > 6686);
        }

        // all other clients are assumed to not handle notification filtering.
        return FALSE;        
    }

    BOOL CanClientConsumePartyInviteMessage() 
    {
        if (!HasOnlineRecord() || !IsOnline())
        {
            // websites can handle party invites.
            return TRUE;
        }

        XBOX_LIBRARY_VERSION xlv = DWORD_TO_CLIENTVERSION(GetClientVersionDWORD());

        if (IS_PC_MACHINE_PUID(m_pOnlinePresence->m_sgaddr.qwXboxID))
        {
            // panorama handles party invites at major version 2.
            return (xlv.wMajorVersion >= 2);
        }
        
        if (IS_XENON_MACHINE_PUID(m_pOnlinePresence->m_sgaddr.qwXboxID) &&
            (m_pOnlinePresence->m_dwAuthDataFlags & XONLINE_AUTHDATA_FLAGS_ISXENONBACKCOMPAT) == 0)
        {
            // xenon client handles party invites after build 7220.
            return (xlv.wBuildNumber > 7220);
        }

        // all other clients are assumed to not handle party invites.
        return FALSE;
    }

    BOOL IsOnline()
    {
        if (m_dwState & P_STATE_MASK_ONLINE)
        {
            XOMASSERT(m_pOnlinePresence);
            if (m_pOnlinePresence == NULL)
            {
                XomNtEvent(XEVENT_PRESENCE_CODE_245, "IsOnline() and m_pOnlinePresence disagree!!  this is REALLY BAD! user=%I64X", GetUserID());
                return FALSE;
            }
        }
        
        return (m_dwState & P_STATE_MASK_ONLINE);
    }

    BOOL HasOnlineRecord() { return (m_pOnlinePresence != NULL); }

    HRESULT CreateOnlineRecord(
        const SGADDR *psgaddr,
        DWORD dwClientVersion,
        DWORD dwAuthDataFlags,
        DWORD dwTitleID,
        DWORD dwTitleVersion,
        DWORD dwTitleRegion,
        XNADDR xnaddr,
        XNKID xkid,
        XNKEY xnkey,
        IN_ADDR ipaXbox,
        WORD ipportXbox,
        BYTE *szLocale,
        QWORD qwVersionFlags)
    {
        XOMASSERT(m_pOnlinePresence == NULL);
        if (m_pOnlinePresence != NULL)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_246, "Attempt to create an online record when one already exists for user %I64X", GetUserID());
            return XONLINE_E_NOTIFICATION_USER_ALREADY_EXISTS;
        }
        
        m_pOnlinePresence = new COnlinePresence(this);
        if (m_pOnlinePresence == NULL)
        {
            return E_OUTOFMEMORY;
        }
        
        memcpy(&(m_pOnlinePresence->m_sgaddr), psgaddr, sizeof(SGADDR));
        m_pOnlinePresence->m_dwClientVersion = dwClientVersion;
        m_pOnlinePresence->m_dwAuthDataFlags = dwAuthDataFlags;
        m_pOnlinePresence->m_dwTitleID = dwTitleID;
        m_pOnlinePresence->m_dwTitleVersion = dwTitleVersion;
        m_pOnlinePresence->m_dwTitleRegion = dwTitleRegion;
        m_pOnlinePresence->m_xnaddr = xnaddr;
        m_pOnlinePresence->m_xkid = xkid;
        m_pOnlinePresence->m_xnkey = xnkey;
        m_pOnlinePresence->m_ipaXbox = ipaXbox;
        m_pOnlinePresence->m_ipportXbox = ipportXbox;
        memcpy(m_pOnlinePresence->m_szLocale, szLocale, XONLINE_PRESENCE_LOCALE_SIZE);
        m_pOnlinePresence->m_qwVersionFlags = qwVersionFlags;

        // safekeeping.  we just created the online record.  it cant already be time to delete it.
        m_fMarkedForDelete = FALSE;
        
        return S_OK;
    }
    
    DWORD GetState() { return m_dwState; }

    BOOL CanClientConsumeRichPresence()
    {
        if ((m_pOnlinePresence == NULL) ||
            IS_XBOX_MACHINE_PUID(m_pOnlinePresence->m_sgaddr.qwXboxID) ||
            (IS_XENON_MACHINE_PUID(m_pOnlinePresence->m_sgaddr.qwXboxID) && 
            (m_pOnlinePresence->m_dwAuthDataFlags & XONLINE_AUTHDATA_FLAGS_ISXENONBACKCOMPAT) == XONLINE_AUTHDATA_FLAGS_ISXENONBACKCOMPAT))
        {
            return FALSE;
        }

        // everything else can get RP.
        return TRUE;           
    }

    DWORD GetAuthDataFlags() { return m_pOnlinePresence ? m_pOnlinePresence->m_dwAuthDataFlags : 0; }
    void SetAuthDataFlags(DWORD dwAuthDataFlags)
    {
        XOMASSERT(m_pOnlinePresence != NULL);
        if (m_pOnlinePresence == NULL)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_247, "NULL online presence record accessed for user %I64X", GetUserID());
            return;
        }
        m_pOnlinePresence->m_dwAuthDataFlags = dwAuthDataFlags;
    }
    
    MSGTIME GetUserStateChanged() { return m_mtUserStateChanged; }
    void SetUserStateChanged() 
    { 
        FILETIME    ft;
        GetSystemTimeAsFileTime(&ft);        
        m_mtUserStateChanged = FileTimeToMsgTime(&ft); 
    }

    DWORD GetLastSeenTitleID() { return m_dwLastSeenTitleID; }
    void SetLastSeenTitleID(DWORD dwTitleID) { m_dwLastSeenTitleID = dwTitleID; }

    QWORD GetMatchSessionID() { return m_pOnlinePresence ? m_pOnlinePresence->m_qwMatchSessionID : 0; }
    DWORD GetTitleStuffLen() { return m_pOnlinePresence ? m_pOnlinePresence->m_cbTitleStuff : 0; }
    BYTE *GetTitleStuff() { return m_pOnlinePresence ? m_pOnlinePresence->m_pPresenceData : NULL; }
    DWORD GetRichPresenceLen() { return m_pOnlinePresence ? m_pOnlinePresence->m_cbRichPresence : 0; }
    BYTE *GetRichPresenceData() { return m_pOnlinePresence ? m_pOnlinePresence->m_pPresenceData : NULL; }
    DWORD GetNicknameLen() { return m_pOnlinePresence ? m_pOnlinePresence->m_cbNickname : 0; }
    BYTE *GetNickname() { return m_pOnlinePresence ? m_pOnlinePresence->m_rgbNickname : NULL; }
    DWORD GetAcctNameLen() { return m_cbAcctName; }
    LPCSTR GetAcctName() { return m_szAcctName; }

    HRESULT SetAcctName(LPCSTR szNewAcctName, DWORD cbNewAcctName)
    {
        if ((szNewAcctName == NULL) || (cbNewAcctName == 0) || (cbNewAcctName >= XONLINE_GAMERTAG_SIZE))
        {
            return E_INVALIDARG;
        }
        memcpy(m_szAcctName, szNewAcctName, XONLINE_GAMERTAG_SIZE);
        m_cbAcctName = cbNewAcctName;

        return S_OK;
    }

    BYTE *GetCachedLocale() { return m_pOnlinePresence ? m_pOnlinePresence->m_szLocale : (BYTE*)""; }

    DWORD GetNumBuddies() { return (DWORD)m_cBuddies; }
    CBuddyListEntry *GetBuddy(DWORD dwIndex)
    {
        if ((dwIndex < (DWORD)m_cBuddies) && (m_rgCBuddyList != NULL))
        {
            return m_rgCBuddyList + dwIndex;
        }
        else
        {
            return NULL;
        }
    }

    BOOL IsMarkedForDelete() { return m_fMarkedForDelete; }
    void MarkForDelete() { m_fMarkedForDelete = TRUE; }

    BOOL IsMarkedForDeadSG() { return m_fMarkedForDeadSG; }
    void MarkForDeadSG() { m_fMarkedForDeadSG = TRUE; }

    BOOL IsMarkedForMigration() { return m_fMarkedForMigration; }
    void MarkForMigration(CInterfaceBucketChangeContext *pCCtx);

    BOOL IsMigrationInProgress() { return m_fMigrationInProgress; }
    void SetMigrationInProgress(bool fInProgress = TRUE) 
    { 
        m_fMarkedForMigration = FALSE;
        m_fMigrationInProgress = fInProgress; 
    }

    BOOL IsMigrationPending() { return m_fMigrationPending; }
    void SetMigrationPending(BOOL fPending) { m_fMigrationPending = fPending; }

    void ReleaseMigrationContext();

    HRESULT AddDeferredContext(CLocalContext *pCCtx);
    void ProcessDeferredQueue();

    void ForceDBAlive() 
    { 
        m_dwBuddyListVersion = 0xFFFFFFFF; 
        if (m_pOnlinePresence) 
        { 
            m_pOnlinePresence->m_dwBlockListVersion = 0xFFFFFFFF; 
        }
    }

    HRESULT AddBuddy(QWORD qwBuddyID, DWORD dwStatus, DWORD dwVersion);
    HRESULT RemoveBuddy(QWORD qwBuddyID, DWORD dwVersion);

    HRESULT SetAffiliates(CAffiliatesList **pAffiliatesLists);
    
    HRESULT GetAffiliates(DWORD dwListFlag, CAffiliatesList *pAffiliates);
    HRESULT AddAffiliates(DWORD dwFlags, DWORD dwTitleID, MSGTIME mtDateUpdated, WORD cwAffiliates, QWORD *pqwAffiliates);
    HRESULT IsUserAffiliate(QWORD qwUserID, DWORD *pdwFlags);
    BOOL IsAffiliatesListLoaded() { return (m_pOnlinePresence != NULL) && (m_pOnlinePresence->m_prgAffiliateLists != NULL); }
    void StoreAffiliates();
    
    DWORD GetBuddyListVersion() { return m_dwBuddyListVersion; }
    void UpdateBuddyListVersion(DWORD dwVersion) 
    { 
        if ((dwVersion > m_dwBuddyListVersion) || (m_dwBuddyListVersion == 0xFFFFFFFF)) 
            m_dwBuddyListVersion = dwVersion; 
    }

    DWORD GetBlockListVersion() { return m_pOnlinePresence ? m_pOnlinePresence->m_dwBlockListVersion : 0xFFFFFFFF; }
    void UpdateBlockListVersion(DWORD dwVersion) 
    { 
        if (m_pOnlinePresence)
        {
            if ((dwVersion > m_pOnlinePresence->m_dwBlockListVersion) || (m_pOnlinePresence->m_dwBlockListVersion == 0xFFFFFFFF)) 
                m_pOnlinePresence->m_dwBlockListVersion = dwVersion; 
        }
    }


    HRESULT SubscribeBuddy(QWORD qwBuddyID);
    HRESULT UnsubscribeBuddy(QWORD qwBuddyID);

    BOOL IsAcceptedBuddy(QWORD qwBuddyID);
    CBuddyListEntry *FindBuddy(QWORD qwBuddyID);

    CInvitation *GetInvite() { return m_pOnlinePresence ? m_pOnlinePresence->m_pCInvitation : NULL; }
    HRESULT CreateInvite(
        DWORD dwTitleID,
        QWORD qwMatchSessionID,
        DWORD cInvitees,
        const QWORD *rgqwInvitees);
    void DeleteInvite();
    HRESULT AddInvitee(QWORD qwInviteeID);
    HRESULT RemoveInvitee(QWORD qwInviteeID);
    BOOL IsInvited(QWORD qwUserID);

    QWORD GetWebID() { return m_qwWebID; }
    void SetWebID(QWORD qwWebID) { m_qwWebID = qwWebID; }

    void SetPrivileges(BYTE rgbPrivileges[XONLINE_NUM_PRIVILEGE_BYTES]);
    
    void SetLastWebTime() 
    { 
        if (!(m_dwState & P_STATE_MASK_ONLINE) || (m_dwState & P_STATE_MASK_CLOAKED))
        {
            SetUserStateChanged();
            SetLastSeenTitleID(
                0xFFED0000 // Xbox.com TitleID
            );
        }
        m_fMarkedForDelete = FALSE;
    }

    DWORD GetLastActiveTime() { return m_dwLastActive; }
    void SetLastActiveTime() { m_dwLastActive = GetTickCount(); }

    DWORD GetNumWatches() { return m_pOnlinePresence ? m_pOnlinePresence->m_CWatchingList.GetCount() : 0; }
    QWORD *GetWatches() { return m_pOnlinePresence ? m_pOnlinePresence->m_CWatchingList.GetUsers() : NULL; }

    HRESULT AddWatch(QWORD qwUserID)
    {
        XOMASSERT(m_pOnlinePresence != NULL);
        if (m_pOnlinePresence == NULL)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_248, "NULL online presence record accessed for user %I64X", GetUserID());
            return HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
        }
        return m_pOnlinePresence->m_CWatchingList.Add(qwUserID);
    }

    HRESULT RemoveWatch(QWORD qwUserID)
    {
        XOMASSERT(m_pOnlinePresence != NULL);
        if (m_pOnlinePresence == NULL)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_249, "NULL online presence record accessed for user %I64X", GetUserID());
            return HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
        }
        return m_pOnlinePresence->m_CWatchingList.Remove(qwUserID);
    }

    void ClearWatches()
    {
        XOMASSERT(m_pOnlinePresence != NULL);
        if (m_pOnlinePresence == NULL)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_250, "NULL online presence record accessed for user %I64X", GetUserID());
            return;
        }
        m_pOnlinePresence->m_CWatchingList.Clear();
    }

    HRESULT ReplaceWatches(DWORD cNew, const QWORD *pqwNew, DWORD *pcAdd, QWORD *rgqwAdd, DWORD *pcSub, QWORD *rgqwSub)
    {
        XOMASSERT(m_pOnlinePresence != NULL);
        if (m_pOnlinePresence == NULL)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_251, "NULL online presence record accessed for user %I64X", GetUserID());
            return HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
        }
        return m_pOnlinePresence->m_CWatchingList.Replace(cNew, pqwNew, pcAdd, rgqwAdd, pcSub, rgqwSub);
    }

    HRESULT UpdateWatches(DWORD cAdd, QWORD *rgqwAdd, DWORD cSub, QWORD *rgqwSub)
    {
        XOMASSERT(m_pOnlinePresence != NULL);
        if (m_pOnlinePresence == NULL)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_251, "NULL online presence record accessed for user %I64X", GetUserID());
            return HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
        }
        return m_pOnlinePresence->m_CWatchingList.Update(cAdd, rgqwAdd, cSub, rgqwSub);
    }

    DWORD GetNumWatchers() { return m_CWatcherList.GetCount(); }
    QWORD *GetWatchers() { return m_CWatcherList.GetUsers(); }

    HRESULT AddWatcher(QWORD qwUserID)
    {
        HRESULT hr = m_CWatcherList.Add(qwUserID);
        if (hr == S_OK)
        {
            g_Counters.IncrementValue32(XPPERF_SERVER_SUBSCRIPTIONS_TOTAL, 1);
            g_Counters.IncrementValue32(XPPERF_SERVER_PEER_SUBSCRIPTIONS_TOTAL, 1);
        }
        return hr;
    }

    HRESULT RemoveWatcher(QWORD qwUserID)
    {
        HRESULT hr = m_CWatcherList.Remove(qwUserID);
        if (hr == S_OK)
        {
            g_Counters.DecrementValue32(XPPERF_SERVER_SUBSCRIPTIONS_TOTAL, 1);
            g_Counters.DecrementValue32(XPPERF_SERVER_PEER_SUBSCRIPTIONS_TOTAL, 1);
        }
        return hr;
    }

    void SetNeverList( WORD cUsers, QWORD* rgqwUsers );
    const QWORD* GetNeverList() { return m_rgqwNeverList; }
    WORD GetNeverListCount() { return m_cNeverList; }


    HRESULT AddItem(
        DWORD dwQType,
        DWORD cbData,
        const BYTE *pbData,
        DWORD *pdwItemID);

    HRESULT AddXMsgItem(
        const Q_SEND_MESSAGE_MSG* pSendMessage,
        BYTE fSenderIsFriend,
        const BYTE* pbProperties,         // size is in pSendMessage
        DWORD *pdwItemID);

    HRESULT DeleteXMsgBySource(
        QWORD qwSender,
        QWORD qwContext,
        BYTE bType)
    {
        return m_pOnlinePresence ? m_pOnlinePresence->m_rgCQueues[ PQUEUE_TRANSIENT_MSGS ].DeleteXMsgBySource(qwSender, qwContext, bType) : E_UNEXPECTED;
    }

    HRESULT DeleteXMsgItem(
        DWORD dwItemID);

    HRESULT ListItems(
        BOOL fV1ItemsOnly,
        DWORD dwQType,
        DWORD dwStartItemID,
        DWORD* pcMaxItems,        // Specifies the max size on the way in, and the actual size on the way out
        DWORD* pcbMaxItemDataSize,// Specifies the max size on the way in, and the actual size on the way out
        CQueueItem** ppFirstItem,
        DWORD* pdwNextItemID,
        DWORD* pcItemsLeft);

    CQueueItem* GetItem(
        DWORD dwQType,
        DWORD dwItemID);

    DWORD *GetQVals() { return m_pOnlinePresence ? m_pOnlinePresence->m_rgdwQVals : NULL; }
    void ResetV1InviteQFlag();
    void SetXMsgAddQVals(
        const Q_SEND_MESSAGE_MSG* pNewMessage,
        BOOL fSenderIsFriend,
        DWORD dwItemID);
    void SetXMsgDeleteQVals(
        DWORD dwItemID,
        BOOL fSendNow,
        BOOL fPushQVals = TRUE);

    CQueue *GetQueue(DWORD dwQType) 
    { 
        if (m_pOnlinePresence && (dwQType < PQUEUE_NUM_TYPES))
        {
            return & (m_pOnlinePresence->m_rgCQueues[dwQType]); 
        }
        else
        {
            return NULL;
        }
    }

    void ClearAllQs();

    void SetTimeScheduled(DWORD dwTimeScheduled)
    {
        XOMASSERT(m_pOnlinePresence);
        if (m_pOnlinePresence == NULL)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_252, "NULL online presence record accessed for user %I64X", GetUserID());
            return;
        }
        m_pOnlinePresence->m_dwTimeScheduled = dwTimeScheduled;
    }

    DWORD GetTimeScheduled() { return m_pOnlinePresence ? m_pOnlinePresence->m_dwTimeScheduled : 0; }
    DWORD GetPQueueIndex() { return m_pOnlinePresence ? m_pOnlinePresence->m_dwPQueueIndex : ((DWORD)~0); }
    DWORD GetTickleCount() { return m_pOnlinePresence ? m_pOnlinePresence->m_dwTickleCount : 0; }

    void SetPQueueIndex(DWORD dwPQueueIndex)
    {
        XOMASSERT(m_pOnlinePresence);
        if (m_pOnlinePresence == NULL)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_253, "NULL online presence record accessed for user %I64X", GetUserID());
            return;
        }
        m_pOnlinePresence->m_dwPQueueIndex = dwPQueueIndex;
    }

    BOOL IsUserBlocked( QWORD qwUserID );
    void UnblockUsers( const QWORD* rgqwUsers, WORD cUsers );
    void BlockUser( QWORD qwUserID );

    WORD GetNumMessagesToday() { return m_cMessagesToday; }
    WORD GetNumRecipientsToday() { return m_cRecipientsToday; }
    MSGTIME GetTimeFirstMessageSent() { return m_mtMessageThrottle; }

    BOOL HasTransientMessages();

    void SendQVals();
    void SetQValsReply( DWORD dwSeqNum );

    void DeleteExpiredMessages( DWORD dwTime );

    // Parental Controls & Privacy
    BOOL CanPlayOnline()
    {
        return m_PrivMultiplayer;
    }
    
    BOOL CanMessage(QWORD qwTarget)
    {
        if (qwTarget == GetUserID())
            return TRUE;
        
        if ( m_PrivCommunications )
            return TRUE;

        if ( IsAcceptedBuddy(qwTarget) && m_PrivCommunicationsFriendsOnly )
            return TRUE;

        return FALSE;
    }

    BOOL CanSharePresence(QWORD qwTarget)
    {
        if (qwTarget == GetUserID())
            return TRUE;

        if ( m_PrivPresence )
            return TRUE;

        if ( IsAcceptedBuddy(qwTarget) && m_PrivPresenceFriendsOnly)
            return TRUE;

        return FALSE;
    }

    BOOL CanShareFriendsList(QWORD qwTarget)
    {
        if (qwTarget == GetUserID())
            return TRUE;

        if ( m_PrivFriendsList )
            return TRUE;

        if ( IsAcceptedBuddy(qwTarget) && m_PrivFriendsListFriendsOnly)
            return TRUE;

        return FALSE;
    }

    BOOL CanMessage(BOOL fFriend)
    {
        if ( m_PrivCommunications )
            return TRUE;

        if ( fFriend && m_PrivCommunicationsFriendsOnly )
            return TRUE;

        return FALSE;
    }

    BOOL CanSharePresence(BOOL fFriend)
    {
        if ( m_PrivPresence )
            return TRUE;

        if ( fFriend && m_PrivPresenceFriendsOnly)
            return TRUE;

        return FALSE;
    }

    BOOL CanShareFriendsList(BOOL fFriend)
    {
        if ( m_PrivFriendsList )
            return TRUE;

        if ( fFriend && m_PrivFriendsListFriendsOnly)
            return TRUE;

        return FALSE;
    }

    BOOL ThrottledMessageAllowed(WORD cRecipients)
    {
        FILETIME ft;
        SYSTEMTIME st;
        GetSystemTime(&st);
        SystemTimeToFileTime(&st, &ft);
        MSGTIME mtNow = FileTimeToMsgTime(&ft);
        
        if (mtNow >= m_mtMessageThrottle)
        {
            // its a new day!
            m_cMessagesToday = 0;
            m_cRecipientsToday = 0;
        }

        if (HasOnlineRecord() && g_CPresCfg.IsValidOnWatchAddr(m_pOnlinePresence->m_ipaXbox))
        {
            return TRUE;
        }

        // limit on number of actual messages        
        if (m_cMessagesToday + 1 > (WORD)g_CPresCfg.GetMessagingDailySends())
        {
            return FALSE;
        }

        // limit on number of recipients
        if (m_cRecipientsToday + cRecipients > (WORD)g_CPresCfg.GetMessagingDailyRecipients())
        {
            return FALSE;
        }

        // first message of the day starts the timer for that day.
        if (m_cMessagesToday == 0)
        {
            m_mtMessageThrottle = mtNow + 24 * 60 * 60;
        }

        // everything checks out, this message is allowed.
        m_cMessagesToday = m_cMessagesToday + 1;
        m_cRecipientsToday = m_cRecipientsToday + cRecipients;

        return TRUE;
    }

    void RecordUserAlive();

    void SetDebugReference(BOOL fRef) { m_fDebugReference = fRef; }
    BOOL HasDebugReference() { return m_fDebugReference; }

protected:
    void RecordUserKilled();
    
    void RecordPlayStart(DWORD dwState, DWORD dwTitleID, QWORD qwMatchSessionID);
    void RecordPlayStop();
    void RecordTitleChange(DWORD dwTitleID, BOOL fAlive, BOOL fKill);
    void RecordGuestChange(DWORD dwTitleID, DWORD oldState, DWORD newState);
    
    HRESULT IsUserAffiliate(QWORD qwUserID, DWORD * pdwFlags, DWORD *rgIndices);

    void ProcessDeferredQueue(CContextQueueNode *pNode);

    // General presence info
    QWORD m_qwUserID;
    QWORD m_qwNonce;
    DWORD m_dwLastActive;
    MSGTIME m_mtUserStateChanged;
    DWORD m_dwLastSeenTitleID;

    // online data
    COnlinePresence *m_pOnlinePresence;

    // Parent pointer
    CSwitchboard* m_pSwitchboard;

    union
    {
        DWORD m_dwFlags;
        struct
        {
            DWORD   // Privilege flags
                    m_PrivMultiplayer : 1,
                    m_PrivCommunications : 1,
                    m_PrivCommunicationsFriendsOnly : 1,
                    m_PrivPresence : 1,
                    m_PrivPresenceFriendsOnly : 1,

                    // Hash Chain flags 
                    m_fMarkedForDelete : 1,
                    m_fMarkedForDeadSG : 1,

                    // QVals
                    m_fPushQVals : 1,

                    // migration flags
                    m_fMarkedForMigration : 1,
                    m_fMigrationInProgress : 1,
                    m_fMigrationPending : 1,

                    // debug flags
                    m_fDebugReference : 1,
                    
                    // friends privilege.
                    m_PrivFriendsList : 1,
                    m_PrivFriendsListFriendsOnly : 1,

                    // NEW STUFF GOES HERE
                    
                    m_FlagsUnused : 18;
        };
    };
    
    // Web/Alerts integration info
    QWORD m_qwWebID;

    // State info
    DWORD m_dwState;

    // Message Throttling
    WORD m_cMessagesToday;
    WORD m_cRecipientsToday;
    MSGTIME m_mtMessageThrottle;

    // List lengths
    WORD m_cBuddies;
    WORD m_cNeverList;
    
    // Buddy list info
    DWORD m_dwBuddyListVersion;
    CBuddyListEntry *m_rgCBuddyList;

    // Never list info
    QWORD *m_rgqwNeverList;

    // Watch lists
    CUserList m_CWatcherList;

    // Main User Hash Chain
    CPresence *m_pCPresenceNext;
    CPresence *m_pCPresenceBack;

    // migration context reference
    CInterfaceBucketChangeContext *m_pCBucketChangeCtx;
    CContextQueueNode *m_pDeferredQueue;
    
    // Acctname at the end to be cache friendly
    DWORD m_cbAcctName;
    CHAR m_szAcctName[MAX_ACCTNAME_BYTES];
};

/*****************************************************************************

CPresenceUserIndex

Primary index into CPresence by User Id

*****************************************************************************/
class CPresenceUserIndex 
{
public:
    CPresenceUserIndex();
    ~CPresenceUserIndex();

    HRESULT Init();
    void Shutdown();

    HRESULT Resize(DWORD dwNewSize);

    HRESULT CreatePresence(
        CSwitchboard *pSwitchboard,
        QWORD qwUserID,
        QWORD qwNonce,
        DWORD cbAcctName,
        LPCSTR szAcctName,
        QWORD qwUserWebID,
        CPresence **ppCPresence);

    HRESULT AddPresence(CPresence *pCPresence);

    void RemovePresence(CPresence *pCPresence);

    HRESULT FindPresence(QWORD qwUserID, CPresence **ppCPresence, BOOL fOverride = FALSE);

    HRESULT QueueDeferredRequest(QWORD qwUserID, CLocalContext *pCCtx);

    DWORD GetNumBuckets() { return m_cBuckets; }
    CPresence *GetBucket(DWORD dwBucket)
    {
        CPresence *pRet = NULL;
        
        if (dwBucket < m_cBuckets)
        {
            pRet = m_rgpCUserHashTable[dwBucket];
            SAFE_ADDREF(pRet);
        }

        return pRet;
    }

    CPresence *GetNext(CPresence *pCPresence)
    {
        CPresence *pRet = NULL;
        
        if (pCPresence != NULL)
        {
            pRet = pCPresence->m_pCPresenceNext;
            SAFE_ADDREF(pRet);
        }

        return pRet;
    }

protected:

    DWORD Hash(QWORD qwUserID);

    DWORD m_cBuckets;
    CPresence **m_rgpCUserHashTable;
};

/*****************************************************************************

CPresenceXBoxIndex

An index into CPresence by full XBox address

*****************************************************************************/
class CPresenceXBoxIndex 
{
public:
    CPresenceXBoxIndex();
    ~CPresenceXBoxIndex();

    HRESULT Init();

    HRESULT Resize(DWORD dwNewSize);

    void AddPresence(CPresence *pCPresence);
    void RemovePresence(CPresence *pCPresence);

    CPresence *GetFirstEntry(const SGADDR *psgaddr) 
    {
        CPresence *pRet = NULL;
        
        pRet = m_rgpCPresenceXBoxHashTable[Hash(psgaddr)];
        SAFE_ADDREF(pRet);
        
        return pRet;
    }
    CPresence *GetNextEntry(CPresence *pCPresence)
    {
        CPresence *pRet = NULL;
        
        if ((pCPresence != NULL) && (pCPresence->m_pOnlinePresence != NULL))
        {
            pRet = pCPresence->m_pOnlinePresence->m_pCXBoxNext;
            SAFE_ADDREF(pRet);
        }

        return pRet;
    }

protected:
    DWORD Hash(const SGADDR *psgaddr);

    DWORD m_cBuckets;
    CPresence **m_rgpCPresenceXBoxHashTable;
};

/*****************************************************************************

CPresenceSGIndex

An index into CPresence by partial SG address

*****************************************************************************/
class CPresenceSGIndex 
{
public:
    CPresenceSGIndex();
    ~CPresenceSGIndex();

    HRESULT Init();

    HRESULT Resize(DWORD dwNewSize);

    void AddPresence(CPresence *pCPresence);
    void RemovePresence(CPresence *pCPresence);
 
    CPresence *GetFirstEntry(const SGADDR *psgaddr) 
    {
        CPresence *pRet = NULL;
        
        pRet = m_rgpCPresenceSGHashTable[Hash(psgaddr)];
        SAFE_ADDREF(pRet);
        
        return pRet;
    }
    CPresence *GetNextEntry(CPresence *pCPresence)
    {
        CPresence *pRet = NULL;
        
        if ((pCPresence != NULL) && (pCPresence->m_pOnlinePresence != NULL))
        {
            pRet = pCPresence->m_pOnlinePresence->m_pCSGNext;
            SAFE_ADDREF(pRet);
        }

        return pRet;
    }

protected:
    DWORD Hash(const SGADDR *psgaddr);

    DWORD m_cBuckets;
    CPresence **m_rgpCPresenceSGHashTable;
};

/*****************************************************************************

CTicklePriQueue

Priority queue for tickles

*****************************************************************************/
class CTicklePriQueue
{
public:
    CTicklePriQueue() 
    { 
        srand(GetTickCount());
    }
    
    HRESULT Insert(CPresence* pObject);

    HRESULT Peek(DWORD dwIndex, CPresence** ppObject )
    {
        *ppObject = m_CHeap.Peek(dwIndex);

        return S_OK;
    }

    HRESULT Remove(DWORD dwIndex, CPresence** ppObject );

    HRESULT DropObject(CPresence* pObject);

    HRESULT GetCount() { return m_CHeap.GetCount(); }
  
protected:

    class NotifyOnNewPosition
    {
    public:
        void operator()(
            CPresence* p, 
            int iNewIndex
        )
        {
            p->SetPQueueIndex(iNewIndex);
        }
    };

    class Compare
    {
    public:
        int operator()(
            CPresence* a,
            CPresence* b
        )
        {
            return WrapDWORDCompare(a->GetTimeScheduled(), b->GetTimeScheduled());
        }
    };
            
    typedef CDHeap<CPresence*, Compare, 1024, 1024, 4, NotifyOnNewPosition> DHEAP;

    DHEAP m_CHeap;
};

#endif  // __PRESENCE_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\inh\StdAfx.h ===
// Copyright (c) Microsoft Corporation.  All rights reserved

// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#pragma once


#ifdef UNICODE
#undef UNICODE
#endif

#ifdef _UNICODE
#undef _UNICODE
#endif

// Disable warning: conditional expression is constant
// this is caused by the xomtrace macros, which are used everywhere.
#pragma warning( disable : 4127 )

// Disable warning: unreferenced formal parameter
// this is caused by (among other things) our use of OnIoCompletion() which rarely uses all the parameters passed.
#pragma warning (disable : 4100)

#define INCL_WINSOCK_API_TYPEDEFS 1
#include <winsock2.h>
#include <windows.h>
#include <wininet.h>
#include <stdio.h>
#include <stdlib.h>
#include <icecap.h>
#include <atlbase.h>
#include <atlcom.h>

#ifndef ARRAY_ELEMENTS
#define ARRAY_ELEMENTS(x) (sizeof(x) / sizeof(x[0]))
#endif

#ifndef WRAP_DWORD_CMP
#define WRAP_DWORD_CMP
__forceinline int WrapDWORDCompare(DWORD dwLeft, DWORD dwRight)
{
    DWORD dwDiffLR;
    DWORD dwDiffRL;

    if (dwLeft == dwRight)
    {
        return 0;
    }
    else
    {
        // Shorest distance will tell us which is likely later (within 20+ days)
        dwDiffLR = dwRight - dwLeft;
        dwDiffRL = dwLeft - dwRight;

        if (dwDiffLR < dwDiffRL)
        {
            // Right later
            return 1;
        }
        else
        {
            // Left later
            return -1;
        }
    }
}
#endif

#import "mscorlib.tlb" raw_interfaces_only, no_smart_pointers, rename("ReportEvent", "__ReportEvent")
#import "CommonConfig.tlb" raw_interfaces_only, no_smart_pointers
#import "VelocityInterop.tlb" raw_interfaces_only, no_smart_pointers

using namespace XblConfig;
using namespace VelocityInterop;

#undef IMPL_X_NEWDELETE
extern void * __cdecl operator new(size_t len, void *pvPlacement);
extern void __cdecl operator delete(void *pv, void *pvPlacement);

#ifdef _ADDRESS_TRACKING
void TrackNew(void *p);
void TrackDelete(void *p);
#endif

#include <commonconfig.h>
#include "xboxverp.h"
#include "wmsstd.h"
#include "xalloc.h"
#include "xmgmt.h"
#include "dheap.h"
#include "wsockntp.h"
#include "xonlinep.h"
#include "perfapi.h"
#include "presperf.h"
#include "perfctrs.h"
#include "wststore.h"
#include "wsoledbresult.h"
#include "OleDBWrapper.h"
#include "xeventids.h"
#include "ntservice.h"
#include "servsock.h"
#include "tcpcnt.h"
#include "ConfigListener.h"
#include "presconfig.h"
#include "bufferpool.h"
#include "xpserver.h"
#include "xqschema.h"
#include "presence.h"
#include "cliconn.h"
#include "profilestore.h"
#include "pconn.h"
#include "sgcomm.h"
#include "velocityproxy.h"
#include "switchboard.h"
#include "callback.h"
#include "msgutil.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\inh\xpserver.h ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#ifndef XPSERVER_H_INCLUDED
#define XPSERVER_H_INCLUDED

XomImportArea(PresenceLog);
XomImportArea(PresenceDebug);
XomImportArea(TeamsLog);
XomImportArea(Reporting);

#endif  // XPSERVER_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\clientstubtest\main.cs ===
using System;

using xonline.common.config;
using xonline.common.protocol;
using xonline.common.service;

using xonline.server.presence.client;

public class TestApp
{
    public static void Main()
    {
        ulong userid = 2533274917397597;
        string gamertag = XCache.LookupGamerTag(userid);

        PresClient.DeleteUser(userid);

        string gtfound = XCache.LookupGamerTag(userid);
        ulong puidfound = XCache.LookupPUID(gamertag);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\clientstubtest\makefile.inc ===
!include $(INETROOT)\build\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\inh\xpserver.cpp ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#include "stdafx.h"

#define PN_CONFIG_FILE_NAME "xpnconfig.ini"

XomDefineArea(PresenceLog);
XomDefineArea(PresenceDebug);
XomDefineArea(TeamsLog);
XomDefineArea(Reporting);

#ifdef _ADDRESS_TRACKING

#define MAX_TRACKED_ADDRESSES 65536
void *g_rgTrackedAddresses[MAX_TRACKED_ADDRESSES];
int g_cTrackedAddresses = 0;

void TrackNew(void *p)
{
    XOMASSERT(p != NULL);
    XOMASSERT((DWORD)p != 0xdeadbeef);
    XOMASSERT(g_cTrackedAddresses < MAX_TRACKED_ADDRESSES);
    g_rgTrackedAddresses[g_cTrackedAddresses++] = p;
}

void TrackDelete(void *p)
{
    XOMASSERT(p != NULL);
    XOMASSERT((DWORD)p != 0xdeadbeef);
    XOMASSERT(g_cTrackedAddresses > 0);
    
    for (int i = g_cTrackedAddresses - 1; i >= 0; i--)
    {
        if (p == g_rgTrackedAddresses[i])
        {
            g_cTrackedAddresses--;
            memcpy(&g_rgTrackedAddresses[i], &g_rgTrackedAddresses[i + 1], (g_cTrackedAddresses - i) * sizeof(void *));
            g_rgTrackedAddresses[g_cTrackedAddresses] = NULL;
            return;
        }
    }

    // address not tracked.
    XOMASSERT(FALSE);
}

#endif

void * __cdecl operator new(size_t len)
{
    void *pv = XAlloc(len);

//    XomTrace(PresenceDebug, L_LOW, "new() allocating %d bytes, returning address 0x%0X", len, pv);
    
    return pv;
}

void __cdecl operator delete(void *pv)
{
//    XomTrace(PresenceDebug, L_LOW, "delete() freeing address 0x%0X", pv);

#ifdef _ADDRESS_TRACKING

    for (int i = g_cTrackedAddresses - 1; i >= 0; i--)
    {
        if (pv == g_rgTrackedAddresses[i])
        {
            // delete called on a tracked address!
            XOMASSERT(FALSE);
        }
    }

#endif

    XFree(pv);
}

//////////////////////////////////////////////////////////////////////////////
class CXPService : public CNTService
{
public:
    CXPService() :
        CNTService(
            L"XPServer",
            L"Xbox Online Presence Server",
            L"Handles presence services for Xbox users while they are online",
            L"PresPerf",
            Component_xpserver),
        m_pSwitchboard(NULL)
    {
    }

    virtual HRESULT InitService( DWORD dwArgc, LPWSTR *pszArgv )
    {
        HRESULT hr = S_OK;
        
        // Init core logging and tracing
        hr = g_xomcentral.Init("Presence", NULL, "xpserver");

        if(FAILED(hr))
        {
            XomNtEvent(XEVENT_PRESENCE_CONFIG_78, "Unrecoverable failure while initializing: Failed to init g_xomcentral: hr=0x%X", hr);
            goto lDone;
        }

        hr = g_xomcentral.RegisterControlCallback(&g_ControlCallback);

        if(FAILED(hr))
        {
            XomNtEvent(XEVENT_PRESENCE_CONFIG_79, "Unrecoverable failure while initializing: Failed to register control callback function: hr=0x%X", hr);
            goto lDone;
        }

        XomNtEvent(XEVENT_PRESENCE_INFO_18, "Presence starting...");

        // Initialize Winsock
        WSADATA wsaData;

        int rc = WSAStartup( MAKEWORD( 2, 2 ), &wsaData );
        if( 0 != rc )
        {
            hr = HRESULT_FROM_WIN32( WSAGetLastError() );
            XomNtEvent(XEVENT_PRESENCE_CONFIG_80, "Unrecoverable failure while initializing: WSAStartup failed hr=0x%X", hr);
            goto lDone;
        }
        Checkpoint();

        hr = g_CPresCfg.Init();
        if(FAILED(hr))
        {
            XomNtEvent(XEVENT_PRESENCE_CONFIG_81, "Unrecoverable failure while initializing: Load configuration failed hr=0x%X", hr);
            goto lDone;
        }
        Checkpoint();

        if (g_CPresCfg.GetStoreStateInVelocity())
        {
            hr = g_VelocityProxy.Init();
            if (FAILED(hr))
            {
                XomNtEvent(XEVENT_PRESENCE_CONFIG_VELOCITY_INIT, "Unrecoverable failure while initializing: Velocity initialization failed hr=0x%X", hr);
                goto lDone;
            }
            Checkpoint();
        }

        // Initialize perfmon counters
        hr = g_Counters.Init();
        if( FAILED( hr ) )
        {
            XomNtEvent(XEVENT_PRESENCE_CONFIG_82, "Unrecoverable failure while initializing: Failed to init perf counters hr=0x%X", hr);
            goto lDone;
        }

        g_rgdwMaxAffiliates[X_AFFILIATE_ENCOUNTERED_INDEX] = g_CPresCfg.GetAffiliatesEncounteredListSize();
        g_rgdwMaxAffiliates[X_AFFILIATE_COMPLETED_GAME_INDEX] = g_CPresCfg.GetAffiliatesCompletedGameListSize();
        g_rgdwMaxAffiliates[X_AFFILIATE_POSITIVE_FEEDBACK_INDEX] = g_CPresCfg.GetAffiliatesPositiveFeedbackListSize();
        g_rgdwMaxAffiliates[X_AFFILIATE_NEGATIVE_FEEDBACK_INDEX] = g_CPresCfg.GetAffiliatesNegativeFeedbackListSize();
        g_rgdwMaxAffiliates[X_AFFILIATE_AVOIDING_ME_INDEX] = g_CPresCfg.GetAffiliatesAvoidingMeListSize();
        g_rgdwMaxAffiliates[X_AFFILIATE_FAVORITES_INDEX] = g_CPresCfg.GetAffiliatesFavoritesListSize();

        g_pBufferPool = new BufferPool();
        if (g_pBufferPool == NULL)
        {
            XomNtEvent(XEVENT_PRESENCE_CONFIG_83, "Unrecoverable failure while initializing: Send Buffer Pool == NULL");
            goto lDone;
        }

        g_pCPresenceInfoContextQueue = new CPresenceInfoContextQueue();
        if (g_pCPresenceInfoContextQueue == NULL)
        {
            XomNtEvent(XEVENT_PRESENCE_CONFIG_84, "Unrecoverable failure while initializing: Presence Info Context Queue == NULL");
            goto lDone;
        }
        
        Checkpoint();

        // Intialize the indexes
        hr = g_CPresenceUserIndex.Init();
        if( FAILED( hr ) )
        {
            XomNtEvent(XEVENT_PRESENCE_CONFIG_85, "Unrecoverable failure while initializing: Failed to init User Index hr=0x%X", hr);
            goto lDone;
        }
        hr = g_CPresenceXBoxIndex.Init();
        if( FAILED( hr ) )
        {
            XomNtEvent(XEVENT_PRESENCE_CONFIG_86, "Unrecoverable failure while initializing: Failed to init XBox Index hr=0x%X", hr);
            goto lDone;
        }
        hr = g_CPresenceSGIndex.Init();
        if( FAILED( hr ) )
        {
            XomNtEvent(XEVENT_PRESENCE_CONFIG_87, "Unrecoverable failure while initializing: Failed to init SG Index hr=0x%X", hr);
            goto lDone;
        }
        Checkpoint();

        // Create networking worker threads listening on the designated port
        m_pSwitchboard = new CSwitchboard;
        if( NULL == m_pSwitchboard )
        {
            XomNtEvent(XEVENT_PRESENCE_CONFIG_88, "Unrecoverable failure while initializing: Failed to allocate switchboard");
            hr = E_OUTOFMEMORY;
            goto lDone;
        }

        hr = m_pSwitchboard->Init();
        if( FAILED( hr ) )
        {
            XomNtEvent(XEVENT_PRESENCE_CONFIG_89, "Unrecoverable failure while initializing: Failed to init switchboard hr=0x%X", hr);
            goto lDone;
        }

        g_ControlCallback.Init(m_pSwitchboard);

        Checkpoint();

lDone:
        if (FAILED(hr))
        {
            XomNtEvent(XEVENT_PRESENCE_CONFIG_90, "Unrecoverable failure while initializing: InitService returning hr=0x%X", hr);
        }

        return( hr );
    }

    virtual HRESULT RunService( BOOL *pfServiceRan )
    {
        if (m_pSwitchboard == NULL)
        {
            return E_UNEXPECTED;
        }
        if (pfServiceRan == NULL)
        {
            return E_INVALIDARG;
        }

        *pfServiceRan = TRUE;

        XomNtEvent(XEVENT_PRESENCE_INFO_19, "Presence started");

        //
        // Have this thread hang out until the server is told to shut down, waking
        // up once in a while to let the switchboard have periodic heartbeats.
        //
        for(;;)
        {
            DWORD dwRes = WaitForSingleObject(ShutdownEvent(), g_CPresCfg.GetHeartbeatDelay());

            if( WAIT_TIMEOUT == dwRes )
            {
#ifdef ICECAP_BUILD
                StartProfile(PROFILE_THREADLEVEL, PROFILE_CURRENTID);
#endif
                m_pSwitchboard->OnHeartbeat();
#ifdef ICECAP_BUILD
                StopProfile(PROFILE_THREADLEVEL, PROFILE_CURRENTID);
#endif
            }
            else
            {
                break;
            }
        }

        XomNtEvent(XEVENT_PRESENCE_INFO_20, "Presence stopping...");

        ChangeState(SERVICE_STOP_PENDING);

        // this has to get deleted before switchboard.  it will purge any pending contexts, and they might reference switchboard.
        SAFE_DELETE(g_pCPresenceInfoContextQueue);

        g_VelocityProxy.Close();

        g_CPresCfg.Shutdown();

        g_CPresenceUserIndex.Shutdown();

        // wait for users to delete before shutting down switchboard.
        DWORD dwMaxWaitSeconds = 10;
        while ((dwMaxWaitSeconds > 0) && (g_Counters.GetCurrentValue32(XPPERF_SERVER_TOTAL_USERS_COUNTER) > 0))
        {
            dwMaxWaitSeconds--;
            Sleep(1000);
            Checkpoint(dwMaxWaitSeconds * 1000);
        }

        m_pSwitchboard->Shutdown();

        SAFE_DELETE(g_pBufferPool);

        WSACleanup();

        XomNtEvent(XEVENT_PRESENCE_INFO_21, "Presence stopped");

        g_xomcentral.Term();

        XDumpLeaks();

        return S_OK;
    }

protected:
    CSwitchboard *m_pSwitchboard;
};

static CXPService g_Service;
CNTService *g_pService = &g_Service;

//////////////////////////////////////////////////////////////////////////////
int __cdecl wmain( int argc, WCHAR *argv[] )
{
    return( g_Service.ProcessMain( argc, argv ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\inh\xqschema.cpp ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#include "stdafx.h"

// CONSIDER: Calc sizes from structure definitions

Q_SCHEMA g_QSchemas[ PQUEUE_NUM_TYPES ] = {
    {   // Type 0 holds incomming friend request list changes - see P_LIST_CHANGE_ITEM in xonlinep.h
        0xffffffff, // dwMaxItems
        20,         // dwMinDataSize
        84,         // dwMaxDataSize
        TRUE,       // fAllowDups
        0,          // dwDupAttrOffset
        0,          // dwDupAttrLen
    },
    {   // Type 1 holds all other list changes - see P_LIST_CHANGE_ITEM in xonlinep.h
        0xffffffff, // dwMaxItems
        20,         // dwMinDataSize
        84,         // dwMaxDataSize
        TRUE,       // fAllowDups
        0,          // dwDupAttrOffset
        0,          // dwDupAttrLen
    },
    {   // Type 2 holds presence items - see P_PRESENCE_ITEM in xonlinep.h
        0xffffffff, // dwMaxItems
        28,         // dwMinDataSize
        60,         // dwMaxDataSize
        TRUE,      // fAllowDups
        0,          // dwDupAttrOffset
        8,          // dwDupAttrLen
    },
    {   // Type 3 holds invitation items - see P_INVITATION_ITEM in xonlinep.h
        0xffffffff, // dwMaxItems
        28,         // dwMinDataSize
        28,         // dwMaxDataSize
        FALSE,      // fAllowDups
        0,          // dwDupAttrOffset
        8,          // dwDupAttrLen
    },
    {   // Type 4 holds invitation answer items - see P_INVITATION_ANS_ITEM in xonlinep.h
        0xffffffff, // dwMaxItems
        26,         // dwMinDataSize
        26,         // dwMaxDataSize
        FALSE,      // fAllowDups
        0,          // dwDupAttrOffset
        8,          // dwDupAttrLen
    },
    {   // Type 5 holds transient messages - see Q_MESSAGE_SUMMARY in xonlinep.h
        MAX_TRANSIENT_MESSAGES,                            // dwMaxItems
        sizeof( Q_MESSAGE_SUMMARY ),                       // dwMinDataSize
        sizeof( Q_MESSAGE_SUMMARY ) + XONLINE_MAX_MESSAGE_DETAILS + sizeof( P_INVITATION_ITEM ), // dwMaxDataSize
        TRUE,                                              // fAllowDups
        0,                                                 // dwDupAttrOffset
        0,                                                 // dwDupAttrLen
    },
    {   // Type 6 holds peer presence items - see P_PEER_PRESENCE_ITEM in xonlinep.h
        0xffffffff,                                           // dwMaxItems
        sizeof(P_PEER_PRESENCE_ITEM),                         // dwMinDataSize
        sizeof(P_PEER_PRESENCE_ITEM) + MAX_TITLE_STATE_BYTES, // dwMaxDataSize
        TRUE,                                                // fAllowDups
        0,                                                    // dwDupAttrOffset
        8,                                                    // dwDupAttrLen
    },
    {   // Type 7 holds rich presence items - see P_PRESENCE_2_ITEM in xonlinep.h
        0xffffffff,                                           // dwMaxItems
        sizeof(P_PRESENCE_2_ITEM),                            // dwMinDataSize
        sizeof(P_PRESENCE_2_ITEM) + MAX_TITLE_DATA_BYTES,     // dwMaxDataSize
        TRUE,                                                // fAllowDups
        0,                                                    // dwDupAttrOffset
        8,                                                    // dwDupAttrLen
    },
};
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\inh\VelocityProxy.h ===
#pragma once

class VelocityProxy
{
public:
    VelocityProxy() :
        m_fInit(FALSE)
    {
    }
    
    HRESULT Init()
    {
        HRESULT hr = S_OK;

        if (m_fInit)
        {
            hr = S_FALSE;
            goto lDone;
        }

        hr = m_pVelocity.CoCreateInstance(__uuidof(AccelerationInteropImpl));
        if (FAILED(hr))
        {
            goto lDone;
        }

        hr = m_pVelocity->Init();
        if (FAILED(hr))
        {
            goto lDone;
        }

/*
        hr = m_pVelocity.CoCreateInstance(__uuidof(VelocityInteropImpl));
        if (FAILED(hr))
        {
            goto lDone;
        }

        hr = g_CPresCfg.LoadVelocityServers();
        if( FAILED( hr ) )
        {
            XomNtEvent( XEVENT_PRESENCE_CONFIG_VELOCITY_DISCOVERY, "VelocityProxy::Init() - Failed to load Velocity servers from npdb, hr=0x%08X", hr );
            goto lDone;
        }
        
        hr = m_pVelocity->Init_2(
            g_CPresCfg.GetVelocityServers(),
            g_CPresCfg.GetVelocityPorts(),
            1,
            0,
            CComBSTR(Interface_XNotiCache));
        if (FAILED(hr))
        {
            goto lDone;
        }
*/

        m_fInit = TRUE;

lDone:
        return hr;
    }

    HRESULT Close()
    {
        if (!m_fInit)
        {
            return E_UNEXPECTED;
        }
        
        m_pVelocity.Release();
        m_fInit = FALSE;
        
        return S_OK;
    }

    HRESULT Put(CHAR *szKey, DWORD cbValue, BYTE *rgbValue)
    {
        HRESULT hr = S_OK;       
        SAFEARRAY sa = {0};

        if (!m_fInit)
        {
            hr = E_UNEXPECTED;
            goto lDone;
        }

        sa.rgsabound[0].lLbound = 0;
        sa.rgsabound[0].cElements = cbValue;
        sa.cDims = 1;
        sa.cbElements = 1;
        sa.pvData = rgbValue;

        hr = m_pVelocity->Put(CComBSTR(szKey), &sa);

lDone:
        return hr;
    }

    HRESULT Get(CHAR *szKey, DWORD *pcbValue, BYTE *rgbValue)
    {
        HRESULT hr = S_OK;
        
        if (!m_fInit)
        {
            hr = E_UNEXPECTED;
            goto lDone;
        }

        SAFEARRAY *psa;
        BYTE *pData = NULL;

        hr = m_pVelocity->Get(CComBSTR(szKey), &psa);
        if (FAILED(hr))
        {
            goto lDone;
        }

        if (psa->rgsabound[0].cElements > *pcbValue)
        {
            *pcbValue = psa->rgsabound[0].cElements;
            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            goto lDone;
        }

        *pcbValue = psa->rgsabound[0].cElements;
        hr = SafeArrayAccessData(psa, (void **)&pData);
        if (FAILED(hr))
        {
            goto lDone;
        }

        memcpy(rgbValue, pData, *pcbValue);

lDone:
        if (pData != NULL)
        {
            SafeArrayUnaccessData(psa);
        }

        if (psa != NULL)
        {
            SafeArrayDestroy(psa);
        }

        return hr;
    }

private:
    CComPtr<IVelocity> m_pVelocity;
    BOOL m_fInit;

};

extern VelocityProxy g_VelocityProxy;
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\inh\xqschema.h ===
// Copyright (c) Microsoft Corporation.  All rights reserved

struct Q_SCHEMA
{
    BOOL IsValid()
    {        
        // Check for valid length
        if (dwMaxItems <= 0)
        {
            return FALSE;
        }
        
        // Check size restrictions
        if (dwMinDataSize > dwMaxDataSize)
        {
            return FALSE;
        }

        // Min size must hold all mandatory fields
        if(!fAllowDups)
        {
            if ((dwDupAttrLen <= 0) || (dwMinDataSize < (dwDupAttrOffset + dwDupAttrLen)))
            {
                return FALSE;
            }
        }

        // Note: not checking for field overlap since it's too painful

        return TRUE;
    }

    void Dump()
    {
        XomTrace(PresenceDebug, L_NORMAL, "   dwMaxItems         = 0x%x", dwMaxItems );
        XomTrace(PresenceDebug, L_NORMAL, "   dwMinDataSize      = 0x%x", dwMinDataSize );
        XomTrace(PresenceDebug, L_NORMAL, "   dwMaxDataSize      = 0x%x", dwMaxDataSize );
        XomTrace(PresenceDebug, L_NORMAL, "   fAllowDups         = %d", fAllowDups );
        XomTrace(PresenceDebug, L_NORMAL, "   dwDupAttrOffset    = %d", dwDupAttrOffset );
        XomTrace(PresenceDebug, L_NORMAL, "   dwDupAttrLen       = %d", dwDupAttrLen );
    }

    //
    // Public configurable Q schema parameters
    //
    DWORD dwMaxItems;

    DWORD dwMinDataSize;
    DWORD dwMaxDataSize;

    BOOL fAllowDups;
    DWORD dwDupAttrOffset;
    DWORD dwDupAttrLen;
};

extern Q_SCHEMA g_QSchemas[ PQUEUE_NUM_TYPES ];
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\inh\switchboard.h ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#ifndef SWITCHBOARD_H_INCLUDED
#define SWITCHBOARD_H_INCLUDED

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

extern const SGADDR sgaddrIgnore;

class CSwitchboard;
class SendMessageReplyHandler;
class CSendMessageExternalContext;
class CCheckTitleMessagesContext;
class CPresenceInfoContextQueue;
class CInterfaceBucketChangeContext;

extern CInterfaceBucketChangeContext *g_pCInterfaceBucketChangeContextQueue;
extern CPresenceInfoContextQueue *g_pCPresenceInfoContextQueue;
extern BOOL g_bSwitchboardTooBusy;
extern DWORD g_dwSwitchboardTooBusyTimeout;
extern BOOL g_bSimulateTooBusy;
extern HANDLE g_hControlCallbackEvent;

using namespace XONLINE_SUBNOTI;

// Turn this on to get events when operations take longer than a threshold (5 secs)
//#define INSTRUMENTED

/*****************************************************************************

CScopeTimer

This object times how long it is in scope.

*****************************************************************************/
class CScopeTimer
{
public:
    CScopeTimer( DWORD dwAvgCounter, DWORD dwBaseCounter ) :
        m_dwAvgCounter( dwAvgCounter ),
        m_dwBaseCounter( dwBaseCounter )
    {
        m_dwStartTime = GetTickCount();
    }
    ~CScopeTimer()
    {
        DWORD dwElapsed = GetTickCount() - m_dwStartTime;

        g_Counters.IncrementValue64(
            m_dwAvgCounter,
            dwElapsed );

        g_Counters.IncrementValue32(
            m_dwBaseCounter,
            1 );

#ifdef INSTRUMENTED
        if( 5000 < dwElapsed )
        {
            XomNtEvent( XEVENT_PRESENCE_HACK_213, "CScopeTimer::~CScopeTimer - took longer than threshold (%d ms, file='%s', line=%d)", dwElapsed, m_pszFile, m_dwLine );
        }
#endif // INSTRUMENTED
    }

private:
    DWORD m_dwStartTime;
    DWORD m_dwAvgCounter;
    DWORD m_dwBaseCounter;
};

/*****************************************************************************

CLocalContext

This object wraps the servhlp completion objects so that we can do service-specific
validation.

*****************************************************************************/
class CLocalContext :
    public CCompletionContext,
    public CCompletionHandler
{
public:
    CLocalContext() :
        m_dwTime( 0 ),
        m_type( PostUnknown )
    {
    }
    virtual ~CLocalContext()
    {
    }

    enum PostType
    {
        PostUnknown = 0,
        PostSwitchboard,
        PostSql,
    };

    void SetPostData( PostType type )
    {
        XOMASSERT( 0 == m_dwTime );
        m_dwTime = GetTickCount();
        m_type = type;
    }

    void CheckIoCompletion( PostType type )
    {
        DWORD dwElapsed = GetElapsedTime();
#ifdef INSTRUMENTED
        if( 5000 < dwElapsed )
        {
            XomNtEvent( XEVENT_PRESENCE_HACK_214, "CLocalContext::CheckIoCompletion - item sat in queue for too long (%d ms, desc='%s')", dwElapsed, GetContextDesc() );
        }
#endif // INSTRUMENTED

        if( type != m_type )
        {
            XomNtEvent( XEVENT_PRESENCE_HACK_215, "CLocalContext::CheckIoCompletion - post type does not match completion type (%d != %d), desc='%s'", m_type, type, GetContextDesc() );
        }

        if( PostSwitchboard == m_type )
        {
            /*
            // removing this becaues it causes too many errors for xbox.com, xbox clients, and the event log.
            if (dwElapsed > g_dwSwitchboardTooBusyTimeout)
            {
                g_bSwitchboardTooBusy = TRUE;
            }
            else
            {
                g_bSwitchboardTooBusy = FALSE;
            }
            */

            g_Counters.IncrementValue64(
                XPPERF_SERVER_SWITCHBOARD_QUEUE_WAIT_TIME_AVERAGE,
                dwElapsed );

            g_Counters.IncrementValue32(
                XPPERF_SERVER_SWITCHBOARD_QUEUE_WAIT_TIME_BASE,
                1 );
        }
        else if( PostSql == m_type )
        {
            g_Counters.IncrementValue64(
                XPPERF_SERVER_SQL_QUEUE_WAIT_TIME_AVERAGE,
                dwElapsed );

            g_Counters.IncrementValue32(
                XPPERF_SERVER_SQL_QUEUE_WAIT_TIME_BASE,
                1 );
        }
    }

    virtual const char* GetContextDesc() = 0;

    virtual void CompletionProc() = 0;

    virtual void OnIoCompletion(
        DWORD dwError,
        DWORD cbTransferred,
        ULONG_PTR ulpKey,
        CCompletionContext *pCtx )
    {
        XOMASSERT(pCtx == this);

        DWORD dwStartTime = GetTickCount();
        PostType type = m_type;

        // this only works because all of the implementations of GetContextDesc() return static strings.  if that fact ever changes, this will break.
        const char *szDescription = GetContextDesc();

        // call the overriden proc.
        CompletionProc();

        DWORD dwElapsedTime = GetTickCount() - dwStartTime;

        if ((type == PostSwitchboard) && (dwElapsedTime > g_CPresCfg.GetContextDurationAlertLimit()))
        {
            XomNtEvent( XEVENT_PRESENCE_HACK_214, "CLocalContext::OnIoCompletion - switchboard context took too long to process! (%d ms, desc='%s')", dwElapsedTime, szDescription );
        }
    }


private:
    DWORD GetElapsedTime()
    {
        XOMASSERT( 0 != m_dwTime );
        DWORD dwElapsed = GetTickCount() - m_dwTime;
        m_dwTime = 0;
        return dwElapsed;
    }

    DWORD m_dwTime;
    PostType m_type;
};

/*****************************************************************************

CPresenceInfoContext

Stores context objects that are waiting for network data.

*****************************************************************************/

class CPresenceInfoContext
{
public:

    CPresenceInfoContext() :
        m_dwContextID(0),
        m_qwUserID(0),
        m_cPendingServerReplies(0),
        m_rgPUIDs(NULL),
        m_cdwPUIDs(0),
        m_pNext(NULL)
    {
    }

    virtual ~CPresenceInfoContext()
    {
        delete[] m_rgPUIDs;
    }

    virtual ULONG AddRef() = 0;
    virtual ULONG Release() = 0;

    virtual HRESULT ApplyPresenceData(DWORD cdwPUIDs, P_PRESENCE_INFO_DATA_MSG *pReply) = 0;

    // we use this function to forcibly terminate the pending requests.
    HRESULT TerminateRequest()
    {
        HRESULT hr = S_OK;

        // set the pending count to 1, and then fake the last apply message.
        // TODO: find a way to enforce that this will work.

        if (m_cPendingServerReplies > 0)
        {
            m_cPendingServerReplies = 1;
            hr = ApplyPresenceData(0, NULL);
        }
        else
        {
            // if we got here, somebody forgot to remove the context after it completed.
            XomNtEvent(
                XEVENT_PRESENCE_CODE_485,
                "CPresenceInfoContext::TerminateRequest() called when m_cPendingServerReplies == 0.  user = %I64X, context = %d",
                m_qwUserID,
                m_dwContextID);
        }

       return hr;
    }

    QWORD m_qwUserID;
    DWORD m_dwContextID;
    DWORD m_cdwPUIDs;
    QWORD *m_rgPUIDs;

    DWORD m_dwTime;
    DWORD m_cPendingServerReplies;

    CPresenceInfoContext *m_pNext;
};

/*****************************************************************************

CPendingContextQueue

Stores context objects that are waiting for network data.

*****************************************************************************/

class CPresenceInfoContextQueue
{
public:

    CPresenceInfoContextQueue() :
        m_pHead(NULL),
        m_pTail(NULL),
        m_dwNextContext(1)
    {
    }

    ~CPresenceInfoContextQueue()
    {
        while (m_pHead != NULL)
        {
            CPresenceInfoContext *pVictim = m_pHead;
            m_pHead = m_pHead->m_pNext;

            pVictim->TerminateRequest();
            pVictim->Release();
        }
    }

    BOOL IsEmpty() { return (m_pHead == NULL); }

    void Insert(CPresenceInfoContext *pCCtx)
    {
        XOMASSERT(pCCtx != NULL);

        pCCtx->AddRef();
        pCCtx->m_pNext = NULL;
        pCCtx->m_dwTime = GetTickCount();
        pCCtx->m_dwContextID = m_dwNextContext++;

        if (m_dwNextContext == 0)
            m_dwNextContext = 1;

        if (IsEmpty())
        {
            m_pHead = pCCtx;
        }
        else
        {
            m_pTail->m_pNext = pCCtx;
        }

        m_pTail = pCCtx;
    }

    void Remove(CPresenceInfoContext *pCCtx)
    {
        if ((pCCtx == NULL) || IsEmpty())
        {
            return;
        }

        if (m_pHead == pCCtx)
        {
            m_pHead = m_pHead->m_pNext;
            if (m_pTail == pCCtx)
            {
                m_pTail = m_pHead;
            }

            pCCtx->m_pNext = NULL;
            pCCtx->Release();
        }
        else
        {
            for (CPresenceInfoContext *pQ = m_pHead; pQ->m_pNext != NULL; pQ = pQ->m_pNext)
            {
                if (pQ->m_pNext == pCCtx)
                {
                    pQ->m_pNext = pCCtx->m_pNext;

                    if (pQ->m_pNext == NULL)
                    {
                        m_pTail = pQ;
                    }

                    pCCtx->m_pNext = NULL;
                    pCCtx->Release();
                    break;
                }
            }
        }
    }

    CPresenceInfoContext *Find(QWORD qwUserID, DWORD dwContextID)
    {
        for (CPresenceInfoContext *pQ = m_pHead; pQ != NULL; pQ = pQ->m_pNext)
        {
            if ((pQ->m_qwUserID == qwUserID) && (pQ->m_dwContextID == dwContextID))
            {
                return pQ;
            }
        }

        return NULL;
    }

    void Purge(DWORD dwNow)
    {
        CPresenceInfoContext *pVictim = NULL;

        // list is sorted by time.  all expired items will be at the head.
        while (!IsEmpty() &&
            WrapDWORDCompare(dwNow, m_pHead->m_dwTime + g_CPresCfg.GetMessageTimeout()) < 0)
        {
            pVictim = m_pHead;
            m_pHead = m_pHead->m_pNext;

            pVictim->m_pNext = NULL;
            pVictim->TerminateRequest();
            pVictim->Release();
        }
    }

private:
    CPresenceInfoContext *m_pHead;
    CPresenceInfoContext *m_pTail;
    DWORD m_dwNextContext;
};


/*****************************************************************************

CHeartbeatHandler

This object is posted to the main IO Completion port on a regular interval to
do maintainece processing such as retrying dead connections, cleanup, etc.

*****************************************************************************/
class CHeartbeatHandler :
    public CCompletionContext,
    public CCompletionHandler
{
public:
    CHeartbeatHandler( CSwitchboard *pSwitchboard ) :
        m_pSwitchboard( pSwitchboard )
    {
    }

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual ULONG AddRef();
    virtual ULONG Release();

    virtual void OnIoCompletion(
        DWORD dwError,
        DWORD cbTransferred,
        ULONG_PTR ulpKey,
        CCompletionContext *pCtx );

protected:
    CSwitchboard *m_pSwitchboard;
};

/*****************************************************************************

CSwitchboard

Main object for most service tasks.  Holds the main IO Completion port,
listening socket and instances other major objects.

*****************************************************************************/
class CSwitchboard
{
public:
    CSwitchboard();
    ~CSwitchboard();

    IMPLEMENT_REFCOUNT;

    HRESULT Init();

    void Shutdown();

    HRESULT PostCompletion( CLocalContext *pCCtx )
    {
        if (m_pCompPort == NULL)
        {
            return E_UNEXPECTED;
        }
        pCCtx->SetPostData( CLocalContext::PostSwitchboard );
        return m_pCompPort->PostCompletion( pCCtx );
    }

    CCompletionPort* GetCompletionPort() { return m_pCompPort; }
    CXPCluster *GetPCluser() { return &m_CXPCluster; }
    CClientListener *GetClientListener() {return &m_CClientListener; }
    CSGCommunicator* GetSGComm() { return &m_CSGComm; }
    CProfileStore *GetProfileStore() { return &m_CProfileStore; }

    // Heartbeat
    void OnHeartbeat();

    void PeriodicHeartbeat();
    void UserMaintainence();
    void SendQVals();

    // Messages from users

    HRESULT LogonCheck(
        SGADDR sgaddr,
        QWORD qwUserID);

    HRESULT Alive(
        SGADDR sgaddr,
        QWORD qwUserID,
        DWORD cbAcctName,
        LPCSTR szAcctName,
        DWORD dwClientVersion,
        DWORD dwBuddyListVersion,
        DWORD dwBlockListVersion,
        QWORD qwNonce,
        DWORD dwAuthDataFlags,
        DWORD dwTitleID,
        DWORD dwAltTitleID1,
        DWORD dwAltTitleID2,
        DWORD dwAltTitleID3,
        DWORD dwAltTitleID4,
        DWORD dwTitleVersion,
        DWORD dwTitleRegion,
        XNADDR xnaddr,
        XNKID xkid,
        XNKEY xnkey,
        IN_ADDR ipaXbox,
        WORD ipportXbox,
        BYTE *szLocale,
        QWORD qwVersionFlags,
        CClientConnection *pCReplyConn,
        DWORD dwSeqNum);

    HRESULT CheckTitleMessages(
        QWORD qwUserID,
        DWORD dwTitleID,
        DWORD dwAltTitleID1,
        DWORD dwAltTitleID2,
        DWORD dwAltTitleID3,
        DWORD dwAltTitleID4,
        DWORD dwTitleRegion,
        DWORD dwTitleVersion,
        CClientConnection *pCReplyConn,
        DWORD dwSeqNum);

    HRESULT Sync(
        SGADDR sgaddr,
        QWORD qwUserID,
        DWORD dwBuddyListVersion,
        DWORD dwBlockListVersion,
        CClientConnection *pCReplyConn,
        DWORD dwSeqNum);

    HRESULT Add(
        SGADDR sgaddr,
        DWORD dwSeqNum,
        QWORD qwUserID,
        QWORD qwBuddyID,
        DWORD dwMessageFlags,
        WORD cbDetails,
        const BYTE* pbDetails,
        LPCSTR pszBuddyAcctName,
        QWORD *pqwNonce);

    HRESULT AddAffiliates(
        SGADDR sgaddr,
        QWORD qwUserID,
        DWORD dwListFlag,
        DWORD dwTitleID,
        WORD cwAffiliates,
        QWORD *pqwAffiliates);

    HRESULT IsAffiliate(
        SGADDR sgaddr,
        DWORD dwSeqNum,
        QWORD qwUserID,
        QWORD qwAffiliateID,
        CClientConnection *pCReplyConn);

    HRESULT QueryAffiliates(
        SGADDR sgaddr,
        DWORD dwSeqNum,
        QWORD qwUserID,
        DWORD dwListFlags,
        DWORD cdwLimit,
        DWORD dwTitleID,
        CClientConnection *pCReplyConn);

    HRESULT GetPresenceInfo(
        DWORD dwContext,
        QWORD qwSenderID,
        DWORD cdwUsers,
        QWORD *rgUsers,
        BOOL fFromPresence,
        CTCPCntMessageBased<CTCPCntMessageBasedPlugin_PN> *pCReplyConn);

    HRESULT PresenceInfoReply(
        DWORD dwContext,
        QWORD qwUserID,
        DWORD cdwUsers,
        P_PRESENCE_INFO_DATA_MSG* rgReply);

    HRESULT Delete(
        SGADDR sgaddr,
        DWORD dwSeqNum,
        QWORD qwUserID,
        QWORD qwExBuddyID,
        QWORD *pqwNonce);

    HRESULT Block(
        SGADDR sgaddr,
        DWORD dwSeqNum,
        QWORD qwUserID,
        QWORD qwBlockID,
        QWORD *pqwNonce);

    HRESULT Unblock(
        SGADDR sgaddr,
        DWORD dwSeqNum,
        QWORD qwUserID,
        QWORD qwBlockID,
        QWORD *pqwNonce);

    HRESULT Accept(
        SGADDR sgaddr,
        DWORD dwSeqNum,
        QWORD qwUserID,
        QWORD qwNewBuddyID,
        QWORD *pqwNonce);

    HRESULT Reject(
        SGADDR sgaddr,
        DWORD dwSeqNum,
        QWORD qwUserID,
        QWORD qwNonBuddyID,
        BOOL fNever,
        QWORD *pqwNonce);

    HRESULT Invite(
        SGADDR sgaddr,
        QWORD qwUserID,
        DWORD dwTitleID,
        QWORD qwMatchSessionID,
        WORD cInviteeIDs,
        const QWORD *rgqwInviteeIDs,
        DWORD dwMessageFlags,
        QWORD qwSenderContext,
        WORD cbDetails,
        const BYTE* pbDetails,
        QWORD *pqwNonce);

    HRESULT Cancel(
        SGADDR sgaddr,
        QWORD qwUserID,
        QWORD qwMatchSessionID,
        DWORD cInviteeIDs,
        const QWORD *rgqwInviteeIDs,
        QWORD *pqwNonce);

     HRESULT InviteAnswer(
        SGADDR sgaddr,
        QWORD qwUserID,
        QWORD qwHostID,
        QWORD qwMatchSessionID,
        WORD wAnswer,
        QWORD *pqwNonce);

    HRESULT Nickname(
        SGADDR sgaddr,
        QWORD qwUserID,
        DWORD cbNickname,
        const BYTE *pbNickname,
        QWORD *pqwNonce);

    HRESULT WebAlive(
        QWORD qwUserID,
        CClientConnection *pCReplyConn,
        DWORD dwSeqNum);

    HRESULT GetFriendsList(
        QWORD qwUserID,
        QWORD qwTargetID,
        CClientConnection *pCReplyConn,
        DWORD dwSeqNum,
        DWORD dwReplyType);

    // Mesages from connection servers
    HRESULT State(
        SGADDR sgaddr,
        QWORD qwUserID,
        DWORD dwState,
        QWORD qwMatchSessionID,
        DWORD dwTitleID,
        WORD cbTitleStuff,
        const BYTE *rgbTitleStuff,
        WORD cbRichPresence,
        const P_RICH_PRESENCE *pRichPresence,
        WORD cbMemcacheData,
        BYTE *pMemCacheData,
        QWORD *pqwNonce);

    HRESULT GetState(
        DWORD dwSeqNum,
        QWORD qwUserID,
        HRESULT hrReply,
        CClientConnection *pCReplyConn,
        QWORD *pqwNonce);

    HRESULT SendGetStateReply(
        DWORD dwSeqNum,
        QWORD qwUserID,
        HRESULT hrReply,
        CClientConnection *pCReplyConn,
        CPresence *pCPresence);

    HRESULT DeadUser(
        SGADDR sgaddr,
        QWORD qwUserID,
        QWORD *pqwNonce);

    HRESULT DeadXBox(SGADDR sgaddr);

    HRESULT DeadSG(SGADDR sgaddr);

    HRESULT Kick(QWORD qwUserID, BOOL fFlushTickets);

    HRESULT PurgeUser(
        QWORD qwUserID,
        DWORD dwSeqNum,
        CClientConnection *pCReplyConn);

    HRESULT InvalidateUser( QWORD qwUserID );

    HRESULT UserPreMigration(QWORD qwUserID);
    HRESULT UserFullMigration(P_USER_FULL_MIGRATION_MSG *pMsg, DWORD cbMsg);

    BOOL AdminShowPresenceRecord(LPCSTR pszParams, DWORD dwRequestId, CXomControlResponseInterface *pResponseInterface);
    BOOL AdminKickUser(LPCSTR pszParams, DWORD dwRequestId, CXomControlResponseInterface *pResponseInterface);
    BOOL AdminSetPresenceCacheState(LPCSTR pszParams, DWORD dwRequestId, CXomControlResponseInterface *pResponseInterface);
    BOOL AdminGetPresenceCacheState(LPCSTR pszParams, DWORD dwRequestId, CXomControlResponseInterface *pResponseInterface);
    void AdminShowPresenceBucketMap(LPCSTR pszParams, DWORD dwRequestId, CXomControlResponseInterface *pResponseInterface);
    void AdminShowPresenceBucketUsers(LPCSTR pszParams, DWORD dwRequestId, CXomControlResponseInterface *pResponseInterface);
    void AdminAddrefUser(LPCSTR pszParams, DWORD dwRequestId, CXomControlResponseInterface *pResponseInterface);
    void AdminReleaseUser(LPCSTR pszParams, DWORD dwRequestId, CXomControlResponseInterface *pResponseInterface);
    void AdminClearMigratingUsers(LPCSTR pszParams, DWORD dwRequestId, CXomControlResponseInterface *pResponseInterface);

    HRESULT PeerSession(
        QWORD qwUserID,
        QWORD qwHostUserID,
        CClientConnection *pCReplyConn,
        DWORD dwSeqNum);

    HRESULT PeerSubscribe(
        SGADDR sgaddr,
        QWORD qwUserID,
        DWORD cSrcUserIDs,
        QWORD *pqwSrcUserIDs,
        CClientConnection *pCReplyConn,
        DWORD dwSeqNum);

    HRESULT PeerSubscribeEx(
        SGADDR sgaddr,
        QWORD qwUserID,
        DWORD dwFlags,
        DWORD cUserIDs,
        QWORD *pqwUserIDs,
        CClientConnection *pCReplyConn,
        DWORD dwSeqNum);

    HRESULT PeerUnsubscribe(
        SGADDR sgaddr,
        QWORD qwUserID,
        CClientConnection *pCReplyConn,
        DWORD dwSeqNum);

    // Mesages from presence servers
    HRESULT Announce(
        QWORD qwDestUserID,
        DWORD dwTitleID,
        LPCSTR pszGamerTag,
        DWORD cSourceUserIDs,
        QWORD *rgqwSourceUserIDs);

    HRESULT Subscribed(
        QWORD qwDestUserID,
        DWORD cSourceUserIDs,
        const QWORD *rgqwSourceUserIDs);

    HRESULT Unsubscribe(
        QWORD qwSourceUserID,
        DWORD cDestUserIDs,
        QWORD *rgqwDestUserIDs);

    HRESULT Added(
        QWORD qwUserID,
        QWORD qwBuddyID,
        DWORD dwVersion,
        WORD cbBuddyAcctName,
        LPCSTR szBuddyAcctName);

    HRESULT Accepted(
        QWORD qwUserID,
        QWORD qwBuddyID,
        DWORD dwVersion,
        WORD cbBuddyAcctName,
        LPCSTR szBuddyAcctName);

    HRESULT Removed(
        QWORD qwUserID,
        QWORD qwBuddyID,
        DWORD dwVersion);

    HRESULT InviteAnswerPeer(
        QWORD qwUserID,
        QWORD qwHostID,
        QWORD qwMatchSessionID,
        WORD wAnswer);

    // Team Messages
    HRESULT TeamListTeams(
        SGADDR sgaddr,
        QWORD qwUserID,
        DWORD dwTitleID,
        DWORD cTeamIDs,
        QWORD *pqwTeamIDs,
        CClientConnection *pCReplyConn,
        DWORD dwSeqNum);

    HRESULT TeamListUserTeams(
        SGADDR sgaddr,
        QWORD qwUserID,
        DWORD dwTitleID,
        CClientConnection *pCReplyConn,
        DWORD dwSeqNum);

    HRESULT TeamListMembers(
        SGADDR sgaddr,
        QWORD qwUserID,
        DWORD dwTitleID,
        QWORD qwTeamID,
        BOOL fShowRecruits,
        CClientConnection *pCReplyConn,
        DWORD dwSeqNum);

    HRESULT TeamCreate(
        SGADDR sgaddr,
        QWORD qwUserID,
        DWORD dwTitleID,
        DWORD dwMaxMembers,
        DWORD cbTeamName,
        LPCWSTR wszTeamName,
        DWORD cbTeamDescription,
        LPCWSTR wszTeamDescription,
        DWORD cbTeamMotto,
        LPCWSTR wszTeamMotto,
        DWORD cbTeamURL,
        LPCWSTR wszTeamURL,
        DWORD cbTeamData,
        BYTE *pbTeamData,
        DWORD cbCreatorData,
        BYTE *pbCreatorData,
        BOOL fXenon,
        CClientConnection *pCReplyConn,
        DWORD dwSeqNum);

    HRESULT TeamDelete(
        SGADDR sgaddr,
        QWORD qwUserID,
        DWORD dwTitleID,
        QWORD qwTeamID,
        CClientConnection *pCReplyConn,
        DWORD dwSeqNum);

    HRESULT TeamRemove(
        SGADDR sgaddr,
        ULONGLONG qwUserID,
        DWORD dwTitleID,
        ULONGLONG qwTeamID,
        ULONGLONG qwMemberID,
        CClientConnection *pCReplyConn,
        DWORD dwSeqNum);

    HRESULT TeamManageTeam(
        SGADDR sgaddr,
        QWORD qwUserID,
        DWORD dwTitleID,
        QWORD qwTeamID,
        DWORD cbTeamName,
        LPCWSTR wszTeamName,
        DWORD cbTeamDescription,
        LPCWSTR wszTeamDescription,
        DWORD cbTeamMotto,
        LPCWSTR wszTeamMotto,
        DWORD cbTeamURL,
        LPCWSTR wszTeamURL,
        DWORD cbTeamData,
        BYTE *pbTeamData,
        BOOL fXenon,
        CClientConnection *pCReplyConn,
        DWORD dwSeqNum);

    HRESULT TeamManageMember(
        SGADDR sgaddr,
        ULONGLONG qwUserID,
        DWORD dwTitleID,
        ULONGLONG qwTeamID,
        ULONGLONG qwMemberID,
        DWORD dwMemberPriv,
        DWORD cbMemberData,
        BYTE *pbMemberData,
        CClientConnection *pCReplyConn,
        DWORD dwSeqNum);

    HRESULT TeamRecruit(
        SGADDR sgaddr,
        ULONGLONG qwUserID,
        DWORD dwTitleID,
        ULONGLONG qwTeamID,
        ULONGLONG qwMemberID,
        LPCSTR szMemberName,
        DWORD dwMemberPriv,
        DWORD dwMessageFlags,
        WORD cbDetails,
        const BYTE* pbDetails,
        DWORD cbMemberData,
        const BYTE *pbMemberData,
        CClientConnection *pCReplyConn,
        DWORD dwSeqNum);

    HRESULT TeamJoin(
        SGADDR sgaddr,
        QWORD qwUserID,
        DWORD dwTitleID,
        QWORD qwTeamID,
        DWORD dwRecruitMsgID,
        BYTE bAnswer,
        CClientConnection *pCReplyConn,
        DWORD dwSeqNum);

    HRESULT TeamGetTicket(
        SGADDR sgaddr,
        QWORD qwUserID,
        DWORD dwTitleID,
        CClientConnection *pCReplyConn,
        DWORD dwSeqNum);

    // Non-Friend Presence

    HRESULT WatchStart(
        QWORD qwDestUserID,
        DWORD cSourceUserIDs,
        QWORD *rgqwSourceUserIDs);

    HRESULT WatchStop(
        QWORD qwDestUserID,
        DWORD cSourceUserIDs,
        QWORD *rgqwSourceUserIDs);

    // Revoke helper
    HRESULT QueueRevokeMessage(
        QWORD qwSenderID,
        QWORD qwSenderContext,
        DWORD dwFlags,
        WORD wPropTag,
        WORD cbProp,
        const BYTE* pbProp,
        BYTE bMessageType,
        WORD cRecipients,
        const Q_RECIPIENT_RESULT *rgRecipients);


    // Callback methods from the store
    void AliveStoreComplete(CAliveContext *pCCtx);
    HRESULT SyncComplete(CSyncContext *pCCtx);
    HRESULT AddBuddyComplete(CAddBuddyContext *pCCtx);
    HRESULT CheckTitleMessagesComplete(CCheckTitleMessagesContext *pCCtx);
    HRESULT AddAffiliatesComplete(CAddAffiliatesContext *pCCtx);
    HRESULT IsAffiliateComplete(CIsAffiliateContext *pCCtx);
    HRESULT QueryAffiliatesStoreComplete(CQueryAffiliatesContext *pCCtx);
    HRESULT QueryAffiliatesComplete(CQueryAffiliatesContext *pCCtx);
    HRESULT AcceptBuddyComplete(CAcceptBuddyContext *pCCtx);
    HRESULT RejectBuddyComplete(CRejectBuddyContext *pCCtx);
    HRESULT DeleteBuddyComplete(CDeleteBuddyContext *pCCtx);
    HRESULT BlockComplete(CBlockContext *pCCtx);
    HRESULT UnblockComplete(CUnblockContext *pCCtx);
    HRESULT ClearAllBlocksComplete(CClearAllBlocksContext *pCCtx);
    void GetFriendsListComplete(CGetFriendsListContext *pCCtx);
    HRESULT TeamListTeamsComplete(CTeamListTeamsContext *pCCtx);
    HRESULT TeamListUserTeamsComplete(CTeamListUserTeamsContext *pCCtx);
    HRESULT TeamListMembersComplete(CTeamListMembersContext *pCCtx);
    HRESULT TeamCreateComplete(CTeamCreateContext *pCCtx);
    HRESULT TeamRemoveComplete(CTeamRemoveContext *pCCtx);
    HRESULT TeamDeleteComplete(CTeamDeleteContext *pCCtx);
    HRESULT TeamManageTeamComplete(CTeamManageTeamContext *pCCtx);
    HRESULT TeamManageMemberComplete(CTeamManageMemberContext *pCCtx);
    HRESULT TeamRecruitComplete(CTeamRecruitContext *pCCtx);
    HRESULT TeamJoinComplete(CTeamJoinContext *pCCtx);
    HRESULT TeamGetTicketComplete(CTeamGetTicketContext *pCCtx);

    // Callbacks from Notification

    HRESULT SendEmptyReply(
        DWORD dwMsgType,
        DWORD cbReply,
        DWORD dwSeqNum,
        HRESULT hrReply,
        CClientConnection *pCReplyConn);

    // Special replies
    HRESULT SendEmptyAliveReply(
        DWORD dwSeqNum,
        HRESULT hrReply,
        DWORD dwBuddyListVersion,
        DWORD dwBlockListVersion,
        CClientConnection *pCReplyConn);

    HRESULT SendLogonCheckReply(
        DWORD dwSeqNum,
        HRESULT hrReply,
        CClientConnection *pCReplyConn);

    HRESULT SendCheckTitleMessagesReply(
        DWORD dwSeqNum,
        HRESULT hrReply,
        CClientConnection *pCReplyConn);

    HRESULT SendErrorSyncReply(
        DWORD dwSeqNum,
        HRESULT hrReply,
        CClientConnection *pCReplyConn);

    HRESULT SendWebAliveReply(
        QWORD qwUserID,
        DWORD dwSeqNum,
        HRESULT hrReply,
        CClientConnection *pCReplyConn);

    HRESULT SendGetFriendsListReply(
        QWORD qwTargetID,
        DWORD dwSeqNum,
        DWORD dwReplyType,
        HRESULT hrReply,
        DWORD dwVersion,
        DWORD cdwResults,
        P_GET_FRIENDS_LIST_REPLY_DATA *rgResults,
        CClientConnection *pCReplyConn);

    HRESULT SendPeerSessionReply(
        DWORD dwSeqNum,
        QWORD qwUserID,
        DWORD dwTitleID,
        DWORD dwTitleVersion,
        DWORD dwTitleRegion,
        XNADDR xnaddr,
        XNKID xkid,
        XNKEY xnkey,
        CClientConnection *pCReplyConn);

    HRESULT SendPeerSubscribeReply(
        DWORD dwSeqNum,
        HRESULT hrReply,
        CClientConnection *pCReplyConn);

    HRESULT SendPeerSubscribeExReply(
        DWORD dwSeqNum,
        HRESULT hrReply,
        WORD cResults,
        P_PEER_SUBSCRIBE_EX_DATA *rgResults,
        CClientConnection *pCReplyConn);

    HRESULT SendPeerUnsubscribeReply(
        DWORD dwSeqNum,
        HRESULT hrReply,
        CClientConnection *pCReplyConn);

    HRESULT SendTeamListTeamsReply(
        DWORD dwSeqNum,
        HRESULT hrReply,
        DWORD cReplies,
        CTCPCntVarBuffer **rgpReplies,
        CClientConnection *pCReplyConn);

    HRESULT SendTeamListUserTeamsReply(
        DWORD dwSeqNum,
        HRESULT hrReply,
        DWORD cTeams,
        P_REPLY_USER_TEAM *rgUserTeams,
        CClientConnection *pCReplyConn);

    HRESULT SendTeamListMembersReply(
        DWORD dwSeqNum,
        HRESULT hrReply,
        QWORD qwTeamID,
        DWORD cMembers,
        CTCPCntVarBuffer *pReply,
        CClientConnection *pCReplyConn);

    HRESULT SendTeamCreateReply(
        DWORD dwSeqNum,
        HRESULT hrReply,
        QWORD qwTeamID,
        CClientConnection *pCReplyConn);

    HRESULT SendTeamDeleteReply(
        DWORD dwSeqNum,
        HRESULT hrReply,
        CClientConnection *pCReplyConn);

    HRESULT SendTeamRemoveReply(
        DWORD dwSeqNum,
        HRESULT hrReply,
        CClientConnection *pCReplyConn);

    HRESULT SendTeamManageTeamReply(
        DWORD dwSeqNum,
        HRESULT hrReply,
        CClientConnection *pCReplyConn);

    HRESULT SendTeamManageMemberReply(
        DWORD dwSeqNum,
        HRESULT hrReply,
        CClientConnection *pCReplyConn);

    HRESULT SendTeamRecruitReply(
        DWORD dwSeqNum,
        HRESULT hrReply,
        CClientConnection *pCReplyConn);

    HRESULT SendTeamJoinReply(
        DWORD dwSeqNum,
        HRESULT hrReply,
        CClientConnection *pCReplyConn);

    HRESULT SendTeamGetTicketReply(
        DWORD dwSeqNum,
        HRESULT hrReply,
        QWORD qwUserID,
        DWORD cTeamIDs,
        QWORD *pqwTeamIDs,
        CClientConnection *pCReplyConn);

    HRESULT SendIsAffiliateReply(
        DWORD dwSeqNum,
        HRESULT hrReply,
        QWORD qwAffiliateID,
        DWORD dwListFlags,
        CClientConnection *pCReplyConn);

    HRESULT SendQueryAffiliatesReply(
        DWORD dwSeqNum,
        HRESULT hrReply,
        DWORD cdwResults,
        P_QUERY_AFFILIATES_REPLY_DATA_MSG *rgResults,
        CClientConnection *pCReplyConn);

    HRESULT SendGetPresenceInfo(CPresenceInfoContext *pCCtx, BOOL fUseAltServer = FALSE);

    HRESULT KillUser(CPresence *pCPresence);

    // Admin functions

    HRESULT AdminPConnStatus(DWORD dwRequestId, CXomControlResponseInterface* pResponseInterface)
    {
        return m_CXPCluster.Status(dwRequestId, pResponseInterface);
    }
    HRESULT AdminPConnReset(DWORD dwIndex) { return m_CXPCluster.ResetConnection(dwIndex); }


    // User and queue commands
    HRESULT AddToQ(
        const SGADDR* psgaddr,
        QWORD qwUserID,
        DWORD dwQType,
        DWORD cbData,
        const BYTE *pbData,
        DWORD *pdwItemID );

    HRESULT Dequeue(
        DWORD dwSeqNum,
        const SGADDR* psgaddr,
        QWORD qwUserID,
        DWORD dwQType,
        DWORD dwStartItemID,
        DWORD dwMaxItems,
        DWORD dwTotalItemDataSize,
        CClientConnection *pReplyConn );

    // Messaging functions
    HRESULT EnumerateMessages(
        QWORD qwUserID,
        CClientConnection *pCReplyConn,
        DWORD dwMsgType,
        DWORD dwSeqNum);

    HRESULT GetMessageSummary(
        QWORD qwUserID,
        DWORD dwMessageID,
        CClientConnection *pCReplyConn,
        DWORD dwMsgType,
        DWORD dwSeqNum);

    HRESULT GetMessageDetails(
        QWORD qwUserID,
        DWORD dwMessageID,
        DWORD dwSetFlags,
        DWORD dwUnsetFlags,
        CClientConnection *pCReplyConn,
        DWORD dwSeqNum);

    HRESULT DeleteMessage(
        BOOL  fFromPresence,
        QWORD qwUserID,
        DWORD dwMessageID,
        DWORD dwFlags,
        CTCPCntMessageBased<CTCPCntMessageBasedPlugin_PN> *pCReplyConn,
        DWORD dwSeqNum);

    HRESULT SendMessageExternal(
        BOOL  fFromPresence,
        Q_SEND_MESSAGE_MSG* pSendMessage,
        const ULONGLONG* pqwRecipientIDs,
        const BYTE* pbDetails,
        const Q_SEND_MESSAGE_ADDENDUM* rgAddendum,
        CTCPCntMessageBased<CTCPCntMessageBasedPlugin_PN> *pCReplyConn,
        DWORD dwSeqNum);

    HRESULT SendMessageInternal(
        Q_SEND_MESSAGE_MSG* pSendMessage,
        ULONGLONG* pqwRecipientIDs,
        const BYTE* pbDetails,
        const Q_SEND_MESSAGE_ADDENDUM* rgAddendum,
        CPresConnection *pCReplyConn,
        DWORD dwSeqNum,
        SendMessageReplyHandler* pExternalCtx);

    HRESULT RevokeMessageExternal(
        const Q_REVOKE_MESSAGE_EX_MSG* pMessage,
        const Q_RECIPIENT_RESULT* pRecipients,
        const BYTE* pbProp);

    HRESULT RevokeMessageInternal(
        const Q_REVOKE_MESSAGE_EX_MSG* pMessage,
        Q_RECIPIENT_RESULT* pRecipients,
        const BYTE* pbProp);

    HRESULT DeleteUserTitle(
        QWORD qwUserID,
        DWORD dwTitleID,
        CClientConnection *pCReplyConn,
        DWORD dwSeqNum);

    HRESULT EnumerateUserTitles(
        QWORD qwUserID,
        CClientConnection *pCReplyConn,
        DWORD dwSeqNum);

    HRESULT MessageFlags(
        QWORD qwUserID,
        DWORD dwMessageID,
        DWORD dwSetFlags,
        DWORD dwUnsetFlags,
        CClientConnection *pCReplyConn,
        DWORD dwSeqNum);

    HRESULT EnumSystemMessages(
        DWORD dwTitleID,
        CClientConnection *pCReplyConn,
        DWORD dwSeqNum);

    HRESULT GetSystemMessageDetails(
        DWORD dwTitleID,
        DWORD dwMessageID,
        CClientConnection *pCReplyConn,
        DWORD dwSeqNum);

    HRESULT DeleteSystemMessage(
        DWORD dwTitleID,
        DWORD dwMessageID,
        DWORD dwFlags,
        CClientConnection *pCReplyConn,
        DWORD dwSeqNum);

    HRESULT SendSystemMessage(
        const Q_SEND_SYSTEM_MESSAGE_MSG* pSendMessage,
        const BYTE* pbDetails,
        CClientConnection *pCReplyConn,
        DWORD dwSeqNum);

    // Messages from the SG
    void SetQValsReply(
        SGADDR* psgaddr,
        QWORD qwUserId,
        DWORD dwSeqQVals,
        BOOL  fNotFound,
        BOOL  fNoSuchUser);

    // Callback methods from the store
    void EnumerateMessagesComplete(CEnumerateMessagesContext *pCCtx);
    void GetMessageSummaryComplete(CGetMessageSummaryContext *pCCtx);
    void GetMessageDetailsComplete(CGetMessageDetailsContext *pCCtx);
    void DeleteMessageComplete(CDeleteMessageContext *pCCtx);
    void SendMessageInternalComplete(CSendMessageInternalContext *pCCtx);
    void RevokeMessageComplete(CRevokeMessageContext *pCCtx);
    void DeleteUserTitleComplete(CDeleteUserTitleContext *pCCtx);
    void EnumerateUserTitlesComplete(CEnumerateUserTitlesContext *pCCtx);
    void MessageFlagsComplete(CMessageFlagsContext *pCCtx);
    void EnumSystemMessagesComplete( CEnumSystemMessagesContext* pCCtx );
    void GetSystemMessageDetailsComplete( CSystemMessageDetailsContext* pCCtx );
    void DeleteSystemMessageComplete( CDeleteSystemMessageContext* pCCtx );
    void SendSystemMessageComplete( CSendSystemMessageContext* pCCtx );

    // Callback methods from the Notification cluster
    void SendMessageExternalComplete(CSendMessageExternalContext *pCCtx);

    HRESULT NotifyPresenceAll(CPresence *pCPresence, BOOL fSendToXbox = TRUE, BOOL fSendToFriendXenon = TRUE, BOOL fSendToPeerXenon = TRUE);
    HRESULT NotifyOfflineAll(CPresence *pCPresence, BOOL fBlockFriends);

protected:

    BOOL CheckSGAddr(const SGADDR *psgaddrIn, CPresence *pCPresence);

    HRESULT AnnounceToAllBuddies(CPresence *pCPresence);
    HRESULT UnsubscribeFromAllBuddies(CPresence *pCPresence);
    HRESULT ClearInvitation(CPresence *pCPresence);
    HRESULT ClearPeerWatches(CPresence *pCPresence);

    HRESULT SendWelcomeMessage(QWORD qwUserID, DWORD dwMessageID);

    // Completion port
    CCompletionPort *m_pCompPort;

    // Contained objects
    CHeartbeatHandler m_HeartbeatHandler;
    DWORD m_dwLastHeartBeat;
    DWORD m_dwLastIndex;

    CClientListener m_CClientListener;
    CProfileStore m_CProfileStore;
    CXPCluster m_CXPCluster;
    CServerSocket *m_pKickSocket;
    CSGCommunicator m_CSGComm;
};

/*****************************************************************************

CCliConnReceiveContext

*****************************************************************************/
class CForwardReceiveContext : public CLocalContext
{
public:
    CForwardReceiveContext(
        CForwardingConnection *pCFwdConn) :
        m_pCFwdConn(pCFwdConn)
    {
        m_pCFwdConn->AddRef();
    }

    virtual ~CForwardReceiveContext()
    {
        SAFE_RELEASE(m_pCFwdConn);
        SAFE_ARRAYDELETE(m_pMsg);
    }

    IMPLEMENT_REFCOUNT

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual void CompletionProc()
    {
        XOMASSERT( NULL != m_pCFwdConn );

        CheckIoCompletion(PostSwitchboard);
        m_pCFwdConn->ProcessReplyMessage(m_pMsg, m_cbEntireMsg);

        Release();
    }

    virtual const char* GetContextDesc() { return "ForwardConnectionReceive"; }

protected:
    CForwardingConnection *m_pCFwdConn;

public:
    BYTE *m_pMsg;
    DWORD m_cbEntireMsg;
};

/*****************************************************************************

CCliConnReceiveContext

*****************************************************************************/
class CCliConnReceiveContext : public CLocalContext
{
public:
    CCliConnReceiveContext(
        CClientConnection *pCCliConn) :
        m_pCCliConn(pCCliConn)
    {
        m_pCCliConn->AddRef();
    }

    virtual ~CCliConnReceiveContext()
    {
        SAFE_RELEASE(m_pCCliConn);
        SAFE_ARRAYDELETE(m_pMsg);
    }

    IMPLEMENT_REFCOUNT

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual void CompletionProc()
    {
        XOMASSERT( NULL != m_pCCliConn );

        CheckIoCompletion(PostSwitchboard);
        m_pCCliConn->ProcessCliConnMessage(m_pMsg, m_cbEntireMsg);

        Release();
    }

    virtual const char* GetContextDesc() { return "CliConnReceive"; }

protected:
    CClientConnection *m_pCCliConn;

public:
    BYTE *m_pMsg;
    DWORD m_cbEntireMsg;
};

/*****************************************************************************

CPConnReceiveContext

*****************************************************************************/
class CPConnReceiveContext : public CLocalContext
{
public:
    CPConnReceiveContext(
        CPresConnection *pCPConn) :
        m_pCPConn(pCPConn)
    {
        m_pCPConn->AddRef();
    }

    virtual ~CPConnReceiveContext()
    {
        SAFE_RELEASE(m_pCPConn);
        SAFE_ARRAYDELETE(m_pMsg);
    }

    IMPLEMENT_REFCOUNT

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual void CompletionProc()
    {
        XOMASSERT( NULL != m_pCPConn );

        CheckIoCompletion(PostSwitchboard);
        m_pCPConn->ProcessPConnMessage(m_pMsg, m_cbEntireMsg);

        Release();
    }

    virtual const char* GetContextDesc() { return "PConnReceive"; }

protected:
    CPresConnection *m_pCPConn;

public:
    BYTE *m_pMsg;
    DWORD m_cbEntireMsg;

    BYTE *m_pWrite;
};

/*****************************************************************************

CAliveContext

*****************************************************************************/
class CAliveContext : public CLocalContext
{
public:
    enum AliveState
    {
        AliveState_Init,
        AliveState_Store,
        AliveState_StoreComplete,
        AliveState_Done
    };

    CAliveContext(
        CSwitchboard *pSwitchboard,
        CProfileStore *pCProfileStore) :
        m_pCSwitchboard(pSwitchboard),
        m_pCProfileStore(pCProfileStore),
        m_eState(AliveState_Init),
        m_hrStore(S_FALSE),
        m_hrUserInfo(S_FALSE),
        m_pCNext(NULL),
        m_qwUserID(0),
        m_dwClientBuddyListVersion(0),
        m_dwClientBlockListVersion(0),
        m_dwTitleID(0),
        m_dwAltTitleID1(0),
        m_dwAltTitleID2(0),
        m_dwAltTitleID3(0),
        m_dwAltTitleID4(0),
        m_dwTitleRegion(0),
        m_pCReplyConn(NULL),
        m_dwSeqNum(0),
        m_dwBuddyListVersion(0),
        m_cBuddies(0),
        m_rgCBuddyList(NULL),
        m_dwBlockListVersion(0),
        m_cBlocks(0),
        m_pCReplyBuddies(NULL),
        m_pCReplyBlocks(NULL),
        m_cbAccountName(0),
        m_pqwNeverList(NULL),
        m_cNeverList(0),
        m_qwUserWebID(0),
        m_fWentToStore(FALSE),
        m_qwVersionFlags(0),
        m_dwFirstLogon(0),
        m_pCPresence(NULL)
    {
        memset(&m_sgaddr, 0, sizeof(SGADDR));
        memset(m_szAccountName, 0, sizeof(m_szAccountName));
        memset(m_rgbPrivileges, 0, sizeof(m_rgbPrivileges));
        memset(m_szLocale, 0, XONLINE_PRESENCE_LOCALE_SIZE);

        g_Counters.SafeIncrement32(XPPERF_SERVER_SQL_WORK_ITEMS);
    }

    virtual ~CAliveContext()
    {
        g_Counters.SafeDecrement32(XPPERF_SERVER_SQL_WORK_ITEMS);

        if (m_pCReplyConn != NULL)
        {
            m_pCReplyConn->Release();
        }

        if (m_rgCBuddyList != NULL)
        {
            delete[] m_rgCBuddyList;
        }
        if (m_pqwNeverList != NULL )
        {
            delete[] m_pqwNeverList;
        }

        SAFE_RELEASE(m_pCReplyBuddies);
        SAFE_RELEASE(m_pCReplyBlocks);
        SAFE_RELEASE(m_pCPresence);
    }

    IMPLEMENT_REFCOUNT

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual void CompletionProc()
    {
        XOMASSERT( NULL != m_pCSwitchboard );

        switch(m_eState)
        {
        case AliveState_Store:
        {
            CScopeTimer scope( XPPERF_SERVER_ALIVE_STORE_TIME_AVERAGE, XPPERF_SERVER_ALIVE_STORE_TIME_BASE );
            CheckIoCompletion( PostSql );
            m_pCProfileStore->StoreAlive(this);
            break;
        }
        case AliveState_StoreComplete:
        {
            CScopeTimer scope( XPPERF_SERVER_ALIVE_STORE_COMPLETE_TIME_AVERAGE, XPPERF_SERVER_ALIVE_STORE_COMPLETE_TIME_BASE );
            CheckIoCompletion( PostSwitchboard );
            m_pCSwitchboard->AliveStoreComplete(this);
            break;
        }
        case AliveState_Init:
        case AliveState_Done:
            XOMASSERT(FALSE);
        }
    }

    virtual const char* GetContextDesc() { return "Alive"; }

protected:
    CSwitchboard *m_pCSwitchboard;
    CProfileStore *m_pCProfileStore;

public:
    // Task state and results
    AliveState m_eState;
    HRESULT m_hrStore;
    HRESULT m_hrUserInfo;
    CAliveContext *m_pCNext;

    // Input
    QWORD m_qwUserID;
    DWORD m_dwClientBuddyListVersion;
    DWORD m_dwClientBlockListVersion;
    DWORD m_dwTitleID;
    DWORD m_dwAltTitleID1;
    DWORD m_dwAltTitleID2;
    DWORD m_dwAltTitleID3;
    DWORD m_dwAltTitleID4;
    DWORD m_dwTitleRegion;
    BYTE m_szLocale[XONLINE_PRESENCE_LOCALE_SIZE];
    QWORD m_qwVersionFlags;
    CClientConnection *m_pCReplyConn;
    DWORD m_dwSeqNum;

    // Buddy List
    DWORD m_dwBuddyListVersion;
    DWORD m_cBuddies;
    CBuddyListEntry *m_rgCBuddyList;

    // Block List
    DWORD m_dwBlockListVersion;
    DWORD m_cBlocks;

    // Never List
    ULONGLONG* m_pqwNeverList;
    WORD m_cNeverList;

    // Replies
    CTCPCntVarBuffer *m_pCReplyBuddies;
    CTCPCntVarBuffer *m_pCReplyBlocks;

    // SGADDR
    SGADDR m_sgaddr;

    // Web integration
    QWORD m_qwUserWebID;
    BOOL m_fWentToStore;

    BYTE m_rgbPrivileges[XONLINE_NUM_PRIVILEGE_BYTES];

    // Acctname at end to be cache friendly
    DWORD m_cbAccountName;
    char m_szAccountName[ MAX_ACCTNAME_BYTES + 1 ];

    // Is this the first logon on this machine?
    DWORD m_dwFirstLogon;

    CPresence *m_pCPresence;
};

/*****************************************************************************

CSyncContext

*****************************************************************************/
class CSyncContext : public CLocalContext
{
public:
    CSyncContext(
        CSwitchboard *pSwitchboard,
        CProfileStore *pCProfileStore) :
        m_pCSwitchboard(pSwitchboard),
        m_pCProfileStore(pCProfileStore),
        m_fProcessed(FALSE),
        m_qwUserID(0),
        m_dwClientBuddyListVersion(0),
        m_dwClientBlockListVersion(0),
        m_pCReplyConn(NULL),
        m_dwSeqNum(0),
        m_hr(S_OK),
        m_dwBuddyListVersion(0),
        m_cBuddies(0),
        m_rgCBuddyList(0),
        m_dwBlockListVersion(0),
        m_cBlocks(0),
        m_pCReplyBuddies(NULL),
        m_pCReplyBlocks(NULL),
        m_pCPresence(NULL)
    {
        g_Counters.SafeIncrement32(XPPERF_SERVER_SQL_WORK_ITEMS);
    }

    virtual ~CSyncContext()
    {
        g_Counters.SafeDecrement32(XPPERF_SERVER_SQL_WORK_ITEMS);

        if (m_pCReplyConn != NULL)
        {
            m_pCReplyConn->Release();
        }

        if (m_rgCBuddyList != NULL)
        {
            delete[] m_rgCBuddyList;
        }

        SAFE_RELEASE(m_pCReplyBuddies);
        SAFE_RELEASE(m_pCReplyBlocks);
        SAFE_RELEASE(m_pCPresence);
    }

    IMPLEMENT_REFCOUNT

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual void CompletionProc()
    {
        XOMASSERT( NULL != m_pCSwitchboard );

        HRESULT hr = S_OK;

        if (!m_fProcessed)
        {
            CScopeTimer scope( XPPERF_SERVER_SYNC_STORE_TIME_AVERAGE, XPPERF_SERVER_SYNC_STORE_TIME_BASE );
            CheckIoCompletion( PostSql );
            hr = m_pCProfileStore->StoreSync(this);
        }
        else
        {
            CScopeTimer scope( XPPERF_SERVER_SYNC_COMPLETION_TIME_AVERAGE, XPPERF_SERVER_SYNC_COMPLETION_TIME_BASE );
            CheckIoCompletion( PostSwitchboard );
            hr = m_pCSwitchboard->SyncComplete(this);
        }
    }

    virtual const char* GetContextDesc() { return "Sync"; }

protected:
    CSwitchboard *m_pCSwitchboard;
    CProfileStore *m_pCProfileStore;

public:
    BOOL m_fProcessed;

    // Input
    QWORD m_qwUserID;
    DWORD m_dwClientBuddyListVersion;
    DWORD m_dwClientBlockListVersion;
    CClientConnection *m_pCReplyConn;
    DWORD m_dwSeqNum;

    // Store hr
    HRESULT m_hr;

    // Buddy List
    DWORD m_dwBuddyListVersion;
    DWORD m_cBuddies;
    CBuddyListEntry *m_rgCBuddyList;

    // Block List
    DWORD m_dwBlockListVersion;
    DWORD m_cBlocks;

    // Replies
    CTCPCntVarBuffer *m_pCReplyBuddies;
    CTCPCntVarBuffer *m_pCReplyBlocks;

    CPresence *m_pCPresence;
};

/*****************************************************************************

CAddBuddyContext

*****************************************************************************/
class CAddBuddyContext : public CLocalContext
{
public:
    CAddBuddyContext(
        CSwitchboard *pSwitchboard,
        CProfileStore *pCProfileStore) :
        m_pCSwitchboard(pSwitchboard),
        m_pCProfileStore(pCProfileStore),
        m_fProcessed(FALSE),
        m_qwUserID(0),
        m_qwBuddyID(0),
        m_cbUserAccountName(0),
        m_hr(S_OK),
        m_dwUserBuddyListVersion(0),
        m_dwBuddyBuddyListVersion(0),
        m_cbBuddyAccountName(0),
        m_dwMessageFlags(0),
        m_dwTitleID(0),
        m_cbDetails(0),
        m_pCPresence(NULL)

    {
        m_szUserAccountName[0] = '\0';
        m_szBuddyAccountName[0] = '\0';
        g_Counters.SafeIncrement32(XPPERF_SERVER_SQL_WORK_ITEMS);
    }

    virtual ~CAddBuddyContext()
    {
        g_Counters.SafeDecrement32(XPPERF_SERVER_SQL_WORK_ITEMS);

        SAFE_RELEASE(m_pCPresence);
    }

    IMPLEMENT_REFCOUNT

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual void CompletionProc()
    {
        XOMASSERT( NULL != m_pCSwitchboard );

        HRESULT hr = S_OK;

        if (!m_fProcessed)
        {
            CScopeTimer scope( XPPERF_SERVER_ADD_BUDDY_STORE_TIME_AVERAGE, XPPERF_SERVER_ADD_BUDDY_STORE_TIME_BASE );
            CheckIoCompletion( PostSql );
            hr = m_pCProfileStore->StoreAddBuddy(this);
        }
        else
        {
            CScopeTimer scope( XPPERF_SERVER_ADD_BUDDY_COMPLETION_TIME_AVERAGE, XPPERF_SERVER_ADD_BUDDY_COMPLETION_TIME_BASE );
            CheckIoCompletion( PostSwitchboard );
            hr = m_pCSwitchboard->AddBuddyComplete(this);
        }
    }

    virtual const char* GetContextDesc() { return "AddBuddy"; }

protected:
    CSwitchboard *m_pCSwitchboard;
    CProfileStore *m_pCProfileStore;

public:
    BOOL m_fProcessed;

    // Input
    QWORD m_qwUserID;
    QWORD m_qwBuddyID;
    DWORD m_cbUserAccountName;

    DWORD m_dwMessageFlags;
    DWORD m_dwTitleID;
    WORD  m_cbDetails;
    BYTE  m_rgbDetails[ XONLINE_MAX_MESSAGE_DETAILS ];

    // Output
    HRESULT m_hr;
    DWORD m_dwUserBuddyListVersion;
    DWORD m_dwBuddyBuddyListVersion;
    DWORD m_cbBuddyAccountName;

    // Account names at end to be cache friendly
    char m_szUserAccountName[ MAX_ACCTNAME_BYTES + 1 ];
    char m_szBuddyAccountName[ MAX_ACCTNAME_BYTES + 1 ];

    CPresence *m_pCPresence;
};

/*****************************************************************************

CIsAffiliateContext

*****************************************************************************/
class CIsAffiliateContext : public CLocalContext
{
public:
    CIsAffiliateContext(
        CSwitchboard *pSwitchboard,
        CProfileStore *pCProfileStore) :
        m_pCSwitchboard(pSwitchboard),
        m_pCProfileStore(pCProfileStore),
        m_fProcessed(FALSE),
        m_qwUserID(0),
        m_qwAffiliateID(0),
        m_hr(S_OK),
        m_dwSeqNum(0),
        m_pCReplyConn(NULL),
        m_prgAffiliateLists(NULL),
        m_pCPresence(NULL)
    {
        g_Counters.SafeIncrement32(XPPERF_SERVER_SQL_WORK_ITEMS);
    }

    virtual ~CIsAffiliateContext()
    {
        g_Counters.SafeDecrement32(XPPERF_SERVER_SQL_WORK_ITEMS);

        if (m_prgAffiliateLists)
        {
            for (DWORD dwList = 0; dwList < NUM_STORED_AFFILIATE_LISTS; dwList++)
            {
                delete m_prgAffiliateLists[dwList];
                m_prgAffiliateLists[dwList] = NULL;
            }

            delete[] m_prgAffiliateLists;
        }

        SAFE_RELEASE(m_pCReplyConn);
        SAFE_RELEASE(m_pCPresence);
    }

    IMPLEMENT_REFCOUNT

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual void CompletionProc()
    {
        XOMASSERT( NULL != m_pCSwitchboard );

        HRESULT hr = S_OK;

        if (!m_fProcessed)
        {
            CScopeTimer scope( XPPERF_SERVER_IS_AFFILIATE_STORE_TIME_AVERAGE, XPPERF_SERVER_IS_AFFILIATE_STORE_TIME_BASE );
            CheckIoCompletion( PostSql );
            hr = m_pCProfileStore->StoreIsAffiliate(this);
        }
        else
        {
            CScopeTimer scope( XPPERF_SERVER_IS_AFFILIATE_COMPLETION_TIME_AVERAGE, XPPERF_SERVER_IS_AFFILIATE_COMPLETION_TIME_BASE );
            CheckIoCompletion( PostSwitchboard );
            hr = m_pCSwitchboard->IsAffiliateComplete(this);
        }
    }

    virtual const char* GetContextDesc() { return "IsAffiliate"; }

protected:
    CSwitchboard *m_pCSwitchboard;
    CProfileStore *m_pCProfileStore;

public:
    BOOL m_fProcessed;

    // Input
    QWORD m_qwUserID;
    QWORD m_qwAffiliateID;
    CClientConnection *m_pCReplyConn;
    DWORD m_dwSeqNum;

    // Output
    HRESULT m_hr;
    CAffiliatesList **m_prgAffiliateLists;

    CPresence *m_pCPresence;
};

/*****************************************************************************

CCheckTitleMessagesContext

*****************************************************************************/
class CCheckTitleMessagesContext : public CLocalContext
{
public:
    CCheckTitleMessagesContext(
        CSwitchboard *pSwitchboard,
        CProfileStore *pCProfileStore) :
        m_pCSwitchboard(pSwitchboard),
        m_pCProfileStore(pCProfileStore),
        m_fProcessed(FALSE),
        m_pAliveCtx(NULL),
        m_hr(S_OK),
        m_dwSeqNum(0),
        m_pCReplyConn(NULL),
        m_pCPresence(NULL)
    {
        g_Counters.SafeIncrement32(XPPERF_SERVER_SQL_WORK_ITEMS);
    }

    virtual ~CCheckTitleMessagesContext()
    {
        SAFE_RELEASE(m_pAliveCtx);
        SAFE_RELEASE(m_pCReplyConn);
        SAFE_RELEASE(m_pCPresence);
        g_Counters.SafeDecrement32(XPPERF_SERVER_SQL_WORK_ITEMS);
    }

    IMPLEMENT_REFCOUNT

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual void CompletionProc()
    {
        XOMASSERT( NULL != m_pCSwitchboard );

        HRESULT hr = S_OK;

        if (!m_fProcessed)
        {
            CScopeTimer scope( XPPERF_SERVER_ENUM_SYSTEM_MESSAGES_STORE_TIME_AVERAGE, XPPERF_SERVER_ENUM_SYSTEM_MESSAGES_STORE_TIME_BASE );
            CheckIoCompletion( PostSql );
            m_hr = m_pCProfileStore->SProcMessagingUserInit(m_pAliveCtx);
            m_fProcessed = TRUE;
            m_pCSwitchboard->PostCompletion(this);
        }
        else
        {
            CScopeTimer scope( XPPERF_SERVER_ENUM_SYSTEM_MESSAGES_COMPLETION_TIME_AVERAGE, XPPERF_SERVER_ENUM_SYSTEM_MESSAGES_COMPLETION_TIME_BASE );
            CheckIoCompletion( PostSwitchboard );
            hr = m_pCSwitchboard->CheckTitleMessagesComplete(this);
        }
    }

    virtual const char* GetContextDesc() { return "CheckTitleMessages"; }

protected:
    CSwitchboard *m_pCSwitchboard;
    CProfileStore *m_pCProfileStore;

public:
    BOOL m_fProcessed;

    // Input
    CAliveContext *m_pAliveCtx;
    DWORD m_dwSeqNum;
    CClientConnection *m_pCReplyConn;

    // Output
    HRESULT m_hr;

    CPresence *m_pCPresence;
};

/*****************************************************************************

CDeadSGContext

*****************************************************************************/
class CDeadSGContext : public CLocalContext
{
public:
    CDeadSGContext(
        CSwitchboard *pSwitchboard) :
        m_pCSwitchboard(pSwitchboard)
    {
    }

    virtual ~CDeadSGContext()
    {
    }

    IMPLEMENT_REFCOUNT

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual void CompletionProc()
    {
        XOMASSERT( NULL != m_pCSwitchboard );

        CheckIoCompletion(PostSwitchboard);
        m_pCSwitchboard->DeadSG(m_sgaddr);

        Release();
    }

    virtual const char* GetContextDesc() { return "DeadSG"; }

protected:
    CSwitchboard *m_pCSwitchboard;

public:
    SGADDR m_sgaddr;
};

/*****************************************************************************

CSetQValsReplyContext

*****************************************************************************/
class CSetQValsReplyContext : public CLocalContext
{
public:
    CSetQValsReplyContext(
        CSwitchboard *pSwitchboard) :
        m_pCSwitchboard(pSwitchboard)
    {
    }

    virtual ~CSetQValsReplyContext()
    {
    }

    IMPLEMENT_REFCOUNT

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual void CompletionProc()
    {
        XOMASSERT( NULL != m_pCSwitchboard );

        CheckIoCompletion(PostSwitchboard);
        m_pCSwitchboard->SetQValsReply(
            &m_sgaddr,
            m_qwUserId,
            m_dwContext,
            m_fNotFound,
            m_fNoSuchUser);

        Release();
    }

    virtual const char* GetContextDesc() { return "SetQValsReply"; }

protected:
    CSwitchboard *m_pCSwitchboard;

public:
    SGADDR m_sgaddr;
    QWORD m_qwUserId;
    DWORD m_dwContext;
    BOOL m_fNotFound;
    BOOL m_fNoSuchUser;
};


/*****************************************************************************

CAddAffiliatesContext

*****************************************************************************/
class CAddAffiliatesContext : public CLocalContext
{
public:
    CAddAffiliatesContext(
        CSwitchboard *pSwitchboard,
        CProfileStore *pCProfileStore) :
        m_pCSwitchboard(pSwitchboard),
        m_pCProfileStore(pCProfileStore),
        m_fProcessed(FALSE),
        m_qwUserID(0),
        m_cwAffiliates(0),
        m_pqwAffiliates(NULL),
        m_hr(S_OK),
        m_dwTitleID(0),
        m_dwListFlag(0),
        m_mtDateUpdated(0),
        m_pCPresence(NULL),
        m_prgAffiliateLists(NULL)
    {
        g_Counters.SafeIncrement32(XPPERF_SERVER_SQL_WORK_ITEMS);
    }

    virtual ~CAddAffiliatesContext()
    {
        if (m_pqwAffiliates != NULL)
        {
            delete[] m_pqwAffiliates;
        }
        g_Counters.SafeDecrement32(XPPERF_SERVER_SQL_WORK_ITEMS);

        if (m_prgAffiliateLists)
        {
            for (DWORD dwList = 0; dwList < NUM_STORED_AFFILIATE_LISTS; dwList++)
            {
                delete m_prgAffiliateLists[dwList];
                m_prgAffiliateLists[dwList] = NULL;
            }

            delete[] m_prgAffiliateLists;
        }

        SAFE_RELEASE(m_pCPresence);
    }

    IMPLEMENT_REFCOUNT

    HRESULT SetAffiliates(
        WORD cwAffiliates,
        QWORD *pqwAffiliates)
    {
        HRESULT hr = S_OK;

        XOMASSERT(m_cwAffiliates == 0);
        XOMASSERT(m_pqwAffiliates == NULL);

        m_pqwAffiliates = new QWORD[cwAffiliates];
        if (m_pqwAffiliates != NULL)
        {
            memcpy(m_pqwAffiliates, pqwAffiliates, cwAffiliates * sizeof(QWORD));
            m_cwAffiliates = cwAffiliates;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        return hr;
    }

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual void CompletionProc()
    {
        XOMASSERT( NULL != m_pCSwitchboard );

        HRESULT hr = S_OK;

        if (!m_fProcessed)
        {
            CScopeTimer scope( XPPERF_SERVER_ADD_AFFILIATES_STORE_TIME_AVERAGE, XPPERF_SERVER_ADD_AFFILIATES_STORE_TIME_BASE );
            CheckIoCompletion( PostSql );
            hr = m_pCProfileStore->StoreAddAffiliates(this);
        }
        else
        {
            CScopeTimer scope( XPPERF_SERVER_ADD_AFFILIATES_COMPLETION_TIME_AVERAGE, XPPERF_SERVER_ADD_AFFILIATES_COMPLETION_TIME_BASE );
            CheckIoCompletion( PostSwitchboard );
            hr = m_pCSwitchboard->AddAffiliatesComplete(this);
        }
    }

    virtual const char* GetContextDesc() { return "AddAffiliates"; }

protected:
    CSwitchboard *m_pCSwitchboard;
    CProfileStore *m_pCProfileStore;

public:
    BOOL m_fProcessed;

    // Input
    QWORD m_qwUserID;
    DWORD m_dwTitleID;
    DWORD m_dwListFlag;
    WORD m_cwAffiliates;
    QWORD *m_pqwAffiliates;
    MSGTIME m_mtDateUpdated;

    // Output
    HRESULT m_hr;
    CAffiliatesList **m_prgAffiliateLists;

    CPresence *m_pCPresence;

};

class CStoreAffiliatesContext : public CLocalContext
{
public:
    CStoreAffiliatesContext(
        CSwitchboard *pSwitchboard,
        CProfileStore *pCProfileStore) :
        m_pCSwitchboard(pSwitchboard),
        m_pCProfileStore(pCProfileStore),
        m_qwUserID(0),
        m_hr(S_OK),
        m_pCPresence(NULL),
        m_prgAffiliateLists(NULL),
        m_mtAffiliatesLoaded(0),
        m_fProcessed(FALSE)
    {
        g_Counters.SafeIncrement32(XPPERF_SERVER_SQL_WORK_ITEMS);
    }

    virtual ~CStoreAffiliatesContext()
    {
        g_Counters.SafeDecrement32(XPPERF_SERVER_SQL_WORK_ITEMS);

        if (m_prgAffiliateLists)
        {
            for (DWORD dwList = 0; dwList < NUM_STORED_AFFILIATE_LISTS; dwList++)
            {
                delete m_prgAffiliateLists[dwList];
                m_prgAffiliateLists[dwList] = NULL;
            }

            delete[] m_prgAffiliateLists;
        }

        SAFE_RELEASE(m_pCPresence);
    }

    IMPLEMENT_REFCOUNT

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual void CompletionProc()
    {
        XOMASSERT( NULL != m_pCSwitchboard );

        if (!m_fProcessed)
        {
            CScopeTimer scope( XPPERF_SERVER_ADD_AFFILIATES_STORE_TIME_AVERAGE, XPPERF_SERVER_ADD_AFFILIATES_STORE_TIME_BASE );
            CheckIoCompletion( PostSql );
            m_pCProfileStore->StoreStoreAffiliates(this);
        }
        else
        {
            CheckIoCompletion( PostSwitchboard );
            Release();
        }
    }

    virtual const char* GetContextDesc() { return "StoreAffiliates"; }


    CSwitchboard *m_pCSwitchboard;
    CProfileStore *m_pCProfileStore;

    // Input
    QWORD m_qwUserID;
    CAffiliatesList **m_prgAffiliateLists;
    MSGTIME m_mtAffiliatesLoaded;

    // Output
    HRESULT m_hr;
    BOOL m_fProcessed;

    CPresence *m_pCPresence;
};

/*****************************************************************************

CQueryAffiliatesContext

*****************************************************************************/
class CQueryAffiliatesContext :
    public CLocalContext,
    public CPresenceInfoContext
{
public:

    enum QueryAffiliatesState
    {
        QueryAffiliates_Init,
        QueryAffiliates_LoadList,
        QueryAffiliates_ListLoaded,
        QueryAffiliates_WaitForPresence,
        QueryAffiliates_PresenceObtained,
        QueryAffiliates_Complete
    };

    CQueryAffiliatesContext(
        CSwitchboard *pSwitchboard,
        CProfileStore *pCProfileStore) :
        m_pCSwitchboard(pSwitchboard),
        m_pCProfileStore(pCProfileStore),
        m_eState(QueryAffiliates_Init),
        m_hr(S_OK),
        m_dwListFlags(0),
        m_cdwLimit(0),
        m_dwTitleID(0),
        m_pCReplyConn(NULL),
        m_dwSeqNum(0),
        m_cdwResults(0),
        m_rgResults(NULL),
        m_prgAffiliateLists(NULL),
        m_pCPresence(NULL)
    {
        g_Counters.SafeIncrement32(XPPERF_SERVER_SQL_WORK_ITEMS);
    }

    virtual ~CQueryAffiliatesContext()
    {
        if (m_rgResults != NULL)
        {
            delete[] m_rgResults;
        }

        if (m_prgAffiliateLists)
        {
            for (DWORD dwList = 0; dwList < NUM_STORED_AFFILIATE_LISTS; dwList++)
            {
                delete m_prgAffiliateLists[dwList];
                m_prgAffiliateLists[dwList] = NULL;
            }

            delete[] m_prgAffiliateLists;
        }

        SAFE_RELEASE(m_pCReplyConn);
        SAFE_RELEASE(m_pCPresence);

        g_Counters.SafeDecrement32(XPPERF_SERVER_SQL_WORK_ITEMS);
    }

    IMPLEMENT_REFCOUNT

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    HRESULT BuildResultsList(
        CPresence *pCPresence)
    {
        if (pCPresence == NULL)
        {
            return E_INVALIDARG;
        }

        if ((m_cdwResults != 0) ||
            (m_rgResults != NULL))
        {
            return E_UNEXPECTED;
        }

        HRESULT hr;
        CAffiliatesList rgAffiliatesLists[NUM_STORED_AFFILIATE_LISTS];

        if (m_dwListFlags & X_AFFILIATE_INDEX_TO_FLAG(X_AFFILIATE_FRIEND_INDEX))
        {
            m_cdwResults += pCPresence->GetNumBuddies();
        }

        if (m_dwListFlags & X_AFFILIATE_INDEX_TO_FLAG(X_AFFILIATE_BLOCK_INDEX))
        {
            m_cdwResults += pCPresence->GetNeverListCount();
        }

        for (DWORD dwFlags = m_dwListFlags; dwFlags; dwFlags &= (dwFlags - 1))
        {
            DWORD dwListFlag = dwFlags - (dwFlags & (dwFlags - 1));
            DWORD dwListIndex = X_AFFILIATE_FLAG_TO_INDEX(dwListFlag);

            if (dwListIndex >= NUM_STORED_AFFILIATE_LISTS)
            {
                // this is a special flag, skip it.
                continue;
            }

            hr = pCPresence->GetAffiliates(dwListFlag, &(rgAffiliatesLists[dwListIndex]));
            if (FAILED(hr))
            {
                m_cdwResults = 0;
                return hr;
            }

            m_cdwResults += rgAffiliatesLists[dwListIndex].dwSize;
        }

        // build CPresenceInfoContext PUID list also
        m_rgPUIDs = new QWORD[m_cdwResults];
        if (m_rgPUIDs == NULL)
        {
            return E_OUTOFMEMORY;
        }

        m_rgResults = new P_QUERY_AFFILIATES_REPLY_DATA_MSG[m_cdwResults];
        if (m_rgResults == NULL)
        {
            m_cdwResults = 0;
            return E_OUTOFMEMORY;
        }

        m_cdwResults = 0;
        m_cdwPUIDs = 0;

        if (m_dwListFlags & X_AFFILIATE_INDEX_TO_FLAG(X_AFFILIATE_FRIEND_INDEX))
        {
            for (DWORD iResult = 0; iResult < pCPresence->GetNumBuddies(); iResult++)
            {
                m_rgResults[m_cdwResults].dwListFlags = X_AFFILIATE_INDEX_TO_FLAG(X_AFFILIATE_FRIEND_INDEX);
                m_rgResults[m_cdwResults].dwTitleID = 0;
                m_rgResults[m_cdwResults].qwAffiliateID = pCPresence->GetBuddy(iResult)->GetBuddyID();
                m_rgResults[m_cdwResults].qwSessionID = 0;
                m_rgResults[m_cdwResults].szGamerTag[0] = '\0';
                m_rgResults[m_cdwResults].mtDateUpdated = 0;
                m_cdwResults++;

                // build CPresenceInfoContext PUID list also

                // check for duplicates
                DWORD iPUID;
                for (iPUID = 0; iPUID < m_cdwPUIDs; iPUID++)
                {
                    if (m_rgPUIDs[iPUID] == pCPresence->GetBuddy(iResult)->GetBuddyID())
                    {
                        //duplicate found
                        break;
                    }
                }

                if (iPUID == m_cdwPUIDs)
                {
                    m_rgPUIDs[m_cdwPUIDs] = pCPresence->GetBuddy(iResult)->GetBuddyID();
                    m_cdwPUIDs++;
                }
            }
        }

        if (m_dwListFlags & X_AFFILIATE_INDEX_TO_FLAG(X_AFFILIATE_BLOCK_INDEX))
        {
            const QWORD *rgNevers = pCPresence->GetNeverList();

            for (DWORD iResult = 0; iResult < pCPresence->GetNeverListCount(); iResult++)
            {
                m_rgResults[m_cdwResults].dwListFlags = X_AFFILIATE_INDEX_TO_FLAG(X_AFFILIATE_BLOCK_INDEX);
                m_rgResults[m_cdwResults].dwTitleID = 0;
                m_rgResults[m_cdwResults].qwAffiliateID = rgNevers[iResult];
                m_rgResults[m_cdwResults].qwSessionID = 0;
                m_rgResults[m_cdwResults].szGamerTag[0] = '\0';
                m_rgResults[m_cdwResults].mtDateUpdated = 0;
                m_cdwResults++;

                // build CPresenceInfoContext PUID list also

                // check for duplicates
                DWORD iPUID;
                for (iPUID = 0; iPUID < m_cdwPUIDs; iPUID++)
                {
                    if (m_rgPUIDs[iPUID] == rgNevers[iResult])
                    {
                        //duplicate found
                        break;
                    }
                }

                if (iPUID == m_cdwPUIDs)
                {
                    m_rgPUIDs[m_cdwPUIDs] = rgNevers[iResult];
                    m_cdwPUIDs++;
                }
            }
        }

        for (DWORD dwFlags = m_dwListFlags; dwFlags; dwFlags &= (dwFlags - 1))
        {
            DWORD dwListFlag = dwFlags - (dwFlags & (dwFlags - 1));
            DWORD dwListIndex = X_AFFILIATE_FLAG_TO_INDEX(dwListFlag);

            if (dwListIndex >= NUM_STORED_AFFILIATE_LISTS)
            {
                // this is a special flag, skip it.
                continue;
            }

            for (DWORD iResult = 0; iResult < rgAffiliatesLists[dwListIndex].dwSize; iResult++)
            {
                m_rgResults[m_cdwResults].dwListFlags = dwListFlag;
                m_rgResults[m_cdwResults].dwTitleID = rgAffiliatesLists[dwListIndex].rgAffiliates[iResult].dwTitleID;
                m_rgResults[m_cdwResults].qwAffiliateID = rgAffiliatesLists[dwListIndex].rgAffiliates[iResult].qwAffiliateID;
                m_rgResults[m_cdwResults].qwSessionID = 0;
                m_rgResults[m_cdwResults].szGamerTag[0] = '\0';
                m_rgResults[m_cdwResults].mtDateUpdated = rgAffiliatesLists[dwListIndex].rgAffiliates[iResult].mtDateUpdated;
                m_cdwResults++;

                // build CPresenceInfoContext PUID list also

                // check for duplicates
                DWORD iPUID;
                for (iPUID = 0; iPUID < m_cdwPUIDs; iPUID++)
                {
                    if (m_rgPUIDs[iPUID] == rgAffiliatesLists[dwListIndex].rgAffiliates[iResult].qwAffiliateID)
                    {
                        //duplicate found
                        break;
                    }
                }

                if (iPUID == m_cdwPUIDs)
                {
                    m_rgPUIDs[m_cdwPUIDs] = rgAffiliatesLists[dwListIndex].rgAffiliates[iResult].qwAffiliateID;
                    m_cdwPUIDs++;
                }
            }

            delete[] rgAffiliatesLists[dwListIndex].rgAffiliates;
            rgAffiliatesLists[dwListIndex].rgAffiliates = NULL;
        }

        return S_OK;
    }

    virtual HRESULT ApplyPresenceData(DWORD cdwAffiliates, P_PRESENCE_INFO_DATA_MSG *pReply)
    {
        HRESULT hr = S_OK;

        // we should only be here if we were asked to get online users.
        XOMASSERT(m_dwTitleID != 0);
        XOMASSERT(m_cPendingServerReplies > 0);

        // TODO: n-squared!!
        while (cdwAffiliates > 0)
        {
            for (DWORD iInternal = 0; iInternal < m_cdwResults; iInternal++)
            {
                if (pReply->qwUserID == m_rgResults[iInternal].qwAffiliateID)
                {
                    // check for a nonzero session id, and the titleid in question.
                    BOOL fUse = (pReply->qwSessionID != 0) && (pReply->dwTitleID == m_dwTitleID);

                    // check to see if the user is "hiding."  this could be due to the appear offline setting, or parental controls.
                    if (fUse &&
                        (!(pReply->dwState & P_STATE_MASK_ONLINE) ||
                        (pReply->dwState & P_STATE_MASK_CLOAKED)))
                    {
                        // check if this entry is a positive affiliation.
                        if (m_rgResults[iInternal].dwListFlags & (
                            X_AFFILIATE_INDEX_TO_FLAG(X_AFFILIATE_COMPLETED_GAME_INDEX) |
                            X_AFFILIATE_INDEX_TO_FLAG(X_AFFILIATE_ENCOUNTERED_INDEX) |
                            X_AFFILIATE_INDEX_TO_FLAG(X_AFFILIATE_FAVORITES_INDEX) |
                            X_AFFILIATE_INDEX_TO_FLAG(X_AFFILIATE_FRIEND_INDEX) |
                            X_AFFILIATE_INDEX_TO_FLAG(X_AFFILIATE_POSITIVE_FEEDBACK_INDEX)))
                        {
                            // we remove the positive affiliates if they are hiding.  negative ones still persist.
                            fUse = FALSE;
                        }
                    }

                    if (fUse)
                    {
                        // add presence data.
                        m_rgResults[iInternal].qwSessionID = pReply->qwSessionID;
                        memcpy(m_rgResults[iInternal].szGamerTag, pReply->szGamerTag, XONLINE_GAMERTAG_SIZE);
                    }
                    else
                    {
                        // remove this result.
                        m_cdwResults--;
                        memcpy(&(m_rgResults[iInternal]), &(m_rgResults[m_cdwResults]), sizeof(P_QUERY_AFFILIATES_REPLY_DATA_MSG));
                        iInternal--;
                    }

                    //cant break here.  there may be multiple results with the same affiliateID.
                }
            }

            pReply = (P_PRESENCE_INFO_DATA_MSG *)((BYTE *)(pReply + 1) + pReply->cbStateData + pReply->cbRichPresence);
            cdwAffiliates--;
        }

        m_cPendingServerReplies--;
        if (m_cPendingServerReplies == 0)
        {
            m_eState = QueryAffiliates_PresenceObtained;
            m_pCSwitchboard->PostCompletion(this);
        }

        return hr;
    }

    virtual void CompletionProc()
    {
        XOMASSERT(NULL != m_pCSwitchboard);
        XOMASSERT(NULL != m_pCProfileStore);

        HRESULT hr = S_OK;

        switch(m_eState)
        {
        case QueryAffiliates_Init:
            XOMASSERT(FALSE);
            break;

        case QueryAffiliates_LoadList:
        {
            CScopeTimer scope( XPPERF_SERVER_QUERY_AFFILIATES_STORE_TIME_AVERAGE, XPPERF_SERVER_QUERY_AFFILIATES_STORE_TIME_BASE );
            CheckIoCompletion( PostSql );
            hr = m_pCProfileStore->StoreQueryAffiliates(this);
            break;
        }

        case QueryAffiliates_ListLoaded:
        {
            hr = m_pCSwitchboard->QueryAffiliatesStoreComplete(this);
        }
            // fall through
        case QueryAffiliates_WaitForPresence:
            if (m_dwTitleID != 0)
            {
                CScopeTimer scope( XPPERF_SERVER_GET_PRESENCE_INFO_PEER_TIME_AVERAGE, XPPERF_SERVER_GET_PRESENCE_INFO_PEER_TIME_BASE );
                CheckIoCompletion( PostSwitchboard );
                hr = m_pCSwitchboard->SendGetPresenceInfo(this);
                break;
            }
            // else fall through
        case QueryAffiliates_PresenceObtained:
            // fall through
        case QueryAffiliates_Complete:
        {
            CScopeTimer scope( XPPERF_SERVER_QUERY_AFFILIATES_COMPLETION_TIME_AVERAGE, XPPERF_SERVER_QUERY_AFFILIATES_COMPLETION_TIME_BASE );
            CheckIoCompletion( PostSwitchboard );
            hr = m_pCSwitchboard->QueryAffiliatesComplete(this);
            break;
        }

        default:
            XOMASSERT(FALSE);
            break;
        }
    }

    virtual const char* GetContextDesc() { return "QueryAffiliates"; }

protected:
    CSwitchboard *m_pCSwitchboard;
    CProfileStore *m_pCProfileStore;

public:
    QueryAffiliatesState m_eState;

    // Input
    CClientConnection *m_pCReplyConn;
    DWORD m_dwListFlags;
    DWORD m_cdwLimit;
    DWORD m_dwTitleID;
    DWORD m_dwSeqNum;

    // Output
    HRESULT m_hr;
    DWORD m_cdwResults;
    P_QUERY_AFFILIATES_REPLY_DATA_MSG *m_rgResults;
    CAffiliatesList **m_prgAffiliateLists;

    CPresence *m_pCPresence;
};

/*****************************************************************************

CAcceptBuddyContext

*****************************************************************************/
class CAcceptBuddyContext : public CLocalContext
{
public:
    CAcceptBuddyContext(
        CSwitchboard *pSwitchboard,
        CProfileStore *pCProfileStore) :
        m_pCSwitchboard(pSwitchboard),
        m_pCProfileStore(pCProfileStore),
        m_fProcessed(FALSE),
        m_qwUserID(0),
        m_qwBuddyID(0),
        m_hr(S_OK),
        m_dwUserBuddyListVersion(0),
        m_cbUserAccountName(0),
        m_dwBuddyBuddyListVersion(0),
        m_cbBuddyAccountName(0),
        m_pCPresence(NULL)
    {
        m_szUserAccountName[0] = '\0';
        m_szBuddyAccountName[0] = '\0';
        g_Counters.SafeIncrement32(XPPERF_SERVER_SQL_WORK_ITEMS);
    }

    virtual ~CAcceptBuddyContext()
    {
        SAFE_RELEASE(m_pCPresence);
        g_Counters.SafeDecrement32(XPPERF_SERVER_SQL_WORK_ITEMS);
    }

    IMPLEMENT_REFCOUNT

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual void CompletionProc()
    {
        XOMASSERT( NULL != m_pCSwitchboard );

        HRESULT hr = S_OK;

        if (!m_fProcessed)
        {
            CScopeTimer scope( XPPERF_SERVER_ACCEPT_BUDDY_STORE_TIME_AVERAGE, XPPERF_SERVER_ACCEPT_BUDDY_STORE_TIME_BASE );
            CheckIoCompletion( PostSql );
            hr = m_pCProfileStore->StoreAcceptBuddy(this);
        }
        else
        {
            CScopeTimer scope( XPPERF_SERVER_ACCEPT_BUDDY_COMPLETION_TIME_AVERAGE, XPPERF_SERVER_ACCEPT_BUDDY_COMPLETION_TIME_BASE );
            CheckIoCompletion( PostSwitchboard );
            hr = m_pCSwitchboard->AcceptBuddyComplete(this);
        }
    }

    virtual const char* GetContextDesc() { return "AcceptBuddy"; }

protected:
    CSwitchboard *m_pCSwitchboard;
    CProfileStore *m_pCProfileStore;

public:
    BOOL m_fProcessed;

    // Input
    QWORD m_qwUserID;
    QWORD m_qwBuddyID;

    // Output
    HRESULT m_hr;
    DWORD m_dwUserBuddyListVersion;
    DWORD m_cbUserAccountName;
    DWORD m_dwBuddyBuddyListVersion;
    DWORD m_cbBuddyAccountName;

    // Account names at end to be cache friendly
    char m_szUserAccountName[ MAX_ACCTNAME_BYTES + 1 ];
    char m_szBuddyAccountName[ MAX_ACCTNAME_BYTES + 1 ];

    CPresence *m_pCPresence;
};

/*****************************************************************************

CRejectBuddyContext

*****************************************************************************/
class CRejectBuddyContext : public CLocalContext
{
public:
    CRejectBuddyContext(
        CSwitchboard *pSwitchboard,
        CProfileStore *pCProfileStore) :
        m_pCSwitchboard(pSwitchboard),
        m_pCProfileStore(pCProfileStore),
        m_fProcessed(FALSE),
        m_qwUserID(0),
        m_qwBuddyID(0),
        m_fNever(FALSE),
        m_hr(S_OK),
        m_dwUserBuddyListVersion(0),
        m_dwBuddyBuddyListVersion(0),
        m_pCPresence(NULL)
    {
        g_Counters.SafeIncrement32(XPPERF_SERVER_SQL_WORK_ITEMS);
    }

    virtual ~CRejectBuddyContext()
    {
        SAFE_RELEASE(m_pCPresence);
        g_Counters.SafeDecrement32(XPPERF_SERVER_SQL_WORK_ITEMS);
    }

    IMPLEMENT_REFCOUNT

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual void CompletionProc()
    {
        XOMASSERT( NULL != m_pCSwitchboard );

        HRESULT hr = S_OK;

        if (!m_fProcessed)
        {
            CScopeTimer scope( XPPERF_SERVER_REJECT_BUDDY_STORE_TIME_AVERAGE, XPPERF_SERVER_REJECT_BUDDY_STORE_TIME_BASE );
            CheckIoCompletion( PostSql );
            hr = m_pCProfileStore->StoreRejectBuddy(this);
        }
        else
        {
            CScopeTimer scope( XPPERF_SERVER_REJECT_BUDDY_COMPLETION_TIME_AVERAGE, XPPERF_SERVER_REJECT_BUDDY_COMPLETION_TIME_BASE );
            CheckIoCompletion( PostSwitchboard );
            hr = m_pCSwitchboard->RejectBuddyComplete(this);
        }
    }

    virtual const char* GetContextDesc() { return "RejectBuddy"; }

protected:
    CSwitchboard *m_pCSwitchboard;
    CProfileStore *m_pCProfileStore;

public:
    BOOL m_fProcessed;

    // Input
    QWORD m_qwUserID;
    QWORD m_qwBuddyID;
    BOOL m_fNever;

    // Output
    HRESULT m_hr;
    DWORD m_dwUserBuddyListVersion;
    DWORD m_dwBuddyBuddyListVersion;

    CPresence *m_pCPresence;
};

/*****************************************************************************

CDeleteBuddyContext

*****************************************************************************/
class CDeleteBuddyContext : public CLocalContext
{
public:
    CDeleteBuddyContext(
        CSwitchboard *pSwitchboard,
        CProfileStore *pCProfileStore) :
        m_pCSwitchboard(pSwitchboard),
        m_pCProfileStore(pCProfileStore),
        m_fProcessed(FALSE),
        m_qwUserID(0),
        m_qwBuddyID(0),
        m_hr(S_OK),
        m_dwUserBuddyListVersion(0),
        m_dwBuddyBuddyListVersion(0),
        m_pCPresence(NULL)
    {
        g_Counters.SafeIncrement32(XPPERF_SERVER_SQL_WORK_ITEMS);
    }

    virtual ~CDeleteBuddyContext()
    {
        SAFE_RELEASE(m_pCPresence);
        g_Counters.SafeDecrement32(XPPERF_SERVER_SQL_WORK_ITEMS);
    }

    IMPLEMENT_REFCOUNT

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual void CompletionProc()
    {
        XOMASSERT( NULL != m_pCSwitchboard );

        HRESULT hr = S_OK;

        if (!m_fProcessed)
        {
            CScopeTimer scope( XPPERF_SERVER_DELETE_BUDDY_STORE_TIME_AVERAGE, XPPERF_SERVER_DELETE_BUDDY_STORE_TIME_BASE );
            CheckIoCompletion( PostSql );
            hr = m_pCProfileStore->StoreDeleteBuddy(this);
        }
        else
        {
            CScopeTimer scope( XPPERF_SERVER_DELETE_BUDDY_COMPLETION_TIME_AVERAGE, XPPERF_SERVER_DELETE_BUDDY_COMPLETION_TIME_BASE );
            CheckIoCompletion( PostSwitchboard );
            hr = m_pCSwitchboard->DeleteBuddyComplete(this);
        }
    }

    virtual const char* GetContextDesc() { return "DeleteBuddy"; }

protected:
    CSwitchboard *m_pCSwitchboard;
    CProfileStore *m_pCProfileStore;

public:
    BOOL m_fProcessed;

    // Input
    QWORD m_qwUserID;
    QWORD m_qwBuddyID;

    // Output
    HRESULT m_hr;
    DWORD m_dwUserBuddyListVersion;
    DWORD m_dwBuddyBuddyListVersion;

    CPresence *m_pCPresence;
};


/*****************************************************************************

CBlockContext

*****************************************************************************/
class CBlockContext : public CLocalContext
{
public:
    CBlockContext(
        CSwitchboard *pSwitchboard,
        CProfileStore *pCProfileStore) :
        m_pCSwitchboard(pSwitchboard),
        m_pCProfileStore(pCProfileStore),
        m_fProcessed(FALSE),
        m_qwUserID(0),
        m_qwBlockID(0),
        m_hr(S_OK),
        m_dwBlockListVersion(0),
        m_pCPresence(NULL)
    {
        g_Counters.SafeIncrement32(XPPERF_SERVER_SQL_WORK_ITEMS);
    }

    virtual ~CBlockContext()
    {
        SAFE_RELEASE(m_pCPresence);
        g_Counters.SafeDecrement32(XPPERF_SERVER_SQL_WORK_ITEMS);
    }

    IMPLEMENT_REFCOUNT

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual void CompletionProc()
    {
        XOMASSERT( NULL != m_pCSwitchboard );

        HRESULT hr = S_OK;

        if (!m_fProcessed)
        {
            CScopeTimer scope( XPPERF_SERVER_MUTE_STORE_TIME_AVERAGE, XPPERF_SERVER_MUTE_STORE_TIME_BASE );
            CheckIoCompletion( PostSql );
            hr = m_pCProfileStore->StoreBlock(this);
        }
        else
        {
            CScopeTimer scope( XPPERF_SERVER_MUTE_COMPLETION_TIME_AVERAGE, XPPERF_SERVER_MUTE_COMPLETION_TIME_BASE );
            CheckIoCompletion( PostSwitchboard );
            hr = m_pCSwitchboard->BlockComplete(this);
        }
    }

    virtual const char* GetContextDesc() { return "BlockUser"; }

protected:
    CSwitchboard *m_pCSwitchboard;
    CProfileStore *m_pCProfileStore;

public:
    BOOL m_fProcessed;

    // Input
    QWORD m_qwUserID;
    QWORD m_qwBlockID;

    // Output
    HRESULT m_hr;
    DWORD m_dwBlockListVersion;

    CPresence *m_pCPresence;
};

/*****************************************************************************

CUnblockContext

*****************************************************************************/
class CUnblockContext : public CLocalContext
{
public:
    CUnblockContext(
        CSwitchboard *pSwitchboard,
        CProfileStore *pCProfileStore) :
        m_pCSwitchboard(pSwitchboard),
        m_pCProfileStore(pCProfileStore),
        m_fProcessed(FALSE),
        m_qwUserID(0),
        m_qwBlockID(0),
        m_hr(S_OK),
        m_dwBlockListVersion(0),
        m_pCPresence(NULL)
    {
        g_Counters.SafeIncrement32(XPPERF_SERVER_SQL_WORK_ITEMS);
    }

    virtual ~CUnblockContext()
    {
        SAFE_RELEASE(m_pCPresence);
        g_Counters.SafeDecrement32(XPPERF_SERVER_SQL_WORK_ITEMS);
    }

    IMPLEMENT_REFCOUNT

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual void CompletionProc()
    {
        XOMASSERT( NULL != m_pCSwitchboard );

        HRESULT hr = S_OK;

        if (!m_fProcessed)
        {
            CScopeTimer scope( XPPERF_SERVER_UNMUTE_STORE_TIME_AVERAGE, XPPERF_SERVER_UNMUTE_STORE_TIME_BASE );
            CheckIoCompletion( PostSql );
            hr = m_pCProfileStore->StoreUnblock(this);
        }
        else
        {
            CScopeTimer scope( XPPERF_SERVER_UNMUTE_COMPLETION_TIME_AVERAGE, XPPERF_SERVER_UNMUTE_COMPLETION_TIME_BASE );
            CheckIoCompletion( PostSwitchboard );
            hr = m_pCSwitchboard->UnblockComplete(this);
        }
    }

    virtual const char* GetContextDesc() { return "UnblockUser"; }

protected:
    CSwitchboard *m_pCSwitchboard;
    CProfileStore *m_pCProfileStore;

public:
    BOOL m_fProcessed;

    // Input
    QWORD m_qwUserID;
    QWORD m_qwBlockID;

    // Output
    HRESULT m_hr;
    DWORD m_dwBlockListVersion;

    CPresence *m_pCPresence;
};


/*****************************************************************************

CClearAllBlocksContext

*****************************************************************************/
class CClearAllBlocksContext : public CLocalContext
{
public:
    CClearAllBlocksContext(
        CSwitchboard *pSwitchboard,
        CProfileStore *pCProfileStore) :
        m_pCSwitchboard(pSwitchboard),
        m_pCProfileStore(pCProfileStore),
        m_fProcessed(FALSE),
        m_qwUserID(0),
        m_hr(S_OK),
        m_dwBlockListVersion(0),
        m_pCPresence(NULL)
    {
        g_Counters.SafeIncrement32(XPPERF_SERVER_SQL_WORK_ITEMS);
    }

    virtual ~CClearAllBlocksContext()
    {
        SAFE_RELEASE(m_pCPresence);
        g_Counters.SafeDecrement32(XPPERF_SERVER_SQL_WORK_ITEMS);
    }

    IMPLEMENT_REFCOUNT

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual void CompletionProc()
    {
        XOMASSERT( NULL != m_pCSwitchboard );

        HRESULT hr = S_OK;

        if (!m_fProcessed)
        {
            CScopeTimer scope( XPPERF_SERVER_UNMUTE_STORE_TIME_AVERAGE, XPPERF_SERVER_UNMUTE_STORE_TIME_BASE );
            CheckIoCompletion( PostSql );
            hr = m_pCProfileStore->StoreClearAllBlocks(this);
        }
        else
        {
            CScopeTimer scope( XPPERF_SERVER_UNMUTE_COMPLETION_TIME_AVERAGE, XPPERF_SERVER_UNMUTE_COMPLETION_TIME_BASE );
            CheckIoCompletion( PostSwitchboard );
            hr = m_pCSwitchboard->ClearAllBlocksComplete(this);
        }
    }

    virtual const char* GetContextDesc() { return "ClearAllBlocks"; }

protected:
    CSwitchboard *m_pCSwitchboard;
    CProfileStore *m_pCProfileStore;

public:
    BOOL m_fProcessed;

    // Input
    QWORD m_qwUserID;

    // Output
    HRESULT m_hr;
    DWORD m_dwBlockListVersion;

    CPresence *m_pCPresence;
};


/*****************************************************************************

CSetFlushTicketsContext

*****************************************************************************/
class CSetFlushTicketsContext : public CLocalContext
{
public:
    CSetFlushTicketsContext(
        CSwitchboard *pSwitchboard,
        CProfileStore *pCProfileStore) :
        m_pCSwitchboard(pSwitchboard),
        m_pCProfileStore(pCProfileStore),
        m_hr(S_OK)
    {
        g_Counters.SafeIncrement32(XPPERF_SERVER_SQL_WORK_ITEMS);
    }

    virtual ~CSetFlushTicketsContext()
    {
        g_Counters.SafeDecrement32(XPPERF_SERVER_SQL_WORK_ITEMS);
    }

    IMPLEMENT_REFCOUNT

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual void CompletionProc()
    {
        XOMASSERT( NULL != m_pCSwitchboard );

        HRESULT hr = S_OK;

        CScopeTimer scope( XPPERF_SERVER_FLUSH_TICKETS_STORE_TIME_AVERAGE, XPPERF_SERVER_FLUSH_TICKETS_STORE_TIME_BASE );
        CheckIoCompletion( PostSql );
        hr = m_pCProfileStore->StoreSetFlushTickets(this);
    }

    virtual const char* GetContextDesc() { return "FlushTickets"; }

protected:
    CSwitchboard *m_pCSwitchboard;
    CProfileStore *m_pCProfileStore;

public:
    // Input
    QWORD m_qwUserID;

    // Output
    HRESULT m_hr;
};


/*****************************************************************************

CLoadOfflinePresenceCaller

allows another context object to be notified when an offline load is complete.

*****************************************************************************/
class CLoadOfflinePresenceCaller
{
public:
    CLoadOfflinePresenceCaller() :
        dwPendingLoads(0)
    {
    }

    virtual HRESULT ProcessUser(CPresence *pCPresence, void *pvData) = 0;
    virtual HRESULT Finalize() = 0;

    HRESULT LoadComplete(HRESULT hrLoad, QWORD qwUserID, CPresence *pCPresence, void *pvData)
    {
        dwPendingLoads--;

        HRESULT hr = hrLoad;
        if (FAILED(hr))
        {
            XomNtEvent(
                XEVENT_PRESENCE_CODE_486,
                "CLoadOfflinePresenceCaller::LoadComplete() failed for user %I64X, hr=0x%x",
                qwUserID,
                hr);

            hr = ProcessUser(NULL, pvData);

            goto lDone;
        }

        hr = ProcessUser(pCPresence, pvData);
        if (FAILED(hr))
        {
            goto lDone;
        }

    lDone:

        if (FAILED(hr))
        {
            XomTrace(
                PresenceDebug,
                L_NORMAL,
                "CLoadOfflinePresenceCaller::ProcessUser() failed for user %I64X, hr=0x%x",
                qwUserID,
                hr);
        }

        if (dwPendingLoads == 0)
        {
            hr = Finalize();
        }

        return hr;
    }

    DWORD dwPendingLoads;
};


/*****************************************************************************

CGetFriendsListContext

*****************************************************************************/
class CGetFriendsListContext :
    public CPresenceInfoContext
{
public:

    CGetFriendsListContext(
        CSwitchboard *pSwitchboard) :
        m_pCSwitchboard(pSwitchboard),
        m_hr(S_OK),
        m_pCReplyConn(NULL),
        m_dwSeqNum(0),
        m_dwReplyType(0),
        m_cdwResults(0),
        m_rgbResults(NULL),
        m_pCPresence(NULL)
    {
    }

    virtual ~CGetFriendsListContext()
    {
        if (m_pCReplyConn != NULL)
        {
            m_pCReplyConn->Release();
        }

        if (m_rgbResults != NULL)
        {
            delete[] m_rgbResults;
        }

        SAFE_RELEASE(m_pCPresence);
    }

    IMPLEMENT_REFCOUNT

    virtual HRESULT ApplyPresenceData(DWORD cdwPUIDs, P_PRESENCE_INFO_DATA_MSG * pReply)
    {
        HRESULT hr = S_OK;

        // we should only be here if we were asked to get online users.
        XOMASSERT(m_cPendingServerReplies > 0);

        // TODO: n-squared!!
        while (cdwPUIDs > 0)
        {
            P_GET_FRIENDS_LIST_REPLY_DATA *pResult = (P_GET_FRIENDS_LIST_REPLY_DATA *)m_rgbResults;
            for (DWORD iInternal = 0; iInternal < m_cdwResults; iInternal++)
            {
                if (pReply->qwUserID == pResult->qwFriendID)
                {
                    pResult->cbStateData = pReply->cbStateData;
                    pResult->cbRichPresence = pReply->cbRichPresence;
                    pResult->dwOnlineState = pReply->dwState;
                    pResult->dwTitleID = pReply->dwTitleID;
                    pResult->mtLastActive = pReply->mtLastActive;
                    memcpy(pResult->szGamerTag, pReply->szGamerTag, XONLINE_GAMERTAG_SIZE);
                    memcpy(pResult + 1, pReply + 1, pReply->cbStateData);
                    memcpy((BYTE *)(pResult + 1) + pReply->cbStateData, (BYTE *)(pReply + 1) + pReply->cbStateData, pReply->cbRichPresence);
                }

                pResult = (P_GET_FRIENDS_LIST_REPLY_DATA *)((BYTE *)(pResult + 1) + MAX_TITLE_STATE_BYTES + g_CPresCfg.GetMaxRichPresenceBytes());
            }

            pReply = (P_PRESENCE_INFO_DATA_MSG *)((BYTE *)(pReply + 1) + pReply->cbStateData + pReply->cbRichPresence);
            cdwPUIDs--;
        }

        m_cPendingServerReplies--;
        if (m_cPendingServerReplies == 0)
        {
            m_pCSwitchboard->GetFriendsListComplete(this);
        }

        return hr;
    }

    HRESULT BuildResultsList()
    {
        if (m_pCPresence == NULL)
        {
            return E_INVALIDARG;
        }

        if ((m_cdwResults != 0) ||
            (m_rgbResults != NULL))
        {
            return E_UNEXPECTED;
        }

        // build CPresenceInfoContext PUID list also
        m_rgPUIDs = new QWORD[m_pCPresence->GetNumBuddies()];
        if (m_rgPUIDs == NULL)
        {
            return E_OUTOFMEMORY;
        }

        // allocate max space for RP data.  we'll have to compact it later.  ultimately, the FD will format the RP string anyway.
        m_rgbResults = new BYTE[m_pCPresence->GetNumBuddies() * (sizeof(P_GET_FRIENDS_LIST_REPLY_DATA) + MAX_TITLE_STATE_BYTES + g_CPresCfg.GetMaxRichPresenceBytes())];
        if (m_rgbResults == NULL)
        {
            m_cdwResults = 0;
            return E_OUTOFMEMORY;
        }

        P_GET_FRIENDS_LIST_REPLY_DATA *pResult = (P_GET_FRIENDS_LIST_REPLY_DATA *)m_rgbResults;
        for (m_cdwResults = 0; m_cdwResults < m_pCPresence->GetNumBuddies(); m_cdwResults++)
        {
            CBuddyListEntry *pBuddy = m_pCPresence->GetBuddy(m_cdwResults);
            if (pBuddy == NULL)
            {
                return E_FAIL;
            }

            pResult->qwFriendID = pBuddy->GetBuddyID();
            pResult->dwStatus = pBuddy->GetStatus();
            pResult->cbStateData = 0;
            pResult->cbRichPresence = 0;

            pResult = (P_GET_FRIENDS_LIST_REPLY_DATA *)((BYTE *)(pResult + 1) + MAX_TITLE_STATE_BYTES + g_CPresCfg.GetMaxRichPresenceBytes());

            // build CPresenceInfoContext PUID list also
            m_rgPUIDs[m_cdwResults] = pBuddy->GetBuddyID();
        }

        m_cdwPUIDs = m_cdwResults;

        return S_OK;
    }


protected:
    CSwitchboard *m_pCSwitchboard;

public:

    // Input
    CClientConnection *m_pCReplyConn;
    DWORD m_dwSeqNum;
    DWORD m_dwReplyType;

    // Output
    HRESULT m_hr;
    DWORD m_cdwResults;
    BYTE *m_rgbResults;

    CPresence *m_pCPresence;
};

/*****************************************************************************

CPeerSubscribeExContext

*****************************************************************************/
class CPeerSubscribeExContext :
    public CPresenceInfoContext
{
public:

    CPeerSubscribeExContext(
        CSwitchboard *pSwitchboard) :
        m_pCSwitchboard(pSwitchboard),
        m_hr(S_OK),
        m_pCReplyConn(NULL),
        m_dwSeqNum(0),
        m_cResults(0),
        m_rgResults(NULL),
        m_pCPresence(NULL)
    {
    }

    virtual ~CPeerSubscribeExContext()
    {
        if (m_pCReplyConn != NULL)
        {
            m_pCReplyConn->Release();
        }

        if (m_rgResults != NULL)
        {
            delete[] m_rgResults;
        }

        SAFE_RELEASE(m_pCPresence);
    }

    IMPLEMENT_REFCOUNT

    virtual HRESULT ApplyPresenceData(DWORD cdwPUIDs, P_PRESENCE_INFO_DATA_MSG * pReply)
    {
        HRESULT hr = S_OK;

        // we should only be here if we were asked to get online users.
        XOMASSERT(m_cPendingServerReplies > 0);

        while (cdwPUIDs > 0)
        {
            m_rgResults[m_cResults].dwState = (pReply->dwState & P_STATE_MASK_CLOAKED) ? 0 : pReply->dwState;
            m_rgResults[m_cResults].mtUserTime = pReply->mtLastActive;
            m_rgResults[m_cResults].qwUserID = pReply->qwUserID;
            m_rgResults[m_cResults].dwTitleID = pReply->dwTitleID;
            memcpy(m_rgResults[m_cResults].szGamertag, pReply->szGamerTag, XONLINE_GAMERTAG_SIZE);

            pReply = (P_PRESENCE_INFO_DATA_MSG *)((BYTE *)(pReply + 1) + pReply->cbStateData + pReply->cbRichPresence);
            cdwPUIDs--;
            m_cResults++;
        }

        m_cPendingServerReplies--;
        if (m_cPendingServerReplies == 0)
        {
            hr = m_pCSwitchboard->SendPeerSubscribeExReply(m_dwSeqNum, m_hr, m_cResults, m_rgResults, m_pCReplyConn);
            Release();
        }

        return hr;
    }

    HRESULT BuildResultsList(DWORD cPUIDs, QWORD *rgPUIDs)
    {
        if (m_pCPresence == NULL)
        {
            return E_INVALIDARG;
        }

        if ((m_cResults != 0) ||
            (m_rgResults != NULL))
        {
            return E_UNEXPECTED;
        }

        // build CPresenceInfoContext PUID list
        m_rgPUIDs = new QWORD[cPUIDs];
        if (m_rgPUIDs == NULL)
        {
            return E_OUTOFMEMORY;
        }

        memcpy(m_rgPUIDs, rgPUIDs, cPUIDs * sizeof(QWORD));
        m_cdwPUIDs = cPUIDs;

        m_rgResults = new P_PEER_SUBSCRIBE_EX_DATA[cPUIDs];
        if (m_rgResults == NULL)
        {
            m_cResults = 0;
            return E_OUTOFMEMORY;
        }

        return S_OK;
    }


protected:
    CSwitchboard *m_pCSwitchboard;

public:

    // Input
    CClientConnection *m_pCReplyConn;
    DWORD m_dwSeqNum;

    // Output
    HRESULT m_hr;
    WORD m_cResults;
    P_PEER_SUBSCRIBE_EX_DATA *m_rgResults;

    CPresence *m_pCPresence;
};


class CWebAliveContext :
    public CLoadOfflinePresenceCaller
{
public:

    CWebAliveContext(
        CSwitchboard *pSwitchboard) :
        m_pCSwitchboard(pSwitchboard),
        m_hr(S_OK),
        m_pCReplyConn(NULL),
        m_dwSeqNum(0),
        m_pCPresence(NULL)
    {
    }

    virtual ~CWebAliveContext()
    {
        if (m_pCReplyConn != NULL)
        {
            m_pCReplyConn->Release();
        }

        SAFE_RELEASE(m_pCPresence);
    }

    IMPLEMENT_REFCOUNT

    virtual HRESULT ProcessUser(CPresence * pCPresence, void * pvData)
    {
        if (pCPresence == NULL)
        {
            m_hr = HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
        }
        else
        {
            m_pCPresence = pCPresence;
            pCPresence->AddRef();

            m_hr = m_pCPresence->WebAlive();
        }

        return m_hr;
    }

    virtual HRESULT Finalize()
    {
        HRESULT hr = S_OK;

        if (FAILED(m_hr))
        {
            XomNtEvent(
                XEVENT_PRESENCE_CODE_493,
                "CSwitchboard::WebAlive LoadComplete failed user=%I64X hr=0x%X",
                m_qwUserID,
                m_hr);
        }

        hr = m_pCSwitchboard->SendWebAliveReply(m_qwUserID, m_dwSeqNum, m_hr, m_pCReplyConn);

        Release();

        return hr;
    }

protected:
    CSwitchboard *m_pCSwitchboard;

public:

    // Input
    CClientConnection *m_pCReplyConn;
    DWORD m_dwSeqNum;
    QWORD m_qwUserID;

    // Output
    HRESULT m_hr;
    DWORD m_cdwResults;
    BYTE *m_rgbResults;

    CPresence *m_pCPresence;
};


class CWatchStartContext : public CLoadOfflinePresenceCaller
{
public:

    virtual HRESULT ProcessUser(CPresence * pCPresence, void * pvData)
    {
        if (pCPresence == NULL)
        {
            return HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
        }

        HRESULT hr = S_OK;

        if ((GET_PUID_BITS(qwDestUserID) != pCPresence->GetUserID()) && pCPresence->IsAcceptedBuddy(qwDestUserID))
        {
            CBuddyListEntry *pBuddy = pCPresence->FindBuddy(qwDestUserID);
            if (pBuddy != NULL)
            {
                pBuddy->SetPeerSubscribed(TRUE);

                if (pCPresence->IsOnline())
                {
                    hr = pXPCluster->QueuePresence(pCPresence, &qwDestUserID, 1);
                }
            }
        }
        else
        {
            hr = pCPresence->AddWatcher(qwDestUserID);

            if (pCPresence->IsOnline())
            {
                hr = pXPCluster->QueuePeerPresence(pCPresence, &qwDestUserID, 1);
            }
        }


        return hr;
    }

    virtual HRESULT Finalize()
    {
        delete this;
        return S_OK;
    }


    CXPCluster *pXPCluster;
    QWORD qwDestUserID;
};

class CGetPresenceInfoContext :
    public CLoadOfflinePresenceCaller,
    public CPresenceInfoContext
{
public:

    CGetPresenceInfoContext(CSwitchboard *pSwitchboard) :
        m_pSwitchboard(pSwitchboard),
        dwContext(0),
        qwSenderID(0),
        cdwUsers(0),
        fFromPresence(FALSE),
        pCReplyConn(NULL),
        pBuffer(NULL)
    {
    }

    virtual ~CGetPresenceInfoContext()
    {
        SAFE_RELEASE(pCReplyConn);
        SAFE_ARRAYDELETE(pBuffer);
    }

    IMPLEMENT_REFCOUNT

    virtual HRESULT ProcessUser(CPresence * pCPresence, void * pvData)
    {
        if (pvData == NULL)
        {
            return E_INVALIDARG;
        }

        P_PRESENCE_INFO_DATA_MSG *pReply = (P_PRESENCE_INFO_DATA_MSG *)pvData;

        if (pCPresence == NULL)
        {
            ZeroMemory(pReply, sizeof(P_PRESENCE_INFO_DATA_MSG));
            return HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
        }

        if (pCPresence->CanSharePresence(qwSenderID))
        {
            pReply->dwState = pCPresence->GetState();
            pReply->mtLastActive = pCPresence->GetUserStateChanged();

            if (pReply->cbStateData != 0)
            {
                pReply->cbStateData = (WORD)pCPresence->GetTitleStuffLen();
                memcpy(pReply + 1, pCPresence->GetTitleStuff(), pReply->cbStateData);
            }
            if (pReply->cbRichPresence != 0)
            {
                pReply->cbRichPresence = pCPresence->GetRichPresenceLen();
                memcpy((BYTE *)(pReply + 1) + pReply->cbStateData, pCPresence->GetRichPresenceData(), pReply->cbRichPresence);
            }
        }
        else
        {
            pReply->dwState = P_STATE_MASK_NONE;
            pReply->mtLastActive = 0;
            pReply->cbStateData = 0;
            pReply->cbRichPresence = 0;
        }

        memcpy(pReply->szGamerTag, pCPresence->GetAcctName(), XONLINE_GAMERTAG_SIZE);

        // NOTE: we always return the session ID and the title ID so that QueryAffiliates can return the data to
        // matchmaking.  nobody else should be consuming the session ID, and since we restrict access to the
        // last seen time, we are safe to return the last seen title.
        pReply->qwSessionID = pCPresence->GetMatchSessionID();
        pReply->dwTitleID = pCPresence->GetLastSeenTitleID();

        return S_OK;
    }

    virtual HRESULT ApplyPresenceData(DWORD cdwPUIDs, P_PRESENCE_INFO_DATA_MSG * pReply)
    {
        HRESULT hr = S_OK;

        // we should only be here if we were asked to get online users.
        XOMASSERT(m_cPendingServerReplies > 0);

        // find the end of the local buffer
        P_PRESENCE_INFO_DATA_MSG *pLocalReplyEnd = (P_PRESENCE_INFO_DATA_MSG *)pBuffer;
        for (DWORD iLocalUser = 0; iLocalUser < cdwUsers; iLocalUser++)
        {
            pLocalReplyEnd = (P_PRESENCE_INFO_DATA_MSG *)((BYTE *)(pLocalReplyEnd + 1) + pLocalReplyEnd->cbStateData + pLocalReplyEnd->cbRichPresence);
        }

        // find the end of the remote buffer
        P_PRESENCE_INFO_DATA_MSG *pRemoteReplyEnd = pReply;
        for (DWORD iRemoteUser = 0; iRemoteUser < cdwPUIDs; iRemoteUser++)
        {
            pRemoteReplyEnd = (P_PRESENCE_INFO_DATA_MSG *)((BYTE *)(pRemoteReplyEnd + 1) + pRemoteReplyEnd->cbStateData + pRemoteReplyEnd->cbRichPresence);
        }

        // append the remote results to the local results.
        memcpy(pLocalReplyEnd, pReply, (BYTE *)pRemoteReplyEnd - (BYTE *)pReply);
        cdwUsers += cdwPUIDs;

        m_cPendingServerReplies--;
        if (m_cPendingServerReplies == 0)
        {
            // mark as all local users.
            m_cdwPUIDs = 0;

            // run finalize again.
            Finalize();
        }

        return hr;
    }


    virtual HRESULT Finalize()
    {
        HRESULT hr = S_OK;
        CTCPCntVarBuffer *pSendBuffer = NULL;

        if (m_cdwPUIDs > 0)
        {
            // some of our users are no longer here.  we need to send a forwarded request to get their info.
            m_qwUserID = qwSenderID;

            // AddRef() before calling SendGetPresenceInfo().  if the send fails, it will automatically call ApplyPresenceData() with empty results.
            // addref to  counter the release below.
            AddRef();

            hr = m_pSwitchboard->SendGetPresenceInfo(this, TRUE);

            // we're done for now.  Finalize will get called again when the GPI results are back.
            goto lDone;
        }

        if (pCReplyConn == NULL)
        {
            // local short circuit

            CPresenceInfoContext *pCCtx = g_pCPresenceInfoContextQueue->Find(qwSenderID, dwContext);
            XOMASSERT(pCCtx != NULL);
            if (pCCtx == NULL)
            {
                hr = E_UNEXPECTED;
                goto lDone;
            }

            hr = pCCtx->ApplyPresenceData(cdwUsers, (P_PRESENCE_INFO_DATA_MSG *)pBuffer);

            if (pCCtx->m_cPendingServerReplies == 0)
            {
                g_pCPresenceInfoContextQueue->Remove(pCCtx);
            }
        }
        else
        {
            // Make sure we have a connection to send to
            if (!pCReplyConn->IsConnected())
            {
                hr = HRESULT_FROM_WIN32(WSAENOTCONN);
                goto lDone;
            }

            // find the end of the buffer
            P_PRESENCE_INFO_DATA_MSG *pReply = (P_PRESENCE_INFO_DATA_MSG *)pBuffer;
            for (DWORD iUser = 0; iUser < cdwUsers; iUser++)
            {
                pReply = (P_PRESENCE_INFO_DATA_MSG *)((BYTE *)(pReply + 1) + pReply->cbStateData + pReply->cbRichPresence);
            }

            DWORD cbReply = (BYTE *)pReply - pBuffer;

            // CONSIDER: find the best way to avoid this allocation.  perhaps pass a CTCPCntVarBuffer that already contains the reply.
            pSendBuffer = CTCPCntVarBuffer::CreateInstance(sizeof(P_GET_PRESENCE_INFO_MSG) + cbReply);
            if (pSendBuffer == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto lDone;
            }

            // Fill in the base message fields
            P_GET_PRESENCE_INFO_MSG *pMsg = (P_GET_PRESENCE_INFO_MSG *)pSendBuffer->GetBuffer();

            pMsg->dwMsgType = PMSG_PRESENCE_INFO_REPLY;
            pMsg->dwMsgLen = sizeof(P_GET_PRESENCE_INFO_MSG) + cbReply - sizeof(BASE_MSG_HEADER);
            pMsg->sgaddr = sgaddrIgnore;
            pMsg->qwSenderID = qwSenderID;
            pMsg->cdwUsers = cdwUsers;
            pMsg->dwContext = dwContext;

            if (fFromPresence)
            {
                // for pconn, seqnums are always sequential.
                pMsg->dwSeqNum = ((CPresConnection *)pCReplyConn)->IncrementSequenceNumber();
            }
            else
            {
                // for cliconn, the seqnum is passed to us from the xpnfd (stored as dwContext).
                pMsg->dwSeqNum = dwContext;
            }

            memcpy(pMsg + 1, pBuffer, cbReply);

            // Send the message
            hr = pCReplyConn->Send(pSendBuffer);
            if(FAILED(hr))
            {
                goto lDone;
            }
        }

    lDone:

        SAFE_RELEASE(pSendBuffer);

        Release();

        return hr;
    }

    DWORD dwContext;
    QWORD qwSenderID;
    DWORD cdwUsers;
    BOOL fFromPresence;
    CTCPCntMessageBased<CTCPCntMessageBasedPlugin_PN> *pCReplyConn;
    BYTE *pBuffer;
    CSwitchboard *m_pSwitchboard;
};

class CAnnounceContext : public CLoadOfflinePresenceCaller
{
public:

    virtual HRESULT ProcessUser(CPresence * pCPresence, void * pvData)
    {
        if (pCPresence == NULL)
        {
            return HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
        }

        return S_OK;
    }

    virtual HRESULT Finalize()
    {
        delete[] rgqwSourceUserIDs;
        delete this;

        return S_OK;
    }

    QWORD qwDestUserID;
    DWORD dwTitleID;
    CHAR szGamerTag[XONLINE_GAMERTAG_SIZE];
    DWORD cSourceUserIDs;
    QWORD *rgqwSourceUserIDs;
};

class CInvalidateUserContext : public CLoadOfflinePresenceCaller
{
public:

    virtual HRESULT ProcessUser(CPresence * pCPresence, void * pvData)
    {
        if (pCPresence == NULL)
        {
            return HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
        }

        if (m_pSwitchboard == NULL)
        {
            return E_UNEXPECTED;
        }

        // TODO: do we want to do something like ForceDBAlive() here?

        // update subscribers due to new privileges.
        if (m_fPresFriend && !pCPresence->CanSharePresence(TRUE))
        {
            // cant send presence to friends anymore.
            m_pSwitchboard->NotifyOfflineAll(pCPresence, TRUE);
        }
        else if (m_fPresOther && !pCPresence->CanSharePresence(FALSE))
        {
            // cant send presence to non-friends anymore.
            m_pSwitchboard->NotifyOfflineAll(pCPresence, FALSE);
        }
        else if ((!m_fPresFriend && pCPresence->CanSharePresence(TRUE)) ||
            (!m_fPresOther && pCPresence->CanSharePresence(FALSE)))
        {
            // got a new privilege.
            if (!(pCPresence->GetState() & P_STATE_MASK_CLOAKED))
            {
                // this will only send to the subscribers allowed by the new privileges.
                m_pSwitchboard->NotifyPresenceAll(pCPresence);
            }
        }

         XomTrace(
            PresenceDebug,
            L_HIGH,
            "InvalidateUser reloaded offline presence for User=%I64X, CanPlayOnline=%d, CanMessage(anyone)=%d, CanMessage(friend)=%d, CanSharePresence(anyone)=%d, CanSharePresence(friend)=%d",
            pCPresence->GetUserID(),
            pCPresence->CanPlayOnline(),
            pCPresence->CanMessage(FALSE),
            pCPresence->CanMessage(TRUE),
            pCPresence->CanSharePresence(FALSE),
            pCPresence->CanSharePresence(TRUE)
            );

        return S_OK;
    }

    virtual HRESULT Finalize()
    {
        delete this;
        return S_OK;
    }

    BOOL m_fPresFriend;
    BOOL m_fPresOther;
    CSwitchboard *m_pSwitchboard;

};



/*****************************************************************************

CLoadPresenceContext

*****************************************************************************/
class CLoadOfflinePresenceContext :
    public CLocalContext
{
public:

    CLoadOfflinePresenceContext(
        CSwitchboard *pSwitchboard,
        CProfileStore *pCProfileStore) :
        m_pCSwitchboard(pSwitchboard),
        m_pCProfileStore(pCProfileStore),
        m_hr(S_OK),
        m_dwBuddyListVersion(0),
        m_cBuddies(0),
        m_rgCBuddyList(NULL),
        m_cNevers(0),
        m_rgNevers(NULL),
        m_qwWebID(0),
        m_pvParentData(NULL),
        m_fProcessed(FALSE),
        m_qwUserID(0),
        m_pCaller(NULL),
        m_pCPresence(NULL)
    {
        m_szGamerTag[0] = '\0';
        memset(m_rgbPrivileges, 0, sizeof(m_rgbPrivileges));

        g_Counters.SafeIncrement32(XPPERF_SERVER_SQL_WORK_ITEMS);
    }

    virtual ~CLoadOfflinePresenceContext()
    {
        g_Counters.SafeDecrement32(XPPERF_SERVER_SQL_WORK_ITEMS);

        if (m_rgCBuddyList != NULL)
        {
            delete[] m_rgCBuddyList;
        }
        if (m_rgNevers != NULL)
        {
            delete[] m_rgNevers;
        }

        SAFE_RELEASE(m_pCPresence);
    }

    IMPLEMENT_REFCOUNT

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual void CompletionProc()
    {
        XOMASSERT(NULL != m_pCSwitchboard);
        XOMASSERT(NULL != m_pCProfileStore);

        HRESULT hr = S_OK;

        if (m_fProcessed == FALSE)
        {
            CScopeTimer scope( XPPERF_SERVER_WEB_ALIVE_STORE_TIME_AVERAGE, XPPERF_SERVER_WEB_ALIVE_STORE_TIME_BASE );
            CheckIoCompletion( PostSql );

            // check for user 0.
            if (m_qwUserID == 0)
            {
                m_hr = HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
                m_fProcessed = TRUE;
                m_pCSwitchboard->PostCompletion(this);
            }

            // ensure that the user is owned by this server.
            DWORD dwServer = g_CPresCfg.MapUserToPresSrv(m_qwUserID, FALSE);
            DWORD dwAltServer = g_CPresCfg.MapUserToPresSrv(m_qwUserID, TRUE);
            if ((dwServer != g_CPresCfg.GetMyPresServerIndex()) && (dwAltServer != g_CPresCfg.GetMyPresServerIndex()))
            {
                m_hr = XONLINE_E_PRESENCE_USER_MIGRATED;
                m_fProcessed = TRUE;
                m_pCSwitchboard->PostCompletion(this);
            }
            else
            {
                hr = m_pCProfileStore->StoreGetOfflinePresence(this);
            }
        }
        else
        {
            CScopeTimer scope( XPPERF_SERVER_WEB_ALIVE_STORE_COMPLETE_TIME_AVERAGE, XPPERF_SERVER_WEB_ALIVE_STORE_COMPLETE_TIME_BASE );
            CheckIoCompletion( PostSwitchboard );

            if (FAILED(m_hr))
            {
                // this should never happen
                hr = m_pCaller->LoadComplete(m_hr, m_qwUserID, NULL, m_pvParentData);
            }
            else
            {
                hr = CreatePresenceRecord();

                if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
                {
                    // this should never happen
                    hr = m_pCaller->LoadComplete(hr, m_qwUserID, NULL, m_pvParentData);
                }
                else if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
                {
                    g_CPresenceUserIndex.QueueDeferredRequest(m_qwUserID, this);
                    SAFE_RELEASE(m_pCPresence);
                }
                else
                {
                    hr = m_pCaller->LoadComplete(hr, m_qwUserID, m_pCPresence, m_pvParentData);
                }
            }

            Release();
        }
    }

    HRESULT CreatePresenceRecord()
    {
        HRESULT hr = m_hr;
        if (FAILED(hr))
        {
            goto lDone;
        }

        // Do we have a record for this user now?
        hr = g_CPresenceUserIndex.FindPresence(m_qwUserID, &m_pCPresence);

        if ((hr == XONLINE_E_PRESENCE_DEFER_REQUEST) ||
            (hr == XONLINE_E_PRESENCE_USER_MIGRATED))
        {
            goto lDone;
        }

        if (m_pCPresence == NULL)
        {
            // No, create one
            hr = g_CPresenceUserIndex.CreatePresence(
                m_pCSwitchboard,
                m_qwUserID,
                0,
                lstrlen(m_szGamerTag) + 1,  // TODO: make absolutely sure its ok to use lstrlen() here.
                m_szGamerTag,
                m_qwWebID,
                &m_pCPresence);

            if (FAILED(hr))
            {
                goto lDone;
            }

            if (m_rgNevers)
            {
                m_pCPresence->SetNeverList((WORD)m_cNevers, m_rgNevers);
                m_rgNevers = NULL;
            }

            if (m_rgCBuddyList != NULL)
            {
                hr = m_pCPresence->SetBuddyList(m_cBuddies, m_dwBuddyListVersion, m_rgCBuddyList);
                m_rgCBuddyList = NULL;
            }
        }

        // always update these.  (we can call this API to refresh the base record even if it already exists.)
        m_pCPresence->SetPrivileges(m_rgbPrivileges);
        m_pCPresence->SetAcctName(m_szGamerTag, lstrlen(m_szGamerTag) + 1);
        // TODO: if the gamertag has changed, consider issuing ListChange notifications to friends and team members.

        // TODO: should we update the friend and never lists always?

    lDone:

        return hr;
    }

    virtual const char* GetContextDesc() { return "LoadOfflinePresence"; }

protected:
    CSwitchboard *m_pCSwitchboard;
    CProfileStore *m_pCProfileStore;

    CPresence *m_pCPresence;

public:
    // Task state and results
    void *m_pvParentData;
    BOOL m_fProcessed;
    QWORD m_qwUserID;
    CLoadOfflinePresenceCaller *m_pCaller;

    // Buddy List
    DWORD m_dwBuddyListVersion;
    DWORD m_cBuddies;
    CBuddyListEntry *m_rgCBuddyList;
    DWORD m_cNevers;
    QWORD *m_rgNevers;
    QWORD m_qwWebID;
    CHAR m_szGamerTag[XONLINE_GAMERTAG_SIZE];
    BYTE m_rgbPrivileges[XONLINE_NUM_PRIVILEGE_BYTES];

    // Output
    HRESULT m_hr;
};


class CStoreStateContext : public CLocalContext
{
public:
    CStoreStateContext(
        CSwitchboard *pSwitchboard,
        QWORD qwUserID,
        CHAR *szGamertag,
        DWORD dwTitleID,
        MSGTIME mtLastSeen,
        QWORD qwSessionID,
        DWORD dwState,
        BOOL fShareEveryone,
        BOOL fShareFriends,
        WORD cbRichPresenceData,
        BYTE *pRichPresenceData,
        DWORD dwStateChange) :
        m_pSwitchboard(pSwitchboard),
        m_cbRichPresenceData(cbRichPresenceData),
        m_pRichPresenceData(NULL),
        m_dwStateChange(dwStateChange),
        m_fProcessed(FALSE)
    {
        m_basicData.doSpec.wObjectSize = sizeof(BASIC_PRESENCE_DATA);
        m_basicData.doSpec.wDataType = eBasicPresence;
        m_basicData.doSpec.dwDataSubType = 0;
        m_basicData.doSpec.qwOwnerXUID = qwUserID;
        m_basicData.dwHeaderFlags = 0;
        m_basicData.dwTitleID = dwTitleID;
        m_basicData.mtLastSeen = mtLastSeen;
        m_basicData.qwSessionID = qwSessionID;
        m_basicData.dwState = dwState;
        memcpy(m_basicData.szGamertag, szGamertag, XONLINE_GAMERTAG_SIZE);

        if (fShareEveryone) m_basicData.dwHeaderFlags |= XONLINE_CONNSRV_DATA_FLAG_SHARE_EVERYONE;
        if (fShareFriends) m_basicData.dwHeaderFlags |= XONLINE_CONNSRV_DATA_FLAG_SHARE_FRIENDS;

        if (m_cbRichPresenceData > 0)
        {
            m_pRichPresenceData = new BYTE[m_cbRichPresenceData];
            if (m_pRichPresenceData == NULL)
            {
                m_cbRichPresenceData = 0;
            }
            else
            {
                memcpy(m_pRichPresenceData, pRichPresenceData, m_cbRichPresenceData);
            }
        }

        g_Counters.SafeIncrement32(XPPERF_SERVER_SQL_WORK_ITEMS);
    }

    virtual ~CStoreStateContext()
    {
        SAFE_ARRAYDELETE(m_pRichPresenceData);
        g_Counters.SafeDecrement32(XPPERF_SERVER_SQL_WORK_ITEMS);
    }

    IMPLEMENT_REFCOUNT

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual void CompletionProc()
    {
        HRESULT hr = S_OK;

        if (!m_fProcessed)
        {
            CheckIoCompletion( PostSql );

            // key format: "eBasicPresence:1234123412341234:0"
            CHAR szKey[64] = {0};

            // basic.
            if (m_dwStateChange & ~P_STATE_MASK_RICHPRES_CHANGED)
            {
                sprintf(szKey, "eBasicPresence:%I64X:0", m_basicData.doSpec.qwOwnerXUID);

                hr = g_VelocityProxy.Put(szKey, m_basicData.doSpec.wObjectSize, (BYTE*)&m_basicData);
                if (FAILED(hr))
                {
                    XomNtEvent(XEVENT_PRESENCE_COMM_VELOCITY_WRITE, "CStoreStateContext: failed to write to Velocity.  hr=%X", hr);
                }
            }

            // rich.
            if (m_dwStateChange & P_STATE_MASK_RICHPRES_CHANGED)
            {
                sprintf(szKey, "eRichPresenceString:%I64X:0", m_basicData.doSpec.qwOwnerXUID);

                if (m_cbRichPresenceData < sizeof(BASE_DATA_HEADER))
                {
                    // reuse the basic blob
                    m_basicData.doSpec.wObjectSize = sizeof(BASE_DATA_HEADER);
                    m_basicData.doSpec.wDataType = eRichPresenceString;
                    hr = g_VelocityProxy.Put(szKey, m_basicData.doSpec.wObjectSize, (BYTE*)&m_basicData);
                }
                else
                {
                    // set rich presence privacy equal to basic presence privacy.
                    BASE_DATA_HEADER *pHeader = (BASE_DATA_HEADER *)m_pRichPresenceData;
                    pHeader->dwHeaderFlags &= ~(XONLINE_CONNSRV_DATA_FLAG_SHARE_EVERYONE | XONLINE_CONNSRV_DATA_FLAG_SHARE_FRIENDS);
                    pHeader->dwHeaderFlags |= (m_basicData.dwHeaderFlags & (XONLINE_CONNSRV_DATA_FLAG_SHARE_EVERYONE | XONLINE_CONNSRV_DATA_FLAG_SHARE_FRIENDS));
                    hr = g_VelocityProxy.Put(szKey, m_cbRichPresenceData, m_pRichPresenceData);
                }

                if (FAILED(hr))
                {
                    XomNtEvent(XEVENT_PRESENCE_COMM_VELOCITY_WRITE, "CStoreStateContext: failed to write to Velocity.  hr=%X", hr);
                }
            }

            m_fProcessed = TRUE;

            m_pSwitchboard->PostCompletion(this);
        }
        else
        {
            CheckIoCompletion(PostSwitchboard);
            Release();
        }
    }

    virtual const char* GetContextDesc() { return "StoreState"; }

    // Input
    CSwitchboard *m_pSwitchboard;
    BASIC_PRESENCE_DATA m_basicData;
    WORD m_cbRichPresenceData;
    BYTE *m_pRichPresenceData;
    DWORD m_dwStateChange;

    BOOL m_fProcessed;
};

class CStoreFriendsListContext : public CLocalContext
{
public:
    CStoreFriendsListContext(
        CSwitchboard *pSwitchboard,
        QWORD qwUserID,
        DWORD dwListVersion,
        DWORD cdwFriends,
        CBuddyListEntry *rgFriends,
        BOOL fShareEveryone,
        BOOL fShareFriends) :
        m_pSwitchboard(pSwitchboard),
        m_qwUserID(qwUserID),
        m_fProcessed(FALSE)
    {
        m_cbData = sizeof(USER_LIST_DATA) + cdwFriends * sizeof(USER_DATA);
        m_pData = new BYTE[m_cbData];
        if (m_pData != NULL)
        {
            USER_LIST_DATA *pUserList = (USER_LIST_DATA *)m_pData;
            pUserList->doSpec.wObjectSize = (WORD)m_cbData;
            pUserList->doSpec.wDataType = eFriendsList;
            pUserList->doSpec.dwDataSubType = 0;
            pUserList->doSpec.qwOwnerXUID = qwUserID;
            pUserList->dwHeaderFlags = 0;
            pUserList->dwListVersion = dwListVersion;
            pUserList->dwNumUsers = cdwFriends;

            if (fShareEveryone) pUserList->dwHeaderFlags |= XONLINE_CONNSRV_DATA_FLAG_SHARE_EVERYONE;
            if (fShareFriends) pUserList->dwHeaderFlags |= XONLINE_CONNSRV_DATA_FLAG_SHARE_FRIENDS;

            USER_DATA *rgUsers = (USER_DATA *)(pUserList + 1);
            for (DWORD dwFriend = 0; dwFriend < cdwFriends; dwFriend++)
            {
                rgUsers[dwFriend].qwXUID = rgFriends[dwFriend].GetBuddyID();
                rgUsers[dwFriend].dwUserFlags = rgFriends[dwFriend].GetStatus();
            }
        }

        g_Counters.SafeIncrement32(XPPERF_SERVER_SQL_WORK_ITEMS);
    }

    virtual ~CStoreFriendsListContext()
    {
        SAFE_ARRAYDELETE(m_pData);
        g_Counters.SafeDecrement32(XPPERF_SERVER_SQL_WORK_ITEMS);
    }

    IMPLEMENT_REFCOUNT

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual void CompletionProc()
    {
        HRESULT hr = S_OK;

        if (!m_fProcessed)
        {
            CheckIoCompletion( PostSql );

            if (m_pData != NULL)
            {
                // key format: "eFriendsList:1234123412341234:0"
                CHAR szKey[64] = {0};

                sprintf(szKey, "eFriendsList:%I64X:0", m_qwUserID);

                hr = g_VelocityProxy.Put(szKey, m_cbData, m_pData);
                if (FAILED(hr))
                {
                    XomNtEvent(XEVENT_PRESENCE_COMM_VELOCITY_WRITE, "CStoreFriendsListContext: failed to write to Velocity.  hr=%X", hr);
                }
            }

            m_fProcessed = TRUE;

            m_pSwitchboard->PostCompletion(this);
        }
        else
        {
            CheckIoCompletion(PostSwitchboard);
            Release();
        }
    }

    virtual const char* GetContextDesc() { return "StoreFriendsList"; }

    // Input
    CSwitchboard *m_pSwitchboard;
    QWORD m_qwUserID;

    BOOL m_fProcessed;
    DWORD m_cbData;
    BYTE *m_pData;
};


/*****************************************************************************

CSendMessageContext

*****************************************************************************/
class CSendMessageContext
{
public:

    CSendMessageContext(
        CSwitchboard *pSwitchboard) :
        m_pCSwitchboard(pSwitchboard),
        m_qwSenderID(0),
        m_dwSendTime(0),
        m_pCNext(NULL),
        m_dwSeqNum(0),
        m_hrSend(S_OK),
        m_bMessageType(0),
        m_cRecipientResults(0)
    {
    }

    virtual ~CSendMessageContext()
    {
    }

    IMPLEMENT_REFCOUNT

protected:
    CSwitchboard *m_pCSwitchboard;

public:
    // Inputs
    QWORD m_qwSenderID;
    BYTE m_bMessageType;
    WORD m_cRecipients;
    QWORD m_rgqwRecipients[ XONLINE_MAX_MESSAGE_RECIPIENTS ];

    WORD m_cRecipientResults;
    Q_RECIPIENT_RESULT m_RecipientResults[ XONLINE_MAX_MESSAGE_RECIPIENTS ];
    HRESULT m_hrSend;

    // Notification server info
    CSendMessageContext* m_pCNext;
    DWORD m_dwSeqNum;
    DWORD m_dwSendTime;
};

/*****************************************************************************

CTeamListTeamsContext

*****************************************************************************/
class CTeamListTeamsContext : public CLocalContext
{
public:
    CTeamListTeamsContext(
        CSwitchboard *pSwitchboard,
        CProfileStore *pCProfileStore) :
        m_pCSwitchboard(pSwitchboard),
        m_pCProfileStore(pCProfileStore),
        m_fProcessed(FALSE),
        m_qwUserID(0),
        m_dwTitleID(0),
        m_cTeamIDs(0),
        m_pCReplyConn(NULL),
        m_dwSeqNum(0),
        m_hr(S_OK),
        m_cReplies(0)
    {
        DWORD dwIndex;

        for (dwIndex = 0; dwIndex < MAX_TEAMS; dwIndex++)
        {
            m_rgqwTeamIDs[dwIndex] = 0;
            m_rgpReplies[dwIndex] = NULL;
        }

        g_Counters.SafeIncrement32(XPPERF_SERVER_SQL_WORK_ITEMS);
    }

    virtual ~CTeamListTeamsContext()
    {
        DWORD dwIndex;

        for (dwIndex = 0; dwIndex < m_cReplies; dwIndex++)
        {
            SAFE_RELEASE(m_rgpReplies[dwIndex]);
        }

        SAFE_RELEASE(m_pCReplyConn);

        g_Counters.SafeDecrement32(XPPERF_SERVER_SQL_WORK_ITEMS);
    }

    IMPLEMENT_REFCOUNT

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual void CompletionProc()
    {
        XOMASSERT( NULL != m_pCSwitchboard );

        HRESULT hr = S_OK;

        if (!m_fProcessed)
        {
            CScopeTimer scope( XPPERF_SERVER_LIST_TEAMS_STORE_TIME_AVERAGE, XPPERF_SERVER_LIST_TEAMS_STORE_TIME_BASE );
            CheckIoCompletion( PostSql );
            hr = m_pCProfileStore->StoreTeamListTeams(this);
        }
        else
        {
            CScopeTimer scope( XPPERF_SERVER_LIST_TEAMS_COMPLETION_TIME_AVERAGE, XPPERF_SERVER_LIST_TEAMS_COMPLETION_TIME_BASE );
            CheckIoCompletion( PostSwitchboard );
            hr = m_pCSwitchboard->TeamListTeamsComplete(this);
        }
    }

    virtual const char* GetContextDesc() { return "ListTeams"; }

protected:
    CSwitchboard *m_pCSwitchboard;
    CProfileStore *m_pCProfileStore;

public:
    BOOL m_fProcessed;

    // Input
    QWORD m_qwUserID;
    DWORD m_dwTitleID;
    DWORD m_cTeamIDs;
    QWORD m_rgqwTeamIDs[MAX_TEAMS];
    CClientConnection *m_pCReplyConn;
    DWORD m_dwSeqNum;

    // Output
    HRESULT m_hr;
    DWORD m_cReplies;
    CTCPCntVarBuffer *m_rgpReplies[MAX_TEAMS];
};

/*****************************************************************************

CTeamListUserTeamsContext

*****************************************************************************/
class CTeamListUserTeamsContext : public CLocalContext
{
public:
    CTeamListUserTeamsContext(
        CSwitchboard *pSwitchboard,
        CProfileStore *pCProfileStore) :
        m_pCSwitchboard(pSwitchboard),
        m_pCProfileStore(pCProfileStore),
        m_fProcessed(FALSE),
        m_qwUserID(0),
        m_dwTitleID(0),
        m_pCReplyConn(NULL),
        m_dwSeqNum(0),
        m_hr(S_OK),
        m_cTeams(0)
    {
        memset(m_rgUserTeams, 0, sizeof(P_REPLY_USER_TEAM) * MAX_TEAMS);

        g_Counters.SafeIncrement32(XPPERF_SERVER_SQL_WORK_ITEMS);
    }

    virtual ~CTeamListUserTeamsContext()
    {
        SAFE_RELEASE(m_pCReplyConn);

        g_Counters.SafeDecrement32(XPPERF_SERVER_SQL_WORK_ITEMS);
    }

    IMPLEMENT_REFCOUNT

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual void CompletionProc()
    {
        XOMASSERT( NULL != m_pCSwitchboard );

        HRESULT hr = S_OK;

        if (!m_fProcessed)
        {
            CScopeTimer scope( XPPERF_SERVER_LIST_TEAMS_STORE_TIME_AVERAGE, XPPERF_SERVER_LIST_TEAMS_STORE_TIME_BASE );
            CheckIoCompletion( PostSql );
            hr = m_pCProfileStore->StoreTeamListUserTeams(this);
        }
        else
        {
            CScopeTimer scope( XPPERF_SERVER_LIST_TEAMS_COMPLETION_TIME_AVERAGE, XPPERF_SERVER_LIST_TEAMS_COMPLETION_TIME_BASE );
            CheckIoCompletion( PostSwitchboard );
            hr = m_pCSwitchboard->TeamListUserTeamsComplete(this);
        }
    }

    virtual const char* GetContextDesc() { return "ListTeams"; }

protected:
    CSwitchboard *m_pCSwitchboard;
    CProfileStore *m_pCProfileStore;

public:
    BOOL m_fProcessed;

    // Input
    QWORD m_qwUserID;
    DWORD m_dwTitleID;
    CClientConnection *m_pCReplyConn;
    DWORD m_dwSeqNum;

    // Output
    HRESULT m_hr;
    DWORD m_cTeams;
    P_REPLY_USER_TEAM m_rgUserTeams[MAX_TEAMS];
};

/*****************************************************************************

CTeamListMembersContext

*****************************************************************************/
class CTeamListMembersContext : public CLocalContext
{
public:
    CTeamListMembersContext(
        CSwitchboard *pSwitchboard,
        CProfileStore *pCProfileStore) :
        m_pCSwitchboard(pSwitchboard),
        m_pCProfileStore(pCProfileStore),
        m_fProcessed(FALSE),
        m_qwUserID(0),
        m_dwTitleID(0),
        m_qwTeamID(0),
        m_fShowRecruits(FALSE),
        m_pCReplyConn(NULL),
        m_dwSeqNum(0),
        m_hr(S_OK),
        m_cMembers(0),
        m_pReply(NULL)
    {
        g_Counters.SafeIncrement32(XPPERF_SERVER_SQL_WORK_ITEMS);
    }

    virtual ~CTeamListMembersContext()
    {
        SAFE_RELEASE(m_pReply);
        SAFE_RELEASE(m_pCReplyConn);

        g_Counters.SafeDecrement32(XPPERF_SERVER_SQL_WORK_ITEMS);
    }

    IMPLEMENT_REFCOUNT

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual void CompletionProc()
    {
        XOMASSERT( NULL != m_pCSwitchboard );

        HRESULT hr = S_OK;

        if (!m_fProcessed)
        {
            CScopeTimer scope( XPPERF_SERVER_LIST_TEAM_MEMBERS_STORE_TIME_AVERAGE, XPPERF_SERVER_LIST_TEAM_MEMBERS_STORE_TIME_BASE );
            CheckIoCompletion( PostSql );
            hr = m_pCProfileStore->StoreTeamListMembers(this);
        }
        else
        {
            CScopeTimer scope( XPPERF_SERVER_LIST_TEAM_MEMBERS_COMPLETION_TIME_AVERAGE, XPPERF_SERVER_LIST_TEAM_MEMBERS_COMPLETION_TIME_BASE );
            CheckIoCompletion( PostSwitchboard );
            hr = m_pCSwitchboard->TeamListMembersComplete(this);
        }
    }

    virtual const char* GetContextDesc() { return "ListTeamMembers"; }

protected:
    CSwitchboard *m_pCSwitchboard;
    CProfileStore *m_pCProfileStore;

public:
    BOOL m_fProcessed;

    // Input
    QWORD m_qwUserID;
    DWORD m_dwTitleID;
    QWORD m_qwTeamID;
    BOOL m_fShowRecruits;
    CClientConnection *m_pCReplyConn;
    DWORD m_dwSeqNum;

    // Output
    HRESULT m_hr;
    DWORD m_cMembers;
    QWORD m_rgqwMemberIDs[XONLINE_MAX_TEAM_MEMBER_COUNT];
    CTCPCntVarBuffer *m_pReply;
};

/*****************************************************************************

CTeamCreateContext

*****************************************************************************/
class CTeamCreateContext : public CLocalContext
{
public:
    CTeamCreateContext(
        CSwitchboard *pSwitchboard,
        CProfileStore *pCProfileStore) :
        m_pCSwitchboard(pSwitchboard),
        m_pCProfileStore(pCProfileStore),
        m_fProcessed(FALSE),
        m_qwUserID(0),
        m_dwTitleID(0),
        m_dwMaxMembers(0),
        m_cbTeamName(0),
        m_cbTeamDescription(0),
        m_cbTeamMotto(0),
        m_cbTeamURL(0),
        m_cbTeamData(0),
        m_cbCreatorName(0),
        m_cbCreatorData(0),
        m_fXenon(FALSE),
        m_pCReplyConn(NULL),
        m_dwSeqNum(0),
        m_hr(S_OK),
        m_qwTeamID(0)
    {
        memset(m_wszTeamName, 0, MAX_TEAM_NAME_BYTES);
        memset(m_wszTeamDescription, 0, MAX_TEAM_DESCRIPTION_BYTES);
        memset(m_wszTeamMotto, 0, MAX_TEAM_MOTTO_BYTES);
        memset(m_wszTeamURL, 0, MAX_TEAM_URL_BYTES);
        memset(m_pbTeamData, 0, MAX_TEAM_DATA_BYTES);
        memset(m_szCreatorName, 0, XONLINE_GAMERTAG_SIZE);
        memset(m_pbCreatorData, 0, MAX_TEAM_MEMBER_DATA_BYTES);

        g_Counters.SafeIncrement32(XPPERF_SERVER_SQL_WORK_ITEMS);
    }

    virtual ~CTeamCreateContext()
    {
        SAFE_RELEASE(m_pCReplyConn);
        g_Counters.SafeDecrement32(XPPERF_SERVER_SQL_WORK_ITEMS);
    }

     IMPLEMENT_REFCOUNT

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual void CompletionProc()
    {
        XOMASSERT( NULL != m_pCSwitchboard );

        HRESULT hr = S_OK;

        if (!m_fProcessed)
        {
            CScopeTimer scope( XPPERF_SERVER_TEAM_CREATE_STORE_TIME_AVERAGE, XPPERF_SERVER_TEAM_CREATE_STORE_TIME_BASE );
            CheckIoCompletion( PostSql );
            hr = m_pCProfileStore->StoreTeamCreate(this);
        }
        else
        {
            CScopeTimer scope( XPPERF_SERVER_TEAM_CREATE_COMPLETION_TIME_AVERAGE, XPPERF_SERVER_TEAM_CREATE_COMPLETION_TIME_BASE );
            CheckIoCompletion( PostSwitchboard );
            hr = m_pCSwitchboard->TeamCreateComplete(this);
        }
    }

    virtual const char* GetContextDesc() { return "TeamCreate"; }

protected:
    CSwitchboard *m_pCSwitchboard;
    CProfileStore *m_pCProfileStore;

public:
    BOOL m_fProcessed;

    // Input
    QWORD m_qwUserID;
    DWORD m_dwTitleID;
    DWORD m_dwMaxMembers;
    DWORD m_cbTeamName;
    DWORD m_cbTeamDescription;
    DWORD m_cbTeamMotto;
    DWORD m_cbTeamURL;
    DWORD m_cbTeamData;
    DWORD m_cbCreatorName;
    DWORD m_cbCreatorData;
    BOOL m_fXenon;
    CClientConnection *m_pCReplyConn;
    DWORD m_dwSeqNum;

    // Output
    HRESULT m_hr;
    QWORD m_qwTeamID;

    // Array data at end to be cache friendly
    WCHAR m_wszTeamName[MAX_TEAM_NAME_CHAR];
    WCHAR m_wszTeamDescription[MAX_TEAM_DESCRIPTION_CHAR];
    WCHAR m_wszTeamMotto[MAX_TEAM_MOTTO_CHAR];
    WCHAR m_wszTeamURL[MAX_TEAM_URL_CHAR];
    BYTE m_pbTeamData[MAX_TEAM_DATA_BYTES];
    CHAR m_szCreatorName[XONLINE_GAMERTAG_SIZE];
    BYTE m_pbCreatorData[MAX_TEAM_MEMBER_DATA_BYTES];
};

/*****************************************************************************

CTeamDeleteContext

*****************************************************************************/
class CTeamDeleteContext : public CLocalContext
{
public:
    CTeamDeleteContext(
        CSwitchboard *pSwitchboard,
        CProfileStore *pCProfileStore) :
        m_pCSwitchboard(pSwitchboard),
        m_pCProfileStore(pCProfileStore),
        m_fProcessed(FALSE),
        m_qwUserID(0),
        m_dwTitleID(0),
        m_qwTeamID(0),
        m_pCReplyConn(NULL),
        m_dwSeqNum(0),
        m_hr(S_OK),
        m_cMemberIDs(0)
    {
        g_Counters.SafeIncrement32(XPPERF_SERVER_SQL_WORK_ITEMS);
    }

    virtual ~CTeamDeleteContext()
    {
        SAFE_RELEASE(m_pCReplyConn);
        g_Counters.SafeDecrement32(XPPERF_SERVER_SQL_WORK_ITEMS);
    }

     IMPLEMENT_REFCOUNT

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual void CompletionProc()
    {
        XOMASSERT( NULL != m_pCSwitchboard );

        HRESULT hr = S_OK;

        if (!m_fProcessed)
        {
            CScopeTimer scope( XPPERF_SERVER_TEAM_DELETE_STORE_TIME_AVERAGE, XPPERF_SERVER_TEAM_DELETE_STORE_TIME_BASE );
            CheckIoCompletion( PostSql );
            hr = m_pCProfileStore->StoreTeamDelete(this);
        }
        else
        {
            CScopeTimer scope( XPPERF_SERVER_TEAM_DELETE_COMPLETION_TIME_AVERAGE, XPPERF_SERVER_TEAM_DELETE_COMPLETION_TIME_BASE );
            CheckIoCompletion( PostSwitchboard );
            hr = m_pCSwitchboard->TeamDeleteComplete(this);
        }
    }

    virtual const char* GetContextDesc() { return "TeamDelete"; }

protected:
    CSwitchboard *m_pCSwitchboard;
    CProfileStore *m_pCProfileStore;

public:
    BOOL m_fProcessed;

    // Input
    QWORD m_qwUserID;
    DWORD m_dwTitleID;
    QWORD m_qwTeamID;
    CClientConnection *m_pCReplyConn;
    DWORD m_dwSeqNum;

    // Output
    HRESULT m_hr;
    DWORD m_cMemberIDs;
    QWORD m_rgqwMemberIDs[XONLINE_MAX_TEAM_MEMBER_COUNT];
};

/*****************************************************************************

CTeamRemoveContext

*****************************************************************************/
class CTeamRemoveContext : public CLocalContext
{
public:
    CTeamRemoveContext(
        CSwitchboard *pSwitchboard,
        CProfileStore *pCProfileStore) :
        m_pCSwitchboard(pSwitchboard),
        m_pCProfileStore(pCProfileStore),
        m_fProcessed(FALSE),
        m_qwUserID(0),
        m_dwTitleID(0),
        m_qwTeamID(0),
        m_qwMemberID(0),
        m_pCReplyConn(NULL),
        m_dwSeqNum(0),
        m_hr(S_OK)
    {
        g_Counters.SafeIncrement32(XPPERF_SERVER_SQL_WORK_ITEMS);
    }

    virtual ~CTeamRemoveContext()
    {
        SAFE_RELEASE(m_pCReplyConn);
        g_Counters.SafeDecrement32(XPPERF_SERVER_SQL_WORK_ITEMS);
    }

     IMPLEMENT_REFCOUNT

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual void CompletionProc()
    {
        XOMASSERT( NULL != m_pCSwitchboard );

        HRESULT hr = S_OK;

        if (!m_fProcessed)
        {
            CScopeTimer scope( XPPERF_SERVER_TEAM_REMOVE_MEMBER_STORE_TIME_AVERAGE, XPPERF_SERVER_TEAM_REMOVE_MEMBER_STORE_TIME_BASE );
            CheckIoCompletion( PostSql );
            hr = m_pCProfileStore->StoreTeamRemove(this);
        }
        else
        {
            CScopeTimer scope( XPPERF_SERVER_TEAM_REMOVE_MEMBER_COMPLETION_TIME_AVERAGE, XPPERF_SERVER_TEAM_REMOVE_MEMBER_COMPLETION_TIME_BASE );
            CheckIoCompletion( PostSwitchboard );
            hr = m_pCSwitchboard->TeamRemoveComplete(this);
        }
    }

    virtual const char* GetContextDesc() { return "TeamRemove"; }

protected:
    CSwitchboard *m_pCSwitchboard;
    CProfileStore *m_pCProfileStore;

public:
    BOOL m_fProcessed;

    // Input
    QWORD m_qwUserID;
    DWORD m_dwTitleID;
    QWORD m_qwTeamID;
    QWORD m_qwMemberID;
    CClientConnection *m_pCReplyConn;
    DWORD m_dwSeqNum;

    // Output
    HRESULT m_hr;
};

/*****************************************************************************

CTeamManageTeamContext

*****************************************************************************/
class CTeamManageTeamContext : public CLocalContext
{
public:
    CTeamManageTeamContext(
        CSwitchboard *pSwitchboard,
        CProfileStore *pCProfileStore) :
        m_pCSwitchboard(pSwitchboard),
        m_pCProfileStore(pCProfileStore),
        m_fProcessed(FALSE),
        m_qwUserID(0),
        m_dwTitleID(0),
        m_qwTeamID(0),
        m_dwCreatorPriv(0),
        m_cbTeamName(0),
        m_cbTeamDescription(0),
        m_cbTeamMotto(0),
        m_cbTeamURL(0),
        m_cbTeamData(0),
        m_cbCreatorName(0),
        m_cbCreatorData(0),
        m_fXenon(FALSE),
        m_pCReplyConn(NULL),
        m_dwSeqNum(0),
        m_hr(S_OK)
    {
        memset(m_wszTeamName, 0, MAX_TEAM_NAME_BYTES);
        memset(m_wszTeamDescription, 0, MAX_TEAM_DESCRIPTION_BYTES);
        memset(m_wszTeamMotto, 0, MAX_TEAM_MOTTO_BYTES);
        memset(m_wszTeamURL, 0, MAX_TEAM_URL_BYTES);
        memset(m_pbTeamData, 0, MAX_TEAM_DATA_BYTES);

        g_Counters.SafeIncrement32(XPPERF_SERVER_SQL_WORK_ITEMS);
    }

    virtual ~CTeamManageTeamContext()
    {
        SAFE_RELEASE(m_pCReplyConn);
        g_Counters.SafeDecrement32(XPPERF_SERVER_SQL_WORK_ITEMS);
    }

     IMPLEMENT_REFCOUNT

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual void CompletionProc()
    {
        XOMASSERT( NULL != m_pCSwitchboard );

        HRESULT hr = S_OK;

        if (!m_fProcessed)
        {
            CScopeTimer scope( XPPERF_SERVER_TEAM_MANAGE_STORE_TIME_AVERAGE, XPPERF_SERVER_TEAM_MANAGE_STORE_TIME_BASE );
            CheckIoCompletion( PostSql );
            hr = m_pCProfileStore->StoreTeamManageTeam(this);
        }
        else
        {
            CScopeTimer scope( XPPERF_SERVER_TEAM_MANAGE_COMPLETION_TIME_AVERAGE, XPPERF_SERVER_TEAM_MANAGE_COMPLETION_TIME_BASE );
            CheckIoCompletion( PostSwitchboard );
            hr = m_pCSwitchboard->TeamManageTeamComplete(this);
        }
    }

    virtual const char* GetContextDesc() { return "ManageTeam"; }

protected:
    CSwitchboard *m_pCSwitchboard;
    CProfileStore *m_pCProfileStore;

public:
    BOOL m_fProcessed;

    // Input
    QWORD m_qwUserID;
    DWORD m_dwTitleID;
    QWORD m_qwTeamID;
    DWORD m_dwCreatorPriv;
    DWORD m_cbTeamName;
    DWORD m_cbTeamDescription;
    DWORD m_cbTeamMotto;
    DWORD m_cbTeamURL;
    DWORD m_cbTeamData;
    DWORD m_cbCreatorName;
    DWORD m_cbCreatorData;
    BOOL m_fXenon;
    CClientConnection *m_pCReplyConn;
    DWORD m_dwSeqNum;

    // Output
    HRESULT m_hr;

    // Array data at end to be cache friendly
    WCHAR m_wszTeamName[MAX_TEAM_NAME_CHAR];
    WCHAR m_wszTeamDescription[MAX_TEAM_DESCRIPTION_CHAR];
    WCHAR m_wszTeamMotto[MAX_TEAM_MOTTO_CHAR];
    WCHAR m_wszTeamURL[MAX_TEAM_URL_CHAR];
    BYTE m_pbTeamData[MAX_TEAM_DATA_BYTES];
};

/*****************************************************************************

CTeamManageMemberContext

*****************************************************************************/
class CTeamManageMemberContext : public CLocalContext
{
public:
    CTeamManageMemberContext(
        CSwitchboard *pSwitchboard,
        CProfileStore *pCProfileStore) :
        m_pCSwitchboard(pSwitchboard),
        m_pCProfileStore(pCProfileStore),
        m_fProcessed(FALSE),
        m_qwUserID(0),
        m_dwTitleID(0),
        m_qwTeamID(0),
        m_qwMemberID(0),
        m_dwMemberPriv(0),
        m_cbMemberData(0),
        m_pCReplyConn(NULL),
        m_dwSeqNum(0),
        m_hr(S_OK)
    {
        memset(m_pbMemberData, 0, MAX_TEAM_MEMBER_DATA_BYTES);

        g_Counters.SafeIncrement32(XPPERF_SERVER_SQL_WORK_ITEMS);
    }

    virtual ~CTeamManageMemberContext()
    {
        SAFE_RELEASE(m_pCReplyConn);
        g_Counters.SafeDecrement32(XPPERF_SERVER_SQL_WORK_ITEMS);
    }

     IMPLEMENT_REFCOUNT

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual void CompletionProc()
    {
        XOMASSERT( NULL != m_pCSwitchboard );

        HRESULT hr = S_OK;

        if (!m_fProcessed)
        {
            CScopeTimer scope( XPPERF_SERVER_TEAM_MANAGE_MEMBER_STORE_TIME_AVERAGE, XPPERF_SERVER_TEAM_MANAGE_MEMBER_STORE_TIME_BASE );
            CheckIoCompletion( PostSql );
            hr = m_pCProfileStore->StoreTeamManageMember(this);
        }
        else
        {
            CScopeTimer scope( XPPERF_SERVER_TEAM_MANAGE_MEMBER_COMPLETION_TIME_AVERAGE, XPPERF_SERVER_TEAM_MANAGE_MEMBER_COMPLETION_TIME_BASE );
            CheckIoCompletion( PostSwitchboard );
            hr = m_pCSwitchboard->TeamManageMemberComplete(this);
        }
    }

    virtual const char* GetContextDesc() { return "TeamManageMember"; }

protected:
    CSwitchboard *m_pCSwitchboard;
    CProfileStore *m_pCProfileStore;

public:
    BOOL m_fProcessed;

    // Input
    QWORD m_qwUserID;
    DWORD m_dwTitleID;
    QWORD m_qwTeamID;
    QWORD m_qwMemberID;
    DWORD m_dwMemberPriv;
    DWORD m_cbMemberData;
    CClientConnection *m_pCReplyConn;
    DWORD m_dwSeqNum;

    // Output
    HRESULT m_hr;

    // Array data at end to be cache friendly
    BYTE m_pbMemberData[MAX_TEAM_MEMBER_DATA_BYTES];
};

/*****************************************************************************

CTeamRecruitContext

*****************************************************************************/
class CTeamRecruitContext : public CLocalContext
{
public:
    CTeamRecruitContext(
        CSwitchboard *pSwitchboard,
        CProfileStore *pCProfileStore) :
        m_pCSwitchboard(pSwitchboard),
        m_pCProfileStore(pCProfileStore),
        m_fProcessed(FALSE),
        m_qwUserID(0),
        m_dwTitleID(0),
        m_qwTeamID(0),
        m_qwMemberID(0),
        m_dwMemberPriv(0),
        m_cbMemberData(0),
        m_pCReplyConn(NULL),
        m_dwSeqNum(0),
        m_hr(S_OK),
        m_dwMessageFlags(0),
        m_cbDetails(0)
    {
        memset(m_szMemberName, 0, XONLINE_GAMERTAG_SIZE);
        memset(m_szSenderName, 0, XONLINE_GAMERTAG_SIZE);
        memset(m_pbMemberData, 0, MAX_TEAM_MEMBER_DATA_BYTES);
        memset(m_rgbDetails, 0, XONLINE_MAX_MESSAGE_DETAILS);

        g_Counters.SafeIncrement32(XPPERF_SERVER_SQL_WORK_ITEMS);
    }

    virtual ~CTeamRecruitContext()
    {
        SAFE_RELEASE(m_pCReplyConn);
        g_Counters.SafeDecrement32(XPPERF_SERVER_SQL_WORK_ITEMS);
    }

     IMPLEMENT_REFCOUNT

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual void CompletionProc()
    {
        XOMASSERT( NULL != m_pCSwitchboard );

        HRESULT hr = S_OK;

        if (!m_fProcessed)
        {
            CScopeTimer scope( XPPERF_SERVER_TEAM_RECRUIT_STORE_TIME_AVERAGE, XPPERF_SERVER_TEAM_RECRUIT_STORE_TIME_BASE );
            CheckIoCompletion( PostSql );
            hr = m_pCProfileStore->StoreTeamRecruit(this);
        }
        else
        {
            CScopeTimer scope( XPPERF_SERVER_TEAM_RECRUIT_COMPLETION_TIME_AVERAGE, XPPERF_SERVER_TEAM_RECRUIT_COMPLETION_TIME_BASE );
            CheckIoCompletion( PostSwitchboard );
            hr = m_pCSwitchboard->TeamRecruitComplete(this);
        }
    }

    virtual const char* GetContextDesc() { return "TeamRecruit"; }

protected:
    CSwitchboard *m_pCSwitchboard;
    CProfileStore *m_pCProfileStore;

public:
    BOOL m_fProcessed;

    // Input
    QWORD m_qwUserID;
    DWORD m_dwTitleID;
    QWORD m_qwTeamID;
    QWORD m_qwMemberID;
    DWORD m_dwMessageFlags;
    WORD  m_cbDetails;
    DWORD m_dwMemberPriv;
    DWORD m_cbMemberData;
    CClientConnection *m_pCReplyConn;
    DWORD m_dwSeqNum;

    // Output
    HRESULT m_hr;

    // Array data at end to be cache friendly
    CHAR m_szMemberName[ XONLINE_GAMERTAG_SIZE ];
    CHAR m_szSenderName[ XONLINE_GAMERTAG_SIZE ];
    BYTE m_pbMemberData[MAX_TEAM_MEMBER_DATA_BYTES];
    BYTE m_rgbDetails[ XONLINE_MAX_MESSAGE_DETAILS ];
};

/*****************************************************************************

CTeamJoinContext

*****************************************************************************/
class CTeamJoinContext : public CLocalContext
{
public:
    CTeamJoinContext(
        CSwitchboard *pSwitchboard,
        CProfileStore *pCProfileStore) :
        m_pCSwitchboard(pSwitchboard),
        m_pCProfileStore(pCProfileStore),
        m_fProcessed(FALSE),
        m_qwUserID(0),
        m_dwTitleID(0),
        m_qwTeamID(0),
        m_dwRecruitMsgID(0),
        m_bAnswer(0),
        m_pCReplyConn(NULL),
        m_dwSeqNum(0),
        m_hr(S_OK)
    {
        g_Counters.SafeIncrement32(XPPERF_SERVER_SQL_WORK_ITEMS);
    }

    virtual ~CTeamJoinContext()
    {
        SAFE_RELEASE(m_pCReplyConn);
        g_Counters.SafeDecrement32(XPPERF_SERVER_SQL_WORK_ITEMS);
    }

     IMPLEMENT_REFCOUNT

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual void CompletionProc()
    {
        XOMASSERT( NULL != m_pCSwitchboard );

        HRESULT hr = S_OK;

        if (!m_fProcessed)
        {
            CScopeTimer scope( XPPERF_SERVER_TEAM_JOIN_STORE_TIME_AVERAGE, XPPERF_SERVER_TEAM_JOIN_STORE_TIME_BASE );
            CheckIoCompletion( PostSql );
            hr = m_pCProfileStore->StoreTeamJoin(this);
        }
        else
        {
            CScopeTimer scope( XPPERF_SERVER_TEAM_JOIN_COMPLETION_TIME_AVERAGE, XPPERF_SERVER_TEAM_JOIN_COMPLETION_TIME_BASE );
            CheckIoCompletion( PostSwitchboard );
            hr = m_pCSwitchboard->TeamJoinComplete(this);
        }
    }

    virtual const char* GetContextDesc() { return "TeamJoin"; }

protected:
    CSwitchboard *m_pCSwitchboard;
    CProfileStore *m_pCProfileStore;

public:
    BOOL m_fProcessed;

    // Input
    QWORD m_qwUserID;
    DWORD m_dwTitleID;
    QWORD m_qwTeamID;
    DWORD m_dwRecruitMsgID;
    BYTE m_bAnswer;
    CClientConnection *m_pCReplyConn;
    DWORD m_dwSeqNum;

    // Output
    HRESULT m_hr;
};


/*****************************************************************************

CTeamGetTicketContext

*****************************************************************************/
class CTeamGetTicketContext : public CLocalContext
{
public:

    CTeamGetTicketContext(
        CSwitchboard *pSwitchboard,
        CProfileStore *pCProfileStore) :
        m_pCSwitchboard(pSwitchboard),
        m_pCProfileStore(pCProfileStore),
        m_fProcessed(FALSE),
        m_qwUserID(0),
        m_dwTitleID(0),
        m_pCReplyConn(NULL),
        m_dwSeqNum(0),
        m_hr(S_OK),
        m_cTeamIDs(0)
    {
        memset(m_rgqwTeamIDs, 0, sizeof(m_rgqwTeamIDs));
        g_Counters.SafeIncrement32(XPPERF_SERVER_SQL_WORK_ITEMS);
    }

    virtual ~CTeamGetTicketContext()
    {
        SAFE_RELEASE(m_pCReplyConn);
        g_Counters.SafeDecrement32(XPPERF_SERVER_SQL_WORK_ITEMS);
    }

     IMPLEMENT_REFCOUNT

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual void CompletionProc()
    {
        XOMASSERT( NULL != m_pCSwitchboard );

        HRESULT hr = S_OK;

        if (!m_fProcessed)
        {
            CScopeTimer scope( XPPERF_SERVER_TEAM_GET_TICKET_STORE_TIME_AVERAGE, XPPERF_SERVER_TEAM_GET_TICKET_STORE_TIME_BASE );
            CheckIoCompletion( PostSql );
            hr = m_pCProfileStore->StoreTeamGetTicket(this);
        }
        else
        {
            CScopeTimer scope( XPPERF_SERVER_TEAM_GET_TICKET_COMPLETION_TIME_AVERAGE, XPPERF_SERVER_TEAM_GET_TICKET_COMPLETION_TIME_BASE );
            CheckIoCompletion( PostSwitchboard );
            hr = m_pCSwitchboard->TeamGetTicketComplete(this);
        }
    }

    virtual const char* GetContextDesc() { return "TeamGetTickets"; }

protected:
    CSwitchboard *m_pCSwitchboard;
    CProfileStore *m_pCProfileStore;

public:
    BOOL m_fProcessed;

    // Input
    QWORD m_qwUserID;
    DWORD m_dwTitleID;
    CClientConnection *m_pCReplyConn;
    DWORD m_dwSeqNum;

    // Output
    HRESULT m_hr;
    DWORD m_cTeamIDs;
    QWORD m_rgqwTeamIDs[MAX_TEAMS];
};

/*****************************************************************************

CEnumerateMessagesContext

*****************************************************************************/
class CEnumerateMessagesContext : public CLocalContext
{
public:
    CEnumerateMessagesContext(
        CSwitchboard *pSwitchboard,
        CProfileStore *pCProfileStore) :
        m_pCSwitchboard(pSwitchboard),
        m_pCProfileStore(pCProfileStore),
        m_fProcessed(FALSE),
        m_hr(S_OK),
        m_pCReplyConn(NULL),
        m_dwSeqNum(0),
        m_dwMsgType(0),
        m_pCReply(NULL),
        m_qwUserID(0),
        m_pCPresence(NULL)
    {
        g_Counters.SafeIncrement32( XPPERF_SERVER_SQL_WORK_ITEMS );
    }

    virtual ~CEnumerateMessagesContext()
    {
        g_Counters.SafeDecrement32( XPPERF_SERVER_SQL_WORK_ITEMS );

        if (m_pCReplyConn != NULL)
        {
            m_pCReplyConn->Release();
        }

        SAFE_RELEASE(m_pCReply);
        SAFE_RELEASE(m_pCPresence);
    }

     IMPLEMENT_REFCOUNT

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual void CompletionProc()
    {
        XOMASSERT( NULL != m_pCSwitchboard );

        if (!m_fProcessed)
        {
            CScopeTimer scope( XPPERF_SERVER_ENUM_MESSAGES_STORE_TIME_AVERAGE, XPPERF_SERVER_ENUM_MESSAGES_STORE_TIME_BASE );
            CheckIoCompletion( PostSql );
            m_pCProfileStore->StoreEnumerateMessages(this);
        }
        else
        {
            CScopeTimer scope( XPPERF_SERVER_ENUM_MESSAGES_COMPLETION_TIME_AVERAGE, XPPERF_SERVER_ENUM_MESSAGES_COMPLETION_TIME_BASE );
            CheckIoCompletion( PostSwitchboard );
            m_pCSwitchboard->EnumerateMessagesComplete(this);
        }
    }

    virtual const char* GetContextDesc() { return "EnumerateMessages"; }

protected:
    CSwitchboard *m_pCSwitchboard;
    CProfileStore *m_pCProfileStore;

public:
    BOOL m_fProcessed;
    HRESULT m_hr;

    // Input
    QWORD m_qwUserID;
    DWORD m_dwMsgType;
    BYTE m_bMaxKnownMsgType;

    // Replies
    CClientConnection *m_pCReplyConn;
    DWORD m_dwSeqNum;
    CTCPCntVarBuffer *m_pCReply;

    CPresence *m_pCPresence;
};

/*****************************************************************************

CGetMessageSummaryContext

*****************************************************************************/
class CGetMessageSummaryContext : public CLocalContext
{
public:
    CGetMessageSummaryContext(
        CSwitchboard *pSwitchboard,
        CProfileStore *pCProfileStore) :
        m_pCSwitchboard(pSwitchboard),
        m_pCProfileStore(pCProfileStore),
        m_fProcessed(FALSE),
        m_hr(S_OK),
        m_pCReplyConn(NULL),
        m_dwSeqNum(0),
        m_dwMsgType(0),
        m_qwUserID(0),
        m_dwMessageID(0),
        m_pCReply(NULL),
        m_pCPresence(NULL)
    {
        g_Counters.SafeIncrement32( XPPERF_SERVER_SQL_WORK_ITEMS );
    }

    virtual ~CGetMessageSummaryContext()
    {
        g_Counters.SafeDecrement32( XPPERF_SERVER_SQL_WORK_ITEMS );

        if (m_pCReplyConn != NULL)
        {
            m_pCReplyConn->Release();
        }

        SAFE_RELEASE(m_pCReply);
        SAFE_RELEASE(m_pCPresence);
    }

     IMPLEMENT_REFCOUNT

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual void CompletionProc()
    {
        XOMASSERT( NULL != m_pCSwitchboard );

        if (!m_fProcessed)
        {
            CScopeTimer scope( XPPERF_SERVER_MESSAGE_SUMMARY_STORE_TIME_AVERAGE, XPPERF_SERVER_MESSAGE_SUMMARY_STORE_TIME_BASE );
            CheckIoCompletion( PostSql );
            m_pCProfileStore->StoreGetMessageSummary(this);
        }
        else
        {
            CScopeTimer scope( XPPERF_SERVER_MESSAGE_SUMMARY_COMPLETION_TIME_AVERAGE, XPPERF_SERVER_MESSAGE_SUMMARY_COMPLETION_TIME_BASE );
            CheckIoCompletion( PostSwitchboard );
            m_pCSwitchboard->GetMessageSummaryComplete(this);
        }
    }

    virtual const char* GetContextDesc() { return "MessageSummary"; }

protected:
    CSwitchboard *m_pCSwitchboard;
    CProfileStore *m_pCProfileStore;

public:
    BOOL m_fProcessed;
    HRESULT m_hr;

    // Input
    QWORD m_qwUserID;
    DWORD m_dwMessageID;
    BYTE m_bMaxKnownMsgType;

    // Replies
    CClientConnection *m_pCReplyConn;
    DWORD m_dwSeqNum;
    DWORD m_dwMsgType;
    CTCPCntVarBuffer *m_pCReply;

    CPresence *m_pCPresence;
};

/*****************************************************************************

CGetMessageDetailsContext

*****************************************************************************/
class CGetMessageDetailsContext : public CLocalContext
{
public:
    CGetMessageDetailsContext(
        CSwitchboard *pSwitchboard,
        CProfileStore *pCProfileStore) :
        m_pCSwitchboard(pSwitchboard),
        m_pCProfileStore(pCProfileStore),
        m_fProcessed(FALSE),
        m_hr(S_OK),
        m_pCReplyConn(NULL),
        m_dwSeqNum(0),
        m_pCReply(NULL),
        m_qwUserID(0),
        m_dwMessageID(0),
        m_dwSetFlags(0),
        m_dwUnsetFlags(0),
        m_pCPresence(NULL)
    {
        g_Counters.SafeIncrement32( XPPERF_SERVER_SQL_WORK_ITEMS );
    }

    virtual ~CGetMessageDetailsContext()
    {
        g_Counters.SafeDecrement32( XPPERF_SERVER_SQL_WORK_ITEMS );

        if (m_pCReplyConn != NULL)
        {
            m_pCReplyConn->Release();
        }

        SAFE_RELEASE(m_pCReply);
        SAFE_RELEASE(m_pCPresence);
    }

     IMPLEMENT_REFCOUNT

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual void CompletionProc()
    {
        XOMASSERT( NULL != m_pCSwitchboard );

        if (!m_fProcessed)
        {
            CScopeTimer scope( XPPERF_SERVER_MESSAGE_DETAILS_STORE_TIME_AVERAGE, XPPERF_SERVER_MESSAGE_DETAILS_STORE_TIME_BASE );
            CheckIoCompletion( PostSql );
            m_pCProfileStore->StoreGetMessageDetails(this);
        }
        else
        {
            CScopeTimer scope( XPPERF_SERVER_MESSAGE_DETAILS_COMPLETION_TIME_AVERAGE, XPPERF_SERVER_MESSAGE_DETAILS_COMPLETION_TIME_BASE );
            CheckIoCompletion( PostSwitchboard );
            m_pCSwitchboard->GetMessageDetailsComplete(this);
        }
    }

    virtual const char* GetContextDesc() { return "MessageDetails"; }

protected:
    CSwitchboard *m_pCSwitchboard;
    CProfileStore *m_pCProfileStore;

public:
    BOOL m_fProcessed;
    HRESULT m_hr;

    // Input
    QWORD m_qwUserID;
    DWORD m_dwMessageID;
    DWORD m_dwSetFlags;
    DWORD m_dwUnsetFlags;

    // Replies
    CClientConnection *m_pCReplyConn;
    DWORD m_dwSeqNum;
    CTCPCntVarBuffer *m_pCReply;

    CPresence *m_pCPresence;
};

/*****************************************************************************

CDeleteMessageContext

*****************************************************************************/
class CDeleteMessageContext : public CLocalContext
{
public:
    CDeleteMessageContext(
        CSwitchboard *pSwitchboard,
        CProfileStore *pCProfileStore) :
        m_pCSwitchboard(pSwitchboard),
        m_pCProfileStore(pCProfileStore),
        m_fProcessed(FALSE),
        m_hr(S_OK),
        m_pCReplyConn(NULL),
        m_dwSeqNum(0),
        m_qwUserID(0),
        m_dwMessageID(0),
        m_dwFlags(0),
        m_qwSenderID(0),
        m_fFromPresence(FALSE),
        m_pCPresence(NULL)
    {
        g_Counters.SafeIncrement32( XPPERF_SERVER_SQL_WORK_ITEMS );
    }

    virtual ~CDeleteMessageContext()
    {
        g_Counters.SafeDecrement32( XPPERF_SERVER_SQL_WORK_ITEMS );

        if (m_pCReplyConn != NULL)
        {
            m_pCReplyConn->Release();
        }

        SAFE_RELEASE(m_pCPresence);
    }

     IMPLEMENT_REFCOUNT

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual void CompletionProc()
    {
        XOMASSERT( NULL != m_pCSwitchboard );

        if (!m_fProcessed)
        {
            CScopeTimer scope( XPPERF_SERVER_DELETE_MESSAGE_STORE_TIME_AVERAGE, XPPERF_SERVER_DELETE_MESSAGE_STORE_TIME_BASE );
            CheckIoCompletion( PostSql );
            m_pCProfileStore->StoreDeleteMessage(this);
        }
        else
        {
            CScopeTimer scope( XPPERF_SERVER_DELETE_MESSAGE_COMPLETION_TIME_AVERAGE, XPPERF_SERVER_DELETE_MESSAGE_COMPLETION_TIME_BASE );
            CheckIoCompletion( PostSwitchboard );
            m_pCSwitchboard->DeleteMessageComplete(this);
        }
    }

    virtual const char* GetContextDesc() { return "DeleteMessage"; }

protected:
    CSwitchboard *m_pCSwitchboard;
    CProfileStore *m_pCProfileStore;

public:
    BOOL m_fProcessed;
    HRESULT m_hr;

    // Input
    QWORD m_qwUserID;
    DWORD m_dwMessageID;
    DWORD m_dwFlags;
    BOOL m_fFromPresence;

    // Output
    QWORD m_qwSenderID;

    // Replies
    CTCPCntMessageBased<CTCPCntMessageBasedPlugin_PN> *m_pCReplyConn;
    DWORD m_dwSeqNum;

    CPresence *m_pCPresence;
};

class SendMessageReplyHandler
{
public:

    SendMessageReplyHandler() :
        m_lSendCount(0),
        m_dwSendTime(0),
        m_fSomeRecipientsFailed(FALSE),
        m_cRecipientResults(0),
        m_pPerServerInfo(NULL),
        m_fVisitedForServerListChange(FALSE)
    {
        ZeroMemory( m_rgAddendum, sizeof( m_rgAddendum ) );
        ZeroMemory( m_rgqwRecipients, sizeof( m_rgqwRecipients ) );
    }

    ~SendMessageReplyHandler()
    {
        if( NULL != m_pPerServerInfo )
        {
            delete[] m_pPerServerInfo;
        }
    }

    virtual ULONG AddRef() = 0;
    virtual ULONG Release() = 0;

    virtual void HandleSendReply(
        WORD cResults,
        const Q_RECIPIENT_RESULT* pRecipientResultsSrc,
        HRESULT hrResults) = 0;

    // Per-Notification server info
    struct PerServerInfo
    {
        PerServerInfo() :
            m_pCNext(NULL),
            m_dwSeqNum(0),
            m_wStartRecipIndex(0),
            m_cRecipients(0)
        { }

        SendMessageReplyHandler* m_pCNext;
        DWORD m_dwSeqNum;
        WORD m_wStartRecipIndex;
        WORD m_cRecipients;
    } *m_pPerServerInfo;

    QWORD m_rgqwRecipients[ XONLINE_MAX_MESSAGE_RECIPIENTS ];
    Q_SEND_MESSAGE_ADDENDUM m_rgAddendum[ XONLINE_MAX_MESSAGE_RECIPIENTS ];

    LONG m_lSendCount;
    DWORD m_dwSendTime;

    BOOL m_fSomeRecipientsFailed;
    LONG m_cRecipientResults;

    BOOL m_fVisitedForServerListChange;
};

/*****************************************************************************

CSendMessageExternalContext

*****************************************************************************/
class CSendMessageExternalContext : public SendMessageReplyHandler
{
public:

    CSendMessageExternalContext( CSwitchboard* pSwitchboard ) :
        m_pCSwitchboard( pSwitchboard ),
        m_pCReplyConn(NULL),
        m_dwOrigSeqNum(0),
        m_pSendReplyBuffer(NULL),
        m_fV1Invite(FALSE),
        m_fFromPresence(FALSE),
        m_pCPresence(NULL)
    {
    }

    virtual ~CSendMessageExternalContext()
    {
        if (m_pCReplyConn != NULL)
        {
            m_pCReplyConn->Release();
        }
        SAFE_RELEASE( m_pSendReplyBuffer );
        SAFE_RELEASE(m_pCPresence);
    }

     IMPLEMENT_REFCOUNT

    virtual void HandleSendReply( WORD cResults, const Q_RECIPIENT_RESULT* pRecipientResultsSrc, HRESULT hrResults)
    {
        Q_RECIPIENT_RESULT* pRecipientResultsDest;

        // There may be multiple replies since we may have sent to multiple Notification servers.  Add this
        // one on to the actual reply.

        // Set the result for all of these recipients
        pRecipientResultsDest = (Q_RECIPIENT_RESULT*)( (Q_SEND_MESSAGE_REPLY_MSG*)m_pSendReplyBuffer->GetBuffer() + 1 );

        for( WORD iRecipient = 0; iRecipient < cResults; iRecipient++ )
        {
            pRecipientResultsDest[ m_cRecipientResults ].qwUserID = pRecipientResultsSrc[ iRecipient ].qwUserID;

            // If the whole operation failed, insert that HRESULT for all recipients, otherwise if individual
            // recipients failed or all succeeded, copy over the actual result.
            // NOTE: hrRecipient/dwMessageID are a union.
            if( FAILED( hrResults ) )
            {
                pRecipientResultsDest[ m_cRecipientResults ].hrRecipient = hrResults;
            }
            else
            {
                pRecipientResultsDest[ m_cRecipientResults ].hrRecipient = pRecipientResultsSrc[ iRecipient ].hrRecipient;
            }
            m_cRecipientResults++;
        }

        // hr may be S_FALSE if some recipients in this send failed, or E_xxx if they all failed.  Either way
        // some of the entire operation failed if the hr is not S_OK.
        if( S_OK != hrResults )
        {
            m_fSomeRecipientsFailed = TRUE;
        }

        // One less reply expected
        m_lSendCount--;

        // If this is the last expected reply, clean up
        if( 0 == m_lSendCount )
        {
            // NOTE: This will free the context, we should touch no members after this
            // Give our reference over to the switchboard
            m_pCSwitchboard->SendMessageExternalComplete( this );
        }
    }

protected:
    CSwitchboard* m_pCSwitchboard;

public:
    // Inputs
    Q_SEND_MESSAGE_MSG m_Message;
    CTCPCntMessageBased<CTCPCntMessageBasedPlugin_PN> *m_pCReplyConn;
    DWORD m_dwOrigSeqNum;

    CTCPCntVarBuffer* m_pSendReplyBuffer;
    BOOL m_fV1Invite;
    BOOL m_fFromPresence;

    CPresence *m_pCPresence;

};

/*****************************************************************************

CSendMessageInternalContext

*****************************************************************************/
class CSendMessageInternalContext :
    public CLocalContext,
    public CLoadOfflinePresenceCaller,
    public SendMessageReplyHandler
{
public:
    enum SendMessageState
    {
        SendMessageState_Init,
        SendMessageState_Store,
        SendMessageState_ResolveWebIDs,
        SendMessageState_Complete,
    };

    CSendMessageInternalContext(
        CSwitchboard *pSwitchboard,
        CProfileStore *pCProfileStore) :
        m_pCSwitchboard(pSwitchboard),
        m_pCProfileStore(pCProfileStore),
        m_eState(SendMessageState_Init),
        m_hr(S_OK),
        m_pCReplyConn(NULL),
        m_dwSeqNum(0),
        m_pExternalCtx(NULL),
        m_rgpCPresence(NULL),
        m_cForwardIDs(0),
        m_cForwardReplys(0),
        m_rgForwardIDs(NULL)
    {
        ZeroMemory( &m_Message, sizeof( m_Message ) );
        ZeroMemory( &m_rgqwRecipientIDs[0], sizeof( m_rgqwRecipientIDs ) );
        ZeroMemory( &m_rgbDetails[0], sizeof( m_rgbDetails ) );
        ZeroMemory( &m_RecipientResults[0], sizeof( m_RecipientResults ) );
        ZeroMemory( &m_rgAddendum[0], sizeof( m_rgAddendum ) );
        g_Counters.SafeIncrement32( XPPERF_SERVER_SQL_WORK_ITEMS );
    }

    virtual ~CSendMessageInternalContext()
    {
        g_Counters.SafeDecrement32( XPPERF_SERVER_SQL_WORK_ITEMS );

        if (m_pCReplyConn != NULL)
        {
            m_pCReplyConn->Release();
        }

        if (m_rgpCPresence != NULL)
        {
            for (DWORD i = 0; i < m_Message.cRecipients; i++)
            {
                SAFE_RELEASE(m_rgpCPresence[i]);
            }

            SAFE_ARRAYDELETE(m_rgpCPresence);
        }

        SAFE_ARRAYDELETE(m_rgForwardIDs);
    }

     IMPLEMENT_REFCOUNT

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual HRESULT ProcessUser(CPresence * pCPresence, void * pvData)
    {
        DWORD iRecipient = (DWORD)pvData;

        if (pCPresence == NULL)
        {
            m_RecipientResults[ iRecipient ].hrRecipient = HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
            goto lDone;
        }

        m_rgpCPresence[iRecipient] = pCPresence;
        pCPresence->AddRef();

        m_RecipientResults[iRecipient].qwUserID = pCPresence->GetUserID();

        // There are two types of messages, transient and persistent.  Transient messages only live in memory
        // on the Notification server and are deleted by Presence when the message sender goes offline.  All other
        // messages are persistent messages, and they are stored in the profile store.

        if( XONLINE_MSG_TYPE_GAME_INVITE == m_Message.bMessageType )
        {
            if (!pCPresence->HasOnlineRecord())
            {
                SGADDR sgaddr = {0};
                XNADDR xnaddr = {0};
                XNKID xkid = {0};
                XNKEY xnkey = {0};
                IN_ADDR ipaXbox = {0};

                m_RecipientResults[ iRecipient ].hrRecipient = pCPresence->CreateOnlineRecord(
                    &sgaddr,
                    0,
                    0,
                    0,
                    0,
                    0,
                    xnaddr,
                    xkid,
                    xnkey,
                    ipaXbox,
                    0,
                    (BYTE*)"",
                    0);

                if (FAILED(m_RecipientResults[ iRecipient ].hrRecipient))
                {
                    goto lDone;
                }
            }

            // Check if we are allowed to receive this message from the sender.
            //  Messages from PUID 0 are always allowed, since they represent messages
            //   from the Live service.
            //  Friend requests are also always allowed.
            //  All other messages may be restricted to friends only or nobody based on the users privilege
            if (0 != m_Message.qwSenderID)
            {
                if (FALSE == pCPresence->CanMessage( m_Message.qwSenderID ))
                {
                    // Insufficient privileges to receive this message
                    XomTrace(
                        PresenceDebug,
                        L_NORMAL,
                        "SendMessageInternal: user=%I64X has insufficient privileges to Receive Messages from user %I64X.",
                        pCPresence->GetUserID(),
                        m_Message.qwSenderID
                        );

                    // Next recipient
                    m_RecipientResults[ iRecipient ].hrRecipient = XONLINE_E_MESSAGE_UNDELIVERABLE;
                    goto lDone;
                }
            }

            // See if the recipient has blocked the sender
            // NOTE: We have one of two cases.  First, if the user record was just created above, their block list
            // will be empty, this message will send successfully, and when the user comes online SetOnline will
            // remove it.  Second, if the user record already existed because the user is online, their block list
            // will be valid and this check will succeed or fail based on its contents.
            if( pCPresence->IsUserBlocked( m_Message.qwSenderID ) )
            {
                XomTrace(
                    PresenceDebug,
                    L_INFO,
                    "Switchboard - SendMessageInternal - User %I64X has blocked user %I64X, not sending message to this recipient",
                    pCPresence->GetUserID(),
                    m_Message.qwSenderID
                    );

                // Add a record of this failure to the response
                m_RecipientResults[ iRecipient ].hrRecipient = XONLINE_E_MESSAGE_SENDER_BLOCKED;
                goto lDone;
            }

            pCPresence->DeleteXMsgBySource(m_Message.qwSenderID, m_Message.qwSenderContext, XONLINE_MSG_TYPE_GAME_INVITE);
            DWORD dwItemID;

            HRESULT hrRecipient = pCPresence->AddXMsgItem(
                &m_Message,
                m_rgAddendum[ iRecipient ].fFriend,
                m_rgbDetails,
                &dwItemID);
            if( FAILED( hrRecipient ) )
            {
                XomNtEvent(
                        XEVENT_PRESENCE_CODE_488,
                        "pCUser->AddXMsgItem failed hr=%X",
                        hrRecipient);

                // Add a record of this failure to the response
                m_RecipientResults[ iRecipient ].hrRecipient = hrRecipient;
                goto lDone;
            }

            // Success, return the ID as the result
            m_RecipientResults[ iRecipient ].dwMessageID = dwItemID;
        }
        else
        {
            // Check if we are allowed to receive this message from the sender.
            //  Messages from PUID 0 are always allowed, since they represent messages
            //   from the Live service.
            //  Friend requests are also always allowed.
            //  All other messages may be restricted to friends only or nobody based on the users privilege
            if (0 != m_Message.qwSenderID)
            {
                if (FALSE == pCPresence->CanMessage( m_Message.qwSenderID ))
                {
                    // Insufficient privileges to receive this message
                    XomTrace(
                        PresenceDebug,
                        L_NORMAL,
                        "SendMessageInternal: user=%I64X has insufficient privileges to Receive Messages from user %I64X.",
                        pCPresence->GetUserID(),
                        m_Message.qwSenderID
                        );

                    // Next recipient
                    m_RecipientResults[ iRecipient ].hrRecipient = XONLINE_E_MESSAGE_UNDELIVERABLE;
                    goto lDone;
                }
            }

            if (m_Message.dwMessageFlags & XONLINE_MSG_FLAG_REQUIRED)
            {
                // required messages force a need to skip the alive cache.
                pCPresence->ForceDBAlive();
            }
        }

    lDone:

        return m_RecipientResults[ iRecipient ].hrRecipient;
    }

    virtual HRESULT Finalize()
    {
        HRESULT hr = S_OK;

        if (m_cForwardIDs > m_cForwardReplys)
        {
            // some recipients have been migrated off server.

            WORD cRecipients = m_Message.cRecipients;
            m_Message.cRecipients = (WORD)m_cForwardIDs;

            // add a send count just to make sure we dont complete too early.
            m_lSendCount++;

            hr = m_pCSwitchboard->GetPCluser()->SendSendMessage(
                &m_Message,
                m_rgForwardIDs,
                m_rgbDetails,
                (XONLINE_MSG_TYPE_GAME_INVITE == m_Message.bMessageType) ? m_rgAddendum : NULL,
                this,
                TRUE);

            m_Message.cRecipients = cRecipients;

            // remove the extra count we added above.
            m_lSendCount--;
            if (m_lSendCount > 0)
            {
                // we will call finalize again when the forward replies come in.
                return hr;
            }
            else
            {
                // all the replies must have failed.  we can just finish now.
                XOMASSERT(m_cForwardIDs == m_cForwardReplys);
                m_cForwardIDs = m_cForwardReplys;
            }
        }

        if (XONLINE_MSG_TYPE_GAME_INVITE == m_Message.bMessageType)
        {
            m_eState = CSendMessageInternalContext::SendMessageState_Complete;
            m_pCSwitchboard->SendMessageInternalComplete(this);
        }
        else
        {
            hr = m_pCProfileStore->SendToSqlThread(this);
        }

        return hr;
    }

    virtual void HandleSendReply(WORD cResults, const Q_RECIPIENT_RESULT * pRecipientResultsSrc, HRESULT hrResults)
    {
        for (WORD iResult = 0; iResult < cResults; iResult++)
        {
            m_rgqwRecipientIDs[m_Message.cRecipients - m_cForwardIDs + m_cForwardReplys] = pRecipientResultsSrc[iResult].qwUserID;
            m_RecipientResults[m_Message.cRecipients - m_cForwardIDs + m_cForwardReplys].qwUserID = pRecipientResultsSrc[iResult].qwUserID;

            if (FAILED(hrResults))
            {
                m_RecipientResults[m_Message.cRecipients - m_cForwardIDs + m_cForwardReplys].hrRecipient = hrResults;
            }
            else
            {
                m_RecipientResults[m_Message.cRecipients - m_cForwardIDs + m_cForwardReplys].hrRecipient = pRecipientResultsSrc[iResult].hrRecipient;
            }

            m_cForwardReplys++;
        }

        // hr may be S_FALSE if some recipients in this send failed, or E_xxx if they all failed.  Either way
        // some of the entire operation failed if the hr is not S_OK.
        if( S_OK != hrResults )
        {
            m_fSomeRecipientsFailed = TRUE;
        }

        // One less reply expected
        m_lSendCount--;

        // If this is the last expected reply, clean up
        if( 0 == m_lSendCount )
        {
            XOMASSERT((m_cForwardIDs == m_cForwardReplys) || m_fSomeRecipientsFailed);
            m_cForwardIDs = m_cForwardReplys;

            // call finalize again.
            Finalize();
        }
    }

    virtual void CompletionProc()
    {
        XOMASSERT( NULL != m_pCSwitchboard );

        switch(m_eState)
        {
        case SendMessageState_Store:
        {
            CScopeTimer scope( XPPERF_SERVER_SEND_MESSAGE_STORE_TIME_AVERAGE, XPPERF_SERVER_SEND_MESSAGE_STORE_TIME_BASE );
            CheckIoCompletion( PostSql );
            m_pCProfileStore->StoreSendMessage( this );
            break;
        }
        case SendMessageState_ResolveWebIDs:
            XOMASSERT(FALSE);
            break;
        case SendMessageState_Complete:
        {
            CScopeTimer scope( XPPERF_SERVER_SEND_MESSAGE_COMPLETION_TIME_AVERAGE, XPPERF_SERVER_SEND_MESSAGE_COMPLETION_TIME_BASE );
            CheckIoCompletion( PostSwitchboard );
            m_pCSwitchboard->SendMessageInternalComplete( this );
            break;
        }
        case SendMessageState_Init:
            XOMASSERT(FALSE);
        }

    }

    virtual const char* GetContextDesc() { return "SendMessage"; }

protected:
    CSwitchboard *m_pCSwitchboard;
    CProfileStore *m_pCProfileStore;

public:
    SendMessageState m_eState;
    HRESULT m_hr;

    // Input
    Q_SEND_MESSAGE_MSG m_Message;
    QWORD m_rgqwRecipientIDs[XONLINE_MAX_MESSAGE_RECIPIENTS];
    BYTE m_rgbDetails[XONLINE_MAX_MESSAGE_DETAILS];

    // Replies
    CPresConnection *m_pCReplyConn;
    DWORD m_dwSeqNum;
    SendMessageReplyHandler *m_pExternalCtx; // Used instead of m_pCReplyConn for sends to the local server
    Q_RECIPIENT_RESULT m_RecipientResults[XONLINE_MAX_MESSAGE_RECIPIENTS];

    // Alerts
    Q_SEND_MESSAGE_ADDENDUM m_rgAddendum[XONLINE_MAX_MESSAGE_RECIPIENTS];

    CPresence **m_rgpCPresence;

    DWORD m_cForwardIDs;
    DWORD m_cForwardReplys;
    QWORD *m_rgForwardIDs;

};

/*****************************************************************************

CRevokeMessageContext

*****************************************************************************/
class CRevokeMessageContext : public CLocalContext
{
public:
    CRevokeMessageContext(
        CSwitchboard *pSwitchboard,
        CProfileStore *pCProfileStore) :
        m_pCSwitchboard(pSwitchboard),
        m_pCProfileStore(pCProfileStore),
        m_fProcessed(FALSE),
        m_rgpCPresence(NULL)
    {
        g_Counters.SafeIncrement32( XPPERF_SERVER_SQL_WORK_ITEMS );
    }

    virtual ~CRevokeMessageContext()
    {
        g_Counters.SafeDecrement32( XPPERF_SERVER_SQL_WORK_ITEMS );

        if (m_rgpCPresence != NULL)
        {
            for (DWORD i = 0; i < m_Message.cRecipients; i++)
            {
                SAFE_RELEASE(m_rgpCPresence[i]);
            }

            SAFE_ARRAYDELETE(m_rgpCPresence);
        }
    }

     IMPLEMENT_REFCOUNT

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual void CompletionProc()
    {
        XOMASSERT( NULL != m_pCProfileStore );
        XOMASSERT( NULL != m_pCSwitchboard );

        if (!m_fProcessed)
        {
            CScopeTimer scope( XPPERF_SERVER_REVOKE_MESSAGE_STORE_TIME_AVERAGE, XPPERF_SERVER_REVOKE_MESSAGE_STORE_TIME_BASE );
            CheckIoCompletion( PostSql );
            m_pCProfileStore->StoreRevokeMessage(this);
        }
        else
        {
            CScopeTimer scope( XPPERF_SERVER_REVOKE_MESSAGE_COMPLETION_TIME_AVERAGE, XPPERF_SERVER_REVOKE_MESSAGE_COMPLETION_TIME_BASE );
            CheckIoCompletion( PostSwitchboard );
            m_pCSwitchboard->RevokeMessageComplete(this);
        }
    }

    virtual const char* GetContextDesc() { return "RevokeMessage"; }

protected:
    CSwitchboard *m_pCSwitchboard;
    CProfileStore *m_pCProfileStore;

public:
    BOOL m_fProcessed;

public:
    // Input
    Q_REVOKE_MESSAGE_EX_MSG m_Message;
    Q_RECIPIENT_RESULT m_rgRecipients[XONLINE_MAX_MESSAGE_RECIPIENTS];

    // Output
    HRESULT m_hrRecipient[ XONLINE_MAX_MESSAGE_RECIPIENTS ];

    CPresence **m_rgpCPresence;
};

/*****************************************************************************

CDeleteUserTitleContext

*****************************************************************************/
class CDeleteUserTitleContext : public CLocalContext
{
public:
    CDeleteUserTitleContext(
        CSwitchboard *pSwitchboard,
        CProfileStore *pCProfileStore) :
        m_pCSwitchboard(pSwitchboard),
        m_pCProfileStore(pCProfileStore),
        m_fProcessed(FALSE),
        m_hr(S_OK),
        m_pCReplyConn(NULL),
        m_dwSeqNum(0),
        m_qwUserID(0),
        m_dwTitleID(0),
        m_pCPresence(NULL)
    {
        g_Counters.SafeIncrement32( XPPERF_SERVER_SQL_WORK_ITEMS );
    }

    virtual ~CDeleteUserTitleContext()
    {
        g_Counters.SafeDecrement32( XPPERF_SERVER_SQL_WORK_ITEMS );

        if (m_pCReplyConn != NULL)
        {
            m_pCReplyConn->Release();
        }

        SAFE_RELEASE(m_pCPresence);
    }

     IMPLEMENT_REFCOUNT

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual void CompletionProc()
    {
        XOMASSERT( NULL != m_pCSwitchboard );

        if (!m_fProcessed)
        {
            CScopeTimer scope( XPPERF_SERVER_DELETE_TITLE_STORE_TIME_AVERAGE, XPPERF_SERVER_DELETE_TITLE_STORE_TIME_BASE );
            CheckIoCompletion( PostSql );
            m_pCProfileStore->StoreDeleteUserTitle(this);
        }
        else
        {
            CScopeTimer scope( XPPERF_SERVER_DELETE_TITLE_COMPLETION_TIME_AVERAGE, XPPERF_SERVER_DELETE_TITLE_COMPLETION_TIME_BASE );
            CheckIoCompletion( PostSwitchboard );
            m_pCSwitchboard->DeleteUserTitleComplete(this);
        }
    }

    virtual const char* GetContextDesc() { return "DeleteUserTitle"; }

protected:
    CSwitchboard *m_pCSwitchboard;
    CProfileStore *m_pCProfileStore;

public:
    BOOL m_fProcessed;
    HRESULT m_hr;

    // Input
    QWORD m_qwUserID;
    DWORD m_dwTitleID;

    // Replies
    CClientConnection *m_pCReplyConn;
    DWORD m_dwSeqNum;

    CPresence *m_pCPresence;
};

/*****************************************************************************

CEnumerateUserTitlesContext

*****************************************************************************/
class CEnumerateUserTitlesContext : public CLocalContext
{
public:
    CEnumerateUserTitlesContext(
        CSwitchboard *pSwitchboard,
        CProfileStore *pCProfileStore) :
        m_pCSwitchboard(pSwitchboard),
        m_pCProfileStore(pCProfileStore),
        m_fProcessed(FALSE),
        m_hr(S_OK),
        m_pCReplyConn(NULL),
        m_dwSeqNum(0),
        m_pCReply(NULL),
        m_qwUserID(0),
        m_pCPresence(NULL)
    {
        g_Counters.SafeIncrement32( XPPERF_SERVER_SQL_WORK_ITEMS );
    }

    virtual ~CEnumerateUserTitlesContext()
    {
        g_Counters.SafeDecrement32( XPPERF_SERVER_SQL_WORK_ITEMS );

        if (m_pCReplyConn != NULL)
        {
            m_pCReplyConn->Release();
        }

        SAFE_RELEASE(m_pCReply);
        SAFE_RELEASE(m_pCPresence);
    }

     IMPLEMENT_REFCOUNT

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual void CompletionProc()
    {
        XOMASSERT( NULL != m_pCSwitchboard );

        if (!m_fProcessed)
        {
            CScopeTimer scope( XPPERF_SERVER_ENUM_TITLES_STORE_TIME_AVERAGE, XPPERF_SERVER_ENUM_TITLES_STORE_TIME_BASE );
            CheckIoCompletion( PostSql );
            m_pCProfileStore->StoreEnumerateUserTitles(this);
        }
        else
        {
            CScopeTimer scope( XPPERF_SERVER_ENUM_TITLES_COMPLETION_TIME_AVERAGE, XPPERF_SERVER_ENUM_TITLES_COMPLETION_TIME_BASE );
            CheckIoCompletion( PostSwitchboard );
            m_pCSwitchboard->EnumerateUserTitlesComplete(this);
        }
    }

    virtual const char* GetContextDesc() { return "EnumUserTitles"; }

protected:
    CSwitchboard *m_pCSwitchboard;
    CProfileStore *m_pCProfileStore;

public:
    BOOL m_fProcessed;
    HRESULT m_hr;

    // Input
    QWORD m_qwUserID;

    // Replies
    CClientConnection *m_pCReplyConn;
    DWORD m_dwSeqNum;
    CTCPCntVarBuffer *m_pCReply;

    CPresence *m_pCPresence;
};

/*****************************************************************************

CMessageFlagsContext

*****************************************************************************/
class CMessageFlagsContext : public CLocalContext
{
public:
    CMessageFlagsContext(
        CSwitchboard *pSwitchboard,
        CProfileStore *pCProfileStore) :
        m_pCSwitchboard(pSwitchboard),
        m_pCProfileStore(pCProfileStore),
        m_fProcessed(FALSE),
        m_hr(S_OK),
        m_pCReplyConn(NULL),
        m_dwSeqNum(0),
        m_qwUserID(0),
        m_dwMessageID(0),
        m_dwSetFlags(0),
        m_dwUnsetFlags(0),
        m_pCPresence(NULL)
    {
        g_Counters.SafeIncrement32( XPPERF_SERVER_SQL_WORK_ITEMS );
    }

    virtual ~CMessageFlagsContext()
    {
        g_Counters.SafeDecrement32( XPPERF_SERVER_SQL_WORK_ITEMS );

        if (m_pCReplyConn != NULL)
        {
            m_pCReplyConn->Release();
        }

        SAFE_RELEASE(m_pCPresence);
    }

     IMPLEMENT_REFCOUNT

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual void CompletionProc()
    {
        XOMASSERT( NULL != m_pCSwitchboard );

        if (!m_fProcessed)
        {
            CScopeTimer scope( XPPERF_SERVER_MESSAGE_FLAGS_STORE_TIME_AVERAGE, XPPERF_SERVER_MESSAGE_FLAGS_STORE_TIME_BASE );
            CheckIoCompletion( PostSql );
            m_pCProfileStore->StoreMessageFlags(this);
        }
        else
        {
            CScopeTimer scope( XPPERF_SERVER_MESSAGE_FLAGS_COMPLETION_TIME_AVERAGE, XPPERF_SERVER_MESSAGE_FLAGS_COMPLETION_TIME_BASE );
            CheckIoCompletion( PostSwitchboard );
            m_pCSwitchboard->MessageFlagsComplete(this);
        }
    }

    virtual const char* GetContextDesc() { return "MessageFlags"; }

protected:
    CSwitchboard *m_pCSwitchboard;
    CProfileStore *m_pCProfileStore;

public:
    BOOL m_fProcessed;
    HRESULT m_hr;

    // Input
    QWORD m_qwUserID;
    DWORD m_dwMessageID;
    DWORD m_dwSetFlags;
    DWORD m_dwUnsetFlags;

    // Replies
    CClientConnection *m_pCReplyConn;
    DWORD m_dwSeqNum;

    CPresence *m_pCPresence;
};

/*****************************************************************************

CUnblockUsersContext

*****************************************************************************/
class CUnblockUsersContext : public CLocalContext
{
public:
    CUnblockUsersContext( CProfileStore *pCProfileStore ) :
        m_pCProfileStore( pCProfileStore ),
        m_qwUserID( 0 ),
        m_cUsersToUnblock( 0 )
    {
        g_Counters.SafeIncrement32( XPPERF_SERVER_SQL_WORK_ITEMS );
    }

    virtual ~CUnblockUsersContext()
    {
        g_Counters.SafeDecrement32( XPPERF_SERVER_SQL_WORK_ITEMS );
    }

     IMPLEMENT_REFCOUNT

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual void CompletionProc()
    {
        CScopeTimer scope( XPPERF_SERVER_UNBLOCK_USERS_STORE_TIME_AVERAGE, XPPERF_SERVER_UNBLOCK_USERS_STORE_TIME_BASE );
        CheckIoCompletion( PostSql );
        m_pCProfileStore->StoreUnblockUsers(this);
    }

    virtual const char* GetContextDesc() { return "UnblockUsers"; }

protected:
    CProfileStore *m_pCProfileStore;

public:
    // Input
    QWORD m_qwUserID;
    WORD m_cUsersToUnblock;
    QWORD m_rgqwUsersToUnblock[ XONLINE_MAX_MESSAGE_RECIPIENTS ];
};

/*****************************************************************************

CEnumSystemMessagesContext

*****************************************************************************/
class CEnumSystemMessagesContext : public CLocalContext
{
public:
    CEnumSystemMessagesContext(
        CSwitchboard *pSwitchboard,
        CProfileStore *pCProfileStore) :
        m_pCSwitchboard(pSwitchboard),
        m_pCProfileStore(pCProfileStore),
        m_fProcessed(FALSE),
        m_hr(S_OK),
        m_pCReplyConn(NULL),
        m_dwSeqNum(0),
        m_dwTitleID( 0 ),
        m_pCReply( NULL )
    {
        g_Counters.SafeIncrement32( XPPERF_SERVER_SQL_WORK_ITEMS );
    }

    virtual ~CEnumSystemMessagesContext()
    {
        g_Counters.SafeDecrement32( XPPERF_SERVER_SQL_WORK_ITEMS );

        if (m_pCReplyConn != NULL)
        {
            m_pCReplyConn->Release();
        }

        SAFE_RELEASE(m_pCReply);
    }

     IMPLEMENT_REFCOUNT

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual void CompletionProc()
    {
        if (!m_fProcessed)
        {
            CScopeTimer scope( XPPERF_SERVER_ENUM_SYSTEM_MESSAGES_STORE_TIME_AVERAGE, XPPERF_SERVER_ENUM_SYSTEM_MESSAGES_STORE_TIME_BASE );
            CheckIoCompletion( PostSql );
            m_pCProfileStore->StoreEnumSystemMessages(this);
        }
        else
        {
            CScopeTimer scope( XPPERF_SERVER_ENUM_SYSTEM_MESSAGES_COMPLETION_TIME_AVERAGE, XPPERF_SERVER_ENUM_SYSTEM_MESSAGES_COMPLETION_TIME_BASE );
            CheckIoCompletion( PostSwitchboard );
            m_pCSwitchboard->EnumSystemMessagesComplete(this);
        }
    }

    virtual const char* GetContextDesc() { return "EnumSysMessages"; }

protected:
    CSwitchboard *m_pCSwitchboard;
    CProfileStore *m_pCProfileStore;

public:
    BOOL m_fProcessed;
    HRESULT m_hr;

    // Input
    DWORD m_dwTitleID;

    // Replies
    CClientConnection *m_pCReplyConn;
    DWORD m_dwSeqNum;
    CTCPCntVarBuffer *m_pCReply;
};

/*****************************************************************************

CSystemMessageDetailsContext

*****************************************************************************/
class CSystemMessageDetailsContext : public CLocalContext
{
public:
    CSystemMessageDetailsContext(
        CSwitchboard *pSwitchboard,
        CProfileStore *pCProfileStore) :
        m_pCSwitchboard(pSwitchboard),
        m_pCProfileStore(pCProfileStore),
        m_fProcessed(FALSE),
        m_hr(S_OK),
        m_pCReplyConn(NULL),
        m_dwSeqNum(0),
        m_dwTitleID( 0 ),
        m_dwMessageID( 0 ),
        m_pCReply( NULL )
    {
        g_Counters.SafeIncrement32( XPPERF_SERVER_SQL_WORK_ITEMS );
    }

    virtual ~CSystemMessageDetailsContext()
    {
        g_Counters.SafeDecrement32( XPPERF_SERVER_SQL_WORK_ITEMS );

        if (m_pCReplyConn != NULL)
        {
            m_pCReplyConn->Release();
        }

        SAFE_RELEASE(m_pCReply);
    }

     IMPLEMENT_REFCOUNT

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual void CompletionProc()
    {
        if (!m_fProcessed)
        {
            CScopeTimer scope( XPPERF_SERVER_SYSTEM_MESSAGE_DETAILS_STORE_TIME_AVERAGE, XPPERF_SERVER_SYSTEM_MESSAGE_DETAILS_STORE_TIME_BASE );
            CheckIoCompletion( PostSql );
            m_pCProfileStore->StoreGetSystemMessageDetails(this);
        }
        else
        {
            CScopeTimer scope( XPPERF_SERVER_SYSTEM_MESSAGE_DETAILS_COMPLETION_TIME_AVERAGE, XPPERF_SERVER_SYSTEM_MESSAGE_DETAILS_COMPLETION_TIME_BASE );
            CheckIoCompletion( PostSwitchboard );
            m_pCSwitchboard->GetSystemMessageDetailsComplete(this);
        }
    }

    virtual const char* GetContextDesc() { return "SysMessagesDetails"; }

protected:
    CSwitchboard *m_pCSwitchboard;
    CProfileStore *m_pCProfileStore;

public:
    BOOL m_fProcessed;
    HRESULT m_hr;

    // Input
    DWORD m_dwTitleID;
    DWORD m_dwMessageID;

    // Replies
    CClientConnection *m_pCReplyConn;
    DWORD m_dwSeqNum;
    CTCPCntVarBuffer *m_pCReply;
};

/*****************************************************************************

CDeleteSystemMessageContext

*****************************************************************************/
class CDeleteSystemMessageContext : public CLocalContext
{
public:
    CDeleteSystemMessageContext(
        CSwitchboard *pSwitchboard,
        CProfileStore *pCProfileStore) :
        m_pCSwitchboard(pSwitchboard),
        m_pCProfileStore(pCProfileStore),
        m_fProcessed(FALSE),
        m_hr(S_OK),
        m_pCReplyConn(NULL),
        m_dwSeqNum(0),
        m_dwTitleID( 0 ),
        m_dwMessageID( 0 ),
        m_dwFlags( 0 )
    {
        g_Counters.SafeIncrement32( XPPERF_SERVER_SQL_WORK_ITEMS );
    }

    virtual ~CDeleteSystemMessageContext()
    {
        g_Counters.SafeDecrement32( XPPERF_SERVER_SQL_WORK_ITEMS );

        if (m_pCReplyConn != NULL)
        {
            m_pCReplyConn->Release();
        }
    }

     IMPLEMENT_REFCOUNT

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual void CompletionProc()
    {
        if (!m_fProcessed)
        {
            CScopeTimer scope( XPPERF_SERVER_DELETE_SYSTEM_MESSAGE_STORE_TIME_AVERAGE, XPPERF_SERVER_DELETE_SYSTEM_MESSAGE_STORE_TIME_BASE );
            CheckIoCompletion( PostSql );
            m_pCProfileStore->StoreDeleteSystemMessage(this);
        }
        else
        {
            CScopeTimer scope( XPPERF_SERVER_DELETE_SYSTEM_MESSAGE_COMPLETION_TIME_AVERAGE, XPPERF_SERVER_DELETE_SYSTEM_MESSAGE_COMPLETION_TIME_BASE );
            CheckIoCompletion( PostSwitchboard );
            m_pCSwitchboard->DeleteSystemMessageComplete(this);
        }
    }

    virtual const char* GetContextDesc() { return "DeleteSysMessage"; }

protected:
    CSwitchboard *m_pCSwitchboard;
    CProfileStore *m_pCProfileStore;

public:
    BOOL m_fProcessed;
    HRESULT m_hr;

    // Input
    DWORD m_dwTitleID;
    DWORD m_dwMessageID;
    DWORD m_dwFlags;

    // Replies
    CClientConnection *m_pCReplyConn;
    DWORD m_dwSeqNum;
};

/*****************************************************************************

CSendSystemMessageContext

*****************************************************************************/
class CSendSystemMessageContext : public CLocalContext
{
public:
    CSendSystemMessageContext(
        CSwitchboard *pSwitchboard,
        CProfileStore *pCProfileStore) :
        m_pCSwitchboard(pSwitchboard),
        m_pCProfileStore(pCProfileStore),
        m_fProcessed(FALSE),
        m_hr(S_OK),
        m_pCReplyConn(NULL),
        m_dwSeqNum(0),
        m_dwMessageID(0)
    {
        g_Counters.SafeIncrement32( XPPERF_SERVER_SQL_WORK_ITEMS );
    }

    virtual ~CSendSystemMessageContext()
    {
        g_Counters.SafeDecrement32( XPPERF_SERVER_SQL_WORK_ITEMS );

        if (m_pCReplyConn != NULL)
        {
            m_pCReplyConn->Release();
        }
    }

     IMPLEMENT_REFCOUNT

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual void CompletionProc()
    {
        if (!m_fProcessed)
        {
            CScopeTimer scope( XPPERF_SERVER_SEND_SYSTEM_MESSAGE_STORE_TIME_AVERAGE, XPPERF_SERVER_SEND_SYSTEM_MESSAGE_STORE_TIME_BASE );
            CheckIoCompletion( PostSql );
            m_pCProfileStore->StoreSendSystemMessage(this);
        }
        else
        {
            CScopeTimer scope( XPPERF_SERVER_SEND_SYSTEM_MESSAGE_COMPLETION_TIME_AVERAGE, XPPERF_SERVER_SEND_SYSTEM_MESSAGE_COMPLETION_TIME_BASE );
            CheckIoCompletion( PostSwitchboard );
            m_pCSwitchboard->SendSystemMessageComplete(this);
        }
    }

    virtual const char* GetContextDesc() { return "SendSysMessage"; }

protected:
    CSwitchboard *m_pCSwitchboard;
    CProfileStore *m_pCProfileStore;

public:
    BOOL m_fProcessed;
    HRESULT m_hr;
    DWORD m_dwMessageID;

    // Input
    Q_SEND_SYSTEM_MESSAGE_MSG m_Message;
    BYTE m_rgbDetails[ XONLINE_MAX_MESSAGE_DETAILS ];

    // Replies
    CClientConnection *m_pCReplyConn;
    DWORD m_dwSeqNum;
};

/*****************************************************************************

CBlockUsersContext

*****************************************************************************/
class CBlockUsersContext : public CLocalContext
{
public:
    CBlockUsersContext( CProfileStore *pCProfileStore ) :
        m_pCProfileStore( pCProfileStore ),
        m_qwSenderID( 0 ),
        m_qwRecipientID( 0 )
    {
        g_Counters.SafeIncrement32( XPPERF_SERVER_SQL_WORK_ITEMS );
    }

    virtual ~CBlockUsersContext()
    {
        g_Counters.SafeDecrement32( XPPERF_SERVER_SQL_WORK_ITEMS );
    }

     IMPLEMENT_REFCOUNT

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual void CompletionProc()
    {
        CScopeTimer scope( XPPERF_SERVER_BLOCK_USERS_STORE_TIME_AVERAGE, XPPERF_SERVER_BLOCK_USERS_STORE_TIME_BASE );
        CheckIoCompletion( PostSql );
        m_pCProfileStore->StoreBlockUser(this);
    }

    virtual const char* GetContextDesc() { return "BlockUsers"; }

protected:
    CProfileStore *m_pCProfileStore;

public:
    // Input
    QWORD m_qwSenderID;
    QWORD m_qwRecipientID;
};


class CPConnDisconnectContext : public CLocalContext
{
public:
    CPConnDisconnectContext() :
        m_pCConn(NULL),
        m_pCCluster(NULL)
    { }

    virtual ~CPConnDisconnectContext()
    {
        SAFE_RELEASE(m_pCConn);
        SAFE_RELEASE(m_pCCluster);
    }

     IMPLEMENT_REFCOUNT

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual void CompletionProc()
    {
        CheckIoCompletion( PostSwitchboard );

        m_pCCluster->OnDisconnectInternal(m_pCConn);

        Release();
    }

    virtual const char* GetContextDesc() { return "PConn Disconnect"; }

    CPresConnection *m_pCConn;
    CXPCluster *m_pCCluster;

};

class CFwdConnDisconnectContext : public CLocalContext
{
public:
    CFwdConnDisconnectContext() :
        m_pCConn(NULL),
        m_hrReason(S_OK)
    { }

    virtual ~CFwdConnDisconnectContext()
    {
        SAFE_RELEASE(m_pCConn);
    }

     IMPLEMENT_REFCOUNT

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual void CompletionProc()
    {
        CheckIoCompletion( PostSwitchboard );

        m_pCConn->OnDisconnectInternal(m_hrReason);

        Release();
    }

    virtual const char* GetContextDesc() { return "PConn Disconnect"; }

    CForwardingConnection *m_pCConn;
    HRESULT m_hrReason;

};

/*****************************************************************************

CSettingsChangeContext

*****************************************************************************/
class CSettingsChangeContext : public CLocalContext
{
public:
    CSettingsChangeContext() :
        m_eventArgs(NULL),
        m_hevtFinished(NULL),
        m_hr(S_OK)
    { }

    virtual ~CSettingsChangeContext()
    {
    }

     IMPLEMENT_REFCOUNT

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual void CompletionProc()
    {
        CheckIoCompletion( PostSwitchboard );

        m_hr = g_CPresCfg.Reload(m_eventArgs);

        if (m_hevtFinished)
        {
            SetEvent(m_hevtFinished);
        }
    }

    virtual const char* GetContextDesc() { return "SettingsChange"; }

    struct ISettingChangeEventArgs *m_eventArgs;
    HANDLE m_hevtFinished;
    HRESULT m_hr;

};

/*****************************************************************************

CInterfaceBucketChangeContext

*****************************************************************************/
class CInterfaceBucketChangeContext : public CLocalContext
{
public:
    CInterfaceBucketChangeContext(CSwitchboard *pSwitchboard) :
        m_dwBucket(0),
        m_dtStart(0),
        m_pNext(NULL),
        m_fTimeToStart(FALSE),
        m_fCompleted(FALSE),
        m_pSwitchboard(pSwitchboard)
    { }

    virtual ~CInterfaceBucketChangeContext()
    {
        if (!m_fCompleted)
        {
            XomNtEvent(XEVENT_PRESENCE_INFO_16, "Bucket %d users relocated.  Updating npdb to complete migration -- please wait for the true completion event (this may take 2 minutes).", m_dwBucket);
            g_CPresCfg.CompleteBucketMigration(m_dwBucket);
        }
    }

     IMPLEMENT_REFCOUNT

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual void CompletionProc()
    {
        CheckIoCompletion( PostSwitchboard );

        HRESULT hr = S_OK;

        if (m_fCompleted)
        {
            hr = g_CPresCfg.ChangeBucketMap(m_dwBucket, m_bsCurrentServer, m_bsNextServer, m_dtStart, FALSE);
            XomNtEvent(XEVENT_PRESENCE_INFO_17, "Presence Bucket Migration complete for bucket %d.", m_dwBucket);
        }
        else if (!m_fTimeToStart)
        {
            BOOL fMine = g_CPresCfg.IsBucketMine(m_dwBucket);

            hr = g_CPresCfg.ChangeBucketMap(m_dwBucket, m_bsCurrentServer, m_bsNextServer, m_dtStart, fMine);

            if (fMine)
            {
                if (hr == S_OK)
                {
                    SYSTEMTIME st;
                    VariantTimeToSystemTime(m_dtStart, &st);
                    SystemTimeToFileTime(&st, &m_ftStart);

                    // create the client forwarding connection for this new target server.
                    // this should finish connecting before anyone tries to use it.
                    m_pSwitchboard->GetClientListener()->CreateForwardConnection(g_CPresCfg.GetBucketNextServerIndex(m_dwBucket));
                }
                else if (hr == S_FALSE)
                {
                    SYSTEMTIME st;
                    GetSystemTime(&st);
                    SystemTimeToFileTime(&st, &m_ftStart);

                    // add 70 seconds to the current system time to allow the other servers to get this first.
                    *(QWORD *)(&m_ftStart) += 70 * 1000 * 1000 * 10;

                    m_fCompleted = TRUE;
                }

                // put on migration queue.
                QueueInterfaceBucketContext();
            }
            else
            {
                m_fCompleted = TRUE;

                if (g_CPresCfg.IsBucketMine(m_dwBucket))
                {
                    // the bucket just became ours.  we need to clean up any users that are stuck and still migration pending.
                    // walk all the user buckets
                    for (DWORD dwBucket = 0; dwBucket < g_CPresenceUserIndex.GetNumBuckets(); dwBucket++)
                    {
                        // walk the bucket chain
                        CPresence *pCNextUser = g_CPresenceUserIndex.GetBucket(dwBucket);
                        while (pCNextUser != NULL)
                        {
                            CPresence *pCUser = pCNextUser;
                            pCNextUser = g_CPresenceUserIndex.GetNext(pCUser);

                            if (pCUser->IsMigrationPending() && (m_dwBucket == g_CPresCfg.HashPUID(pCUser->GetUserID())))
                            {
                                // there should be no way this user has an online record.  it should just be a stubbed out empty base record awaiting a full migration message that never came.

                                // no messing with refcounting, just kill the record outright.
                                g_CPresenceUserIndex.RemovePresence(pCUser);

                                // destructor is protected, so just pound the release function until it's gone.
                                while (0 < pCUser->Release());

                                pCUser = NULL;
                            }

                            SAFE_RELEASE(pCUser);
                        }
                    }
                }
            }
        }
        else
        {
            // mark this bucket as migrating.
            g_CPresCfg.SetBucketValidAltServerFlag(m_dwBucket, TRUE);

            // walk all the user buckets
            for (DWORD dwBucket = 0; dwBucket < g_CPresenceUserIndex.GetNumBuckets(); dwBucket++)
            {
                // walk the bucket chain
                CPresence *pCNextUser = g_CPresenceUserIndex.GetBucket(dwBucket);
                while (pCNextUser != NULL)
                {
                    CPresence *pCUser = pCNextUser;
                    pCNextUser = g_CPresenceUserIndex.GetNext(pCUser);

                    // does this user hash to the migrating bucket?
                    if (g_CPresCfg.HashPUID(pCUser->GetUserID()) == m_dwBucket)
                    {
                        // mark for migration
                        pCUser->MarkForMigration(this);
                    }

                    pCUser->Release();
                }
            }
        }

        Release();
    }


    void QueueInterfaceBucketContext()
    {
        CInterfaceBucketChangeContext *p = g_pCInterfaceBucketChangeContextQueue;

        if ((p == NULL) || (CompareFileTime(&m_ftStart, &(p->m_ftStart)) <= 0))
        {
            m_pNext = p;
            g_pCInterfaceBucketChangeContextQueue = this;
        }
        else
        {
            while ((p->m_pNext != NULL) && (CompareFileTime(&(p->m_pNext->m_ftStart), &m_ftStart) < 0))
            {
                p = p->m_pNext;
            }

            m_pNext = p->m_pNext;
            p->m_pNext = this;
        }

        AddRef();
    }

    virtual const char* GetContextDesc() { return "InterfaceBucketChange"; }

    DWORD m_dwBucket;
    DATE m_dtStart;
    FILETIME m_ftStart;
    CComBSTR m_bsCurrentServer;
    CComBSTR m_bsNextServer;
    BOOL m_fTimeToStart;
    BOOL m_fCompleted;
    CSwitchboard *m_pSwitchboard;

    CInterfaceBucketChangeContext *m_pNext;
};

/*****************************************************************************

CServerListChangeContext

*****************************************************************************/
class CServerListChangeContext : public CLocalContext
{
public:
    CServerListChangeContext(CSwitchboard *pSwitchboard) :
        m_pSwitchboard(pSwitchboard),
        m_cServers(0),
        m_rgbsServers(NULL)
    { }

    virtual ~CServerListChangeContext()
    {
        SAFE_ARRAYDELETE(m_rgbsServers);
    }

     IMPLEMENT_REFCOUNT

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual void CompletionProc()
    {
        CheckIoCompletion( PostSwitchboard );

        g_CPresCfg.ChangeServerList(m_cServers, m_rgbsServers);

        Release();
    }

    virtual const char* GetContextDesc() { return "ServerListChange"; }

    CSwitchboard *m_pSwitchboard;
    DWORD m_cServers;
    CComBSTR *m_rgbsServers;
};

/*****************************************************************************

CUserMigrationContext

*****************************************************************************/
class CUserMigrationContext : public CLocalContext
{
public:
    CUserMigrationContext() :
        m_pCPresence(NULL),
        m_fPreMigration(TRUE),
        m_pCSwitchboard(NULL)
    { }

    virtual ~CUserMigrationContext()
    {
        SAFE_RELEASE(m_pCPresence);
    }

     IMPLEMENT_REFCOUNT

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual void CompletionProc()
    {
        CheckIoCompletion( PostSwitchboard );

        if (m_fPreMigration)
        {
            m_pCSwitchboard->GetPCluser()->SendPreMigrationMessage(m_pCPresence->GetUserID());
            m_fPreMigration = FALSE;
            m_pCSwitchboard->PostCompletion(this);
        }
        else
        {
            // store affiliates now to avoid double-delete issues with base records during migration.  any future adds or querys are going to get forwarded anyway.
            m_pCPresence->StoreAffiliates();

            m_pCPresence->SetMigrationInProgress();
            Release();
        }
    }

    virtual const char* GetContextDesc() { return "UserMigration"; }

    BOOL m_fPreMigration;
    CPresence *m_pCPresence;
    CSwitchboard *m_pCSwitchboard;

};

#define FORWARDED_MESSAGE_CONTEXT_SIGNATURE 'CFMC'

class CForwardedMessageContext : public CLocalContext
{
public:
    CForwardedMessageContext(CClientConnection *pCCliConn) :
        m_pCCliConn(pCCliConn),
        m_dwOldSeqNum(0),
        m_dwNewSeqNum(0),
        dwSig(FORWARDED_MESSAGE_CONTEXT_SIGNATURE)
    {
        SAFE_ADDREF(pCCliConn);
    }

    virtual ~CForwardedMessageContext()
    {
        SAFE_RELEASE(m_pCCliConn);
    }

     IMPLEMENT_REFCOUNT

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    virtual void CompletionProc()
    {
    }

    virtual const char* GetContextDesc() { return "ForwardedMessage"; }

    DWORD dwSig;
    DWORD m_dwNewSeqNum;
    DWORD m_dwOldSeqNum;
    CClientConnection *m_pCCliConn;

};

class CAdminControlRequestContext : public CLocalContext
{
public:
    CAdminControlRequestContext(CSwitchboard *pSwitchboard) :
        pszRequest(NULL),
        dwRequestId(0),
        pResponseInterface(NULL),
        m_pCSwitchboard(pSwitchboard)
    {
    }

    virtual ~CAdminControlRequestContext()
    {
    }

     IMPLEMENT_REFCOUNT

    virtual CCompletionHandler *GetHandler()
    {
        return( this );
    }

    void ShowPresenceHelp(
        CXomControlResponseInterface* pResponseInterface,
        DWORD dwRequestId)
    {
        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "\r\n\r\nPresence Admin Commands:\r\n");
        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "  servertoobusy_on : simulate the server-too-busy condition\r\n");
        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "  servertoobusy_off : disable the server-too-busy condition\r\n");
        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "  servertoobusy_threshold <max wait time> : maximum switchboard wait time (ms) before the server-too-busy condition is triggered.\r\n");
        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "  presconn_status : display connectivity status to other presinh servers\r\n");
        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "  presconn_reset <connection index> : reset connection to another inh server\r\n");
        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "    connection index -1 = reset all connections\r\n    use presconn_status to obtain other connection indices\r\n");
        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "  getcachestate <user id (decimal)> : show memory usage for a specific user\r\n");
        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "  setcachestate <user id> <state> : force memory usage for a specific user\r\n");
        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "    state 0 = not in memory\r\n    state 1 = base record only\r\n    state 2 = base and online record\r\n");
        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "  showrecord <user id (decimal)> : display contents of a user's presence record\r\n");
        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "  kick <user id (decimal)> : force an online user to log off\r\n");
        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "  showbucketmap [bucket] : display interface bucket configuration [for specified bucket]\r\n");
        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "  showbucketusers <bucket> : displays up to 3 users residing in the specified bucket.\r\n");
        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "  addrefuser <user id (decimal)> : add a debug reference to the specified user's record.  (freezes migration.)\r\n");
        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "  releaseuser <user id (decimal)> : remove debug reference from the specified user's record.  (reallows migration.)\r\n");
        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "  clearmigratingusers : delete records for any users stuck in the pre-migration state.\r\n");
    }

    virtual void CompletionProc()
    {
        BOOL fWait = FALSE;

        if(_stricmp(pszRequest, "servertoobusy_on") == 0)
        {
            g_bSimulateTooBusy = TRUE;
            pResponseInterface->WriteResponse(dwRequestId,
                (BYTE*)"Presence server is now simulating the too busy condition.\r\n", (DWORD) -1);
        }
        else if(_stricmp(pszRequest, "servertoobusy_off") == 0)
        {
            g_bSimulateTooBusy = FALSE;
            pResponseInterface->WriteResponse(dwRequestId,
                (BYTE*)"Too busy simulation has been turned off.\r\n", (DWORD) -1);
        }
        else if(_strnicmp(pszRequest, "servertoobusy_threshold", 23) == 0)
        {
            DWORD dwTimeout;
            int iRet = sscanf(pszRequest + 23, "%d", &dwTimeout);

            if (iRet != 1)
            {
                XomWriteFormattedResponse(pResponseInterface, dwRequestId, "servertoobusy_threshold current setting = %d.\r\n", g_dwSwitchboardTooBusyTimeout);
            }
            else
            {
                g_dwSwitchboardTooBusyTimeout = dwTimeout;
                XomWriteFormattedResponse(pResponseInterface, dwRequestId, "servertoobusy_threshold set to %d.\r\n", g_dwSwitchboardTooBusyTimeout);
            }
        }
        // All subsequent commands require m_pCSwitchboard
        else if (m_pCSwitchboard == NULL)
        {
            pResponseInterface->WriteResponse(dwRequestId,
                    (BYTE*)"FAILURE: m_pCSwitchboard is NULL.\r\n", (DWORD) -1);
        }
        else if(_stricmp(pszRequest, "presconn_status") == 0)
        {
            m_pCSwitchboard->AdminPConnStatus(dwRequestId, pResponseInterface);
        }
        else if(_strnicmp(pszRequest, "presconn_reset", 14) == 0)
        {
            DWORD dwIndex;
            int iRet = sscanf(pszRequest + 14, "%d", &dwIndex);

            if (iRet != 1)
            {
                XomWriteFormattedResponse(pResponseInterface, dwRequestId, "usage: exec :presence presconn_reset <connection index>\r\nconnection index -1 = reset all connections\r\nfor other connection indices, see presconn_status\r\n");
            }
            else
            {
                HRESULT hr = m_pCSwitchboard->AdminPConnReset(dwIndex);
                if (dwIndex == -1)
                {
                    XomWriteFormattedResponse(pResponseInterface, dwRequestId, "all presence connection indices reset.\r\n");
                }
                else if (FAILED(hr))
                {
                    XomWriteFormattedResponse(pResponseInterface, dwRequestId, "presence connection reset failed.  hr = 0x%X\r\n", hr);
                }
                else
                {
                    XomWriteFormattedResponse(pResponseInterface, dwRequestId, "presence connection index %d reset.\r\n", dwIndex);
                }
            }
        }
        else if(_strnicmp(pszRequest, "showrecord", 10) == 0)
        {
            fWait = m_pCSwitchboard->AdminShowPresenceRecord(pszRequest + 10, dwRequestId, pResponseInterface);
        }
        else if(_strnicmp(pszRequest, "kick", 4) == 0)
        {
            fWait = m_pCSwitchboard->AdminKickUser(pszRequest + 4, dwRequestId, pResponseInterface);
        }
        else if(_strnicmp(pszRequest, "getcachestate", 13) == 0)
        {
            fWait = m_pCSwitchboard->AdminGetPresenceCacheState(pszRequest + 13, dwRequestId, pResponseInterface);
        }
        else if(_strnicmp(pszRequest, "setcachestate", 13) == 0)
        {
            fWait = m_pCSwitchboard->AdminSetPresenceCacheState(pszRequest + 13, dwRequestId, pResponseInterface);
        }
        else if(_strnicmp(pszRequest, "showbucketmap", 13) == 0)
        {
            m_pCSwitchboard->AdminShowPresenceBucketMap(pszRequest + 13, dwRequestId, pResponseInterface);
        }
        else if(_strnicmp(pszRequest, "showbucketusers", 15) == 0)
        {
            m_pCSwitchboard->AdminShowPresenceBucketUsers(pszRequest + 15, dwRequestId, pResponseInterface);
        }
        else if(_strnicmp(pszRequest, "addrefuser", 10) == 0)
        {
            m_pCSwitchboard->AdminAddrefUser(pszRequest + 10, dwRequestId, pResponseInterface);
        }
        else if(_strnicmp(pszRequest, "releaseuser", 11) == 0)
        {
            m_pCSwitchboard->AdminReleaseUser(pszRequest + 11, dwRequestId, pResponseInterface);
        }
        else if(_strnicmp(pszRequest, "clearmigratingusers", 19) == 0)
        {
            m_pCSwitchboard->AdminClearMigratingUsers(pszRequest + 11, dwRequestId, pResponseInterface);
        }
        else if(_stricmp(pszRequest, "help") == 0)
        {
            ShowPresenceHelp(pResponseInterface, dwRequestId);
        }

        if (!fWait)
        {
            SetEvent(g_hControlCallbackEvent);
        }

        Release();
    }

    virtual const char* GetContextDesc() { return "AdminControlRequest"; }

    LPCSTR pszRequest;
    DWORD dwRequestId;
    CXomControlResponseInterface* pResponseInterface;
    CSwitchboard *m_pCSwitchboard;
};



#endif  // SWITCHBOARD_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\inh\switchboard.cpp ===
// Copyright (c) Microsoft Corporation.  All rights reserved

#include "stdafx.h"
#include "callback.h"

XomDefineArea(Reporting_v2);
const SGADDR sgaddrIgnore = { 0, 0, 0, 0, 0, 0, 0};

CInterfaceBucketChangeContext *g_pCInterfaceBucketChangeContextQueue = NULL;
CPresenceInfoContextQueue *g_pCPresenceInfoContextQueue = NULL;
BOOL g_bSwitchboardTooBusy = FALSE;
DWORD g_dwSwitchboardTooBusyTimeout = 500;
HANDLE g_hControlCallbackEvent = NULL;


BOOL CompareBinaryData(const DWORD cb1, const BYTE *pb1, const DWORD cb2, const BYTE *pb2)
{
    if (cb1 != cb2)
    {
        return FALSE;
    }

    if (cb1 == 0)
    {
        return TRUE;
    }

    return (0 == memcmp(pb1, pb2, cb1));
}

/*****************************************************************************

CompareMessageSentTime

Compare two messages by sent time.

*****************************************************************************/
static int __cdecl CompareMessageSentTime( const void *pCLeft, const void *pCRight )
{
    if ( ((const Q_MESSAGE_SUMMARY*)pCLeft)->mtSentTime >
         ((const Q_MESSAGE_SUMMARY*)pCRight)->mtSentTime )
    {
        return -1;
    }
    else if ( ((const Q_MESSAGE_SUMMARY*)pCLeft)->mtSentTime <
              ((const Q_MESSAGE_SUMMARY*)pCRight)->mtSentTime )
    {
        return 1;
    }
    else
    {
        return 0;
    }
}

/*****************************************************************************

CompareMessageSentTime

Compare two messages by sent time.

*****************************************************************************/
static int __cdecl CompareMessageSentTime2( const void *pCLeft, const void *pCRight )
{
    if ( ((const Q_MESSAGE_SUMMARY_2*)pCLeft)->mtSentTime >
         ((const Q_MESSAGE_SUMMARY_2*)pCRight)->mtSentTime )
    {
        return -1;
    }
    else if ( ((const Q_MESSAGE_SUMMARY_2*)pCLeft)->mtSentTime <
              ((const Q_MESSAGE_SUMMARY_2*)pCRight)->mtSentTime )
    {
        return 1;
    }
    else
    {
        return 0;
    }
}

/*****************************************************************************

CompareQueryAffiliatesRepliesByDateDesc

Used by the bsearch and qsort libary routines.

*****************************************************************************/
static int __cdecl CompareQueryAffiliatesRepliesByDateDesc( const void *pCLeft, const void *pCRight )
{
    return ((P_QUERY_AFFILIATES_REPLY_DATA_MSG *)pCRight)->mtDateUpdated - ((P_QUERY_AFFILIATES_REPLY_DATA_MSG *)pCLeft)->mtDateUpdated;
}


void CheckMigrationContextQueue(CSwitchboard *pSwitchboard)
{
    static DWORD dwDelay = 0;

    dwDelay++;
    // TODO: make this a config setting.
    dwDelay %= 100;

    if (dwDelay != 0)
    {
        // come back later.
        return;
    }

    SYSTEMTIME st;
    GetSystemTime(&st);
    FILETIME ft;
    SystemTimeToFileTime(&st, &ft);

    if ((g_pCInterfaceBucketChangeContextQueue != NULL) &&
        (CompareFileTime(&(g_pCInterfaceBucketChangeContextQueue->m_ftStart), &ft) < 0))
    {
        CInterfaceBucketChangeContext *pCCtx = g_pCInterfaceBucketChangeContextQueue;
        g_pCInterfaceBucketChangeContextQueue = g_pCInterfaceBucketChangeContextQueue->m_pNext;
        pCCtx->m_pNext = NULL;

        pCCtx->m_fTimeToStart = TRUE;
        pSwitchboard->PostCompletion(pCCtx);
    }
}


/*****************************************************************************

CHeartbeatHandler::Release

*****************************************************************************/
ULONG CHeartbeatHandler::AddRef()
{
    return m_pSwitchboard->AddRef();
}

/*****************************************************************************

CHeartbeatHandler::Release

*****************************************************************************/
ULONG CHeartbeatHandler::Release()
{
    return m_pSwitchboard->Release();
}

/*****************************************************************************

CHeartbeatHandler::OnIoCompletion

*****************************************************************************/
void CHeartbeatHandler::OnIoCompletion(
    DWORD dwError,
    DWORD cbTransferred,
    ULONG_PTR ulpKey,
    CCompletionContext *pCtx )
{
    XOMASSERT( NULL != m_pSwitchboard );
    XOMASSERT( pCtx == this );

    CScopeTimer scope( XPPERF_SERVER_HEARTBEAT_TIME_AVERAGE, XPPERF_SERVER_HEARTBEAT_TIME_BASE );
    m_pSwitchboard->PeriodicHeartbeat();
}

/*****************************************************************************

CSwitchboard::CSwitchboard

Constructor

*****************************************************************************/

CSwitchboard::CSwitchboard() :
    m_pCompPort( NULL ),
    m_HeartbeatHandler( this ),
    m_CProfileStore( this ),
    m_dwLastIndex(0)
{
    m_dwLastHeartBeat = GetTickCount();
}


/*****************************************************************************

CSwitchboard::~CSwitchboard

Destructor

*****************************************************************************/
CSwitchboard::~CSwitchboard()
{
    Shutdown();
}


/*****************************************************************************

CSwitchboard::Init

Initializer, must be called before first use.

*****************************************************************************/
HRESULT CSwitchboard::Init()
{
    HRESULT hr = S_OK;
    sockaddr_in sa;

    // Initalize the store
    hr = m_CProfileStore.Init();
    if(FAILED(hr))
    {
        XomNtEvent(XEVENT_PRESENCE_CONFIG_67, "Unrecoverable failure while initializing: m_CProfileStore.Init failed (%X)", hr);
        goto lDone;
    }

    // Create worker threads to deal with incoming network traffic
    hr = CCompletionPort::CreateInstance(
        0,  // dwConcurrancy
        1,  // dwThreadPoolSize
        THREAD_PRIORITY_HIGHEST,
        &m_pCompPort );

    if(FAILED(hr))
    {
        XomNtEvent(XEVENT_PRESENCE_CONFIG_68, "Unrecoverable failure while initializing: CCompPort::CreateInstance failed (%X)", hr);
        goto lDone;
    }

    // Init our SG communications
    hr = m_CSGComm.Init(this);
    if( FAILED( hr ) )
    {
        XomNtEvent(XEVENT_PRESENCE_CONFIG_69, "Unrecoverable failure while initializing: m_CSGComm.Init failed (%X)", hr);
        goto lDone;
    }

    // Init our connections to the presence servers
    hr = m_CXPCluster.Init(this);
    if( FAILED( hr ) )
    {
        XomNtEvent(XEVENT_PRESENCE_CONFIG_71, "Unrecoverable failure while initializing: m_CXPCluster.Init failed (%X)", hr);
        goto lDone;
    }

    // Create a socket to send out kick messages
    hr = CServerSocket::CreateInstance( &m_pKickSocket, m_pCompPort, m_pCompPort );

    if(FAILED(hr))
    {
        XomNtEvent(XEVENT_PRESENCE_CONFIG_72, "Unrecoverable failure while initializing: CServSocket::CreateInstance failed (%X)", hr );
        goto lDone;
    }

    memset(&sa, 0, sizeof(sa));
    sa.sin_family = AF_INET;

    hr = m_pKickSocket->Init(IPPROTO_UDP, &sa, FALSE);
    if(FAILED(hr))
    {
        XomNtEvent(XEVENT_PRESENCE_CONFIG_73, "Unrecoverable failure while initializing: m_pKickSocket::Init failed (%X)", hr);
        goto lDone;
    }

    // Init our client connection listener
    hr = m_CClientListener.Init(this);
    if(FAILED(hr))
    {
        XomNtEvent(XEVENT_PRESENCE_CONFIG_74, "Unrecoverable failure while initializing: m_CClientListener.Init failed (%X)", hr);
        goto lDone;
    }

    hr = g_CPresCfg.RegisterSwitchboard(this);
    if(FAILED(hr))
    {
        XomNtEvent(XEVENT_PRESENCE_CONFIG_75, "Unrecoverable failure while initializing: g_pConfig->RegisterSwitchboard failed (%X)", hr);
        goto lDone;
    }

    hr = S_OK;

lDone:

    return hr;
}

/*****************************************************************************

CSwitchboard::Shutdown

Deinitializer

*****************************************************************************/
void CSwitchboard::Shutdown()
{
    // NOTE: Shut down the completion port first.  This will stop all incoming data packets and cause all
    // connections to other servers in the cluster to disconnect.
    SAFE_SHUTRELEASE( m_pCompPort );

    // Now shut down all of the rest of our dependents
    m_CClientListener.Shutdown();
    m_CXPCluster.Shutdown();
    SAFE_RELEASE( m_pKickSocket );
}

/*****************************************************************************

CSwitchboard::OnHeartbeat

Regularly called from ServiceMain.  Posts a heartbeat object to the main
completion port.

*****************************************************************************/
void CSwitchboard::OnHeartbeat()
{
    HRESULT hr;

    if (m_pCompPort != NULL)
    {
        hr = m_pCompPort->PostCompletion( &m_HeartbeatHandler );
        XOMASSERT( SUCCEEDED( hr ) );
    }
    else
    {
        XOMASSERT(FALSE);
    }
}

/*****************************************************************************

CSwitchboard::PeriodicHeartbeat

Callback from listening socket.

*****************************************************************************/
void CSwitchboard::PeriodicHeartbeat()
{
    // Beat the clusters first
    m_CXPCluster.PeriodicHeartbeat();

    SendQVals();
    UserMaintainence();

    // POST-XENON: we punted the ability to load t_interface_buckets dynamically.  there's no reason to make this
    // call until we're ready to tackle that endevor.  When we do, we'll need to evaluate how expensive re-loading
    // the bucketmap actually is.  We may not want to do this in on the heartbeat.

    //g_CPresCfg.LoadBucketMap();
}

/*****************************************************************************

CSwitchboard::UserMaintainence

Perform maintainence on the users over a large interval of time

*****************************************************************************/
void CSwitchboard::UserMaintainence()
{
    HRESULT hr = S_OK;
    DWORD dwNow = 0;
    DWORD dwBucketsToVisit = 0;
    DWORD dwBucketIndex = 0;
    CPresence *pCPres = NULL;
    CPresence *pCVictim = NULL;

    if ((g_CPresCfg.GetPresUserCleanupDelay() == 0) ||
        (g_CPresenceUserIndex.GetNumBuckets() == 0))
    {
        // nop
        return;
    }

    // what time is it?
    dwNow = GetTickCount();

    dwBucketsToVisit = (g_CPresenceUserIndex.GetNumBuckets() * g_CPresCfg.GetHeartbeatDelay()) / g_CPresCfg.GetPresUserCleanupDelay();
    if (dwBucketsToVisit == 0)
    {
        XomNtEvent(XEVENT_PRESENCE_CONFIG_76, "UserMaintainence calculated 0 buckets to visit based on config settings.  This means user records will never be cleaned up.  Investigate the config settings for UserMaintainence.");
        return;
    }

    // Update the last heartbeat time using our change to control round down
    m_dwLastHeartBeat = dwNow;
    dwBucketIndex = m_dwLastIndex;

    XomTrace(PresenceDebug, L_LOW, "UserMaintainence: visiting %d buckets, starting with bucket %d.", dwBucketsToVisit, m_dwLastIndex);

    while (dwBucketsToVisit > 0)
    {
        bool fAbort = false;

        // For each entry in the chain
        pCPres = g_CPresenceUserIndex.GetBucket(dwBucketIndex);
        while (pCPres != NULL)
        {
            pCVictim = pCPres;
            pCPres = g_CPresenceUserIndex.GetNext(pCPres);

            // Delete expired messages
            pCVictim->DeleteExpiredMessages( dwNow );

            if (pCVictim->IsMarkedForMigration())
            {
                // create a migration context
                CUserMigrationContext *pCCtx = new CUserMigrationContext();
                if (pCCtx != NULL)
                {
                    pCCtx->m_pCSwitchboard = this;
                    pCCtx->m_pCPresence = pCVictim;
                    pCVictim->AddRef();

                    hr = PostCompletion(pCCtx);
                    if (FAILED(hr))
                    {
                        pCCtx->Release();
                    }

                    hr = S_OK;
                }
            }
            else if (pCVictim->IsMigrationInProgress())
            {
                // this prevents us from ever trying to send the full migration message.
                pCVictim->SetMigrationInProgress(FALSE);

                // we've looped all the way back around to this user, and he still hasnt migrated.  we give up.
                if (pCVictim->HasOnlineRecord() && pCVictim->IsOnline())
                {
                    pCVictim->SelfDestruct();
                    g_Counters.SafeDecrement32(XPPERF_SERVER_ACTIVE_USERS_COUNTER);
                }

                // make sure to release the bucket context.
                pCVictim->ReleaseMigrationContext();

                g_CPresenceUserIndex.RemovePresence(pCVictim);

                /* BUGBUG: if we got here, we probly leaked a reference for this record.  this means, Release() likely didnt
                the record.  we're thus leaking the whole presence record by abandoning it here. */
            }
            else if (!(pCVictim->IsOnline()) &&
                (pCVictim->HasOnlineRecord()) &&
                !(pCVictim->HasTransientMessages()))
            {
                if (!(pCVictim->IsMarkedForDelete()))
                {
                    // Pick it up next time
                    pCVictim->MarkForDelete();
                }
                else
                {
                    // Clean it up now
                    pCVictim->SelfDestruct();
                }
            }
            else if (pCVictim->IsMarkedForDeadSG())
            {
                hr = KillUser(pCVictim);
                if (FAILED(hr))
                {
                    // Ignore failures, specific errors logged by the function
                    XomTrace(PresenceDebug, L_NORMAL, "CSwitchboard::UserMaintainence - KillUser failed hr=0x%X", hr);

                    // bug 28713:  check if the outbound buffers have overflowed.
                    if (hr == XONLINE_E_NOTIFICATION_SEND_FAILED)
                    {
                        // this happens when we kill too many users at once.  sending notifications for all these users fills up the send
                        // buffers.  we need to relinquish flow control so that other context get scheduled and the buffers have a chance
                        // to drain.  we'll just pick up where we left off on the next call to UserMaintainence().

                        XomNtEvent(
                            XEVENT_PRESENCE_CONFIG_77,
                            "UserMaintainence(): outbound buffers filled while cleaning up users from a deadsg.  Deferring cleanup to the next heartbeat.  Current bucket = %d.",
                            dwBucketIndex);

                        fAbort = true;
                        break;
                    }

                    hr = S_OK;
                }
            }
            else if (pCVictim->IsOnline())
            {
                // BUGBUG: Move to config setting
                // If a user has been online too long, try sending QVals to them.  If they are gone, the SG will reply to us
                // with fNoSuchUser set to TRUE, and we will clean them up.
                if (dwNow - pCVictim->GetLastActiveTime() > 3600000)
                {
                    m_CSGComm.SendQVals(
                        pCVictim->GetSGAddr(),
                        pCVictim->GetUserID(),
                        0,
                        NULL,
                        0,
                        FALSE);
                }
            }

            SAFE_RELEASE(pCVictim);
        }

        if (fAbort)
        {
            // skip the increment to dwBucketIndex.
            break;
        }

        // Next Bucket
        dwBucketsToVisit--;
        dwBucketIndex++;
        if (dwBucketIndex == g_CPresenceUserIndex.GetNumBuckets())
        {
            dwBucketIndex = 0;
        }
    }

    m_dwLastIndex = dwBucketIndex;


    // Timeout Presence Info Contexts
    g_pCPresenceInfoContextQueue->Purge(dwNow);

    // check migration queue
    CheckMigrationContextQueue(this);
}

/*****************************************************************************

CSwitchboard::SendQVals

(Re)Send QVals for users

*****************************************************************************/
void CSwitchboard::SendQVals()
{
    HRESULT hr = S_OK;
    DWORD dwTotalSent = 0;
    DWORD dwNow;
    CPresence *pCPresence = NULL;

    // Keep time static inside the scope of this function
    dwNow = GetTickCount();

    for (dwTotalSent = 0; dwTotalSent < g_CPresCfg.GetMaxQValsPerHeartbeat(); dwTotalSent++)
    {
        // If there is anything in the heap
        if (g_CTicklePriQueue.GetCount() == 0)
        {
            break;
        }

        // Check if the top item is due
        hr = g_CTicklePriQueue.Peek( 0, &pCPresence );
        if( FAILED( hr ) ||
            NULL == pCPresence ||
            WrapDWORDCompare( dwNow, pCPresence->GetTimeScheduled() ) > 0 )
        {
            // No tickles are due yet
            break;
        }

        // Get the next user that needs to be tickled
        hr = g_CTicklePriQueue.Remove( 0, &pCPresence );
        if( FAILED( hr ) ||
            NULL == pCPresence )
        {
            // Possibly the user has gone offline, no need to keep sending them QVals
            continue;
        }

        pCPresence->SendQVals();
    }
}


HRESULT CSwitchboard::LogonCheck(
    SGADDR sgaddr,
    QWORD qwUserID)
{
    HRESULT hr = S_OK;
    CPresence *pCPresence;

    // See if there's currently a record for the given user
    hr = g_CPresenceUserIndex.FindPresence(qwUserID, &pCPresence);
    if(FAILED(hr))
    {
        goto lDone;
    }

    // check xboxid of caller versus presence record.
    if (pCPresence->IsOnline() && (sgaddr.qwXboxID != pCPresence->GetSGAddr()->qwXboxID))
    {
        hr = HRESULT_FROM_WIN32(ERROR_USER_EXISTS);
    }

lDone:

    SAFE_RELEASE(pCPresence);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "LogonCheck: User=%I64X, hr=0x%X",
        qwUserID,
        hr);

    return hr;
}

/*****************************************************************************

CSwitchboard::Alive

Establishes the user's presence in the system.

*****************************************************************************/
HRESULT CSwitchboard::Alive(
    SGADDR sgaddr,
    QWORD qwUserID,
    DWORD cbAcctName,
    LPCSTR szAcctName,
    DWORD dwClientVersion,
    DWORD dwBuddyListVersion,
    DWORD dwBlockListVersion,
    QWORD qwNonce,
    DWORD dwAuthDataFlags,
    DWORD dwTitleID,
    DWORD dwAltTitleID1,
    DWORD dwAltTitleID2,
    DWORD dwAltTitleID3,
    DWORD dwAltTitleID4,
    DWORD dwTitleVersion,
    DWORD dwTitleRegion,
    XNADDR xnaddr,
    XNKID xkid,
    XNKEY xnkey,
    IN_ADDR ipaXbox,
    WORD ipportXbox,
    BYTE *szLocale,
    QWORD qwVersionFlags,
    CClientConnection *pCReplyConn,
    DWORD dwSeqNum)
{
    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Alive: User=%I64X AcctLen=%d Acct=%s TitleId=0x%08X sg %X spi %X xb %I64X BuddyVer= %d BlockVer= %d",
        qwUserID,
        cbAcctName,
        szAcctName,
        dwTitleID,
        sgaddr.inaSg,
        sgaddr.dwSpiSg,
        sgaddr.qwXboxID,
        dwBuddyListVersion,
        dwBlockListVersion);

    HRESULT hr = S_OK;
    CPresence *pCPresence = NULL;
    CAliveContext *pCCtx = NULL;

    // Make sure the gamertag is valid
    if ((cbAcctName <= 1) || (szAcctName == NULL) || (szAcctName[0] == '\0'))
    {
        hr = E_INVALIDARG;
        goto lDone;
    }

    // If this is an XonWatch account, check the IP address
    if ((szAcctName[0] >= '0') &&
        (szAcctName[0] <= '9') &&
        (!g_CPresCfg.IsValidOnWatchAddr(ipaXbox)))
    {
        XomNtEvent(
            XEVENT_PRESENCE_HACK_212,
            "Attempted login by gamertag %s from addr %s:%d",
            szAcctName,
            inet_ntoa(ipaXbox),
            ntohs(ipportXbox));
        hr = E_FAIL;
        goto lDone;
    }

    // Check to make sure there aren't too many users on the system
    if ((g_Counters.GetCurrentValue32(XPPERF_SERVER_ACTIVE_USERS_COUNTER) >=
        g_CPresCfg.GetMaxPresenceUsers()) ||
        g_bSimulateTooBusy ||
        g_bSwitchboardTooBusy)
    {
        // CONSIDER: should this be an NT event instead?
        XomTrace(
            PresenceDebug,
            L_NORMAL,
            "Throttle: Active Users: %d >= Max Users: %d",
            g_Counters.GetCurrentValue32(XPPERF_SERVER_ACTIVE_USERS_COUNTER),
            g_CPresCfg.GetMaxPresenceUsers());

        hr = XONLINE_E_NOTIFICATION_SERVER_BUSY;
        goto lDone;
    }

    // Create a context object
    pCCtx = new CAliveContext(this, &m_CProfileStore);
    if (pCCtx == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pCCtx->m_eState = CAliveContext::AliveState_Store;
    pCCtx->m_sgaddr = sgaddr;
    pCCtx->m_qwUserID = qwUserID;
    pCCtx->m_cbAccountName = cbAcctName;
    memcpy(pCCtx->m_szAccountName, szAcctName, cbAcctName);
    pCCtx->m_szAccountName[cbAcctName] = '\0';
    pCCtx->m_dwClientBuddyListVersion = dwBuddyListVersion;
    pCCtx->m_dwClientBlockListVersion = dwBlockListVersion;
    pCCtx->m_dwTitleID = dwTitleID;
    pCCtx->m_dwAltTitleID1 = dwAltTitleID1;
    pCCtx->m_dwAltTitleID2 = dwAltTitleID2;
    pCCtx->m_dwAltTitleID3 = dwAltTitleID3;
    pCCtx->m_dwAltTitleID4 = dwAltTitleID4;
    pCCtx->m_dwTitleRegion = dwTitleRegion;
    memcpy(pCCtx->m_szLocale, szLocale, XONLINE_PRESENCE_LOCALE_SIZE);
    pCCtx->m_qwVersionFlags = qwVersionFlags;
    pCCtx->m_pCReplyConn = pCReplyConn;
    pCReplyConn->AddRef();
    pCCtx->m_dwSeqNum = dwSeqNum;

    // See if there's currently a record for the given user
    hr = g_CPresenceUserIndex.FindPresence(qwUserID, &pCPresence);
    if (FAILED(hr) && (hr != HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER)))
    {
        goto lDone;
    }

    if (pCPresence)
    {
        // Try to kick off the old user
        XomTrace(
            PresenceDebug,
            L_NORMAL,
            "Kicking old session: sg %X spi %X xb %I64X User=%I64X",
            sgaddr.inaSg,
            sgaddr.dwSpiSg,
            sgaddr.qwXboxID,
            qwUserID);

        if (pCPresence->IsOnline())
        {
            m_CSGComm.SendKick(pCPresence->GetSGAddr());
        }

        // Clear any invitations
        ClearInvitation(pCPresence);

        // Can we just let them through?
        if ((pCPresence->GetTitleID() == dwTitleID) &&
            (pCPresence->GetSGAddr()->qwXboxID == sgaddr.qwXboxID) &&
            (pCPresence->GetClientVersionDWORD() == dwClientVersion) &&
            (pCPresence->GetBuddyListVersion() == dwBuddyListVersion) &&
            (pCPresence->GetBuddyListVersion() != 0xFFFFFFFF) &&
            (pCPresence->GetBlockListVersion() == dwBlockListVersion) &&
            (pCPresence->GetBlockListVersion() != 0xFFFFFFFF) &&
            (g_CPresCfg.GetPresUserCleanupDelay() > 0))
        {
            // Skip the store
            pCCtx->m_eState = CAliveContext::AliveState_StoreComplete;
            pCCtx->m_hrStore = XONLINE_S_LOGON_USER_MESSAGE_ENUMERATION_NEEDED; // Always tell the client to enumerate after an Alive cache hit
            pCCtx->m_dwBuddyListVersion = dwBuddyListVersion;
            pCCtx->m_dwBlockListVersion = dwBlockListVersion;

            g_Counters.IncrementValue32(XPPERF_SERVER_ALIVE_CACHE_HIT_COUNTER, 1);
            g_Counters.IncrementValue32(XPPERF_SERVER_ALIVE_CACHE_HIT_RATE, 1);
        }
        else
        {
            // If the Alive cache was stale, then make sure that if this Alive doesn't succeed (such as if the user has required messages)
            // the next Alive hits the store.
            pCPresence->ForceDBAlive();
        }

        // Overwrite the old record
        hr = pCPresence->Alive(
            &sgaddr,
            dwClientVersion,
            qwNonce,
            dwAuthDataFlags,
            dwTitleID,
            dwAltTitleID1,
            dwAltTitleID2,
            dwAltTitleID3,
            dwAltTitleID4,
            dwTitleVersion,
            dwTitleRegion,
            xnaddr,
            xkid,
            xnkey,
            ipaXbox,
            ipportXbox,
            cbAcctName,
            szAcctName,
            szLocale,
            qwVersionFlags);
    }
    else
    {
        // Create a new record
        hr = g_CPresenceUserIndex.CreatePresence(
            this,
            pCCtx->m_qwUserID,
            qwNonce,
            cbAcctName,
            szAcctName,
            0,
            &pCPresence);
        if (FAILED(hr))
        {
            goto lDone;
        }

        hr = pCPresence->CreateOnlineRecord(
            &sgaddr,
            dwClientVersion,
            dwAuthDataFlags,
            dwTitleID,
            dwTitleVersion,
            dwTitleRegion,
            xnaddr,
            xkid,
            xnkey,
            ipaXbox,
            ipportXbox,
            szLocale,
            qwVersionFlags);
        if(FAILED(hr))
        {
            goto lDone;
        }

        // Add it to the indexes
        g_CPresenceXBoxIndex.AddPresence(pCPresence);
        g_CPresenceSGIndex.AddPresence(pCPresence);

        pCPresence->RecordUserAlive();

    }

    if (FAILED(hr))
    {
        goto lDone;
    }

    // Post the context to the next part of the state machine
    pCCtx->AddRef();
    pCCtx->m_pCPresence = pCPresence;
    pCPresence->AddRef();

    if (pCCtx->m_eState == CAliveContext::AliveState_Store)
    {
        hr = m_CProfileStore.SendToSqlThread(pCCtx);
    }
    else
    {
        // NOTE: If this fails it will already have sent a response, no result is needed here
        AliveStoreComplete(pCCtx);
    }

    if (FAILED(hr))
    {
        goto lDone;
    }

lDone:

    if (FAILED(hr))
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_413,
            "CSwitchboard::Alive failed user=%I64X name=%s TitleId=0x%08X hr=0x%X",
            qwUserID,
            szAcctName,
            dwTitleID,
            hr);
    }

    SAFE_RELEASE(pCCtx);
    SAFE_RELEASE(pCPresence);

    return hr;
}

/*****************************************************************************

CSwitchboard::CheckTitleMessages

checks for new system messages on a title change

*****************************************************************************/
HRESULT CSwitchboard::CheckTitleMessages(
        QWORD qwUserID,
        DWORD dwTitleID,
        DWORD dwAltTitleID1,
        DWORD dwAltTitleID2,
        DWORD dwAltTitleID3,
        DWORD dwAltTitleID4,
        DWORD dwTitleRegion,
        DWORD dwTitleVersion,
        CClientConnection *pCReplyConn,
        DWORD dwSeqNum)
{
    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "CheckTitleMessages: User=%I64X TitleId=0x%08X",
        qwUserID,
        dwTitleID);

    HRESULT hr;
    CPresence *pCPresence;
    CCheckTitleMessagesContext *pCCtx = NULL;
    CAliveContext *pAliveCtx = NULL;

    // See if there's currently a record for the given user
    hr = g_CPresenceUserIndex.FindPresence(qwUserID, &pCPresence);
    if(FAILED(hr))
    {
        goto lDone;
    }

    //  Do the equivalent of Alive - enumerate title messages, etc.

    // if these allocs return null, we just wont do it.  no need to report this error if the rest of the call can succeed.
    pCCtx = new CCheckTitleMessagesContext(this, &m_CProfileStore);
    if (pCCtx == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // we need to call one of alive's sprocs, so we'll make a dummy alive context to pass to it.
    pAliveCtx = new CAliveContext(NULL, NULL);
    if (pAliveCtx == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pAliveCtx->m_qwUserID = qwUserID;
    pAliveCtx->m_dwTitleID = dwTitleID;
    pAliveCtx->m_dwAltTitleID1 = dwAltTitleID1;
    pAliveCtx->m_dwAltTitleID2 = dwAltTitleID2;
    pAliveCtx->m_dwAltTitleID3 = dwAltTitleID3;
    pAliveCtx->m_dwAltTitleID4 = dwAltTitleID4;
    pAliveCtx->m_dwTitleRegion = dwTitleRegion;

    pCCtx->m_pAliveCtx = pAliveCtx;
    pCCtx->m_dwSeqNum = dwSeqNum;
    pCCtx->m_pCReplyConn = pCReplyConn;
    pCReplyConn->AddRef();
    pCCtx->m_pCPresence = pCPresence;
    pCPresence->AddRef();

    // this will do more work on completion, but it isnt pertinent to the rest of this function.
    hr = m_CProfileStore.SendToSqlThread(pCCtx);

lDone:

    if (FAILED(hr))
    {
        SAFE_RELEASE(pAliveCtx);
        SAFE_RELEASE(pCCtx);
    }

    SAFE_RELEASE(pCPresence);

    return hr;
}

/*****************************************************************************

CSwitchboard::Sync

Resync the buddy and block lists for the given user

*****************************************************************************/
HRESULT CSwitchboard::Sync(
    SGADDR sgaddr,
    QWORD qwUserID,
    DWORD dwBuddyListVersion,
    DWORD dwBlockListVersion,
    CClientConnection *pCReplyConn,
    DWORD dwSeqNum)
{
    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Sync: User=%I64X sg %X spi %X xb %I64X BuddyVer= %d BlockVer= %d",
        qwUserID,
        sgaddr.inaSg,
        sgaddr.dwSpiSg,
        sgaddr.qwXboxID,
        dwBuddyListVersion,
        dwBlockListVersion);

    HRESULT hr;
    CPresence *pCPresence;
    CSyncContext *pCCtx = NULL;

    // See if there's currently a record for the given user
    hr = g_CPresenceUserIndex.FindPresence(qwUserID, &pCPresence);
    if(FAILED(hr))
    {
        goto lDone;
    }

    // Validate the message's sgaddr against the user's
    if (!CheckSGAddr(&sgaddr, pCPresence))
    {
        if (pCPresence->IsOnline())
        {
            // this is only an error if the expected sg is nonzero.  otherwise it may be that the user just logged off.
            g_Counters.IncrementValue32(XPPERF_SERVER_BAD_USER_COUNTER, 1);
            g_Counters.IncrementValue32(XPPERF_SERVER_BAD_USER_RATE, 1);
            hr = XONLINE_E_SERVER_ERROR;
        }
        goto lDone;
    }

    // Create a context object
    pCCtx = new CSyncContext(this, &m_CProfileStore);
    if (pCCtx == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pCCtx->m_fProcessed = FALSE;
    pCCtx->m_qwUserID = qwUserID;
    pCCtx->m_dwClientBuddyListVersion = dwBuddyListVersion;
    pCCtx->m_dwClientBlockListVersion = dwBlockListVersion;
    pCCtx->m_pCReplyConn = pCReplyConn;
    pCReplyConn->AddRef();
    pCCtx->m_dwSeqNum = dwSeqNum;
    pCCtx->m_pCPresence = pCPresence;
    pCPresence->AddRef();

    // Send it over to the SQL thread pool
    hr = m_CProfileStore.SendToSqlThread( pCCtx );
    if (FAILED(hr))
    {
        goto lDone;
    }

lDone:

    if (FAILED(hr))
    {
        SAFE_RELEASE(pCCtx);
    }

    // SYNC response will be sent from callback

    SAFE_RELEASE(pCPresence);

    return hr;
}

/*****************************************************************************

CSwitchboard::Add

Attempt to add the given person to the sender's buddy list, either by the
person's ID or name.

*****************************************************************************/
HRESULT CSwitchboard::Add(
    SGADDR sgaddr,
    DWORD dwSeqNum,
    QWORD qwUserID,
    QWORD qwBuddyID,
    DWORD dwMessageFlags,
    WORD cbDetails,
    const BYTE* pbDetails,
    LPCSTR pszBuddyAcctName,
    QWORD *pqwNonce)
{
    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Add: User=%I64X Buddy=%I64X (%s)",
        qwUserID,
        qwBuddyID,
        ( 0 == qwBuddyID ) ? pszBuddyAcctName : "" );

    HRESULT hr = S_OK;
    CPresence *pCPresence = NULL;
    CAddBuddyContext *pCCtx = NULL;

    // See if there's currently a record for the given user
    hr = g_CPresenceUserIndex.FindPresence(qwUserID, &pCPresence);
    if(FAILED(hr))
    {
        goto lDone;
    }

    // Create a context object
    pCCtx = new CAddBuddyContext(this, &m_CProfileStore);
    if (pCCtx == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pCCtx->m_fProcessed = FALSE;
    pCCtx->m_qwUserID = qwUserID;
    pCCtx->m_dwMessageFlags = dwMessageFlags;
    pCCtx->m_cbDetails = cbDetails;
    memcpy( pCCtx->m_rgbDetails, pbDetails, cbDetails );
    pCCtx->m_qwBuddyID = qwBuddyID;

    pCCtx->m_cbBuddyAccountName = pszBuddyAcctName[ 0 ] ? strlen( pszBuddyAcctName ) + 1 : 0;
    memcpy(pCCtx->m_szBuddyAccountName, pszBuddyAcctName, pCCtx->m_cbBuddyAccountName);


    if (memcmp(&sgaddrIgnore, &sgaddr, sizeof(SGADDR)) != 0)
    {
        // Online case

        // Validate the message's sgaddr against the user's
        if (!CheckSGAddr(&sgaddr, pCPresence))
        {
            g_Counters.IncrementValue32(XPPERF_SERVER_BAD_USER_COUNTER, 1);
            g_Counters.IncrementValue32(XPPERF_SERVER_BAD_USER_RATE, 1);

            hr = XONLINE_E_SERVER_ERROR;
            goto lDone;
        }

        XOMASSERT(pqwNonce != NULL);
        *pqwNonce = pCPresence->GetNonce();

        pCCtx->m_dwTitleID = pCPresence->GetTitleID();
        pCCtx->m_cbUserAccountName = pCPresence->GetAcctNameLen();
        memcpy(pCCtx->m_szUserAccountName, pCPresence->GetAcctName(), pCPresence->GetAcctNameLen());
    }
    else
    {
        pCCtx->m_dwTitleID = XONLINE_XBOX_DASH_TITLE_ID;  // Dashboard
        pCCtx->m_cbUserAccountName = 0;
        pCCtx->m_szUserAccountName[0] = '\0';
    }

    pCCtx->m_pCPresence = pCPresence;
    pCPresence->AddRef();

    // Send it over to the SQL thread pool
    hr = m_CProfileStore.SendToSqlThread( pCCtx );
    if (FAILED(hr))
    {
        goto lDone;
    }


    // Call will post a completion when it resolves

lDone:

    if (FAILED(hr))
    {
        SAFE_RELEASE(pCCtx);
    }

    SAFE_RELEASE(pCPresence);

    return hr;
}

/*****************************************************************************

CSwitchboard::AddAffiliates

Attempt to add the given users to the sender's affiliates list.

*****************************************************************************/
HRESULT CSwitchboard::AddAffiliates(
    SGADDR sgaddr,
    QWORD qwUserID,
    DWORD dwListFlag,
    DWORD dwTitleID,
    WORD cwAffiliates,
    QWORD *pqwAffiliates)
{
    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "AddAffiliates: User=%I64X cwAffiliates=%d dwListFlag=0x%08X dwTitleID=0x%08X",
        qwUserID,
        cwAffiliates,
        dwListFlag,
        dwTitleID);

    for (WORD i = 0; i < cwAffiliates; i++)
    {
        XomTrace(
            PresenceDebug,
            L_NORMAL,
            "AddAffiliates(%d/%d): Affiliate=%I64X",
            i,
            cwAffiliates,
            pqwAffiliates[i]);
    }

    HRESULT hr = S_OK;
    CPresence *pCPresence = NULL;
    CAddAffiliatesContext *pCCtx = NULL;

    // See if there's currently a record for the given user
    hr = g_CPresenceUserIndex.FindPresence(qwUserID, &pCPresence);
    if(FAILED(hr))
    {
        goto lDone;
    }

    if (memcmp(&sgaddrIgnore, &sgaddr, sizeof(SGADDR)) != 0)
    {
        // Online case

        // Validate the message's sgaddr against the user's
        if (!CheckSGAddr(&sgaddr, pCPresence))
        {
            g_Counters.IncrementValue32(XPPERF_SERVER_BAD_USER_COUNTER, 1);
            g_Counters.IncrementValue32(XPPERF_SERVER_BAD_USER_RATE, 1);

            hr = XONLINE_E_SERVER_ERROR;
            goto lDone;
        }
    }

    FILETIME ft;
    GetSystemTimeAsFileTime(&ft);

    // Create a context object
    pCCtx = new CAddAffiliatesContext(this, &m_CProfileStore);
    if (pCCtx == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Populate the context object
    pCCtx->m_fProcessed = TRUE;
    pCCtx->m_qwUserID = qwUserID;
    pCCtx->m_dwListFlag = dwListFlag;
    pCCtx->m_dwTitleID = dwTitleID;
    pCCtx->m_mtDateUpdated = FileTimeToMsgTime(&ft);
    if (pCPresence != NULL)
    {
        pCCtx->m_pCPresence = pCPresence;
        pCPresence->AddRef();
    }
    hr = pCCtx->SetAffiliates(cwAffiliates, pqwAffiliates);
    if (FAILED(hr))
    {
        goto lDone;
    }

    if (!(pCPresence->IsAffiliatesListLoaded()))
    {
        // need to go to sql and get the affiliates lists.
        pCCtx->m_fProcessed = FALSE;

        // allocate memory for the lists on the switchboard thread.
        pCCtx->m_prgAffiliateLists = new CAffiliatesList *[NUM_STORED_AFFILIATE_LISTS];
        if (pCCtx->m_prgAffiliateLists == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto lDone;
        }

        ZeroMemory(pCCtx->m_prgAffiliateLists, NUM_STORED_AFFILIATE_LISTS * sizeof(CAffiliatesList *));

        for (DWORD dwList = 0; dwList < NUM_STORED_AFFILIATE_LISTS; dwList++)
        {
            pCCtx->m_prgAffiliateLists[dwList] = new CAffiliatesList;
            if (pCCtx->m_prgAffiliateLists[dwList] == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto lDone;
            }

            pCCtx->m_prgAffiliateLists[dwList]->dwAlloc = g_rgdwMaxAffiliates[dwList];
            pCCtx->m_prgAffiliateLists[dwList]->dwSize = 0;
            pCCtx->m_prgAffiliateLists[dwList]->rgAffiliates = new CAffiliatesListEntry[g_rgdwMaxAffiliates[dwList]];
            if (pCCtx->m_prgAffiliateLists[dwList]->rgAffiliates == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto lDone;
            }
        }

        // Send it over to the SQL thread pool
        hr = m_CProfileStore.SendToSqlThread( pCCtx );
        if (FAILED(hr))
        {
            goto lDone;
        }
    }
    else
    {
        // affiliates are no longer write-through.  we can just service the add right here.
        hr = AddAffiliatesComplete(pCCtx);
    }


lDone:

    if (FAILED(hr))
    {
        SAFE_RELEASE(pCCtx);
    }

    SAFE_RELEASE(pCPresence);

    return hr;
}

/*****************************************************************************

CSwitchboard::IsAffiliate

query if a user is on the sender's affiliates list.

*****************************************************************************/
HRESULT CSwitchboard::IsAffiliate(
    SGADDR sgaddr,
    DWORD dwSeqNum,
    QWORD qwUserID,
    QWORD qwAffiliateID,
    CClientConnection *pCReplyConn)
{
    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "IsAffiliate: User=%I64X qwAffiliateID=%I64X",
        qwUserID,
        qwAffiliateID);

    HRESULT hr = S_OK;
    CPresence *pCPresence = NULL;
    CIsAffiliateContext *pCCtx = NULL;

    // See if there's currently a record for the given user
    hr = g_CPresenceUserIndex.FindPresence(qwUserID, &pCPresence);
    if (FAILED(hr))
    {
        goto lDone;
    }
    if(!(pCPresence->HasOnlineRecord()))
    {
        hr = HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
        goto lDone;
    }

    // Validate the message's sgaddr against the user's
    if (!CheckSGAddr(&sgaddr, pCPresence))
    {
        if (pCPresence->IsOnline())
        {
            // this is only an error if the expected sg is nonzero.  otherwise it may be that the user just logged off.
            g_Counters.IncrementValue32(XPPERF_SERVER_BAD_USER_COUNTER, 1);
            g_Counters.IncrementValue32(XPPERF_SERVER_BAD_USER_RATE, 1);
            hr = XONLINE_E_SERVER_ERROR;
        }
        goto lDone;
    }

    if (!pCPresence->IsAffiliatesListLoaded())
    {
        // get profile store to load the list.  it will do a callback to send the reply.
        pCCtx = new CIsAffiliateContext(this, &m_CProfileStore);
        if (pCCtx == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto lDone;
        }

        // Populate the context object
        pCCtx->m_fProcessed = FALSE;
        pCCtx->m_qwUserID = qwUserID;
        pCCtx->m_dwSeqNum = dwSeqNum;
        pCCtx->m_qwAffiliateID = qwAffiliateID;
        pCCtx->m_pCReplyConn = pCReplyConn;
        pCReplyConn->AddRef();
        pCCtx->m_pCPresence = pCPresence;
        pCPresence->AddRef();

        // allocate memory for the lists on the switchboard thread.
        pCCtx->m_prgAffiliateLists = new CAffiliatesList *[NUM_STORED_AFFILIATE_LISTS];
        if (pCCtx->m_prgAffiliateLists == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto lDone;
        }

        ZeroMemory(pCCtx->m_prgAffiliateLists, NUM_STORED_AFFILIATE_LISTS * sizeof(CAffiliatesList *));

        for (DWORD dwList = 0; dwList < NUM_STORED_AFFILIATE_LISTS; dwList++)
        {
            pCCtx->m_prgAffiliateLists[dwList] = new CAffiliatesList;
            if (pCCtx->m_prgAffiliateLists[dwList] == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto lDone;
            }

            pCCtx->m_prgAffiliateLists[dwList]->dwAlloc = g_rgdwMaxAffiliates[dwList];
            pCCtx->m_prgAffiliateLists[dwList]->dwSize = 0;
            pCCtx->m_prgAffiliateLists[dwList]->rgAffiliates = new CAffiliatesListEntry[g_rgdwMaxAffiliates[dwList]];
            if (pCCtx->m_prgAffiliateLists[dwList]->rgAffiliates == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto lDone;
            }
        }

        // Send it over to the SQL thread pool
        hr = m_CProfileStore.SendToSqlThread( pCCtx );
        if (FAILED(hr))
        {
            goto lDone;
        }
    }
    else
    {
        // list is loaded already, we can service the request here.
        DWORD dwFlags = 0;

        hr = pCPresence->IsUserAffiliate(
            qwAffiliateID,
            &dwFlags);
        if (FAILED(hr))
        {
            goto lDone;
        }

        hr = SendIsAffiliateReply(
            dwSeqNum,
            hr,
            qwAffiliateID,
            dwFlags,
            pCReplyConn);

        if( SUCCEEDED(hr) ||
            (hr == HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER)) || // mistyped name
            (hr == HRESULT_FROM_WIN32(ERROR_USER_EXISTS)) || // already a friend
            (hr == XONLINE_E_NOTIFICATION_BLOCKED) || // never list
            (hr == XONLINE_E_NOTIFICATION_LIST_FULL) || // full list
            (hr == XONLINE_E_NOTIFICATION_OTHER_LIST_FULL)) // other list is full
        {
            g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_IS_AFFILIATE_MSGS_COUNTER );
        }
        else
        {
            g_Counters.TrackFailureMessage( XPPERF_SERVER_IS_AFFILIATE_MSGS_COUNTER );

            XomNtEvent(
                XEVENT_PRESENCE_CODE_414,
                "CSwitchboard::IsAffiliateComplete failed user=%I64X; affiliate %I64X; hr=0x%X",
                qwUserID,
                qwAffiliateID,
                hr);
        }
    }

lDone:

    if (FAILED(hr))
    {
        SAFE_RELEASE(pCCtx);
    }

    SAFE_RELEASE(pCPresence);

    return hr;
}

/*****************************************************************************

CSwitchboard::QueryAffiliates

query the sender's affiliates list.

*****************************************************************************/
HRESULT CSwitchboard::QueryAffiliates(
    SGADDR sgaddr,
    DWORD dwSeqNum,
    QWORD qwUserID,
    DWORD dwListFlags,
    DWORD cdwLimit,
    DWORD dwTitleID,
    CClientConnection *pCReplyConn)
{
    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "QueryAffiliates: SeqNum=%d User=%I64X dwFlags=0x%08X dwTitleID=0x%08X cdwLimit=%d",
        dwSeqNum,
        qwUserID,
        dwListFlags,
        dwTitleID,
        cdwLimit);

    HRESULT hr = S_OK;
    CPresence *pCPresence = NULL;
    CQueryAffiliatesContext *pCCtx = NULL;

    // See if there's currently a record for the given user
    hr = g_CPresenceUserIndex.FindPresence(qwUserID, &pCPresence);
    if (FAILED(hr))
    {
        goto lDone;
    }
    if(!(pCPresence->HasOnlineRecord()))
    {
        hr = HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
        goto lDone;
    }

    // Validate the message's sgaddr against the user's
    if (!CheckSGAddr(&sgaddr, pCPresence))
    {
        if (pCPresence->IsOnline())
        {
            // this is only an error if the expected sg is nonzero.  otherwise it may be that the user just logged off.
            g_Counters.IncrementValue32(XPPERF_SERVER_BAD_USER_COUNTER, 1);
            g_Counters.IncrementValue32(XPPERF_SERVER_BAD_USER_RATE, 1);
            hr = XONLINE_E_SERVER_ERROR;
        }
        goto lDone;
    }

    pCCtx = new CQueryAffiliatesContext(this, &m_CProfileStore);
    if (pCCtx == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pCCtx->m_cdwLimit = cdwLimit;
    pCCtx->m_dwListFlags = dwListFlags & X_AFFILIATE_FLAGS_IN_USE;
    pCCtx->m_dwSeqNum = dwSeqNum;
    pCCtx->m_dwTitleID = dwTitleID;
    pCCtx->m_qwUserID = qwUserID;
    pCCtx->m_pCReplyConn = pCReplyConn;
    pCReplyConn->AddRef();
    pCCtx->m_pCPresence = pCPresence;
    pCPresence->AddRef();

    if (!pCPresence->IsAffiliatesListLoaded())
    {
        // allocate memory for the lists on the switchboard thread.
        pCCtx->m_prgAffiliateLists = new CAffiliatesList *[NUM_STORED_AFFILIATE_LISTS];
        if (pCCtx->m_prgAffiliateLists == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto lDone;
        }

        ZeroMemory(pCCtx->m_prgAffiliateLists, NUM_STORED_AFFILIATE_LISTS * sizeof(CAffiliatesList *));

        for (DWORD dwList = 0; dwList < NUM_STORED_AFFILIATE_LISTS; dwList++)
        {
            pCCtx->m_prgAffiliateLists[dwList] = new CAffiliatesList;
            if (pCCtx->m_prgAffiliateLists[dwList] == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto lDone;
            }

            pCCtx->m_prgAffiliateLists[dwList]->dwAlloc = g_rgdwMaxAffiliates[dwList];
            pCCtx->m_prgAffiliateLists[dwList]->dwSize = 0;
            pCCtx->m_prgAffiliateLists[dwList]->rgAffiliates = new CAffiliatesListEntry[g_rgdwMaxAffiliates[dwList]];
            if (pCCtx->m_prgAffiliateLists[dwList]->rgAffiliates == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto lDone;
            }
        }

        // get profile store to load the list.  it will do a callback to send the reply.
        pCCtx->m_eState = CQueryAffiliatesContext::QueryAffiliates_LoadList;
        hr = m_CProfileStore.SendToSqlThread(pCCtx);
        if (FAILED(hr))
        {
            goto lDone;
        }
    }
    else
    {
        // build the lists from presence
        hr = pCCtx->BuildResultsList(pCPresence);
        if (FAILED(hr))
        {
            goto lDone;
        }

        if (dwTitleID != 0)
        {
            // get presence info for the list.
            pCCtx->m_eState = CQueryAffiliatesContext::QueryAffiliates_WaitForPresence;
            hr = PostCompletion(pCCtx);
        }
        else
        {
            // no interest in presence state.  we can service the request now.
            hr = QueryAffiliatesComplete(pCCtx);
        }
    }

lDone:

    if (FAILED(hr))
    {
        SAFE_RELEASE(pCCtx);
    }

    SAFE_RELEASE(pCPresence);

    return hr;
}

/*****************************************************************************

CSwitchboard::GetPresenceInfo

returns presence info for a list of users.

*****************************************************************************/
HRESULT CSwitchboard::GetPresenceInfo(
    DWORD dwContext,
    QWORD qwSenderID,
    DWORD cdwUsers,
    QWORD * rgUsers,
    BOOL fFromPresence,
    CTCPCntMessageBased<CTCPCntMessageBasedPlugin_PN> *pCReplyConn)
{
    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "GetPresenceInfo: SeqNum=%d User=%I64X",
        dwContext,
        qwSenderID);

    HRESULT hr = S_OK;
    CPresence *pCPresence = NULL;
    CGetPresenceInfoContext *pCallerCtx = NULL;
    DWORD dwForwardsNeeded = 0;

    for (DWORD iPreScan = 0; iPreScan < cdwUsers; iPreScan++)
    {
        hr = g_CPresenceUserIndex.FindPresence(rgUsers[iPreScan], &pCPresence);
        SAFE_RELEASE(pCPresence);

        if (!fFromPresence && FAILED(hr) &&
            (hr != HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER)))
        {
            // The client version of this message will get defered or forwarded by cliconn.
            // Since there can only be one target in the client version, we dont need to swap anything.

            // HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER) is an expected error meaning that this call needs to load the base record.
            goto lDone;
        }

        if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
        {
            // swap the defered user to the front
            QWORD qwFirst = rgUsers[0];
            rgUsers[0] = rgUsers[iPreScan];
            rgUsers[iPreScan] = qwFirst;

            goto lDone;
        }
        else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
        {
            dwForwardsNeeded++;
        }
    }
    hr = S_OK;

    BYTE *pBuffer = new BYTE[cdwUsers * (sizeof (P_PRESENCE_INFO_DATA_MSG) + MAX_TITLE_STATE_BYTES + g_CPresCfg.GetMaxRichPresenceBytes())];
    if (pBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pCallerCtx = new CGetPresenceInfoContext(this);
    if (pCallerCtx == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }
    pCallerCtx->cdwUsers = cdwUsers;
    pCallerCtx->dwContext = dwContext;
    pCallerCtx->dwPendingLoads = 0;
    pCallerCtx->pBuffer = pBuffer;
    pCallerCtx->fFromPresence = fFromPresence;
    pCallerCtx->pCReplyConn = pCReplyConn;
    SAFE_ADDREF(pCReplyConn);
    pCallerCtx->qwSenderID = qwSenderID;

    P_PRESENCE_INFO_DATA_MSG *pReply = (P_PRESENCE_INFO_DATA_MSG *)pBuffer;

    if (dwForwardsNeeded > 0)
    {
        pCallerCtx->m_rgPUIDs = new QWORD[dwForwardsNeeded];
        if (pCallerCtx->m_rgPUIDs == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto lDone;
        }
    }

    for (DWORD iUser = 0; iUser < cdwUsers; iUser++)
    {
        HRESULT hrInner = S_OK;

        // See if there's currently a record for the given user
        hrInner = g_CPresenceUserIndex.FindPresence(rgUsers[iUser], &pCPresence);
        if( pCPresence == NULL )
        {
            // first make sure this user hasnt been migrated.
            if (hrInner == XONLINE_E_PRESENCE_USER_MIGRATED)
            {
                // add this user to the forward list
                pCallerCtx->m_rgPUIDs[pCallerCtx->m_cdwPUIDs] = rgUsers[iUser];
                pCallerCtx->m_cdwPUIDs++;
                pCallerCtx->cdwUsers--;
                continue;
            }

            // need to load this record.
            CLoadOfflinePresenceContext *pCCtx = new CLoadOfflinePresenceContext(this, &m_CProfileStore);
            if (pCCtx == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto lDone;
            }

            pCallerCtx->dwPendingLoads++;
            pCCtx->m_pvParentData = pReply;
            pCCtx->m_pCaller = pCallerCtx;
            pCCtx->m_qwUserID = rgUsers[iUser];

            // user is offline, so he will have no rich presence data
            pReply->cbStateData = 0;
            pReply->cbRichPresence = 0;

            hrInner = m_CProfileStore.SendToSqlThread(pCCtx);
            if (FAILED(hrInner))
            {
                continue;
            }
        }
        else
        {
            // add the user now

            // signal that there is space available for the variable length fields.
            pReply->cbStateData = 0xFFFF;
            pReply->cbRichPresence = 0xFFFFFFFF;

            hrInner = pCallerCtx->ProcessUser(pCPresence, (void *)pReply);
            if (FAILED(hrInner))
            {
                SAFE_RELEASE(pCPresence);
                continue;
            }
        }

        pReply->qwUserID = rgUsers[iUser];
        pReply = (P_PRESENCE_INFO_DATA_MSG *)((BYTE *)(pReply + 1) + pReply->cbStateData + pReply->cbRichPresence);

        SAFE_RELEASE(pCPresence);
    }

lDone:

    if (pCallerCtx && pCallerCtx->dwPendingLoads == 0)
    {
        hr = pCallerCtx->Finalize();
    }

    return hr;
}

/*****************************************************************************

CSwitchboard::PresenceInfoReply

receive presence info from other xpservers.

*****************************************************************************/
HRESULT CSwitchboard::PresenceInfoReply(
    DWORD dwContext,
    QWORD qwUserID,
    DWORD cdwUsers,
    P_PRESENCE_INFO_DATA_MSG* rgReply)
{
    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "PresenceInfoReply: SeqNum=%d User=%I64X",
        dwContext,
        qwUserID);

    HRESULT hr = S_OK;

    CPresenceInfoContext *pCCtx = g_pCPresenceInfoContextQueue->Find(qwUserID, dwContext);
    if (pCCtx == NULL)
    {
        hr = E_UNEXPECTED;
        goto lDone;
    }

    hr = pCCtx->ApplyPresenceData(cdwUsers, rgReply);

    if (pCCtx->m_cPendingServerReplies == 0)
    {
        g_pCPresenceInfoContextQueue->Remove(pCCtx);
    }

lDone:

    return hr;
}

/*****************************************************************************

CSwitchboard::Delete

Delete a buddy from the given user's buddy list

*****************************************************************************/
HRESULT CSwitchboard::Delete(
    SGADDR sgaddr,
    DWORD dwSeqNum,
    QWORD qwUserID,
    QWORD qwExBuddyID,
    QWORD *pqwNonce)
{
     XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Delete: User=%I64X  Ex Buddy=%I64X",
        qwUserID,
        qwExBuddyID );

    HRESULT hr = S_OK;
    CPresence *pCPresence = NULL;
    CDeleteBuddyContext *pCCtx = NULL;

    // See if there's currently a record for the given user
    hr = g_CPresenceUserIndex.FindPresence(qwUserID, &pCPresence);
    if( pCPresence == NULL )
    {
        goto lDone;
    }

    // Create a context object
    pCCtx = new CDeleteBuddyContext(this, &m_CProfileStore);
    if (pCCtx == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Populate the context object
    pCCtx->m_fProcessed = FALSE;
    pCCtx->m_qwUserID = qwUserID;
    pCCtx->m_qwBuddyID = qwExBuddyID;

    if (memcmp(&sgaddrIgnore, &sgaddr, sizeof(SGADDR)) != 0)
    {
        // Online case
        // Validate the message's sgaddr against the user's
        if (!CheckSGAddr(&sgaddr, pCPresence))
        {
            g_Counters.IncrementValue32(XPPERF_SERVER_BAD_USER_COUNTER, 1);
            g_Counters.IncrementValue32(XPPERF_SERVER_BAD_USER_RATE, 1);

            hr = XONLINE_E_SERVER_ERROR;
            goto lDone;
        }

        XOMASSERT(pqwNonce != NULL);
        *pqwNonce = pCPresence->GetNonce();
    }

    pCCtx->m_pCPresence = pCPresence;
    pCPresence->AddRef();

    // Send it over to the SQL thread pool
    hr = m_CProfileStore.SendToSqlThread( pCCtx );
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Call will post a completion when it resolves

lDone:

    if (FAILED(hr))
    {
        SAFE_RELEASE(pCCtx);
    }

    SAFE_RELEASE(pCPresence);
    return hr;
}

/*****************************************************************************

CSwitchboard::Accept

Accept a request to be someone's buddy

*****************************************************************************/
HRESULT CSwitchboard::Accept(
    SGADDR sgaddr,
    DWORD dwSeqNum,
    QWORD qwUserID,
    QWORD qwNewBuddyID,
    QWORD *pqwNonce)
{
     XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Accept: User=%I64X New Buddy=%I64X",
        qwUserID,
        qwNewBuddyID );

    HRESULT hr = S_OK;
    CPresence *pCPresence = NULL;
    CAcceptBuddyContext *pCCtx = NULL;

    // See if there's currently a record for the given user
    hr = g_CPresenceUserIndex.FindPresence(qwUserID, &pCPresence);
    if( pCPresence == NULL )
    {
        goto lDone;
    }

    // Create a context object
    pCCtx = new CAcceptBuddyContext(this, &m_CProfileStore);
    if (pCCtx == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Populate the context object
    pCCtx->m_fProcessed = FALSE;
    pCCtx->m_qwUserID = qwUserID;
    pCCtx->m_qwBuddyID = qwNewBuddyID;


    if (memcmp(&sgaddrIgnore, &sgaddr, sizeof(SGADDR)) != 0)
    {
        // Online case
        // Validate the message's sgaddr against the user's
        if (!CheckSGAddr(&sgaddr, pCPresence))
        {
            g_Counters.IncrementValue32(XPPERF_SERVER_BAD_USER_COUNTER, 1);
            g_Counters.IncrementValue32(XPPERF_SERVER_BAD_USER_RATE, 1);

            hr = XONLINE_E_SERVER_ERROR;
            goto lDone;
        }

        XOMASSERT(pqwNonce != NULL);
        *pqwNonce = pCPresence->GetNonce();
    }

    pCCtx->m_pCPresence = pCPresence;
    pCPresence->AddRef();

    // Send it over to the SQL thread pool
    hr = m_CProfileStore.SendToSqlThread( pCCtx );
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Call will post a completion when it resolves

lDone:

    if (FAILED(hr))
    {
        SAFE_RELEASE(pCCtx);
    }

    SAFE_RELEASE(pCPresence);

    return hr;
}

/*****************************************************************************

CSwitchboard::Reject

Reject a request to be someone's buddy

*****************************************************************************/
HRESULT CSwitchboard::Reject(
    SGADDR sgaddr,
    DWORD dwSeqNum,
    QWORD qwUserID,
    QWORD qwNonBuddyID,
    BOOL fNever,
    QWORD *pqwNonce)
{
      XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Reject: User=%I64X Non Buddy=%I64X",
        qwUserID,
        qwNonBuddyID );

    HRESULT hr = S_OK;
    CPresence *pCPresence = NULL;
    CRejectBuddyContext *pCCtx = NULL;

    // See if there's currently a record for the given user
    hr = g_CPresenceUserIndex.FindPresence(qwUserID, &pCPresence);
    if( pCPresence == NULL )
    {
        goto lDone;
    }

    // Create a context object
    pCCtx = new CRejectBuddyContext(this, &m_CProfileStore);
    if (pCCtx == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Populate the context object
    pCCtx->m_fProcessed = FALSE;
    pCCtx->m_qwUserID = qwUserID;
    pCCtx->m_qwBuddyID = qwNonBuddyID;
    pCCtx->m_fNever = fNever;

    if (memcmp(&sgaddrIgnore, &sgaddr, sizeof(SGADDR)) != 0)
    {
        // Online case
        // Validate the message's sgaddr against the user's
        if (!CheckSGAddr(&sgaddr, pCPresence))
        {
            g_Counters.IncrementValue32(XPPERF_SERVER_BAD_USER_COUNTER, 1);
            g_Counters.IncrementValue32(XPPERF_SERVER_BAD_USER_RATE, 1);

            hr = XONLINE_E_SERVER_ERROR;
            goto lDone;
        }

        XOMASSERT(pqwNonce != NULL);
        *pqwNonce = pCPresence->GetNonce();
    }

    pCCtx->m_pCPresence = pCPresence;
    pCPresence->AddRef();

    // Send it over to the SQL thread pool
    hr = m_CProfileStore.SendToSqlThread( pCCtx );
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Call will post a completion when it resolves

lDone:

    if (FAILED(hr))
    {
        SAFE_RELEASE(pCCtx);
    }

    SAFE_RELEASE(pCPresence);

    return hr;
}

/*****************************************************************************

CSwitchboard::Block

Add a user to my blocklist

*****************************************************************************/
HRESULT CSwitchboard::Block(
    SGADDR sgaddr,
    DWORD dwSeqNum,
    QWORD qwUserID,
    QWORD qwBlockID,
    QWORD *pqwNonce)
{
     XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Block: User=%I64X  Block=%I64X",
        qwUserID,
        qwBlockID);

    HRESULT hr;
    CPresence *pCPresence;
    CBlockContext *pCCtx = NULL;

    // See if there's currently a record for the given user
    hr = g_CPresenceUserIndex.FindPresence(qwUserID, &pCPresence);
    if( pCPresence == NULL )
    {
        goto lDone;
    }

    // Create a context object
    pCCtx = new CBlockContext(this, &m_CProfileStore);
    if (pCCtx == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Populate the context object
    pCCtx->m_fProcessed = FALSE;
    pCCtx->m_qwUserID = qwUserID;
    pCCtx->m_qwBlockID = qwBlockID;

    // Validate the message's sgaddr against the user's
    if (!CheckSGAddr(&sgaddr, pCPresence))
    {
        if (pCPresence->IsOnline())
        {
            // this is only an error if the expected sg is nonzero.  otherwise it may be that the user just logged off.
            g_Counters.IncrementValue32(XPPERF_SERVER_BAD_USER_COUNTER, 1);
            g_Counters.IncrementValue32(XPPERF_SERVER_BAD_USER_RATE, 1);
            hr = XONLINE_E_SERVER_ERROR;
        }
        goto lDone;
    }

    XOMASSERT(pqwNonce != NULL);
    *pqwNonce = pCPresence->GetNonce();

    pCCtx->m_pCPresence = pCPresence;
    pCPresence->AddRef();

    XOMASSERT(qwBlockID != 0); // CliConn already checked for this

    // Send it over to the SQL thread pool
    hr = m_CProfileStore.SendToSqlThread( pCCtx );
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Call will post a completion when it resolves

lDone:

    if (FAILED(hr))
    {
        SAFE_RELEASE(pCCtx);
    }

    SAFE_RELEASE(pCPresence);

    return hr;
}

/*****************************************************************************

CSwitchboard::Unblock

Remove the a user from the given user's blocklist

*****************************************************************************/
HRESULT CSwitchboard::Unblock(
    SGADDR sgaddr,
    DWORD dwSeqNum,
    QWORD qwUserID,
    QWORD qwBlockID,
    QWORD *pqwNonce)
{
     XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Unblock: User=%I64X  Block=%I64X",
        qwUserID,
        qwBlockID);

    HRESULT hr;
    CPresence *pCPresence;

    CClearAllBlocksContext *pClearAllCtx = NULL;
    CUnblockContext *pUnblockCtx = NULL;

    // See if there's currently a record for the given user
    hr = g_CPresenceUserIndex.FindPresence(qwUserID, &pCPresence);
    if( pCPresence == NULL )
    {
        goto lDone;
    }

    // Validate the message's sgaddr against the user's
    if (!CheckSGAddr(&sgaddr, pCPresence))
    {
        if (pCPresence->IsOnline())
        {
            // this is only an error if the expected sg is nonzero.  otherwise it may be that the user just logged off.
            g_Counters.IncrementValue32(XPPERF_SERVER_BAD_USER_COUNTER, 1);
            g_Counters.IncrementValue32(XPPERF_SERVER_BAD_USER_RATE, 1);
            hr = XONLINE_E_SERVER_ERROR;
        }
        goto lDone;
    }

    XOMASSERT(pqwNonce != NULL);
    *pqwNonce = pCPresence->GetNonce();

    if (qwBlockID != 0)
    {
        // Remove a block
        // Create a context object
        pUnblockCtx = new CUnblockContext(this, &m_CProfileStore);
        if (pUnblockCtx == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto lDone;
        }

        // Populate the context object
        pUnblockCtx->m_fProcessed = FALSE;
        pUnblockCtx->m_qwUserID = qwUserID;
        pUnblockCtx->m_qwBlockID = qwBlockID;
        pUnblockCtx->m_pCPresence = pCPresence;
        pCPresence->AddRef();

        // Send it over to the SQL thread pool
        hr = m_CProfileStore.SendToSqlThread( pUnblockCtx );
        if (FAILED(hr))
        {
            goto lDone;
        }
    }
    else
    {
        // Clear all blocks
        pClearAllCtx = new CClearAllBlocksContext(this, &m_CProfileStore);
        if (pClearAllCtx == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto lDone;
        }

        // Populate the context object
        pClearAllCtx->m_fProcessed = FALSE;
        pClearAllCtx->m_qwUserID = qwUserID;
        pClearAllCtx->m_pCPresence = pCPresence;
        pCPresence->AddRef();

        // Send it over to the SQL thread pool
        hr = m_CProfileStore.SendToSqlThread( pClearAllCtx );
        if (FAILED(hr))
        {
            goto lDone;
        }
    }

    // Call will post a completion when it resolves

lDone:

    if (FAILED(hr))
    {
        SAFE_RELEASE(pUnblockCtx);
        SAFE_RELEASE(pClearAllCtx);
    }

    SAFE_RELEASE(pCPresence);

    return hr;
}

/*****************************************************************************

CSwitchboard::Invite

Invite user(s) to a game session

*****************************************************************************/
HRESULT CSwitchboard::Invite(
    SGADDR sgaddr,
    QWORD qwUserID,
    DWORD dwTitleID,
    QWORD qwMatchSessionID,
    WORD cInviteeIDs,
    const QWORD *rgqwInviteeIDs,
    DWORD dwMessageFlags,
    QWORD qwSenderContext,
    WORD cbDetails,
    const BYTE* pbDetails,
    QWORD *pqwNonce)
{
    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Invite: User=%I64X TitleId=0x%08X MatchSession=%I64X Flags=0x%08X NumInvitees=%d Inv0=%I64X",
        qwUserID,
        dwTitleID,
        qwMatchSessionID,
        dwMessageFlags,
        cInviteeIDs,
        cInviteeIDs ? *rgqwInviteeIDs : 0);

    HRESULT hr = S_OK;
    CPresence *pCPresence = NULL;
    DWORD dwIndex = 0;
    WORD cRecipients = 0;
    QWORD rgqwRecipients[ XONLINE_MAX_MESSAGE_RECIPIENTS ];
    Q_SEND_MESSAGE_ADDENDUM rgAddendum[ XONLINE_MAX_MESSAGE_RECIPIENTS ];
    Q_SEND_MESSAGE_MSG sendmsg;

    // See if there's currently a record for the given user
    hr = g_CPresenceUserIndex.FindPresence( qwUserID, &pCPresence );
    if( pCPresence == NULL )
    {
        goto lDone;
    }

    // Validate the message's sgaddr against the user's
    if (!CheckSGAddr(&sgaddr, pCPresence))
    {
        if (pCPresence->IsOnline())
        {
            // this is only an error if the expected sg is nonzero.  otherwise it may be that the user just logged off.
            g_Counters.IncrementValue32(XPPERF_SERVER_BAD_USER_COUNTER, 1);
            g_Counters.IncrementValue32(XPPERF_SERVER_BAD_USER_RATE, 1);
            hr = XONLINE_E_SERVER_ERROR;
        }
        goto lDone;
    }

    XOMASSERT(pqwNonce != NULL);
    *pqwNonce = pCPresence->GetNonce();

    // Is it a new invitation?
    if ((pCPresence->GetInvite() == NULL) ||
        (pCPresence->GetInvite()->dwTitleID != dwTitleID) ||
        (pCPresence->GetInvite()->qwMatchSessionID != qwMatchSessionID))
    {
        // Clear any previous invitation
        ClearInvitation(pCPresence);

        // New invitation, add the invite to our presence record
        hr = pCPresence->CreateInvite(
            dwTitleID,
            qwMatchSessionID,
            cInviteeIDs,
            rgqwInviteeIDs);
        if (FAILED(hr))
        {
            goto lDone;
        }

        // We will send a message to all invited users in this case
        cRecipients = cInviteeIDs;
        memcpy( rgqwRecipients, rgqwInviteeIDs, sizeof( *rgqwRecipients ) * cInviteeIDs );
    }
    else
    {
        // Old invitation, add the new invitees
        // CONSIDER: bulk add
        for (dwIndex = 0; dwIndex < cInviteeIDs; dwIndex++)
        {
            // If AddInvitee fails or returns S_FALSE, don't send a message
            if( S_OK == pCPresence->AddInvitee(rgqwInviteeIDs[dwIndex]) )
            {
                rgqwRecipients[ cRecipients ] = rgqwInviteeIDs[dwIndex];
                cRecipients++;
            }
        }
    }

    // Prepare the message addendum now that we know who we need to send to
    for (dwIndex = 0; dwIndex < cRecipients; dwIndex++)
    {
        CBuddyListEntry *pCBuddy = pCPresence->FindBuddy(rgqwRecipients[dwIndex]);

        // TODO: get rid of the addendum.  it is obsolete.
        if (pCBuddy && (pCBuddy->GetStatus()== P_BUDDY_STATUS_OK))
        {
            rgAddendum[dwIndex].fFriend = TRUE;
            rgAddendum[dwIndex].qwWebID = 0;
        }
        else
        {
            rgAddendum[dwIndex].fFriend = FALSE;
            rgAddendum[dwIndex].qwWebID = 0;
        }
    }

    if( 0 != cRecipients )
    {
        sendmsg.qwSenderID = qwUserID;
        sendmsg.qwSenderContext = qwSenderContext;
        sendmsg.dwMessageFlags = dwMessageFlags;
        sendmsg.dwSenderTitleID = dwTitleID;
        sendmsg.wExpireMinutes = (WORD) g_CPresCfg.GetMessageTypeExpiration(XONLINE_MSG_TYPE_GAME_INVITE-1);
        sendmsg.cbDetails = cbDetails;
        sendmsg.cRecipients = cRecipients;
        sendmsg.bMessageType = XONLINE_MSG_TYPE_GAME_INVITE;
        strncpy( sendmsg.szSenderName, pCPresence->GetAcctName(), sizeof( sendmsg.szSenderName ) );

        // Send the notifications
        hr = SendMessageExternal(
            TRUE,
            &sendmsg,
            rgqwRecipients,
            pbDetails,
            rgAddendum,
            NULL,
            0);
        if (FAILED(hr))
        {
            goto lDone;
        }
    }

lDone:

    SAFE_RELEASE(pCPresence);

    return hr;
}


/*****************************************************************************

CSwitchboard::SendEmptyReply

Send an empty Reply message

*****************************************************************************/
HRESULT CSwitchboard::SendEmptyReply(
    DWORD dwMsgType,
    DWORD cbReply,
    DWORD dwSeqNum,
    HRESULT hrReply,
    CClientConnection *pCReplyConn)
{
    HRESULT hr = S_OK;
    CTCPCntVarBuffer *pCReplyBuffer = NULL;
    Q_ENUM_MESSAGES_REPLY_MSG *pmsgReply = NULL;

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "CSwitchboard::SendEmptyReply for Seq %d, Type=%d, hr=0x%08X",
        dwSeqNum,
        dwMsgType,
        hrReply );

    // Send a SYNC response
    pCReplyBuffer = g_pBufferPool->GetBuffer(cbReply);
    if (pCReplyBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pmsgReply = (Q_ENUM_MESSAGES_REPLY_MSG *) pCReplyBuffer->GetBuffer();

    pmsgReply->dwMsgType = dwMsgType;
    pmsgReply->dwMsgLen = pCReplyBuffer->GetBufferLength() - sizeof(BASE_MSG_HEADER);
    pmsgReply->dwSeqNum = dwSeqNum;
    pmsgReply->hr = hrReply;

    memset( &pmsgReply->cMessages, 0, cbReply - sizeof(BASE_MSG_HEADER) - sizeof(HRESULT) );

    pCReplyConn->Send(pCReplyBuffer);

lDone:

    SAFE_RELEASE(pCReplyBuffer);

    return hr;
}

/*****************************************************************************

CSwitchboard::Cancel

Cancel an invite

*****************************************************************************/
HRESULT CSwitchboard::Cancel(
    SGADDR sgaddr,
    QWORD qwUserID,
    QWORD qwMatchSessionID,
    DWORD cInviteeIDs,
    const QWORD *rgqwInviteeIDs,
    QWORD *pqwNonce)
{
     XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Cancel: User=%I64X MatchSession=%I64X",
        qwUserID,
        qwMatchSessionID);

    HRESULT hr = S_OK;
    CPresence *pCPresence = NULL;
    DWORD dwIndex = 0;

    // See if there's currently a record for the given user
    hr = g_CPresenceUserIndex.FindPresence(qwUserID, &pCPresence);
    if( pCPresence == NULL )
    {
        goto lDone;
    }

    // Validate the message's sgaddr against the user's
    if (!CheckSGAddr(&sgaddr, pCPresence))
    {
        if (pCPresence->IsOnline())
        {
            // this is only an error if the expected sg is nonzero.  otherwise it may be that the user just logged off.
            g_Counters.IncrementValue32(XPPERF_SERVER_BAD_USER_COUNTER, 1);
            g_Counters.IncrementValue32(XPPERF_SERVER_BAD_USER_RATE, 1);
            hr = XONLINE_E_SERVER_ERROR;
        }
        goto lDone;
    }

    XOMASSERT(pqwNonce != NULL);
    *pqwNonce = pCPresence->GetNonce();

    if ((pCPresence->GetInvite() != NULL) &&
        (qwMatchSessionID == pCPresence->GetInvite()->qwMatchSessionID))
    {
        if (cInviteeIDs == 0)
        {
            // Clear the entire invitation
            hr = ClearInvitation(pCPresence);
            if (FAILED(hr))
            {
                hr = S_OK;
            }
        }
        else
        {
            Q_RECIPIENT_RESULT rgRecipients[ XONLINE_MAX_MESSAGE_RECIPIENTS ];

            // Clear the given invitees
            for (dwIndex = 0; dwIndex < cInviteeIDs; dwIndex++)
            {
                pCPresence->RemoveInvitee(rgqwInviteeIDs[dwIndex]);

                rgRecipients[ dwIndex ].qwUserID = rgqwInviteeIDs[ dwIndex ];
                rgRecipients[ dwIndex ].dwMessageID = 0;
            }

            // Clear unread invitations from notification queues
            hr = QueueRevokeMessage(
                qwUserID,                                   // SenderID
                0,                                          // SenderContext
                ( XMSG_REVOKE_MESSAGE_EX_FLAG_USE_PROP |
                  XMSG_REVOKE_MESSAGE_EX_FLAG_USE_TYPE |
                  XMSG_REVOKE_MESSAGE_EX_FLAG_USE_SENDER ), // dwFlags
                XONLINE_MSG_PROP_SESSION_ID,                // wPropTag
                sizeof( qwMatchSessionID ),                 // cbProp
                (const BYTE*) &qwMatchSessionID,            // pbProp
                XONLINE_MSG_TYPE_GAME_INVITE,               // bMessageType
                (WORD) cInviteeIDs,                         // cRecipients
                rgRecipients );                             // rgRecipients
        }
    }

lDone:

    SAFE_RELEASE(pCPresence);

    return hr;

}

/*****************************************************************************

CSwitchboard::InviteAnswer

Answer an invite

*****************************************************************************/
HRESULT CSwitchboard::InviteAnswer(
    SGADDR sgaddr,
    QWORD qwUserID,
    QWORD qwHostID,
    QWORD qwMatchSessionID,
    WORD wAnswer,
    QWORD *pqwNonce)
{
     XomTrace(
        PresenceDebug,
        L_NORMAL,
        "InviteAnswer: User=%I64X Host=%I64X MatchSession=%I64X Answer=%d",
        qwUserID,
        qwHostID,
        qwMatchSessionID,
        wAnswer);

    HRESULT hr = S_OK;
    CPresence *pCPresence = NULL;
    FILETIME ftSent;

    // See if there's currently a record for the given user
    hr = g_CPresenceUserIndex.FindPresence(qwUserID, &pCPresence);
    if( pCPresence == NULL )
    {
        goto lDone;
    }

    // Validate the message's sgaddr against the user's
    if (!CheckSGAddr(&sgaddr, pCPresence))
    {
        if (pCPresence->IsOnline())
        {
            // this is only an error if the expected sg is nonzero.  otherwise it may be that the user just logged off.
            g_Counters.IncrementValue32(XPPERF_SERVER_BAD_USER_COUNTER, 1);
            g_Counters.IncrementValue32(XPPERF_SERVER_BAD_USER_RATE, 1);
            hr = XONLINE_E_SERVER_ERROR;
        }
        goto lDone;
    }

    XOMASSERT(pqwNonce != NULL);
    *pqwNonce = pCPresence->GetNonce();

    // If we accepted, clear our outgoing invitations
    if (wAnswer == PINVITE_REPLY_YES)
    {
        hr = ClearInvitation(pCPresence);
        if (FAILED(hr))
        {
            hr = S_OK;
        }
    }

    // Get the time
    GetSystemTimeAsFileTime(&ftSent);

    // Send our peer notice of our answer
    hr = m_CXPCluster.SendMsgInviteAnswer(
        qwUserID,
        qwHostID,
        qwMatchSessionID,
        wAnswer);
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Send the host a notification of our answer
    hr = m_CXPCluster.QueueInviteAnswer(
        qwUserID,
        qwHostID,
        qwMatchSessionID,
        ftSent,
        wAnswer == PINVITE_REPLY_NEVER ? (WORD)PINVITE_REPLY_NO : wAnswer); // To stay compatible with V1 clients, we don't send the NEVER answer over to Notification
    if (FAILED(hr))
    {
        goto lDone;
    }

    Q_RECIPIENT_RESULT recip;
    recip.qwUserID = qwUserID;
    recip.dwMessageID = 0;

    DWORD dwBlockFlag = 0;
    if( PINVITE_REPLY_NEVER == wAnswer )
    {
        dwBlockFlag = XMSG_REVOKE_MESSAGE_EX_FLAG_BLOCK_SENDER;
    }

    hr = QueueRevokeMessage(
        qwHostID,                                   // SenderID
        0,                                          // SenderContext
        ( XMSG_REVOKE_MESSAGE_EX_FLAG_USE_PROP |
          XMSG_REVOKE_MESSAGE_EX_FLAG_USE_TYPE |
          XMSG_REVOKE_MESSAGE_EX_FLAG_USE_SENDER |
          dwBlockFlag ),                            // dwFlags
        XONLINE_MSG_PROP_SESSION_ID,                // wPropTag
        sizeof( qwMatchSessionID ),                 // cbProp
        (const BYTE*) &qwMatchSessionID,            // pbProp
        XONLINE_MSG_TYPE_GAME_INVITE,               // bMessageType
        1,                                          // cRecipients
        &recip );                                   // rgRecipients

lDone:

    // LineType|MachinePUID|TitleID|UserPUID|HostPUID|SessionID|wAnswer|HR
    XomLog( PresenceLog, "INVANSWER|%I64X|%X|%I64X|%I64X|%I64X|%d|%X",
        sgaddr.qwXboxID,
        (pCPresence == NULL) ? 0 : pCPresence->GetTitleID(),
        qwUserID,
        qwHostID,
        qwMatchSessionID,
        wAnswer,
        hr );
    XomLog( Reporting_v2, "INVANSWER|%I64X|%X|%I64X|%I64X|%I64X|%d|%X",
        sgaddr.qwXboxID,
        (pCPresence == NULL) ? 0 : pCPresence->GetTitleID(),
        qwUserID,
        qwHostID,
        qwMatchSessionID,
        wAnswer,
        hr );

    SAFE_RELEASE(pCPresence);

    return hr;

}

/*****************************************************************************

CSwitchboard::Nickname

Set the given user's nickname

*****************************************************************************/
HRESULT CSwitchboard::Nickname(
    SGADDR sgaddr,
    QWORD qwUserID,
    DWORD cbNickname,
    const BYTE *pbNickname,
    QWORD *pqwNonce)
{
     XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Nickname: User=%I64X NicknameLen=%d",
        qwUserID,
        cbNickname);

    HRESULT hr = S_OK;
    CPresence *pCPresence = NULL;

    // See if there's currently a record for the given user
    hr = g_CPresenceUserIndex.FindPresence(qwUserID, &pCPresence );
    if( pCPresence == NULL )
    {
        goto lDone;
    }

    // Validate the message's sgaddr against the user's
    if (!CheckSGAddr(&sgaddr, pCPresence))
    {
        if (pCPresence->IsOnline())
        {
            // this is only an error if the expected sg is nonzero.  otherwise it may be that the user just logged off.
            g_Counters.IncrementValue32(XPPERF_SERVER_BAD_USER_COUNTER, 1);
            g_Counters.IncrementValue32(XPPERF_SERVER_BAD_USER_RATE, 1);
            hr = XONLINE_E_SERVER_ERROR;
        }
        goto lDone;
    }

    XOMASSERT(pqwNonce != NULL);
    *pqwNonce = pCPresence->GetNonce();

    // Has the nickname changed?
    if ((pCPresence->GetNicknameLen() != cbNickname) ||
        (memcmp(pCPresence->GetNickname(), pbNickname, cbNickname) != 0))
    {
        // Update the state info for this user
        pCPresence->SetNickname(
            cbNickname,
            pbNickname);

        // Send notifications to subscribed buddies
        hr = NotifyPresenceAll(pCPresence, TRUE, FALSE, FALSE);
        if (FAILED(hr))
        {
            // Ignore failures, specific errors logged by the function
            XomTrace(PresenceDebug, L_NORMAL, "Failure to notify all buddies on state change hr=0x%X", hr);
            hr = S_OK;
        }
    }

lDone:

    SAFE_RELEASE(pCPresence);

    return hr;
}

/*****************************************************************************

CSwitchboard::GetFriendsList

Process a Web Friends message

*****************************************************************************/
HRESULT CSwitchboard::GetFriendsList(
    QWORD qwUserID,
    QWORD qwTargetID,
    CClientConnection *pCReplyConn,
    DWORD dwSeqNum,
    DWORD dwReplyType)
{
    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "GetFriendsList: User=%I64X Seq=%d",
        qwUserID,
        dwSeqNum);

    HRESULT hr = S_OK;
    CGetFriendsListContext *pCCtx = NULL;

    // Create a context object
    pCCtx = new CGetFriendsListContext(this);
    if (pCCtx == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pCCtx->m_qwUserID = qwUserID;
    pCCtx->m_pCReplyConn = pCReplyConn;
    pCReplyConn->AddRef();
    pCCtx->m_dwSeqNum = dwSeqNum;
    pCCtx->m_dwReplyType = dwReplyType;

    // See if there's currently a record for the given user
    hr = g_CPresenceUserIndex.FindPresence(qwTargetID, &(pCCtx->m_pCPresence) );
    if (FAILED(hr))
    {
        goto lDone;
    }

    if (!(pCCtx->m_pCPresence->CanShareFriendsList(qwUserID)))
    {
        hr = XONLINE_E_MESSAGE_INSUFFICIENT_PRIVILEGES;
        goto lDone;
    }

    if (pCCtx->m_pCPresence->GetNumBuddies() == 0)
    {
        hr = SendGetFriendsListReply(
            qwUserID,
            dwSeqNum,
            dwReplyType,
            S_OK,
            pCCtx->m_pCPresence->GetBuddyListVersion(),
            0,
            NULL,
            pCReplyConn);

        goto lDone;
    }

    hr = pCCtx->BuildResultsList();
    if (FAILED(hr))
    {
        goto lDone;
    }

    // AddRef() before calling SendGetPresenceInfo().  if the send fails, it will automatically call ApplyPresenceData() with empty results.
    // addref to  counter the release below.
    pCCtx->AddRef();

    hr = SendGetPresenceInfo(pCCtx);

lDone:

    if (FAILED(hr))
    {
        if (hr != XONLINE_E_MESSAGE_INSUFFICIENT_PRIVILEGES)
        {
            XomNtEvent(
                XEVENT_PRESENCE_CODE_415,
                "CSwitchboard::GetFriendsList failed user=%I64X hr=0x%X",
                qwUserID,
                hr);
        }

        // NOTE: cliconn will send a response

    }

    SAFE_RELEASE(pCCtx);

    return hr;
}

HRESULT CSwitchboard::WebAlive(
    QWORD qwUserID,
    CClientConnection *pCReplyConn,
    DWORD dwSeqNum)
{
    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "WebAlive: User=%I64X Seq=%d",
        qwUserID,
        dwSeqNum);

    HRESULT hr = S_OK;
    CPresence *pCPresence = NULL;
    CWebAliveContext *pCCtx = NULL;

    // Check to make sure there aren't too many users on the system
    if ((g_Counters.GetCurrentValue32(XPPERF_SERVER_ACTIVE_USERS_COUNTER) >=
        g_CPresCfg.GetMaxPresenceUsers()) ||
        g_bSimulateTooBusy ||
        g_bSwitchboardTooBusy)
    {
        // CONSIDER: should this be an NT event instead?
        XomTrace(
            PresenceDebug,
            L_NORMAL,
            "Throttle: Active Users: %d >= Max Users: %d",
            g_Counters.GetCurrentValue32(XPPERF_SERVER_ACTIVE_USERS_COUNTER),
            g_CPresCfg.GetMaxPresenceUsers());

        hr = XONLINE_E_NOTIFICATION_SERVER_BUSY;
        goto lDone;
    }

    // Create a context object
    pCCtx = new CWebAliveContext(this);
    if (pCCtx == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pCCtx->m_qwUserID = qwUserID;
    pCCtx->m_pCReplyConn = pCReplyConn;
    pCReplyConn->AddRef();
    pCCtx->m_dwSeqNum = dwSeqNum;

    // See if there's currently a record for the given user
    hr = g_CPresenceUserIndex.FindPresence(qwUserID, &pCPresence );
    if (FAILED(hr) && (hr != HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER)))
    {
        goto lDone;
    }

    if (pCPresence == NULL)
    {
        // need to load this record.
        CLoadOfflinePresenceContext *pLoadCtx = new CLoadOfflinePresenceContext(this, &m_CProfileStore);
        if (pLoadCtx == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto lDone;
        }

        pCCtx->dwPendingLoads++;
        pLoadCtx->m_pvParentData = NULL;
        pLoadCtx->m_pCaller = pCCtx;
        pLoadCtx->m_qwUserID = qwUserID;

        hr = m_CProfileStore.SendToSqlThread(pLoadCtx);
        if (FAILED(hr))
        {
            goto lDone;
        }
    }
    else
    {
        pCCtx->ProcessUser(pCPresence, NULL);
        pCCtx->Finalize();
    }

    if (FAILED(hr))
    {
        goto lDone;
    }

lDone:

    if (FAILED(hr))
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_492,
            "CSwitchboard::WebAlive failed user=%I64X hr=0x%X",
            qwUserID,
            hr);

        // NOTE: cliconn will send a response

        SAFE_RELEASE(pCCtx);
    }

    SAFE_RELEASE(pCPresence);

    return hr;
}

/*****************************************************************************

CSwitchboard::WebAliveComplete

Callback after a WebUserInfo has completed for a web alive

*****************************************************************************/
void CSwitchboard::GetFriendsListComplete(CGetFriendsListContext *pCCtx)
{
    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "GetFriendsListComplete: User=%I64X Seq=%d",
        pCCtx->m_qwUserID,
        pCCtx->m_dwSeqNum);

    HRESULT hr = S_OK;

    // Check the operation for failure
    hr = pCCtx->m_hr;
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Do we have a record for this user?
    if( NULL == pCCtx->m_pCPresence)
    {
        hr = HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
        goto lDone;
    }


lDone:

    if (FAILED(hr))
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_416,
            "CSwitchboard::GetFriendsListComplete failed user=%I64X hr=0x%X",
            pCCtx->m_qwUserID,
            hr);

        hr = SendGetFriendsListReply(
            pCCtx->m_qwUserID,
            pCCtx->m_dwSeqNum,
            pCCtx->m_dwReplyType,
            pCCtx->m_hr,
            0,
            0,
            NULL,
            pCCtx->m_pCReplyConn);
    }
    else
    {
        hr = SendGetFriendsListReply(
            pCCtx->m_qwUserID,
            pCCtx->m_dwSeqNum,
            pCCtx->m_dwReplyType,
            pCCtx->m_hr,
            pCCtx->m_pCPresence->GetBuddyListVersion(),
            pCCtx->m_cdwResults,
            (P_GET_FRIENDS_LIST_REPLY_DATA *)pCCtx->m_rgbResults,
            pCCtx->m_pCReplyConn);
    }

    SAFE_RELEASE(pCCtx);
}

/*****************************************************************************

CSwitchboard::State

This supplies the latest state info for a user

*****************************************************************************/
HRESULT CSwitchboard::State(
    SGADDR sgaddr,
    QWORD qwUserID,
    DWORD dwState,
    QWORD qwMatchSessionID,
    DWORD dwTitleID,
    WORD cbTitleStuff,
    const BYTE *rgbTitleStuff,
    WORD cbRichPresence,
    const P_RICH_PRESENCE *pRichPresence,
    WORD cbMemcacheData,
    BYTE *pMemCacheData,
    QWORD *pqwNonce)
{
     XomTrace(
        PresenceDebug,
        L_NORMAL,
        "State: User=%I64X State=0x%X Match Session=%I64X TitleId=0x%08X TitleStuffLen=%d cbRichPresence=%d",
        qwUserID,
        dwState,
        qwMatchSessionID,
        dwTitleID,
        cbTitleStuff,
        cbRichPresence );

    HRESULT hr = S_OK;
    CPresence *pCPresence = NULL;

    // See if there's currently a record for the given user
    hr = g_CPresenceUserIndex.FindPresence(qwUserID, &pCPresence );
    if( pCPresence == NULL )
    {
        goto lDone;
    }

    // Validate the message's sgaddr against the user's
    if (!CheckSGAddr(&sgaddr, pCPresence))
    {
        if (pCPresence->IsOnline())
        {
            // this is only an error if the expected sg is nonzero.  otherwise it may be that the user just logged off.
            g_Counters.IncrementValue32(XPPERF_SERVER_BAD_USER_COUNTER, 1);
            g_Counters.IncrementValue32(XPPERF_SERVER_BAD_USER_RATE, 1);
            hr = XONLINE_E_SERVER_ERROR;
        }
        goto lDone;
    }

    XOMASSERT(pqwNonce != NULL);
    *pqwNonce = pCPresence->GetNonce();

    // Do we need to recall any invitations?
    if ((qwMatchSessionID != pCPresence->GetMatchSessionID()) &&
        (pCPresence->GetInvite() != NULL) &&
        (pCPresence->GetInvite()->qwMatchSessionID == pCPresence->GetMatchSessionID()))
    {
        // Clear outstanding invitations
        hr = ClearInvitation(pCPresence);
        if (FAILED(hr))
        {
            hr = S_OK;
        }
    }

    if (dwTitleID == 0)
    {
        // unchanged title id.  (comes from old state1 message)
        dwTitleID = pCPresence->GetTitleID();
    }

    if (g_CPresCfg.GetEnableRichPresence() == FALSE)
    {
        // rich presence is disabled.
        cbRichPresence = 0;
        pRichPresence = NULL;
        cbMemcacheData = 0;
        pMemCacheData = NULL;
    }

    // notification filtering.  let's figure out what's changed.
    DWORD dwStateChange = pCPresence->GetState() ^ dwState;

    // using some extra bits here for easy filtering.  these bits are normally reserved for the client.  they have no meaning to the server and thus are never sent up.
    dwStateChange &= ~P_STATE_MASK_CLIENTFLAGS;
    dwStateChange |= (dwTitleID == pCPresence->GetTitleID()) ? 0 : P_STATE_MASK_TITLEID_CHANGED;
    dwStateChange |= (qwMatchSessionID == pCPresence->GetMatchSessionID()) ? 0 : P_STATE_MASK_SESSIONID_CHANGED;
    dwStateChange |= CompareBinaryData(cbTitleStuff, rgbTitleStuff, pCPresence->GetTitleStuffLen(), pCPresence->GetTitleStuff()) ? 0 : P_STATE_MASK_TITLEDATA_CHANGED;
    dwStateChange |= CompareBinaryData(cbRichPresence, (BYTE *)pRichPresence, pCPresence->GetRichPresenceLen(), pCPresence->GetRichPresenceData()) ? 0 : P_STATE_MASK_RICHPRES_CHANGED;

    // perf counter stuff
    if (dwStateChange & P_STATE_MASK_ONLINE) g_Counters.IncrementValue32(XPPERF_SERVER_STATECHANGE_ONLINE_RATE, 1);
    if (dwStateChange & P_STATE_MASK_PLAYING) g_Counters.IncrementValue32(XPPERF_SERVER_STATECHANGE_PLAYING_RATE, 1);
    if (dwStateChange & P_STATE_MASK_CLOAKED) g_Counters.IncrementValue32(XPPERF_SERVER_STATECHANGE_CLOAKED_RATE, 1);
    if (dwStateChange & P_STATE_MASK_VOICE) g_Counters.IncrementValue32(XPPERF_SERVER_STATECHANGE_VOICE_RATE, 1);
    if (dwStateChange & (P_STATE_MASK_JOINABLE | P_STATE_MASK_JOINABLE_FRIENDS_ONLY)) g_Counters.IncrementValue32(XPPERF_SERVER_STATECHANGE_JOINABLE_RATE, 1);
    if (dwStateChange & (P_STATE_MASK_PARTY_JOINABLE | P_STATE_MASK_PARTY_JOINABLE_FRIENDS_ONLY)) g_Counters.IncrementValue32(XPPERF_SERVER_STATECHANGE_PARTY_JOINABLE_RATE, 1);
    if (dwStateChange & P_STATE_MASK_PARTY_PLAYING) g_Counters.IncrementValue32(XPPERF_SERVER_STATECHANGE_PARTY_PLAYING_RATE, 1);
    if (dwStateChange & P_STATE_MASK_PARTY_COUNTER) g_Counters.IncrementValue32(XPPERF_SERVER_STATECHANGE_PARTY_COUNTER_RATE, 1);
    if (dwStateChange & P_STATE_MASK_USER_STATE) g_Counters.IncrementValue32(XPPERF_SERVER_STATECHANGE_USERSTATE_RATE, 1);
    if (dwStateChange & P_STATE_MASK_TITLEID_CHANGED) g_Counters.IncrementValue32(XPPERF_SERVER_STATECHANGE_TITLEID_RATE, 1);
    if (dwStateChange & P_STATE_MASK_TITLEDATA_CHANGED) g_Counters.IncrementValue32(XPPERF_SERVER_STATECHANGE_TITLEDATA_RATE, 1);
    if (dwStateChange & P_STATE_MASK_SESSIONID_CHANGED) g_Counters.IncrementValue32(XPPERF_SERVER_STATECHANGE_SESSIONID_RATE, 1);
    if (dwStateChange & P_STATE_MASK_RICHPRES_CHANGED) g_Counters.IncrementValue32(XPPERF_SERVER_STATECHANGE_RICHPRES_RATE, 1);

    // Update the state info for this user
    DWORD dwOldState = pCPresence->SetState(
        dwState,
        dwTitleID,
        qwMatchSessionID,
        cbTitleStuff,
        rgbTitleStuff,
        cbRichPresence,
        pRichPresence,
        cbMemcacheData,
        pMemCacheData,
        dwStateChange);

    if (dwState & P_STATE_MASK_ONLINE)
    {
        if (!(dwState & P_STATE_MASK_CLOAKED))
        {
            // not cloaked.  Send notifications to subscribed buddies
            hr = NotifyPresenceAll(
                pCPresence,
                (dwStateChange & P_STATE_MASK_NOTIFY_XBOX) ? TRUE : FALSE,
                (dwStateChange & g_CPresCfg.GetStateBitsNotifyWhitelist()) ? TRUE : FALSE,
                (dwStateChange & P_STATE_MASK_NOTIFY_XENON_PEER) ? TRUE : FALSE);

            if (FAILED(hr))
            {
                // Ignore failures, specific errors logged by the function
                XomTrace(PresenceDebug, L_NORMAL, "Failure to notify all buddies on state change hr=0x%X", hr);
                hr = S_OK;
            }
        }
        else if (!(dwOldState & P_STATE_MASK_CLOAKED))
        {
            // just cloaked.  fake like we're going offline.
            hr = NotifyOfflineAll(pCPresence, TRUE);
            if (FAILED(hr))
            {
                // Ignore failures, specific errors logged by the function
                XomTrace(PresenceDebug, L_NORMAL, "Failure to notify all buddies on state change hr=0x%X", hr);
                hr = S_OK;
            }
        }
        // else do nothing.  we're still cloaked.
    }
    else
    {
        // If the user's state is offline, remove them
        hr = UnsubscribeFromAllBuddies(pCPresence);
        if (FAILED(hr))
        {
            // Ignore failures, specific errors logged by the function
            XomTrace(PresenceDebug, L_NORMAL, "Failure to unsubscribe from all buddies on offline state hr=0x%X", hr);
            hr = S_OK;
        }

        pCPresence->SelfDestruct();
    }

lDone:

    SAFE_RELEASE(pCPresence);

    return hr;
}

/*****************************************************************************

CSwitchboard::SendGetStateReply

This supplies the latest state info for a user

*****************************************************************************/
HRESULT CSwitchboard::GetState(
    DWORD dwSeqNum,
    QWORD qwUserID,
    HRESULT hrReply,
    CClientConnection *pCReplyConn,
    QWORD *pqwNonce)
{
    CPresence *pCPresence = NULL;

    HRESULT hr = S_OK;

    // See if there's currently a record for the given user
    hr = g_CPresenceUserIndex.FindPresence(qwUserID, &pCPresence );
    if( pCPresence != NULL )
    {
        XOMASSERT(pqwNonce != NULL);
        *pqwNonce = pCPresence->GetNonce();
    }

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "CSwitchboard::GetState for seq %d User=%I64X hrReply=0x%X hr=0x%X",
        dwSeqNum,
        qwUserID,
        hrReply,
        hr);

    hr = SendGetStateReply(
        dwSeqNum,
        qwUserID,
        hrReply,
        pCReplyConn,
        pCPresence);

    SAFE_RELEASE(pCPresence);

    return hr;
}

/*****************************************************************************

CSwitchboard::SendGetStateReply

This supplies the latest state info for a user

*****************************************************************************/
HRESULT CSwitchboard::SendGetStateReply(
    DWORD dwSeqNum,
    QWORD qwUserID,
    HRESULT hrReply,
    CClientConnection *pCReplyConn,
    CPresence *pCPresence)
{
    CTCPCntVarBuffer *pCReplyBuffer = NULL;
    P_GET_STATE_REPLY_MSG *pmsgReply = NULL;
    HRESULT hr = S_OK;
    DWORD cbReplySize = sizeof(P_GET_STATE_REPLY_MSG);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "CSwitchboard::SendGetStateReply for seq %d User=%I64X hrReply=0x%X",
        dwSeqNum,
        qwUserID,
        hrReply);

    // Send a response - calculate the size first
    if ( (SUCCEEDED(hrReply)) && (pCPresence != NULL) && (pCPresence->GetRichPresenceLen() > 0) )
    {
        cbReplySize = sizeof(P_GET_STATE_REPLY_MSG) + pCPresence->GetRichPresenceLen() - sizeof(P_RICH_PRESENCE);
    }

    pCReplyBuffer = g_pBufferPool->GetBuffer(cbReplySize);

    if (pCReplyBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pmsgReply = (P_GET_STATE_REPLY_MSG *) pCReplyBuffer->GetBuffer();
    memset(pmsgReply, 0, sizeof(P_GET_STATE_REPLY_MSG));

    pmsgReply->dwMsgType = PMSG_GET_STATE_REPLY;
    pmsgReply->dwMsgLen = cbReplySize - sizeof(BASE_MSG_HEADER);
    pmsgReply->dwSeqNum = dwSeqNum;
    pmsgReply->sgaddr = sgaddrIgnore;

    if ( FAILED(hrReply) )
    {
        pmsgReply->hr = hrReply;
    }
    else if (pCPresence == NULL)
    {
        pmsgReply->hr = HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
    }
    else
    {
        pmsgReply->dwState = pCPresence->GetState();
        pmsgReply->qwMatchSessionID = pCPresence->GetMatchSessionID();
        pmsgReply->dwTitleID = pCPresence->GetLastSeenTitleID();

        if (pCPresence->GetRichPresenceLen() == 0)
        {
            pmsgReply->hr = XONLINE_E_NOTIFICATION_NO_DATA;
        }
        else
        {
            pmsgReply->hr = hrReply;
            memcpy(&pmsgReply->rp, pCPresence->GetRichPresenceData(), pCPresence->GetRichPresenceLen());
        }
    }

    hr = pCReplyConn->Send(pCReplyBuffer);

lDone:
    SAFE_RELEASE(pCReplyBuffer);

    return hr;
}

/*****************************************************************************

CSwitchboard::DeadUser

The given user just went offline.

*****************************************************************************/
HRESULT CSwitchboard::DeadUser(
    SGADDR sgaddr,
    QWORD qwUserID,
    QWORD *pqwNonce)
{
    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "DeadUser: sg %X spi %X xb %I64X user %I64X",
        sgaddr.inaSg,
        sgaddr.dwSpiSg,
        sgaddr.qwXboxID,
        qwUserID);

    HRESULT hr = S_OK;
    CPresence *pCPresence = NULL;

    // See if there's currently a record for the given user
    hr = g_CPresenceUserIndex.FindPresence(qwUserID, &pCPresence );
    if( pCPresence == NULL )
    {
        goto lDone;
    }

    // Validate the message's sgaddr against the user's
    if (!CheckSGAddr(&sgaddr, pCPresence))
    {
        if (pCPresence->IsOnline())
        {
            // this is only an error if the expected sg is nonzero.  otherwise it may be that the user just logged off.
            g_Counters.IncrementValue32(XPPERF_SERVER_BAD_USER_COUNTER, 1);
            g_Counters.IncrementValue32(XPPERF_SERVER_BAD_USER_RATE, 1);
            hr = XONLINE_E_SERVER_ERROR;
        }
        goto lDone;
    }

    XOMASSERT(pqwNonce != NULL);
    *pqwNonce = pCPresence->GetNonce();

    hr = KillUser(pCPresence);
    if (FAILED(hr))
    {
        // Ignore failures, specific errors logged by the function
        XomTrace(PresenceDebug, L_NORMAL, "CSwitchboard::DeadUser - KillUser failed hr=0x%X", hr);
        hr = S_OK;
    }

lDone:

    SAFE_RELEASE(pCPresence);

    return hr;
}


/*****************************************************************************

CSwitchboard::DeadXBox

The given XBox just went offline, so any users who were on this XBox should be
considered offline also.

*****************************************************************************/
HRESULT CSwitchboard::DeadXBox(SGADDR sgaddr)
{
    HRESULT hr = S_OK;
    CPresence *pCIndex = NULL;
    CPresence *pCVictim = NULL;

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "DeadXBox: sg %X spi %X xb %I64X",
        sgaddr.inaSg,
        sgaddr.dwSpiSg,
        sgaddr.qwXboxID);

    pCIndex = g_CPresenceXBoxIndex.GetFirstEntry(&sgaddr);
    while (pCIndex != NULL)
    {
        pCVictim = pCIndex;
        pCIndex = g_CPresenceXBoxIndex.GetNextEntry(pCIndex);

        if (memcmp(pCVictim->GetSGAddr(), &sgaddr, sizeof(SGADDR)) == 0)
        {
            hr = KillUser(pCVictim);
            if (FAILED(hr))
            {
                // Ignore failures, specific errors logged by the function
                XomTrace(PresenceDebug, L_NORMAL,  "CSwitchboard::DeadXBox - KillUser failed hr=0x%X", hr);
                hr = S_OK;
            }
        }

        SAFE_RELEASE(pCVictim);
    }

    return hr;
}

/*****************************************************************************

CSwitchboard::DeadSG

The given SG just went offline, so any users who were on this XRG should be
considered offline also.

*****************************************************************************/
HRESULT CSwitchboard::DeadSG(SGADDR sgaddr)
{
    HRESULT hr = S_OK;
    CPresence *pCIndex = NULL;
    CPresence *pCVictim = NULL;

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "DeadSG: sg %X spi %X xb %I64X",
        sgaddr.inaSg,
        sgaddr.dwSpiSg,
        sgaddr.qwXboxID);

    pCIndex = g_CPresenceSGIndex.GetFirstEntry(&sgaddr);
    while (pCIndex != NULL)
    {
        pCVictim = pCIndex;
        pCIndex = g_CPresenceSGIndex.GetNextEntry(pCIndex);

        if (pCVictim->GetSGAddr()->inaSg.S_un.S_addr == sgaddr.inaSg.S_un.S_addr)
        {
            // Set the victim as having a dead sg
            pCVictim->MarkForDeadSG();
        }

        SAFE_RELEASE(pCVictim);
    }

    return hr;
}

/*****************************************************************************

CSwitchboard::Kick

Kick the given user, optionally setting a flag to have their tickets flushed
on next login.

*****************************************************************************/
HRESULT CSwitchboard::Kick(QWORD qwUserID, BOOL fFlushTickets )
{
    HRESULT hr = S_OK;
    CPresence *pCPresence = NULL;

     XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Kick: User=%I64X FlushTickets=%d",
        qwUserID,
        fFlushTickets);

    // See if the user is on the system
    hr = g_CPresenceUserIndex.FindPresence(qwUserID, &pCPresence );
    if( pCPresence != NULL )
    {
        // First set the flush tickets flag
        if (fFlushTickets)
        {
            hr = m_CProfileStore.SetFlushTickets(qwUserID);
            if (FAILED(hr))
            {
                goto lDone;
            }
        }

        // They're on, kick them off the system
        if (pCPresence->IsOnline())
        {
            m_CSGComm.SendKick(pCPresence->GetSGAddr());
        }

        // Force a trip to the database next login
        pCPresence->ForceDBAlive();
    }

lDone:

    SAFE_RELEASE(pCPresence);

    return hr;
}

HRESULT CSwitchboard::PurgeUser(QWORD qwUserID, DWORD dwSeqNum, CClientConnection *pCReplyConn)
{
    HRESULT hr = S_OK;
    CPresence *pCPresence = NULL;
    CTCPCntVarBuffer *pBuffer = NULL;
    P_PURGE_USER_REPLY_MSG *pReply = NULL;

     XomTrace(
        PresenceDebug,
        L_NORMAL,
        "PurgeUser: User=%I64X",
        qwUserID);

    pBuffer = g_pBufferPool->GetBuffer(sizeof(P_PURGE_USER_REPLY_MSG));
    if (pBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }
    ZeroMemory(pBuffer->GetBuffer(), pBuffer->GetBufferLength());
    pReply = (P_PURGE_USER_REPLY_MSG *)pBuffer->GetBuffer();
    pReply->dwMsgType = PMSG_PURGE_USER_REPLY;
    pReply->dwSeqNum = dwSeqNum;
    pReply->dwMsgLen = sizeof(P_PURGE_USER_REPLY_MSG) - sizeof(BASE_MSG_HEADER);

    // See if the user is on the system
    hr = g_CPresenceUserIndex.FindPresence(qwUserID, &pCPresence );
    if( pCPresence != NULL )
    {
        if (pCPresence->HasOnlineRecord())
        {
            if (pCPresence->IsOnline() || pCPresence->HasTransientMessages())
            {
                // why were we asked to purge this user??
                hr = HRESULT_FROM_WIN32(ERROR_USER_EXISTS);
                goto lDone;
            }
            else
            {
                pCPresence->SelfDestruct();
            }
        }

        memcpy(pReply->szGamertag, pCPresence->GetAcctName(), XONLINE_GAMERTAG_SIZE);

        g_CPresenceUserIndex.RemovePresence(pCPresence);

        LONG lRefCount = pCPresence->GetRefCount() - 1;
        SAFE_RELEASE(pCPresence);

        if (lRefCount > 0)
        {
            hr = E_UNEXPECTED;
        }
    }

lDone:

    if (pBuffer != NULL)
    {
        pReply->hr = hr;
        pCReplyConn->Send(pBuffer);

        SAFE_RELEASE(pBuffer);
    }

    SAFE_RELEASE(pCPresence);

    return hr;
}

/*****************************************************************************

CSwitchboard::InvalidateUser

Invalidate the given users presence record.

*****************************************************************************/
HRESULT CSwitchboard::InvalidateUser( QWORD qwUserID )
{
    HRESULT hr = S_OK;
    CPresence *pCPresence = NULL;
    CInvalidateUserContext *pCCtx = NULL;
    CLoadOfflinePresenceContext *pLoadCtx = NULL;

     XomTrace(
        PresenceDebug,
        L_NORMAL,
        "InvalidateUser: User=%I64X",
        qwUserID
        );

    // See if the user is on the system
    hr = g_CPresenceUserIndex.FindPresence(qwUserID, &pCPresence );
    if( pCPresence != NULL )
    {
        pCCtx = new CInvalidateUserContext;
        if (pCCtx == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto lDone;
        }

        pCCtx->m_fPresFriend = pCPresence->CanSharePresence(TRUE);
        pCCtx->m_fPresOther = pCPresence->CanSharePresence(FALSE);
        pCCtx->m_pSwitchboard = this;
        pCCtx->dwPendingLoads++;

        pLoadCtx = new CLoadOfflinePresenceContext(this, &m_CProfileStore);
        if (pLoadCtx == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto lDone;
        }

        pLoadCtx->m_qwUserID = qwUserID;
        memcpy(pLoadCtx->m_szGamerTag, pCPresence->GetAcctName(), XONLINE_GAMERTAG_SIZE);
        pLoadCtx->m_pCaller = pCCtx;

        hr = m_CProfileStore.SendToSqlThread(pLoadCtx);
    }

lDone:

    if (FAILED(hr))
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_417,
            "CSwitchboard::InvalidateUser() failed for User %I64X, hr=0x%X",
            qwUserID,
            hr);

        delete pLoadCtx;
        delete pCCtx;
    }

    SAFE_RELEASE(pCPresence);

    return hr;
}

HRESULT CSwitchboard::UserPreMigration(QWORD qwUserID)
{
    HRESULT hr = S_OK;

    CPresence *pCPresence = NULL;
    hr = g_CPresenceUserIndex.FindPresence(qwUserID, &pCPresence);

    if (hr != HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER))
    {
        XomNtEvent(XEVENT_PRESENCE_CODE_418, "UserPreMigration() user record already found for user %I64X.  hr = 0x%X", qwUserID, hr);
        hr = HRESULT_FROM_WIN32(ERROR_USER_EXISTS);
        goto lDone;
    }

    // create a stub record.
    hr = g_CPresenceUserIndex.CreatePresence(
        this,
        qwUserID,
        0,
        0,
        "",
        0,
        &pCPresence);

    if (FAILED(hr))
    {
        goto lDone;
    }

    pCPresence->SetMigrationPending(TRUE);

lDone:

    SAFE_RELEASE(pCPresence);

    return hr;
}
HRESULT CSwitchboard::UserFullMigration(P_USER_FULL_MIGRATION_MSG *pMsg, DWORD cbMsg)
{
    HRESULT hr = S_OK;

    CPresence *pCPresence = NULL;
    hr = g_CPresenceUserIndex.FindPresence(pMsg->qwUserID, &pCPresence, TRUE);

    if (FAILED(hr))
    {
        XomNtEvent(XEVENT_PRESENCE_CODE_419, "UserFullMigration() user record missing for user %I64d.  hr = 0x%X", pMsg->qwUserID, hr);
        hr = HRESULT_FROM_WIN32(ERROR_USER_EXISTS);
        goto lDone;
    }

    if (!(pCPresence->IsMigrationPending()))
    {
        XomNtEvent(XEVENT_PRESENCE_CODE_420, "UserFullMigration() user record %I64X not marked as migration pending.", pMsg->qwUserID);
        hr = E_UNEXPECTED;
        goto lDone;
    }

    // populate the record with all the new data.
    hr = pCPresence->DeSerialize(pMsg, cbMsg);
    if (FAILED(hr))
    {
        goto lDone;
    }

    if (pCPresence->IsOnline())
    {
        g_Counters.SafeIncrement32(XPPERF_SERVER_ACTIVE_USERS_COUNTER);
    }

    // handle any deferred requests.
    pCPresence->ProcessDeferredQueue();

    // just in case, we trigger this again from the new server.
    pCPresence->SendQVals();

lDone:

    SAFE_RELEASE(pCPresence);

    return hr;
}


/*****************************************************************************

CSwitchboard::PeerSession

Retreive the peer session for the given user

*****************************************************************************/
HRESULT CSwitchboard::PeerSession(
    QWORD qwUserID,
    QWORD qwHostUserID,
    CClientConnection *pCReplyConn,
    DWORD dwSeqNum)
{
    HRESULT hr = S_OK;
    CPresence *pCPresence = NULL;
    XNADDR xnaddrZero = { 0 };
    XNKID xkidZero = { 0 };
    XNKEY xnkeyZero = { 0 };

     XomTrace(
        PresenceDebug,
        L_NORMAL,
        "PeerSession: User=%I64X HostUser=%I64X",
        qwUserID,
        qwHostUserID);

    // See if the user is on the system
    hr = g_CPresenceUserIndex.FindPresence(qwHostUserID, &pCPresence );
    if( pCPresence != NULL )
    {
        // They're on and a friend send the information
        if (pCPresence->IsOnline())
        {
            hr = SendPeerSessionReply(
                dwSeqNum,
                qwHostUserID,
                pCPresence->GetTitleID(),
                pCPresence->GetTitleVersion(),
                pCPresence->GetTitleRegion(),
                pCPresence->GetXNADDR(),
                pCPresence->GetXNKID(),
                pCPresence->GetXNKEY(),
                pCReplyConn);
        }
        else
        {
            // Offline
            hr = SendPeerSessionReply(
                dwSeqNum,
                qwHostUserID,
                0,
                0,
                0,
                xnaddrZero,
                xkidZero,
                xnkeyZero,
                pCReplyConn);
        }
    }

    SAFE_RELEASE(pCPresence);

    return hr;
}

/*****************************************************************************

CSwitchboard::PeerSubscribe

Subscribe to peer presence for a list of UserIDs

*****************************************************************************/
HRESULT CSwitchboard::PeerSubscribe(
    SGADDR sgaddr,
    QWORD qwUserID,
    DWORD cSrcUserIDs,
    QWORD *pqwSrcUserIDs,
    CClientConnection *pCReplyConn,
    DWORD dwSeqNum)
{
    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "PeerSubscribe: User=%I64X cSrcUserIDs=%d SrcUserID0=%I64X",
        qwUserID,
        cSrcUserIDs,
        pqwSrcUserIDs != NULL? pqwSrcUserIDs[0] : (QWORD)0);

    HRESULT hr = S_OK;
    CPresence *pCPresence = NULL;
    DWORD cStartList = 0;
    QWORD rgqwStartList[MAX_PEER_SUBSCRIPTIONS];
    DWORD cStopList = 0;
    QWORD rgqwStopList[MAX_PEER_SUBSCRIPTIONS];

    // See if there's currently a record for the given user
    hr = g_CPresenceUserIndex.FindPresence(qwUserID, &pCPresence );
    if(pCPresence == NULL)
    {
        goto lDone;
    }
    else if (!(pCPresence->HasOnlineRecord()))
    {
        m_CSGComm.SendKick(&sgaddr);
        hr = HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
        goto lDone;
    }

    // Validate the message's sgaddr against the user's
    if (!CheckSGAddr(&sgaddr, pCPresence))
    {
        if (pCPresence->IsOnline())
        {
            // this is only an error if the expected sg is nonzero.  otherwise it may be that the user just logged off.
            g_Counters.IncrementValue32(XPPERF_SERVER_BAD_USER_COUNTER, 1);
            g_Counters.IncrementValue32(XPPERF_SERVER_BAD_USER_RATE, 1);
            hr = XONLINE_E_SERVER_ERROR;
        }
        goto lDone;
    }

    hr = pCPresence->ReplaceWatches(cSrcUserIDs, pqwSrcUserIDs, &cStartList, rgqwStartList, &cStopList, rgqwStopList);
    if (FAILED(hr))
    {
        goto lDone;
    }

    SET_PUID_CLIENT_TYPE(qwUserID, (pCPresence->CanClientConsumeRichPresence() ? PRES_CLIENT_TYPE_XENON : PRES_CLIENT_TYPE_XBOX));
    SET_PUID_CLIENT_BETA(qwUserID, (pCPresence->CanClientIgnoreFriendStateNotifications() ? 1 : 0));

    // Send WatchStart
    if (cStartList > 0)
    {
        hr = m_CXPCluster.SendMsgWatchStart(
            qwUserID,
            cStartList,
            rgqwStartList);
        if (FAILED(hr))
        {
            goto lDone;
        }
    }

    // Send WatchStop
    if (cStopList > 0)
    {
        hr = m_CXPCluster.SendMsgWatchStop(
            qwUserID,
            cStopList,
            rgqwStopList);
        if (FAILED(hr))
        {
            goto lDone;
        }
    }

    SendPeerSubscribeReply(
        dwSeqNum,
        hr,
        pCReplyConn);

lDone:

    SAFE_RELEASE(pCPresence);

    return hr;
}

HRESULT CSwitchboard::PeerSubscribeEx(
    SGADDR sgaddr,
    QWORD qwUserID,
    DWORD dwFlags,
    DWORD cUserIDs,
    QWORD *pqwUserIDs,
    CClientConnection *pCReplyConn,
    DWORD dwSeqNum)
{
    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "PeerSubscribeEx: User=%I64X cSrcUserIDs=%d SrcUserID0=%I64X",
        qwUserID,
        cUserIDs,
        (pqwUserIDs != NULL) ? (pqwUserIDs[0] & ~X_PEER_SUBSCRIBE_EX_USER_FLAGS_MASK) : (QWORD)0);

    HRESULT hr = S_OK;
    DWORD cStartList = 0;
    QWORD rgqwStartList[MAX_PEER_SUBSCRIPTIONS];
    DWORD cStopList = 0;
    QWORD rgqwStopList[MAX_PEER_SUBSCRIPTIONS];
    CPeerSubscribeExContext *pCCtx = new CPeerSubscribeExContext(this);
    if (pCCtx == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // See if there's currently a record for the given user
    hr = g_CPresenceUserIndex.FindPresence(qwUserID, &pCCtx->m_pCPresence );
    if(pCCtx->m_pCPresence == NULL)
    {
        goto lDone;
    }
    else if (!(pCCtx->m_pCPresence->HasOnlineRecord()))
    {
        m_CSGComm.SendKick(&sgaddr);
        hr = HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
        goto lDone;
    }

    // Validate the message's sgaddr against the user's
    if (!CheckSGAddr(&sgaddr, pCCtx->m_pCPresence))
    {
        if (pCCtx->m_pCPresence->IsOnline())
        {
            // this is only an error if the expected sg is nonzero.  otherwise it may be that the user just logged off.
            g_Counters.IncrementValue32(XPPERF_SERVER_BAD_USER_COUNTER, 1);
            g_Counters.IncrementValue32(XPPERF_SERVER_BAD_USER_RATE, 1);
            hr = XONLINE_E_SERVER_ERROR;
        }
        else
        {
            hr = SendPeerSubscribeExReply(
                dwSeqNum,
                hr,
                0,
                NULL,
                pCReplyConn);
        }
        goto lDone;
    }

    pCCtx->m_qwUserID = qwUserID;
    pCCtx->m_dwSeqNum = dwSeqNum;
    pCCtx->m_pCReplyConn = pCReplyConn;
    pCCtx->m_pCReplyConn->AddRef();

    if (dwFlags & X_PEER_SUBSCRIBE_EX_FLAGS_USE_DIFFS)
    {
        for (DWORD iSubscribee = 0; iSubscribee < cUserIDs; iSubscribee++)
        {
            if (pqwUserIDs[iSubscribee] & X_PEER_SUBSCRIBE_EX_USER_FLAGS_ADD)
            {
                rgqwStartList[cStartList++] = (pqwUserIDs[iSubscribee] & ~X_PEER_SUBSCRIBE_EX_USER_FLAGS_MASK);
            }
            else if (pqwUserIDs[iSubscribee] & X_PEER_SUBSCRIBE_EX_USER_FLAGS_REMOVE)
            {
                rgqwStopList[cStopList++] = (pqwUserIDs[iSubscribee] & ~X_PEER_SUBSCRIBE_EX_USER_FLAGS_MASK);
            }
        }

        hr = pCCtx->m_pCPresence->UpdateWatches(cStartList, rgqwStartList, cStopList, rgqwStopList);
        if (FAILED(hr))
        {
            goto lDone;
        }

        // only obtain initial state results from the new subscriptions
        hr = pCCtx->BuildResultsList(cStartList, rgqwStartList);
        if (FAILED(hr))
        {
            goto lDone;
        }
    }
    else
    {
        // clear user flags
        for (DWORD iSubscribee = 0; iSubscribee < cUserIDs; iSubscribee++)
        {
            pqwUserIDs[iSubscribee] &= ~X_PEER_SUBSCRIBE_EX_USER_FLAGS_MASK;
        }

        hr = pCCtx->m_pCPresence->ReplaceWatches(cUserIDs, pqwUserIDs, &cStartList, rgqwStartList, &cStopList, rgqwStopList);
        if (FAILED(hr))
        {
            goto lDone;
        }

        // obtain initial state results from all subscriptions
        hr = pCCtx->BuildResultsList(cUserIDs, pqwUserIDs);
        if (FAILED(hr))
        {
            goto lDone;
        }
    }

    SET_PUID_CLIENT_TYPE(qwUserID, (pCCtx->m_pCPresence->CanClientConsumeRichPresence() ? PRES_CLIENT_TYPE_XENON : PRES_CLIENT_TYPE_XBOX));
    SET_PUID_CLIENT_BETA(qwUserID, (pCCtx->m_pCPresence->CanClientIgnoreFriendStateNotifications() ? 1 : 0));

    // Send WatchStart
    if (cStartList > 0)
    {
        hr = m_CXPCluster.SendMsgWatchStart(
            qwUserID,
            cStartList,
            rgqwStartList);
        if (FAILED(hr))
        {
            goto lDone;
        }
    }

    // Send WatchStop
    if (cStopList > 0)
    {
        hr = m_CXPCluster.SendMsgWatchStop(
            qwUserID,
            cStopList,
            rgqwStopList);
        if (FAILED(hr))
        {
            goto lDone;
        }
    }

    // any reason to think this wouldnt be S_OK?
    pCCtx->m_hr = hr;

    // AddRef() before calling SendGetPresenceInfo().  if the send fails, it will automatically call ApplyPresenceData() with empty results.
    pCCtx->AddRef();

    hr = SendGetPresenceInfo(pCCtx);

lDone:

    SAFE_RELEASE(pCCtx);

    return hr;
}


/*****************************************************************************

CSwitchboard::PeerUnsubscribe

Unsubscribe to peer presence

*****************************************************************************/
HRESULT CSwitchboard::PeerUnsubscribe(
    SGADDR sgaddr,
    QWORD qwUserID,
    CClientConnection *pCReplyConn,
    DWORD dwSeqNum)
{
    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "PeerUnsubscribe: User=%I64X",
        qwUserID);

    HRESULT hr = S_OK;
    CPresence *pCPresence;

    // See if there's currently a record for the given user
    hr = g_CPresenceUserIndex.FindPresence(qwUserID, &pCPresence );
    if(pCPresence == NULL)
    {
        goto lDone;
    }
    else if (!(pCPresence->HasOnlineRecord()))
    {
        m_CSGComm.SendKick(&sgaddr);
        hr = HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
        goto lDone;
    }

    // Validate the message's sgaddr against the user's
    if (!CheckSGAddr(&sgaddr, pCPresence))
    {
        if (pCPresence->IsOnline())
        {
            // this is only an error if the expected sg is nonzero.  otherwise it may be that the user just logged off.
            g_Counters.IncrementValue32(XPPERF_SERVER_BAD_USER_COUNTER, 1);
            g_Counters.IncrementValue32(XPPERF_SERVER_BAD_USER_RATE, 1);
            hr = XONLINE_E_SERVER_ERROR;
        }
        goto lDone;
    }

    // Clear any watches we have
    hr = ClearPeerWatches(pCPresence);
    if (FAILED(hr))
    {
        goto lDone;
    }

    SendPeerUnsubscribeReply(
        dwSeqNum,
        hr,
        pCReplyConn);

lDone:

    SAFE_RELEASE(pCPresence);

    return hr;
}


/*****************************************************************************

CSwitchboard::TeamListTeams

List a set of teams or the teams the user is in if the set is empty.

*****************************************************************************/
HRESULT CSwitchboard::TeamListTeams(
    SGADDR sgaddr,
    QWORD qwUserID,
    DWORD dwTitleID,
    DWORD cTeamIDs,
    QWORD *pqwTeamIDs,
    CClientConnection *pCReplyConn,
    DWORD dwSeqNum)
{
     XomTrace(
        PresenceDebug,
        L_NORMAL,
        "TeamListTeams: User=%I64X TitleId=0x%08X cTeamIDs=%d team0=%I64X",
        qwUserID,
        dwTitleID,
        cTeamIDs,
        pqwTeamIDs != NULL? pqwTeamIDs[0] : (QWORD)0);

    HRESULT hr;
    CPresence *pCPresence = NULL;
    hr = g_CPresenceUserIndex.FindPresence(qwUserID, &pCPresence);
    if (SUCCEEDED(hr))
    {
        hr = m_CProfileStore.TeamListTeams(
            qwUserID,
            dwTitleID,
            cTeamIDs,
            pqwTeamIDs,
            pCReplyConn,
            dwSeqNum);

        // Call will post a completion when it resolves
    }

    SAFE_RELEASE(pCPresence);

    return hr;
}

/*****************************************************************************

CSwitchboard::TeamListUserTeams

List a set of teams or the teams the user is in if the set is empty.

*****************************************************************************/
HRESULT CSwitchboard::TeamListUserTeams(
    SGADDR sgaddr,
    QWORD qwUserID,
    DWORD dwTitleID,
    CClientConnection *pCReplyConn,
    DWORD dwSeqNum)
{
     XomTrace(
        PresenceDebug,
        L_NORMAL,
        "TeamListUserTeams: User=%I64X TitleId=0x%08X",
        qwUserID,
        dwTitleID);

    HRESULT hr;

    CPresence *pCPresence = NULL;
    hr = g_CPresenceUserIndex.FindPresence(qwUserID, &pCPresence);
    if (SUCCEEDED(hr))
    {
        hr = m_CProfileStore.TeamListUserTeams(
            qwUserID,
            dwTitleID,
            pCReplyConn,
            dwSeqNum);

        // Call will post a completion when it resolves
    }

    SAFE_RELEASE(pCPresence);

    return hr;
}

/*****************************************************************************

CSwitchboard::TeamListMembers

List the members of a team

*****************************************************************************/
HRESULT CSwitchboard::TeamListMembers(
    SGADDR sgaddr,
    QWORD qwUserID,
    DWORD dwTitleID,
    QWORD qwTeamID,
    BOOL fShowRecruits,
    CClientConnection *pCReplyConn,
    DWORD dwSeqNum)
{
     XomTrace(
        PresenceDebug,
        L_NORMAL,
        "TeamListMembers: User=%I64X TitleId=0x%08X TeamID=%I64X",
        qwUserID,
        dwTitleID,
        qwTeamID);

    HRESULT hr;

    CPresence *pCPresence = NULL;
    hr = g_CPresenceUserIndex.FindPresence(qwUserID, &pCPresence);
    if (SUCCEEDED(hr))
    {
        hr = m_CProfileStore.TeamListMembers(
            qwUserID,
            dwTitleID,
            qwTeamID,
            fShowRecruits,
            pCReplyConn,
            dwSeqNum);

        // Call will post a completion when it resolves
    }

    SAFE_RELEASE(pCPresence);

    return hr;
}
/*****************************************************************************

CSwitchboard::TeamCreate

Create a team

*****************************************************************************/
HRESULT CSwitchboard::TeamCreate(
    SGADDR sgaddr,
    QWORD qwUserID,
    DWORD dwTitleID,
    DWORD dwMaxMembers,
    DWORD cbTeamName,
    LPCWSTR wszTeamName,
    DWORD cbTeamDescription,
    LPCWSTR wszTeamDescription,
    DWORD cbTeamMotto,
    LPCWSTR wszTeamMotto,
    DWORD cbTeamURL,
    LPCWSTR wszTeamURL,
    DWORD cbTeamData,
    BYTE *pbTeamData,
    DWORD cbCreatorData,
    BYTE *pbCreatorData,
    BOOL fXenon,
    CClientConnection *pCReplyConn,
    DWORD dwSeqNum)
{
     XomTrace(
        PresenceDebug,
        L_NORMAL,
        "TeamCreate: User=%I64X TitleId=0x%08X TeamName=%S",
        qwUserID,
        dwTitleID,
        wszTeamName != NULL? wszTeamName : L"");

    HRESULT hr;

    CPresence *pCPresence = NULL;
    hr = g_CPresenceUserIndex.FindPresence(qwUserID, &pCPresence);
    if (SUCCEEDED(hr))
    {
        hr = m_CProfileStore.TeamCreate(
            qwUserID,
            dwTitleID,
            dwMaxMembers,
            cbTeamName,
            wszTeamName,
            cbTeamDescription,
            wszTeamDescription,
            cbTeamMotto,
            wszTeamMotto,
            cbTeamURL,
            wszTeamURL,
            cbTeamData,
            pbTeamData,
            cbCreatorData,
            pbCreatorData,
            fXenon,
            pCReplyConn,
            dwSeqNum);

        // Call will post a completion when it resolves
    }

    SAFE_RELEASE(pCPresence);

    return hr;
}

/*****************************************************************************

CSwitchboard::TeamDelete

Delete a team

*****************************************************************************/
HRESULT CSwitchboard::TeamDelete(
    SGADDR sgaddr,
    QWORD qwUserID,
    DWORD dwTitleID,
    QWORD qwTeamID,
    CClientConnection *pCReplyConn,
    DWORD dwSeqNum)
{
     XomTrace(
        PresenceDebug,
        L_NORMAL,
        "TeamDelete: User=%I64X TitleId=0x%08X Team=%I64X",
        qwUserID,
        dwTitleID,
        qwTeamID);

    HRESULT hr;

    CPresence *pCPresence = NULL;
    hr = g_CPresenceUserIndex.FindPresence(qwUserID, &pCPresence);
    if (SUCCEEDED(hr))
    {
        hr = m_CProfileStore.TeamDelete(
            qwUserID,
            dwTitleID,
            qwTeamID,
            pCReplyConn,
            dwSeqNum);

        // Call will post a completion when it resolves
    }

    SAFE_RELEASE(pCPresence);

    return hr;
}

/*****************************************************************************

CSwitchboard::TeamRemove

Remove a team member

*****************************************************************************/
HRESULT CSwitchboard::TeamRemove(
    SGADDR sgaddr,
    ULONGLONG qwUserID,
    DWORD dwTitleID,
    ULONGLONG qwTeamID,
    ULONGLONG qwMemberID,
    CClientConnection *pCReplyConn,
    DWORD dwSeqNum)
{
     XomTrace(
        PresenceDebug,
        L_NORMAL,
        "TeamRemove: User=%I64X TitleId=0x%08X Team=%I64X Member=%I64X",
        qwUserID,
        dwTitleID,
        qwTeamID,
        qwMemberID);

    HRESULT hr;

    CPresence *pCPresence = NULL;
    hr = g_CPresenceUserIndex.FindPresence(qwUserID, &pCPresence);
    if (SUCCEEDED(hr))
    {
        hr = m_CProfileStore.TeamRemove(
            qwUserID,
            dwTitleID,
            qwTeamID,
            qwMemberID,
            pCReplyConn,
            dwSeqNum);

        // Call will post a completion when it resolves
    }

    SAFE_RELEASE(pCPresence);

    return hr;
}

/*****************************************************************************

CSwitchboard::TeamManageTeam

Manage a team

*****************************************************************************/
HRESULT CSwitchboard::TeamManageTeam(
    SGADDR sgaddr,
    QWORD qwUserID,
    DWORD dwTitleID,
    QWORD qwTeamID,
    DWORD cbTeamName,
    LPCWSTR wszTeamName,
    DWORD cbTeamDescription,
    LPCWSTR wszTeamDescription,
    DWORD cbTeamMotto,
    LPCWSTR wszTeamMotto,
    DWORD cbTeamURL,
    LPCWSTR wszTeamURL,
    DWORD cbTeamData,
    BYTE *pbTeamData,
    BOOL fXenon,
    CClientConnection *pCReplyConn,
    DWORD dwSeqNum)
{
     XomTrace(
        PresenceDebug,
        L_NORMAL,
        "TeamManageTeam: User=%I64X TitleId=0x%08X  TeamID=%I64X Name=%S Desc=%S Motto=%S URL=%S",
        qwUserID,
        dwTitleID,
        qwTeamID,
        wszTeamName,
        wszTeamDescription,
        wszTeamMotto,
        wszTeamURL);

    HRESULT hr;

    CPresence *pCPresence = NULL;
    hr = g_CPresenceUserIndex.FindPresence(qwUserID, &pCPresence);
    if (SUCCEEDED(hr))
    {
        hr = m_CProfileStore.TeamManageTeam(
            qwUserID,
            dwTitleID,
            qwTeamID,
            cbTeamName,
            wszTeamName,
            cbTeamDescription,
            wszTeamDescription,
            cbTeamMotto,
            wszTeamMotto,
            cbTeamURL,
            wszTeamURL,
            cbTeamData,
            pbTeamData,
            fXenon,
            pCReplyConn,
            dwSeqNum);

        // Call will post a completion when it resolves
    }

    SAFE_RELEASE(pCPresence);

    return hr;
}

/*****************************************************************************

CSwitchboard::TeamManageMember

Manage a team member

*****************************************************************************/
HRESULT CSwitchboard::TeamManageMember(
    SGADDR sgaddr,
    ULONGLONG qwUserID,
    DWORD dwTitleID,
    ULONGLONG qwTeamID,
    ULONGLONG qwMemberID,
    DWORD dwMemberPriv,
    DWORD cbMemberData,
    BYTE *pbMemberData,
    CClientConnection *pCReplyConn,
    DWORD dwSeqNum)
{
    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "TeamManageMember: User=%I64X TitleId=0x%08X  Team=%I64X Member=%I64X",
        qwUserID,
        dwTitleID,
        qwTeamID,
        qwMemberID);

    HRESULT hr;

    CPresence *pCPresence = NULL;
    hr = g_CPresenceUserIndex.FindPresence(qwUserID, &pCPresence);
    if (SUCCEEDED(hr))
    {
        hr = m_CProfileStore.TeamManageMember(
            qwUserID,
            dwTitleID,
            qwTeamID,
            qwMemberID,
            dwMemberPriv,
            cbMemberData,
            pbMemberData,
            pCReplyConn,
            dwSeqNum);

        // Call will post a completion when it resolves
    }

    SAFE_RELEASE(pCPresence);

    return hr;
}

/*****************************************************************************

CSwitchboard::TeamRecruit

Recruit someone into a team

*****************************************************************************/
HRESULT CSwitchboard::TeamRecruit(
    SGADDR sgaddr,
    ULONGLONG qwUserID,
    DWORD dwTitleID,
    ULONGLONG qwTeamID,
    ULONGLONG qwMemberID,
    LPCSTR szMemberName,
    DWORD dwMemberPriv,
    DWORD dwMessageFlags,
    WORD cbDetails,
    const BYTE* pbDetails,
    DWORD cbMemberData,
    const BYTE *pbMemberData,
    CClientConnection *pCReplyConn,
    DWORD dwSeqNum)
{
     XomTrace(
        PresenceDebug,
        L_NORMAL,
        "TeamRecruit: User=%I64X TitleId=0x%08X  Team=%I64X MemberID=%I64X MemberName=%s MemberPriv=%d MessageFlags=%d cbDetails=%d cbMemberData=%d",
        qwUserID,
        dwTitleID,
        qwTeamID,
        qwMemberID,
        szMemberName,
        dwMemberPriv,
        dwMessageFlags,
        cbDetails,
        cbMemberData);

    HRESULT hr = S_OK;

    CPresence *pCPresence = NULL;
    hr = g_CPresenceUserIndex.FindPresence(qwUserID, &pCPresence);
    if (SUCCEEDED(hr))
    {
        hr = m_CProfileStore.TeamRecruit(
            qwUserID,
            dwTitleID,
            qwTeamID,
            qwMemberID,
            szMemberName,
            dwMemberPriv,
            dwMessageFlags,
            pCPresence->GetAcctName(),
            cbDetails,
            pbDetails,
            cbMemberData,
            pbMemberData,
            pCReplyConn,
            dwSeqNum);

        // Call will post a completion when it resolves
    }

    SAFE_RELEASE(pCPresence);

    return hr;
}

/*****************************************************************************

CSwitchboard::TeamJoin

Accept or reject recruitment into a team

*****************************************************************************/
HRESULT CSwitchboard::TeamJoin(
    SGADDR sgaddr,
    QWORD qwUserID,
    DWORD dwTitleID,
    QWORD qwTeamID,
    DWORD dwRecruitMsgID,
    BYTE bAnswer,
    CClientConnection *pCReplyConn,
    DWORD dwSeqNum)
{
     XomTrace(
        PresenceDebug,
        L_NORMAL,
        "TeamJoin: User=%I64X TitleId=0x%08X  Team=%I64X RecruitMsgID=%d bAnswer=%d",
        qwUserID,
        dwTitleID,
        qwTeamID,
        dwRecruitMsgID,
        (DWORD)bAnswer);

    HRESULT hr;

    CPresence *pCPresence = NULL;
    hr = g_CPresenceUserIndex.FindPresence(qwUserID, &pCPresence);
    if (SUCCEEDED(hr))
    {
        hr = m_CProfileStore.TeamJoin(
            qwUserID,
            dwTitleID,
            qwTeamID,
            dwRecruitMsgID,
            bAnswer,
            pCReplyConn,
            dwSeqNum);

        // Call will post a completion when it resolves
    }

    SAFE_RELEASE(pCPresence);

    return hr;
}

/*****************************************************************************

CSwitchboard::TeamGetTicket

Get a ticket containing team membership

*****************************************************************************/
HRESULT CSwitchboard::TeamGetTicket(
    SGADDR sgaddr,
    QWORD qwUserID,
    DWORD dwTitleID,
    CClientConnection *pCReplyConn,
    DWORD dwSeqNum)
{
    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "TeamGetTicket: User=%I64X TitleId=0x%08X ",
        qwUserID,
        dwTitleID);

    HRESULT hr;

    CPresence *pCPresence = NULL;
    hr = g_CPresenceUserIndex.FindPresence(qwUserID, &pCPresence);
    if (SUCCEEDED(hr))
    {
        hr = m_CProfileStore.TeamGetTicket(
            qwUserID,
            dwTitleID,
            pCReplyConn,
            dwSeqNum);

        // Call will post a completion when it resolves
    }

    SAFE_RELEASE(pCPresence);

    return hr;
}

/*****************************************************************************

CSwitchboard::WatchStart

Start collecting presence from a set of sources

*****************************************************************************/
HRESULT CSwitchboard::WatchStart(
    QWORD qwDestUserID,
    DWORD cSourceUserIDs,
    QWORD *rgqwSourceUserIDs)
{
    HRESULT hr = S_OK;
    DWORD dwSourceIndex;
    CPresence *pCSourcePresence;
    CWatchStartContext *pCallerCtx = NULL;

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "WatchStart: dest %I64X numsrc %d src0=%I64X",
        qwDestUserID,
        cSourceUserIDs,
        rgqwSourceUserIDs[0]);

    QWORD *rgForwardIDs = NULL;
    DWORD cForwardIDs = 0;

    for (DWORD iPreScan = 0; iPreScan < cSourceUserIDs; iPreScan++)
    {
        hr = g_CPresenceUserIndex.FindPresence(rgqwSourceUserIDs[iPreScan], &pCSourcePresence);
        SAFE_RELEASE(pCSourcePresence);
        if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
        {
            // swap the deferring user to the front
            QWORD qwFirst = rgqwSourceUserIDs[0];
            rgqwSourceUserIDs[0] = rgqwSourceUserIDs[iPreScan];
            rgqwSourceUserIDs[iPreScan] = qwFirst;

            goto lDone;
        }
        else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
        {
            cForwardIDs++;
        }
    }
    hr = S_OK;

    pCallerCtx = new CWatchStartContext;
    if (pCallerCtx == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    if (cForwardIDs > 0)
    {
        rgForwardIDs = new QWORD[cForwardIDs];
        if (rgForwardIDs == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto lDone;
        }
        cForwardIDs = 0;
    }

    pCallerCtx->qwDestUserID = qwDestUserID;
    pCallerCtx->pXPCluster = &m_CXPCluster;
    pCallerCtx->dwPendingLoads = 0;

    // For each source (buddy)
    for (dwSourceIndex = 0; dwSourceIndex < cSourceUserIDs; dwSourceIndex++)
    {
        HRESULT hrInner = S_OK;

        hrInner = g_CPresenceUserIndex.FindPresence(rgqwSourceUserIDs[dwSourceIndex], &pCSourcePresence );

        // If the source is in not in memory, add it
        if (pCSourcePresence == NULL)
        {
            // first make sure this user hasnt been migrated.
            if (hrInner == XONLINE_E_PRESENCE_USER_MIGRATED)
            {
                // add this user to the forwarding list.
                rgForwardIDs[cForwardIDs] = rgqwSourceUserIDs[dwSourceIndex];
                cForwardIDs++;
                continue;
            }

            CLoadOfflinePresenceContext *pCCtx = new CLoadOfflinePresenceContext(this, &m_CProfileStore);
            if (pCCtx == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto lDone;
            }

            pCallerCtx->dwPendingLoads++;
            pCCtx->m_qwUserID = rgqwSourceUserIDs[dwSourceIndex];
            pCCtx->m_pCaller = pCallerCtx;

            hr = m_CProfileStore.SendToSqlThread(pCCtx);
        }
        else
        {
            // do it now.
            pCallerCtx->ProcessUser(pCSourcePresence, NULL);
        }

        SAFE_RELEASE(pCSourcePresence);
    }

    if (cForwardIDs > 0)
    {
        hr = m_CXPCluster.SendMsgWatchStart(qwDestUserID, cForwardIDs, rgForwardIDs, TRUE);
    }

lDone:

    if (pCallerCtx && pCallerCtx->dwPendingLoads == 0)
    {
        pCallerCtx->Finalize();
    }

    SAFE_ARRAYDELETE(rgForwardIDs);

    return hr;
}

/*****************************************************************************

CSwitchboard::WatchStop

Stop collecting presence from a set of sources

*****************************************************************************/
HRESULT CSwitchboard::WatchStop(
    QWORD qwDestUserID,
    DWORD cSourceUserIDs,
    QWORD *rgqwSourceUserIDs)
{
    HRESULT hr = S_OK;
    DWORD dwSourceIndex;
    CPresence *pCSourcePresence;

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "WatchStop: dest %I64X numsrc %d src0=%I64X",
        qwDestUserID,
        cSourceUserIDs,
        rgqwSourceUserIDs[0]);

    QWORD *rgForwardIDs = NULL;
    DWORD cForwardIDs = 0;

    for (DWORD iPreScan = 0; iPreScan < cSourceUserIDs; iPreScan++)
    {
        hr = g_CPresenceUserIndex.FindPresence(rgqwSourceUserIDs[iPreScan], &pCSourcePresence);
        SAFE_RELEASE(pCSourcePresence);
        if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
        {
            // swap the deferring user to the front
            QWORD qwFirst = rgqwSourceUserIDs[0];
            rgqwSourceUserIDs[0] = rgqwSourceUserIDs[iPreScan];
            rgqwSourceUserIDs[iPreScan] = qwFirst;

            goto lDone;
        }
        else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
        {
            cForwardIDs++;
        }
    }
    hr = S_OK;

    if (cForwardIDs > 0)
    {
        rgForwardIDs = new QWORD[cForwardIDs];
        if (rgForwardIDs == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto lDone;
        }
        cForwardIDs = 0;
    }

    // For each source (peer)
    for (dwSourceIndex = 0; dwSourceIndex < cSourceUserIDs; dwSourceIndex++)
    {
        HRESULT hrInner = S_OK;

        hrInner = g_CPresenceUserIndex.FindPresence(rgqwSourceUserIDs[dwSourceIndex], &pCSourcePresence);

        if (pCSourcePresence == NULL)
        {
            // first make sure this user hasnt been migrated.
            if (hrInner == XONLINE_E_PRESENCE_USER_MIGRATED)
            {
                // add this user to the forwarding list.
                rgForwardIDs[cForwardIDs] = rgqwSourceUserIDs[dwSourceIndex];
                cForwardIDs++;
                continue;
            }
        }
        else
        {
            // always remove from the watcher list.
            hrInner = pCSourcePresence->RemoveWatcher(qwDestUserID);

            if ((GET_PUID_BITS(qwDestUserID) != pCSourcePresence->GetUserID()) && pCSourcePresence->IsAcceptedBuddy(qwDestUserID))
            {
                CBuddyListEntry *pBuddy = pCSourcePresence->FindBuddy(qwDestUserID);
                if (pBuddy != NULL)
                {
                    pBuddy->SetPeerSubscribed(FALSE);
                }
            }
            else
            {
                // If we're online, mark us as offline to avoid dirty reads of online
                if (pCSourcePresence->IsOnline() && (hrInner == S_OK))
                {
                    m_CXPCluster.QueuePeerPresenceOffline(pCSourcePresence, 1, &qwDestUserID);
                }
            }
        }

        SAFE_RELEASE(pCSourcePresence);
    }

    if (cForwardIDs > 0)
    {
        hr = m_CXPCluster.SendMsgWatchStop(qwDestUserID, cForwardIDs, rgForwardIDs, TRUE);
    }

    // Ignore failures to send to notification, logged at lower layer
    hr = S_OK;

lDone:

    SAFE_ARRAYDELETE(rgForwardIDs);

    return hr;
}

/*****************************************************************************

CSwitchboard::TeamListTeamsComplete

Callback, called when a Team List Teams message has finished processing.

*****************************************************************************/
HRESULT CSwitchboard::TeamListTeamsComplete(CTeamListTeamsContext *pCCtx)
{
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "TeamListTeamsComplete for User %I64X hr=0x%X",
        pCCtx->m_qwUserID,
        pCCtx->m_hr);

    HRESULT hr = S_OK;

    // Send the reply
    SendTeamListTeamsReply(
        pCCtx->m_dwSeqNum,
        pCCtx->m_hr,
        pCCtx->m_cReplies,
        pCCtx->m_rgpReplies,
        pCCtx->m_pCReplyConn);


    if (SUCCEEDED(hr))
    {
        g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_TEAM_LIST_TEAMS_MSGS_COUNTER );
    }
    else
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_TEAM_LIST_TEAMS_MSGS_COUNTER );

        XomNtEvent(
            XEVENT_PRESENCE_CODE_421,
            "CSwitchboard::TeamListTeamsComplete failed user=%I64X hr=0x%X",
            pCCtx->m_qwUserID,
            hr);
    }

    SAFE_RELEASE(pCCtx);

    return hr;
}

/*****************************************************************************

CSwitchboard::TeamListUserTeamsComplete

Callback, called when a TeamListUserTeams message has finished processing.

*****************************************************************************/
HRESULT CSwitchboard::TeamListUserTeamsComplete(CTeamListUserTeamsContext *pCCtx)
{
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "TeamListUserTeamsComplete for User %I64X hr=0x%X",
        pCCtx->m_qwUserID,
        pCCtx->m_hr);

    HRESULT hr = S_OK;

    // Send the reply
    SendTeamListUserTeamsReply(
        pCCtx->m_dwSeqNum,
        pCCtx->m_hr,
        pCCtx->m_cTeams,
        pCCtx->m_rgUserTeams,
        pCCtx->m_pCReplyConn);


    if (SUCCEEDED(hr))
    {
        g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_TEAM_LIST_TEAMS_MSGS_COUNTER );
    }
    else
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_TEAM_LIST_TEAMS_MSGS_COUNTER );

        XomNtEvent(
            XEVENT_PRESENCE_CODE_422,
            "CSwitchboard::TeamListUserTeamsComplete failed user=%I64X hr=0x%X",
            pCCtx->m_qwUserID,
            hr);
    }

    SAFE_RELEASE(pCCtx);

    return hr;
}

/*****************************************************************************

CSwitchboard::TeamListMembersComplete

Callback, called when a Team List Members message has finished processing.

*****************************************************************************/
HRESULT CSwitchboard::TeamListMembersComplete(CTeamListMembersContext *pCCtx)
{
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "TeamListMembersComplete for User %I64X hr=0x%X",
        pCCtx->m_qwUserID,
        pCCtx->m_hr);

    HRESULT hr = S_OK;

    // Send the reply
    SendTeamListMembersReply(
        pCCtx->m_dwSeqNum,
        pCCtx->m_hr,
        pCCtx->m_qwTeamID,
        pCCtx->m_cMembers,
        pCCtx->m_pReply,
        pCCtx->m_pCReplyConn);


    if (SUCCEEDED(hr))
    {
        g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_TEAM_LIST_MEMBERS_MSGS_COUNTER );
    }
    else
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_TEAM_LIST_MEMBERS_MSGS_COUNTER );

        XomNtEvent(
            XEVENT_PRESENCE_CODE_423,
            "CSwitchboard::TeamListMembersComplete failed user=%I64X hr=0x%X",
            pCCtx->m_qwUserID,
            hr);
    }

    SAFE_RELEASE(pCCtx);

    return hr;
}

/*****************************************************************************

CSwitchboard::TeamCreateComplete

Callback, called when a Team Create message has finished processing.

*****************************************************************************/
HRESULT CSwitchboard::TeamCreateComplete(CTeamCreateContext *pCCtx)
{
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "TeamCreateComplete for User %I64X hr=0x%X",
        pCCtx->m_qwUserID,
        pCCtx->m_hr);

    HRESULT hr = S_OK;

    // Send the reply
    SendTeamCreateReply(
        pCCtx->m_dwSeqNum,
        pCCtx->m_hr,
        pCCtx->m_qwTeamID,
        pCCtx->m_pCReplyConn);

    XomTrace( TeamsLog, L_NORMAL, "TCR|%X:%X|%I64X|%I64X|%X",
        pCCtx->m_pCReplyConn == NULL ? 0 : ntohl( pCCtx->m_pCReplyConn->GetSockAddr()->sin_addr.S_un.S_addr ),
        pCCtx->m_pCReplyConn == NULL ? 0 : ntohs( pCCtx->m_pCReplyConn->GetSockAddr()->sin_port ),
        pCCtx->m_qwTeamID,
        pCCtx->m_qwUserID,
        hr );


    if (SUCCEEDED(hr))
    {
        g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_TEAM_CREATE_MSGS_COUNTER );
    }
    else
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_TEAM_CREATE_MSGS_COUNTER );

        XomNtEvent(
            XEVENT_PRESENCE_CODE_424,
            "CSwitchboard::TeamCreateComplete failed user=%I64X hr=0x%X",
            pCCtx->m_qwUserID,
            hr);
    }

    SAFE_RELEASE(pCCtx);

    return hr;
}

/*****************************************************************************

CSwitchboard::TeamDeleteComplete

Callback, called when a Team Delete message has finished processing.

*****************************************************************************/
HRESULT CSwitchboard::TeamDeleteComplete(CTeamDeleteContext *pCCtx)
{
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "TeamDeleteComplete for User %I64X hr=0x%X",
        pCCtx->m_qwUserID,
        pCCtx->m_hr);

    HRESULT hr = pCCtx->m_hr;

    // Send the reply
    SendTeamDeleteReply(
        pCCtx->m_dwSeqNum,
        pCCtx->m_hr,
        pCCtx->m_pCReplyConn);

    if( FAILED( hr ) )
    {
        goto lDone;
    }

    if (pCCtx->m_cMemberIDs > 0)
    {

        // Delete any team recruit message to the member
        Q_RECIPIENT_RESULT rgRecipients[ XONLINE_MAX_MESSAGE_RECIPIENTS ];

        for( DWORD iRecip = 0; iRecip < pCCtx->m_cMemberIDs; iRecip++ )
        {
            rgRecipients[ iRecip ].qwUserID = pCCtx->m_rgqwMemberIDs[ iRecip ];
            rgRecipients[ iRecip ].dwMessageID = 0;
        }

        // Delete any team recruit message to the members (best-effort)
        (void) QueueRevokeMessage(
            0,                                          // SenderID
            pCCtx->m_qwTeamID,                          // SenderContext
            ( XMSG_REVOKE_MESSAGE_EX_FLAG_USE_TYPE |
              XMSG_REVOKE_MESSAGE_EX_FLAG_USE_CONTEXT ),// dwFlags
            0,                                          // wPropTag
            0,                                          // cbProp
            NULL,                                       // pbProp
            XONLINE_MSG_TYPE_TEAM_RECRUIT,              // bMessageType
            (WORD) pCCtx->m_cMemberIDs,                 // cRecipients
            rgRecipients );                             // rgRecipients
    }

    XomTrace( TeamsLog, L_NORMAL, "TDL|%X:%X|%I64X|%I64X|%X",
        pCCtx->m_pCReplyConn == NULL ? 0 : ntohl( pCCtx->m_pCReplyConn->GetSockAddr()->sin_addr.S_un.S_addr ),
        pCCtx->m_pCReplyConn == NULL ? 0 : ntohs( pCCtx->m_pCReplyConn->GetSockAddr()->sin_port ),
        pCCtx->m_qwTeamID,
        pCCtx->m_qwUserID,
        hr );

lDone:
    if (SUCCEEDED(hr))
    {
        g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_TEAM_DELETE_MSGS_COUNTER );
    }
    else
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_TEAM_DELETE_MSGS_COUNTER );

        XomNtEvent(
            XEVENT_PRESENCE_CODE_425,
            "CSwitchboard::TeamDeleteComplete failed user=%I64X hr=0x%X",
            pCCtx->m_qwUserID,
            hr);
    }

    SAFE_RELEASE(pCCtx);

    return hr;
}

/*****************************************************************************

CSwitchboard::TeamRemoveComplete

Callback, called when a Team Remove message has finished processing.

*****************************************************************************/
HRESULT CSwitchboard::TeamRemoveComplete(CTeamRemoveContext *pCCtx)
{
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "TeamRemoveComplete for User %I64X hr=0x%X",
        pCCtx->m_qwUserID,
        pCCtx->m_hr);

    HRESULT hr = pCCtx->m_hr;

    // Send the reply
    SendTeamRemoveReply(
            pCCtx->m_dwSeqNum,
            pCCtx->m_hr,
            pCCtx->m_pCReplyConn);

    if( FAILED( hr ) )
    {
        goto lDone;
    }

    // Delete any team recruit message to the member
    Q_RECIPIENT_RESULT recipient;
    recipient.qwUserID = pCCtx->m_qwMemberID;
    recipient.dwMessageID = 0; // Don't know, the sender context and message type will be used to match it

    // Clear the message from Notification, best effort
    (void) QueueRevokeMessage(
        pCCtx->m_qwUserID,                          // SenderID
        pCCtx->m_qwTeamID,                          // SenderContext
        ( XMSG_REVOKE_MESSAGE_EX_FLAG_USE_TYPE |
          XMSG_REVOKE_MESSAGE_EX_FLAG_USE_SENDER |
          XMSG_REVOKE_MESSAGE_EX_FLAG_USE_CONTEXT ),// dwFlags
        0,                                          // wPropTag
        0,                                          // cbProp
        NULL,                                       // pbProp
        XONLINE_MSG_TYPE_TEAM_RECRUIT,              // bMessageType
        1,                                          // cRecipients
        &recipient );                               // rgRecipients

    XomTrace( TeamsLog, L_NORMAL, "TRM|%X:%X|%I64X|%I64X|%I64X|%X",
        pCCtx->m_pCReplyConn == NULL ? 0 : ntohl( pCCtx->m_pCReplyConn->GetSockAddr()->sin_addr.S_un.S_addr ),
        pCCtx->m_pCReplyConn == NULL ? 0 : ntohs( pCCtx->m_pCReplyConn->GetSockAddr()->sin_port ),
        pCCtx->m_qwTeamID,
        pCCtx->m_qwUserID,
        pCCtx->m_qwMemberID,
        hr );

lDone:
    if (SUCCEEDED(hr))
    {
        g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_TEAM_REMOVE_MSGS_COUNTER );
    }
    else
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_TEAM_REMOVE_MSGS_COUNTER );

        XomNtEvent(
            XEVENT_PRESENCE_CODE_426,
            "CSwitchboard::TeamRemoveComplete failed user=%I64X hr=0x%X",
            pCCtx->m_qwUserID,
            hr);
    }

    SAFE_RELEASE(pCCtx);

    return hr;
}

/*****************************************************************************

CSwitchboard::TeamManageMemberComplete

Callback, called when a Team Manage Member message has finished processing.

*****************************************************************************/
HRESULT CSwitchboard::TeamManageMemberComplete(CTeamManageMemberContext *pCCtx)
{
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "TeamManageMemberComplete for User %I64X hr=0x%X",
        pCCtx->m_qwUserID,
        pCCtx->m_hr);

    HRESULT hr = S_OK;

    // Send the reply
    SendTeamManageMemberReply(
            pCCtx->m_dwSeqNum,
            pCCtx->m_hr,
            pCCtx->m_pCReplyConn);

    XomTrace( TeamsLog, L_NORMAL, "TMM|%X:%X|%I64X|%I64X|%I64X|%X",
        pCCtx->m_pCReplyConn == NULL ? 0 : ntohl( pCCtx->m_pCReplyConn->GetSockAddr()->sin_addr.S_un.S_addr ),
        pCCtx->m_pCReplyConn == NULL ? 0 : ntohs( pCCtx->m_pCReplyConn->GetSockAddr()->sin_port ),
        pCCtx->m_qwTeamID,
        pCCtx->m_qwUserID,
        pCCtx->m_qwMemberID,
        hr );


    if (SUCCEEDED(hr))
    {
        g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_TEAM_MANAGE_MEMBER_MSGS_COUNTER );
    }
    else
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_TEAM_MANAGE_MEMBER_MSGS_COUNTER );

        XomNtEvent(
            XEVENT_PRESENCE_CODE_427,
            "CSwitchboard::TeamManageMemberComplete failed user=%I64X hr=0x%X",
            pCCtx->m_qwUserID,
            hr);
    }

    SAFE_RELEASE(pCCtx);

    return hr;
}

/*****************************************************************************

CSwitchboard::TeamManageTeamComplete

Callback, called when a Team Manage Team message has finished processing.

*****************************************************************************/
HRESULT CSwitchboard::TeamManageTeamComplete(CTeamManageTeamContext *pCCtx)
{
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "TeamManageTeamComplete for User %I64X hr=0x%X",
        pCCtx->m_qwUserID,
        pCCtx->m_hr);

    HRESULT hr = S_OK;

    // Send the reply
    SendTeamManageTeamReply(
            pCCtx->m_dwSeqNum,
            pCCtx->m_hr,
            pCCtx->m_pCReplyConn);

    XomTrace( TeamsLog, L_NORMAL, "TMT|%X:%X|%I64X|%I64X|%X",
        pCCtx->m_pCReplyConn == NULL ? 0 : ntohl( pCCtx->m_pCReplyConn->GetSockAddr()->sin_addr.S_un.S_addr ),
        pCCtx->m_pCReplyConn == NULL ? 0 : ntohs( pCCtx->m_pCReplyConn->GetSockAddr()->sin_port ),
        pCCtx->m_qwTeamID,
        pCCtx->m_qwUserID,
        hr );


    if (SUCCEEDED(hr))
    {
        g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_TEAM_MANAGE_TEAM_MSGS_COUNTER );
    }
    else
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_TEAM_MANAGE_TEAM_MSGS_COUNTER );

        XomNtEvent(
            XEVENT_PRESENCE_CODE_428,
            "CSwitchboard::TeamManageTeamComplete failed user=%I64X hr=0x%X",
            pCCtx->m_qwUserID,
            hr);
    }

    SAFE_RELEASE(pCCtx);

    return hr;
}

/*****************************************************************************

CSwitchboard::TeamRecruitComplete

Callback, called when a Team Recruit message has finished processing.

*****************************************************************************/
HRESULT CSwitchboard::TeamRecruitComplete(CTeamRecruitContext *pCCtx)
{
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "TeamRecruitComplete for User %I64X hr=0x%X",
        pCCtx->m_qwUserID,
        pCCtx->m_hr);

    HRESULT hr = pCCtx->m_hr;
    Q_SEND_MESSAGE_MSG sendmsg;

    // Send the reply
    SendTeamRecruitReply(
            pCCtx->m_dwSeqNum,
            pCCtx->m_hr,
            pCCtx->m_pCReplyConn);

    if( FAILED( pCCtx->m_hr ) )
    {
        goto lDone;
    }

    // Send a message to the user
    sendmsg.qwSenderID = pCCtx->m_qwUserID;
    sendmsg.qwSenderContext = pCCtx->m_qwTeamID;
    sendmsg.dwMessageFlags = pCCtx->m_dwMessageFlags;
    sendmsg.dwSenderTitleID = pCCtx->m_dwTitleID;
    sendmsg.wExpireMinutes = (WORD) g_CPresCfg.GetMessageTypeExpiration(XONLINE_MSG_TYPE_TEAM_RECRUIT-1);
    sendmsg.cbDetails = pCCtx->m_cbDetails;
    sendmsg.cRecipients = 1;
    sendmsg.bMessageType = XONLINE_MSG_TYPE_TEAM_RECRUIT;
    strncpy( sendmsg.szSenderName, pCCtx->m_szSenderName, sizeof( sendmsg.szSenderName ) );

    // Send the notifications, best effort
    SendMessageExternal(
        TRUE,
        &sendmsg,
        &pCCtx->m_qwMemberID,
        pCCtx->m_rgbDetails,
        NULL,
        NULL,
        0);

    XomTrace( TeamsLog, L_NORMAL, "TRC|%X:%X|%I64X|%I64X|%I64X|%X",
        pCCtx->m_pCReplyConn == NULL ? 0 : ntohl( pCCtx->m_pCReplyConn->GetSockAddr()->sin_addr.S_un.S_addr ),
        pCCtx->m_pCReplyConn == NULL ? 0 : ntohs( pCCtx->m_pCReplyConn->GetSockAddr()->sin_port ),
        pCCtx->m_qwTeamID,
        pCCtx->m_qwUserID,
        pCCtx->m_qwMemberID,
        hr );

lDone:
    if( SUCCEEDED( pCCtx->m_hr ) )
    {
        g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_TEAM_RECRUIT_MSGS_COUNTER );
    }
    else
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_TEAM_RECRUIT_MSGS_COUNTER );

        XomNtEvent(
            XEVENT_PRESENCE_CODE_429,
            "CSwitchboard::TeamRecruitComplete failed user=%I64X hr=0x%X",
            pCCtx->m_qwUserID,
            pCCtx->m_hr );

    }

    SAFE_RELEASE(pCCtx);

    return hr;
}

/*****************************************************************************

CSwitchboard::TeamJoinComplete

Callback, called when a Team Join message has finished processing.

*****************************************************************************/
HRESULT CSwitchboard::TeamJoinComplete(CTeamJoinContext *pCCtx)
{
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "TeamJoinComplete for User %I64X hr=0x%X",
        pCCtx->m_qwUserID,
        pCCtx->m_hr);

    HRESULT hr = pCCtx->m_hr;

    // Send the reply
    SendTeamJoinReply(
            pCCtx->m_dwSeqNum,
            pCCtx->m_hr,
            pCCtx->m_pCReplyConn);

    if( FAILED( hr ) && (hr != XONLINE_E_TEAMS_USER_ALREADY_EXISTS) )
    {
        goto lDone;
    }

    // Delete any team recruit message to the member
    Q_RECIPIENT_RESULT recipient;
    recipient.qwUserID = pCCtx->m_qwUserID;
    recipient.dwMessageID = 0; // Don't know, the sender context and message type will be used to match it

    // Clear the message from Notification, best effort
    (void) m_CXPCluster.QueueDeleteMessage(
        pCCtx->m_qwUserID,
        pCCtx->m_dwRecruitMsgID,
        pCCtx->m_bAnswer == PINVITE_REPLY_NEVER );

    XomTrace( TeamsLog, L_NORMAL, "TJN|%X:%X|%I64X|%I64X|%X",
        pCCtx->m_pCReplyConn == NULL ? 0 : ntohl( pCCtx->m_pCReplyConn->GetSockAddr()->sin_addr.S_un.S_addr ),
        pCCtx->m_pCReplyConn == NULL ? 0 : ntohs( pCCtx->m_pCReplyConn->GetSockAddr()->sin_port ),
        pCCtx->m_qwTeamID,
        pCCtx->m_qwUserID,
        hr );

lDone:
    if (SUCCEEDED(hr))
    {
        g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_TEAM_JOIN_MSGS_COUNTER );
    }
    else
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_TEAM_JOIN_MSGS_COUNTER );

        XomNtEvent(
            XEVENT_PRESENCE_CODE_430,
            "CSwitchboard::TeamJoinComplete failed user=%I64X hr=0x%X",
            pCCtx->m_qwUserID,
            hr);
    }

    SAFE_RELEASE(pCCtx);

    return hr;
}

/*****************************************************************************

CSwitchboard::TeamGetTicketComplete

Callback, called when a Team Get Ticket message has finished processing.

*****************************************************************************/
HRESULT CSwitchboard::TeamGetTicketComplete(CTeamGetTicketContext *pCCtx)
{
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "TeamGetTicketComplete for User %I64X hr=0x%X",
        pCCtx->m_qwUserID,
        pCCtx->m_hr);

    HRESULT hr = S_OK;
    P_TEAM_TICKET sTicket;

    // Fill in the ticket
    memset(&sTicket, 0, sizeof(P_TEAM_TICKET));

    // Send the reply
    SendTeamGetTicketReply(
            pCCtx->m_dwSeqNum,
            pCCtx->m_hr,
            pCCtx->m_qwUserID,
            pCCtx->m_cTeamIDs,
            pCCtx->m_rgqwTeamIDs,
            pCCtx->m_pCReplyConn);

    if (SUCCEEDED(hr))
    {
        g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_TEAM_GET_TICKET_MSGS_COUNTER );
    }
    else
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_TEAM_GET_TICKET_MSGS_COUNTER );

        XomNtEvent(
            XEVENT_PRESENCE_CODE_431,
            "CSwitchboard::TeamGetTicketComplete failed user=%I64X TitleId=0x%08X  hr=0x%X",
            pCCtx->m_qwUserID,
            pCCtx->m_dwTitleID,
            hr);
    }

    SAFE_RELEASE(pCCtx);

    return hr;
}

/*****************************************************************************

CSwitchboard::Announce

(Re)Announces a given user has come online on a presence server (including
local) with their relevent buddies.  If the buddy is online, they are expected
to send the appropriate notifications and a subscribed back.

*****************************************************************************/
HRESULT CSwitchboard::Announce(
    QWORD qwDestUserID,
    DWORD dwTitleID,
    LPCSTR pszGamerTag,
    DWORD cSourceUserIDs,
    QWORD *rgqwSourceUserIDs)
{
    HRESULT hr = S_OK;
    DWORD dwSourceIndex;
    CPresence *pCSourcePresence;
    DWORD cSubscribedIDs = 0;
    QWORD rgqwSubscribedIDs[MAX_BUDDIES];

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Announce: Dest=%I64X TitleId=0x%08X Numsrc=%d src0=%I64X",
        qwDestUserID,
        dwTitleID,
        cSourceUserIDs,
        rgqwSourceUserIDs[0]);

    QWORD *rgForwardIDs = NULL;
    DWORD cForwardIDs = 0;
    CAnnounceContext *pCallerCtx = NULL;

    for (DWORD iPreScan = 0; iPreScan < cSourceUserIDs; iPreScan++)
    {
        hr = g_CPresenceUserIndex.FindPresence(rgqwSourceUserIDs[iPreScan], &pCSourcePresence);
        SAFE_RELEASE(pCSourcePresence);
        if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
        {
            // swap the deferring user to the front
            QWORD qwFirst = rgqwSourceUserIDs[0];
            rgqwSourceUserIDs[0] = rgqwSourceUserIDs[iPreScan];
            rgqwSourceUserIDs[iPreScan] = qwFirst;

            goto lDone;
        }
        else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
        {
            cForwardIDs++;
        }
    }
    hr = S_OK;

    pCallerCtx = new CAnnounceContext;
    if (pCallerCtx == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    if (cForwardIDs > 0)
    {
        rgForwardIDs = new QWORD[cForwardIDs];
        if (rgForwardIDs == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto lDone;
        }
        cForwardIDs = 0;
    }

    pCallerCtx->cSourceUserIDs = cSourceUserIDs;
    pCallerCtx->dwPendingLoads = 0;
    pCallerCtx->dwTitleID = dwTitleID;
    pCallerCtx->qwDestUserID = qwDestUserID;
    pCallerCtx->rgqwSourceUserIDs = new QWORD[cSourceUserIDs];
    if (pCallerCtx->rgqwSourceUserIDs == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }
    memcpy(pCallerCtx->rgqwSourceUserIDs, rgqwSourceUserIDs, cSourceUserIDs * sizeof(QWORD));
    memcpy(pCallerCtx->szGamerTag, pszGamerTag, XONLINE_GAMERTAG_SIZE);

    // For each source (buddy)
    for (dwSourceIndex = 0; dwSourceIndex < cSourceUserIDs; dwSourceIndex++)
    {
        HRESULT hrInner = S_OK;

        // If the source is online
        hrInner = g_CPresenceUserIndex.FindPresence(rgqwSourceUserIDs[dwSourceIndex], &pCSourcePresence );

        if (pCSourcePresence == NULL)
        {
            // first make sure this user hasnt been migrated.
            if (hrInner == XONLINE_E_PRESENCE_USER_MIGRATED)
            {
                // add this user to the forwarding list.
                rgForwardIDs[cForwardIDs] = rgqwSourceUserIDs[dwSourceIndex];
                cForwardIDs++;
                continue;
            }

            CLoadOfflinePresenceContext *pCCtx = new CLoadOfflinePresenceContext(this, &m_CProfileStore);
            if (pCCtx == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto lDone;
            }

            pCallerCtx->dwPendingLoads++;
            pCCtx->m_pCaller = pCallerCtx;
            pCCtx->m_qwUserID = rgqwSourceUserIDs[dwSourceIndex];

            hr = m_CProfileStore.SendToSqlThread(pCCtx);
        }
        else
        {
            if (pCSourcePresence->IsOnline())
            {
                // Mark them as subscribed to the destination
                hr = pCSourcePresence->SubscribeBuddy(qwDestUserID);
                if (FAILED(hr))
                {
                    XomNtEvent(
                        XEVENT_PRESENCE_CODE_432,
                        "CSwitchboard::Announce: pCSourcePresence->SubscribeBuddy failed dest=%I64X numsrc=%d src0=%I64X hr=0x%X",
                        qwDestUserID,
                        cSourceUserIDs,
                        rgqwSourceUserIDs[0],
                        hr);
                }

                // Add them to the subscribed list
                rgqwSubscribedIDs[cSubscribedIDs] = pCSourcePresence->GetUserID();
                SET_PUID_CLIENT_TYPE(rgqwSubscribedIDs[cSubscribedIDs], (pCSourcePresence->CanClientConsumeRichPresence() ? PRES_CLIENT_TYPE_XENON : PRES_CLIENT_TYPE_XBOX));
                SET_PUID_CLIENT_BETA(rgqwSubscribedIDs[cSubscribedIDs], (pCSourcePresence->CanClientIgnoreFriendStateNotifications() ? 1 : 0));
                cSubscribedIDs++;
            }

            // queue presence even if online.  but dont send if the user has never been online.
            if (pCSourcePresence->GetLastSeenTitleID() != 0)
            {
                // Send a notification of our state
                hr = m_CXPCluster.QueuePresence(pCSourcePresence, &qwDestUserID, 1);
            }

        }

        SAFE_RELEASE(pCSourcePresence);
    }

    // Send the subscribed list back
    if (cSubscribedIDs > 0)
    {
        hr = m_CXPCluster.SendMsgSubscribed(GET_PUID_BITS(qwDestUserID), cSubscribedIDs, rgqwSubscribedIDs);
    }

    if (cForwardIDs > 0)
    {
        hr = m_CXPCluster.SendMsgAnnounce(
            qwDestUserID,
            dwTitleID,
            pszGamerTag,
            cForwardIDs,
            rgForwardIDs,
            TRUE);
    }

    // only finalize if no loads were scheduled.  otherwise the last load will trigger this.
    if (pCallerCtx->dwPendingLoads == 0)
    {
        pCallerCtx->Finalize();
    }

    // Ignore failures to send to notification, logged at lower layer
    hr = S_OK;

lDone:

    // this check is weird.  basically the ony way we get here is if the alloc for the qword array fails.
    // i just want to make sure the context gets deleted.
    if (FAILED(hr) && pCallerCtx)
    {
        pCallerCtx->Finalize();
    }

    SAFE_ARRAYDELETE(rgForwardIDs);

    return hr;
}

/*****************************************************************************

CSwitchboard::Subscribed

Response to an announce message specifing the online sources (buddies) from
the annouce request.  This should trigger the appropriate notifications to be
sent to the online buddy.

*****************************************************************************/
HRESULT CSwitchboard::Subscribed(
    QWORD qwDestUserID,
    DWORD cSourceUserIDs,
    const QWORD *rgqwSourceUserIDs)
{
    HRESULT hr = S_OK;
    DWORD dwSourceIndex;
    CPresence *pCDestPresence;

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Subscribed: Dest=%I64X Numsrc=%d src0=%I64X",
        qwDestUserID,
        cSourceUserIDs,
        rgqwSourceUserIDs[0]);

    // Punt if the destination is no longer online
    // CONSIDER: Send an unsubscribe?  For now I'll assume it was already sent
    hr = g_CPresenceUserIndex.FindPresence(qwDestUserID, &pCDestPresence );
    if (pCDestPresence == NULL)
    {
        goto lDone;
    }
    else if (!(pCDestPresence->IsOnline()))
    {
        hr = HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
        goto lDone;
    }

     // For each source (buddy)
    for (dwSourceIndex = 0; dwSourceIndex < cSourceUserIDs; dwSourceIndex++)
    {
        // Mark them as subscribed
        hr = pCDestPresence->SubscribeBuddy(rgqwSourceUserIDs[dwSourceIndex]);
        if (FAILED(hr))
        {
            XomNtEvent(
                XEVENT_PRESENCE_CODE_433,
                "CSwitchboard::Subscribed: pCDestPresence->SubscribeBuddy failed dest=%I64X numsrc=%d src0=%I64X hr=0x%X",
                qwDestUserID,
                cSourceUserIDs,
                rgqwSourceUserIDs[0],
                hr);
        }
    }

    // Send a notification of our state
    hr = m_CXPCluster.QueuePresence(pCDestPresence, rgqwSourceUserIDs, cSourceUserIDs);

    // Ignore failures to send to notification, logged at lower layer
    hr = S_OK;

lDone:

    SAFE_RELEASE(pCDestPresence);

    return hr;
}

/*****************************************************************************

CSwitchboard::Unsubscribe

A given user is offline, stop sending them notifications

*****************************************************************************/
HRESULT CSwitchboard::Unsubscribe(
    QWORD qwSourceUserID,
    DWORD cDestUserIDs,
    QWORD *rgqwDestUserIDs)
{
    HRESULT hr = S_OK;
    DWORD dwDestIndex;
    CPresence *pCDestPresence;

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Unsubscribe: Src=%I64X Numdest=%d dest0=%I64X",
        qwSourceUserID,
        cDestUserIDs,
        rgqwDestUserIDs[0]);

    QWORD *rgForwardIDs = NULL;
    DWORD cForwardIDs = 0;

    for (DWORD iPreScan = 0; iPreScan < cDestUserIDs; iPreScan++)
    {
        hr = g_CPresenceUserIndex.FindPresence(rgqwDestUserIDs[iPreScan], &pCDestPresence);
        SAFE_RELEASE(pCDestPresence);
        if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
        {
            // swap the deferring user to the front
            QWORD qwFirst = rgqwDestUserIDs[0];
            rgqwDestUserIDs[0] = rgqwDestUserIDs[iPreScan];
            rgqwDestUserIDs[iPreScan] = qwFirst;

            goto lDone;
        }
        else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
        {
            cForwardIDs++;
        }
    }
    hr = S_OK;

    if (cForwardIDs > 0)
    {
        rgForwardIDs = new QWORD[cForwardIDs];
        if (rgForwardIDs == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto lDone;
        }
        cForwardIDs = 0;
    }

    // For each destination (buddy)
    for (dwDestIndex = 0; dwDestIndex < cDestUserIDs; dwDestIndex++)
    {
        HRESULT hrInner = S_OK;

        // If the destination is online
        hrInner = g_CPresenceUserIndex.FindPresence(rgqwDestUserIDs[dwDestIndex], &pCDestPresence );
        if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
        {
            // add this user to the forwarding list.
            rgForwardIDs[cForwardIDs] = rgqwDestUserIDs[dwDestIndex];
            cForwardIDs++;
            continue;
        }

        if ((pCDestPresence != NULL) && pCDestPresence->IsOnline())
        {
            // Mark them as unsubscribed to the source
            hrInner = pCDestPresence->UnsubscribeBuddy(qwSourceUserID);

            if (FAILED(hr))
            {
                XomNtEvent(
                    XEVENT_PRESENCE_CODE_434,
                    "CSwitchboard::Unsubscribe: pCDestPresence->UnsubscribeBuddy failed src=%I64X numdest=%d dest0=%I64X hr=0x%X",
                    qwSourceUserID,
                    cDestUserIDs,
                    rgqwDestUserIDs[0],
                    hrInner);
            }
        }

        SAFE_RELEASE(pCDestPresence);
    }

    if (cForwardIDs > 0)
    {
        hr = m_CXPCluster.SendMsgUnsubscribe(qwSourceUserID, cForwardIDs, rgForwardIDs, TRUE);
    }

lDone:

    SAFE_ARRAYDELETE(rgForwardIDs);

    return hr;
}

/*****************************************************************************

CSwitchboard::Added

The given buddy was added to the given user's buddy list.

*****************************************************************************/
HRESULT CSwitchboard::Added(
    QWORD qwUserID,
    QWORD qwBuddyID,
    DWORD dwVersion,
    WORD cbBuddyAcctName,
    LPCSTR szBuddyAcctName)
{
    HRESULT hr;
    CPresence *pCPresence = NULL;

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Added: User=%I64X Buddy=%I64X Ver=%d Acct=%s",
        qwUserID,
        qwBuddyID,
        dwVersion,
        (cbBuddyAcctName > 0) ?  szBuddyAcctName : "");

    // Get the user's presence information
    hr = g_CPresenceUserIndex.FindPresence(qwUserID, &pCPresence );
    if (FAILED(hr) && (hr != HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER)))
    {
        goto lDone;
    }

    // If we have a record for them
    if( pCPresence != NULL )
    {
        // Update the internal list
        hr = pCPresence->AddBuddy(
            qwBuddyID,
            P_BUDDY_STATUS_REQUEST,
            dwVersion);

        // If they are online
        if(pCPresence->IsOnline())
        {
            // Post the change to the buddy's notifcation queue
            hr = m_CXPCluster.QueueListChange(
                qwUserID,
                dwVersion,
                qwBuddyID,
                PLIST_BUDDY_ADDED,
                S_OK,
                cbBuddyAcctName,
                szBuddyAcctName);
            if (FAILED(hr))
            {
                // Log and continue
                XomNtEvent(XEVENT_PRESENCE_CODE_435, "Failure to enqueue added list change item UserID=%I64X hr=0x%X", qwUserID, hr);
                hr = S_OK;
            }
        }
    }

lDone:

    SAFE_RELEASE(pCPresence);

    return hr;
}

/*****************************************************************************

CSwitchboard::Accepted

The given buddy was accepted to the given user's buddy list.

*****************************************************************************/
HRESULT CSwitchboard::Accepted(
    QWORD qwUserID,
    QWORD qwBuddyID,
    DWORD dwVersion,
    WORD cbBuddyAcctName,
    LPCSTR szBuddyAcctName)
{
    HRESULT hr;
    CPresence *pCPresence = NULL;

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Accepted: User=%I64X Buddy=%I64X Ver=%d",
        qwUserID,
        qwBuddyID,
        dwVersion);

    // Get the user's presence information
    hr = g_CPresenceUserIndex.FindPresence(qwUserID, &pCPresence );
    if (FAILED(hr) && (hr != HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER)))
    {
        goto lDone;
    }

    // If they are online
    if(pCPresence != NULL)
    {
        // Update the internal list
        hr = pCPresence->AddBuddy(
            qwBuddyID,
            P_BUDDY_STATUS_OK,
            dwVersion);

        // If they are online
        if(pCPresence->IsOnline())
        {
            // Post the change to the buddy's notifcation queue
            hr = m_CXPCluster.QueueListChange(
                qwUserID,
                dwVersion,
                GET_PUID_BITS(qwBuddyID),
                PLIST_BUDDY_ACCEPT,
                S_OK,
                cbBuddyAcctName,
                szBuddyAcctName);
            if (FAILED(hr))
            {
                // Log and continue
                XomNtEvent(XEVENT_PRESENCE_CODE_436, "Failure to enqueue accept list change item UserID=%I64X hr=0x%X", qwUserID, hr);
                hr = S_OK;
            }

            // Announce is implied
            hr = Announce(
                    qwBuddyID,
                    0,
                    "",
                    1,
                    &qwUserID);

        }
    }

lDone:

    SAFE_RELEASE(pCPresence);

    return hr;
}

/*****************************************************************************

CSwitchboard::Removed

The given buddy was removed from the given user's buddy list (either a reject
or delete.)

*****************************************************************************/
HRESULT CSwitchboard::Removed(
    QWORD qwUserID,
    QWORD qwBuddyID,
    DWORD dwVersion)
{
    HRESULT hr;
    CPresence *pCPresence = NULL;

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Removed: User=%I64X Buddy=%I64X Ver=%d",
        qwUserID,
        qwBuddyID,
        dwVersion);

    // Get the user's presence information
    hr = g_CPresenceUserIndex.FindPresence(qwUserID, &pCPresence );
    if (FAILED(hr) && (hr != HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER)))
    {
        goto lDone;
    }

    // If they are online
    if(pCPresence != NULL)
    {
        // Update the internal list
        hr = pCPresence->RemoveBuddy(qwBuddyID, dwVersion);

        // If they are online
        if(pCPresence->IsOnline())
        {
            // Post the change to the buddy's notifcation queue
            hr = m_CXPCluster.QueueListChange(
                qwUserID,
                dwVersion,
                qwBuddyID,
                PLIST_BUDDY_DELETE,
                S_OK,
                0,
                "");
            if (FAILED(hr))
            {
                // Log and continue
                XomNtEvent(XEVENT_PRESENCE_CODE_437, "Failure to enqueue delete list change item UserID=%I64X hr=0x%X", qwUserID, hr);
                hr = S_OK;
            }

            // Unsubscribe is implied, but moot because the buddy record was already removed
        }
    }

lDone:

    SAFE_RELEASE(pCPresence);

    return hr;
}

/*****************************************************************************

CSwitchboard::InviteAnswerPeer

The given user answered the given host's message.  Used to pass on no answers
so the invitation is not reposted.

*****************************************************************************/
HRESULT CSwitchboard::InviteAnswerPeer(
    QWORD qwUserID,
    QWORD qwHostID,
    QWORD qwMatchSessionID,
    WORD wAnswer)
{
    HRESULT hr = S_OK;
    CPresence *pCPresence = NULL;
    CInvitation *pCInvite = NULL;

    // See if the host is around
    hr = g_CPresenceUserIndex.FindPresence(qwHostID, &pCPresence );
    if (FAILED(hr) && (hr != HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER)))
    {
        goto lDone;
    }

    if((pCPresence != NULL) &&
        (pCPresence->HasOnlineRecord()))
    {
        pCInvite = pCPresence->GetInvite();

        // Validate the message's match session id against the users's
        if ((pCInvite != NULL) && (qwMatchSessionID == pCInvite->qwMatchSessionID))
        {
            // Try to remove us from the invitee list since it was answered
            hr = pCPresence->RemoveInvitee(qwUserID);
        }
    }

lDone:

    SAFE_RELEASE(pCPresence);

    return hr;
}

/*****************************************************************************

CSwitchboard::AliveStoreComplete

Callback, called when an Alive message has finished processing store logic.

*****************************************************************************/
void CSwitchboard::AliveStoreComplete(CAliveContext *pCCtx)
{
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "AliveStoreComplete for User %I64X hrStore=0x%X Buddies=%d Ver=%d Blocks=%d Ver=%d",
        pCCtx->m_qwUserID,
        pCCtx->m_hrStore,
        pCCtx->m_cBuddies,
        pCCtx->m_dwBuddyListVersion,
        pCCtx->m_cBlocks,
        pCCtx->m_dwBlockListVersion);

    DWORD dwWelcomeMessage = 0;
    HRESULT hr = S_OK;
    CTCPCntVarBuffer *pCAliveReplyBuffer = NULL;
    P_ALIVE_REPLY_MSG *pmsgAliveReply = NULL;

    // See if the record for the user is current
    if( (pCCtx->m_pCPresence == NULL) || (memcmp(&(pCCtx->m_sgaddr), pCCtx->m_pCPresence->GetSGAddr(), sizeof(SGADDR)) != 0))
    {
        // For diagnosing bug 24004
        if (pCCtx->m_pCPresence == NULL)
        {
            XomTrace(
                PresenceDebug,
                L_ERROR,
                "CSwitchboard::AliveStoreComplete matching presence record not found user=%I64X name=%s TitleId=0x%08X  hr=0x%X",
                pCCtx->m_qwUserID,
                pCCtx->m_szAccountName,
                pCCtx->m_dwTitleID,
                hr);

                hr = HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
        }
        else
        {
            XomTrace(
                PresenceDebug,
                L_ERROR,
                "CSwitchboard::AliveStoreComplete presence record does not match user=%I64X name=%s TitleId=0x%08X  hr=0x%X",
                pCCtx->m_qwUserID,
                pCCtx->m_szAccountName,
                pCCtx->m_dwTitleID,
                hr);

                hr = XONLINE_E_SERVER_ERROR;
        }

        goto lDone;
    }

    // Check the Store operation for failure
    hr = pCCtx->m_hrStore;
    if (FAILED(hr))
    {
        goto lDone;
    }

    // #18799: Only set these in the Presence record if we loaded them from the DB
    //  if we shortcircuited because of the cache, leave these alone.
    if (pCCtx->m_fWentToStore)
    {
        pCCtx->m_pCPresence->SetPrivileges(pCCtx->m_rgbPrivileges);
    }

    // Put the results into the presence record
    pCCtx->m_pCPresence->UpdateBuddyListVersion(pCCtx->m_dwBuddyListVersion);
    pCCtx->m_pCPresence->UpdateBlockListVersion(pCCtx->m_dwBlockListVersion);

    // Update Web Info
    if (pCCtx->m_qwUserWebID != 0)
    {
        pCCtx->m_pCPresence->SetWebID(pCCtx->m_qwUserWebID);
    }

    if (pCCtx->m_rgCBuddyList != NULL)
    {
        hr = pCCtx->m_pCPresence->SetBuddyList(
            pCCtx->m_cBuddies,
            pCCtx->m_dwBuddyListVersion,
            pCCtx->m_rgCBuddyList
            );

        // Presence object owns the list now
        pCCtx->m_rgCBuddyList = NULL;
        if (FAILED(hr))
        {
            goto lDone;
        }
    }

    // If we have new never list data from the store, update the in-memory never list
    if( 0 != pCCtx->m_cNeverList &&
        NULL != pCCtx->m_pqwNeverList )
    {
        pCCtx->m_pCPresence->SetNeverList(
            pCCtx->m_cNeverList,
            pCCtx->m_pqwNeverList );

        // Presence object owns the list now
        pCCtx->m_pqwNeverList = NULL;
    }

    // If the user has transient messages, let Presence know that
    if( 0 != pCCtx->m_pCPresence->GetQueue( PQUEUE_TRANSIENT_MSGS )->GetLength() )
    {
        pCCtx->m_hrUserInfo = XONLINE_S_LOGON_USER_MESSAGE_ENUMERATION_NEEDED;
    }
    else
    {
        pCCtx->m_hrUserInfo = S_OK;
    }

    // Init user's state
    pCCtx->m_pCPresence->SetState(
        P_STATE_MASK_ONLINE | P_STATE_MASK_CLOAKED,
        pCCtx->m_dwTitleID,
        0,
        0,
        NULL,
        0,
        NULL,
        0,
        NULL,
        0xFFFFFFFF);

    // Subscribe to all our buddies
    hr = AnnounceToAllBuddies(pCCtx->m_pCPresence);
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Is this the first time that the user has been on this console?
    if (pCCtx->m_dwFirstLogon == XONLINE_PRESENCE_LOGON_FIRST_TIME_CONSOLE)
    {
        dwWelcomeMessage = g_CPresCfg.GetWelcomeToNewConsoleMessage();
    }

    // Is this the first time that the user has been on the service?
    else if (pCCtx->m_dwFirstLogon == XONLINE_PRESENCE_LOGON_FIRST_TIME_LIVE)
    {
        dwWelcomeMessage = g_CPresCfg.GetWelcomeToXboxLiveMessage();
    }

    // Do we need to send a welcome message at all?
    if (dwWelcomeMessage != 0)
    {
        hr = SendWelcomeMessage( pCCtx->m_qwUserID, dwWelcomeMessage );
        if (FAILED(hr))
        {
            goto lDone;
        }
    }

    // Send an ALIVE response
    pCAliveReplyBuffer = g_pBufferPool->GetBuffer(sizeof(P_ALIVE_REPLY_MSG));
    if (pCAliveReplyBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pmsgAliveReply = (P_ALIVE_REPLY_MSG *) pCAliveReplyBuffer->GetBuffer();

    pmsgAliveReply->dwMsgType = PMSG_ALIVE_REPLY;
    pmsgAliveReply->dwMsgLen = sizeof(P_ALIVE_REPLY_MSG) - sizeof(BASE_MSG_HEADER);
    if (pCCtx->m_pCReplyBuddies != NULL)
    {
        pmsgAliveReply->dwMsgLen += pCCtx->m_pCReplyBuddies->GetBufferLength();
    }
    if (pCCtx->m_pCReplyBlocks != NULL)
    {
        pmsgAliveReply->dwMsgLen += pCCtx->m_pCReplyBlocks->GetBufferLength();
    }
    pmsgAliveReply->dwSeqNum = pCCtx->m_dwSeqNum;
    pmsgAliveReply->sgaddr = sgaddrIgnore;
    if (pCCtx->m_hrStore == XONLINE_S_LOGON_USER_HAS_MESSAGE)
    {
        pmsgAliveReply->hr = XONLINE_S_LOGON_USER_HAS_MESSAGE;
    }
    else if (pCCtx->m_hrStore == XONLINE_S_LOGON_USER_MESSAGE_ENUMERATION_NEEDED)
    {
        pmsgAliveReply->hr = XONLINE_S_LOGON_USER_MESSAGE_ENUMERATION_NEEDED;
    }
    else if (pCCtx->m_hrUserInfo == XONLINE_S_LOGON_USER_MESSAGE_ENUMERATION_NEEDED)
    {
        pmsgAliveReply->hr = XONLINE_S_LOGON_USER_MESSAGE_ENUMERATION_NEEDED;
    }
    else
    {
        pmsgAliveReply->hr = S_OK;
    }
    pmsgAliveReply->dwBuddyListVersion = pCCtx->m_dwBuddyListVersion;
    if (pCCtx->m_pCReplyBuddies != NULL)
    {
        pmsgAliveReply->cBuddiesSent = (WORD) pCCtx->m_cBuddies;
    }
    else
    {
        pmsgAliveReply->cBuddiesSent = 0;
    }
    pmsgAliveReply->dwBlockListVersion = pCCtx->m_dwBlockListVersion;
    if (pCCtx->m_pCReplyBlocks != NULL)
    {
        pmsgAliveReply->cBlocksSent = (WORD) pCCtx->m_cBlocks;
    }
    else
    {
        pmsgAliveReply->cBlocksSent = 0;
    }

    pCCtx->m_pCReplyConn->Send(pCAliveReplyBuffer);

    if (pCCtx->m_pCReplyBuddies != NULL)
    {
        pCCtx->m_pCReplyConn->Send(pCCtx->m_pCReplyBuddies);
    }

    if (pCCtx->m_pCReplyBlocks != NULL)
    {
        pCCtx->m_pCReplyConn->Send(pCCtx->m_pCReplyBlocks);
    }

lDone:

    if (SUCCEEDED(hr))
    {
        g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_ALIVE_MSGS_COUNTER );
    }
    else
    {
        if ((hr == XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT) ||
            (hr == XONLINE_E_NOTIFICATION_FLUSH_TICKETS))
        {
            g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_ALIVE_MSGS_COUNTER );
        }
        else
        {
            g_Counters.TrackFailureMessage( XPPERF_SERVER_ALIVE_MSGS_COUNTER );

            XomNtEvent(
                XEVENT_PRESENCE_CODE_438,
                "CSwitchboard::AliveStoreComplete failed user=%I64X name=%s TitleId=0x%08X  hr=0x%X",
                pCCtx->m_qwUserID,
                pCCtx->m_szAccountName,
                pCCtx->m_dwTitleID,
                hr);
        }

        // unsuccessful login.
        pCCtx->m_pCPresence->SetOffline();

        if (hr == XONLINE_E_USER_NOT_PRESENT)
        {
            // this user doesnt exist.  delete the base record we created.
            g_CPresenceUserIndex.RemovePresence(pCCtx->m_pCPresence);
        }

        SendEmptyAliveReply( pCCtx->m_dwSeqNum, hr, 0, 0, pCCtx->m_pCReplyConn );
    }

    SAFE_RELEASE(pCCtx);
    SAFE_RELEASE(pCAliveReplyBuffer);
}

/*****************************************************************************

CSwitchboard::SyncComplete

Callback, called when a Sync message has finished processing.

*****************************************************************************/
HRESULT CSwitchboard::SyncComplete(CSyncContext *pCCtx)
{
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "SyncComplete for User %I64X hr=0x%X Buddies=%d Ver=%d Blocks=%d Ver=%d",
        pCCtx->m_qwUserID,
        pCCtx->m_hr,
        pCCtx->m_cBuddies,
        pCCtx->m_dwBuddyListVersion,
        pCCtx->m_cBlocks,
        pCCtx->m_dwBlockListVersion);

    HRESULT hr = S_OK;
    CTCPCntVarBuffer *pCSyncReplyBuffer = NULL;
    P_SYNC_REPLY_MSG *pmsgSyncReply = NULL;

    // Check the operation for failure
    hr = pCCtx->m_hr;
    if (FAILED(hr))
    {
        goto lDone;
    }

    delete[] pCCtx->m_rgCBuddyList;
    pCCtx->m_rgCBuddyList = NULL;

    // Send a SYNC response
    pCSyncReplyBuffer = g_pBufferPool->GetBuffer(sizeof(P_SYNC_REPLY_MSG));
    if (pCSyncReplyBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pmsgSyncReply = (P_SYNC_REPLY_MSG *) pCSyncReplyBuffer->GetBuffer();

    pmsgSyncReply->dwMsgType = PMSG_SYNC_REPLY;
    pmsgSyncReply->dwMsgLen = sizeof(P_SYNC_REPLY_MSG) - sizeof(BASE_MSG_HEADER);
    if (pCCtx->m_pCReplyBuddies != NULL)
    {
        pmsgSyncReply->dwMsgLen += pCCtx->m_pCReplyBuddies->GetBufferLength();
    }
    if (pCCtx->m_pCReplyBlocks != NULL)
    {
        pmsgSyncReply->dwMsgLen += pCCtx->m_pCReplyBlocks->GetBufferLength();
    }
    pmsgSyncReply->dwSeqNum = pCCtx->m_dwSeqNum;
    pmsgSyncReply->sgaddr = sgaddrIgnore;
    pmsgSyncReply->hr = S_OK;
    pmsgSyncReply->dwBuddyListVersion = pCCtx->m_dwBuddyListVersion;
    pmsgSyncReply->cBuddiesSent = (WORD) pCCtx->m_cBuddies;
    pmsgSyncReply->dwBlockListVersion = pCCtx->m_dwBlockListVersion;
    pmsgSyncReply->cBlocksSent = (WORD) pCCtx->m_cBlocks;

    pCCtx->m_pCReplyConn->Send(pCSyncReplyBuffer);

    if (pCCtx->m_pCReplyBuddies != NULL)
    {
        pCCtx->m_pCReplyConn->Send(pCCtx->m_pCReplyBuddies);
    }

    if (pCCtx->m_pCReplyBlocks != NULL)
    {
        pCCtx->m_pCReplyConn->Send(pCCtx->m_pCReplyBlocks);
    }

lDone:

    if( SUCCEEDED(hr) )
    {
        g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_SYNC_MSGS_COUNTER );
    }
    else
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_SYNC_MSGS_COUNTER );

        XomNtEvent(XEVENT_PRESENCE_CODE_439, "CSwitchboard::SyncComplete failed hr=0x%X", hr);

        SendErrorSyncReply( pCCtx->m_dwSeqNum, hr, pCCtx->m_pCReplyConn );
    }

    SAFE_RELEASE(pCCtx);
    SAFE_RELEASE(pCSyncReplyBuffer);

    return hr;
}


/*****************************************************************************

CSwitchboard::AddBuddyComplete

Callback, called when an Add message has finished processing.

*****************************************************************************/
HRESULT CSwitchboard::AddBuddyComplete(CAddBuddyContext *pCCtx)
{
    XOMASSERT(pCCtx != NULL);

    HRESULT hr;
    Q_SEND_MESSAGE_MSG sendmsg;

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "AddBuddyComplete for User %I64X (%s) ver=%d Buddy %I64X (%s) ver=%d  hr=0x%X",
        pCCtx->m_qwUserID,
        pCCtx->m_szUserAccountName,
        pCCtx->m_dwUserBuddyListVersion,
        pCCtx->m_qwBuddyID,
        pCCtx->m_szBuddyAccountName,
        pCCtx->m_dwBuddyBuddyListVersion,
        pCCtx->m_hr);

    // Post back the result to the user's notifcation queue
    hr = m_CXPCluster.QueueListChange(
        pCCtx->m_qwUserID,
        pCCtx->m_dwUserBuddyListVersion,
        pCCtx->m_qwBuddyID,
        PLIST_BUDDY_ADD,
        pCCtx->m_hr,
        (WORD) pCCtx->m_cbBuddyAccountName,
        pCCtx->m_szBuddyAccountName);
    if (FAILED(hr))
    {
        // Log and continue
        XomNtEvent(XEVENT_PRESENCE_CODE_440, "Failure to enqueue add list change item UserID=%I64X hr=0x%X", pCCtx->m_qwUserID, hr);
        hr = S_OK;
    }

    // Check the operation for failure
    hr = pCCtx->m_hr;
    if (FAILED(hr))
    {
        goto lDone;
    }

    sendmsg.qwSenderID = pCCtx->m_qwUserID;
    sendmsg.qwSenderContext = 0;
    sendmsg.dwMessageFlags = pCCtx->m_dwMessageFlags;
    sendmsg.dwSenderTitleID = pCCtx->m_dwTitleID;
    sendmsg.wExpireMinutes = (WORD) g_CPresCfg.GetMessageTypeExpiration(XONLINE_MSG_TYPE_FRIEND_REQUEST-1);
    sendmsg.cbDetails = pCCtx->m_cbDetails;
    sendmsg.cRecipients = 1;
    sendmsg.bMessageType = XONLINE_MSG_TYPE_FRIEND_REQUEST;
    strncpy( sendmsg.szSenderName, pCCtx->m_szUserAccountName, sizeof( sendmsg.szSenderName ) );

    // Send the message component
    hr = SendMessageExternal(
            TRUE,
            &sendmsg,
            &pCCtx->m_qwBuddyID,
            pCCtx->m_rgbDetails,
            NULL,
            NULL,
            0);
    if (FAILED(hr))
    {
        // Log and continue
        XomNtEvent(XEVENT_PRESENCE_CODE_441, "Failure to send friend request message UserID=%I64X hr=0x%X", pCCtx->m_qwUserID, hr);
        hr = S_OK;
    }

    // Update the user's internal record if they are online
    if( pCCtx->m_pCPresence != NULL )
    {
        hr = pCCtx->m_pCPresence->AddBuddy(
            pCCtx->m_qwBuddyID,
            P_BUDDY_STATUS_PENDING,
            pCCtx->m_dwUserBuddyListVersion);
        if (FAILED(hr))
        {
            goto lDone;
        }
    }

    // If successfull, tell our buddy
    hr = m_CXPCluster.SendMsgAdded(
        pCCtx->m_qwBuddyID,
        pCCtx->m_qwUserID,
        pCCtx->m_dwBuddyBuddyListVersion,
        (WORD) pCCtx->m_cbUserAccountName,
        pCCtx->m_szUserAccountName);

    // Best effort on non-perstistant record keeping
    hr = S_OK;

lDone:

    if( SUCCEEDED(hr) ||
        (hr == HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER)) || // mistyped name
        (hr == HRESULT_FROM_WIN32(ERROR_USER_EXISTS)) || // already a friend
        (hr == DB_E_INTEGRITYVIOLATION) || // dtc rollback
        (hr == XONLINE_E_NOTIFICATION_BLOCKED) || // never list
        (hr == XONLINE_E_NOTIFICATION_LIST_FULL) || // full list
        (hr == XONLINE_E_NOTIFICATION_OTHER_LIST_FULL)) // other list is full
    {
        g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_ADD_MSGS_COUNTER );
    }
    else
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_ADD_MSGS_COUNTER );

        XomNtEvent(
            XEVENT_PRESENCE_CODE_442,
            "CSwitchboard::AddBuddyComplete failed user=%I64X buddy=%I64X hr=0x%X",
            pCCtx->m_qwUserID,
            pCCtx->m_qwBuddyID,
            hr);
    }

    SAFE_RELEASE(pCCtx);

    return S_OK;
}

/*****************************************************************************

CSwitchboard::CheckTitleMessagesComplete

*****************************************************************************/
HRESULT CSwitchboard::CheckTitleMessagesComplete(CCheckTitleMessagesContext *pCCtx)
{
    XOMASSERT(pCCtx != NULL);

    HRESULT hr;

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "CheckTitleMessagesComplete for User=%I64X TitleId=0x%08X hr=0x%X",
        pCCtx->m_pAliveCtx->m_qwUserID,
        pCCtx->m_pAliveCtx->m_dwTitleID,
        pCCtx->m_hr);

    hr = SendCheckTitleMessagesReply(pCCtx->m_dwSeqNum, pCCtx->m_hr, pCCtx->m_pCReplyConn);

    if (FAILED(hr))
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_443,
            "SendCheckTitleMessagesReply failed for user %I64X, hr = 0x%X",
            pCCtx->m_pAliveCtx->m_qwUserID,
            hr);
    }

    SAFE_RELEASE(pCCtx);

    return S_OK;
}



/*****************************************************************************

CSwitchboard::IsAffiliateComplete

Callback, called when an IsAffiliate message has finished processing.

*****************************************************************************/
HRESULT CSwitchboard::IsAffiliateComplete(CIsAffiliateContext *pCCtx)
{
    XOMASSERT(pCCtx != NULL);

    HRESULT hr;
    DWORD dwListFlags = 0;

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "IsAffiliateComplete for User=%I64X Affiliate=%I64X; hr=0x%X",
        pCCtx->m_qwUserID,
        pCCtx->m_qwAffiliateID,
        pCCtx->m_hr);

    if (FAILED(pCCtx->m_hr))
    {
        goto lDone;
    }

    XOMASSERT(pCCtx->m_pCPresence != NULL);
    if( pCCtx->m_pCPresence == NULL )
    {
        XomNtEvent(XEVENT_PRESENCE_CODE_444, "NULL presence record found requesting user %I64X", pCCtx->m_qwUserID);
        hr = E_INVALIDARG;
        goto lCleanup;
    }

    if (pCCtx->m_pCPresence->IsAffiliatesListLoaded() == FALSE)
    {
        pCCtx->m_pCPresence->SetAffiliates(pCCtx->m_prgAffiliateLists);

        // presence owns these now.
        pCCtx->m_prgAffiliateLists = NULL;
    }

    pCCtx->m_hr = pCCtx->m_pCPresence->IsUserAffiliate(
        pCCtx->m_qwAffiliateID,
        &dwListFlags);

lDone:

    hr = SendIsAffiliateReply(
        pCCtx->m_dwSeqNum,
        pCCtx->m_hr,
        pCCtx->m_qwAffiliateID,
        dwListFlags,
        pCCtx->m_pCReplyConn);

lCleanup:
    if( SUCCEEDED(hr) ||
        (hr == HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER)) || // mistyped name
        (hr == HRESULT_FROM_WIN32(ERROR_USER_EXISTS)) || // already a friend
        (hr == XONLINE_E_NOTIFICATION_BLOCKED) || // never list
        (hr == XONLINE_E_NOTIFICATION_LIST_FULL) || // full list
        (hr == XONLINE_E_NOTIFICATION_OTHER_LIST_FULL)) // other list is full
    {
        g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_IS_AFFILIATE_MSGS_COUNTER );
    }
    else
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_IS_AFFILIATE_MSGS_COUNTER );

        XomNtEvent(
            XEVENT_PRESENCE_CODE_445,
            "CSwitchboard::IsAffiliateComplete failed user=%I64X; affiliate %I64X; hr=0x%X",
            pCCtx->m_qwUserID,
            pCCtx->m_qwAffiliateID,
            hr);
    }

    SAFE_RELEASE(pCCtx);

    return S_OK;
}

/*****************************************************************************

CSwitchboard::QueryAffiliatesStoreComplete

Callback, called when a QueryAffiliates message has finished processing.

*****************************************************************************/
HRESULT CSwitchboard::QueryAffiliatesStoreComplete(CQueryAffiliatesContext *pCCtx)
{
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "QueryAffiliatesStoreComplete for User=%I64X hr=0x%X",
        pCCtx->m_qwUserID,
        pCCtx->m_hr);

    if (FAILED(pCCtx->m_hr))
    {
        goto lDone;
    }

    if( NULL == pCCtx->m_pCPresence )
    {
        XomNtEvent(XEVENT_PRESENCE_CODE_446, "NULL presence record found requesting user %I64X", pCCtx->m_qwUserID);
        pCCtx->m_hr = HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
        goto lDone;
    }

    if (pCCtx->m_pCPresence->IsAffiliatesListLoaded() == FALSE)
    {
        pCCtx->m_pCPresence->SetAffiliates(pCCtx->m_prgAffiliateLists);

        // presence owns these now.
        pCCtx->m_prgAffiliateLists = NULL;
    }

    pCCtx->m_hr = pCCtx->BuildResultsList(pCCtx->m_pCPresence);

    pCCtx->m_eState = CQueryAffiliatesContext::QueryAffiliates_WaitForPresence;

lDone:

    return pCCtx->m_hr;
}

/*****************************************************************************

CSwitchboard::QueryAffiliatesComplete

Callback, called when a QueryAffiliates message has finished processing.

*****************************************************************************/
HRESULT CSwitchboard::QueryAffiliatesComplete(CQueryAffiliatesContext *pCCtx)
{
    XOMASSERT(pCCtx != NULL);

    HRESULT hr;

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "QueryAffiliatesComplete for User=%I64X NumResults=%d hr=0x%X",
        pCCtx->m_qwUserID,
        pCCtx->m_cdwResults,
        pCCtx->m_hr);

    if (FAILED(pCCtx->m_hr))
    {
        goto lDone;
    }

    if (pCCtx->m_cdwLimit > 0)
    {
        // sort by date.
        qsort(pCCtx->m_rgResults, pCCtx->m_cdwResults, sizeof(P_QUERY_AFFILIATES_REPLY_DATA_MSG), CompareQueryAffiliatesRepliesByDateDesc);

        if (pCCtx->m_cdwLimit < pCCtx->m_cdwResults)
        {
            // limit the results.
            pCCtx->m_cdwResults = pCCtx->m_cdwLimit;
        }
    }

    if (0 == (pCCtx->m_dwListFlags & (pCCtx->m_dwListFlags - 1)))
    {
        // HACK: here we're further overloading the API.  this will be used when the HUD queries for the encountered list.
        // if the query asks for only 1 list (list X), then we can return all the lists that each user from list X exists in, rather than just echoing
        // that same list bit back in every result.  since only list X was queried, the other data in the return structure (titleID, date) is implied
        // to apply to the affiliations from list X.

        if ((pCCtx->m_pCPresence != NULL) && pCCtx->m_pCPresence->IsAffiliatesListLoaded())
        {
            for (DWORD dwResult = 0; dwResult < pCCtx->m_cdwResults; dwResult++)
            {
                DWORD dwFlags = 0;

                HRESULT hrAffiliate = pCCtx->m_pCPresence->IsUserAffiliate(pCCtx->m_rgResults[dwResult].qwAffiliateID, &dwFlags);
                if (FAILED(hrAffiliate))
                {
                    // if any of these fail, we just eat the error.
                    continue;
                }

                pCCtx->m_rgResults[dwResult].dwListFlags = dwFlags;
            }
        }
    }

lDone:

    hr = SendQueryAffiliatesReply(
        pCCtx->m_dwSeqNum,
        pCCtx->m_hr,
        pCCtx->m_cdwResults,
        pCCtx->m_rgResults,
        pCCtx->m_pCReplyConn);

    if( SUCCEEDED(hr) ||
        (hr == HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER)) || // mistyped name
        (hr == HRESULT_FROM_WIN32(ERROR_USER_EXISTS)) || // already a friend
        (hr == XONLINE_E_NOTIFICATION_BLOCKED) || // never list
        (hr == XONLINE_E_NOTIFICATION_LIST_FULL) || // full list
        (hr == XONLINE_E_NOTIFICATION_OTHER_LIST_FULL)) // other list is full
    {
        g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_QUERY_AFFILIATES_MSGS_COUNTER );
    }
    else
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_QUERY_AFFILIATES_MSGS_COUNTER );

        XomNtEvent(
            XEVENT_PRESENCE_CODE_447,
            "CSwitchboard::QueryAffiliatesComplete failed user=%I64X; hr=0x%X",
            pCCtx->m_qwUserID,
            hr);
    }

    SAFE_RELEASE(pCCtx);

    return S_OK;
}

/*****************************************************************************

CSwitchboard::AddAffiliatesComplete

Callback, called when an AddAffiliates message has finished processing.

*****************************************************************************/
HRESULT CSwitchboard::AddAffiliatesComplete(CAddAffiliatesContext *pCCtx)
{
    XOMASSERT(pCCtx != NULL);

    HRESULT hr;

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "AddAffiliatesComplete for User=%I64X hr=0x%X",
        pCCtx->m_qwUserID,
        pCCtx->m_hr);

    // Check the operation for failure
    hr = pCCtx->m_hr;
    if (FAILED(hr))
    {
        goto lDone;
    }

    // transfer affiliates obtained from sql.
    if (pCCtx->m_pCPresence->IsAffiliatesListLoaded() == FALSE)
    {
        pCCtx->m_pCPresence->SetAffiliates(pCCtx->m_prgAffiliateLists);

        // presence owns these now.
        pCCtx->m_prgAffiliateLists = NULL;
    }

    // Update the user's internal record.
    if((pCCtx->m_pCPresence != NULL) &&
        pCCtx->m_pCPresence->HasOnlineRecord() &&
        pCCtx->m_pCPresence->IsAffiliatesListLoaded())
    {
        // presence object already has the userID.
        hr = pCCtx->m_pCPresence->AddAffiliates(
            pCCtx->m_dwListFlag,
            pCCtx->m_dwTitleID,
            pCCtx->m_mtDateUpdated,
            pCCtx->m_cwAffiliates,
            pCCtx->m_pqwAffiliates);
        if (FAILED(hr))
        {
            goto lDone;
        }

        // if adding to the preferred list, also add to the recent list
        if (pCCtx->m_dwListFlag == X_AFFILIATE_INDEX_TO_FLAG(X_AFFILIATE_COMPLETED_GAME_INDEX))
        {
            hr = pCCtx->m_pCPresence->AddAffiliates(
                X_AFFILIATE_INDEX_TO_FLAG(X_AFFILIATE_ENCOUNTERED_INDEX),
                pCCtx->m_dwTitleID,
                pCCtx->m_mtDateUpdated,
                pCCtx->m_cwAffiliates,
                pCCtx->m_pqwAffiliates);
            if (FAILED(hr))
            {
                goto lDone;
            }
        }
    }

    if (pCCtx->m_dwListFlag == X_AFFILIATE_INDEX_TO_FLAG(X_AFFILIATE_NEGATIVE_FEEDBACK_INDEX))
    {
        // negative feedback is reciprocal.  we need to tell the target that we're avoiding him.
        hr = m_CXPCluster.SendAddAffiliates(
            pCCtx->m_cwAffiliates,
            pCCtx->m_pqwAffiliates,
            pCCtx->m_dwTitleID,
            X_AFFILIATE_INDEX_TO_FLAG(X_AFFILIATE_AVOIDING_ME_INDEX),
            pCCtx->m_qwUserID);
        if (FAILED(hr))
        {
            goto lDone;
        }
    }

    if (pCCtx->m_dwListFlag == X_AFFILIATE_INDEX_TO_FLAG(X_AFFILIATE_POSITIVE_FEEDBACK_INDEX))
    {
        // TODO: make a way to remove yourself from someone else's avoid list.
    }


lDone:

    if( SUCCEEDED(hr) ||
        (hr == HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER)) || // mistyped name
        (hr == HRESULT_FROM_WIN32(ERROR_USER_EXISTS)) || // already a friend
        (hr == XONLINE_E_NOTIFICATION_BLOCKED) || // never list
        (hr == XONLINE_E_NOTIFICATION_LIST_FULL) || // full list
        (hr == XONLINE_E_NOTIFICATION_OTHER_LIST_FULL)) // other list is full
    {
        g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_ADD_AFFILIATES_MSGS_COUNTER );
    }
    else
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_ADD_AFFILIATES_MSGS_COUNTER );

        XomNtEvent(
            XEVENT_PRESENCE_CODE_448,
            "CSwitchboard::AddAffiliatesComplete failed user=%I64X; hr=0x%X",
            pCCtx->m_qwUserID,
            hr);
    }

    SAFE_RELEASE(pCCtx);

    return S_OK;
}



/*****************************************************************************

CSwitchboard::AcceptBuddyComplete

Callback, called when an Accept message has finished processing.

*****************************************************************************/
HRESULT CSwitchboard::AcceptBuddyComplete(CAcceptBuddyContext *pCCtx)
{
    XOMASSERT(pCCtx != NULL);

    HRESULT hr;

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "AcceptBuddyComplete for User=%I64X Buddy=%I64X hr=0x%X",
        pCCtx->m_qwUserID,
        pCCtx->m_qwBuddyID,
        pCCtx->m_hr);

    // Post back the result to the user's notifcation queue
    hr = m_CXPCluster.QueueListChange(
        pCCtx->m_qwUserID,
        pCCtx->m_dwUserBuddyListVersion,
        pCCtx->m_qwBuddyID,
        PLIST_BUDDY_ACCEPT,
        pCCtx->m_hr,
        (WORD) pCCtx->m_cbBuddyAccountName,
        pCCtx->m_szBuddyAccountName);
    if (FAILED(hr))
    {
        // Log and continue
        XomNtEvent(XEVENT_PRESENCE_CODE_449, "Failure to enqueue accept change item UserID=%I64X hr=0x%X", pCCtx->m_qwUserID, hr);
        hr = S_OK;
    }

    // Check the operation for failure
    hr = pCCtx->m_hr;
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Delete any friend request message to the buddy
    Q_RECIPIENT_RESULT recipient;
    recipient.qwUserID = pCCtx->m_qwUserID;
    recipient.dwMessageID = 0;

    // Clear the message from Notification (best-effort)
    (void) QueueRevokeMessage(
        pCCtx->m_qwBuddyID,                         // SenderID
        0,                                          // SenderContext
        ( XMSG_REVOKE_MESSAGE_EX_FLAG_USE_TYPE |
          XMSG_REVOKE_MESSAGE_EX_FLAG_USE_SENDER ), // dwFlags
        0,                                          // wPropTag
        0,                                          // cbProp
        NULL,                                       // pbProp
        XONLINE_MSG_TYPE_FRIEND_REQUEST,            // bMessageType
        1,                                          // cRecipients
        &recipient );                               // rgRecipients

    // Update the user's internal record if they are online
    if( pCCtx->m_pCPresence != NULL )
    {
        hr = pCCtx->m_pCPresence->AddBuddy(
            pCCtx->m_qwBuddyID,
            P_BUDDY_STATUS_OK,
            pCCtx->m_dwUserBuddyListVersion);
        if (FAILED(hr))
        {
            goto lDone;
        }

    }

    SET_PUID_CLIENT_TYPE(pCCtx->m_qwUserID, (pCCtx->m_pCPresence->CanClientConsumeRichPresence() ? PRES_CLIENT_TYPE_XENON : PRES_CLIENT_TYPE_XBOX));
    SET_PUID_CLIENT_BETA(pCCtx->m_qwUserID, (pCCtx->m_pCPresence->CanClientIgnoreFriendStateNotifications() ? 1 : 0));

    // If sucessfull, tell our buddy
    hr = m_CXPCluster.SendMsgAccepted(
        pCCtx->m_qwBuddyID,
        pCCtx->m_qwUserID,
        pCCtx->m_dwBuddyBuddyListVersion,
        (WORD) pCCtx->m_cbUserAccountName,
        pCCtx->m_szUserAccountName);


    // Best effort on non-perstistant record keeping
    hr = S_OK;

lDone:

    if( SUCCEEDED(hr) ||
        (hr == DB_E_INTEGRITYVIOLATION) || // dtc rollback
        (hr == HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER)) || // no more request
        (hr == HRESULT_FROM_WIN32(ERROR_USER_EXISTS))) // already accepted
    {
        g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_ACCEPT_MSGS_COUNTER );
    }
    else
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_ACCEPT_MSGS_COUNTER );

        XomNtEvent(
            XEVENT_PRESENCE_CODE_450,
            "CSwitchboard::AcceptBuddyComplete failed user=%I64X buddy=%I64X hr=0x%X",
            pCCtx->m_qwUserID,
            pCCtx->m_qwBuddyID,
            hr);
    }

    SAFE_RELEASE(pCCtx);

    return S_OK;
}

/*****************************************************************************

CSwitchboard::RejectBuddyComplete

Callback, called when a Reject message has finished processing.

*****************************************************************************/
HRESULT CSwitchboard::RejectBuddyComplete(CRejectBuddyContext *pCCtx)
{
    XOMASSERT(pCCtx != NULL);

    HRESULT hr;

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "RejectBuddyComplete for User=%I64X Buddy=%I64X hr=0x%X",
        pCCtx->m_qwUserID,
        pCCtx->m_qwBuddyID,
        pCCtx->m_hr);

    // Post back the result to the user's notifcation queue
    hr = m_CXPCluster.QueueListChange(
        pCCtx->m_qwUserID,
        pCCtx->m_dwUserBuddyListVersion,
        pCCtx->m_qwBuddyID,
        PLIST_BUDDY_REJECT,
        pCCtx->m_hr,
        0,
        "");
    if (FAILED(hr))
    {
        // Log and continue
        XomNtEvent(XEVENT_PRESENCE_CODE_451, "Failure to enqueue reject change item UserID=%I64X hr=0x%X", pCCtx->m_qwUserID, hr);
        hr = S_OK;
    }

    // Check the operation for failure
    hr = pCCtx->m_hr;
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Delete any friend request message to the buddy
    Q_RECIPIENT_RESULT recipient;
    recipient.qwUserID = pCCtx->m_qwUserID;
    recipient.dwMessageID = 0;

    // Clear the message from Notification (best-effort)
    (void) QueueRevokeMessage(
        pCCtx->m_qwBuddyID,                         // SenderID
        0,                                          // SenderContext
        ( XMSG_REVOKE_MESSAGE_EX_FLAG_USE_TYPE |
          XMSG_REVOKE_MESSAGE_EX_FLAG_USE_SENDER ), // dwFlags
        0,                                          // wPropTag
        0,                                          // cbProp
        NULL,                                       // pbProp
        XONLINE_MSG_TYPE_FRIEND_REQUEST,            // bMessageType
        1,                                          // cRecipients
        &recipient );                               // rgRecipients

    // Update the user's internal record if they are online
    if( pCCtx->m_pCPresence != NULL )
    {
        hr = pCCtx->m_pCPresence->RemoveBuddy(
            pCCtx->m_qwBuddyID,
            pCCtx->m_dwUserBuddyListVersion);

        if (pCCtx->m_fNever)
        {
            pCCtx->m_pCPresence->BlockUser(pCCtx->m_qwBuddyID);
        }
    }

    // If sucessfull, tell our buddy
    // Don't post the notifcation if the update didn't effect the buddy's list
    if (pCCtx->m_dwBuddyBuddyListVersion != 0)
    {
        hr = m_CXPCluster.SendMsgRemoved(
            pCCtx->m_qwBuddyID,
            pCCtx->m_qwUserID,
            pCCtx->m_dwBuddyBuddyListVersion);
    }

    // Best effort on non-perstistant record keeping
    hr = S_OK;

lDone:

    if( SUCCEEDED(hr) ||
        (hr == DB_E_INTEGRITYVIOLATION))  // dtc rollback
    {
        g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_REJECT_MSGS_COUNTER );
    }
    else
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_REJECT_MSGS_COUNTER );

        XomNtEvent(
            XEVENT_PRESENCE_CODE_452,
            "CSwitchboard::RejectBuddyComplete failed user=%I64X buddy=%I64X hr=0x%X",
            pCCtx->m_qwUserID,
            pCCtx->m_qwBuddyID,
            hr);
    }

    SAFE_RELEASE(pCCtx);

    return S_OK;
}

/*****************************************************************************

CSwitchboard::DeleteBuddyComplete

Callback, called when a Delete message has finished processing.

*****************************************************************************/
HRESULT CSwitchboard::DeleteBuddyComplete(CDeleteBuddyContext *pCCtx)
{
    XOMASSERT(pCCtx != NULL);

    HRESULT hr;

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "DeleteBuddyComplete for User %I64X Buddy %I64X hr=0x%X",
        pCCtx->m_qwUserID,
        pCCtx->m_qwBuddyID,
        pCCtx->m_hr);

    // Post back the result to the user's notifcation queue
    hr = m_CXPCluster.QueueListChange(
        pCCtx->m_qwUserID,
        pCCtx->m_dwUserBuddyListVersion,
        pCCtx->m_qwBuddyID,
        PLIST_BUDDY_DELETE,
        pCCtx->m_hr,
        0,
        "");
    if (FAILED(hr))
    {
        // Log and continue
        XomNtEvent(XEVENT_PRESENCE_CODE_453, "Failure to enqueue delete change item UserID=%I64X hr=0x%X", pCCtx->m_qwUserID, hr);
        hr = S_OK;
    }

    // Check the operation for failure
    hr = pCCtx->m_hr;
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Delete any friend request message to the buddy
    Q_RECIPIENT_RESULT recipient;
    recipient.qwUserID = pCCtx->m_qwBuddyID;
    recipient.dwMessageID = 0;

    // Clear the message from Notification (best-effort)
    (void) QueueRevokeMessage(
        pCCtx->m_qwUserID,                          // SenderID
        0,                                          // SenderContext
        ( XMSG_REVOKE_MESSAGE_EX_FLAG_USE_TYPE |
          XMSG_REVOKE_MESSAGE_EX_FLAG_USE_SENDER ), // dwFlags
        0,                                          // wPropTag
        0,                                          // cbProp
        NULL,                                       // pbProp
        XONLINE_MSG_TYPE_FRIEND_REQUEST,            // bMessageType
        1,                                          // cRecipients
        &recipient );                               // rgRecipients

    // Delete any friend request message from the buddy
    recipient.qwUserID = pCCtx->m_qwUserID;
    recipient.dwMessageID = 0;

    // Clear the message from Notification (best-effort)
    (void) QueueRevokeMessage(
        pCCtx->m_qwBuddyID,                         // SenderID
        0,                                          // SenderContext
        ( XMSG_REVOKE_MESSAGE_EX_FLAG_USE_TYPE |
          XMSG_REVOKE_MESSAGE_EX_FLAG_USE_SENDER ), // dwFlags
        0,                                          // wPropTag
        0,                                          // cbProp
        NULL,                                       // pbProp
        XONLINE_MSG_TYPE_FRIEND_REQUEST,            // bMessageType
        1,                                          // cRecipients
        &recipient );                               // rgRecipients

    // Update the user's internal record if they are online
    if( pCCtx->m_pCPresence != NULL )
    {
        hr = pCCtx->m_pCPresence->RemoveBuddy(
            pCCtx->m_qwBuddyID,
            pCCtx->m_dwUserBuddyListVersion);
    }

    // If sucessfull, tell our buddy
    // Don't post the notifcation if the update didn't effect the buddy's list
    if (pCCtx->m_dwBuddyBuddyListVersion != 0)
    {
        hr = m_CXPCluster.SendMsgRemoved(
            pCCtx->m_qwBuddyID,
            pCCtx->m_qwUserID,
            pCCtx->m_dwBuddyBuddyListVersion);
    }

    // Best effort on non-persistant record keeping
    hr = S_OK;

lDone:

    if( SUCCEEDED(hr) ||
        (hr == DB_E_INTEGRITYVIOLATION))  // dtc rollback
    {
        g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_DELETE_MSGS_COUNTER );
    }
    else
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_DELETE_MSGS_COUNTER );

        XomNtEvent(
            XEVENT_PRESENCE_CODE_454,
            "CSwitchboard::DeleteBuddyComplete failed user=%I64X buddy=%I64X hr=0x%X",
            pCCtx->m_qwUserID,
            pCCtx->m_qwBuddyID,
            hr);
    }

    SAFE_RELEASE(pCCtx);

    return S_OK;
}

/*****************************************************************************

CSwitchboard::BlockComplete

Callback, called when a Block message has finished processing.

*****************************************************************************/
HRESULT CSwitchboard::BlockComplete(CBlockContext *pCCtx)
{
   XOMASSERT(pCCtx != NULL);

   HRESULT hr;

   XomTrace(
        PresenceDebug,
        L_NORMAL,
        "BlockComplete for User=%I64X Block=%I64X BlkVer=%d hr=0x%X",
        pCCtx->m_qwUserID,
        pCCtx->m_qwBlockID,
        pCCtx->m_dwBlockListVersion,
        pCCtx->m_hr);

    // Check the operation for failure
    hr = pCCtx->m_hr;
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Update the list version if we have a record for the user
    if( pCCtx->m_pCPresence != NULL )
    {
        pCCtx->m_pCPresence->UpdateBlockListVersion(pCCtx->m_dwBlockListVersion);
    }

    hr = S_OK;

lDone:

    if( SUCCEEDED(hr) )
    {
        g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_BLOCK_MSGS_COUNTER );
    }
    else
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_BLOCK_MSGS_COUNTER );

        XomNtEvent(
            XEVENT_PRESENCE_CODE_455,
            "CSwitchboard::BlockComplete failed user=%I64X block=%I64X hr=0x%X",
            pCCtx->m_qwUserID,
            pCCtx->m_qwBlockID,
            hr);
    }

    SAFE_RELEASE(pCCtx);

    return S_OK;
}

/*****************************************************************************

CSwitchboard::UnblockComplete

Callback, called when an Unblock message with a non-zero block id has
finished processing.

*****************************************************************************/
HRESULT CSwitchboard::UnblockComplete(CUnblockContext *pCCtx)
{
    XOMASSERT(pCCtx != NULL);

    HRESULT hr;

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "UnblockComplete for User=%I64X Block=%I64X hr=0x%X",
        pCCtx->m_qwUserID,
        pCCtx->m_qwBlockID,
        pCCtx->m_hr);

    // Check the operation for failure
    hr = pCCtx->m_hr;
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Update the list version if we have a record for the user
    if( pCCtx->m_pCPresence != NULL )
    {
        pCCtx->m_pCPresence->UpdateBlockListVersion(pCCtx->m_dwBlockListVersion);
    }

lDone:

    if( SUCCEEDED(hr) )
    {
        g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_UNBLOCK_MSGS_COUNTER );
    }
    else
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_UNBLOCK_MSGS_COUNTER );

        XomNtEvent(
            XEVENT_PRESENCE_CODE_456,
            "CSwitchboard::UnblockComplete failed user=%I64X block=%I64X hr=0x%X",
            pCCtx->m_qwUserID,
            pCCtx->m_qwBlockID,
            hr);
    }

    SAFE_RELEASE(pCCtx);

    return S_OK;
}

/*****************************************************************************

CSwitchboard::ClearAllBlocksComplete

Callback, called when an Unblock message with a zero block id has finished
processing.

*****************************************************************************/
HRESULT CSwitchboard::ClearAllBlocksComplete(CClearAllBlocksContext *pCCtx)
{
    XOMASSERT(pCCtx != NULL);

    HRESULT hr;

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "ClearAllBlocksComplete for User=%I64X hr=0x%X",
        pCCtx->m_qwUserID,
        pCCtx->m_hr);

    // Check the operation for failure
    hr = pCCtx->m_hr;
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Update the list version if we have a record for the user
    if( pCCtx->m_pCPresence != NULL )
    {
        pCCtx->m_pCPresence->UpdateBlockListVersion(pCCtx->m_dwBlockListVersion);
    }

    hr = S_OK;

lDone:

    if( SUCCEEDED(hr) )
    {
        g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_UNBLOCK_MSGS_COUNTER );
    }
    else
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_UNBLOCK_MSGS_COUNTER );

        XomNtEvent(
            XEVENT_PRESENCE_CODE_457,
            "CSwitchboard::ClearAllBlocksComplete failed user=%I64X buddy=%I64X hr=0x%X",
            pCCtx->m_qwUserID,
            hr);
    }

    SAFE_RELEASE(pCCtx);

    return S_OK;
}

/*****************************************************************************

CSwitchboard::SendEmptyAliveReply

Send an empty Alive Reply message, possibly with an error code

*****************************************************************************/
HRESULT CSwitchboard::SendEmptyAliveReply(
    DWORD dwSeqNum,
    HRESULT hrReply,
    DWORD dwBuddyListVersion,
    DWORD dwBlockListVersion,
    CClientConnection *pCReplyConn)
{
    HRESULT hr = S_OK;
    CTCPCntVarBuffer *pCAliveReplyBuffer = NULL;
    P_ALIVE_REPLY_MSG *pmsgAliveReply = NULL;

    // Send an ALIVE response
    pCAliveReplyBuffer = g_pBufferPool->GetBuffer(sizeof(P_ALIVE_REPLY_MSG));
    if (pCAliveReplyBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pmsgAliveReply = (P_ALIVE_REPLY_MSG *) pCAliveReplyBuffer->GetBuffer();

    pmsgAliveReply->dwMsgType = PMSG_ALIVE_REPLY;
    pmsgAliveReply->dwMsgLen = sizeof(P_ALIVE_REPLY_MSG) - sizeof(BASE_MSG_HEADER);
    pmsgAliveReply->dwSeqNum = dwSeqNum;
    pmsgAliveReply->sgaddr = sgaddrIgnore;
    pmsgAliveReply->hr = hrReply;
    pmsgAliveReply->dwBuddyListVersion = dwBuddyListVersion;
    pmsgAliveReply->cBuddiesSent = 0;
    pmsgAliveReply->dwBlockListVersion = dwBlockListVersion;
    pmsgAliveReply->cBlocksSent = 0;

    pCReplyConn->Send(pCAliveReplyBuffer);

lDone:

    SAFE_RELEASE(pCAliveReplyBuffer);

    return hr;
}

HRESULT CSwitchboard::SendLogonCheckReply(
    DWORD dwSeqNum,
    HRESULT hrReply,
    CClientConnection *pCReplyConn)
{
    HRESULT hr = S_OK;
    CTCPCntVarBuffer *pCReplyBuffer = NULL;
    P_LOGON_CHECK_REPLY_MSG *pmsgReply = NULL;

    // Send a SYNC response
    pCReplyBuffer = g_pBufferPool->GetBuffer(sizeof(P_LOGON_CHECK_REPLY_MSG));
    if (pCReplyBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pmsgReply = (P_LOGON_CHECK_REPLY_MSG *) pCReplyBuffer->GetBuffer();

    pmsgReply->dwMsgType = PMSG_LOGON_CHECK_REPLY;
    pmsgReply->dwMsgLen = sizeof(P_LOGON_CHECK_REPLY_MSG) - sizeof(BASE_MSG_HEADER);
    pmsgReply->dwSeqNum = dwSeqNum;
    pmsgReply->hr = hrReply;

    pCReplyConn->Send(pCReplyBuffer);

lDone:

    SAFE_RELEASE(pCReplyBuffer);

    return hr;
}


/*****************************************************************************

CSwitchboard::SendCheckTitleMessagesReply

Send a reply to the title messages check

*****************************************************************************/
HRESULT CSwitchboard::SendCheckTitleMessagesReply(
    DWORD dwSeqNum,
    HRESULT hrReply,
    CClientConnection *pCReplyConn)
{
    HRESULT hr = S_OK;
    CTCPCntVarBuffer *pCReplyBuffer = NULL;
    P_CHECK_TITLE_MESSAGES_REPLY_MSG *pmsgReply = NULL;

    // Send a SYNC response
    pCReplyBuffer = g_pBufferPool->GetBuffer(sizeof(P_CHECK_TITLE_MESSAGES_REPLY_MSG));
    if (pCReplyBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pmsgReply = (P_CHECK_TITLE_MESSAGES_REPLY_MSG *) pCReplyBuffer->GetBuffer();

    pmsgReply->dwMsgType = PMSG_CHECK_TITLE_MESSAGES_REPLY;
    pmsgReply->dwMsgLen = sizeof(P_CHECK_TITLE_MESSAGES_REPLY_MSG) - sizeof(BASE_MSG_HEADER);
    pmsgReply->dwSeqNum = dwSeqNum;
    pmsgReply->hr = hrReply;

    pCReplyConn->Send(pCReplyBuffer);

lDone:

    SAFE_RELEASE(pCReplyBuffer);

    return hr;
}

/*****************************************************************************

CSwitchboard::SendErrorSyncReply

Send a Sync Reply message with an error code

*****************************************************************************/
HRESULT CSwitchboard::SendErrorSyncReply(
    DWORD dwSeqNum,
    HRESULT hrReply,
    CClientConnection *pCReplyConn)
{
    HRESULT hr = S_OK;
    CTCPCntVarBuffer *pCSyncReplyBuffer = NULL;
    P_SYNC_REPLY_MSG *pmsgSyncReply = NULL;

    // Send a SYNC response
    pCSyncReplyBuffer = g_pBufferPool->GetBuffer(sizeof(P_SYNC_REPLY_MSG));
    if (pCSyncReplyBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pmsgSyncReply = (P_SYNC_REPLY_MSG *) pCSyncReplyBuffer->GetBuffer();

    pmsgSyncReply->dwMsgType = PMSG_SYNC_REPLY;
    pmsgSyncReply->dwMsgLen = sizeof(P_SYNC_REPLY_MSG) - sizeof(BASE_MSG_HEADER);
    pmsgSyncReply->dwSeqNum = dwSeqNum;
    pmsgSyncReply->sgaddr = sgaddrIgnore;
    pmsgSyncReply->hr = hrReply;
    pmsgSyncReply->dwBuddyListVersion = 0;
    pmsgSyncReply->cBuddiesSent = 0;
    pmsgSyncReply->dwBlockListVersion = 0;
    pmsgSyncReply->cBlocksSent = 0;

    pCReplyConn->Send(pCSyncReplyBuffer);

lDone:

    SAFE_RELEASE(pCSyncReplyBuffer);

    return hr;
}

/*****************************************************************************

CSwitchboard::SendGetFriendsListReply

Send a GetFriendsListReply message, possibly with an error code

*****************************************************************************/
HRESULT CSwitchboard::SendGetFriendsListReply(
    QWORD qwTargetID,
    DWORD dwSeqNum,
    DWORD dwReplyType,
    HRESULT hrReply,
    DWORD dwVersion,
    DWORD cdwResults,
    P_GET_FRIENDS_LIST_REPLY_DATA *rgResults,
    CClientConnection *pCReplyConn)
{
    HRESULT hr = S_OK;
    CTCPCntVarBuffer *pCReplyBuffer = NULL;
    P_GET_FRIENDS_LIST_REPLY_MSG *pmsgReply = NULL;

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "CSwitchboard::SendGetFriendsListReply for Seq=%d hr=0x%X",
        dwSeqNum,
        hrReply);

    // Send a response
    pCReplyBuffer = g_pBufferPool->GetBuffer(sizeof(P_GET_FRIENDS_LIST_REPLY_MSG) + (cdwResults * (sizeof(P_GET_FRIENDS_LIST_REPLY_DATA) + MAX_TITLE_STATE_BYTES + g_CPresCfg.GetMaxRichPresenceBytes())));
    if (pCReplyBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pmsgReply = (P_GET_FRIENDS_LIST_REPLY_MSG *) pCReplyBuffer->GetBuffer();

    pmsgReply->dwMsgType = dwReplyType;
    pmsgReply->dwSeqNum = dwSeqNum;
    pmsgReply->sgaddr = sgaddrIgnore;
    pmsgReply->hr = hrReply;
    pmsgReply->cdwFriends = cdwResults;
    pmsgReply->dwVersion = dwVersion;
    pmsgReply->qwUserID = qwTargetID;

    // compact results while copying to send buffer.
    // TODO: sort the results ?? -- if so, do it in CGetFriendsListContext::BuildResultsList()
    BYTE *pWrite = (BYTE *)(pmsgReply + 1);
    BYTE *pRead = (BYTE *)rgResults;
    while (cdwResults > 0)
    {
        DWORD dwBytesToWrite = sizeof(P_GET_FRIENDS_LIST_REPLY_DATA) + ((P_GET_FRIENDS_LIST_REPLY_DATA *)pRead)->cbStateData + ((P_GET_FRIENDS_LIST_REPLY_DATA *)pRead)->cbRichPresence;
        memcpy(pWrite, pRead, dwBytesToWrite);

        pWrite += dwBytesToWrite;
        pRead += sizeof(P_GET_FRIENDS_LIST_REPLY_DATA) + MAX_TITLE_STATE_BYTES + g_CPresCfg.GetMaxRichPresenceBytes();
        cdwResults--;
    }

    pmsgReply->dwMsgLen = (pWrite - (BYTE *)(pmsgReply)) - sizeof(BASE_MSG_HEADER);
    pCReplyBuffer->Resize(pWrite - (BYTE *)pmsgReply);

    pCReplyConn->Send(pCReplyBuffer);

lDone:

    SAFE_RELEASE(pCReplyBuffer);

    return hr;
}

HRESULT CSwitchboard::SendWebAliveReply(
    QWORD qwUserID,
    DWORD dwSeqNum,
    HRESULT hrReply,
    CClientConnection *pCReplyConn)
{
    HRESULT hr = S_OK;
    CTCPCntVarBuffer *pCReplyBuffer = NULL;
    P_WEB_ALIVE_REPLY_MSG *pmsgReply = NULL;

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "CSwitchboard::SendWebAliveReply for Seq=%d hr=0x%X",
        dwSeqNum,
        hrReply);

    // Send a response
    pCReplyBuffer = g_pBufferPool->GetBuffer(sizeof(P_WEB_ALIVE_REPLY_MSG));
    if (pCReplyBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pmsgReply = (P_WEB_ALIVE_REPLY_MSG *) pCReplyBuffer->GetBuffer();

    pmsgReply->dwMsgType = PMSG_WEB_ALIVE_REPLY;
    pmsgReply->dwMsgLen = sizeof(P_WEB_ALIVE_REPLY_MSG) - sizeof(BASE_MSG_HEADER);
    pmsgReply->dwSeqNum = dwSeqNum;
    pmsgReply->sgaddr = sgaddrIgnore;
    pmsgReply->hr = hrReply;
    pmsgReply->qwUserID = qwUserID;

    pCReplyConn->Send(pCReplyBuffer);

lDone:

    SAFE_RELEASE(pCReplyBuffer);

    return hr;
}

/*****************************************************************************

CSwitchboard::SendPeerSessionReply

Send a Peer Session Reply message, possibly with an error code

*****************************************************************************/
HRESULT CSwitchboard::SendPeerSessionReply(
    DWORD dwSeqNum,
    QWORD qwUserID,
    DWORD dwTitleID,
    DWORD dwTitleVersion,
    DWORD dwTitleRegion,
    XNADDR xnaddr,
    XNKID xkid,
    XNKEY xnkey,
    CClientConnection *pCReplyConn)
{
    HRESULT hr = S_OK;
    CTCPCntVarBuffer *pCReplyBuffer = NULL;
    P_PEER_SESSION_REPLY_MSG *pmsgReply = NULL;

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "CSwitchboard::SendPeerSessionReply for Seq=%d HostUser=%I64X",
        dwSeqNum,
        qwUserID);

    // Send a response
    pCReplyBuffer = g_pBufferPool->GetBuffer(sizeof(P_PEER_SESSION_REPLY_MSG));
    if (pCReplyBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pmsgReply = (P_PEER_SESSION_REPLY_MSG *) pCReplyBuffer->GetBuffer();

    pmsgReply->dwMsgType = PMSG_PEER_SESSION_REPLY;
    pmsgReply->dwMsgLen = sizeof(P_PEER_SESSION_REPLY_MSG) - sizeof(BASE_MSG_HEADER);
    pmsgReply->dwSeqNum = dwSeqNum;
    pmsgReply->sgaddr = sgaddrIgnore;
    pmsgReply->qwHostUserID = qwUserID;
    pmsgReply->dwTitleID = dwTitleID;
    pmsgReply->dwTitleVersion = dwTitleVersion;
    pmsgReply->dwTitleRegion = dwTitleRegion;
    pmsgReply->xnaddr = xnaddr;
    pmsgReply->xkid = xkid;
    pmsgReply->xnkey = xnkey;

    pCReplyConn->Send(pCReplyBuffer);

lDone:

    SAFE_RELEASE(pCReplyBuffer);

    return hr;
}

/*****************************************************************************

CSwitchboard::SendPeerSubscribeReply

Send a Peer Subscribe Reply message, possibly with an error code

*****************************************************************************/
HRESULT CSwitchboard::SendPeerSubscribeReply(
    DWORD dwSeqNum,
    HRESULT hrReply,
    CClientConnection *pCReplyConn)
{
    HRESULT hr = S_OK;
    CTCPCntVarBuffer *pCReplyBuffer = NULL;
    P_PEER_SUBSCRIBE_REPLY_MSG *pmsgReply = NULL;

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "CSwitchboard::SendPeerSubscribeReply for seq=%d hr=0x%X",
        dwSeqNum,
        hrReply);

    // Send a response
    pCReplyBuffer = g_pBufferPool->GetBuffer(sizeof(P_PEER_SUBSCRIBE_REPLY_MSG));
    if (pCReplyBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pmsgReply = (P_PEER_SUBSCRIBE_REPLY_MSG *) pCReplyBuffer->GetBuffer();

    pmsgReply->dwMsgType = PMSG_PEER_SUBSCRIBE_REPLY;
    pmsgReply->dwMsgLen = sizeof(P_PEER_SUBSCRIBE_REPLY_MSG) - sizeof(BASE_MSG_HEADER);
    pmsgReply->dwSeqNum = dwSeqNum;
    pmsgReply->sgaddr = sgaddrIgnore;
    pmsgReply->hr = hrReply;

    pCReplyConn->Send(pCReplyBuffer);

lDone:

    SAFE_RELEASE(pCReplyBuffer);

    return hr;
}

HRESULT CSwitchboard::SendPeerSubscribeExReply(
    DWORD dwSeqNum,
    HRESULT hrReply,
    WORD cResults,
    P_PEER_SUBSCRIBE_EX_DATA *rgResults,
    CClientConnection *pCReplyConn)
{
    HRESULT hr = S_OK;
    CTCPCntVarBuffer *pCReplyBuffer = NULL;
    P_PEER_SUBSCRIBE_EX_REPLY_MSG *pmsgReply = NULL;

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "CSwitchboard::SendPeerSubscribeExReply for seq=%d hr=0x%X",
        dwSeqNum,
        hrReply);

    // Send a response
    pCReplyBuffer = g_pBufferPool->GetBuffer(sizeof(P_PEER_SUBSCRIBE_EX_REPLY_MSG) + (cResults * sizeof(P_PEER_SUBSCRIBE_EX_DATA)));
    if (pCReplyBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pmsgReply = (P_PEER_SUBSCRIBE_EX_REPLY_MSG *) pCReplyBuffer->GetBuffer();

    pmsgReply->dwMsgType = PMSG_PEER_SUBSCRIBE_EX_REPLY;
    pmsgReply->dwMsgLen = pCReplyBuffer->GetBufferLength() - sizeof(BASE_MSG_HEADER);
    pmsgReply->dwSeqNum = dwSeqNum;
    pmsgReply->sgaddr = sgaddrIgnore;
    pmsgReply->hr = hrReply;
    pmsgReply->cResults = cResults;
    memcpy(pmsgReply + 1, rgResults, cResults * sizeof(P_PEER_SUBSCRIBE_EX_DATA));

    pCReplyConn->Send(pCReplyBuffer);

lDone:

    SAFE_RELEASE(pCReplyBuffer);

    return hr;
}


/*****************************************************************************

CSwitchboard::SendPeerUnsubscribeReply

Send a Peer Unsubscribe Reply message, possibly with an error code

*****************************************************************************/
HRESULT CSwitchboard::SendPeerUnsubscribeReply(
    DWORD dwSeqNum,
    HRESULT hrReply,
    CClientConnection *pCReplyConn)
{
    HRESULT hr = S_OK;
    CTCPCntVarBuffer *pCReplyBuffer = NULL;
    P_PEER_UNSUBSCRIBE_REPLY_MSG *pmsgReply = NULL;

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "CSwitchboard::SendPeerUnsubscribeReply for seq=%d hr=0x%X",
        dwSeqNum,
        hrReply);

    // Send a response
    pCReplyBuffer = g_pBufferPool->GetBuffer(sizeof(P_PEER_UNSUBSCRIBE_REPLY_MSG));
    if (pCReplyBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pmsgReply = (P_PEER_UNSUBSCRIBE_REPLY_MSG *) pCReplyBuffer->GetBuffer();

    pmsgReply->dwMsgType = PMSG_PEER_UNSUBSCRIBE_REPLY;
    pmsgReply->dwMsgLen = sizeof(P_PEER_UNSUBSCRIBE_REPLY_MSG) - sizeof(BASE_MSG_HEADER);
    pmsgReply->dwSeqNum = dwSeqNum;
    pmsgReply->sgaddr = sgaddrIgnore;
    pmsgReply->hr = hrReply;

    pCReplyConn->Send(pCReplyBuffer);

lDone:

    SAFE_RELEASE(pCReplyBuffer);

    return hr;
}

/*****************************************************************************

CSwitchboard::SendIsAffiliateReply

Send an IsAffiliateReply message, possibly with an error code

*****************************************************************************/
HRESULT CSwitchboard::SendIsAffiliateReply(
    DWORD dwSeqNum,
    HRESULT hrReply,
    QWORD qwAffiliateID,
    DWORD dwListFlags,
    CClientConnection * pCReplyConn)
{
    HRESULT hr = S_OK;
    CTCPCntVarBuffer *pCReplyBuffer = NULL;
    P_IS_AFFILIATE_REPLY_MSG *pmsgReply = NULL;

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "CSwitchboard::SendIsAffiliateReply for seq=%d hr=0x%X",
        dwSeqNum,
        hrReply);

    // Send a response
    pCReplyBuffer = g_pBufferPool->GetBuffer(sizeof(P_IS_AFFILIATE_REPLY_MSG));
    if (pCReplyBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pmsgReply = (P_IS_AFFILIATE_REPLY_MSG *) pCReplyBuffer->GetBuffer();

    pmsgReply->dwMsgType = PMSG_IS_AFFILIATE_REPLY;
    pmsgReply->dwMsgLen = sizeof(P_IS_AFFILIATE_REPLY_MSG) - sizeof(BASE_MSG_HEADER);
    pmsgReply->dwSeqNum = dwSeqNum;
    pmsgReply->sgaddr = sgaddrIgnore;
    pmsgReply->hr = hrReply;
    pmsgReply->dwListFlags = dwListFlags;
    pmsgReply->qwAffiliateID = qwAffiliateID;

    pCReplyConn->Send(pCReplyBuffer);

lDone:

    SAFE_RELEASE(pCReplyBuffer);

    return hr;
}

/*****************************************************************************

CSwitchboard::SendueryAffiliatesReply

Send a QueryAffiliatesReply message, possibly with an error code

*****************************************************************************/
HRESULT CSwitchboard::SendQueryAffiliatesReply(
    DWORD dwSeqNum,
    HRESULT hrReply,
    DWORD cdwResults,
    P_QUERY_AFFILIATES_REPLY_DATA_MSG * rgResults,
    CClientConnection * pCReplyConn)
{
    HRESULT hr = S_OK;
    CTCPCntVarBuffer *pCReplyBuffer = NULL;
    P_QUERY_AFFILIATES_REPLY_MSG *pmsgReply = NULL;

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "CSwitchboard::SendQueryAffiliatesReply for seq=%d hr=0x%X",
        dwSeqNum,
        hrReply);

    // Send a response
    pCReplyBuffer = g_pBufferPool->GetBuffer(sizeof(P_QUERY_AFFILIATES_REPLY_MSG) + (cdwResults * sizeof(P_QUERY_AFFILIATES_REPLY_DATA_MSG)));
    if (pCReplyBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pmsgReply = (P_QUERY_AFFILIATES_REPLY_MSG *) pCReplyBuffer->GetBuffer();

    pmsgReply->dwMsgType = PMSG_QUERY_AFFILIATES_REPLY;
    pmsgReply->dwMsgLen = sizeof(P_QUERY_AFFILIATES_REPLY_MSG) + (cdwResults * sizeof(P_QUERY_AFFILIATES_REPLY_DATA_MSG)) - sizeof(BASE_MSG_HEADER);
    pmsgReply->dwSeqNum = dwSeqNum;
    pmsgReply->sgaddr = sgaddrIgnore;
    pmsgReply->cdwResults = cdwResults;

    if (SUCCEEDED(hrReply) &&
        (g_CPresCfg.GetQueryAffiliatesOkToPeerSubscribe() == FALSE))
    {
        hrReply = XONLINE_S_NOTIFICATION_NO_PEER_SUBSCRIBE;
    }
    pmsgReply->hr = hrReply;

    if (cdwResults > 0)
    {
        // TODO:  is there a way to avoid this copy?  can CQueryAffiliatesContext hold its own CTCPCntVarBuffer?
        memcpy(pmsgReply + 1, rgResults, cdwResults * sizeof(P_QUERY_AFFILIATES_REPLY_DATA_MSG));
    }

    pCReplyConn->Send(pCReplyBuffer);

lDone:

    SAFE_RELEASE(pCReplyBuffer);

    return hr;
}

/*****************************************************************************

CSwitchboard::SendGetPresenceInfo

Send a GetPresenceInfo message to the other xpservers

*****************************************************************************/
HRESULT CSwitchboard::SendGetPresenceInfo(
    CPresenceInfoContext *pCCtx,
    BOOL fUseAltServer)
{
    HRESULT hr = S_OK;

    g_pCPresenceInfoContextQueue->Insert(pCCtx);  // Insert() creates a contextID.

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "CSwitchboard::SendGetPresenceInfo for User=%I64X, Context=%d",
        pCCtx->m_qwUserID,
        pCCtx->m_dwContextID);

    hr = m_CXPCluster.SendGetPresenceInfo(pCCtx, fUseAltServer);

    return hr;
}

/*****************************************************************************

CSwitchboard::SendTeamListTeamsReply

Send a Team List Teams Reply message, possibly with an error code

*****************************************************************************/
HRESULT CSwitchboard::SendTeamListTeamsReply(
    DWORD dwSeqNum,
    HRESULT hrReply,
    DWORD cReplies,
    CTCPCntVarBuffer **rgpReplies,
    CClientConnection *pCReplyConn)
{
    HRESULT hr = S_OK;
    CTCPCntVarBuffer *pCReplyBuffer = NULL;
    P_TEAM_LIST_TEAMS_REPLY_MSG *pmsgReply = NULL;
    DWORD dwIndex = 0;

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "CSwitchboard::SendTeamListTeamsReply for Seq=%d hr=0x%X Teams=%d",
        dwSeqNum,
        hrReply,
        cReplies);

    // Send a response
    pCReplyBuffer = g_pBufferPool->GetBuffer(sizeof(P_TEAM_LIST_TEAMS_REPLY_MSG));
    if (pCReplyBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pmsgReply = (P_TEAM_LIST_TEAMS_REPLY_MSG *) pCReplyBuffer->GetBuffer();

    pmsgReply->dwMsgType = PMSG_TEAM_LIST_TEAMS_REPLY;
    pmsgReply->dwMsgLen = sizeof(P_TEAM_LIST_TEAMS_REPLY_MSG) - sizeof(BASE_MSG_HEADER);
    pmsgReply->dwSeqNum = dwSeqNum;
    pmsgReply->sgaddr = sgaddrIgnore;
    pmsgReply->hr = hrReply;
    pmsgReply->cTeams = cReplies;

    for (dwIndex = 0; dwIndex < cReplies; dwIndex++)
    {
        pmsgReply->dwMsgLen += rgpReplies[dwIndex]->GetBufferLength();
    }

    pCReplyConn->Send(pCReplyBuffer);

    for (dwIndex = 0; dwIndex < cReplies; dwIndex++)
    {
        pCReplyConn->Send(rgpReplies[dwIndex]);
    }

lDone:

    SAFE_RELEASE(pCReplyBuffer);

    return hr;
}


/*****************************************************************************

CSwitchboard::SendTeamListUserTeamsReply

Send a TeamListUserTeamsReply message, possibly with an error code

*****************************************************************************/
HRESULT CSwitchboard::SendTeamListUserTeamsReply(
    DWORD dwSeqNum,
    HRESULT hrReply,
    DWORD cTeams,
    P_REPLY_USER_TEAM *rgUserTeams,
    CClientConnection *pCReplyConn)
{
    HRESULT hr = S_OK;
    CTCPCntVarBuffer *pCReplyBuffer = NULL;
    P_TEAM_LIST_USER_TEAMS_REPLY_MSG *pmsgReply = NULL;

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "CSwitchboard::SendTeamListUserTeamsReply for Seq=%d hr=0x%X Teams=%d",
        dwSeqNum,
        hrReply,
        cTeams);

    // Send a response
    pCReplyBuffer = g_pBufferPool->GetBuffer( sizeof(P_TEAM_LIST_USER_TEAMS_REPLY_MSG) + (sizeof(P_REPLY_USER_TEAM) * cTeams) );
    if (pCReplyBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pmsgReply = (P_TEAM_LIST_USER_TEAMS_REPLY_MSG *) pCReplyBuffer->GetBuffer();

    pmsgReply->dwMsgType = PMSG_TEAM_LIST_USER_TEAMS_REPLY;
    pmsgReply->dwMsgLen = sizeof(P_TEAM_LIST_USER_TEAMS_REPLY_MSG) + (sizeof(P_REPLY_USER_TEAM) * cTeams) - sizeof(BASE_MSG_HEADER);
    pmsgReply->dwSeqNum = dwSeqNum;
    pmsgReply->sgaddr = sgaddrIgnore;
    pmsgReply->hr = hrReply;
    pmsgReply->cTeams = cTeams;

    // Copy the team data into the reply
    memcpy((BYTE *)(pmsgReply + 1), rgUserTeams, cTeams * sizeof(P_REPLY_USER_TEAM));

    pCReplyConn->Send(pCReplyBuffer);

lDone:

    SAFE_RELEASE(pCReplyBuffer);

    return hr;
}


/*****************************************************************************

CSwitchboard::SendTeamListMembersReply

Send a Team List Members Reply message, possibly with an error code

*****************************************************************************/
HRESULT CSwitchboard::SendTeamListMembersReply(
    DWORD dwSeqNum,
    HRESULT hrReply,
    QWORD qwTeamID,
    DWORD cMembers,
    CTCPCntVarBuffer *pReply,
    CClientConnection *pCReplyConn)
{
    HRESULT hr = S_OK;
    CTCPCntVarBuffer *pCReplyBuffer = NULL;
    P_TEAM_LIST_MEMBERS_REPLY_MSG *pmsgReply = NULL;

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "CSwitchboard::SendTeamListMembersReply for Seq=%d hr=0x%X Team=%I64X",
        dwSeqNum,
        hrReply,
        qwTeamID);

    // Send a response
    pCReplyBuffer = g_pBufferPool->GetBuffer(sizeof(P_TEAM_LIST_MEMBERS_REPLY_MSG));
    if (pCReplyBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pmsgReply = (P_TEAM_LIST_MEMBERS_REPLY_MSG *) pCReplyBuffer->GetBuffer();

    pmsgReply->dwMsgType = PMSG_TEAM_LIST_MEMBERS_REPLY;
    pmsgReply->dwMsgLen = sizeof(P_TEAM_LIST_MEMBERS_REPLY_MSG) - sizeof(BASE_MSG_HEADER);
    pmsgReply->dwSeqNum = dwSeqNum;
    pmsgReply->sgaddr = sgaddrIgnore;
    pmsgReply->qwTeamID = qwTeamID;
    pmsgReply->cMembers = (WORD) cMembers;
    pmsgReply->hr = hrReply;

    if (pReply != NULL)
    {
        pmsgReply->dwMsgLen += pReply->GetBufferLength();
        pCReplyConn->Send(pCReplyBuffer);
        pCReplyConn->Send(pReply);
    }
    else
    {
        pCReplyConn->Send(pCReplyBuffer);
    }

lDone:

    SAFE_RELEASE(pCReplyBuffer);

    return hr;
}

/*****************************************************************************

CSwitchboard::SendTeamCreateReply

Send a Team Create Reply message, possibly with an error code

*****************************************************************************/
HRESULT CSwitchboard::SendTeamCreateReply(
    DWORD dwSeqNum,
    HRESULT hrReply,
    QWORD qwTeamID,
    CClientConnection *pCReplyConn)
{
    HRESULT hr = S_OK;
    CTCPCntVarBuffer *pCReplyBuffer = NULL;
    P_TEAM_CREATE_REPLY_MSG *pmsgReply = NULL;

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "CSwitchboard::SendTeamCreateReply for Seq=%d hr=0x%X Team=%I64X",
        dwSeqNum,
        hrReply,
        qwTeamID);

    FILETIME ftCreated;
    GetSystemTimeAsFileTime(&ftCreated);

    // Send a response
    pCReplyBuffer = g_pBufferPool->GetBuffer(sizeof(P_TEAM_CREATE_REPLY_MSG));
    if (pCReplyBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pmsgReply = (P_TEAM_CREATE_REPLY_MSG *) pCReplyBuffer->GetBuffer();

    pmsgReply->dwMsgType = PMSG_TEAM_CREATE_REPLY;
    pmsgReply->dwMsgLen = sizeof(P_TEAM_CREATE_REPLY_MSG) - sizeof(BASE_MSG_HEADER);
    pmsgReply->dwSeqNum = dwSeqNum;
    pmsgReply->sgaddr = sgaddrIgnore;
    pmsgReply->hr = hrReply;
    pmsgReply->qwTeamID = qwTeamID;
    pmsgReply->ftCreated = ftCreated;

    pCReplyConn->Send(pCReplyBuffer);

lDone:

    SAFE_RELEASE(pCReplyBuffer);

    return hr;
}

/*****************************************************************************

CSwitchboard::SendTeamDeleteReply

Send a Team Delete Reply message, possibly with an error code

*****************************************************************************/
HRESULT CSwitchboard::SendTeamDeleteReply(
    DWORD dwSeqNum,
    HRESULT hrReply,
    CClientConnection *pCReplyConn)
{
    HRESULT hr = S_OK;
    CTCPCntVarBuffer *pCReplyBuffer = NULL;
    P_TEAM_DELETE_REPLY_MSG *pmsgReply = NULL;

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "CSwitchboard::SendTeamDeleteReply for Seq=%d hr=0x%X",
        dwSeqNum,
        hrReply);

    // Send a response
    pCReplyBuffer = g_pBufferPool->GetBuffer(sizeof(P_TEAM_DELETE_REPLY_MSG));
    if (pCReplyBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pmsgReply = (P_TEAM_DELETE_REPLY_MSG *) pCReplyBuffer->GetBuffer();

    pmsgReply->dwMsgType = PMSG_TEAM_DELETE_REPLY;
    pmsgReply->dwMsgLen = sizeof(P_TEAM_DELETE_REPLY_MSG) - sizeof(BASE_MSG_HEADER);
    pmsgReply->dwSeqNum = dwSeqNum;
    pmsgReply->sgaddr = sgaddrIgnore;
    pmsgReply->hr = hrReply;

    pCReplyConn->Send(pCReplyBuffer);

lDone:

    SAFE_RELEASE(pCReplyBuffer);

    return hr;
}

/*****************************************************************************

CSwitchboard::SendTeamRemoveReply

Send a Team Remove Reply message, possibly with an error code

*****************************************************************************/
HRESULT CSwitchboard::SendTeamRemoveReply(
    DWORD dwSeqNum,
    HRESULT hrReply,
    CClientConnection *pCReplyConn)
{
    HRESULT hr = S_OK;
    CTCPCntVarBuffer *pCReplyBuffer = NULL;
    P_TEAM_REMOVE_REPLY_MSG *pmsgReply = NULL;

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "CSwitchboard::SendTeamRemoveReply for Seq=%d hr=0x%X",
        dwSeqNum,
        hrReply);

    // Send a response
    pCReplyBuffer = g_pBufferPool->GetBuffer(sizeof(P_TEAM_REMOVE_REPLY_MSG));
    if (pCReplyBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pmsgReply = (P_TEAM_REMOVE_REPLY_MSG *) pCReplyBuffer->GetBuffer();

    pmsgReply->dwMsgType = PMSG_TEAM_REMOVE_REPLY;
    pmsgReply->dwMsgLen = sizeof(P_TEAM_REMOVE_REPLY_MSG) - sizeof(BASE_MSG_HEADER);
    pmsgReply->dwSeqNum = dwSeqNum;
    pmsgReply->sgaddr = sgaddrIgnore;
    pmsgReply->hr = hrReply;

    pCReplyConn->Send(pCReplyBuffer);

lDone:

    SAFE_RELEASE(pCReplyBuffer);

    return hr;
}

/*****************************************************************************

CSwitchboard::SendTeamManageTeamReply

Send a Team Manage Team Reply message, possibly with an error code

*****************************************************************************/
HRESULT CSwitchboard::SendTeamManageTeamReply(
    DWORD dwSeqNum,
    HRESULT hrReply,
    CClientConnection *pCReplyConn)
{
    HRESULT hr = S_OK;
    CTCPCntVarBuffer *pCReplyBuffer = NULL;
    P_TEAM_MANAGE_TEAM_REPLY_MSG *pmsgReply = NULL;

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "CSwitchboard::SendTeamManageTeamReply for Seq=%d hr=0x%X",
        dwSeqNum,
        hrReply);

    // Send a response
    pCReplyBuffer = g_pBufferPool->GetBuffer(sizeof(P_TEAM_MANAGE_TEAM_REPLY_MSG));
    if (pCReplyBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pmsgReply = (P_TEAM_MANAGE_TEAM_REPLY_MSG *) pCReplyBuffer->GetBuffer();

    pmsgReply->dwMsgType = PMSG_TEAM_MANAGE_TEAM_REPLY;
    pmsgReply->dwMsgLen = sizeof(P_TEAM_MANAGE_TEAM_REPLY_MSG) - sizeof(BASE_MSG_HEADER);
    pmsgReply->dwSeqNum = dwSeqNum;
    pmsgReply->sgaddr = sgaddrIgnore;
    pmsgReply->hr = hrReply;

    pCReplyConn->Send(pCReplyBuffer);

lDone:

    SAFE_RELEASE(pCReplyBuffer);

    return hr;
}

/*****************************************************************************

CSwitchboard::SendTeamManageMemberReply

Send a Team Manage Member Reply message, possibly with an error code

*****************************************************************************/
HRESULT CSwitchboard::SendTeamManageMemberReply(
    DWORD dwSeqNum,
    HRESULT hrReply,
    CClientConnection *pCReplyConn)
{
    HRESULT hr = S_OK;
    CTCPCntVarBuffer *pCReplyBuffer = NULL;
    P_TEAM_MANAGE_MEMBER_REPLY_MSG *pmsgReply = NULL;

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "CSwitchboard::SendTeamManageMemberReply for Seq=%d hr=0x%X",
        dwSeqNum,
        hrReply);

    // Send a response
    pCReplyBuffer = g_pBufferPool->GetBuffer(sizeof(P_TEAM_MANAGE_MEMBER_REPLY_MSG));
    if (pCReplyBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pmsgReply = (P_TEAM_MANAGE_MEMBER_REPLY_MSG *) pCReplyBuffer->GetBuffer();

    pmsgReply->dwMsgType = PMSG_TEAM_MANAGE_MEMBER_REPLY;
    pmsgReply->dwMsgLen = sizeof(P_TEAM_MANAGE_MEMBER_REPLY_MSG) - sizeof(BASE_MSG_HEADER);
    pmsgReply->dwSeqNum = dwSeqNum;
    pmsgReply->sgaddr = sgaddrIgnore;
    pmsgReply->hr = hrReply;

    pCReplyConn->Send(pCReplyBuffer);

lDone:

    SAFE_RELEASE(pCReplyBuffer);

    return hr;
}


/*****************************************************************************

CSwitchboard::SendTeamRecruitReply

Send a Team Recruit Reply message, possibly with an error code

*****************************************************************************/
HRESULT CSwitchboard::SendTeamRecruitReply(
    DWORD dwSeqNum,
    HRESULT hrReply,
    CClientConnection *pCReplyConn)
{
    HRESULT hr = S_OK;
    CTCPCntVarBuffer *pCReplyBuffer = NULL;
    P_TEAM_RECRUIT_REPLY_MSG *pmsgReply = NULL;

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "CSwitchboard::SendTeamRecruitReply for Seq=%d hr=0x%X",
        dwSeqNum,
        hrReply);

    // Send a response
    pCReplyBuffer = g_pBufferPool->GetBuffer(sizeof(P_TEAM_RECRUIT_REPLY_MSG));
    if (pCReplyBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pmsgReply = (P_TEAM_RECRUIT_REPLY_MSG *) pCReplyBuffer->GetBuffer();

    pmsgReply->dwMsgType = PMSG_TEAM_RECRUIT_REPLY;
    pmsgReply->dwMsgLen = sizeof(P_TEAM_RECRUIT_REPLY_MSG) - sizeof(BASE_MSG_HEADER);
    pmsgReply->dwSeqNum = dwSeqNum;
    pmsgReply->sgaddr = sgaddrIgnore;
    pmsgReply->hr = hrReply;

    pCReplyConn->Send(pCReplyBuffer);

lDone:

    SAFE_RELEASE(pCReplyBuffer);

    return hr;
}

/*****************************************************************************

CSwitchboard::SendTeamJoinReply

Send a Team Join Reply message, possibly with an error code

*****************************************************************************/
HRESULT CSwitchboard::SendTeamJoinReply(
    DWORD dwSeqNum,
    HRESULT hrReply,
    CClientConnection *pCReplyConn)
{
    HRESULT hr = S_OK;
    CTCPCntVarBuffer *pCReplyBuffer = NULL;
    P_TEAM_JOIN_REPLY_MSG *pmsgReply = NULL;

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "CSwitchboard::SendTeamJoinReply for Seq=%d hr=0x%X",
        dwSeqNum,
        hrReply);

    // Send a response
    pCReplyBuffer = g_pBufferPool->GetBuffer(sizeof(P_TEAM_JOIN_REPLY_MSG));
    if (pCReplyBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pmsgReply = (P_TEAM_JOIN_REPLY_MSG *) pCReplyBuffer->GetBuffer();

    pmsgReply->dwMsgType = PMSG_TEAM_JOIN_REPLY;
    pmsgReply->dwMsgLen = sizeof(P_TEAM_JOIN_REPLY_MSG) - sizeof(BASE_MSG_HEADER);
    pmsgReply->dwSeqNum = dwSeqNum;
    pmsgReply->sgaddr = sgaddrIgnore;
    pmsgReply->hr = hrReply;

    pCReplyConn->Send(pCReplyBuffer);

lDone:

    SAFE_RELEASE(pCReplyBuffer);

    return hr;
}


/*****************************************************************************

CSwitchboard::SendTeamGetTicketReply

Send a Team Get Ticket Reply message, possibly with an error code

*****************************************************************************/
HRESULT CSwitchboard::SendTeamGetTicketReply(
    DWORD dwSeqNum,
    HRESULT hrReply,
    QWORD qwUserID,
    DWORD cTeamIDs,
    QWORD *pqwTeamIDs,
    CClientConnection *pCReplyConn)
{
    HRESULT hr = S_OK;
    CTCPCntVarBuffer *pCReplyBuffer = NULL;
    BYTE *pbWork;
    P_TEAM_GET_TICKET_REPLY_MSG *pmsgReply = NULL;

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "CSwitchboard::SendTeamGetTicketReply for Seq=%d hr=0x%X",
        dwSeqNum,
        hrReply);

    // Send a response
    pCReplyBuffer = g_pBufferPool->GetBuffer(
        sizeof(P_TEAM_GET_TICKET_REPLY_MSG) +
        (cTeamIDs * sizeof(QWORD)) +
        8);
    if (pCReplyBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }
    pbWork = pCReplyBuffer->GetBuffer();
    pmsgReply = (P_TEAM_GET_TICKET_REPLY_MSG *) pbWork;
    pbWork += sizeof(P_TEAM_GET_TICKET_REPLY_MSG);

    pmsgReply->dwMsgType = PMSG_TEAM_GET_TICKET_REPLY;
    pmsgReply->dwMsgLen =
        sizeof(P_TEAM_GET_TICKET_REPLY_MSG) - sizeof(BASE_MSG_HEADER) +
        (cTeamIDs * sizeof(QWORD)) +
        8;
    pmsgReply->dwSeqNum = dwSeqNum;
    pmsgReply->sgaddr = sgaddrIgnore;
    pmsgReply->hr = hrReply;

    pmsgReply->sTeamTicket.qwUserID = qwUserID;
    pmsgReply->sTeamTicket.cTeams = (WORD) cTeamIDs;
    pmsgReply->sTeamTicket.cbSignature = 8;

    memcpy(pbWork, pqwTeamIDs, cTeamIDs * sizeof(QWORD));
    pbWork += cTeamIDs * sizeof(QWORD);
    memset(pbWork, 0, 8);

    pCReplyConn->Send(pCReplyBuffer);

lDone:

    SAFE_RELEASE(pCReplyBuffer);

    return hr;
}


/*****************************************************************************

CSwitchboard::KillUser

Set a user as offline, cleans up their state and redies them for cleanup later

*****************************************************************************/
HRESULT CSwitchboard::KillUser(CPresence *pCPresence)
{
    HRESULT hr = S_OK;

    if (pCPresence->IsOnline())
    {
        // Set the victim's state as offline
        pCPresence->SetOffline();

        // Clear invitation if outstanding
        hr = ClearInvitation(pCPresence);
        if (FAILED(hr))
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_458, "CSwitchboard::KillUser - Failure to clear invitation hr=0x%X", hr);
            hr = S_OK;
        }
    }

    // Send notifications to subscribed buddies
    hr = NotifyPresenceAll(pCPresence);
    if (FAILED(hr))
    {
        // Ignore failures, specific errors logged by the function
        XomTrace(PresenceDebug, L_NORMAL, "Failure to notify all buddies on state change hr=0x%X", hr);
        hr = S_OK;
    }

    // Unsubscribe from buddies
    hr = UnsubscribeFromAllBuddies(pCPresence);
    if (FAILED(hr))
    {
        // Ignore failures, specific errors logged by the function
        XomTrace(PresenceDebug, L_NORMAL, "CSwitchboard::KillUser - Failure to unsubscribe from all buddies hr=0x%X", hr);
        hr = S_OK;
    }

    if (g_CPresCfg.GetPresUserCleanupDelay() == 0)
    {
        // Immediate cleanup
        pCPresence->SelfDestruct();
    }

    return hr;
}

/*****************************************************************************

CSwitchboard::SetQValsReply

Process SetQValsReplies from the SG.

*****************************************************************************/
void CSwitchboard::SetQValsReply(
    SGADDR *psgaddr,
    QWORD qwUserId,
    DWORD dwContext,
    BOOL fNotFound,
    BOOL fNoSuchUser)
{
    if (fNotFound || fNoSuchUser)
    {
        DeadXBox(*psgaddr);
    }
    else
    {
        CPresence *pCPresence = NULL;
        g_CPresenceUserIndex.FindPresence(qwUserId, &pCPresence);
        if ((pCPresence != NULL) &&
            (pCPresence->HasOnlineRecord()))
        {
            pCPresence->SetLastActiveTime();
            pCPresence->SetQValsReply( dwContext );
        }

        SAFE_RELEASE(pCPresence);
    }
}

/*****************************************************************************

CSwitchboard::EnumerateMessagesComplete

Callback after the profile store has completed EnumerateMessages

*****************************************************************************/
void CSwitchboard::EnumerateMessagesComplete(CEnumerateMessagesContext *pCCtx)
{
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Switchboard - EnumerateMessagesComplete User=%I64X hr=0x%X",
        pCCtx->m_qwUserID,
        pCCtx->m_hr);

    HRESULT hr = S_OK;
    DWORD dwMaxItems = MAX_TRANSIENT_MESSAGES;
    DWORD dwMaxItemDataSize = MAX_TRANSIENT_MESSAGES * ( sizeof( Q_MESSAGE_SUMMARY ) + XONLINE_MAX_MESSAGE_DETAILS );
    DWORD dwNextItemID;
    DWORD cItemsLeft;
    CQueueItem* pFirstItem;
    DWORD cStoreItems = 0;
    DWORD cMemItems = 0;

    // Check the operation for failure
    hr = pCCtx->m_hr;
    if (FAILED(hr))
    {
        goto lDone;
    }

    XOMASSERT( pCCtx->m_pCReply != NULL );
    Q_ENUM_MESSAGES_REPLY_MSG *pmsgReply = (Q_ENUM_MESSAGES_REPLY_MSG *) pCCtx->m_pCReply->GetBuffer();

    // NOTE: We allow a user to enumerate their messages even if Alive failed with XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT.  This
    // is because the Dash will need to be able to get the user's required messages after receiving this error code.

    // We have the persistent messages, now look for any transient messages
    cStoreItems = pmsgReply->cMessages;

    // See if there's currently a record for the given user
    if((NULL != pCCtx->m_pCPresence) &&
        (pCCtx->m_pCPresence->HasOnlineRecord()))
    {
        // Get the list of items out of the queue
        hr = pCCtx->m_pCPresence->ListItems(
            FALSE, // list all items, not just V1
            PQUEUE_TRANSIENT_MSGS,
            0, // Start with the first item
            &dwMaxItems,
            &dwMaxItemDataSize,
            &pFirstItem,
            &dwNextItemID,
            &cItemsLeft);
        if( FAILED( hr ) )
        {
            goto lDone;
        }

        SYSTEMTIME systime;
        GetSystemTime( &systime );

        FILETIME filetime;
        SystemTimeToFileTime( &systime, &filetime );

        MSGTIME mtNow = FileTimeToMsgTime( &filetime );

        for( DWORD iMessage = 0; iMessage < dwMaxItems; iMessage++ )
        {
            Q_MESSAGE_SUMMARY* pMessageSummarySrc = (Q_MESSAGE_SUMMARY*) pFirstItem->GetData();
            Q_MESSAGE_SUMMARY* pMessageSummaryDst = (Q_MESSAGE_SUMMARY*)( pmsgReply + 1 ) + pmsgReply->cMessages;
            Q_MESSAGE_SUMMARY_2* pMessageSummary2Dst = (Q_MESSAGE_SUMMARY_2*)( pmsgReply + 1 ) + pmsgReply->cMessages;

            if (pCCtx->m_dwMsgType == QMSG_ENUM_MESSAGES_2)
            {
                pMessageSummaryDst = (Q_MESSAGE_SUMMARY *)pMessageSummary2Dst;
            }

            // Calculate the expiration time of the message (MSGTIME is a count of seconds)
            MSGTIME mtExpire = pMessageSummarySrc->mtSentTime + ( pMessageSummarySrc->wExpireMinutes * 60 );

            XomTrace(
                PresenceDebug,
                L_NORMAL,
                "Switchboard - EnumerateMessagesComplete mtNow=%d mtExpire=%d pMessageSummarySrc->mtSentTime=%d pMessageSummarySrc->wExpireMinutes=%d",
                mtNow,
                mtExpire,
                pMessageSummarySrc->mtSentTime,
                pMessageSummarySrc->wExpireMinutes);

            // Don't send back messages that are expired
            if( mtExpire > mtNow )
            {
                memcpy( pMessageSummaryDst, pMessageSummarySrc, sizeof( Q_MESSAGE_SUMMARY ) );

                if (pCCtx->m_dwMsgType == QMSG_ENUM_MESSAGES_2)
                {
                    // Zero out the subject for transient messages on enum2
                    memset( pMessageSummary2Dst->szSubject, 0, sizeof(pMessageSummary2Dst->szSubject) );
                }

                pmsgReply->cMessages++;
            }

            pFirstItem = pFirstItem->GetNextInQ();
        }

        cMemItems = pmsgReply->cMessages - cStoreItems;
    }

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Switchboard - EnumerateMessagesComplete User=%I64X cStoreItems=%u cMemItems=%u hr=0x%X",
        pCCtx->m_qwUserID,
        cStoreItems,
        cMemItems,
        pCCtx->m_hr );

    if (pCCtx->m_dwMsgType == QMSG_ENUM_MESSAGES_2)
    {
        // Sort the messages by sent time
        qsort( (Q_MESSAGE_SUMMARY_2*)( pmsgReply + 1 ), pmsgReply->cMessages, sizeof( Q_MESSAGE_SUMMARY_2 ), CompareMessageSentTime2 );

        // Resize the final buffer down to the correct size
        // NOTE: Do this before setting dwMsgLen.
        pCCtx->m_pCReply = pCCtx->m_pCReply->Resize( sizeof(Q_ENUM_MESSAGES_2_REPLY_MSG) + ( sizeof(Q_MESSAGE_SUMMARY_2) * pmsgReply->cMessages ) );
        if( NULL == pCCtx->m_pCReply )
        {
            hr = E_OUTOFMEMORY;
            goto lDone;
        }

        // Send a response
        pmsgReply->dwMsgType = QMSG_ENUM_MESSAGES_2_REPLY;
    }
    else
    {
        // Sort the messages by sent time
        qsort( (Q_MESSAGE_SUMMARY*)( pmsgReply + 1 ), pmsgReply->cMessages, sizeof( Q_MESSAGE_SUMMARY ), CompareMessageSentTime );

        // Resize the final buffer down to the correct size
        // NOTE: Do this before setting dwMsgLen.
        pCCtx->m_pCReply = pCCtx->m_pCReply->Resize( sizeof(Q_ENUM_MESSAGES_REPLY_MSG) + ( sizeof(Q_MESSAGE_SUMMARY) * pmsgReply->cMessages ) );
        if( NULL == pCCtx->m_pCReply )
        {
            hr = E_OUTOFMEMORY;
            goto lDone;
        }

        // Send a response
        pmsgReply->dwMsgType = QMSG_ENUM_MESSAGES_REPLY;
    }
    pmsgReply->dwMsgLen = pCCtx->m_pCReply->GetBufferLength() - sizeof(BASE_MSG_HEADER);
    pmsgReply->dwSeqNum = pCCtx->m_dwSeqNum;
    pmsgReply->hr = S_OK;

    pCCtx->m_pCReplyConn->Send( pCCtx->m_pCReply );

lDone:

    XomLog( PresenceLog, "ENM|%X:%X|%I64X|%X|%X|%X",
        ntohl( pCCtx->m_pCReplyConn->GetSockAddr()->sin_addr.S_un.S_addr ),
        ntohs( pCCtx->m_pCReplyConn->GetSockAddr()->sin_port ),
        pCCtx->m_qwUserID,
        cStoreItems,
        cMemItems,
        hr );

    if( SUCCEEDED(hr) )
    {
        g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_ENUM_MESSAGES_MSGS_COUNTER );
    }
    else
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_ENUM_MESSAGES_MSGS_COUNTER );

        XomNtEvent(XEVENT_PRESENCE_CODE_459, "CSwitchboard::EnumerateMessagesComplete failed hr=0x%X, User=%I64X", hr, pCCtx->m_qwUserID);

        // #22332: Send the right size of empty reply
        if (pCCtx->m_dwMsgType == QMSG_ENUM_MESSAGES_2)
        {
            SendEmptyReply(
                QMSG_ENUM_MESSAGES_2_REPLY,
                sizeof( Q_ENUM_MESSAGES_2_REPLY_MSG ),
                pCCtx->m_dwSeqNum,
                hr,
                pCCtx->m_pCReplyConn);
        }
        else
        {
            SendEmptyReply(
                QMSG_ENUM_MESSAGES_REPLY,
                sizeof( Q_ENUM_MESSAGES_REPLY_MSG ),
                pCCtx->m_dwSeqNum,
                hr,
                pCCtx->m_pCReplyConn);
        }
    }

    SAFE_RELEASE(pCCtx);
}

/*****************************************************************************

CSwitchboard::GetMessageSummaryComplete

Callback after the profile store has completed GetMessageSummary

*****************************************************************************/
void CSwitchboard::GetMessageSummaryComplete(CGetMessageSummaryContext *pCCtx)
{
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Switchboard - GetMessageSummaryComplete User=%I64X Message=0x%08X hr=0x%X",
        pCCtx->m_qwUserID,
        pCCtx->m_dwMessageID,
        pCCtx->m_hr);

    HRESULT hr = S_OK;
    BYTE bMessageType = 0;

    // Check the operation for failure
    hr = pCCtx->m_hr;
    if (FAILED(hr))
    {
        goto lDone;
    }

    XOMASSERT( pCCtx->m_pCReply != NULL );

    // Send a response
    Q_MESSAGE_SUMMARY_REPLY_MSG *pmsgReply = (Q_MESSAGE_SUMMARY_REPLY_MSG *) pCCtx->m_pCReply->GetBuffer();

    if (pCCtx->m_dwMsgType == QMSG_MESSAGE_SUMMARY_2)
    {
        pmsgReply->dwMsgType = QMSG_MESSAGE_SUMMARY_2_REPLY;
    }
    else
    {
        pmsgReply->dwMsgType = QMSG_MESSAGE_SUMMARY_REPLY;
    }
    pmsgReply->dwMsgLen = pCCtx->m_pCReply->GetBufferLength() - sizeof(BASE_MSG_HEADER);
    pmsgReply->dwSeqNum = pCCtx->m_dwSeqNum;
    pmsgReply->hr = S_OK;

    bMessageType = pmsgReply->summary.bMessageType;

    pCCtx->m_pCReplyConn->Send( pCCtx->m_pCReply );

lDone:

    XomLog( PresenceLog, "SUM|%X:%X|%I64X|%X|%X|%X",
        ntohl( pCCtx->m_pCReplyConn->GetSockAddr()->sin_addr.S_un.S_addr ),
        ntohs( pCCtx->m_pCReplyConn->GetSockAddr()->sin_port ),
        pCCtx->m_qwUserID,
        pCCtx->m_dwMessageID,
        bMessageType,
        hr );

    if( SUCCEEDED(hr) )
    {
        g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_MESSAGE_SUMMARY_MSGS_COUNTER );
    }
    else
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_MESSAGE_SUMMARY_MSGS_COUNTER );

        XomNtEvent(XEVENT_PRESENCE_CODE_460, "CSwitchboard::GetMessageSummaryComplete failed hr=0x%X", hr);

        // #22332: Send the right size of empty reply
        if (pCCtx->m_dwMsgType == QMSG_MESSAGE_SUMMARY_2)
        {
            SendEmptyReply(
                QMSG_MESSAGE_SUMMARY_2_REPLY,
                sizeof( Q_MESSAGE_SUMMARY_2_REPLY_MSG ),
                pCCtx->m_dwSeqNum,
                hr,
                pCCtx->m_pCReplyConn);
        }
        else
        {
            SendEmptyReply(
                QMSG_MESSAGE_SUMMARY_REPLY,
                sizeof( Q_MESSAGE_SUMMARY_REPLY_MSG ),
                pCCtx->m_dwSeqNum,
                hr,
                pCCtx->m_pCReplyConn);
        }
    }

    SAFE_RELEASE(pCCtx);
}

/*****************************************************************************

CSwitchboard::GetMessageDetailsComplete

Callback after the profile store has completed GetMessageDetails

*****************************************************************************/
void CSwitchboard::GetMessageDetailsComplete(CGetMessageDetailsContext *pCCtx)
{
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Switchboard - GetMessageDetailsComplete User=%I64X Message=0x%08X hr=0x%X",
        pCCtx->m_qwUserID,
        pCCtx->m_dwMessageID,
        pCCtx->m_hr);

    HRESULT hr = S_OK;
    BYTE bMessageType = 0;

    // Check the operation for failure
    hr = pCCtx->m_hr;
    if (FAILED(hr))
    {
        goto lDone;
    }

    XOMASSERT( pCCtx->m_pCReply != NULL );

    // Send a response
    Q_MESSAGE_DETAILS_REPLY_MSG *pmsgReply = (Q_MESSAGE_DETAILS_REPLY_MSG *) pCCtx->m_pCReply->GetBuffer();

    pmsgReply->dwMsgType = QMSG_MESSAGE_DETAILS_REPLY;
    pmsgReply->dwMsgLen = pCCtx->m_pCReply->GetBufferLength() - sizeof(BASE_MSG_HEADER);
    pmsgReply->dwSeqNum = pCCtx->m_dwSeqNum;
    pmsgReply->hr = S_OK;

    bMessageType = pmsgReply->summary.bMessageType;

    pCCtx->m_pCReplyConn->Send( pCCtx->m_pCReply );

lDone:

    XomLog( PresenceLog, "DET|%X:%X|%I64X|%X|%X|%X|%X|%X",
        ntohl( pCCtx->m_pCReplyConn->GetSockAddr()->sin_addr.S_un.S_addr ),
        ntohs( pCCtx->m_pCReplyConn->GetSockAddr()->sin_port ),
        pCCtx->m_qwUserID,
        pCCtx->m_dwMessageID,
        pCCtx->m_dwSetFlags,
        pCCtx->m_dwUnsetFlags,
        bMessageType,
        hr );

    if( SUCCEEDED(hr) )
    {
        g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_MESSAGE_DETAILS_MSGS_COUNTER );
    }
    else
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_MESSAGE_DETAILS_MSGS_COUNTER );

        XomNtEvent(XEVENT_PRESENCE_CODE_461, "CSwitchboard::GetMessageDetailsComplete failed hr=0x%X", hr);

        SendEmptyReply(
            QMSG_MESSAGE_DETAILS_REPLY,
            sizeof( Q_MESSAGE_DETAILS_REPLY_MSG ),
            pCCtx->m_dwSeqNum,
            hr,
            pCCtx->m_pCReplyConn);
    }

    SAFE_RELEASE(pCCtx);
}

/*****************************************************************************

CSwitchboard::DeleteMessageComplete

Callback after the profile store has completed DeleteMessage

*****************************************************************************/
void CSwitchboard::DeleteMessageComplete(CDeleteMessageContext *pCCtx)
{
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Switchboard - DeleteMessageComplete User=%I64X Message=0x%08X hr=0x%X",
        pCCtx->m_qwUserID,
        pCCtx->m_dwMessageID,
        pCCtx->m_hr);

    HRESULT hr = S_OK;
    CTCPCntVarBuffer *pCReplyBuffer = NULL;
    Q_DELETE_MESSAGE_REPLY_MSG *pmsgReply = NULL;

    // Check the operation for failure
    hr = pCCtx->m_hr;
    if (FAILED(hr))
    {
        goto lDone;
    }

    // NOTE: When the Dash is reading required messages, Alive will have failed and there will not be a user record.
    if((NULL != pCCtx->m_pCPresence) &&
        (pCCtx->m_pCPresence->HasOnlineRecord()))
    {
         pCCtx->m_pCPresence->SetXMsgDeleteQVals( pCCtx->m_dwMessageID, TRUE );

         // Keep the in-memory block list up to date so we know when we need to make trips to the database for blocking and unblocking
         if( pCCtx->m_dwFlags & XMSG_DELETE_MESSAGE_FLAG_BLOCK_SENDER )
         {
             XOMASSERT( 0 != pCCtx->m_qwSenderID );
             pCCtx->m_pCPresence->BlockUser( pCCtx->m_qwSenderID );
         }
    }

    if (pCCtx->m_pCReplyConn != NULL)
    {
        // Send a response
        pCReplyBuffer = g_pBufferPool->GetBuffer( sizeof(Q_DELETE_MESSAGE_REPLY_MSG) );
        if (pCReplyBuffer == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto lDone;
        }

        pmsgReply = (Q_DELETE_MESSAGE_REPLY_MSG *) pCReplyBuffer->GetBuffer();

        pmsgReply->dwMsgType = QMSG_DELETE_MESSAGE_REPLY;
        pmsgReply->dwMsgLen = sizeof(Q_DELETE_MESSAGE_REPLY_MSG) - sizeof(BASE_MSG_HEADER);
        pmsgReply->hr = S_OK;

        if (pCCtx->m_fFromPresence)
        {
            pmsgReply->dwSeqNum = ((CPresConnection *)(pCCtx->m_pCReplyConn))->IncrementSequenceNumber();
        }
        else
        {
            pmsgReply->dwSeqNum = pCCtx->m_dwSeqNum;
        }

        pCCtx->m_pCReplyConn->Send( pCReplyBuffer );
    }

lDone:

    // LineType|SG IP|SG Port|UserPUID|MsgID|Flags|HR
    XomLog( PresenceLog, "DEL|%X:%X|%I64X|%X|%X|%X",
        pCCtx->m_pCReplyConn == NULL ? 0 : ntohl( pCCtx->m_pCReplyConn->GetSockAddr()->sin_addr.S_un.S_addr ),
        pCCtx->m_pCReplyConn == NULL ? 0 : ntohs( pCCtx->m_pCReplyConn->GetSockAddr()->sin_port ),
        pCCtx->m_qwUserID,
        pCCtx->m_dwMessageID,
        pCCtx->m_dwFlags,
        hr );
    XomLog( Reporting_v2, "DEL|%X:%X|%I64X|%X|%X|%X",
        pCCtx->m_pCReplyConn == NULL ? 0 : ntohl( pCCtx->m_pCReplyConn->GetSockAddr()->sin_addr.S_un.S_addr ),
        pCCtx->m_pCReplyConn == NULL ? 0 : ntohs( pCCtx->m_pCReplyConn->GetSockAddr()->sin_port ),
        pCCtx->m_qwUserID,
        pCCtx->m_dwMessageID,
        pCCtx->m_dwFlags,
        hr );

    if( SUCCEEDED(hr) )
    {
        if( pCCtx->m_fFromPresence )
        {
            g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_DELETE_MESSAGE_MSGS_FROM_PRES_COUNTER );
        }
        else
        {
            g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_Q_DELETE_MESSAGE_MSGS_COUNTER );
        }
    }
    else
    {
        if( pCCtx->m_fFromPresence )
        {
            g_Counters.TrackFailureMessage( XPPERF_SERVER_DELETE_MESSAGE_MSGS_FROM_PRES_COUNTER );
        }
        else
        {
            g_Counters.TrackFailureMessage( XPPERF_SERVER_Q_DELETE_MESSAGE_MSGS_COUNTER );
        }

        if (hr != XONLINE_E_MESSAGE_INVALID_MESSAGE_ID)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_462, "CSwitchboard::DeleteMessageComplete failed hr=0x%X", hr);
        }

        if (pCCtx->m_pCReplyConn != NULL)
        {
            if (pCCtx->m_fFromPresence)
            {
                ((CPresConnection *)(pCCtx->m_pCReplyConn))->SendEmptyReply(
                    QMSG_DELETE_MESSAGE_REPLY,
                    sizeof( Q_DELETE_MESSAGE_REPLY_MSG ),
                    hr);
            }
            else
            {
                SendEmptyReply(
                    QMSG_DELETE_MESSAGE_REPLY,
                    sizeof( Q_DELETE_MESSAGE_REPLY_MSG ),
                    pCCtx->m_dwSeqNum,
                    hr,
                    (CClientConnection *)(pCCtx->m_pCReplyConn));
            }
        }
    }

    SAFE_RELEASE(pCCtx);

    SAFE_RELEASE(pCReplyBuffer);
}

/*****************************************************************************

CSwitchboard::SendMessageExternalComplete

Callback after the Notification cluster completed SendMessage

*****************************************************************************/
void CSwitchboard::SendMessageExternalComplete( CSendMessageExternalContext *pCCtx )
{
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Switchboard - SendMessageExternalComplete Sender=%I64X",
        pCCtx->m_Message.qwSenderID );

    Q_SEND_MESSAGE_REPLY_MSG* pReplyMsg = NULL;

    // Success or failure, there should be one result for each recipient we sent to
    if( pCCtx->m_cRecipientResults != (LONG)pCCtx->m_Message.cRecipients )
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_463,
            "CSwitchboard::SendMessageExternalComplete - count of recipient results != recipients (%d != %d)",
            pCCtx->m_cRecipientResults,
            pCCtx->m_Message.cRecipients);

        pCCtx->m_pSendReplyBuffer = pCCtx->m_pSendReplyBuffer->Resize( sizeof( Q_SEND_MESSAGE_REPLY_MSG ) + pCCtx->m_cRecipientResults * sizeof( Q_RECIPIENT_RESULT ) );
    }

    pReplyMsg = (Q_SEND_MESSAGE_REPLY_MSG*)pCCtx->m_pSendReplyBuffer->GetBuffer();

    // Finish setting values on the message
    pReplyMsg->dwMsgType = QMSG_SEND_MESSAGE_REPLY;
    pReplyMsg->dwMsgLen = pCCtx->m_pSendReplyBuffer->GetBufferLength() - sizeof( BASE_MSG_HEADER );
    pReplyMsg->dwSeqNum = pCCtx->m_dwOrigSeqNum;
    pReplyMsg->sgaddr = sgaddrIgnore;

    pReplyMsg->hr = pCCtx->m_fSomeRecipientsFailed ? S_FALSE : S_OK;
    pReplyMsg->cRecipients = (WORD)pCCtx->m_cRecipientResults;

    if (pCCtx->m_pCReplyConn != NULL)
    {
        pCCtx->m_pCReplyConn->Send( pCCtx->m_pSendReplyBuffer );
    }

    // For legal reasons we need to log the sender, recipients, and time of each message (Xom logs the time)

    // NOTE: The sizeof a string includes the NULL, which here will account for our ';'
    const Q_RECIPIENT_RESULT* pRecipients = (const Q_RECIPIENT_RESULT*)( pReplyMsg + 1 );
    char szBuffer[ sizeof( "0123456789ABCDEF" ) * XONLINE_MAX_MESSAGE_RECIPIENTS + 1 ];
    szBuffer[ 0 ] = '\0';
    char* pszCursor = szBuffer;
    for( DWORD iRecip = 0; iRecip < (WORD) pCCtx->m_cRecipientResults; iRecip++ )
    {
        pszCursor += sprintf( pszCursor, "%I64X;", pRecipients[ iRecip ].qwUserID );
    }
    if( 0 != pCCtx->m_cRecipientResults )
    {
        // Remove the trailing semi-colon
        pszCursor[ -1 ] = '\0';
    }

    // NOTE: This is logged at the highest logging level so that it cannot be turned off since there are legal
    // requirements around it.
    XomTrace( PresenceLog, L_MUTED, "SND|%X:%X|%I64X|%I64X|%X|%X|%X|%X|%X|%s|%X",
        pCCtx->m_pCReplyConn == NULL ? 0 : ntohl( pCCtx->m_pCReplyConn->GetSockAddr()->sin_addr.S_un.S_addr ),
        pCCtx->m_pCReplyConn == NULL ? 0 : ntohs( pCCtx->m_pCReplyConn->GetSockAddr()->sin_port ),
        pCCtx->m_Message.qwSenderID,
        pCCtx->m_Message.qwSenderContext,
        pCCtx->m_Message.dwSenderTitleID,
        pCCtx->m_Message.dwMessageFlags,
        pCCtx->m_Message.wExpireMinutes,
        pCCtx->m_Message.cbDetails,
        pCCtx->m_Message.bMessageType,
        szBuffer,
        pReplyMsg->hr );
    XomLog( Reporting, "SND|%X:%X|%I64X|%I64X|%X|%X|%X|%X|%X|%s|%X",
        pCCtx->m_pCReplyConn == NULL ? 0 : ntohl( pCCtx->m_pCReplyConn->GetSockAddr()->sin_addr.S_un.S_addr ),
        pCCtx->m_pCReplyConn == NULL ? 0 : ntohs( pCCtx->m_pCReplyConn->GetSockAddr()->sin_port ),
        pCCtx->m_Message.qwSenderID,
        pCCtx->m_Message.qwSenderContext,
        pCCtx->m_Message.dwSenderTitleID,
        pCCtx->m_Message.dwMessageFlags,
        pCCtx->m_Message.wExpireMinutes,
        pCCtx->m_Message.cbDetails,
        pCCtx->m_Message.bMessageType,
        szBuffer,
        pReplyMsg->hr );

    // Everything succeeded
    if( pCCtx->m_fFromPresence )
    {
        g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_SEND_MESSAGE_MSGS_FROM_PRES_COUNTER );
    }
    else
    {
        g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_SEND_MESSAGE_MSGS_COUNTER );
    }

    SAFE_RELEASE(pCCtx);
}

/*****************************************************************************

CSwitchboard::SendMessageInternalComplete

Callback after the profile store has completed SendMessage

*****************************************************************************/
void CSwitchboard::SendMessageInternalComplete(CSendMessageInternalContext *pCCtx)
{
    XOMASSERT( pCCtx != NULL );

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Switchboard - SendMessageInternalComplete Sender=%I64X hr=0x%X",
        pCCtx->m_Message.qwSenderID,
        pCCtx->m_hr);

    HRESULT hr = S_OK;
    CTCPCntVarBuffer *pCReplyBuffer = NULL;

    if( NULL != pCCtx->m_pCReplyConn )
    {
        Q_SEND_MESSAGE_INTERNAL_REPLY_MSG *pmsgReply = NULL;
        BYTE* pbWrite = NULL;

        // Allocate the response buffer
        pCReplyBuffer = g_pBufferPool->GetBuffer( sizeof(Q_SEND_MESSAGE_INTERNAL_REPLY_MSG) + ( pCCtx->m_Message.cRecipients * sizeof(Q_RECIPIENT_RESULT) ) );
        if (pCReplyBuffer == NULL)
        {
            hr = E_OUTOFMEMORY;

            pCCtx->m_pCReplyConn->SendEmptySendReply(pCCtx->m_dwSeqNum, hr);

            goto lDone;
        }

        // Send a response
        pmsgReply = (Q_SEND_MESSAGE_INTERNAL_REPLY_MSG *) pCReplyBuffer->GetBuffer();
        pmsgReply->dwMsgType = QMSG_SEND_MESSAGE_REPLY;
        pmsgReply->dwMsgLen = pCReplyBuffer->GetBufferLength() - sizeof(BASE_MSG_HEADER);
        pmsgReply->dwContext = pCCtx->m_dwSeqNum;
        pmsgReply->dwSeqNum = pCCtx->m_pCReplyConn->IncrementSequenceNumber();
        pmsgReply->hr = pCCtx->m_hr; // S_OK = all succeeded, S_FALSE = some recipients failed, E_xxx = all failed
        pmsgReply->cRecipients = pCCtx->m_Message.cRecipients;

        pbWrite = (BYTE*)(pmsgReply + 1);

        // Note the result of the send to each recipient.  The result either has the high bit set, and is an
        // HRESULT, or the high bit is not set and it is a message ID.
        for( DWORD iRecipient = 0; iRecipient < pCCtx->m_Message.cRecipients; iRecipient++ )
        {
            Q_RECIPIENT_RESULT* pResult = (Q_RECIPIENT_RESULT*)pbWrite;

            pResult->qwUserID = pCCtx->m_rgqwRecipientIDs[ iRecipient ];

            XOMASSERT( pCCtx->m_rgqwRecipientIDs[ iRecipient ] == pCCtx->m_RecipientResults[ iRecipient ].qwUserID );

            if( FAILED( pCCtx->m_hr ) )
            {
                pResult->hrRecipient = pCCtx->m_hr;
            }
            else
            {
                // NOTE: hrRecipient/dwMessageID are a union
                pResult->hrRecipient = pCCtx->m_RecipientResults[ iRecipient ].hrRecipient;
                if( XONLINE_MSG_TYPE_GAME_INVITE != pCCtx->m_Message.bMessageType &&
                    SUCCEEDED( pCCtx->m_RecipientResults[ iRecipient ].hrRecipient) )
                {
                    if((NULL != pCCtx->m_rgpCPresence[iRecipient]) &&
                        (pCCtx->m_rgpCPresence[iRecipient]->HasOnlineRecord()))
                    {
                        pCCtx->m_rgpCPresence[iRecipient]->SetXMsgAddQVals(
                            &pCCtx->m_Message,
                            FALSE, // SenderIsFriend doesn't apply to non-invites
                            pCCtx->m_RecipientResults[ iRecipient ].dwMessageID );
                    }
                }
            }

            pbWrite += sizeof(Q_RECIPIENT_RESULT);
        }

        pCCtx->m_pCReplyConn->Send( pCReplyBuffer );
    }
    else
    {
        // Sends to the local server come down this path
        XOMASSERT( NULL != pCCtx->m_pExternalCtx );

        // Set QVals if appropriate
        if( SUCCEEDED( pCCtx->m_hr ) &&
            XONLINE_MSG_TYPE_GAME_INVITE != pCCtx->m_Message.bMessageType )
        {
            for( DWORD iRecipient = 0; iRecipient < pCCtx->m_Message.cRecipients; iRecipient++ )
            {
                // NOTE: hrRecipient/dwMessageID are a union
                if( SUCCEEDED( pCCtx->m_RecipientResults[ iRecipient ].hrRecipient) )
                {
                    if((NULL != pCCtx->m_rgpCPresence[iRecipient]) &&
                        (pCCtx->m_rgpCPresence[iRecipient]->HasOnlineRecord()))
                    {
                        pCCtx->m_rgpCPresence[iRecipient]->SetXMsgAddQVals(
                            &pCCtx->m_Message,
                            FALSE, // SenderIsFriend doesn't apply to non-invites
                            pCCtx->m_RecipientResults[ iRecipient ].dwMessageID );
                    }
                }
            }
        }

        pCCtx->m_pExternalCtx->HandleSendReply( pCCtx->m_Message.cRecipients, pCCtx->m_RecipientResults, pCCtx->m_hr);
    }

lDone:
    if( FAILED(hr) )
    {
        XomNtEvent(XEVENT_PRESENCE_CODE_464, "CSwitchboard::SendMessageInternalComplete failed hr=0x%X", hr);
    }

    SAFE_RELEASE(pCCtx);

    SAFE_RELEASE(pCReplyBuffer);
}


/*****************************************************************************

CSwitchboard::RevokeMessageComplete

Callback after the profile store has completed RevokeMessage

*****************************************************************************/
void CSwitchboard::RevokeMessageComplete( CRevokeMessageContext *pCCtx )
{
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Switchboard - RevokeMessageComplete Sender=%I64X",
        pCCtx->m_Message.qwSenderID);

    // Set each recipient's QVals appropriately
    for( DWORD iRecipient = 0; iRecipient < pCCtx->m_Message.cRecipients; iRecipient++ )
    {
        if( SUCCEEDED( pCCtx->m_hrRecipient[ iRecipient ] ) )
        {
            // NOTE: removed because of migration concerns.  did we ever really need this at all?
            //
            //if (pCCtx->m_rgpCPresence[iRecipient] == NULL)
            //{
            //    // maybe they just logged on?
            //    pCCtx->m_rgpCPresence[iRecipient] = g_CPresenceUserIndex.FindPresence(pCCtx->m_rgRecipients[iRecipient].qwUserID);
            //}

            // Revoking this message may have destroyed the user, so it is okay if we don't find them.
            if((NULL != pCCtx->m_rgpCPresence[iRecipient]) &&
                (pCCtx->m_rgpCPresence[iRecipient]->HasOnlineRecord()))
            {
                BOOL fPush = TRUE;

                // bug 40110: xbox1 dashboard can crash if it gets this qval too soon after an invite answer.
                if ((pCCtx->m_rgpCPresence[iRecipient]->GetTitleID() == XONLINE_XBOX_DASH_TITLE_ID) &&
                    (pCCtx->m_Message.bMessageType == XONLINE_MSG_TYPE_GAME_INVITE))
                {
                    // dont push the qvals.  they will get sent after some time by the sg.
                    fPush = FALSE;
                    XomTrace(PresenceDebug, L_NORMAL, "RevokeMessageComplete: revoking game invite answered by xbox1 dash.  not setting fPushQvals flag for user %I64X.", pCCtx->m_rgRecipients[ iRecipient ].qwUserID);
                }

                // Tell the user the message got deleted
                pCCtx->m_rgpCPresence[iRecipient]->SetXMsgDeleteQVals( pCCtx->m_rgRecipients[ iRecipient ].dwMessageID, TRUE, fPush);
            }
        }
    }

    SAFE_RELEASE(pCCtx);
}

/*****************************************************************************

CSwitchboard::DeleteUserTitleComplete

Callback after the profile store has completed DeleteUserTitle

*****************************************************************************/
void CSwitchboard::DeleteUserTitleComplete(CDeleteUserTitleContext *pCCtx)
{
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Switchboard - DeleteUserTitleComplete User=%I64X Title=0x%08X hr=0x%X",
        pCCtx->m_qwUserID,
        pCCtx->m_dwTitleID,
        pCCtx->m_hr);

    HRESULT hr = S_OK;
    CTCPCntVarBuffer *pCReplyBuffer = NULL;
    Q_DELETE_TITLE_REPLY_MSG *pmsgReply = NULL;

    // Check the operation for failure
    hr = pCCtx->m_hr;
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Send a response
    pCReplyBuffer = g_pBufferPool->GetBuffer( sizeof(Q_DELETE_TITLE_REPLY_MSG) );
    if (pCReplyBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pmsgReply = (Q_DELETE_TITLE_REPLY_MSG *) pCReplyBuffer->GetBuffer();

    pmsgReply->dwMsgType = QMSG_DELETE_TITLE_REPLY;
    pmsgReply->dwMsgLen = pCReplyBuffer->GetBufferLength() - sizeof(BASE_MSG_HEADER);
    pmsgReply->dwSeqNum = pCCtx->m_dwSeqNum;
    pmsgReply->hr = S_OK;

    pCCtx->m_pCReplyConn->Send(pCReplyBuffer);

lDone:

    XomLog( PresenceLog, "DTL|%X:%X|%I64X|%X|%X",
        ntohl( pCCtx->m_pCReplyConn->GetSockAddr()->sin_addr.S_un.S_addr ),
        ntohs( pCCtx->m_pCReplyConn->GetSockAddr()->sin_port ),
        pCCtx->m_qwUserID,
        pCCtx->m_dwTitleID,
        hr );

    if( SUCCEEDED(hr) )
    {
        g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_DELETE_TITLE_MSGS_COUNTER );
    }
    else
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_DELETE_TITLE_MSGS_COUNTER );

        XomNtEvent(XEVENT_PRESENCE_CODE_465, "CSwitchboard::DeleteUserTitleComplete failed hr=0x%X", hr);

        SendEmptyReply(
            QMSG_DELETE_TITLE_REPLY,
            sizeof( Q_DELETE_TITLE_REPLY_MSG ),
            pCCtx->m_dwSeqNum,
            hr,
            pCCtx->m_pCReplyConn);
    }

    SAFE_RELEASE(pCCtx);

    SAFE_RELEASE(pCReplyBuffer);
}

/*****************************************************************************

CSwitchboard::EnumerateUserTitlesComplete

Callback after the profile store has completed EnumerateUserTitles

*****************************************************************************/
void CSwitchboard::EnumerateUserTitlesComplete(CEnumerateUserTitlesContext *pCCtx)
{
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Switchboard - EnumerateUserTitlesComplete User=%I64X hr=0x%X",
        pCCtx->m_qwUserID,
        pCCtx->m_hr);

    HRESULT hr = S_OK;
    DWORD cTitles = 0;

    // Check the operation for failure
    hr = pCCtx->m_hr;
    if (FAILED(hr))
    {
        goto lDone;
    }

    XOMASSERT( pCCtx->m_pCReply != NULL );

    // Send a response
    Q_ENUM_TITLES_REPLY_MSG *pmsgReply = (Q_ENUM_TITLES_REPLY_MSG *) pCCtx->m_pCReply->GetBuffer();

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Switchboard - EnumerateUserTitlesComplete User=%I64X cTitles=%u hr=0x%X",
        pCCtx->m_qwUserID,
        pmsgReply->cTitles,
        pCCtx->m_hr );

    pmsgReply->dwMsgType = QMSG_ENUM_TITLES_REPLY;
    pmsgReply->dwMsgLen = pCCtx->m_pCReply->GetBufferLength() - sizeof(BASE_MSG_HEADER);
    pmsgReply->dwSeqNum = pCCtx->m_dwSeqNum;
    pmsgReply->hr = S_OK;

    cTitles = pmsgReply->cTitles;

    pCCtx->m_pCReplyConn->Send( pCCtx->m_pCReply );

lDone:

    XomLog( PresenceLog, "ETL|%X:%X|%I64X|%X|%X",
        ntohl( pCCtx->m_pCReplyConn->GetSockAddr()->sin_addr.S_un.S_addr ),
        ntohs( pCCtx->m_pCReplyConn->GetSockAddr()->sin_port ),
        pCCtx->m_qwUserID,
        cTitles,
        hr );

    if( SUCCEEDED(hr) )
    {
        g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_ENUM_TITLES_MSGS_COUNTER );
    }
    else
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_ENUM_TITLES_MSGS_COUNTER );

        XomNtEvent(XEVENT_PRESENCE_CODE_466, "CSwitchboard::EnumerateUserTitlesComplete failed hr=0x%X", hr);

        SendEmptyReply(
            QMSG_ENUM_TITLES_REPLY,
            sizeof( Q_ENUM_TITLES_REPLY_MSG ),
            pCCtx->m_dwSeqNum,
            hr,
            pCCtx->m_pCReplyConn);
    }

    SAFE_RELEASE(pCCtx);
}

/*****************************************************************************

CSwitchboard::MessageFlagsComplete

Callback after the profile store has completed MessageFlags

*****************************************************************************/
void CSwitchboard::MessageFlagsComplete(CMessageFlagsContext *pCCtx)
{
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Switchboard - MessageFlagsComplete User=%I64X hr=0x%X",
        pCCtx->m_qwUserID,
        pCCtx->m_hr);

    HRESULT hr = S_OK;
    CTCPCntVarBuffer *pCReplyBuffer = NULL;
    Q_MESSAGE_FLAGS_REPLY_MSG *pmsgReply = NULL;

    // Check the operation for failure
    hr = pCCtx->m_hr;
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Send a response
    pCReplyBuffer = g_pBufferPool->GetBuffer( sizeof(Q_MESSAGE_FLAGS_REPLY_MSG) );
    if (pCReplyBuffer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pmsgReply = (Q_MESSAGE_FLAGS_REPLY_MSG *) pCReplyBuffer->GetBuffer();

    pmsgReply->dwMsgType = QMSG_MESSAGE_FLAGS_REPLY;
    pmsgReply->dwMsgLen = pCReplyBuffer->GetBufferLength() - sizeof(BASE_MSG_HEADER);
    pmsgReply->dwSeqNum = pCCtx->m_dwSeqNum;
    pmsgReply->hr = S_OK;

    pCCtx->m_pCReplyConn->Send( pCReplyBuffer );

lDone:

    XomLog( PresenceLog, "FLG|%X:%X|%I64X|%X|%X|%X|%X",
        ntohl( pCCtx->m_pCReplyConn->GetSockAddr()->sin_addr.S_un.S_addr ),
        ntohs( pCCtx->m_pCReplyConn->GetSockAddr()->sin_port ),
        pCCtx->m_qwUserID,
        pCCtx->m_dwMessageID,
        pCCtx->m_dwSetFlags,
        pCCtx->m_dwUnsetFlags,
        hr );

    if( SUCCEEDED(hr) )
    {
        g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_MESSAGE_FLAGS_MSGS_COUNTER );
    }
    else
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_MESSAGE_FLAGS_MSGS_COUNTER );

        if (hr != XONLINE_E_MESSAGE_INVALID_MESSAGE_ID)
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_467, "CSwitchboard::MessageFlagsComplete failed hr=0x%X", hr);
        }

        SendEmptyReply(
            QMSG_MESSAGE_FLAGS_REPLY,
            sizeof( Q_MESSAGE_FLAGS_REPLY_MSG ),
            pCCtx->m_dwSeqNum,
            hr,
            pCCtx->m_pCReplyConn);
    }

    SAFE_RELEASE(pCCtx);

    SAFE_RELEASE(pCReplyBuffer);
}

/*****************************************************************************

CSwitchboard::EnumSystemMessagesComplete

Callback after the profile store has completed EnumSystemMessages

*****************************************************************************/
void CSwitchboard::EnumSystemMessagesComplete( CEnumSystemMessagesContext* pCCtx )
{
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Switchboard - EnumSystemMessagesComplete Title=0x%08X hr=0x%X",
        pCCtx->m_dwTitleID,
        pCCtx->m_hr);

    HRESULT hr = S_OK;
    Q_ENUM_SYSTEM_MESSAGES_REPLY_MSG* pReply = NULL;
    DWORD cMessages = 0;

    // Check the operation for failure
    hr = pCCtx->m_hr;
    if( FAILED( hr ) )
    {
        goto lDone;
    }

    // Check the operation for failure
    hr = pCCtx->m_hr;
    if (FAILED(hr))
    {
        goto lDone;
    }

    pReply = (Q_ENUM_SYSTEM_MESSAGES_REPLY_MSG*) pCCtx->m_pCReply->GetBuffer();

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Switchboard - EnumSystemMessagesComplete Title=0x%08X cMessages=%u hr=0x%X",
        pCCtx->m_dwTitleID,
        pReply->cMessages,
        pCCtx->m_hr );

    cMessages = pReply->cMessages;

    pReply->dwMsgType = QMSG_ENUM_SYSTEM_MESSAGES_REPLY;
    pReply->dwMsgLen = pCCtx->m_pCReply->GetBufferLength() - sizeof( BASE_MSG_HEADER );
    pReply->dwSeqNum = pCCtx->m_dwSeqNum;

    // Send a response
    pCCtx->m_pCReplyConn->Send( pCCtx->m_pCReply );

lDone:

    XomLog( PresenceLog, "ENS|%X:%X|%X|%X|%X",
        ntohl( pCCtx->m_pCReplyConn->GetSockAddr()->sin_addr.S_un.S_addr ),
        ntohs( pCCtx->m_pCReplyConn->GetSockAddr()->sin_port ),
        pCCtx->m_dwTitleID,
        cMessages,
        hr );

    if( SUCCEEDED(hr) )
    {
        g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_ENUM_SYSTEM_MESSAGES_MSGS_COUNTER );
    }
    else
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_ENUM_SYSTEM_MESSAGES_MSGS_COUNTER );

        XomNtEvent(XEVENT_PRESENCE_CODE_468, "CSwitchboard::EnumSystemMessagesComplete failed title=0x%08X hr=0x%X",
            pCCtx->m_dwTitleID,
            hr);

        SendEmptyReply(
            QMSG_ENUM_SYSTEM_MESSAGES_REPLY,
            sizeof( Q_ENUM_SYSTEM_MESSAGES_REPLY_MSG ),
            pCCtx->m_dwSeqNum,
            hr,
            pCCtx->m_pCReplyConn);
    }

    SAFE_RELEASE( pCCtx );
}

/*****************************************************************************

CSwitchboard::GetSystemMessageDetailsComplete

Callback after the profile store has completed GetSystemMessageDetails

*****************************************************************************/
void CSwitchboard::GetSystemMessageDetailsComplete( CSystemMessageDetailsContext* pCCtx )
{
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Switchboard - SystemMessageDetailsComplete Title=0x%08X Message=0x%08X hr=0x%X",
        pCCtx->m_dwTitleID,
        pCCtx->m_dwMessageID,
        pCCtx->m_hr);

    HRESULT hr = S_OK;
    Q_SYSTEM_MESSAGE_DETAILS_REPLY_MSG* pReply = NULL;
    BYTE bMessageType = 0;

    // Check the operation for failure
    hr = pCCtx->m_hr;
    if( FAILED( hr ) )
    {
        goto lDone;
    }

    pReply = (Q_SYSTEM_MESSAGE_DETAILS_REPLY_MSG*) pCCtx->m_pCReply->GetBuffer();

    pReply->dwMsgType = QMSG_SYSTEM_MESSAGE_DETAILS_REPLY;
    pReply->dwMsgLen = pCCtx->m_pCReply->GetBufferLength() - sizeof( BASE_MSG_HEADER );
    pReply->dwSeqNum = pCCtx->m_dwSeqNum;

    bMessageType = pReply->summary.bMessageType;

    // Send a response
    pCCtx->m_pCReplyConn->Send( pCCtx->m_pCReply );

lDone:
    XomLog( PresenceLog, "DTS|%X:%X|%X|%X|%X|%X",
        ntohl( pCCtx->m_pCReplyConn->GetSockAddr()->sin_addr.S_un.S_addr ),
        ntohs( pCCtx->m_pCReplyConn->GetSockAddr()->sin_port ),
        pCCtx->m_dwTitleID,
        pCCtx->m_dwMessageID,
        bMessageType,
        hr );

    if( SUCCEEDED( hr ) )
    {
        g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_SYSTEM_MESSAGE_DETAILS_MSGS_COUNTER );
    }
    else
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_SYSTEM_MESSAGE_DETAILS_MSGS_COUNTER );

        if( XONLINE_E_MESSAGE_INVALID_MESSAGE_ID != hr )
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_469, "CSwitchboard::SystemMessageDetailsComplete failed title=0x%08X message=0x%08X hr=0x%X",
                pCCtx->m_dwTitleID,
                pCCtx->m_dwMessageID,
                hr);
        }

        SendEmptyReply(
            QMSG_SYSTEM_MESSAGE_DETAILS_REPLY,
            sizeof( Q_SYSTEM_MESSAGE_DETAILS_REPLY_MSG ),
            pCCtx->m_dwSeqNum,
            hr,
            pCCtx->m_pCReplyConn);
    }

    SAFE_RELEASE( pCCtx );
}

/*****************************************************************************

CSwitchboard::DeleteSystemMessageComplete

Callback after the profile store has completed DeleteSystemMessage

*****************************************************************************/
void CSwitchboard::DeleteSystemMessageComplete( CDeleteSystemMessageContext* pCCtx )
{
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Switchboard - DeleteSystemMessageComplete Title=0x%08X Message=0x%08X hr=0x%X",
        pCCtx->m_dwTitleID,
        pCCtx->m_dwMessageID,
        pCCtx->m_hr);

    // Succeed or fail we can use the generic reply function since the reply structure contains only
    // an HRESULT.
    SendEmptyReply(
        QMSG_DELETE_SYSTEM_MESSAGE_REPLY,
        sizeof( Q_DELETE_SYSTEM_MESSAGE_REPLY_MSG ),
        pCCtx->m_dwSeqNum,
        pCCtx->m_hr,
        pCCtx->m_pCReplyConn);

    XomLog( PresenceLog, "DES|%X:%X|%X|%X|%X|%X",
        ntohl( pCCtx->m_pCReplyConn->GetSockAddr()->sin_addr.S_un.S_addr ),
        ntohs( pCCtx->m_pCReplyConn->GetSockAddr()->sin_port ),
        pCCtx->m_dwTitleID,
        pCCtx->m_dwMessageID,
        pCCtx->m_dwFlags,
        pCCtx->m_hr );

    if( SUCCEEDED( pCCtx->m_hr ) )
    {
        g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_DELETE_SYSTEM_MESSAGE_MSGS_COUNTER );
    }
    else
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_DELETE_SYSTEM_MESSAGE_MSGS_COUNTER );

        if( XONLINE_E_MESSAGE_INVALID_MESSAGE_ID != pCCtx->m_hr )
        {
            XomNtEvent(XEVENT_PRESENCE_CODE_470, "CSwitchboard::DeleteSystemMessageComplete failed title=0x%08X message=0x%08X hr=0x%X",
                pCCtx->m_dwTitleID,
                pCCtx->m_dwMessageID,
                pCCtx->m_hr);
        }
    }

    SAFE_RELEASE( pCCtx );
}

/*****************************************************************************

CSwitchboard::SendSystemMessageComplete

Callback after the profile store has completed SendSystemMessage

*****************************************************************************/
void CSwitchboard::SendSystemMessageComplete( CSendSystemMessageContext* pCCtx )
{
    XOMASSERT(pCCtx != NULL);

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Switchboard - SendSystemMessageComplete Title=0x%08X Message=0x%08X hr=0x%X",
        pCCtx->m_Message.dwTitleID,
        pCCtx->m_dwMessageID,
        pCCtx->m_hr);

    HRESULT hr = S_OK;
    CTCPCntVarBuffer *pCReplyBuffer = NULL;
    Q_SEND_SYSTEM_MESSAGE_REPLY_MSG *pmsgReply = NULL;

    // Check the operation for failure
    hr = pCCtx->m_hr;
    if( FAILED( hr ) )
    {
        goto lDone;
    }

    // Send a response
    pCReplyBuffer = g_pBufferPool->GetBuffer( sizeof( Q_SEND_SYSTEM_MESSAGE_REPLY_MSG ) );
    if( NULL == pCReplyBuffer )
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pmsgReply = (Q_SEND_SYSTEM_MESSAGE_REPLY_MSG*) pCReplyBuffer->GetBuffer();

    pmsgReply->dwMsgType = QMSG_SEND_SYSTEM_MESSAGE_REPLY;
    pmsgReply->dwMsgLen = pCReplyBuffer->GetBufferLength() - sizeof(BASE_MSG_HEADER);
    pmsgReply->dwSeqNum = pCCtx->m_dwSeqNum;
    pmsgReply->hr = S_OK;
    pmsgReply->dwMessageID = pCCtx->m_dwMessageID;

    pCCtx->m_pCReplyConn->Send( pCReplyBuffer );

lDone:
    XomLog( PresenceLog, "SNS|%X:%X|%I64X|%X|%X|%I64X|%X|%X|%X|%X|%X|%X",
        ntohl( pCCtx->m_pCReplyConn->GetSockAddr()->sin_addr.S_un.S_addr ),
        ntohs( pCCtx->m_pCReplyConn->GetSockAddr()->sin_port ),
        pCCtx->m_Message.qwSenderContext,
        pCCtx->m_Message.dwTitleID,
        pCCtx->m_Message.dwRegion,
        pCCtx->m_Message.ftSentTime,
        pCCtx->m_Message.dwMessageFlags,
        pCCtx->m_Message.wExpireMinutes,
        pCCtx->m_Message.cbDetails,
        pCCtx->m_Message.bMessageType,
        pCCtx->m_dwMessageID,
        hr );

    if( SUCCEEDED( hr ) )
    {
        g_Counters.TrackSuccessfulMessage( XPPERF_SERVER_SEND_SYSTEM_MESSAGE_MSGS_COUNTER );
    }
    else
    {
        g_Counters.TrackFailureMessage( XPPERF_SERVER_SEND_SYSTEM_MESSAGE_MSGS_COUNTER );

        XomNtEvent( XEVENT_PRESENCE_CODE_471, "CSwitchboard::SendSystemMessageComplete failed title=0x%08X hr=0x%X",
            pCCtx->m_Message.dwTitleID,
            hr );

        SendEmptyReply(
            QMSG_SEND_SYSTEM_MESSAGE_REPLY,
            sizeof( Q_SEND_SYSTEM_MESSAGE_REPLY_MSG ),
            pCCtx->m_dwSeqNum,
            hr,
            pCCtx->m_pCReplyConn);
    }

    SAFE_RELEASE( pCCtx );

    SAFE_RELEASE( pCReplyBuffer );
}

/*****************************************************************************

CSwitchboard::AddToQ

Add an item to the given user's given queue

*****************************************************************************/
HRESULT CSwitchboard::AddToQ(
                             const SGADDR* psgaddr,
                             QWORD qwUserID,
                             DWORD dwQType,
                             DWORD cbData,
                             const BYTE *pbData,
                             DWORD *pdwItemID )
{
    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Add: User=%I64X Type=%d DataLen=%d",
        qwUserID,
        dwQType,
        cbData);

    HRESULT hr = S_OK;
    CPresence* pCPresence = NULL;

    // See if there's currently a record for the given user
    hr = g_CPresenceUserIndex.FindPresence(qwUserID, &pCPresence );
    if (pCPresence == NULL)
    {
        goto lDone;
    }
    else if (!pCPresence->IsOnline())
    {
        hr = HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
        goto lDone;
    }

    // Validate the message's sgaddr against the user's
    if (!CheckSGAddr(psgaddr, pCPresence))
    {
        hr = XONLINE_E_SERVER_ERROR;
        goto lDone;
    }

    // PQUEUE_INVITE should now be obsolete, and transient messages should be added using the
    // Messaging APIs.
    if( PQUEUE_INVITE == dwQType ||
        PQUEUE_TRANSIENT_MSGS == dwQType )
    {
        XomTrace(
            PresenceDebug,
            L_ERROR,
            "Add: User=%I64X Type=%d DataLen=%d, can't use PQUEUE_INVITE or PQUEUE_TRANSIENT_MSGS",
            qwUserID,
            dwQType,
            cbData);

        hr = E_INVALIDARG;
        goto lDone;
    }

    // Xenon client should only queue P_QUEUE_PRESENCE_2 items for Presence
    if( ((PQUEUE_PRESENCE == dwQType) || (PQUEUE_PEER_PRESENCE == dwQType))
        && (pCPresence->CanClientConsumeRichPresence() == TRUE) )
    {
        // Ignore the QADD
        goto lDone;
    }

    // Xbox clients should only queue P_QUEUE_PRESENCE or P_QUEUE_PEER_PRESENCE items
    if( (PQUEUE_PRESENCE_2 == dwQType) && (pCPresence->CanClientConsumeRichPresence() == FALSE) )
    {
        // Ignore the QADD
        goto lDone;
    }

    // Geneva clients get presence notifications from Connection Server
    if ((pCPresence->CanClientConsumeRichPresence() == TRUE)
        && (pCPresence->GetVersionFlags() & XONLINE_PRESENCE_VERSION_FLAGS_USE_CONNECTION_SERVER)
        && (PQUEUE_PRESENCE_2 == dwQType))
    {
        goto lDone;
    }

    hr = pCPresence->AddItem(
        dwQType,
        cbData,
        pbData,
        pdwItemID
    );
    if (FAILED(hr))
    {
        XomNtEvent(
                XEVENT_PRESENCE_CODE_472,
                "pCUser->AddItem failed User=%I64X Type=%d hr=0x%X",
                qwUserID,
                dwQType,
                hr);
        goto lDone;
    }

lDone:

    if (FAILED(hr) &&
        (hr != HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER)) &&
        (hr != XONLINE_E_PRESENCE_DEFER_REQUEST) &&
        (hr != XONLINE_E_PRESENCE_USER_MIGRATED))
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_473,
            "m_pSwitchboard->AddToQ (user %I64X type %d) failed hr=0x%X",
            qwUserID,
            dwQType,
            hr);
    }

    SAFE_RELEASE(pCPresence);

    return hr;
}


/*****************************************************************************

CSwitchboard::Dequeue

Dequeue items from the given user's given queue

*****************************************************************************/
HRESULT CSwitchboard::Dequeue(
    DWORD dwSeqNum,
    const SGADDR* psgaddr,
    QWORD qwUserID,
    DWORD dwQType,
    DWORD dwStartItemID,
    DWORD dwMaxItems,
    DWORD dwTotalItemDataSize,
    CClientConnection *pReplyConn )
{
    HRESULT hr = S_OK;
    CPresence* pCPresence = NULL;
    DWORD dwLocalItems = dwMaxItems;
    DWORD dwLocalItemDataSize = dwTotalItemDataSize;
    DWORD dwNextItemID;
    DWORD cItemsLeft;
    CQueueItem* pFirstItem;
    CTCPCntVarBuffer *pCResponse = NULL;
    DWORD cbResponse = 0;
    BOOL fUseLocale = (g_CPresCfg.GetProtocolVersion() > 1) && (dwQType == PQUEUE_PRESENCE_2);
    Q_LIST_REPLY_MSG *pListReplyMsg;
    Q_LIST_REPLY_2_MSG *pListReply2Msg;
    Q_LIST_ITEM *pListReplyItem;
    BYTE *pbWork = NULL;
    CQueueItem* pCWork = NULL;

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Dequeue: User=%I64X Type=%d StartItem=%d MaxItems=%d TotalSize=%d",
        qwUserID,
        dwQType,
        dwStartItemID,
        dwMaxItems,
        dwTotalItemDataSize );

    // Validate arguments
    if(NULL == pReplyConn)
    {
        hr = E_INVALIDARG;
        goto lDone;
    }

    if( dwQType == PQUEUE_TRANSIENT_MSGS )
    {
        // A V2 client is attempting to use the old Dequeue API for Messaging items, not allowed.
        XomTrace(
            PresenceDebug,
            L_ERROR,
            "Dequeue: User=%I64X Type=%d Not allowed for type PQUEUE_TRANSIENT_MSGS",
            qwUserID,
            dwQType);

        hr = E_INVALIDARG;
        goto lDone;
    }
    else if( dwQType == PQUEUE_INVITE )
    {
        // A V1 client is attempting to dequeue their friend invites, make them
        // look through the Messaging queue for those.
        dwQType = PQUEUE_TRANSIENT_MSGS;
    }

    // See if there's currently a record for the given user
    hr = g_CPresenceUserIndex.FindPresence(qwUserID, &pCPresence );
    if (pCPresence == NULL)
    {
        goto lDone;
    }
    else if (!pCPresence->IsOnline())
    {
        hr = HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
        goto lDone;
    }

    // Validate the message's sgaddr against the user's
    if (!CheckSGAddr(psgaddr, pCPresence))
    {
        if (pCPresence->IsOnline())
        {
            // this is only an error if the expected sg is nonzero.  otherwise it may be that the user just logged off.
            g_Counters.IncrementValue32(XPPERF_SERVER_BAD_USER_COUNTER, 1);
            g_Counters.IncrementValue32(XPPERF_SERVER_BAD_USER_RATE, 1);
            hr = XONLINE_E_SERVER_ERROR;
        }
        goto lDone;
    }

    // Get the list of items out of the queue
    hr = pCPresence->ListItems(
        TRUE, // V1 items only
        dwQType,
        dwStartItemID,
        &dwLocalItems,
        &dwLocalItemDataSize,
        &pFirstItem,
        &dwNextItemID,
        &cItemsLeft);
    if (FAILED(hr) && hr != HRESULT_FROM_WIN32( ERROR_INSUFFICIENT_BUFFER ))
    {
        goto lDone;
    }

    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Dequeue: User=%I64X Type=%d Returning %d items",
        qwUserID,
        dwQType == PQUEUE_TRANSIENT_MSGS ? PQUEUE_INVITE : dwQType,
        dwLocalItems);

    // Allocate and populate the response buffer
    cbResponse =
        (fUseLocale ? sizeof (Q_LIST_REPLY_2_MSG) : sizeof(Q_LIST_REPLY_MSG)) +
        (QVAL_COUNT * sizeof(DWORD)) +
        (dwLocalItems * sizeof(Q_LIST_ITEM)) +
        dwLocalItemDataSize;

    pCResponse = g_pBufferPool->GetBuffer( cbResponse );
    if (pCResponse == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Populate the header
    pListReplyMsg = (Q_LIST_REPLY_MSG *) pCResponse->GetBuffer();
    pListReplyMsg->dwMsgType = fUseLocale? QMSG_LIST_REPLY_2 : QMSG_LIST_REPLY;
    pListReplyMsg->dwMsgLen = cbResponse - sizeof(BASE_MSG_HEADER);
    pListReplyMsg->dwSeqNum = dwSeqNum;
    pListReplyMsg->sgaddr = *psgaddr;
    pListReplyMsg->hr = hr;
    pListReplyMsg->qwUserID = qwUserID;
    pListReplyMsg->wQType = (WORD)( dwQType != PQUEUE_TRANSIENT_MSGS ? dwQType : PQUEUE_INVITE );
    pListReplyMsg->dwNextItemID = dwNextItemID;
    pListReplyMsg->wQLeft = (WORD) cItemsLeft;
    pListReplyMsg->wNumItems = (WORD) dwLocalItems;
    pListReplyMsg->dwTotalItemDataSize = dwLocalItemDataSize;

    if (fUseLocale)
    {
        pListReply2Msg = (Q_LIST_REPLY_2_MSG *) pCResponse->GetBuffer();
        memcpy(pListReply2Msg->szLocale, pCPresence->GetCachedLocale(), XONLINE_PRESENCE_LOCALE_SIZE);
    }

    // Populate the data items
    pCWork = pFirstItem;
    pbWork = pCResponse->GetBuffer() +
        (fUseLocale ? sizeof (Q_LIST_REPLY_2_MSG) : sizeof(Q_LIST_REPLY_MSG)) +
        (QVAL_COUNT * sizeof(DWORD));
    while ((pCWork != NULL) &&
           (dwLocalItems > 0))
    {
        CQueueItem* pCVictim = NULL;

        // Fill in the item header
        pListReplyItem = (Q_LIST_ITEM *) pbWork;

        pListReplyItem->dwItemID = pCWork->GetItemID();
        pListReplyItem->wItemLen = (WORD) pCWork->GetV1DataSize();
        pbWork += sizeof(Q_LIST_ITEM);

        // Copy over the data
        memcpy(pbWork, pCWork->GetV1Data(), pCWork->GetV1DataSize());

        pbWork += pCWork->GetV1DataSize();
        dwLocalItems--;

        // Goto the next in queue, deleting the previous if requested
        pCVictim = pCWork;
        pCWork = pCWork->GetNextV1InQ();
        pCVictim->SetDequeued();
    }

    // See if all V1 items have been dequeued, if so, turn off the V1 QFlag before populating
    // QVals.
    if( PQUEUE_TRANSIENT_MSGS == dwQType && 0 == cItemsLeft )
    {
        pCPresence->ResetV1InviteQFlag();
    }

    // Populate the QVals
    pListReplyMsg->cdwQVals = QVAL_COUNT;
    memcpy(pCResponse->GetBuffer() + (fUseLocale ? sizeof (Q_LIST_REPLY_2_MSG) : sizeof(Q_LIST_REPLY_MSG)), pCPresence->GetQVals(), (QVAL_COUNT * sizeof(DWORD)));

    // Send it back
    hr = pReplyConn->Send(pCResponse);
    if (FAILED(hr))
    {
        goto lDone;
    }

    g_Counters.IncrementValue32(
            XPPERF_SERVER_LIST_REPLY_MSGS_COUNTER,
            1 );

    g_Counters.IncrementValue32(
            XPPERF_SERVER_LIST_REPLY_MSGS_RATE,
            1 );

    pCPresence->SendQVals();

lDone:
    SAFE_RELEASE( pCResponse );

    if (FAILED(hr) &&
        (hr != XONLINE_E_PRESENCE_DEFER_REQUEST) &&
        (hr != XONLINE_E_PRESENCE_USER_MIGRATED))
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_474,
            "m_pSwitchboard->List ( user %I64X qtype %d StartItemID %d items %d size %d ) failed hr=0x%X",
            qwUserID,
            dwQType,
            dwStartItemID,
            dwMaxItems,
            dwTotalItemDataSize,
            hr);
    }

    SAFE_RELEASE(pCPresence);

    return hr;
}

/*****************************************************************************

CSwitchboard::EnumerateMessages

List a user's messages.

*****************************************************************************/
HRESULT CSwitchboard::EnumerateMessages(
    QWORD qwUserID,
    CClientConnection *pCReplyConn,
    DWORD dwMsgType,
    DWORD dwSeqNum)
{
    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Switchboard - EnumerateMessages%d: User=%I64X",
        dwMsgType == QMSG_ENUM_MESSAGES_2 ? 2 : 1,
        qwUserID);

    HRESULT hr = S_OK;
    CEnumerateMessagesContext *pCCtx = NULL;

    // NOTE: We allow a user to enumerate their messages even if Alive failed with XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT,
    // because the Dash will need to be able to get the user's required messages after receiving this error code.

    // Create a context object
    pCCtx = new CEnumerateMessagesContext( this, &m_CProfileStore );
    if( NULL == pCCtx )
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Populate the context object
    pCCtx->m_fProcessed = FALSE;
    pCCtx->m_qwUserID = qwUserID;
    pCCtx->m_pCReplyConn = pCReplyConn;
    pCReplyConn->AddRef();
    pCCtx->m_dwMsgType = dwMsgType;
    pCCtx->m_dwSeqNum = dwSeqNum;

    hr = g_CPresenceUserIndex.FindPresence(qwUserID, &(pCCtx->m_pCPresence));
    if (pCCtx->m_pCPresence == NULL)
    {
        goto lDone;
    }

    // HACK: only 360 stockholm clients can handle the party message type (others crash!)
    // maybe someday we will have clients pass up the max message type they can handle.  EnumerateMessages3!
    pCCtx->m_bMaxKnownMsgType = pCCtx->m_pCPresence->CanClientConsumePartyInviteMessage() ? XONLINE_MSG_TYPE_PARTY_CHAT_INVITE : XONLINE_MSG_TYPE_VIDEO_CHAT_INVITE;

    // We will allocate the reply buffer here, allowing the Profile store to fill it in, followed by the local queue
    // in EnumerateMessagesComplete below, where it will be finished off.
    pCCtx->m_pCReply = g_pBufferPool->GetBuffer( sizeof(Q_ENUM_MESSAGES_2_REPLY_MSG) + ( sizeof(Q_MESSAGE_SUMMARY_2) * MAX_TOTAL_USER_MESSAGES ) );
    if( NULL == pCCtx->m_pCReply )
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Send it over to the Profile store
    hr = m_CProfileStore.SendToSqlThread( pCCtx );

    // Call will post a completion when it resolves

    // We look for any local transient message when this completes in EnumerateMessagesComplete below

lDone:
    if( FAILED( hr ) )
    {
        SAFE_RELEASE( pCCtx );

        XomNtEvent(
            XEVENT_PRESENCE_CODE_475,
            "m_pSwitchboard->EnumerateMessages%d (user %I64X) failed hr=0x%X",
            dwMsgType == QMSG_ENUM_MESSAGES_2 ? 2 : 1,
            qwUserID,
            hr);
    }

    return hr;
}

/*****************************************************************************

CSwitchboard::GetMessageSummary

Get summary information for a message.

*****************************************************************************/
HRESULT CSwitchboard::GetMessageSummary(
    QWORD qwUserID,
    DWORD dwMessageID,
    CClientConnection *pCReplyConn,
    DWORD dwMsgType,
    DWORD dwSeqNum)
{
    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Switchboard - GetMessageSummary: User=%I64X Message=0x%08X",
        qwUserID,
        dwMessageID);

    HRESULT hr = S_OK;
    CTCPCntVarBuffer *pCReply = NULL;
    CGetMessageSummaryContext *pCCtx = NULL;

    // Create a context object
    pCCtx = new CGetMessageSummaryContext( this, &m_CProfileStore );
    if( NULL == pCCtx )
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Populate the context object
    pCCtx->m_fProcessed = FALSE;
    pCCtx->m_qwUserID = qwUserID;
    pCCtx->m_dwMessageID = dwMessageID;
    pCCtx->m_pCReplyConn = pCReplyConn;
    pCReplyConn->AddRef();
    pCCtx->m_dwSeqNum = dwSeqNum;
    pCCtx->m_dwMsgType = dwMsgType;

    hr = g_CPresenceUserIndex.FindPresence(qwUserID, &(pCCtx->m_pCPresence));
    if (pCCtx->m_pCPresence == NULL)
    {
        goto lDone;
    }

    // HACK: only 360 stockholm clients can handle the party message type (others crash!)
    // maybe someday we will have clients pass up the max message type they can handle.  MessageSummary3!
    pCCtx->m_bMaxKnownMsgType = pCCtx->m_pCPresence->CanClientConsumePartyInviteMessage() ? XONLINE_MSG_TYPE_PARTY_CHAT_INVITE : XONLINE_MSG_TYPE_VIDEO_CHAT_INVITE;

    if( IsMsgTransient( dwMessageID ) )
    {
        // The message is transient, handle it locally

        // See if there's currently a record for the given user
        if (!(pCCtx->m_pCPresence->HasOnlineRecord()))
        {
            hr = HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
            goto lDone;
        }

        // NOTE: A user need not be online to check their messages.  They could be on the web.

        // Retrieve the item from the queue
        CQueueItem* pItem = pCCtx->m_pCPresence->GetItem(
            PQUEUE_TRANSIENT_MSGS,
            dwMessageID);
        if( NULL == pItem )
        {
            hr = XONLINE_E_MESSAGE_INVALID_MESSAGE_ID;
            goto lDone;
        }

        DWORD dwBufferSize = sizeof( Q_MESSAGE_SUMMARY_REPLY_MSG );
        if (dwMsgType == QMSG_MESSAGE_SUMMARY_2)
        {
            dwBufferSize = sizeof( Q_MESSAGE_SUMMARY_2_REPLY_MSG );
        }

        // Allocate a buffer for the response
        pCReply = g_pBufferPool->GetBuffer( dwBufferSize );
        if( NULL == pCReply )
        {
            hr = E_OUTOFMEMORY;
            goto lDone;
        }

        Q_MESSAGE_SUMMARY_REPLY_MSG *pReplyWork = (Q_MESSAGE_SUMMARY_REPLY_MSG *) pCReply->GetBuffer();
        Q_MESSAGE_SUMMARY_2_REPLY_MSG *pReply2Work = (Q_MESSAGE_SUMMARY_2_REPLY_MSG *) pCReply->GetBuffer();

        memcpy( &pReplyWork->summary, pItem->GetData(), sizeof( Q_MESSAGE_SUMMARY ) );

        if (dwMsgType == QMSG_MESSAGE_SUMMARY_2)
        {
            // Zero out the subject for transient messages on GetMessageSummary2 messages
            memset( pReply2Work->summary.szSubject, 0, sizeof(pReply2Work->summary.szSubject) );
        }

        // Success, set the output parameters
        pCCtx->m_pCReply = pCReply;
        pCCtx->m_hr = S_OK;

        // This will clean up pCCtx
        GetMessageSummaryComplete( pCCtx );
    }
    else
    {
        // The message is persistent, send it to the profile store
        hr = m_CProfileStore.SendToSqlThread( pCCtx );

        // Call will post a completion when it resolves
    }

lDone:
    if( FAILED( hr ) )
    {
        SAFE_RELEASE( pCCtx );
        SAFE_RELEASE( pCReply );

        if (hr != XONLINE_E_MESSAGE_INVALID_MESSAGE_ID)
        {
            XomNtEvent(
                XEVENT_PRESENCE_CODE_476,
                "m_pSwitchboard->GetMessageSummary (user %I64X, msg 0x%08X) failed hr=0x%X",
                qwUserID,
                dwMessageID,
                hr);
        }
    }

    return hr;
}

/*****************************************************************************

CSwitchboard::GetMessageDetails

Get extended information for a message.

*****************************************************************************/
HRESULT CSwitchboard::GetMessageDetails(
    QWORD qwUserID,
    DWORD dwMessageID,
    DWORD dwSetFlags,
    DWORD dwUnsetFlags,
    CClientConnection *pCReplyConn,
    DWORD dwSeqNum)
{
    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Switchboard - GetMessageDetails: User=%I64X Message=0x%08X SetFlags=0x%08X ClearFlags=0x%08X",
        qwUserID,
        dwMessageID,
        dwSetFlags,
        dwUnsetFlags);

    HRESULT hr = S_OK;
    CTCPCntVarBuffer *pCReply = NULL;
    CGetMessageDetailsContext *pCCtx = NULL;

    // NOTE: When the Dash is reading required messages, Alive will have failed and there will not be a user record.

    // Create a context object
    pCCtx = new CGetMessageDetailsContext( this, &m_CProfileStore );
    if( NULL == pCCtx )
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Populate the context object
    pCCtx->m_fProcessed = FALSE;
    pCCtx->m_qwUserID = qwUserID;
    pCCtx->m_dwMessageID = dwMessageID;
    pCCtx->m_dwSetFlags = dwSetFlags;
    pCCtx->m_dwUnsetFlags = dwUnsetFlags;
    pCCtx->m_pCReplyConn = pCReplyConn;
    pCReplyConn->AddRef();
    pCCtx->m_dwSeqNum = dwSeqNum;

    hr = g_CPresenceUserIndex.FindPresence(qwUserID, &(pCCtx->m_pCPresence));
    if (pCCtx->m_pCPresence == NULL)
    {
        goto lDone;
    }

    if( IsMsgTransient( dwMessageID ) )
    {
        // The message is transient, handle it locally

        // See if there's currently a record for the given user
        if (!(pCCtx->m_pCPresence->HasOnlineRecord()))
        {
            hr = HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
            goto lDone;
        }

        // NOTE: A user need not be online to check their messages.  They could be on the web.

        // Retrieve the item from the queue
        CQueueItem* pItem = pCCtx->m_pCPresence->GetItem(
            PQUEUE_TRANSIENT_MSGS,
            dwMessageID);
        if( NULL == pItem )
        {
            hr = XONLINE_E_MESSAGE_INVALID_MESSAGE_ID;
            goto lDone;
        }

        // Modify the message as requested
        ((Q_MESSAGE_SUMMARY*) pItem->GetData() )->dwMessageFlags &= ~(dwUnsetFlags);
        ((Q_MESSAGE_SUMMARY*) pItem->GetData() )->dwMessageFlags |= dwSetFlags;

        // Get the size of the details section out of the summary
        WORD cbDetails = ((Q_MESSAGE_SUMMARY*) pItem->GetData() )->cbDetails;

        // Allocate a buffer for the response
        pCReply = g_pBufferPool->GetBuffer( sizeof( Q_MESSAGE_DETAILS_REPLY_MSG ) + cbDetails );
        if( NULL == pCReply )
        {
            hr = E_OUTOFMEMORY;
            goto lDone;
        }

        // Copy the details over to the response
        Q_MESSAGE_DETAILS_REPLY_MSG *pReplyWork = (Q_MESSAGE_DETAILS_REPLY_MSG *) pCReply->GetBuffer();

        memcpy( &pReplyWork->summary,  pItem->GetData(), sizeof( pReplyWork->summary ) );
        memcpy( pReplyWork + 1,  pItem->GetData() + sizeof( Q_MESSAGE_SUMMARY ), cbDetails );

        // Success, set the output parameters
        pCCtx->m_pCReply = pCReply;
        pCCtx->m_hr = S_OK;

        // This will clean up pCCtx
        GetMessageDetailsComplete( pCCtx );
    }
    else
    {
        // The message is persistent, send it to the profile store
        hr = m_CProfileStore.SendToSqlThread( pCCtx );

        // Call will post a completion when it resolves
    }

lDone:
    if( FAILED( hr ) )
    {
        SAFE_RELEASE( pCCtx );
        SAFE_RELEASE( pCReply );

        if (hr != XONLINE_E_MESSAGE_INVALID_MESSAGE_ID)
        {
            XomNtEvent(
                XEVENT_PRESENCE_CODE_477,
                "m_pSwitchboard->GetMessageDetails (user %I64X, msg 0x%08X) failed hr=0x%X",
                qwUserID,
                dwMessageID,
                hr);
        }
    }

    return hr;
}

/*****************************************************************************

CSwitchboard::DeleteMessage

Delete a message.

*****************************************************************************/
HRESULT CSwitchboard::DeleteMessage(
    BOOL  fFromPresence,
    QWORD qwUserID,
    DWORD dwMessageID,
    DWORD dwFlags,
    CTCPCntMessageBased<CTCPCntMessageBasedPlugin_PN> *pCReplyConn,
    DWORD dwSeqNum)
{
    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Switchboard - DeleteMessage: User=%I64X Message=0x%08X Flags=0x%08X",
        qwUserID,
        dwMessageID,
        dwFlags);

    HRESULT hr = S_OK;
    CDeleteMessageContext *pCCtx = NULL;

    // NOTE: When the Dash is reading required messages, Alive will have failed and there will not be a user record.

    // Create a context object
    pCCtx = new CDeleteMessageContext( this, &m_CProfileStore );
    if( NULL == pCCtx )
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Populate the context object
    pCCtx->m_fProcessed = FALSE;
    pCCtx->m_qwUserID = qwUserID;
    pCCtx->m_dwMessageID = dwMessageID;
    pCCtx->m_dwFlags = dwFlags;
    pCCtx->m_pCReplyConn = pCReplyConn;
    if( NULL != pCReplyConn ) // Sends to the local server will have a NULL reply connection
    {
        pCReplyConn->AddRef();
    }
    pCCtx->m_dwSeqNum = dwSeqNum;
    pCCtx->m_fFromPresence = fFromPresence;

    // See if there's currently a record for the given user
    hr = g_CPresenceUserIndex.FindPresence( qwUserID, &(pCCtx->m_pCPresence));
    if(NULL == pCCtx->m_pCPresence)
    {
        goto lDone;
    }

    if( IsMsgTransient( dwMessageID ) )
    {
        // The message is transient, handle it locally.
        if (!(pCCtx->m_pCPresence->HasOnlineRecord()))
        {
            hr = HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
            goto lDone;
        }

        // NOTE: A user need not be online to check their messages.  They could be on the web.

        // Retrieve the item from the queue
        CQueueItem* pItem = pCCtx->m_pCPresence->GetItem(
            PQUEUE_TRANSIENT_MSGS,
            dwMessageID);
        if( NULL == pItem )
        {
            pCCtx->m_hr = XONLINE_E_MESSAGE_INVALID_MESSAGE_ID;
        }
        else
        {
            pCCtx->m_qwSenderID = ( (Q_MESSAGE_SUMMARY*) pItem->GetData() )->qwSenderID;

            // Block the sender if requested
            // NOTE: Don't allow blocking PUID zero
            if( pCCtx->m_dwFlags & XMSG_DELETE_MESSAGE_FLAG_BLOCK_SENDER &&
                0 != pCCtx->m_qwSenderID )
            {
                CBlockUsersContext* pCBlockCtx = new CBlockUsersContext( &m_CProfileStore );
                if( NULL != pCBlockCtx )
                {
                    // Populate the context object
                    pCBlockCtx->m_qwSenderID = pCCtx->m_qwSenderID;
                    pCBlockCtx->m_qwRecipientID = pCCtx->m_qwUserID;

                    if( FAILED( m_CProfileStore.SendToSqlThread( pCBlockCtx ) ) )
                    {
                        SAFE_RELEASE( pCBlockCtx );
                    }
                    else
                    {
                        // NOTE: The SQL thread will release the context when it completes
                    }
                }
            }

            // NOTE: This call may end up deleting the user object if the user is not online and this
            // was the last message.  Don't use pUser after this.
            pItem->SelfDestruct();
        }

        // This will clean up pCCtx
        DeleteMessageComplete( pCCtx );
    }
    else
    {
        // The message is persistent, send it to the profile store
        hr = m_CProfileStore.SendToSqlThread( pCCtx );

        // Call will post a completion when it resolves
    }

lDone:
    if( FAILED( hr ) )
    {
        SAFE_RELEASE( pCCtx );

        if (hr != XONLINE_E_MESSAGE_INVALID_MESSAGE_ID)
        {
            XomNtEvent(
                XEVENT_PRESENCE_CODE_478,
                "m_pSwitchboard->DeleteMessage (user %I64X, msg 0x%08X, flags 0x%08X) failed hr=0x%X",
                qwUserID,
                dwMessageID,
                dwFlags,
                hr);
        }
    }

    return hr;
}

/*****************************************************************************

CSwitchboard::SendMessageInternal

Send a message.  This message comes from the sender's notification server to
each recipient's notification server.

*****************************************************************************/
HRESULT CSwitchboard::SendMessageInternal(
    Q_SEND_MESSAGE_MSG* pSendMessage,
    ULONGLONG* pqwRecipientIDs,
    const BYTE* pbDetails,
    const Q_SEND_MESSAGE_ADDENDUM* rgAddendum,
    CPresConnection *pCReplyConn,
    DWORD dwSeqNum,
    SendMessageReplyHandler* pExternalCtx)
{
    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Switchboard - SendMessageInternal: Sender=%I64X Type=0x%04X cRecipients=%d cbDetails=%d recip0=%I64X",
        pSendMessage->qwSenderID,
        pSendMessage->bMessageType,
        pSendMessage->cRecipients,
        pSendMessage->cbDetails,
        pqwRecipientIDs[0]);

    HRESULT hr = S_OK;
    CSendMessageInternalContext *pCCtx = NULL;

    // We should have one or the other of these, not both.
    XOMASSERT( ( NULL == pCReplyConn && NULL != pExternalCtx ) ||
               ( NULL != pCReplyConn && NULL == pExternalCtx ) );

    if (XONLINE_MSG_TYPE_GAME_INVITE == pSendMessage->bMessageType)
    {
        if( NULL == rgAddendum)
        {
            hr = E_INVALIDARG;
            goto lDone;
        }
    }
    else
    {
        if( NULL != rgAddendum)
        {
            hr = E_INVALIDARG;
            goto lDone;
        }
    }

    DWORD dwForwardsNeeded = 0;

    for (DWORD iPreScan = 0; iPreScan < pSendMessage->cRecipients; iPreScan++)
    {
        CPresence *pCPreScan = NULL;
        hr = g_CPresenceUserIndex.FindPresence(pqwRecipientIDs[iPreScan], &pCPreScan);
        SAFE_RELEASE(pCPreScan);
        if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
        {
            // swap the deferring user to the front
            QWORD qwFirst = pqwRecipientIDs[0];
            pqwRecipientIDs[0] = pqwRecipientIDs[iPreScan];
            pqwRecipientIDs[iPreScan] = qwFirst;

            goto lDone;
        }
        else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
        {
            dwForwardsNeeded++;
        }
    }
    hr = S_OK;


    // Create a context object
    pCCtx = new CSendMessageInternalContext( this, &m_CProfileStore );
    if( NULL == pCCtx )
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Populate the context object
    pCCtx->m_pCReplyConn = pCReplyConn;
    if( NULL != pCReplyConn ) // Sends to the local server will have a NULL reply connection
    {
        pCReplyConn->AddRef();
    }
    pCCtx->m_dwSeqNum = dwSeqNum;
    if( NULL != pExternalCtx )
    {
        pExternalCtx->AddRef();
    }
    pCCtx->m_pExternalCtx = pExternalCtx;
    pCCtx->m_eState = CSendMessageInternalContext::SendMessageState_Store;
    memcpy( &pCCtx->m_Message, pSendMessage, sizeof( Q_SEND_MESSAGE_MSG ) );
    memcpy( pCCtx->m_rgbDetails, pbDetails, pSendMessage->cbDetails );
    if (rgAddendum != NULL)
    {
        memcpy( pCCtx->m_rgAddendum, rgAddendum, pSendMessage->cRecipients * sizeof(Q_SEND_MESSAGE_ADDENDUM) );
    }
    pCCtx->dwPendingLoads = 0;

    pCCtx->m_rgpCPresence = new CPresence *[pSendMessage->cRecipients];
    if (pCCtx->m_rgpCPresence == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    if (dwForwardsNeeded > 0)
    {
        pCCtx->m_rgForwardIDs = new QWORD[dwForwardsNeeded];
        if (pCCtx->m_rgForwardIDs == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto lDone;
        }
        pCCtx->m_cForwardIDs = 0;
    }

    ZeroMemory(pCCtx->m_rgpCPresence, pSendMessage->cRecipients * sizeof(CPresence *));

    for( int iRecipient = 0; iRecipient < pSendMessage->cRecipients; iRecipient++ )
    {
        CPresence* pCPresence;
        HRESULT hrInner = g_CPresenceUserIndex.FindPresence( pqwRecipientIDs[ iRecipient ] , &pCPresence );
        if( NULL == pCPresence )
        {
            // first make sure this user hasnt been migrated.
            if (hrInner == XONLINE_E_PRESENCE_USER_MIGRATED)
            {
                pCCtx->m_rgForwardIDs[pCCtx->m_cForwardIDs] = pqwRecipientIDs[iRecipient];
                pCCtx->m_cForwardIDs++;
                continue;
            }

            pCCtx->m_rgqwRecipientIDs[iRecipient - pCCtx->m_cForwardIDs] = pqwRecipientIDs[iRecipient];
            pCCtx->m_RecipientResults[iRecipient - pCCtx->m_cForwardIDs].qwUserID = pqwRecipientIDs[iRecipient];

            CLoadOfflinePresenceContext *pLoadCtx = new CLoadOfflinePresenceContext(this, &m_CProfileStore);
            if (pLoadCtx == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto lDone;
            }

            pCCtx->dwPendingLoads++;
            pLoadCtx->m_pCaller = pCCtx;
            pLoadCtx->m_qwUserID = pqwRecipientIDs[iRecipient];
            pLoadCtx->m_pvParentData = (void *)(iRecipient - pCCtx->m_cForwardIDs);

            hrInner = m_CProfileStore.SendToSqlThread(pLoadCtx);
        }
        else
        {
            pCCtx->m_rgqwRecipientIDs[iRecipient - pCCtx->m_cForwardIDs] = pqwRecipientIDs[iRecipient];
            pCCtx->m_RecipientResults[iRecipient - pCCtx->m_cForwardIDs].qwUserID = pqwRecipientIDs[iRecipient];

            pCCtx->ProcessUser(pCPresence, (void *)(iRecipient - pCCtx->m_cForwardIDs));
        }

        SAFE_RELEASE(pCPresence);
    }

    // can only advance if there were no loads scheduled.  otherwise the last load will advance.
    if (pCCtx->dwPendingLoads == 0)
    {
        hr = pCCtx->Finalize();
    }


lDone:
    if (FAILED(hr))
    {
        SAFE_RELEASE(pCCtx);

        XomNtEvent(
            XEVENT_PRESENCE_CODE_479,
            "m_pSwitchboard->SendMessage (user %I64X, type 0x%02X) failed hr=0x%X",
            pSendMessage->qwSenderID,
            pSendMessage->bMessageType,
            hr);
    }

    return hr;
}

/*****************************************************************************

CSwitchboard::SendMessageExternal

Send a message.  This is a request from the front door or Presence and we are
now on the message sender's notification server and need to fan the message out
to each recipient's server by sending it through the cluster.

*****************************************************************************/
HRESULT CSwitchboard::SendMessageExternal(
    BOOL fFromPresence,
    Q_SEND_MESSAGE_MSG* pSendMessage,
    const ULONGLONG* pqwRecipientIDs,
    const BYTE* pbDetails,
    const Q_SEND_MESSAGE_ADDENDUM* rgAddendum,
    CTCPCntMessageBased<CTCPCntMessageBasedPlugin_PN> *pCReplyConn,
    DWORD dwSeqNum)
{
    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Switchboard - SendMessageExternal: Sender=%I64X Type=0x%04X cRecipients=%d cbDetails=%d recip0=%I64X",
        pSendMessage->qwSenderID,
        pSendMessage->bMessageType,
        pSendMessage->cRecipients,
        pSendMessage->cbDetails,
        pqwRecipientIDs[0]);

    HRESULT hr = S_OK;
    CSendMessageExternalContext *pCCtx = NULL;
    CPresence* pCPresence = NULL;
    QWORD rgqwAuthenticatedUserIDs[ XONLINE_MAX_MESSAGE_RECIPIENTS ];
    QWORD rgqwUsersToUnblock[ XONLINE_MAX_MESSAGE_RECIPIENTS ];
    WORD cUsersAuthenticated = 0;
    WORD cUsersToUnblock = 0;

    // The receipient list we may send to SendMessageInternal
    const QWORD *pqwRecipients = pqwRecipientIDs;

    // Messages from the Live service come in with a zero PUID
    if( 0 != pSendMessage->qwSenderID )
    {
        // See if there's currently a record for the given user
        hr = g_CPresenceUserIndex.FindPresence( pSendMessage->qwSenderID , &pCPresence );
        if (pCPresence == NULL)
        {
            goto lDone;
        }

        // don't trust the gamertag sent by the user.  replace it with the one in the presence record.
        memset(pSendMessage->szSenderName, 0, XONLINE_GAMERTAG_SIZE - 1);
        memcpy(pSendMessage->szSenderName, pCPresence->GetAcctName(), pCPresence->GetAcctNameLen() - 1);
    }

    // There are two types of messages, transient and persistent.  Transient messages only live in memory
    // on the Notification server and are deleted by Presence when the message sender goes offline.  All other
    // messages are persistent messages, and they are stored in the profile store.
    if( XONLINE_MSG_TYPE_GAME_INVITE == pSendMessage->bMessageType )
    {
        if( NULL == rgAddendum )
        {
            hr = E_INVALIDARG;
            goto lDone;
        }

        XomTrace(
            PresenceDebug,
            L_INFO,
            "Switchboard - SendMessageInternal - Addendum: Sender=%I64X Type=0x%04X cRecipients=%d Recip0=%I64X fFriend0=%d webId0=%I64X",
            pSendMessage->qwSenderID,
            pSendMessage->bMessageType,
            pSendMessage->cRecipients,
            pqwRecipientIDs[0],
            rgAddendum[0].fFriend,
            rgAddendum[0].qwWebID);
    }
    else
    {
        if( NULL != rgAddendum )
        {
            hr = E_INVALIDARG;
            goto lDone;
        }

        // check throttling on persistent messages
        if (pCPresence && !pCPresence->ThrottledMessageAllowed(pSendMessage->cRecipients))
        {
            hr = XONLINE_E_MESSAGE_THROTTLED;
            goto lDone;
        }
    }

    // Create a context object
    pCCtx = new CSendMessageExternalContext( this );
    if( NULL == pCCtx )
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    pCCtx->m_pSendReplyBuffer = g_pBufferPool->GetBuffer( sizeof(Q_SEND_MESSAGE_REPLY_MSG) + pSendMessage->cRecipients * sizeof( Q_RECIPIENT_RESULT ) );
    if( NULL == pCCtx->m_pSendReplyBuffer )
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Populate the context object
    memcpy( &pCCtx->m_Message, pSendMessage, sizeof( *pSendMessage ) );
    pCCtx->m_pCReplyConn = pCReplyConn;
    if (pCReplyConn != NULL) pCReplyConn->AddRef();
    pCCtx->m_dwOrigSeqNum = dwSeqNum;
    pCCtx->m_dwSendTime = GetTickCount();
    pCCtx->m_fFromPresence = fFromPresence;
    pCCtx->m_pCPresence = pCPresence;

    // pCPresence can be null if this is a system message.
    SAFE_ADDREF(pCPresence);

    // If this sender has blocked any of the message recipients, sending to them should unblock them.  First, we check
    // the in-memory block list before making a database call.
    // NOTE: This is not applicable for messages from Live where the sender PUID is zero.
    if( 0 != pSendMessage->qwSenderID )
    {
        for( WORD iRecipient = 0; iRecipient < pSendMessage->cRecipients; iRecipient++ )
        {
            if( NULL != pCPresence )
            {
                // pCPresence will be NULL for service messages, so no need to double check here.
                if ( (pSendMessage->bMessageType != XONLINE_MSG_TYPE_FRIEND_REQUEST)
                    && (FALSE == pCPresence->CanMessage( pqwRecipientIDs[ iRecipient ] )) )
                {
                    // Insufficient privileges to send this message
                    XomTrace(
                        PresenceDebug,
                        L_NORMAL,
                        "SendMessageExternal: user=%I64X has insufficient privileges to Send Messages.",
                        pCPresence->GetUserID()
                        );

                    // next recipient
                    continue;
                }

                if( pCPresence->IsUserBlocked( pqwRecipientIDs[ iRecipient ] ) )
                {
                    rgqwUsersToUnblock[ cUsersToUnblock ] = pqwRecipientIDs[ iRecipient ];
                    cUsersToUnblock++;
                }
            }
            else
            {
                // The user is probably logged on from the web, attempt to unblock all users
                rgqwUsersToUnblock[ cUsersToUnblock ] = pqwRecipientIDs[ iRecipient ];
                cUsersToUnblock++;
            }

            // We can send to this user.
            rgqwAuthenticatedUserIDs[cUsersAuthenticated++] = pqwRecipientIDs[iRecipient];
        }

        if( 0 != cUsersToUnblock )
        {
            // Create a context object, failure is non-fatal
            CUnblockUsersContext* pCUnblockCtx = new CUnblockUsersContext( &m_CProfileStore );
            if( NULL != pCUnblockCtx )
            {
                // Populate the context object
                pCUnblockCtx->m_qwUserID = pSendMessage->qwSenderID;
                pCUnblockCtx->m_cUsersToUnblock = cUsersToUnblock;
                memcpy( pCUnblockCtx->m_rgqwUsersToUnblock, rgqwUsersToUnblock, cUsersToUnblock * sizeof( *rgqwUsersToUnblock ) );

                // Send it over to the SQL thread pool
                hr = m_CProfileStore.SendToSqlThread( pCUnblockCtx );
                if( FAILED( hr ) )
                {
                    SAFE_RELEASE( pCUnblockCtx );
                }
                else
                {
                    // NOTE: The SQL thread will release the context when it completes

                    // Update the in-memory list
                    if( NULL != pCPresence )
                    {
                        pCPresence->UnblockUsers( rgqwUsersToUnblock, cUsersToUnblock );
                    }
                }
            }
        }

        if (0 == cUsersAuthenticated)
        {
            // Not authenticated to send to any users. Abort with error.
            hr = XONLINE_E_MESSAGE_INSUFFICIENT_PRIVILEGES;
            goto lDone;
        }
        else
        {
            // Update the authenticated user count
            pSendMessage->cRecipients = cUsersAuthenticated;
        }

        pqwRecipients = rgqwAuthenticatedUserIDs;
    }

    // We need to hold a reference on the send count to make sure that it doesn't go to zero.  This can
    // happen if the send is a transient message to the local server because it will go through SendMessageInternal
    // without ever posting to another thread.  In that case, without this reference both HandleSendReply and this
    // function would find the send count to be zero and try to do final processing.
    pCCtx->m_lSendCount = 1;

    // Now send the message to the notification cluster to be fanned out to each recipient's server
    hr = m_CXPCluster.SendSendMessage(
        pSendMessage,
        pqwRecipients,
        pbDetails,
        rgAddendum,
        pCCtx );

    // Call will post a completion when it resolves

    // Take off the reference we added above
    XOMASSERT( 0 != pCCtx->m_lSendCount );
    pCCtx->m_lSendCount--;

    // If no sends went out or they are all done, then it is time to call the completion now
    if( SUCCEEDED( hr ) )
    {
        // hold an extra reference for the completion.
        pCCtx->AddRef();

        if ( 0 == pCCtx->m_lSendCount )
        {
            SendMessageExternalComplete( pCCtx );
        }
    }

lDone:
    SAFE_RELEASE( pCCtx );

    if (FAILED(hr))
    {
        if ((hr != XONLINE_E_MESSAGE_INSUFFICIENT_PRIVILEGES) &&
            (hr != XONLINE_E_MESSAGE_THROTTLED))
        XomNtEvent(
            XEVENT_PRESENCE_CODE_480,
            "m_pSwitchboard->SendMessageExternal (sender %I64X, type 0x%02X) failed hr=0x%X",
            pSendMessage->qwSenderID,
            pSendMessage->bMessageType,
            hr);
    }

    SAFE_RELEASE(pCPresence);

    return hr;
}

/*****************************************************************************

CSwitchboard::QueueRevokeMessage

Internal function to revoke a message has arrived.

*****************************************************************************/
HRESULT CSwitchboard::QueueRevokeMessage(
    QWORD qwSenderID,
    QWORD qwSenderContext,
    DWORD dwFlags,
    WORD wPropTag,
    WORD cbProp,
    const BYTE* pbProp,
    BYTE bMessageType,
    WORD cRecipients,
    const Q_RECIPIENT_RESULT *rgRecipients)
{
    Q_REVOKE_MESSAGE_EX_MSG Msg;

    Msg.dwMsgType = QMSG_REVOKE_MESSAGE_EX;
    Msg.dwMsgLen = sizeof(Q_REVOKE_MESSAGE_EX_MSG) - sizeof(BASE_MSG_HEADER);
    Msg.dwSeqNum = 0;
    Msg.sgaddr = sgaddrIgnore;

    Msg.qwSenderID = qwSenderID;
    Msg.qwSenderContext = qwSenderContext;
    Msg.dwFlags = dwFlags;
    Msg.wPropTag = wPropTag;
    Msg.bMessageType = bMessageType;

    Msg.cRecipients = cRecipients;

    Msg.cbProp = cbProp;

    return RevokeMessageExternal(&Msg, rgRecipients, pbProp);
}

/*****************************************************************************

CSwitchboard::RevokeMessageExternal

A request from Presence or the front door to revoke a message has arrived.

*****************************************************************************/
HRESULT CSwitchboard::RevokeMessageExternal(
    const Q_REVOKE_MESSAGE_EX_MSG* pMessage,
    const Q_RECIPIENT_RESULT* pRecipients,
    const BYTE* pbProp )
{
    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Switchboard - RevokeMessageExternal: Sender=%I64X cRecipients=%hd dwFlags=%hd wPropTag=%hd cbProp=%hd",
        pMessage->qwSenderID,
        pMessage->cRecipients,
        pMessage->dwFlags,
        pMessage->wPropTag,
        pMessage->cbProp);

    HRESULT hr = S_OK;

    // Now send the message to the notification cluster to be fanned out to each recipient's server
    hr = m_CXPCluster.SendRevokeMessage(
        pMessage,
        pRecipients,
        pbProp );
    if( FAILED( hr ) )
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_481,
            "m_pSwitchboard->RevokeMessageExternal (sender %I64X) failed hr=0x%X",
            pMessage->qwSenderID,
            hr );
    }

    return hr;
}

/*****************************************************************************

CSwitchboard::RevokeMessageInternal

Revoke messages for users on this server.

*****************************************************************************/
HRESULT CSwitchboard::RevokeMessageInternal(
    const Q_REVOKE_MESSAGE_EX_MSG* pMessage,
    Q_RECIPIENT_RESULT* pRecipients,
    const BYTE* pbProp )
{
    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Switchboard - RevokeMessageInternal: Sender=%I64X Context=%I64X cRecipients=%hd dwFlags=%hd wPropTag=%hd cbProp=%hd",
        pMessage->qwSenderID,
        pMessage->qwSenderContext,
        pMessage->cRecipients,
        pMessage->dwFlags,
        pMessage->wPropTag,
        pMessage->cbProp);

    HRESULT hr = S_OK;
    CRevokeMessageContext *pCCtx = NULL;

    Q_REVOKE_MESSAGE_EX_MSG *pFwdMessage = NULL;
    Q_RECIPIENT_RESULT *pFwdRecipients = NULL;
    DWORD cForwardIDs = 0;

    for (DWORD iPreScan = 0; iPreScan < pMessage->cRecipients; iPreScan++)
    {
        CPresence *pCPresence = NULL;
        hr = g_CPresenceUserIndex.FindPresence(pRecipients[iPreScan].qwUserID, &pCPresence);
        SAFE_RELEASE(pCPresence);

        if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
        {
            // swap the defered user to the front
            Q_RECIPIENT_RESULT qrrFirst = {0};
            memcpy(&qrrFirst, &(pRecipients[0]), sizeof(Q_RECIPIENT_RESULT));
            memcpy(&(pRecipients[0]), &(pRecipients[iPreScan]), sizeof(Q_RECIPIENT_RESULT));
            memcpy(&(pRecipients[iPreScan]), &qrrFirst, sizeof(Q_RECIPIENT_RESULT));

            goto lDone;
        }
        else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
        {
            cForwardIDs++;
        }
    }
    hr = S_OK;

    if (cForwardIDs > 0)
    {
        pFwdMessage = (Q_REVOKE_MESSAGE_EX_MSG *)(new BYTE[sizeof(Q_REVOKE_MESSAGE_EX_MSG) + (cForwardIDs * sizeof(Q_RECIPIENT_RESULT)) + pMessage->cbProp]);
        if (pFwdMessage == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto lDone;
        }

        pFwdRecipients = (Q_RECIPIENT_RESULT *)(pFwdMessage + 1);
        cForwardIDs = 0;
    }

    // Create a context object
    pCCtx = new CRevokeMessageContext( this, &m_CProfileStore );
    if( NULL == pCCtx )
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Populate the context object
    pCCtx->m_fProcessed = FALSE;
    memcpy( &pCCtx->m_Message, pMessage, sizeof( *pMessage ) );
    memcpy( pCCtx->m_rgRecipients, pRecipients, pMessage->cRecipients * sizeof( *pRecipients ) );

    pCCtx->m_rgpCPresence = new CPresence *[pMessage->cRecipients];
    if (pCCtx->m_rgpCPresence == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    ZeroMemory(pCCtx->m_rgpCPresence, pMessage->cRecipients * sizeof(CPresence *));

    // There are two types of messages, transient and persistent.  Transient messages only live in memory
    // on the Notification server and are deleted by Presence when the message sender goes offline.  All other
    // messages are persistent messages, and they are stored in the profile store.

    if( ( pMessage->dwFlags & XMSG_REVOKE_MESSAGE_EX_FLAG_USE_TYPE && XONLINE_MSG_TYPE_GAME_INVITE == pMessage->bMessageType ) ||
        ( pMessage->dwFlags & XMSG_REVOKE_MESSAGE_EX_FLAG_USE_ID && IsMsgTransient( pRecipients->dwMessageID ) ) )
    {
        // The message is transient, revoke it from each recipient's queue

        for( int iRecipient = 0; iRecipient < pMessage->cRecipients; iRecipient++ )
        {
            // See if there's currently a record for the given user
            pCCtx->m_hrRecipient[ iRecipient ] = g_CPresenceUserIndex.FindPresence( pRecipients[ iRecipient ].qwUserID, &(pCCtx->m_rgpCPresence[iRecipient]));
            if( NULL == pCCtx->m_rgpCPresence[iRecipient] )
            {
                if (pCCtx->m_hrRecipient[ iRecipient ] == XONLINE_E_PRESENCE_USER_MIGRATED)
                {
                    memcpy(&(pFwdRecipients[cForwardIDs]), &(pRecipients[iRecipient]), sizeof(Q_RECIPIENT_RESULT));
                    cForwardIDs++;
                }

                // Nothing to do
                continue;
            }

            // Block the sender if asked to
            if( pMessage->dwFlags & XMSG_REVOKE_MESSAGE_EX_FLAG_BLOCK_SENDER )
            {
                pCCtx->m_rgpCPresence[iRecipient]->BlockUser( pMessage->qwSenderID );
            }

            // If revoking by ID, just call delete
            if( pMessage->dwFlags & XMSG_REVOKE_MESSAGE_EX_FLAG_USE_ID )
            {
                // Message ID from failed send not allowed
                if( pRecipients[ iRecipient ].dwMessageID & XONLINE_MSG_ID_SEND_FAILED )
                {
                    // The caller has handed us the failed result of a send for this recipient.  We won't
                    // fail the whole call over it, but let them know some failed in the reply HRESULT.
                    pCCtx->m_hrRecipient[ iRecipient ] = XONLINE_E_MESSAGE_INVALID_MESSAGE_ID;
                    continue;
                }

                if (!pCCtx->m_rgpCPresence[iRecipient]->HasOnlineRecord())
                {
                    pCCtx->m_hrRecipient[ iRecipient ] = HRESULT_FROM_WIN32( ERROR_NO_SUCH_USER );
                    continue;
                }
                pCCtx->m_hrRecipient[ iRecipient ] = pCCtx->m_rgpCPresence[iRecipient]->DeleteXMsgItem( pRecipients[ iRecipient ].dwMessageID );
                if( FAILED( pCCtx->m_hrRecipient[ iRecipient ] ) )
                {
                    continue;
                }

                // NOTE: pCCtx->m_rgRecipients[ iRecipient ].dwMessageID contains the message ID and RevokeMessageComplete
                // will send a QVal on it.
            }
            else
            {
                // We are deleting based on some criteria other than message ID, so we need to go through the list of messages

                DWORD dwMaxItems = MAX_TRANSIENT_MESSAGES;
                DWORD dwMaxItemDataSize = MAX_TRANSIENT_MESSAGES * ( sizeof( Q_MESSAGE_SUMMARY ) + XONLINE_MAX_MESSAGE_DETAILS );
                DWORD dwNextItemID;
                DWORD cItemsLeft;
                CQueueItem* pFirstItem;

                if (!pCCtx->m_rgpCPresence[iRecipient]->HasOnlineRecord())
                {
                    pCCtx->m_hrRecipient[ iRecipient ] = HRESULT_FROM_WIN32( ERROR_NO_SUCH_USER );
                    continue;
                }

                // Get the list of items out of the queue
                pCCtx->m_hrRecipient[ iRecipient ] = pCCtx->m_rgpCPresence[iRecipient]->ListItems(
                    FALSE, // list all items, not just V1
                    PQUEUE_TRANSIENT_MSGS,
                    0, // Start with the first item
                    &dwMaxItems,
                    &dwMaxItemDataSize,
                    &pFirstItem,
                    &dwNextItemID,
                    &cItemsLeft);
                if( FAILED( pCCtx->m_hrRecipient[ iRecipient ] ) )
                {
                    continue;
                }

                // Delete all matching messages
                BOOL fFoundMatch = FALSE;
                for( DWORD iMessage = 0; iMessage < dwMaxItems; iMessage++ )
                {
                    const Q_MESSAGE_SUMMARY* pMsgSummary = (Q_MESSAGE_SUMMARY*)pFirstItem->GetData();
                    const XMSG_DETAILS* pMsgDetails = (const XMSG_DETAILS*)( pMsgSummary + 1 );
                    DWORD dwCurrentItemID = pFirstItem->GetItemID();
                    pFirstItem = pFirstItem->GetNextInQ();

                    if( ( pMessage->dwFlags & XMSG_REVOKE_MESSAGE_EX_FLAG_USE_SENDER ) &&
                        pMessage->qwSenderID != pMsgSummary->qwSenderID )
                    {
                        // No match
                        continue;
                    }

                    if( ( pMessage->dwFlags & XMSG_REVOKE_MESSAGE_EX_FLAG_USE_CONTEXT ) &&
                        pMessage->qwSenderContext != pMsgSummary->qwSenderContext )
                    {
                        // No match
                        continue;
                    }

                    if( pMessage->dwFlags & XMSG_REVOKE_MESSAGE_EX_FLAG_USE_PROP )
                    {
                        const BYTE* pbMsgProp = GetMessageProperty( pMessage->wPropTag, pMsgDetails );

                        if( NULL == pbMsgProp )
                        {
                            // No match
                            continue;
                        }

                        if( 0 != memcmp( pbProp, pbMsgProp, pMessage->cbProp ) )
                        {
                            // No match
                            continue;
                        }
                    }

                    XOMASSERT( pMessage->dwFlags & XMSG_REVOKE_MESSAGE_EX_FLAG_USE_TYPE );
                    XOMASSERT( pMessage->bMessageType == pMsgSummary->bMessageType );

                    // Set this first so that if the delete fails, the error code won't get overwritten below
                    fFoundMatch = TRUE;

                    // We have a match, delete it
                    pCCtx->m_hrRecipient[ iRecipient ] = pCCtx->m_rgpCPresence[iRecipient]->DeleteXMsgItem( dwCurrentItemID );

                    // NOTE: Calling DeleteXMsgItem can delete pCUser, don't use it after here

                    // NOTE: Store the message ID we deleted so that we can send a QVal on it in RevokeMessageComplete
                    pCCtx->m_rgRecipients[ iRecipient ].dwMessageID = dwCurrentItemID;

                    break;


                } // for each message

                if( !fFoundMatch )
                {
                    pCCtx->m_hrRecipient[ iRecipient ] = XONLINE_E_MESSAGE_NO_VALID_SENDS_TO_REVOKE;
                }
            }

        } // for each recipient

        // Block anyone that needs blocking
        // NOTE: The parameter validation in msgutil will have validated that there is only one recipient in this
        // case.  Even if the block fails we proceed, this is best effort.
        // NOTE: Don't allow blocking PUID zero
        if( pMessage->dwFlags & XMSG_REVOKE_MESSAGE_EX_FLAG_BLOCK_SENDER &&
            0 != pMessage->qwSenderID )
        {
            XOMASSERT( 1 == pMessage->cRecipients );

            CBlockUsersContext* pCBlockCtx = new CBlockUsersContext( &m_CProfileStore );
            if( NULL != pCBlockCtx )
            {
                // Populate the context object
                pCBlockCtx->m_qwSenderID = pMessage->qwSenderID;
                pCBlockCtx->m_qwRecipientID = pRecipients[ 0 ].qwUserID;

                if( FAILED( m_CProfileStore.SendToSqlThread( pCBlockCtx ) ) )
                {
                    SAFE_RELEASE( pCBlockCtx );
                }
                else
                {
                    // NOTE: The SQL thread will release the context when it completes
                }
            }
        }

        XOMASSERT( S_OK == hr );
        RevokeMessageComplete( pCCtx );
    }
    else
    {
        // The message is persistent, send it to the profile store

        // reference the userids
        for( int iRecipient = 0; iRecipient < pCCtx->m_Message.cRecipients; iRecipient++ )
        {
            // See if there's currently a record for the given user
            pCCtx->m_hrRecipient[ iRecipient ] = g_CPresenceUserIndex.FindPresence( pCCtx->m_rgRecipients[iRecipient].qwUserID, &(pCCtx->m_rgpCPresence[iRecipient]));
            if( NULL == pCCtx->m_rgpCPresence[iRecipient] )
            {
                if (pCCtx->m_hrRecipient[ iRecipient ] == XONLINE_E_PRESENCE_USER_MIGRATED)
                {
                    // add this user to the forward list
                    memcpy(&(pFwdRecipients[cForwardIDs]), &(pCCtx->m_rgRecipients[iRecipient]), sizeof(Q_RECIPIENT_RESULT));
                    cForwardIDs++;

                    // remove this user from this context's list.  the other server will process him.
                    iRecipient--;
                    pCCtx->m_Message.cRecipients--;
                }
            }
        }

        // NOTE: We don't support revoking persistent messages by property, msgutil validates that this doesn't happen,
        // and we therefore don't need to copy pbProp into the context object.

        hr = m_CProfileStore.SendToSqlThread( pCCtx );

        // Call will post a completion when it resolves
    }

    if (cForwardIDs > 0)
    {
        memcpy(pFwdMessage, pMessage, sizeof(Q_REVOKE_MESSAGE_EX_MSG));
        pFwdMessage->cRecipients = (WORD)cForwardIDs;
        memcpy(pFwdRecipients + cForwardIDs, pbProp, pMessage->cbProp);

        hr = m_CXPCluster.SendRevokeMessage(
            pFwdMessage,
            pFwdRecipients,
            (BYTE *)(pFwdRecipients + cForwardIDs),
            TRUE);
    }

lDone:

    if( FAILED( hr ) )
    {
        SAFE_RELEASE( pCCtx );

        XomNtEvent(
            XEVENT_PRESENCE_CODE_482,
            "m_pSwitchboard->RevokeMessageInternal (type %u) failed hr=0x%X",
            pMessage->bMessageType,
            hr);
    }

    SAFE_ARRAYDELETE(pFwdMessage);

    return hr;
}

/*****************************************************************************

CSwitchboard::DeleteUserTitle

Delete a title from a user's owned-title list.

*****************************************************************************/
HRESULT CSwitchboard::DeleteUserTitle(
    QWORD qwUserID,
    DWORD dwTitleID,
    CClientConnection *pCReplyConn,
    DWORD dwSeqNum)
{
    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Switchboard - DeleteUserTitle: User=%I64X Title=0x%08X",
        qwUserID,
        dwTitleID);

    HRESULT hr = S_OK;
    CDeleteUserTitleContext *pCCtx = NULL;

    // Create a context object
    pCCtx = new CDeleteUserTitleContext( this, &m_CProfileStore );
    if( NULL == pCCtx )
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Populate the context object
    pCCtx->m_fProcessed = FALSE;
    pCCtx->m_qwUserID = qwUserID;
    pCCtx->m_dwTitleID = dwTitleID;
    pCCtx->m_pCReplyConn = pCReplyConn;
    pCReplyConn->AddRef();
    pCCtx->m_dwSeqNum = dwSeqNum;

    hr = g_CPresenceUserIndex.FindPresence(qwUserID, &(pCCtx->m_pCPresence));
    if (FAILED(hr))
    {
        goto lDone;
    }

    hr = m_CProfileStore.SendToSqlThread( pCCtx );

    // Call will post a completion when it resolves

lDone:
    if( FAILED( hr ) )
    {
        SAFE_RELEASE( pCCtx );
    }

    return hr;
}

/*****************************************************************************

CSwitchboard::EnumerateUserTitles

List the titles a user has logged on with in the past.

*****************************************************************************/
HRESULT CSwitchboard::EnumerateUserTitles(
    QWORD qwUserID,
    CClientConnection *pCReplyConn,
    DWORD dwSeqNum)
{
    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Switchboard - EnumerateUserTitles: User=%I64X",
        qwUserID);

    HRESULT hr = S_OK;
    CEnumerateUserTitlesContext *pCCtx = NULL;

    // Create a context object
    pCCtx = new CEnumerateUserTitlesContext( this, &m_CProfileStore );
    if( NULL == pCCtx )
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Populate the context object
    pCCtx->m_fProcessed = FALSE;
    pCCtx->m_qwUserID = qwUserID;
    pCCtx->m_pCReplyConn = pCReplyConn;
    pCReplyConn->AddRef();
    pCCtx->m_dwSeqNum = dwSeqNum;

    hr = g_CPresenceUserIndex.FindPresence(qwUserID, &(pCCtx->m_pCPresence));
    if (FAILED(hr))
    {
        goto lDone;
    }

    // Send it over to the SQL thread pool
    hr = m_CProfileStore.SendToSqlThread( pCCtx );

    // Call will post a completion when it resolves

lDone:
    if( FAILED( hr ) )
    {
        SAFE_RELEASE( pCCtx );
    }

    return hr;
}

/*****************************************************************************

CSwitchboard::MessageFlags

Changes the flags on a message.

*****************************************************************************/
HRESULT CSwitchboard::MessageFlags(
    QWORD qwUserID,
    DWORD dwMessageID,
    DWORD dwSetFlags,
    DWORD dwUnsetFlags,
    CClientConnection *pCReplyConn,
    DWORD dwSeqNum)
{
    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Switchboard - MessageFlags: User=%I64X Message=0x%08X SetFlags=0x%08X ClearFlags=0x%08X",
        qwUserID,
        dwMessageID,
        dwSetFlags,
        dwUnsetFlags);

    HRESULT hr = S_OK;
    CMessageFlagsContext *pCCtx = NULL;

    // Create a context object
    pCCtx = new CMessageFlagsContext( this, &m_CProfileStore );
    if( NULL == pCCtx )
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Populate the context object
    pCCtx->m_fProcessed = FALSE;
    pCCtx->m_qwUserID = qwUserID;
    pCCtx->m_dwMessageID = dwMessageID;
    pCCtx->m_dwSetFlags = dwSetFlags;
    pCCtx->m_dwUnsetFlags = dwUnsetFlags;
    pCCtx->m_pCReplyConn = pCReplyConn;
    pCReplyConn->AddRef();
    pCCtx->m_dwSeqNum = dwSeqNum;

    hr = g_CPresenceUserIndex.FindPresence(qwUserID, &(pCCtx->m_pCPresence));
    if (FAILED(hr))
    {
        goto lDone;
    }

    if( IsMsgTransient( dwMessageID ) )
    {
        // The message is transient, handle it locally

        // See if there's currently a record for the given user
        if (!(pCCtx->m_pCPresence->HasOnlineRecord()))
        {
            hr = HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
            goto lDone;
        }

        // Retrieve the item from the queue
        CQueueItem* pItem = pCCtx->m_pCPresence->GetItem(
            PQUEUE_TRANSIENT_MSGS,
            dwMessageID);
        if( NULL == pItem )
        {
            hr = XONLINE_E_MESSAGE_INVALID_MESSAGE_ID;
            goto lDone;
        }

        // Modify the message as requested
        ((Q_MESSAGE_SUMMARY*) pItem->GetData() )->dwMessageFlags &= ~(dwUnsetFlags);
        ((Q_MESSAGE_SUMMARY*) pItem->GetData() )->dwMessageFlags |= dwSetFlags;

        // Success, set the output parameters
        pCCtx->m_hr = S_OK;

        // This will clean up pCCtx
        MessageFlagsComplete( pCCtx );
    }
    else
    {
        // The message is persistent, send it to the profile store
        hr = m_CProfileStore.SendToSqlThread( pCCtx );

        // Call will post a completion when it resolves
    }

lDone:
    if( FAILED( hr ) )
    {
        SAFE_RELEASE( pCCtx );

        if (hr != XONLINE_E_MESSAGE_INVALID_MESSAGE_ID)
        {
            XomNtEvent(
                XEVENT_PRESENCE_CODE_483,
                "m_pSwitchboard->MessageFlags (user %I64X) failed hr=0x%X",
                qwUserID,
                hr);
        }
    }

    return hr;
}

/*****************************************************************************

CSwitchboard::EnumSystemMessages

Enumerates system messages.

*****************************************************************************/
HRESULT CSwitchboard::EnumSystemMessages(
    DWORD dwTitleID,
    CClientConnection *pCReplyConn,
    DWORD dwSeqNum)
{
    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Switchboard - EnumSystemMessages: Title=0x%08X",
        dwTitleID);

    HRESULT hr = S_OK;
    CEnumSystemMessagesContext* pCCtx = NULL;

    // Create a context object
    pCCtx = new CEnumSystemMessagesContext( this, &m_CProfileStore );
    if( NULL == pCCtx )
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Populate the context object
    pCCtx->m_fProcessed = FALSE;
    pCCtx->m_dwTitleID = dwTitleID;
    pCCtx->m_pCReplyConn = pCReplyConn;
    pCReplyConn->AddRef();
    pCCtx->m_dwSeqNum = dwSeqNum;

    // Send it over to the SQL thread pool
    hr = m_CProfileStore.SendToSqlThread( pCCtx );

    // Call will post a completion when it resolves

lDone:
    if( FAILED( hr ) )
    {
        SAFE_RELEASE( pCCtx );
    }
    return hr;
}

/*****************************************************************************

CSwitchboard::GetSystemMessageDetails

Gets details for a system message.

*****************************************************************************/
HRESULT CSwitchboard::GetSystemMessageDetails(
    DWORD dwTitleID,
    DWORD dwMessageID,
    CClientConnection *pCReplyConn,
    DWORD dwSeqNum)
{
    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Switchboard - GetSystemMessageDetails: Title=0x%08X Message=0x%08X",
        dwTitleID,
        dwMessageID);

    HRESULT hr = S_OK;
    CSystemMessageDetailsContext* pCCtx = NULL;

    // Create a context object
    pCCtx = new CSystemMessageDetailsContext( this, &m_CProfileStore );
    if( NULL == pCCtx )
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Populate the context object
    pCCtx->m_fProcessed = FALSE;
    pCCtx->m_dwTitleID = dwTitleID;
    pCCtx->m_dwMessageID = dwMessageID;
    pCCtx->m_pCReplyConn = pCReplyConn;
    pCReplyConn->AddRef();
    pCCtx->m_dwSeqNum = dwSeqNum;

    // Send it over to the SQL thread pool
    hr = m_CProfileStore.SendToSqlThread( pCCtx );

    // Call will post a completion when it resolves

lDone:
    if( FAILED( hr ) )
    {
        SAFE_RELEASE( pCCtx );
    }
    return hr;
}

/*****************************************************************************

CSwitchboard::DeleteSystemMessage

Deletes a system message.

*****************************************************************************/
HRESULT CSwitchboard::DeleteSystemMessage(
    DWORD dwTitleID,
    DWORD dwMessageID,
    DWORD dwFlags,
    CClientConnection *pCReplyConn,
    DWORD dwSeqNum)
{
    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Switchboard - DeleteSystemMessage: Title=0x%08X Message=0x%08X Flags=0x%08X",
        dwTitleID,
        dwMessageID,
        dwFlags);

    HRESULT hr = S_OK;
    CDeleteSystemMessageContext* pCCtx = NULL;

    // Create a context object
    pCCtx = new CDeleteSystemMessageContext( this, &m_CProfileStore );
    if( NULL == pCCtx )
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Populate the context object
    pCCtx->m_fProcessed = FALSE;
    pCCtx->m_dwTitleID = dwTitleID;
    pCCtx->m_dwMessageID = dwMessageID;
    pCCtx->m_dwFlags = dwFlags;
    pCCtx->m_pCReplyConn = pCReplyConn;
    pCReplyConn->AddRef();
    pCCtx->m_dwSeqNum = dwSeqNum;

    // Send it over to the SQL thread pool
    hr = m_CProfileStore.SendToSqlThread( pCCtx );

    // Call will post a completion when it resolves

lDone:
    if( FAILED( hr ) )
    {
        SAFE_RELEASE( pCCtx );
    }
    return hr;
}

/*****************************************************************************

CSwitchboard::SendSystemMessage

Sends a system message.

*****************************************************************************/
HRESULT CSwitchboard::SendSystemMessage(
    const Q_SEND_SYSTEM_MESSAGE_MSG* pSendMessage,
    const BYTE* pbDetails,
    CClientConnection *pCReplyConn,
    DWORD dwSeqNum)
{
    XomTrace(
        PresenceDebug,
        L_NORMAL,
        "Switchboard - SendSystemMessage: Title=0x%08X",
        pSendMessage->dwTitleID);

    HRESULT hr = S_OK;
    CSendSystemMessageContext* pCCtx = NULL;

    // Create a context object
    pCCtx = new CSendSystemMessageContext( this, &m_CProfileStore );
    if( NULL == pCCtx )
    {
        hr = E_OUTOFMEMORY;
        goto lDone;
    }

    // Populate the context object
    pCCtx->m_fProcessed = FALSE;
    memcpy( &pCCtx->m_Message, pSendMessage, sizeof( *pSendMessage ) );
    memcpy( pCCtx->m_rgbDetails, pbDetails, pSendMessage->cbDetails );
    pCCtx->m_pCReplyConn = pCReplyConn;
    pCReplyConn->AddRef();
    pCCtx->m_dwSeqNum = dwSeqNum;

    // Send it over to the SQL thread pool
    hr = m_CProfileStore.SendToSqlThread( pCCtx );

    // Call will post a completion when it resolves

lDone:
    if( FAILED( hr ) )
    {
        SAFE_RELEASE( pCCtx );
    }
    return hr;
}


/*****************************************************************************

CSwitchboard::CheckSGAddr

Checks the SGADDR input against the given expected value for a user.

*****************************************************************************/
BOOL CSwitchboard::CheckSGAddr(const SGADDR *psgaddrIn, CPresence *pCPresence)
{
    if (pCPresence == NULL)
        return FALSE;

    const SGADDR *psgaddrExpected = pCPresence->GetSGAddr();

    // Validate the message's sgaddr against the user's
    if((memcmp(&sgaddrIgnore, psgaddrIn, sizeof(SGADDR)) == 0) ||
       (memcmp(psgaddrExpected, psgaddrIn, sizeof(SGADDR)) == 0))
    {
        return TRUE;
    }

    if (pCPresence->IsOnline())
    {
        XomNtEvent(
            XEVENT_PRESENCE_CODE_484,
            "CheckSGAddr() failed for user %I64X.  Expected (sgip: 0x%X, spi: 0x%X, xbox: 0x%I64X).  Got (sgip: 0x%X, spi: 0x%X, xbox: 0x%I64X).",
            pCPresence->GetUserID(),
            psgaddrExpected->inaSg,
            psgaddrExpected->dwSpiSg,
            psgaddrExpected->qwXboxID,
            psgaddrIn->inaSg,
            psgaddrIn->dwSpiSg,
            psgaddrIn->qwXboxID);
    }

    return FALSE;
}

/*****************************************************************************

CSwitchboard::SendWelcomeMessage

Send a message to the user's inbox whenever they have signed on with a console
that the service has never seen before.

*****************************************************************************/
HRESULT CSwitchboard::SendWelcomeMessage(QWORD qwUserID, DWORD dwMessageID)
{
    HRESULT hr = S_OK;
    WORD cbDetails = sizeof(XMSG_DETAILS) + sizeof(XMSG_PROPERTY) + sizeof(DWORD);
    BYTE *pbDetails = new BYTE[cbDetails];
    Q_SEND_MESSAGE_MSG sendmsg;

    // Build a new message from scratch
    sendmsg.qwSenderID = 0;  // System
    sendmsg.qwSenderContext = 0;
    sendmsg.dwMessageFlags = XONLINE_MSG_FLAG_RECOMMENDED;
    sendmsg.dwSenderTitleID = XONLINE_XBOX_DASH_TITLE_ID;
    sendmsg.wExpireMinutes = (WORD) g_CPresCfg.GetMessageTypeExpiration( XONLINE_MSG_TYPE_LIVE_MESSAGE - 1);
    sendmsg.cbDetails = cbDetails;
    sendmsg.cRecipients = 1;
    sendmsg.bMessageType = XONLINE_MSG_TYPE_LIVE_MESSAGE;
    strncpy( sendmsg.szSenderName, "LIVE System", 12 );

    XMSG_DETAILS *pDetails = (XMSG_DETAILS *) pbDetails;
    pDetails->wPropCount = 1;
    pDetails->cbData = sizeof(DWORD);

    XMSG_PROPERTY *pProperty = (XMSG_PROPERTY *) (pDetails + 1);
    pProperty->wPropTag = XONLINE_MSG_PROP_SYSTEM_TEXT;
    pProperty->wPropOffset = 0;

    DWORD *pdwMessageId = (DWORD *) (pProperty + 1);
    *pdwMessageId = dwMessageID;

    hr = SendMessageExternal(
        TRUE,
        &sendmsg,
        &qwUserID,
        pbDetails,
        NULL,
        NULL,
        0
        );

    delete [] pbDetails;

    // Best Effort --- We don't pass up any errors
    return S_OK;

}

/*****************************************************************************

CSwitchboard::AnnounceToAllBuddies

(Re)Announce that the given user has gone online to all their buddies
reguardless where the buddy's presence servers are.  It is expected that the
buddy will send a subscribed back if they are online.

*****************************************************************************/
HRESULT CSwitchboard::AnnounceToAllBuddies(CPresence *pCPresence)
{
    HRESULT hr = S_OK;
    QWORD qwUserID;
    DWORD dwBuddyIndex;
    DWORD cBuddyIDs = 0;
    QWORD rgqwBuddyIDs[MAX_BUDDIES];

    qwUserID = pCPresence->GetUserID();
    SET_PUID_CLIENT_TYPE(qwUserID, (pCPresence->CanClientConsumeRichPresence() ? PRES_CLIENT_TYPE_XENON : PRES_CLIENT_TYPE_XBOX));
    SET_PUID_CLIENT_BETA(qwUserID, (pCPresence->CanClientIgnoreFriendStateNotifications() ? 1 : 0));

    // Create a list of mutually accepted buddies
    for (dwBuddyIndex = 0; dwBuddyIndex < pCPresence->GetNumBuddies(); dwBuddyIndex++)
    {
        // If the buddy is accepted
        if (pCPresence->GetBuddy(dwBuddyIndex)->GetStatus()== P_BUDDY_STATUS_OK)
        {
            // Add it to the list
            rgqwBuddyIDs[cBuddyIDs] = pCPresence->GetBuddy(dwBuddyIndex)->GetBuddyID();
            cBuddyIDs++;
        }
    }

    // Send the annouce message to the relevant presence servers (local included)
    if (cBuddyIDs > 0)
    {
        hr = m_CXPCluster.SendMsgAnnounce(
                qwUserID,
                pCPresence->GetTitleID(),
                pCPresence->GetAcctName(),
                cBuddyIDs,
                rgqwBuddyIDs);
    }

    // Best effort, don't pass up any errors
    return S_OK;
}

/*****************************************************************************

CSwitchboard::UnsubscribeFromAllBuddies

Unsubscribe the given user from all of their mutualy accepted buddy's presence
reguardless where the buddy's presence servers are.  It is not expected that
the buddy will unsubscribe back because they will assume they were automaticly
unsubscribed.  This does not include the final offline state notification.

*****************************************************************************/
HRESULT CSwitchboard::UnsubscribeFromAllBuddies(CPresence *pCPresence)
{
    HRESULT hr = S_OK;
    QWORD qwUserID;
    DWORD dwBuddyIndex;
    DWORD cBuddyIDs = 0;
    QWORD rgqwBuddyIDs[MAX_BUDDIES];

    qwUserID = pCPresence->GetUserID();

    // Create a list of mutually accepted buddies
    // CONSIDER: limit this to only subscribed budies, however that may create races
    for (dwBuddyIndex = 0; dwBuddyIndex < pCPresence->GetNumBuddies(); dwBuddyIndex++)
    {
        // If the buddy is accepted
        if (pCPresence->GetBuddy(dwBuddyIndex)->GetStatus()== P_BUDDY_STATUS_OK)
        {
            // Add it to the list
            rgqwBuddyIDs[cBuddyIDs] = pCPresence->GetBuddy(dwBuddyIndex)->GetBuddyID();
            cBuddyIDs++;
        }
    }

    // Send the unsubscribe message to the relevant presence servers (local included)
    if (cBuddyIDs > 0)
    {
        hr = m_CXPCluster.SendMsgUnsubscribe(qwUserID, cBuddyIDs, rgqwBuddyIDs);
    }

    // Clear watches
    hr = ClearPeerWatches(pCPresence);

    // Best effort, don't pass up any errors
    return S_OK;
}

/*****************************************************************************

CSwitchboard::NotifyPresenceAll

Notify all of the given user's subscribed mutualy accepted buddies of our
presence by sending a presence item to their  notification queue.

*****************************************************************************/
HRESULT CSwitchboard::NotifyPresenceAll(CPresence *pCPresence, BOOL fSendToXbox, BOOL fSendToFriendXenon, BOOL fSendToPeerXenon)
{
    HRESULT hr = S_OK;
    DWORD dwBuddyIndex;
    DWORD cBuddyIDs = 0;
    QWORD rgqwBuddyIDs[MAX_BUDDIES];

    // For each buddy
    for (dwBuddyIndex = 0; dwBuddyIndex < pCPresence->GetNumBuddies(); dwBuddyIndex++)
    {
        CBuddyListEntry *pBuddy = pCPresence->GetBuddy(dwBuddyIndex);

        // If the buddy is subscribed
        if (!(pBuddy->IsSubscribed() || pBuddy->IsPeerSubscribed()))
        {
            continue;
        }

        DWORD dwClientType = pBuddy->GetClientType();
        DWORD dwClientBeta = pBuddy->IsClientBeta();
        BOOL fIsPeerSubscribed = pBuddy->IsPeerSubscribed();
        if (((dwClientType == PRES_CLIENT_TYPE_XBOX) && !fSendToXbox) ||
            ((dwClientType == PRES_CLIENT_TYPE_XENON) && !fSendToPeerXenon) ||
            ((dwClientType == PRES_CLIENT_TYPE_XENON) && dwClientBeta && !fSendToFriendXenon && !fIsPeerSubscribed))
        {
            // we dont send this notification to this friend.
            g_Counters.IncrementValue32(XPPERF_SERVER_FILTERED_NOTIFICATIONS_RATE, 1);
            continue;
        }

        // Add it to the list queues for the notication
        rgqwBuddyIDs[cBuddyIDs] = pBuddy->GetBuddyID();
        SET_PUID_CLIENT_TYPE(rgqwBuddyIDs[cBuddyIDs], dwClientType);
        cBuddyIDs++;
    }

    // Send the notifications to the server cluster if we have any
    if (cBuddyIDs > 0)
    {
        hr = m_CXPCluster.QueuePresence(pCPresence, rgqwBuddyIDs, cBuddyIDs);
    }

    // Send peer presence notifications
    if (pCPresence->GetNumWatchers() > 0)
    {
        hr = m_CXPCluster.QueuePeerPresence(pCPresence, pCPresence->GetWatchers(), pCPresence->GetNumWatchers(), fSendToXbox, fSendToPeerXenon);
    }

    // Best effort, don't pass up any errors
    return S_OK;
}

/*****************************************************************************

CSwitchboard::NotifyOfflineAll

Notify all of the given user's subscribed mutualy accepted buddies of our
presence by sending an offline presence item to their  notification queue.

*****************************************************************************/
HRESULT CSwitchboard::NotifyOfflineAll(CPresence *pCPresence, BOOL fBlockFriends)
{
    HRESULT hr = S_OK;
    DWORD dwBuddyIndex;
    DWORD cBuddyIDs = 0;
    QWORD rgqwBuddyIDs[MAX_BUDDIES];

    if (fBlockFriends)
    {
        // For each buddy
        for (dwBuddyIndex = 0; dwBuddyIndex < pCPresence->GetNumBuddies(); dwBuddyIndex++)
        {
            // If the buddy is subscribed
            if (pCPresence->GetBuddy(dwBuddyIndex)->IsSubscribed())
            {
                // Add it to the list queues for the notication
                rgqwBuddyIDs[cBuddyIDs] = pCPresence->GetBuddy(dwBuddyIndex)->GetBuddyID();
                SET_PUID_CLIENT_TYPE(rgqwBuddyIDs[cBuddyIDs], pCPresence->GetBuddy(dwBuddyIndex)->GetClientType());
                cBuddyIDs++;
            }
        }

        // Send the notifications to the server cluster if we have any
        if (cBuddyIDs > 0)
        {
            hr = m_CXPCluster.QueuePresenceOffline(pCPresence, cBuddyIDs, rgqwBuddyIDs);
        }
    }

    // Send peer presence notifications
    if (pCPresence->GetNumWatchers() > 0)
    {
        hr = m_CXPCluster.QueuePeerPresenceOffline(pCPresence, pCPresence->GetNumWatchers(), pCPresence->GetWatchers());
    }

    // Best effort, don't pass up any errors
    return S_OK;
}


/*****************************************************************************

CSwitchboard::ClearInvitation

Remove an invitation if one is outstanding.  Deletes the messages from the
appropriate buddies queues.

*****************************************************************************/
HRESULT CSwitchboard::ClearInvitation(CPresence *pCPresence)
{
    HRESULT hr = S_OK;
    CInvitation *pCInvite = NULL;

    // Get the invite
    pCInvite = pCPresence->GetInvite();
    if (pCInvite == NULL)
    {
        // No invite to cancel
        hr = S_OK;
        goto lDone;
    }

    Q_RECIPIENT_RESULT rgRecipients[ XONLINE_MAX_MESSAGE_RECIPIENTS ];

    for( DWORD iRecip = 0; iRecip < pCInvite->cInvitees; iRecip++ )
    {
        rgRecipients[ iRecip ].qwUserID = pCInvite->rgqwInvitees[ iRecip ];
        rgRecipients[ iRecip ].dwMessageID = 0;
    }

    // Clear unread invitations from notification queues (best-effort)
    (void) QueueRevokeMessage(
        pCPresence->GetUserID(),                    // SenderID
        0,                                          // SenderContext
        ( XMSG_REVOKE_MESSAGE_EX_FLAG_USE_PROP |
          XMSG_REVOKE_MESSAGE_EX_FLAG_USE_TYPE |
          XMSG_REVOKE_MESSAGE_EX_FLAG_USE_SENDER ), // dwFlags
        XONLINE_MSG_PROP_SESSION_ID,                // wPropTag
        sizeof( pCInvite->qwMatchSessionID ),       // cbProp
        (const BYTE*) &pCInvite->qwMatchSessionID,  // pbProp
        XONLINE_MSG_TYPE_GAME_INVITE,               // bMessageType
        (WORD) pCInvite->cInvitees,                 // cRecipients
        rgRecipients );                             // rgRecipients

    // Remove it from the presence record
    pCPresence->DeleteInvite();

lDone:
    return hr;
}

/*****************************************************************************

CSwitchboard::ClearPeerWatches

Clear any watches for peer presence

*****************************************************************************/
HRESULT CSwitchboard::ClearPeerWatches(CPresence *pCPresence)
{
    HRESULT hr = S_OK;

    if (pCPresence->GetNumWatches() > 0)
    {
        hr = m_CXPCluster.SendMsgWatchStop(pCPresence->GetUserID(), pCPresence->GetNumWatches(), pCPresence->GetWatches());

        pCPresence->ClearWatches();
    }

    return S_OK;
}

BOOL CSwitchboard::AdminKickUser(LPCSTR pszParams, DWORD dwRequestId, CXomControlResponseInterface *pResponseInterface)
{
    QWORD qwUserID;
    int iRet = sscanf(pszParams, "%I64d", &qwUserID);
    HRESULT hr = S_OK;
    CPresence *pCPresence = NULL;

    if (iRet != 1)
    {
        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "usage: exec :presence kick <user id (decimal)>\r\n");
        goto lDone;
    }

    hr = g_CPresenceUserIndex.FindPresence(qwUserID, &pCPresence);
    if (pCPresence == NULL)
    {
        if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
        {
            XomWriteFormattedResponse(pResponseInterface, dwRequestId, "User %I64X is awaiting migration -- try again in a few seconds.\r\n", qwUserID);
        }
        else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
        {
            DWORD dwServer = g_CPresCfg.MapUserToPresSrv(qwUserID, TRUE);
            XomWriteFormattedResponse(pResponseInterface, dwRequestId, "User %I64X has been migrated to server %s.\r\n", qwUserID, CW2A(g_CPresCfg.GetPresServerName(dwServer)));
            goto lDone;
        }
        else
        {
            DWORD dwServer = g_CPresCfg.MapUserToPresSrv(qwUserID, FALSE);
            if (dwServer != g_CPresCfg.GetMyPresServerIndex())
            {
                XomWriteFormattedResponse(pResponseInterface, dwRequestId, "User %I64X is serviced by server %s.\r\n", qwUserID, CW2A(g_CPresCfg.GetPresServerName(dwServer)));
                goto lDone;
            }
            else
            {
                XomWriteFormattedResponse(pResponseInterface, dwRequestId, "User %I64X is not in memory.\r\n", qwUserID);
            }
        }
    }
    else
    {
        if (!pCPresence->IsOnline())
        {
            XomWriteFormattedResponse(pResponseInterface, dwRequestId, "User %I64X is not online.\r\n", qwUserID);
        }
        else
        {
            hr = m_CSGComm.SendKick(pCPresence->GetSGAddr());
            XomWriteFormattedResponse(pResponseInterface, dwRequestId, "User %I64X was kicked.  hr = %X\r\n", qwUserID, hr);
        }

        pCPresence->ForceDBAlive();
        hr = KillUser(pCPresence);
        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "User %I64X was killed.  hr = %X\r\n", qwUserID, hr);
    }

lDone:

    SAFE_RELEASE(pCPresence);

    return FALSE;
}

BOOL CSwitchboard::AdminShowPresenceRecord(LPCSTR pszParams, DWORD dwRequestId, CXomControlResponseInterface *pResponseInterface)
{
    QWORD qwUserID;
    BOOL fVerbose = FALSE;

    int iRet = sscanf(pszParams, "%I64d", &qwUserID);
    CPresence *pCPresence = NULL;

    if (iRet != 1)
    {
        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "usage: exec :presence showrecord <user id (decimal)> [-v(erbose)]\r\n");
        goto lDone;
    }

    CHAR *szArg = strchr((CHAR *)pszParams, '-');
    if ((szArg != NULL) && (tolower(*(szArg + 1)) == 'v'))
    {
        fVerbose = TRUE;
    }

    HRESULT hr = g_CPresenceUserIndex.FindPresence(qwUserID, &pCPresence);
    if (pCPresence == NULL)
    {
        if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
        {
            XomWriteFormattedResponse(pResponseInterface, dwRequestId, "User %I64X is awaiting migration -- try again in a few seconds.\r\n", qwUserID);
        }
        else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
        {
            DWORD dwPriServer = g_CPresCfg.MapUserToPresSrv(qwUserID, FALSE);
            if (dwPriServer != g_CPresCfg.GetMyPresServerIndex())
            {
                XomWriteFormattedResponse(pResponseInterface, dwRequestId, "User %I64X is serviced by server %s.\r\n", qwUserID, CW2A(g_CPresCfg.GetPresServerName(dwPriServer)));
                goto lDone;
            }
            else
            {
                DWORD dwAltServer = g_CPresCfg.MapUserToPresSrv(qwUserID, TRUE);
                XomWriteFormattedResponse(pResponseInterface, dwRequestId, "User %I64X has been migrated to server %s.\r\n", qwUserID, CW2A(g_CPresCfg.GetPresServerName(dwAltServer)));
            }
        }
        else
        {
            XomWriteFormattedResponse(pResponseInterface, dwRequestId, "User %I64X is not in memory.\r\n", qwUserID);
        }
    }
    else
    {
        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "Current Tick Count: %u\r\n\r\n", GetTickCount());

        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "User %I64X:\r\n\r\n", qwUserID);

        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "  Base Record:\r\n\r\n");

        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "    RefCount = %d (includes this showrecord command)\r\n", pCPresence->GetRefCount());
        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "    Gamertag = %s (size = %d)\r\n", pCPresence->GetAcctName(), pCPresence->GetAcctNameLen());
        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "    State = 0x%X, (%s)\r\n", pCPresence->GetState(), pCPresence->IsOnline() ? "online" : "offline");
        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "    MarkedForDelete = %d\r\n", pCPresence->IsMarkedForDelete());
        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "    MarkedForDeadSG = %d\r\n", pCPresence->IsMarkedForDeadSG());
        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "    MarkedForMigration = %d\r\n", pCPresence->IsMarkedForMigration());
        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "    MigrationInProgress = %d\r\n", pCPresence->IsMigrationInProgress());
        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "    MigrationPending = %d\r\n", pCPresence->IsMigrationPending());
        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "    DebugReference = %d\r\n", pCPresence->HasDebugReference());
        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "    LastActiveTime = %d\r\n", pCPresence->GetLastActiveTime());
        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "    LastSeenTitle = 0x%X\r\n", pCPresence->GetLastSeenTitleID());
        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "    UserStateChangeTime = %d\r\n", (DWORD)pCPresence->GetUserStateChanged());
        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "    WebID = %I64X\r\n", pCPresence->GetWebID());
        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "    NumMessagesToday = %d\r\n", pCPresence->GetNumMessagesToday());
        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "    NumRecipientsToday = %d\r\n", pCPresence->GetNumRecipientsToday());
        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "    TimeFirstMessageSent = %d\r\n", pCPresence->GetTimeFirstMessageSent());

        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "\r\n    Privileges:\r\n");
        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "      CanPlayOnline = %d\r\n", pCPresence->CanPlayOnline());
        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "      CanMessage = %s\r\n", pCPresence->CanMessage(FALSE) ? "Everyone" : pCPresence->CanMessage(TRUE) ? "Friends Only" : "Blocked");
        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "      CanSharePresence = %s\r\n", pCPresence->CanSharePresence(FALSE) ? "Everyone" : pCPresence->CanSharePresence(TRUE) ? "Friends Only" : "Blocked");
        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "      CanShareFriendsList = %s\r\n", pCPresence->CanShareFriendsList(FALSE) ? "Everyone" : pCPresence->CanShareFriendsList(TRUE) ? "Friends Only" : "Blocked");

        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "\r\n    Friends (Num = %d, Version = %d):\r\n", pCPresence->GetNumBuddies(), pCPresence->GetBuddyListVersion());

        if (fVerbose)
        {
            for (DWORD iFriend = 0; iFriend < pCPresence->GetNumBuddies(); iFriend++)
            {
                CBuddyListEntry *pFriend = pCPresence->GetBuddy(iFriend);
                if (pFriend == NULL)
                {
                    continue;
                }

                XomWriteFormattedResponse(pResponseInterface, dwRequestId, "      %3d), FriendPUID = %I64X, Status = %d, Subscribed = %c%c, ClientType = %d, Beta = %d\r\n", iFriend, pFriend->GetBuddyID(), pFriend->GetStatus(), pFriend->IsPeerSubscribed() ? 'P' : ' ', pFriend->IsSubscribed() ? 'F' : ' ', pFriend->GetClientType(), pFriend->IsClientBeta());
            }
        }

        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "\r\n    Nevers (Num = %d):\r\n", pCPresence->GetNeverListCount());
        if (fVerbose)
        {
            const QWORD *rgNevers = pCPresence->GetNeverList();
            for (WORD iNever = 0; iNever < pCPresence->GetNeverListCount(); iNever++)
            {
                XomWriteFormattedResponse(pResponseInterface, dwRequestId, "      %3d), NeverPUID = %I64X\r\n", iNever, rgNevers[iNever]);
            }
        }

        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "\r\n    Watchers (Num = %d):\r\n", pCPresence->GetNumWatchers());
        if (fVerbose)
        {
            const QWORD *rgWatchers = pCPresence->GetWatchers();
            for (DWORD iWatcher = 0; iWatcher < pCPresence->GetNumWatchers(); iWatcher++)
            {
                XomWriteFormattedResponse(pResponseInterface, dwRequestId, "      %3d), WatcherPUID = %I64X, Client Type = %d\r\n", iWatcher, GET_PUID_BITS(rgWatchers[iWatcher]), GET_PUID_CLIENT_TYPE(rgWatchers[iWatcher]));
            }
        }

        if (!pCPresence->HasOnlineRecord())
        {
            XomWriteFormattedResponse(pResponseInterface, dwRequestId, "\r\n  No Online Record\r\n");
        }
        else
        {
            XomWriteFormattedResponse(pResponseInterface, dwRequestId, "\r\n  Online Record:\r\n\r\n");

            const SGADDR *psgaddr = pCPresence->GetSGAddr();
            XBOX_LIBRARY_VERSION xlv = DWORD_TO_CLIENTVERSION(pCPresence->GetClientVersionDWORD());
            XomWriteFormattedResponse(pResponseInterface, dwRequestId, "    SGADDR ip = 0x%X, spi = 0x%X, xbox = %I64X\r\n", psgaddr->inaSg, psgaddr->dwSpiSg, psgaddr->qwXboxID);
            XomWriteFormattedResponse(pResponseInterface, dwRequestId, "    Client type = %s\r\n", IS_XBOX_MACHINE_PUID(psgaddr->qwXboxID) ? "xbox 1" : IS_PC_MACHINE_PUID(psgaddr->qwXboxID) ? "panorama" : IS_XENON_MACHINE_PUID(psgaddr->qwXboxID) ? "xenon" : "unknown!");
            XomWriteFormattedResponse(pResponseInterface, dwRequestId, "    Client version = %d.%d.%d.%d\r\n", xlv.wMajorVersion, xlv.wMinorVersion, xlv.wBuildNumber, xlv.wQFENumber);
            XomWriteFormattedResponse(pResponseInterface, dwRequestId, "    Client version flags = 0x%I64X\r\n", pCPresence->GetVersionFlags());
            XomWriteFormattedResponse(pResponseInterface, dwRequestId, "    TitleID = 0x%X\r\n", pCPresence->GetTitleID());
            XomWriteFormattedResponse(pResponseInterface, dwRequestId, "    TitleRegion = 0x%X\r\n", pCPresence->GetTitleRegion());
            XomWriteFormattedResponse(pResponseInterface, dwRequestId, "    TitleVersion = %d\r\n", pCPresence->GetTitleVersion());
            XomWriteFormattedResponse(pResponseInterface, dwRequestId, "    AuthDataFlags = 0x%X\r\n", pCPresence->GetAuthDataFlags());
            XomWriteFormattedResponse(pResponseInterface, dwRequestId, "    HasTransientMessages = %d\r\n", pCPresence->HasTransientMessages());
            XomWriteFormattedResponse(pResponseInterface, dwRequestId, "    MatchSessionID = %I64X\r\n", pCPresence->GetMatchSessionID());
            XomWriteFormattedResponse(pResponseInterface, dwRequestId, "    BlockListVersion = %d\r\n", pCPresence->GetBlockListVersion());
            XomWriteFormattedResponse(pResponseInterface, dwRequestId, "    PQueueIndex = %d\r\n", pCPresence->GetPQueueIndex());
            XomWriteFormattedResponse(pResponseInterface, dwRequestId, "    TickleCount = %d\r\n", pCPresence->GetTickleCount());
            XomWriteFormattedResponse(pResponseInterface, dwRequestId, "    TimeScheduled = %d\r\n", pCPresence->GetTimeScheduled());
            XomWriteFormattedResponse(pResponseInterface, dwRequestId, "    Nickname = %s (size = %d)\r\n", pCPresence->GetNickname(), pCPresence->GetNicknameLen());
            XomWriteFormattedResponse(pResponseInterface, dwRequestId, "    TitleStuffLen = %d\r\n", pCPresence->GetTitleStuffLen());
            if (pCPresence->GetTitleStuffLen() > 0)
            {
                XomWriteFormattedResponse(pResponseInterface, dwRequestId, "    TitleStuff =");
                BYTE *pData = pCPresence->GetTitleStuff();
                for (DWORD iByte = 0; iByte < pCPresence->GetTitleStuffLen(); iByte++)
                {
                    XomWriteFormattedResponse(pResponseInterface, dwRequestId, " %02X", pData[iByte]);
                }
                XomWriteFormattedResponse(pResponseInterface, dwRequestId, "\r\n");
            }

            XomWriteFormattedResponse(pResponseInterface, dwRequestId, "    RichPresenceLen = %d\r\n", pCPresence->GetRichPresenceLen());
            if (pCPresence->GetRichPresenceLen() > 0)
            {
                XomWriteFormattedResponse(pResponseInterface, dwRequestId, "    RichPresenceData =");
                BYTE *pData = pCPresence->GetRichPresenceData();
                for (DWORD iByte = 0; iByte < pCPresence->GetRichPresenceLen(); iByte++)
                {
                    XomWriteFormattedResponse(pResponseInterface, dwRequestId, " %02X", pData[iByte]);
                }
                XomWriteFormattedResponse(pResponseInterface, dwRequestId, "\r\n");
            }

            DWORD *pdwQvals = pCPresence->GetQVals();
            if (pdwQvals != NULL)
            {
                XomWriteFormattedResponse(pResponseInterface, dwRequestId, "    QVals =");
                for (DWORD iQVal = 0; iQVal < QVAL_COUNT; iQVal++)
                {
                    XomWriteFormattedResponse(pResponseInterface, dwRequestId, " %08X", pdwQvals[iQVal]);
                }
                XomWriteFormattedResponse(pResponseInterface, dwRequestId, "\r\n");
            }

            XomWriteFormattedResponse(pResponseInterface, dwRequestId, "\r\n    Watches (Num = %d):\r\n", pCPresence->GetNumWatches());
            if (fVerbose)
            {
                const QWORD *rgWatches = pCPresence->GetWatches();
                for (DWORD iWatch = 0; iWatch < pCPresence->GetNumWatches(); iWatch++)
                {
                    XomWriteFormattedResponse(pResponseInterface, dwRequestId, "      %3d), WatchPUID = %I64X\r\n", iWatch, rgWatches[iWatch]);
                }
            }

            CInvitation *pInvite = pCPresence->GetInvite();
            if (pInvite != NULL)
            {
                XomWriteFormattedResponse(pResponseInterface, dwRequestId, "\r\n    Invite (TitleID = 0x%X, SessionID = %I64X, NumInvitees = %d):\r\n", pInvite->dwTitleID, pInvite->qwMatchSessionID, pInvite->cInvitees);
                if (fVerbose)
                {
                    for (DWORD iInvitee = 0; iInvitee < pInvite->cInvitees; iInvitee++)
                    {
                        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "      %3d), InviteePUID = %I64X\r\n", iInvitee, pInvite->rgqwInvitees[iInvitee]);
                    }
                }
            }

            if (!pCPresence->IsAffiliatesListLoaded())
            {
                XomWriteFormattedResponse(pResponseInterface, dwRequestId, "\r\n    Affiliates List not loaded\r\n");
            }
            else
            {
                CAffiliatesList Affiliates;
                DWORD iAffiliate;

                pCPresence->GetAffiliates(X_AFFILIATE_INDEX_TO_FLAG(X_AFFILIATE_ENCOUNTERED_INDEX), &Affiliates);
                XomWriteFormattedResponse(pResponseInterface, dwRequestId, "\r\n    Affiliates List (Encountered, size = %d):\r\n", Affiliates.dwSize);
                if (fVerbose)
                {
                    for (iAffiliate = 0; iAffiliate < Affiliates.dwSize; iAffiliate++)
                    {
                        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "      %3d) AffiliatePUID = %I64X, TitleID = 0x%X, Time = %d\r\n", iAffiliate, Affiliates.rgAffiliates[iAffiliate].qwAffiliateID, Affiliates.rgAffiliates[iAffiliate].dwTitleID, (DWORD)Affiliates.rgAffiliates[iAffiliate].mtDateUpdated);
                    }
                }
                delete[] Affiliates.rgAffiliates;

                pCPresence->GetAffiliates(X_AFFILIATE_INDEX_TO_FLAG(X_AFFILIATE_COMPLETED_GAME_INDEX), &Affiliates);
                XomWriteFormattedResponse(pResponseInterface, dwRequestId, "\r\n    Affiliates List (Completed Game, size = %d):\r\n", Affiliates.dwSize);
                if (fVerbose)
                {
                    for (iAffiliate = 0; iAffiliate < Affiliates.dwSize; iAffiliate++)
                    {
                        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "      %3d) AffiliatePUID = %I64X, TitleID = 0x%X, Time = %d\r\n", iAffiliate, Affiliates.rgAffiliates[iAffiliate].qwAffiliateID, Affiliates.rgAffiliates[iAffiliate].dwTitleID, (DWORD)Affiliates.rgAffiliates[iAffiliate].mtDateUpdated);
                    }
                }
                delete[] Affiliates.rgAffiliates;

                pCPresence->GetAffiliates(X_AFFILIATE_INDEX_TO_FLAG(X_AFFILIATE_POSITIVE_FEEDBACK_INDEX), &Affiliates);
                XomWriteFormattedResponse(pResponseInterface, dwRequestId, "\r\n    Affiliates List (Positive Feedback, size = %d):\r\n", Affiliates.dwSize);
                if (fVerbose)
                {
                    for (iAffiliate = 0; iAffiliate < Affiliates.dwSize; iAffiliate++)
                    {
                        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "      %3d) AffiliatePUID = %I64X, TitleID = 0x%X, Time = %d\r\n", iAffiliate, Affiliates.rgAffiliates[iAffiliate].qwAffiliateID, Affiliates.rgAffiliates[iAffiliate].dwTitleID, (DWORD)Affiliates.rgAffiliates[iAffiliate].mtDateUpdated);
                    }
                }
                delete[] Affiliates.rgAffiliates;

                pCPresence->GetAffiliates(X_AFFILIATE_INDEX_TO_FLAG(X_AFFILIATE_NEGATIVE_FEEDBACK_INDEX), &Affiliates);
                XomWriteFormattedResponse(pResponseInterface, dwRequestId, "\r\n    Affiliates List (Negative Feedback, size = %d):\r\n", Affiliates.dwSize);
                if (fVerbose)
                {
                    for (iAffiliate = 0; iAffiliate < Affiliates.dwSize; iAffiliate++)
                    {
                        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "      %3d) AffiliatePUID = %I64X, TitleID = 0x%X, Time = %d\r\n", iAffiliate, Affiliates.rgAffiliates[iAffiliate].qwAffiliateID, Affiliates.rgAffiliates[iAffiliate].dwTitleID, (DWORD)Affiliates.rgAffiliates[iAffiliate].mtDateUpdated);
                    }
                }
                delete[] Affiliates.rgAffiliates;

                pCPresence->GetAffiliates(X_AFFILIATE_INDEX_TO_FLAG(X_AFFILIATE_AVOIDING_ME_INDEX), &Affiliates);
                XomWriteFormattedResponse(pResponseInterface, dwRequestId, "\r\n    Affiliates List (Avoiding Me, size = %d):\r\n", Affiliates.dwSize);
                if (fVerbose)
                {
                    for (iAffiliate = 0; iAffiliate < Affiliates.dwSize; iAffiliate++)
                    {
                        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "      %3d) AffiliatePUID = %I64X, TitleID = 0x%X, Time = %d\r\n", iAffiliate, Affiliates.rgAffiliates[iAffiliate].qwAffiliateID, Affiliates.rgAffiliates[iAffiliate].dwTitleID, (DWORD)Affiliates.rgAffiliates[iAffiliate].mtDateUpdated);
                    }
                }
                delete[] Affiliates.rgAffiliates;

                pCPresence->GetAffiliates(X_AFFILIATE_INDEX_TO_FLAG(X_AFFILIATE_FAVORITES_INDEX), &Affiliates);
                XomWriteFormattedResponse(pResponseInterface, dwRequestId, "\r\n    Affiliates List (Favorites, size = %d):\r\n", Affiliates.dwSize);
                if (fVerbose)
                {
                    for (iAffiliate = 0; iAffiliate < Affiliates.dwSize; iAffiliate++)
                    {
                        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "      %3d) AffiliatePUID = %I64X, TitleID = 0x%X, Time = %d\r\n", iAffiliate, Affiliates.rgAffiliates[iAffiliate].qwAffiliateID, Affiliates.rgAffiliates[iAffiliate].dwTitleID, (DWORD)Affiliates.rgAffiliates[iAffiliate].mtDateUpdated);
                    }
                }
                delete[] Affiliates.rgAffiliates;
                Affiliates.rgAffiliates = NULL;
            }
        }
    }

lDone:

    SAFE_RELEASE(pCPresence);

    return FALSE;
}

void CSwitchboard::AdminShowPresenceBucketMap(LPCSTR pszParams, DWORD dwRequestId, CXomControlResponseInterface * pResponseInterface)
{
    DWORD dwBucket = 0xFFFFFFFF;
    int iRet = sscanf(pszParams, "%d", &dwBucket);

    XomWriteFormattedResponse(
        pResponseInterface,
        dwRequestId,
        "Bucket\tCurrentServer\tNextServer\tUserCount\r\n\r\n");

    if ((iRet != 1) || (dwBucket >= g_CPresCfg.GetBucketCount()))
    {
        // show all buckets
        for (dwBucket = 0; dwBucket < g_CPresCfg.GetBucketCount(); dwBucket++)
        {
            XomWriteFormattedResponse(
                pResponseInterface,
                dwRequestId,
                "%8d\t%S\t%S\t%8d\r\n",
                dwBucket,
                (WCHAR *)(BSTR)g_CPresCfg.GetBucketCurrentServerName(dwBucket),
                (WCHAR *)(BSTR)g_CPresCfg.GetBucketNextServerName(dwBucket),
                g_CPresCfg.GetBucketUserCount(dwBucket));
        }
    }
    else
    {
        // show specified bucket
        XomWriteFormattedResponse(
            pResponseInterface,
            dwRequestId,
            "%8d\t%S\t%S\t%8d\r\n",
            dwBucket,
            (WCHAR *)(BSTR)g_CPresCfg.GetBucketCurrentServerName(dwBucket),
            (WCHAR *)(BSTR)g_CPresCfg.GetBucketNextServerName(dwBucket),
            g_CPresCfg.GetBucketUserCount(dwBucket));
    }
}

void CSwitchboard::AdminShowPresenceBucketUsers(LPCSTR pszParams, DWORD dwRequestId, CXomControlResponseInterface * pResponseInterface)
{
    DWORD dwBucket = 0xFFFFFFFF;
    DWORD cUsers = 3;
    int iRet = sscanf(pszParams, "%d", &dwBucket);

    if (iRet != 1)
    {
        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "usage: exec :presence showbucketusers <bucket>\r\n");
        return;
    }

    if (dwBucket >= g_CPresCfg.GetBucketCount())
    {
        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "bucket id must be less than %d.\r\n", g_CPresCfg.GetBucketCount());
        return;
    }

    if (cUsers > g_CPresCfg.GetBucketUserCount(dwBucket))
    {
        cUsers = g_CPresCfg.GetBucketUserCount(dwBucket);
    }

    if (cUsers == 0)
    {
        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "bucket %d is empty.\r\n", dwBucket);
        return;
    }

    XomWriteFormattedResponse(pResponseInterface, dwRequestId, "The following %d users reside in bucket %d:\r\n", cUsers, dwBucket);

    // walk all the user buckets
    for (DWORD dwHash = 0; dwHash < g_CPresenceUserIndex.GetNumBuckets(); dwHash++)
    {
        // walk the bucket chain
        CPresence *pCNextUser = g_CPresenceUserIndex.GetBucket(dwHash);
        while (pCNextUser != NULL)
        {
            CPresence *pCUser = pCNextUser;
            pCNextUser = g_CPresenceUserIndex.GetNext(pCUser);

            // does this user hash to the migrating bucket?
            if (g_CPresCfg.HashPUID(pCUser->GetUserID()) == dwBucket)
            {
                XomWriteFormattedResponse(pResponseInterface, dwRequestId, "\t%I64X\r\n", pCUser->GetUserID());
                cUsers--;
            }

            pCUser->Release();

            if (cUsers == 0)
            {
                SAFE_RELEASE(pCNextUser);
                return;
            }
        }
    }

}

void CSwitchboard::AdminAddrefUser(LPCSTR pszParams, DWORD dwRequestId, CXomControlResponseInterface * pResponseInterface)
{
    QWORD qwUserID;
    int iRet = sscanf(pszParams, "%I64d", &qwUserID);
    CPresence *pCPresence = NULL;

    if (iRet != 1)
    {
        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "usage: exec :presence addrefuser <user id (decimal)>\r\n");
        return;
    }

    g_CPresenceUserIndex.FindPresence(qwUserID, &pCPresence, TRUE);
    if (pCPresence == NULL)
    {
        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "User %I64X is not in memory.\r\n", qwUserID);
        return;
    }

    if (pCPresence->HasDebugReference())
    {
        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "User %I64X already has a debug reference.  An additional reference will not be added.\r\n", qwUserID);
        pCPresence->Release();
        return;
    }

    pCPresence->SetDebugReference(TRUE);
    XomWriteFormattedResponse(pResponseInterface, dwRequestId, "Added a debug reference for user %I64X.\r\n", qwUserID);

    // no release
}

void CSwitchboard::AdminReleaseUser(LPCSTR pszParams, DWORD dwRequestId, CXomControlResponseInterface * pResponseInterface)
{
    QWORD qwUserID;
    int iRet = sscanf(pszParams, "%I64d", &qwUserID);
    CPresence *pCPresence = NULL;

    if (iRet != 1)
    {
        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "usage: exec :presence releaseuser <user id (decimal)>\r\n");
        return;
    }

    g_CPresenceUserIndex.FindPresence(qwUserID, &pCPresence, TRUE);
    if (pCPresence == NULL)
    {
        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "User %I64X is not in memory.\r\n", qwUserID);
        return;
    }

    if (!pCPresence->HasDebugReference())
    {
        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "User %I64X does not have a debug reference.\r\n", qwUserID);
        pCPresence->Release();
        return;
    }

    pCPresence->SetDebugReference(FALSE);
    ULONG refCount = pCPresence->Release();
    XomWriteFormattedResponse(pResponseInterface, dwRequestId, "Removed debug reference for user %I64X.\r\n", qwUserID);

    XOMASSERT(refCount > 0);

    if (refCount > 0)
    {
        // this call is likely to cause migration.
        pCPresence->Release();
    }
}

void CSwitchboard::AdminClearMigratingUsers(LPCSTR pszParams, DWORD dwRequestId, CXomControlResponseInterface * pResponseInterface)
{
    DWORD dwKilled = 0;

    // walk all the user buckets
    for (DWORD dwBucket = 0; dwBucket < g_CPresenceUserIndex.GetNumBuckets(); dwBucket++)
    {
        // walk the bucket chain
        CPresence *pCNextUser = g_CPresenceUserIndex.GetBucket(dwBucket);
        while (pCNextUser != NULL)
        {
            CPresence *pCUser = pCNextUser;
            pCNextUser = g_CPresenceUserIndex.GetNext(pCUser);

            if (pCUser->IsMigrationPending())
            {
                // there should be no way this user has an online record.  it should just be a stubbed out empty base record awaiting a full migration message that never came.

                // no messing with refcounting, just kill the record outright.
                g_CPresenceUserIndex.RemovePresence(pCUser);

                // destructor is protected, so just pound the release function until it's gone.
                while (0 < pCUser->Release());

                pCUser = NULL;

                dwKilled++;
            }

            SAFE_RELEASE(pCUser);
        }
    }

    XomWriteFormattedResponse(pResponseInterface, dwRequestId, "Cleared %d records.\r\n", dwKilled);
}

BOOL CSwitchboard::AdminGetPresenceCacheState(LPCSTR pszParams, DWORD dwRequestId, CXomControlResponseInterface *pResponseInterface)
{
    QWORD qwUserID;
    int iRet = sscanf(pszParams, "%I64d", &qwUserID);
    CPresence *pCPresence = NULL;

    if (iRet != 1)
    {
        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "usage: exec :presence getcachestate <user id (decimal)>\r\n");
        goto lDone;
    }

    HRESULT hr = g_CPresenceUserIndex.FindPresence(qwUserID, &pCPresence);
    if (pCPresence != NULL)
    {
        if (pCPresence->HasOnlineRecord())
        {
            XomWriteFormattedResponse(pResponseInterface, dwRequestId, "User %I64X has base record and online record.\r\n", qwUserID);
        }
        else
        {
            XomWriteFormattedResponse(pResponseInterface, dwRequestId, "User %I64X has base record.\r\n", qwUserID);
        }
    }
    else
    {
        if (hr == XONLINE_E_PRESENCE_DEFER_REQUEST)
        {
            XomWriteFormattedResponse(pResponseInterface, dwRequestId, "User %I64X is awaiting migration -- try again in a few seconds.\r\n", qwUserID);
        }
        else if (hr == XONLINE_E_PRESENCE_USER_MIGRATED)
        {
            DWORD dwServer = g_CPresCfg.MapUserToPresSrv(qwUserID, TRUE);
            XomWriteFormattedResponse(pResponseInterface, dwRequestId, "User %I64X has been migrated to server %s.\r\n", qwUserID, CW2A(g_CPresCfg.GetPresServerName(dwServer)));
            goto lDone;
        }
        else
        {
            DWORD dwServer = g_CPresCfg.MapUserToPresSrv(qwUserID, FALSE);
            if (dwServer != g_CPresCfg.GetMyPresServerIndex())
            {
                XomWriteFormattedResponse(pResponseInterface, dwRequestId, "User %I64X is serviced by server %s.\r\n", qwUserID, CW2A(g_CPresCfg.GetPresServerName(dwServer)));
                goto lDone;
            }
            else
            {
                XomWriteFormattedResponse(pResponseInterface, dwRequestId, "User %I64X is not in memory.\r\n", qwUserID);
            }
        }
    }

lDone:

    SAFE_RELEASE(pCPresence);

    return FALSE;
}

class CAdminSetPresenceCacheStateContext : public CLoadOfflinePresenceCaller
{
public:

    virtual HRESULT ProcessUser(CPresence * pCPresence, void * pvData)
    {
        HRESULT hr = S_OK;

        if (pCPresence == NULL)
        {
            XomWriteFormattedResponse(pResponseInterface, dwRequestId, "Could not create base record for user.\r\n");
            hr = HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
            goto lDone;
        }

        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "Created base record for user %I64X.\r\n", pCPresence->GetUserID());

        if (dwState >= 2)
        {
            SGADDR sgaddr = {0};
            XNADDR xnaddr = {0};
            XNKID xkid = {0};
            XNKEY xnkey = {0};
            IN_ADDR ipaXbox = {0};

            hr = pCPresence->CreateOnlineRecord(&sgaddr, 0, 0, 0, 0, 0, xnaddr, xkid, xnkey, ipaXbox, 0, (BYTE*)"", 0);
            if(FAILED(hr))
            {
                XomWriteFormattedResponse(pResponseInterface, dwRequestId, "Could not create online record for user %I64X.  hr = 0x%X\r\n", pCPresence->GetUserID(), hr);
                goto lDone;
            }

            XomWriteFormattedResponse(pResponseInterface, dwRequestId, "Created online record for user %I64X.\r\n", pCPresence->GetUserID());
        }

    lDone:

        SetEvent(g_hControlCallbackEvent);
        return hr;
    }

    virtual HRESULT Finalize()
    {
        delete this;
        return S_OK;
    }

    DWORD dwState;
    DWORD dwRequestId;
    CXomControlResponseInterface *pResponseInterface;
};

BOOL CSwitchboard::AdminSetPresenceCacheState(LPCSTR pszParams, DWORD dwRequestId, CXomControlResponseInterface *pResponseInterface)
{
    BOOL fWait = FALSE;
    QWORD qwUserID;
    DWORD dwState = 0xFFFFFFFF;
    int iRet = sscanf(pszParams, "%I64d %d", &qwUserID, &dwState);
    if (iRet != 2)
    {
        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "usage: exec :presence setcachestate <user id (decimal)> <state>\r\nstate 0 = not in memory\r\nstate 1 = base record only\r\nstate 2 = base and online record\r\n");
        goto lDone;
    }

    DWORD dwAltServer = g_CPresCfg.MapUserToPresSrv(qwUserID, TRUE);
    DWORD dwServer = g_CPresCfg.MapUserToPresSrv(qwUserID, FALSE);
    if (dwServer != dwAltServer)
    {
        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "User %I64X hashes to a migrating bucket.  SetCacheState is not allowed during migration.\r\n", qwUserID);
        goto lDone;
    }

    if (dwServer != g_CPresCfg.GetMyPresServerIndex())
    {
        XomWriteFormattedResponse(pResponseInterface, dwRequestId, "User %I64X is serviced by server %s.\r\n", qwUserID, CW2A(g_CPresCfg.GetPresServerName(dwServer)));
        goto lDone;
    }

    CPresence *pCPresence = NULL;
    g_CPresenceUserIndex.FindPresence(qwUserID, &pCPresence);
    if (pCPresence == NULL)
    {
        if (dwState >= 1)
        {
            CAdminSetPresenceCacheStateContext *pCCtx = new CAdminSetPresenceCacheStateContext;
            pCCtx->dwRequestId = dwRequestId;
            pCCtx->pResponseInterface = pResponseInterface;
            pCCtx->dwState = dwState;
            pCCtx->dwPendingLoads++;

            CLoadOfflinePresenceContext *pLoadCtx = new CLoadOfflinePresenceContext(this, &m_CProfileStore);
            pLoadCtx->m_qwUserID = qwUserID;
            pLoadCtx->m_pCaller = pCCtx;

            m_CProfileStore.SendToSqlThread(pLoadCtx);
            fWait = TRUE;
        }
    }
    else
    {
        if (pCPresence->HasOnlineRecord())
        {
            if (dwState < 2)
            {
                if (pCPresence->IsOnline() || pCPresence->HasTransientMessages())
                {
                    XomWriteFormattedResponse(pResponseInterface, dwRequestId, "Could not delete online record for user %I64X.\r\n", qwUserID);
                }
                else
                {
                    pCPresence->SelfDestruct();
                    XomWriteFormattedResponse(pResponseInterface, dwRequestId, "Deleted online record for user %I64X.\r\n", qwUserID);
                }
            }
        }
        else
        {
            if (dwState >= 2)
            {
                SGADDR sgaddr = {0};
                XNADDR xnaddr = {0};
                XNKID xkid = {0};
                XNKEY xnkey = {0};
                IN_ADDR ipaXbox = {0};

                HRESULT hr = pCPresence->CreateOnlineRecord(&sgaddr, 0, 0, 0, 0, 0, xnaddr, xkid, xnkey, ipaXbox, 0, (BYTE*)"", 0);
                if(FAILED(hr))
                {
                    XomWriteFormattedResponse(pResponseInterface, dwRequestId, "Could not create online record for user %I64X.  hr = 0x%X\r\n", pCPresence->GetUserID(), hr);
                    goto lDone;
                }

                XomWriteFormattedResponse(pResponseInterface, dwRequestId, "Created online record for user %I64X.\r\n", qwUserID);
            }
        }

        if (dwState < 1)
        {
            if (pCPresence->HasOnlineRecord())
            {
                XomWriteFormattedResponse(pResponseInterface, dwRequestId, "Could not delete base record for user %I64X.\r\n", qwUserID);
            }
            else
            {
                g_CPresenceUserIndex.RemovePresence(pCPresence);

                LONG lRefCount = pCPresence->GetRefCount() - 1;
                SAFE_RELEASE(pCPresence);

                if (lRefCount > 0)
                {
                    XomWriteFormattedResponse(pResponseInterface, dwRequestId, "%d outstanding references remain for user %I64X.\r\n", lRefCount, qwUserID);
                }
                else
                {
                    XomWriteFormattedResponse(pResponseInterface, dwRequestId, "Deleted base record for user %I64X.\r\n", qwUserID);
                }
            }
        }
    }

    SAFE_RELEASE(pCPresence);

lDone:

    return fWait;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\nmcparser\StdAfx.h ===
#pragma once

#include <winsock2.h>
#include <windows.h>
#include <wininet.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>


#include <wsockntp.h>
#include "xalloc.h"
#include "Memory.h"
#include "NetStruct.h"
#include "NPPTypes.h"
#include <xonlinep.h>
#include "Protocol.h"
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\nmcparser\NPPTypes.h ===
//=============================================================================
//  Microsoft (R) Network Monitor (tm). 
//  Copyright (C) 1997-1999. All rights reserved.
//
//  MODULE: NPPTypes.h
//
//  The source of everything outsiders need to know about NPP
//=============================================================================

#ifndef __npptypes_h__
#define __npptypes_h__

// import 
#ifdef MIDL_PASS
import "unknwn.idl";
#else
#include <unknwn.h>
#endif



#ifndef LPBYTE
typedef BYTE *LPBYTE;
#endif

typedef const void * HBLOB;

#pragma pack(1)

//=============================================================================
// DWORD  General constants.
//=============================================================================

#define MAC_TYPE_UNKNOWN                             0     //... not supported
#define MAC_TYPE_ETHERNET                            1     //... ethernet and 802.3
#define MAC_TYPE_TOKENRING                           2     //... tokenring (802.5)
#define MAC_TYPE_FDDI                                3     //... fddi.
                                                     
#define MACHINE_NAME_LENGTH                         16 
#define USER_NAME_LENGTH                            32 
#define ADAPTER_COMMENT_LENGTH                      32 
                                                
#define CONNECTION_FLAGS_WANT_CONVERSATION_STATS    0x00000001


//=============================================================================
//  Handle to a network
//=============================================================================
typedef DWORD HNETWORK;

//=============================================================================
//  Transmit statistics structure.
//=============================================================================

// -----------
// Structure
// -----------
typedef struct _TRANSMITSTATS
{
    DWORD       TotalFramesSent;
    DWORD       TotalBytesSent;
    DWORD       TotalTransmitErrors;
} TRANSMITSTATS;
typedef TRANSMITSTATS *LPTRANSMITSTATS;
#define TRANSMITSTATS_SIZE sizeof(TRANSMITSTATS)


//=============================================================================
//  Statistics structure.
//=============================================================================

// -----------
// Structure
// -----------
typedef struct _STATISTICS
{
    __int64          TimeElapsed; // in millionths of a second

    //...Buffer statistics
    DWORD           TotalFramesCaptured;
    DWORD           TotalBytesCaptured;

    //...Filtered statistics
    DWORD           TotalFramesFiltered;
    DWORD           TotalBytesFiltered;
    DWORD           TotalMulticastsFiltered;
    DWORD           TotalBroadcastsFiltered;

    //...Overall statistics.
    DWORD           TotalFramesSeen;
    DWORD           TotalBytesSeen;
    DWORD           TotalMulticastsReceived;
    DWORD           TotalBroadcastsReceived;
    DWORD           TotalFramesDropped;
    DWORD           TotalFramesDroppedFromBuffer;
    
    //... Statistics kept by MAC driver.
    DWORD           MacFramesReceived;
    DWORD           MacCRCErrors;
    __int64         MacBytesReceivedEx;
    DWORD           MacFramesDropped_NoBuffers;
    DWORD           MacMulticastsReceived;
    DWORD           MacBroadcastsReceived;
    DWORD           MacFramesDropped_HwError;
} STATISTICS;

typedef STATISTICS *LPSTATISTICS;

#define STATISTICS_SIZE    sizeof(STATISTICS)

//=============================================================================
//  Address structures
//=============================================================================

// -----------
// Constants
// -----------
#define MAX_NAME_SIZE       32 
#define IP_ADDRESS_SIZE     4  
#define MAC_ADDRESS_SIZE    6  

// Q: What is the maximum address size that we could have to copy?
// A: IPX == DWORD + 6 bytes == 10
#define MAX_ADDRESS_SIZE    10 
                                    
#define ADDRESS_TYPE_ETHERNET       0 
#define ADDRESS_TYPE_IP             1 
#define ADDRESS_TYPE_IPX            2 
#define ADDRESS_TYPE_TOKENRING      3 
#define ADDRESS_TYPE_FDDI           4 

#define ADDRESS_TYPE_XNS            5 
#define ADDRESS_TYPE_ANY            6   // NOTE: Special ANY and ANY_GROUP are placeholders, meaning, ignore this type
#define ADDRESS_TYPE_ANY_GROUP      7   
#define ADDRESS_TYPE_FIND_HIGHEST   8   
#define ADDRESS_TYPE_VINES_IP       9   
#define ADDRESS_TYPE_LOCAL_ONLY     10   


#define ADDRESSTYPE_FLAGS_NORMALIZE     0x0001 
#define ADDRESSTYPE_FLAGS_BIT_REVERSE   0x0002 


// -----------
// Structure
// -----------
// Vines IP Address Structure
typedef struct _VINES_IP_ADDRESS
{
    DWORD   NetID;
    WORD    SubnetID;
} VINES_IP_ADDRESS;
typedef VINES_IP_ADDRESS *LPVINES_IP_ADDRESS;
#define VINES_IP_ADDRESS_SIZE sizeof(VINES_IP_ADDRESS)

// IPX Address Structure
typedef struct _IPX_ADDRESS
{
    BYTE    Subnet[4];
    BYTE    Address[6];
} IPX_ADDRESS;
typedef IPX_ADDRESS *LPIPX_ADDRESS;
#define IPX_ADDRESS_SIZE    sizeof(IPX_ADDRESS)

// XNS Address Structure
typedef IPX_ADDRESS XNS_ADDRESS;
typedef IPX_ADDRESS *LPXNS_ADDRESS;

// ETHERNET SOURCE ADDRESS
typedef struct _ETHERNET_SRC_ADDRESS
{
    BYTE    RoutingBit:     1;
    BYTE    LocalBit:       1;
    BYTE    Byte0:          6;
    BYTE    Reserved[5];
} ETHERNET_SRC_ADDRESS;
typedef ETHERNET_SRC_ADDRESS *LPETHERNET_SRC_ADDRESS;

// ETHERNET DESTINATION ADDRESS
typedef struct _ETHERNET_DST_ADDRESS
{
    BYTE    GroupBit:       1;
    BYTE    AdminBit:       1;
    BYTE    Byte0:          6;
    BYTE    Reserved[5];
} ETHERNET_DST_ADDRESS;
typedef ETHERNET_DST_ADDRESS *LPETHERNET_DST_ADDRESS;

// FDDI addresses
typedef ETHERNET_SRC_ADDRESS FDDI_SRC_ADDRESS;
typedef ETHERNET_DST_ADDRESS FDDI_DST_ADDRESS;

typedef FDDI_SRC_ADDRESS *LPFDDI_SRC_ADDRESS;
typedef FDDI_DST_ADDRESS *LPFDDI_DST_ADDRESS;

// TOKENRING Source Address
typedef struct _TOKENRING_SRC_ADDRESS
{
    BYTE    Byte0:          6;
    BYTE    LocalBit:       1;
    BYTE    RoutingBit:     1;
    BYTE    Byte1;
    BYTE    Byte2:          7;
    BYTE    Functional:     1;
    BYTE    Reserved[3];
} TOKENRING_SRC_ADDRESS;
typedef TOKENRING_SRC_ADDRESS *LPTOKENRING_SRC_ADDRESS;

// TOKENRING Destination Address
typedef struct _TOKENRING_DST_ADDRESS
{
    BYTE    Byte0:          6;
    BYTE    AdminBit:       1;
    BYTE    GroupBit:       1;
    BYTE    Reserved[5];
} TOKENRING_DST_ADDRESS;
typedef TOKENRING_DST_ADDRESS *LPTOKENRING_DST_ADDRESS;



// Address Structure
typedef struct _ADDRESS
{
    DWORD                       Type;

#ifdef MIDL_PASS
    [switch_is(Type)] union 
#else
    union
#endif
    {
#ifdef MIDL_PASS
    [default]
#endif
        // ADDRESS_TYPE_ETHERNET
        // ADDRESS_TYPE_TOKENRING
        // ADDRESS_TYPE_FDDI
        BYTE                    MACAddress[MAC_ADDRESS_SIZE];

#ifdef MIDL_PASS
    [case(1)]  // IP
#endif
        BYTE                    IPAddress[IP_ADDRESS_SIZE];

#ifdef MIDL_PASS
    [case(2)] // raw IPX
#endif
        BYTE                    IPXRawAddress[IPX_ADDRESS_SIZE];

#ifdef MIDL_PASS
    [case(3)] // real IPX
#endif
        IPX_ADDRESS             IPXAddress;

#ifdef MIDL_PASS
    [case(4)] // raw Vines IP
#endif
        BYTE                    VinesIPRawAddress[VINES_IP_ADDRESS_SIZE];

#ifdef MIDL_PASS
    [case(5)] // real Vines IP
#endif
        VINES_IP_ADDRESS        VinesIPAddress;

#ifdef MIDL_PASS
    [case(6)] // ethernet with bits defined
#endif
        ETHERNET_SRC_ADDRESS    EthernetSrcAddress;

#ifdef MIDL_PASS
    [case(7)] // ethernet with bits defined
#endif
        ETHERNET_DST_ADDRESS    EthernetDstAddress;

#ifdef MIDL_PASS
    [case(8)] // tokenring with bits defined
#endif
        TOKENRING_SRC_ADDRESS   TokenringSrcAddress;

#ifdef MIDL_PASS
    [case(9)] // tokenring with bits defined
#endif
        TOKENRING_DST_ADDRESS   TokenringDstAddress;

#ifdef MIDL_PASS
    [case(10)] // fddi with bits defined
#endif
        FDDI_SRC_ADDRESS        FddiSrcAddress;

#ifdef MIDL_PASS
    [case(11)] // fddi with bits defined
#endif
        FDDI_DST_ADDRESS        FddiDstAddress;

    };
    
    WORD                        Flags;
} ADDRESS;
typedef ADDRESS *LPADDRESS;
#define ADDRESS_SIZE   sizeof(ADDRESS)

//=============================================================================
//  Address Pair Structure
//=============================================================================

// -----------
// Constants
// -----------
#define ADDRESS_FLAGS_MATCH_DST         0x0001 //... Match dest. address.
#define ADDRESS_FLAGS_MATCH_SRC         0x0002 //... Match src. address.
#define ADDRESS_FLAGS_EXCLUDE           0x0004 //... Perform logical XOR vs logical OR.
#define ADDRESS_FLAGS_DST_GROUP_ADDR    0x0008 //... Match group bit only.

#define ADDRESS_FLAGS_MATCH_BOTH        0x0003 //... 0x0001 | 0x0002.

// -----------
// Structure
// -----------
typedef struct _ADDRESSPAIR
{
    WORD        AddressFlags;
    WORD        NalReserved;
    ADDRESS     DstAddress;
    ADDRESS     SrcAddress;
} ADDRESSPAIR;
typedef ADDRESSPAIR *LPADDRESSPAIR;
#define ADDRESSPAIR_SIZE  sizeof(ADDRESSPAIR)


//=============================================================================
//  Address table.
//=============================================================================

// -----------
// Constants
// -----------
#define MAX_ADDRESS_PAIRS   8

// -----------
// Structure
// -----------
typedef struct _ADDRESSTABLE
{
    DWORD           nAddressPairs;
    DWORD           nNonMacAddressPairs;
    ADDRESSPAIR     AddressPair[MAX_ADDRESS_PAIRS];
} ADDRESSTABLE;

typedef ADDRESSTABLE *LPADDRESSTABLE;

#define ADDRESSTABLE_SIZE sizeof(ADDRESSTABLE)

//=============================================================================
//  Network information.
//=============================================================================

// -----------
// Constants
// -----------
#define NETWORKINFO_FLAGS_PMODE_NOT_SUPPORTED           0x00000001 

#define NETWORKINFO_FLAGS_REMOTE_NAL                    0x00000004 
#define NETWORKINFO_FLAGS_REMOTE_NAL_CONNECTED          0x00000008 
#define NETWORKINFO_FLAGS_REMOTE_CARD                   0x00000010 
#define NETWORKINFO_FLAGS_RAS                           0x00000020 

// -----------
// Structure
// -----------
typedef struct _NETWORKINFO
{
    BYTE            PermanentAddr[6];       //... Permanent MAC address
    BYTE            CurrentAddr[6];         //... Current  MAC address
    ADDRESS         OtherAddress;           //... Other address supported (IP, IPX, etc...)
    DWORD           LinkSpeed;              //... Link speed in Mbits.
    DWORD           MacType;                //... Media type.
    DWORD           MaxFrameSize;           //... Max frame size allowed.
    DWORD           Flags;                  //... Informational flags.
    DWORD           TimestampScaleFactor;   //... 1 = 1/1 ms, 10 = 1/10 ms, 100 = 1/100 ms, etc.
    BYTE            NodeName[32];           //... Name of remote workstation.
    BOOL            PModeSupported;         //... Card claims to support P-Mode
    BYTE            Comment[ADAPTER_COMMENT_LENGTH]; // Adapter comment field.
} NETWORKINFO;
typedef NETWORKINFO *LPNETWORKINFO;
#define NETWORKINFO_SIZE    sizeof(NETWORKINFO)
#define MINIMUM_FRAME_SIZE   32


//=============================================================================
//  Pattern structure.
//=============================================================================

// -----------
// Constants
// -----------
#define MAX_PATTERN_LENGTH  16 

// When set this flag will cause those frames which do NOT have the specified pattern
// in the proper stop to be kept.
#define PATTERN_MATCH_FLAGS_NOT                 0x00000001

// This flag was used in previous versions of Network Monitor and its value is therefore 
// reserved for compatability reasons
#define PATTERN_MATCH_FLAGS_RESERVED_1          0x00000002

// When set this flag indicates that the user is not interested in a pattern match within 
// IP or IPX, but in the protocol that follows.  The driver will ensure that the protocol
// given in OffsetBasis is there and then that the port in the fram matches the port given.
// It will then calculate the offset from the beginning of the protocol that follows IP or IPX.
// NOTE: This flag is ignored if it is used with any OffsetBasis other than 
// OFFSET_BASIS_RELATIVE_TO_IPX or OFFSET_BASIS_RELATIVE_TO_IP
#define PATTERN_MATCH_FLAGS_PORT_SPECIFIED      0x00000008


// The offset given is relative to the beginning of the frame. The 
// PATTERN_MATCH_FLAGS_PORT_SPECIFIED flag is ignored.
#define OFFSET_BASIS_RELATIVE_TO_FRAME                0

// The offset given is relative to the beginning of the Effective Protocol.
// The Effective Protocol is defined as the protocol that follows
// the last protocol that determines Etype/SAP. In normal terms this means 
// that the Effective Protocol will be IP, IPX, XNS, or any of their ilk.
// The PATTERN_MATCH_FLAGS_PORT_SPECIFIED flag is ignored.
#define OFFSET_BASIS_RELATIVE_TO_EFFECTIVE_PROTOCOL   1

// The offset given is relative to the beginning of IPX. If IPX is not present
// then the frame does not match. If the PATTERN_MATCH_FLAGS_PORT_SPECIFIED
// flag is set then the offset is relative to the beginning of the protocol
// which follows IPX.
#define OFFSET_BASIS_RELATIVE_TO_IPX                  2

// The offset given is relative to the beginning of IP. If IP is not present
// then the frame does not match. If the PATTERN_MATCH_FLAGS_PORT_SPECIFIED
// flag is set then the offset is relative to the beginning of the protocol
// which follows IP.
#define OFFSET_BASIS_RELATIVE_TO_IP                   3

// -----------
// Structure
// -----------
typedef union
{
    BYTE IPPort;
    WORD ByteSwappedIPXPort;
} GENERIC_PORT;


typedef struct _PATTERNMATCH
{
    DWORD        Flags;
    BYTE         OffsetBasis;
    GENERIC_PORT Port;
    WORD         Offset;
    WORD         Length;
    BYTE         PatternToMatch[MAX_PATTERN_LENGTH];//... Pattern to match.
} PATTERNMATCH;
typedef PATTERNMATCH *LPPATTERNMATCH;
#define PATTERNMATCH_SIZE sizeof(PATTERNMATCH)

//=============================================================================
//  Expression structure.
//=============================================================================

// -----------
// Constants
// -----------
#define MAX_PATTERNS    4

// -----------
// Structures
// -----------
typedef struct _ANDEXP
{
    DWORD            nPatternMatches;
    PATTERNMATCH     PatternMatch[MAX_PATTERNS];
} ANDEXP;
typedef ANDEXP *LPANDEXP;
#define ANDEXP_SIZE     sizeof(ANDEXP)

typedef struct _EXPRESSION
{
    DWORD       nAndExps;
    ANDEXP      AndExp[MAX_PATTERNS];
} EXPRESSION;
typedef EXPRESSION *LPEXPRESSION;
#define EXPRESSION_SIZE    sizeof(EXPRESSION)

//
//  Trigger.
//

// -----------
// Constants
// -----------

#define TRIGGER_TYPE_PATTERN_MATCH                       1  
#define TRIGGER_TYPE_BUFFER_CONTENT                      2  
#define TRIGGER_TYPE_PATTERN_MATCH_THEN_BUFFER_CONTENT   3  
#define TRIGGER_TYPE_BUFFER_CONTENT_THEN_PATTERN_MATCH   4  

#define TRIGGER_FLAGS_FRAME_RELATIVE                   0x00000000  
#define TRIGGER_FLAGS_DATA_RELATIVE                    0x00000001  

#define TRIGGER_ACTION_NOTIFY                          0x00  
#define TRIGGER_ACTION_STOP                            0x02  
#define TRIGGER_ACTION_PAUSE                           0x03  

#define TRIGGER_BUFFER_FULL_25_PERCENT         0  
#define TRIGGER_BUFFER_FULL_50_PERCENT         1  
#define TRIGGER_BUFFER_FULL_75_PERCENT         2  
#define TRIGGER_BUFFER_FULL_100_PERCENT        3  

// -----------
// Structure
// -----------
// this is just needed in the driver
#ifndef MAX_PATH
#define MAX_PATH 260
#endif

typedef struct _TRIGGER
{
    BOOL            TriggerActive;          //... Whether trigger is running
    BYTE            TriggerType;            //... Opcode of trigger
    BYTE            TriggerAction;          //... Action to take when trigger occurs.
    DWORD           TriggerFlags;           //... Trigger flags.
    PATTERNMATCH    TriggerPatternMatch;    //... Trigger pattern match.
    DWORD           TriggerBufferSize;      //... Trigger buffer size.
    DWORD           TriggerReserved;        //... Set to all zeros - do not use
    char            TriggerCommandLine[MAX_PATH];
} TRIGGER;
typedef TRIGGER *LPTRIGGER;
#define TRIGGER_SIZE    sizeof(TRIGGER)

//
//  Capture filter.
//

// -----------
// Constants
// -----------
//  Capture filter flags. By default all frames are rejected and
//  NalSetCaptureFilter enables them based on the CAPTUREFILTER flags
//  defined below.

#define CAPTUREFILTER_FLAGS_INCLUDE_ALL_SAPS    0x0001      //... include saps.
#define CAPTUREFILTER_FLAGS_INCLUDE_ALL_ETYPES  0x0002      //... include etypes.
#define CAPTUREFILTER_FLAGS_TRIGGER             0x0004      //... process trigger.
#define CAPTUREFILTER_FLAGS_LOCAL_ONLY          0x0008      //... non-promiscuous.
#define CAPTUREFILTER_FLAGS_DISCARD_COMMENTS    0x0010      //... throw away our internal comment frames
#define CAPTUREFILTER_FLAGS_KEEP_RAW        0x0020      //... Keep SMT and Token Ring MAC frames

//.. The following causes both saps and etypes to be included.
#define CAPTUREFILTER_FLAGS_INCLUDE_ALL         0x0003      //... 0x0001 | 0x0002

#define BUFFER_FULL_25_PERCENT                  0 
#define BUFFER_FULL_50_PERCENT                  1 
#define BUFFER_FULL_75_PERCENT                  2 
#define BUFFER_FULL_100_PERCENT                 3 

// -----------
// Structure
// -----------
typedef struct _CAPTUREFILTER
{
                        DWORD           FilterFlags;            //... filter flags,
#ifdef MIDL_PASS
    [size_is(nSaps)]    LPBYTE          lpSapTable;             //... sap table.
    [size_is(nEtypes)]  LPWORD          lpEtypeTable;           //... etype table.
#else
                        LPBYTE          lpSapTable;             //... sap table.
                        LPWORD          lpEtypeTable;           //... etype table.
#endif
                        WORD            nSaps;                  //... sap table length.
                        WORD            nEtypes;                //... Etype table length.
                        LPADDRESSTABLE  AddressTable;           //... Address table.
                        EXPRESSION      FilterExpression;       //... Filter expression.
                        TRIGGER         Trigger;                //... Trigger structure.
                        DWORD           nFrameBytesToCopy;      //... Number of byte of each frame to copy.
                        DWORD           Reserved;
} CAPTUREFILTER;
typedef CAPTUREFILTER *LPCAPTUREFILTER;
#define CAPTUREFILTER_SIZE    sizeof(CAPTUREFILTER)

//=============================================================================
//  Frame type.
//=============================================================================

// -----------
// Structure
// -----------
typedef struct _FRAME
{
                            __int64  TimeStamp;      //... Relative time in 1/1,000,000th seconds.
                            DWORD     FrameLength;  //... MAC frame length.
                            DWORD     nBytesAvail;  //... Actual frame length copied.
#ifdef MIDL_PASS
    [size_is(nBytesAvail)]  BYTE      MacFrame[*];  //... Frame data.
#else
#pragma warning(disable:4200)
                            BYTE      MacFrame[0];  //... Frame data.
#pragma warning(default:4200)
#endif
} FRAME;
typedef FRAME *LPFRAME;
#ifndef MIDL_PASS
typedef FRAME UNALIGNED *ULPFRAME;
#endif
#define FRAME_SIZE sizeof(FRAME)

//=============================================================================
//  Frame descriptor type.
//=============================================================================

// -----------
// Constants
// -----------
#define LOW_PROTOCOL_IPX     OFFSET_BASIS_RELATIVE_TO_IPX  
#define LOW_PROTOCOL_IP      OFFSET_BASIS_RELATIVE_TO_IP   
#define LOW_PROTOCOL_UNKNOWN ((BYTE)-1)
                                                            
// -----------
// Structure
// -----------
typedef struct _FRAME_DESCRIPTOR
{
#ifdef MIDL_PASS
    [size_is(FrameLength)]  LPBYTE  FramePointer;       //... Pointer to frame data
#else
                            LPBYTE  FramePointer;       //... Pointer to frame data
#endif
                            __int64 TimeStamp;      //... Relative time in 1/1,000,000th seconds.
                            DWORD   FrameLength;    //... MAC frame length.
                            DWORD   nBytesAvail;    //... Actual frame length copied.
                            WORD    Etype;
                            BYTE    Sap;       
                            BYTE    LowProtocol;           //... Index of Protocol found
                            WORD    LowProtocolOffset;     //... Offset to protocol data
                            GENERIC_PORT HighPort;         //... Port of high protocol in low protocol
                            WORD    HighProtocolOffset;    //... Offset to protocol data
} FRAME_DESCRIPTOR;
typedef FRAME_DESCRIPTOR *LPFRAME_DESCRIPTOR;
#define FRAME_DESCRIPTOR_SIZE sizeof(FRAME_DESCRIPTOR)



//=============================================================================
//  Frame descriptor table.
//=============================================================================
// -----------
// Structure
// -----------
typedef struct _FRAMETABLE
{
                        DWORD   FrameTableLength;
                        DWORD   StartIndex;
                        DWORD   EndIndex;
                        DWORD   FrameCount;
#ifdef MIDL_PASS
    [size_is(FrameTableLength)] FRAME_DESCRIPTOR    Frames[*];
#else
                        FRAME_DESCRIPTOR    Frames[1];
#endif
} FRAMETABLE;

typedef FRAMETABLE *LPFRAMETABLE;


//=============================================================================
//  Station statistics.
//=============================================================================

// -----------
// Constants
// -----------
#define STATIONSTATS_FLAGS_INITIALIZED  0x0001      //... Structure has been initialized.
#define STATIONSTATS_FLAGS_EVENTPOSTED  0x0002      //... Nal has posted an event for this entry.


#define STATIONSTATS_POOL_SIZE      100

// -----------
// Structure
// -----------
typedef struct _STATIONSTATS
{
    DWORD           NextStationStats;       //... Index of next Station
    DWORD           SessionPartnerList;     //... Index to the session table
    DWORD           Flags;
    BYTE            StationAddress[6];
    WORD            Pad;                    //... DWORD alignment.
    DWORD           TotalPacketsReceived;
    DWORD           TotalDirectedPacketsSent;
    DWORD           TotalBroadcastPacketsSent;
    DWORD           TotalMulticastPacketsSent;
    DWORD           TotalBytesReceived;
    DWORD           TotalBytesSent;
} STATIONSTATS;
typedef STATIONSTATS * LPSTATIONSTATS;
#define STATIONSTATS_SIZE sizeof(STATIONSTATS)

//=============================================================================
//  Session statistics.
//=============================================================================


// -----------
// Constants
// -----------
#define SESSION_FLAGS_INITIALIZED  0x0001           //... Structure has been initialized.
#define SESSION_FLAGS_EVENTPOSTED  0x0002           //... Nal has posted an event for this entry.


#define SESSION_POOL_SIZE           100

// -----------
// Structure
// -----------
typedef struct _SESSIONSTATS
{
    DWORD           NextSession;            // Index of next session
    DWORD           StationOwner;           // Index of one station
    DWORD           StationPartner;         // Index of the other station
    DWORD           Flags;
    DWORD           TotalPacketsSent;
} SESSIONSTATS;
typedef SESSIONSTATS * LPSESSIONSTATS;
#define SESSIONSTATS_SIZE  sizeof(SESSIONSTATS)


//=============================================================================
//  Station Query
//=============================================================================

// -----------
// Constants
// -----------
#define STATIONQUERY_FLAGS_LOADED       0x0001      //... Driver is loaded but the kernel is not.
#define STATIONQUERY_FLAGS_RUNNING      0x0002      //... Driver is loaded but not capturing.
#define STATIONQUERY_FLAGS_CAPTURING    0x0004      //... Driver is actively capturing.
#define STATIONQUERY_FLAGS_TRANSMITTING 0x0008      //... Driver is actively transmitting.

// -----------
// Structure
// -----------
#define STATIONQUERY_VERSION_MINOR      0x01
#define STATIONQUERY_VERSION_MAJOR      0x02

typedef struct _OLDSTATIONQUERY
{
    DWORD           Flags;                              //... Current state of Network Monitor.
    BYTE            BCDVerMinor;                        //... Binary coded decimal (minor).
    BYTE            BCDVerMajor;                        //... Binary coded decimal (major).
    DWORD           LicenseNumber;                      //... Software license number.
    BYTE            MachineName[MACHINE_NAME_LENGTH];   //... Machine name, if any.
    BYTE            UserName[USER_NAME_LENGTH];         //... Username name, if any.
    BYTE            Reserved[32];                       //... Reserved.
    BYTE            AdapterAddress[6];                  //... NIC address.
} OLDSTATIONQUERY;
typedef OLDSTATIONQUERY *LPOLDSTATIONQUERY;
#define OLDSTATIONQUERY_SIZE sizeof(OLDSTATIONQUERY)

typedef struct _STATIONQUERY
{
    DWORD           Flags;                              //... Current state of Network Monitor.
    BYTE            BCDVerMinor;                        //... Binary coded decimal (minor).
    BYTE            BCDVerMajor;                        //... Binary coded decimal (major).
    DWORD           LicenseNumber;                      //... Software license number.
    BYTE            MachineName[MACHINE_NAME_LENGTH];   //... Machine name, if any.
    BYTE            UserName[USER_NAME_LENGTH];         //... Username name, if any.
    BYTE            Reserved[32];                       //... Reserved.
    BYTE            AdapterAddress[6];                  //... NIC address.
    WCHAR           WMachineName[MACHINE_NAME_LENGTH];  //... Wide Machine name, if any.
    WCHAR           WUserName[USER_NAME_LENGTH];        //... Wide Username name, if any.
} STATIONQUERY;
typedef STATIONQUERY *LPSTATIONQUERY;
#define STATIONQUERY_SIZE sizeof(STATIONQUERY)

//=============================================================================
//  QUERYTABLE structure.
//=============================================================================

// -----------
// Structure
// -----------
typedef struct _QUERYTABLE
{
                                DWORD           nStationQueries;
#ifdef MIDL_PASS
    [size_is(nStationQueries)]  STATIONQUERY    StationQuery[*];
#else
                                STATIONQUERY    StationQuery[1];
#endif
} QUERYTABLE;
typedef QUERYTABLE *LPQUERYTABLE;
#define QUERYTABLE_SIZE sizeof(QUERYTABLE)


//=============================================================================
//  The LINK structure is used to chain structures together into a list.
//=============================================================================

#ifndef _LINK_
#define _LINK_

typedef struct _LINK *LPLINK;

typedef struct _LINK
{
    LPLINK     PrevLink;                    //... Previous or back pointer.
    LPLINK     NextLink;                    //... Next or forward pointer.
} LINK;

#endif //_LINK_

//=============================================================================
//  Packet data structure.
//=============================================================================

// -----------
// Structure
// -----------
typedef struct _PACKET
{
    LPBYTE      Frame;                      //... Pointer to entire MAC frame.
    LPVOID      FrameMdl;                   //... Driver-level frame pointer.
    WORD        FrameSize;                  //... Length of frame.
    WORD        ReferenceCount;             //... Number of frame references (lock count).
    DWORD       TimeStamp;                  //... Timestamp of frame.
} PACKET;
typedef struct _PACKET *LPPACKET;
#define PACKET_SIZE  sizeof(PACKET)


//=============================================================================
//  Packet queue data structure.
//=============================================================================

// -----------
// Constants
// -----------
#define PACKETQUEUE_STATE_VOID          0
#define PACKETQUEUE_STATE_PENDING       1
#define PACKETQUEUE_STATE_COMPLETE      2
#define PACKETQUEUE_STATE_CANCEL        3

// -----------
// Structure
// -----------
typedef struct _PACKETQUEUE
{
    //=========================================================================
    //  The following members are set by the Driver and
    //  must be NOT used by applications.
    //=========================================================================

    LINK            QueueLinkage;               //... Queue linkage (used by  drivers).
    DWORD           State;                      //... Transmit complete flag (used by Network Monitor drivers).
    DWORD           Status;                     //... Final Network Monitor error code (used by Network Monitor drivers).
    LPVOID          TimerHandle;                //... Handle to timer or pending transmits (used by Network Monitor drivers).
    HANDLE          hNetwork;                   //... Network handle (set by NAL).
    LPVOID          InstData;                   //... OpenNetwork instance data.

    //=========================================================================
    //  The following members are set by applications, such as the Network 
    //  Monitor NMAPI.
    //=========================================================================

    DWORD           Size;                       //... The overall size in bytes.
    DWORD           FrameTimeDelta;             //... Time between frames (-1 means use frame timestamp).
    DWORD           QueueTimeDelta;             //... Time between queues.
    DWORD           IterationCount;             //... Number of times to repeat send sequence.
    TRANSMITSTATS   TransmitStats;              //... Transmit statistics structure.
//    NETWORKPROC     NetworkProc;                //... Network procedure, used by the kernel to hook transmit completions.

    //=========================================================================
    //  The actual list of packets to transmit.
    //=========================================================================

    DWORD           nPackets;                   //... Packet queue length (i.e. number of frames to send).
#ifdef MIDL_PASS
    [size_is(nPackets)]PACKET Packet[*];                  //... Packet queue.
#else
                       PACKET Packet[1];                  //... Packet queue.
#endif
} PACKETQUEUE;
typedef struct _PACKETQUEUE *LPPACKETQUEUE;

#define PACKETQUEUE_SIZE  sizeof(PACKETQUEUE)

//=============================================================================
//  Security Request packet
//=============================================================================

typedef struct _SECURITY_PERMISSION_CHECK
{
    UINT        Version;
    DWORD       RandomNumber;
    BYTE        MachineName[MACHINE_NAME_LENGTH];
    BYTE        UserName[USER_NAME_LENGTH];
    UINT        MacType;                            //... Mac type.
    BYTE        PermanentAdapterAddress[MAC_ADDRESS_SIZE];
    BYTE        CurrentAdapterAddress[MAC_ADDRESS_SIZE];
    WCHAR       WMachineName[MACHINE_NAME_LENGTH];
    WCHAR       WUserName[USER_NAME_LENGTH];
} SECURITY_PERMISSION_CHECK;

typedef SECURITY_PERMISSION_CHECK * LPSECURITY_PERMISSION_CHECK;

#ifndef MIDL_PASS
typedef SECURITY_PERMISSION_CHECK UNALIGNED * ULPSECURITY_PERMISSION_CHECK;
#endif

#define SECURITY_PERMISSION_CHECK_SIZE     sizeof(SECURITY_PERMISSION_CHECK)


//=============================================================================
//  Security Response packet
//=============================================================================

#define MAX_SECURITY_BREACH_REASON_SIZE             100
#define MAX_SIGNATURE_LENGTH                        128
#define MAX_USER_NAME_LENGTH                        256

typedef struct _SECURITY_PERMISSION_RESPONSE
{
    UINT        Version;
    DWORD       RandomNumber;
    BYTE        MachineName[MACHINE_NAME_LENGTH];
    BYTE        Address[MAC_ADDRESS_SIZE];
    BYTE        UserName[MAX_USER_NAME_LENGTH];
    BYTE        Reason[MAX_SECURITY_BREACH_REASON_SIZE];
    DWORD       SignatureLength;
    BYTE        Signature[MAX_SIGNATURE_LENGTH];
} SECURITY_PERMISSION_RESPONSE;

typedef SECURITY_PERMISSION_RESPONSE * LPSECURITY_PERMISSION_RESPONSE;

#ifndef MIDL_PASS
typedef SECURITY_PERMISSION_RESPONSE UNALIGNED * ULPSECURITY_PERMISSION_RESPONSE;
#endif

#define SECURITY_PERMISSION_RESPONSE_SIZE     sizeof(SECURITY_PERMISSION_RESPONSE)


//
//  Callback type
//
//
// An UpdateEvent structure is part of an open context (defined below).
// As events occur, the update thread is released. While the thread
// is processing events, we want to be sure we don't lose any events.
// A queue of UpdateEvent structures is used for that purpose.
//

// -----------
// Constants
// -----------
// generic events
#define UPDATE_EVENT_TERMINATE_THREAD               0x00000000
#define UPDATE_EVENT_NETWORK_STATUS                 0x00000001

// rtc events
#define UPDATE_EVENT_RTC_INTERVAL_ELAPSED           0x00000002
#define UPDATE_EVENT_RTC_FRAME_TABLE_FULL           0x00000003
#define UPDATE_EVENT_RTC_BUFFER_FULL                0x00000004

// delayed events
#define UPDATE_EVENT_TRIGGER_BUFFER_CONTENT         0x00000005
#define UPDATE_EVENT_TRIGGER_PATTERN_MATCH          0x00000006
#define UPDATE_EVENT_TRIGGER_BUFFER_PATTERN         0x00000007
#define UPDATE_EVENT_TRIGGER_PATTERN_BUFFER         0x00000008

// transmit events
#define UPDATE_EVENT_TRANSMIT_STATUS                0x00000009

// Security events
#define UPDATE_EVENT_SECURITY_BREACH                0x0000000A

// Remote failure event
#define UPDATE_EVENT_REMOTE_FAILURE                 0x0000000B

// actions
#define UPDATE_ACTION_TERMINATE_THREAD              0x00000000
#define UPDATE_ACTION_NOTIFY                        0x00000001
#define UPDATE_ACTION_STOP_CAPTURE                  0x00000002
#define UPDATE_ACTION_PAUSE_CAPTURE                 0x00000003
#define UPDATE_ACTION_RTC_BUFFER_SWITCH             0x00000004
                                                        
// -----------
// Structures
// -----------
typedef struct _UPDATE_EVENT 
{
    USHORT          Event;          //... Actual event being recorded
    DWORD           Action;         //... What action was taken
    DWORD           Status;         //... Usually network status
    DWORD           Value;          //... Auxilary counter variable
    __int64         TimeStamp;      //... Mark the events( in millionths of a second)
#ifndef MIDL_PASS
    LPVOID          lpUserContext;  //... User context given by App
#else
    DWORD           lpUserContext;
#endif
#ifndef MIDL_PASS
    LPVOID          lpReserved;     //... Driver/NAL use
#else
    DWORD           lpReserved;     //... Driver/NAL use
#endif
    UINT            FramesDropped;  //... RTF frames dropped in this buffer
#ifdef MIDL_PASS
    [switch_is(Event)] union 
#else
    union
#endif
    {
#ifdef MIDL_PASS
    [default]
#endif
        DWORD           Reserved;       //... No data comes back with this switch option.
#ifndef CALLBACK_PASS
#ifdef MIDL_PASS
    [case(2,3,4)] 
#endif
        LPFRAMETABLE    lpFrameTable;   //... RTF only
#ifdef MIDL_PASS
    [case(9)] 
#endif
        DWORD   lpPacketQueue;  //... For transmits
#endif // CALLBACK_PASS
#ifdef MIDL_PASS
    [case(10)]
#endif
        SECURITY_PERMISSION_RESPONSE SecurityResponse;// remote security monitor response
    };

    // this is only filled in on non-security related stops (ie. triggers)
    LPSTATISTICS lpFinalStats;

} UPDATE_EVENT;
typedef UPDATE_EVENT *PUPDATE_EVENT;

// note for c++ users:
// the declaration for this callback should be in the public part of the header file:
// static WINAPI DWORD NetworkCallback( UPDATE_EVENT events);
// and the implementation should be, in the protected section of the cpp file:
// DWORD WINAPI ClassName::NetworkCallback( UPDATE_EVENT events) {};
//typedef DWORD (WINAPI *LPNETWORKCALLBACKPROC)( UPDATE_EVENT);
#ifndef MIDL_PASS
typedef DWORD (WINAPI *LPNETWORKCALLBACKPROC)( UPDATE_EVENT);
#endif
 

//=============================================================================
//  NETWORKSTATUS data structure.
//=============================================================================

typedef struct _NETWORKSTATUS
{
    DWORD       State;                                      //... Current state.
    DWORD       Flags;                                      //... Current flags.
//    DWORD       BufferSize;                                 //... Capture buffer size.
} NETWORKSTATUS;

typedef NETWORKSTATUS *LPNETWORKSTATUS;

#define NETWORKSTATUS_SIZE   sizeof(NETWORKSTATUS)

#define NETWORKSTATUS_STATE_VOID                0           //... Nothing state.
#define NETWORKSTATUS_STATE_INIT                1           //... Initial state.
#define NETWORKSTATUS_STATE_CAPTURING           2           //... Capturing state.
#define NETWORKSTATUS_STATE_PAUSED              3           //... Paused state.

#define NETWORKSTATUS_FLAGS_TRIGGER_PENDING     0x0001      //... Trigger pending.

//
//  BONEPACKET structure.
//=============================================================================

typedef struct _BONEPACKET
{
    DWORD       Signature;                  //... 'RTSS'
    BYTE        Command;                    //... packet command field.
    BYTE        Flags;                      //... flags.
    DWORD       Reserved;                   //... reserved.
    WORD        Length;                     //... length of data, if any.
} BONEPACKET;
typedef BONEPACKET *LPBONEPACKET;
#define BONEPACKET_SIZE     sizeof(BONEPACKET)

//=============================================================================
//  BONE alert packet.
//=============================================================================

typedef struct _ALERT
{
    DWORD           AlertCode;                          //... Alert code.
    WCHAR           WMachineName[MACHINE_NAME_LENGTH];   //... Machine name, if any.
    WCHAR           WUserName[USER_NAME_LENGTH];         //... Username name, if any.

    union
    {
        BYTE            Pad[32];                        //... Alert code-specific data.
        DWORD           nFramesToSend;                  //... Transmit alert data.
    };
} ALERT;

typedef ALERT *LPALERT;

#define ALERT_SIZE sizeof(ALERT)

//... Alert codes.

#define ALERT_CODE_BEGIN_TRANSMIT           0

//
//  BONEPACKET signature.
//

#define MAKE_WORD(l, h)         (((WORD) (l)) | (((WORD) (h)) << 8))
#define MAKE_LONG(l, h)         (((DWORD) (l)) | (((DWORD) (h)) << 16L))
#define MAKE_SIG(a, b, c, d)    MAKE_LONG(MAKE_WORD(a, b), MAKE_WORD(c, d))
#define BONE_PACKET_SIGNATURE   MAKE_SIG('R', 'T', 'S', 'S')

//
//  BONEPACKET commands.
//

#define BONE_COMMAND_STATION_QUERY_REQUEST      0
#define BONE_COMMAND_STATION_QUERY_RESPONSE     1
#define BONE_COMMAND_ALERT                      2
#define BONE_COMMAND_PERMISSION_CHECK           3
#define BONE_COMMAND_PERMISSION_RESPONSE        4
#define BONE_COMMAND_SECURITY_MONITOR_EVENT     5


//
//  STATISTICS parameter structure return from OpenNetwork().
//
#define MAX_SESSIONS    100
#define MAX_STATIONS    100

typedef struct _STATISTICSPARAM
{
    DWORD           StatisticsSize;             //... Number of bytes.
    STATISTICS      Statistics;
    DWORD           StatisticsTableEntries;     //... Number of entries.
    STATIONSTATS    StatisticsTable[MAX_STATIONS];
    DWORD           SessionTableEntries;        //... Number of entries.
    SESSIONSTATS    SessionTable[MAX_SESSIONS];
} STATISTICSPARAM;
typedef STATISTICSPARAM *LPSTATISTICSPARAM;
#define STATISTICSPARAM_SIZE  sizeof(STATISTICSPARAM)

//=============================================================================
//  Capture file header.
//=============================================================================

#define CAPTUREFILE_VERSION_MAJOR   2
#define CAPTUREFILE_VERSION_MINOR   0

#define MakeVersion(Major, Minor)   ((DWORD) MAKEWORD(Minor, Major))

#define GetCurrentVersion()         MakeVersion(CAPTUREFILE_VERSION_MAJOR, CAPTUREFILE_VERSION_MINOR)

#define NETMON_1_0_CAPTUREFILE_SIGNATURE     MAKE_IDENTIFIER('R', 'T', 'S', 'S')
#define NETMON_2_0_CAPTUREFILE_SIGNATURE     MAKE_IDENTIFIER('G', 'M', 'B', 'U')

typedef struct _CAPTUREFILE_HEADER_VALUES
{
    DWORD      Signature;                //... Unique identifier: 'RTSS'.
    BYTE       BCDVerMinor;              //... Binary coded decimal (minor).
    BYTE       BCDVerMajor;              //... Binary coded decimal (major).
    WORD       MacType;                  //... Topology type.
    SYSTEMTIME TimeStamp;                //... time of capture.
    DWORD      FrameTableOffset;         //... Frame index table.
    DWORD      FrameTableLength;         //... Frame index table size.
    DWORD      UserDataOffset;           //... User data offset.
    DWORD      UserDataLength;           //... User data length.
    DWORD      CommentDataOffset;        //... Comment Data offset
    DWORD      CommentDataLength;        //... Length of comment data.
    DWORD      StatisticsOffset;         //....offset to STATISTICS STRUCTURE
    DWORD      StatisticsLength;         //....length of stats struct
    DWORD      NetworkInfoOffset;        //....offset to network info structure
    DWORD      NetworkInfoLength;        //....length of network info structure
    DWORD      ConversationStatsOffset;  //....offset of conv stats structure
    DWORD      ConversationStatsLength;  //....length of conv stats structure
} CAPTUREFILE_HEADER_VALUES;

typedef CAPTUREFILE_HEADER_VALUES  *LPCAPTUREFILE_HEADER_VALUES;

#define CAPTUREFILE_HEADER_VALUES_SIZE sizeof(CAPTUREFILE_HEADER_VALUES)


//=============================================================================
//  Capture file.
//=============================================================================


typedef struct _CAPTUREFILE_HEADER
{
    union
    {
        CAPTUREFILE_HEADER_VALUES  ActualHeader;
        BYTE  Buffer[CAPTUREFILE_HEADER_VALUES_SIZE];
    };

    BYTE                    Reserved[128 - CAPTUREFILE_HEADER_VALUES_SIZE];
} CAPTUREFILE_HEADER;

typedef CAPTUREFILE_HEADER         *LPCAPTUREFILE_HEADER;

#define CAPTUREFILE_HEADER_SIZE     sizeof(CAPTUREFILE_HEADER)


//=============================================================================
//  Stats Frame definitions.
//=============================================================================


//=============================================================================
//  Stats Frame definitions.
//=============================================================================
typedef struct _EFRAMEHDR
{
    BYTE    SrcAddress[6];
    BYTE    DstAddress[6];
    WORD    Length;
    BYTE    DSAP;
    BYTE    SSAP;
    BYTE    Control;
    BYTE    ProtocolID[3];
    WORD    EtherType;
} EFRAMEHDR;
 
typedef struct _TRFRAMEHDR
{
    BYTE    AC;
    BYTE    FC;
    BYTE    SrcAddress[6];
    BYTE    DstAddress[6];
    BYTE    DSAP;
    BYTE    SSAP;
    BYTE    Control;
    BYTE    ProtocolID[3];
    WORD    EtherType;
} TRFRAMEHDR;
 
#define DEFAULT_TR_AC       0x00
#define DEFAULT_TR_FC       0x40
#define DEFAULT_SAP         0xAA
#define DEFAULT_CONTROL     0x03
#define DEFAULT_ETHERTYPE   0x8419
 
typedef struct _FDDIFRAMEHDR
{
    BYTE    FC;
    BYTE    SrcAddress[6];
    BYTE    DstAddress[6];
    BYTE    DSAP;
    BYTE    SSAP;
    BYTE    Control;
    BYTE    ProtocolID[3];
    WORD    EtherType;
} FDDIFRAMEHDR;
#define DEFAULT_FDDI_FC      0x10
 
typedef struct _FDDISTATFRAME
{
    __int64     TimeStamp;          //... Relative time in milliseconds.
    DWORD       FrameLength;        //... MAC frame length.
    DWORD       nBytesAvail;        //... Actual frame length copied.
    FDDIFRAMEHDR  FrameHeader;
    BYTE        FrameID[4];         //... $MST
    DWORD       Flags;              //... Flags
    DWORD       FrameType;          //... Statistics is always 103 (0x67)
    WORD        StatsDataLen;       //... Length of Version DWORD + STATISTICS
    DWORD       StatsVersion;
    STATISTICS  Statistics;
} FDDISTATFRAME;
 
typedef FDDISTATFRAME *LPFDDISTATFRAME;
#ifndef MIDL_PASS
typedef FDDISTATFRAME UNALIGNED *ULPFDDISTATFRAME;
#endif
 
#define FDDISTATFRAME_SIZE  sizeof(FDDISTATFRAME)
 
typedef struct _TRSTATFRAME
{
    __int64     TimeStamp;          //... Relative time in milliseconds.
    DWORD       FrameLength;        //... MAC frame length.
    DWORD       nBytesAvail;        //... Actual frame length copied.
    TRFRAMEHDR  FrameHeader;
    BYTE        FrameID[4];         //... $MST
    DWORD       Flags;              //... Flags
    DWORD       FrameType;          //... Statistics is always 103 (0x67)
    WORD        StatsDataLen;       //... Length of Version DWORD + STATISTICS
    DWORD       StatsVersion;
    STATISTICS  Statistics;
} TRSTATFRAME;
 
typedef TRSTATFRAME *LPTRSTATFRAME;
#ifndef MIDL_PASS
typedef TRSTATFRAME UNALIGNED *ULPTRSTATFRAME;
#endif
 
#define TRSTATFRAME_SIZE  sizeof(TRSTATFRAME)
 
typedef struct _ESTATFRAME
{
    __int64     TimeStamp;          //... Relative time in milliseconds.
    DWORD       FrameLength;        //... MAC frame length.
    DWORD       nBytesAvail;        //... Actual frame length copied.
    EFRAMEHDR   FrameHeader;
    BYTE        FrameID[4];         //... $MST
    DWORD       Flags;              //... Flags
    DWORD       FrameType;          //... Statistics is always 103 (0x67)
    WORD        StatsDataLen;       //... Length of Version DWORD + STATISTICS
    DWORD       StatsVersion;
    STATISTICS  Statistics;
} ESTATFRAME;
 
 
#define STATISTICS_VERSION_1_0  0x00000000
#define STATISTICS_VERSION_2_0  0x00000020
 
typedef ESTATFRAME *LPESTATFRAME;
#ifndef MIDL_PASS
typedef ESTATFRAME UNALIGNED *ULPESTATFRAME;
#endif

#define ESTATFRAME_SIZE  sizeof(ESTATFRAME)
 
// this variable could change if any of the above sizes changed
#define MAX_STATSFRAME_SIZE sizeof(TRSTATFRAME)
 
#define STATS_FRAME_TYPE   103

#pragma pack()
#endif //__npptypes_h__
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\presencefunc\FuncAddBuddy.cs ===
using System;
using System.Collections;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.Notification;
using ServerTestFramework.LiveService.PresNotiCommon;
using xonline.common.diagnostics;
using xonline.common.protocol.SubNoti;
using ServerTestFramework.LiveService.UserAccount;

namespace PresenceTest
{
    /// <summary>
    /// Positive functional test cases for AddBuddy. Add buddy is also handled 
    /// by the FriendsCommon common code but these tests provide an isolated view
    /// of the server messages outside of a wrapper.
    /// </summary>
    [TestGroup, TestFrequency("Regression"), TestCasePriority(3), AsyncGroup(1, 0)]
    class FuncAddBuddy_PositiveCases : PresenceTestBaseGroup
    {
        
        public void AcceptFriend(PNUser u, PNUser buddy)
        {
            buddy.AcceptBuddy(u);
        }

        public void AddById(PNUser u, PNUser buddy, ulong buddyId)
        {
            AddById(u, buddy, buddyId, true);
        }

        public void AddById(PNUser u, PNUser buddy, ulong buddyId, bool expectMessage)
        {
            PMsgAddBuddy req = new PMsgAddBuddy(u, buddyId, null);
            req.TransactFD();

            u.PeerSubscribeEx(buddy); 

            HandleNotifications(u, buddy, expectMessage);
        }

        public void AddByName(PNUser u, PNUser buddy, string buddyName)
        {
            AddByName(u, buddy, buddyName, true);
        }

        public void AddByName(PNUser u, PNUser buddy, string buddyName, bool expectMessage)
        {

            PMsgAddBuddy req = new PMsgAddBuddy(u, 0, buddyName);
            req.TransactFD();

            u.PeerSubscribeEx(buddy);

            HandleNotifications(u, buddy, expectMessage);
        }

        void HandleNotifications(PNUser u, PNUser buddy, bool expectMessage)
        {
            QValPacket qval = null;

            //U should get list change here.
            qval = u.WaitForQFlags(XonPresNoti.QFLAG_MASK_LIST_CHANGE);
            u.HandleQValPacket(qval);


            // Wait for the buddy request notification
            qval = buddy.WaitForQFlags(XonPresNoti.QFLAG_MASK_BUDDY_REQ);
            buddy.HandleQValPacket(qval);

            uint msgId = 0;
            try
            {
                qval = buddy.WaitForNewMessageType(XonPresNoti.MSG_TYPE_FRIEND_REQUEST);
                if (expectMessage)
                {
                    // Make sure we get a message on the buddy end from the user
                    msgId = qval.NewMessageId(0);
                    UserMsgFolder folder = new UserMsgFolder(buddy);
                    folder.ValidateContainsMessage(msgId, UserMessage.CreateFriendsRequestMsg(u));
                }
                else
                {
                    Assert.IsTrue(false, "Adding buddy when throttled should not have sent a message.");
                }
            }
            catch (TimeOutException ex)
            {
                if (expectMessage)
                {
                    throw ex;
                }
            }

            AcceptFriend(u, buddy);

            // Wait for the buddy added notification
            qval = u.WaitForQFlags(XonPresNoti.QFLAG_MASK_LIST_CHANGE);
            u.HandleQValPacket(qval);
            
            // Make sure that the message was deleted
            qval = buddy.WaitForDeletedMessage();
            ValueCheck.Test("DeletedMessage == Friend Message Id", msgId, qval.DeletedMessageId(0));

            PNUser.MutualWaitForFullFriend(u, buddy);

            // Make sure we get the initial presence announce
            _fc.ProcessInitialAnnounce(u, buddy);

        }

        public void CheckFriends(PNUser u, PNUser[] buddies)
        {
            bool matched = false;
            foreach (PNUser buddy in buddies)
            {
                matched = false;
                IDictionaryEnumerator e = u.BuddyEnumerator;
                while (e.MoveNext())
                {
                    PNUser.BuddyInfo info = (PNUser.BuddyInfo)e.Value;

                    ValueCheck.Test("BuddyStatus: " + ((ulong)e.Key).ToString("x") + " (buddy.Name)",
                            XonPresNoti.P_BUDDY_STATUS_OK, info.Status);

                    if (info.Name == buddy.Name)
                    {
                        matched = true;
                        break;
                    }

                    if (!matched && (info.Name.ToLower() == buddy.Name.ToLower()))
                    {
                        throw new UnexpectedTestResultException("Buddy names case was messed up: " + info.Name + " != " + buddy.Name);
                    }
                }
                Assert.IsTrue(matched, "Buddy not found");
            }
        }

        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public void P_AddById_RealPassport()
        {
            XeUser userA = new XeUser(true);
            userA.Create();

            XeUser userB = new XeUser(true);
            userB.Create();
            FriendsCommon.WaitForXCache();

            PNUser xenona = new PNUser(userA.Gamertag, userA.UserPuid);
            PNUser xenonb = new PNUser(userB.Gamertag, userB.UserPuid);

            _fc.LogonUser(xenona);
            _fc.LogonUser(xenonb);

            AddById(xenona, xenonb, xenonb.UserId);

            CheckFriends(xenona, new PNUser[] { xenonb });
            CheckFriends(xenonb, new PNUser[] { xenona });
        }


        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public void P_AddById()
        {
            PNUser xenona = CreateCleanXenonUser(true);
            PNUser xenonb = CreateCleanXenonUser(true);
            
            AddById(xenona, xenonb, xenonb.UserId);

            CheckFriends(xenona, new PNUser[] { xenonb });
            CheckFriends(xenonb, new PNUser[] { xenona });
        }

        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public void P_AddByName()
        {
            PNUser xenona = CreateXenonUser(true);
            PNUser xenonb = CreateXenonUser(true);
            //validating message in handlenotification was failing due to the system message. 
            UserMsgFolder folder = new UserMsgFolder(xenona);
            folder.LoadEx();
            folder.DeleteAllMessages();
            folder = new UserMsgFolder(xenonb);
            folder.LoadEx();

            AddByName(xenona, xenonb, xenonb.Name);

            CheckFriends(xenona, new PNUser[] { xenonb });
            CheckFriends(xenonb, new PNUser[] { xenona });
        }

        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public void P_AddByName_Case_Problem()
        {
            PNUser xenona = CreateXenonUser(true);
            PNUser xenonb = CreateXenonUser(true);
            //validating message in handlenotification was failing due to the system message. 
            UserMsgFolder folder = new UserMsgFolder(xenona);
            folder.LoadEx();
            folder.DeleteAllMessages();
            folder = new UserMsgFolder(xenonb);
            folder.LoadEx();

            AddByName(xenona, xenonb, xenonb.Name.ToLower());

            CheckFriends(xenona, new PNUser[] { xenonb });
            CheckFriends(xenonb, new PNUser[] { xenona });
        }

        /// <summary>
        /// 
        /// </summary>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public void P_AddByNameOrIdOver100()
		{
            PNUser u = CreateXenonUser(true);
            PNUser oneover = CreateXenonUser(true);
            PNUser[] friends = CreateXenonUsers(FriendsCommon.MAXFRIENDS, false) ;

            foreach (PNUser f in friends)
            {
                _fc.MakeFriendFast(u.UserId, f.UserId);
            }

            _fc.LogoffUser(u);
            _fc.LogonUser(u);
            _fc.LogonUser(oneover);
            _fc.LogonUser(friends[4]);
            Assert.IsTrue(u.BuddiesOK == FriendsCommon.MAXFRIENDS);

            CheckFriends(u, friends);

            AddOverLimit(oneover, u);
            AddOverLimit(u, oneover);

            // Remove a friends and make sure we can add now
            u.DeleteBuddy(friends[4]);

            // Add in the one over
            AddById(u, oneover, oneover.UserId, true);

            // Make sure we're failing again
            AddOverLimit(u, friends[4]);
            AddOverLimit(friends[4], u);

            // Delete the oneover
            u.DeleteBuddy(oneover);

            // Add in the friend the oposite direction
            AddById(friends[4], u, u.UserId, true);
        }

        /// <summary>
        /// 
        /// </summary>
        [TestCase, EnvRequirement("Manual")]
        public void P_AddByNameOrId_When_Full()
        {
            PNUser u = CreateXenonUser(true);
            PNUser oneover = CreateXenonUser(true);
            //set friends limit.
            uint maxFriends_OldVal = uint.Parse(Global.XEnv.GetSetting(xonline.common.config.Setting.presence_MaxFriends));
            uint maxFriends = 10;
            SettingState oldState = _fc.SetMaxFriends(maxFriends);

            PNUser[] friends = new PNUser[maxFriends];

            try
            {
                ProgressInfo progress = new ProgressInfo("Creating buddies", (uint)maxFriends, 1);
                for (int i = 0; i < maxFriends; ++i)
                {
                    Global.RO.Info(i.ToString());
                    friends[i] = CreateXenonUser(true);
                    int tries = 0;
                    bool passed = false;
                    while (tries < 3 && !passed)
                    {
                        try
                        {
                            _fc.MakeFriend(u, friends[i]);
                        }
                        catch (TimeOutException)
                        {
                            tries++;
                            continue;
                        }
                        passed = true;
                    }
                    if (!passed)
                    {
                        progress.Finish();
                        throw new UnexpectedTestResultException("Couldn't make buddies with 3 tries");
                    }
                    progress.Step();
                }
                progress.Finish();

                CheckFriends(u, friends);

                AddOverLimit(oneover, u);
                AddOverLimit(u, oneover);

                // Remove a friends and make sure we can add now
                u.DeleteBuddy(friends[4]);

                // Add in the one over
                AddById(u, oneover, oneover.UserId, true);

                // Make sure we're failing again
                AddOverLimit(u, friends[4]);
                _fc.LogonUser(friends[4]);
                AddOverLimit(friends[4], u);

                // Delete the oneover
                u.DeleteBuddy(oneover);

                // Add in the friend the oposite direction
                AddById(friends[4], u, u.UserId, true);
            }
            catch (Exception exp)
            {
                Global.RO.Error(exp.Message);
            }
            finally
            {
                _fc.ResetMaxFriends(oldState);     
            }
        }

        void AddOverLimit(PNUser a, PNUser b)
        {
			uint hr;
			ListItem[] items;
			QValPacket qval = null;
            PMsgAddBuddy req = null;

            // Add full by ID	
            req = new PMsgAddBuddy(a, b.UserId, null);
            req.TransactFD();

			qval = a.WaitForQFlags(XonPresNoti.QFLAG_MASK_LIST_CHANGE);
            try
            {
                items = a.GetRawQVals(XonPresNoti.PQUEUE_LIST_CHANGE);
                Assert.IsTrue(false, "Add Buddy over MaxFriendLimit should have resulted in error.");
            }
            catch(HResultException hrex)
            {
                hr = hrex.HR;
                if(hr != HResult.XONLINE_E_NOTIFICATION_OTHER_LIST_FULL && hr != HResult.XONLINE_E_NOTIFICATION_LIST_FULL)
                {
                    throw new UnexpectedTestResultException("Unexpected notification item list result: " + hrex.Message);
                }
            }
            // Add full by name
            req = new PMsgAddBuddy(a, 0, b.Name);
            req.TransactFD();

			// Make sure we dequeue an invalid list item
			qval = a.WaitForQFlags(XonPresNoti.QFLAG_MASK_LIST_CHANGE);
            try
            {
                items = a.GetRawQVals(XonPresNoti.PQUEUE_LIST_CHANGE);
                Assert.IsTrue(false, "Add Buddy over MaxFriendLimit should have resulted in error.");
            }
            catch(HResultException hrex)
            {
                hr = hrex.HR;
                if(hr != HResult.XONLINE_E_NOTIFICATION_OTHER_LIST_FULL && hr != HResult.XONLINE_E_NOTIFICATION_LIST_FULL)
                {
                    throw new UnexpectedTestResultException("Unexpected notification item list result: " + hrex.Message);
                }
            }
        }

        void AddWhenNever(PNUser a, PNUser b)
        {
            uint hr;
            ListItem[] items;
            QValPacket qval = null;
            PMsgAddBuddy req = null;

            // Add full by ID	
            req = new PMsgAddBuddy(a, b.UserId, null);
            req.TransactFD();

            // Make sure we dequeue an invalid list item
            qval = a.WaitForQFlags(XonPresNoti.QFLAG_MASK_LIST_CHANGE);
            try
            {
                items = a.GetRawQVals(XonPresNoti.PQUEUE_LIST_CHANGE);
                Assert.IsTrue(false, "Add Buddy listing me as a never should have resulted in error.");
            }
            catch (HResultException hrex)
            {
                hr = hrex.HR;
                if (hr != HResult.XONLINE_E_NOTIFICATION_BLOCKED)
                {
                    throw new UnexpectedTestResultException("Unexpected notification item list result: " + hrex.Message);
                }
            }

            // Add full by name
            req = new PMsgAddBuddy(a, 0, b.Name);
            req.TransactFD();

            // Make sure we dequeue an invalid list item
            qval = a.WaitForQFlags(XonPresNoti.QFLAG_MASK_LIST_CHANGE);
            try
            {
                items = a.GetRawQVals(XonPresNoti.PQUEUE_LIST_CHANGE);
                Assert.IsTrue(false, "Add Buddy listing me as a never should have resulted in error.");
            }
            catch (HResultException hrex)
            {
                hr = hrex.HR;
                if (hr != HResult.XONLINE_E_NOTIFICATION_BLOCKED)
                {
                    throw new UnexpectedTestResultException("Unexpected notification item list result: " + hrex.Message);
                }
            }
        }


        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public void P_AddBuddy_Same_Console()
        {
            PNUser a = CreateXenonUser(true);
            PNUser b = CreateXenonUser(false);

            // Logon user b on same console as user a
            b.Xbox = a.Xbox;
            _fc.LogonUser(b);

            AddById(a, b, b.UserId);
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public void P_AddBuddy_From_Web()
        {
            PNUser a = CreateXenonUser(false);
            PNUser b = CreateXenonUser(true);

            _fc.LogonUser(a);
            _fc.LogoffUser(a);

            a.WebAlive();
            a.AddBuddy(b);

            b.WaitForBuddyStatusRequested(a);

            PWebFriendReplyMsgData wfd = a.GetWebFriends();
            foreach (WebFriend wf in wfd.rgFriends)
            {
                if (wf.BuddyID == b.UserId)
                {
                    ValueCheck.Test("buddy.TitleId", b.Xbox.TitleId, wf.TitleID);
                    ValueCheck.Test("buddy.Status", XonPresNoti.P_BUDDY_STATUS_PENDING, wf.Status);
                    ValueCheck.Test("buddy.OnlineState", b.State, wf.OnlineState);
                    return;
                }
            }

            throw new UnexpectedTestResultException("Buddy ID not found: " + b.UserId.ToString("x"));
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public void P_AddNeverBuddy()
        {
            PNUser a = CreateXenonUser(true);
            PNUser b = CreateXenonUser(true);
            // delete the system msg.
            UserMsgFolder folder = new UserMsgFolder(a);
            folder.LoadEx();
            folder.DeleteAllMessages();
            folder = new UserMsgFolder(b);
            folder.LoadEx();
            folder.DeleteAllMessages();

            a.AddBuddy(b);
            b.WaitForBuddyStatusRequested(a);

            // Go get the friend message ID
            folder = new UserMsgFolder(b);
            folder.LoadEx();
            UserMessage[] msgs = folder.FindBySender(XonPresNoti.MSG_TYPE_FRIEND_REQUEST, a.UserId);
            ValueCheck.Test("Friend requests from user: " + a.UserId, 1, msgs.Length);

            b.RejectBuddy(a, true);

            // Make sure we get the deleted message QVAL
            b.WaitForDeletedMessage(msgs[0].ID);
            b.WaitForBuddyStatusDeleted(a);
            a.WaitForBuddyStatusDeleted(b);

            // make another friend request
            AddWhenNever(a, b);

            // ensure that b doesn't receive it.
            folder = new UserMsgFolder(b);
            folder.LoadEx();
            msgs = folder.FindBySender(XonPresNoti.MSG_TYPE_FRIEND_REQUEST, a.UserId);
            ValueCheck.Test("Friend requests from user: " + a.UserId, 0, msgs.Length);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\nmcparser\Parser.cpp ===
// ---------------------------------------------------------------------------------------
// Originally ported from xnetcapx.cpp
//
// (XNet NetMon Capture File Analyzer)
// 
// Presence and queue server netmon parser
//
// Copyright (C) Microsoft Corporation
// ---------------------------------------------------------------------------------------

#include "StdAfx.h"

// ---------------------------------------------------------------------------------------
// Definitions
// ---------------------------------------------------------------------------------------

typedef __int64 INT64;
typedef unsigned __int64 UINT64;

char * SzCommaize(UINT n, BOOL fBlankIfZero = FALSE);

//
// Internal structures
//

struct CCapFile
{
    // Data ------------------------------------------------------------------------------

    UINT                        _iCapFile;
    char *                      _pszFile;
    HANDLE                      _hFile;
    HANDLE                      _hFileMap;
    BYTE *                      _pb;
    INT64                       _cb;
    CAPTUREFILE_HEADER_VALUES * _pHeader;
    DWORD *                     _pibFrame;
    DWORD                       _cibFrame;
};

//-------------------------------------------------------------------------------
// Endpoint for packet processing
struct CEndpoint
{

#define ENDPOINT_HASH_SZ  	13	
#define ENDPOINT_BUFFER_SZ 	2048

	struct CEndpoint	*_pNext;
	DWORD 				_dwAddr;
	WORD 				_wPort;
	BYTE 				_rgBuffer[ENDPOINT_BUFFER_SZ];
	DWORD 				_cbBuffer;
	CBaseMsgHeader 		*_pMsgHdr;

	CEndpoint(DWORD dwAddr, WORD wPort) { 
		_pNext = 0;
		_dwAddr = dwAddr;
		_wPort = wPort;
		_cbBuffer = 0;
		_pMsgHdr = 0;
	}
	void ParsePacket(BYTE *prgData, DWORD cbData);
};


// ---------------------------------------------------------------------------------------
// Globals
// ---------------------------------------------------------------------------------------

CCapFile        g_aCapFile[16];
UINT            g_cCapFile;
BOOL            g_fVerbose;
BOOL            g_fWarn;
BOOL            g_fDump;
BOOL            g_fDumpFrameInfo;
BOOL            g_fDumpHex;
BOOL            g_fLineMode;
const char *    g_apszDayOfWeek[] = { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" };
CEndpoint		*g_mEndpoint[ENDPOINT_HASH_SZ];

void CorruptFrame(DWORD iCapFile, DWORD iFrame, const char *pszMessage)
{
	if (g_fVerbose)
    {
        printf("CorruptFrame %d.%d: %s\n", iCapFile + 1, iFrame + 1, pszMessage);
    }
}


char * SzIndent(UINT cIndent)
{
    static char g_achIndent[] = "                                                                                                   ";
    return(&g_achIndent[dimensionof(g_achIndent) - cIndent + 1]);
}

// ---------------------------------------------------------------------------------------
// Utilities
// ---------------------------------------------------------------------------------------

char * SzErrMsg(DWORD dwError)
{
    static char s_achErrMsg[512];

    if (!FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwError, 0, s_achErrMsg, dimensionof(s_achErrMsg), NULL))
    {
        sprintf(s_achErrMsg, "ErrorCode %08lX", dwError);
    }

    char * pch = &s_achErrMsg[strlen(s_achErrMsg) - 1];

    while (pch >= s_achErrMsg && (*pch == '\n' || *pch == '\r'))
    {
        *pch-- = 0;
    }

    return(s_achErrMsg);
}

char * SzCommaize(UINT n, BOOL fBlankIfZero)
{
    static char s_achCommaize[8 * 16];
    static LONG s_lCommaize;
    char * pchBuf = &s_achCommaize[((s_lCommaize++) % 8) * 16];
    char * pch = pchBuf + 16 - 1;

    *pch = 0;

    if (fBlankIfZero && n == 0)
        return(pch);

    UINT iChar = 0;

    while (1)
    {
        *--pch = '0' + (n % 10);

        n /= 10;

        if (n == 0)
        {
            break;
        }

        if ((++iChar % 3) == 0)
        {
            *--pch = ',';
        }
    }

    return(pch);
}

void __cdecl fatal(DWORD dwError, const char * pszFmt, ...)
{
    va_list va;
    char ach[1024];

    va_start(va, pszFmt);
    _vsnprintf(ach, sizeof(ach), pszFmt, va);
    va_end(va);

    printf("\nxnetcapx: %s\n", ach);

    if (dwError)
    {
        printf("xnetcapx: %s\n", SzErrMsg(dwError));
    }

    exit(1);
}

void usage()
{
    printf("usage: XPQNMParser <options> file1.cap { file2.cap ... }\n");
    printf("[Options]\n");
    printf("   -v          - Verbose program diagnostics\n");
    printf("   -w          - Show warnings\n");
    printf("   -dump       - Dump packets as hex\n");
    printf("   -frameinfo  - Show frame info in output\n");
    printf("   -linemode   - Print packets on single lines\n");
    exit(0);
}

void * MemAlloc(UINT cb)
{
    void * pv = malloc(cb);//HalAlloc(cb, 0);

    if (pv == NULL)
    {
        fatal(0, "Out of memory allocating %d bytes", cb);
    }

    return(pv);
}

void * MemAllocZ(UINT cb)
{
    void * pv = calloc(cb, sizeof(BYTE));//HalAllocZ(cb, 0);

    if (pv == NULL)
    {
        fatal(0, "Out of memory allocating %d bytes", cb);
    }

    return(pv);
}

void MemFree(void * pv)
{
    if (pv)
    {
        free(pv);//HalFree(pv);
    }
}

char * StrDup(char * psz)
{
    char * pszDup = (char *)MemAlloc(strlen(psz) + 1);

    strcpy(pszDup, psz);

    return(pszDup);
}

void DumpHex(BYTE *prgData, DWORD cbData)
{
	DWORD dwBytes = 0;

	// Emit the hex data bytes in 16 byte chunks
	printf("0000 0000: ");
	while(dwBytes < cbData)
	{
		printf("%02X ", *prgData);
		if((dwBytes & 3) == 3)
		{
			printf(" ");
		}
		prgData++;
		dwBytes++;

		if((dwBytes-1 & 15) == 15)
		{
			printf("\n");
			printf("%04X %04X: ", dwBytes >> 16, dwBytes & 0xffff);
		}
	}

	if((dwBytes-1 & 15) != 15)
	{
		printf("\n");
	}
}


// Hash endpoints by folding addr and port together
CEndpoint *LookupEndpoint(DWORD dwAddr, WORD wPort)
{
	CEndpoint *pEndpoint;
	DWORD dwKey = dwAddr + wPort;
	DWORD dwIndex = dwKey % ENDPOINT_HASH_SZ;

	for(pEndpoint = g_mEndpoint[dwIndex]; pEndpoint; pEndpoint = pEndpoint->_pNext)
	{
		if((pEndpoint->_dwAddr == dwAddr) && (pEndpoint->_wPort == wPort))
		{
			break;
		}
	}

	if(!pEndpoint)
	{
		pEndpoint = new CEndpoint(dwAddr, wPort);
		pEndpoint->_pNext = g_mEndpoint[dwIndex];
		g_mEndpoint[dwIndex] = pEndpoint;
	}

	return pEndpoint;
}

// Buffer and parse presence packets
void CEndpoint::ParsePacket(BYTE *prgData, DWORD cbData)
{

	// damn it!
	if(_cbBuffer + cbData > ENDPOINT_BUFFER_SZ)
	{
		printf("!! parse packet: buffer overflow: %d > %d\n",
				_cbBuffer + cbData, ENDPOINT_BUFFER_SZ);
		return;
	}

	CopyMemory(_rgBuffer + _cbBuffer, prgData, cbData);
	_cbBuffer += cbData;

	// set the header pointer when we get an initial message header read
	if(!_pMsgHdr && _cbBuffer >= sizeof(CBaseMsgHeader))
	{
		_pMsgHdr = (CBaseMsgHeader*)_rgBuffer;
	}

    DUMP_MESSAGE_FORMAT eFormat = g_fLineMode ? DMF_SINGLE_LINE : DMF_MULTI_LINE;

	// check to see if we have a current msg header
	while(_pMsgHdr)
	{
		DWORD dwTotMsgLen = _pMsgHdr->dwMsgLen + sizeof(CBaseMsgHeader);

		// do we have enough data to parse this message
		if(_cbBuffer >= dwTotMsgLen)
		{
			if(!DumpMessage(_rgBuffer, dwTotMsgLen, eFormat) && g_fWarn)
            {
			    fprintf(stderr, "... Unknown packet type: %4X\n", _pMsgHdr->dwMsgType);
            }

			// update buffer and message header pointer
			MoveMemory(_rgBuffer, _rgBuffer + dwTotMsgLen, _cbBuffer - dwTotMsgLen);
			_cbBuffer -= dwTotMsgLen;
			_pMsgHdr = NULL;
			
			// see if we have enough buffer for another message header
			if(_cbBuffer >= sizeof(CBaseMsgHeader))
			{
				_pMsgHdr = (CBaseMsgHeader*)_rgBuffer;
			}
		}
		else
		{
			// go get some more buffer
			break;
		}
	}
}

// ---------------------------------------------------------------------------------------
// Process Capture File
// ---------------------------------------------------------------------------------------

void OpenCaptureFile(char * pszFile)
{
    if (g_cCapFile == dimensionof(g_aCapFile))
    {
        fatal(0, "Too many capture files.", g_cCapFile);
        return;
    }

    char achPath[MAX_PATH];

    if (GetFullPathNameA(pszFile, dimensionof(achPath), achPath, NULL))
    {
        pszFile = StrDup(achPath);
    }

	printf("Opening capture file: %s\n", pszFile);

    CCapFile * pCapFile = &g_aCapFile[g_cCapFile];

    pCapFile->_iCapFile = g_cCapFile;
    pCapFile->_pszFile = pszFile;

    pCapFile->_hFile = CreateFileA(pszFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);

    if (pCapFile->_hFile == INVALID_HANDLE_VALUE)
    {
        fatal(GetLastError(), "Cannot open '%s'", pszFile);
    }

    if (!GetFileSizeEx(pCapFile->_hFile, (LARGE_INTEGER *)&pCapFile->_cb))
    {
        fatal(GetLastError(), "Cannot get size of file '%s'", pszFile);
    }

    pCapFile->_hFileMap = CreateFileMappingA(pCapFile->_hFile, NULL, PAGE_READONLY, 0, 0, NULL);

    if (pCapFile->_hFileMap == NULL)
    {
        fatal(GetLastError(), "Cannot create file mapping of '%s'", pszFile);
    }

    pCapFile->_pb = (BYTE *)MapViewOfFile(pCapFile->_hFileMap, FILE_MAP_READ, 0, 0, 0);

    if (pCapFile->_pb == NULL)
    {
        fatal(GetLastError(), "Cannot map view of file '%s'", pszFile);
    }

    pCapFile->_pHeader  = (CAPTUREFILE_HEADER_VALUES *)pCapFile->_pb;
    pCapFile->_pibFrame = (DWORD *)(pCapFile->_pb + pCapFile->_pHeader->FrameTableOffset);
    pCapFile->_cibFrame = pCapFile->_pHeader->FrameTableLength / sizeof(DWORD);

    if (    pCapFile->_cb < sizeof(CAPTUREFILE_HEADER)
        ||  pCapFile->_pHeader->Signature != NETMON_2_0_CAPTUREFILE_SIGNATURE
        ||  pCapFile->_pHeader->FrameTableOffset > pCapFile->_cb
        ||  pCapFile->_pHeader->FrameTableLength > pCapFile->_cb
        ||  pCapFile->_pHeader->FrameTableLength > pCapFile->_cb - pCapFile->_pHeader->FrameTableOffset
        ||  pCapFile->_pHeader->FrameTableLength == 0
        || (pCapFile->_pHeader->FrameTableLength % sizeof(DWORD)) != 0)
    {
        fatal(0, "'%s' is not a netmon capture file", pszFile);
    }
    
	// Scan the capture file
	BYTE 		*pbData;
	DWORD		cbData;
	CEnetHdr 	*pEnetHdr;
	CIpHdr 		*pIpHdr;
	CTcpHdr 	*pTcpHdr;
	FRAME 		*pFrame;
	WORD 		wIpHdrLen;
	WORD		wIpLen;
	WORD		wTcpHdrLen;
	WORD		wDstPort;
	WORD		wSrcPort;

	DWORD 		iCapFile = pCapFile->_iCapFile;
	DWORD		iFrame = 0;
	DWORD 		*pibFrame = pCapFile->_pibFrame;
	DWORD 		cibFrame = pCapFile->_cibFrame;
	while(cibFrame--)
	{
		pFrame = (FRAME*)(pCapFile->_pb + *pibFrame);
		pbData = pFrame->MacFrame;
		cbData = pFrame->nBytesAvail;

		// move cursor to next frame
		pibFrame++;
		iFrame++;
		if((iFrame & 0xffff) == 0xffff)
			fprintf(stderr, "Decoded %d/%d frames...\n", iFrame, pCapFile->_cibFrame);

		if(pFrame->TimeStamp == 0)
		{
			continue;
		}

		// Grab ethernet header
		if(cbData < sizeof(CEnetHdr))
		{
	        CorruptFrame(iCapFile, iFrame, "Ethernet header truncated");
			continue;
		}

		pEnetHdr = (CEnetHdr*)pbData;
		if(pEnetHdr->_wType != ENET_TYPE_IP)
		{
			continue;
		}

		// fixed size enet header
    	pbData += sizeof(CEnetHdr);
    	cbData -= sizeof(CEnetHdr);

		// Grab IP header
		pIpHdr = (CIpHdr*)pbData;

		if((pIpHdr->_bVerHdr & 0xF0) != 0x40)
		{
			CorruptFrame(iCapFile, iFrame, "Invalid IP Header version");
			continue;
		}

		wIpHdrLen = (WORD)pIpHdr->GetHdrLen();
		wIpLen = (WORD)pIpHdr->GetLen();

		if(wIpHdrLen > cbData)
		{
			CorruptFrame(iCapFile, iFrame, "IP header size too big");
			continue;
		}

		if (wIpHdrLen > cbData)
		{
			CorruptFrame(iCapFile, iFrame, "IP header size too big");
			continue;
		}

		if (wIpLen < wIpHdrLen)
		{
			CorruptFrame(iCapFile, iFrame, "IP packet size too small");
			continue;
		}

		if (wIpLen > cbData)
		{
			CorruptFrame(iCapFile, iFrame, "IP packet size too big");
			continue;
		}


    	//if (tcpipxsum(0, pIpHdr, pIpHdr->GetHdrLen()) != 0xffff)
    	//{
        	//CorruptFrame(iCapFile, iFrame, "IP header checksum failed");
        	//continue;
    	//}

    	pbData += wIpHdrLen;
    	cbData = wIpLen - wIpHdrLen; // segment size(-enethdr) - size of ip hdr

		if(pIpHdr->_bProtocol == IPPROTOCOL_TCP)
		{

			// Grab TCP header 
			if(cbData < sizeof(CTcpHdr))
			{
				CorruptFrame(iCapFile, iFrame, "TCP header truncated");
				continue;
			}
			pTcpHdr = (CTcpHdr*)pbData;
			wTcpHdrLen = (WORD)pTcpHdr->_info.GetHdrLen();

			if (wTcpHdrLen < sizeof(CTcpHdr))
			{
				CorruptFrame(iCapFile, iFrame, "TCP header size too small");
				continue;
			}

			if (wTcpHdrLen > cbData)
			{
				CorruptFrame(iCapFile, iFrame, "TCP header size too big");
				continue;
			}

			pbData += wTcpHdrLen;
			cbData -= wTcpHdrLen;

            wSrcPort = pTcpHdr->_ipportSrc._w;
            wDstPort = pTcpHdr->_ipportDst._w;

			if(   wSrcPort == HTONS(3001) 
               || wSrcPort == HTONS(3000) 
               || wDstPort == HTONS(3001) 
               || wDstPort == HTONS(3000))
			{
                if(g_fDumpFrameInfo)
                {
                    printf("[%8.4f %8d.%-8d %s:%d -> %s:%d, cbData: %4d, dwSeqNum: %08X, dwAckNum: %08X ]\n", 
                            (float)((double)pFrame->TimeStamp / 1000000.0),
                            iCapFile,
                            iFrame,
                            pIpHdr->_ipaSrc.Str(),
                            NTOHS(pTcpHdr->_ipportSrc._w),
                            pIpHdr->_ipaDst.Str(), 
                            NTOHS(pTcpHdr->_ipportDst._w),
                            cbData,
                            pTcpHdr->_info._dwSeqNum,
                            pTcpHdr->_info._dwAckNum);
                }

                if(g_fDump)
                {
				    DumpHex(pbData, cbData);
                }
				
				CEndpoint *pEndpoint = LookupEndpoint(pIpHdr->_ipaSrc._dw, pTcpHdr->_ipportSrc._w);
				pEndpoint->ParsePacket(pbData, cbData);
			}
		}
	}

    g_cCapFile += 1;

    if (g_fVerbose)
    {
        printf("xnetcapx: Capture %d is '%s' and contains %d frames\n",
               pCapFile->_iCapFile + 1, pCapFile->_pszFile, pCapFile->_cibFrame);
    }
}


// ---------------------------------------------------------------------------------------
// Main entry point
// ---------------------------------------------------------------------------------------

int __cdecl main(int argc, char * argv[])
{
    printf("Presence/Notification protocol parser\n\n");

    char *  apszFiles[8];
    UINT    cpszFiles = 0;
    UINT    i, j, k;

    if (argc < 2 || argc > 8)
    {
        usage();
    }

    for (i = 1; i < (UINT)argc; ++i)
    {
        if (argv[i][0] == '-')
        {
            if (_stricmp(argv[i], "-v") == 0)
            {
                g_fVerbose = TRUE;
            }
            else if (_stricmp(argv[i], "-w") == 0)
            {
                g_fWarn = TRUE;
            }
            else if (_stricmp(argv[i], "-dump") == 0)
            {
                g_fDump = TRUE;
            }
            else if (_stricmp(argv[i], "-frameinfo") == 0)
            {
                g_fDumpFrameInfo = TRUE;
            }
            else if (_stricmp(argv[i], "-linemode") == 0)
            {
                g_fLineMode = TRUE;
            }
            else
            {
                usage();
            }
        }
        else
        {
            apszFiles[cpszFiles++] = argv[i];
        }
    }

    if (cpszFiles == 0)
    {
        usage();
    }

    for (i = 0; i < cpszFiles; ++i)
    {
        OpenCaptureFile(apszFiles[i]);
    }

    if (g_cCapFile == 0)
    {
        usage();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\presencefunc\FuncAlive.cs ===
using System;
using System.Collections;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Notification;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.FakeSG;
using xonline.common.diagnostics;
using xonline.common.config;
using xonline.common.community;
namespace PresenceTest
{
    /// <summary>
    /// Functional Tests for Alive2
    /// </summary>
    [TestGroup, TestFrequency("Regression"), TestCasePriority(3), AsyncGroup(1, 0), AsyncThreadCount(2)]
    public class FuncAlive_PostiveCases : PresenceTestBaseGroup
    {
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public void P_Alive_Once()
        {
            PNUser u = CreateXenonUser(false);

            // Connect the user to the xbox in the FakeSG
            u.Connect(u.Xbox);

            uint hr = u.Alive();
            if(HResult.Failed(hr))
            {
                throw new HResultException(hr, "Alive failed");
            }
        }

        class Notifier
        {
            public int Completed;
            public void Finished()
            {
                Interlocked.Increment(ref Completed);
            }
        }
        class SimpleAliveThread:ThreadBase
        {
            int _i;
            FriendsCommon _fc;
            PNUser _u;
            Notifier _n;

            public SimpleAliveThread(int i, FriendsCommon fc, PNUser u, Notifier n)
            {
                _i = i;
                _fc = fc;
                _u = u;
                _n = n;
            }
            protected override void ThreadBody()
            {
                try
                {
                    Global.RO.Debug("Thread[{0}]: 1st logon", _i);
                    _fc.LogonUser(_u);
                    _n.Finished();

                    Global.RO.Debug("Thread[{0}]: Sleep 5000ms", _i);
                    Thread.Sleep(5000);

                    Global.RO.Debug("Thread[{0}]: 2nd alive", _i);
                    uint hr = _u.Alive();
                    if(HResult.Failed(hr))
                    {
                        throw new HResultException(hr, "2nd alive failed");
                    }
                }
                catch(Exception ex)
                {
                    Global.RO.Error("Thread[{0}]: Failed, Reason: {1}",
                        _i, ex.ToString());
                }
            }
        }

        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public void P_Alive_Twice()
        {
            PNUser u = CreateXenonUser(true);

            uint hr = u.Alive();
            if(HResult.Failed(hr))
            {
                throw new HResultException(hr, "2nd alive failed");
            }
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public void P_Alive_DeadUser_Invite()
        {
            PNUser a = CreateXenonUser(true);
            PNUser b = CreateXenonUser(true);

            a.Disconnect();

            Thread.Sleep(5000);
            a.Invite(new PNUser[]{b}, 0xaaaabbbbccccdddd);
        }

        [TestCase, AsyncGroup(0)]
        public void P_Alive_100_Twice()
        {
            PNUser []users = new PNUser[100];

            for(int i = 0; i < 100; ++i)
            {
                users[i] = CreateXenonUser(false);
            }

            Notifier notifier = new Notifier();
            SimpleAliveThread[] threads = new SimpleAliveThread[100];
            for(int i = 0; i < 100; ++i)
            {
                threads[i] = new SimpleAliveThread(i, _fc, users[i], notifier);
                threads[i].Go();
            }

            for(int i = 0; i < 100; ++i)
            {
                threads[i].TaskThread.Join();
            }

            Global.RO.Debug("Logins completed: {0}", notifier.Completed);
        }

        /// <summary>
        /// This test needs to run on test environment. It will fail on xblob.
        /// </summary>
        [TestCase, EnvRequirement("Manual")]
        public void P_Alive_With_MAXFRIENDS_Offline_Friends()
        {
            PNUser u = CreateXenonUser(true);
            int numUsers = (int)FriendsCommon.MAXFRIENDS - 1;
            PNUser[] users = new PNUser[numUsers];

            for (int i = 0; i < numUsers; ++i)
            {
                Global.RO.Debug(i.ToString());
                users[i] = CreateXenonUser(true);
                _fc.MakeFriend(u, users[i]);
                _fc.LogoffUser(users[i]);
            }

            _fc.LogoffUser(u);
            _fc.LogonUser(u); 
        }

        /// <summary>
        /// 	Logon User that has offline friends
        /// </summary>
        /// <remarks>
        /// 	<Description>
        /// 	</Description>
        /// 	<Verify>
        /// 	</Verify>
        /// </remarks>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public void P_Alive_With_Offline_Friends()
        {
            // xenon title config for RP easily
            PNUser xenonUser = CreateXenonUser(true);
            PNUser xenonFriendA = CreateXenonUser(true);
            PNUser xenonFriendB = CreateXenonUser(true);


            _fc.MakeFriend(xenonUser, xenonFriendA);
            _fc.MakeFriend(xenonUser, xenonFriendB);

            // Clear any transient messages or qvals
            xenonFriendA.ProcessNotifications();
            xenonFriendB.ProcessNotifications();

            // Log off the friends
            _fc.LogoffUser(xenonFriendA);
            _fc.LogoffUser(xenonFriendB);


            // Re-Logon once normally (All friends are still in cache)
            _fc.LogoffUser(xenonUser);
            _fc.LogonUser(xenonUser);

            // Make sure we clear any pending transient messages or qvals
            xenonUser.ProcessNotifications();
			

            // Re-Logon with everyone in offline state
            _fc.LogoffUser(xenonUser);
            _fc.LogonUser(xenonUser);

            // Clear any transient garbage
            xenonUser.ProcessNotifications();

            // Re-Logon with friends in no memory state
            _fc.LogoffUser(xenonUser);
            _fc.LogonUser(xenonUser);

            // Clear any transient garbage
            xenonUser.ProcessNotifications();

            // Re-Logon with everyone in no memory state
            _fc.LogoffUser(xenonUser);
            _fc.LogonUser(xenonUser);
        }

        /// <summary>
        /// 	Logon User while spamming with friend removes (Bug Xenon#13484)
        /// </summary>
        /// <remarks>
        /// 	<Description>
        /// 	</Description>
        /// 	<Verify>
        /// 	</Verify>
        /// </remarks>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public void P_Alive_Friend_Count_Race_With_Removes()
        {
            // Give indication of setup
            ProgressInfo progress = new ProgressInfo("Creating and aliving users", 101, 1);
            PNUser u = null;
            PNUser[] f = null;

            try
            {
                // Create the main user
                u = CreateXenonUser(true);
                progress.Step();

                // Create max friends
                f = new PNUser[100];
                for(int i = 0; i < 100; ++i)
                {
                    f[i] = CreateXenonUser(true);
                    progress.Step();
                }
            }
            finally
            {
                progress.Finish();
            }

            FriendProcThread friendProc = new FriendProcThread(u, f);
            AliveProcThread aliveProc = new AliveProcThread(_fc, u, friendProc);

            aliveProc.Go();	
            friendProc.Go();	

            while(!aliveProc.Finished)
            {
                Thread.Sleep(1000);
            }

            if(aliveProc.LastException != null)
            {
                throw aliveProc.LastException;
            }
            if(friendProc.LastException != null)
            {
                throw friendProc.LastException;
            }
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public void P_Alive_With_Marketing_Flags()
        {
            //Create offline user.
            Global.RO.Info("Create offline, set marketing flags.");
            PNUser u = CreateXenonUser(false);
            u.SubscribeToMSMarketing();
            u.SubscribeToPartnerMarketing();

            // Connect the user to the xbox in the FakeSG
            u.Connect(u.Xbox);

            uint hr = u.Alive();
            if (HResult.Failed(hr))
            {
                throw new HResultException(hr, "Alive failed");
            }

            Global.RO.Info("Create online, set marketing flags, logoff, logon.");
            u = CreateXenonUser(true);
            u.SubscribeToMSMarketing();
            u.SubscribeToPartnerMarketing();
            _fc.LogoffUser(u);

            // Connect the user to the xbox in the FakeSG
            u.Connect(u.Xbox);

            hr = u.Alive();
            if (HResult.Failed(hr))
            {
                throw new HResultException(hr, "Alive failed");
            }

            Global.RO.Info("Create online, logoff, set marketing flags, logon.");
            u = CreateXenonUser(true);
            _fc.LogoffUser(u);
            u.SubscribeToMSMarketing();
            u.SubscribeToPartnerMarketing();

            // Connect the user to the xbox in the FakeSG
            u.Connect(u.Xbox);

            hr = u.Alive();
            if (HResult.Failed(hr))
            {
                throw new HResultException(hr, "Alive failed");
            }

        }

        class AliveProcThread:ThreadBase
        {
            public bool Finished = false;
            public Exception LastException = null;

            FriendsCommon _fc;
            PNUser _u;
            FriendProcThread _fproc;
            ProgressInfo _progress;

            public AliveProcThread(FriendsCommon fc, PNUser u, FriendProcThread fproc)
            {
                _fc = fc;
                _u = u;
                _fproc = fproc;
            }

            void SetProgress(DateTime begtime, DateTime fartime)
            {
                double n = fartime.ToFileTime() - DateTime.Now.ToFileTime();
                double d = fartime.ToFileTime() - begtime.ToFileTime() + 1;

                double left =  100.0 * (1-n  / d);
                uint dwleft = (uint)left;

                // truncate dwleft to keep it from closing the progress handle
                if(dwleft >= 100) 
                {
                    dwleft = 99;
                }

                _progress.SetValue(dwleft);
            }

            protected override void ThreadBody()
            {
                try
                {
                    DateTime neartime, fartime, begtime;

                    int interval = 100;
                    int cycle = 0;

                    // run 10 up and down cycles
                    _progress = new ProgressInfo("Cycle transitions", 100, 1);

                    while(cycle++ < 3)
                    {
                        // Up cycle (accept friend requests)
                        _fproc.UpCycle();
                        fartime = DateTime.Now.AddSeconds(60);
                        begtime = DateTime.Now;
                        while(DateTime.Now < fartime)
                        {
                            if(!_u.LoggedOn)
                            {
                                _fc.LogonUser(_u);
                            }

                            // Process QVALs and accept invites for a slice of time
                            _progress.SetMessage("Processing qvals: up cycle: " + cycle);
                            neartime = DateTime.Now.AddSeconds(5);
                            while(DateTime.Now < neartime)
                            {
                                _u.ProcessNotifications();
                                IDictionaryEnumerator enumerator = _u.BuddyEnumerator;
                                while(DateTime.Now < neartime && enumerator.MoveNext())
                                {
                                    PNUser.BuddyInfo bi = enumerator.Value as PNUser.BuddyInfo;
                                    if(bi.Status == XonPresNoti.P_BUDDY_STATUS_REQUEST)
                                    {
                                        // Accet the buddy and change their status to keep from
                                        // accepting them multiple times
                                        _u.AcceptBuddy(bi.User);
                                        bi.Status = XonPresNoti.P_BUDDY_STATUS_ACCEPTED;
                                    }
                                }
                                SetProgress(begtime, fartime);
                            }

                            _fc.LogoffUser(_u);

                            // Log off and let some stuff queue up
                            _progress.SetMessage("Sleeping: up cycle: " + cycle);
                            neartime = DateTime.Now.AddSeconds(5);
                            while(DateTime.Now < neartime)
                            {
                                Thread.Sleep(interval);
                                SetProgress(begtime, fartime);
                            }

                        }

                        // Down cycle (deletes from other thread, logon/logoff)
                        _fproc.DownCycle();
                        fartime = DateTime.Now.AddSeconds(60);
                        begtime = DateTime.Now;
                        while(DateTime.Now < fartime)
                        {
                            if(!_u.LoggedOn)
                            {
                                _fc.LogonUser(_u);
                            }

                            _progress.SetMessage("Processing qvals: down cycle: " + cycle);
                            neartime= DateTime.Now.AddSeconds(5);
                            while(DateTime.Now < neartime)
                            {
                                _u.ProcessNotifications();
                                Thread.Sleep(interval);
                                SetProgress(begtime, fartime);
                            }

                            _progress.SetMessage("Sleeping: down cycle: " + cycle);
                            _fc.LogoffUser(_u);
                            neartime= DateTime.Now.AddSeconds(5);
                            while(DateTime.Now < neartime)
                            {
                                Thread.Sleep(interval);
                                SetProgress(begtime, fartime);
                            }
                        }
                    }

                    // Done.
                    _progress.Finish();
                }
                catch(Exception ex)
                {
                    LastException = ex;
                    Global.RO.Error("Alive proc failed: " + ex.ToString());
                }
                finally
                {
                    Finished = true;
                    _fproc.Finish();
                    Global.RO.Info("Alive multithreaded procedure finished");
                }
            }
        }
        class FriendProcThread:ThreadBase
        {	
            public Exception LastException = null;

            PNUser _u;
            PNUser[] _f;
            int direction;
			
            public FriendProcThread(PNUser u, PNUser []f)
            {
                _u = u;
                _f = f;
            }
            public void UpCycle()
            {
                direction = 1;
            }
            public void DownCycle()
            {
                direction = -1;
            }
            public void Finish()
            {
                direction = 2;
            }
            protected override void ThreadBody()
            {
                try
                {
                    int operations = 0;
                    while(true)
                    {
                        int interval = 100;

                        switch(direction)
                        {
                            case 1:
                                AddBuddies();
                                break;
                            case -1:
                                DeleteBuddies();
                                break;
                            case 2:
                                goto lbDone;
                            default:
                                // don't do anything until the main thread
                                // 'signals' this thread
                                break;
                        }

                        operations++;

                        Thread.Sleep(interval);

                        if(0 != operations && (0 == operations % 1000))
                        {
                            Global.RO.Info("FriendsThread: 1000 friends operations completed");
                        }
                    }
                }
                catch(Exception ex)
                {
                    LastException = ex;
                    Global.RO.Error("Friends procedure failed: " + ex.ToString());
                }
                lbDone:
                    Global.RO.Info("Friends multithreaded procedure finished");
            }
            private void AddBuddies()
            {
                foreach(PNUser f in _f)
                {
                    if(!f.IsBuddy(_u))
                    {
                        f.AddBuddy(_u);
                    }
                }
            }
            private void DeleteBuddies()
            {
                foreach(PNUser f in _f)
                {
                    if(f.IsBuddy(_u))
                    {
                        f.DeleteBuddy(_u);
                    }
                }
            }
        }

        /// <summary>
        /// 	Logon User that uses an XonWatch Name to check for event
        /// </summary>
        /// <remarks>
        /// 	<Description>
        /// 	</Description>
        /// 	<Verify>
        /// 	</Verify>
        /// </remarks>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public void XonWatchAccount()
        {
            PNUser xonUser = new PNUser( "1isMyNumber", 1 );
            try
            {
                _fc.LogonUser( xonUser );
                Assert.IsTrue(false, "Alive for account 1isMyNumber : 1 should have failed.");
            }
            catch( HResultException )
            {
                ConsoleX.WriteLine( "Alive Failed as Expected, Check PresInh event log for expected event." );
            }
        }

        /// <summary>
        /// 	Logon User and check for message enumeration needed success code
        /// </summary>
        /// <remarks>
        /// 	<Description>
        /// 	</Description>
        /// 	<Verify>
        /// 	</Verify>
        /// </remarks>		
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public void P_EnumNeeded()
        {
            PNUser sender    = CreateXenonUser( true );
            PNUser recipient = CreateXenonUser( true );

            _fc.LogoffUser( recipient );

            MsgDetails details = MsgDetails.CreateBlank();
            UserMessage msg = UserMessage.Create( sender, XonPresNoti.MSG_TYPE_LIVE_MESSAGE, 0, XonPresNoti.MSG_FLAG_RECOMMENDED, 60, details );
            msg.Send( sender, recipient );

            uint HR = _fc.LogonUser( recipient );

            ValueCheck.TestHR("Recommended message HR", HResult.XONLINE_S_LOGON_USER_HAS_MESSAGE, HR );
        }
		
        /// <summary>
        /// 	Logon User and check for has nomal success code
        /// </summary>
        /// <remarks>
        /// 	<Description>
        /// 	</Description>
        /// 	<Verify>
        /// 	</Verify>
        /// </remarks>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public void P_NoEnumNeeded_Expired()
        {
            PNUser sender    = CreateXenonUser( true );
            PNUser recipient = CreateXenonUser( false );

            MsgDetails details = MsgDetails.CreateBlank();
            UserMessage msg = UserMessage.Create( sender, XonPresNoti.MSG_TYPE_LIVE_MESSAGE, 0, 0, 1, details );
            msg.Send( sender, recipient );

            Console.WriteLine( "Wait for message to expire" );
            Thread.Sleep( new TimeSpan( 0, 2, 0 ) );

            _fc.LogonUser( recipient );
        }

        /// <summary>
        /// 	Logon User and check for has recomended message success code
        /// </summary>
        /// <remarks>
        /// 	<Description>
        /// 	</Description>
        /// 	<Verify>
        /// 	</Verify>
        /// </remarks>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public void P_HasRecomended()
        {
            PNUser sender    = CreateXenonUser( true );
            PNUser recipient = CreateXenonUser( true );

            _fc.LogoffUser( recipient );

            MsgDetails details = MsgDetails.CreateBlank();
            UserMessage msg = UserMessage.Create( sender, XonPresNoti.MSG_TYPE_LIVE_MESSAGE, 0, XonPresNoti.MSG_FLAG_RECOMMENDED, 60, details );
            msg.Send( sender, recipient );

            uint HR = _fc.LogonUser( recipient );

            ValueCheck.TestHR("First Alive HR", HResult.XONLINE_S_LOGON_USER_HAS_MESSAGE, HR );
            _fc.LogoffUser( recipient );
            HR = _fc.LogonUser( recipient );
            ValueCheck.TestHR("Second Alive HR", HResult.XONLINE_S_LOGON_USER_HAS_MESSAGE, HR );
        }

        /// <summary>
        /// 	Logon User and check for has nomal success code
        /// </summary>
        /// <remarks>
        /// 	<Description>
        /// 	</Description>
        /// 	<Verify>
        /// 	</Verify>
        /// </remarks>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public void HadRecomented_Expired()
        {
            PNUser sender    = CreateXenonUser( true );
            PNUser recipient = CreateXenonUser( false );

            MsgDetails details = MsgDetails.CreateBlank();
            UserMessage msg = UserMessage.Create( sender, XonPresNoti.MSG_TYPE_LIVE_MESSAGE, 0, XonPresNoti.MSG_FLAG_RECOMMENDED, 1, details );
            msg.Send( sender, recipient );

            Console.WriteLine( "Wait for message to expire" );
            Thread.Sleep( new TimeSpan( 0, 2, 0 ) );

            _fc.LogonUser( recipient );
        }

        /// <summary>
        /// 	Logon User and check for has required message error code
        /// </summary>
        /// <remarks>
        /// 	<Description>
        /// 	</Description>
        /// 	<Verify>
        /// 	</Verify>
        /// </remarks>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public void HasRequired()
        {
            PNUser sender    = CreateXenonUser( true );
            PNUser recipient = CreateXenonUser(true);
            PNUser friend1 = CreateXenonUser(true);
            PNUser friend2 = CreateXenonUser(true);
            PNUser friend3 = CreateXenonUser(true);

            _fc.MakeFriend( recipient, friend1 );
            _fc.MakeFriend( recipient, friend2 );
            _fc.MakeFriend( recipient, friend3 );

            _fc.LogoffUser( recipient );

            MsgDetails details = MsgDetails.CreateBlank();
            UserMessage msg = UserMessage.Create( sender, XonPresNoti.MSG_TYPE_LIVE_MESSAGE, 0, XonPresNoti.MSG_FLAG_REQUIRED, 60, details );
            msg.Send( sender, recipient );

            try
            {
                _fc.LogonUser( recipient );
            }
            catch( HResultException e )
            {
                if( e.HR != HResult.XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT )
                    throw e;
            }

            UserMsgFolder inbox = new UserMsgFolder( recipient.UserId );
            UserMessage[] inMsg = inbox.Find( XonPresNoti.MSG_TYPE_LIVE_MESSAGE, sender.UserId, 0 );

            msg.Delete( recipient );

            _fc.LogonUser( recipient );
        }

        /// <summary>
        /// 	Logon User after message has expired and check for normal success code
        /// </summary>
        /// <remarks>
        /// 	<Description>
        /// 	</Description>
        /// 	<Verify>
        /// 	</Verify>
        /// </remarks>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public void HadRequired_Expired()
        {
            PNUser sender = CreateXenonUser(true);
            PNUser recipient = CreateXenonUser(false);

            MsgDetails details = MsgDetails.CreateBlank();
            UserMessage msg = UserMessage.Create( sender, XonPresNoti.MSG_TYPE_LIVE_MESSAGE, 0, XonPresNoti.MSG_FLAG_REQUIRED, 1, details );
            msg.Send( sender, recipient );

            Console.WriteLine( "Wait for message to expire" );
            Thread.Sleep( new TimeSpan( 0, 2, 0 ) );

            _fc.LogonUser( recipient );
        }
		
        /// <summary>
        /// 	Logon User and check for required message in another title ID
        /// </summary>
        /// <remarks>
        /// 	<Description>
        /// 	</Description>
        /// 	<Verify>
        /// 	</Verify>
        /// </remarks>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public void P_HasRequiredInOtherTitle()
        {
            PNUser sender = CreateXenonUser(true);
            PNUser recipient = CreateXenonUser(true);

            _fc.LogoffUser( recipient );

            MsgDetails details = MsgDetails.CreateBlank();
            UserMessage msg = UserMessage.Create( sender, XonPresNoti.MSG_TYPE_LIVE_MESSAGE, 0, XonPresNoti.MSG_FLAG_REQUIRED, 60, details );
            msg.Send( sender, recipient );

            _fc.LogonUser( recipient, PNXbox.DefTitleId - 1 );
        }

        /// <summary>
        /// 	Logon twice with unread required message still fails
        /// </summary>
        /// <remarks>
        /// 	<Description>
        /// 	</Description>
        /// 	<Verify>
        /// 	</Verify>
        /// </remarks>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public void HasRequiredAliveTwice()
        {
            PNUser sender = CreateXenonUser(true);
            PNUser recipient = CreateXenonUser(true);

            _fc.LogoffUser(recipient);

            MsgDetails details = MsgDetails.CreateBlank();
            UserMessage msg = UserMessage.Create(sender, XonPresNoti.MSG_TYPE_LIVE_MESSAGE, 0, XonPresNoti.MSG_FLAG_REQUIRED, 60, details);
            msg.Send(sender, recipient);

            try
            {
                _fc.LogonUser(recipient);
            }
            catch (HResultException e)
            {
                if (e.HR != HResult.XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT)
                    throw e;
            }

            try
            {
                _fc.LogonUser(recipient);
            }
            catch (HResultException e)
            {
                if (e.HR != HResult.XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT)
                    throw e;
            }

            UserMsgFolder inbox = new UserMsgFolder(recipient.UserId);
            UserMessage[] inMsg = inbox.Find(XonPresNoti.MSG_TYPE_LIVE_MESSAGE, sender.UserId, 0);

            msg.Delete(recipient);

            uint hr = _fc.LogonUser(recipient, recipient.Xbox.TitleId + 1);
            int welcomeMsgEnabled = int.Parse(Config.GetSetting("presence_WelcomeToXboxLiveMessage"));
            if (welcomeMsgEnabled != 0)
            {
                ValueCheck.TestHR("Alive after clearing required message", HResult.XONLINE_S_LOGON_USER_HAS_MESSAGE, hr);
            }
            {
                ValueCheck.TestHR("Alive after clearing required message", HResult.S_OK, hr);
            }
            
        }

        private void WebAliveVerify(PNUser u, PNUser friend,  uint expectedTtleId)
        {
            //Get a key for Internal Presence and verify LastSeenTitleId
            string key = CacheUtil.BuildCacheKey(DATA_TYPES.eInternalPresence, u.UserId);
            PresenceRecord rec = (PresenceRecord)CacheUtil.ReadFromCache(key);
            Assert.IsTrue(rec.dwLastSeenTitleID == expectedTtleId);
            DateTime nowTime = DateTime.UtcNow;
            TimeSpan tp = nowTime.Subtract(rec.dtLastSeen);
            Global.RO.Debug("Lastseen: " + rec.dtLastSeen.ToLongTimeString() + " diff: " + tp.ToString());
            Assert.IsTrue(tp.Hours == 0  && tp.Minutes == 0 && tp.Seconds < 10);

            //Get a key for Basic Presence and verify LastSeenTitleId
            key = CacheUtil.BuildCacheKey(DATA_TYPES.eBasicPresence, u.UserId);
            BasicPresence presrec = (BasicPresence)CacheUtil.ReadFromCache(key);
            Assert.IsTrue(presrec.dwTitleID == expectedTtleId);
            tp = nowTime.Subtract(presrec.LastSeenTime);
            Global.RO.Debug("Lastseen: " + rec.dtLastSeen.ToLongTimeString() + " diff: " + tp.ToString());
            Assert.IsTrue(tp.Hours == 0 && tp.Minutes == 0 && tp.Seconds < 10);

            PWebFriendReplyMsgData wfd = friend.GetWebFriends();

            //Verify.
            bool bVerified = false;
            foreach (WebFriend wf in wfd.rgFriends)
            {
                if (wf.BuddyID == u.UserId)
                {
                    ValueCheck.Test("buddy.TitleId", expectedTtleId, wf.TitleID);
                    bVerified = true;
                }
            }

            Assert.IsTrue(bVerified);
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public void P_HasRequiredSystemAliveTwice()
        {
            uint hr;

            PNUser recipient = CreateXenonUser(true);

            _fc.LogoffUser( recipient );

            Thread.Sleep( 1000 );

            SystemMessage msg = SystemMessage.CreateLiveMsg( Message.Priority.Required, "TestGuy", PNXbox.DefTitleId + 20, 0, "Test", 1, 0, 30 );

            msg.Send();

            Thread.Sleep( 1000 );

            //NOTE : Previously this used to throw an exception, but now it gives XONLINE_S_LOGON_USER_HAS_MESSAGE
            try
            {
                hr = _fc.LogonUser( recipient, recipient.Xbox.TitleId + 1 );
                if (hr != HResult.XONLINE_S_LOGON_USER_HAS_MESSAGE)
                    throw new UnexpectedTestResultException( "Alive was suppose to fail" );
            }
            catch( HResultException e )
            {
                if( e.HR != HResult.XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT )
                    throw e;
            }

            _fc.LogoffUser(recipient);

            try
            {
                hr = _fc.LogonUser(recipient, recipient.Xbox.TitleId + 2);
                if (hr != HResult.XONLINE_S_LOGON_USER_HAS_MESSAGE)
                    throw new UnexpectedTestResultException("Alive was suppose to fail");
            }
            catch( HResultException e )
            {
                if( e.HR != HResult.XONLINE_E_LOGON_USER_ACCOUNT_REQUIRES_MANAGEMENT )
                    throw e;
            }

            msg.Delete( SystemMessage.RevokeAlso.Yes );

            _fc.LogoffUser(recipient);

            Thread.Sleep( 5000 );

            _fc.LogonUser( recipient, PNXbox.DefTitleId + 20 );
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public void P_WebAlive()
        {
            //Create user.
            PNUser u = CreateXenonUser(true);
            //Make a friend with someone.
            PNUser friend = CreateXenonUser(true);
            _fc.MakeFriend(u, friend);
            //Log them off.
            _fc.LogoffUser(u);
            _fc.LogoffUser(friend);

            //Set a platform type to Mobile and call webalive.
            u.PlatformType = PNUser.UserPlatformType.Web;
            uint hr = u.WebAlive();
            Assert.IsTrue(hr == 0);

            WebAliveVerify(u, friend, xonline.common.service.XOn.WEB_TITLE_ID);
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public void P_WebAlive2()
        {
            //Create user.
            PNUser u = CreateXenonUser(true, 3456789);
            //Make a friend with someone.
            PNUser friend = CreateXenonUser(true, 3456789);
            _fc.MakeFriend(u, friend);
            //Log them off.
            _fc.LogoffUser(u);
            _fc.LogoffUser(friend);

            //Set a platform type to Mobile and call webalive.
            u.PlatformType = PNUser.UserPlatformType.Web;
            uint hr = u.WebAlive2();
            Assert.IsTrue(hr == 0);

            WebAliveVerify(u, friend, u.Xbox.TitleId);
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public void P_PhoneAlive()
        {
            //Create user.
            PNUser u = CreateXenonUser(true);
            //Make a friend with someone.
            PNUser friend = CreateXenonUser(true);
            _fc.MakeFriend(u, friend);
            //Log them off.
            _fc.LogoffUser(u);
            _fc.LogoffUser(friend);

            //Set a platform type to Mobile and call webalive.
            u.PlatformType = PNUser.UserPlatformType.Mobile;
            uint hr = u.WebAlive();
            Assert.IsTrue(hr == 0);

            WebAliveVerify(u, friend, xonline.common.service.XOn.MOBILE_TITLE_ID);
        }


        //        /// <summary>
        //        /// 	Changed gamer tag alive request
        //        /// </summary>
        //        /// <remarks>
        //        /// 	<Description>
        //        /// 	</Description>
        //        /// 	<Verify>
        //        /// 	</Verify>
        //        /// </remarks>
        //        [TestCase]
        //        public void P_ChangeGamerTag()
        //        {
        //            // create the user DH Silver
        //            string Name = "DH Silver";
        //            Owner owner = new Owner( Name );
        //            UacsCommon UACS = new UacsCommon();
        //            ulong UserId = UACS.CreateUser( owner );
        //            PNUser DHSilver = new PNUser(Name,UserId);
        //
        //            // create the user DH Silver2
        //            string Name2 = "DH Silver2";
        //            owner = new Owner( Name2 );
        //            ulong UserId2 = UACS.CreateUser( owner );
        //            PNUser DHSilver2 = new PNUser(Name2,UserId2);
        //
        //            // create a base presence record for this user
        //            _fc.LogonUser(DHSilver);
        //
        //            XRLSetUserAccountStatus	StatusRequest = new XRLSetUserAccountStatus();
        //            StatusRequest.nameChangeRequired=1;
        //            StatusRequest.userPuid=UserId;
        //            StatusRequest.Execute();
        //            XRLChangeGamerTag	Request = new XRLChangeGamerTag();
        //            Request.userPuid=UserId;
        //            Request.newTag="DH Gold";
        //            Request.Execute();
        //
        //            // add a friend request to DHSilver2
        //            DHSilver.AddBuddy(DHSilver2);
        //            QValPacket qval = DHSilver.WaitForQFlags(XonPresNoti.QFLAG_MASK_LIST_CHANGE);
        //            DHSilver.HandleQValPacket(qval);
        //
        //            // log off DHGold
        //            _fc.LogoffUser(DHSilver);
        //
        //            // log on DHSilver2
        //            _fc.LogonUser(DHSilver2);
        //
        //            Name = "";
        //        }
        //    
        //        /// <summary>
        //        /// 	Changed gamer tag to a taken gamertag
        //        /// </summary>
        //        /// <remarks>
        //        /// 	<Description>
        //        /// 	</Description>
        //        /// 	<Verify>
        //        /// 	</Verify>
        //        /// </remarks>
        //        [TestCase]
        //        public void P_ChangeToDuplicateGamerTag()
        //        {
        //            PNUser Original = CreateXenonUser(true);
        //            PNUser Duplicate = CreateXenonUser(false);
        //            Duplicate.Name = Original.Name;
        //            _fc.LogonUser(Duplicate);
        //
        //            _fc.LogoffUser(Original);
        //            _fc.LogoffUser(Duplicate);
        //        }

    }

    /// <summary>
    /// 	Negative functional tests for Alive
    /// </summary>
    [TestGroup, TestFrequency("Regression"), TestCasePriority(3)]
    public class FuncAlive_NegativeCases : PresenceTestBaseGroup
    {
        /// <summary>
        /// 	Alive with a user ID of 1
        /// </summary>
        /// <remarks>
        /// 	<Description>
        /// 	</Description>
        /// 	<Verify>
        /// 	</Verify>
        /// </remarks>
        [TestCase]
        public void N_Alive_MinUserId()
        {
            PNUser user = new PNUser("MrBrown", 1);
            try
            {
                _fc.LogonUser(user, PNXbox.DefTitleId);
            }
            catch (HResultException ex)
            {
                ValueCheck.Test("HR expected", HResult.XONLINE_E_USER_NOT_PRESENT, ex.HR);
            }
            finally
            {
                user.Dispose();
            }
        }
		
        /// <summary>
        /// 	Alive with a user ID of 0xffffffffffffffff
        /// </summary>
        /// <remarks>
        /// 	<Description>
        /// 	</Description>
        /// 	<Verify>
        /// 	</Verify>
        /// </remarks>
        [TestCase]
        public void N_Alive_MaxUserId()
        {
            PNUser user = new PNUser("MrPink", 0xffffffffffffffff);
            try
            {
                _fc.LogonUser(user, PNXbox.DefTitleId);
            }
            catch(XErrException ex)
            {
                ValueCheck.TestHR("HR expected", HResult.XONLINE_E_NOTIFICATION_INVALID_PUID, ex.XErr);
            }
        }


        //PS Bug # 18987
        [TestCase]
        public void N_ChangeNameBeforeAlive()
        {
            //Create user.
            PNUser u = CreateXenonUser(true);
            _fc.LogoffUser(u);

            //Change name and wait for xcache.
            Global.RO.Debug("Name: " + u.Name);
            u.Name = "ChangedGamerTag";
            WaitForXCache();

            //Connect to SG..
            u.Connect(u.Xbox);
            uint hr;

            //Try sending alive. should fail.
            try
            {
                hr = u.Alive();
                throw new Exception("Should not reach here.");
            }
            catch (HResultException ex)
            {
                ValueCheck.TestHR("Expected failure", xonline.common.service.HResult.XONLINE_E_LOGON_INVALID_USER, ex.HR);
            }
        }
        private void WaitForXCache()
        {
            int wait = Config.GetIntSetting(Setting.xcache_db_pollingInterval);
            Global.RO.Debug("Sleeping " + wait.ToString() + "s (for Xcache)");
            Thread.Sleep(wait * 1000);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\presencefunc\FuncAccept.cs ===
using System;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Notification;
using ServerTestFramework.LiveService.Presence;

namespace PresenceTest
{
	/// <summary>
	/// Functional Tests for Accept (Buddy)
	/// </summary>
    [TestGroup, TestFrequency("BVT"), TestCasePriority(1)]
	public class FuncAccept : TestNode
	{
		/// <summary>
		///  Accept a buddy request
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 		Send an Add buddy request from User1 followed by Accept buddy request
		/// 		from User2. 
		/// 	</Description>
		/// 	<Verify>
		/// 		<ul>
		/// 		<li>Users both alive.</li>
		/// 		<li>Add succeeds with S_OK.</li>
		/// 		<li>Appropriate qval notification. </li>
		/// 		<li>Proper dequeue of buddy request item.</li>
		/// 		<li>Accept succeeds with S_OK.</li>
		/// 		</ul>
		/// 	</Verify>
		/// </remarks>
                [TestCase]
		class P_Mainline : TestBase
		{
			override protected void Execute()
			{
                PNUser user1 = null;
                PNUser user2 = null;
                try
                {
                    FriendsCommon fc = new FriendsCommon();
                    user1 = fc.CreateUser(true);
                    user2 = fc.CreateUser(true);

                    user1.AddBuddy(user2);
                    user2.AcceptBuddy(user1);
                }
                finally
                {
                    user1.Disconnect();
                    user2.Disconnect();
                }

				ResultCode = TEST_RESULTS.PASSED;
			}
		}

		/// <summary>
		/// 	Multithreaded accept from multiple requested buddies
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 		Create a user and add 100 buddy requests. Spawn a number of threads
		/// 		and accept the buddy requests from those threads. This was an older
		/// 		V1/V2 test which doesn't make too much sense given the operation of the
		/// 		switchboard in a single completion port thread. Should discuss if this test
		/// 		should be removed.
		/// 	</Description>
		/// 	<Verify>
		/// 		All requested buddies accepted. See mainline case for more granular verification
		/// 		that occurs in this test as well.
		/// 	</Verify>
		/// </remarks>
                [TestCase, TestFrequency("Regression"), TestCasePriority(3)]
		class P_SpamWithAccepts_Multithreaded : TestBase
		{
			override protected void Execute()
			{
				FriendsCommon fc = new FriendsCommon();

				// Get a user to go nuts with, make sure they have no friends to start
				PNUser user;
				do 
				{
					user = fc.CreateUser( true );
				} 
				while( user.BuddiesAny > 0 );

				PWebFriendReplyMsgData wfd = user.GetWebFriends();
				ValueCheck.Test( "Web Friend Count", (byte)0, wfd.cdwFriends);
				if(wfd.rgFriends!= null)
					ValueCheck.Test( "Web Friend Count", (byte)0, wfd.rgFriends.Length );

				// Have user request 100 buddies.
				PNUser[] buddies = new PNUser[ 100 ];
				for( int i = 0; i < buddies.Length; ++i )
				{
					do 
					{
						buddies[i] = fc.CreateUser(true);
						fc.LogonUser( buddies[i] );
					} 
					while( buddies[i].BuddiesAny > 0 );

					user.AddBuddy( buddies[i] );
				}
				
				Thread.Sleep( 5000 ); // Wait for last Adds to complete

				fc.LogoffUser( user );
				fc.LogonUser( user );

				ValueCheck.Test( "Pending Buddy Count", 100, user.BuddiesPending );

				// Create an array of accept jobs
				AcceptUserJob[] jobs = new AcceptUserJob[ 20 ];
				for( int i = 0; i < jobs.Length; ++i )
				{
					jobs[i] = new AcceptUserJob( user, buddies, i, fc );
				}

				// Fly my pretties
				for( int i = 0; i < jobs.Length; ++i )
				{
					jobs[i].T.Start();
				}

				bool allDone;
				do
				{
					Thread.Sleep( 2000 );
					allDone = true;
					for( int i = 0; i < jobs.Length; ++i )
					{
						if( jobs[i].T.IsAlive )
						{
							allDone = false;
							break;
						}
					}
				}
				while( !allDone );

				Thread.Sleep( 5000 ); // Wait for last Accepts to complete

				fc.LogoffUser( user );
				fc.LogonUser( user );

				ValueCheck.Test( "Accepted Buddy Count", 100, user.BuddiesOK );

				PWebFriendReplyMsgData wfrd = user.GetWebFriends();
                ValueCheck.Test("Web Friend Count", (byte)100, wfrd.cdwFriends);
			
				ResultCode = TEST_RESULTS.PASSED;
			}
			
			class AcceptUserJob
			{
				private FriendsCommon FC;

				public Thread T;

				public PNUser User;
				public PNUser[] Buddies;
				public int StartI;
			
				public AcceptUserJob( PNUser user, PNUser[] buddies, int startI, FriendsCommon fc )
				{
					User    = user;
					Buddies = buddies;
					StartI  = startI*5;
					FC      = fc;

					T = new Thread( new ThreadStart( this.AcceptBuddy ) );
				}

				private void AcceptBuddy()
				{
					for( int i = StartI; i < StartI+5; ++i )
					{
						Buddies[ i ].AcceptBuddy( User );
					}
				}
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\presencefunc\FuncAddAffiliates.cs ===
using System; 
using System.Collections; 
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Notification;
using ServerTestFramework.LiveService.Presence;
using xonline.common.config;
using xonline.common.community;
using xonline.common.sql.webstore;
using Microsoft.Webstore.WstClient;

namespace PresenceTest
{
	/// <summary>
	/// 	Positive Functional Tests for AddAffiliates
	/// </summary>
	/// <remarks>
	/// 	<Description>
	/// 		<p>
	/// 		Add affiliate calls are used to append or update the affiliate user record
	/// 		on a set of affiliate lists in the presence server. These sets are not 
	/// 		transactional in nature and may actually not be consistent between memory
	/// 		and the database where they are pesisted between logons. 
	/// 		</p>
	///			
	///			<div class="test_data_label">
	///			AddAffiliates Request Format:
	///			</div>
	///			<table class="test_data">
	///				<tr><td>ULONGLONG qwSenderID</td><td>User ID of player sending feedback</td></tr>
	///				<tr><td>DWORD dwListFlags</td><td>Flags marking list to add user</td></tr>
	///				<tr><td>DWORD dwTitleID</td><td>Title ID where player was seen</td></tr>
	///				<tr><td>WORD cAffiliates</td><td>Number of affiliates in the payload</td></tr>
	///				<tr><td>ULONGLONG rgAffiliateIDs[]</td><td>Payload of User IDs to add</td></tr>
	///			</table>
	///
	/// 		<p>
	/// 		Add affiliate calls	are asynchronous, there is no response code returned on add. 
	/// 		Presence tracks affiliates state for each online player. Each add write both to 
	/// 		memory and the database.  When the player logs into the system again their list 
	/// 		will be loaded and cropped from the database.
	/// 		</p>
	///
	/// 		<p>
	/// 		In order to validate test behavior a local affiliates state object is built-up
	/// 		as calls are made to the add call. This object is then compared with another 
	/// 		affiliates state object that is loaded using the QueryAffiliates XRL. 
	/// 		</p>
	///
	/// 		<p>
	/// 		The affiliates state object hashes all users and affiliate item state
	/// 		to the correct list type, tracks positive to negative and negative to positive
	/// 		transitions and fall through from completed to encountered lists.
	/// 		</p>
	///
	/// 		<div class="test_data_label">
	/// 		The set of lists that are tracked by the affiliates system are:
	/// 		</div>
	/// 			
	///			<div class="test_data_label">
	/// 		Explicit lists:
	/// 		</div>
	/// 		<ul>
	/// 			<li>Encountered</li>
	/// 			<ul><li>This list tracks all recent players you have seen on live as well as the users that you have completed games with.</li></ul>
	/// 			<li>Completed Game</li>
	/// 			<ul><li>This list tracks all players you have completed a game with.</li></ul>
	/// 			<li>Positive Feedback</li>
	/// 			<ul><li>This list tracks all players that you have submitted positive feedback on.</li></ul>
	///				<li>Negative Feedback</li>
	///				<ul><li>This list tracks all players that you have submitted negative feedback on.</li></ul>
    ///				<li>Favorites</li>
    ///				<ul><li>This list tracks all players that you have flagged as a favorite.</li></ul>
	///			</ul>
	///
	///
	///			<div class="test_data_label">
	///			Implicit lists:
	///			</div>
	///			<ul>
	///				<li>Avoiding Me</li>
	///				<ul><li>This list tracks all players that have submitted negative feedback on you.</li></ul>
	///				<li>Friend</li>
	///				<ul><li>This is an emulated list that will return your friends list in the normalized affiliate format.</li></ul>
	///				<li>Block</li>
	///				<ul><li>This is an emulated list that will return your block list in the normalized affiliate format.</li></ul>
	///				<li>Mute</li>
	///				<ul><li>This is an emulated list that will return your mute list in the normalized affiliate format.</li></ul>
	///			</ul>
	///
	///			<p>
	///			The affiliate item format can be retrieved by the QueryAffiliates call. See the functional
	///			test group for QueryAffiliates for more information on the data format used for transferring
	///			affiliates.
	///			</p>
	///
	///			
	/// 	</Description>
	/// </remarks>
    [TestGroup, TestFrequency("Regression"), TestCasePriority(3)]
    class FuncAddAffiliates_PositiveCases : PresenceTestBaseGroup
	{
		static Report ro = new Report(typeof(FuncAddAffiliates_PositiveCases).Name);
		AffiliateState state;
    
        public override void Setup()
		{
            base.Setup();
			state = new AffiliateState();
			state.Initialize(CreateXenonUser(true));
		}

        /// <summary>
        /// 	Add one user to the Favorites affiliates list
        /// </summary>
        /// <remarks>
        /// 	<Description>
        /// 	</Description>
        /// 	<Verify>
        /// 	</Verify>
        /// </remarks>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public void P_AddOne_Favorites()
        {
            PNUser user = CreateXenonUser(true);
            state.Restore();
            state.Add(user, (uint)AffiliateFlags.Favorites);
            state.ValidateAllServerAffiliates();

            AffiliateState state2 = new AffiliateState(state);
            state2.Load();

            state.Compare(state2);
        }


		/// <summary>
		/// 	Add one user to the encountered affiliates list
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 	</Description>
		/// 	<Verify>
		/// 	</Verify>
		/// </remarks>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
		public void P_AddOne_Encountered()
		{
            PNUser user = CreateXenonUser(true);
			state.Restore();
			state.Add(user, (uint)AffiliateFlags.Encountered);
			state.ValidateAllServerAffiliates();

			AffiliateState state2 = new AffiliateState(state);
			state2.Load();

			state.Compare(state2);
		}


		/// <summary>
		/// 	Add a list of two users to the encountered affiliates list
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 	</Description>
		/// 	<Verify>
		/// 	</Verify>
		/// </remarks>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
		public void P_AddTwo_Encountered()
		{
            PNUser[] list = CreateXenonUsers(2, true);
			state.Restore();
			state.Add(list, (uint)AffiliateFlags.Encountered);
			state.Check(list, (uint)AffiliateFlags.Encountered);
			state.ValidateAllServerAffiliates();

			// Load up a new state to compare against the populated state
			AffiliateState state2 = new AffiliateState(state);
			state2.Load();
			state.Compare(state2);
		}

		/// <summary>
		/// 	Add the max number of encountered players (16)
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 	</Description>
		/// 	<Verify>
		/// 	</Verify>
		/// </remarks>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
		public void P_AddMax_Encountered()
		{
			state.Restore();

			// Add 16 affiliates
            PNUser[] list = CreateXenonUsers(16, false);
			state.Add(list, (uint)AffiliateFlags.Encountered);

			AffiliateState state2 = new AffiliateState(state);
			state2.Load();
			state.Compare(state2);
		}

		uint FindAffiliateIndex(ulong affiliateId, QueryAffiliatesReplyData[] results)
		{
			for(uint i = 0; i < results.Length; ++i)
			{
				if(results[i].qwAffiliateID == affiliateId)
					return i;
			}
			return 0xffffffff;
		}
		
		/// <summary>
		/// 	Re-add a user to completed game, ensure they sort at the top of recent players
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 	</Description>
		/// 	<Verify>
		/// 	</Verify>
		/// </remarks>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
		public void P_AddAffiliates_Already_Existing_CompletedGame()
		{
			state.Restore();

            PNUser[] list = CreateXenonUsers(2, true);
			state.Add(list[0], (uint)AffiliateFlags.CompletedGame);
			state.Add(list[1], (uint)AffiliateFlags.CompletedGame);
			
			PQueryAffiliatesReplyMsgData data;
			
			data = state.LoadExternal(UInt32.MaxValue, false, (uint)AffiliateFlags.CompletedGame);

			// Find affiliates indexes
			uint index0 = FindAffiliateIndex(list[0].UserId, data.rgResults);
			uint index1 = FindAffiliateIndex(list[1].UserId, data.rgResults);

			ValueCheck.IsTrue(index1 < index0, "Affiliate Indexes (index1 < index0)");

			// Re-add affiliate 1 should sort on top
			state.Add(list[1], (uint)AffiliateFlags.CompletedGame);

			data = state.LoadExternal(UInt32.MaxValue, false, (uint)AffiliateFlags.CompletedGame);

			// Find affiliates indexes
			index0 = FindAffiliateIndex(list[0].UserId, data.rgResults);
			index1 = FindAffiliateIndex(list[1].UserId, data.rgResults);

			ValueCheck.IsTrue(index0 > index1, "Affiliate Indexes (index0 > index1)");
		}


		/// <summary>
		/// 	Add a new user to the completed game list check the encountered list for existence
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 	</Description>
		/// 	<Verify>
		/// 	</Verify>
		/// </remarks>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
		public void P_AddAffiliates_CompletedGame_Verify_Encountered()
		{
			state.Restore();

			uint precount = state.GetInstanceCount((uint)AffiliateFlags.CompletedGame);

            state.Add(CreateXenonUser(true), (uint)AffiliateFlags.CompletedGame);
			state.ValidateAllServerAffiliates();
			state.Restore();

			uint postcount = state.GetInstanceCount((uint)AffiliateFlags.CompletedGame);
			
			ValueCheck.Test("Encountered+CompletedGame (post-pre)", 2, postcount-precount);
		}

		/// <summary>
		/// 	Add one user to the positive feedback list
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 	</Description>
		/// 	<Verify>
		/// 	</Verify>
		/// </remarks>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
		public void P_AddAffiliates_PositiveFeedback()
		{
			state.Restore();
            PNUser user = CreateXenonUser(true);
			state.Add(user, (uint)AffiliateFlags.PositiveFeedback);

			AffiliateState state2 = new AffiliateState(state);
			state2.Load();
			state.Compare(state2);
		}


		/// <summary>
		/// 	Add one user to the negative feedback list
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 	</Description>
		/// 	<Verify>
		/// 	</Verify>
		/// </remarks>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
		public void P_AddAffiliates_NegativeFeedback()
		{
			state.Restore();
            PNUser user = CreateXenonUser(true);
			state.Add(user, (uint)AffiliateFlags.NegativeFeedback);

			AffiliateState state2 = new AffiliateState(state);
			state2.Load();
			state.Compare(state2);

            // Check recip state
            AffiliateState recipState = new AffiliateState(user);
            recipState.Load();
            recipState.ValidateAffiliateFlags(state.GetOwner(), (uint)AffiliateFlags.AvoidingMe);
		}


		/// <summary>
		/// 	Add one to negative feedback then to positive feedback
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 	</Description>
		/// 	<Verify>
		/// 	</Verify>
		/// </remarks>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
		public void P_AddAffiliates_One_NegativeFeedback_To_PositiveFeedback()
		{
			state.Restore();

            PNUser user = CreateXenonUser(true);
			
			AffiliateState recipState = new AffiliateState(user);

			// Give some negative feedback
			state.Add(user, (uint)AffiliateFlags.NegativeFeedback);

			// Load compare state clean from the server
			AffiliateState state2 = new AffiliateState(state);
			state2.Load();
			state.Compare(state2);

			// Check recip state
			recipState.Load();
			recipState.ValidateAffiliateFlags(state.GetOwner(), (uint)AffiliateFlags.AvoidingMe);

			// TODO-jacobr: the server can't do this yet... :(
			// Move the user back to positive feedback list
			//state.Add(user, (uint)AffiliateFlags.PositiveFeedback);
			// Compare state with what we think internally
			//state2.Load();
			//state.Compare(state2);

			// Check recip state
			//recipState.Load();
			//recipState.ValidateIsNotAffiliate(state.GetOwner());
		}

		/// <summary>
		/// 	Add one to positive feedback then to negative feedback
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 	</Description>
		/// 	<Verify>
		/// 	</Verify>
		/// </remarks>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
		public void P_AddAffiliates_One_PositiveFeedback_To_NegativeFeedback()
		{
			state.Restore();

            PNUser user = CreateXenonUser(true);
			
			AffiliateState recipState = new AffiliateState(user);

			// Give some positive feedback
			state.Add(user, (uint)AffiliateFlags.PositiveFeedback);

			// Load compare state clean from the server
			AffiliateState state2 = new AffiliateState(state);
			state2.Load();
			state.Compare(state2);

			// Check recip state
			recipState.Load();
			recipState.ValidateIsNotAffiliate(state.GetOwner());

			// Provide some negative feedback
			state.Add(user, (uint)AffiliateFlags.NegativeFeedback);

			// Compare state with what we think internally
			state2.Restore();
			state.Compare(state2);

			// Check recip state
			recipState.Load();
			recipState.ValidateAffiliateFlags(state.GetOwner(), (uint)AffiliateFlags.AvoidingMe);
		}


		/// <summary>
		/// 	Add one user and a list of users without specifying flags
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 	</Description>
		/// 	<Verify>
		/// 	</Verify>
		/// </remarks>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
		public void P_AddAffiliates_One_And_Two_Zero_Flags()
		{
			state.Restore();

            PNUser user = CreateXenonUser(true);
            PNUser[] list = CreateXenonUsers(2, true);

			state.Add(user, 0);
			state.Add(list, 0);

			state.ValidateIsNotAffiliate(user);
			state.ValidateIsNotAffiliate(list);

			AffiliateState state2 = new AffiliateState(state);
			state2.Load();

			state.Compare(state2);
		}

		/// <summary>
		/// 	Add one user and two users without specifying a title ID
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 	</Description>
		/// 	<Verify>
		/// 	</Verify>
		/// </remarks>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
		public void P_AddAffiliates_One_And_Two_Zero_TitleId()
		{
			state.Restore();

            PNUser user = CreateXenonUser(true);
            PNUser[] list = CreateXenonUsers(2, true);

			state.Add(user, (uint)AffiliateFlags.CompletedGame, 0);
			state.Add(list, (uint)AffiliateFlags.CompletedGame, 0);

			state.ValidateAllServerAffiliates();

			AffiliateState state2 = new AffiliateState(state);
			state2.Load();

			state.Compare(state2);
		}

		/// <summary>
		/// 	Add some affiliates, remove with 'XMGMT SetCacheState' and re-load the list
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 	</Description>
		/// 	<Verify>
		/// 	</Verify>
		/// </remarks>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
		public void P_AddAffiliates_And_Eject_Affiliates()
		{
			state.Restore();

            PNUser[] list = CreateXenonUsers(16, true);
			state.Add(list, (uint)AffiliateFlags.CompletedGame);
			state.ValidateAllServerAffiliates();

			AffiliateState state2 = new AffiliateState(state);
			state2.Load();
			state.Compare(state2);

			// Eject the affiliates from the cache
			//Global.XEnv.ExecuteXmgmtCommand(Interface.xpserver, "e :presence setcachestate " + state.GetOwner().UserId + " 0");
		}

        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
		public void P_AddAffiliates_CheckOrder()
		{
			PNUser u1 = CreateXenonUser(true);
			PNUser p1 = CreateXenonUser(true);
			PNUser p2 = CreateXenonUser(true);
			PNUser u2 = CreateXenonUser(true);
			PNUser e1 = CreateXenonUser(true);
			PNUser e2 = CreateXenonUser(true);

			// Validate positive feedback order
			AffiliateState state1 = new AffiliateState(u1);
			state1.Add(p1, (uint)AffiliateFlags.PositiveFeedback);
			state1.Add(p2, (uint)AffiliateFlags.PositiveFeedback);
			
			PQueryAffiliatesReplyMsgData  reply;

			reply = state1.LoadExternal(2, false, (uint)AffiliateFlags.PositiveFeedback, true);
			ValidateAffiliateOrder(reply.rgResults, p2, p1);

			// Validate the order swaps
			state1.Add(p1, (uint)AffiliateFlags.PositiveFeedback);
			reply = state1.LoadExternal(2, false, (uint)AffiliateFlags.PositiveFeedback, true);
			ValidateAffiliateOrder(reply.rgResults, p1, p2);

			// Validate encountered affiliate order
			AffiliateState state2 = new AffiliateState(u2);
			state2.Add(e1, (uint)AffiliateFlags.Encountered);
			state2.Add(e2, (uint)AffiliateFlags.Encountered);

			reply = state2.LoadExternal(2, false, (uint)AffiliateFlags.Encountered, true);
			ValidateAffiliateOrder(reply.rgResults, e2, e1);

			// Validate the order swaps
			state2.Add(e1, (uint)AffiliateFlags.Encountered);
			reply = state2.LoadExternal(2, false, (uint)AffiliateFlags.Encountered, true);
			ValidateAffiliateOrder(reply.rgResults, e1, e2);

		}


        // affiliates are in descending updated time order.
		void ValidateAffiliateOrder(QueryAffiliatesReplyData []data, PNUser a, PNUser b)
		{
			ValueCheck.TestNonZero("Affiliate list reply", data.Length);
			ValueCheck.Test("Affiliate Pos 0 PUID", a.UserId, data[0].qwAffiliateID);
            ValueCheck.Test("Affiliate Pos 1 PUID", b.UserId, data[1].qwAffiliateID);
			ValueCheck.Test("Affiliate Date Updated Comparison", false, (data[0].mtDateUpdated < data[1].mtDateUpdated));
		}
        [TestCase]
        public void P_AddMax_Favorites_Total_Store()
        {
            int MaxFavorites = int.Parse(Config.GetSetting("presence_AffiliatesFavoritesListSize"));

            AffiliateState state1 = new AffiliateState();
            state1.Initialize(CreateXenonUser(true));
            // Add 1 affiliate at a time to get date right for removal
            PNUser[] list;
            state1.SetAddPostSleep(1000);
            for (int i = 0; i < MaxFavorites; i++)
            {
                list = CreateXenonUsers(1, false);
                state1.Add(list, (uint)AffiliateFlags.Favorites);
            }
            _fc.LogoffUser(state1.GetOwner());
            _fc.LogonUser(state1.GetOwner());

            AffiliateState state2 = new AffiliateState(state1);
            state2.Load();
            state1.Compare(state2);
        }
        [TestCase]
        public void P_AddMax_Favorites_Total_Plus_One_Store()
        {
            int MaxFavorites = int.Parse(Config.GetSetting("presence_AffiliatesFavoritesListSize")) + 1;

            AffiliateState state1 = new AffiliateState();
            state1.Initialize(CreateXenonUser(true));
            // Add 1 affiliate at a time to get date right for removal
            PNUser[] list;
            state1.SetAddPostSleep(1000);

            for (int i = 0; i < MaxFavorites; i++)
            {
                list = CreateXenonUsers(1, false);
                state1.Add(list, (uint)AffiliateFlags.Favorites);
            }

            _fc.LogoffUser(state1.GetOwner());
            _fc.LogonUser(state1.GetOwner());

            AffiliateState state2 = new AffiliateState(state1);
            state2.Load();
            state1.Compare(state2);
        }

        [TestCase]
        public void P_AddMax_MaxCompleted_Store()
        {
            int MaxCompleted = int.Parse(Config.GetSetting("presence_AffiliatesCompletedGameListSize"));

            AffiliateState state1 = new AffiliateState();
            state1.Initialize(CreateXenonUser(true));
            // Add 1 affiliate at a time to get date right for removal
            PNUser[] list;
            state1.SetAddPostSleep(1000);

            for (int i = 0; i < MaxCompleted; i++)
            {
                list = CreateXenonUsers(1, true);
                state1.Add(list, (uint)AffiliateFlags.CompletedGame);
            }

            Thread.Sleep(2000);
            _fc.LogoffUser(state1.GetOwner());
            Thread.Sleep(2000);
            _fc.LogonUser(state1.GetOwner());
            Thread.Sleep(2000);

            AffiliateState state2 = new AffiliateState(state1);
            state2.Load();
            Thread.Sleep(2000);
            state1.Compare(state2);
        }
        [TestCase]
        public void P_AddMax_Max_Plus1_Completed_Store()
        {
            int MaxCompleted = int.Parse(Config.GetSetting("presence_AffiliatesCompletedGameListSize")) + 1;

            AffiliateState state1 = new AffiliateState();
            state1.Initialize(CreateXenonUser(true));
            // Add 1 affiliate at a time to get date right for removal
            PNUser[] list;
            state1.SetAddPostSleep(1000);

            for (int i = 0; i < MaxCompleted; i++)
            {
                list = CreateXenonUsers(1, false);
                state1.Add(list, (uint)AffiliateFlags.CompletedGame);
            }

            Thread.Sleep(2000);
            _fc.LogoffUser(state1.GetOwner());
            Thread.Sleep(2000);
            _fc.LogonUser(state1.GetOwner());
            Thread.Sleep(2000);

            AffiliateState state2 = new AffiliateState(state1);
            state2.Load();
            Thread.Sleep(2000);
            state1.Compare(state2);
        }

        [TestCase]
        public void P_AddMax_Max_PlusMany_Completed_Store()
        {
            int MaxCompleted = int.Parse(Config.GetSetting("presence_AffiliatesCompletedGameListSize"));

            AffiliateState state1 = new AffiliateState();
            state1.Initialize(CreateXenonUser(true));
            // Add 1 affiliate at a time to get date right for removal
            PNUser[] list;
            state1.SetAddPostSleep(1000);

            for (int i = 0; i < MaxCompleted; i++)
            {
                list = CreateXenonUsers(1, false);
                state1.Add(list, (uint)AffiliateFlags.CompletedGame);
            }

            Thread.Sleep(2000);
            _fc.LogoffUser(state1.GetOwner());
            Thread.Sleep(2000);
            _fc.LogonUser(state1.GetOwner());
            Thread.Sleep(2000);

            AffiliateState state2 = new AffiliateState(state1);
            state2.Load();
            Thread.Sleep(2000);
            state1.Compare(state2);
        }

        [TestCase]
        public void P_AddMax_Completed_Store_RemoveKey()
        {
            int MaxCompleted = int.Parse(Config.GetSetting("presence_AffiliatesCompletedGameListSize"));

            AffiliateState state1 = new AffiliateState();
            state1.Initialize(CreateXenonUser(true));
            // Add 1 affiliate at a time to get date right for removal
            PNUser[] list;
            state1.SetAddPostSleep(1000);

            for (int i = 0; i < MaxCompleted; i++)
            {
                list = CreateXenonUsers(1, true);
                state1.Add(list, (uint)AffiliateFlags.CompletedGame);
            }

            string key = CacheUtil.BuildCacheKey(DATA_TYPES.eInternalPresence, state1.GetOwner().UserId);
            CacheUtil.RemoveFromCache(key);

            AffiliateState state2 = new AffiliateState(state1);
            state2.Load();
            state1.Compare(state2);
        }

        /// <summary>
        /// 	Add the max number of Favorites players and Completed Game total, 
        ///     store then load
        /// </summary>
        /// <remarks>
        /// 	<Description>
        /// 	</Description>
        /// 	<Verify>
        /// 	</Verify>
        /// </remarks>
        [TestCase]
        public void P_AddMax_Favorites_Same_CompletedGame_Total_Store()
        {
            int MaxFavorites = int.Parse(Config.GetSetting("presence_AffiliatesFavoritesListSize"));

            AffiliateState state1 = new AffiliateState();
            state1.Initialize(CreateXenonUser(true));
            // Add 1 affiliate at a time to get date right for removal
            PNUser[] list;
            state1.SetAddPostSleep(1000);
            for (int i = 0; i < MaxFavorites; i++)
            {
                list = CreateXenonUsers(1, false);
                state1.Add(list, (uint)AffiliateFlags.Favorites);
                state1.Add(list, (uint)AffiliateFlags.CompletedGame);
            }

            _fc.LogoffUser(state1.GetOwner());
            _fc.LogonUser(state1.GetOwner());

            AffiliateState state2 = new AffiliateState(state1);
            state2.Load();
            state1.Compare(state2);
        }

        /// <summary>
        /// 	Add the max number of encountered players (16), store then load
        /// </summary>
        /// <remarks>
        /// 	<Description>
        /// 	</Description>
        /// 	<Verify>
        /// 	</Verify>
        /// </remarks>
        [TestCase]
        public void P_AddMax_Encountered_Store()
        {
            state.Restore();

            // Add 16 affiliates
            PNUser[] list = CreateXenonUsers(16, false);
            state.Add(list, (uint)AffiliateFlags.Encountered);

            _fc.LogoffUser(state.GetOwner());
            _fc.LogonUser(state.GetOwner());

            AffiliateState state2 = new AffiliateState(state);
            state2.Load();
            state.Compare(state2);
        }

        /// <summary>
        /// 	Add the max number of encountered players (16) twice, store then load
        /// </summary>
        /// <remarks>
        /// 	<Description>
        /// 	</Description>
        /// 	<Verify>
        /// 	</Verify>
        /// </remarks>
        [TestCase]
        public void P_AddMax_Encountered_Twice_Store()
        {
            state.Restore();

            // Add 16 affiliates
            PNUser[] list = CreateXenonUsers(16, false);
            state.Add(list, (uint)AffiliateFlags.Encountered);

            list = CreateXenonUsers(16, false);
            state.Add(list, (uint)AffiliateFlags.Encountered);

            _fc.LogoffUser(state.GetOwner());
            _fc.LogonUser(state.GetOwner());

            AffiliateState state2 = new AffiliateState(state);
            state2.Load();
            state.Compare(state2);
        }

        /// <summary>
        /// 	Add the max number of encountered players total in batches of 16, store then load
        /// </summary>
        /// <remarks>
        /// 	<Description>
        /// 	</Description>
        /// 	<Verify>
        /// 	</Verify>
        /// </remarks>
        [TestCase]
        public void P_AddMax_Encountered_Total_Store()
        {
            int MaxEncountered = int.Parse(Config.GetSetting("presence_AffiliatesEncounteredListSize"));

            AffiliateState state1 = new AffiliateState();
            state1.Initialize(CreateXenonUser(true));
            // Add 1 affiliate at a time to get date right for removal
            PNUser[] list;
            state1.SetAddPostSleep(1000);

            for (int i = 0; i < MaxEncountered; i++)
            {
                list = CreateXenonUsers(1, false);
                state1.Add(list, (uint)AffiliateFlags.Encountered);
            }

            _fc.LogoffUser(state1.GetOwner());
            _fc.LogonUser(state1.GetOwner());

            Thread.Sleep(10000);

            AffiliateState state2 = new AffiliateState(state1);
            state2.Load();
            state1.Compare(state2);
        }

        /// <summary>
        /// 	Add the max number of encountered players total in batches of 16, store then load
        /// </summary>
        /// <remarks>
        /// 	<Description>
        /// 	</Description>
        /// 	<Verify>
        /// 	</Verify>
        /// </remarks>
        [TestCase]
        public void P_AddMax_Encountered_Total_Plus_One_Store()
        {
            int MaxEncountered = int.Parse(Config.GetSetting("presence_AffiliatesEncounteredListSize")) + 1;

            AffiliateState state1 = new AffiliateState();
            state1.Initialize(CreateXenonUser(true));
            // Add 1 affiliate at a time to get date right for removal
            PNUser[] list;
            state1.SetAddPostSleep(1000);

            for (int i = 0; i < MaxEncountered; i++)
            {
                list = CreateXenonUsers(1, false);
                state1.Add(list, (uint)AffiliateFlags.Encountered);
            }

            _fc.LogoffUser(state1.GetOwner());
            _fc.LogonUser(state1.GetOwner());

            Thread.Sleep(10000);

            AffiliateState state2 = new AffiliateState(state1);
            state2.Load();
            state1.Compare(state2);
        }

        /// <summary>
        /// 	Re-add a user to completed game, ensure they sort at the top of recent players
        /// </summary>
        /// <remarks>
        /// 	<Description>
        /// 	</Description>
        /// 	<Verify>
        /// 	</Verify>
        /// </remarks>
        [TestCase]
        public void P_AddAffiliates_Already_Existing_CompletedGame_Store()
        {
            state.Restore();
            state.SetAddPostSleep(1000);

            PNUser[] list = CreateXenonUsers(2, true);
            state.Add(list[0], (uint)AffiliateFlags.CompletedGame);
            state.Add(list[1], (uint)AffiliateFlags.CompletedGame);

            PQueryAffiliatesReplyMsgData data;

            data = state.LoadExternal(UInt32.MaxValue, false, (uint)AffiliateFlags.CompletedGame);

            // Find affiliates indexes
            uint index0 = FindAffiliateIndex(list[0].UserId, data.rgResults);
            uint index1 = FindAffiliateIndex(list[1].UserId, data.rgResults);

            ValueCheck.TestGreaterThan("Affiliate Indexes (index1 < index0)", index1, index0);

            _fc.LogoffUser(state.GetOwner());
            _fc.LogonUser(state.GetOwner());

            AffiliateState state2 = new AffiliateState(state);
            state2.Load();
            state.Compare(state2);

            // Re-add affiliate 1 should sort on top
            state.Add(list[1], (uint)AffiliateFlags.CompletedGame);

            data = state.LoadExternal(UInt32.MaxValue, false, (uint)AffiliateFlags.CompletedGame);

            // Find affiliates indexes
            index0 = FindAffiliateIndex(list[0].UserId, data.rgResults);
            index1 = FindAffiliateIndex(list[1].UserId, data.rgResults);

            ValueCheck.TestLessThan("Affiliate Indexes (index0 > index1)", index0, index1);

            _fc.LogoffUser(state.GetOwner());
            _fc.LogonUser(state.GetOwner());

            state2 = new AffiliateState(state);
            state2.Load();
            state.Compare(state2);
        }

        /// <summary>
        /// 	Add a new user to the completed game list check the encountered list for existence
        /// </summary>
        /// <remarks>
        /// 	<Description>
        /// 	</Description>
        /// 	<Verify>
        /// 	</Verify>
        /// </remarks>
        [TestCase]
        public void P_AddAffiliates_CompletedGame_Verify_Encountered_Store()
        {
            state.Restore();

            uint precount = state.GetInstanceCount((uint)AffiliateFlags.CompletedGame);

            state.Add(CreateXenonUser(true), (uint)AffiliateFlags.CompletedGame);
            state.ValidateAllServerAffiliates();
            state.Restore();

            _fc.LogoffUser(state.GetOwner());
            _fc.LogonUser(state.GetOwner());

            uint postcount = state.GetInstanceCount((uint)AffiliateFlags.CompletedGame);

            ValueCheck.Test("Encountered+CompletedGame (post-pre)", 2, postcount - precount);

        }

        /// <summary>
        /// 	Add one user to the positive feedback list
        /// </summary>
        /// <remarks>
        /// 	<Description>
        /// 	</Description>
        /// 	<Verify>
        /// 	</Verify>
        /// </remarks>
        [TestCase]
        public void P_AddAffiliates_PositiveFeedback_Store()
        {
            state.Restore();
            PNUser user = CreateXenonUser(true);
            state.Add(user, (uint)AffiliateFlags.PositiveFeedback);

            _fc.LogoffUser(state.GetOwner());
            _fc.LogonUser(state.GetOwner());

            AffiliateState state2 = new AffiliateState(state);
            state2.Load();
            state.Compare(state2);
        }

        /// <summary>
        /// 	Add one user to the negative feedback list
        /// </summary>
        /// <remarks>
        /// 	<Description>
        /// 	</Description>
        /// 	<Verify>
        /// 	</Verify>
        /// </remarks>
        [TestCase]
        public void P_AddAffiliates_NegativeFeedback_Store()
        {
            state.Restore();
            PNUser user = CreateXenonUser(true);
            state.Add(user, (uint)AffiliateFlags.NegativeFeedback);

            _fc.LogoffUser(state.GetOwner());
            _fc.LogonUser(state.GetOwner());

            AffiliateState state2 = new AffiliateState(state);
            state2.Load();
            state.Compare(state2);

            // Check recip state
            AffiliateState recipState = new AffiliateState(user);
            recipState.Load();
            recipState.ValidateAffiliateFlags(state.GetOwner(), (uint)AffiliateFlags.AvoidingMe);
        }

        /// <summary>
        /// 	Add one to positive feedback then to negative feedback
        /// </summary>
        /// <remarks>
        /// 	<Description>
        /// 	</Description>
        /// 	<Verify>
        /// 	</Verify>
        /// </remarks>
        [TestCase]
        public void P_AddAffiliates_One_PositiveFeedback_To_NegativeFeedback_Store()
        {
            state.Restore();

            PNUser user = CreateXenonUser(true);

            AffiliateState recipState = new AffiliateState(user);

            // Give some positive feedback
            state.Add(user, (uint)AffiliateFlags.PositiveFeedback);

            _fc.LogoffUser(state.GetOwner());
            _fc.LogonUser(state.GetOwner());

            // Load compare state clean from the server
            AffiliateState state2 = new AffiliateState(state);
            state2.Load();
            state.Compare(state2);

            // Check recip state
            recipState.Load();
            recipState.ValidateIsNotAffiliate(state.GetOwner());

            // Provide some negative feedback
            state.Add(user, (uint)AffiliateFlags.NegativeFeedback);

            _fc.LogoffUser(state.GetOwner());
            _fc.LogonUser(state.GetOwner());

            // Compare state with what we think internally
            state2.Restore();
            state.Compare(state2);

            // Check recip state
            recipState.Load();
            recipState.ValidateAffiliateFlags(state.GetOwner(), (uint)AffiliateFlags.AvoidingMe);
        }

        /// <summary>
        /// 	Add one user and a list of users without specifying flags
        /// </summary>
        /// <remarks>
        /// 	<Description>
        /// 	</Description>
        /// 	<Verify>
        /// 	</Verify>
        /// </remarks>
        [TestCase]
        public void P_AddAffiliates_One_And_Two_Zero_Flags_Store()
        {
            state.Restore();

            PNUser user = CreateXenonUser(true);
            PNUser[] list = CreateXenonUsers(2, true);

            state.Add(user, 0);
            state.Add(list, 0);

            state.ValidateIsNotAffiliate(user);
            state.ValidateIsNotAffiliate(list);

            _fc.LogoffUser(state.GetOwner());
            _fc.LogonUser(state.GetOwner());

            AffiliateState state2 = new AffiliateState(state);
            state2.Load();

            state.Compare(state2);
        }

        /// <summary>
        /// 	Add one user and two users without specifying a title ID
        /// </summary>
        /// <remarks>
        /// 	<Description>
        /// 	</Description>
        /// 	<Verify>
        /// 	</Verify>
        /// </remarks>
        [TestCase]
        public void P_AddAffiliates_One_And_Two_Zero_TitleId_Store()
        {
            state.Restore();

            PNUser user = CreateXenonUser(true);
            PNUser[] list = CreateXenonUsers(2, true);

            state.Add(user, (uint)AffiliateFlags.CompletedGame, 0);
            state.Add(list, (uint)AffiliateFlags.CompletedGame, 0);

            state.ValidateAllServerAffiliates();

            _fc.LogoffUser(state.GetOwner());
            _fc.LogonUser(state.GetOwner());

            AffiliateState state2 = new AffiliateState(state);
            state2.Load();

            state.Compare(state2);
        }

        [TestCase]
        public void P_AddAffiliates_CheckOrder_After_Store()
        {
            PNUser u1 = CreateXenonUser(true);
            PNUser p1 = CreateXenonUser(true);
            PNUser p2 = CreateXenonUser(true);
            PNUser u2 = CreateXenonUser(true);
            PNUser e1 = CreateXenonUser(true);
            PNUser e2 = CreateXenonUser(true);

            // Validate positive feedback order
            AffiliateState state1 = new AffiliateState(u1);
            state1.Add(p1, (uint)AffiliateFlags.PositiveFeedback);
            state1.Add(p2, (uint)AffiliateFlags.PositiveFeedback);

            _fc.LogoffUser(state1.GetOwner());
            _fc.LogonUser(state1.GetOwner());

            PQueryAffiliatesReplyMsgData reply;

            reply = state1.LoadExternal(2, false, (uint)AffiliateFlags.PositiveFeedback, true);
            ValidateAffiliateOrder(reply.rgResults, p2, p1);

            // Validate the order swaps
            state1.Add(p1, (uint)AffiliateFlags.PositiveFeedback);

            _fc.LogoffUser(state.GetOwner());
            _fc.LogonUser(state.GetOwner());

            reply = state1.LoadExternal(2, false, (uint)AffiliateFlags.PositiveFeedback, true);
            ValidateAffiliateOrder(reply.rgResults, p1, p2);

            // Validate encountered affiliate order
            AffiliateState state2 = new AffiliateState(u2);
            state2.Add(e1, (uint)AffiliateFlags.Encountered);
            state2.Add(e2, (uint)AffiliateFlags.Encountered);

            _fc.LogoffUser(state2.GetOwner());
            _fc.LogonUser(state2.GetOwner());

            reply = state2.LoadExternal(2, false, (uint)AffiliateFlags.Encountered, true);
            ValidateAffiliateOrder(reply.rgResults, e2, e1);

            // Validate the order swaps
            state2.Add(e1, (uint)AffiliateFlags.Encountered);

            _fc.LogoffUser(state2.GetOwner());
            _fc.LogonUser(state2.GetOwner());

            reply = state2.LoadExternal(2, false, (uint)AffiliateFlags.Encountered, true);
            ValidateAffiliateOrder(reply.rgResults, e1, e2);

        }

        private void GenericVerifyDBPostLogoff(int maxCount, AffiliateFlags flag)
        {
            Global.RO.Info("Testing : " + flag.ToString());
            System.Collections.Generic.List<ulong> addedAffiliates = new System.Collections.Generic.List<ulong>();
            System.Collections.Generic.List<ulong> loadedAffiliates = new System.Collections.Generic.List<ulong>();

            AffiliateState state1 = new AffiliateState();
            state1.SetAddPostSleep(1000);
            PNUser[] list;
            bool bFound = false;

            //create user and add affiliate
            PNUser user = CreateXenonUser(true);
            state1.Initialize(user);
            for (int i = 0; i < maxCount; i++)
            {
                list = CreateXenonUsers(1, false);
                addedAffiliates.Add(list[0].UserId);
                state1.Add(list, (uint)flag);
            }

            Thread.Sleep(2000);
            _fc.LogoffUser(state1.GetOwner());
            Thread.Sleep(2000);
            _fc.LogonUser(state1.GetOwner());

            //Query DB
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.Partition = ws.CalcPartition(state1.GetOwner().UserId);
                ws.StoredProc = "dbo.p_pres_load_affiliates";
                ws.AddParameter(ParamType.RETVAL, "@ret", 0);
                ws.AddParameter("@bi_user_puid", (long)state1.GetOwner().UserId);
                ws.AddParameter("@i_list_flag", (int)flag);
                WstDataReader reader = ws.Execute();
                xonline.common.service.HResult hr = (uint)ws.GetIntParameter("@ret");
                if (HResult.Succeeded((uint)hr) && reader.HasRows)
                {
                    while (reader.Read())
                    {
                        loadedAffiliates.Add(ulong.Parse(reader["bi_affiliate_puid"].ToString()));
                    }
                }
            }

            //Verify db return values
            ValueCheck.Test("Number of return rows", maxCount - 1, loadedAffiliates.Count);
            foreach (ulong affiliateId in loadedAffiliates)
            {
                if (affiliateId == addedAffiliates[0])
                    bFound = true;
            }
            ValueCheck.Test("The first added affiliate is cropped.", false, bFound);
        }

        [TestCase]
        public void P_AddMax_VerifyDBPostLogoff()
        {
            int MaxCompleted = int.Parse(Config.GetSetting("presence_AffiliatesCompletedGameListSize"))+ 1;
            int MaxEncountered = int.Parse(Config.GetSetting("presence_AffiliatesEncounteredListSize"))+ 1;
            int MaxFavorite = int.Parse(Config.GetSetting("presence_AffiliatesFavoritesListSize"))+ 1;
            int MaxPositive =int.Parse(Config.GetSetting("presence_AffiliatesPositiveFeedbackListSize"))+ 1;
            int MaxNegative =int.Parse(Config.GetSetting("presence_AffiliatesNegativeFeedbackListSize"))+ 1;

            //Not testing avoiding Me List because it is implicit list.
            GenericVerifyDBPostLogoff(MaxCompleted, AffiliateFlags.CompletedGame);
            GenericVerifyDBPostLogoff(MaxEncountered, AffiliateFlags.Encountered);
            GenericVerifyDBPostLogoff(MaxFavorite, AffiliateFlags.Favorites);
            GenericVerifyDBPostLogoff(MaxPositive, AffiliateFlags.PositiveFeedback);
            GenericVerifyDBPostLogoff(MaxNegative, AffiliateFlags.NegativeFeedback);
        }

        private void GenericVerifyDBPresenceRecordReconstruct(int maxCount, AffiliateFlags flag, string settingName)
        {
            //Change the setting first.
            XConfig xconfig = new XConfig();
            SettingState st = xconfig.OverrideSetting("ALL", "ALL", settingName, maxCount.ToString());
            xconfig.CheckForUpdates();
            Global.XEnv.ExecuteXmgmtCommand(Interface.xpnfd_presence, "e :xpnfd configcacherefresh");

            Global.RO.Info("Testing : " + flag.ToString());
            System.Collections.Generic.List<ulong> addedAffiliates = new System.Collections.Generic.List<ulong>();
            System.Collections.Generic.List<ulong> loadedAffiliates = new System.Collections.Generic.List<ulong>();

            AffiliateState state1 = new AffiliateState();
            state1.SetAddPostSleep(1000);
            PNUser[] list;
            bool bFound = false;

            //create user and add affiliate
            Global.RO.Info("Creating test user.");
            PNUser user = CreateXenonUser(true);
            state1.Initialize(user);
            Global.RO.Info("Adding affiliates.");
            for (int i = 0; i < maxCount; i++)
            {
                list = CreateXenonUsers(1, true);
                addedAffiliates.Add(list[0].UserId);
                state1.Add(list, (uint)flag);
            }

            Global.RO.Info("Logging off test user to persist to db.");
            Thread.Sleep(1000);
            _fc.LogoffUser(state1.GetOwner());
            Thread.Sleep(1000);
            Global.RO.Info("Log on test user again");
            _fc.LogonUser(state1.GetOwner());

            //verify db.
            //Query DB
            Global.RO.Info("Verifying database.");
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.Partition = ws.CalcPartition(state1.GetOwner().UserId);
                ws.StoredProc = "dbo.p_pres_load_affiliates";
                ws.AddParameter(ParamType.RETVAL, "@ret", 0);
                ws.AddParameter("@bi_user_puid", (long)state1.GetOwner().UserId);
                ws.AddParameter("@i_list_flag", (int)flag);
                WstDataReader reader = ws.Execute();
                xonline.common.service.HResult hr = (uint)ws.GetIntParameter("@ret");
                if (HResult.Succeeded((uint)hr) && reader.HasRows)
                {
                    while (reader.Read())
                    {
                        loadedAffiliates.Add(ulong.Parse(reader["bi_affiliate_puid"].ToString()));
                    }
                }
            }
            //Verify db return values
            ValueCheck.Test("Number of return rows", maxCount, loadedAffiliates.Count);

            //Now change the setting back.
            Global.RO.Info("Changing back config setting.");
            Global.XEnv.DeleteOverrideSetting("ALL", "ALL", settingName, 1);
            xconfig.CheckForUpdates();
            Global.XEnv.ExecuteXmgmtCommand(Interface.xpnfd_presence, "e :xpnfd configcacherefresh");

            //User is still logged on. now kill the key.
            Global.RO.Info("Deleting cache key");
            string key = CacheUtil.BuildCacheKey(DATA_TYPES.eAffiliateList, state1.GetOwner().UserId, xonline.common.protocol.PresDefs.X_AFFILIATE_FLAG_TO_INDEX((uint)flag));
            CacheUtil.RemoveFromCache(key);

            //Load again. This will trigger crop
            Global.RO.Info("Loading affiliates. This should trigger crop");
            AffiliateList.Load(user.UserId, xonline.common.protocol.PresDefs.X_AFFILIATE_FLAG_TO_INDEX((uint)flag));

            //Query DB
            Global.RO.Info("Querying database and verifying");
            loadedAffiliates.Clear();
            using (WSClient ws = new WSClient(ConfigUtil.UodbWebstoreApp, CmdType.WRITETHENREAD_COMMANDTYPE))
            {
                ws.Partition = ws.CalcPartition(state1.GetOwner().UserId);
                ws.StoredProc = "dbo.p_pres_load_affiliates";
                ws.AddParameter(ParamType.RETVAL, "@ret", 0);
                ws.AddParameter("@bi_user_puid", (long)state1.GetOwner().UserId);
                ws.AddParameter("@i_list_flag", (int)flag);
                WstDataReader reader = ws.Execute();
                xonline.common.service.HResult hr = (uint)ws.GetIntParameter("@ret");
                if (HResult.Succeeded((uint)hr) && reader.HasRows)
                {
                    while (reader.Read())
                    {
                        loadedAffiliates.Add(ulong.Parse(reader["bi_affiliate_puid"].ToString()));
                    }
                }
            }

            //Verify db return values
            ValueCheck.Test("Number of return rows", maxCount - 1, loadedAffiliates.Count);
            foreach (ulong affiliateId in loadedAffiliates)
            {
                if (affiliateId == addedAffiliates[0])
                    bFound = true;
            }
            ValueCheck.Test("The first added affiliate is cropped.", false, bFound);
        }

        [TestCase, EnvRequirement("Manual")]
        public void P_AddMax_VerifyDBPostPresenceRecordReconstruct()
        {
            int MaxCompleted = int.Parse(Config.GetSetting("presence_AffiliatesCompletedGameListSize"))+ 1;
            int MaxEncountered = int.Parse(Config.GetSetting("presence_AffiliatesEncounteredListSize"))+ 1;
            int MaxFavorite = int.Parse(Config.GetSetting("presence_AffiliatesFavoritesListSize"))+ 1;
            int MaxPositive =int.Parse(Config.GetSetting("presence_AffiliatesPositiveFeedbackListSize"))+ 1;
            int MaxNegative =int.Parse(Config.GetSetting("presence_AffiliatesNegativeFeedbackListSize"))+ 1;

            //Not testing avoiding Me List because it is implicit list.
            GenericVerifyDBPresenceRecordReconstruct(MaxCompleted, AffiliateFlags.CompletedGame, Setting.presence_AffiliatesCompletedGameListSize);
            GenericVerifyDBPresenceRecordReconstruct(MaxEncountered, AffiliateFlags.Encountered, Setting.presence_AffiliatesEncounteredListSize);
            GenericVerifyDBPresenceRecordReconstruct(MaxFavorite, AffiliateFlags.Favorites, Setting.presence_AffiliatesFavoritesListSize);
            GenericVerifyDBPresenceRecordReconstruct(MaxPositive, AffiliateFlags.PositiveFeedback, Setting.presence_AffiliatesPositiveFeedbackListSize);
            GenericVerifyDBPresenceRecordReconstruct(MaxNegative, AffiliateFlags.NegativeFeedback, Setting.presence_AffiliatesNegativeFeedbackListSize);
        }
	}

	/// <summary>
	/// 	Negative Functional Tests for AddAffiliates
	/// </summary>
    [TestGroup, TestFrequency("Regression"), TestCasePriority(3)]
	class FuncAddAffiliates_NegativeCases : PresenceTestBaseGroup
	{
		PNUser         _validOnline;
		PNUser         _validNotInMemory;
		PNUser         _validLoggedOff;
		PNUser         _zero;
		uint           _titleId;
		AffiliateState _state;
		PQueryAffiliatesReplyMsgData _queryReply;
		
		public override void Setup()
		{
            base.Setup();

			_validOnline      = CreateXenonUser(true);
			_validNotInMemory = CreateXenonUser(false);
			_validLoggedOff   = CreateXenonUser(true);

			_fc.LogoffUser(_validLoggedOff);
			
			PNXbox xbox = new PNXbox();
			_zero = new PNUser("zero", 0);
            _alUsers.Add(_zero);
			_zero.Xbox = xbox;

			_titleId = PNXbox.DefTitleId;
			_state = new AffiliateState(_validOnline);
		}

		public override void TearDown()
		{
			_validOnline = null;
			_validNotInMemory = null;
			_validLoggedOff = null;
			_zero = null;
            base.TearDown();
		}

		void SendAdd(PNUser user, uint flags, uint titleId, PNUser other)
		{
			SendAdd(user, flags, titleId, new PNUser[]{other});
		}

		void SendAdd(PNUser user, uint flags, uint titleId, PNUser[] list)
		{
			PMsgAddAffiliates req = new PMsgAddAffiliates(
					user, 
					flags,
					titleId, 
					list);
			req.TransactFD();
		}


		/// <summary>
		/// 	User not online
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 	Send add affiliates with user ID set to a user who is valid
		/// 	but is not alive.
		/// 	</Description>
		/// 	<Verify>
        /// 	HRESULT equal to XONLINE_E_NOTIFICATION_INVALID_PUID
		/// 	</Verify>
		/// </remarks>
		[TestCase]
		public void N_AddAffiliates_User_Not_Online()
		{
            uint hr = 0;
            try
            {
                SendAdd(_validLoggedOff, (uint)AffiliateFlags.CompletedGame, _titleId, _validOnline);
            } 
            catch(XErrException ex)
            {
                hr = ex.XErr;
            }
            ValueCheck.TestHR("Expected failure", HResult.XONLINE_E_NOTIFICATION_INVALID_PUID, hr);
		}

		/// <summary>
		/// 	User zero
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 	Send add affiliates with user ID set to zero.
		/// 	</Description>
		/// 	<Verify>
		/// 	HRESULT equal to E_INVALIDARG.
		/// 	</Verify>
		/// </remarks>
		[TestCase]
		public void N_AddAffiliates_User_Zero()
        {
            uint hr = 0;
            try
            {
                SendAdd(_zero, (uint)AffiliateFlags.CompletedGame, _titleId, _validOnline);
            } 
            catch(XErrException ex)
            {
                hr = ex.XErr;
            }

            ValueCheck.TestHR("Expected failure", HResult.E_INVALIDARG, hr);
        }
		
		/// <summary>
		/// 	Add to avoiding me list
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 	Send add affiliates to the non-mutable list avoiding me.
		/// 	</Description>
		/// 	<Verify>
        /// 	Affiliates list size should not change.
		/// 	</Verify>
		/// </remarks>
		[TestCase]
		public void N_AddAffiliates_AvoidingMe_List()
		{
            _queryReply = _state.LoadExternal(20, false, (uint)AffiliateFlags.AvoidingMe);
            uint results = _queryReply.cdwResults;
            
            SendAdd(_validOnline, (uint)AffiliateFlags.AvoidingMe, _titleId, _validLoggedOff);
            
            _queryReply = _state.LoadExternal(20, false, (uint)AffiliateFlags.AvoidingMe);

            ValueCheck.Test("Reply length", results, _queryReply.cdwResults);
		}

		/// <summary>
		/// 	Add to friend list
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 	Send add affiliates to the non-mutable list friends.
		/// 	</Description>
		/// 	<Verify>
        /// 	Affiliates list size should not change.
		/// 	</Verify>
		/// </remarks>
		[TestCase]
		public void N_AddAffiliates_Friend_List()
		{
            _queryReply = _state.LoadExternal(20, false, (uint)AffiliateFlags.Friend);
            uint results = _queryReply.cdwResults;
            
            SendAdd(_validOnline, (uint)AffiliateFlags.Friend, _titleId, _validLoggedOff);

            _queryReply = _state.LoadExternal(20, false, (uint)AffiliateFlags.Friend);

            ValueCheck.Test("Reply length", results, _queryReply.cdwResults);
		}

		/// <summary>
		/// 	Add to block list
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 	Send add affiliates to the non-mutable list blocks.
		/// 	</Description>
		/// 	<Verify>
        /// 	Affiliates list size should not change.
		/// 	</Verify>
		/// </remarks>
		[TestCase]
		public void N_AddAffiliates_Block_List()
		{
            _queryReply = _state.LoadExternal(20, false, (uint)AffiliateFlags.Block);
            uint results = _queryReply.cdwResults;
            
            SendAdd(_validOnline, (uint)AffiliateFlags.Block, _titleId, _validLoggedOff);

            _queryReply = _state.LoadExternal(20, false, (uint)AffiliateFlags.Block);

            ValueCheck.Test("Reply length", results, _queryReply.cdwResults);
		}

		/// <summary>
		/// 	Add to mute list
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 	Send add affiliates to the non-mutable list blocks.
		/// 	</Description>
		/// 	<Verify>
        /// 	Affiliates list size should not change.
		/// 	</Verify>
		/// </remarks>
		[TestCase]
		public void N_AddAffiliates_Mute_List()
		{
            _queryReply = _state.LoadExternal(20, false, (uint)AffiliateFlags.Mute);
            uint results = _queryReply.cdwResults;
            
            SendAdd(_validOnline, (uint)AffiliateFlags.Mute, _titleId, _validLoggedOff);

            _queryReply = _state.LoadExternal(20, false, (uint)AffiliateFlags.Mute);

            ValueCheck.Test("Reply length", results, _queryReply.cdwResults);
		}

		/// <summary>
		/// 	Add to all possible lists (0xffffffff)
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 	Send add affiliates to the non-mutable list blocks.
		/// 	</Description>
		/// 	<Verify>
        /// 	Affiliates list size should not change.
		/// 	</Verify>
		/// </remarks>
		[TestCase]
		public void N_AddAffiliates_AllBits()
		{
            _queryReply = _state.LoadExternal(20, false, 0xffffffff);
            uint results = _queryReply.cdwResults;
            
            SendAdd(_validOnline, 0xffffffff, _titleId, _validLoggedOff);

            _queryReply = _state.LoadExternal(20, false, 0xffffffff);

            ValueCheck.Test("Reply length", results, _queryReply.cdwResults);
		}

		/// <summary>
		/// 	Add zero count affiliates
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 	Send add affiliates with zero count payload puids.
		/// 	</Description>
		/// 	<Verify>
        /// 	Affiliates list size should not change.
		/// 	</Verify>
		/// </remarks>
		[TestCase]
		public void N_AddAffiliates_Count_Zero()
		{
            _queryReply = _state.LoadExternal(20, false, (uint)AffiliateFlags.CompletedGame);
            uint results = _queryReply.cdwResults;
            
            SendAdd(_validOnline, (uint)AffiliateFlags.CompletedGame, _titleId, new PNUser[]{});

            _queryReply = _state.LoadExternal(20, false, (uint)AffiliateFlags.CompletedGame);

            ValueCheck.Test("Reply length", results, _queryReply.cdwResults);
		}

		/// <summary>
		/// 	Add max count (0xffff)
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 	Send add affiliates well beyond max supported.
		/// 	</Description>
		/// 	<Verify>
        /// 	Should get status code NotFound, since request of this size shouldn't get past XrlScan
		/// 	</Verify>
		/// </remarks>
		[TestCase]
		public void N_AddAffiliates_Count_Max()
		{
            PNUser[] wooboy = new PNUser[0xffff];
			for(uint i = 0; i < 0xffff; ++i)
			{
				wooboy[i] = new PNUser(i.ToString(), (ulong)0x1234000000000000|i);
			}
            
            try
            {
                SendAdd(_validOnline, (uint)AffiliateFlags.CompletedGame, _titleId, wooboy);
            }
            catch (HttpStatusCodeException e)
            {
                ValueCheck.Test("Status code", System.Net.HttpStatusCode.NotFound, e.StatusCode); 
            }

		}

		/// <summary>
		/// 	Add a affiliate ID (0xabcd1234abcd1234) in first position
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 	Send add affiliates with a bogus user puid.
		/// 	</Description>
		/// 	<Verify>
        /// 	Affiliates list size should not change.
		/// 	</Verify>
		/// </remarks>
		[TestCase]
		public void N_AddAffiliates_Invalid_FirstPuid()
		{
            _queryReply = _state.LoadExternal(20, false, (uint)AffiliateFlags.AvoidingMe);
            uint results = _queryReply.cdwResults;
            
            PNUser []list = new PNUser[2];
			list[0] = new PNUser("Invalid", 0xabcd1234abcd1234);
			list[1] = _validLoggedOff;
            
            SendAdd(_validOnline, (uint)AffiliateFlags.AvoidingMe, _titleId, list);

            _queryReply = _state.LoadExternal(20, false, (uint)AffiliateFlags.AvoidingMe);

            ValueCheck.Test("Reply length", results, _queryReply.cdwResults); 
		}
		
		/// <summary>
		/// 	Add a affiliate ID (0xabcd1234abcd1234) in second position
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 	Send add affiliates with a bogus user puid.
		/// 	</Description>
		/// 	<Verify>
        /// 	Affiliates list size should not change.
		/// 	</Verify>
		/// </remarks>
		[TestCase]
		public void N_AddAffiliates_Invalid_SecondPuid()
		{
            _queryReply = _state.LoadExternal(20, false, (uint)AffiliateFlags.AvoidingMe);
            uint results = _queryReply.cdwResults;
            
            PNUser []list = new PNUser[2];
			list[0] = _validLoggedOff;
			list[1] = new PNUser("Invalid", 0xabcd1234abcd1234);
            
            SendAdd(_validOnline, (uint)AffiliateFlags.AvoidingMe, _titleId, list);

            _queryReply = _state.LoadExternal(20, false, (uint)AffiliateFlags.AvoidingMe);

            ValueCheck.Test("Reply length", results, _queryReply.cdwResults);
		}
		
		/// <summary>
		/// 	Add a zero affiliate ID
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 	Send add affiliates with a bogus user puid.
		/// 	</Description>
		/// 	<Verify>
        /// 	Affiliates list size should not change.
		/// 	</Verify>
		/// </remarks>
		[TestCase]
		public void N_AddAffiliates_Zero_AffiliateId()
		{
            _queryReply = _state.LoadExternal(20, false, (uint)AffiliateFlags.CompletedGame);
            uint results = _queryReply.cdwResults;
            
            SendAdd(_validOnline, (uint)AffiliateFlags.CompletedGame, _titleId, _zero);

            _queryReply = _state.LoadExternal(20, false, (uint)AffiliateFlags.CompletedGame);

            ValueCheck.Test("Reply length", results, _queryReply.cdwResults);
		}

		/// <summary>
		/// 	Add too many affiliates (17)
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 	Send add affiliates just beyond max supported.
		/// 	</Description>
        /// 	Affiliates list size should not change.
		/// 	<Verify>
		/// 	</Verify>
		/// </remarks>
		[TestCase]
		public void N_AddAffiliates_TooMany()
		{
            _queryReply = _state.LoadExternal(20, false, (uint)AffiliateFlags.CompletedGame);
            uint results = _queryReply.cdwResults;
            
            PNUser []list = new PNUser[17];
			for(uint i = 0; i < 17; ++i)
			{
				list[i] = _validLoggedOff;
			}

            SendAdd(_validOnline, (uint)AffiliateFlags.CompletedGame, _titleId, list);

            _queryReply = _state.LoadExternal(20, false, (uint)AffiliateFlags.CompletedGame);

            ValueCheck.Test("Reply length", results, _queryReply.cdwResults);
            
		}

		/// <summary>
		/// 	Add affiliates without specifying a valid SG address in ticket
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 		Specify a zero SG addr on the internet port of FD.
		/// 	</Description>
		/// 	<Verify>
        /// 		Affiliates list size should not change.
		/// 	</Verify>
		/// </remarks>
		[TestCase]
		public void N_AddAffiliates_Zero_SGAddr()
		{
            _queryReply = _state.LoadExternal(20, false, (uint)AffiliateFlags.CompletedGame);
            uint results = _queryReply.cdwResults;
            
            PMsgAddAffiliates req = new PMsgAddAffiliates(
					_validOnline, 
					(uint)AffiliateFlags.CompletedGame,
					_titleId, 
					new PNUser[]{_validLoggedOff});

			req.Msg.Hdr.Sgaddr.inaSg = 0;
			req.Msg.Hdr.Sgaddr.SpiSg = 0;
			req.Msg.Hdr.Sgaddr.XboxID = 0;
			
            try
            {
                req.TransactFD();
                Global.RO.Error("Should not reach here, TransactFD should throw");
            }
            catch (XErrException e)
            {
                ValueCheck.TestHR("HR expected", HResult.XONLINE_E_SERVER_ERROR, e.XErr);
            }

            _queryReply = _state.LoadExternal(20, false, (uint)AffiliateFlags.CompletedGame);

            ValueCheck.Test("Reply length", results, _queryReply.cdwResults);
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\presencefunc\FuncDead.cs ===
using System;
using System.Threading;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.GI;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.Notification;
using xonline.common.protocol.SubNoti;
using xonline.common.community;

namespace PresenceTest
{
    /// <summary> 
    /// Functional Tests for DeadUser, DeadXbox and DeadSG internal->FD message types
    /// </summary>
    [TestGroup, TestFrequency("Regression"), TestCasePriority(3)]
    class FuncDead : PresenceTestBaseGroup
    {
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public void P_DeadXenon_Mainline()
        {
            PNUser u = CreateXenonUser(true);
            PNUser f = CreateXenonUser(true);

            _fc.MakeFriend(u, f);
            u.ProcessNotifications();
            f.ProcessNotifications();
            PNUser.BuddyInfo buddyInfo = f.GetBuddyInfo(u.UserId);
            ValueCheck.Test("BuddyInfo.State", u.State, buddyInfo.BasicPresenceData.State);

            //Ask the SG to kick off the xbox
            GlobalFakeSG.FakeSG.DeadXbox(u.Xbox.XboxId);

            UserNotification noti = f.WaitForUserNotifications(DATA_TYPES.eBasicPresence);
            f.HandleTCPNotification(noti);

            buddyInfo = f.GetBuddyInfo(u.UserId);
            ValueCheck.Test("BuddyInfo.RichPresence.State", 0, buddyInfo.BasicPresenceData.State);
        }

        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public void P_DeadUser_Mainline()
        {
            PNUser u = CreateXenonUser(true);
            PNUser f = CreateXenonUser(true);

            _fc.MakeFriend(u, f);

            u.ProcessNotifications();
            f.ProcessNotifications();
            
            PNUser.BuddyInfo buddyInfo = f.GetBuddyInfo(u.UserId);
            ValueCheck.Test("BuddyInfo.State", u.State, buddyInfo.BasicPresenceData.State);

            u.Disconnect();

            UserNotification noti = f.WaitForUserNotifications(DATA_TYPES.eBasicPresence);
            f.HandleTCPNotification(noti);

            buddyInfo = f.GetBuddyInfo(u.UserId);
            ValueCheck.Test("BuddyInfo.State", 0, buddyInfo.BasicPresenceData.State);
        }

        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public void P_DeadUser_FriendStateUpdate()
        {
            PNUser a = CreateXenonUser(true);
            PNUser b = CreateXenonUser(true);
            PNUser f = CreateXenonUser(true);
            PNUser g = CreateXenonUser(true);

            P_DeadUser_FriendStateUpdate_Scenario("xenon->xenon", a, b, true);
        }

        void P_DeadUser_FriendStateUpdate_Scenario(string name, PNUser a, PNUser b, bool xenonPres)
        {
            Global.RO.Info("Running P_DeadUser_FriendStateUpdate_Scenario: {0}...", name);

            _fc.MakeFriend(a, b);
            a.Disconnect();

            UserNotification noti = b.WaitForUserNotifications(DATA_TYPES.eBasicPresence);
            b.HandleTCPNotification(noti);

            PNUser.BuddyInfo bi = b.GetBuddyInfo(a.UserId);
            ValueCheck.TestNotNull("BuddyInfo", bi);
            ValueCheck.TestNotNull("BuddyInfo.RichPresence", bi.RichPresenceData);
            ValueCheck.Test("BuddyInfo.RichPresence.State not online", true, 0 == (bi.BasicPresenceData.State & XonPresNoti.P_STATE_MASK_ONLINE));
        }


        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public void P_DeadUser_Xenon_PeerAndFriend_StateUpdate()
        {
            PNUser a = CreateXenonUser(true);
            PNUser b = CreateXenonUser(true);
            PNUser c = CreateXenonUser(true);

            _fc.MakeFriend(a, b);

            // Get the initial peer subscribe notification
            a.PeerSubscribeEx(new PNUser[]{c});

            a.ProcessNotifications();
            b.ProcessNotifications();
            c.ProcessNotifications();
            ValueCheck.TestBits("Buddy state bits", a.GetBuddyInfo(b.UserId).BasicPresenceData.State, b.State);
            ValueCheck.TestBits("Peer state bits", a.GetPeerInfo(c.UserId).BasicPresenceData.State, c.State);

            // Disconnect the peer and friend
            b.Disconnect();
            c.Disconnect();
            System.Threading.Thread.Sleep(1000);
            UserNotification noti = a.WaitForUserNotifications(DATA_TYPES.eBasicPresence);
            a.HandleTCPNotification(noti);

            a.ProcessNotifications();

            ValueCheck.Test("Buddy state bits", a.GetBuddyInfo(b.UserId).BasicPresenceData.State, 0);
            ValueCheck.Test("Peer state bits", a.GetPeerInfo(c.UserId).BasicPresenceData.State, 0);
        }

        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public void P_DeadUser_GetPresenceInfo()
        {
            PNUser a = CreateXenonUser(true);
            PNUser b = CreateXenonUser(true);

            // Disconnect one user
            a.Disconnect();

            // Lookup the presence data
            PresenceInfo info = b.GetPresenceInfo(a);   
            ValueCheck.Test("Deaduser.OnlineState", 0, info.OnlineState);
            ValueCheck.Test("Deaduser.SessionID", 0, info.qwSessionID); 
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\presencefunc\FuncDeleteBuddy.cs ===
using System;
using System.Collections;

using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.Notification;
using ServerTestFramework.LiveService.PresNotiCommon;


namespace PresenceTest
{
    [TestGroup, TestFrequency("Regression"), TestCasePriority(3), AsyncGroup(1, 0)]
    class FuncDeleteBuddy : PresenceTestBaseGroup
    {
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public void P_DeleteMainline()
        {
            PNUser a = CreateXenonUser(true);
            PNUser b = CreateXenonUser(true);
            _fc.MakeFriend(a, b);
            a.DeleteBuddy(b);


            QValPacket qval = null;
            PNUser.BuddyInfo biAB = null;
            PNUser.BuddyInfo biBA = null;

            qval = a.WaitForQFlags(XonPresNoti.QFLAG_MASK_LIST_CHANGE);
            a.HandleQValPacket(qval);

            qval = b.WaitForQFlags(XonPresNoti.QFLAG_MASK_LIST_CHANGE);
            b.HandleQValPacket(qval);

            // make sure the buddy is gone from qval
            biAB = a.GetBuddyInfo(b.UserId);
            biBA = b.GetBuddyInfo(a.UserId);

            if (null != biAB || null != biBA)
            {
                throw new UnexpectedTestResultException("Buddy relationship was still established after delete");
            }

            _fc.LogoffUser(a);
            _fc.LogoffUser(b);
            _fc.LogonUser(a);
            _fc.LogonUser(b);

            // make sure the buddy is gone after re-logon
            biAB = a.GetBuddyInfo(b.UserId);
            biBA = b.GetBuddyInfo(a.UserId);

            if (null != biAB || null != biBA)
            {
                throw new UnexpectedTestResultException("Buddy relationship was still established after re-logon");
            }
        }

        [TestCase, TestFrequency("BVT"), TestCasePriority(2)]
        public void P_DeletePending()
        {
            PNUser.BuddyInfo biAB = null;
            PNUser.BuddyInfo biBA = null;
            PNUser a = CreateCleanXenonUser(true);
            PNUser b = CreateCleanXenonUser(true);
            //Get  Inboxes.
            UserMsgFolder folderA = new UserMsgFolder(a);
            UserMsgFolder folderB = new UserMsgFolder(b);

            //Send a friend request.
            _fc.RequestFriend(a, b);
       
            //Verify relationship locally
            biAB = a.GetBuddyInfo(b.UserId);
            biBA = b.GetBuddyInfo(a.UserId);

            if (biAB.Status != XonPresNoti.P_BUDDY_STATUS_PENDING)
                throw new UnexpectedTestResultException("Invalid BuddyInfo status: " + biAB.Status);

            if (biBA.Status != XonPresNoti.P_BUDDY_STATUS_REQUEST)
                throw new UnexpectedTestResultException("Invalid BuddyInfo status: " + biBA.Status);

            ValueCheck.Test("FolderA Load() count", (uint)0, folderA.Load2());
            ValueCheck.Test("FolderB Load() count", (uint)1, folderB.Load2());

            // Remove the pending request
            _fc.DeleteFriend(a, b);

            //Verify relationship locally
            biAB = a.GetBuddyInfo(b.UserId);
            biBA = b.GetBuddyInfo(a.UserId);

            if (biAB != null && biBA != null)
                throw new UnexpectedTestResultException("Why are we still buddy?");

            ValueCheck.Test("FolderA Load() count", (uint)0, folderA.Load2());
            ValueCheck.Test("FolderB Load() count", (uint)0, folderB.Load2());
        }

        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public void P_DeleteRequested()
        {
            PNUser.BuddyInfo biAB = null;
            PNUser.BuddyInfo biBA = null;

            PNUser a = CreateCleanXenonUser(true);
            PNUser b = CreateCleanXenonUser(true);
            //Get  Inboxes.
            UserMsgFolder folderA = new UserMsgFolder(a);
            UserMsgFolder folderB = new UserMsgFolder(b);

            //Send a friend request.
            _fc.RequestFriend(a, b);

            //Verify relationship locally
            biAB = a.GetBuddyInfo(b.UserId);
            biBA = b.GetBuddyInfo(a.UserId);

            if (biAB.Status != XonPresNoti.P_BUDDY_STATUS_PENDING)
                throw new UnexpectedTestResultException("Invalid BuddyInfo status: " + biAB.Status);

            if (biBA.Status != XonPresNoti.P_BUDDY_STATUS_REQUEST)
                throw new UnexpectedTestResultException("Invalid BuddyInfo status: " + biBA.Status);

            ValueCheck.Test("FolderA Load() count", (uint)0, folderA.Load2());
            ValueCheck.Test("FolderB Load() count", (uint)1, folderB.Load2());

            // Remove the pending request
            _fc.DeleteFriend(b,a);

            //Verify relationship locally
            biAB = a.GetBuddyInfo(b.UserId);
            biBA = b.GetBuddyInfo(a.UserId);

            if (biAB != null && biBA != null)
                throw new UnexpectedTestResultException("Why are we still buddy?");

            ValueCheck.Test("FolderA Load() count", (uint)0, folderA.Load2());
            ValueCheck.Test("FolderB Load() count", (uint)0, folderB.Load2());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\presencefunc\FuncFindUser.cs ===
using System;
using System.Collections;
using System.Threading;
using System.Text;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Notification;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.GI;
using ServerTestFramework.LiveService.FakeSG;


namespace PresenceTest
{
	/// <summary>
	/// Positive Functional Tests for FindUser
	/// </summary>
    [TestGroup, TestFrequency("Daily"), TestCasePriority(2), AsyncGroup(1, 0)]
    class FuncFindUser_PositiveCases : PresenceTestBaseGroup
	{
		PNUser []_Users;

		public override void Setup()
		{
            base.Setup();
			_Users = new PNUser[4];
			_Users[0] = CreateXenonUser(true);		
			_Users[1] = CreateXenonUser(true);		
			_Users[2] = CreateXenonUser(true);		
			_Users[3] = CreateXenonUser(true);		

			new SleepInfo("Waiting for xcache", 30 * 1000); 
		}

		public static PFindUserReplyMsgData FindUser(ulong userId, string gamertag, PNUser sender, PNUser expected)
		{
			PMsgFindUser req = new PMsgFindUser(sender, userId, gamertag);
			PNMsg rep = null;
            req.TransactFD(out rep);

			ValueCheck.TestNotNull("Reply", rep);
			ValueCheck.TestNotNull("Reply.Data", rep.Data);
			PFindUserReplyMsgData data = (PFindUserReplyMsgData)rep.Data;

			if(null != expected)
			{
				ValueCheck.Test("FoundID", expected.UserId, data.FoundID);
				ValueCheck.Test("FoundName", expected.Name, data.GamerTag);
			}
			else
			{
				ValueCheck.Test("FoundID", 0, data.FoundID);
				ValueCheck.Test("FoundName", "", data.GamerTag);
			}

			return data;
		}	

		[TestCase]
		public void P_FindUser_ById()
		{
			FindUser(_Users[1].UserId, "", _Users[0], _Users[1]);
		}

		[TestCase]
		public void P_FindUser_ByName()
		{
			FindUser(0, _Users[1].Name, _Users[0], _Users[1]);
		}

		[TestCase]
		public void P_FindUser_MixedCase()
		{
			FindUser(0, _Users[1].Name.ToLower(), _Users[0], _Users[1]);
			FindUser(0, _Users[1].Name.ToUpper(), _Users[0], _Users[1]);
		}

		[TestCase]
		public void P_FindUser_FromMultiplePartitions()
		{
			FindUser(0, _Users[1].Name.ToUpper(), _Users[0], _Users[1]);
			FindUser(0, _Users[2].Name.ToUpper(), _Users[0], _Users[2]);
			FindUser(0, _Users[3].Name.ToUpper(), _Users[0], _Users[3]);
		}

		[TestCase]
		public void P_FindUser_FindBogusPuid()
		{
			FindUser(_Users[1].UserId | 0x7000000000000000, "", _Users[0], null);
		}

		[TestCase]
		public void P_FindUser_FindBogusName()
		{
			FindUser(0, "N0SUChU53R9161", _Users[0], null);
		}

		[TestCase]
		public void N_FindUser_FindZeroPuidNoName()
		{
			FindUser(0, "", _Users[0], null);
		}

		
		[TestCase]
		public void P_FindUser_FindBogusPuidBogusName()
		{
			FindUser(0xaa00123400001234, "N0SUChU53R9161", _Users[0], null);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\presencefunc\FuncBlock.cs ===
using System;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.Notification;
using ServerTestFramework.LiveService.PresNotiCommon;
using xonline.common.protocol.SubNoti;
namespace PresenceTest
{
    //TODO: We need new test cases for Block.
	public class BlockTestBaseGroup : PresenceTestBaseGroup
	{
		protected void CreateXenonUsers(out PNUser a, out PNUser b)
		{
			CreateXenonUsers(out a, out b, false);
		}
		protected void CreateXenonUsers(out PNUser a, out PNUser b, bool friends)
		{
			a = CreateXenonUser(true);
			b = CreateXenonUser(true);

			if(friends)
			{
				_fc.MakeFriend(a, b);
			}
		}
	}

	/// <summary>
	/// Functional Tests for Block
	/// </summary>
    [TestGroup, AsyncGroup(1, 0), TestFrequency("Regression"), TestCasePriority(3)]
	public class FuncBlock_PositiveCases : BlockTestBaseGroup
	{
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
		public void P_Block_TitleCustomMessage()
		{
			PNUser a, b; 
			CreateXenonUsers(out a, out b, false);

			a.Mute(b);

			// For 5 seconds make sure that user A has read and deleted all of his messages
			// that he receives a notification for.
			a.ProcessNotifications();

			// Send a new message from user b to user a
			UserMessage msg = UserMessage.CreateTitleCustomMsg(b);
			uint msgId = msg.Send(b, a);

			Global.RO.Info("Send custom message: {0:x}", msgId);

			// message should be received
			QValPacket qval = a.WaitForNewMessageType(XonPresNoti.MSG_TYPE_TITLE_CUSTOM);
			uint recvMsgId = qval.FirstMessageIdMatchingType(XonPresNoti.MSG_TYPE_TITLE_CUSTOM);
		}

        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
		public void P_Block_Invites()
		{
			PNUser a, b; 
			CreateXenonUsers(out a, out b, false);
			a.Mute(b);

			// For 5 seconds make sure that user A has read and deleted all of his messages
			// that he receives a notification for.
			a.ProcessNotifications();

			b.Invite(new PNUser[]{a}, 0xaaaabbbbccccdddd);

			// message should be received
			QValPacket qval = a.WaitForNewMessageType(XonPresNoti.MSG_TYPE_GAME_INVITE);
			uint recvMsgId = qval.FirstMessageIdMatchingType(XonPresNoti.MSG_TYPE_GAME_INVITE);
		}

        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
		public void P_Block_Friends()
		{
			PNUser a, b; 
			CreateXenonUsers(out a, out b, false);

			a.Mute(b);

			// For 5 seconds make sure that user A has read and deleted all of his messages
			// that he receives a notification for.
			a.ProcessQVals(5, PNUser.HQV_DeleteMessages|PNUser.HQV_ReadMessages);

			// Send a new friend request from user b to user a
			b.AddBuddy(a);	

			// message should be received
			QValPacket qval = a.WaitForNewMessageType(XonPresNoti.MSG_TYPE_FRIEND_REQUEST);
			uint recvMsgId = qval.FirstMessageIdMatchingType(XonPresNoti.MSG_TYPE_FRIEND_REQUEST);
		}

		/// <summary>
		/// 	Block the same user twice
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 	</Description>
		/// 	<Verify>
		/// 	</Verify>
		/// </remarks>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
		public void  P_Twice_Check_Updated_Time()
		{
			PNUser user1 = CreateXenonUser(true);
			PNUser user2 = CreateXenonUser(true);

			PMsgBlockVoice blockMsg = new PMsgBlockVoice( user1, user2 );
            blockMsg.TransactFD();
            Thread.Sleep(2000);
			LockoutInfo []locks = null;
			
			locks = UodbWS.GetLockoutList(user1.UserId);
			ValueCheck.Test("Lockout list length", 1, locks.Length);
			ValueCheck.Test("Lockout item user", user1.UserId, locks[0].UserPuid);
			ValueCheck.Test("Lockout item locked", user2.UserId, locks[0].LockoutPuid);
			DateTime changed = locks[0].Changed;

			// Make sure we don't add another entry and that the changed time is updated
            blockMsg.TransactFD();
            Thread.Sleep(2000);
			locks = UodbWS.GetLockoutList(user1.UserId);
			ValueCheck.Test("Lockout list length", 1, locks.Length);
			ValueCheck.Test("Lockout item user", user1.UserId, locks[0].UserPuid);
			ValueCheck.Test("Lockout item locked", user2.UserId, locks[0].LockoutPuid);
            ValueCheck.TestGreaterThan("Lockout item change time", changed, locks[0].Changed);
		}

        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public void P_Block_Unblock()
        {
            PNUser user1 = CreateXenonUser(true);
            PNUser user2 = CreateXenonUser(true);

            PMsgBlockVoice blockMsg = new PMsgBlockVoice(user1, user2);
            blockMsg.TransactFD();
            Thread.Sleep(2000);
            LockoutInfo[] locks = null;

            locks = UodbWS.GetLockoutList(user1.UserId);
            ValueCheck.Test("Lockout list length", 1, locks.Length);
            ValueCheck.Test("Lockout item user", user1.UserId, locks[0].UserPuid);
            ValueCheck.Test("Lockout item locked", user2.UserId, locks[0].LockoutPuid);

            user1.UnMute(user2);
            Thread.Sleep(2000);
            locks = null;
            locks = UodbWS.GetLockoutList(user1.UserId);
            ValueCheck.Test("Lockout list length", 0, locks.Length);
        }

        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public void P_Block_UnblockAll()
        {
            PNUser user1 = CreateXenonUser(true);
            PNUser user2 = CreateXenonUser(true);
            PNUser user3 = CreateXenonUser(true);

            user1.Mute(user2);
            user1.Mute(user3);
            Thread.Sleep(2000);
            LockoutInfo[] locks = null;
            locks = UodbWS.GetLockoutList(user1.UserId);
            ValueCheck.Test("Lockout list length", 2, locks.Length);

            user1.UnMuteAll();
            locks = null;
            locks = UodbWS.GetLockoutList(user1.UserId);
            ValueCheck.Test("Lockout list length", 0, locks.Length);
        }
	}

    [TestGroup, TestFrequency("Regression"), TestCasePriority(3), AsyncGroup(1, 0)]
    public class FuncBlock_NegativeCases : BlockTestBaseGroup
	{
		[TestCase]
		public void N_Block_Zero_Sender()
		{
		}

		[TestCase]
		public void N_Block_Zero_Target()
		{
		}

		[TestCase]
		public void N_Block_Self()
		{
			PNUser user1 = CreateXenonUser(true);
			PNUser user2 = CreateXenonUser(true);

			user1.Mute(user1); //self mute.

			Thread.Sleep(2000);
			LockoutInfo[] locks = null;
			locks = UodbWS.GetLockoutList(user1.UserId);
            ValueCheck.Test("Lockout list length", 1, locks.Length); //Apparently you are allowed to block your self. :(

			// For 5 seconds make sure that user A has read and deleted all of his messages
			// that he receives a notification for.
			user1.ProcessQVals(5, PNUser.HQV_DeleteMessages | PNUser.HQV_ReadMessages);

			// Send a new friend request from user b to user a
			user2.AddBuddy(user1);

			// message should be received
			QValPacket qval = user1.WaitForNewMessageType(XonPresNoti.MSG_TYPE_FRIEND_REQUEST);
			uint recvMsgId = qval.FirstMessageIdMatchingType(XonPresNoti.MSG_TYPE_FRIEND_REQUEST);

                        // self mute again. see if lockout list number is updated.
			user1.Mute(user1); //self mute.
			locks = UodbWS.GetLockoutList(user1.UserId);
                        ValueCheck.Test("Lockout list length", 2, locks.Length); //Apparently you are allowed to block your self. :(
		}

		[TestCase]
		public void N_Block_Invalid_Sender()
		{
		}

		[TestCase]
		public void N_Block_Invalid_Target()
		{
		}

		[TestCase]
		public void N_Block_Invalid_SgAddr()
		{
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\presencefunc\FuncChangeGamertag.cs ===
using System;
using System.Net;
using System.Collections;
using System.Net.Sockets;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.Notification;
using ServerTestFramework.LiveService.PresNotiCommon;
using xonline.common.protocol.SubNoti;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.Billing;
using ServerTestFramework.LiveService.Billing.License;
using ServerTestFramework.LiveService.Billing.DRM;
using xonline.common.config;

namespace PresenceTest
{
    /// <summary>
    /// Functional Tests for Block
    /// </summary>
    [TestGroup, AsyncGroup(1, 0), TestFrequency("Regression"), TestCasePriority(3)]
    public class FuncChangeGamertag : PresenceTestBaseGroup
    {
        /// <summary>
        /// Steps:
        /// 1. Make a user and friends
        /// 2. Make them friends
        /// 3. Log all of them in.
        /// 4. Change a gamertag of u
        /// 5. relogon u
        /// 6. relogon friends and verify that they have new gamertag for a buddy
        /// </summary>
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
        public void P_ChangeGamertag()
        {
            XeUser user = XbosUser.XenonGoldUser();
            XbosOffer.RewardUSUser1600Points(user);

            PNUser u = new PNUser(user.Gamertag, user.UserPuid);
            PNUser[] friends =  _fc.CreateXenonUsers(100, false);

            //make them friends.
            foreach (PNUser friend in friends)
            {
                _fc.MakeFriendFast(u.UserId, friend.UserId);
            }

            //log them on.
            _fc.LogonUser(u, true);
            foreach (PNUser friend in friends)
            {
                _fc.LogonUser(friend, true);
            }

            //change gamertag.
            string oldtag = u.Name;
            string newtag = changegamertag(u);
            Global.RO.Info( String.Format( "Old: {0} ; New: {1}", oldtag, newtag));
            //log off everyone.
            try
            {
                _fc.LogoffUser(u);
            }
            catch{}

            GlobalFakeSG.FakeSG.DeadXbox(u.Xbox.XboxId);
            u.Xbox = null;

            foreach (PNUser friend in friends)
            {
                try
                {
                    _fc.LogoffUser(friend);
                }
                catch { }
            }
            

            //wait for xcache.
            FriendsCommon.WaitForXCache();

            //now log on everyone.
            u = new PNUser (newtag, u.UserId); //after gamertag change need to recreate u.
            _fc.LogonUser(u, true);
            foreach (PNUser friend in friends)
            {
                _fc.LogonUser(friend, true);
            }

            //verify for each friend.
            foreach (PNUser friend in friends)
            {
                IDictionaryEnumerator enumerator = friend.BuddyEnumerator;
                while (enumerator.MoveNext())
                {
                    PNUser.BuddyInfo bi = enumerator.Value as PNUser.BuddyInfo;
                    if (bi.Name != newtag)
                        throw new Exception("Gamertag change is not reflected on buddy: Expected: " + newtag + " current: " + bi.Name);
                }
            }
        }

        public static string changegamertag(PNUser u)
        {
            XRLXeOfferPurchaseGamertag request = new XRLXeOfferPurchaseGamertag();
            XRLXeOfferPurchaseGamertagResponse response = new XRLXeOfferPurchaseGamertagResponse();

            RandomEx rnd = new RandomEx();
            string newGamerTag = rnd.GenerateRandomString("XEC", 15);

            request.UserPuid = u.UserId;
            request.MachinePuid = u.Xbox.XboxId;
            request.PaymentType = (uint)PaymentTypeEnum.Points;
            request.Gamertag = newGamerTag;
            request.Slot.titleId = XOn.XENON_DASH_TITLE_ID;

            int numChanges = UodbWS.GetGamerTagChanges(u.UserId).Length;

            Global.RO.Info("Changing user 0x" + u.UserId.ToString("X") + " gamertag from " + u.Name + " to " + newGamerTag);
            if (!request.Execute(out response))
                throw new UnexpectedTestResultException("XRLXeOfferPurchaseGamertag failed: " + request.GetDumpString());
            if (request.XErr != HResult.S_OK)
                throw new UnexpectedTestResultException(String.Format("XRLXeOfferPurchaseGamertag returned XErr=0x{0:x}", request.XErr));

            return newGamerTag;
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\presencefunc\FuncFindUsers.cs ===
using System;
using System.Collections;
using System.Threading;
using System.Text;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Notification;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.GI;
using ServerTestFramework.LiveService.FakeSG;
using xonline.common.diagnostics;


namespace PresenceTest
{
	/// <summary>
	/// Functional Tests for FindUsers
	/// </summary>
    [TestGroup, TestFrequency("Regression"), TestCasePriority(3), AsyncGroup(1, 0)]
    class FuncFindUsers_Cases : PresenceTestBaseGroup
	{
        PNUser emptyUser;
		PNUser[] _Users;
        ulong[]  _TargetIDs;
        string[] _TargetGTs;

		public override void Setup()
		{
            base.Setup();
            _Users     = new PNUser[101];
            _TargetIDs = new ulong[_Users.Length];
            _TargetGTs = new string[_Users.Length];

            for (int iTarget = 0; iTarget < _Users.Length; iTarget++)
            {
                _Users[iTarget]     = CreateXenonUser(true);
                _TargetIDs[iTarget] = _Users[iTarget].UserId;
                _TargetGTs[iTarget] = _Users[iTarget].Name;
            }

            emptyUser = new PNUser("", 0);
		}

		private PFindUsersReplyMsgData FindUsers(ulong[] userIds, string[] gamertags, PNUser sender, PNUser[] expected)
		{
			PMsgFindUsers req = new PMsgFindUsers(sender, userIds, gamertags);
			PNMsg rep = null;
            PFindUsersReplyMsgData pReplyData = null;
            req.TransactFD(out rep);

			ValueCheck.TestNotNull("Reply", rep);
			ValueCheck.TestNotNull("Reply.Data", rep.Data);
            pReplyData = (PFindUsersReplyMsgData)(rep.Data);

            Assert.IsTrue(pReplyData.cdwResults == expected.Length, "incorrect number of results returned: " + pReplyData.cdwResults.ToString());
            for (int iResult = 0; iResult < expected.Length; iResult++)
            {
                Assert.IsTrue(pReplyData.rgResults[iResult].FindID == expected[iResult].UserId, "FindUser failed, user " + iResult.ToString() + " PUID is not equal");
                Assert.IsTrue(pReplyData.rgResults[iResult].GamerTag == expected[iResult].Name, "FindUser failed, user " + iResult.ToString() + " Name is not equal");
            }

            return pReplyData;
		}

        private void GetArrays(out PNUser[] Users, out string[] GamerTags, uint NumGamerTags, out ulong[] IDs, uint NumIDs, bool GTFirst)
        {
            uint NumUsers = NumGamerTags + NumIDs;
            Assert.IsTrue( NumUsers <= _Users.Length, "GetArrays: Request for too many users");
            GamerTags = new string[NumUsers];
            IDs = new ulong[NumUsers];
            Users = new PNUser[NumUsers];
            Array.Copy(_Users, Users, NumUsers);
            if (GTFirst)
            {
                Array.Copy(_TargetGTs, 0, GamerTags, 0, NumGamerTags);
                Array.Copy(_TargetIDs, NumGamerTags, IDs, NumGamerTags, NumIDs);
            }
            else
            {
                Array.Copy(_TargetIDs, 0, IDs, 0, NumIDs);
                Array.Copy(_TargetGTs, NumIDs, GamerTags, NumIDs, NumGamerTags);
            }
        }

        private PNUser[] GetUsers(ulong[] IDs, string[] GamerTags, PNUser[] Valid)
        {
            Assert.IsTrue(GamerTags.Length == IDs.Length, "GetUsers: GamerTags and IDs not the same length");
            PNUser[] users = new PNUser[GamerTags.Length];
            for (int cUser = 0; cUser < GamerTags.Length; cUser++)
            {
                if (Valid != null)
                {
                    foreach (PNUser user in Valid)
                    {
                        if (user.UserId == IDs[cUser] || (IDs[cUser] == 0 && user.Name == GamerTags[cUser]))
                        {
                            // valid user
                            users[cUser] = user;
                            break;
                        }
                    }
                }
                if (users[cUser] == null)
                {
                    // 0 returned with ""
                    users[cUser] = emptyUser;
                }
            }
            return users;
        }

        private void RunTest(uint NumGamerTags, uint NumIDs, bool GTFirst)
        {
            PNUser[] users;
            string[] GTs;
            ulong[] IDs;
            GetArrays(out users, out GTs, NumGamerTags, out IDs, NumIDs, GTFirst);
            FindUsers(IDs, GTs, _Users[0], users);
        }

        private void RunNegativeTest(uint NumGamerTags, uint NumIDs, bool GTFirst)
        {
            try
            {
                RunTest(NumGamerTags, NumIDs, GTFirst);
            }
            catch (XErrException ex)
            {
                if (ex.XErr != 0x80150028) // XONLINE_E_DESERIALIZATION_ERROR
                {
                    throw ex;
                }
            }
        }

        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public void N_FindUsers_None()
        {
            RunNegativeTest(0, 0, true);
        }

        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
		public void P_FindUsers_ById()
		{
            RunTest(0, 50, true);
		}

        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public void P_FindUsers_ByName()
        {
            RunTest(50, 0, true);
        }

        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public void P_FindUsers_Mixed()
        {
            RunTest(25, 25, true);
            RunTest(25, 25, false);
        }

        [TestCase]
        public void P_FindUsers_MaxById()
        {
            RunTest(0, 100, true);
        }

        [TestCase]
        public void P_FindUsers_MaxByName()
        {
            RunTest(100, 0, true);
        }

        [TestCase]
        public void P_FindUsers_MaxMixed()
        {
            RunTest(50, 50, true);
            RunTest(50, 50, false);
        }

        [TestCase]
        public void N_FindUsers_OverMaxById()
        {
            RunNegativeTest(0, 101, true);
        }

        [TestCase]
        public void N_FindUsers_OverMaxByName()
        {
            RunNegativeTest(101, 0, true);
        }

        [TestCase]
        public void N_FindUsers_OverMaxMixed()
        {
            RunNegativeTest(51, 50, true);
            RunNegativeTest(51, 50, false);
        }


        [TestCase]
        public void P_FindUser_MixedCase()
        {
            ulong[] IDs = new ulong[] { 0, 0 };
            string[] GamerTags = new string[] { _Users[1].Name.ToUpper(), _Users[1].Name.ToLower() };
            FindUsers(IDs, GamerTags, _Users[0], new PNUser[] { _Users[1], _Users[1] } );
        }

        [TestCase]
        public void P_FindUsers_FindZeroPuidEmptyName()
        {
            ulong[] IDs = new ulong[] { 0 };
            string[] GamerTags = new string[] { "" };
            FindUsers(IDs, GamerTags, _Users[0], GetUsers(IDs, GamerTags, null));
        }
   		
        [TestCase]
        public void P_FindUsers_BogusPuidEmptyName()
        {
            ulong [] IDs = new ulong[] { 0xaa00123400001234 };
            string [] GamerTags = new string[] { "" };
            FindUsers(IDs, GamerTags, _Users[0], GetUsers(IDs, GamerTags, null));
        }

        [TestCase]
        public void P_FindUsers_ZeroPuidBogusName()
        {
            ulong [] IDs = new ulong[] { 0 };
            string [] GamerTags = new string[] { "N0SUChU53R9161" };
            FindUsers(IDs, GamerTags, _Users[0], GetUsers(IDs, GamerTags, null));
        }

        [TestCase]
        public void P_FindUsers_BogusPuidBogusName()
        {
            ulong [] IDs = new ulong[] { 0xaa00123400001234 };
            string [] GamerTags = new string[] { "N0SUChU53R9161" };
            FindUsers(IDs, GamerTags, _Users[0], GetUsers(IDs, GamerTags, null));
        }

        [TestCase]
        public void P_FindUsers_BogusPuidBogusNameSeparate()
        {
            ulong [] IDs = new ulong[] { 0xaa00123400001234, 0 };
            string [] GamerTags = new string[] { "", "N0SUChU53R9161" };
            FindUsers(IDs, GamerTags, _Users[0], GetUsers(IDs, GamerTags, null));
        }

        [TestCase]
        public void P_FindUsers_BogusPuidsEmptyNames()
        {
            ulong[] IDs = new ulong[] { 0xaa00123400001234, 0xaa00123400001235 };
            string[] GamerTags = new string[] { "", "" };
            FindUsers(IDs, GamerTags, _Users[0], GetUsers(IDs, GamerTags, null));
        }

        [TestCase]
        public void P_FindUsers_ZeroPuidsBogusNames()
        {
            ulong[] IDs = new ulong[] { 0, 0 };
            string[] GamerTags = new string[] { "N0SUChU53R9161", "N0SUChU53R9162" };
            FindUsers(IDs, GamerTags, _Users[0], GetUsers(IDs, GamerTags, null));
        }

        [TestCase]
        public void P_FindUsers_BogusPuidsBogusNames()
        {
            ulong[] IDs = new ulong[] { 0xaa00123400001234, 0xaa00123400001235 };
            string[] GamerTags = new string[] { "N0SUChU53R9161", "N0SUChU53R9162" };
            FindUsers(IDs, GamerTags, _Users[0], GetUsers(IDs, GamerTags, null));
        }

        [TestCase]
        public void P_FindUsers_BogusPuidsBogusNamesSeparate()
        {
            ulong[] IDs = new ulong[] { 0xaa00123400001234, 0xaa00123400001235, 0, 0 };
            string[] GamerTags = new string[] {"","", "N0SUChU53R9161", "N0SUChU53R9162" };
            FindUsers(IDs, GamerTags, _Users[0], GetUsers(IDs, GamerTags, null ));

            IDs = new ulong[] { 0xaa00123400001234,  0, 0, 0xaa00123400001235 };
            GamerTags = new string[] {"", "N0SUChU53R9161", "N0SUChU53R9162", "" };
            FindUsers(IDs, GamerTags, _Users[0], GetUsers(IDs, GamerTags, null));

            IDs = new ulong[] { 0, 0, 0xaa00123400001235, 0xaa00123400001234 };
            GamerTags = new string[] {"N0SUChU53R9161", "N0SUChU53R9162", "", "" };
            FindUsers(IDs, GamerTags, _Users[0], GetUsers(IDs, GamerTags, null));
        }

        [TestCase]
        public void P_FindUsers_BogusPuidsBogusNamesWithSingleValid()
        {
            ulong[] IDs = new ulong[] { 0xaa00123400001234, 0xaa00123400001235, _Users[1].UserId };
            string[] GamerTags = new string[] { "N0SUChU53R9161", "N0SUChU53R9162", "" };
            FindUsers(IDs, GamerTags, _Users[0], GetUsers(IDs, GamerTags, new PNUser[] { _Users[1] } ));

            IDs = new ulong[] { _Users[1].UserId, 0xaa00123400001234, 0xaa00123400001235 };
            GamerTags = new string[] { "", "", "" };
            FindUsers(IDs, GamerTags, _Users[0], GetUsers(IDs, GamerTags, new PNUser[] { _Users[1] }));

            IDs = new ulong[] { 0xaa00123400001234, _Users[1].UserId, 0 };
            GamerTags = new string[] { "", "", "N0SUChU53R9162" };
            FindUsers(IDs, GamerTags, _Users[0], GetUsers(IDs, GamerTags, new PNUser[] { _Users[1] }));
        }

        [TestCase]
        public void P_FindUsers_Duplicates()
        {
            ulong[] IDs = new ulong[] { _Users[1].UserId, _Users[1].UserId, _Users[2].UserId, _Users[3].UserId, _Users[2].UserId };
            string[] GamerTags = new string[] { "", "", "", "", "" };
            FindUsers(IDs, GamerTags, _Users[0], GetUsers(IDs, GamerTags, new PNUser[] { _Users[1], _Users[2], _Users[3] }));

            IDs = new ulong[] { 0, 0, 0, 0, 0 };
            GamerTags = new string[] { _Users[1].Name, _Users[1].Name, _Users[2].Name, _Users[3].Name, _Users[2].Name }; ;
            FindUsers(IDs, GamerTags, _Users[0], GetUsers(IDs, GamerTags, new PNUser[] { _Users[1], _Users[2], _Users[3] }));

        }

        // various valid with invalid data
        [TestCase]
        public void P_FindUsers_ValidInvalidCombinations()
        {
            ulong[] IDs = new ulong[] { _Users[1].UserId, 0xaa00123400001234, 0, 0 };
            string[] GamerTags = new string[] { "", "", _Users[2].Name, "N0SUChU53R9163" }; ;
            FindUsers(IDs, GamerTags, _Users[0], GetUsers(IDs, GamerTags, new PNUser[] { _Users[1], _Users[2] }));
        }
        
        [TestCase]
        public void P_FindUsers_ValidInvalidCombinationsSameIndex()
        {
            ulong[] IDs = new ulong[] { _Users[1].UserId, _Users[1].UserId, _Users[2].UserId, 0xaa00123400001234, 0xaa00123400001235 };
            string[] GamerTags = new string[] {"N0SUChU53R9161", "N0SUChU53R9162", _Users[2].Name, _Users[3].Name, _Users[2].Name }; ;
            FindUsers(IDs, GamerTags, _Users[0], GetUsers(IDs, GamerTags, new PNUser[] { _Users[1], _Users[2], _Users[3] }));
        }

        [TestCase]
        public void P_FindUsers_AllData()
        {
            ulong[] IDs = new ulong[] { _Users[1].UserId, _Users[1].UserId, _Users[2].UserId, _Users[3].UserId, _Users[2].UserId };
            string[] GamerTags = new string[] { _Users[1].Name, _Users[1].Name, _Users[2].Name, _Users[3].Name, _Users[2].Name }; ;
            FindUsers(IDs, GamerTags, _Users[0], GetUsers(IDs, GamerTags, new PNUser[] { _Users[1], _Users[2], _Users[3] }));
        }

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\presencefunc\FuncAPIEventCheck.cs ===

using System;
using System.Threading;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.GI;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.Notification;
using xonline.common.protocol.SubNoti;
using xonline.common.config;
using xonline.common.service;
using System.Diagnostics;

namespace PresenceTest
{
    class EventMgmtInterface
    {
        private EventLog evlog;

        public EventMgmtInterface(string eventlog, string machinename)
        {
            evlog = new EventLog(eventlog, machinename);
        }

        public bool IsExistingNow(string source, uint code)
        {
            EventLogEntry latest = null;
            foreach(EventLogEntry entry in evlog.Entries)
            {
                if (entry.Source == "xpnfd")
                   latest = entry;
            }
            if (latest.InstanceId == code)
                return true;
            return false;
        }
    }
    /// <summary> 
    /// Functional Tests for DeadUser, DeadXbox and LogonCheck APIs w.r.t events to be sent
    /// to them
    /// </summary>
    [TestGroup, DVT, TestFrequency("Regression"), TestCasePriority(3), Owner("mayankd")]
    class FuncAPIEventCheck : PresenceTestBaseGroup
	{
        [TestCase, Ignore]  
        public void LogonCheckZeroUserId()
        {
            PNUser user = CreateXenonUser(true);
            PMsgLogonCheck logoncheck = new PMsgLogonCheck(user, user.Xbox.XboxId);
            Global.RO.Info("Initiating 0 user id check");
            ((PLogonCheckMsgData)logoncheck.Msg.Data).UserID = 0;
            logoncheck.TransactFD();
            System.Threading.Thread.Sleep(1000);
            EventMgmtInterface evt = new EventMgmtInterface("Application",
                Config.GetVirtualInterface(VirtualInterface.xpnfd_presence).IPAddressString);
            ValueCheck.IsTrue(evt.IsExistingNow("xpnfd", XEvent.MessageFromId(XEvent.Id.PRESENCE_INVALID_USERID)),
                "Expected Event not raised on server");
            //Find a way to check eventviewer of target machine
        }

        [TestCase, Ignore]
        public void LogonCheckNullPresenceRecord()
        {
            PNUser user = CreateXenonUser(false);
            PMsgLogonCheck logoncheck = new PMsgLogonCheck(user, user.Xbox.XboxId);
            Global.RO.Info("Initiating Null Presence Record check");
            logoncheck.TransactFD();
            System.Threading.Thread.Sleep(1000);
            EventMgmtInterface evt = new EventMgmtInterface("Application",
                Config.GetVirtualInterface(VirtualInterface.xpnfd_presence).IPAddressString);
            ValueCheck.IsTrue(evt.IsExistingNow("xpnfd", XEvent.MessageFromId(XEvent.Id.PRESENCE_CACHE_NOTFOUND)),
                "Expected Event not raised on server");
            //Find a way to check eventviewer of target machine
        }

        [TestCase, Ignore]
        public void LogonCheck()
        {
            PNUser user = CreateXenonUser(true);
            PMsgLogonCheck logoncheck = new PMsgLogonCheck(user, user.Xbox.XboxId);
            Global.RO.Info("Initiating Presence Record check should be offline");
            PNMsg reply; 
            logoncheck.TransactFD(out reply);
            PLogonCheckReplyMsgData data = (PLogonCheckReplyMsgData)reply.Data;
            ValueCheck.IsTrue(data != null, "reply data should NOT be NULL");
            ValueCheck.IsTrue(data.HR == xonline.common.service.Win32ErrorCode.GetHResult(Win32ErrorCode.Codes.ERROR_NO_SUCH_USER),
                "Did not get E_NO_USER");
            //Find a way to check eventviewer of target machine
        }

        [TestCase, Ignore]
        public void DeadUserZeroUserId()
        {
            PNUser user = CreateXenonUser(true);
            PNMsgDeadUser deaduser = new PNMsgDeadUser(user);
            Global.RO.Info("Initiating 0 user id check");
            ((PNDeadUserMsgData)deaduser.Msg.Data).UserID = 0;
            deaduser.TransactFD();

            //Find a way to check eventviewer of target machine
            System.Threading.Thread.Sleep(1000);
            EventMgmtInterface evt = new EventMgmtInterface("Application",
                Config.GetVirtualInterface(VirtualInterface.xpnfd_presence).IPAddressString);
            ValueCheck.IsTrue(evt.IsExistingNow("xpnfd", XEvent.MessageFromId(XEvent.Id.PRESENCE_INVALID_USERID)),
                "Expected Event not raised on server");
        }

        [TestCase, Ignore]
        public void DeadUserNullPresenceRecord()
        {
            PNUser user = CreateXenonUser(false);
            PNMsgDeadUser deaduser = new PNMsgDeadUser(user);
            Global.RO.Info("Initiating Null presence record check");
            deaduser.TransactFD();
            Global.RO.Info("Check logs for null presence record and DeadUser return value in HResult");
        }

        [TestCase, Ignore]
        public void DeadXBox()
        {
            //TODO: Figure out how to post to the FD as expected.
            PNUser user = CreateXenonUser(false);
            GlobalFakeSG.FakeSG.DeadXbox(user.Xbox.XboxId);
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\presencefunc\FuncInvalidateUser.cs ===
using System;
using System.Collections;
using System.Threading;
using System.Text;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Notification;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.GI;
using ServerTestFramework.LiveService.FakeSG;


namespace PresenceTest
{
	/// <summary>
	/// Positive Functional Tests for InvalidateUser
	/// </summary>
    [TestGroup, TestFrequency("Regression"), TestCasePriority(3)]
	class FuncInvalidateUser_PositiveCases : PresenceTestBaseGroup
	{
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
		public void P_InvalidateUser_Mainline()
		{
			PNUser xenonUser = CreateXenonUser(true);
			PNUser xboxUser = CreateXenonUser(true);

			xenonUser.Invalidate();
			xboxUser.Invalidate();
		}

        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
		public void P_InvalidateUser_WithFriends()
		{
			PNUser user = CreateXenonUser(true);
			PNUser a = CreateXenonUser(true);
			PNUser b = CreateXenonUser(true);
			PNUser c = CreateXenonUser(true);
			PNUser d = CreateXenonUser(true);

			_fc.MakeFriend(user, a);
			_fc.MakeFriend(user, b);
			_fc.MakeFriend(user, c);
			_fc.MakeFriend(user, d);

			// Invalidate this user
			user.Invalidate();

			// Invalidate this user's friends
			a.Invalidate();
			b.Invalidate();
			c.Invalidate();
			d.Invalidate();
		}

		[TestCase]
		public void P_InvalidateUser_PeerSubscribeScenarios()
		{
			// Create users
			PNUser a = CreateXenonUser(true);
			PNUser b = CreateXenonUser(true);
			PNUser c = CreateXenonUser(true);

			// Subscribe
			b.PeerSubscribe(a);
			c.PeerSubscribe(a);

			// Invalidate
			a.Invalidate();
			b.Invalidate();
			c.Invalidate();
		}

		[TestCase]
		public void P_InvalidateUser_WithTransientMessages()
		{
			PNUser a = CreateXenonUser(true);
			PNUser b = CreateXenonUser(true);

			a.Invite(new PNUser[]{b}, (ulong)0xaaaabbbbccccdddd);
			b.Invalidate();
		}

        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
		public void P_InvalidateUser_OfflineUser()
		{
			PNUser user = CreateXenonUser(true);
			_fc.LogoffUser(user);
			user.Invalidate();
		}
	}

	/// <summary>
	/// Negative Functional Tests for InvalidateUser
	/// </summary>
    [TestGroup, TestFrequency("Regression"), TestCasePriority(3)]
	class FuncInvalidateUser_NegativeCases : PresenceTestBaseGroup
	{
		[TestCase]
		public void N_InvalidateUser_ZeroPuid()
		{
            PNUser user = null;
            try
            {
                user = new PNUser("Invalid", 0);
                PNXbox xbox = new PNXbox();
                user.Xbox = xbox;
                user.Invalidate();
            }
            finally
            {
                GlobalFakeSG.FakeSG.ClearXboxes();
                if (user != null && user.LoggedOn)
                {
                    user.Dispose();
                }
            }
		}

		[TestCase]
		public void N_InvalidateUser_NotInMemory()
		{
            // TODO: what does not in memory mean in the new system?
			PNUser user = CreateXenonUser(true);
			_fc.LogonUser(user);
			_fc.LogoffUser(user);
			//PNServers.SetCacheState(user, CacheState.NotInMemory);
			user.Invalidate();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\presencefunc\FuncGetPresenceInfo.cs ===
using System;
using System.Collections;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Notification;
using ServerTestFramework.LiveService.Presence;

namespace PresenceTest
{
    /// <summary>
    /// Positive functional tests for the GetPresenceInfo API.
    /// TODO: Add test cases around basic/rich presence content?
    /// TODO: Add test cases around privacy settings?
     /// </summary>
    [TestGroup, TestFrequency("Daily"), TestCasePriority(2), AsyncGroup(1, 0)]
    public class FuncGetPresenceInfo_PositiveCases : PresenceTestBaseGroup
    {
        void GetPIScenario(PNUser user, PNUser []targets)
        {
            PMsgGetPresenceInfo req = new PMsgGetPresenceInfo(user, targets);
            PNMsg rep;
            req.TransactFD(out rep);

            PPresenceInfoReplyMsgData data = (PPresenceInfoReplyMsgData)rep.Data;
            ValueCheck.Test("UserId", data.qwSenderID, user.UserId);
            ValueCheck.Test("UserCount", targets.Length, data.cdwUsers);
            for( int i = 0; i < targets.Length; ++i)
            {
                ValueCheck.Test("TargetXuid", targets[i].UserId, data.rgUsers[i].SenderID);
            }
        }

        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public void P_GetPI_Self()
        {
            PNUser user = CreateXenonUser(true);
            GetPIScenario(user, new PNUser[]{user});
        }

        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public void P_GetPI_Online_Friend()
        {
            PNUser user = CreateXenonUser(true);
            PNUser friend = CreateXenonUser(true);
            _fc.MakeFriend(user, friend);
            GetPIScenario(user, new PNUser[]{friend});
        }

        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public void P_GetPI_Online_NonFriend()
        {
            PNUser user = CreateXenonUser(true);
            PNUser nonfriend = CreateXenonUser(true);
            GetPIScenario(user, new PNUser[]{nonfriend});
        }
        
        [TestCase]
        public void P_GetPI_Online_Peer()
        {
            PNUser user = CreateXenonUser(true);
            PNUser nonfriend = CreateXenonUser(true);
            user.PeerSubscribe(new PNUser[]{nonfriend});
            GetPIScenario(user, new PNUser[]{nonfriend});
        }

        [TestCase]
        public void P_GetPI_Offline_NonFriend()
        {
            PNUser user = CreateXenonUser(true);
            PNUser nonfriend = CreateXenonUser(false);
            GetPIScenario(user, new PNUser[]{nonfriend});
        }

        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public void P_GetPI_Offline_Friend()
        {
            PNUser user = CreateXenonUser(true);
            PNUser friend = CreateXenonUser(true);
            _fc.MakeFriend(user, friend);
            friend.Disconnect();
            GetPIScenario(user, new PNUser[]{friend});
        }

        // Status: Online/Offline
        // Relationship: Peer/Friend/None
        // Combinations: 8
        [TestCase]
        public void P_GetPI_MixedOnline_MixedFriendsAndPeers()
        {
            int cTargets = 8;
            PNUser user = CreateXenonUser(true);
            PNUser[] targets = new PNUser[cTargets];
            for( int i = 0; i < cTargets; ++i)
            {
                targets[i] = CreateXenonUser(true);
                switch (i % 3)
                {
                    case 0:
                        _fc.MakeFriend(user, targets[i]);
                        break;
                    case 1:
                        user.PeerSubscribe(new PNUser[] { targets[i] });
                        break;
                    default:
                        break;
                }
                if ((i & 1) == 0)
                {
                    targets[i].Disconnect();
                }
            }
            GetPIScenario(user, targets);
        }
    }

    /// <summary>
    /// Negative functional tests for the GetPresenceInfo API.
    /// TODO: Other than sending the request FROM an invalid user, the service does not return errors anymore.
    /// </summary>
    [TestGroup, AsyncGroup(1, 0)]
    public class FuncGetPresenceInfo_NegativeCases : PresenceTestBaseGroup
    {
        PNUser _validUser;

        void GetPIScenario(uint dwContext, ulong qwXboxId, ulong qwSenderId, uint cdwPuids, ulong []rgqwPuids, uint hrExpect)
        {
            PMsgGetPresenceInfo req = new PMsgGetPresenceInfo(dwContext, qwXboxId, qwSenderId, cdwPuids, rgqwPuids);
            PNMsg rep;
            bool caughtEx = false;

            try
            {
                req.TransactFD(out rep);
            }
            catch(XErrException ex) 
            {
                ValueCheck.TestHR("Expected negative result", hrExpect, ex.XErr);
                caughtEx = true;
            }

            if(!caughtEx && HResult.S_OK != hrExpect)
            {
                ValueCheck.TestHR("Did not receive expected hresult", hrExpect, HResult.S_OK);
            }
        }

        public override void Setup()
        {
            base.Setup();
            _validUser = CreateXenonUser(true);
        }
        
        public override void TearDown()
        {
            _fc.LogoffUser(_validUser);
            base.TearDown();
        }

        [TestCase]
        public void N_GetPI_ZeroUsers()
        {
            GetPIScenario(0, _validUser.Xbox.XboxId, _validUser.UserId, 0, new ulong[]{}, HResult.E_INVALIDARG);
        }

        [TestCase]
        public void N_GetPI_InvalidUserCount()
        {
            PNUser target = CreateXenonUser(true);
            GetPIScenario(0, _validUser.Xbox.XboxId, _validUser.UserId, 1, new ulong[]{0,1}, HResult.E_NO_SUCH_USER);
        }

        [TestCase]
        public void N_GetPI_InvalidUserPuids()
        {
            GetPIScenario(0, _validUser.Xbox.XboxId, _validUser.UserId, 3, new ulong[]{0,1,2}, HResult.E_NO_SUCH_USER);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\presencefunc\FuncKick.cs ===
using System;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.Notification;
using ServerTestFramework.LiveService.PresNotiCommon;
using xonline.common.protocol.SubNoti;
using xonline.common.community;

namespace PresenceTest
{
    [TestGroup, TestFrequency("Daily"), TestCasePriority(2), AsyncGroup(1, 0), Owner("Shailesh")]
	public class FuncKick: PresenceTestBaseGroup
	{
		[TestCase]
		public void KickUser()
		{
		    PNUser u= CreateXenonUser(true);
		    PMSGKick kick = new PMSGKick(u);
		    PNMsg replyMsg = new PNMsg();
		    kick.TransactFD(out replyMsg);
		    PKickReplyMsgData kickReply = (PKickReplyMsgData)replyMsg.Data;
		    PresenceRecord record = PresenceUtil.GetPresenceRecord(u.UserId);
		    ValueCheck.IsFalse(record.IsOnline(), "User should not be online anymore.");
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\presencefunc\FuncInvite.cs ===
using System;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.Notification;

namespace PresenceTest
{
	// TODO: turn this into a proper data table or matrix test
											// Friend:	Y	Y	N	N	
											// Linked:	Y	N	Y	N
		//	---------------------------------------------------------
		//	NoFriends_WeblinkNone									x	
		//	NoFriends_WeblinkAll								x		
		//	NoFriends_WeblinkedSome								x	x	
		//	AllFriends_WeblinkNone							x			
		//	AllFriends_WebLinkAll						x				
		//	AllFriends_WebLinkSome						x	x			
		//	SomeFriends_WeblinkNone							x		x	
		//	SomeFriends_WeblinkAll						x		x		
		//	SomeFriends_WeblinkAllFriendsNoOthers		x			x	
		//	SomeFriends_WeblinkAllFriendsSomeOthers		x		x	x	
		//	SomeFriends_WeblinkNoFriendsAllOthers			x	x		
		//	SomeFriends_WeblinkNoFriendsSomeOthers			x	x	x	
		//	SomeFriends_WeblinkSomeFriendsAllOthers			x	x	x		
		//	SomeFriends_WeblinkSomeFriendsNoOthers		x	x		x	
		//	SomeFriends_WeblinkSomeFriendsSomeOthers	x	x	x	x	
	
	/// <summary>
	/// Functional Tests for Invite, InviteAnswer and CancelInvite
	/// </summary>
    [TestGroup, AsyncGroup(1, 0), AsyncThreadCount(4)]
    public class FuncInvite : PresenceTestBaseGroup
	{

		static Report ro = new Report("FuncInvite");

		/// <summary>
		/// Create two unique logged on users and make them be friends
		/// </summary>
		/// <param name="user1">First user</param>
		/// <param name="user2">Second user</param>
		/// <param name="makeFriends">True to create the friend relationship</param>
		public void CreateUsers(out PNUser user1, out PNUser user2, bool makeFriends)
		{
			user1 = CreateXenonUser(true);
			user2 = CreateXenonUser(true);

			ClearUserInbox(user1);
			ClearUserInbox(user2);

			if(makeFriends)
			{
				_fc.MakeFriend(user1, user2);
			}
		}

		/// <summary>
		/// Create some unique logged on users and make them be friends
		/// </summary>
		/// <param name="nFriends">Number of friends to create</param>
		/// <param name="nWebLinkedFriends">Number of web linked friends to create</param>
		/// <param name="nOthers">Number of other users to create</param>
		/// <param name="nWebLinkedOthers">Number of other web linked users to create</param>
		/// <param name="invitor">Number of other web linked users to create</param>
		/// <param name="invitees">Number of other web linked users to create</param>
		public void CreateUsers(
			int nFriends, int nWebLinkedFriends, 
			int nOthers,  int nWebLinkedOthers,
			out PNUser invitor, out PNUser[] invitees)
		{
			invitor = CreateXenonUser(true);

			invitees = new PNUser[ nFriends + nWebLinkedFriends + nOthers + nWebLinkedOthers ];
			int i = 0;

			for(int friendI = 0; friendI < nFriends; ++friendI)
			{
				invitees[i] =CreateXenonUser(true);
				_fc.MakeFriend(invitor, invitees[i]);
				++i;
			}

			for(int linkedFriendI = 0; linkedFriendI < nWebLinkedFriends; ++linkedFriendI)
			{
				invitees[i] = CreateLinkedUser(true);
				_fc.MakeFriend(invitor, invitees[i]);
				++i;
			}

			for(int otherI = 0; otherI < nOthers; ++otherI)
			{
				invitees[i] = CreateXenonUser(true);
				++i;
			}

			for(int linkedOtherI = 0; linkedOtherI < nWebLinkedOthers; ++linkedOtherI)
			{
				invitees[i] = CreateLinkedUser(true);
				++i;
			}

			ClearUserInbox(invitor);
            ClearUsersInbox(invitees);
		}

		/// <summary>
		/// Send invite message and have target wait for notification, 
		/// as well as check for and validate message
		/// </summary>
		/// <param name="invitor">Sender</param>
		/// <param name="invitee">Target</param>
		public static uint DoValidInvite(PNUser invitor, PNUser invitee)
		{
			QValPacket qval = null;
			bool friends = false;
			PNUser.BuddyInfo bi = invitor.GetBuddyInfo(invitee.UserId);

			if(null != bi && bi.Status == XonPresNoti.P_BUDDY_STATUS_OK)
			{
				friends = true;
			}


			// Invitor sends invitation 
			PNUser[] invited = { invitee };
			invitor.Invite(invited, 1);
			uint msgId = 0;

			if(invitee.LoggedOn)
			{
				if(friends)
				{
					// Invitee wait for qflag qval then deques notification
					qval = invitee.WaitForQFlags(XonPresNoti.QFLAG_MASK_INVITE);
					invitee.HandleQValPacket(qval);

					PNUser.InvitationInfo info = invitee.GetInvitationInfo(invitor.UserId);

					ValueCheck.TestNotNull("InvitationInfo", info);
					ValueCheck.TestNotNull("InvitationInfo.Invitation", info.Invitation);

					TimeSpan dt = DateTime.UtcNow - info.Invitation.TimeSent;
					if(Math.Abs(dt.TotalHours) > 0.1)
					{
						throw new Exception("Time sent is wrong. Server says: " + info.Invitation.TimeSent.ToString());
					}
				}
				// Make sure we get a message id in slot 0
				qval = invitee.WaitForNewMessageType(XonPresNoti.MSG_TYPE_GAME_INVITE);	
                

				msgId = qval.FirstMessageIdMatchingType(XonPresNoti.MSG_TYPE_GAME_INVITE);
				ValueCheck.TestNonZero("Game invite message ID", msgId);

				// this will auto retrieve summary
				invitee.HandleQValPacket(qval);

				// get the message details
				UserMessage invitation = UserMessage.CreateAndLoad(invitee, msgId);

				ValueCheck.Test("Sender Title", invitor.Xbox.TitleId, invitation.TitleID);
				ValueCheck.Test("Sender Name", invitor.Name, invitation.SenderName);

				ValueCheck.Test("Expire Minutes", XonPresNoti.INVITE_EXPIRATION_MINUTES, invitation.ExpireMinutes);

				ValueCheck.Test("Datails Property Count", 1, invitation.Details.properties.Length);
				ValueCheck.Test("Details Property Tag", XonPresNoti.MSG_PROP_SESSION_ID, invitation.Details.properties[0].wPropTag.tag);

				ulong SessId = (ulong)invitation.Details.GetQwordProperty(XonPresNoti.MSG_PROP_SESSION_ID);
				ValueCheck.Test("Session ID", invitor.MatchSessionId, SessId);
			}

			return msgId;
		}

		/// <summary>
		/// Send invite anwer message and have target wait for notification, 
		/// as well as make sure invite message is revoked
		///	</summary>
		/// <param name="invitor">Target</param>
		/// <param name="invitee">Sender</param>
		/// <param name="accept">True to answer positively</param>
		/// <param name="never">True to put on never list</param>
		public static void DoValidInviteAnswer(PNUser invitor, PNUser invitee, bool accept, bool never)
		{
			if(accept)
            {
                invitee.AcceptInvite(invitor);
            }
			else
            {
				invitee.RejectInvite(invitor, never);
            }

			// Invitor wait for qflag qval then deques notification
			QValPacket qval = invitor.WaitForQFlags(XonPresNoti.QFLAG_MASK_INVITE_ANSWER);
			invitor.HandleQValPacket(qval);

			// Check out notificaion 
			PNUser.InvitationInfo info = invitor.GetInvitationInfo(invitor.UserId);
			ValueCheck.TestNotNull("InvitationInfo", info);
			ValueCheck.IsTrue(info.InvitationAnswers.ContainsKey(invitee.UserId), String.Format("InvitationInfo.InvitationAnswer.ContainsKey({0})",invitee.UserId));
				
			InvitationAnswerItem inviteAnserItem = info.InvitationAnswers[invitee.UserId] as InvitationAnswerItem;
			
			// Check delivery time
			TimeSpan dt = DateTime.UtcNow - inviteAnserItem.TimeSent;
			if(Math.Abs(dt.TotalHours) > 0.1)
			{
				throw new Exception("Time sent is wrong. Server says: " + inviteAnserItem.TimeSent.ToString());
			}

			// Check answer
			if(inviteAnserItem.Answer != (accept ? XonPresNoti.PINVITE_REPLY_YES : XonPresNoti.PINVITE_REPLY_NO))
			{
				throw new UnexpectedTestResultException("Answer is wrong: "+inviteAnserItem.Answer);
			}

			Thread.Sleep(5000);

			// Invitee enumerates for invitation message, to make sure it's revoked
			QMsgEnumMsgs msgEnumMsg = new QMsgEnumMsgs(invitee);
			PNMsg replyMsg;
			msgEnumMsg.TransactFD(out replyMsg);
			QEnumMsgsReplyMsgData replyData = (QEnumMsgsReplyMsgData)(replyMsg.Data);
			ValueCheck.Test("Enum reply HR", HResult.S_OK, replyData.HR);
			ValueCheck.Test("New Message Count", 0, replyData.Messages.Length);
		}

		/// <summary>
		/// 	Invite friend messages coalesced (BugId: XboxPlatform #36384)
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 	</Description>
		/// 	<Verify>
		/// 	</Verify>
		/// </remarks>
		[TestCase(36384)]
		public void P_Coalesce_Game_Invites_Friends()
		{
			PNUser invitor, invitee;

			// Make 2 users and set as friends
			CreateUsers(out invitor, out invitee, true);	

			// Send 2 invites, this first call dequeues the invite
			DoValidInvite(invitor, invitee);

			// send the raw invite again
			invitor.Invite(new PNUser[]{invitee}, 1);

			// Manually wait for the second invite on the recipient to validate that it doesn't occur
			// at this point the DoValidInvite has already deque'd the last invite
			// TODO: This isn't the most effecient way to do this, probably should just check the queue flags
			// but this method has some builtin tolerence for load problems.
			try
			{
				invitee.WaitForQFlags(XonPresNoti.QFLAG_MASK_INVITE);
			}
			catch(TimeOutException)
			{
				ro.Debug("Got expected timeout waiting for second invite");
			}

			// Make sure we can answer the first invite
			DoValidInviteAnswer(invitor, invitee, true, false);
		}

        [TestCase]
        public void P_Invite_99Friends()
        {
            uint numusers = 99;
            PNUser u = CreateXenonUser(true);
            PNUser[] friends = new PNUser[numusers];


            PNConditionalWaitState inviteWaitState = new PNConditionalWaitState();
            PNConditionalWaitState inviteAnswerWaitState = new PNConditionalWaitState();
            for (uint i = 0; i < numusers; i++)
            {
                friends[i] = CreateXenonUser(true);

                inviteWaitState.AddRequiredMessageData((uint)(XonPresNoti.MSG_TYPE_GAME_INVITE << 24), u, friends[i]);
                inviteWaitState.AddRequiredQFlag(XonPresNoti.QFLAG_MASK_INVITE, u, friends[i]);

                inviteAnswerWaitState.AddRequiredQFlag(XonPresNoti.QFLAG_MASK_INVITE_ANSWER, friends[i], u);
            }

            // Create our friend relationships
            foreach (PNUser friend in friends)
            {
                _fc.MakeFriendFast(u.UserId, friend.UserId);
            }
            _fc.LogoffUser(u);
            _fc.LogonUser(u);

            //now invite.
            u.Invite(friends, u.UserId);
            inviteWaitState.WaitOnQValConditions();

            foreach (PNUser t in friends)
            {
                t.AcceptInvite(u);
            }

            inviteAnswerWaitState.WaitOnQValConditions();
        }
        [TestCase]
        public void P_Invite_100Friends()
        {
            uint numusers = 100;
            PNUser u = CreateXenonUser(true);
            PNUser[] friends = new PNUser[numusers];


            PNConditionalWaitState inviteWaitState = new PNConditionalWaitState();
            PNConditionalWaitState inviteAnswerWaitState = new PNConditionalWaitState();
            for (uint i = 0; i < numusers; i++)
            {
                friends[i] = CreateXenonUser(true);

                inviteWaitState.AddRequiredMessageData((uint)(XonPresNoti.MSG_TYPE_GAME_INVITE << 24), u, friends[i]);
                inviteWaitState.AddRequiredQFlag(XonPresNoti.QFLAG_MASK_INVITE, u, friends[i]);

                inviteAnswerWaitState.AddRequiredQFlag(XonPresNoti.QFLAG_MASK_INVITE_ANSWER, friends[i], u);
            }

            // Create our friend relationships
            foreach (PNUser friend in friends)
            {
                _fc.MakeFriendFast(u.UserId, friend.UserId);
            }
            _fc.LogoffUser(u);
            _fc.LogonUser(u);

            //now invite.
            u.Invite(friends, u.UserId);
            inviteWaitState.WaitOnQValConditions();

            foreach (PNUser t in friends)
            {
                t.AcceptInvite(u);
            }

            inviteAnswerWaitState.WaitOnQValConditions();
        }

        [TestCase]
        public void P_Invite_101Friends()
        {
            uint numusers = 101;
            PNUser u = CreateXenonUser(true);
            PNUser[] friends = new PNUser[numusers];


            PNConditionalWaitState inviteWaitState = new PNConditionalWaitState();
            PNConditionalWaitState inviteAnswerWaitState = new PNConditionalWaitState();
            for (uint i = 0; i < numusers; i++)
            {
                friends[i] = CreateXenonUser(true);

                inviteWaitState.AddRequiredMessageData((uint)(XonPresNoti.MSG_TYPE_GAME_INVITE << 24), u, friends[i]);
                inviteWaitState.AddRequiredQFlag(XonPresNoti.QFLAG_MASK_INVITE, u, friends[i]);

                inviteAnswerWaitState.AddRequiredQFlag(XonPresNoti.QFLAG_MASK_INVITE_ANSWER, friends[i], u);
            }

           //now invite.
            try
            {
                u.Invite(friends, u.UserId);
                throw new Exception("Should not reach here."); //I may need to change this if we are not getting error back from server.
            }
            catch (Exception ex)
            {
                Global.RO.Debug(ex.Message);
            }
        }

		[TestCase]
		public void P_Invite_Multiple_Friends()
		{
			uint nusers = 16;

			PNUser u = CreateXenonUser(true);
			PNUser []targets = new PNUser[nusers];

			PNConditionalWaitState inviteWaitState = new PNConditionalWaitState();
			PNConditionalWaitState inviteAnswerWaitState = new PNConditionalWaitState();

			for(uint i = 0; i < nusers;  i++)
			{
				targets[i] = CreateXenonUser(true);
	
				inviteWaitState.AddRequiredMessageData((uint)(XonPresNoti.MSG_TYPE_GAME_INVITE << 24), u, targets[i]);
				inviteWaitState.AddRequiredQFlag(XonPresNoti.QFLAG_MASK_INVITE, u, targets[i]);

				inviteAnswerWaitState.AddRequiredQFlag(XonPresNoti.QFLAG_MASK_INVITE_ANSWER, targets[i], u);
			}

			ClearUserInbox(u);
			ClearUsersInbox(targets);

			// Create our friend relationships
			_fc.MakeFriends(u, targets);

			u.Invite(targets, u.UserId);
			inviteWaitState.WaitOnQValConditions();

			foreach(PNUser t in targets)
			{
				t.AcceptInvite(u);
			}

			inviteAnswerWaitState.WaitOnQValConditions();
		}

		[TestCase]
		public void P_Invite_Multiple_Non_Friends()
		{
			uint nusers = 16;

			PNUser u = CreateXenonUser(true);
			PNUser []targets = new PNUser[nusers];

			PNConditionalWaitState inviteWaitState = new PNConditionalWaitState();
			PNConditionalWaitState inviteAnswerWaitState = new PNConditionalWaitState();

			for(uint i = 0; i < nusers;  i++)
			{
				targets[i] = CreateXenonUser(true);
	
				inviteWaitState.AddRequiredMessageData((uint)(XonPresNoti.MSG_TYPE_GAME_INVITE << 24), u, targets[i]);

				inviteAnswerWaitState.AddRequiredQFlag(XonPresNoti.QFLAG_MASK_INVITE_ANSWER, targets[i], u);
			}

			ClearUserInbox(u);
			ClearUsersInbox(targets);

			u.Invite(targets, u.UserId);
			inviteWaitState.WaitOnQValConditions();

			foreach(PNUser t in targets)
			{
				t.AcceptInvite(u);
			}

			inviteAnswerWaitState.WaitOnQValConditions();
		}

        ///// <summary>
        ///// 	Invite SameUser: No Answer
        ///// </summary>
        ///// <remarks>
        ///// 	<Description>
        /////			Invitee doesn't answer invite that has been received.
        /////         Invitor sends a second invite.
        ///// 	</Description>
        ///// 	<Verify>
        ///// 	</Verify>
        ///// </remarks>
        //[TestCase]
        //public void P_Invite_Twice_NoAnswer()
        //{
        //    PNUser invitor;
        //    PNUser invitee;
        //    CreateUsers(out invitor, out invitee, true);
        //    DoValidInvite(invitor, invitee);
        //
        //    DoValidInvite(invitor, invitee);
        //    DoValidInviteAnswer(invitor, invitee, false, false);
        //}

		/// <summary>
		/// 	Invite SameUser: After yes
		/// </summary>
		/// <remarks>
		/// 	<Description>
		///			Invitee answers Yes to invite that has been received.
        ///         Invitor sends a second invite.
		/// 	</Description>
		/// 	<Verify>
		/// 	</Verify>
		/// </remarks>
        [TestCase]
        public void P_Invite_Twice_AfterYes()
        {
            PNUser invitor;
            PNUser invitee;
            CreateUsers(out invitor, out invitee, true);
            DoValidInvite(invitor, invitee);
            DoValidInviteAnswer(invitor, invitee, true, false);

            DoValidInvite(invitor, invitee);
            DoValidInviteAnswer(invitor, invitee, true, false);
        }

        /// <summary>
        /// 	Invite SameUser: After no
        /// </summary>
        /// <remarks>
        /// 	<Description>
        ///			Invitee answers No to invite that has been received.
        ///         Invitor sends a second invite.
        /// 	</Description>
        /// 	<Verify>
        /// 	</Verify>
        /// </remarks>
        [TestCase]
        public void P_Invite_Twice_AfterNo()
        {
            PNUser invitor;
            PNUser invitee;
            CreateUsers(out invitor, out invitee, true);
            DoValidInvite(invitor, invitee);
            DoValidInviteAnswer(invitor, invitee, false, false);

            DoValidInvite(invitor, invitee);
            DoValidInviteAnswer(invitor, invitee, false, false);
        }

		/// <summary>
		/// 	InviteAnswer: Answer yes
		/// </summary>
		/// <remarks>
		/// 	<Description>
		///			Answer Yes to invite that has been received.
		/// 	</Description>
		/// 	<Verify>
		/// 	</Verify>
		/// </remarks>
		[TestCase]
		public void P_Invite_AnswerYes()
		{
			PNUser invitor;
			PNUser invitee;
			CreateUsers(out invitor, out invitee, true);
			DoValidInvite(invitor, invitee);
			DoValidInviteAnswer(invitor, invitee, true, false);
		}
		
		/// <summary>
		/// 	InviteAnswer: Answer yes not friends
		/// </summary>
		/// <remarks>
		/// 	<Description>
		///			Answer Yes to invite that has been received from non friend
		/// 	</Description>
		/// 	<Verify>
		/// 	</Verify>
		/// </remarks>
		[TestCase]
		public void P_Invite_AnswerYes_NotFriends() 
		{
			PNUser invitor;
			PNUser invitee;
			CreateUsers(out invitor, out invitee, false);
			DoValidInvite(invitor, invitee);
			DoValidInviteAnswer(invitor, invitee, true, false);
		}

		/// <summary>
		/// 	InviteAnswer: Answer no
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 	</Description>
		/// 	<Verify>
		/// 	</Verify>
		/// </remarks>
		[TestCase]
		public void P_Invite_AnswerNo()
		{
			PNUser invitor;
			PNUser invitee;
			CreateUsers(out invitor, out invitee, true);
			DoValidInvite(invitor, invitee);
			DoValidInviteAnswer(invitor, invitee, false, false);
		}
		
		/// <summary>
		/// 	InviteAnswer: Answer no, not friends
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 	</Description>
		/// 	<Verify>
		/// 	</Verify>
		/// </remarks>
		[TestCase]
		public void P_Invite_AnswerNo_NotFriends()
		{
			PNUser invitor;
			PNUser invitee;
			CreateUsers(out invitor, out invitee, true);
			DoValidInvite(invitor, invitee);
			DoValidInviteAnswer(invitor, invitee, false, false);
		}
		
		/// <summary>
		/// 	InviteAnswer: Answer never
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 	</Description>
		/// 	<Verify>
		/// 	</Verify>
		/// </remarks>
        [TestCase]
        public void AnswerNever()
        {
            PNUser invitor;
            PNUser invitee;
            CreateUsers(out invitor, out invitee, true);

            DoValidInvite(invitor, invitee);

            DoValidInviteAnswer(invitor, invitee, false, true);

            invitee.ExpectInviteBlip();
            PNUser[] invited = { invitee };
            invitor.Invite(invited, 2);
            bool timedOut = false;
            try
            {
                invitee.WaitForInviteBlip();
            }
            catch (TimeOutException)
            {
                timedOut = true;
            }

            if (!timedOut)
                throw new UnexpectedTestResultException("Didn't expect invitation from user on never list");

            Thread.Sleep(5000);

            QMsgEnumMsgs msgEnumMsg = new QMsgEnumMsgs(invitee);
            PNMsg replyMsg;
            msgEnumMsg.TransactFD(out replyMsg);
            QEnumMsgsReplyMsgData replyData = (QEnumMsgsReplyMsgData)(replyMsg.Data);

            // Check out message summary
            if (replyData.HR != HResult.S_OK)
                throw new UnexpectedTestResultException(
                    "Error in Enum reply, HR: 0x" + replyData.HR.ToString("X8"));

            ValueCheck.Test("Message Count", 0, replyData.Messages.Length);
        }
		
		/// <summary>
		/// 	InviteAnswer: Delete and never sender
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 	</Description>
		/// 	<Verify>
		/// 	</Verify>
		/// </remarks>
        [TestCase]
        public void DeleteNever()
        {
            PNUser invitor;
            PNUser invitee;
            CreateUsers(out invitor, out invitee, true);

            DoValidInvite(invitor, invitee);

            UserMsgFolder inviteeInbox = new UserMsgFolder(invitee);
            UserMessage invitation = inviteeInbox.WaitForMsg(XonPresNoti.MSG_TYPE_GAME_INVITE, invitor.UserId, 0, 30);
            invitation.Delete(invitee, true);

            invitee.ExpectInviteBlip();
            PNUser[] invited = { invitee };
            invitor.Invite(invited, 2);
            bool timedOut = false;
            try
            {
                invitee.WaitForInviteBlip();
            }
            catch (TimeOutException)
            {
                timedOut = true;
            }

            if (!timedOut)
                throw new UnexpectedTestResultException("Didn't expect invitation from user on never list");

            Thread.Sleep(5000);

            QMsgEnumMsgs msgEnumMsg = new QMsgEnumMsgs(invitee);
            PNMsg replyMsg;
            msgEnumMsg.TransactFD(out replyMsg);
            QEnumMsgsReplyMsgData replyData = (QEnumMsgsReplyMsgData)(replyMsg.Data);

            // Check out message summary
            if (replyData.HR != HResult.S_OK)
                throw new UnexpectedTestResultException(
                    "Error in Enum reply, HR: 0x" + replyData.HR.ToString("X8"));

            ValueCheck.Test("Message Count", 0, replyData.Messages.Length);
        }
		
		/// <summary>
		/// 	InviteAnswer: Answer never, not friends
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 	</Description>
		/// 	<Verify>
		/// 	</Verify>
		/// </remarks>
		[TestCase]
		public void P_Invite_AnswerNever_NotFriends()
		{
			PNUser invitor;
			PNUser invitee;
			CreateUsers(out invitor, out invitee, true);

			DoValidInvite(invitor, invitee);

			DoValidInviteAnswer(invitor, invitee, false, true);

			PNUser[] invited = { invitee };
			invitor.Invite(invited, 2);

			UserMsgFolder inviteeInbox = new UserMsgFolder(invitee);
			bool timedOut = false;
			try
			{
				inviteeInbox.WaitForMsg(XonPresNoti.MSG_TYPE_GAME_INVITE, invitor.UserId, 0, 30);
			}
			catch(TimeOutException)
			{
				timedOut = true;
			}

			if(!timedOut)
				throw new UnexpectedTestResultException("Didn't expect invitation for someone on never list");
			ValueCheck.Test("Message Count", (ushort)0, inviteeInbox.Count);
		}
		
		/// <summary>
		/// 	Cancel Invite: Outstanding invite
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 	</Description>
		/// 	<Verify>
		/// 	</Verify>
		/// </remarks>
		[TestCase]
		public void P_Invite_Cancel()
		{
			PNUser invitor;
			PNUser invitee;
			CreateUsers(out invitor, out invitee, true);

			DoValidInvite(invitor, invitee);

			PNUser[] invited = { invitee };
			invitor.CancelInvite(invited);

			Thread.Sleep(10000);

			// Invitee enumerates for invitation message
			QMsgEnumMsgs msgEnumMsg = new QMsgEnumMsgs(invitee);
			PNMsg replyMsg;
            msgEnumMsg.TransactFD(out replyMsg);
			QEnumMsgsReplyMsgData replyData = (QEnumMsgsReplyMsgData)(replyMsg.Data);

			// Check out message summary
			if(replyData.HR != HResult.S_OK)
				throw new UnexpectedTestResultException(
						"Error in Enum reply, HR: 0x"+replyData.HR.ToString("X8"));

			ValueCheck.Test("Message Count", 0, replyData.Messages.Length);
		}
		
		/// <summary>
		/// 	Cancel Invite: Auto-removed from never list
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 	</Description>
		/// 	<Verify>
		/// 	</Verify>
		/// </remarks>
		[TestCase]
		public void P_Invite_UnNeverWithCanceledInvite()
		{
			PNUser invitor;
			PNUser invitee;
			CreateUsers(out invitor, out invitee, true);

			DoValidInvite(invitor, invitee);

			DoValidInviteAnswer(invitor, invitee, false, true);

			invitee.ExpectInviteBlip();				
			PNUser[] invited = { invitee };
			invitor.Invite(invited, 2);
			bool timedOut = false;
			try
			{
				invitee.WaitForInviteBlip();
			}
			catch(TimeOutException) 
			{
				timedOut = true;
			}

			if(!timedOut)
				throw new UnexpectedTestResultException("Didn't expect invitation from user on never list");

			Thread.Sleep(10000);

			QMsgEnumMsgs msgEnumMsg = new QMsgEnumMsgs(invitee);
			PNMsg replyMsg;
			msgEnumMsg.TransactFD(out replyMsg);
			QEnumMsgsReplyMsgData replyData = (QEnumMsgsReplyMsgData)(replyMsg.Data);

			// Check out message summary
			if(replyData.HR != HResult.S_OK)
				throw new UnexpectedTestResultException(
						"Error in Enum reply, HR: 0x"+replyData.HR.ToString("X8"));

			ValueCheck.Test("Message Count", 0, replyData.Messages.Length);

			DoValidInvite(invitee, invitor);
			invited[0] = invitor;
			invitee.CancelInvite(invited);

			DoValidInvite(invitor, invitee);

			DoValidInviteAnswer(invitor, invitee, true, false);
		}
		
		/// <summary>
		/// 	Cancel Invite: Auto-removed from never list, not friends
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 	</Description>
		/// 	<Verify>
		/// 	</Verify>
		/// </remarks>
		[TestCase]
		public void P_UnNeverWithCanceledInvite_NotFriends()
		{
			PNUser invitor;
			PNUser invitee;
			CreateUsers(out invitor, out invitee, false);

			DoValidInvite(invitor, invitee);

			DoValidInviteAnswer(invitor, invitee, false, true);

			PNUser[] invited = { invitee };
			invitor.Invite(invited, 2);

			UserMsgFolder inviteeInbox = new UserMsgFolder(invitee);
			bool timedOut = false;
			try
			{
				inviteeInbox.WaitForMsg(XonPresNoti.MSG_TYPE_GAME_INVITE, invitor.UserId, 0, 30);
			}
			catch(TimeOutException)
			{
				timedOut = true;
			}

			if(!timedOut)
				throw new UnexpectedTestResultException("Didn't expect invitation for someone on never list");

			ValueCheck.Test("Message Count", (ushort)0, inviteeInbox.Count);

			DoValidInvite(invitee, invitor);

			invited[0] = invitor;
			invitee.CancelInvite(invited);
            //Now wait for cancel message..
            invitee.WaitForDeletedMessage();
            //send invite.
			DoValidInvite(invitor, invitee);

			DoValidInviteAnswer(invitor, invitee, true, false);
		}

		/// <summary>
		/// 	Cancel Invite: Buddy request nevered, not friends
		/// </summary>
		/// <remarks>
		/// 	<Description>
		///			Invite then cancel the invite just to get someone off your never list that's not a friend.
		/// 	</Description>
		/// 	<Verify>
		/// 	</Verify>
		/// </remarks>
		[TestCase]
		public void P_UnNeverWithCanceledInvite_NotFriends_BuddyReqNevered()
		{
			PNUser invitor = CreateXenonUser(true);
			PNUser invitee = CreateXenonUser(true);

			ClearUserInbox(invitor);
			ClearUserInbox(invitee);

			_fc.RequestFriend(invitor, invitee);
			_fc.RejectFriend(invitee, invitor, true);

			PNUser[] invited = { invitee };
			invitor.Invite(invited, 2);

			UserMsgFolder inviteeInbox = new UserMsgFolder(invitee);
			bool timedOut = false;
			try
			{
				inviteeInbox.WaitForMsg(XonPresNoti.MSG_TYPE_GAME_INVITE, invitor.UserId, 0, 30);
			}
			catch(TimeOutException)
			{
				timedOut = true;
			}

			if(!timedOut)
				throw new UnexpectedTestResultException("Didn't expect invitation for someone on never list");

			ValueCheck.Test("Message Count", (ushort)0, inviteeInbox.Count);

			DoValidInvite(invitee, invitor);
			invited[0] = invitor;
			invitee.CancelInvite(invited);

			DoValidInvite(invitor, invitee);

			DoValidInviteAnswer(invitor, invitee, true, false);
		}

		[TestCase]
		public void P_Invite_LoggedOff_User()
		{
			PNUser a = CreateXenonUser(true);
			PNUser b = CreateXenonUser(true);
			_fc.LogoffUser(b);
			DoValidInvite(a, b);
		}

		[TestCase]
		public void P_Invite_Cleared_From_StateUpdate()
		{
			PNUser a = CreateXenonUser(true);
			PNUser b = CreateXenonUser(true);

			QValPacket qval;

			// Invite B into a session, this will pulse their state and invite the other user 
			a.Invite(new PNUser[]{b}, 1010);

			// Wait for the non-friend transient message invite
			qval = b.WaitForNewMessage();	

			Global.RO.Debug("Got invite message ID: {0}", qval.NewMessageId(0));

			// Change our session ID, this should revoke the invite
			a.SetTitleData((ulong)1011);

			qval = b.WaitForDeletedMessage();
			Global.RO.Debug("Got deleted message ID: {0}", qval.DeletedMessageId(0));
		}

        [TestCase, Ignore]
        public void P_Invite_Cleared_From_StateUpdate_Target_Offline()
        {
            PNUser a = CreateXenonUser(true);
            PNUser b = CreateXenonUser(true);

            QValPacket qval;

            // Invite B into a session, this will pulse their state and invite the other user 
            a.Invite(new PNUser[] { b }, 1010);

            // Wait for the non-friend transient message invite
            qval = b.WaitForNewMessage();

            Global.RO.Debug("Got invite message ID: {0}", qval.NewMessageId(0));

            _fc.LogoffUser(b);

            // Change our session ID, this should revoke the invite
            a.SetTitleData((ulong)1011);

            // Verify that the transient message was revoked for the offline user
            // Need to use Show Record
        }

		[TestCase]
		public void P_Invite_Persist_Across_Logoff_Logon()
		{
			// Create two users non-friends invite b into a's session
			PNUser a = CreateXenonUser(true);
			PNUser b = CreateXenonUser(true);

			ClearUserInbox(a);
			ClearUserInbox(b);
            
			P_Invite_Persist_Across_Logoff_Logon_Scenario("xenon->xenon", a, b);
		}

		public void P_Invite_Persist_Across_Logoff_Logon_Scenario(string name, PNUser a, PNUser b)
		{
			QValPacket qval;
			uint oldMsgId;

			Global.RO.Info("Invite persist across logoff scenario: {0}", name);

			_fc.MakeFriend(a, b);
			a.Invite(new PNUser[]{b}, 100);

			// Handle the invite qval
			qval = b.WaitForQFlags(XonPresNoti.QFLAG_MASK_INVITE);
			b.HandleQValPacket(qval);

			// Make sure we have the invite message
			qval = b.WaitForNewMessage();
			oldMsgId = qval.NewMessageId(0);

			// Logoff and logon again
			_fc.LogoffUser(b);
			
			uint hr = _fc.LogonUser(b);
			ValueCheck.TestHR("Expecting enum needed hr", HResult.XONLINE_S_LOGON_USER_MESSAGE_ENUMERATION_NEEDED, hr);

			// Get the message that should still be there for b
			UserMsgFolder folder = new UserMsgFolder(b);
			uint count = folder.Load();

			//ValueCheck.Test("Message count", 1, count);

			UserMessage msg = folder[oldMsgId];
			ValueCheck.TestNotNull("UserMessage", msg);
			ValueCheck.Test("UserMessage", msg.ID, oldMsgId);

			qval = b.WaitForQFlags(XonPresNoti.QFLAG_MASK_INVITE);
			b.HandleQValPacket(qval);
		}

		[TestCase]
		public void P_Invite_RevokedOnLogoff()
		{
            // TODO: what does not in memory mean in the new presence system?

            PNUser u                    = CreateXenonUser(true);
			PNUser loggedOffFriend      = CreateXenonUser(true);
			PNUser loggedOff            = CreateXenonUser(true);
			PNUser loggedOffPending     = CreateXenonUser(true);
			PNUser loggedOffRequested   = CreateXenonUser(true);
			PNUser notInMemoryFriend    = CreateXenonUser(true);
			PNUser notInMemory          = CreateXenonUser(true);
			PNUser notInMemoryPending   = CreateXenonUser(true);
			PNUser notInMemoryRequested = CreateXenonUser(true);
			PNUser onlineFriend         = CreateXenonUser(true);
			PNUser online               = CreateXenonUser(true);
			PNUser onlinePeer           = CreateXenonUser(true);
			PNUser onlinePending        = CreateXenonUser(true);
			PNUser onlineRequested      = CreateXenonUser(true);
			

			// Create our target data
			PNUser []targets = new PNUser[13];
			targets[0]  = loggedOffFriend;
			targets[1]  = loggedOff;
			targets[2]  = loggedOffPending;
			targets[3]  = loggedOffRequested;
			targets[4]  = notInMemoryFriend;
			targets[5]  = notInMemory;
			targets[6]  = notInMemoryPending;
			targets[7]  = notInMemoryRequested;
			targets[8]  = onlineFriend;
			targets[9]  = online;
			targets[10] = onlinePeer;
			targets[11] = onlinePending;
			targets[12] = onlineRequested;

			ClearUserInbox(u);
			ClearUsersInbox(targets);

			
			// Setup friend states
			_fc.MakeFriend(u, loggedOffFriend);
			_fc.MakeFriend(u, notInMemoryFriend);
			_fc.MakeFriend(u, onlineFriend);

			u.AddBuddy(loggedOffPending);
			u.AddBuddy(notInMemoryPending);
			u.AddBuddy(onlinePending);
			loggedOffRequested.AddBuddy(u);
			notInMemoryRequested.AddBuddy(u);
			onlineRequested.AddBuddy(u);

			

			// kick two users offline
			_fc.LogoffUser(loggedOffFriend);
			_fc.LogoffUser(loggedOff);
			_fc.LogoffUser(loggedOffPending);
			_fc.LogoffUser(loggedOffRequested);
			_fc.LogoffUser(notInMemoryFriend);
			_fc.LogoffUser(notInMemory);
			_fc.LogoffUser(notInMemoryPending);
			_fc.LogoffUser(notInMemoryRequested);

			// Allow the logoffs to settle
			Thread.Sleep(5000);

			// kick users out of memory
			//PNServers.SetCacheState(notInMemoryFriend, CacheState.NotInMemory);
			//PNServers.SetCacheState(notInMemory, CacheState.NotInMemory);
			//PNServers.SetCacheState(notInMemoryPending, CacheState.NotInMemory);
			//PNServers.SetCacheState(notInMemoryRequested, CacheState.NotInMemory);

			// peer subscribe 
			onlinePeer.AddPeerSubscription(u);

			// Invite them all into a session
			u.Invite(targets, u.UserId);

			// Create the conditional waitable state
			PNConditionalWaitState inviteWait = new PNConditionalWaitState();
			inviteWait.AddRequiredQFlag(XonPresNoti.QFLAG_MASK_INVITE, u, onlineFriend);
			inviteWait.AddRequiredMessageType(XonPresNoti.MSG_TYPE_GAME_INVITE, u, onlineFriend);
			inviteWait.AddRequiredMessageType(XonPresNoti.MSG_TYPE_GAME_INVITE, u, online);
			inviteWait.AddRequiredMessageType(XonPresNoti.MSG_TYPE_GAME_INVITE, u, onlinePeer);
			inviteWait.AddRequiredMessageType(XonPresNoti.MSG_TYPE_GAME_INVITE, u, onlinePending);
			inviteWait.AddRequiredMessageType(XonPresNoti.MSG_TYPE_GAME_INVITE, u, onlineRequested);

			// Satisfy all invite conditions
			inviteWait.WaitOnQValConditions();

			// Logoff the user
			_fc.LogoffUser(u);

			PNConditionalWaitState revokeWait = new PNConditionalWaitState();
			revokeWait.AddRequiredDeletedMessageId(onlineFriend.GetMessageInfoFrom(u)[0].Id, u, onlineFriend);
			revokeWait.AddRequiredDeletedMessageId(online.GetMessageInfoFrom(u)[0].Id, u, online);
			revokeWait.AddRequiredDeletedMessageId(onlinePeer.GetMessageInfoFrom(u)[0].Id, u, onlinePeer);
			revokeWait.AddRequiredDeletedMessageId(onlinePending.GetMessageInfoFrom(u)[0].Id, u, onlinePending);
			revokeWait.AddRequiredDeletedMessageId(onlineRequested.GetMessageInfoFrom(u)[0].Id, u, onlineRequested);

			// Check the users that had online message data
			revokeWait.WaitOnQValConditions();

			uint hr;
			UserMsgFolder folder;
			UserMessage []msgs;

			// Logon some other users make sure they don't have pending invites
			// 
			// enumeration needed will be returned if the user hits the alive cache
			//
			hr = _fc.LogonUser(loggedOffFriend);
			ValueCheck.TestHR("LoggedOffFriend: Logon.HR",
					new uint[]{HResult.S_OK, HResult.XONLINE_S_LOGON_USER_MESSAGE_ENUMERATION_NEEDED},
					hr);
			ValueCheck.Test("LoggedOffFriend: Message count", (ushort)0, new UserMsgFolder(loggedOffFriend).Load());

			hr = _fc.LogonUser(loggedOff);
			ValueCheck.TestHR("LoggedOff: Logon.HR",
					new uint[]{HResult.S_OK, HResult.XONLINE_S_LOGON_USER_MESSAGE_ENUMERATION_NEEDED},
					hr);
			ValueCheck.Test("LoggedOff: Message count", (ushort)0, new UserMsgFolder(loggedOff).Load());

			// Make sure we don't count the friend request message
			hr = _fc.LogonUser(loggedOffPending);
			ValueCheck.TestHR("LoggedOffPending: Logon.HR", 
					new uint[]{HResult.S_OK, HResult.XONLINE_S_LOGON_USER_MESSAGE_ENUMERATION_NEEDED},
					hr);
			folder = new UserMsgFolder(loggedOffPending);
			folder.Load();
			msgs = folder.FindBySender(XonPresNoti.MSG_TYPE_GAME_INVITE, u.UserId);
			ValueCheck.Test("LoggedOffPending: Message count", (ushort)0, msgs.Length);

			// Make sure we don't count the friend requested message
			hr = _fc.LogonUser(loggedOffRequested);
			ValueCheck.TestHR("LoggedOffRequested: Logon.HR",
					new uint[]{HResult.S_OK, HResult.XONLINE_S_LOGON_USER_MESSAGE_ENUMERATION_NEEDED},
					hr);
			folder = new UserMsgFolder(loggedOffRequested);
			folder.Load();
			msgs = folder.FindBySender(XonPresNoti.MSG_TYPE_GAME_INVITE, u.UserId);
			ValueCheck.Test("LoggedOffRequested: Message count", (ushort)0, msgs.Length);

			hr = _fc.LogonUser(notInMemoryFriend);
			ValueCheck.TestHR("NotInMemoryFriend: Logon.HR",
					new uint[]{HResult.S_OK, HResult.XONLINE_S_LOGON_USER_MESSAGE_ENUMERATION_NEEDED},
					hr);
			ValueCheck.Test("NotInMemoryFriend: Message count", (ushort)0, new UserMsgFolder(notInMemoryFriend).Load());

			hr = _fc.LogonUser(notInMemory);
			ValueCheck.TestHR("NotInMemory: Logon.HR",
					new uint[]{HResult.S_OK, HResult.XONLINE_S_LOGON_USER_MESSAGE_ENUMERATION_NEEDED},
					hr);
			ValueCheck.Test("NotInMemory: Message count", (ushort)0, new UserMsgFolder(notInMemory).Load());

			hr = _fc.LogonUser(notInMemoryPending);
			ValueCheck.TestHR("NotInMemoryPending: Logon.HR",
					new uint[]{HResult.S_OK, HResult.XONLINE_S_LOGON_USER_MESSAGE_ENUMERATION_NEEDED},
					hr);
			folder = new UserMsgFolder(notInMemoryPending);
			folder.Load();
			msgs = folder.FindBySender(XonPresNoti.MSG_TYPE_GAME_INVITE, u.UserId);
			ValueCheck.Test("NotInMemoryPending: Message count", (ushort)0, msgs.Length);

			hr = _fc.LogonUser(notInMemoryRequested);
			ValueCheck.TestHR("NotInMemoryRequested: Logon.HR",
					new uint[]{HResult.S_OK, HResult.XONLINE_S_LOGON_USER_MESSAGE_ENUMERATION_NEEDED},
					hr);
			folder = new UserMsgFolder(notInMemoryRequested);
			folder.Load();
			msgs = folder.FindBySender(XonPresNoti.MSG_TYPE_GAME_INVITE, u.UserId);
			ValueCheck.Test("NotInMemoryRequested: Message count", (ushort)0, msgs.Length);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\presencefunc\FuncLogonCheck.cs ===
using System;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Database;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.Notification;
using ServerTestFramework.LiveService.PresNotiCommon;
using xonline.common.protocol.SubNoti;
using xonline.common.community;

namespace PresenceTest
{
    [TestGroup, TestFrequency("Daily"), TestCasePriority(2), AsyncGroup(1, 0), Owner("Shailesh")]
	public class FuncLogonCheck: PresenceTestBaseGroup
	{
		[TestCase]
		public void LogonCheckOnline()
		{
		    PNUser user = CreateXenonUser(true);
		    PMsgLogonCheck logoncheck = new PMsgLogonCheck(user, user.Xbox.XboxId);
		    PNMsg reply;
		    logoncheck.TransactFD(out reply);
		    PLogonCheckReplyMsgData data = (PLogonCheckReplyMsgData)reply.Data;
		    ValueCheck.IsTrue(data != null, "reply data should NOT be NULL");
		    ValueCheck.IsTrue(data.HR == 0, "Got right HR");
        }

        [TestCase]
        public void LogonCheckOffline()
        {
            PNUser user = CreateXenonUser(true);
            _fc.LogoffUser(user);
            PMsgLogonCheck logoncheck = new PMsgLogonCheck(user, user.Xbox.XboxId);
            PNMsg reply;
            try
            {
                logoncheck.TransactFD(out reply);
            }
            catch
            {
                ValueCheck.IsTrue(true, "Function threw, sweet!");
                return;
            }

            ValueCheck.IsTrue(false, "Function did not throw, failure.");
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\presencefunc\FuncIsAffiliate.cs ===
using System; 
using System.Collections; 
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.Database;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Notification;
using ServerTestFramework.LiveService.Presence;

namespace PresenceTest
{
	/// <summary>
	/// 	Positive Functional Tests for IsAffiliate
	/// </summary>
	/// <remarks>
	/// 	<Description>
	/// 		<p>
	/// 		IsAffiliates query is used to determine if a single user is an affiliate
	/// 		of another user. The XRL takes two user IDs that will be tested for any
	/// 		non-emulated affiliation (Friend list, Mute list and Block list do not count).
	/// 		</p>
	///			
	///			<div class="test_data_label">
	/// 			IsAffiliate Request Format:
	/// 		</div>
	/// 		<table class="test_data">
	/// 			<tr><td>ULONGLONG qwSenderID   </td><td>Owner of affiliate list</td></tr>
	/// 			<tr><td>ULONGLONG qwAffiliateID</td><td>Affiliate ID to test</td></tr>
	/// 		</table>
	///
	/// 		<div class="test_data_label">
	/// 			IsAffiliate Reply Format:
	/// 		</div>
	/// 		<table class="test_data">
	/// 			<tr><td>HRESULT hr             </td><td>Result code returned of the query</td></tr>
	/// 			<tr><td>ULONGLONG qwAffiliateID</td><td>Affiliate ID queried</td></tr>
	/// 			<tr><td>DWORD dwListFlags      </td><td>List flags that affiliate matched</td></tr>
	/// 		</table>
	///
	/// 		<div class="test_data_label">
	/// 			IsAffiliate HRESULT Codes:
	/// 		</div>
	/// 		<table class="test_data">
	/// 			<tr><td>S_OK                   </td><td>Operation succeeded, affiliate exists</td></tr>
	/// 			<tr><td>S_FALSE                </td><td>Operation succeeded, affiliate does not exists</td></tr>
	/// 			<tr><td>ERROR_NO_SUCH_USER     </td><td>User requested does not online</td></tr>
	/// 			<tr><td>E_FAIL                 </td><td>SQL sproc failed unexpectably</td></tr>
	/// 			<tr><td>E_OUTOFMEMORY          </td><td>The server ran into a memory condition</td></tr>
	/// 			<tr><td>E_INVALIDARG           </td><td>An invalid affiliate list was requested</td></tr>
	/// 		</table>
	///
	///			<p>
	/// 		When affiliations do not exist IsAffiliate XRL returns S_FALSE.
	/// 		</p>
	///
	/// 		<p>
	/// 		(See FuncQueryAffiliates on data formats, bit flags and notation for those flags)
	/// 		</p>
	///
	///			<p>
	/// 		The bulk of IsAffiliate tests are in the form of a matrix that uses a user control set 
	/// 		similar to query affiliates but only two user control sets are used: 
	/// 		</p>
	///
	///			<div class="test_data_label">
	///				User control sets
	///			</div>
	///			<table class="test_data">
	/// 			<tr><td>Initiator control set  </td><td>Users that will have affiliations added and will be initiators of the XRL call</td></tr>
	/// 			<tr><td>Result control set     </td><td>Users who will be the recipricol of the affiliation</td></tr>
	/// 		</table>
	///
	///			<p>
	/// 		The last tests are performed to ensure that two users who are not affiliated in any
	/// 		way do not return S_OK.
	/// 		</p>
	///	</Description>
	/// </remarks>
    [TestGroup, TestFrequency("Daily"), TestCasePriority(2), AsyncGroup(1, 0)]
    public class FuncIsAffiliate_PositiveCases : PresenceTestBaseGroup
	{
		//------------------------------------------------------------------------------
		// 
		// Mainline IsAffiliate cases
		//
	
		/// <summary>
		/// 	IsAffiliate XRL matrix test
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 		Query for each user in the initiator control set each user in the result
		/// 		control set.
		/// 	</Description>
		/// 	<Verify>
		/// 		Validate for each user in the initiator control set that each user in the
		/// 		result control set IsAffiliates XRL return S_OK.
		/// 	</Verify>
		/// </remarks>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
		public void P_IsAffiliate_Matrix()
		{
			PNUser owner          = CreateXenonUser(true);
			AffiliateState state  = new AffiliateState(owner);
			state.Initialize();

			PNUser encountered    = CreateXenonUser(true);
			PNUser completed      = CreateXenonUser(true);
			PNUser positive       = CreateXenonUser(true);
			PNUser negative       = CreateXenonUser(true);
		
			// Add explicit affiliates
			state.Add(encountered, (uint)AffiliateFlags.Encountered);
			state.Add(completed, (uint)AffiliateFlags.CompletedGame);
			state.Add(positive, (uint)AffiliateFlags.PositiveFeedback);
			state.Add(negative, (uint)AffiliateFlags.NegativeFeedback);


			ValidateIsAffiliateReplyData(encountered, state.ValidateIsAffiliateExternal(encountered), (uint)AffiliateFlags.Encountered);
			ValidateIsAffiliateReplyData(completed, state.ValidateIsAffiliateExternal(completed), (uint)(AffiliateFlags.CompletedGame|AffiliateFlags.Encountered));
			ValidateIsAffiliateReplyData(positive, state.ValidateIsAffiliateExternal(positive), (uint)AffiliateFlags.PositiveFeedback);
			ValidateIsAffiliateReplyData(negative, state.ValidateIsAffiliateExternal(negative), (uint)AffiliateFlags.NegativeFeedback);
		}

		private void ValidateIsAffiliateReplyData(PNUser affiliate, PIsAffiliateReplyMsgData data, uint flags)
		{
			ValueCheck.TestHR("IsAffiliateReply.HR", HResult.S_OK, data.hr);
			ValueCheck.Test("IsAffiliateReply.ListFlags", flags, data.dwListFlags);
			ValueCheck.Test("IsAffiliateReply.AffiliateId", affiliate.UserId, data.qwAffiliateID);
		}

		/// <summary>
		/// No affiliation test
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 		Get two clean users and test their affiliation. 
		/// 	</Description>
		/// 	<Verify>
		/// 		<ul>
		/// 			<li>S_FALSE HRESULT</li>
		/// 			<li>0 qwAffiliateID</li>
		/// 		</ul>
		/// 	</Verify>
		/// </remarks>
		[TestCase]
		public void P_IsAffiliate_No_Affiliation()
		{
			PNUser owner = CreateXenonUser(true);
			PNUser other = CreateXenonUser(true);

			AffiliateState state = new AffiliateState(owner);
			state.ValidateIsNotAffiliate(other);
		}
	}

	/// <summary>
	/// 	Negative Functional Tests for IsAffiliate
	/// </summary>
    [TestGroup, TestFrequency("Regression"), TestCasePriority(3)]
	public class FuncIsAffiliate_NegativeCases : PresenceTestBaseGroup
	{
		AffiliateState _state;
		PNUser         _owner;

		public override void Setup()
		{
            base.Setup();
			_owner = CreateXenonUser(true);
			_state = new AffiliateState(_owner);
		}

		public override void TearDown()
		{
			_fc.LogoffUser(_owner);
			_owner = null;
			_state = null;
            base.TearDown();
		}

		/// <summary>
		/// Affiliate ID zero
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 		Get one clean user and request affiliate matches
		/// 		for affiliate ID zero.
		/// 	</Description>
		/// 	<Verify>
		/// 		<ul>
		/// 			<li>HRESULT equal to S_FALSE</li>
		/// 			<li>0 qwAffiliateID</li>
		/// 		</ul>
		/// 	</Verify>
		/// </remarks>
		[TestCase]
		public void N_IsAffiliate_AffiliateID_Zero()
		{
			PNUser user = new PNUser("Notreal", 0);
            try
            {
                _state.ValidateIsAffiliate(user);
            }
            catch (HResultException ex)
            {
                if (ex.HR != HResult.E_INVALIDARG)
                {
                    throw ex;
                }
            }
            finally
            {
                user.Dispose();
            }
		}

		/// <summary>
		/// User not online
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 		Request affiliate query for offline user.
		/// 	</Description>
		/// 	<Verify>
		/// 		HRESULT equal to XONLINE_E_NOTIFICATION_INVALID_PUID
		/// 	</Verify>
		/// </remarks>
		[TestCase]
		public void N_IsAffiliate_User_Not_Online()
		{
			bool caught = false;

			// setup offline user
			PNUser u = CreateXenonUser(true);
			_fc.LogoffUser(u);

			// do the request
			PMsgIsAffiliate request = new PMsgIsAffiliate(u, _owner);

			try
			{
				PNMsg reply;
                request.TransactFD(out reply);
			}
			catch(XErrException ex)
			{
				caught = true;
				ValueCheck.TestHR("IsAffiliateReply.HR", HResult.XONLINE_E_NOTIFICATION_INVALID_PUID, ex.XErr);
			}

			if(!caught)
			{
				throw new UnexpectedTestResultException("Did not catch XRL exception from invalid request");
			}
		}

		/// <summary>
		/// User zero
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 		Request affiliate query for user ID zero.
		/// 	</Description>
		/// 	<Verify>
        /// 		HRESULT equal to E_INVALIDARG 
		/// 	</Verify>
		/// </remarks>
		[TestCase]
		public void N_IsAffiliate_User_Zero()
		{
			bool caught = false;
			PNUser zero = new PNUser("zero", 0);
			zero.Xbox = new PNXbox();

			PMsgIsAffiliate request = new PMsgIsAffiliate(zero, _owner);

			try
			{
				PNMsg reply;
                request.TransactFD(out reply);
			}
			catch(XErrException ex)
			{
				caught = true;
				ValueCheck.TestHR("IsAffiliateReply.HR", HResult.E_INVALIDARG, ex.XErr);
			}

			if(!caught)
			{
				throw new UnexpectedTestResultException("Did not catch XRL exception from invalid request");
			}
		}
		
		/// <summary>
		/// 	IsAffilate mute list
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 		Request affiliate query for a muted user.
		/// 	</Description>
		/// 	<Verify>
		/// 		HRESULT equal to S_FALSE 
		/// 	</Verify>
		/// </remarks>
		[TestCase]
		public void N_IsAffilate_Mute_List()
		{
			PNUser muted = CreateXenonUser(true);
			_owner.Mute(muted);
			PIsAffiliateReplyMsgData data = _state.ValidateIsAffiliateExternal(muted);
			ValueCheck.TestHR("IsAffiliateReply.HR", HResult.S_FALSE, data.hr);
		}

		/// <summary>
		/// 	IsAffiliate block list
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 		Request affiliate query for a blocked user.
		/// 	</Description>
		/// 	<Verify>
		/// 		HRESULT equal to S_FALSE
		/// 	</Verify>
		/// </remarks>
		[TestCase]
		public void N_IsAffiliate_Block_List()
		{
			PNUser muted = CreateXenonUser(true);
			_owner.Mute(muted);
			PIsAffiliateReplyMsgData data = _state.ValidateIsAffiliateExternal(muted);
			ValueCheck.TestHR("IsAffiliateReply.HR", HResult.S_FALSE, data.hr);
		}

		/// <summary>
		/// 	Query for affiliates without specifying a valid SG address in ticket
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 		Specify a zero SG addr on the internet port of FD.
		/// 	</Description>
		/// 	<Verify>
		/// 		HRESULT equal to XONLINE_E_SERVER_ERROR
		/// 	</Verify>
		/// </remarks>
		[TestCase]
		public void N_IsAffiliate_Zero_SGAddr()
		{
			bool caught = false;
			PMsgIsAffiliate request = new PMsgIsAffiliate(_owner, _owner);
			request.Msg.Hdr.Sgaddr.inaSg  = 0;
			request.Msg.Hdr.Sgaddr.SpiSg  = 0;
			request.Msg.Hdr.Sgaddr.XboxID = 0;

			try
			{
				PNMsg reply;
                request.TransactFD(out reply);
			}
			catch(XErrException ex)
			{
				caught = true;
                ValueCheck.TestHR("IsAffiliateReply.HR", xonline.common.service.HResult.XONLINE_E_SERVER_ERROR, ex.XErr);
			}

			if(!caught)
			{
				throw new UnexpectedTestResultException("Did not catch XRL exception from invalid request");
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\presencefunc\FuncFriendsLimitedPresence.cs ===
using System;
using System.Collections;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.Notification;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.UserAccount;
using xonline.common.diagnostics;
using xonline.common.protocol;

namespace PresenceTest
{
	/// <summary>
	/// Functional Tests for GetFriendsList
	/// </summary>
    [TestGroup, TestFrequency("Daily"), TestCasePriority(2), AsyncGroup(1, 0)]
    public class FuncFriendsLimitedPresence : PresenceTestBaseGroup
    {

        static Report ro = new Report("GetFriendsListLimitedPresence");

        static void SetPrivilege(PNUser user, uint priv, bool grant)
        {
            // Create a grant request
            XRLXeUpdateParentalControls request = new XRLXeUpdateParentalControls();
            request.UserPuid = user.UserId;
            request.Source = "STF-PRES-FPC";

            UserPrivileges grants = new UserPrivileges();
            UserPrivileges restrictions = new UserPrivileges();

            // Populate the new requested privilege
            if (grant)
            {
                grants[(int)priv] = true;
            }
            else
            {
                restrictions[(int)priv] = true;
            }

            request.UserGrantPrivileges = grants.ToArray();
            request.UserRestrictPrivileges = restrictions.ToArray();
            request.ExecuteSafe();

            Thread.Sleep(5000);
        }


        /// <summary>
        /// 	Request friends data for a friend who is online
        /// </summary>
        /// <remarks>
        /// 	<Description>
        /// 	</Description>
        /// 	<Verify>
        /// 	</Verify>
        /// </remarks>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public void P_GetFriendsListLimitedPresence_NoFriends()
        {
            PNUser requestor = CreateXenonUser(true);

            // Give presence some time and make sure these users don't have any transient messages
            Thread.Sleep(5000);

            // Get friends limited presence
            ro.Debug("Getting friends list for requestor...");

            // Get user A friends list, make sure he sees web friends. b should be online and c should be online
            PFriendsLimitedPresenceReplyMsgData replyData = requestor.GetFriendsLimitedPresence();
            ValueCheck.Test("Friend count", (ushort)0, (ushort)(replyData.cdwFriends));
        }

        /// <summary>
        /// 	Request friends data for a friend who is online
        /// </summary>
        /// <remarks>
        /// 	<Description>
        /// 	</Description>
        /// 	<Verify>
        /// 	</Verify>
        /// </remarks>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public void P_GetFriendsListLimitedPresence_OnePendingFriend()
        {
            PNUser requestor = CreateXenonUser(true);
            PNUser a;
            
            // Create some clean users who are friends
            a = CreateXenonUser(true);
            _fc.RequestFriend(requestor, a);

            // Give presence some time and make sure these users don't have any transient messages
            Thread.Sleep(5000);
            a.ProcessNotifications();

            // Get friends limited presence
            ro.Debug("Getting friends list for requestor...");

            // Get user A friends list, make sure he sees web friends. b should be online and c should be online
            PFriendsLimitedPresenceReplyMsgData replyData = requestor.GetFriendsLimitedPresence();
            ValueCheck.Test("Friend count", (ushort)1, (ushort)(replyData.cdwFriends));
            ValueCheck.TestNonZero<uint>("Friend Online", replyData.rgFriends[0].OnlineState & PresDefs.P_STATE_FLAG_ONLINE);
            ValueCheck.Test("Friend Status", PresDefs.P_BUDDY_STATUS_PENDING, replyData.rgFriends[0].FriendStatus);

            //Get Limited presense for the friend
            PFriendsLimitedPresenceReplyMsgData replyData2 = a.GetFriendsLimitedPresence();
            ValueCheck.TestNonZero<uint>("Friend Online", replyData2.rgFriends[0].OnlineState & PresDefs.P_STATE_FLAG_ONLINE);
            ValueCheck.Test("Friend Status", PresDefs.P_BUDDY_STATUS_REQUEST, replyData2.rgFriends[0].FriendStatus);

        }

       
        /// <summary>
        /// 	Request friends data for a friend who is online
        /// </summary>
        /// <remarks>
        /// 	<Description>
        /// 	</Description>
        /// 	<Verify>
        /// 	</Verify>
        /// </remarks>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public void P_GetFriendsListLimitedPresence_Online()
        {
            PNUser requestor = CreateXenonUser(true);

            PNUser a, b, c;

            // Create some clean users who are friends
            a = CreateXenonUser(true);
            b = CreateXenonUser(true);
            c = CreateXenonUser(true);
            _fc.MakeFriend(requestor, a);
            _fc.MakeFriend(requestor, b);
            _fc.RequestFriend(requestor, c);

            // Give presence some time and make sure these users don't have any transient messages
            Thread.Sleep(5000);
            a.ProcessNotifications();
            b.ProcessNotifications();
            c.ProcessNotifications();

            // Get friends limited presence
            ro.Debug("Getting friends list for requestor...");

            // Get user A friends list, make sure he sees web friends. b should be online and c should be online
            PFriendsLimitedPresenceReplyMsgData replyData = requestor.GetFriendsLimitedPresence();
            ValueCheck.Test("Friend count", (ushort)3, (ushort)(replyData.cdwFriends));
            ValueCheck.TestNonZero<uint>("Friend Online", replyData.rgFriends[0].OnlineState & PresDefs.P_STATE_FLAG_ONLINE);
            ValueCheck.TestNonZero<uint>("Friend Online", replyData.rgFriends[1].OnlineState & PresDefs.P_STATE_FLAG_ONLINE);
            ValueCheck.TestNonZero<uint>("Friend Online", replyData.rgFriends[2].OnlineState & PresDefs.P_STATE_FLAG_ONLINE);
            ValueCheck.Test("Friend Status", PresDefs.P_BUDDY_STATUS_OK, replyData.rgFriends[0].FriendStatus);
            ValueCheck.Test("Friend Status", PresDefs.P_BUDDY_STATUS_OK, replyData.rgFriends[1].FriendStatus);
            ValueCheck.Test("Friend Status", PresDefs.P_BUDDY_STATUS_PENDING, replyData.rgFriends[2].FriendStatus);

            //Get Limited presense for one of the friends
            PFriendsLimitedPresenceReplyMsgData replyData2 = b.GetFriendsLimitedPresence();
            ValueCheck.TestNonZero<uint>("Friend Online", replyData2.rgFriends[0].OnlineState & PresDefs.P_STATE_FLAG_ONLINE);
            ValueCheck.Test("Friend Status", PresDefs.P_BUDDY_STATUS_REQUEST, replyData2.rgFriends[0].FriendStatus);
        }

        /// <summary>
        /// 	Request friends data for a friend who is online
        /// </summary>
        /// <remarks>
        /// 	<Description>
        /// 	</Description>
        /// 	<Verify>
        /// 	</Verify>
        /// </remarks>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public void P_GetFriendsListLimitedPresence_FriendsOffline()
        {
            PNUser requestor = CreateXenonUser(true);

            PNUser a, b, c;

            // Create some clean users who are friends and keep them offline
            a = CreateXenonUser(true);
            b = CreateXenonUser(true);
            c = CreateXenonUser(true);
            _fc.MakeFriend(requestor, a);
            _fc.MakeFriend(requestor, b);
            _fc.RequestFriend(requestor, c);

          
        
            // Give presence some time and make sure these users don't have any transient messages
            Thread.Sleep(5000);
            a.ProcessNotifications();
            b.ProcessNotifications();
            c.ProcessNotifications();

            //Log them off
            _fc.LogoffUser(a);
            _fc.LogoffUser(b);
            _fc.LogoffUser(c); 

            // Get friends limited presence
            ro.Debug("Getting friends list for requestor...");

            // Get user A friends list, make sure he sees web friends. b should be online and c should be online
            PFriendsLimitedPresenceReplyMsgData replyData = requestor.GetFriendsLimitedPresence();
            ValueCheck.Test("Friend count", (ushort)3, (ushort)(replyData.cdwFriends));
            ValueCheck.Test("Friend Online", PresDefs.P_STATE_FLAG_NONE, replyData.rgFriends[0].OnlineState);
            ValueCheck.Test("Friend Online", PresDefs.P_STATE_FLAG_NONE, replyData.rgFriends[1].OnlineState);
            ValueCheck.Test("Friend Online", PresDefs.P_STATE_FLAG_NONE, replyData.rgFriends[2].OnlineState);
            ValueCheck.Test("Friend Status", PresDefs.P_BUDDY_STATUS_OK, replyData.rgFriends[0].FriendStatus);
            ValueCheck.Test("Friend Status", PresDefs.P_BUDDY_STATUS_OK, replyData.rgFriends[1].FriendStatus);
            ValueCheck.Test("Friend Status", PresDefs.P_BUDDY_STATUS_PENDING, replyData.rgFriends[2].FriendStatus);

            //Get Limited presense for one of the friends
            _fc.LogonUser(a);

            // Give presence some time
            Thread.Sleep(2000);

            PFriendsLimitedPresenceReplyMsgData replyData2 = c.GetFriendsLimitedPresence();
            ValueCheck.TestNonZero<uint>("Friend Online", replyData2.rgFriends[0].OnlineState & PresDefs.P_STATE_FLAG_ONLINE);
            ValueCheck.Test("Friend Status", PresDefs.P_BUDDY_STATUS_REQUEST, replyData2.rgFriends[0].FriendStatus);
        }
    }

    /// <summary>
    /// Functional Tests for GetFriendsList
    /// </summary>
    [TestGroup, TestFrequency("Daily"), TestCasePriority(2), AsyncGroup(1, 0)]
    public class FuncFriendsNoPresence : PresenceTestBaseGroup
    {

        static Report ro = new Report("GetFriendsListNoPresence");

        static void SetPrivilege(PNUser user, uint priv, bool grant)
        {
            // Create a grant request
            XRLXeUpdateParentalControls request = new XRLXeUpdateParentalControls();
            request.UserPuid = user.UserId;
            request.Source = "STF-PRES-FPC";

            UserPrivileges grants = new UserPrivileges();
            UserPrivileges restrictions = new UserPrivileges();

            // Populate the new requested privilege
            if (grant)
            {
                grants[(int)priv] = true;
            }
            else
            {
                restrictions[(int)priv] = true;
            }

            request.UserGrantPrivileges = grants.ToArray();
            request.UserRestrictPrivileges = restrictions.ToArray();
            request.ExecuteSafe();

            Thread.Sleep(5000);
        }


        /// <summary>
        /// 	Request friends data for a friend who is online
        /// </summary>
        /// <remarks>
        /// 	<Description>
        /// 	</Description>
        /// 	<Verify>
        /// 	</Verify>
        /// </remarks>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public void P_GetFriendsListNoPresence_Online()
        {
            PNUser requestor = CreateXenonUser(true);

            PNUser a, b;

            // Create some clean users who are friends
            a = CreateXenonUser(true);
            b = CreateXenonUser(true);
            _fc.MakeFriend(requestor, a);
            _fc.MakeFriend(requestor, b);

            // Give presence some time and make sure these users don't have any transient messages
            Thread.Sleep(5000);
            requestor.ProcessNotifications();
            a.ProcessNotifications();
            b.ProcessNotifications();

            // Get web friends
            ro.Debug("Getting friends list for requestor");

            // Get user A friends list, make sure he sees web friends. b should be online and c should be online
            PFriendsNoPresenceReplyMsgData replyData = requestor.GetFriendsNoPresence();
            ValueCheck.Test("Friend count", (ushort)2, (ushort)(replyData.cdwFriends));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\presencefunc\FuncPrivilegeControl.cs ===
using System;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.UserAccount;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.GI;
using ServerTestFramework.LiveService.Notification;
using ServerTestFramework.LiveService.Billing;
using xonline.common.diagnostics;
using xonline.common.protocol;
using xonline.common.config;
namespace PresenceTest
{
	/// <summary>
	/// 	Functional Tests for Privilege Control Bits
	/// </summary>
	/// <remarks>
	/// 	<Description>
	/// 		<p>
	/// 		Five privilege controls bits are used in presence to control certain communication
	/// 		code paths. The bits are loaded when a user alives and will not change unless
	/// 		until the user has left the system and their online record has been flushed from
	/// 		memory.
	/// 		</p>
	///
	///			<div class="test_data_label">
	/// 		The five control bits used by presence are as follows:
	/// 		</div>
	///
	///			<table class="test_data">
	///			<tr><th>Multiplayer Privilege               </th><td></td></tr>
	/// 		<tr><td>Define:                             </td><td>XONLINE_PRIVILEGE_MULTIPLAYER_SESSIONS</td></tr>
	/// 		<tr><td>Description:                        </td><td>On if a player is able to participate in multiplayer sessions.</td></tr>
	/// 		<tr><td>Notation:                           </td><td>+M,-M</td></tr>
	/// 		<tr><th>Communications Privilege            </th><td></td></tr>
	/// 		<tr><td>Define:                             </td><td>XONLINE_PRIVILEGE_COMMUNICATIONS</td></tr>
	/// 		<tr><td>Description:                        </td><td>On if a player is able to communicate with anyone in the live service.</td></tr>
	/// 		<tr><td>Notation:                           </td><td>+C,-C</td></tr>
	/// 		<tr><th>Friends Only Communication Privilege</th><td></td></tr>
	/// 		<tr><td>Define:                             </td><td>XONLINE_PRIVILEGE_COMMUNICATIONS_FRIENDS_ONLY</td></tr>
	/// 		<tr><td>Description:                        </td><td>On if the player is only able to communicate with members of thier friend list.</td></tr>
	/// 		<tr><td>Notation:                           </td><td>+fC,-fC</td></tr>
	/// 		<tr><th>Presence Privilege                  </th><td></td></tr>
	/// 		<tr><td>Define:                             </td><td>XONLINE_PRIVILEGE_PRESENCE</td></tr>
	/// 		<tr><td>Description:                        </td><td>On if the player will queue status changes to any subscribers.</td></tr>
	/// 		<tr><td>Notation:                           </td><td>+P,-P</td></tr>
	/// 		<tr><th>Friends Only Presence Privilege     </th><td></td></tr>
	/// 		<tr><td>Define:                             </td><td>XONLINE_PRIVILEGE_PRESENCE_FRIENDS_ONLY</td></tr>
	/// 		<tr><td>Description:                        </td><td>On if the payer will only queue status changes to subscribers in thier friend list.</td></tr>
	/// 		<tr><td>Notation:                           </td><td>+fP,-fP</td></tr>
	/// 		</table>
	///
	/// 		<p>
	/// 		In order to test the operation of these privileges in isolation a seperate group of
	/// 		tests runs will call the affected APIs with the bits in effect.
	/// 		</p>
	/// 		
	/// 		<p>
	/// 		The notation the test cases will adopt is to omit flags that are disabled.
	/// 		</p>
	/// 	</Description>
	/// </remarks>
    [TestGroup, TestFrequency("Regression"), TestCasePriority(3)]
	public class FuncPrivilegeControl : PresenceTestBaseGroup
	{
		static private Report ro = new Report(typeof(FuncPrivilegeControl).Name);

		//------------------------------------------------------------------------------
		//
		// Helper APIs for privilege testing
		//
		//------------------------------------------------------------------------------
		PNUser CreateOpenUser(bool goldUser)
		{
            XeUser xeu = new XeUser(true, _fc.Random.GenerateRandomMachineId(CSGInfo.ClientType.Xenon));
			xeu.BirthDate = DateTime.UtcNow.AddYears(-18);
			xeu.ParentalControlGroup = XOn.PARENTAL_CONTROL_GROUP_OPEN;
            if (goldUser)
            {
                xeu.OfferId = Offers.GetBaseOfferId(Offers.BaseOffers.GoldSignup);
            }
			ulong puid = xeu.Create();

			if(0 == puid)
			{
				throw new UnexpectedTestResultException("Failed to create user from billing: " + xeu.GetDumpString());
			}

			PNUser pnu = new PNUser(xeu.Gamertag, puid);
            FriendsCommon.WaitForXCache();
            _alUsers.Add(pnu);
            PNXbox xb = new PNXbox(FriendsCommon.DefaultXenonTitleId, ClientVersions.LatestXenonClientVersion, true);
			_fc.LogonUser(pnu, xb);

			return pnu;
		}

		PNUser CreateMediumUser(bool goldUser)
		{
            XeUser xeu = new XeUser(true, _fc.Random.GenerateRandomMachineId(CSGInfo.ClientType.Xenon));
			xeu.BirthDate = DateTime.UtcNow.AddYears(-15);
			xeu.ParentalControlGroup = XOn.PARENTAL_CONTROL_GROUP_MEDIUM;
            if (goldUser)
            {
                xeu.OfferId = Offers.GetBaseOfferId(Offers.BaseOffers.GoldSignup);
                xeu.BillingToken = Offers.GetBaseOfferPrepaidVoucherCode(Offers.BaseOffers.GoldPP1Year);
            }
            ulong puid = xeu.Create();

			if(0 == puid)
			{
				throw new UnexpectedTestResultException("Failed to create user from billing: " + xeu.GetDumpString());
			}


			PNUser pnu = new PNUser(xeu.Gamertag, puid);
            FriendsCommon.WaitForXCache();
            _alUsers.Add(pnu);
            PNXbox xb = new PNXbox(FriendsCommon.DefaultXenonTitleId, ClientVersions.LatestXenonClientVersion, true);
			_fc.LogonUser(pnu, xb);

			return pnu;
		}

		PNUser CreateRestrictedUser(bool goldUser)
		{
            XeUser parent = new XeUser(true);
            ulong puid = parent.Create();

            XeUser xeu = new XeUser(true, _fc.Random.GenerateRandomMachineId(CSGInfo.ClientType.Xenon));
			xeu.BirthDate = DateTime.UtcNow.AddYears(-13);
			xeu.ParentalControlGroup = XOn.PARENTAL_CONTROL_GROUP_RESTRICTED;
            if (goldUser)
            {
                xeu.OfferId = Offers.GetBaseOfferId(Offers.BaseOffers.GoldSignup);
            }
            puid = xeu.CreateMinor(parent,true);

			if(0 == puid)
			{
				throw new UnexpectedTestResultException("Failed to create user from billing: " + xeu.GetDumpString());
			}

			PNUser pnu = new PNUser(xeu.Gamertag, puid);
            FriendsCommon.WaitForXCache();
            _alUsers.Add(pnu);
            PNXbox xb = new PNXbox(FriendsCommon.DefaultXenonTitleId, ClientVersions.LatestXenonClientVersion, true);
			_fc.LogonUser(pnu, xb);

			return pnu;
		}

		void SetPrivilege(PNUser user, uint priv, bool grant)
		{
			// Create a grant request
			XRLXeUpdateParentalControls request = new XRLXeUpdateParentalControls();
			request.UserPuid = user.UserId;
			request.Source = "STF-PRES-FPC"; 

			UserPrivileges grants       = new UserPrivileges();
			UserPrivileges restrictions = new UserPrivileges();

			// Populate the new requested privilege
			if(grant)
			{
				grants[(int)priv] = true;
			}
			else
			{
				restrictions[(int)priv] = true;
			}

			request.UserGrantPrivileges    = grants.ToArray(); 
			request.UserRestrictPrivileges = restrictions.ToArray(); 
			request.ExecuteSafe();

			Thread.Sleep(5000);
		}

		//------------------------------------------------------------------------------
		// Privilege control scenarios invoked by tests
		//------------------------------------------------------------------------------
		void NoPresence2Scenario(PNUser a, PNUser b)
		{
            UserNotification noti = null;
			bool caught = false;

            //Get rid of residue.
            a.ProcessNotifications();
            b.ProcessNotifications();

            try
            {
                // Issue a title change, pulse title data (user should not push presence to a)
                b.State |= (XonPresNoti.P_STATE_MASK_PLAYING | XonPresNoti.P_STATE_MASK_JOINABLE);
                b.MatchSessionId = 0xaaaabbbbccccdddd;
                b.Xbox.ChangeTitle(b.Xbox.TitleId + 1, 0, 0);
                b.SetTitleData();

                try
                {
                    ro.Info("Waiting for presence 2 item timeout");
                    noti = a.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eBasicPresence);
                }
                catch (TimeOutException)
                {
                    caught = true;
                }

                if (!caught)
                {
                    a.HandleTCPNotification(noti);
                    throw new UnexpectedTestResultException("User: " + a.UserId.ToString("x") + " should not have received presence");
                }

                PresenceInfo info = a.GetPresenceInfo(b);
                ValueCheck.Test("GPI.cbRichPresence", (uint)0, info.cbRichPresence);
                ValueCheck.Test("GPI.cbStateData", (ushort)0, info.cbStateData);
                ValueCheck.Test("GPI.mtLastActive", (uint)0, info.mtLastActive);
                ValueCheck.Test("GPI.OnlineState", (uint)0, info.OnlineState);
            }
            finally
            {
                b.Xbox.ChangeTitle(b.Xbox.TitleId - 1);
                b.SetTitleData();
            }
		}

		void Presence2Scenario(PNUser a, PNUser b)
		{
            //Cleanup pending queue
            a.ProcessNotifications();
            b.ProcessNotifications();
			// Issue a title change, pulse title data (user should not push presence to a)
			b.SetTitleData((ulong)0xddddccccbbbbaaaa);
			
            UserNotification noti = null;

            noti = a.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eBasicPresence);
            a.HandleTCPNotification(noti);

			if(a.GetBuddyInfo(b.UserId).BasicPresenceData.MatchSessionId != 0xddddccccbbbbaaaa)
			{
				throw new UnexpectedTestResultException("User: " + a.UserId.ToString("x") + " did not receive correct presence");
			}

			PresenceInfo info = a.GetPresenceInfo(b);
			if(0 == (info.OnlineState & b.State) || info.qwSessionID != 0xddddccccbbbbaaaa)
			{
				throw new UnexpectedTestResultException("User: " + a.UserId.ToString("x") + " failed to match GetPresenceInfo for user: " + b.UserId.ToString("x"));
			}
		}

        void Presence2ScenarioRichOnly(PNUser a, PNUser b, bool filtered)
		{
            // clear out rich presence to ensure it changes to test filtering
            b.SetTitleData(new byte[8]);
            Thread.Sleep(2000);

            // process outstanding notifications
            a.ProcessNotifications();
            b.ProcessNotifications();

            string pi1;
            // Fill in the properties and contexts for presence context 0
            GIBlob gi = new GIBlob();
            gi.AddContext((uint)Pong.Context.GameMode, (uint)Pong.GameMode.SinglePlayer);
            gi.AddContext((uint)Pong.Context.GameSize, (uint)Pong.GameSize.Medium);
            gi.AddContext((uint)Pong.Context.GameSpeed, (uint)Pong.GameSpeed.Fast);
            b.SetTitleData(gi.GetBytes());

            try
            {
                UserNotification noti = a.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eRichPresenceString);
                Assert.IsTrue(!filtered, "Changing rich presence should not have sent a notification to this user.");
                a.HandleTCPNotification(noti);
                pi1 = a.GetBuddyInfo(b.UserId).RichPresenceData.RichPresenceString;
                //Pong Title Needs to be Propped
                ValueCheck.IsTrue(null != pi1, "Presence ListItem for user 2 is null");
                ValueCheck.IsTrue(pi1.Length != 0, "Presence rgbTitleStuff for user 2 is 0 length, even though it has been set. ");
            }
            catch (TimeOutException)
            {
                Assert.IsTrue(filtered, "Changing rich presence should have sent a notification to this user.");
                return;
            }
		}

		//------------------------------------------------------------------------------
		//
		// Game invite privilage control
		//
		//------------------------------------------------------------------------------

        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
		public void P_RestrictedUser_CanFriends()
		{
			PNUser a = CreateOpenUser(true);
			PNUser b = CreateRestrictedUser(true);
			_fc.MakeFriend(a, b);
		}


        [TestCase, TestFrequency("Daily"), TestCasePriority(2), Ignore("SetPrivilege throws in new system for restricted user. Need to investigate alternatives.")]
		public void P_RestrictedUser_PresenceFriendsOnly()
		{
			PNUser a = CreateOpenUser(true);
			PNUser b = CreateOpenUser(true);
			PNUser c = CreateRestrictedUser(true);
            //c needs to use Pong for SetTitleData with rich presence to work
            c.Xbox.ChangeTitle(Pong.TitleId);
            c.SetTitleData();

			// A->C friends
			_fc.MakeFriend(a, c);

			// B->C peer subscribed
			b.PeerSubscribe(new PNUser[]{c});

			SetPrivilege(c, XOn.XPRIVILEGE_PRESENCE, false);
			SetPrivilege(c, XOn.XPRIVILEGE_PRESENCE_FRIENDS_ONLY, true);

			Presence2Scenario(a, c);
            Presence2ScenarioRichOnly(a, c, false);
			NoPresence2Scenario(b, c);
            Presence2ScenarioRichOnly(b, c, true);

            // A->C peer subscribed
            a.PeerSubscribe(new PNUser[] { c });
            Presence2ScenarioRichOnly(a, c, false);
		}

        [TestCase, TestFrequency("Daily"), TestCasePriority(2), Ignore("SetPrivilege throws in new system for restricted user. Need to investigate alternatives.")]
		public void P_RestrictedUser_NoPresence()
		{
			PNUser a = CreateOpenUser(true);
			PNUser b = CreateOpenUser(true);
			PNUser c = CreateRestrictedUser(true);

			// A->C friends
			_fc.MakeFriend(a, c);

			// B->C peer subscribed
			b.PeerSubscribe(new PNUser[]{c});

			SetPrivilege(c, XOn.XPRIVILEGE_PRESENCE, false);
			SetPrivilege(c, XOn.XPRIVILEGE_PRESENCE_FRIENDS_ONLY, false);
            
            // dequeue offline presence 
            UserNotification noti = a.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eBasicPresence);
            a.HandleTCPNotification(noti);

            // dequeue offline presence 
            noti = b.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eBasicPresence);
            b.HandleTCPNotification(noti);

			NoPresence2Scenario(a, c);
			NoPresence2Scenario(b, c);
		}

        //// We don't handle the multiplayer bit on the server as of this release
        //[TestCase,Ignore]
        //public void P_RestrictedUser_GrantMultiplayer()
        //{
        //    // Create two users
        //    // 	A -- open control group 
        //    // 	B -- restricted parentally controlled user
        //    PNUser a = CreateOpenUser(true);
        //    PNUser b = CreateRestrictedUser(true);

        //    // 	Make sure that user A invite does not arrive for B
        //    // 	Make sure that user B invite does not arrive for A 
        //    SendInvite(a, b);
        //    ValidateNoInvite(a, b);
        //    SendInvite(b, a);
        //    ValidateNoInvite(b, a);

        //    // Grant multiplayer
        //    SetPrivilege(b, XOn.XPRIVILEGE_MULTIPLAYER_SESSIONS, true);

        //    // Make sure that the invite can go between users
        //    SendInvite(a, b);
        //    ValidateInvite(a, b);
        //    CancelInvite(a, b);
        //    SendInvite(b, a);
        //    ValidateInvite(b, a);
        //    CancelInvite(b, a);
        //}

		// We don't handle the multiplayer bit on the server as of this release
        //[TestCase,Ignore]
        //public void P_RestrictedUserFriends_GrantMultiplayer()
        //{
        //    // Create two users
        //    // 	A -- open control group 
        //    // 	B -- restricted parentally controlled user
        //    PNUser a = CreateOpenUser(true);
        //    PNUser b = CreateRestrictedUser(true);

        //    _fc.MakeFriend(a, b);

        //    // 	Make sure that user A invite does not arrive for B
        //    // 	Make sure that user B invite does not arrive for A 
        //    SendInvite(a, b);
        //    ValidateNoInvite(a, b);
        //    SendInvite(b, a);
        //    ValidateNoInvite(b, a);

        //    // Grant multiplayer
        //    SetPrivilege(b, XOn.XPRIVILEGE_MULTIPLAYER_SESSIONS, true);

        //    // Make sure that the invite can go between users
        //    SendInvite(a, b);
        //    ValidateInvite(a, b);
        //    CancelInvite(a, b);
        //    SendInvite(b, a);
        //    ValidateInvite(b, a);
        //    CancelInvite(b, a);
        //}

        //[TestCase]
        //public void P_RestrictedUser_GrantCommunications()
        //{
        //    // Create users
        //    PNUser a = CreateOpenUser(true);
        //    PNUser b = CreateRestrictedUser(true);

        //    // Make sure we can't send A->B, B->A
        //    SendMessage(a, b);
        //    SendMessage(b, a);

        //    ValidateNoMessage(a, b);
        //    ValidateNoMessage(b, a);

        //    // Enable communications
        //    SetPrivilege(b, XOn.XPRIVILEGE_COMMUNICATIONS, true);

        //    SendMessage(a, b);
        //    SendMessage(b, a);

        //    ValidateSingleMessage(a, b);
        //    ValidateSingleMessage(b, a);
        //}

        //[TestCase]
        //public void P_RestrictedUser_GrantCommunicationsFriendsOnly()
        //{
        //    // Create users
        //    PNUser a = CreateOpenUser(true);
        //    PNUser b = CreateRestrictedUser(true);

        //    // Make sure we can't send A->B, B->A
        //    SendMessage(a, b);
        //    SendMessage(b, a);

        //    ValidateNoMessage(a, b);
        //    ValidateNoMessage(b, a);

        //    // Enable communications
        //    SetPrivilege(b, XOn.XPRIVILEGE_COMMUNICATIONS_FRIENDS_ONLY, true);

        //    // Make friends
        //    _fc.MakeFriend(a, b);

        //    SendMessage(a, b);
        //    SendMessage(b, a);

        //    ValidateSingleMessage(a, b);
        //    ValidateSingleMessage(b, a);
        //}

        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
		public void P_Open_NoPresence()
		{
			PNUser a = CreateOpenUser(true);
			PNUser b = CreateOpenUser(true);
			PNUser c = CreateOpenUser(true);

			_fc.MakeFriend(a, c);

			b.PeerSubscribe(new PNUser[]{c});

            //note: won't work in xconnsrv
            //// Clear initial watch start 
            //QValPacket qval = b.WaitForQFlags(XonPresNoti.QFLAG_MASK_PRESENCE_2);
            //b.HandleQValPacket(qval);

			SetPrivilege(c, XOn.XPRIVILEGE_PRESENCE, false);
			SetPrivilege(c, XOn.XPRIVILEGE_PRESENCE_FRIENDS_ONLY, false);

			// clear the offline presence record from the invalidate
            UserNotification noti = a.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eBasicPresence);
            a.HandleTCPNotification(noti);

			// clear the offline presence record from the invalidate
            noti = b.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eBasicPresence);
            b.HandleTCPNotification(noti);

			NoPresence2Scenario(a, c);
			NoPresence2Scenario(b, c);
		}

        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
		public void P_Uacs_Integration()
		{
			XeUser user = new XeUser(true);
			ulong userPuid = user.Create();
			if (userPuid == 0) 
			{
				throw new UnexpectedTestResultException("XeUser.Create failed: " + user.GetDumpString());
			}

			PNUser pnuser = new PNUser(user.Gamertag, userPuid);
            _alUsers.Add(pnuser);
			_fc.LogonUser(pnuser);

			XRLXeUpdateParentalControls request = new XRLXeUpdateParentalControls();

			request.UserPuid = userPuid;
			request.Source = "stftest"; // this is the grantor of the priv (for auditing)
			UserPrivileges privs = new UserPrivileges();


			privs.SetAllPrivs(true);
			request.UserGrantPrivileges = privs.ToArray(); // grant all privileges

			// privileges only get revoked if a value in the priv array is set to true
			privs.SetAllPrivs(false);
			request.UserRestrictPrivileges = privs.ToArray();  // do not revoke any privs

			if (!request.Execute()) 
				throw new UnexpectedTestResultException("XeUpdateParentalControlsTests failed: " + request.GetDumpString());
			if (request.XErr != HResult.S_OK)
				throw new UnexpectedTestResultException(String.Format("XeUpdateParentalControlsTests returned XErr=0x{0:x}", request.XErr));

			// we won't verify the database state in the mainline case.
		}

		/// <summary>
		/// 	Game invite privilege bits test matrix
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 		<p class="test_case_description_body">
		/// 		Game invites obey the M,C,fC flags. Presence flags will have an impact
		/// 		on your disovery process of a game invite but do not change the code path
		/// 		once you have succesfully selected a XUID in an invite message. Game invites
		/// 		are delivered through the messaging system and stored in memory as 'transient' 
		/// 		messages. Respose to a game invite is delivered ansynchronously through the 
		/// 		transient message queue in the form of P_INVITATION_ANSWER_ITEM. 
		/// 		</p>
		///
		///			<p class="test_case_description_body">
		///			There are eight possible bit patterns possible for a recipient of a game invite.
		///			There will be a user representing each bit pattern and one user to control
		///			the test:
		///			</p>
		///
		///			<table class="test_data">
		///				<tr><td>User0: </td><td>-M-C-fC</td></tr>
		///				<tr><td>User1: </td><td>-M-C+fC</td></tr>
		///				<tr><td>User2: </td><td>-M+C-fC</td></tr>
		///				<tr><td>User3: </td><td>-M+C+fC</td></tr>
		///				<tr><td>User4: </td><td>+M-C-fC</td></tr>
		///				<tr><td>User5: </td><td>+M-C+fC</td></tr>
		///				<tr><td>User6: </td><td>+M+C-fC</td></tr>
		///				<tr><td>User7: </td><td>+M+C+fC</td></tr>
		///			</table>
		///
		///			<p class="test_case_description_body">
		///			The valid recipient patterns as currently implemented by the invite
		///			code path are:
		///			</p>
		///
		///			<table class="test_data">
		///				<tr><td>A:</td><td> Single friend</td></tr>
		///				<tr><td>B:</td><td> Single non-friend</td></tr>
		///				<tr><td>C:</td><td> Multiple friends</td></tr>
		///				<tr><td>D:</td><td> Multiple non-friends</td></tr>
		///				<tr><td>E:</td><td> Mix friends/non-friend</td></tr>
		///			</table>
		///
		///			<p class="test_case_description_body">
		///			The tests will not try to combine mixed in/out online record memory conditions since 
		///			that condition must be satisfied out of the main invite privilege condition.
		///			</p>
		///
		///			<p class="test_case_description_body">
		///			To create the five recipient patterns we will create four control users. Each controller
		///			has all bits on. We will initiate each scenario with one of the controllers, except mix
		///			scenarios where we require two control users. The relationship of the controller to the 
		///			users is as follows:
		///			</p>
		///
		///			<table class="test_data">
		///				<tr><td>NonFriendSender:    </td><td>+M+C+fC   </td><td>None             </td><td>(NFS)</td></tr>
		///				<tr><td>FriendSender:       </td><td>+M+C+fC   </td><td>0,1,2,3,4,5,6,7  </td><td>(FS)</td></tr>
		///				<tr><td>MixSenderA:         </td><td>+M+C+fC   </td><td>1,3,5,7          </td><td>(MSA)</td></tr>
		///				<tr><td>MixSenderB:         </td><td>+M+C+fC   </td><td>0,2,4,6          </td><td>(MSB)</td></tr>
		///			</table>
		///
		///			Each scenario will use a specific query to grab controller(s) and recipients for that scenario. 
		/// 		
		/// 	</Description>
		/// 	<Verify>
		/// 		<p class="test_case_verify_body">
		/// 		Internally the  server to server messaging will populate an HR of 
		/// 		XONLINE_E_MESSAGE_UNDELIVERABLE in the recipients list when blocked. Unfortunately, this
		/// 		is not disoverable by the testing framework. 
		/// 		</p>
		///
		/// 		<p class="test_case_verify_body">
		/// 		To detect a success the test will answer any received invites with a positive YES answer 
		/// 		the control users will dequeue and collect all invite answer items. Once the QVAL timout has been hit
		/// 		the test conditions should be satisfied.
		/// 		</p>
		///
		///			<p class="test_case_verify_body">
		///			Each test will run until the QVAL timeout interval has been reached. At that point
		///			each user participating in the scenario will have their privilege bits verified against
		///			their relationship to the controller.
		///			</p>
		///
		/// 		<p class="test_case_verify_body">
		/// 		Validation table:
		/// 		</p>
		///
		///			<p class="test_case_verify_body">
		/// 		+ Indicates invitatation answer item
		/// 		- Indicates no invitation answer item
		/// 		</p>
		///			
		///			<ul>
		///				<li>Scenario A 'Single friend' Iterations: </li>
		///					<ul>
		///					<li>FS: -User0</li>
		///					<li>FS: -User1</li>
		///					<li>FS: -User2</li>
		///					<li>FS: -User3</li>
		///					<li>FS: -User4</li>
		///					<li>FS: +User5</li>
		///					<li>FS: +User6</li>
		///					<li>FS: +User7</li>
		///					</ul>
		///
		///				<li>Scenario B 'Single non-friend' Iterations: </li>
		///					<ul>
		///					<li>NFS: -User0</li>
		///					<li>NFS: -User1</li>
		///					<li>NFS: -User2</li>
		///					<li>NFS: -User3</li>
		///					<li>NFS: -User4</li>
		///					<li>NFS: -User5</li>
		///					<li>NFS: +User6</li>
		///					<li>NFS: -User7</li>
		///					</ul>
		///
		///				<li>Scenario C 'Multiple friends' Iterations:</li>
		///					<ul>
		///					<li>FS: -User0, -User1, -User2, -User3, -User4, +User5, +User6, +User7</li>
		///					</ul>
		///
		///				<li>Scenario D 'Multiple non-friends' Iterations:</li>
		///					<ul>
		///					<li>NFS: -User0, -User1, -User2, -User3, -User4, -User5, +User6, -User7</li>
		///					</ul>
		///
		///				<li>Scenario E 'Mix friends/non-friends' Iterations: </li>
		///					<ul>
		///					<li>MSA: -User0, -User1, -User2, -User3, -User4, +User5, +User6, +User7</li>
		///					<li>MSB: -User0, -User1, -User2, -User3, -User4, -User5, +User6, -User7</li>
		///					</ul>
		///
		///			</ul>
		/// 	</Verify> 
		/// </remarks> 
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
		public void P_GameInvite_Privilege_Matrix()
		{
		}

		/// <summary>
		/// 	Send message privilege bits test matrix
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 		<p class="test_case_description_body">
		/// 		Message sending only obeys the C,fC flags. For each recipient of a message
		/// 		that is not a friend request the C and fC privilege bits are tested.
		/// 		</p>
		///
		/// 		<p class="test_case_description_body">
		/// 		There are four possible bit combinations that control message send privilege
		/// 		code paths. For each of these combinations we will create one user.
		/// 		</p>
		///
		/// 		<table class="test_data">
		/// 			<tr><td>User0: </td><td>-C-fC</td></tr>
		/// 			<tr><td>User1: </td><td>-C+fC</td></tr>
		/// 			<tr><td>User2: </td><td>+C-fC</td></tr>
		/// 			<tr><td>User3: </td><td>+C+fC</td></tr>
		/// 		</table>
		///
		///			<p class="test_case_description_body">
		///			The valid recipient patterns as currently implemented by the send message
		///			code path are:
		///			</p>
		///
		///			<table class="test_data">
		///				<tr><td>A: </td><td>Single friend </td></tr>
		///				<tr><td>B: </td><td>Single non-friend </td></tr>
		///				<tr><td>C: </td><td>Multiple friends </td></tr>
		///				<tr><td>D: </td><td>Multiple non-friends </td></tr>
		///				<tr><td>E: </td><td>Mix friends/non-friends</td></tr>
		///			</table>
		///
		///			<p class="test_case_description_body">
		///			To create the five recipient patterns we will create four control users. Each controller
		///			has all bits on. We will initiate each scenario with one of the controllers, except mix
		///			scenarios where we require two control users. The relationship of the controller to the 
		///			users is as follows:
		///			</p>
		///
		///			<table class="test_data">
		///				<tr><td>NonFriendSender:    </td><td>+M+C+fC   </td><td>None             </td><td>(NFS)</td></tr>
		///				<tr><td>FriendSender:       </td><td>+M+C+fC   </td><td>0,1,2,3,4,5,6,7  </td><td>(FS)</td></tr>
		///				<tr><td>MixSenderA:         </td><td>+M+C+fC   </td><td>1,3,5,7          </td><td>(MSA)</td></tr>
		///				<tr><td>MixSenderB:         </td><td>+M+C+fC   </td><td>0,2,4,6          </td><td>(MSB)</td></tr>
		///			</table>
		///
		///			<p class="test_case_description_body">
		///			Each scenario will use a specific query to grab controller(s) and recipients for that scenario. 
		///			</p>
		/// 	</Description>
		/// 	<Verify>
		/// 		<p class="test_case_verify_body">
		/// 		To detect a success the test will answer any received invites with a positive YES answer 
		/// 		the control users will dequeue and collect all invite answer items. Once the QVAL timout has been hit
		/// 		the test conditions should be satisfied.
		/// 		</p>
		///
		///			<p class="test_case_verify_body">
		///			Each test will run until the QVAL timeout interval has been reached. At that point
		///			each user participating in the scenario will have their privilege bits verified against
		///			their relationship to the controller.
		///			</p>
		///
		/// 		<p class="test_case_verify_body">
		/// 		Validation table:
		/// 		</p>
		///
		/// 		<p class="test_case_verify_body">
		/// 		(+) Indicates invitatation answer item, (-) Indicates no invitation answer item
		/// 		</p>
		///			
		///			<ul>
		///				<li>Scenario A 'Single friend' Iterations:</li>
		///					<ul>
		///					<li>FS: -User0</li>
		///					<li>FS: -User1</li>
		///					<li>FS: +User2</li>
		///					<li>FS: +User3</li>
		///					<li>FS: -User4</li>
		///					<li>FS: -User5</li>
		///					<li>FS: +User6</li>
		///					<li>FS: +User7</li>
		///					</ul>
		///
		///				<li>Scenario B 'Single non-friend' Iterations:</li>
		///					<ul>
		///					<li>NFS: -User0</li>
		///					<li>NFS: -User1</li>
		///					<li>NFS: +User2</li>
		///					<li>NFS: -User3</li>
		///					<li>NFS: -User4</li>
		///					<li>NFS: -User5</li>
		///					<li>NFS: +User6</li>
		///					<li>NFS: -User7</li>
		///					</ul>
		///
		///				<li>Scenario C 'Multiple friends' Iterations:</li>
		///					<ul>
		///					<li>FS: -User0, -User1, +User2, +User3, -User4, -User5, +User6, +User7</li>
		///					</ul>
		///
		///				<li>Scenario D 'Multiple non-friends' Iterations:</li>
		///					<ul>
		///					<li>NFS: -User0, -User1, +User2, -User3, -User4, -User5, +User6, -User7</li>
		///					</ul>
		///
		///				<li>Scenario E 'Mix friends/non-friends' Iterations:</li>
		///					<ul>
		///					<li>MSA: -User0, -User1, +User2, +User3, -User4, +User5, +User6, +User7</li>
		///					<li>MSB: -User0, -User1, +User2, -User3, -User4, -User5, +User6, -User7</li>
		///					</ul>
		///			</ul>
		/// 	</Verify> 
		/// </remarks> 
        [TestCase, TestFrequency("Daily"), TestCasePriority(2)]
		public void P_SendMessage_PrivilegeMatrix()
		{
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\presencefunc\FuncNotification.cs ===
using System;
using System.Threading;
using System.Collections;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.GI;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.Notification;
using xonline.common.diagnostics;


namespace PresenceTest
{
	/// <summary> 
	/// Functional Tests Asyncronous Presence Queues. All this tests are Pri1 and BVT.
	/// </summary>
	/// <remarks>
	/// <Description>
	/// <p>
	/// Functional dequeue test cases are intendend verify proper operation of queues that are exposed to the
	/// xbox 1 and xenon clients. Operations are performed which cause a Q_ADD on the appropriate PQUEUE type.
	/// The items that are added to the queue are then dequeued using the QMSG_DEQUEUE XRL and validated on a 
	/// per item basis.
	/// </p>
	///
	/// <div class="test_data_label">
	/// The queues that are available for dequeue are as follows:
	/// </div>
	/// 	<ul>
	/// 		<li>XBOX 1 Clients</li>
	/// 		<ul>
	/// 		<li>PQUEUE_BUDDY_REQ</li>
	/// 		<li>PQUEUE_LIST_CHANGE</li>
	/// 		<li>PQUEUE_PRESENCE</li>
	/// 		<li>PQUEUE_INVITE</li>
	/// 		<li>PQUEUE_INVITE_ANSWER</li>
	/// 		<li>PQUEUE_PEER_PRESENCE</li>
	/// 		</ul>
	///			
	/// 		<li>XENON Clients</li>
	/// 		<ul>
	/// 		<li>PQUEUE_BUDDY_REQ</li>
	/// 		<li>PQUEUE_LIST_CHANGE</li>
	/// 		<li>PQUEUE_INVITE</li>
	/// 		<li>PQUEUE_INVITE_ANSWER</li>
	/// 		<li>PQUEUE_PRESENCE_2</li>
	/// 		</ul>
	/// 	</ul>
	///
	/// <p>
	/// In order to properly test interop issues and that the queues operate
	/// properly for users or developers running consoles of different versions
	/// a variety clients will be used in the tests with the following client
	/// version numbers.
	/// </p>
	/// 
	/// <div class="test_data_label">
	/// Xbox 1 clients:
	/// </div>
	/// 	<ul>
	/// 	<li>XboxA</li>
	/// 	<li>XboxB</li>
	/// 	</ul>
	///
	/// <div class="test_data_label">
	/// Xenon clients (Xenon flag is true):
	/// </div>
	/// 	<ul>
	/// 	<li>XboxC</li>
	/// 	<li>XboxD</li>
	/// 	</ul>
	///
	/// <p>
	/// Additionally the tests will involve scenarios putting 1-4 users
	/// on each xbox and have them try to communicate back and forth
	/// using the asyncronous notification queues and the XRLs required
	/// to queue up queue items.
	/// </p>
	/// </Description>
	/// </remarks>
    [TestGroup, TestFrequency("BVT"), TestCasePriority(1), AsyncGroup(1, 0)]
	class FuncNotifications : PresenceTestBaseGroup
	{
        static Report _Report = new Report(typeof(FuncNotifications).Name);

		// TODO: Implement
		public void DumpReply(UserNotification noti)
		{
//            _Report.Debug("QDequeueReply: HR: {0}, QType: {1}, UserId: {2:x}, NextItemID: {3}, QLeft: {4}",
//                    reply.Hdr.HR, reply.Hdr.QType, reply.Hdr.UserID, reply.Hdr.NextItemID, reply.Hdr.QLeft);

//            if(reply.Hdr.QVals.Length != 15)
//            {
//                _Report.Debug("QDequeueReply: No QVals to print");
//                goto lbDone;
//            }

//            string strFlags = XonPresNoti.BuildQFlagsString(reply.Hdr.QVals[0]);

//            // Dump QVals
//            _Report.Debug("  Notification QFlags {0:x8}, {1:x8} ({2})",
//                reply.Hdr.QVals[0],
//                reply.Hdr.QVals[1],
//                strFlags);
			
//            _Report.Debug("  Invite(bool): {0:x8}",
//                reply.Hdr.QVals[2]);

//            _Report.Debug("  NewMsgIds: {0:x8}, 0: {1:x8}, 1: {2:x8}, 2: {3:x8}",
//                reply.Hdr.QVals[3],
//                reply.Hdr.QVals[4],
//                reply.Hdr.QVals[5],
//                reply.Hdr.QVals[6]);

//            _Report.Debug("   NewMsgData: {0:x8}, 0: {1:x8}, 1: {2:x8}, 2: {3:x8}",
//                reply.Hdr.QVals[7],
//                reply.Hdr.QVals[8],
//                reply.Hdr.QVals[9],
//                reply.Hdr.QVals[10]);

//            _Report.Debug("   DelMsgIds: {0:x8}, 0: {1:x8}, 1: {2:x8}, 2: {3:x8}",
//                reply.Hdr.QVals[11],
//                reply.Hdr.QVals[12],
//                reply.Hdr.QVals[13],
//                reply.Hdr.QVals[14]);

//            ListItem[] items = reply.Items;
//            for(int i = 0; i < items.Length; ++i)
//            {
//                ListItem li = items[i];
//                _Report.Debug("ListItem[{0}]: ItemId: {1}, ItemLen: {2}", i, li.Hdr.ItemID, li.Hdr.ItemLen);
//            }

//lbDone:
            return;
		}

		/// <summary>
		/// 	Dequeue a buddy list change on the PQUEUE_BUDDY_REQUEST queue
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 		If UserA and UserB are friends then we will delete their
		/// 		friend relationship or create if it doesn't exist. UserB
		/// 		will wait on QFLAG_MASK_LIST_CHANGE for 30 seconds. When notification
		/// 		arrives the P_LIST_CHANGE_ITEM is dequeued and validated.
		/// 	</Description>
		/// 	<Verify>
		/// 		Ensure more than 0 items are delivered on the PQUEUE_LIST_CHANGE queue.
		/// 		Per-field validation of the P_LIST_CHANGE_ITEM.
		/// 	</Verify> 
		/// </remarks> 
		[TestCase]
		public void P_Dequeue_List_Change()
		{
			PNUser xenona = CreateXenonUser(true);
			PNUser xenonb = CreateXenonUser(true);

			_Report.Debug("ListChangeScenario: Xenon<->Xenon");
			ListChangeDequeueScenario(xenona, xenonb);
		}

		void ListChangeDequeueScenario(PNUser a, PNUser b)
		{
            QValPacket qval = null;

			// Add buddy maps to buddy request on receiver and list change
			// on requestor.
			//
			// It is special cased in the server

			// add buddy (initiator request track) 
			_Report.Debug("AddBuddy...");
			_Report.Debug("Wait for A LIST_CHANGE");
			a.AddBuddy(b);

            qval = a.WaitForQFlags(XonPresNoti.QFLAG_MASK_LIST_CHANGE);
            a.HandleQValPacket(qval);

			// add buddy (receiver request track)
			_Report.Debug("Wait for B BUDDY_REQ");
            qval = b.WaitForQFlags(XonPresNoti.QFLAG_MASK_BUDDY_REQ);
            b.HandleQValPacket(qval);

			// accept buddy (initiator list change)
			_Report.Debug("AcceptBuddy...");
			_Report.Debug("Wait for A LIST_CHANGE");		
			b.AcceptBuddy(a);
            qval = a.WaitForQFlags(XonPresNoti.QFLAG_MASK_LIST_CHANGE);
            a.HandleQValPacket(qval);

			// accept buddy (receiver list change)
			_Report.Debug("Wait for B LIST_CHANGE");
            qval = b.WaitForQFlags(XonPresNoti.QFLAG_MASK_LIST_CHANGE);
            b.HandleQValPacket(qval);

			// delete buddy (initiator list change)
			_Report.Debug("DeleteBuddy...");		
			a.DeleteBuddy(b);
			_Report.Debug("Wait for A LIST_CHANGE");
            qval = a.WaitForQFlags(XonPresNoti.QFLAG_MASK_LIST_CHANGE);
            a.HandleQValPacket(qval);

			// delete buddy (receiver list change)
			_Report.Debug("Wait for B LIST_CHANGE");
            qval = b.WaitForQFlags(XonPresNoti.QFLAG_MASK_LIST_CHANGE);
            b.HandleQValPacket(qval);
        }

		/// <summary>
		/// 	Dequeue peer rich presence data on the presence 2 queue
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 		UserD adds a peer subscription for UserC. UserC does a set state
		/// 		on the presence SG state handler with a GI blob. UserD waits for
		/// 		QFLAG_MASK_PRESENCE_2 for 30 seconds. Dequeue raw P_PRESENCE_ITEM_2
		/// 		and validate.
		/// 	</Description>
		/// 	<Verify>
		/// 		Ensure more than 0 P_PRESENCE_ITEM_2 items returned on dequeue call.
		/// 		Per-field validation of the presence item.
		/// 	</Verify> 
		/// </remarks> 
		[TestCase]
		public void P_Dequeue_Peer_Presence_Rich()
		{
			// Note: this comes in on the presence_2 queue
            PNUser a = CreateXenonUser(true);
            PNUser b = CreateXenonUser(true, Pong.TitleId);

            PNUser c = CreatePanoramaUser(true);
            PNUser d = CreatePanoramaUser(true, Pong.TitleId);

            a.AddPeerSubscription(b);
            a.AddPeerSubscription(d);
            c.AddPeerSubscription(b);
            c.AddPeerSubscription(d);

			GIBlob gi = new GIBlob();
			gi.TitlePresence = 1;
			gi.AddProperty(new GIProperty((uint)Pong.PropertyPoints, (int)17));
			gi.AddProperty(new GIProperty((uint)Pong.PropertyLosses, (int)3));
			gi.AddProperty(new GIProperty((uint)Pong.PropertyWins, (int)11));

			gi.AddContext((uint)Pong.Context.GameMode, (uint)Pong.GameMode.MultiPlayer);
			gi.AddContext((uint)Pong.Context.WinScore, (uint)Pong.WinScore.Points21);
            
            // handle any pending qvals
			a.ProcessNotifications();
            c.ProcessNotifications();

			// change user b state
			b.SetTitleData(gi.GetBytes());
            d.SetTitleData(gi.GetBytes());
            
			// peer presence comes in on the pres 2 queue
            UserNotification noti = a.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eRichPresenceString);
            
            //DumpReply(data); TODO: DumpReply (noti);
			ValueCheck.TestNonZero("notification data count", noti.SubscriptionData.data.Length);

            noti = c.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eRichPresenceString);
            //DumpReply(data); todo: dumpreply (Noti);
            ValueCheck.TestNonZero("notification data count", noti.SubscriptionData.data.Length);
		}

		/// <summary>
		/// 	Dequeue friend rich presence data on the presence 2 queue 
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 		Make two friends using users logged in on Xenon consoles. SetState on one user
		/// 		with a GI blob. Wait for QFLAG_MASK_PRESENCE_2 qflag for 30 seconds. Dequeue
		/// 		the raw P_PRESENCE_ITEM_2 and validate.
		/// 	</Description>
		/// 	<Verify>
		/// 		Ensure more than 1 P_PRESENCE_ITEM_2 is returned on the dequeue call.
		/// 		Per-field validation of the presence item.
		/// 	</Verify> 
		/// </remarks> 
		[TestCase]
		public void P_Dequeue_Presence_2()
		{
			PNUser a = CreateXenonUser(true, Pong.TitleId);
            PNUser b = CreateXenonUser(true, Pong.TitleId);

            PNUser c = CreatePanoramaUser(true, Pong.TitleId);
            PNUser d = CreatePanoramaUser(true, Pong.TitleId);

			_fc.MakeFriend(a, b);
            _fc.MakeFriend(a, d);

            _fc.MakeFriend(c, b);
            _fc.MakeFriend(c, d);
            
			GIBlob gi = new GIBlob();
			gi.TitlePresence = 1;
			gi.AddProperty(new GIProperty((uint)Pong.PropertyPoints, (int)17));
			gi.AddProperty(new GIProperty((uint)Pong.PropertyLosses, (int)3));
			gi.AddProperty(new GIProperty((uint)Pong.PropertyWins, (int)11));

			gi.AddContext((uint)Pong.Context.GameMode, (uint)Pong.GameMode.MultiPlayer);
			gi.AddContext((uint)Pong.Context.WinScore, (uint)Pong.WinScore.Points21);

			// handle any pending qvals
			b.ProcessNotifications();
            d.ProcessNotifications();

			a.SetTitleData(gi.GetBytes());
            c.SetTitleData(gi.GetBytes());

            UserNotification noti;
            noti = b.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eRichPresenceString);
			//DumpReply(noti); 
			ValueCheck.TestNonZero("notification data count", noti.SubscriptionData.data.Length);

            noti = d.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eRichPresenceString);
            //DumpReply(noti);
            ValueCheck.TestNonZero("notification data count", noti.SubscriptionData.data.Length);

			// handle any pending qvals
			a.ProcessNotifications();
            c.ProcessNotifications();

			b.SetTitleData(gi.GetBytes());
            d.SetTitleData(gi.GetBytes());

            noti = a.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eRichPresenceString);
			//DumpReply(noti);
			ValueCheck.TestNonZero("notification data count", noti.SubscriptionData.data.Length);

            noti = c.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eRichPresenceString);
            //DumpReply(noti);
            ValueCheck.TestNonZero("notification data count", noti.SubscriptionData.data.Length);
        }

        [TestCase]
        public void P_Dequeue_Presence_2_XenonOnly()
        {
            UserNotification noti;
            PNUser a = CreateXenonUser(true, Pong.TitleId);
            PNUser b = CreateXenonUser(true, Pong.TitleId);

            _fc.MakeFriend(a, b);

            GIBlob gi = new GIBlob();
            gi.TitlePresence = 1;
            gi.AddProperty(new GIProperty((uint)Pong.PropertyPoints, (int)17));
            gi.AddProperty(new GIProperty((uint)Pong.PropertyLosses, (int)3));
            gi.AddProperty(new GIProperty((uint)Pong.PropertyWins, (int)11));

            gi.AddContext((uint)Pong.Context.GameMode, (uint)Pong.GameMode.MultiPlayer);
            gi.AddContext((uint)Pong.Context.WinScore, (uint)Pong.WinScore.Points21);

            b.ProcessNotifications();
            a.SetTitleData(gi.GetBytes());

            noti = b.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eRichPresenceString);
            //DumpReply(noti);
            ValueCheck.TestNonZero("notification data count", noti.SubscriptionData.data.Length);

            a.ProcessNotifications();
            b.SetTitleData(gi.GetBytes());

            noti = a.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eRichPresenceString);
            //DumpReply(noti);
            ValueCheck.TestNonZero("notification data count", noti.SubscriptionData.data.Length);
        }


		/// <summary>
		/// Dequeue both peer and friend presence in one shot on xenon client
		/// </summary>
		/// <remarks>
		///		<Description>
		/// 		Make one user with one friend and one peer logged in on Xenon consoles. 
		/// 		SetState on friend and peer. Wait for QFLAG_MASK_PRESENCE_2 for 30 seconds.
		/// 		Dequeue both of the raw P_PRESENCE_ITEM_2 off the one queue and validate.
		/// 	</Description>
		/// 	<Verify>
		/// 		Ensure more than 1 P_PRESENCE_ITEM_2 is returned on the dequeue call.
		/// 		Per-field validation of the presence items.
		/// 	</Verify> 
		/// </remarks>
		[TestCase]
		public void P_Dequeue_Peer_Friend_Rich_Presence()
		{
			PNUser a = CreateXenonUser(true);
			PNUser b = CreateXenonUser(true);
			PNUser c = CreateXenonUser(true);

			_fc.MakeFriend(a, b);
			a.PeerSubscribe(c);

			// Clear pending Qvals
			a.ProcessNotifications();

			GIBlob giB = new GIBlob();
			giB.TitlePresence = 1;
			giB.AddProperty(new GIProperty((uint)Pong.PropertyPoints, (int)1));
			giB.AddProperty(new GIProperty((uint)Pong.PropertyLosses, (int)1));
			giB.AddProperty(new GIProperty((uint)Pong.PropertyWins, (int)1));

			giB.AddContext((uint)Pong.Context.GameMode, (uint)Pong.GameMode.MultiPlayer);
			giB.AddContext((uint)Pong.Context.WinScore, (uint)Pong.WinScore.Points21);

			GIBlob giC = new GIBlob();
			giC.TitlePresence = 1;
			giC.AddProperty(new GIProperty((uint)Pong.PropertyPoints, (int)1));
			giC.AddProperty(new GIProperty((uint)Pong.PropertyLosses, (int)1));
			giC.AddProperty(new GIProperty((uint)Pong.PropertyWins, (int)1));

			giC.AddContext((uint)Pong.Context.GameMode, (uint)Pong.GameMode.MultiPlayer);
			giC.AddContext((uint)Pong.Context.WinScore, (uint)Pong.WinScore.Points21);

			// handle any pending qvals
			b.ProcessNotifications();

			b.SetTitleData(giB.GetBytes());
			c.SetTitleData(giC.GetBytes());

			// Wait on the presence 2 queue for items from both users (peer and friend)
			PNConditionalWaitState wait = new PNConditionalWaitState();
            wait.AddRequiredNotification(xonline.common.community.DATA_TYPES.eRichPresenceString, b, a);
            wait.AddRequiredNotification(xonline.common.community.DATA_TYPES.eRichPresenceString, c, a);
			wait.WaitOnConditions();
		}
		
		[TestCase]
		public void P_Offline_Online_Dequeue_Transitions()
		{
			PNConditionalWaitState waitState = null;

			PNUser xenona = CreateXenonUser(true);
			PNUser xenonb = CreateXenonUser(true);
			PNUser control = CreateXenonUser(true); // the user to validate control conditions
			_fc.MakeFriend(xenona, xenonb);

			// setup the control user
			_fc.MakeFriend(control, xenona);
			_fc.MakeFriend(control, xenonb);

			// create the control wait state to make sure we clear all presence from logoff
			waitState = new PNConditionalWaitState();
            waitState.AddRequiredNotification(xonline.common.community.DATA_TYPES.eRichPresenceString, xenona, control);
            waitState.AddRequiredNotification(xonline.common.community.DATA_TYPES.eRichPresenceString, xenonb, control);

			_fc.LogoffUser(xenona);
			_fc.LogoffUser(xenonb);

			// Make sure control user gets all of the logoff notifications
			waitState.WaitOnConditions();

			// Clear any old qval packets that are left in the fake SG for each of these users
			xenona.ProcessNotifications();
			xenonb.ProcessNotifications();

			_fc.LogonUser(xenona);
			_fc.LogonUser(xenonb);		

			waitState = new PNConditionalWaitState();

            waitState.AddRequiredNotification(xonline.common.community.DATA_TYPES.eBasicPresence, xenona, xenonb);
            waitState.AddRequiredNotification(xonline.common.community.DATA_TYPES.eBasicPresence, xenonb, xenona);
            waitState.AddRequiredNotification(xonline.common.community.DATA_TYPES.eBasicPresence, xenona, control);
            waitState.AddRequiredNotification(xonline.common.community.DATA_TYPES.eBasicPresence, xenonb, control);

            waitState.WaitOnConditions();
		}

		[TestCase]
		public void P_Cloaked_LastSeenTime_Scenarios()
		{
			_Report.Info("Cloaked user test: Setup");

			// 1. Setup
			//
			// Create two new users as friends, b will be the observer in this scenario
			PNUser a = CreateXenonUser(true);
			PNUser b = CreateXenonUser(true);
			
            UserNotification noti;

			// Set some rich presence context
			GIBlob giblobA = a.GIBlob;
			giblobA.AddContext(0,0);
			giblobA.AddContext(1,0);

			GIBlob giblobB = b.GIBlob;
			giblobB.AddContext(0,0);
			giblobB.AddContext(1,0);

			_fc.MakeFriend(a, b);

			ConsumeAllPresence(a, b);

			// Logoff control user
			_fc.LogoffUser(a);

			// Wait on status change qval for user A with his actual last seen time
            noti = b.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eBasicPresence);
			b.HandleTCPNotification(noti);

			//
			// 2. Logon cloaked, logoff, mark last seen time
			//		Catches logon/state pulse in cloaked state
			//
			//
			ConsumeAllPresence(a, b);
            
            // Mark last seen time
            uint lastSeen = b.GetBuddyInfo(a.UserId).BasicPresenceData.mtLastSeen;
            _Report.Info("Cloaked user test: Step 1 finished (setup), LastSeen: {0}", lastSeen);

			_fc.LogonUser(a, true/*appear offline*/); 

			ValidateLastSeenNotChanged(a, b, lastSeen);

			_fc.LogoffUser(a);

			ValidateLastSeenNotChanged(a, b, lastSeen);

			_Report.Info("Cloaked user test:  Step 2 finished (cloaked operations), LastSeen: {0}", lastSeen);

			// 
			// 3. Logon cloaked , go from Cloaked->Uncloaked, check last seen was set to a new value
			//
			ConsumeAllPresence(a, b);	

			_fc.LogonUser(a, true/*appear offline*/);

            ValidateLastSeenNotChanged(a, b, lastSeen);

			a.SetTitleData(XonPresNoti.P_STATE_MASK_ONLINE);

			lastSeen = ValidateLastSeenLessThanCurrent(a, b, lastSeen);

			_Report.Info("Cloaked user test:  Step 3 finished (cloaked->uncloaked), LastSeen: {0}", lastSeen);

			// 
			// 4. Go from Uncloaked->cloaked, check last seen was set to a new value
			//
			ConsumeAllPresence(a, b);

			a.SetTitleData(XonPresNoti.P_STATE_MASK_ONLINE|XonPresNoti.P_STATE_MASK_CLOAKED);

			lastSeen = ValidateLastSeenLessThanCurrent(a, b, lastSeen);

			_Report.Info("Cloaked user test:  Step 4 finished (uncloaked->cloaked), LastSeen: {0}", lastSeen);

			// 
			// 5. Pulse titlestuff make sure that last seen time is not updated
			//
            ConsumeAllPresence(a, b);	

            a.SetTitleData();

            ValidateLastSeenNotChanged(a, b, lastSeen);

			_Report.Info("Cloaked user test:  Step 5 finished (cloaked pulse state), LastSeen: {0}", lastSeen);

			//
			// 6. Logoff make sure that last seen time is not updated
			//
			a.ProcessNotifications();
			b.ProcessNotifications();

			_fc.LogoffUser(a);


			_Report.Info("Cloaked user test:  Step 6 finished (cloaked logoff), LastSeen: {0}", lastSeen);


			//
			// 7. Change title cloaked make sure it doesn't reflect in presence
			//
			ConsumeAllPresence(a, b);

            ValidateLastSeenNotChanged(a, b, lastSeen);
		
			uint lastTitleId = a.Xbox.TitleId;
			a.Xbox.ChangeTitle(a.Xbox.TitleId+1, 0, 0);
			_fc.LogonUser(a, true /*appear offline*/);

            ValidateLastSeenNotChanged(a, b, lastSeen);

			// Clear off any other qvals (could be some but a real client will eat them)
			b.ProcessNotifications();

			// Get the last change title ID and validate it
			PNUser.BuddyInfo info = b.GetBuddyInfo(a.UserId);
			ValueCheck.TestNotNull("Control user buddy info", info);
			ValueCheck.TestNotNull("Control user buddy info rich presence", info.RichPresenceData);
			ValueCheck.Test("Buddy titleID should not change", lastTitleId, info.BasicPresenceData.TitleId);
			ValueCheck.Test("Buddy lastSeen should not change", lastSeen, info.BasicPresenceData.mtLastSeen);

			_Report.Info("Cloaked user test:  Step 7 finished (cloaked title change), LastTitle: {0:x}", info.BasicPresenceData.TitleId);

		}
		void ValidateLastSeenNotChanged(PNUser a, PNUser b, uint lastSeen)
		{
			try
			{
                UserNotification noti = b.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eBasicPresence);
                b.HandleTCPNotification(noti);

			    // Clear off any other qvals (could be some but a real client will eat them)
			    b.ProcessNotifications();
			}
			catch (TimeOutException)
			{
			}            

			PNUser.BuddyInfo info = b.GetBuddyInfo(a.UserId);
			ValueCheck.TestNotNull("Control user buddy info", info);
			ValueCheck.TestNotNull("Control user buddy info rich presence", info.RichPresenceData);

			ValueCheck.Test("Buddy state time should not change", lastSeen, info.BasicPresenceData.mtLastSeen);
		}
		uint ValidateLastSeenLessThanCurrent(PNUser a, PNUser b, uint lastSeen)
		{
            UserNotification noti = b.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eBasicPresence);
            b.HandleTCPNotification(noti);

			// Update any state information (could be some but client would eat them)
			b.ProcessNotifications();

			_Report.Info("Checking BuddyInfo object for control user");
			PNUser.BuddyInfo info = b.GetBuddyInfo(a.UserId);
			ValueCheck.TestNotNull("Control user buddy info", info);
			ValueCheck.TestNotNull("Control user buddy info rich presence", info.RichPresenceData);

			_Report.Info("Validating info.RichPresence.BuddyStateTime: > lastSeen: {0} > {1}", info.BasicPresenceData.mtLastSeen, lastSeen);
			ValueCheck.TestGreaterThan("Buddy state time should change", lastSeen, info.BasicPresenceData.mtLastSeen);

			// return the new state time to the caller
			return info.BasicPresenceData.mtLastSeen;
		}
		void ConsumeAllPresence(PNUser a, PNUser b)
		{
			// Conume presence for 5 seconds
			DateTime abortTime = DateTime.Now.AddSeconds(5);
			while(abortTime > DateTime.Now)
			{
				a.ProcessNotifications();
				b.ProcessNotifications();
				Thread.Sleep(500);
			}
		}

		[TestCase]
		public void P_Dequeue_Offline_Presence_Xenon()
		{
			PNUser u = CreateXenonUser(true);
			PNUser friendNotInMemory = CreateXenonUser(true);
			PNUser friendBaseRecordOnly = CreateXenonUser(true);
			PNUser friendJustLoggedOff = CreateXenonUser(true);
			_fc.MakeFriend(u, friendNotInMemory);
			_fc.MakeFriend(u, friendBaseRecordOnly);
			_fc.MakeFriend(u, friendJustLoggedOff);

			// Clear out any pending qvals
			friendNotInMemory.ProcessNotifications();
			friendBaseRecordOnly.ProcessNotifications();
			friendJustLoggedOff.ProcessNotifications();

			_fc.LogoffUser(u);
			_fc.LogoffUser(friendNotInMemory);
			_fc.LogoffUser(friendBaseRecordOnly);
			_fc.LogoffUser(friendJustLoggedOff);

            //TODO: Consult experts.
            RemoveCacheKey(friendNotInMemory, xonline.common.community.DATA_TYPES.eInternalPresence);
            RemoveCacheKey(friendNotInMemory, xonline.common.community.DATA_TYPES.eBasicPresence);
            RemoveCacheKey(friendNotInMemory, xonline.common.community.DATA_TYPES.eRichPresenceString);
            RemoveCacheKey(friendBaseRecordOnly, xonline.common.community.DATA_TYPES.eBasicPresence);
            RemoveCacheKey(friendBaseRecordOnly, xonline.common.community.DATA_TYPES.eRichPresenceString);

			PNConditionalWaitState waitState = new PNConditionalWaitState(120);
			// This user does not have any presence state 
			// waitState.AddRequiredQFlag(XonPresNoti.QFLAG_MASK_PRESENCE_2, friendNotInMemory);
            waitState.AddRequiredNotification(xonline.common.community.DATA_TYPES.eBasicPresence, friendBaseRecordOnly, u);
            waitState.AddRequiredNotification(xonline.common.community.DATA_TYPES.eBasicPresence, friendJustLoggedOff, u);
			_fc.LogonUser(u);

			waitState.WaitOnConditions();
		}
        private void RemoveCacheKey(PNUser u, xonline.common.community.DATA_TYPES keyType)
        {
            string key = xonline.common.community.CacheUtil.BuildCacheKey(keyType, u.UserId);
            string result = ExecuteXmgmt("removecachekey", key);
            ValueCheck.IsTrue(result.Contains("Removed key: " + key), result);
        }
        private string ExecuteXmgmt(string command, string commandArg)
        {
            string result = string.Empty;
            ManagementConsole.Execute(Global.XEnv.GetServerListByInterface("xpnfd_presence_int")[0], "e :xpnfd " + command + " " + commandArg, out result);
            return result;
        }

		[TestCase]
		public void P_Dequeue_Friend_Title_Change()
		{
			PNUser a = CreateXenonUser(true);
			PNUser b = CreateXenonUser(true);

			_fc.MakeFriend(a, b);
			b.ProcessNotifications();

			// change title and pulse state (should invoke title change in presence)
			a.Xbox.ChangeTitle(a.Xbox.TitleId+1, 0, 0);
			a.SetTitleData();

            UserNotification noti = b.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eBasicPresence);
            b.HandleTCPNotification(noti);

			PNUser.BuddyInfo bi = b.GetBuddyInfo(a.UserId);
			ValueCheck.TestNotNull("BuddyInfo", bi);
			ValueCheck.TestNotNull("BuddyInfo.RichPresence", bi.RichPresenceData);

			ValueCheck.Test("TitleId updated on change titleI", 
					a.Xbox.TitleId, bi.BasicPresenceData.TitleId);
		}

        [TestCase]
		public void P_Dequeue_MultiSignonPresence_Scenario()
		{
			// xbox set a
			PNUser aa = CreateXenonUser(true);
			// xbox set b
			PNUser ba = CreateXenonUser(true);
			PNUser bb = CreateXenonUser(false);
			PNUser bc = CreateXenonUser(false);
			PNUser bd = CreateXenonUser(false);

            bb.Xbox = ba.Xbox;
            bc.Xbox = ba.Xbox;
            bd.Xbox = ba.Xbox;

			_fc.LogonUser(bb);
			_fc.LogonUser(bc);
			_fc.LogonUser(bd);

			_fc.MakeFriend(aa, ba);
			_fc.MakeFriend(aa, bb); 
			_fc.MakeFriend(aa, bc);
			_fc.MakeFriend(aa, bd);

			_fc.LogoffUser(aa);
			_fc.LogoffUser(ba);
			_fc.LogoffUser(bb);
			_fc.LogoffUser(bc);
			_fc.LogoffUser(bd);

			new SleepInfo("Waiting for logoffs to settle", 2000);

			// Clear the old qval packets that are queued up
			aa.ProcessNotifications();
			ba.ProcessNotifications();
			bb.ProcessNotifications();
			bc.ProcessNotifications();
			bd.ProcessNotifications();

			// Get everyone online again
			_fc.LogonUser(aa);
			_fc.LogonUser(ba);
			_fc.LogonUser(bb);
			_fc.LogonUser(bc);
			_fc.LogonUser(bd);

			new SleepInfo("Waiting for logons to settle", 2000);

			// Clear the logon qval packets
			aa.ProcessNotifications();
			ba.ProcessNotifications();
			bb.ProcessNotifications();
			bc.ProcessNotifications();
			bd.ProcessNotifications();

			PNConditionalWaitState waitState = new PNConditionalWaitState();
            waitState.AddRequiredNotification(xonline.common.community.DATA_TYPES.eBasicPresence, aa, ba);
            waitState.AddRequiredNotification(xonline.common.community.DATA_TYPES.eBasicPresence, aa, bb);
            waitState.AddRequiredNotification(xonline.common.community.DATA_TYPES.eBasicPresence, aa, bc);
            waitState.AddRequiredNotification(xonline.common.community.DATA_TYPES.eBasicPresence, aa, bd);

			aa.SetTitleData(aa.State|XonPresNoti.P_STATE_ENUM_AWAY);
            new SleepInfo("Waiting for logons to settle", 3000);
			waitState.WaitOnConditions();
		}

        // This test should be extended to try and determine the whitelist
        // then compare that against the setting
        [TestCase]
        public void P_Dequeue_XenonRichPresenceFiltering_Friend()
        {
            UserNotification noti;

            PNUser xenona = CreateXenonUser(true);
            PNUser xenonb = CreateXenonUser(true);
            PNUser pca = CreatePanoramaUser(true);

            _fc.MakeFriend(xenona, xenonb);
            _fc.MakeFriend(xenona, pca);

            xenona.ProcessNotifications();
            xenonb.ProcessNotifications();
            pca.ProcessNotifications();

            GIBlob gi = new GIBlob();
            gi.TitlePresence = 1;
            gi.AddProperty(new GIProperty((uint)Pong.PropertyPoints, (int)1));
            gi.AddProperty(new GIProperty((uint)Pong.PropertyLosses, (int)1));
            gi.AddProperty(new GIProperty((uint)Pong.PropertyWins, (int)1));
            gi.AddContext(new GIContext(0, 0));
            gi.AddContext(new GIContext(1, 0));

            gi.AddContext((uint)Pong.Context.GameMode, (uint)Pong.GameMode.MultiPlayer);
            gi.AddContext((uint)Pong.Context.WinScore, (uint)Pong.WinScore.Points21);

            // Update xenon GI data
            xenona.GIBlob = gi;
            xenona.SetTitleData();

            // since rich presence is the only thing changing this client should not be notified.
            try
            {
                noti = xenonb.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eRichPresenceString);
            }
            catch (TimeOutException)
            {
                Assert.IsTrue(false, "In new presence, we will get notification for both basic and rich, because makefriends subscribe to both.");
                // this is expected
            }

            noti = pca.WaitForUserNotifications(xonline.common.community.DATA_TYPES.eRichPresenceString);
            pca.HandleTCPNotification(noti);
        }
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Xbox Live Source\XONLINE_MAIN\private\server\presence\test\presencefunc\FuncGetFriendsList.cs ===
using System;
using System.Collections;
using System.Threading;
using ServerTestFramework;
using ServerTestFramework.Utilities;
using ServerTestFramework.LiveService;
using ServerTestFramework.LiveService.FakeSG;
using ServerTestFramework.LiveService.Notification;
using ServerTestFramework.LiveService.Presence;
using ServerTestFramework.LiveService.PresNotiCommon;
using ServerTestFramework.LiveService.UserAccount;
using xonline.common.diagnostics;

namespace PresenceTest
{
	/// <summary>
	/// Functional Tests for GetFriendsList
	/// </summary>
    [TestGroup, TestFrequency("Daily"), TestCasePriority(2), AsyncGroup(1, 0)]
    public class FuncGetFriendsList : PresenceTestBaseGroup
	{
        
        static Report ro = new Report("GetFriendsList");

        static void SetPrivilege(PNUser user, uint priv, bool grant)
        {
            // Create a grant request
            XRLXeUpdateParentalControls request = new XRLXeUpdateParentalControls();
            request.UserPuid = user.UserId;
            request.Source = "STF-PRES-FPC";

            UserPrivileges grants = new UserPrivileges();
            UserPrivileges restrictions = new UserPrivileges();

            // Populate the new requested privilege
            if (grant)
            {
                grants[(int)priv] = true;
            }
            else
            {
                restrictions[(int)priv] = true;
            }

            request.UserGrantPrivileges = grants.ToArray();
            request.UserRestrictPrivileges = restrictions.ToArray();
            request.ExecuteSafe();

            Thread.Sleep(5000);
        }

		[TestCase]
		public void N_Invalid_UserId()
		{
            PNUser valid = CreateXenonUser(true);

			// Do a bunch of busy work to register this invalid stuff with the fake SG
			PNUser invalid = new PNUser("Invalid", 0x4d2);
			PNXbox xbox = new PNXbox(FriendsCommon.DefaultXenonTitleId, xonline.common.protocol.XboxVersion.FEB_2005_ALPHA_XEDK);
			invalid.Connect(xbox);

            PMsgGetFriendsList pMsg = new PMsgGetFriendsList(valid, invalid);
            PNMsg reply;
            pMsg.TransactFD(out reply);
            PGetFriendsListReplyMsgData replyData = (PGetFriendsListReplyMsgData)(reply.Data);
            if( replyData.HR != HResult.E_NO_SUCH_USER)
			{
                throw new HResultException( replyData.HR, "Get Friends List unexpected HR = 0x"+Global.XErrToString(replyData.HR));
			}
		}

		/// <summary>
		/// 	Request friends data for a friend who is online
		/// </summary>
		/// <remarks>
		/// 	<Description>
		/// 	</Description>
		/// 	<Verify>
		/// 	</Verify>
		/// </remarks>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public void P_GetFriendsList_Target_Online()
        {
            PNUser requestor = CreateXenonUser(true);

            PNUser a, b;

            // Create some clean users who are friends
            a = CreateXenonUser(true);
            b = CreateXenonUser(true);
            _fc.MakeFriend(a, b);

            // Give presence some time and make sure these users don't have any transient messages
            Thread.Sleep(5000);
            a.ProcessNotifications();
            b.ProcessNotifications();
            _fc.LogoffUser(a);
            _fc.LogoffUser(b);

            // Logon
            ro.Debug("Logging in with user A...");
            _fc.LogonUser(a);

            // Get web friends
            ro.Debug("Getting friends list for user B...");

            // Get user B friends list, make sure he sees web friends
            PGetFriendsListReplyMsgData replyData = requestor.GetFriendsList(b);
            ValueCheck.Test("Friend count", (ushort)(replyData.cdwFriends), (ushort)1);
        }


        /// <summary>
        /// 	Request friends data for a friend who is online
        /// </summary>
        /// <remarks>
        /// 	<Description>
        /// 	</Description>
        /// 	<Verify>
        /// 	</Verify>
        /// </remarks>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public void P_GetFriendsList_Target_Offline()
        {
            PNUser requestor = CreateXenonUser(true);

            PNUser a, b;

            // Create some clean users who are friends
            a = CreateXenonUser(true);
            b = CreateXenonUser(true);
            _fc.MakeFriend(a, b);

            // Give presence some time and make sure these users don't have any transient messages
            Thread.Sleep(5000);
            a.ProcessNotifications();
            b.ProcessNotifications();
            _fc.LogoffUser(a);
            _fc.LogoffUser(b);

            // Get web friends
            ro.Debug("Getting friends list for user B...");

            // Get user B friends list, make sure he sees web friends
            PGetFriendsListReplyMsgData replyData = requestor.GetFriendsList(b);
            ValueCheck.Test("Friend count", (ushort)(replyData.cdwFriends), (ushort)1);
        }


        /// <summary>
        /// 	Request friends data for a friend who is online
        /// </summary>
        /// <remarks>
        /// 	<Description>
        /// 	</Description>
        /// 	<Verify>
        /// 	</Verify>
        /// </remarks>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public void P_GetFriendsList_Target_NotInMemory()
        {
            // TODO: What does not in memory mean for new presence system?

            PNUser requestor = CreateXenonUser(true);

            PNUser a, b;

            // Create some clean users who are friends
            a = CreateXenonUser(true);
            b = CreateXenonUser(true);
            _fc.MakeFriend(a, b);

            // Give presence some time and make sure these users don't have any transient messages
            Thread.Sleep(5000);
            a.ProcessNotifications();
            b.ProcessNotifications();
            _fc.LogoffUser(a);
            _fc.LogoffUser(b);

            ro.Debug("Removing A alive cache, Removing B from memory...");
            //PNServers.SetCacheState(a, CacheState.BaseRecordOnly);
            //PNServers.SetCacheState(b, CacheState.NotInMemory);

            //BugID: 101234
            requestor.GetPresenceInfo(b);

            // Get web friends
            ro.Debug("Getting friends list for user B...");

            // Get user B friends list, make sure he sees web friends
            PGetFriendsListReplyMsgData replyData = requestor.GetFriendsList(b);
            ValueCheck.Test("Friend count", (ushort)(replyData.cdwFriends), (ushort)1);
        }

        /// <summary>
        /// 	Request friends data for a friend who is online
        /// </summary>
        /// <remarks>
        /// 	<Description>
        /// 	</Description>
        /// 	<Verify>
        /// 	</Verify>
        /// </remarks>
        [TestCase, TestFrequency("BVT"), TestCasePriority(1)]
        public void P_GetFriendsList_Target_Friend_NotInMemory()
        {

            // TODO: What does not in memory mean for the new presence system?

            PNUser requestor = CreateXenonUser(true);

            PNUser a, b;

            // Create some clean users who are friends
            a = CreateXenonUser(true);
            b = CreateXenonUser(true);
            _fc.MakeFriend(a, b);

            // Give presence some time and make sure these users don't have any transient messages
            Thread.Sleep(5000);
            a.ProcessNotifications();
            b.ProcessNotifications();
            _fc.LogoffUser(a);
            _fc.LogoffUser(b);

            ro.Debug("Removing B from alive cache, Removing A from memory...");
            //PNServers.SetCacheState(a, CacheState.NotInMemory);
            //PNServers.SetCacheState(b, CacheState.Ba