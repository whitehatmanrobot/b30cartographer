nlining these is both faster and smaller.
 */
#define CopyRect        CopyRectInl
#define EqualRect       EqualRectInl
#define SetRectEmpty    SetRectEmptyInl

__inline void
CopyRectInl(LPRECT prcDest, LPCRECT prcSrc)
{
    *prcDest = *prcSrc;
}

__inline DWORD
EqualRectInl(LPCRECT prc1, LPCRECT prc2)
{
    return RtlEqualMemory(prc1, prc2, sizeof(*prc1));
}

__inline void
SetRectEmptyInl(LPRECT prc)
{
    RtlZeroMemory(prc, sizeof(*prc));
}

/***************************************************************************\
* ANSI/Unicode function names
*
* For non-API Client/Server stubs, an "A" or "W" suffix must be added.
* (API function names are generated by running wcshdr.exe over winuser.x)
*
\***************************************************************************/
#ifdef UNICODE
    #define TEXT_FN(fn) fn##W
#else // UNICODE
    #define TEXT_FN(fn) fn##A
#endif // UNICODE

#ifdef UNICODE
    #define BYTESTOCHARS(cb) ((cb) / sizeof(TCHAR))
    #define CHARSTOBYTES(cch) ((cch) * sizeof(TCHAR))
#else // UNICODE
    #define BYTESTOCHARS(cb) (cb)
    #define CHARSTOBYTES(cch) (cch)
#endif // UNICODE

/*
 * Internal window class names
 */
#define DESKTOPCLASS    MAKEINTATOM(0x8001)
#define DIALOGCLASS     MAKEINTATOM(0x8002)
#define SWITCHWNDCLASS  MAKEINTATOM(0x8003)
#define ICONTITLECLASS  MAKEINTATOM(0x8004)
#define INFOCLASS       MAKEINTATOM(0x8005)
#define TOOLTIPCLASS    MAKEINTATOM(0x8006)
#define GHOSTCLASS      MAKEINTATOM(0x8007)
#define MENUCLASS       MAKEINTATOM(0x8000)     /* Public Knowledge */

//
// System timer IDs
//
#define IDSYS_LAYER         0x0000FFF5L
#define IDSYS_FADE          0x0000FFF6L
#define IDSYS_WNDTRACKING   0x0000FFF7L
#define IDSYS_FLASHWND      0x0000FFF8L
#define IDSYS_MNAUTODISMISS 0x0000FFF9L
#define IDSYS_MOUSEHOVER    0x0000FFFAL
#define IDSYS_MNANIMATE     0x0000FFFBL
#define IDSYS_MNDOWN        MFMWFP_DOWNARROW /* 0xFFFFFFFC */
#define IDSYS_LBSEARCH      0x0000FFFCL
#define IDSYS_MNUP          MFMWFP_UPARROW   /* 0xFFFFFFFD */
#define IDSYS_STANIMATE     0x0000FFFDL
#define IDSYS_MNSHOW        0x0000FFFEL
#define IDSYS_SCROLL        0x0000FFFEL
#define IDSYS_MNHIDE        0x0000FFFFL
#define IDSYS_CARET         0x0000FFFFL


/*
 * Special case string token codes.  These must be the same as in the resource
 * compiler's RC.H file.
 */
/*
 * NOTE: Order is assumed and much be this way for applications to be
 * compatable with windows 2.0
 */
#define CODEBIT             0x80
#define BUTTONCODE          0x80
#define EDITCODE            0x81
#define STATICCODE          0x82
#define LISTBOXCODE         0x83
#define SCROLLBARCODE       0x84
#define COMBOBOXCODE        0x85
#define MDICLIENTCODE       0x86
#define COMBOLISTBOXCODE    0x87

/*
 * Internal window classes. These numbers serve as indices into the
 * atomSysClass table so that we can get the atoms for the various classes.
 * The order of the control classes (through COMBOLISTBOXCLASS) is assumed
 * to be the same as the class codes above.
 */
#define ICLS_BUTTON         0
#define ICLS_EDIT           1
#define ICLS_STATIC         2
#define ICLS_LISTBOX        3
#define ICLS_SCROLLBAR      4
#define ICLS_COMBOBOX       5       // End of special dlgmgr indices

#define ICLS_MDICLIENT      6
#define ICLS_COMBOLISTBOX   7
#define ICLS_DDEMLEVENT     8
#define ICLS_DDEMLMOTHER    9
#define ICLS_DDEML16BIT     10
#define ICLS_DDEMLCLIENTA   11
#define ICLS_DDEMLCLIENTW   12
#define ICLS_DDEMLSERVERA   13
#define ICLS_DDEMLSERVERW   14
#define ICLS_IME            15

#define ICLS_CTL_MAX        16       // Number of public control classes


#define ICLS_DESKTOP        16
#define ICLS_DIALOG         17
#define ICLS_MENU           18
#define ICLS_SWITCH         19
#define ICLS_ICONTITLE      20
#define ICLS_TOOLTIP        21
#define ICLS_GHOST          22
#define ICLS_MAX            23  // Number of system classes

/*
 * Directory name for windowstations and desktops
 */
#define WINSTA_DIR  L"\\Windows\\WindowStations"
#define WINSTA_SESSION_DIR  L"\\Sessions\\xxxxxxxxxxx\\Windows\\WindowStations"
#define WINSTA_NAME L"Service-0x0000-0000$"
#define MAX_SESSION_PATH   256
#define SESSION_ROOT L"\\Sessions"

/***************************************************************************\
* Normal Stuff
*
* Nice normal typedefs, defines, prototypes, etc that everyone wants to share.
*
\***************************************************************************/

/*
 * Define size limit of callback data. Below or equal to this limit, put data
 * on the client-side stack. Above this limit allocate virtual memory
 * for the data.
 */
#define CALLBACKSTACKLIMIT  (KERNEL_PAGE_SIZE / 2)

/*
 * Capture buffer definition for callbacks.
 */
typedef struct _CAPTUREBUF {
    DWORD cbCallback;
    DWORD cbCapture;
    DWORD cCapturedPointers;
    PBYTE pbFree;
    DWORD offPointers;
    PVOID pvVirtualAddress;
} CAPTUREBUF, *PCAPTUREBUF;

/*
 * Callback return status
 */
typedef struct _CALLBACKSTATUS {
    KERNEL_ULONG_PTR retval;
    DWORD cbOutput;
    KERNEL_PVOID pOutput;
} CALLBACKSTATUS, *PCALLBACKSTATUS;

#define IS_PTR(p)       ((((ULONG_PTR)(p)) & ~MAXUSHORT) != 0)
#define PTR_TO_ID(p)    ((USHORT)(((ULONG_PTR)(p)) & MAXUSHORT))

//
// Strings are counted 16-bit character strings. If they are
// NULL terminated, Length does not include trailing NULL.
//
typedef struct _LARGE_STRING {
    ULONG Length;
    ULONG MaximumLength : 31;
    ULONG bAnsi : 1;
    KERNEL_PVOID Buffer;
} LARGE_STRING, *PLARGE_STRING;

typedef struct _LARGE_ANSI_STRING {
    ULONG Length;
    ULONG MaximumLength : 31;
    ULONG bAnsi : 1;
    KPSTR Buffer;
} LARGE_ANSI_STRING, *PLARGE_ANSI_STRING;

typedef struct _LARGE_UNICODE_STRING {
    ULONG Length;
    ULONG MaximumLength : 31;
    ULONG bAnsi : 1;
    KPWSTR Buffer;
} LARGE_UNICODE_STRING, *PLARGE_UNICODE_STRING;

/*
 * String macros
 */
__inline BOOL IsEmptyString(PVOID p, ULONG bAnsi)
{
    return (BOOL)!(bAnsi ? *(LPSTR)p : *(LPWSTR)p);
}
__inline void NullTerminateString(PVOID p, ULONG bAnsi)
{
    if (bAnsi) *(LPSTR)p = (CHAR)0; else *(LPWSTR)p = (WCHAR)0;
}
__inline UINT StringLength(PVOID p, ULONG bAnsi)
{
    return (bAnsi ? strlen((LPSTR)p) : wcslen((LPWSTR)p));
}

typedef struct _CTLCOLOR {
    COLORREF crText;
    COLORREF crBack;
    int iBkMode;
} CTLCOLOR, *PCTLCOLOR;


/*
 * This is used by the cool client side DrawIcon code
 */
typedef struct _DRAWICONEXDATA {
    HBITMAP hbmMask;
    HBITMAP hbmColor;
    int cx;
    int cy;
    HBITMAP hbmUserAlpha;
} DRAWICONEXDATA;

/*
 * Static items stored in the TEB
 */
typedef struct _CALLBACKWND {
    KHWND               hwnd;
    PWND                pwnd;
    PACTIVATION_CONTEXT pActCtx;
} CALLBACKWND, *PCALLBACKWND;

#define CVKKEYCACHE                 32
#define CBKEYCACHE                  (CVKKEYCACHE >> 2)

#define CVKASYNCKEYCACHE            32
#define CBASYNCKEYCACHE             (CVKASYNCKEYCACHE >> 2)

/*
 * The offset to cSpins must match WIN32_CLIENT_INFO_SPIN_COUNT defined
 * in ntpsapi.h.  GDI uses this offset to reset the spin count.
 * WARNING! This struct cannot be made larger without changing the TEB struct:
 * It must fit in ULONG_PTR Win32ClientInfo[WIN32_CLIENT_INFO_LENGTH]; (ntpsapi.h)
 * (ifdef FE_SB, sizeof(CLIENTINFO) == 0x7c == 4 * WIN32_CLIENT_INFO_LENGTH)
 */
typedef struct _CLIENTINFO {
    KERNEL_ULONG_PTR    CI_flags;           // Needs to be first because CSR sets this
    KERNEL_ULONG_PTR    cSpins;             // GDI resets this
    DWORD               dwExpWinVer;
    DWORD               dwCompatFlags;
    DWORD               dwCompatFlags2;
    DWORD               dwTIFlags;
    PDESKTOPINFO        pDeskInfo;
    KERNEL_ULONG_PTR    ulClientDelta;
    PHOOK               phkCurrent;
    DWORD               fsHooks;
    CALLBACKWND         CallbackWnd;
    DWORD               dwHookCurrent;
    int                 cInDDEMLCallback;
    PCLIENTTHREADINFO   pClientThreadInfo;
    KERNEL_ULONG_PTR    dwHookData;
    DWORD               dwKeyCache;
    BYTE                afKeyState[CBKEYCACHE];
    DWORD               dwAsyncKeyCache;
    BYTE                afAsyncKeyState[CBASYNCKEYCACHE];
    BYTE                afAsyncKeyStateRecentDown[CBASYNCKEYCACHE];
    KHKL                hKL;
    WORD                CodePage;

    BYTE                achDbcsCF[2]; // Save ANSI DBCS LeadByte character code
                                      // in this field for ANSI to Unicode.
                                      // Uses SendMessageA/PostMessageA from CLIENT
                                      // to SERVER (index 0)
                                      //  And...
                                      // Uses SendMessageA/DispatchMessageA
                                      // for CLIENT to CLIENT (index 1)
    KERNEL_MSG          msgDbcsCB;    // Save ANSI DBCS character message in
                                      // this field for convert Unicode to ANSI.
                                      // Uses GetMessageA/PeekMessageA from
                                      // SERVER to CLIENT

#ifdef LATER
    EVENTMSG            eventCached;  // Cached Event for Journal Hook
#endif
} CLIENTINFO, *PCLIENTINFO;


#define CI_IN_SYNC_TRANSACTION 0x00000001
#define CI_PROCESSING_QUEUE    0x00000002
#define CI_16BIT               0x00000004
#define CI_INITIALIZED         0x00000008
#define CI_INTERTHREAD_HOOK    0x00000010
#define CI_REGISTERCLASSES     0x00000020
#define CI_INPUTCONTEXT_REINIT 0x00000040

#ifdef CUAS_ENABLE
#define CI_CUAS_COINIT_CALLED  0x00000080 /* CoInit is called for CUAS */
#define CI_CUAS_TIM_ACTIVATED  0x00000100 /* Tim activate for CUAS */
#define CI_CUAS_MSCTF_RUNNING  0x00000200 /* Msctf (hooks) is running in the thread */
#define CI_CUAS_DISABLE        0x00000400 /* Disable CUAS on thread */
#define CI_CUAS_AIMM12ACTIVATED  0x00000800
#endif // CUAS_ENABLE

//
// THREAD_CODEPAGE()
//
// Returns the CodePage based on the current keyboard layout.
//
#ifdef _USERK_
    #define THREAD_CODEPAGE() (PtiCurrent()->pClientInfo->CodePage)
#else // _USERK_
    #define THREAD_CODEPAGE() (GetClientInfo()->CodePage)
#endif // _USERK_

// WMCR_IR_DBCSCHAR and DBCS Macros
/*
 * Flags used for the WM_CHAR  HIWORD of wParam for DBCS messaging.
 *  (LOWORD of wParam will have character codepoint)
 */
#define WMCR_IR_DBCSCHAR       0x80000000
/*
 * Macros to determine this is DBCS message or not.
 */
#define IS_DBCS_MESSAGE(DbcsChar) (((DWORD)(DbcsChar)) & 0x0000FF00)

/*
 * Macros for IR_DBCSCHAR format to/from regular format.
 */
#define MAKE_IR_DBCSCHAR(DbcsChar) \
        (IS_DBCS_MESSAGE((DbcsChar)) ?                                     \
            (MAKEWPARAM(MAKEWORD(HIBYTE((DbcsChar)),LOBYTE((DbcsChar))),0)) : \
            ((WPARAM)((DbcsChar) & 0x00FF))                                   \
        )

#define MAKE_WPARAM_DBCSCHAR(DbcsChar) \
        (IS_DBCS_MESSAGE((DbcsChar)) ?                                     \
            (MAKEWPARAM(MAKEWORD(HIBYTE((DbcsChar)),LOBYTE((DbcsChar))),0)) : \
            ((WPARAM)((DbcsChar) & 0x00FF))                                   \
        )

#define DBCS_CHARSIZE   (2)

#define IS_DBCS_ENABLED()  (TEST_SRVIF(SRVIF_DBCS))
#define _IS_IME_ENABLED()  (TEST_SRVIF(SRVIF_IME))
#ifdef _IMMCLI_
    #define IS_IME_ENABLED()   (gpsi && _IS_IME_ENABLED())
#else   // _IMMCLI_
    #define IS_IME_ENABLED()   _IS_IME_ENABLED()
#endif  // _IMMCLI_

#ifdef CUAS_ENABLE

#define _IS_CICERO_ENABLED()   (TEST_SRVIF(SRVIF_CTFIME_ENABLED))
#ifdef _IMMCLI_
    #define IS_CICERO_ENABLED() (gpsi && _IS_CICERO_ENABLED())
    #define IS_CICERO_ENABLED_AND_NOT16BIT() \
                                (IS_CICERO_ENABLED() && !(GetClientInfo()->dwTIFlags & TIF_16BIT))
#else  // _IMMCLI_
    #define IS_CICERO_ENABLED() _IS_CICERO_ENABLED()
    #define IS_CICERO_ENABLED_AND_NOT16BIT() \
                                (IS_CICERO_ENABLED() && !(PtiCurrent()->TIF_flags & TIF_16BIT))
#endif // _IMMCLI_

#endif // CUAS_ENABLE

#define IS_DBCS_HKL()       (IS_ANY_DBCS_CODEPAGE(THREAD_CODEPAGE()))
#define IS_DBCS_INPUT()     (IS_DBCS_ENABLED() || IS_DBCS_HKL())

#ifndef IS_IME_KBDLAYOUT
#define IS_IME_KBDLAYOUT(hkl) ((HIWORD((ULONG_PTR)(hkl)) & 0xf000) == 0xe000)
#endif


#define CP_JAPANESE     (932)
#define CP_KOREAN       (949)
#define CP_CHINESE_SIMP (936)
#define CP_CHINESE_TRAD (950)

#define IS_DBCS_CODEPAGE(wCodePage) \
            ((wCodePage) == CP_JAPANESE || \
             (wCodePage) == CP_KOREAN || \
             (wCodePage) == CP_CHINESE_TRAD || \
             (wCodePage) == CP_CHINESE_SIMP)

#define IS_DBCS_CHARSET(charset) \
            ((charset) == SHIFTJIS_CHARSET || \
             (charset) == HANGEUL_CHARSET || \
             (charset) == CHINESEBIG5_CHARSET || \
             (charset) == GB2312_CHARSET)

#define IS_JPN_1BYTE_KATAKANA(c)   ((c) >= 0xa1 && (c) <= 0xdf)

/*
 * Dynamic layout switching
 */

typedef struct tagKBDTABLE_MULT_INTERNAL {
    KBDTABLE_MULTI multi;
    WCHAR wszDllName[32];   // main dll name
    struct {
        KHANDLE hFile;
        WORD wTable;
        WORD wNls;
    } files[KBDTABLE_MULTI_MAX];
} KBDTABLE_MULTI_INTERNAL, *PKBDTABLE_MULTI_INTERNAL;

// IMM dynamic loading support
#define IMM_MAGIC_CALLER_ID     (0x19650412)

BOOL User32InitializeImmEntryTable(DWORD dwMagic);

#define IS_MIDEAST_ENABLED()   (TEST_SRVIF(SRVIF_MIDEAST))

/*
 * Flags used for the WM_CLIENTSHUTDOWN wParam.
 */
#define WMCS_EXIT             0x0001
#define WMCS_QUERYEND         0x0002
#define WMCS_SHUTDOWN         0x0004
#define WMCS_CONTEXTLOGOFF    0x0008
#define WMCS_ENDTASK          0x0010
#define WMCS_CONSOLE          0x0020
#define WMCS_NODLGIFHUNG      0x0040
#define WMCS_NORETRY          0x0080
#define WMCS_LOGOFF           ENDSESSION_LOGOFF  /* from winuser.w */

/*
 * WM_CLIENTSHUTDOWN return value
 */
#define WMCSR_ALLOWSHUTDOWN     1
#define WMCSR_DONE              2
#define WMCSR_CANCEL            3

/*
 * We don't need 64-bit intermediate precision so we use this macro
 * instead of calling MulDiv.
 */
#define MultDiv(x, y, z)        (((INT)(x) * (INT)(y) + (INT)(z) / 2) / (INT)(z))

typedef DWORD ICH, *LPICH;

typedef struct _PROPSET {
    KHANDLE hData;
    ATOM atom;
} PROPSET, *PPROPSET;

/*
 * Internal menu flags stored in pMenu->fFlags.
 * High order bits are used for public MNS_ flags defined in winuser.w
 */
#define MFISPOPUP               0x00000001
#define MFMULTIROW              0x00000002
#define MFUNDERLINE             0x00000004
#define MFWINDOWDC              0x00000008  /* Window DC vs Client area DC when drawing*/
#define MFINACTIVE              0x00000010
#define MFRTL                   0x00000020
#define MFDESKTOP               0x00000040 /* Set on the desktop menu AND its submenus */
#define MFSYSMENU               0x00000080 /* Set on desktop menu but NOT on its submenus */
#define MFAPPSYSMENU            0x00000100 /* Set on (sub)menu we return to the app via GetSystemMenu */
#define MFREADONLY              0x00000200 /* Menu cannot be modified */
#define MFLAST                  0x00000200

#if (MNS_LAST <= MFLAST)
    #error MNS_ AND MF defines conflict
#endif // (MNS_LAST <= MFLAST)

// Event stuff --------------------------------------------

typedef struct tagEVENT_PACKET {
    DWORD EventType;    // == apropriate afCmd filter flag
    WORD  fSense;       // TRUE means flag on is passed.
    WORD  cbEventData;  // size of data starting at Data field.
    DWORD Data;         // event specific data - must be last
} EVENT_PACKET, *PEVENT_PACKET;

// Window long offsets in mother window     (szDDEMLMOTHERCLASS)

#define GWLP_INSTANCE_INFO  0       // PCL_INSTANCE_INFO


// Window long offsets in client window     (szDDEMLCLIENTCLASS)

#define GWLP_PCI            0
#define GWL_CONVCONTEXT     GWLP_PCI + sizeof(PVOID)
#define GWL_CONVSTATE       GWL_CONVCONTEXT + sizeof(CONVCONTEXT)   // See CLST_ flags
#define GWLP_SHINST         GWL_CONVSTATE + sizeof(LONG)
#define GWLP_CHINST         GWLP_SHINST + sizeof(HANDLE)

#define CLST_CONNECTED              0
#define CLST_SINGLE_INITIALIZING    1
#define CLST_MULT_INITIALIZING      2

// Window long offsets in server window     (szDDEMLSERVERCLASS)

#define GWLP_PSI            0

// Window long offsets in event window      (szDDEMLEVENTCLASS)

#define GWLP_PSII           0


/*
 * DrawFrame defines
 */
#define DF_SHIFT0           0x0000
#define DF_SHIFT1           0x0001
#define DF_SHIFT2           0x0002
#define DF_SHIFT3           0x0003
#define DF_PATCOPY          0x0000
#define DF_PATINVERT        0x0004
#define DF_SHIFTMASK (DF_SHIFT0 | DF_SHIFT1 | DF_SHIFT2 | DF_SHIFT3)
#define DF_ROPMASK   (DF_PATCOPY | DF_PATINVERT)
#define DF_HBRMASK   ~(DF_SHIFTMASK | DF_ROPMASK)

#define DF_SCROLLBAR        (COLOR_SCROLLBAR << 3)
#define DF_BACKGROUND       (COLOR_BACKGROUND << 3)
#define DF_ACTIVECAPTION    (COLOR_ACTIVECAPTION << 3)
#define DF_INACTIVECAPTION  (COLOR_INACTIVECAPTION << 3)
#define DF_MENU             (COLOR_MENU << 3)
#define DF_WINDOW           (COLOR_WINDOW << 3)
#define DF_WINDOWFRAME      (COLOR_WINDOWFRAME << 3)
#define DF_MENUTEXT         (COLOR_MENUTEXT << 3)
#define DF_WINDOWTEXT       (COLOR_WINDOWTEXT << 3)
#define DF_CAPTIONTEXT      (COLOR_CAPTIONTEXT << 3)
#define DF_ACTIVEBORDER     (COLOR_ACTIVEBORDER << 3)
#define DF_INACTIVEBORDER   (COLOR_INACTIVEBORDER << 3)
#define DF_APPWORKSPACE     (COLOR_APPWORKSPACE << 3)
#define DF_3DSHADOW         (COLOR_3DSHADOW << 3)
#define DF_3DFACE           (COLOR_3DFACE << 3)
#define DF_GRAY             (COLOR_MAX << 3)


/*
 * CreateWindowEx internal flags for dwExStyle
 */

#define WS_EX_MDICHILD      0x00000040L         // Internal
#define WS_EX_ANSICREATOR   0x80000000L         // Internal

/*
 * These flags are used in the internal version of NtUserFindWindowEx
 */
#define FW_BOTH 0
#define FW_16BIT 1
#define FW_32BIT 2

/*
 * Calculate the size of a field in a structure of type type.
 */
#define FIELD_SIZE(type, field)     (sizeof(((type *)0)->field))

#define FLASTKEY 0x80

/*
 * Special types we've fabricated for special thunks.
 */
typedef struct {
    POINT point1;
    POINT point2;
    POINT point3;
    POINT point4;
    POINT point5;
} POINT5, *LPPOINT5;

typedef struct {
    DWORD dwRecipients;
    DWORD dwFlags;
    BSMINFO;
} BROADCASTSYSTEMMSGPARAMS, *LPBROADCASTSYSTEMMSGPARAMS;
/*
 * Server side address constants. When we want to call a server side proc,
 * we pass an index indentifying the function, rather than the server side
 * address itself. More robust.  The functions between WNDPROCSTART/END
 * have client side stubs which map to this routines.
 *
 * Adding a new FNID (This is just what I figured out...so fix it if wrong or incomplete)
 * -Decide what range it should be in:
 *      FNID_WNDPROCSTART to FNID_WNDPROCEND: Server side proc with client
 *          stub
 *      FIND_CONTROLSTART to FNID_CONTROLEND: Client side controls with no
 *          server side proc
 *      After FNID_CONTROLEND: other, like server side only procs or client
 *          side only....
 * -Make sure to adjust FNID_*START and FNID_*END appropriately here and in wowuserp.w.
 * -If the ID is to be associated with a window class, and it is for all
 *      windows of that class, make sure that the InternalRegisterClassEx call
 *      receives the id as a parameter.
 * -If in FNID_WNDPROCSTART-END range, make the proper STOCID call in InitFunctionTables.
 * -Add proper FNID call in InitFunctionTables.
 * -If the class has a client side worker function (pcls->lpfnWorker) or you expect
 *   apps to send messages to it or call its window proc directly, define
 *   a message table in kernel\server.c and initialize it in InitMessageTables.
 * -Add a new entry to the PFNCLIENT and matching entries in clinet\clinet.c pfnClientA and
 *   pfnClientW arrays.
 * -Add the debug-only text description of this FNID to in gapszFNID in globals.c
 * -Modify aiClassWow in client\client.c
 * -Modify the gaFNIDtoICLS table in kernel\ntstubs.c
 */
#define FNID_START                  0x0000029A
#define FNID_WNDPROCSTART           0x0000029A

#define FNID_SCROLLBAR              0x0000029A      // xxxSBWndProc;
#define FNID_ICONTITLE              0x0000029B      // xxxDefWindowProc;
#define FNID_MENU                   0x0000029C      // xxxMenuWindowProc;
#define FNID_DESKTOP                0x0000029D      // xxxDesktopWndProc;
#define FNID_DEFWINDOWPROC          0x0000029E      // xxxDefWindowProc;
#define FNID_MESSAGEWND             0x0000029F      // xxxDefWindowProc;
#define FNID_SWITCH                 0x000002A0      // xxxSwitchWndProc

#define FNID_WNDPROCEND             0x000002A0      // see PatchThreadWindows
#define FNID_CONTROLSTART           0x000002A1

#define FNID_BUTTON                 0x000002A1      // No server side proc
#define FNID_COMBOBOX               0x000002A2      // No server side proc
#define FNID_COMBOLISTBOX           0x000002A3      // No server side proc
#define FNID_DIALOG                 0x000002A4      // No server side proc
#define FNID_EDIT                   0x000002A5      // No server side proc
#define FNID_LISTBOX                0x000002A6      // No server side proc
#define FNID_MDICLIENT              0x000002A7      // No server side proc
#define FNID_STATIC                 0x000002A8      // No server side proc

#define FNID_IME                    0x000002A9      // No server side proc
#define FNID_CONTROLEND             0x000002A9

#define FNID_HKINLPCWPEXSTRUCT      0x000002AA
#define FNID_HKINLPCWPRETEXSTRUCT   0x000002AB
#define FNID_DEFFRAMEPROC           0x000002AC      // No server side proc
#define FNID_DEFMDICHILDPROC        0x000002AD      // No server side proc
#define FNID_MB_DLGPROC             0x000002AE      // No server side proc
#define FNID_MDIACTIVATEDLGPROC     0x000002AF      // No server side proc
#define FNID_SENDMESSAGE            0x000002B0

#define FNID_SENDMESSAGEFF          0x000002B1
#define FNID_SENDMESSAGEEX          0x000002B2
#define FNID_CALLWINDOWPROC         0x000002B3
#define FNID_SENDMESSAGEBSM         0x000002B4
#define FNID_TOOLTIP                0x000002B5
#define FNID_GHOST                  0x000002B6

#define FNID_SENDNOTIFYMESSAGE      0x000002B7
#define FNID_SENDMESSAGECALLBACK    0x000002B8

#define FNID_END                    0x000002B8

/*
 * The size of the server side function table is defined as a power of two
 * so a simple "and" operation can be used to determine if a function index
 * is legal or not. Unused entries in the table are fill with a routine that
 * catches invalid functions that have indices within range, but are not
 * implemented.
 */

#define FNID_ARRAY_SIZE             32

#if (FNID_END - FNID_START + 1) > FNID_ARRAY_SIZE
    #error"The size of the function array is greater than the allocated storage"
#endif // (FNID_END - FNID_START + 1) > FNID_ARRAY_SIZE

#define FNID_DDE_BIT                0x00002000    // Used by RegisterClassExWOW
#define FNID_CLEANEDUP_BIT          0x00004000
#define FNID_DELETED_BIT            0x00008000
#define FNID_STATUS_BITS            (FNID_CLEANEDUP_BIT | FNID_DELETED_BIT)

#define FNID(s)     (gpsi->mpFnidPfn[((DWORD)(s) - FNID_START) & (FNID_ARRAY_SIZE - 1)])
#define STOCID(s)   (gpsi->aStoCidPfn[(DWORD)((s) & ~FNID_STATUS_BITS) - FNID_START])
#define CBFNID(s)   (gpsi->mpFnid_serverCBWndProc[(DWORD)((s) & ~FNID_STATUS_BITS) - FNID_START])
#define GETFNID(pwnd)       ((pwnd)->fnid & ~FNID_STATUS_BITS)

#ifndef BUILD_WOW6432
typedef LRESULT (APIENTRY * WNDPROC_PWND)(PWND, UINT, WPARAM, LPARAM);
typedef LRESULT (APIENTRY * WNDPROC_PWNDEX)(PWND, UINT, WPARAM, LPARAM, ULONG_PTR);
#else
typedef KERNEL_PVOID WNDPROC_PWND;
typedef KERNEL_PVOID WNDPROC_PWNDEX;
#endif
typedef BOOL (APIENTRY * WNDENUMPROC_PWND)(PWND, LPARAM);
typedef VOID (APIENTRY * TIMERPROC_PWND)(PWND, UINT, UINT_PTR, LPARAM);

/*
 * Structure passed by client during process initialization that holds some
 * client-side callback addresses.
 */
typedef struct _PFNCLIENT {
    KPROC pfnScrollBarWndProc;       // and must be paired Unicode then ANSI
    KPROC pfnTitleWndProc;
    KPROC pfnMenuWndProc;
    KPROC pfnDesktopWndProc;
    KPROC pfnDefWindowProc;
    KPROC pfnMessageWindowProc;
    KPROC pfnSwitchWindowProc;

// Below not in FNID_WNDPROCSTART FNID_WNDPROCEND range

    KPROC pfnButtonWndProc;
    KPROC pfnComboBoxWndProc;
    KPROC pfnComboListBoxProc;
    KPROC pfnDialogWndProc;
    KPROC pfnEditWndProc;
    KPROC pfnListBoxWndProc;
    KPROC pfnMDIClientWndProc;
    KPROC pfnStaticWndProc;
    KPROC pfnImeWndProc;

// Below not in FNID_CONTROLSTART FNID_CONTROLEND range

    KPROC pfnHkINLPCWPSTRUCT;    // client-side callback for hook thunks
    KPROC pfnHkINLPCWPRETSTRUCT; // client-side callback for hook thunks
    KPROC pfnDispatchHook;
    KPROC pfnDispatchDefWindowProc;
    KPROC pfnDispatchMessage;
    KPROC pfnMDIActivateDlgProc;
} PFNCLIENT, *PPFNCLIENT;

typedef struct _PFNCLIENTWORKER {
    KPROC pfnButtonWndProc;
    KPROC pfnComboBoxWndProc;
    KPROC pfnComboListBoxProc;
    KPROC pfnDialogWndProc;
    KPROC pfnEditWndProc;
    KPROC pfnListBoxWndProc;
    KPROC pfnMDIClientWndProc;
    KPROC pfnStaticWndProc;
    KPROC pfnImeWndProc;
} PFNCLIENTWORKER, *PPFNCLIENTWORKER;

#ifdef BUILD_WOW6432

extern const PFNCLIENT   pfnClientA;
extern const PFNCLIENT   pfnClientW;
extern const PFNCLIENTWORKER   pfnClientWorker;

#define FNID_TO_CLIENT_PFNA_CLIENT(s) ((ULONG_PTR)(*(((KERNEL_ULONG_PTR *)&pfnClientA) + (s - FNID_START))))
#define FNID_TO_CLIENT_PFNW_CLIENT(s) ((ULONG_PTR)(*(((KERNEL_ULONG_PTR *)&pfnClientW) + (s - FNID_START))))
#define FNID_TO_CLIENT_PFNWORKER(s)   ((ULONG_PTR)(*(((KERNEL_ULONG_PTR *)&pfnClientWorker) + (s - FNID_CONTROLSTART))))

WNDPROC_PWND MapKernelClientFnToClientFn(WNDPROC_PWND lpfnWndProc);

#else

#define FNID_TO_CLIENT_PFNA_CLIENT FNID_TO_CLIENT_PFNA_KERNEL
#define FNID_TO_CLIENT_PFNW_CLIENT FNID_TO_CLIENT_PFNW_KERNEL
#define FNID_TO_CLIENT_PFNWORKER(s) (*(((KERNEL_ULONG_PTR *)&gpsi->apfnClientWorker) + (s - FNID_CONTROLSTART)))

#define MapKernelClientFnToClientFn(lpfnWndProc) (lpfnWndProc)

#endif

#define FNID_TO_CLIENT_PFNA_KERNEL(s) (*(((KERNEL_ULONG_PTR * KPTR_MODIFIER)&gpsi->apfnClientA) + (s - FNID_START)))
#define FNID_TO_CLIENT_PFNW_KERNEL(s) (*(((KERNEL_ULONG_PTR * KPTR_MODIFIER)&gpsi->apfnClientW) + (s - FNID_START)))

#define FNID_TO_CLIENT_PFNA FNID_TO_CLIENT_PFNA_KERNEL
#define FNID_TO_CLIENT_PFNW FNID_TO_CLIENT_PFNW_KERNEL

/*
 * Object types
 *
 * NOTE: Changing this table means changing hard-coded arrays that depend
 * on the index number (in security.c and in debug.c)
 */
#define TYPE_FREE           0           // must be zero!
#define TYPE_WINDOW         1           // in order of use for C code lookups
#define TYPE_MENU           2
#define TYPE_CURSOR         3
#define TYPE_SETWINDOWPOS   4
#define TYPE_HOOK           5
#define TYPE_CLIPDATA       6           // clipboard data
#define TYPE_CALLPROC       7
#define TYPE_ACCELTABLE     8
#define TYPE_DDEACCESS      9
#define TYPE_DDECONV        10
#define TYPE_DDEXACT        11          // DDE transaction tracking info.
#define TYPE_MONITOR        12
#define TYPE_KBDLAYOUT      13          // Keyboard Layout handle (HKL) object.
#define TYPE_KBDFILE        14          // Keyboard Layout file object.
#define TYPE_WINEVENTHOOK   15          // WinEvent hook (EVENTHOOK)
#define TYPE_TIMER          16
#define TYPE_INPUTCONTEXT   17          // Input Context info structure
#define TYPE_HIDDATA        18
#define TYPE_DEVICEINFO     19

#define TYPE_CTYPES         20          // Count of TYPEs; Must be LAST + 1

#define TYPE_GENERIC        255         // used for generic handle validation

/* OEM Bitmap Information Structure */
typedef struct tagOEMBITMAPINFO
{
    int     x;
    int     y;
    int     cx;
    int     cy;
} OEMBITMAPINFO, * KPTR_MODIFIER POEMBITMAPINFO;

// For the following OBI_ defines :
//
// a  pushed   state bitmap should be at +1 from it's normal state bitmap
// an inactive state bitmap should be at +2 from it's normal state bitmap
// A small caption bitmap should be +2 from the normal bitmap

#define DOBI_NORMAL         0
#define DOBI_PUSHED         1
#define DOBI_HOT            2
#define DOBI_INACTIVE       3

#define DOBI_CHECK      1   // checkbox/radio/3state button states
#define DOBI_DOWN       2
#define DOBI_CHECKDOWN  3

#define DOBI_CAPON      0   // caption states
#define DOBI_CAPOFF     1

// shared bitmap mappings
#define DOBI_3STATE         8   // offset from checkbox to 3state
#define DOBI_MBAR OBI_CLOSE_MBAR    // offset to menu bar equivalent

#define OBI_CLOSE            0      // caption close button
#define OBI_CLOSE_D          1
#define OBI_CLOSE_H          2
#define OBI_CLOSE_I          3
#define OBI_REDUCE           4      // caption minimize button
#define OBI_REDUCE_D         5
#define OBI_REDUCE_H         6
#define OBI_REDUCE_I         7
#define OBI_RESTORE          8      // caption restore button
#define OBI_RESTORE_D        9
#define OBI_RESTORE_H       10
#define OBI_HELP            11
#define OBI_HELP_D          12
#define OBI_HELP_H          13
#define OBI_ZOOM            14      // caption maximize button
#define OBI_ZOOM_D          15
#define OBI_ZOOM_H          16
#define OBI_ZOOM_I          17
#define OBI_CLOSE_MBAR      18      // menu bar close button
#define OBI_CLOSE_MBAR_D    19
#define OBI_CLOSE_MBAR_H    20
#define OBI_CLOSE_MBAR_I    21
#define OBI_REDUCE_MBAR     22      // menu bar minimize button
#define OBI_REDUCE_MBAR_D   23
#define OBI_REDUCE_MBAR_H   24
#define OBI_REDUCE_MBAR_I   25
#define OBI_RESTORE_MBAR    26      // menu bar restore button
#define OBI_RESTORE_MBAR_D  27
#define OBI_RESTORE_MBAR_H  28
#define OBI_CAPCACHE1       29      // caption icon cache entry #1
#define OBI_CAPCACHE1_I     30
#define OBI_CAPCACHE2       31      // caption icon cache entry #2
#define OBI_CAPCACHE2_I     32
#define OBI_CAPCACHE3       33      // caption icon cache entry #3
#define OBI_CAPCACHE3_I     34
#define OBI_CAPCACHE4       35      // caption icon cache entry #4
#define OBI_CAPCACHE4_I     36
#define OBI_CAPCACHE5       37      // caption icon cache entry #5
#define OBI_CAPCACHE5_I     38
#define OBI_CAPBTNS         39      // caption buttons cache
#define OBI_CAPBTNS_I       40
#define OBI_CLOSE_PAL       41      // small caption close button
#define OBI_CLOSE_PAL_D     42
#define OBI_CLOSE_PAL_H     43
#define OBI_CLOSE_PAL_I     44
#define OBI_NCGRIP          45      // bottom/right size grip
#define OBI_UPARROW         46      // up scroll arrow
#define OBI_UPARROW_D       47
#define OBI_UPARROW_H       48
#define OBI_UPARROW_I       49
#define OBI_DNARROW         50      // down scroll arrow
#define OBI_DNARROW_D       51
#define OBI_DNARROW_H       52
#define OBI_DNARROW_I       53
#define OBI_RGARROW         54      // right scroll arrow
#define OBI_RGARROW_D       55
#define OBI_RGARROW_H       56
#define OBI_RGARROW_I       57
#define OBI_LFARROW         58      // left scroll arrow
#define OBI_LFARROW_D       59
#define OBI_LFARROW_H       60
#define OBI_LFARROW_I       61
#define OBI_MENUARROW       62      // menu hierarchy arrow
#define OBI_MENUCHECK       63      // menu check mark
#define OBI_MENUBULLET      64      // menu bullet mark
#define OBI_MENUARROWUP     65
#define OBI_MENUARROWUP_H   66
#define OBI_MENUARROWUP_I   67
#define OBI_MENUARROWDOWN   68
#define OBI_MENUARROWDOWN_H 69
#define OBI_MENUARROWDOWN_I 70
#define OBI_RADIOMASK       71      // radio button mask
#define OBI_CHECK           72      // check box
#define OBI_CHECK_C         73
#define OBI_CHECK_D         74
#define OBI_CHECK_CD        75
#define OBI_CHECK_CDI       76
#define OBI_RADIO           77      // radio button
#define OBI_RADIO_C         78
#define OBI_RADIO_D         79
#define OBI_RADIO_CD        80
#define OBI_RADIO_CDI       81
#define OBI_3STATE          82      // 3-state button
#define OBI_3STATE_C        83
#define OBI_3STATE_D        84
#define OBI_3STATE_CD       85
#define OBI_3STATE_CDI      86
#define OBI_POPUPFIRST      87      // System popupmenu bitmaps.
#define OBI_CLOSE_POPUP     87
#define OBI_RESTORE_POPUP   88
#define OBI_ZOOM_POPUP      89
#define OBI_REDUCE_POPUP    90
#define OBI_NCGRIP_L        91
#define OBI_MENUARROW_L     92
#define OBI_COUNT           93      // bitmap count

/*
 * One global instance of this structure is allocated into memory that is
 * mapped into all clients' address space.  Client-side functions will
 * read this data to avoid calling the server.
 */

#define NCHARS   256
#define NCTRLS   0x20

#define PUSIF_PALETTEDISPLAY            0x00000001  /* Is the display palettized? */
#define PUSIF_SNAPTO                    0x00000002  /* Is SnapTo enabled? */
#define PUSIF_COMBOBOXANIMATION         0x00000004  /* Must match UPBOOLMask(SPI_GETCOMBOBOXANIMATION) */
#define PUSIF_LISTBOXSMOOTHSCROLLING    0x00000008  /* Must match UPBOOLMask(SPI_GETLISTBOXSMOOTHSCROLLING) */
#define PUSIF_KEYBOARDCUES              0x00000020  /* Must match UPBOOLMask(SPI_GETKEYBOARDCUES) */

#define PUSIF_UIEFFECTS                 0x80000000  /* Must match UPBOOLMask(SPI_GETUIEFFECTS) */

#define TEST_PUSIF(f)               TEST_FLAG(gpsi->PUSIFlags, f)
#define TEST_BOOL_PUSIF(f)          TEST_BOOL_FLAG(gpsi->PUSIFlags, f)
#define SET_PUSIF(f)                SET_FLAG(gpsi->PUSIFlags, f)
#define CLEAR_PUSIF(f)              CLEAR_FLAG(gpsi->PUSIFlags, f)
#define SET_OR_CLEAR_PUSIF(f, fSet) SET_OR_CLEAR_FLAG(gpsi->PUSIFlags, f, fSet)
#define TOGGLE_PUSIF(f)             TOGGLE_FLAG(gpsi->PUSIFlags, f)

#define TEST_EffectPUSIF(f)  \
    ((gpsi->PUSIFlags & (f | PUSIF_UIEFFECTS)) == (f | PUSIF_UIEFFECTS))

/*
 * Some UI effects have an "inverted" disabled value (ie, disabled is TRUE)
 */
#define TEST_EffectInvertPUSIF(f) (TEST_PUSIF(f) || !TEST_PUSIF(PUSIF_UIEFFECTS))

#define TEST_KbdCuesPUSIF (!gpsi->bKeyboardPref                         \
                        && !TEST_EffectInvertPUSIF(PUSIF_KEYBOARDCUES)  \
                        && !(GetAppCompatFlags2(VER40) & GACF2_KCOFF))


typedef struct tagPERUSERSERVERINFO {
    /*
     * All of this information should be mapped to the server, but put in
     * the desktop section so it can vary from desktop to desktop.
     */

    int         aiSysMet[SM_CMETRICS];
    COLORREF    argbSystemUnmatched[COLOR_MAX];
    COLORREF    argbSystem[COLOR_MAX];
    KHBRUSH     ahbrSystem[COLOR_MAX];
    KHBRUSH     hbrGray;
    POINT       ptCursor;
    DWORD       dwLastRITEventTickCount;
    int         nEvents;

    int         gclBorder;              /* # of logical units in window frame */

    UINT        dtScroll;
    UINT        dtLBSearch;
    UINT        dtCaretBlink;
    UINT        ucWheelScrollLines;    /* # of lines to scroll when wheel is rolled */

    int         wMaxLeftOverlapChars;
    int         wMaxRightOverlapChars;

    /*
     * these are here to lose a thunk for GetDialogBaseUnits
     */
    int         cxSysFontChar;
    int         cySysFontChar;
    int         cxMsgFontChar;
    int         cyMsgFontChar;
    TEXTMETRIC  tmSysFont;

    /*
     * values to allow HasCaptionIcon to be in user32
     */
    KHICON      hIconSmWindows;
    KHICON      hIcoWindows;

    KHFONT      hCaptionFont;
    KHFONT      hMsgFont;

    /*
     * These are needed for various user-mode performance hacks.
     */
    DWORD       dwKeyCache;
    DWORD       dwAsyncKeyCache;
    DWORD       cCaptures;

    /*
     * Information about the current state of the display which needs to
     * be shared with the client side. The information here corresponds
     * to the display in gpDispInfo. Note that much of this information
     * is only for the primary monitor.
     */
    OEMBITMAPINFO oembmi[OBI_COUNT];  /* OEM bitmap information */
    RECT          rcScreen;           /* rectangle of the virtual screen */
    WORD          BitCount;           /* Planes * Depth */
    WORD          dmLogPixels;        /* logical pixels per inch, both X and Y */
    BYTE          Planes;             /* Planes */
    BYTE          BitsPixel;          /* Depth */

    DWORD         PUSIFlags;          // PUSIF_ flags
    UINT          uCaretWidth;        /* caret width in edits */
    LANGID        UILangID;           // Default UI language

    BOOL        bLastRITWasKeyboard : 1;
    BOOL        bKeyboardPref : 1;    /* To propagate ACCF_KEYBOARDPREF to client side */

    /*
     * TickCount when our session updated LastSystemRITEventTickCount on
     * the shared system page that stands for the last RIT event time across
     * all terminal sessions. For MP performance, it is not updated all
     * the time.
     */
    DWORD       dwLastSystemRITEventTickCountUpdate;

} PERUSERSERVERINFO, *PPERUSERSERVERINFO;

/*
 * System-wide last user input info on shared system page is updated
 * by a session only if this many tick counts have elapsed since
 * the last time the session updated it.
 */

#define SYSTEM_RIT_EVENT_UPDATE_PERIOD  (60 * 1000)

#define SRVIF_CHECKED                   0x0001
//      SRVIF_WINEVENTHOOKS             0x0002  Obsoleted by FEVENTHOOKED
#define SRVIF_DBCS                      0x0004
#define SRVIF_IME                       0x0008
#define SRVIF_MIDEAST                   0x0010
#define SRVIF_HOOKED                    0x0020
#ifdef CUAS_ENABLE
#define SRVIF_CTFIME_ENABLED            0x0040
#endif // CUAS_ENABLE

#define TEST_SRVIF(f)                   TEST_FLAG(gpsi->wSRVIFlags, f)
#define TEST_BOOL_SRVIF(f)              TEST_BOOL_FLAG(gpsi->wSRVIFlags, f)
#define SET_SRVIF(f)                    SET_FLAG(gpsi->wSRVIFlags, f)
#define CLEAR_SRVIF(f)                  CLEAR_FLAG(gpsi->wSRVIFlags, f)
#define SET_OR_CLEAR_SRVIF(f, fSet)     SET_OR_CLEAR_FLAG(gpsi->wSRVIFlags, f, fSet)
#define TOGGLE_SRVIF(f)                 TOGGLE_FLAG(gpsi->wSRVIFlags, f)

typedef struct tagSERVERINFO {      // si
    WORD    wRIPFlags;              // RIPF_ flags
    WORD    wSRVIFlags;             // SRVIF_ flags
    WORD    wRIPPID;                // PID of process to apply RIP flags to (zero means all)
    WORD    wRIPError;              // Error to break on (zero means all errors are treated equal)

    KERNEL_ULONG_PTR cHandleEntries;    // count of handle entries in array

    /*
     * Array of server-side function pointers.
     * Client passes servers function ID so they can be easily validated;
     * this array maps function ID into server-side function address.
     * The order of these are enforced by the FNID_ constants, and must match
     * the client-side mpFnidClientPfn[] order as well.
     */
    WNDPROC_PWNDEX mpFnidPfn[FNID_ARRAY_SIZE]; // function mapping table
    WNDPROC_PWND aStoCidPfn[(FNID_WNDPROCEND - FNID_START) + 1];

    // mapping of fnid to min bytes need by public windproc user
    WORD mpFnid_serverCBWndProc[(FNID_END - FNID_START) + 1];

    /*
     * Client side functions pointer structure.
     */
    struct _PFNCLIENT apfnClientA;
    struct _PFNCLIENT apfnClientW;
    struct _PFNCLIENTWORKER apfnClientWorker;

    DWORD cbHandleTable;

    /*
     * Class atoms to allow fast checks on the client.
     */
    ATOM atomSysClass[ICLS_MAX];   // Atoms for control classes

    DWORD dwDefaultHeapBase;            // so WOW can do handle validation
    DWORD dwDefaultHeapSize;

    UINT uiShellMsg;         // message for shell hooks

    UINT  wMaxBtnSize;   /* Size of the longest button string in any MessageBox */

    MBSTRING MBStrings[MAX_MB_STRINGS];

    /*
     * values to allow HasCaptionIcon to be in user32
     */
    ATOM atomIconSmProp;
    ATOM atomIconProp;

    ATOM atomContextHelpIdProp;

    char acOemToAnsi[NCHARS];
    char acAnsiToOem[NCHARS];

#ifdef LAME_BUTTON
    /*
     * button size
     */
    int ncxLame;
    WCHAR   gwszLame[50];
#endif // LAME_BUTTON

    /*
     * Per user settings. We use _HYDRA_'s PERUSERSERVERINO struct
     * to avoid defining fields in two places.
     */
    PERUSERSERVERINFO;

#if DEBUGTAGS
    DWORD adwDBGTAGFlags[DBGTAG_Max + 1];
#endif // DEBUGTAGS

    /*
     * We track the WinEvent hooks that are installed for events by their
     * event category.  This is strictly an implementation detail, and is
     * not exposed to the user.  The user API is IsWinEventHookInstalled.
     */
    DWORD dwInstalledEventHooks;

} SERVERINFO;


/*
 * IS_BUTTON checks if the button is either our system button control or
 * a fusionized one.
 *
 * To check for system button controls only, then use
 * (GETFNID(pwnd) == FNID_BUTTON).
 *
 * IS_EDIT works similarly for edit controls and the system edit control
 * can also be checked by (GETFNID(pwnd) == FNID_EDIT).
 */
#ifdef _USERK_
#define REBASEALWAYS(p, elem) ((p)->elem)
#endif
#define IS_BUTTON(pwnd)  (gpsi->atomSysClass[ICLS_BUTTON] == ((PCLS)REBASEALWAYS(pwnd, pcls))->atomNVClassName)
#define IS_EDIT(pwnd)    (gpsi->atomSysClass[ICLS_EDIT] == ((PCLS)REBASEALWAYS(pwnd, pcls))->atomNVClassName)

/*
 * Event Categories
 * If you make any changes here, you must update the global variable geci,
 * and the define EVENTCATEGORY_ALL!
 */
#define EVENTCATEGORY_SYSTEM_MENU           0x0001
#define EVENTCATEGORY_CONSOLE               0x0002
#define EVENTCATEGORY_FOCUS                 0x0004
#define EVENTCATEGORY_NAMECHANGE            0x0008
#define EVENTCATEGORY_VALUECHANGE           0x0010
#define EVENTCATEGORY_STATECHANGE           0x0020
#define EVENTCATEGORY_LOCATIONCHANGE        0x0040
#define EVENTCATEGORY_OTHER                 0x8000
#define EVENTCATEGORY_ALL                   0x807F
DWORD CategoryMaskFromEvent(DWORD event);
DWORD CategoryMaskFromEventRange(DWORD eventMin, DWORD eventMax);

/*
 * Quick test for any Window Event Hooks.
 */
#define FEVENTCATEGORYHOOKED(CategoryMask) (TEST_FLAG(gpsi->dwInstalledEventHooks, (CategoryMask)) ? TRUE : FALSE)
#define FEVENTHOOKED(Event) FEVENTCATEGORYHOOKED(CategoryMaskFromEvent(Event))

/* MessageBox String pointers from offset in the gpsi struct */
#define GETGPSIMBPSTR(u) KPWSTR_TO_PWSTR(gpsi->MBStrings[(u)].szName)

typedef struct _WNDMSG {
    UINT maxMsgs;
    KPBYTE abMsgs;
} WNDMSG, *PWNDMSG;

typedef struct tagSHAREDINFO {
    PSERVERINFO     psi;
    PHE             aheList;         /* handle table pointer                */
    PDISPLAYINFO    pDispInfo;       /* global displayinfo                  */
    KERNEL_UINT_PTR ulSharedDelta;   /* delta between client and kernel mapping of ...*/
                                     /* shared memory section. Only valid/used in client.*/

    WNDMSG          awmControl[FNID_END - FNID_START + 1];

    WNDMSG          DefWindowMsgs;
    WNDMSG          DefWindowSpecMsgs;
} SHAREDINFO, *PSHAREDINFO;

typedef struct _USERCONNECT {
    IN  ULONG ulVersion;
    OUT ULONG ulCurrentVersion;
    IN  DWORD dwDispatchCount;
    OUT SHAREDINFO siClient;
} USERCONNECT, *PUSERCONNECT;

#define USER_MAJOR_VERSION  0x0005
#define USER_MINOR_VERSION  0x0000

#define USERCURRENTVERSION   MAKELONG(USER_MINOR_VERSION, USER_MAJOR_VERSION)

/*
 * Options used for NtUserSetSysColors
 */
#define SSCF_NOTIFY             0x00000001
#define SSCF_FORCESOLIDCOLOR    0x00000002
#define SSCF_SETMAGICCOLORS     0x00000004
#define SSCF_16COLORS           0x00000008

/*
 * Structure used for GetClipboardData, where we can have
 * extra information returned from the kernel.
 */
typedef struct tagGETCLIPBDATA {

    UINT   uFmtRet;          // Identifies returned format.
    BOOL   fGlobalHandle;    // Indicates if handle is global.
    union {
        HANDLE hLocale;      // Locale (text-type formats only).
        HANDLE hPalette;     // Palette (bitmap-type formats only).
    };

} GETCLIPBDATA, *PGETCLIPBDATA;

/*
 * Structure used for SetClipboardData, where we can have
 * extra information passed to the kernel.
 */
typedef struct tagSETCLIPBDATA {

    BOOL fGlobalHandle;      // Indicates if handle is global.
    BOOL fIncSerialNumber;   // Indicates if we should increment serial#

} SETCLIPBDATA, *PSETCLIPBDATA;

/*
 * HM Object definition control flags
 */
#define OCF_THREADOWNED         0x01
#define OCF_PROCESSOWNED        0x02
#define OCF_MARKPROCESS         0x04
#define OCF_USEPOOLQUOTA        0x08
#define OCF_DESKTOPHEAP         0x10
#define OCF_USEPOOLIFNODESKTOP  0x20
#define OCF_SHAREDHEAP          0x40
#if DBG
#define OCF_VARIABLESIZE        0x80
#else
#define OCF_VARIABLESIZE        0
#endif

/*
 * From HANDTABL.C
 */
/*
 * Static information about each handle type.
 */
typedef void (*FnDestroyUserObject)(void *);

typedef struct tagHANDLETYPEINFO {
#if DBG
    LPCSTR              szObjectType;
    UINT                uSize;
#endif
    FnDestroyUserObject fnDestroy;
    DWORD               dwAllocTag;
    BYTE                bObjectCreateFlags;
} HANDLETYPEINFO, *PHANDLETYPEINFO;

/*
 * The following is the header of all objects managed in the handle list.
 * (allocated as part of the object for easy access).  All object
 * headers must start with the members of a HEAD structure.
 */
typedef struct _HEAD {
    KHANDLE h;
    DWORD   cLockObj;
} HEAD, * KPTR_MODIFIER PHEAD;

/*
 * sizeof(THROBJHEAD) must be equal to sizeof(PROCOBJHEAD)
 * This is to make sure that DESKHEAD fields are always at the same offset.
 */
typedef struct _THROBJHEAD {
    HEAD;
    PTHREADINFO pti;
} THROBJHEAD, * KPTR_MODIFIER PTHROBJHEAD;

typedef struct _PROCOBJHEAD {
    HEAD;
    DWORD hTaskWow;
} PROCOBJHEAD, *PPROCOBJHEAD;

typedef struct _PROCMARKHEAD {
    PROCOBJHEAD;
    PPROCESSINFO ppi;
} PROCMARKHEAD, *PPROCMARKHEAD;

typedef struct _DESKHEAD {
    PDESKTOP rpdesk;
    KPBYTE   pSelf;
} DESKHEAD, *PDESKHEAD;

/*
 * This type is for HM casting only. Use THRDESKHEAD or PROCDESKHEAD instead.
 */
typedef struct _DESKOBJHEAD {
    HEAD;
    KERNEL_PVOID pOwner;
    DESKHEAD;
} DESKOBJHEAD, *PDESKOBJHEAD;

typedef struct _THRDESKHEAD {
    THROBJHEAD;
    DESKHEAD;
} THRDESKHEAD, *PTHRDESKHEAD;

typedef struct _PROCDESKHEAD {
    PROCOBJHEAD;
    DESKHEAD;
} PROCDESKHEAD, *PPROCDESKHEAD;



#define HANDLEF_DESTROY        0x01
#define HANDLEF_INDESTROY      0x02
#define HANDLEF_MARKED_OK      0x10
#define HANDLEF_GRANTED        0x20
#define HANDLEF_POOL           0x40     // for the mother desktop window
#define HANDLEF_VALID          0x7F

/*
 * The following is a handle table entry.
 *
 * Note that by keeping a pointer to the owning entity (process or
 * thread), cleanup will touch only those objects that belong to
 * the entity being destroyed.  This helps keep the working set
 * size down.  Look at DestroyProcessesObjects() for an example.
 */
typedef struct _HANDLEENTRY {
    PHEAD       phead;                  /* pointer to the real object */
    KERNEL_PVOID pOwner;                 /* pointer to owning entity (pti or ppi) */
    BYTE        bType;                  /* type of object */
    BYTE        bFlags;                 /* flags - like destroy flag */
    WORD        wUniq;                  /* uniqueness count */

#if DBG
    PLR         plr;                    /* lock record pointer */
#endif // DBG

} HANDLEENTRY;

/*
 * Change HMINDEXBITS for bits that make up table index in handle
 * Change HMUNIQSHIFT for count of bits to shift uniqueness left.
 * Change HMUNIQBITS for bits that make up uniqueness.
 *
 * Currently 64K handles can be created, w/16 bits of uniqueness.
 */
#define HMINDEXBITS             0x0000FFFF      // bits where index is stored
#define HMUNIQSHIFT             16              // bits to shift uniqueness
#define HMUNIQBITS              0xFFFF          // valid uniqueness bits

#ifdef _USERK_
#define HMHandleFromIndex(i)    LongToHandle((LONG)(i) | ((LONG)gSharedInfo.aheList[i].wUniq << HMUNIQSHIFT))
#define HMObjectFlags(p)        (gahti[HMObjectType(p)].bObjectCreateFlags)
#endif

#define HMIndexFromHandle(h)    ((ULONG)(((ULONG_PTR)(h)) & HMINDEXBITS))
#define _HMPheFromObject(p)      (&gSharedInfo.aheList[HMIndexFromHandle((((PHEAD)p)->h))])
#define _HMObjectFromHandle(h)  ((KERNEL_PVOID)(gSharedInfo.aheList[HMIndexFromHandle(h)].phead))
#define HMUniqFromHandle(h)     ((WORD)((((ULONG_PTR)h) >> HMUNIQSHIFT) & HMUNIQBITS))
#define HMObjectType(p)         (HMPheFromObject(p)->bType)

#define HMIsMarkDestroy(p)      (HMPheFromObject(p)->bFlags & HANDLEF_DESTROY)

/*
 * Validation, handle mapping, etc.
 */
#define HMRevalidateHandle(h)       HMValidateHandleNoSecure(h, TYPE_GENERIC)
#define HMRevalidateCatHandle(h)    HMValidateCatHandleNoSecure(h, TYPE_GENERIC)

#define HMRevalidateHandleNoRip(h)  HMValidateHandleNoRip(h, TYPE_GENERIC)
#define RevalidateHmenu(hmenuX)     HMValidateHandleNoRip(hmenuX, TYPE_MENU)

#define _PtoHq(p)       (KHANDLE_TO_HANDLE(((PHEAD)p)->h))
#define _PtoH(p)        ((HANDLE)((p) == NULL ? NULL : _PtoHq(p)))
#define _HW(pwnd)       ((HWND)_PtoH(pwnd))
#define _HWCCX(ccxPwnd) ((HWND)_PtoH(ccxPwnd))
#define _HWq(pwnd)      ((HWND)_PtoHq(pwnd))

#if DBG && defined(_USERK_)

PHE DBGHMPheFromObject (PVOID p);
PVOID DBGHMObjectFromHandle (HANDLE h);
PVOID DBGHMCatObjectFromHandle (HANDLE h);
HANDLE DBGPtoH (PVOID p);
HANDLE DBGPtoHq (PVOID p);
HWND DBGHW (PWND pwnd);
HWND DBGHWCCX (PWND pwnd);
HWND DBGHWq (PWND pwnd);

#define HMPheFromObject(p)      DBGHMPheFromObject((p))
#define HMObjectFromHandle(h)   DBGHMObjectFromHandle((HANDLE)(h))
#define HMCatObjectFromHandle(h) DBGHMCatObjectFromHandle((HANDLE)(h))
#define PtoH(p)                 DBGPtoH((PVOID)(p))
#define PtoHq(p)                DBGPtoHq((PVOID)(p))
#define HW(pwnd)                DBGHW((PWND)(pwnd))
#define HWCCX(ccxPwnd)          DBGHWCCX((PWND)(ccxPwnd))
#define HWq(pwnd)               DBGHWq((PWND)(pwnd))

#else

#define HMPheFromObject(p)      _HMPheFromObject(p)
#define HMObjectFromHandle(h)   _HMObjectFromHandle(h)
#define HMCatObjectFromHandle(h) _HMObjectFromHandle(h)
#define PtoH(p)                 _PtoH(p)
#define PtoHq(p)                _PtoHq(p)
#define HW(pwnd)                _HW(pwnd)
#define HWCCX(ccxPwnd)          _HW(ccxPwnd)
#define HWq(pwnd)               _HWq(pwnd)

#endif // DBG && defined(_USERK_)

/*
 * Inline functions / macros to access HM object head fields
 */
#define _GETPTI(p)      (((PTHROBJHEAD)p)->pti)
#define _GETPDESK(p)    (((PDESKOBJHEAD)p)->rpdesk)
#define _GETPPI(p)      (((PPROCMARKHEAD)p)->ppi)

#if DBG && defined(_USERK_)
extern CONST HANDLETYPEINFO gahti[];
extern SHAREDINFO gSharedInfo;
__inline PTHREADINFO GETPTI (PVOID p)
{
    UserAssert(HMObjectFlags(p) & OCF_THREADOWNED);
    return _GETPTI(p);
}
__inline PDESKTOP GETPDESK (PVOID p)
{
    UserAssert(HMObjectFlags(p) & OCF_DESKTOPHEAP);
    return _GETPDESK(p);
}
__inline PPROCESSINFO GETPPI (PVOID p)
{
    UserAssert(HMObjectFlags(p) & OCF_MARKPROCESS);
    return _GETPPI(p);
}

#else

#define GETPTI(p)       _GETPTI(p)
#define GETPDESK(p)     _GETPDESK(p)
#define GETPPI(p)       _GETPPI(p)

#endif /* #else #if DBG && defined(_USERK_) */

#define GETPWNDPPI(p) (GETPTI(p)->ppi)
#define GETPTIID(p)   (PsGetThreadId((p)->pEThread))


/*
 * NOTE!: there is code in exitwin.c that assumes HMIsMarkDestroy is defined as
 *      (HMPheFromObject(p)->bFlags & HANDLEF_DESTROY)
 */

#define CPD_ANSI_TO_UNICODE     0x0001      /* CPD represents ansi to U transition */
#define CPD_UNICODE_TO_ANSI     0x0002
#define CPD_TRANSITION_TYPES    (CPD_ANSI_TO_UNICODE|CPD_UNICODE_TO_ANSI)

#define CPD_CLASS               0x0010      /* Get CPD for a class */
#define CPD_WND                 0x0020
#define CPD_DIALOG              0x0040
#define CPD_WNDTOCLS            0x0080

#define CPDHANDLE_HI            ((ULONG_PTR)~HMINDEXBITS)
#define MAKE_CPDHANDLE(h)       (HMIndexFromHandle(h) | CPDHANDLE_HI)
#define ISCPDTAG(x)             (((ULONG_PTR)(x) & CPDHANDLE_HI) == CPDHANDLE_HI)

/*
 * Call Proc Handle Info
 */
typedef struct _CALLPROCDATA {
    PROCDESKHEAD                 head;
    PCALLPROCDATA                spcpdNext;
    KERNEL_ULONG_PTR             pfnClientPrevious;
    WORD                         wType;
} CALLPROCDATA;

/*
 * Class styles
 */
#define CFVREDRAW         0x0001
#define CFHREDRAW         0x0002
#define CFKANJIWINDOW     0x0004
#define CFDBLCLKS         0x0008
#define CFSERVERSIDEPROC  0x0010    // documented as reserved in winuser.h
#define CFOWNDC           0x0020
#define CFCLASSDC         0x0040
#define CFPARENTDC        0x0080
#define CFNOKEYCVT        0x0101
#define CFNOCLOSE         0x0102
#define CFLVB             0x0104
#define CFSAVEBITS        0x0108
#define CFOEMCHARS        0x0140
#define CFIME             0x0201
#define CFDROPSHADOW      0x0202

/*
 * Offset from the beginning of the CLS structure to the WNDCLASS section.
 */
#define CFOFFSET             (FIELD_OFFSET(CLS, style))

#define TestCF(hwnd, flag)   (*((KPBYTE)((PWND)(hwnd))->pcls + CFOFFSET + HIBYTE(flag)) & LOBYTE(flag))
#define SetCF(hwnd, flag)    (*((KPBYTE)((PWND)(hwnd))->pcls + CFOFFSET + HIBYTE(flag)) |= LOBYTE(flag))
#define ClrCF(pcls, flag)    (*((KPBYTE)((PWND)(hwnd))->pcls + CFOFFSET + HIBYTE(flag)) &= ~LOBYTE(flag))

#define TestCF2(pcls, flag)  (*((KPBYTE)(pcls) + CFOFFSET + (int)HIBYTE(flag)) & LOBYTE(flag))
#define SetCF2(pcls, flag)   (*((KPBYTE)(pcls) + CFOFFSET + (int)HIBYTE(flag)) |= LOBYTE(flag))
#define ClrCF2(pcls, flag)   (*((KPBYTE)(pcls) + CFOFFSET + (int)HIBYTE(flag)) &= ~LOBYTE(flag))

#define PWCFromPCLS(pcls)  ((PWC)KPBYTE_TO_PBYTE((KPBYTE)(pcls) + sizeof(CLS) + (pcls)->cbclsExtra))

/* Window class structure */
typedef struct tagCOMMON_WNDCLASS
{
    /*
     * We'll add cWndReferenceCount here so COMMON_WNDCLASS and WNDCLASSEX have
     * the same layout. Otherwise padding will mess us up on 64-bit platforms.
     */
    int           cWndReferenceCount; /* The number of windows registered
                                         with this class */
    UINT          style;
    WNDPROC_PWND  lpfnWndProc;       // HI BIT on means WOW PROC
    int           cbclsExtra;
    int           cbwndExtra;
    KHANDLE       hModule;
    PCURSOR       spicn;
    PCURSOR       spcur;
    KHBRUSH       hbrBackground;
    KLPWSTR       lpszMenuName;
    KLPSTR        lpszAnsiClassName;
    PCURSOR       spicnSm;
} COMMON_WNDCLASS;

/*
 * Class Menu names structure. For performance reasons (GetClassInfo) we
 * keep two client side copies of wndcls.lpszMenu and another kernel side
 * copy. This structure is used to pass menu names info between client and
 * kernel.
 */
typedef struct tagCLSMENUNAME
{
    KLPSTR              pszClientAnsiMenuName;
    KLPWSTR             pwszClientUnicodeMenuName;
    PUNICODE_STRING     pusMenuName;
} CLSMENUNAME, *PCLSMENUNAME;

/*
 * This is the window class structure.  All window classes are linked
 * together in a master list pointed to by gpclsList.
 *
 * RED ALERT! Do not add any fields after the COMMON_WNDCLASS structure;
 *            CFOFFSET depends on this.
 */

typedef struct tagCLS {
    /* NOTE: The order of the following fields is assumed. */
    PCLS                        pclsNext;
    ATOM                        atomClassName;      //Version aware class name.
    ATOM                        atomNVClassName;    //None-version aware class name.
    WORD                        fnid;               // record window proc used by this hwnd
                                                    // access through GETFNID
    PDESKTOP                    rpdeskParent;/* Parent desktop */
    PDCE                        pdce;            /* PDCE to DC associated with class */
    WORD                        hTaskWow;
    WORD                        CSF_flags;           /* internal class flags */
    KLPSTR                      lpszClientAnsiMenuName;     /* string or resource ID */
    KLPWSTR                     lpszClientUnicodeMenuName;  /* string or resource ID */

    PCALLPROCDATA               spcpdFirst;       /* Pointer to first CallProcData element (or 0) */
    PCLS                        pclsBase;        /* Pointer to base class */
    PCLS                        pclsClone;       /* Pointer to clone class list */

    COMMON_WNDCLASS;
    /*
     * WARNING:
     * CFOFFSET expects COMMON_WNDCLASS to be last fields in CLS
     */
} CLS, **PPCLS;

/*
 * This class flag is used to distinguish classes that were registered
 * by the server (most system classes) from those registered by the client.
 * Note -- flags are a WORD in the class structure now.
 */
#define CSF_SERVERSIDEPROC      0x0001
#define CSF_ANSIPROC            0x0002
#define CSF_WOWDEFERDESTROY     0x0004
#define CSF_SYSTEMCLASS         0x0008
#define CSF_WOWCLASS            0x0010  // extra words at end for wow info
#define CSF_WOWEXTRA            0x0020
#define CSF_CACHEDSMICON        0x0040
#define CSF_WIN40COMPAT         0x0080
#define CSF_VERSIONCLASS        0x0100
#define CSF_VALID               (CSF_ANSIPROC | CSF_WIN40COMPAT | CSF_VERSIONCLASS)

/*
 * SBDATA are the values for one scrollbar
 */

typedef struct tagSBDATA {
    int    posMin;
    int    posMax;
    int    page;
    int    pos;
} SBDATA, *PSBDATA;

/*
 * SBINFO is the set of values that hang off of a window structure, if the
 * window has scrollbars.
 */
typedef struct tagSBINFO {
    int WSBflags;
    SBDATA Horz;
    SBDATA Vert;
} SBINFO, * KPTR_MODIFIER PSBINFO;

/*
 * Window Property structure
 */
typedef struct tagPROP {
    KHANDLE hData;
    ATOM atomKey;
    WORD fs;
} PROP, * KPTR_MODIFIER PPROP;

#define PROPF_INTERNAL   0x0001
#define PROPF_STRING     0x0002
#define PROPF_NOPOOL     0x0004


/*
 * Window Property List structure
 */
typedef struct tagPROPLIST {
    UINT cEntries;
    UINT iFirstFree;
    PROP aprop[1];
} PROPLIST, * KPTR_MODIFIER PPROPLIST;

/*
 * NOTE -- this structure has been sorted (roughly) in order of use
 * of the fields. The x86 code set allows cheaper access to fields
 * that are in the first 0x80 bytes of a structure. Please attempt
 * to ensure that frequently-used fields are below this boundary.
 */

typedef struct tagWND {
    THRDESKHEAD   head;

    WW;         // WOW-USER common fields. Defined in wowuserp.h
                // The presence of "state" at the start of this structure is
                // assumed by the STATEOFFSET macro.

    PWND                 spwndNext;    // Handle to the next window
    PWND                 spwndPrev;    // Handle to the previous window
    PWND                 spwndParent;  // Backpointer to the parent window.
    PWND                 spwndChild;   // Handle to child
    PWND                 spwndOwner;   // Popup window owner field

    RECT                 rcWindow;     // Window outer rectangle
    RECT                 rcClient;     // Client rectangle

    WNDPROC_PWND         lpfnWndProc;  // Can be WOW address or standard address

    PCLS                 pcls;         // Pointer to window class

    KHRGN                hrgnUpdate;   // Accumulated paint region

    PPROPLIST            ppropList;    // Pointer to property list
    PSBINFO              pSBInfo;      // Words used for scrolling

    PMENU                spmenuSys;    // Handle to system menu
    PMENU                spmenu;       // Menu handle or ID

    KHRGN                hrgnClip;     // Clipping region for this window

    LARGE_UNICODE_STRING strName;
    int                  cbwndExtra;   // Extra bytes in window
    PWND                 spwndLastActive; // Last active in owner/ownee list
    KHIMC                hImc;         // Associated input context handle
    KERNEL_ULONG_PTR     dwUserData;   // Reserved for random application data
    struct _ACTIVATION_CONTEXT  * KPTR_MODIFIER pActCtx;
#ifdef LAME_BUTTON
    KERNEL_PVOID    pStackTrace;       // Creation stack trace; used by lame
                                       // button.
#endif // LAME_BUTTON
} WND;

#define NEEDSPAINT(pwnd)    (pwnd->hrgnUpdate != NULL || TestWF(pwnd, WFINTERNALPAINT))

/*
 * Combo Box stuff
 */
typedef struct tagCBox {
    PWND    spwnd;      /* Window for the combo box */
    PWND    spwndParent;/* Parent of the combo box */
    RECT    editrc;            /* Rectangle for the edit control/static text
                                  area */
    RECT    buttonrc;          /* Rectangle where the dropdown button is */

    int     cxCombo;            // Width of sunken area
    int     cyCombo;            // Height of sunken area
    int     cxDrop;             // 0x24 Width of dropdown
    int     cyDrop;             // Height of dropdown or shebang if simple

    PWND    spwndEdit;  /* Edit control window handle */
    PWND    spwndList;  /* List box control window handle */

    UINT    CBoxStyle:2;         /* Combo box style */
    UINT    fFocus:1;          /* Combo box has focus? */
    UINT    fNoRedraw:1;       /* Stop drawing? */
    UINT    fMouseDown:1;      /* Was the popdown button just clicked and
                                   mouse still down? */
    UINT    fButtonPressed:1; /* Is the dropdown button in an inverted state?
                                */
    UINT    fLBoxVisible:1;    /* Is list box visible? (dropped down?) */
    UINT    OwnerDraw:2;       /* Owner draw combo box if nonzero. value
                                * specifies either fixed or varheight
                                */
    UINT    fKeyboardSelInListBox:1; /* Is the user keyboarding through the
                                      * listbox. So that we don't hide the
                                      * listbox on selchanges caused by the
                                      * user keyboard through it but we do
                                      * hide it if the mouse causes the
                                      * selchange.
                                      */
    UINT    fExtendedUI:1;     /* Are we doing TandyT's UI changes on this
                                * combo box?
                                */
    UINT    fCase:2;

    UINT    f3DCombo:1;         // 3D or flat border?
    UINT    fNoEdit:1;         /* True if editing is not allowed in the edit
                                * window.
                                */
#ifdef COLOR_HOTTRACKING
    UINT    fButtonHotTracked:1; /* Is the dropdown hot-tracked? */
#endif // COLOR_HOTTRACKING
    UINT    fRightAlign:1;     /* used primarily for MidEast right align */
    UINT    fRtoLReading:1;    /* used only for MidEast, text rtol reading order */
    UINT    fInDestroy:1;      /* Is combobox destruction started already? */
    HANDLE  hFont;             /* Font for the combo box */
    LONG    styleSave;         /* Temp to save the style bits when creating
                                * window.  Needed because we strip off some
                                * bits and pass them on to the listbox or
                                * edit box.
                                */
} CBOX, * KPTR_MODIFIER PCBOX;

typedef struct tagCOMBOWND {
    WND wnd;
    PCBOX pcbox;
} COMBOWND, * KPTR_MODIFIER PCOMBOWND;

/*
 * List Box
 */
typedef struct _SCROLLPOS {
    INT cItems;
    UINT iPage;
    INT iPos;
    UINT fMask;
    INT iReturn;
} SCROLLPOS, *PSCROLLPOS;

typedef struct tagLBIV {
    PWND    spwndParent;    /* parent window */
    PWND    spwnd;          /* lbox ctl window */
    INT     iTop;           /* index of top item displayed          */
    INT     iSel;           /* index of current item selected       */
    INT     iSelBase;       /* base sel for multiple selections     */
    INT     cItemFullMax;   /* cnt of Fully Visible items. Always contains
                               result of CItemInWindow(plb, FALSE) for fixed
                               height listboxes. Contains 1 for var height
                               listboxes. */
    INT     cMac;           /* cnt of items in listbox              */
    INT     cMax;           /* cnt of total # items allocated for rgpch.
                               Not all are necessarly in use    */
    KPBYTE  rgpch;          /* pointer to array of string offsets    */
    KLPWSTR hStrings;       /* string storage handle                */
    INT     cchStrings;     /* Size in bytes of hStrings            */
    INT     ichAlloc;       /* Pointer to end of hStrings (end of last valid
                               string) */
    INT     cxChar;         /* Width of a character                 */
    INT     cyChar;         /* height of line                       */
    INT     cxColumn;       /* width of a column in multicolumn listboxes */
    INT     itemsPerColumn; /* for multicolumn listboxes */
    INT     numberOfColumns; /* for multicolumn listboxes */
    POINT   ptPrev;         /* coord of last tracked mouse pt. used for auto
                               scrolling the listbox during timer's */

    UINT    OwnerDraw:2;    /* Owner draw styles. Non-zero if ownerdraw. */
    UINT    fRedraw:1;      /* if TRUE then do repaints             */
    UINT    fDeferUpdate:1; /* */
    UINT    wMultiple:2;    /* SINGLESEL allows a single item to be selected.
                             * MULTIPLESEL allows simple toggle multi-selection
                             * EXTENDEDSEL allows extended multi selection;
                             */

    UINT     fSort:1;        /* if TRUE the sort list                */
    UINT     fNotify:1;      /* if TRUE then Notify parent           */
    UINT     fMouseDown:1;   /* if TRUE then process mouse moves/mouseup */
    UINT     fCaptured:1;    /* if TRUE then process mouse messages  */
    UINT     fCaret:1;       /* flashing caret allowed               */
    UINT     fDoubleClick:1; /* mouse down in double click           */
    UINT     fCaretOn:1;     /* if TRUE then caret is on             */
    UINT     fAddSelMode:1;  /* if TRUE, then it is in ADD selection mode */
    UINT     fHasStrings:1;  /* True if the listbox has a string associated
                              * with each item else it has an app suppled LONG
                              * value and is ownerdraw
                              */
    UINT     fHasData:1;    /* if FALSE, then lb doesn't keep any line data
                             * beyond selection state, but instead calls back
                             * to the client for each line's definition.
                             * Forces OwnerDraw==OWNERDRAWFIXED, !fSort,
                             * and !fHasStrings.
                             */
    UINT     fNewItemState:1; /* select/deselect mode? for multiselection lb
                              */
    UINT     fUseTabStops:1; /* True if the non-ownerdraw listbox should handle
                             * tabstops
                             */
    UINT     fMultiColumn:1; /* True if this is a multicolumn listbox */
    UINT     fNoIntegralHeight:1; /* True if we don't want to size the listbox
                                  * an integral lineheight
                                  */
    UINT     fWantKeyboardInput:1; /* True if we should pass on WM_KEY & CHAR
                                   * so that the app can go to special items
                                   * with them.
                                   */
    UINT     fDisableNoScroll:1;   /* True if the listbox should
                                    * automatically Enable/disable
                                    * it's scroll bars. If false, the scroll
                                    * bars will be hidden/Shown automatically
                                    * if they are present.
                                    */
    UINT    fHorzBar:1; // TRUE if WS_HSCROLL specified at create time

    UINT    fVertBar:1; // TRUE if WS_VSCROLL specified at create time
    UINT    fFromInsert:1;  // TRUE if client drawing should be deferred during delete/insert ops
    UINT    fNoSel:1;

    UINT    fHorzInitialized : 1;   // Horz scroll cache initialized
    UINT    fVertInitialized : 1;   // Vert scroll cache initialized

    UINT    fSized : 1;             // Listbox was resized.
    UINT    fIgnoreSizeMsg : 1;     // If TRUE, ignore WM_SIZE message

    UINT    fInitialized : 1;

    UINT    fRightAlign:1;     // used primarily for MidEast right align
    UINT    fRtoLReading:1;    // used only for MidEast, text rtol reading order
    UINT    fSmoothScroll:1;   // allow just one smooth-scroll per scroll cycle

    int     xRightOrigin;      // For horizontal scrolling. The current x origin

    INT     iLastSelection; /* Used for cancelable selection. Last selection
                             * in listbox for combo box support
                             */
    INT     iMouseDown;     /* For multiselection mouse click & drag extended
                             * selection. It is the ANCHOR point for range
                             * selections
                             */
    INT     iLastMouseMove; /* selection of listbox items */
    KPINT   iTabPixelPositions; /* List of positions for tabs */
    KHANDLE hFont;          /* User settable font for listboxes */
    int     xOrigin;        /* For horizontal scrolling. The current x origin */
    int     maxWidth;       /* Maximum width of listbox in pixels for
                               horizontal scrolling purposes */
    PCBOX   pcbox;          /* Combo box pointer */
    HDC     hdc;            /* hdc currently in use */
    DWORD   dwLocaleId;     /* Locale used for sorting strings in list box */
    int     iTypeSearch;
    KLPWSTR pszTypeSearch;
    SCROLLPOS HPos;
    SCROLLPOS VPos;
} LBIV, *PLBIV;

typedef struct tagLBWND {
    WND wnd;
    PLBIV pLBIV;
} LBWND, * KPTR_MODIFIER PLBWND;

/*
 * Kernel side input context structure.
 */
typedef struct tagIMC {    /* hImc */
    THRDESKHEAD                     head;
    struct tagIMC* KPTR_MODIFIER    pImcNext;
    KERNEL_ULONG_PTR                dwClientImcData;    // Client side data
    KHWND                           hImeWnd;            // in use Ime Window
} IMC, * KPTR_MODIFIER PIMC;


/*
 * Hook structure.
 */
#undef HOOKBATCH
typedef struct tagHOOK {   /* hk */
    THRDESKHEAD     head;
    PHOOK           phkNext;
    int             iHook;              // WH_xxx hook type
    KERNEL_ULONG_PTR offPfn;
    UINT            flags;              // HF_xxx flags
    int             ihmod;
    PTHREADINFO     ptiHooked;          // Thread hooked.
    PDESKTOP        rpdesk;             // Global hook pdesk. Only used when
                                        //  hook is locked and owner is destroyed

    BOOL            fLastHookHung : 1;  // for LL hook only

#ifdef HOOKBATCH
    DWORD           cEventMessages;     // Number of events in the cache
    DWORD           iCurrentEvent;      // Current cache event
    DWORD           CacheTimeOut;       // Timeout between keys
    PEVENTMSG       aEventCache;        // The array of Events
#endif // HOOKBATCH
} HOOK;

/*
 * Hook defines.
 */
#define HF_GLOBAL          0x0001
#define HF_ANSI            0x0002
#define HF_NEEDHC_SKIP     0x0004
#define HF_HUNG            0x0008      // Hook Proc hung don't call if system
#define HF_HOOKFAULTED     0x0010      // Hook Proc faulted
#define HF_NOPLAYBACKDELAY 0x0020      // Ignore requested delay
#define HF_DESTROYED       0x0080      // Set by FreeHook
#if DBG
#define HF_INCHECKWHF      0x0100      // fsHooks is being updated
#define HF_FREED           0x0200      // Object has been freed.
#define HF_DBGUSED         0x03FF      // Update if adding a flag
#endif

/*
 * Macro to convert the WH_* index into a bit position for
 * the fsHooks fields of SERVERINFO and THREADINFO.
 */
#define WHF_FROM_WH(n)     (1 << (n + 1))

/*
 * Flags for IsHooked().
 */
#define WHF_MSGFILTER       WHF_FROM_WH(WH_MSGFILTER)
#define WHF_JOURNALRECORD   WHF_FROM_WH(WH_JOURNALRECORD)
#define WHF_JOURNALPLAYBACK WHF_FROM_WH(WH_JOURNALPLAYBACK)
#define WHF_KEYBOARD        WHF_FROM_WH(WH_KEYBOARD)
#define WHF_GETMESSAGE      WHF_FROM_WH(WH_GETMESSAGE)
#define WHF_CALLWNDPROC     WHF_FROM_WH(WH_CALLWNDPROC)
#define WHF_CALLWNDPROCRET  WHF_FROM_WH(WH_CALLWNDPROCRET)
#define WHF_CBT             WHF_FROM_WH(WH_CBT)
#define WHF_SYSMSGFILTER    WHF_FROM_WH(WH_SYSMSGFILTER)
#define WHF_MOUSE           WHF_FROM_WH(WH_MOUSE)
#define WHF_HARDWARE        WHF_FROM_WH(WH_HARDWARE)
#define WHF_DEBUG           WHF_FROM_WH(WH_DEBUG)
#define WHF_SHELL           WHF_FROM_WH(WH_SHELL)
#define WHF_FOREGROUNDIDLE  WHF_FROM_WH(WH_FOREGROUNDIDLE)

/*
 * Windowstation and desktop enum list structure.
 */
typedef struct tagNAMELIST {
    DWORD cb;
    DWORD cNames;
    WCHAR awchNames[1];
} NAMELIST, *PNAMELIST;

#define MONF_VISIBLE         0x01   // monitor is visible on desktop
#define MONF_PALETTEDISPLAY  0x02   // monitor has palette

#ifndef _USERSRV_

#ifdef SUBPIXEL_MOUSE
typedef LONG64 FIXPOINT;

/*
 * Number of points in the arrays describing the acceleration curves.
 */
#define SM_POINT_CNT 5

#endif // SUBPIXEL_MOUSE

/*
 * Monitor information structure.
 *
 *     This structure defines the attributes of a single monitor
 *     in a virtual display.
 */
typedef struct tagMONITOR {
    HEAD                        head;            // object handle stuff

    PMONITOR                    pMonitorNext;    // next monitor in free or used list
    DWORD                       dwMONFlags;      // flags
    RECT                        rcMonitor;       // location of monitor in virtual screen coordinates
    RECT                        rcWork;          // work area of monitor in virtual screen coordinates
    KHRGN                       hrgnMonitor;     // monitor region in virtual screen coordinates
    short                       cFullScreen;     // number of fullscreen apps on this monitor
    short                       cWndStack;       // number of tiled top-level windows
    KHANDLE                     hDev;            // hdev associated with this monitor

#ifdef SUBPIXEL_MOUSE
    FIXPOINT                    xTxf[SM_POINT_CNT], yTxf[SM_POINT_CNT];
    /*
     * SM_POINT_CNT - 1 because you need two points for one slope/yint value.
     */
    FIXPOINT                    slope[SM_POINT_CNT - 1], yint[SM_POINT_CNT - 1];
#endif // SUBPIXEL_MOUSE
} MONITOR;
#endif

/*
 * Display Information Structure.
 *
 *   This structure defines the display attributes for the
 *   desktop.  This is usually maintained in the DESKTOP
 *   structure. The current display in use is pointed to
 *   by gpDispInfo.
 *
 *   CONSIDER: How many of these fields need to be actually kept
 *   in a DISPLAYINFO that is not in use, rather than just be put
 *   in gpsi or a kernel-side global?
 */
#ifndef _USERSRV_

typedef struct tagDISPLAYINFO {
    // device stuff
    KHANDLE       hDev;
    KERNEL_PVOID  pmdev;
    KHANDLE       hDevInfo;

    // useful dcs
    KHDC          hdcScreen;        // Device-Context for screen
    KHDC          hdcBits;          // Holds system-bitmap resource

    // Graystring resources
    KHDC          hdcGray;          // GrayString DC.
    KHBITMAP      hbmGray;          // GrayString Bitmap Surface.
    int           cxGray;           // width of gray bitmap
    int           cyGray;           // height of gray bitmap

    // random stuff
    PDCE          pdceFirst;       // list of dcs
    PSPB          pspbFirst;       // list of spbs

    // Monitors on this device
    ULONG         cMonitors;        // number of MONF_VISIBLE monitors attached to desktop
    PMONITOR      pMonitorPrimary;  // the primary monitor (display)
    PMONITOR      pMonitorFirst;    // monitor in use list

    // device characteristics
    RECT          rcScreen;         // Rectangle of entire desktop surface
    KHRGN         hrgnScreen;       // region describing virtual screen
    WORD          dmLogPixels;      // pixels per inch
    WORD          BitCountMax;      // Maximum bitcount across all monitors

    BOOL          fDesktopIsRect:1;   // Is the desktop a simple rectangle?
    BOOL          fAnyPalette:1;      // Are any of the monitors paletized?

    // NOTE: if you need more flags, make fDesktopIsRect a flags field instead.

} DISPLAYINFO;

/*
 * Multimonitor function in rtl\mmrtl.c
 */
PMONITOR _MonitorFromPoint(POINT pt, DWORD dwFlags);
PMONITOR _MonitorFromRect(LPCRECT lprc, DWORD dwFlags);
PMONITOR _MonitorFromWindow(PWND pwnd, DWORD dwFlags);
#endif

#define HDCBITS() gpDispInfo->hdcBits

#define DTF_NEEDSPALETTECHANGED      0x00000001
#define DTF_NEEDSREDRAW              0x00000002

#define CWINHOOKS       (WH_MAX - WH_MIN + 1)

/*
 * VWPL - Volatile Window Pointer List (see rare.c)
 * VPWLs are manipulate with the functions:
 *    VWPLAdd(), VWPLRemove() and VWPLNext()
 */
typedef struct {
    DWORD       cPwnd;       // number of pwnds in apwnd[]
    DWORD       cElem;       // number of elements in apwnd[]
    DWORD       cThreshhold; // (re)allocation increment/decrement
    PWND        aPwnd[0];    // array of pwnds
} VWPL, * KPTR_MODIFIER PVWPL;

/*
 * Desktop Information Structure.
 *
 *   This structure contains information regading the
 *   desktop.  This is viewable from both the client and
 *   kernel processes.
 */
typedef struct tagDESKTOPINFO {

    KERNEL_PVOID  pvDesktopBase;          // For handle validation
    KERNEL_PVOID  pvDesktopLimit;         // ???
    PWND          spwnd;                 // Desktop window
    DWORD         fsHooks;                // Deskop global hooks
    PHOOK         aphkStart[CWINHOOKS];  // List of hooks
    PWND          spwndShell;            // Shell window
    PPROCESSINFO  ppiShellProcess;        // Shell Process
    PWND          spwndBkGnd;            // Shell background window
    PWND          spwndTaskman;          // Task-Manager window
    PWND          spwndProgman;          // Program-Manager window
    PVWPL         pvwplShellHook;         // see (De)RegisterShellHookWindow
    int           cntMBox;                // ???
} DESKTOPINFO;


#define CURSOR_ALWAYSDESTROY    0
#define CURSOR_CALLFROMCLIENT   1
#define CURSOR_THREADCLEANUP    2

typedef struct tagCURSOR_ACON {
    PROCMARKHEAD    head;
    PCURSOR         pcurNext;
    UNICODE_STRING   strName;
    ATOM             atomModName;
    WORD             rt;
} CURSOR_ACON;

typedef struct CURSOR_COMMON {
    CURSINFO;                          // CURSINFO includes the flags

    DWORD            bpp;
    DWORD            cx;
    DWORD            cy;
} CURSOR_COMMON;

typedef struct ACON_COMMON {
    int            cpcur;              // Count of image frames
    int            cicur;              // Count of steps in animation sequence
    PCURSOR * KPTR_MODIFIER aspcur;    // Array of image frame pointers
    DWORD * KPTR_MODIFIER aicur;       // Array of frame indices (seq-table)
    JIF * KPTR_MODIFIER ajifRate;      // Array of time offsets
    int            iicur;              // Current step in animation
} ACON_COMMON;

typedef struct tagCURSOR {
    CURSOR_ACON;                       // common cursor/acon elements -
                                       // See SetSystemImage()
    CURSOR_COMMON;
} CURSOR;

typedef struct tagACON {               // acon
    CURSOR_ACON;                       // common cursor/acon elements -
                                       // See SetSystemImage()
    /*
     * CURSORF_flags must be the first element to follow CURSOR_ACON. This
     * way all members up to and including CURSORF_flags are the same in
     * tagCURSOR and tagACON which is needed for SetSystemImage. See more
     * comments for CI_FIRST in wingdi.w.
     */
    DWORD CURSORF_flags;               // same as CI_FIRST in CURSINFO

    ACON_COMMON;
} ACON, *PACON;

#define PICON PCURSOR

typedef struct tagCURSORDATA {
    KLPWSTR  lpName;
    KLPWSTR  lpModName;
    WORD    rt;
    WORD    dummy;

    CURSOR_COMMON;

    ACON_COMMON;
} CURSORDATA, *PCURSORDATA;


typedef struct tagCURSORFIND {

    KHCURSOR hcur;
    DWORD   rt;
    DWORD   cx;
    DWORD   cy;
    DWORD   bpp;

} CURSORFIND, *PCURSORFIND;

#define MSGFLAG_MASK                0xFFFE0000
#define MSGFLAG_WOW_RESERVED        0x00010000      // Used by WOW
#define MSGFLAG_DDE_MID_THUNK       0x80000000      // DDE tracking thunk
#define MSGFLAG_DDE_SPECIAL_SEND    0x40000000      // WOW bad DDE app hack
#define MSGFLAG_SPECIAL_THUNK       0x10000000      // server->client thunk needs special handling

#define WIDTHBYTES(i) \
    ((((i) + 31) & ~31) >> 3)

#define BITMAPWIDTHSIZE(cx, cy, planes, bpp) \
    (WIDTHBYTES((cx * bpp)) * (cy) * (planes))

/*
 * Window Style and State Masks -
 *
 * High byte of word is byte index from the start of the state field
 * in the WND structure, low byte is the mask to use on the byte.
 * These masks assume the order of the state and style fields of a
 * window instance structure.
 *
 * This is how the Test/Set/Clr/MaskWF value ranges map to the corresponding
 * fields in the window structure.
 *
 *   offset                 WND field
 *   0 - 3                  state        - private
 *   4 - 7                  state2       - private
 *   8 - B                  ExStyle      - public, exposed in SetWindowLong(GWL_EXSTYLE)
 *   C - F                  style        - public, exposed in SetWindowLong(GWL_STYLE)
 *                                         C-D are reserved for window class designer.
 *                                         E-F are reserved for WS_ styles.
 *
 * NOTE: Be sure to add the flag to the wFlags array in kd\userexts.c!!!
 */

/*
 * State flags, from 0x0000 to 0x0780.
 */

/*
 * DON'T MOVE ANY ONE OF THE FOLLOWING WFXPRESENT FLAGS,
 * BECAUSE WFFRAMEPRESENTMASK DEPENDS ON THEIR VALUES
 */
#define WFMPRESENT              0x0001
#define WFVPRESENT              0x0002
#define WFHPRESENT              0x0004
#define WFCPRESENT              0x0008
#define WFFRAMEPRESENTMASK      0x000F

#define WFSENDSIZEMOVE          0x0010
#define WFMSGBOX                0x0020  // used to maintain count of msg boxes on screen
#define WFFRAMEON               0x0040
#define WFHASSPB                0x0080
#define WFNONCPAINT             0x0101
#define WFSENDERASEBKGND        0x0102
#define WFERASEBKGND            0x0104
#define WFSENDNCPAINT           0x0108
#define WFINTERNALPAINT         0x0110
#define WFUPDATEDIRTY           0x0120
#define WFHIDDENPOPUP           0x0140
#define WFMENUDRAW              0x0180

/*
 * NOTE -- WFDIALOGWINDOW is used in WOW.  DO NOT CHANGE without
 *   changing WD_DIALOG_WINDOW in winuser.w
 */
#define WFDIALOGWINDOW          0x0201

#define WFTITLESET              0x0202
#define WFSERVERSIDEPROC        0x0204
#define WFANSIPROC              0x0208
#define WFBEINGACTIVATED        0x0210  // prevent recursion in xxxActivateThis Window
#define WFHASPALETTE            0x0220
#define WFPAINTNOTPROCESSED     0x0240  // WM_PAINT message not processed
#define WFSYNCPAINTPENDING      0x0280
#define WFGOTQUERYSUSPENDMSG    0x0301
#define WFGOTSUSPENDMSG         0x0302
#define WFTOGGLETOPMOST         0x0304  // Toggle the WS_EX_TOPMOST bit ChangeStates

/*
 * DON'T MOVE REDRAWIFHUNGFLAGS WITHOUT ADJUSTING WFANYHUNGREDRAW
 */
#define WFREDRAWIFHUNG          0x0308
#define WFREDRAWFRAMEIFHUNG     0x0310
#define WFANYHUNGREDRAW         0x0318

#define WFANSICREATOR           0x0320
#define WFREALLYMAXIMIZABLE     0x0340  // The window fills the work area or monitor when maximized
#define WFDESTROYED             0x0380
#define WFWMPAINTSENT           0x0401
#define WFDONTVALIDATE          0x0402
#define WFSTARTPAINT            0x0404
#define WFOLDUI                 0x0408
#define WFCEPRESENT             0x0410  // Client edge present
#define WFBOTTOMMOST            0x0420  // Bottommost window
#define WFFULLSCREEN            0x0440
#define WFINDESTROY             0x0480

/*
 * DON'T MOVE ANY ONE OF THE FOLLOWING WFWINXXCOMPAT FLAGS,
 * BECAUSE WFWINCOMPATMASK DEPENDS ON THEIR VALUES
 */
#define WFWIN31COMPAT           0x0501  // Win 3.1 compatible window
#define WFWIN40COMPAT           0x0502  // Win 4.0 compatible window
#define WFWIN50COMPAT           0x0504  // Win 5.0 compatibile window
#define WFWINCOMPATMASK         0x0507  // Compatibility flag mask

#define WFMAXFAKEREGIONAL       0x0508  // Window has a fake region for maxing on 1 monitor

// Active Accessibility (Window Event) state
#define WFCLOSEBUTTONDOWN       0x0510
#define WFZOOMBUTTONDOWN        0x0520
#define WFREDUCEBUTTONDOWN      0x0540
#define WFHELPBUTTONDOWN        0x0580
#define WFLINEUPBUTTONDOWN      0x0601  // Line up/left scroll button down
#define WFPAGEUPBUTTONDOWN      0x0602  // Page up/left scroll area down
#define WFPAGEDNBUTTONDOWN      0x0604  // Page down/right scroll area down
#define WFLINEDNBUTTONDOWN      0x0608  // Line down/right scroll area down
#define WFSCROLLBUTTONDOWN      0x0610  // Any scroll button down?
#define WFVERTSCROLLTRACK       0x0620  // Vertical or horizontal scroll track...

#define WFALWAYSSENDNCPAINT     0x0640  // Always send WM_NCPAINT to children
#define WFPIXIEHACK             0x0680  // Send (HRGN)1 to WM_NCPAINT (see PixieHack)

/*
 * WFFULLSCREENBASE MUST HAVE LOWORD OF 0. See SetFullScreen macro.
 */
#define WFFULLSCREENBASE        0x0700  // Fullscreen flags take up 0x0701
#define WFFULLSCREENMASK        0x0707  // and 0x0702 and 0x0704
#define WEFTRUNCATEDCAPTION     0x0708  // The caption text was truncated -> caption tootip

#define WFNOANIMATE             0x0710  // ???
#define WFSMQUERYDRAGICON       0x0720  // ??? Small icon comes from WM_QUERYDRAGICON
#define WFSHELLHOOKWND          0x0740  // ???
#define WFISINITIALIZED         0x0780  // Window is initialized -- checked by WoW32

/*
 * Add more state flags here, up to 0x0780.
 * Look for empty slots above before adding to the end.
 * Be sure to add the flag to the wFlags array in kd\userexts.c
 */

/*
 * Window Extended Style, from 0x0800 to 0x0B80.
 */
#define WEFDLGMODALFRAME        0x0801  // WS_EX_DLGMODALFRAME
#define WEFDRAGOBJECT           0x0802  // ???
#define WEFNOPARENTNOTIFY       0x0804  // WS_EX_NOPARENTNOTIFY
#define WEFTOPMOST              0x0808  // WS_EX_TOPMOST
#define WEFACCEPTFILES          0x0810  // WS_EX_ACCEPTFILES
#define WEFTRANSPARENT          0x0820  // WS_EX_TRANSPARENT
#define WEFMDICHILD             0x0840  // WS_EX_MDICHILD
#define WEFTOOLWINDOW           0x0880  // WS_EX_TOOLWINDOW
#define WEFWINDOWEDGE           0x0901  // WS_EX_WINDOWEDGE
#define WEFCLIENTEDGE           0x0902  // WS_EX_CLIENTEDGE
#define WEFEDGEMASK             0x0903  // WS_EX_WINDOWEDGE | WS_EX_CLIENTEDGE
#define WEFCONTEXTHELP          0x0904  // WS_EX_CONTEXTHELP
#define WEFGHOSTMAKEVISIBLE     0x0908  // WS_EXP_GHOSTMAKEVISIBLE


// intl styles
#define WEFRIGHT                0x0910  // WS_EX_RIGHT
#define WEFRTLREADING           0x0920  // WS_EX_RTLREADING
#define WEFLEFTSCROLL           0x0940  // WS_EX_LEFTSCROLLBAR


#define WEFCONTROLPARENT        0x0A01  // WS_EX_CONTROLPARENT
#define WEFSTATICEDGE           0x0A02  // WS_EX_STATICEDGE
#define WEFAPPWINDOW            0x0A04  // WS_EX_APPWINDOW
#define WEFLAYERED              0x0A08  // WS_EX_LAYERED

#define WEFNOINHERITLAYOUT      0x0A10  // WS_EX_NOINHERITLAYOUT
#define WEFLAYOUTVBHRESERVED    0x0A20  // WS_EX_LAYOUTVBHRESERVED
#define WEFLAYOUTRTL            0x0A40  // WS_EX_LAYOUTRTL
#define WEFLAYOUTBTTRESERVED    0x0A80  // WS_EX_LAYOUTBTTRESERVED

/*
 * To delay adding a new state3 DWORD in the WW structure, we're using
 * the extended style bits for now.  If we'll need more of these, we'll
 * add the new DWORD and move these ones around
 */
#define WEFPUIFOCUSHIDDEN         0x0B80  // focus indicators hidden
#define WEFPUIACCELHIDDEN         0x0B40  // keyboard acceleraors hidden
#define WEFPREDIRECTED            0x0B20  // redirection bit
#define WEFPCOMPOSITING           0x0B10  // compositing


/*
 * Add more Window Extended Style flags here, up to 0x0B80.
 * Be sure to add the flag to the wFlags array in kd\userexts.c
 */
#ifdef REDIRECTION
#define WEFEXTREDIRECTED        0x0B01   // WS_EX_EXTREDIRECTED
#endif // REDIRECTION

#define WEFCOMPOSITED           0x0B02   // WS_EX_COMPOSITED
#define WEFPUIACTIVE            0x0B04   // WS_EXP_UIACTIVE
#define WEFNOACTIVATE           0x0B08   // WS_EX_NOACTIVATE

#ifdef LAME_BUTTON
#define WEFLAMEBUTTON           0x0980   // the window should display a lame button
#endif // LAME_BUTTON

/*
 * Window styles, from 0x0E00 to 0x0F80.
 */
#define WFMAXBOX                0x0E01  // WS_MAXIMIZEBOX
#define WFTABSTOP               0x0E01  // WS_TABSTOP
#define WFMINBOX                0x0E02  // WS_MAXIMIZEBOX
#define WFGROUP                 0x0E02  // WS_GROUP
#define WFSIZEBOX               0x0E04  // WS_THICKFRAME, WS_SIZEBOX
#define WFSYSMENU               0x0E08  // WS_SYSMENU
#define WFHSCROLL               0x0E10  // WS_HSCROLL
#define WFVSCROLL               0x0E20  // WS_VSCROLL
#define WFDLGFRAME              0x0E40  // WS_DLGFRAME
#define WFTOPLEVEL              0x0E40  // ???
#define WFBORDER                0x0E80  // WS_BORDER
#define WFBORDERMASK            0x0EC0  // WS_BORDER | WS_DLGFRAME
#define WFCAPTION               0x0EC0  // WS_CAPTION

#define WFTILED                 0x0F00  // WS_OVERLAPPED, WS_TILED
#define WFMAXIMIZED             0x0F01  // WS_MAXIMIZE
#define WFCLIPCHILDREN          0x0F02  // WS_CLIPCHILDREN
#define WFCLIPSIBLINGS          0x0F04  // WS_CLIPSIBLINGS
#define WFDISABLED              0x0F08  // WS_DISABLED
#define WFVISIBLE               0x0F10  // WS_VISIBLE
#define WFMINIMIZED             0x0F20  // WS_MINIMIZE
#define WFCHILD                 0x0F40  // WS_CHILD
#define WFPOPUP                 0x0F80  // WS_POPUP
#define WFTYPEMASK              0x0FC0  // WS_CHILD | WS_POPUP
#define WFICONICPOPUP           0x0FC0  // WS_CHILD | WS_POPUP
#define WFICONIC                WFMINIMIZED
/*
 * No more Window style flags are available, use Extended window styles.
 */

/*
 * Window Styles for built-in classes, from 0x0C00 to 0x0D80.
 */

// Buttons
#define BFTYPEMASK              0x0C0F

#define BFRIGHTBUTTON           0x0C20
#define BFICON                  0x0C40
#define BFBITMAP                0x0C80
#define BFIMAGEMASK             0x0CC0

#define BFLEFT                  0x0D01
#define BFRIGHT                 0x0D02
#define BFCENTER                0x0D03
#define BFHORZMASK              0x0D03
#define BFTOP                   0x0D04
#define BFBOTTOM                0x0D08
#define BFVCENTER               0x0D0C
#define BFVERTMASK              0x0D0C
#define BFALIGNMASK             0x0D0F

#define BFPUSHLIKE              0x0D10
#define BFMULTILINE             0x0D20
#define BFNOTIFY                0x0D40
#define BFFLAT                  0x0D80

#define ISBSTEXTOROD(pwnd) (!TestWF(pwnd, BFBITMAP) && !TestWF(pwnd, BFICON))

// Combos
#define CBFSIMPLE               0x0C01
#define CBFDROPDOWN             0x0C02
#define CBFDROPDOWNLIST         0x0C03

#define CBFEDITABLE             0x0C01
#define CBFDROPPABLE            0x0C02
#define CBFDROPTYPE             0x0C03

#define CBFOWNERDRAWFIXED       0x0C10
#define CBFOWNERDRAWVAR         0x0C20
#define CBFOWNERDRAW            0x0C30

#define CBFAUTOHSCROLL          0x0C40
#define CBFOEMCONVERT           0x0C80
#define CBFSORT                 0x0D01
#define CBFHASSTRINGS           0x0D02
#define CBFNOINTEGRALHEIGHT     0x0D04
#define CBFDISABLENOSCROLL      0x0D08
#define CBFBUTTONUPTRACK        0x0D10

#define CBFUPPERCASE            0x0D20
#define CBFLOWERCASE            0x0D40

// Dialogs
#define DFSYSMODAL              0x0C02
#define DF3DLOOK                0x0C04
#define DFNOFAILCREATE          0x0C10
#define DFLOCALEDIT             0x0C20
#define WFNOIDLEMSG             0x0D01
#define DFCONTROL               0x0D04

// Edits
#define EFMULTILINE             0x0C04
#define EFUPPERCASE             0x0C08
#define EFLOWERCASE             0x0C10
#define EFPASSWORD              0x0C20
#define EFAUTOVSCROLL           0x0C40
#define EFAUTOHSCROLL           0x0C80
#define EFNOHIDESEL             0x0D01
#define EFCOMBOBOX              0x0D02
#define EFOEMCONVERT            0x0D04
#define EFREADONLY              0x0D08
#define EFWANTRETURN            0x0D10
#define EFNUMBER                0x0D20

// Scrollbars
#define SBFSIZEBOXTOPLEFT       0x0C02
#define SBFSIZEBOXBOTTOMRIGHT   0x0C04
#define SBFSIZEBOX              0x0C08
#define SBFSIZEGRIP             0x0C10

// Statics
#define SFTYPEMASK              0x0C1F
#define SFREALSIZECONTROL       0x0C40
#define SFNOPREFIX              0x0C80
#define SFNOTIFY                0x0D01
#define SFCENTERIMAGE           0x0D02
#define SFRIGHTJUST             0x0D04
#define SFREALSIZEIMAGE         0x0D08
#define SFSUNKEN                0x0D10
#define SFEDITCONTROL           0x0D20
#define SFELLIPSISMASK          0x0DC0
#define SFWIDELINESPACING       0x0C20


/*
 *
 */
#define SYS_ALTERNATE           0x2000
#define SYS_PREVKEYSTATE        0x4000

/*** AWESOME HACK ALERT!!!
 *
 * The low byte of the WF?PRESENT state flags must NOT be the
 * same as the low byte of the WFBORDER and WFCAPTION flags,
 * since these are used as paint hint masks.  The masks are calculated
 * with the MaskWF macro below.
 *
 * The magnitude of this hack compares favorably with that of the national debt.
 *
 * STATEOFFSET is the offset into the WND structure of the state field.
 * The state field is actually part of the WW structure defined in wowuserp.h
 * which is embedded in the WND structure.
 */
#define STATEOFFSET (FIELD_OFFSET(WND, state))

#define TestWF(hwnd, flag)   (*(((KPBYTE)(hwnd)) + STATEOFFSET + (int)HIBYTE(flag)) & LOBYTE(flag))
#define SetWF(hwnd, flag)    (*(((KPBYTE)(hwnd)) + STATEOFFSET + (int)HIBYTE(flag)) |= LOBYTE(flag))
#define ClrWF(hwnd, flag)    (*(((KPBYTE)(hwnd)) + STATEOFFSET + (int)HIBYTE(flag)) &= ~LOBYTE(flag))
#define MaskWF(flag)         ((WORD)( (HIBYTE(flag) & 1) ? LOBYTE(flag) << 8 : LOBYTE(flag)))


#define TestwndChild(hwnd)   (TestWF(hwnd, WFTYPEMASK) == LOBYTE(WFCHILD))
#define TestwndIPopup(hwnd)  (TestWF(hwnd, WFTYPEMASK) == LOBYTE(WFICONICPOPUP))
#define TestwndTiled(hwnd)   (TestWF(hwnd, WFTYPEMASK) == LOBYTE(WFTILED))
#define TestwndNIPopup(hwnd) (TestWF(hwnd, WFTYPEMASK) == LOBYTE(WFPOPUP))
#define TestwndPopup(hwnd)   (TestwndNIPopup(hwnd) || TestwndIPopup(hwnd))
#define TestwndHI(hwnd)      (TestwndTiled(hwnd) || TestwndIPopup(hwnd))

#define GetChildParent(pwnd) (TestwndChild(pwnd) ? pwnd->spwndParent : (PWND)NULL)
#define GetWindowCreator(pwnd) (TestwndChild(pwnd) ? pwnd->spwndParent : pwnd->spwndOwner)

#define TestwndFrameOn(pwnd) (TestWF(pwnd, WFFRAMEON) && (GETPTI(pwnd)->pq == gpqForeground))

#define GetFullScreen(pwnd)        (TestWF(pwnd, WFFULLSCREENMASK))
#define SetFullScreen(pwnd, state) (ClrWF(pwnd, WFFULLSCREENMASK), \
                                    SetWF(pwnd, WFFULLSCREENBASE | (state & WFFULLSCREENMASK)))

//#define FTrueVis(pwnd)       (pwnd->fs & WF_TRUEVIS)
#define FTrueVis(pwnd)       (_IsWindowVisible(pwnd))
#define _IsWindowEnabled(pwnd) (TestWF(pwnd, WFDISABLED)  == 0)
#define _IsIconic(pwnd)        (TestWF(pwnd, WFMINIMIZED) != 0)
#define _IsZoomed(pwnd)        (TestWF(pwnd, WFMAXIMIZED) != 0)

WORD VersionFromWindowFlag(PWND pwnd);

#define SV_UNSET        0x0000
#define SV_SET          0x0001
#define SV_CLRFTRUEVIS  0x0002

/*
 * System menu IDs
 */
#define ID_SYSMENU              0x10
#define ID_CLOSEMENU            0x20
#define CHILDSYSMENU            ID_CLOSEMENU
#define ID_DIALOGSYSMENU        0x30
#define ID_HSCROLLMENU          0x40
#define ID_VSCROLLMENU          0x50

/*
 * Menu Item Structure
 */
typedef struct tagITEM {
    UINT                fType;          // Item Type  Flags
    UINT                fState;         // Item State Flags
    UINT                wID;
    PMENU               spSubMenu;      /* Handle to a popup */
    KHANDLE             hbmpChecked;    /* Bitmap for an on  check */
    KHANDLE             hbmpUnchecked;  /* Bitmap for an off check */
    KLPWSTR             lpstr;          //item's text
    DWORD               cch;            /* String: WCHAR count */
    KERNEL_ULONG_PTR    dwItemData;
    DWORD               xItem;
    DWORD               yItem;
    DWORD               cxItem;
    DWORD               cyItem;
    DWORD               dxTab;
    DWORD               ulX;            /* String: Underline start */
    DWORD               ulWidth;        /* String: underline width */
    KHBITMAP            hbmp;           // item's bitmap
    int                 cxBmp;          // bitmap width
    int                 cyBmp;          // bitmap height
} ITEM, * KPTR_MODIFIER PITEM, * KPTR_MODIFIER LPITEM;

/*
 * MENULIST structure, holds the PMENUs that contain a submenu
 * We store a list of menus in MENU.pParentMenus as a menu
 * can be submenu in more items
 */
typedef struct tagMENULIST {
    struct tagMENULIST   *pNext;
    PMENU       pMenu;
} MENULIST, * KPTR_MODIFIER PMENULIST;

/*
 * Scroll menu arrow flags
 */
#define MSA_OFF         0
#define MSA_ON          1
#define MSA_ATTOP       2
#define MSA_ATBOTTOM    3

/*
 * Menu Structure
 */
typedef struct tagMENU {
    PROCDESKHEAD    head;
    DWORD           fFlags;         /* Menu Flags */
    int             iItem;          /* Contains the position of the selected
                                       item in the menu. -1 if no selection */
    UINT            cAlloced;       // Number of items that can fit in rgItems
    UINT            cItems;         /* Number of items in rgItems */

    DWORD           cxMenu;
    DWORD           cyMenu;
    DWORD           cxTextAlign;    /* Text align offset for popups*/
    PWND            spwndNotify;     /* The owner hwnd of this menu */
    PITEM           rgItems;        /* The list of items in this menu */
    PMENULIST       pParentMenus;   // The list of parents (menus that have this as submenu)
    DWORD           dwContextHelpId;// Context help Id for the whole menu
    DWORD           cyMax;          /* max menu height after which menu scrolls */
    KERNEL_ULONG_PTR dwMenuData;     /* app-supplied menu data */

    KHBRUSH         hbrBack;        // background brush for menu
    int             iTop;           // Scroll top
    int             iMaxTop;        // Scroll MaxTop
    DWORD           dwArrowsOn:2;   // Scroll flags
} MENU, * KPTR_MODIFIER PMENU;


/*
 *  Items used for WinHelp and Context Sensitive help support
 */

#define ID_HELPMENU            4

// WINHELP4 invoked type
enum {
        TYPE_NORMAL,
        TYPE_POPUP,
        TYPE_TCARD
};

typedef struct tagDLGENUMDATA {
    PWND    pwndDialog;
    PWND    pwndControl;
    POINT   ptCurHelp;
} DLGENUMDATA, *PDLGENUMDATA;

BOOL CALLBACK EnumPwndDlgChildProc(PWND pwnd, LPARAM lParam);
BOOL FIsParentDude(PWND pwnd);


#define MNF_DONTSKIPSEPARATORS      0x0001

/*
 * The following masks can be used along with the wDisableFlags field of SB
 * to find if the Up/Left or Down/Right arrow or Both are disabled;
 * Now it is possible to selectively Enable/Disable just one or both the
 * arrows in a scroll bar control;
 */
#define LTUPFLAG    0x0001  // Left/Up arrow disable flag.
#define RTDNFLAG    0x0002  // Right/Down arrow disable flag.

typedef struct tagSBCALC {
    SBDATA;               /* this must be first -- we cast structure pointers */
    int    pxTop;
    int    pxBottom;
    int    pxLeft;
    int    pxRight;
    int    cpxThumb;
    int    pxUpArrow;
    int    pxDownArrow;
    int    pxStart;         /* Initial position of thumb */
    int    pxThumbBottom;
    int    pxThumbTop;
    int    cpx;
    int    pxMin;
} SBCALC, *PSBCALC;

typedef struct tagSBTRACK {
    DWORD  fHitOld : 1;
    DWORD  fTrackVert : 1;
    DWORD  fCtlSB : 1;
    DWORD  fTrackRecalc: 1;
    PWND   spwndTrack;
    PWND   spwndSB;
    PWND   spwndSBNotify;
    RECT   rcTrack;
    VOID   (*xxxpfnSB)(PWND, UINT, WPARAM, LPARAM, PSBCALC);
    UINT   cmdSB;
    UINT_PTR hTimerSB;
    int    dpxThumb;        /* Offset from mouse point to start of thumb box */
    int    pxOld;           /* Previous position of thumb */
    int    posOld;
    int    posNew;
    int    nBar;
    PSBCALC pSBCalc;
} SBTRACK, *PSBTRACK;

/*
 * How many times a thread can spin through get/peek message without idling
 * before the system puts the app in the background.
 */
#define CSPINBACKGROUND 100

#define CCHTITLEMAX     256

#define SW_MDIRESTORE   0xCC    /* special xxxMinMaximize() command for MDI */

/*
 * This is used by CreateWindow() - the 16 bit version of CW_USEDEFAULT,
 * that we still need to support.
 */
#define CW2_USEDEFAULT          0x8000
#define CW_FLAGS_DIFFHMOD       0x80000000
#define CW_FLAGS_VERSIONCLASS   0x40000000


/*
 * Menu commands
 */
//#define MENUBIT             (0x8000)
//#define MENUUP              (0x8000 | VK_UP)
//#define MENUDOWN            (0x8000 | VK_DOWN)
//#define MENULEFT            (0x8000 | VK_LEFT)
//#define MENURIGHT           (0x8000 | VK_RIGHT)
//#define MENUEXECUTE         TEXT('\r')      /* Return character */
#define MENUSYSMENU         TEXT(' ')       /* Space character */
#define MENUCHILDSYSMENU    TEXT('-')       /* Hyphen */
#define LAMEBUTTONHOTKEY    TEXT('/')       /* Forward slash */

#define MF_ALLSTATE         0x00FF
#define MF_MAINMENU         0xFFFF
#define MFMWFP_OFFMENU      0
#define MFMWFP_MAINMENU     0x0000FFFF
#define MFMWFP_NOITEM       0xFFFFFFFF
#define MFMWFP_UPARROW      0xFFFFFFFD  /* Warning: Also used to define IDSYS_MNUP */
#define MFMWFP_DOWNARROW    0xFFFFFFFC  /* Warning: Also used to define IDSYS_MNDOWN */
#define MFMWFP_MINVALID     0xFFFFFFFC
#define MFMWFP_ALTMENU      0xFFFFFFFB
#define MFMWFP_FIRSTITEM    0


/*
 * NOTE: SetMF() can only be used on single bit flags.
 */
#define SetMF(pmenu, flag)    ((pmenu)->fFlags |=  (flag))
#define ClearMF(pmenu, flag)  ((pmenu)->fFlags &= ~(flag))
#define TestMF(pmenu, flag)   ((pmenu)->fFlags &   (flag))

#define SetMFS(pitem, flag)   ((pitem)->fState |=  (flag))
#define TestMFS(pitem, flag)  ((pitem)->fState &   (flag))
#define ClearMFS(pitem, flag) ((pitem)->fState &= ~(flag))

#define SetMFT(pitem, flag)   ((pitem)->fType |=  (flag))
#define TestMFT(pitem, flag)  ((pitem)->fType &   (flag))
#define ClearMFT(pitem, flag) ((pitem)->fType &= ~(flag))

/*
 * Dialog structure (dlg). The window-words for the dialog structure must
 * be EXACTLY 30 bytes long! This is because Windows 3.0 exported a constant
 * called DLGWINDOWEXTRA that resolved to 30. Although we could redefine this
 * for 32-bit windows apps, we cannot redefine it for 16 bit apps (it is
 * a difficult problem). So instead we peg the window-words at 30 bytes
 * exactly, and allocate storage for the other information.
 */
typedef struct _DLG {
    DLGPROC lpfnDlg;
    DWORD   flags;          /* Various useful flags -- see definitions below */
    int     cxChar;
    int     cyChar;
    KHWND   hwndFocusSave;
    UINT    fEnd      : 1;
    UINT    fDisabled : 1;
    KERNEL_INT_PTR result;         /* DialogBox result */
    KHANDLE  hData;          /* Global handle for edit ctl storage. */
    KHFONT   hUserFont;      /* Handle of the font mentioned by the user in template*/
#ifdef SYSMODALWINDOWS
    KHWND    hwndSysModalSave;  /* Previous sysmodal window saved here */
#endif
} DLG, * KPTR_MODIFIER PDLG;

typedef struct _DIALOG {
    WND             wnd;
    KERNEL_LRESULT  resultWP;       /* window proc result -- DWL_MSGRESULT (+0) */
    PDLG            pdlg;
    KERNEL_LONG_PTR unused;        /* DWL_USER (+8) */
    BYTE            reserved[DLGWINDOWEXTRA - sizeof(KERNEL_LRESULT) - sizeof(PDLG) - sizeof(KERNEL_LONG_PTR)];
} DIALOG, * KPTR_MODIFIER PDIALOG;

#define PDLG(pwnd) (((PDIALOG)pwnd)->pdlg)

/*
 * Flags definitions for DLG.flags
 */
#define DLGF_ANSI           0x01    /* lpfnDlg is an ANSI proc */

/*
 * MDI typedefs
 */
typedef struct tagMDI {
    UINT    cKids;
    HWND    hwndMaxedChild;
    HWND    hwndActiveChild;
    HMENU   hmenuWindow;
    UINT    idFirstChild;
    UINT    wScroll;
    LPWSTR  pTitle;
    UINT    iChildTileLevel;
} MDI, * PMDI;

typedef struct tagMDIWND {
    WND             wnd;
    KERNEL_UINT_PTR dwReserved; // quattro pro 1.0 stores stuff here!!
    PMDI            pmdi;
} MDIWND, * KPTR_MODIFIER PMDIWND;

#define CST_DESKTOP                 (UINT)0x00000001
#define CST_RIT                     (UINT)0x00000002
#define CST_GHOST                   (UINT)0x00000003
#define CST_POWER                   (UINT)0x00000004
#define CST_LAST                    (UINT)0x00000004

#define GWLP_MDIDATA        (FIELD_OFFSET(MDIWND, pmdi) - sizeof(WND))

#define TIF_INCLEANUP               (UINT)0x00000001
#define TIF_16BIT                   (UINT)0x00000002
#define TIF_SYSTEMTHREAD            (UINT)0x00000004
#define TIF_CSRSSTHREAD             (UINT)0x00000008
#define TIF_TRACKRECTVISIBLE        (UINT)0x00000010
#define TIF_ALLOWFOREGROUNDACTIVATE (UINT)0x00000020
#define TIF_DONTATTACHQUEUE         (UINT)0x00000040
#define TIF_DONTJOURNALATTACH       (UINT)0x00000080
#define TIF_WOW64                   (UINT)0x00000100 /* Thread is in a emulated 32bit process */
#define TIF_INACTIVATEAPPMSG        (UINT)0x00000200
#define TIF_SPINNING                (UINT)0x00000400
#define TIF_PALETTEAWARE            (UINT)0x00000800
#define TIF_SHAREDWOW               (UINT)0x00001000
#define TIF_FIRSTIDLE               (UINT)0x00002000
#define TIF_WAITFORINPUTIDLE        (UINT)0x00004000
#define TIF_MOVESIZETRACKING        (UINT)0x00008000
#define TIF_VDMAPP                  (UINT)0x00010000
#define TIF_DOSEMULATOR             (UINT)0x00020000
#define TIF_GLOBALHOOKER            (UINT)0x00040000
#define TIF_DELAYEDEVENT            (UINT)0x00080000
#define TIF_MSGPOSCHANGED           (UINT)0x00100000
#define TIF_IGNOREPLAYBACKDELAY     (UINT)0x00200000
#define TIF_ALLOWOTHERACCOUNTHOOK   (UINT)0x00400000
#define TIF_MEOW                    (UINT)0x00800000 /* Thread is associated with the MEOW VM */
#define TIF_GUITHREADINITIALIZED    (UINT)0x01000000
#define TIF_DISABLEIME              (UINT)0x02000000
#define TIF_INGETTEXTLENGTH         (UINT)0x04000000
#define TIF_ANSILENGTH              (UINT)0x08000000
#define TIF_DISABLEHOOKS            (UINT)0x10000000
#define TIF_RESTRICTED              (UINT)0x20000000
#define TIF_QUITPOSTED              (UINT)0x40000000


/*
 * Client Thread Information Structure.
 *
 *   This structure contains information regarding the
 *   thread.  This is viewable from both the client and
 *   kernel processes.
 */
typedef struct tagCLIENTTHREADINFO {
    UINT        CTIF_flags;
    WORD        fsChangeBits;           // Bits changes since last compared
    WORD        fsWakeBits;             // Bits currently available
    WORD        fsWakeBitsJournal;      // Bits saved while journalling
    WORD        fsWakeMask;             // Bits looking for when asleep
    LONG        timeLastRead;           // Time of last input read
#ifdef MESSAGE_PUMP_HOOK
    LONG        cMessagePumpHooks;      // Count of installed MPH's on this thread
#endif
} CLIENTTHREADINFO;

#define CTIF_SYSQUEUELOCKED         (UINT)0x00000001
#define CTIF_INSENDMESSAGE          (UINT)0x00000002
#define CTIF_INCALLBACKMESSAGE      (UINT)0x00000004

/*
 * First check for a 0, 0 filter which means we want all input.
 * If inverted message range, filter is exclusive.
 */
#define CheckMsgFilter(wMsg, wMsgFilterMin, wMsgFilterMax)                 \
    (   ((wMsgFilterMin) == 0 && (wMsgFilterMax) == 0xFFFFFFFF)            \
     || (  ((wMsgFilterMin) > (wMsgFilterMax))                             \
         ? (((wMsg) <  (wMsgFilterMax)) || ((wMsg) >  (wMsgFilterMin)))    \
         : (((wMsg) >= (wMsgFilterMin)) && ((wMsg) <= (wMsgFilterMax)))))

UINT    CalcWakeMask(UINT wMsgFilterMin, UINT wMsgFilterMax, UINT fsWakeMaskFilter);

/*
 * GetInputBits
 * This function checks if the specified input (fsWakeMask) has arrived (fsChangeBits)
 *  or it's available (fsWakeBits)
 */
__inline WORD GetInputBits (CLIENTTHREADINFO *pcti, WORD fsWakeMask, BOOL fAvailable)
{
    return (pcti->fsChangeBits  | (fAvailable ? pcti->fsWakeBits : 0)) & fsWakeMask;
}


typedef struct tagCARET {
    struct tagWND *spwnd;
    UINT    fVisible : 1;
    UINT    fOn      : 1;
    int     iHideLevel;
    int     x;
    int     y;
    int     cy;
    int     cx;
    HBITMAP hBitmap;
    UINT_PTR hTimer;
    DWORD   tid;

    /*
     * The following values are used to track the equivelent client coordinates
     * for caret positions in a window with a private DC.
     * See Also: zzzSetCaretPos, _GetGUIThreadInfo
     */
    int     xOwnDc;
    int     yOwnDc;
    int     cxOwnDc;
    int     cyOwnDc;
} CARET, *PCARET;

#define XPixFromXDU(x, cxChar)       MultDiv(x, cxChar, 4)
#define YPixFromYDU(y, cyChar)       MultDiv(y, cyChar, 8)
#define XDUFromXPix(x, cxChar)       MultDiv(x, 4, cxChar)
#define YDUFromYPix(y, cyChar)       MultDiv(y, 8, cyChar)


/*
 * Flags for the Q structure.
 */
#define QF_UPDATEKEYSTATE         (UINT)0x00001 // Set as key events are received. See PostUpdateKeyStateEvent.

#define QF_FMENUSTATUSBREAK       (UINT)0x00004 // Mouse button went up/down while ALT key was down == ignore ALT up.
#define QF_FMENUSTATUS            (UINT)0x00008 // ALT key down - toggle menu status mode (enter or exit).
#define QF_FF10STATUS             (UINT)0x00010 // Context menu key down. Treat us ALT if set on key up.
#define QF_MOUSEMOVED             (UINT)0x00020 // Mouse has moved but no move posted yet. Coalescing & performance
#define QF_ACTIVATIONCHANGE       (UINT)0x00040 // This flag is examined in the
                                                // menu loop code so that we
                                                // exit from menu mode if
                                                // another window was activated
                                                // while we were tracking
                                                // menus. This flag is set
                                                // whenever we activate a new
                                                // window.

#define QF_TABSWITCHING           (UINT)0x00080 // This bit is used as a
                                                // safety check when alt-
                                                // tabbing between apps.  It
                                                // tells us when to expect
                                                // a tab-switch in dwp.c.

#define QF_KEYSTATERESET          (UINT)0x00100 // Used by xxxSwitchDesktop to overwrite the key state upon desktop activation
#define QF_INDESTROY              (UINT)0x00200 // Debug only. To make sure we don't use a queue to be destroyed.
#define QF_LOCKNOREMOVE           (UINT)0x00400 // An input message has been peeked but not removed. Must be removed next.
#define QF_FOCUSNULLSINCEACTIVE   (UINT)0x00800 // Application set focus to NULL. Don't send focus messages on activation
#define QF_DIALOGACTIVE           (UINT)0x04000 // To pass this info in key/char messages lparam's. Undocumented.
#define QF_EVENTDEACTIVATEREMOVED (UINT)0x08000 //

#define QF_CAPTURELOCKED             0x00100000 // Set by menu mode. Prevent capture changes.
#define QF_ACTIVEWNDTRACKING         0x00200000 // Mouse has moved over a new window while in active wnd tracking mode

/*
 * Constants for Round Frame balloons
 */
#define RNDFRM_CORNER 10
#define RNDFRM_BORDER 3

/*
 * Constants for GetRealClientRect
 */
#define GRC_SCROLLS     0x0001
#define GRC_MINWNDS     0x0002
#define GRC_FULLSCREEN  0x0004

/*
 * Scroll bar info structure
 */
typedef struct tagSBWND {
    WND    wnd;
    BOOL   fVert;
#ifdef COLOR_HOTTRACKING
    int    ht;
#endif // COLOR_HOTTRACKING
    UINT   wDisableFlags;       /* Indicates which arrow is disabled; */
    SBCALC SBCalc;
} SBWND, * KPTR_MODIFIER PSBWND;

//
// Special regions
//
#define HRGN_NONE           ((HRGN)-1)
#define HRGN_EMPTY          ((HRGN)0)
#define HRGN_FULL           ((HRGN)1)
#define HRGN_MONITOR        ((HRGN)2)
#define HRGN_SPECIAL_LAST   HRGN_MONITOR

/*
 * SendMsgTimeout client/server transition struct
 */
typedef struct tagSNDMSGTIMEOUT {   /* smto */
    UINT fuFlags;                       // how to send the message, SMTO_BLOCK, SMTO_ABORTIFHUNG
    UINT uTimeout;                      // time-out duration
    ULONG_PTR lSMTOReturn;              // return value TRUE or FALSE
    ULONG_PTR lSMTOResult;              // result value for lpdwResult
} SNDMSGTIMEOUT, *PSNDMSGTIMEOUT;

typedef struct tagSNDMSGCALLBACK {
    SENDASYNCPROC lpResultCallBack;
    ULONG_PTR dwData;
} SNDMSGCALLBACK, *PSNDMSGCALLBACK;


#ifndef _USERK_
#if DBG
ULONG_PTR USERTHREADCONNECT();
__inline ULONG_PTR USERTHREADCONNECT()
{
    ULONG_PTR ulReturn;

    ulReturn = NtUserGetThreadState(UserThreadConnect);
    UserAssert(ulReturn == 0 || ulReturn == 1);
    return ulReturn;
}
#else
#define USERTHREADCONNECT() (NtUserGetThreadState(UserThreadConnect))
#endif // DBG

#define ConnectIfNecessary(retval) \
{ \
    if ((NtCurrentTebShared()->Win32ThreadInfo == NULL) \
            && !USERTHREADCONNECT()) { \
        return retval; \
    } \
}
#endif // !_USERK_

/*
 *  Button data structures (use to be in usercli.h)
 */
typedef struct tagBUTN {
    PWND spwnd;
    UINT buttonState;
    KHANDLE hFont;
    KHANDLE hImage;
    UINT fPaintKbdCuesOnly : 1;
} BUTN, * KPTR_MODIFIER PBUTN;

typedef struct tagBUTNWND {
    WND wnd;
    PBUTN pbutn;
} BUTNWND, * KPTR_MODIFIER PBUTNWND;

/*
 * IME control data structures
 */
typedef struct tagIMEUI {
    PWND  spwnd;
    KHIMC hIMC;
    KHWND hwndIMC;
    KHKL  hKL;
    KHWND hwndUI;               // To keep handle for UI window.
    int   nCntInIMEProc;        // Non-zero if hwnd has called into ImeWndProc.
    BOOL  fShowStatus:1;        // TRUE if don't want to show IME's window.
    BOOL  fActivate:1;          // TRUE if hwnd has called into ImeWndProc.
    BOOL  fDestroy:1;           // TRUE if hwnd has called into ImeWndProc.
    BOOL  fDefault:1;           // TRUE if this is the default IME.
    BOOL  fChildThreadDef:1;    // TRUE if this is the default IME which
                                // thread has only child window.
    BOOL  fCtrlShowStatus:1;    // Control status of show status bar.
    BOOL  fFreeActiveEvent:1;   // Control status of show status bar.

#ifdef CUAS_ENABLE
    // Cicero
    DWORD dwPrevToolbarStatus;  // Cicero for Hide or RestoreToolbar
#endif // CUAS_ENABLE
} IMEUI, *PIMEUI;

typedef struct tagIMEWND {
    WND wnd;
    PIMEUI pimeui;
} IMEWND, * KPTR_MODIFIER PIMEWND;


/*
 * SysErrorBox is a 3.1 API that has no 32-bit equivalent.  It's
 * implemented for WOW in harderr.c.
 */
#define MAX_SEB_STYLES  11  /* number of SEB_* values */

/*
 * The next values should be in the same order
 * with the ones in IDOK and STR_OK lists
 */
#define  SEB_OK         0  /* Button with "OK".     */
#define  SEB_CANCEL     1  /* Button with "Cancel"  */
#define  SEB_ABORT      2  /* Button with "&Abort"   */
#define  SEB_RETRY      3  /* Button with "&Retry"   */
#define  SEB_IGNORE     4  /* Button with "&Ignore"  */
#define  SEB_YES        5  /* Button with "&Yes"     */
#define  SEB_NO         6  /* Button with "&No"      */
#define  SEB_CLOSE      7  /* Button with "&Close"   */
#define  SEB_HELP       8  /* Button with "&Help"    */
#define  SEB_TRYAGAIN   9  /* Button with "&Try Again"  */
#define  SEB_CONTINUE   10 /* Button with "&Continue"   */

#define  SEB_DEFBUTTON  0x8000  /* Mask to make this button default */

typedef struct _MSGBOXDATA {            // mbd
    MSGBOXPARAMS;                       // Must be 1st item in structure
    PWND     pwndOwner;                 // Converted hwndOwner
    WORD     wLanguageId;
    INT    * pidButton;                 // Array of button IDs
    LPWSTR * ppszButtonText;            // Array of button text strings
    UINT     cButtons;                  // Number of buttons
    UINT     DefButton;
    UINT     CancelId;
    DWORD    dwTimeout;
} MSGBOXDATA, *PMSGBOXDATA, *LPMSGBOXDATA;

LPWSTR MB_GetString(UINT wBtn);
int    SoftModalMessageBox(LPMSGBOXDATA lpmb);

DWORD GetContextHelpId(PWND pwnd);

PITEM  MNLookUpItem(PMENU pMenu, UINT wCmd, BOOL fByPosition, PMENU *ppMenuItemIsOn);
BOOL xxxMNCanClose(PWND pwnd);
PMENU xxxGetSysMenuHandle(PWND pwnd);
PWND    GetPrevPwnd(PWND pwndList, PWND pwndFind);
BOOL   _RegisterServicesProcess(DWORD dwProcessId);

#ifdef _USERK_
#define RTLMENU PMENU
#define RtlGetSubMenu(rtlMenu, nPos) _GetSubMenu(rtlMenu, nPos)
#define xxxRtlSetMenuInfo xxxSetMenuInfo
#define xxxRtlInsertMenuItem(rtlMenu, wIndex, fByPos, lpmii, pstrItem) \
            xxxInsertMenuItem(rtlMenu, wIndex, fByPos, lpmii, pstrItem)
#define xxxRtlSetMenuItemInfo(rtlMenu, uId, pmii) \
            xxxSetMenuItemInfo(rtlMenu, uId, FALSE, pmii, NULL)
#else
#define RTLMENU HMENU
#define RtlGetSubMenu(rtlMenu, nPos) GetSubMenu(rtlMenu, nPos)
#define xxxRtlSetMenuInfo NtUserThunkedMenuInfo
#define xxxRtlInsertMenuItem(rtlMenu, wIndex, fByPos, lpmii, pstrItem) \
            InternalInsertMenuItem(rtlMenu, wIndex, fByPos, lpmii)
#define xxxRtlSetMenuItemInfo(rtlMenu, uId, pmii) \
            NtUserThunkedMenuItemInfo(rtlMenu, uId, FALSE, FALSE, pmii, NULL)
#endif
#ifdef LAME_BUTTON
RTLMENU xxxLoadSysMenu(UINT uMenuId, PWND pwnd);
#else
RTLMENU xxxLoadSysMenu(UINT uMenuId);
#endif // LAME_BUTTON


BOOL _FChildVisible(PWND pwnd);

#define CH_PREFIX TEXT('&')
//
// Japan support both Kanji and English mnemonic characters,
// toggled from control panel.  Both mnemonics are embedded in menu
// resource templates.  The following prefixes guide their parsing.
//
#define CH_ENGLISHPREFIX 0x1E
#define CH_KANJIPREFIX   0x1F


BOOL RtlWCSMessageWParamCharToMB(DWORD msg, WPARAM *pWParam);
BOOL RtlMBMessageWParamCharToWCS(DWORD msg, WPARAM *pWParam);

VOID RtlInitLargeAnsiString(PLARGE_ANSI_STRING plstr, LPCSTR psz,
        UINT cchLimit);
VOID RtlInitLargeUnicodeString(PLARGE_UNICODE_STRING plstr, LPCWSTR psz,
        UINT cchLimit);

DWORD RtlGetExpWinVer(HANDLE hmod);

/***************************************************************************\
*
* International multi-keyboard layout/font support
*
\***************************************************************************/

#define DT_CHARSETDRAW  1
#define DT_GETNEXTWORD  2

typedef void (FAR *LPFNTEXTDRAW)(HDC, int, int, LPWSTR, int, DWORD);

typedef  struct   {
    RECT     rcFormat;          // Format rectangle.
    int      cxTabLength;       // Tab length in pixels.
    int      iXSign;
    int      iYSign;
    int      cyLineHeight;      // Height of a line based on DT_EXTERNALLEADING
    int      cxMaxWidth;        // Width of the format rectangle.
    int      cxMaxExtent;       // Width of the longest line drawn.
    int      cxRightMargin;     // Right margin in pixels (with proper sign)
    LPFNTEXTDRAW  lpfnTextDraw; // pointer to PSTextOut or PSMTextOut based
                                // on DT_NOPREFIX flag.
    int      cxOverhang;        // Character overhang.
    BOOL     bCharsetDll;       // redirect to intl DLL, not textout
    int      iCharset;          // ANSI charset value
} DRAWTEXTDATA, *LPDRAWTEXTDATA;

typedef LONG (*FPLPKTABBEDTEXTOUT)
               (HDC, int, int, LPCWSTR, int, int, CONST INT *, int, BOOL, int, int, int);

typedef void (*FPLPKPSMTEXTOUT)
               (HDC, int, int, LPWSTR, int, DWORD);

typedef int  (*FPLPKDRAWTEXTEX)
               (HDC, int, int, LPCWSTR, int, BOOL, UINT, LPDRAWTEXTDATA, UINT, int);

extern FPLPKTABBEDTEXTOUT fpLpkTabbedTextOut;
extern FPLPKPSMTEXTOUT    fpLpkPSMTextOut;
extern FPLPKDRAWTEXTEX    fpLpkDrawTextEx;


// The number of characters in the ellipsis string (string defined in rtl\drawtext.c).
#define CCHELLIPSIS  3

int DrawTextExWorker(HDC hdc, LPWSTR lpchText, int cchText, LPRECT lprc,
                     UINT dwDTformat, LPDRAWTEXTPARAMS lpDTparams, int iCharset);


/***************************************************************************\
*
* Language pack edit control callouts.
*
* Functions are accessed through the pLpkEditCallout pointer in the ED
* structure. pLpkEditCallout points to a structure containing a pointer
* to each callout routine. These are typedef'd here.
*
* (In Windows95 this was achieved through a single function pointer
* - lpfnCharset - which was written in assembler and called from over 30
* places with different parameters. Since for NT the Lpk is written in C,
* the ED structure now points to a list of function pointers, each properly
* typedef'd, improving performance, enabling typechecking and avoiding
* varargs discrepancies between architectures.)
*
\***************************************************************************/

typedef struct tagED *PED;

typedef BOOL LpkEditCreate        (PED ped, HWND hWnd);

typedef int  LpkEditIchToXY       (PED ped, HDC hDC, PSTR pText, ICH cch, ICH ichPos);

typedef ICH  LpkEditMouseToIch    (PED ped, HDC hDC, PSTR pText, ICH cch, INT iX);

typedef ICH  LpkEditCchInWidth    (PED ped, HDC hdc, PSTR pText, ICH cch, int width);

typedef INT  LpkEditGetLineWidth  (PED ped, HDC hdc, PSTR pText, ICH cch);

typedef void LpkEditDrawText      (PED ped, HDC hdc, PSTR pText, INT cch, INT iMinSel, INT iMaxSel, INT iY);

typedef BOOL LpkEditHScroll       (PED ped, HDC hdc, PSTR pText);

typedef ICH  LpkEditMoveSelection (PED ped, HDC hdc, PSTR pText, ICH ich, BOOL fLeft);

typedef int  LpkEditVerifyText    (PED ped, HDC hdc, PSTR pText, ICH ichInsert, PSTR pInsertText, ICH cchInsert);

typedef void LpkEditNextWord      (PED ped, HDC hdc, PSTR pText, ICH ichStart, BOOL fLeft, ICH *pichMin, ICH *pichMax);

typedef void LpkEditSetMenu       (PED ped, HMENU hMenu);

typedef int  LpkEditProcessMenu   (PED ped, UINT idMenuItem);

typedef int  LpkEditCreateCaret   (PED ped, HDC hdc, INT nWidth, INT nHeight, UINT hkl);

typedef ICH  LpkEditAdjustCaret   (PED ped, HDC hdc, PSTR pText, ICH ich);


typedef struct tagLPKEDITCALLOUT {
    LpkEditCreate        *EditCreate;
    LpkEditIchToXY       *EditIchToXY;
    LpkEditMouseToIch    *EditMouseToIch;
    LpkEditCchInWidth    *EditCchInWidth;
    LpkEditGetLineWidth  *EditGetLineWidth;
    LpkEditDrawText      *EditDrawText;
    LpkEditHScroll       *EditHScroll;
    LpkEditMoveSelection *EditMoveSelection;
    LpkEditVerifyText    *EditVerifyText;
    LpkEditNextWord      *EditNextWord;
    LpkEditSetMenu       *EditSetMenu;
    LpkEditProcessMenu   *EditProcessMenu;
    LpkEditCreateCaret   *EditCreateCaret;
    LpkEditAdjustCaret   *EditAdjustCaret;
} LPKEDITCALLOUT, *PLPKEDITCALLOUT;

extern PLPKEDITCALLOUT    fpLpkEditControl;

/***************************************************************************\
*
*  Structure for client-side thread-info.
*   dwHookCurrent HIWORD is current hook filter type (eg: WH_GETMESSAGE)
*                 LOWORD is TRUE if current hook is ANSI, FALSE if Unicode
*
\***************************************************************************/


/*
 * Hook thunks.
 */
#ifdef REDIRECTION
LRESULT CALLBACK fnHkINLPPOINT(DWORD nCode,
        WPARAM wParam, LPPOINT lParam,
        ULONG_PTR xParam, PROC xpfnProc);
#endif // REDIRECTION

LRESULT CALLBACK fnHkINLPRECT(DWORD nCode,
        WPARAM wParam, LPRECT lParam,
        ULONG_PTR xParam, PROC xpfnProc);
LRESULT CALLBACK fnHkINDWORD(DWORD nCode,
        WPARAM wParam, LPARAM lParam,
        ULONG_PTR xParam, PROC xpfnProc, LPDWORD lpFlags);
LRESULT CALLBACK fnHkINLPMSG(DWORD nCode,
        WPARAM wParam, LPMSG lParam,
        ULONG_PTR xParam, PROC xpfnProc, BOOL bAnsi, LPDWORD lpFlags);
LRESULT CALLBACK fnHkOPTINLPEVENTMSG(DWORD nCode,
        WPARAM wParam, LPEVENTMSGMSG lParam,
        ULONG_PTR xParam, PROC xpfnProc);
LRESULT CALLBACK fnHkINLPDEBUGHOOKSTRUCT(DWORD nCode,
        WPARAM wParam, LPDEBUGHOOKINFO lParam,
        ULONG_PTR xParam, PROC xpfnProc);
LRESULT CALLBACK fnHkINLPMOUSEHOOKSTRUCTEX(DWORD nCode,
        WPARAM wParam, LPMOUSEHOOKSTRUCTEX lParam,
        ULONG_PTR xParam, PROC xpfnProc, LPDWORD lpFlags);
LRESULT CALLBACK fnHkINLPKBDLLHOOKSTRUCT(DWORD nCode,
        WPARAM wParam, LPKBDLLHOOKSTRUCT lParam,
        ULONG_PTR xParam, PROC xpfnProc);
LRESULT CALLBACK fnHkINLPMSLLHOOKSTRUCT(DWORD nCode,
        WPARAM wParam, LPMSLLHOOKSTRUCT lParam,
        ULONG_PTR xParam, PROC xpfnProc);
LRESULT CALLBACK fnHkINLPCBTACTIVATESTRUCT(DWORD nCode,
        WPARAM wParam, LPCBTACTIVATESTRUCT lParam,
        ULONG_PTR xParam, PROC xpfnProc);
LRESULT CALLBACK fnHkINLPCBTCSTRUCT(UINT msg,
        WPARAM wParam, LPCBT_CREATEWND pcbt,
        PROC xpfnProc, BOOL bAnsi);
LRESULT CALLBACK fnHkINLPCBTMDICCSTRUCT(UINT msg,
        WPARAM wParam, LPCBT_CREATEWND pcbt,
        PROC xpfnProc, BOOL bAnsi);

#ifdef REDIRECTION
LRESULT CALLBACK fnHkINLPHTHOOKSTRUCT(DWORD nCode,
        WPARAM wParam, LPHTHOOKSTRUCT lParam,
        ULONG_PTR xParam, PROC xpfnProc);
#endif // REDIRECTION

/***************************************************************************\
*
* Definitions for client/server-specific data referenced by rtl routines.
*
\***************************************************************************/

extern HBRUSH   ghbrWhite;
extern HBRUSH   ghbrBlack;


ULONG_PTR GetCPD(KERNEL_PVOID pWndOrCls, DWORD options, ULONG_PTR dwData);

BOOL TestWindowProcess(PWND pwnd);
DWORD GetAppCompatFlags(PTHREADINFO pti);
DWORD GetAppCompatFlags2(WORD wVer);
DWORD GetAppImeCompatFlags(PTHREADINFO pti);
PWND _GetDesktopWindow(VOID);
PWND _GetMessageWindow(VOID);

/***************************************************************************\
*
* Shared function prototypes
*
\***************************************************************************/


PVOID FASTCALL HMValidateHandle(HANDLE h, BYTE btype);
PVOID FASTCALL HMValidateCatHandleNoRip(HANDLE h, BYTE btype);
PVOID FASTCALL HMValidateHandleNoRip(HANDLE h, BYTE btype);
KERNEL_PVOID FASTCALL HMValidateHandleNoDesktop(HANDLE h, BYTE btype);
PVOID FASTCALL HMValidateSharedHandle(HANDLE h, BYTE bType);

PVOID FASTCALL HMValidateCatHandleNoSecure(HANDLE h, BYTE bType);
PVOID FASTCALL HMValidateCatHandleNoSecureCCX(HANDLE h, BYTE bType, PCLIENTINFO ccxPci);
PVOID FASTCALL HMValidateHandleNoSecure(HANDLE h, BYTE bType);

ULONG_PTR MapClientNeuterToClientPfn(PCLS pcls, KERNEL_ULONG_PTR dw, BOOL bAnsi);
ULONG_PTR MapServerToClientPfn(KERNEL_ULONG_PTR dw, BOOL bAnsi);

BOOL IsSysFontAndDefaultMode(HDC hdc);

int GetCharDimensions(HDC hDC, TEXTMETRICW *lpTextMetrics, LPINT lpcy);

int   GetWindowBorders(LONG lStyle, DWORD dwExStyle, BOOL fWindow, BOOL fClient);
PWND  SizeBoxHwnd(PWND pwnd);
VOID  _GetClientRect(PWND pwnd, LPRECT prc);

#ifndef _USERSRV_
void GetRealClientRect(PWND pwnd, LPRECT prc, UINT uFlags, PMONITOR pMonitor);
#endif

VOID  _GetWindowRect(PWND pwnd, LPRECT prc);
PWND  _GetLastActivePopup(PWND pwnd);
BOOL  _IsChild(PWND pwndParent, PWND pwnd);
BOOL  _AdjustWindowRectEx(LPRECT lprc, DWORD style, BOOL fMenu, DWORD dwExStyle);
BOOL  NeedsWindowEdge(DWORD dwStyle, DWORD dwExStyle, BOOL fNewApp);
VOID  _ClientToScreen(PWND pwnd, PPOINT ppt);
VOID  _ScreenToClient(PWND pwnd, PPOINT ppt);
int   _MapWindowPoints(PWND pwndFrom, PWND pwndTo, LPPOINT lppt, DWORD cpt);
BOOL  _IsWindowVisible(PWND pwnd);
BOOL  _IsDescendant(PWND pwndParent, PWND pwndChild);
BOOL  IsVisible(PWND pwnd);
PWND  _GetWindow(PWND pwnd, UINT cmd);
PWND  _GetParent(PWND pwnd);
int   FindNCHit(PWND pwnd, LONG lPt);
SHORT _GetKeyState(int vk);
PHOOK PhkNextValid(PHOOK phk);

#define GRECT_CLIENT        0x0001
#define GRECT_WINDOW        0x0002
#define GRECT_RECTMASK      0x0003

#define GRECT_CLIENTCOORDS  0x0010
#define GRECT_WINDOWCOORDS  0x0020
#define GRECT_PARENTCOORDS  0x0040
#define GRECT_COORDMASK     0x0070

void GetRect(PWND pwnd, LPRECT lprc, UINT uCoords);

PPROP _FindProp(PWND pwnd, PCWSTR pszKey, BOOL fInternal);
HANDLE _GetProp(PWND pwnd, PCWSTR pszKey, BOOL fInternal);
BOOL _HasCaptionIcon(PWND pwnd);
PWND GetTopLevelWindow(PWND pwnd);

BOOL _SBGetParms(PWND pwnd, int code, PSBDATA pw, LPSCROLLINFO lpsi);
BOOL PSMGetTextExtent(HDC hdc, LPCWSTR lpstr, int cch, PSIZE psize);

LONG   GetPrefixCount(LPCWSTR lpstr, int cb, LPWSTR lpstrCopy, int cbCopy);
PMENU _GetSubMenu(PMENU pMenu, int nPos);
DWORD _GetMenuDefaultItem(PMENU pMenu, BOOL fByPosition, UINT uFlags);
UINT _GetMenuState(PMENU pMenu, UINT wID, UINT dwFlags);

BOOL APIENTRY CopyInflateRect(LPRECT prcDst, CONST RECT *prcSrc, int cx, int cy);
BOOL APIENTRY CopyOffsetRect(LPRECT prcDst, CONST RECT *prcSrc, int cx, int cy);

DWORD FindCharPosition(LPWSTR lpString, WCHAR ch);
LPWSTR  TextAlloc(LPCWSTR lpsz);
UINT  TextCopy(PLARGE_UNICODE_STRING pstr, LPWSTR lpstr, UINT size);
DWORD wcsncpycch(LPWSTR pwsDest, LPCWSTR pwszSrc, DWORD cch);
DWORD strncpycch(LPSTR pszDest, LPCSTR pszSrc, DWORD cch);


#define TextPointer(h) ((LPWSTR)h)

BOOL DrawFrame(HDC hdc, LPRECT prect, int clFrame, int cmd);
VOID DrawPushButton(HDC hdc, LPRECT lprc, UINT state, UINT flags);
BOOL ClientFrame(HDC hDC, CONST RECT *pRect, HBRUSH hBrush, DWORD patOp, int cxBorder, int cyBorder);

VOID MirrorClientRect(PWND pwnd, LPRECT lprc);
VOID MirrorWindowRect(PWND pwnd, LPRECT lprc);

#define DO_DROPFILE 0x454C4946L

#define ISTS() (!!(USER_SHARED_DATA->SuiteMask & (1 << TerminalServer)))

/*
 * Structure for DoConnect system call.
 */
typedef struct _DOCONNECTDATA {
    BOOL   fConsoleShadowFlag;
    BOOL   fMouse;
    BOOL   fINetClient;
    BOOL   fInitialProgram;
    BOOL   fHideTitleBar;
    HANDLE IcaVideoChannel;
    HANDLE IcaBeepChannel;
    HANDLE IcaMouseChannel;
    HANDLE IcaKeyboardChannel;
    HANDLE IcaThinwireChannel;
    HANDLE DisplayChangeEvent;
    WCHAR  WinStationName[32];
    WCHAR  ProtocolName[10];
    WCHAR  AudioDriverName[10];
    BOOL   fClientDoubleClickSupport;
    BOOL   fEnableWindowsKey;
    DWORD  drBitsPerPel;
    DWORD  drPelsWidth;
    DWORD  drPelsHeight;
    DWORD  drDisplayFrequency;
    USHORT drProtocolType;
    CLIENTKEYBOARDTYPE  ClientKeyboardType;
} DOCONNECTDATA, *PDOCONNECTDATA;

/*
 * Structure for DoReconnect system call.
 */

#define DR_DISPLAY_DRIVER_NAME_LENGTH 9
#define DR_PROTOCOL_NAME_LENGTH 9

typedef struct _DORECONNECTDATA {
    BOOL   fMouse;
    BOOL   fINetClient;
    WCHAR  WinStationName[32];
    WCHAR   DisplayDriverName[DR_DISPLAY_DRIVER_NAME_LENGTH];
    WCHAR   ProtocolName[DR_PROTOCOL_NAME_LENGTH];
    WCHAR  AudioDriverName[9];
    BOOL   fClientDoubleClickSupport;
    BOOL   fEnableWindowsKey;
    DWORD  drBitsPerPel;
    DWORD  drPelsWidth;
    DWORD  drPelsHeight;
    DWORD  drDisplayFrequency;
    USHORT drProtocolType;
    BOOL   fChangeDisplaySettings;
    CLIENTKEYBOARDTYPE  ClientKeyboardType;
} DORECONNECTDATA, *PDORECONNECTDATA;

typedef enum _NOTIFYEVENT {
    Notify_Disconnect,
    Notify_Reconnect,
    Notify_PreReconnect,
    Notify_SyncDisconnect,
    Notify_DisableScrnSaver,
    Notify_EnableScrnSaver,
    Notify_StopReadInput,
    Notify_PreReconnectDesktopSwitch,
    Notify_HelpAssistantShadowStart,
    Notify_HelpAssistantShadowFinish,
    Notify_DisconnectPipe
} NOTIFYEVENT, *PNOTIFYEVENT;

typedef struct _DONOTIFYDATA {
    NOTIFYEVENT NotifyEvent;
} DONOTIFYDATA, *PDONOTIFYDATA;

/*
 * EndTask, ExitWindows, hung app, etc time outs
 */
#define CMSSLEEP                250
#define CMSHUNGAPPTIMEOUT       (5 * 1000)
#define CMSHUNGTOKILLCOUNT       4
#define CMSWAITTOKILLTIMEOUT    (CMSHUNGTOKILLCOUNT * CMSHUNGAPPTIMEOUT)
#define CMSAPPSTARTINGTIMEOUT   (6 * CMSHUNGAPPTIMEOUT) /* Some setup apps are pretty slow. bug 195832 */
#define CMS_QANIMATION          165
#define CMS_FLASHWND            500
#define CMS_MENUFADE            175
#define CMS_SELECTIONFADE       350
#define CMS_TOOLTIP             135
#ifdef MOUSE_IP
#define CMS_SONARTIMEOUT        1000    /* if it takes more than this, sonar will just bail out */
#endif
#define PROCESSTERMINATETIMEOUT (90 * 1000)

/*
 * Message table definitions
 */
typedef struct tagMSG_TABLE_ENTRY {
    BYTE iFunction:6;
    BYTE bThunkMessage:1;
    BYTE bSyncOnlyMessage:1;
} MSG_TABLE_ENTRY;

extern CONST MSG_TABLE_ENTRY MessageTable[];

#define TESTSYNCONLYMESSAGE(msg, wParam) (((msg) < WM_USER) ?       \
        (   (MessageTable[msg].bSyncOnlyMessage) ||                 \
            (((msg) == WM_DEVICECHANGE) && ((wParam) & 0x8000))) :  \
        0)


/*
 * Drag and Drop menus.
 * MNDragOver output info
 */
typedef struct tagMNDRAGOVERINFO
{
    DWORD dwFlags;
    HMENU hmenu;
    UINT uItemIndex;
    HWND hwndNotify;
} MNDRAGOVERINFO, * PMNDRAGOVERINFO;

#ifdef _USERK_
typedef struct tagMOUSECURSOR {
    BYTE bAccelTableLen;
    BYTE bAccelTable[128];
    BYTE bConstantTableLen;
    BYTE bConstantTable[128];
} MOUSECURSOR;
#endif

typedef struct tagINTERNALSETHIGHCONTRAST {
    UINT    cbSize;
    DWORD   dwFlags;
    UNICODE_STRING usDefaultScheme;
} INTERNALSETHIGHCONTRAST, *LPINTERNALSETHIGHCONTRAST;

#define InMsgRange(msg, start, end) (((msg) >= (start)) && ((msg) <= (end)))


/*
 * Enforce 64bit/32bit natural alignment
 * N.b. does not work for byte aligned objects.
 */

#define NATURAL_ALIGNED_PTR(type, x)  ((type*)(((ULONG_PTR)(x) + PROBE_ALIGNMENT(type) - 1) & ~(PROBE_ALIGNMENT(type) - 1)))

#define ARABIC_UI_LANGID()    (gpsi->UILangID == MAKELANGID(LANG_ARABIC, SUBLANG_DEFAULT))
#define HEBREW_UI_LANGID()    (gpsi->UILangID == MAKELANGID(LANG_HEBREW, SUBLANG_DEFAULT))
#define RTL_UI()              (ARABIC_UI_LANGID() || HEBREW_UI_LANGID())

#endif // _USER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbda1\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbda3\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\makefile.inc ===
#############################################################################
#
# This is the first phase of building keyboard layouts
#
# For each *.txt layout definition (eg: kbdbe.txt kbdbtr.txt etc.):
#  - make the ..\tmp\* directory
#  - generate "sources", "makefile" and "makefile.inc" files in ..\tmp\*
#
# Also generate the ..\tmp\dirs files
#
# THIS FILE IS INCLUDED BY ..\us_kbd\makefile.inc
#
#############################################################################

#
# Layout names (eg: kbdbe)
#
TARGETNAMES=$(SOURCES:.c=)

#
# Directories in which layout will be built (eg: ..\tmp\kbdbe)
#
TARGETDIRS=$(TARGETNAMES:kbd=..\tmp\kbd)

#
# "sources" files used by BUILD to compile layouts (eg: kbdbe\sources)
#
TARGETSOURCEFILES=$(SOURCES:.c=\sources)

#############################################################################
#
# Build all
# builds the "dirs" file that steers the compile and link phase
#
#############################################################################
all: always_build_dirs $(TARGETSOURCEFILES:kbd=..\tmp\kbd)

#
# build -clean does this
#
clean:
    delnode /q ..\tmp\*

#
# Build the DIRS file in ..\tmp
# do this always
#
always_build_dirs: ..\tmp\dirs
    type << > ..\tmp\dirs
DIRS=\
$(TARGETNAMES)
<<


#
# If the "sources" or (this) "makefile.inc" file in this directory have
# changed, make the TARGETDIRS out of date (by deleting)
#
..\tmp\dirs: ..\all_kbds\sources ..\us_kbd\sources makefile.inc
    -md ..\tmp
    type << > ..\tmp\dirs
DIRS=\
$(TARGETNAMES)
<<
    delnode /q ..\tmp\kbd*

#
# Dependencies to make sure the "sources" files are built
# (eg: ..\tmp\kbdbe\sources: ..\tmp\kbdbe)
#
$(TARGETSOURCEFILES:kbd=..\tmp\kbd): $$(@D)


#
# build the SOURCES, MAKEFILE and MAKEFILE.INC in each ..\tmp\kbd*
#   The target of this rule is a directory, which is a problem, since the
#   timestamp of these can only change if the directory is deleted and
#   recreated: hence the delnode /q ..\tmp\kbd* line is the ..\tmp\dirs
#   rule (above).  This deletes the _objects.mac files so you have to run
#   build twice is either the sources or makefile.inc files are updated.
#   To get around this by changing the
#
$(TARGETDIRS): sources ..\all_kbds\makefile.inc
    -md $@
    copy ..\all_kbds\makefile.tpl $@\makefile
    type << > $@\makefile.inc
$(@B).c $(@B).h $(@B).rc $(@B).def: ..\..\all_kbds\$(@B).txt
    kbdtool ..\..\all_kbds\$(@B).txt
<<
    type << > $@\sources._xx
^!IF 0
Copyright (c) 1995  Microsoft Corporation
^!ENDIF

NOLINK=
MAJORCOMP=user
MINORCOMP=$(@B)
TARGETNAME=$(@B)
TARGETPATH=$(O)
TARGETTYPE=DYNLINK
TARGETLIBS=
INCLUDES=..\..\..\inc
SOURCES=$(@B).c $(@B).rc
C_DEFINES=
UMTYPE=nt
UMTEST=
UMAPPL=
UMBASE=0x1000000
UMLIBS=
^!if $$(IA64)
SECTION_ALIGNMENT=0x4000
LINKER_FLAGS = -merge:.edata=.data -merge:.srdata=.data -merge:.text=.data -merge:.bss=.data -section:.data,re
^!else
LINKER_FLAGS = -merge:.edata=.data -merge:.rdata=.data -merge:.text=.data -merge:.bss=.data -section:.data,re
^!endif

NTTARGETFILE0=$(@B).h $(@B).rc $(@B).def
<< 
    sed "s/^\^//" $@\sources._xx > $@\sources
    del /f $@\sources._xx
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbda3\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\sources.inc ===
INCLUDES=..\..\..\inc

C_DEFINES=
UMTYPE=nt
UMTEST=
UMAPPL=
UMBASE=0x1000000
UMLIBS=
TARGETLIBS=
DLLDEF=$(O)\$(TARGETNAME).def

!if $(IA64)
SECTION_ALIGNMENT=0x4000
NO_READONLY_STRINGS=1
!endif
LINKER_FLAGS = -merge:.edata=.data -merge:.rdata=.data -merge:.text=.data -merge:.bss=.data -section:.data,re

TARGETPATH=$(_OBJ_DIR)
TARGETTYPE=DYNLINK

SOURCES=$(O)\$(TARGETNAME).c $(O)\$(TARGETNAME).rc

!if "$(SOURCES_USED)" != "..\..\..\fekbds.inc"
NTTARGETFILE0=$(O)\$(TARGETNAME).h $(O)\$(TARGETNAME).rc $(O)\$(TARGETNAME).def
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdal\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbda1\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbda2\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdarme\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdarmw\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdarme\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdal\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbda2\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdaze\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdaze\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdarmw\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdbe\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdbe\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdazel\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdazel\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdbene\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdblr\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdblr\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdbene\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdbr\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdbr\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdbu\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdca\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdbu\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdca\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdcan\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdcan\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdcr\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdcr\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdcz\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdcz\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdcz1\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdcz2\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdcz2\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdcz1\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdda\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbddiv1\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdda\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbddiv1\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbddiv2\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbddv\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbddv\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdes\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbddiv2\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdes\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdest\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdest\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdfa\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdfc\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdfc\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdfa\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdfi\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdfi\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdfo\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdfr\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdfo\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdfr\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdgae\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdgeo\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdgae\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdgkl\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdgeo\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdgkl\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdgr\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdgr\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdgr1\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdgr1\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdhe\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdhe220\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdhe\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdhe220\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdhe319\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdhe319\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdheb\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdheb\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdhebx\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdhela2\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdhebx\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdhela2\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdhela3\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdhela3\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdhept\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdhept\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdhu\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdhu\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdhu1\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdhu1\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdic\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdic\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdinasa\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdindev\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdinben\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdinasa\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdinben\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdindev\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdinguj\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdinguj\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdinhin\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdinhin\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdinkan\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdinkan\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdinmal\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdinmal\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdinmar\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdinori\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdinmar\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdinori\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdinpun\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdintam\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdinpun\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdintel\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdintam\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdintel\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdir\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdir\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdit\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdit\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdit142\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdit142\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdkaz\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdkyr\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdkyr\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdkaz\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdla\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdla\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdlt\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdlt\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdlt1\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdlt1\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdlv\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdlv\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdlv1\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdlv1\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdmac\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdmac\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdmon\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdmon\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdne\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdne\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdno\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdno\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdpl\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdpl\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdpl1\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdpo\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdpl1\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdpo\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdro\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdru\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdro\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdru\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdru1\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdru1\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdsf\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdsf\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdsg\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdsg\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdsl\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdsl\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdsl1\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdsp\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdsl1\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdsyr1\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdsw\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdsp\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdsw\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdsyr1\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdsyr2\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdsyr2\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdtat\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdth0\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdtat\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdth0\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdth1\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdth1\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdth3\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdth2\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdth2\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdth3\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdtuf\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdtuf\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdtuq\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdtuq\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbduk\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbduk\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdur\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdur\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdurdu\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdurdu\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdurs\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdusa\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdusl\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdusa\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdurs\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdusr\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdusl\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdusx\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdusr\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbduzb\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdusx\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdvntc\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbduzb\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdycc\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdycc\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdvntc\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdycl\daytona\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\all_kbds\kbdycl\wow6432\makefile.inc ===
!INCLUDE ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\fe_kbds\fekbds.inc ===
#****************************** File Header ******************************\
# File Name: Sources.inc for FE KBDs
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific SOURCES file.
#
# History:
# May-14-1999 HiroYama Created
#***************************************************************************/


TARGETNAME=$(MINORCOMP)
NOLINK=
MAJORCOMP=user

SOURCES_USED=..\..\..\fekbds.inc

!include ..\..\..\..\sources.inc


# Override some of the values set by sources.inc
SOURCES=..\$(MINORCOMP).c ..\$(MINORCOMP).rc

INCLUDES= \
    ..\..\inc; \
    $(NTUSER_PATH)\inc; \
    $(NTUSER_PATH)\inc\$(ALT_PROJECT)\$(O); \
    $(PROJECT_ROOT)\core\w32inc; \
    $(BASE_INC_PATH);

#    $(SHELL_INC_PATH)
C_DEFINES=$(C_DEFINES) -DFE_SB -DFE_IME
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\fe_kbds\jpn\101\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

MINORCOMP=kbd101

!include ..\..\japan.inc

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\fe_kbds\jpn\101\kbd101.h ===
/****************************** Module Header ******************************\
* Module Name: kbd101.h
*
* Copyright (c) 1985-2000, Microsoft Corporation
*
* Various defines for use by keyboard input code.
*
* History:
\***************************************************************************/

/*
 * kbd type should be controlled by cl command-line argument
 */
#define KBD_TYPE 4

/*
 * Include the basis of all keyboard table values
 */
#include "kbd.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\fe_kbds\jpn\japan.inc ===
#****************************** File Header ******************************\
# File Name: Sources.inc for JPN KBDs
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific SOURCES file.
#
# History:
# May-14-1999 HiroYama Created
#***************************************************************************/

!include ..\..\..\fekbds.inc

C_DEFINES=$(C_DEFINES) -DJAPAN -DNEWKBDMAP

SOURCES_USED=..\..\japan.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\fe_kbds\common\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

MAJORCOMP=user
MINORCOMP=kbdfe_common
TARGETPATH=$(ALT_PROJECT_TARGET)\$(_OBJ_DIR)

C_DEFINES=$(C_DEFINES) $(USER_C_DEFINES)

TARGETNAME=fekbdcom
TARGETTYPE=LIBRARY

#INCLUDES=..\inc;..\..\..\inc;..\..\..\..\inc;..\$(BASE_KEYBOARD_LAYOUT)


SOURCES=..\fekbdcom.c

SYNCHRONIZE_BLOCK=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\fe_kbds\jpn\106\kbd106.c ===
/***************************************************************************\
* Module Name: kbd106.c
*
* Copyright (c) 1985-2000, Microsoft Corporation
*
* History:
\***************************************************************************/

//@@BEGIN_DDKSPLIT
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
//@@END_DDKSPLIT
#include <windows.h>
#include "kbdjpn.h"
#include "kbd106.h"

#if defined(_M_IA64)
#pragma section(".data")
#define ALLOC_SECTION_LDATA __declspec(allocate(".data"))
#else
#pragma data_seg(".data")
#define ALLOC_SECTION_LDATA
#endif

/***************************************************************************\
* ausVK[] - Virtual Scan Code to Virtual Key conversion table for 106
\***************************************************************************/

static ALLOC_SECTION_LDATA USHORT ausVK[] = {
    T00, T01, T02, T03, T04, T05, T06, T07,
    T08, T09, T0A, T0B, T0C, T0D, T0E, T0F,
    T10, T11, T12, T13, T14, T15, T16, T17,
    T18, T19, T1A, T1B, T1C, T1D, T1E, T1F,
    T20, T21, T22, T23, T24, T25, T26, T27,
    T28,

    /*
     * Hankaku/Zenkaku/Kanji key must have KBDSPECIAL bit set (NLS key)
     */
    T29 | KBDSPECIAL,

              T2A, T2B, T2C, T2D, T2E, T2F,
    T30, T31, T32, T33, T34, T35,

    /*
     * Right-hand Shift key must have KBDEXT bit set.
     */
    T36 | KBDEXT,

    /*
     * numpad_* + Shift/Alt -> SnapShot
     */
    T37 | KBDMULTIVK,

    T38, T39,

    /*
     * Alphanumeric/CapsLock key must have KBDSPECIAL bit set (NLS key)
     */
    T3A | KBDSPECIAL,

                   T3B, T3C, T3D, T3E, T3F,
    T40, T41, T42, T43, T44,

    /*
     * NumLock Key:
     *     KBDEXT     - VK_NUMLOCK is an Extended key
     *     KBDMULTIVK - VK_NUMLOCK or VK_PAUSE (without or with CTRL)
     */
    T45 | KBDEXT | KBDMULTIVK,

    T46 | KBDMULTIVK,

    /*
     * Number Pad keys:
     *     KBDNUMPAD  - digits 0-9 and decimal point.
     *     KBDSPECIAL - require special processing by Windows
     */
    T47 | KBDNUMPAD | KBDSPECIAL,   // Numpad 7 (Home)
    T48 | KBDNUMPAD | KBDSPECIAL,   // Numpad 8 (Up),
    T49 | KBDNUMPAD | KBDSPECIAL,   // Numpad 9 (PgUp),
    T4A,
    T4B | KBDNUMPAD | KBDSPECIAL,   // Numpad 4 (Left),
    T4C | KBDNUMPAD | KBDSPECIAL,   // Numpad 5 (Clear),
    T4D | KBDNUMPAD | KBDSPECIAL,   // Numpad 6 (Right),
    T4E,
    T4F | KBDNUMPAD | KBDSPECIAL,   // Numpad 1 (End),
    T50 | KBDNUMPAD | KBDSPECIAL,   // Numpad 2 (Down),
    T51 | KBDNUMPAD | KBDSPECIAL,   // Numpad 3 (PgDn),
    T52 | KBDNUMPAD | KBDSPECIAL,   // Numpad 0 (Ins),
    T53 | KBDNUMPAD | KBDSPECIAL,   // Numpad . (Del),

    T54, T55, T56, T57, T58, T59, T5A, T5B,
    T5C, T5D, T5E, T5F, T60, T61, T62, T63,
    T64, T65, T66, T67, T68, T69, T6A, T6B,
    T6C, T6D, T6E, T6F,

    /*
     * Hiragana/Katakana/Roman key must have KBDSPECIAL bit set (NLS key)
     */
    T70 | KBDSPECIAL,

                             T71, T72, T73,
    T74, T75, T76, T77, T78,

    /*
     * Conversion key must have KBDSPECIAL bit set (NLS key)
     */
    T79 | KBDSPECIAL,

                                  T7A,

    /*
     * Non-Conversion key must have KBDSPECIAL bit set (NLS key)
     */
    T7B | KBDSPECIAL,

    T7C, T7D, T7E, T7F

};

static ALLOC_SECTION_LDATA VSC_VK aE0VscToVk[] = {
        { 0x10, X10 | KBDEXT              },  // Speedracer: Previous Track
        { 0x19, X19 | KBDEXT              },  // Speedracer: Next Track
        { 0x1C, X1C | KBDEXT              },  // Numpad Enter
        { 0x1D, X1D | KBDEXT              },  // RControl
        { 0x20, X20 | KBDEXT              },  // Speedracer: Volume Mute
        { 0x21, X21 | KBDEXT              },  // Speedracer: Launch App 2
        { 0x22, X22 | KBDEXT              },  // Speedracer: Media Play/Pause
        { 0x24, X24 | KBDEXT              },  // Speedracer: Media Stop
        { 0x2E, X2E | KBDEXT              },  // Speedracer: Volume Down
        { 0x30, X30 | KBDEXT              },  // Speedracer: Volume Up
        { 0x32, X32 | KBDEXT              },  // Speedracer: Browser Home
        { 0x35, X35 | KBDEXT              },  // Numpad Divide
        { 0x37, X37 | KBDEXT              },  // Snapshot
        { 0x38, X38 | KBDEXT              },  // RMenu
        { 0x46, X46 | KBDEXT              },  // Break (Ctrl + Pause)
        { 0x47, X47 | KBDEXT              },  // Home
        { 0x48, X48 | KBDEXT              },  // Up
        { 0x49, X49 | KBDEXT              },  // Prior
        { 0x4B, X4B | KBDEXT              },  // Left
        { 0x4D, X4D | KBDEXT              },  // Right
        { 0x4F, X4F | KBDEXT              },  // End
        { 0x50, X50 | KBDEXT              },  // Down
        { 0x51, X51 | KBDEXT              },  // Next
        { 0x52, X52 | KBDEXT              },  // Insert
        { 0x53, X53 | KBDEXT              },  // Delete
        { 0x5B, X5B | KBDEXT              },  // Left Win
        { 0x5C, X5C | KBDEXT              },  // Right Win
        { 0x5D, X5D | KBDEXT              },  // Application
        { 0x5F, X5F | KBDEXT              },  // Speedracer: Sleep
        { 0x65, X65 | KBDEXT              },  // Speedracer: Browser Search
        { 0x66, X66 | KBDEXT              },  // Speedracer: Browser Favorites
        { 0x67, X67 | KBDEXT              },  // Speedracer: Browser Refresh
        { 0x68, X68 | KBDEXT              },  // Speedracer: Browser Stop
        { 0x69, X69 | KBDEXT              },  // Speedracer: Browser Forward
        { 0x6A, X6A | KBDEXT              },  // Speedracer: Browser Back
        { 0x6B, X6B | KBDEXT              },  // Speedracer: Launch App 1
        { 0x6C, X6C | KBDEXT              },  // Speedracer: Launch Mail
        { 0x6D, X6D | KBDEXT              },  // Speedracer: Launch Media Selector
        { 0,      0                       }
};

static ALLOC_SECTION_LDATA VSC_VK aE1VscToVk[] = {
        { 0x1D, Y1D                       },  // Pause
        { 0   ,   0                       }
};

/***************************************************************************\
* aVkToBits[]  - map Virtual Keys to Modifier Bits
*
* See kbd.h for a full description.
*
* US Keyboard has only three shifter keys:
*     SHIFT (L & R) affects alphabnumeric keys,
*     CTRL  (L & R) is used to generate control characters
*     ALT   (L & R) used for generating characters by number with numpad
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_BIT aVkToBits[] = {
    { VK_SHIFT,   KBDSHIFT },
    { VK_CONTROL, KBDCTRL  },
    { VK_MENU,    KBDALT   },
    { VK_KANA,    KBDKANA  },
    { 0,          0        }
};

/***************************************************************************\
* aModification[]  - map character modifier bits to modification number
*
* See kbd.h for a full description.
*
\***************************************************************************/

static ALLOC_SECTION_LDATA MODIFIERS CharModifiers = {
    &aVkToBits[0],
    11,
    {
    //  Modification# //  Keys Pressed  : Explanation
    //  ============= // ============== : =============================
        0,            //                : unshifted characters
        1,            //          SHIFT : capitals, ~!@#$%^&*()_+{}:"<>? etc.
        4,            //     CTRL       : control characters
        6,            //     CTRL SHIFT :
        SHFT_INVALID, // ALT            : invalid
        SHFT_INVALID, // ALT      SHIFT : invalid
        SHFT_INVALID, // ALT CTRL       : invalid
        SHFT_INVALID, // ALT CTRL SHIFT : invalid
        2,            //KANA
        3,            //KANA      SHIFT
        5,            //KANA CTRL
        7             //KANA CTRL SHIFT
    }
};

/***************************************************************************\
*
* aVkToWch2[]  - Virtual Key to WCHAR translation for 2 shift states
* aVkToWch3[]  - Virtual Key to WCHAR translation for 3 shift states
* aVkToWch4[]  - Virtual Key to WCHAR translation for 4 shift states
*
* Table attributes: Unordered Scan, null-terminated
*
* Search this table for an entry with a matching Virtual Key to find the
* corresponding unshifted and shifted WCHAR characters.
*
* Reserved VirtualKey values (first column)
*     -1            - this line contains dead characters (diacritic)
*     0             - terminator
*
* Reserved Attribute values (second column)
*     CAPLOK        - CapsLock affects this key like Shift
*     KANALOK       - The KANA-LOCK key affects this key like KANA
*
* Reserved character values (third through last column)
*     WCH_NONE      - No character
*     WCH_DEAD      - Dead character (diacritic) value is in next line
*
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch4[] = {
    //                               |          |   SHIFT  |  KANA  | K+SHFT |
    //                               |          |==========|========|========|
    {'0'          ,          KANALOK ,'0'       ,WCH_NONE  ,WCH_WA  ,WCH_WO  },
    {'1'          ,          KANALOK ,'1'       ,'!'       ,WCH_NU  ,WCH_NU  },
    {'3'          ,          KANALOK ,'3'       ,'#'       ,WCH_A   ,WCH_AA  },
    {'4'          ,          KANALOK ,'4'       ,'$'       ,WCH_U   ,WCH_UU  },
    {'5'          ,          KANALOK ,'5'       ,'%'       ,WCH_E   ,WCH_EE  },
    {'7'          ,          KANALOK ,'7'       ,0x27      ,WCH_YA  ,WCH_YAA },
    {'8'          ,          KANALOK ,'8'       ,'('       ,WCH_YU  ,WCH_YUU },
    {'9'          ,          KANALOK ,'9'       ,')'       ,WCH_YO  ,WCH_YOO },
    {'A'          , CAPLOK | KANALOK ,'a'       ,'A'       ,WCH_TI  ,WCH_TI  },
    {'B'          , CAPLOK | KANALOK ,'b'       ,'B'       ,WCH_KO  ,WCH_KO  },
    {'C'          , CAPLOK | KANALOK ,'c'       ,'C'       ,WCH_SO  ,WCH_SO  },
    {'D'          , CAPLOK | KANALOK ,'d'       ,'D'       ,WCH_SI  ,WCH_SI  },
    {'E'          , CAPLOK | KANALOK ,'e'       ,'E'       ,WCH_I   ,WCH_II  },
    {'F'          , CAPLOK | KANALOK ,'f'       ,'F'       ,WCH_HA  ,WCH_HA  },
    {'G'          , CAPLOK | KANALOK ,'g'       ,'G'       ,WCH_KI  ,WCH_KI  },
    {'H'          , CAPLOK | KANALOK ,'h'       ,'H'       ,WCH_KU  ,WCH_KU  },
    {'I'          , CAPLOK | KANALOK ,'i'       ,'I'       ,WCH_NI  ,WCH_NI  },
    {'J'          , CAPLOK | KANALOK ,'j'       ,'J'       ,WCH_MA  ,WCH_MA  },
    {'K'          , CAPLOK | KANALOK ,'k'       ,'K'       ,WCH_NO  ,WCH_NO  },
    {'L'          , CAPLOK | KANALOK ,'l'       ,'L'       ,WCH_RI  ,WCH_RI  },
    {'M'          , CAPLOK | KANALOK ,'m'       ,'M'       ,WCH_MO  ,WCH_MO  },
    {'N'          , CAPLOK | KANALOK ,'n'       ,'N'       ,WCH_MI  ,WCH_MI  },
    {'O'          , CAPLOK | KANALOK ,'o'       ,'O'       ,WCH_RA  ,WCH_RA  },
    {'P'          , CAPLOK | KANALOK ,'p'       ,'P'       ,WCH_SE  ,WCH_SE  },
    {'Q'          , CAPLOK | KANALOK ,'q'       ,'Q'       ,WCH_TA  ,WCH_TA  },
    {'R'          , CAPLOK | KANALOK ,'r'       ,'R'       ,WCH_SU  ,WCH_SU  },
    {'S'          , CAPLOK | KANALOK ,'s'       ,'S'       ,WCH_TO  ,WCH_TO  },
    {'T'          , CAPLOK | KANALOK ,'t'       ,'T'       ,WCH_KA  ,WCH_KA  },
    {'U'          , CAPLOK | KANALOK ,'u'       ,'U'       ,WCH_NA  ,WCH_NA  },
    {'V'          , CAPLOK | KANALOK ,'v'       ,'V'       ,WCH_HI  ,WCH_HI  },
    {'W'          , CAPLOK | KANALOK ,'w'       ,'W'       ,WCH_TE  ,WCH_TE  },
    {'X'          , CAPLOK | KANALOK ,'x'       ,'X'       ,WCH_SA  ,WCH_SA  },
    {'Y'          , CAPLOK | KANALOK ,'y'       ,'Y'       ,WCH_NN  ,WCH_NN  },
    {'Z'          , CAPLOK | KANALOK ,'z'       ,'Z'       ,WCH_TU  ,WCH_TUU },
    {VK_OEM_1     ,          KANALOK ,':'       ,'*'       ,WCH_KE  ,WCH_KE  },
    {VK_OEM_2     ,          KANALOK ,'/'       ,'?'       ,WCH_ME  ,WCH_MD  },
    {VK_OEM_3     ,          KANALOK ,'@'       ,'`'       ,WCH_VS  ,WCH_VS  },
    {VK_OEM_7     ,          KANALOK ,'^'       ,'~'       ,WCH_HE  ,WCH_HE  },
    {VK_OEM_8     , 0                ,WCH_NONE  ,WCH_NONE  ,WCH_NONE,WCH_NONE},
    {VK_OEM_COMMA ,          KANALOK ,','       ,'<'       ,WCH_NE  ,WCH_IC  },
    {VK_OEM_PERIOD,          KANALOK ,'.'       ,'>'       ,WCH_RU  ,WCH_IP  },
    {VK_OEM_PLUS  ,          KANALOK ,';'       ,'+'       ,WCH_RE  ,WCH_RE  },
    {VK_TAB       , 0                ,'\t'      ,'\t'      ,'\t'    ,'\t'    },
    {VK_ADD       , 0                ,'+'       ,'+'       ,'+'     ,'+'     },
    {VK_DECIMAL   , 0                ,'.'       ,'.'       ,'.'     ,'.'     },
    {VK_DIVIDE    , 0                ,'/'       ,'/'       ,'/'     ,'/'     },
    {VK_MULTIPLY  , 0                ,'*'       ,'*'       ,'*'     ,'*'     },
    {VK_SUBTRACT  , 0                ,'-'       ,'-'       ,'-'     ,'-'     },
    {0            , 0                ,0         ,0         ,0       ,0       }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS6 aVkToWch6[] = {
    //                      |          |   SHIFT  |  KANA  | K+SHFT |  CONTROL  |  K+CTRL   |
    //                      |          |==========|========|========|===========|===========|
    {VK_BACK      , 0       ,'\b'      ,'\b'      ,'\b'    ,'\b'    , 0x7f      , 0x7f      },
    {VK_CANCEL    , 0       ,0x03      ,0x03      ,0x03    ,0x03    , 0x03      , 0x03      },
    {VK_ESCAPE    , 0       ,0x1b      ,0x1b      ,0x1b    ,0x1b    , 0x1b      , 0x1b      },
    {VK_OEM_4     , KANALOK ,'['       ,'{'       ,WCH_SVS ,WCH_OB  , 0x1b      , 0x1b      },
    {VK_OEM_5     , KANALOK ,'\\'      ,'|'       ,WCH_PS  ,WCH_PS  , 0x1c      , 0x1c      },
    {VK_OEM_102   , KANALOK ,'\\'      ,'_'       ,WCH_RO  ,WCH_RO  , 0x1c      , 0x1c      },
    {VK_OEM_6     , KANALOK ,']'       ,'}'       ,WCH_MU  ,WCH_CB  , 0x1d      , 0x1d      },
    {VK_RETURN    , 0       ,'\r'      ,'\r'      ,'\r'    ,'\r'    , '\n'      , '\n'      },
    {VK_SPACE     , 0       ,' '       ,' '       ,' '     ,' '     , 0x20      , 0x20      },
    {0            , 0       ,0         ,0         ,0       ,0       , 0         , 0         }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS8 aVkToWch8[] = {
    //                      |          |   SHIFT  |  KANA  | K+SHFT |  CONTROL  |  K+CTRL   | SHFT+CTRL |K+SHFT+CTRL|
    //                      |          |==========|========|========|===========|===========|===========|===========|
    {'2'          , KANALOK ,'2'       ,'"'       ,WCH_HU  ,WCH_HU  , WCH_NONE  , WCH_NONE  , 0x00      , 0x00      },
    {'6'          , KANALOK ,'6'       ,'&'       ,WCH_O   ,WCH_OO  , WCH_NONE  , WCH_NONE  , 0x1e      , 0x1e      },
    {VK_OEM_MINUS , KANALOK ,'-'       ,'='       ,WCH_HO  ,WCH_HO  , WCH_NONE  , WCH_NONE  , 0x1f      , 0x1f      },
    {0            , 0       ,0         ,0         ,0       ,0       , 0         , 0         , 0         , 0         }
};

// Put this last so that VkKeyScan interprets number characters
// as coming from the main section of the kbd (aVkToWch2 and
// aVkToWch4) before considering the numpad (aVkToWch1).

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch1[] = {
    //                     |          |   SHIFT  |  KANA  | K+SHFT |
    //                     |          |==========|========|========|
    { VK_NUMPAD0   , 0      ,  '0'    , WCH_NONE ,   '0'  ,WCH_NONE},
    { VK_NUMPAD1   , 0      ,  '1'    , WCH_NONE ,   '1'  ,WCH_NONE},
    { VK_NUMPAD2   , 0      ,  '2'    , WCH_NONE ,   '2'  ,WCH_NONE},
    { VK_NUMPAD3   , 0      ,  '3'    , WCH_NONE ,   '3'  ,WCH_NONE},
    { VK_NUMPAD4   , 0      ,  '4'    , WCH_NONE ,   '4'  ,WCH_NONE},
    { VK_NUMPAD5   , 0      ,  '5'    , WCH_NONE ,   '5'  ,WCH_NONE},
    { VK_NUMPAD6   , 0      ,  '6'    , WCH_NONE ,   '6'  ,WCH_NONE},
    { VK_NUMPAD7   , 0      ,  '7'    , WCH_NONE ,   '7'  ,WCH_NONE},
    { VK_NUMPAD8   , 0      ,  '8'    , WCH_NONE ,   '8'  ,WCH_NONE},
    { VK_NUMPAD9   , 0      ,  '9'    , WCH_NONE ,   '9'  ,WCH_NONE},
    { 0            , 0      ,  '\0'   , 0        ,   0    ,0       }   //null terminator
};

/***************************************************************************\
* aVkToWcharTable: table of pointers to Character Tables
*
* Describes the character tables and the order they should be searched.
*
* Note: the order determines the behavior of VkKeyScan() : this function
*       takes a character and attempts to find a Virtual Key and character-
*       modifier key combination that produces that character.  The table
*       containing the numeric keypad (aVkToWch1) must appear last so that
*       VkKeyScan('0') will be interpreted as one of keys from the main
*       section, not the numpad.  etc.
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHAR_TABLE aVkToWcharTable[] = {
    {  (PVK_TO_WCHARS1)aVkToWch6, 6, sizeof(aVkToWch6[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch8, 8, sizeof(aVkToWch8[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch4, 4, sizeof(aVkToWch4[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch1, 4, sizeof(aVkToWch1[0]) },  // must come last
    {                       NULL, 0, 0                    }
};

/***************************************************************************\
* aKeyNames[], aKeyNamesExt[]  - Scan Code -> Key Name tables
*
* For the GetKeyNameText() API function
*
* Tables for non-extended and extended (KBDEXT) keys.
* (Keys producing printable characters are named by the character itself)
\***************************************************************************/

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNames[] = {
    0x01,    L"Esc",
    0x0e,    L"Backspace",
    0x0f,    L"Tab",
    0x1c,    L"Enter",
    0x1d,    L"Ctrl",
    0x29,    (LPWSTR)SZ_KEY_NAME_HANKAKU_ZENKAKU,  // NLS Key
    0x2a,    L"Shift",
    0x36,    L"Right Shift",
    0x37,    L"Num *",
    0x38,    L"Alt",
    0x39,    L"Space",
    0x3a,    L"Caps Lock",
    0x3b,    L"F1",
    0x3c,    L"F2",
    0x3d,    L"F3",
    0x3e,    L"F4",
    0x3f,    L"F5",
    0x40,    L"F6",
    0x41,    L"F7",
    0x42,    L"F8",
    0x43,    L"F9",
    0x44,    L"F10",
    0x45,    L"Pause",
    0x46,    L"Scroll Lock",
    0x47,    L"Num 7",
    0x48,    L"Num 8",
    0x49,    L"Num 9",
    0x4a,    L"Num -",
    0x4b,    L"Num 4",
    0x4c,    L"Num 5",
    0x4d,    L"Num 6",
    0x4e,    L"Num +",
    0x4f,    L"Num 1",
    0x50,    L"Num 2",
    0x51,    L"Num 3",
    0x52,    L"Num 0",
    0x53,    L"Num Del",
    0x54,    L"Sys Req",
    0x57,    L"F11",
    0x58,    L"F12",
    0x70,    (LPWSTR)SZ_KEY_NAME_HIRAGANA,
    0x79,    (LPWSTR)SZ_KEY_NAME_HENKAN,
    0x7b,    (LPWSTR)SZ_KEY_NAME_MUHENKAN,
    0x7C,    L"F13",
    0   ,    NULL
};

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNamesExt[] = {
    0x1c,    L"Num Enter",
    0x1d,    L"Right Control",
    0x35,    L"Num /",
    0x37,    L"Prnt Scrn",
    0x38,    L"Right Alt",
    0x45,    L"Num Lock",
    0x46,    L"Break",
    0x47,    L"Home",
    0x48,    L"Up",
    0x49,    L"Page Up",
    0x4b,    L"Left",
    0x4d,    L"Right",
    0x4f,    L"End",
    0x50,    L"Down",
    0x51,    L"Page Down",
    0x52,    L"Insert",
    0x53,    L"Delete",
    0x5B,    L"Left Windows",
    0x5C,    L"Right Windows",
    0x5D,    L"Application",
    0   ,    NULL
};

ALLOC_SECTION_LDATA KBDTABLES KbdTables106 = {
    /*
     * Modifier keys
     */
    &CharModifiers,

    /*
     * Characters tables
     */
    aVkToWcharTable,

    /*
     * Diacritics  (none for US English)
     */
    NULL,

    /*
     * Names of Keys  (no dead keys)
     */
    aKeyNames,
    aKeyNamesExt,
    NULL,

    /*
     * Scan codes to Virtual Keys
     */
    ausVK,
    sizeof(ausVK) / sizeof(ausVK[0]),
    aE0VscToVk,
    aE1VscToVk,

    /*
     * No Locale-specific special processing
     */
    0,

    /*
     * No Ligatures
     */
    0, 0, NULL,

    /*
     * Type and subtype.
     */
    KEYBOARD_TYPE_JAPAN,    // Japanese Keyboard Layout
    MAKEWORD(MICROSOFT_KBD_106_TYPE, NLSKBD_OEM_MICROSOFT),
};

PKBDTABLES KbdLayerDescriptor(VOID)
{
    return &KbdTables106;
}

/***********************************************************************\
* VkToFuncTable_106[]
*
\***********************************************************************/

static ALLOC_SECTION_LDATA VK_F VkToFuncTable_106[] = {
    {
        VK_DBE_ALPHANUMERIC,  // Base Vk
        KBDNLS_TYPE_TOGGLE,   // NLSFEProcType
        KBDNLS_INDEX_NORMAL,  // NLSFEProcCurrent
        0x02, /* 00000010 */  // NLSFEProcSwitch
        {                     // NLSFEProc
            {KBDNLS_ALPHANUM,0},               // Base
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Shift
            {KBDNLS_ALPHANUM,0},               // Control
            {KBDNLS_ALPHANUM,0},               // Shift+Control
            {KBDNLS_ALPHANUM,0},               // Alt
            {KBDNLS_ALPHANUM,0},               // Shift+Alt
            {KBDNLS_CODEINPUT,0},              // Control+Alt
            {KBDNLS_CODEINPUT,0}               // Shift+Control+Alt
        },
        {                     // NLSFEProcAlt
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Base
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Shift
            {KBDNLS_NOEVENT,0},                // Control
            {KBDNLS_NOEVENT,0},                // Shift+Control
            {KBDNLS_NOEVENT,0},                // Alt
            {KBDNLS_NOEVENT,0},                // Shift+Alt
            {KBDNLS_NOEVENT,0},                // Control+Alt
            {KBDNLS_NOEVENT,0}                 // Shift+Control+Alt
        }
    },
    {
        VK_DBE_HIRAGANA,     // Base Vk
        KBDNLS_TYPE_TOGGLE,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x08, /* 00001000 */ // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_HIRAGANA,0},             // Base
            {KBDNLS_KATAKANA,0},             // Shift
            {KBDNLS_HIRAGANA,0},             // Control
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Shift+Control
            {KBDNLS_ROMAN,0},                // Alt
            {KBDNLS_ROMAN,0},                // Shift+Alt
            {KBDNLS_ROMAN,0},                // Control+Alt
            {KBDNLS_NOEVENT,0}               // Shift+Control+Alt
        },
        {                    // NLSFEProcIndexAlt
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Base
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Shift
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Control
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Shift+Control
            {KBDNLS_NOEVENT,0},              // Alt
            {KBDNLS_NOEVENT,0},              // Shift+Alt
            {KBDNLS_NOEVENT,0},              // Control+Alt
            {KBDNLS_NOEVENT,0}               // Shift+Control+Alt
        }
    },
    {
        VK_DBE_SBCSCHAR,     // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SBCSDBCS,0},             // Base
            {KBDNLS_SBCSDBCS,0},             // Shift
            {KBDNLS_SBCSDBCS,0},             // Control
            {KBDNLS_SBCSDBCS,0},             // Shift+Control
            {KBDNLS_SEND_PARAM_VK,VK_KANJI}, // Alt
            {KBDNLS_SBCSDBCS,0},             // Shift+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}, // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}  // Shift+Control+Alt
        },
        {                    // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_NONCONVERT,       // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},         // Base
            {KBDNLS_SEND_BASE_VK,0},         // Shift
            {KBDNLS_SEND_BASE_VK,0},         // Control
            {KBDNLS_SEND_BASE_VK,0},         // Shift+Control
            {KBDNLS_SEND_BASE_VK,0},         // Alt
            {KBDNLS_SEND_BASE_VK,0},         // Shift+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}, // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}  // Shift+Control+Alt
        },
        {                         // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    }
};

/***********************************************************************\
* KbdNlsTables
*
\***********************************************************************/

ALLOC_SECTION_LDATA KBDNLSTABLES KbdNlsTables106 = {
    0,                      // OEM ID (0 = Microsoft)
    0,                      // Information
    4,                      // Number of VK_F entry
    VkToFuncTable_106,      // Pointer to VK_F array
    0,                      // Number of MouseVk entry
    NULL                    // Pointer to MouseVk array
};

//@@BEGIN_DDKSPLIT
static ALLOC_SECTION_LDATA KBDNLSTABLES KbdNlsTablesNEC98 = {
    0x0d,                   // OEM ID (0x0d = NEC)
    0,                      // Information
    4,                      // Number of VK_F entry
    VkToFuncTable_106,      // Pointer to VK_F array
    0,                      // Number of MouseVk entry
    NULL                    // Pointer to MouseVk array
};
//@@END_DDKSPLIT

PKBDNLSTABLES KbdNlsLayerDescriptor(VOID)
{
//@@BEGIN_DDKSPLIT
    if (!IsNEC_98) {
//@@END_DDKSPLIT
        return &KbdNlsTables106;
//@@BEGIN_DDKSPLIT
    } else {
        return &KbdNlsTablesNEC98;
    }
//@@END_DDKSPLIT
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\fe_kbds\jpn\101\kbd101.c ===
/***************************************************************************\
* Module Name: kbd101.c
*
* Copyright (c) 1985-2000, Microsoft Corporation
*
* History:
\***************************************************************************/

#include <windows.h>
#include "kbdjpn.h"
#include "kbd101.h"

#if defined(_M_IA64)
#pragma section(".data")
#define ALLOC_SECTION_LDATA __declspec(allocate(".data"))
#else
#pragma data_seg(".data")
#define ALLOC_SECTION_LDATA
#endif

/***************************************************************************\
* ausVK[] - Virtual Scan Code to Virtual Key conversion table for 101
\***************************************************************************/

static ALLOC_SECTION_LDATA USHORT ausVK[] = {
    T00, T01, T02, T03, T04, T05, T06, T07,
    T08, T09, T0A, T0B, T0C, T0D, T0E, T0F,
    T10, T11, T12, T13, T14, T15, T16, T17,
    T18, T19, T1A, T1B, T1C, T1D, T1E, T1F,
    T20, T21, T22, T23, T24, T25, T26, T27,
    T28,

    /*
     * '~' key must have KBDSPECIAL bit set. (NLS key)
     */
    T29 | KBDSPECIAL,

              T2A, T2B, T2C, T2D, T2E, T2F,
    T30, T31, T32, T33, T34, T35,

    /*
     * Right-hand Shift key must have KBDEXT bit set.
     */
    T36 | KBDEXT,

    /*
     * numpad_* + Shift/Alt -> SnapShot
     */
    T37 | KBDMULTIVK,

    T38, T39,

    /*
     * CapsLock key must have KBDSPECIAL bit set. (NLS key)
     */
    T3A | KBDSPECIAL,

                   T3B, T3C, T3D, T3E, T3F,
    T40, T41, T42, T43, T44,

    /*
     * NumLock Key:
     *     KBDEXT     - VK_NUMLOCK is an Extended key
     *     KBDMULTIVK - VK_NUMLOCK or VK_PAUSE (without or with CTRL)
     */
    T45 | KBDEXT | KBDMULTIVK,

    T46 | KBDMULTIVK,

    /*
     * Number Pad keys:
     *     KBDNUMPAD  - digits 0-9 and decimal point.
     *     KBDSPECIAL - require special processing by Windows
     */
    T47 | KBDNUMPAD | KBDSPECIAL,   // Numpad 7 (Home)
    T48 | KBDNUMPAD | KBDSPECIAL,   // Numpad 8 (Up),
    T49 | KBDNUMPAD | KBDSPECIAL,   // Numpad 9 (PgUp),
    T4A,
    T4B | KBDNUMPAD | KBDSPECIAL,   // Numpad 4 (Left),
    T4C | KBDNUMPAD | KBDSPECIAL,   // Numpad 5 (Clear),
    T4D | KBDNUMPAD | KBDSPECIAL,   // Numpad 6 (Right),
    T4E,
    T4F | KBDNUMPAD | KBDSPECIAL,   // Numpad 1 (End),
    T50 | KBDNUMPAD | KBDSPECIAL,   // Numpad 2 (Down),
    T51 | KBDNUMPAD | KBDSPECIAL,   // Numpad 3 (PgDn),
    T52 | KBDNUMPAD | KBDSPECIAL,   // Numpad 0 (Ins),
    T53 | KBDNUMPAD | KBDSPECIAL,   // Numpad . (Del),

    T54, T55, T56, T57, T58, T59, T5A, T5B,
    T5C, T5D, T5E, T5F, T60, T61, T62, T63,
    T64, T65, T66, T67, T68, T69, T6A, T6B,
    T6C, T6D, T6E, T6F, T70, T71, T72, T73,
    T74, T75, T76, T77, T78, T79, T7A, T7B,
    T7C, T7D, T7E, T7F

};

static ALLOC_SECTION_LDATA VSC_VK aE0VscToVk[] = {
        { 0x10, X10 | KBDEXT              },  // Speedracer: Previous Track
        { 0x19, X19 | KBDEXT              },  // Speedracer: Next Track
        { 0x1C, X1C | KBDEXT              },  // Numpad Enter
        { 0x1D, X1D | KBDEXT              },  // RControl
        { 0x20, X20 | KBDEXT              },  // Speedracer: Volume Mute
        { 0x21, X21 | KBDEXT              },  // Speedracer: Launch App 2
        { 0x22, X22 | KBDEXT              },  // Speedracer: Media Play/Pause
        { 0x24, X24 | KBDEXT              },  // Speedracer: Media Stop
        { 0x2E, X2E | KBDEXT              },  // Speedracer: Volume Down
        { 0x30, X30 | KBDEXT              },  // Speedracer: Volume Up
        { 0x32, X32 | KBDEXT              },  // Speedracer: Browser Home
        { 0x35, X35 | KBDEXT              },  // Numpad Divide
        { 0x37, X37 | KBDEXT              },  // Snapshot
        { 0x38, X38 | KBDEXT              },  // RMenu
        { 0x46, X46 | KBDEXT              },  // Break (Ctrl + Pause)
        { 0x47, X47 | KBDEXT              },  // Home
        { 0x48, X48 | KBDEXT              },  // Up
        { 0x49, X49 | KBDEXT              },  // Prior
        { 0x4B, X4B | KBDEXT              },  // Left
        { 0x4D, X4D | KBDEXT              },  // Right
        { 0x4F, X4F | KBDEXT              },  // End
        { 0x50, X50 | KBDEXT              },  // Down
        { 0x51, X51 | KBDEXT              },  // Next
        { 0x52, X52 | KBDEXT              },  // Insert
        { 0x53, X53 | KBDEXT              },  // Delete
        { 0x5B, X5B | KBDEXT              },  // Left Win
        { 0x5C, X5C | KBDEXT              },  // Right Win
        { 0x5D, X5D | KBDEXT              },  // Application
        { 0x5F, X5F | KBDEXT              },  // Speedracer: Sleep
        { 0x65, X65 | KBDEXT              },  // Speedracer: Browser Search
        { 0x66, X66 | KBDEXT              },  // Speedracer: Browser Favorites
        { 0x67, X67 | KBDEXT              },  // Speedracer: Browser Refresh
        { 0x68, X68 | KBDEXT              },  // Speedracer: Browser Stop
        { 0x69, X69 | KBDEXT              },  // Speedracer: Browser Forward
        { 0x6A, X6A | KBDEXT              },  // Speedracer: Browser Back
        { 0x6B, X6B | KBDEXT              },  // Speedracer: Launch App 1
        { 0x6C, X6C | KBDEXT              },  // Speedracer: Launch Mail
        { 0x6D, X6D | KBDEXT              },  // Speedracer: Launch Media Selector
        { 0,      0                       }
};

static ALLOC_SECTION_LDATA VSC_VK aE1VscToVk[] = {
        { 0x1D, Y1D                       },  // Pause
        { 0   ,   0                       }
};

/***************************************************************************\
* aVkToBits[]  - map Virtual Keys to Modifier Bits
*
* See kbd.h for a full description.
*
* US Keyboard has only three shifter keys:
*     SHIFT (L & R) affects alphabnumeric keys,
*     CTRL  (L & R) is used to generate control characters
*     ALT   (L & R) used for generating characters by number with numpad
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_BIT aVkToBits[] = {
    { VK_SHIFT,   KBDSHIFT },
    { VK_CONTROL, KBDCTRL  },
    { VK_MENU,    KBDALT   },
    { VK_KANA,    KBDKANA  },
    { 0,          0        }
};

/***************************************************************************\
* aModification[]  - map character modifier bits to modification number
*
* See kbd.h for a full description.
*
\***************************************************************************/

static ALLOC_SECTION_LDATA MODIFIERS CharModifiers = {
    &aVkToBits[0],
    11,
    {
    //  Modification# //  Keys Pressed  : Explanation
    //  ============= // ============== : =============================
        0,            //                : unshifted characters
        1,            //          SHIFT : capitals, ~!@#$%^&*()_+{}:"<>? etc.
        4,            //     CTRL       : control characters
        6,            //     CTRL SHIFT :
        SHFT_INVALID, // ALT            : invalid
        SHFT_INVALID, // ALT      SHIFT : invalid
        SHFT_INVALID, // ALT CTRL       : invalid
        SHFT_INVALID, // ALT CTRL SHIFT : invalid
        2,            //KANA
        3,            //KANA      SHIFT
        5,            //KANA CTRL
        7             //KANA CTRL SHIFT
    }
};

/***************************************************************************\
*
* aVkToWch2[]  - Virtual Key to WCHAR translation for 2 shift states
* aVkToWch3[]  - Virtual Key to WCHAR translation for 3 shift states
* aVkToWch4[]  - Virtual Key to WCHAR translation for 4 shift states
*
* Table attributes: Unordered Scan, null-terminated
*
* Search this table for an entry with a matching Virtual Key to find the
* corresponding unshifted and shifted WCHAR characters.
*
* Reserved VirtualKey values (first column)
*     -1            - this line contains dead characters (diacritic)
*     0             - terminator
*
* Reserved Attribute values (second column)
*     CAPLOK        - CapsLock affects this key like Shift
*     KANALOK       - The KANA-LOCK key affects this key like KANA
*
* Reserved character values (third through last column)
*     WCH_NONE      - No character
*     WCH_DEAD      - Dead character (diacritic) value is in next line
*
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch4[] = {
    //                               |          |   SHIFT  |  KANA  | K+SHFT |
    //                               |          |==========|========|========|
    {'0'          ,          KANALOK ,'0'       ,')'       ,WCH_WA  ,WCH_WO  },
    {'1'          ,          KANALOK ,'1'       ,'!'       ,WCH_NU  ,WCH_NU  },
    {'3'          ,          KANALOK ,'3'       ,'#'       ,WCH_A   ,WCH_AA  },
    {'4'          ,          KANALOK ,'4'       ,'$'       ,WCH_U   ,WCH_UU  },
    {'5'          ,          KANALOK ,'5'       ,'%'       ,WCH_E   ,WCH_EE  },
    {'7'          ,          KANALOK ,'7'       ,'&'       ,WCH_YA  ,WCH_YAA },
    {'8'          ,          KANALOK ,'8'       ,'*'       ,WCH_YU  ,WCH_YUU },
    {'9'          ,          KANALOK ,'9'       ,'('       ,WCH_YO  ,WCH_YOO },
    {'A'          , CAPLOK | KANALOK ,'a'       ,'A'       ,WCH_TI  ,WCH_TI  },
    {'B'          , CAPLOK | KANALOK ,'b'       ,'B'       ,WCH_KO  ,WCH_KO  },
    {'C'          , CAPLOK | KANALOK ,'c'       ,'C'       ,WCH_SO  ,WCH_SO  },
    {'D'          , CAPLOK | KANALOK ,'d'       ,'D'       ,WCH_SI  ,WCH_SI  },
    {'E'          , CAPLOK | KANALOK ,'e'       ,'E'       ,WCH_I   ,WCH_II  },
    {'F'          , CAPLOK | KANALOK ,'f'       ,'F'       ,WCH_HA  ,WCH_HA  },
    {'G'          , CAPLOK | KANALOK ,'g'       ,'G'       ,WCH_KI  ,WCH_KI  },
    {'H'          , CAPLOK | KANALOK ,'h'       ,'H'       ,WCH_KU  ,WCH_KU  },
    {'I'          , CAPLOK | KANALOK ,'i'       ,'I'       ,WCH_NI  ,WCH_NI  },
    {'J'          , CAPLOK | KANALOK ,'j'       ,'J'       ,WCH_MA  ,WCH_MA  },
    {'K'          , CAPLOK | KANALOK ,'k'       ,'K'       ,WCH_NO  ,WCH_NO  },
    {'L'          , CAPLOK | KANALOK ,'l'       ,'L'       ,WCH_RI  ,WCH_RI  },
    {'M'          , CAPLOK | KANALOK ,'m'       ,'M'       ,WCH_MO  ,WCH_MO  },
    {'N'          , CAPLOK | KANALOK ,'n'       ,'N'       ,WCH_MI  ,WCH_MI  },
    {'O'          , CAPLOK | KANALOK ,'o'       ,'O'       ,WCH_RA  ,WCH_RA  },
    {'P'          , CAPLOK | KANALOK ,'p'       ,'P'       ,WCH_SE  ,WCH_SE  },
    {'Q'          , CAPLOK | KANALOK ,'q'       ,'Q'       ,WCH_TA  ,WCH_TA  },
    {'R'          , CAPLOK | KANALOK ,'r'       ,'R'       ,WCH_SU  ,WCH_SU  },
    {'S'          , CAPLOK | KANALOK ,'s'       ,'S'       ,WCH_TO  ,WCH_TO  },
    {'T'          , CAPLOK | KANALOK ,'t'       ,'T'       ,WCH_KA  ,WCH_KA  },
    {'U'          , CAPLOK | KANALOK ,'u'       ,'U'       ,WCH_NA  ,WCH_NA  },
    {'V'          , CAPLOK | KANALOK ,'v'       ,'V'       ,WCH_HI  ,WCH_HI  },
    {'W'          , CAPLOK | KANALOK ,'w'       ,'W'       ,WCH_TE  ,WCH_TE  },
    {'X'          , CAPLOK | KANALOK ,'x'       ,'X'       ,WCH_SA  ,WCH_SA  },
    {'Y'          , CAPLOK | KANALOK ,'y'       ,'Y'       ,WCH_NN  ,WCH_NN  },
    {'Z'          , CAPLOK | KANALOK ,'z'       ,'Z'       ,WCH_TU  ,WCH_TUU },
    {VK_OEM_1     ,          KANALOK ,';'       ,':'       ,WCH_RE  ,WCH_RE  },
    {VK_OEM_2     ,          KANALOK ,'/'       ,'?'       ,WCH_ME  ,WCH_MD  },
    {VK_OEM_3     ,          KANALOK ,'`'       ,'~'       ,WCH_RO  ,WCH_RO  },
    {VK_OEM_7     ,          KANALOK ,0x27      ,'"'       ,WCH_KE  ,WCH_KE  },
    {VK_OEM_8     , 0                ,WCH_NONE  ,WCH_NONE  ,WCH_NONE,WCH_NONE},
    {VK_OEM_COMMA ,          KANALOK ,','       ,'<'       ,WCH_NE  ,WCH_IC  },
    {VK_OEM_PERIOD,          KANALOK ,'.'       ,'>'       ,WCH_RU  ,WCH_IP  },
    {VK_OEM_PLUS  ,          KANALOK ,'='       ,'+'       ,WCH_HE  ,WCH_HE  },
    {VK_TAB       , 0                ,'\t'      ,'\t'      ,'\t'    ,'\t'    },
    {VK_ADD       , 0                ,'+'       ,'+'       ,'+'     ,'+'     },
    {VK_DECIMAL   , 0                ,'.'       ,'.'       ,'.'     ,'.'     },
    {VK_DIVIDE    , 0                ,'/'       ,'/'       ,'/'     ,'/'     },
    {VK_MULTIPLY  , 0                ,'*'       ,'*'       ,'*'     ,'*'     },
    {VK_SUBTRACT  , 0                ,'-'       ,'-'       ,'-'     ,'-'     },
    {0            , 0                ,0         ,0         ,0       ,0       }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS6 aVkToWch6[] = {
    //                      |          |   SHIFT  |  KANA  | K+SHFT |  CONTROL  |  K+CTRL   |
    //                      |          |==========|========|========|===========|===========|
    {VK_BACK      , 0       ,'\b'      ,'\b'      ,'\b'    ,'\b'    , 0x7f      , 0x7f      },
    {VK_CANCEL    , 0       ,0x03      ,0x03      ,0x03    ,0x03    , 0x03      , 0x03      },
    {VK_ESCAPE    , 0       ,0x1b      ,0x1b      ,0x1b    ,0x1b    , 0x1b      , 0x1b      },
    {VK_OEM_4     , KANALOK ,'['       ,'{'       ,WCH_VS  ,WCH_OB  , 0x1b      , 0x1b      },
    {VK_OEM_5     , KANALOK ,'\\'      ,'|'       ,WCH_MU  ,WCH_MU  , 0x1c      , 0x1c      },
    {VK_OEM_102   , KANALOK ,'\\'      ,'|'       ,WCH_MU  ,WCH_MU  , 0x1c      , 0x1c      },
    {VK_OEM_6     , KANALOK ,']'       ,'}'       ,WCH_SVS ,WCH_CB  , 0x1d      , 0x1d      },
    {VK_RETURN    , 0       ,'\r'      ,'\r'      ,'\r'    ,'\r'    , '\n'      , '\n'      },
    {VK_SPACE     , 0       ,' '       ,' '       ,' '     ,' '     , 0x20      , 0x20      },
    {0            , 0       ,0         ,0         ,0       ,0       , 0         , 0         }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS8 aVkToWch8[] = {
    //                      |          |   SHIFT  |  KANA  | K+SHFT |  CONTROL  |  K+CTRL   | SHFT+CTRL |K+SHFT+CTRL|
    //                      |          |==========|========|========|===========|===========|===========|===========|
    {'2'          , KANALOK ,'2'       ,'@'       ,WCH_HU  ,WCH_HU  , WCH_NONE  , WCH_NONE  , 0x00      , 0x00      },
    {'6'          , KANALOK ,'6'       ,'^'       ,WCH_O   ,WCH_OO  , WCH_NONE  , WCH_NONE  , 0x1e      , 0x1e      },
    {VK_OEM_MINUS , KANALOK ,'-'       ,'_'       ,WCH_HO  ,WCH_PS  , WCH_NONE  , WCH_NONE  , 0x1f      , 0x1f      },
    {0            , 0       ,0         ,0         ,0       ,0       , 0         , 0         , 0         , 0         }
};

// Put this last so that VkKeyScan interprets number characters
// as coming from the main section of the kbd (aVkToWch2 and
// aVkToWch4) before considering the numpad (aVkToWch1).

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch1[] = {
    //                     |          |   SHIFT  |  KANA  | K+SHFT |
    //                     |          |==========|========|========|
    { VK_NUMPAD0   , 0      ,  '0'    , WCH_NONE ,   '0'  ,WCH_NONE},
    { VK_NUMPAD1   , 0      ,  '1'    , WCH_NONE ,   '1'  ,WCH_NONE},
    { VK_NUMPAD2   , 0      ,  '2'    , WCH_NONE ,   '2'  ,WCH_NONE},
    { VK_NUMPAD3   , 0      ,  '3'    , WCH_NONE ,   '3'  ,WCH_NONE},
    { VK_NUMPAD4   , 0      ,  '4'    , WCH_NONE ,   '4'  ,WCH_NONE},
    { VK_NUMPAD5   , 0      ,  '5'    , WCH_NONE ,   '5'  ,WCH_NONE},
    { VK_NUMPAD6   , 0      ,  '6'    , WCH_NONE ,   '6'  ,WCH_NONE},
    { VK_NUMPAD7   , 0      ,  '7'    , WCH_NONE ,   '7'  ,WCH_NONE},
    { VK_NUMPAD8   , 0      ,  '8'    , WCH_NONE ,   '8'  ,WCH_NONE},
    { VK_NUMPAD9   , 0      ,  '9'    , WCH_NONE ,   '9'  ,WCH_NONE},
    { 0            , 0      ,  '\0'   , 0        ,   0    ,0       }   //null terminator
};

/***************************************************************************\
* aVkToWcharTable: table of pointers to Character Tables
*
* Describes the character tables and the order they should be searched.
*
* Note: the order determines the behavior of VkKeyScan() : this function
*       takes a character and attempts to find a Virtual Key and character-
*       modifier key combination that produces that character.  The table
*       containing the numeric keypad (aVkToWch1) must appear last so that
*       VkKeyScan('0') will be interpreted as one of keys from the main
*       section, not the numpad.  etc.
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHAR_TABLE aVkToWcharTable[] = {
    {  (PVK_TO_WCHARS1)aVkToWch6, 6, sizeof(aVkToWch6[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch8, 8, sizeof(aVkToWch8[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch4, 4, sizeof(aVkToWch4[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch1, 4, sizeof(aVkToWch1[0]) },  // must come last
    {                       NULL, 0, 0                    }
};

/***************************************************************************\
* aKeyNames[], aKeyNamesExt[]  - Scan Code -> Key Name tables
*
* For the GetKeyNameText() API function
*
* Tables for non-extended and extended (KBDEXT) keys.
* (Keys producing printable characters are named by the character itself)
\***************************************************************************/

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNames[] = {
    0x01,    L"Esc",
    0x0e,    L"Backspace",
    0x0f,    L"Tab",
    0x1c,    L"Enter",
    0x1d,    L"Ctrl",
    0x2a,    L"Shift",
    0x36,    L"Right Shift",
    0x37,    L"Num *",
    0x38,    L"Alt",
    0x39,    L"Space",
    0x3a,    L"Caps Lock",
    0x3b,    L"F1",
    0x3c,    L"F2",
    0x3d,    L"F3",
    0x3e,    L"F4",
    0x3f,    L"F5",
    0x40,    L"F6",
    0x41,    L"F7",
    0x42,    L"F8",
    0x43,    L"F9",
    0x44,    L"F10",
    0x45,    L"Pause",
    0x46,    L"Scroll Lock",
    0x47,    L"Num 7",
    0x48,    L"Num 8",
    0x49,    L"Num 9",
    0x4a,    L"Num -",
    0x4b,    L"Num 4",
    0x4c,    L"Num 5",
    0x4d,    L"Num 6",
    0x4e,    L"Num +",
    0x4f,    L"Num 1",
    0x50,    L"Num 2",
    0x51,    L"Num 3",
    0x52,    L"Num 0",
    0x53,    L"Num Del",
    0x54,    L"Sys Req",
    0x57,    L"F11",
    0x58,    L"F12",
    0x7C,    L"F13",
    0x7D,    L"F14",
    0x7E,    L"F15",
    0x7F,    L"F16",
    0x80,    L"F17",
    0x81,    L"F18",
    0x82,    L"F19",
    0x83,    L"F20",
    0x84,    L"F21",
    0x85,    L"F22",
    0x86,    L"F23",
    0x87,    L"F24",
    0   ,    NULL
};

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNamesExt[] = {
    0x1c,    L"Num Enter",
    0x1d,    L"Right Control",
    0x35,    L"Num /",
    0x37,    L"Prnt Scrn",
    0x38,    L"Right Alt",
    0x45,    L"Num Lock",
    0x46,    L"Break",
    0x47,    L"Home",
    0x48,    L"Up",
    0x49,    L"Page Up",
    0x4b,    L"Left",
    0x4d,    L"Right",
    0x4f,    L"End",
    0x50,    L"Down",
    0x51,    L"Page Down",
    0x52,    L"Insert",
    0x53,    L"Delete",
    0x5B,    L"Left Windows",
    0x5C,    L"Right Windows",
    0x5D,    L"Application",
    0   ,    NULL
};

ALLOC_SECTION_LDATA KBDTABLES KbdTables101 = {
    /*
     * Modifier keys
     */
    &CharModifiers,

    /*
     * Characters tables
     */
    aVkToWcharTable,

    /*
     * Diacritics  (none for US English)
     */
    NULL,

    /*
     * Names of Keys  (no dead keys)
     */
    aKeyNames,
    aKeyNamesExt,
    NULL,

    /*
     * Scan codes to Virtual Keys
     */
    ausVK,
    sizeof(ausVK) / sizeof(ausVK[0]),
    aE0VscToVk,
    aE1VscToVk,

    /*
     * No Locale-specific special processing
     */
    0,


    /*
     * No Ligatures
     */
    0, 0, NULL,

    /*
     * Type and subtype.
     */
    KEYBOARD_TYPE_GENERIC_101,  // Generic 101
    MAKEWORD(MICROSOFT_KBD_101_TYPE, NLSKBD_OEM_MICROSOFT),
};

PKBDTABLES KbdLayerDescriptor(VOID)
{
    return &KbdTables101;
}

/***********************************************************************\
* VkToFuncTable_101[]
*
\***********************************************************************/

static ALLOC_SECTION_LDATA VK_F VkToFuncTable_101[] = {
    {
        VK_CAPITAL,                 // Base Vk
        KBDNLS_TYPE_TOGGLE,         // NLSFEProcType
        KBDNLS_INDEX_NORMAL,        // NLSFEProcCurrent
        0x08, /* 00001000 */        // NLSFEProcSwitch
        {                           // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},        // Base
            {KBDNLS_ALPHANUM,0},            // Shift
            {KBDNLS_HIRAGANA,0},            // Control
            {KBDNLS_SEND_PARAM_VK,VK_KANA}, // Shift+Control
            {KBDNLS_KATAKANA,0},            // Alt
            {KBDNLS_SEND_BASE_VK,0},        // Shift+Alt
            {KBDNLS_SEND_BASE_VK,0},        // Control+Alt
            {KBDNLS_SEND_BASE_VK,0}         // Shift+Control+Alt
        },
        {                           // NLSFEProcAlt
            {KBDNLS_SEND_PARAM_VK,VK_KANA}, // Base
            {KBDNLS_SEND_PARAM_VK,VK_KANA}, // Shift
            {KBDNLS_SEND_PARAM_VK,VK_KANA}, // Control
            {KBDNLS_SEND_PARAM_VK,VK_KANA}, // Shift+Control
            {KBDNLS_SEND_BASE_VK,0},        // Alt
            {KBDNLS_SEND_BASE_VK,0},        // Shift+Alt
            {KBDNLS_SEND_BASE_VK,0},        // Control+Alt
            {KBDNLS_SEND_BASE_VK,0}         // Shift+Control+Alt
        }
    },
    {
        VK_OEM_3,            // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0,                   // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},         // Base
            {KBDNLS_SEND_BASE_VK,0},         // Shift
            {KBDNLS_SBCSDBCS,0},             // Control
            {KBDNLS_SEND_BASE_VK,0},         // Shift+Control
            {KBDNLS_SEND_PARAM_VK,VK_KANJI}, // Alt
            {KBDNLS_SEND_BASE_VK,0},         // Shift+Alt
            {KBDNLS_SEND_BASE_VK,0},         // Control+Alt
            {KBDNLS_SEND_BASE_VK,0}          // Shift+Control+Alt
        },
        {                    // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},                 // Base
            {KBDNLS_NULL,0},                 // Shift
            {KBDNLS_NULL,0},                 // Control
            {KBDNLS_NULL,0},                 // Shift+Control
            {KBDNLS_NULL,0},                 // Alt
            {KBDNLS_NULL,0},                 // Shift+Alt
            {KBDNLS_NULL,0},                 // Control+Alt
            {KBDNLS_NULL,0}                  // Shift+Control+Alt
        }
    }
};

/***********************************************************************\
* KbdNlsTables
*
\***********************************************************************/

ALLOC_SECTION_LDATA KBDNLSTABLES KbdNlsTables101 = {
    0,                      // OEM ID (0 = Microsoft)
    0,                      // Information
    2,                      // Number of VK_F entry
    VkToFuncTable_101,      // Pointer to VK_F array
    0,                      // Number of MouseVk entry
    NULL                    // Pointer to MouseVk array
};

PKBDNLSTABLES KbdNlsLayerDescriptor(VOID)
{
    return &KbdNlsTables101;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\fe_kbds\common\fekbdcom.c ===
/***************************************************************************\
* Module Name: fekbdcom.c
* Common FE routines for stub keyboard layout DLLs
*
* Copyright (c) 1985-92, Microsoft Corporation
*
* History: Created Aug 1997 by Hiro Yamamoto
\***************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <kbd.h>

/***************************************************************************\
 * KbdLayerRealDllFile() returns the name of the real keyboard Dll
 *
 * Get Dll name from the registry
 * PATH:"\Registry\Machine\System\CurrentControlSet\Services\i8042prt\Parameters"
 * VALUE:"LayerDriver" (REG_SZ)
 *
 * kbdjpn.dll for Japanese and kbdkor.dll for Korean
\***************************************************************************/

#if 0   // FYI: old explanation
/***************************************************************************\
 * KbdLayerRealDriverFile() returns the name of the real keyboard driver
 *
 * 1) Get Path to the name of safe real driver
 * KEY: "\Registry\Machine\Hardware\DeviceMap\KeyboardPort"
 * VALUE: "\Device\KeyboardPort0" (REG_SZ) keeps path in the registry
 *   e.g. "\REGISTRY\Machine\System\ControlSet001\Services\i8042prt"
 *                                               ~~~~~~~~~~~~~~~~~~
 * 2) Create path from the results
 * "\Registry\Machine\System\CurrentControlSet" + "\Services\i8042prt"  + "\Parameters"
 *
 * 3) Get value
 * PATH: "\Registry\Machine\System\CurrentControlSet\Services\i8042prt\Parameters"
 * VALUE: "Parameters" (REG_SZ)
 *
 * NOTE: default value:
 *      "KBD101.DLL" for Japanese
 *      "KBD101A.DLL" for Korean
 *
 * kbdjpn.dll and kbdkor.dll
\***************************************************************************/
#endif


#if defined(HIRO_DBG)
#define TRACE(x)    DbgPrint x
#else
#define TRACE(x)
#endif

#ifndef ARRAY_SIZE
#define ARRAY_SIZE(x)   (sizeof((x)) / sizeof((x)[0]))
#endif

/*
 * Maximum character count
 */
#define MAXBUF_CSIZE    (256)

/*
 * Null-terminates the wchar string in pKey.
 * returns pointer to WCHAR string.
 *
 * limit: maximum BYTE SIZE
 */
__inline LPWSTR MakeString(PKEY_VALUE_FULL_INFORMATION pKey, size_t limit)
{
    LPWSTR pwszHead = (LPWSTR)((LPBYTE)pKey + pKey->DataOffset);
    LPWSTR pwszTail = (LPWSTR)((LPBYTE)pwszHead + pKey->DataLength);

    ASSERT((LPBYTE)pwszTail - (LPBYTE)pKey < (int)limit );
    *pwszTail = L'\0';

    UNREFERENCED_PARAMETER(limit);  // just in case

    return pwszHead;
}

#ifdef OBSOLETE // not needed any more
/*
 * Find L"\services" in the given str.
 * Case insensitive search.
 * To avoid the binary size increase,
 * and since we know the string we're searching only contains
 * alphabet and backslash,
 * it's safe here not to use ideal functions (tolower/toupper).
 */
WCHAR* FindServices(WCHAR* str)
{
    CONST WCHAR wszServices[] = L"\\services";

    while (*str) {
        CONST WCHAR* p1;
        CONST WCHAR* p2;
        for (p1 = str, p2 = wszServices; *p1 && *p2; ++p1, ++p2) {
            // we know p2 only contains alphabet and backslash
            if (*p2 != L'\\') {
                if ((*p1 != *p2) && (*p1 + (L'a' - L'A') != *p2)) {
                    break;
                }
            }
            else if (*p1 != L'\\') {
                break;
            }
        }
        if (*p2 == 0) {
            // we found a match !
            return str;
        }
        ++str;
    }
    return NULL;
}
#endif

BOOL GetRealDllFileNameWorker(CONST WCHAR* pwszKeyName, WCHAR* RealDllName)
{
    NTSTATUS            Status;
    HANDLE              handleService;
    BOOL                fRet = FALSE;
    UNICODE_STRING      servicePath;
    OBJECT_ATTRIBUTES   servicePathObjectAttributes;
    WCHAR               serviceRegistryPath[MAXBUF_CSIZE];

    servicePath.Buffer = serviceRegistryPath;
    servicePath.Length = 0;
    servicePath.MaximumLength = sizeof serviceRegistryPath; // byte count !

    RtlAppendUnicodeToString(&servicePath,
                             L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\i8042prt\\Parameters");

    InitializeObjectAttributes(&servicePathObjectAttributes,
                               &servicePath,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    TRACE(("Open -> '%ws'\n",servicePath.Buffer));

    Status = NtOpenKey(&handleService, KEY_READ, &servicePathObjectAttributes);

    if (NT_SUCCESS(Status)) {

        UNICODE_STRING layerName;
        WCHAR LayerDllName[MAXBUF_CSIZE];
        ULONG cbStringSize;

        RtlInitUnicodeString(&layerName, pwszKeyName);
        TRACE(("Entry name -> '%ws'\n", layerName.Buffer));

        /*
         * Get the name of the DLL based on the device name.
         */
        Status = NtQueryValueKey(handleService,
                                 &layerName,
                                 KeyValueFullInformation,
                                 LayerDllName,
                                 sizeof LayerDllName - sizeof(WCHAR),    // reserves room for L'\0'
                                 &cbStringSize);

        if (NT_SUCCESS(Status)) {
            LPWSTR pwszStr = MakeString((PKEY_VALUE_FULL_INFORMATION)LayerDllName,
                                        sizeof LayerDllName);

            wcscpy(RealDllName, pwszStr);

            TRACE(("Real Dll name -> '%ws'\n", RealDllName));

            //
            // everything went fine.
            //
            fRet = TRUE;
        }
        NtClose(handleService);
    }

    return fRet;
}

///////////////////////////////////////////////////////////////////////
// This entry is used for backward compatibility.
// Exported as ordinal 3.
///////////////////////////////////////////////////////////////////////

BOOL KbdLayerRealDllFileNT4(WCHAR *RealDllName)
{
    TRACE(("KbdLayerRealDllFile():\n"));
    return GetRealDllFileNameWorker(L"LayerDriver", RealDllName);
}

///////////////////////////////////////////////////////////////////////
// This entry is used for remote client of Hydra server.
//
// Created: 1988 kazum
///////////////////////////////////////////////////////////////////////

BOOL KbdLayerRealDllFileForWBT(HKL hkl, WCHAR *realDllName, PCLIENTKEYBOARDTYPE pClientKbdType, LPVOID reserve)
{
    HANDLE hkRegistry = NULL;
    UNICODE_STRING    deviceMapPath;
    OBJECT_ATTRIBUTES deviceMapObjectAttributes;
    NTSTATUS          Status;
    HANDLE            handleMap;
    HANDLE            handleService;
    ULONG             cbStringSize;
    PWCHAR            pwszReg;

    UNREFERENCED_PARAMETER(reserve);

    ASSERT(pClientKbdType != NULL);
    /*
     * Set default keyboard layout for error cases.
     */
    if (PRIMARYLANGID(LOWORD(hkl)) == LANG_JAPANESE) {
        wcscpy(realDllName, L"kbd101.dll");
        pwszReg = L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Terminal Server\\KeyboardType Mapping\\JPN";
    }
    else if (PRIMARYLANGID(LOWORD(hkl)) == LANG_KOREAN) {
        wcscpy(realDllName, L"kbd101a.dll");
        pwszReg = L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Terminal Server\\KeyboardType Mapping\\KOR";
    }
    else {
        ASSERT(FALSE);
    }


    /*
     * Start by opening the registry for keyboard type mapping table.
     */
    RtlInitUnicodeString(&deviceMapPath, pwszReg);

    InitializeObjectAttributes(&deviceMapObjectAttributes,
                               &deviceMapPath,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    TRACE(("Open -> %ws\n",deviceMapPath.Buffer));

    Status = NtOpenKey(&handleMap, KEY_READ, &deviceMapObjectAttributes);

    if (NT_SUCCESS(Status)) {
        WCHAR SubKbdBuffer[16];
        WCHAR FuncKeyBuffer[16];
        WCHAR SubKbdAndFuncKeyBuffer[32];
        UNICODE_STRING SubKbd = {
            0, sizeof SubKbdBuffer, SubKbdBuffer,
        };
        UNICODE_STRING FuncKbd = {
            0, sizeof FuncKeyBuffer, FuncKeyBuffer,
        };
        UNICODE_STRING SubKbdAndFuncKey = {
            0, sizeof SubKbdAndFuncKeyBuffer, SubKbdAndFuncKeyBuffer,
        };
        UCHAR AnsiBuffer[16];
        ANSI_STRING AnsiString;
        WCHAR LayerDriverName[256];

        /*
         * Convert the sub keyboard type to the Ansi string buffer.
         */
        RtlZeroMemory(AnsiBuffer, sizeof(AnsiBuffer));
        Status = RtlIntegerToChar(pClientKbdType->SubType, 16L,
                                  -8, // length of buffer, but negative means 0 padding
                                  AnsiBuffer);
        if (NT_SUCCESS(Status)) {
            /*
             * Convert the Ansi string buffer to Unicode string buffer.
             */
            AnsiString.Buffer = AnsiBuffer;
            AnsiString.MaximumLength = sizeof AnsiBuffer;
            AnsiString.Length = (USHORT)strlen(AnsiBuffer);
            Status = RtlAnsiStringToUnicodeString(&SubKbd, &AnsiString, FALSE);
        }
        ASSERT(NT_SUCCESS(Status));     // Make sure the number is not bad

        /*
         * Convert the number of function key to the Ansi string buffer.
         */
        RtlZeroMemory(AnsiBuffer, sizeof(AnsiBuffer));
        Status = RtlIntegerToChar(pClientKbdType->FunctionKey, 10L,
                                  -4, // length of buffer, but negative means 0 padding
                                  AnsiBuffer);
        if (NT_SUCCESS(Status)) {
            /*
             * Convert the Ansi string buffer to Unicode string buffer.
             */
            AnsiString.Buffer = AnsiBuffer;
            AnsiString.MaximumLength = sizeof AnsiBuffer;
            AnsiString.Length = (USHORT)strlen(AnsiBuffer);
            Status = RtlAnsiStringToUnicodeString(&FuncKbd, &AnsiString, FALSE);
        }
        ASSERT(NT_SUCCESS(Status));  // Make sure the number is not bad


        /*
         * Get the sub kbd + function key layout name
         */
        RtlCopyUnicodeString(&SubKbdAndFuncKey, &SubKbd);
        RtlAppendUnicodeStringToString(&SubKbdAndFuncKey, &FuncKbd);
        Status = NtQueryValueKey(handleMap,
                                 &SubKbdAndFuncKey,
                                 KeyValueFullInformation,
                                 LayerDriverName,
                                 sizeof(LayerDriverName),
                                 &cbStringSize);

        if (NT_SUCCESS(Status)) {

            LayerDriverName[cbStringSize / sizeof(WCHAR)] = L'\0';

            wcscpy(realDllName,
                   (LPWSTR)((PUCHAR)LayerDriverName +
                            ((PKEY_VALUE_FULL_INFORMATION)LayerDriverName)->DataOffset));

            TRACE(("Real driver name -> %ws\n",realDllName));
        }
        else {
            /*
             * Get the sub kbd layout name
             */
            Status = NtQueryValueKey(handleMap,
                                     &SubKbd,
                                     KeyValueFullInformation,
                                     LayerDriverName,
                                     sizeof(LayerDriverName),
                                     &cbStringSize);

            if (NT_SUCCESS(Status)) {

                LayerDriverName[cbStringSize / sizeof(WCHAR)] = L'\0';

                wcscpy(realDllName,
                       (LPWSTR)((PUCHAR)LayerDriverName +
                                ((PKEY_VALUE_FULL_INFORMATION)LayerDriverName)->DataOffset));

                TRACE(("Real driver name -> %ws\n",realDllName));
            }
        }

        NtClose(handleMap);
    }

    return TRUE;
}


__inline WCHAR* wszcpy(WCHAR* target, CONST WCHAR* src)
{
    while (*target++ = *src++);
    return target - 1;
}


///////////////////////////////////////////////////////////////////////
// KbdLayerRealDllFile
//
// Enhanced version of KbdLayerRealDllFile:
// Distinguishes KOR and JPN.
///////////////////////////////////////////////////////////////////////

BOOL KbdLayerRealDllFile(HKL hkl, WCHAR *realDllName, PCLIENTKEYBOARDTYPE pClientKbdType, LPVOID reserve)
{
    WCHAR pwszBuff[32];
    WCHAR* pwszTail;
    LPCWSTR pwsz;

    ASSERT(PRIMARYLANGID(LOWORD(hkl)) == LANG_JAPANESE ||
           PRIMARYLANGID(LOWORD(hkl)) == LANG_KOREAN);

    if (pClientKbdType != NULL) {
        //
        // HYDRA case
        //
        return KbdLayerRealDllFileForWBT(hkl, realDllName, pClientKbdType, reserve);
    }

    if (PRIMARYLANGID(LOWORD(hkl)) == LANG_JAPANESE) {
        pwsz = L" JPN";
    }
    else if (PRIMARYLANGID(LOWORD(hkl)) == LANG_KOREAN) {
        pwsz = L" KOR";
    }
    else {
        pwsz = L"";
    }

    pwszTail = wszcpy(pwszBuff, L"LayerDriver");
    if (*pwsz) {
        wszcpy(pwszTail, pwsz);
    }

    TRACE(("KbdLayerRealDllFileEx: fetching '%S'\n", pwszBuff));

    return GetRealDllFileNameWorker(pwszBuff, realDllName);
}

///////////////////////////////////////////////////////////////////////
// EnumDyanmicLayoutSwitchingLayouts
//
//
// The form of each entry is:
// name: filename of DLL without the directory path
//   to reserve a room for the future expansion, dll name can have
//   qualifier after the ",".  A string after the comma will be ignored.
//   as of Whistler, qualifier is not really effective yet.
// value: KBD_TYPE_INFO.
//   version, XXXXXXXX,YYYYYYYY
//      version is 0, in DWORD
//      XX.. is the keyboard type, in DWORD
//      YY.. is the keyboard subtype, in DWORD
///////////////////////////////////////////////////////////////////////

#define DIGITS_PER_BYTE (2)

BOOL UnpackDynamicLayoutInformation(PKBDTABLE_MULTI pKbdTableMulti, PKEY_VALUE_FULL_INFORMATION pKeyValueFullInformation)
{
    PKBDTABLE_DESC pKbdTableDesc = &pKbdTableMulti->aKbdTables[pKbdTableMulti->nTables];
    PKBD_TYPE_INFO pKbdTypeInfo;
    LPWSTR pwstrStop;

    /*
     * Validate the registry entry name, i.e. DLL name.
     */
    if (pKeyValueFullInformation->NameLength >= sizeof(pKbdTableDesc->wszDllName)) {
        TRACE(("UnpackDynamicLayoutInformation: too long DLL name %d\n", pKeyValueFullInformation->NameLength / sizeof(WCHAR)));
        return FALSE;
    }

    /*
     * Validate the data field.
     */
    if (pKeyValueFullInformation->DataLength != sizeof(KBD_TYPE_INFO)) {
        TRACE(("UnpackDynamicLayoutInformation: invalid data length %d for %.*ws\n",
               pKeyValueFullInformation->DataLength, pKeyValueFullInformation->NameLength / sizeof(WCHAR), pKeyValueFullInformation->Name));
        return FALSE;
    }

    /*
     * Retrieve the DLL name.
     */
    wcsncpy(pKbdTableDesc->wszDllName, pKeyValueFullInformation->Name, pKeyValueFullInformation->NameLength / sizeof(WCHAR));
    /*
     * Make sure it's NULL terminated.
     */
    pKbdTableDesc->wszDllName[ARRAY_SIZE(pKbdTableDesc->wszDllName) - 1] = L'\0';

    /*
     * Cut out the qualifier.
     */
    if ((pwstrStop = wcschr(pKbdTableDesc->wszDllName, L',')) != NULL) {
        /*
         * Allow additional information after ','
         */
        *pwstrStop = L'\0';
    }

    /*
     * Retrieve the type and the subtype (combined with OEMID)
     */
    pKbdTypeInfo = (PKBD_TYPE_INFO)((LPBYTE)pKeyValueFullInformation + pKeyValueFullInformation->DataOffset);
    if (pKbdTypeInfo->dwVersion != 0) {
        TRACE(("UnpackDynamicLayoutInformation: unrecognized version %d\n", pKbdTypeInfo->dwVersion));
        return FALSE;
    }

    pKbdTableDesc->dwType = pKbdTypeInfo->dwType;
    pKbdTableDesc->dwSubType = pKbdTypeInfo->dwSubType;

    TRACE((" - UnpackDynamicLayoutInformation: \"%ws\" = (%x,%x)\n", pKbdTableDesc->wszDllName,
           pKbdTableDesc->dwType, pKbdTableDesc->dwSubType));

    return TRUE;
}

BOOL EnumDynamicSwitchingLayouts(LPCWSTR lpwszBaseDll, PKBDTABLE_MULTI pKbdTableMulti)
{
    WCHAR wszKeyName[MAX_PATH];
    UNICODE_STRING strKeyName = {
        0, sizeof wszKeyName, wszKeyName,
    };
    UNICODE_STRING strBaseDll, strTmp;
    HANDLE hKey;
    OBJECT_ATTRIBUTES oaKey;
    NTSTATUS Status;

#if DBG
    /*
     * Validate the arguments
     */
    if (lpwszBaseDll == NULL || *lpwszBaseDll == L'\0' || pKbdTableMulti == NULL) {
        TRACE(("EnumDynamicSwitchingLayouts: invalid argument!\n"));
        return FALSE;
    }
#endif

    /*
     * Make full key name.
     */
    RtlInitUnicodeString(&strTmp, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Keyboard Layout\\Dynamic Tables\\");
    RtlCopyUnicodeString(&strKeyName, &strTmp);
    RtlInitUnicodeString(&strBaseDll, lpwszBaseDll);
    RtlAppendUnicodeStringToString(&strKeyName, &strBaseDll);

    TRACE(("EnumDynamicSwitchingLayouts: key name=\"%.*ws\"\n", strKeyName.Length, strKeyName.Buffer));

    /*
     * Open the key to read the setting from.
     */
    InitializeObjectAttributes(&oaKey,
                               &strKeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);
    Status = NtOpenKey(&hKey, KEY_READ, &oaKey);
    if (!NT_SUCCESS(Status)) {
        TRACE(("EnumDynamicSwitchingLayouts: failed to open the top key.\n"));
        return FALSE;
    }

    for (pKbdTableMulti->nTables = 0; pKbdTableMulti->nTables < ARRAY_SIZE(pKbdTableMulti->aKbdTables); ++pKbdTableMulti->nTables) {
        ULONG uResultLength;
        WCHAR buffer[512];
        PKEY_VALUE_FULL_INFORMATION pKeyValueFullInformation = (PKEY_VALUE_FULL_INFORMATION)buffer;

        Status = NtEnumerateValueKey(hKey, pKbdTableMulti->nTables, KeyValueFullInformation, pKeyValueFullInformation, sizeof buffer, &uResultLength);
        if (!NT_SUCCESS(Status)) {
            break;
        }

        if (!UnpackDynamicLayoutInformation(pKbdTableMulti, pKeyValueFullInformation)) {
            /*
             * If unpacking fails, we'll abort the whole registry stuff and will use
             * the default layout table.
             */
            pKbdTableMulti->nTables = 0;
            break;
        }
    }

    NtClose(hKey);

    if (pKbdTableMulti->nTables == 0) {
        /*
         * If there wasn't any entry, tell the caller so.
         */
        TRACE(("EnumDynamicSwitchingLayouts: there was no entry.\n"));
        return FALSE;
    }

    TRACE(("EnumDynamicSwitchingLayouts: %d entries found.\n", pKbdTableMulti->nTables));

#if DBG
    {
        UINT i;

        for (i = 0; i < pKbdTableMulti->nTables; ++i) {
            TRACE(("EnumDynamicSwitchingLayouts: [%d] \"%ws\"\n", i, pKbdTableMulti->aKbdTables[i].wszDllName));
        }
    }
#endif

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\fe_kbds\jpn\106\kbd106.h ===
/****************************** Module Header ******************************\
* Module Name: kbd106.h
*
* Copyright (c) 1985-2000, Microsoft Corporation
*
* Various defines for use by keyboard input code.
*
* History:
\***************************************************************************/

/*
 * kbd type should be controlled by cl command-line argument
 */
#define KBD_TYPE 8

/*
 * Include the basis of all keyboard table values
 */
#include "kbd.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\fe_kbds\jpn\106n\kbd106n.h ===
/****************************** Module Header ******************************\
* Module Name: kbd106n.h
*
* Copyright (c) 1985-91, Microsoft Corporation
*
* Various defines for use by keyboard input code.
*
* History:
\***************************************************************************/

/*
 * kbd type should be controlled by cl command-line argument
 */
#define KBD_TYPE 8

/*
 * Include the basis of all keyboard table values
 */
#include "kbd.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\fe_kbds\jpn\ax2\kbdax2.h ===
/****************************** Module Header ******************************\
* Module Name: kbdax2.h
*
* Copyright (c) 1985-91, Microsoft Corporation
*
* Various defines for use by keyboard input code.
*
* History:
\***************************************************************************/

/*
 * kbd type should be controlled by cl command-line argument
 */
#define KBD_TYPE 16

/*
 * Include the basis of all keyboard table values
 */
#include "kbd.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\fe_kbds\jpn\ax2\sources.inc ===
!IF 0

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


!ENDIF

MINORCOMP=kbdax2

!include ..\..\japan.inc

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\fe_kbds\jpn\106\sources.inc ===
!IF 0

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


!ENDIF

MINORCOMP=kbd106

!include ..\..\japan.inc

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\fe_kbds\jpn\106n\kbd106n.c ===
/***************************************************************************\
* Module Name: kbd106.c
*
* Copyright (c) 1985-92, Microsoft Corporation
*
* History:
\***************************************************************************/

#include <windows.h>
#include <ime.h>
#include "vkoem.h"
#include "kbdjpn.h"
#include "kbd106n.h"

#if defined(_M_IA64)
#pragma section(".data")
#define ALLOC_SECTION_LDATA __declspec(allocate(".data"))
#else
#pragma data_seg(".data")
#define ALLOC_SECTION_LDATA
#endif

/***************************************************************************\
* ausVK[] - Virtual Scan Code to Virtual Key conversion table for 106
\***************************************************************************/

static ALLOC_SECTION_LDATA USHORT ausVK[] = {
    T00, T01, T02, T03, T04, T05, T06, T07,
    T08, T09, T0A, T0B, T0C, T0D, T0E, T0F,
    T10, T11, T12, T13, T14, T15, T16, T17,
    T18, T19, T1A, T1B, T1C, T1D, T1E, T1F,
    T20, T21, T22, T23, T24, T25, T26, T27,
    T28,

    /*
     * Hankaku/Zenkaku/Kanji key must have KBDSPECIAL bit set (NLS key)
     */
    T29 | KBDSPECIAL,

              T2A, T2B, T2C, T2D, T2E, T2F,
    T30, T31, T32, T33, T34, T35,

    /*
     * Right-hand Shift key must have KBDEXT bit set.
     */
    T36 | KBDEXT,

    /*
     * numpad_* + Shift/Alt -> SnapShot
     */
    T37 | KBDMULTIVK,

    T38, T39,

    /*
     * Alphanumeric/CapsLock key must have KBDSPECIAL bit set (NLS key)
     */
    T3A | KBDSPECIAL,

                   T3B, T3C, T3D, T3E, T3F,
    T40, T41, T42, T43, T44,

    /*
     * NumLock Key:
     *     KBDEXT     - VK_NUMLOCK is an Extended key
     *     KBDMULTIVK - VK_NUMLOCK or VK_PAUSE (without or with CTRL)
     */
    T45 | KBDEXT | KBDMULTIVK,

    T46 | KBDMULTIVK,

    /*
     * Number Pad keys:
     *     KBDNUMPAD  - digits 0-9 and decimal point.
     *     KBDSPECIAL - require special processing by Windows
     */
    T47 | KBDNUMPAD | KBDSPECIAL,   // Numpad 7 (Home)
    T48 | KBDNUMPAD | KBDSPECIAL,   // Numpad 8 (Up),
    T49 | KBDNUMPAD | KBDSPECIAL,   // Numpad 9 (PgUp),
    T4A,
    T4B | KBDNUMPAD | KBDSPECIAL,   // Numpad 4 (Left),
    T4C | KBDNUMPAD | KBDSPECIAL,   // Numpad 5 (Clear),
    T4D | KBDNUMPAD | KBDSPECIAL,   // Numpad 6 (Right),
    T4E,
    T4F | KBDNUMPAD | KBDSPECIAL,   // Numpad 1 (End),
    T50 | KBDNUMPAD | KBDSPECIAL,   // Numpad 2 (Down),
    T51 | KBDNUMPAD | KBDSPECIAL,   // Numpad 3 (PgDn),
    T52 | KBDNUMPAD | KBDSPECIAL,   // Numpad 0 (Ins),
    T53 | KBDNUMPAD | KBDSPECIAL,   // Numpad . (Del),

    T54, T55, T56, T57, T58, T59, T5A, T5B,
    T5C, T5D, T5E, T5F, T60, T61, T62, T63,
    T64, T65, T66, T67, T68, T69, T6A, T6B,
    T6C, T6D, T6E, T6F,

    /*
     * Hiragana/Katakana/Roman key must have KBDSPECIAL bit set (NLS key)
     */
    T70 | KBDSPECIAL,

                             T71, T72, T73,
    T74, T75, T76, T77, T78,

    /*
     * Conversion key must have KBDSPECIAL bit set (NLS key)
     */
    T79 | KBDSPECIAL,

                                  T7A,

    /*
     * Non-Conversion key must have KBDSPECIAL bit set (NLS key)
     */
    T7B | KBDSPECIAL,

    T7C, T7D, T7E, T7F

};

static ALLOC_SECTION_LDATA VSC_VK aE0VscToVk[] = {
        { 0x10, X10 | KBDEXT              },  // Speedracer: Previous Track
        { 0x19, X19 | KBDEXT              },  // Speedracer: Next Track
        { 0x1C, X1C | KBDEXT              },  // Numpad Enter
        { 0x1D, X1D | KBDEXT              },  // RControl
        { 0x20, X20 | KBDEXT              },  // Speedracer: Volume Mute
        { 0x21, X21 | KBDEXT              },  // Speedracer: Launch App 2
        { 0x22, X22 | KBDEXT              },  // Speedracer: Media Play/Pause
        { 0x24, X24 | KBDEXT              },  // Speedracer: Media Stop
        { 0x2E, X2E | KBDEXT              },  // Speedracer: Volume Down
        { 0x30, X30 | KBDEXT              },  // Speedracer: Volume Up
        { 0x32, X32 | KBDEXT              },  // Speedracer: Browser Home
        { 0x35, X35 | KBDEXT              },  // Numpad Divide
        { 0x37, X37 | KBDEXT              },  // Snapshot
        { 0x38, X38 | KBDEXT              },  // RMenu
        { 0x46, X46 | KBDEXT              },  // Break (Ctrl + Pause)
        { 0x47, X47 | KBDEXT              },  // Home
        { 0x48, X48 | KBDEXT              },  // Up
        { 0x49, X49 | KBDEXT              },  // Prior
        { 0x4B, X4B | KBDEXT              },  // Left
        { 0x4D, X4D | KBDEXT              },  // Right
        { 0x4F, X4F | KBDEXT              },  // End
        { 0x50, X50 | KBDEXT              },  // Down
        { 0x51, X51 | KBDEXT              },  // Next
        { 0x52, X52 | KBDEXT              },  // Insert
        { 0x53, X53 | KBDEXT              },  // Delete
        { 0x5B, X5B | KBDEXT              },  // Left Win
        { 0x5C, X5C | KBDEXT              },  // Right Win
        { 0x5D, X5D | KBDEXT              },  // Application
        { 0x5F, X5F | KBDEXT              },  // Speedracer: Sleep
        { 0x65, X65 | KBDEXT              },  // Speedracer: Browser Search
        { 0x66, X66 | KBDEXT              },  // Speedracer: Browser Favorites
        { 0x67, X67 | KBDEXT              },  // Speedracer: Browser Refresh
        { 0x68, X68 | KBDEXT              },  // Speedracer: Browser Stop
        { 0x69, X69 | KBDEXT              },  // Speedracer: Browser Forward
        { 0x6A, X6A | KBDEXT              },  // Speedracer: Browser Back
        { 0x6B, X6B | KBDEXT              },  // Speedracer: Launch App 1
        { 0x6C, X6C | KBDEXT              },  // Speedracer: Launch Mail
        { 0x6D, X6D | KBDEXT              },  // Speedracer: Launch Media Selector
        { 0,      0                       }
};

static ALLOC_SECTION_LDATA VSC_VK aE1VscToVk[] = {
        { 0x1D, Y1D                       },  // Pause
        { 0   ,   0                       }
};

/***************************************************************************\
* aVkToBits[]  - map Virtual Keys to Modifier Bits
*
* See kbd.h for a full description.
*
* US Keyboard has only three shifter keys:
*     SHIFT (L & R) affects alphabnumeric keys,
*     CTRL  (L & R) is used to generate control characters
*     ALT   (L & R) used for generating characters by number with numpad
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_BIT aVkToBits[] = {
    { VK_SHIFT,   KBDSHIFT },
    { VK_CONTROL, KBDCTRL  },
    { VK_MENU,    KBDALT   },
    { VK_KANA,    KBDKANA  },
    { 0,          0        }
};

/***************************************************************************\
* aModification[]  - map character modifier bits to modification number
*
* See kbd.h for a full description.
*
\***************************************************************************/

static ALLOC_SECTION_LDATA MODIFIERS CharModifiers = {
    &aVkToBits[0],
    11,
    {
    //  Modification# //  Keys Pressed  : Explanation
    //  ============= // ============== : =============================
        0,            //                : unshifted characters
        1,            //          SHIFT : capitals, ~!@#$%^&*()_+{}:"<>? etc.
        4,            //     CTRL       : control characters
        6,            //     CTRL SHIFT :
        SHFT_INVALID, // ALT            : invalid
        SHFT_INVALID, // ALT      SHIFT : invalid
        SHFT_INVALID, // ALT CTRL       : invalid
        SHFT_INVALID, // ALT CTRL SHIFT : invalid
        2,            //KANA
        3,            //KANA      SHIFT
        5,            //KANA CTRL
        7             //KANA CTRL SHIFT
    }
};

/***************************************************************************\
*
* aVkToWch2[]  - Virtual Key to WCHAR translation for 2 shift states
* aVkToWch3[]  - Virtual Key to WCHAR translation for 3 shift states
* aVkToWch4[]  - Virtual Key to WCHAR translation for 4 shift states
*
* Table attributes: Unordered Scan, null-terminated
*
* Search this table for an entry with a matching Virtual Key to find the
* corresponding unshifted and shifted WCHAR characters.
*
* Reserved VirtualKey values (first column)
*     -1            - this line contains dead characters (diacritic)
*     0             - terminator
*
* Reserved Attribute values (second column)
*     CAPLOK        - CapsLock affects this key like Shift
*     KANALOK       - The KANA-LOCK key affects this key like KANA
*
* Reserved character values (third through last column)
*     WCH_NONE      - No character
*     WCH_DEAD      - Dead character (diacritic) value is in next line
*
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch4[] = {
    //                               |          |   SHIFT  |  KANA  | K+SHFT |
    //                               |          |==========|========|========|
    {'0'          ,          KANALOK ,'0'       ,WCH_NONE  ,WCH_WA  ,WCH_WO  },
    {'1'          ,          KANALOK ,'1'       ,'!'       ,WCH_NU  ,WCH_NU  },
    {'3'          ,          KANALOK ,'3'       ,'#'       ,WCH_A   ,WCH_AA  },
    {'4'          ,          KANALOK ,'4'       ,'$'       ,WCH_U   ,WCH_UU  },
    {'5'          ,          KANALOK ,'5'       ,'%'       ,WCH_E   ,WCH_EE  },
    {'7'          ,          KANALOK ,'7'       ,0x27      ,WCH_YA  ,WCH_YAA },
    {'8'          ,          KANALOK ,'8'       ,'('       ,WCH_YU  ,WCH_YUU },
    {'9'          ,          KANALOK ,'9'       ,')'       ,WCH_YO  ,WCH_YOO },
    {'A'          , CAPLOK | KANALOK ,'a'       ,'A'       ,WCH_TI  ,WCH_TI  },
    {'B'          , CAPLOK | KANALOK ,'b'       ,'B'       ,WCH_KO  ,WCH_KO  },
    {'C'          , CAPLOK | KANALOK ,'c'       ,'C'       ,WCH_SO  ,WCH_SO  },
    {'D'          , CAPLOK | KANALOK ,'d'       ,'D'       ,WCH_SI  ,WCH_SI  },
    {'E'          , CAPLOK | KANALOK ,'e'       ,'E'       ,WCH_I   ,WCH_II  },
    {'F'          , CAPLOK | KANALOK ,'f'       ,'F'       ,WCH_HA  ,WCH_HA  },
    {'G'          , CAPLOK | KANALOK ,'g'       ,'G'       ,WCH_KI  ,WCH_KI  },
    {'H'          , CAPLOK | KANALOK ,'h'       ,'H'       ,WCH_KU  ,WCH_KU  },
    {'I'          , CAPLOK | KANALOK ,'i'       ,'I'       ,WCH_NI  ,WCH_NI  },
    {'J'          , CAPLOK | KANALOK ,'j'       ,'J'       ,WCH_MA  ,WCH_MA  },
    {'K'          , CAPLOK | KANALOK ,'k'       ,'K'       ,WCH_NO  ,WCH_NO  },
    {'L'          , CAPLOK | KANALOK ,'l'       ,'L'       ,WCH_RI  ,WCH_RI  },
    {'M'          , CAPLOK | KANALOK ,'m'       ,'M'       ,WCH_MO  ,WCH_MO  },
    {'N'          , CAPLOK | KANALOK ,'n'       ,'N'       ,WCH_MI  ,WCH_MI  },
    {'O'          , CAPLOK | KANALOK ,'o'       ,'O'       ,WCH_RA  ,WCH_RA  },
    {'P'          , CAPLOK | KANALOK ,'p'       ,'P'       ,WCH_SE  ,WCH_SE  },
    {'Q'          , CAPLOK | KANALOK ,'q'       ,'Q'       ,WCH_TA  ,WCH_TA  },
    {'R'          , CAPLOK | KANALOK ,'r'       ,'R'       ,WCH_SU  ,WCH_SU  },
    {'S'          , CAPLOK | KANALOK ,'s'       ,'S'       ,WCH_TO  ,WCH_TO  },
    {'T'          , CAPLOK | KANALOK ,'t'       ,'T'       ,WCH_KA  ,WCH_KA  },
    {'U'          , CAPLOK | KANALOK ,'u'       ,'U'       ,WCH_NA  ,WCH_NA  },
    {'V'          , CAPLOK | KANALOK ,'v'       ,'V'       ,WCH_HI  ,WCH_HI  },
    {'W'          , CAPLOK | KANALOK ,'w'       ,'W'       ,WCH_TE  ,WCH_TE  },
    {'X'          , CAPLOK | KANALOK ,'x'       ,'X'       ,WCH_SA  ,WCH_SA  },
    {'Y'          , CAPLOK | KANALOK ,'y'       ,'Y'       ,WCH_NN  ,WCH_NN  },
    {'Z'          , CAPLOK | KANALOK ,'z'       ,'Z'       ,WCH_TU  ,WCH_TUU },
    {VK_OEM_1     ,          KANALOK ,':'       ,'*'       ,WCH_KE  ,WCH_KE  },
    {VK_OEM_2     ,          KANALOK ,'/'       ,'?'       ,WCH_ME  ,WCH_MD  },
    {VK_OEM_3     ,          KANALOK ,'@'       ,'`'       ,WCH_VS  ,WCH_VS  },
    {VK_OEM_7     ,          KANALOK ,'^'       ,'~'       ,WCH_HE  ,WCH_HE  },
    {VK_OEM_8     , 0                ,','       ,','       ,','     ,','     },
    {VK_OEM_COMMA ,          KANALOK ,','       ,'<'       ,WCH_NE  ,WCH_IC  },
    {VK_OEM_PERIOD,          KANALOK ,'.'       ,'>'       ,WCH_RU  ,WCH_IP  },
    {VK_OEM_PLUS  ,          KANALOK ,';'       ,'+'       ,WCH_RE  ,WCH_RE  },
    {VK_TAB       , 0                ,'\t'      ,'\t'      ,'\t'    ,'\t'    },
    {VK_ADD       , 0                ,'+'       ,'+'       ,'+'     ,'+'     },
    {VK_DECIMAL   , 0                ,'.'       ,'.'       ,'.'     ,'.'     },
    {VK_DIVIDE    , 0                ,'/'       ,'/'       ,'/'     ,'/'     },
    {VK_MULTIPLY  , 0                ,'*'       ,'*'       ,'*'     ,'*'     },
    {VK_SUBTRACT  , 0                ,'-'       ,'-'       ,'-'     ,'-'     },
    {0            , 0                ,0         ,0         ,0       ,0       }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS6 aVkToWch6[] = {
    //                      |          |   SHIFT  |  KANA  | K+SHFT |  CONTROL  |  K+CTRL   |
    //                      |          |==========|========|========|===========|===========|
    {VK_BACK      , 0       ,'\b'      ,'\b'      ,'\b'    ,'\b'    , 0x7f      , 0x7f      },
    {VK_CANCEL    , 0       ,0x03      ,0x03      ,0x03    ,0x03    , 0x03      , 0x03      },
    {VK_ESCAPE    , 0       ,0x1b      ,0x1b      ,0x1b    ,0x1b    , 0x1b      , 0x1b      },
    {VK_OEM_4     , KANALOK ,'['       ,'{'       ,WCH_SVS ,WCH_OB  , 0x1b      , 0x1b      },
    {VK_OEM_5     , KANALOK ,'\\'      ,'|'       ,WCH_PS  ,WCH_PS  , 0x1c      , 0x1c      },
    {VK_OEM_102   , KANALOK ,'\\'      ,'_'       ,WCH_RO  ,WCH_RO  , 0x1c      , 0x1c      },
    {VK_OEM_6     , KANALOK ,']'       ,'}'       ,WCH_MU  ,WCH_CB  , 0x1d      , 0x1d      },
    {VK_RETURN    , 0       ,'\r'      ,'\r'      ,'\r'    ,'\r'    , '\n'      , '\n'      },
    {VK_SPACE     , 0       ,' '       ,' '       ,' '     ,' '     , 0x20      , 0x20      },
    {0            , 0       ,0         ,0         ,0       ,0       , 0         , 0         }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS8 aVkToWch8[] = {
    //                      |          |   SHIFT  |  KANA  | K+SHFT |  CONTROL  |  K+CTRL   | SHFT+CTRL |K+SHFT+CTRL|
    //                      |          |==========|========|========|===========|===========|===========|===========|
    {'2'          , KANALOK ,'2'       ,'"'       ,WCH_HU  ,WCH_HU  , WCH_NONE  , WCH_NONE  , 0x00      , 0x00      },
    {'6'          , KANALOK ,'6'       ,'&'       ,WCH_O   ,WCH_OO  , WCH_NONE  , WCH_NONE  , 0x1e      , 0x1e      },
    {VK_OEM_MINUS , KANALOK ,'-'       ,'='       ,WCH_HO  ,WCH_HO  , WCH_NONE  , WCH_NONE  , 0x1f      , 0x1f      },
    {0            , 0       ,0         ,0         ,0       ,0       , 0         , 0         , 0         , 0         }
};

// Put this last so that VkKeyScan interprets number characters
// as coming from the main section of the kbd (aVkToWch2 and
// aVkToWch4) before considering the numpad (aVkToWch1).

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch1[] = {
    //                     |          |   SHIFT  |  KANA  | K+SHFT |
    //                     |          |==========|========|========|
    { VK_NUMPAD0   , 0      ,  '0'    , WCH_NONE ,   '0'  ,WCH_NONE},
    { VK_NUMPAD1   , 0      ,  '1'    , WCH_NONE ,   '1'  ,WCH_NONE},
    { VK_NUMPAD2   , 0      ,  '2'    , WCH_NONE ,   '2'  ,WCH_NONE},
    { VK_NUMPAD3   , 0      ,  '3'    , WCH_NONE ,   '3'  ,WCH_NONE},
    { VK_NUMPAD4   , 0      ,  '4'    , WCH_NONE ,   '4'  ,WCH_NONE},
    { VK_NUMPAD5   , 0      ,  '5'    , WCH_NONE ,   '5'  ,WCH_NONE},
    { VK_NUMPAD6   , 0      ,  '6'    , WCH_NONE ,   '6'  ,WCH_NONE},
    { VK_NUMPAD7   , 0      ,  '7'    , WCH_NONE ,   '7'  ,WCH_NONE},
    { VK_NUMPAD8   , 0      ,  '8'    , WCH_NONE ,   '8'  ,WCH_NONE},
    { VK_NUMPAD9   , 0      ,  '9'    , WCH_NONE ,   '9'  ,WCH_NONE},
    { 0            , 0      ,  '\0'   , 0        ,   0    ,0       }   //null terminator
};

/***************************************************************************\
* aVkToWcharTable: table of pointers to Character Tables
*
* Describes the character tables and the order they should be searched.
*
* Note: the order determines the behavior of VkKeyScan() : this function
*       takes a character and attempts to find a Virtual Key and character-
*       modifier key combination that produces that character.  The table
*       containing the numeric keypad (aVkToWch1) must appear last so that
*       VkKeyScan('0') will be interpreted as one of keys from the main
*       section, not the numpad.  etc.
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHAR_TABLE aVkToWcharTable[] = {
    {  (PVK_TO_WCHARS1)aVkToWch6, 6, sizeof(aVkToWch6[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch8, 8, sizeof(aVkToWch8[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch4, 4, sizeof(aVkToWch4[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch1, 4, sizeof(aVkToWch1[0]) },  // must come last
    {                       NULL, 0, 0                    }
};

/***************************************************************************\
* aKeyNames[], aKeyNamesExt[]  - Scan Code -> Key Name tables
*
* For the GetKeyNameText() API function
*
* Tables for non-extended and extended (KBDEXT) keys.
* (Keys producing printable characters are named by the character itself)
\***************************************************************************/

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNames[] = {
    0x01,    L"Esc",
    0x0e,    L"Backspace",
    0x0f,    L"Tab",
    0x1c,    L"Enter",
    0x1d,    L"Ctrl",
    0x29,    (LPWSTR)SZ_KEY_NAME_HANKAKU_ZENKAKU,  // NLS Key
    0x2a,    L"Shift",
    0x36,    L"Right Shift",
    0x37,    L"Num *",
    0x38,    L"Alt",
    0x39,    L"Space",
    0x3a,    L"Caps Lock",
    0x3b,    L"F1",
    0x3c,    L"F2",
    0x3d,    L"F3",
    0x3e,    L"F4",
    0x3f,    L"F5",
    0x40,    L"F6",
    0x41,    L"F7",
    0x42,    L"F8",
    0x43,    L"F9",
    0x44,    L"F10",
    0x45,    L"Pause",
    0x46,    L"Scroll Lock",
    0x47,    L"Num 7",
    0x48,    L"Num 8",
    0x49,    L"Num 9",
    0x4a,    L"Num -",
    0x4b,    L"Num 4",
    0x4c,    L"Num 5",
    0x4d,    L"Num 6",
    0x4e,    L"Num +",
    0x4f,    L"Num 1",
    0x50,    L"Num 2",
    0x51,    L"Num 3",
    0x52,    L"Num 0",
    0x53,    L"Num Del",
    0x54,    L"Sys Req",
    0x57,    L"F11",
    0x58,    L"F12",
    0x70,    (LPWSTR)SZ_KEY_NAME_HIRAGANA,
    0x79,    (LPWSTR)SZ_KEY_NAME_HENKAN,
    0x7b,    (LPWSTR)SZ_KEY_NAME_MUHENKAN,
    0x7C,    L"F13",
    0   ,    NULL
};

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNamesExt[] = {
    0x1c,    L"Num Enter",
    0x1d,    L"Right Control",
    0x35,    L"Num /",
    0x37,    L"Prnt Scrn",
    0x38,    L"Right Alt",
    0x45,    L"Num Lock",
    0x46,    L"Break",
    0x47,    L"Home",
    0x48,    L"Up",
    0x49,    L"Page Up",
    0x4b,    L"Left",
    0x4d,    L"Right",
    0x4f,    L"End",
    0x50,    L"Down",
    0x51,    L"Page Down",
    0x52,    L"Insert",
    0x53,    L"Delete",
    0x5B,    L"Left Windows",
    0x5C,    L"Right Windows",
    0x5D,    L"Application",
    0   ,    NULL
};

static ALLOC_SECTION_LDATA KBDTABLES KbdTables = {
    /*
     * Modifier keys
     */
    &CharModifiers,

    /*
     * Characters tables
     */
    aVkToWcharTable,

    /*
     * Diacritics  (none for US English)
     */
    NULL,

    /*
     * Names of Keys  (no dead keys)
     */
    aKeyNames,
    aKeyNamesExt,
    NULL,

    /*
     * Scan codes to Virtual Keys
     */
    ausVK,
    sizeof(ausVK) / sizeof(ausVK[0]),
    aE0VscToVk,
    aE1VscToVk,

    /*
     * No Locale-specific special processing
     */
    0,

    /*
     * No Ligatures
     */
    0, 0, NULL,

    /*
     * Type and subtype
     */
    KEYBOARD_TYPE_JAPAN,
    MAKEWORD(MICROSOFT_KBD_106_TYPE, NLSKBD_OEM_MICROSOFT),
};

PKBDTABLES KbdLayerDescriptor(VOID)
{
    return &KbdTables;
}

/***********************************************************************\
* VkToFuncTable_106[]
*
\***********************************************************************/

static ALLOC_SECTION_LDATA VK_F VkToFuncTable_106[] = {
    {
        VK_DBE_ALPHANUMERIC,  // Base Vk
        KBDNLS_TYPE_TOGGLE,   // NLSFEProcType
        KBDNLS_INDEX_NORMAL,  // NLSFEProcCurrent
        0x02, /* 00000010 */  // NLSFEProcSwitch
        {                     // NLSFEProc
            {KBDNLS_ALPHANUM,0},               // Base
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Shift
            {KBDNLS_SEND_PARAM_VK,VK_KANA},    // Control
            {KBDNLS_ALPHANUM,0},               // Shift+Control
            {KBDNLS_ALPHANUM,0},               // Alt
            {KBDNLS_ALPHANUM,0},               // Shift+Alt
            {KBDNLS_CODEINPUT,0},              // Control+Alt
            {KBDNLS_CODEINPUT,0}               // Shift+Control+Alt
        },
        {                     // NLSFEProcAlt
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Base
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Shift
            {KBDNLS_NOEVENT,0},                // Control
            {KBDNLS_NOEVENT,0},                // Shift+Control
            {KBDNLS_NOEVENT,0},                // Alt
            {KBDNLS_NOEVENT,0},                // Shift+Alt
            {KBDNLS_NOEVENT,0},                // Control+Alt
            {KBDNLS_NOEVENT,0}                 // Shift+Control+Alt
        }
    },
    {
        VK_DBE_HIRAGANA,     // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_HIRAGANA,0},             // Base
            {KBDNLS_KATAKANA,0},             // Shift
            {KBDNLS_HIRAGANA,0},             // Control
            {KBDNLS_KATAKANA,0},             // Shift+Control
            {KBDNLS_ROMAN,0},                // Alt
            {KBDNLS_ROMAN,0},                // Shift+Alt
            {KBDNLS_ROMAN,0},                // Control+Alt
            {KBDNLS_NOEVENT,0}               // Shift+Control+Alt
        },
        {                    // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},                 // Base
            {KBDNLS_NULL,0},                 // Shift
            {KBDNLS_NULL,0},                 // Control
            {KBDNLS_NULL,0},                 // Shift+Control
            {KBDNLS_NULL,0},                 // Alt
            {KBDNLS_NULL,0},                 // Shift+Alt
            {KBDNLS_NULL,0},                 // Control+Alt
            {KBDNLS_NULL,0}                  // Shift+Control+Alt
        }
    },
    {
        VK_DBE_SBCSCHAR,     // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SBCSDBCS,0},             // Base
            {KBDNLS_SBCSDBCS,0},             // Shift
            {KBDNLS_SBCSDBCS,0},             // Control
            {KBDNLS_SBCSDBCS,0},             // Shift+Control
            {KBDNLS_SEND_PARAM_VK,VK_KANJI}, // Alt
            {KBDNLS_SBCSDBCS,0},             // Shift+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}, // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}  // Shift+Control+Alt
        },
        {                    // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_NONCONVERT,       // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},         // Base
            {KBDNLS_SEND_BASE_VK,0},         // Shift
            {KBDNLS_SEND_BASE_VK,0},         // Control
            {KBDNLS_SEND_BASE_VK,0},         // Shift+Control
            {KBDNLS_SEND_BASE_VK,0},         // Alt
            {KBDNLS_SEND_BASE_VK,0},         // Shift+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}, // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}  // Shift+Control+Alt
        },
        {                         // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    }
};

/***********************************************************************\
* KbdNlsTables
*
\***********************************************************************/

static ALLOC_SECTION_LDATA KBDNLSTABLES KbdNlsTables = {
    0,                      // OEM ID (0 = Microsoft)
    0,                      // Information
    4,                      // Number of VK_F entry
    VkToFuncTable_106,      // Pointer to VK_F array
    0,                      // Number of MouseVk entry
    NULL                    // Pointer to MouseVk array
};

PKBDNLSTABLES KbdNlsLayerDescriptor(VOID)
{
    return &KbdNlsTables;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\fe_kbds\jpn\ax2\kbdax2.c ===
/***************************************************************************\
* Module Name: kbdax2.c
*
* Copyright (c) 1985-92, Microsoft Corporation
*
* History:
\***************************************************************************/

#include <windows.h>
#include <ime.h>
#include "vkoem.h"
#include "kbdjpn.h"
#include "kbdax2.h"

#if defined(_M_IA64)
#pragma section(".data")
#define ALLOC_SECTION_LDATA __declspec(allocate(".data"))
#else
#pragma data_seg(".data")
#define ALLOC_SECTION_LDATA
#endif

/***************************************************************************\
* ausVK[] - Virtual Scan Code to Virtual Key conversion table for AX2
\***************************************************************************/

static ALLOC_SECTION_LDATA USHORT ausVK[] = {
    T00, T01, T02, T03, T04, T05, T06, T07,
    T08, T09, T0A, T0B, T0C, T0D, T0E, T0F,
    T10, T11, T12, T13, T14, T15, T16, T17,
    T18, T19, T1A, T1B, T1C, T1D, T1E, T1F,
    T20, T21, T22, T23, T24, T25, T26, T27,
    T28, T29, T2A, T2B, T2C, T2D, T2E, T2F,
    T30, T31, T32, T33, T34, T35,

    /*
     * Right-hand Shift key must have KBDEXT bit set.
     */
    T36 | KBDEXT,

    /*
     * numpad_* + Shift/Alt -> SnapShot
     */
    T37 | KBDMULTIVK,

    T38, T39, T3A, T3B, T3C, T3D, T3E, T3F,
    T40, T41, T42, T43, T44,

    /*
     * NumLock Key:
     *     KBDEXT     - VK_NUMLOCK is an Extended key
     *     KBDMULTIVK - VK_NUMLOCK or VK_PAUSE (without or with CTRL)
     */
    T45 | KBDEXT | KBDMULTIVK,

    T46 | KBDMULTIVK,

    /*
     * Number Pad keys:
     *     KBDNUMPAD  - digits 0-9 and decimal point.
     *     KBDSPECIAL - require special processing by Windows
     */
    T47 | KBDNUMPAD | KBDSPECIAL,   // Numpad 7 (Home)
    T48 | KBDNUMPAD | KBDSPECIAL,   // Numpad 8 (Up),
    T49 | KBDNUMPAD | KBDSPECIAL,   // Numpad 9 (PgUp),
    T4A,
    T4B | KBDNUMPAD | KBDSPECIAL,   // Numpad 4 (Left),
    T4C | KBDNUMPAD | KBDSPECIAL,   // Numpad 5 (Clear),
    T4D | KBDNUMPAD | KBDSPECIAL,   // Numpad 6 (Right),
    T4E,
    T4F | KBDNUMPAD | KBDSPECIAL,   // Numpad 1 (End),
    T50 | KBDNUMPAD | KBDSPECIAL,   // Numpad 2 (Down),
    T51 | KBDNUMPAD | KBDSPECIAL,   // Numpad 3 (PgDn),
    T52 | KBDNUMPAD | KBDSPECIAL,   // Numpad 0 (Ins),
    T53 | KBDNUMPAD | KBDSPECIAL,   // Numpad . (Del),

    T54, T55, T56, T57, T58, T59,

    /*
     * Non-Conversion key must have KBDSPECIAL bit set (NLS key)
     */
    T5A | KBDSPECIAL,

    /*
     * Conversion key must have KBDSPECIAL bit set (NLS key)
     */
    T5B | KBDSPECIAL,

    /*
     * AX key
     */
    T5C,

                             T5D, T5E, T5F,
    T60, T61, T62, T63, T64, T65, T66, T67,
    T68, T69, T6A, T6B, T6C, T6D, T6E, T6F,
    T70, T71, T72, T73, T74, T75, T76, T77,
    T78, T79, T7A, T7B, T7C, T7D, T7E, T7F
};

static ALLOC_SECTION_LDATA VSC_VK aE0VscToVk[] = {
    { 0x1C, X1C | KBDEXT              },  // Numpad Enter
    { 0x1D, X1D | KBDEXT | KBDSPECIAL },  // Alphanumeric/Katakana key
    { 0x35, X35 | KBDEXT              },  // Numpad Divide
    { 0x37, X37 | KBDEXT              },  // Snapshot
    { 0x38, X38 | KBDEXT | KBDSPECIAL },  // Kanji key
    { 0x46, X46 | KBDEXT              },  // Break (Ctrl + Pause)
    { 0x47, X47 | KBDEXT              },  // Home
    { 0x48, X48 | KBDEXT              },  // Up
    { 0x49, X49 | KBDEXT              },  // Prior
    { 0x4B, X4B | KBDEXT              },  // Left
    { 0x4D, X4D | KBDEXT              },  // Right
    { 0x4F, X4F | KBDEXT              },  // End
    { 0x50, X50 | KBDEXT              },  // Down
    { 0x51, X51 | KBDEXT              },  // Next
    { 0x52, X52 | KBDEXT              },  // Insert
    { 0x53, X53 | KBDEXT              },  // Delete
    { 0x5B, X5B | KBDEXT              },  // Left Win
    { 0x5C, X5C | KBDEXT              },  // Right Win
    { 0x5D, X5D | KBDEXT              },  // Application
    { 0,      0                       }
};

static ALLOC_SECTION_LDATA VSC_VK aE1VscToVk[] = {
    { 0x1D, Y1D                       },  // Pause
    { 0   ,   0                       }
};

/***************************************************************************\
* aVkToBits[]  - map Virtual Keys to Modifier Bits
*
* See kbd.h for a full description.
*
* US Keyboard has only three shifter keys:
*     SHIFT (L & R) affects alphabnumeric keys,
*     CTRL  (L & R) is used to generate control characters
*     ALT   (L & R) used for generating characters by number with numpad
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_BIT aVkToBits[] = {
    { VK_SHIFT,   KBDSHIFT },
    { VK_CONTROL, KBDCTRL  },
    { VK_MENU,    KBDALT   },
    { VK_KANA,    KBDKANA  },
    { 0,          0        }
};

/***************************************************************************\
* aModification[]  - map character modifier bits to modification number
*
* See kbd.h for a full description.
*
\***************************************************************************/

static ALLOC_SECTION_LDATA MODIFIERS CharModifiers = {
    &aVkToBits[0],
    11,
    {
    //  Modification# //  Keys Pressed  : Explanation
    //  ============= // ============== : =============================
        0,            //                : unshifted characters
        1,            //          SHIFT : capitals, ~!@#$%^&*()_+{}:"<>? etc.
        4,            //     CTRL       : control characters
        6,            //     CTRL SHIFT :
        SHFT_INVALID, // ALT            : invalid
        SHFT_INVALID, // ALT      SHIFT : invalid
        SHFT_INVALID, // ALT CTRL       : invalid
        SHFT_INVALID, // ALT CTRL SHIFT : invalid
        2,            //KANA
        3,            //KANA      SHIFT
        5,            //KANA CTRL
        7             //KANA CTRL SHIFT
    }
};

/***************************************************************************\
*
* aVkToWch2[]  - Virtual Key to WCHAR translation for 2 shift states
* aVkToWch3[]  - Virtual Key to WCHAR translation for 3 shift states
* aVkToWch4[]  - Virtual Key to WCHAR translation for 4 shift states
*
* Table attributes: Unordered Scan, null-terminated
*
* Search this table for an entry with a matching Virtual Key to find the
* corresponding unshifted and shifted WCHAR characters.
*
* Reserved VirtualKey values (first column)
*     -1            - this line contains dead characters (diacritic)
*     0             - terminator
*
* Reserved Attribute values (second column)
*     CAPLOK        - CapsLock affects this key like Shift
*     KANALOK       - The KANA-LOCK key affects this key like KANA
*
* Reserved character values (third through last column)
*     WCH_NONE      - No character
*     WCH_DEAD      - Dead character (diacritic) value is in next line
*
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch4[] = {
    //                               |          |   SHIFT  |  KANA  | K+SHFT |
    //                               |          |==========|========|========|
    {'0'          ,          KANALOK ,'0'       ,')'       ,WCH_WA  ,WCH_WO  },
    {'1'          ,          KANALOK ,'1'       ,'!'       ,WCH_NU  ,WCH_NU  },
    {'3'          ,          KANALOK ,'3'       ,'#'       ,WCH_A   ,WCH_AA  },
    {'4'          ,          KANALOK ,'4'       ,'$'       ,WCH_U   ,WCH_UU  },
    {'5'          ,          KANALOK ,'5'       ,'%'       ,WCH_E   ,WCH_EE  },
    {'7'          ,          KANALOK ,'7'       ,'&'       ,WCH_YA  ,WCH_YAA },
    {'8'          ,          KANALOK ,'8'       ,'*'       ,WCH_YU  ,WCH_YUU },
    {'9'          ,          KANALOK ,'9'       ,'('       ,WCH_YO  ,WCH_YOO },
    {'A'          , CAPLOK | KANALOK ,'a'       ,'A'       ,WCH_TI  ,WCH_TI  },
    {'B'          , CAPLOK | KANALOK ,'b'       ,'B'       ,WCH_KO  ,WCH_KO  },
    {'C'          , CAPLOK | KANALOK ,'c'       ,'C'       ,WCH_SO  ,WCH_SO  },
    {'D'          , CAPLOK | KANALOK ,'d'       ,'D'       ,WCH_SI  ,WCH_SI  },
    {'E'          , CAPLOK | KANALOK ,'e'       ,'E'       ,WCH_I   ,WCH_II  },
    {'F'          , CAPLOK | KANALOK ,'f'       ,'F'       ,WCH_HA  ,WCH_HA  },
    {'G'          , CAPLOK | KANALOK ,'g'       ,'G'       ,WCH_KI  ,WCH_KI  },
    {'H'          , CAPLOK | KANALOK ,'h'       ,'H'       ,WCH_KU  ,WCH_KU  },
    {'I'          , CAPLOK | KANALOK ,'i'       ,'I'       ,WCH_NI  ,WCH_NI  },
    {'J'          , CAPLOK | KANALOK ,'j'       ,'J'       ,WCH_MA  ,WCH_MA  },
    {'K'          , CAPLOK | KANALOK ,'k'       ,'K'       ,WCH_NO  ,WCH_NO  },
    {'L'          , CAPLOK | KANALOK ,'l'       ,'L'       ,WCH_RI  ,WCH_RI  },
    {'M'          , CAPLOK | KANALOK ,'m'       ,'M'       ,WCH_MO  ,WCH_MO  },
    {'N'          , CAPLOK | KANALOK ,'n'       ,'N'       ,WCH_MI  ,WCH_MI  },
    {'O'          , CAPLOK | KANALOK ,'o'       ,'O'       ,WCH_RA  ,WCH_RA  },
    {'P'          , CAPLOK | KANALOK ,'p'       ,'P'       ,WCH_SE  ,WCH_SE  },
    {'Q'          , CAPLOK | KANALOK ,'q'       ,'Q'       ,WCH_TA  ,WCH_TA  },
    {'R'          , CAPLOK | KANALOK ,'r'       ,'R'       ,WCH_SU  ,WCH_SU  },
    {'S'          , CAPLOK | KANALOK ,'s'       ,'S'       ,WCH_TO  ,WCH_TO  },
    {'T'          , CAPLOK | KANALOK ,'t'       ,'T'       ,WCH_KA  ,WCH_KA  },
    {'U'          , CAPLOK | KANALOK ,'u'       ,'U'       ,WCH_NA  ,WCH_NA  },
    {'V'          , CAPLOK | KANALOK ,'v'       ,'V'       ,WCH_HI  ,WCH_HI  },
    {'W'          , CAPLOK | KANALOK ,'w'       ,'W'       ,WCH_TE  ,WCH_TE  },
    {'X'          , CAPLOK | KANALOK ,'x'       ,'X'       ,WCH_SA  ,WCH_SA  },
    {'Y'          , CAPLOK | KANALOK ,'y'       ,'Y'       ,WCH_NN  ,WCH_NN  },
    {'Z'          , CAPLOK | KANALOK ,'z'       ,'Z'       ,WCH_TU  ,WCH_TUU },
    {VK_OEM_1     ,          KANALOK ,';'       ,':'       ,WCH_RE  ,WCH_RE  },
    {VK_OEM_2     ,          KANALOK ,'/'       ,'?'       ,WCH_ME  ,WCH_MD  },
    {VK_OEM_3     ,          KANALOK ,'`'       ,'~'       ,WCH_MU  ,WCH_CB  },
    {VK_OEM_7     ,          KANALOK ,0x27      ,'"'       ,WCH_KE  ,WCH_KE  },
    {VK_OEM_8     , 0                ,WCH_NONE  ,WCH_NONE  ,WCH_NONE,WCH_NONE},
    {VK_OEM_COMMA ,          KANALOK ,','       ,'<'       ,WCH_NE  ,WCH_IC  },
    {VK_OEM_PERIOD,          KANALOK ,'.'       ,'>'       ,WCH_RU  ,WCH_IP  },
    {VK_OEM_PLUS  ,          KANALOK ,'='       ,'+'       ,WCH_HE  ,WCH_HE  },
    {VK_TAB       , 0                ,'\t'      ,'\t'      ,'\t'    ,'\t'    },
    {VK_ADD       , 0                ,'+'       ,'+'       ,'+'     ,'+'     },
    {VK_DECIMAL   , 0                ,'.'       ,'.'       ,'.'     ,'.'     },
    {VK_DIVIDE    , 0                ,'/'       ,'/'       ,'/'     ,'/'     },
    {VK_MULTIPLY  , 0                ,'*'       ,'*'       ,'*'     ,'*'     },
    {VK_SUBTRACT  , 0                ,'-'       ,'-'       ,'-'     ,'-'     },
    {0            , 0                ,0         ,0         ,0       ,0       }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS6 aVkToWch6[] = {
    //                      |          |   SHIFT  |  KANA  | K+SHFT |  CONTROL  |  K+CTRL   |
    //                      |          |==========|========|========|===========|===========|
    {VK_BACK      , 0       ,'\b'      ,'\b'      ,'\b'    ,'\b'    , 0x7f      , 0x7f      },
    {VK_CANCEL    , 0       ,0x03      ,0x03      ,0x03    ,0x03    , 0x03      , 0x03      },
    {VK_ESCAPE    , 0       ,0x1b      ,0x1b      ,0x1b    ,0x1b    , 0x1b      , 0x1b      },
    {VK_OEM_4     , KANALOK ,'['       ,'{'       ,WCH_VS  ,WCH_VS  , 0x1b      , 0x1b      },
    {VK_OEM_5     , KANALOK ,'\\'      ,'|'       ,WCH_PS  ,WCH_PS  , 0x1c      , 0x1c      },
    {VK_OEM_102   , KANALOK ,'\\'      ,'|'       ,WCH_RO  ,WCH_RO  , 0x1c      , 0x1c      },
    {VK_OEM_6     , KANALOK ,']'       ,'}'       ,WCH_SVS ,WCH_OB  , 0x1d      , 0x1d      },
    {VK_RETURN    , 0       ,'\r'      ,'\r'      ,'\r'    ,'\r'    , '\n'      , '\n'      },
    {VK_SPACE     , 0       ,' '       ,' '       ,' '     ,' '     , 0x20      , 0x20      },
    {0            , 0       ,0         ,0         ,0       ,0       , 0         , 0         }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS8 aVkToWch8[] = {
    //                      |          |   SHIFT  |  KANA  | K+SHFT |  CONTROL  |  K+CTRL   | SHFT+CTRL |K+SHFT+CTRL|
    //                      |          |==========|========|========|===========|===========|===========|===========|
    {'2'          , KANALOK ,'2'       ,'@'       ,WCH_HU  ,WCH_HU  , WCH_NONE  , WCH_NONE  , 0x00      , 0x00      },
    {'6'          , KANALOK ,'6'       ,'^'       ,WCH_O   ,WCH_OO  , WCH_NONE  , WCH_NONE  , 0x1e      , 0x1e      },
    {VK_OEM_MINUS , KANALOK ,'-'       ,'_'       ,WCH_HO  ,WCH_HO  , WCH_NONE  , WCH_NONE  , 0x1f      , 0x1f      },
    {0            , 0       ,0         ,0         ,0       ,0       , 0         , 0         , 0         , 0         }
};

// Put this last so that VkKeyScan interprets number characters
// as coming from the main section of the kbd (aVkToWch2 and
// aVkToWch4) before considering the numpad (aVkToWch1).

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch1[] = {
    //                     |          |   SHIFT  |  KANA  | K+SHFT |
    //                     |          |==========|========|========|
    { VK_NUMPAD0   , 0      ,  '0'    , WCH_NONE ,   '0'  ,WCH_NONE},
    { VK_NUMPAD1   , 0      ,  '1'    , WCH_NONE ,   '1'  ,WCH_NONE},
    { VK_NUMPAD2   , 0      ,  '2'    , WCH_NONE ,   '2'  ,WCH_NONE},
    { VK_NUMPAD3   , 0      ,  '3'    , WCH_NONE ,   '3'  ,WCH_NONE},
    { VK_NUMPAD4   , 0      ,  '4'    , WCH_NONE ,   '4'  ,WCH_NONE},
    { VK_NUMPAD5   , 0      ,  '5'    , WCH_NONE ,   '5'  ,WCH_NONE},
    { VK_NUMPAD6   , 0      ,  '6'    , WCH_NONE ,   '6'  ,WCH_NONE},
    { VK_NUMPAD7   , 0      ,  '7'    , WCH_NONE ,   '7'  ,WCH_NONE},
    { VK_NUMPAD8   , 0      ,  '8'    , WCH_NONE ,   '8'  ,WCH_NONE},
    { VK_NUMPAD9   , 0      ,  '9'    , WCH_NONE ,   '9'  ,WCH_NONE},
    { 0            , 0      ,  '\0'   , 0        ,   0    ,0       }   //null terminator
};

/***************************************************************************\
* aVkToWcharTable: table of pointers to Character Tables
*
* Describes the character tables and the order they should be searched.
*
* Note: the order determines the behavior of VkKeyScan() : this function
*       takes a character and attempts to find a Virtual Key and character-
*       modifier key combination that produces that character.  The table
*       containing the numeric keypad (aVkToWch1) must appear last so that
*       VkKeyScan('0') will be interpreted as one of keys from the main
*       section, not the numpad.  etc.
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHAR_TABLE aVkToWcharTable[] = {
    {  (PVK_TO_WCHARS1)aVkToWch6, 6, sizeof(aVkToWch6[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch8, 8, sizeof(aVkToWch8[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch4, 4, sizeof(aVkToWch4[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch1, 4, sizeof(aVkToWch1[0]) },  // must come last
    {                       NULL, 0, 0                    }
};

/***************************************************************************\
* aKeyNames[], aKeyNamesExt[]  - Scan Code -> Key Name tables
*
* For the GetKeyNameText() API function
*
* Tables for non-extended and extended (KBDEXT) keys.
* (Keys producing printable characters are named by the character itself)
\***************************************************************************/

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNames[] = {
    0x01,    L"Esc",
    0x0e,    L"Backspace",
    0x0f,    L"Tab",
    0x1c,    L"Enter",
    0x1d,    L"Ctrl",
    0x2a,    L"Shift",
    0x36,    L"Right Shift",
    0x37,    L"Num *",
    0x38,    L"Alt",
    0x39,    L"Space",
    0x3a,    L"Caps Lock",
    0x3b,    L"F1",
    0x3c,    L"F2",
    0x3d,    L"F3",
    0x3e,    L"F4",
    0x3f,    L"F5",
    0x40,    L"F6",
    0x41,    L"F7",
    0x42,    L"F8",
    0x43,    L"F9",
    0x44,    L"F10",
    0x45,    L"Pause",
    0x46,    L"Scroll Lock",
    0x47,    L"Num 7",
    0x48,    L"Num 8",
    0x49,    L"Num 9",
    0x4a,    L"Num -",
    0x4b,    L"Num 4",
    0x4c,    L"Num 5",
    0x4d,    L"Num 6",
    0x4e,    L"Num +",
    0x4f,    L"Num 1",
    0x50,    L"Num 2",
    0x51,    L"Num 3",
    0x52,    L"Num 0",
    0x53,    L"Num Del",
    0x54,    L"Sys Req",
    0x57,    L"F11",
    0x58,    L"F12",
    0x5a,    (LPWSTR)SZ_KEY_NAME_MUHENKAN,  // NLS Key
    0x5b,    (LPWSTR)SZ_KEY_NAME_HENKAN,    // NLS Key
    0x5c,    L"AX",                 // NLS Key
    0x7C,    L"F13",
    0x7D,    L"F14",
    0x7E,    L"F15",
    0x7F,    L"F16",
    0x80,    L"F17",
    0x81,    L"F18",
    0x82,    L"F19",
    0x83,    L"F20",
    0x84,    L"F21",
    0x85,    L"F22",
    0x86,    L"F23",
    0x87,    L"F24",
    0   ,    NULL
};

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNamesExt[] = {
    0x1c,    L"Num Enter",
    0x1d,    (LPWSTR)SZ_KEY_NAME_EISU_KANA, // NLS Key
    0x35,    L"Num /",
    0x37,    L"Prnt Scrn",
    0x38,    (LPWSTR)SZ_KEY_NAME_KANJI,     // NLS Key
    0x45,    L"Num Lock",
    0x46,    L"Break",
    0x47,    L"Home",
    0x48,    L"Up",
    0x49,    L"Page Up",
    0x4b,    L"Left",
    0x4d,    L"Right",
    0x4f,    L"End",
    0x50,    L"Down",
    0x51,    L"Page Down",
    0x52,    L"Insert",
    0x53,    L"Delete",
    0x54,    L"<00>",
    0x56,    L"Help",
    0x5B,    L"Left Windows",
    0x5C,    L"Right Windows",
    0x5D,    L"Application",
    0   ,    NULL
};

static ALLOC_SECTION_LDATA KBDTABLES KbdTables = {
    /*
     * Modifier keys
     */
    &CharModifiers,

    /*
     * Characters tables
     */
    aVkToWcharTable,

    /*
     * Diacritics  (none for US English)
     */
    NULL,

    /*
     * Names of Keys  (no dead keys)
     */
    aKeyNames,
    aKeyNamesExt,
    NULL,

    /*
     * Scan codes to Virtual Keys
     */
    ausVK,
    sizeof(ausVK) / sizeof(ausVK[0]),
    aE0VscToVk,
    aE1VscToVk,

    /*
     * No Locale-specific special processing
     */
    0,

    /*
     * No Ligatures
     */
    0, 0, NULL,

    /*
     * Type and subtype
     */
    KEYBOARD_TYPE_JAPAN,
    MAKEWORD(MICROSOFT_KBD_AX_TYPE, NLSKBD_OEM_MICROSOFT),
};

PKBDTABLES KbdLayerDescriptor(VOID)
{
    return &KbdTables;
}

/***********************************************************************\
* VkToFuncTable_ax2[]
*
\***********************************************************************/

static ALLOC_SECTION_LDATA VK_F VkToFuncTable_ax2[] = {
    {
        VK_DBE_KATAKANA,      // Base Vk
        KBDNLS_TYPE_TOGGLE,   // NLSFEProcType
        KBDNLS_INDEX_NORMAL,  // NLSFEProcCurrent
        0x8, /* 00001000 */   // NLSFEProcSwitch
        {                     // NLSFEProc
            {KBDNLS_KATAKANA,0},               // Base
            {KBDNLS_HIRAGANA,0},               // Shift
            {KBDNLS_ROMAN,0},                  // Control
            {KBDNLS_SEND_PARAM_VK,VK_KANA},    // Shift+Control
            {KBDNLS_ALPHANUM,0},               // Alt
            {KBDNLS_ALPHANUM,0},               // Shift+Alt
            {KBDNLS_ALPHANUM,0},               // Control+Alt
            {KBDNLS_ALPHANUM,0}                // Shift+Control+Alt
        },
        {                     // NLSFEProcAlt
            {KBDNLS_SEND_PARAM_VK,VK_KANA},    // Base
            {KBDNLS_SEND_PARAM_VK,VK_KANA},    // Shift
            {KBDNLS_SEND_PARAM_VK,VK_KANA},    // Control
            {KBDNLS_SEND_PARAM_VK,VK_KANA},    // Shift+Control
            {KBDNLS_NOEVENT,0},                // Alt
            {KBDNLS_NOEVENT,0},                // Shift+Alt
            {KBDNLS_NOEVENT,0},                // Control+Alt
            {KBDNLS_NOEVENT,0}                 // Shift+Control+Alt
        }
    },
    {
        VK_NONCONVERT,       // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},                             // Base
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}, // Shift
            {KBDNLS_CODEINPUT,0},                                // Control
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}, // Shift+Control
            {KBDNLS_SEND_BASE_VK,0},                             // Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}, // Shift+Alt
            {KBDNLS_CODEINPUT,0},                                // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}  // Shift+Control+Alt
        },
        {                    // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},              // Base
            {KBDNLS_NULL,0},              // Shift
            {KBDNLS_NULL,0},              // Control
            {KBDNLS_NULL,0},              // Shift+Control
            {KBDNLS_NULL,0},              // Alt
            {KBDNLS_NULL,0},              // Shift+Alt
            {KBDNLS_NULL,0},              // Control+Alt
            {KBDNLS_NULL,0}               // Shift+Control+Alt
        }
    },
    {
        VK_KANJI,            // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},                          // Base
            {KBDNLS_SBCSDBCS,0},                              // Shift
            {KBDNLS_SEND_BASE_VK,0},                          // Control
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}, // Shift+Control
            {KBDNLS_SEND_BASE_VK,0},                          // Alt
            {KBDNLS_SBCSDBCS,0},                              // Shift+Alt
            {KBDNLS_SEND_BASE_VK,0},                          // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}  // Shift+Control+Alt
        },
        {                    // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    }
};

/***********************************************************************\
* KbdNlsTables
*
\***********************************************************************/

static ALLOC_SECTION_LDATA KBDNLSTABLES KbdNlsTables = {
    0,                      // OEM ID (0 = Microsoft)
    0,                      // Information
    3,                      // Number of VK_F entry
    VkToFuncTable_ax2,      // Pointer to VK_F array
    0,                      // Number of MouseVk entry
    NULL                    // Pointer to MouseVk array
};

PKBDNLSTABLES KbdNlsLayerDescriptor(VOID)
{
    return &KbdNlsTables;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\fe_kbds\jpn\106n\sources.inc ===
!IF 0

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


!ENDIF

MINORCOMP=kbd106n

!include ..\..\japan.inc

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\fe_kbds\jpn\f3ahvoas\f3ahvoas.h ===
/****************************** Module Header ******************************\
* Module Name: f3ahvoas.h
*
* Copyright (c) 1985-91, Microsoft Corporation
*
* Various defines for use by keyboard input code.
*
* History:
\***************************************************************************/

/*
 * kbd type should be controlled by cl command-line argument
 */
#define KBD_TYPE 22

/*
 * Include the basis of all keyboard table values
 */
#include "kbd.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\fe_kbds\jpn\f3ahvoas\sources.inc ===
!IF 0

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


!ENDIF

MINORCOMP=f3ahvoas

!include ..\..\japan.inc

SOURCES_USED=..\sources.inc

LINKLIBS=$(WINDOWS_LIB_PATH)\w32umode.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\fe_kbds\jpn\f3ahvoas\f3ahvoas.c ===
/***************************************************************************\
* Module Name: f3ahvoas.
*
* Copyright (c) 1985-92, Microsoft Corporation
*
* History:
\***************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ime.h>
#include "vkoem.h"
#include "kbdjpn.h"
#include "f3ahvoas.h"

#include "cscall.h"
#include "usercall.h"

#if defined(_M_IA64)
#pragma section(".data")
#define ALLOC_SECTION_LDATA __declspec(allocate(".data"))
#else
#pragma data_seg(".data")
#define ALLOC_SECTION_LDATA
#endif

/***************************************************************************\
* ausVK[] - Virtual Scan Code to Virtual Key conversion table for F3AHVOAS
\***************************************************************************/

static ALLOC_SECTION_LDATA USHORT ausVK[] = {
    T00, T01, T02, T03, T04, T05, T06, T07,
    T08, T09, T0A, T0B, T0C, T0D, T0E, T0F,
    T10, T11, T12, T13, T14, T15, T16, T17,
    T18, T19, T1A, T1B, T1C, T1D, T1E, T1F,
    T20, T21, T22, T23, T24, T25, T26, T27,
    T28,

    /*
     * Hankaku/Zenkaku/Kanji key must have KBDSPECIAL bit set (NLS key)
     */
    T29 | KBDSPECIAL,

              T2A, T2B, T2C, T2D, T2E, T2F,
    T30, T31, T32, T33, T34, T35,

    /*
     * Right-hand Shift key must have KBDEXT bit set.
     */
    T36 | KBDEXT,

    /*
     * numpad_* + Shift/Alt -> SnapShot
     */
    T37 | KBDMULTIVK,

    T38, T39,

    /*
     * Alphanumeric/CapsLock key must have KBDSPECIAL bit set (NLS key)
     */
    T3A | KBDSPECIAL,

                   T3B, T3C, T3D, T3E, T3F,
    T40, T41, T42, T43, T44,

    /*
     * NumLock Key:
     *     KBDEXT     - VK_NUMLOCK is an Extended key
     *     KBDMULTIVK - VK_NUMLOCK or VK_PAUSE (without or with CTRL)
     */
    T45 | KBDEXT | KBDMULTIVK,

    T46 | KBDMULTIVK,

    /*
     * Number Pad keys:
     *     KBDNUMPAD  - digits 0-9 and decimal point.
     *     KBDSPECIAL - require special processing by Windows
     */
    T47 | KBDNUMPAD | KBDSPECIAL,   // Numpad 7 (Home)
    T48 | KBDNUMPAD | KBDSPECIAL,   // Numpad 8 (Up),
    T49 | KBDNUMPAD | KBDSPECIAL,   // Numpad 9 (PgUp),
    T4A,
    T4B | KBDNUMPAD | KBDSPECIAL,   // Numpad 4 (Left),
    T4C | KBDNUMPAD | KBDSPECIAL,   // Numpad 5 (Clear),
    T4D | KBDNUMPAD | KBDSPECIAL,   // Numpad 6 (Right),
    T4E,
    T4F | KBDNUMPAD | KBDSPECIAL,   // Numpad 1 (End),
    T50 | KBDNUMPAD | KBDSPECIAL,   // Numpad 2 (Down),
    T51 | KBDNUMPAD | KBDSPECIAL,   // Numpad 3 (PgDn),
    T52 | KBDNUMPAD | KBDSPECIAL,   // Numpad 0 (Ins),
    T53 | KBDNUMPAD | KBDSPECIAL,   // Numpad . (Del),

    T54, T55, T56, T57, T58, T59, T5A, T5B,
    T5C, T5D, T5E, T5F, T60, T61, T62, T63,
    T64, T65, T66, T67, T68, T69, T6A, T6B,
    T6C, T6D, T6E, T6F,

    /*
     * Hiragana/Katakana/Roman key must have KBDSPECIAL bit set (NLS key)
     */
    T70 | KBDSPECIAL,

                             T71, T72, T73,
    T74, T75, T76, T77, T78,

    /*
     * Conversion key must have KBDSPECIAL bit set (NLS key)
     */
    T79 | KBDSPECIAL,

                                  T7A,

    /*
     * Non-Conversion key must have KBDSPECIAL bit set (NLS key)
     */
    T7B | KBDSPECIAL,

    T7C, T7D, T7E, T7F

};

static ALLOC_SECTION_LDATA VSC_VK aE0VscToVk[] = {
        { 0x1C, X1C | KBDEXT              },  // Numpad Enter
        { 0x1D, X1D | KBDEXT              },  // RControl
        { 0x35, X35 | KBDEXT              },  // Numpad Divide
        { 0x37, X37 | KBDEXT              },  // Snapshot
        { 0x38, X38 | KBDEXT              },  // RMenu
        { 0x46, X46 | KBDEXT              },  // Break (Ctrl + Pause)
        { 0x47, X47 | KBDEXT              },  // Home
        { 0x48, X48 | KBDEXT              },  // Up
        { 0x49, X49 | KBDEXT              },  // Prior
        { 0x4B, X4B | KBDEXT              },  // Left
        { 0x4D, X4D | KBDEXT              },  // Right
        { 0x4F, X4F | KBDEXT              },  // End
        { 0x50, X50 | KBDEXT              },  // Down
        { 0x51, X51 | KBDEXT              },  // Next
        { 0x52, X52 | KBDEXT              },  // Insert
        { 0x53, X53 | KBDEXT              },  // Delete
        { 0x5B, X5B | KBDEXT              },  // Left Win
        { 0x5C, X5C | KBDEXT              },  // Right Win
        { 0x5D, X5D | KBDEXT              },  // Application
        { 0,      0                       }
};

static ALLOC_SECTION_LDATA VSC_VK aE1VscToVk[] = {
        { 0x1D, Y1D                       },  // Pause
        { 0   ,   0                       }
};

/***************************************************************************\
* aVkToBits[]  - map Virtual Keys to Modifier Bits
*
* See kbd.h for a full description.
*
* US Keyboard has only three shifter keys:
*     SHIFT (L & R) affects alphabnumeric keys,
*     CTRL  (L & R) is used to generate control characters
*     ALT   (L & R) used for generating characters by number with numpad
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_BIT aVkToBits[] = {
    { VK_SHIFT,   KBDSHIFT },
    { VK_CONTROL, KBDCTRL  },
    { VK_MENU,    KBDALT   },
    { VK_KANA,    KBDKANA  },
    { 0,          0        }
};

/***************************************************************************\
* aModification[]  - map character modifier bits to modification number
*
* See kbd.h for a full description.
*
\***************************************************************************/

static ALLOC_SECTION_LDATA MODIFIERS CharModifiers = {
    &aVkToBits[0],
    11,
    {
    //  Modification# //  Keys Pressed  : Explanation
    //  ============= // ============== : =============================
        0,            //                : unshifted characters
        1,            //          SHIFT : capitals, ~!@#$%^&*()_+{}:"<>? etc.
        4,            //     CTRL       : control characters
        6,            //     CTRL SHIFT :
        SHFT_INVALID, // ALT            : invalid
        SHFT_INVALID, // ALT      SHIFT : invalid
        SHFT_INVALID, // ALT CTRL       : invalid
        SHFT_INVALID, // ALT CTRL SHIFT : invalid
        2,            //KANA
        3,            //KANA      SHIFT
        5,            //KANA CTRL
        7             //KANA CTRL SHIFT
    }
};

/***************************************************************************\
*
* aVkToWch2[]  - Virtual Key to WCHAR translation for 2 shift states
* aVkToWch3[]  - Virtual Key to WCHAR translation for 3 shift states
* aVkToWch4[]  - Virtual Key to WCHAR translation for 4 shift states
*
* Table attributes: Unordered Scan, null-terminated
*
* Search this table for an entry with a matching Virtual Key to find the
* corresponding unshifted and shifted WCHAR characters.
*
* Reserved VirtualKey values (first column)
*     -1            - this line contains dead characters (diacritic)
*     0             - terminator
*
* Reserved Attribute values (second column)
*     CAPLOK        - CapsLock affects this key like Shift
*     KANALOK       - The KANA-LOCK key affects this key like KANA
*
* Reserved character values (third through last column)
*     WCH_NONE      - No character
*     WCH_DEAD      - Dead character (diacritic) value is in next line
*
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch4[] = {
    //                               |          |   SHIFT  |  KANA  | K+SHFT |
    //                               |          |==========|========|========|
    {'0'          ,          KANALOK ,'0'       ,WCH_NONE  ,WCH_WA  ,WCH_WO  },
    {'1'          ,          KANALOK ,'1'       ,'!'       ,WCH_NU  ,WCH_NU  },
    {'3'          ,          KANALOK ,'3'       ,'#'       ,WCH_A   ,WCH_AA  },
    {'4'          ,          KANALOK ,'4'       ,'$'       ,WCH_U   ,WCH_UU  },
    {'5'          ,          KANALOK ,'5'       ,'%'       ,WCH_E   ,WCH_EE  },
    {'7'          ,          KANALOK ,'7'       ,0x27      ,WCH_YA  ,WCH_YAA },
    {'8'          ,          KANALOK ,'8'       ,'('       ,WCH_YU  ,WCH_YUU },
    {'9'          ,          KANALOK ,'9'       ,')'       ,WCH_YO  ,WCH_YOO },
    {'A'          , CAPLOK | KANALOK ,'a'       ,'A'       ,WCH_TI  ,WCH_TI  },
    {'B'          , CAPLOK | KANALOK ,'b'       ,'B'       ,WCH_KO  ,WCH_KO  },
    {'C'          , CAPLOK | KANALOK ,'c'       ,'C'       ,WCH_SO  ,WCH_SO  },
    {'D'          , CAPLOK | KANALOK ,'d'       ,'D'       ,WCH_SI  ,WCH_SI  },
    {'E'          , CAPLOK | KANALOK ,'e'       ,'E'       ,WCH_I   ,WCH_II  },
    {'F'          , CAPLOK | KANALOK ,'f'       ,'F'       ,WCH_HA  ,WCH_HA  },
    {'G'          , CAPLOK | KANALOK ,'g'       ,'G'       ,WCH_KI  ,WCH_KI  },
    {'H'          , CAPLOK | KANALOK ,'h'       ,'H'       ,WCH_KU  ,WCH_KU  },
    {'I'          , CAPLOK | KANALOK ,'i'       ,'I'       ,WCH_NI  ,WCH_NI  },
    {'J'          , CAPLOK | KANALOK ,'j'       ,'J'       ,WCH_MA  ,WCH_MA  },
    {'K'          , CAPLOK | KANALOK ,'k'       ,'K'       ,WCH_NO  ,WCH_NO  },
    {'L'          , CAPLOK | KANALOK ,'l'       ,'L'       ,WCH_RI  ,WCH_RI  },
    {'M'          , CAPLOK | KANALOK ,'m'       ,'M'       ,WCH_MO  ,WCH_MO  },
    {'N'          , CAPLOK | KANALOK ,'n'       ,'N'       ,WCH_MI  ,WCH_MI  },
    {'O'          , CAPLOK | KANALOK ,'o'       ,'O'       ,WCH_RA  ,WCH_RA  },
    {'P'          , CAPLOK | KANALOK ,'p'       ,'P'       ,WCH_SE  ,WCH_SE  },
    {'Q'          , CAPLOK | KANALOK ,'q'       ,'Q'       ,WCH_TA  ,WCH_TA  },
    {'R'          , CAPLOK | KANALOK ,'r'       ,'R'       ,WCH_SU  ,WCH_SU  },
    {'S'          , CAPLOK | KANALOK ,'s'       ,'S'       ,WCH_TO  ,WCH_TO  },
    {'T'          , CAPLOK | KANALOK ,'t'       ,'T'       ,WCH_KA  ,WCH_KA  },
    {'U'          , CAPLOK | KANALOK ,'u'       ,'U'       ,WCH_NA  ,WCH_NA  },
    {'V'          , CAPLOK | KANALOK ,'v'       ,'V'       ,WCH_HI  ,WCH_HI  },
    {'W'          , CAPLOK | KANALOK ,'w'       ,'W'       ,WCH_TE  ,WCH_TE  },
    {'X'          , CAPLOK | KANALOK ,'x'       ,'X'       ,WCH_SA  ,WCH_SA  },
    {'Y'          , CAPLOK | KANALOK ,'y'       ,'Y'       ,WCH_NN  ,WCH_NN  },
    {'Z'          , CAPLOK | KANALOK ,'z'       ,'Z'       ,WCH_TU  ,WCH_TUU },
    {VK_OEM_1     ,          KANALOK ,':'       ,'*'       ,WCH_KE  ,WCH_KE  },
    {VK_OEM_2     ,          KANALOK ,'/'       ,'?'       ,WCH_ME  ,WCH_MD  },
    {VK_OEM_3     ,          KANALOK ,'@'       ,'`'       ,WCH_VS  ,WCH_VS  },
    {VK_OEM_7     ,          KANALOK ,'^'       ,'~'       ,WCH_HE  ,WCH_HE  },
    {VK_OEM_8     , 0                ,WCH_NONE  ,WCH_NONE  ,WCH_NONE,WCH_NONE},
    {VK_OEM_COMMA ,          KANALOK ,','       ,'<'       ,WCH_NE  ,WCH_IC  },
    {VK_OEM_PERIOD,          KANALOK ,'.'       ,'>'       ,WCH_RU  ,WCH_IP  },
    {VK_OEM_PLUS  ,          KANALOK ,';'       ,'+'       ,WCH_RE  ,WCH_RE  },
    {VK_TAB       , 0                ,'\t'      ,'\t'      ,'\t'    ,'\t'    },
    {VK_ADD       , 0                ,'+'       ,'+'       ,'+'     ,'+'     },
    {VK_DECIMAL   , 0                ,'.'       ,'.'       ,'.'     ,'.'     },
    {VK_DIVIDE    , 0                ,'/'       ,'/'       ,'/'     ,'/'     },
    {VK_MULTIPLY  , 0                ,'*'       ,'*'       ,'*'     ,'*'     },
    {VK_SUBTRACT  , 0                ,'-'       ,'-'       ,'-'     ,'-'     },
    {0            , 0                ,0         ,0         ,0       ,0       }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS6 aVkToWch6[] = {
    //                      |          |   SHIFT  |  KANA  | K+SHFT |  CONTROL  |  K+CTRL   |
    //                      |          |==========|========|========|===========|===========|
    {VK_BACK      , 0       ,'\b'      ,'\b'      ,'\b'    ,'\b'    , 0x7f      , 0x7f      },
    {VK_CANCEL    , 0       ,0x03      ,0x03      ,0x03    ,0x03    , 0x03      , 0x03      },
    {VK_ESCAPE    , 0       ,0x1b      ,0x1b      ,0x1b    ,0x1b    , 0x1b      , 0x1b      },
    {VK_OEM_4     , KANALOK ,'['       ,'{'       ,WCH_SVS ,WCH_OB  , 0x1b      , 0x1b      },
    {VK_OEM_5     , KANALOK ,'\\'      ,'|'       ,WCH_PS  ,WCH_PS  , 0x1c      , 0x1c      },
    {VK_OEM_102   , KANALOK ,'\\'      ,'_'       ,WCH_RO  ,WCH_RO  , 0x1c      , 0x1c      },
    {VK_OEM_6     , KANALOK ,']'       ,'}'       ,WCH_MU  ,WCH_CB  , 0x1d      , 0x1d      },
    {VK_RETURN    , 0       ,'\r'      ,'\r'      ,'\r'    ,'\r'    , '\n'      , '\n'      },
    {VK_SPACE     , 0       ,' '       ,' '       ,' '     ,' '     , 0x20      , 0x20      },
    {0            , 0       ,0         ,0         ,0       ,0       , 0         , 0         }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS8 aVkToWch8[] = {
    //                      |          |   SHIFT  |  KANA  | K+SHFT |  CONTROL  |  K+CTRL   | SHFT+CTRL |K+SHFT+CTRL|
    //                      |          |==========|========|========|===========|===========|===========|===========|
    {'2'          , KANALOK ,'2'       ,'"'       ,WCH_HU  ,WCH_HU  , WCH_NONE  , WCH_NONE  , 0x00      , 0x00      },
    {'6'          , KANALOK ,'6'       ,'&'       ,WCH_O   ,WCH_OO  , WCH_NONE  , WCH_NONE  , 0x1e      , 0x1e      },
    {VK_OEM_MINUS , KANALOK ,'-'       ,'='       ,WCH_HO  ,WCH_HO  , WCH_NONE  , WCH_NONE  , 0x1f      , 0x1f      },
    {0            , 0       ,0         ,0         ,0       ,0       , 0         , 0         , 0         , 0         }
};

// Put this last so that VkKeyScan interprets number characters
// as coming from the main section of the kbd (aVkToWch2 and
// aVkToWch4) before considering the numpad (aVkToWch1).

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch1[] = {
    //                     |          |   SHIFT  |  KANA  | K+SHFT |
    //                     |          |==========|========|========|
    { VK_NUMPAD0   , 0      ,  '0'    , WCH_NONE ,   '0'  ,WCH_NONE},
    { VK_NUMPAD1   , 0      ,  '1'    , WCH_NONE ,   '1'  ,WCH_NONE},
    { VK_NUMPAD2   , 0      ,  '2'    , WCH_NONE ,   '2'  ,WCH_NONE},
    { VK_NUMPAD3   , 0      ,  '3'    , WCH_NONE ,   '3'  ,WCH_NONE},
    { VK_NUMPAD4   , 0      ,  '4'    , WCH_NONE ,   '4'  ,WCH_NONE},
    { VK_NUMPAD5   , 0      ,  '5'    , WCH_NONE ,   '5'  ,WCH_NONE},
    { VK_NUMPAD6   , 0      ,  '6'    , WCH_NONE ,   '6'  ,WCH_NONE},
    { VK_NUMPAD7   , 0      ,  '7'    , WCH_NONE ,   '7'  ,WCH_NONE},
    { VK_NUMPAD8   , 0      ,  '8'    , WCH_NONE ,   '8'  ,WCH_NONE},
    { VK_NUMPAD9   , 0      ,  '9'    , WCH_NONE ,   '9'  ,WCH_NONE},
    { 0            , 0      ,  '\0'   , 0        ,   0    ,0       }   //null terminator
};

/***************************************************************************\
* aVkToWcharTable: table of pointers to Character Tables
*
* Describes the character tables and the order they should be searched.
*
* Note: the order determines the behavior of VkKeyScan() : this function
*       takes a character and attempts to find a Virtual Key and character-
*       modifier key combination that produces that character.  The table
*       containing the numeric keypad (aVkToWch1) must appear last so that
*       VkKeyScan('0') will be interpreted as one of keys from the main
*       section, not the numpad.  etc.
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHAR_TABLE aVkToWcharTable[] = {
    {  (PVK_TO_WCHARS1)aVkToWch6, 6, sizeof(aVkToWch6[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch8, 8, sizeof(aVkToWch8[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch4, 4, sizeof(aVkToWch4[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch1, 4, sizeof(aVkToWch1[0]) },  // must come last
    {                       NULL, 0, 0                    }
};

/***************************************************************************\
* aKeyNames[], aKeyNamesExt[]  - Scan Code -> Key Name tables
*
* For the GetKeyNameText() API function
*
* Tables for non-extended and extended (KBDEXT) keys.
* (Keys producing printable characters are named by the character itself)
\***************************************************************************/

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNames[] = {
    0x01,    L"Esc",
    0x0e,    L"Backspace",
    0x0f,    L"Tab",
    0x1c,    L"Enter",
    0x1d,    L"Ctrl",
    0x29,    (LPWSTR)SZ_KEY_NAME_HANKAKU_ZENKAKU,  // NLS Key
    0x2a,    L"Shift",
    0x36,    L"Right Shift",
    0x37,    L"Num *",
    0x38,    L"Alt",
    0x39,    L"Space",
    0x3a,    L"Caps Lock",
    0x3b,    L"F1",
    0x3c,    L"F2",
    0x3d,    L"F3",
    0x3e,    L"F4",
    0x3f,    L"F5",
    0x40,    L"F6",
    0x41,    L"F7",
    0x42,    L"F8",
    0x43,    L"F9",
    0x44,    L"F10",
    0x45,    L"Pause",
    0x46,    L"Scroll Lock",
    0x47,    L"Num 7",
    0x48,    L"Num 8",
    0x49,    L"Num 9",
    0x4a,    L"Num -",
    0x4b,    L"Num 4",
    0x4c,    L"Num 5",
    0x4d,    L"Num 6",
    0x4e,    L"Num +",
    0x4f,    L"Num 1",
    0x50,    L"Num 2",
    0x51,    L"Num 3",
    0x52,    L"Num 0",
    0x53,    L"Num Del",
    0x54,    L"Sys Req",
    0x57,    L"F11",
    0x58,    L"F12",
    0x70,    (LPWSTR)SZ_KEY_NAME_HIRAGANA,
    0x79,    (LPWSTR)SZ_KEY_NAME_HENKAN,
    0x7b,    (LPWSTR)SZ_KEY_NAME_MUHENKAN,
    0x7C,    L"F13",
    0   ,    NULL
};

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNamesExt[] = {
    0x1c,    L"Num Enter",
    0x1d,    L"Right Control",
    0x35,    L"Num /",
    0x37,    L"Prnt Scrn",
    0x38,    L"Right Alt",
    0x45,    L"Num Lock",
    0x46,    L"Break",
    0x47,    L"Home",
    0x48,    L"Up",
    0x49,    L"Page Up",
    0x4b,    L"Left",
    0x4d,    L"Right",
    0x4f,    L"End",
    0x50,    L"Down",
    0x51,    L"Page Down",
    0x52,    L"Insert",
    0x53,    L"Delete",
    0x5B,    L"Left Windows",
    0x5C,    L"Right Windows",
    0x5D,    L"Application",
    0   ,    NULL
};

static ALLOC_SECTION_LDATA KBDTABLES KbdTables = {
    /*
     * Modifier keys
     */
    &CharModifiers,

    /*
     * Characters tables
     */
    aVkToWcharTable,

    /*
     * Diacritics  (none for US English)
     */
    NULL,

    /*
     * Names of Keys  (no dead keys)
     */
    aKeyNames,
    aKeyNamesExt,
    NULL,

    /*
     * Scan codes to Virtual Keys
     */
    ausVK,
    sizeof(ausVK) / sizeof(ausVK[0]),
    aE0VscToVk,
    aE1VscToVk,

    /*
     * No Locale-specific special processing
     */
    0,

    /*
     * No Ligatures
     */
    0, 0, NULL,

    /*
     * Type and subtype
     */
    KEYBOARD_TYPE_JAPAN,
    MAKEWORD(FMV_KBD_OASYS_TYPE, NLSKBD_OEM_FUJITSU),
};

PKBDTABLES KbdLayerDescriptor(VOID)
{
    return &KbdTables;
}

/***********************************************************************\
* VkToFuncTable_F3AHVOAS[]
*
\***********************************************************************/

static ALLOC_SECTION_LDATA VK_F VkToFuncTable_F3AHVOAS[] = {
    {
        VK_DBE_ALPHANUMERIC,  // Base Vk
        KBDNLS_TYPE_TOGGLE,   // NLSFEProcType
        KBDNLS_INDEX_NORMAL,  // NLSFEProcCurrent
        0x02, /* 00000010 */  // NLSFEProcSwitch
        {                     // NLSFEProc
            {KBDNLS_ALPHANUM,0},               // Base
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Shift
            {KBDNLS_ALPHANUM,0},               // Control
            {KBDNLS_ALPHANUM,0},               // Shift+Control
            {KBDNLS_ALPHANUM,0},               // Alt
            {KBDNLS_ALPHANUM,0},               // Shift+Alt
            {KBDNLS_CODEINPUT,0},              // Control+Alt
            {KBDNLS_CODEINPUT,0}               // Shift+Control+Alt
        },
        {                     // NLSFEProcAlt
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Base
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Shift
            {KBDNLS_NOEVENT,0},                // Control
            {KBDNLS_NOEVENT,0},                // Shift+Control
            {KBDNLS_NOEVENT,0},                // Alt
            {KBDNLS_NOEVENT,0},                // Shift+Alt
            {KBDNLS_NOEVENT,0},                // Control+Alt
            {KBDNLS_NOEVENT,0}                 // Shift+Control+Alt
        }
    },
    {
        VK_DBE_HIRAGANA,     // Base Vk
        KBDNLS_TYPE_TOGGLE,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x08, /* 00001000 */ // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_HIRAGANA,0},             // Base
            {KBDNLS_KATAKANA,0},             // Shift
            {KBDNLS_HIRAGANA,0},             // Control
            {KBDNLS_KANAEVENT,VK_KANA},      // Shift+Control
            {KBDNLS_ROMAN,0},                // Alt
            {KBDNLS_ROMAN,0},                // Shift+Alt
            {KBDNLS_ROMAN,0},                // Control+Alt
            {KBDNLS_NOEVENT,0}               // Shift+Control+Alt
        },
        {                    // NLSFEProcIndexAlt
            {KBDNLS_KANAEVENT,VK_KANA},      // Base
            {KBDNLS_KANAEVENT,VK_KANA},      // Shift
            {KBDNLS_KANAEVENT,VK_KANA},      // Control
            {KBDNLS_KANAEVENT,VK_KANA},      // Shift+Control
            {KBDNLS_NOEVENT,0},              // Alt
            {KBDNLS_NOEVENT,0},              // Shift+Alt
            {KBDNLS_NOEVENT,0},              // Control+Alt
            {KBDNLS_NOEVENT,0}               // Shift+Control+Alt
        }
    },
    {
        VK_DBE_SBCSCHAR,     // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SBCSDBCS,0},             // Base
            {KBDNLS_SBCSDBCS,0},             // Shift
            {KBDNLS_SBCSDBCS,0},             // Control
            {KBDNLS_SBCSDBCS,0},             // Shift+Control
            {KBDNLS_SEND_PARAM_VK,VK_KANJI}, // Alt
            {KBDNLS_SBCSDBCS,0},             // Shift+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}, // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}  // Shift+Control+Alt
        },
        {                    // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_CONVERT,          // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_CONV_OR_NONCONV,0},      // Base
            {KBDNLS_CONV_OR_NONCONV,0},      // Shift
            {KBDNLS_CONV_OR_NONCONV,0},      // Control
            {KBDNLS_CONV_OR_NONCONV,0},      // Shift+Control
            {KBDNLS_CONV_OR_NONCONV,0},      // Alt
            {KBDNLS_CONV_OR_NONCONV,0},      // Shift+Alt
            {KBDNLS_CONV_OR_NONCONV,0},      // Control+Alt
            {KBDNLS_CONV_OR_NONCONV,0},      // Shift+Control+Alt
        },
        {                         // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_NONCONVERT,       // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_CONV_OR_NONCONV,0},      // Base
            {KBDNLS_CONV_OR_NONCONV,0},      // Shift
            {KBDNLS_CONV_OR_NONCONV,0},      // Control
            {KBDNLS_CONV_OR_NONCONV,0},      // Shift+Control
            {KBDNLS_CONV_OR_NONCONV,0},      // Alt
            {KBDNLS_CONV_OR_NONCONV,0},      // Shift+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}, // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}  // Shift+Control+Alt
        },
        {                         // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    }
};

/***********************************************************************\
* KbdNlsTables
*
\***********************************************************************/

static ALLOC_SECTION_LDATA KBDNLSTABLES KbdNlsTables = {
    NLSKBD_OEM_FUJITSU,                    // OEM ID (0 = Microsoft)
    NLSKBD_INFO_SEND_IME_NOTIFICATION |
    NLSKBD_INFO_EMURATE_106_KEYBOARD,      // Information
    5,                                     // Number of VK_F entry
    VkToFuncTable_F3AHVOAS,                // Pointer to VK_F array
    0,                                     // Pointer to MouseVk entry
    NULL                                   // Pointer to MouseVk array
};

PKBDNLSTABLES KbdNlsLayerDescriptor(VOID)
{
    return &KbdNlsTables;
}

VOID FujitsuOyayubiControl(DWORD dwOpen, DWORD dwConversion)
{
    NtUserCallTwoParam(dwOpen, dwConversion, SFI_NLSKBDSENDIMENOTIFICATION);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\fe_kbds\jpn\ibm02\kbdibm02.h ===
/****************************** Module Header ******************************\
* Module Name: kbdibm02.h
*
* Copyright (c) 1985-91, Microsoft Corporation
*
* Various defines for use by keyboard input code.
*
* History:
\***************************************************************************/

/*
 * kbd type should be controlled by cl command-line argument
 */
#define KBD_TYPE 7

/*
 * Include the basis of all keyboard table values
 */
#include "kbd.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\fe_kbds\jpn\jpn\kbdjpn.c ===
/***************************************************************************\
* Module Name: kbdjpn.c
*
* Copyright (c) 1985-92, Microsoft Corporation
*
* History:
\***************************************************************************/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#if ((BASE_KEYBOARD_LAYOUT) == 101)
/*
 * include kbd101.c (PC/AT 101 English keyboard layout driver)
 */
#include "..\101\kbd101.c"
#elif ((BASE_KEYBOARD_LAYOUT) == 106)
/*
 * include kbd106.c (PC/AT 106 Japanese keyboard layout driver)
 */
#include "..\106\kbd106.c"
#else
#error "BASE_KEYBOARD_LAYOUT should be 101 or 106."
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\fe_kbds\jpn\ibm02\sources.inc ===
!IF 0

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


!ENDIF

MINORCOMP=kbdibm02

!include ..\..\japan.inc

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\fe_kbds\jpn\inc\kbdjpn.h ===
/****************************** Module Header ******************************\
* Module Name: kbdjpn.h
*
* Copyright (c) 1985-91, Microsoft Corporation
*
* Various defines for use by keyboard input code.
*
* History:
\***************************************************************************/
/*
 * Katakana Unicode
 */
enum _KATAKANA_UNICODE {
    WCH_IP=0xff61, // Ideographic Period
    WCH_OB,        // Opening Corner Bracket
    WCH_CB,        // Closing Corner Bracket
    WCH_IC,        // Ideographic Comma
    WCH_MD,        // Katakana Middle Dot
    WCH_WO,        // Katakana Letter WO
    WCH_AA,        // Katakana Letter Small A
    WCH_II,        // Katakana Letter Small I
    WCH_UU,        // Katakana Letter Small U
    WCH_EE,        // Katakana Letter Small E
    WCH_OO,        // Katakana Letter Small O
    WCH_YAA,       // Katakana Letter Small YA
    WCH_YUU,       // Katakana Letter Small YU
    WCH_YOO,       // Katakana Letter Small YO
    WCH_TUU,       // Katakana Letter Small TU
    WCH_PS,        // Katakana Prolonged Sound Mark
    WCH_A,         // Katakana Letter A
    WCH_I,         // Katakana Letter I
    WCH_U,         // Katakana Letter U
    WCH_E,         // Katakana Letter E
    WCH_O,         // Katakana Letter O
    WCH_KA,        // Katakana Letter KA
    WCH_KI,        // Katakana Letter KI
    WCH_KU,        // Katakana Letter KU
    WCH_KE,        // Katakana Letter KE
    WCH_KO,        // Katakana Letter KO
    WCH_SA,        // Katakana Letter SA
    WCH_SI,        // Katakana Letter SI
    WCH_SU,        // Katakana Letter SU
    WCH_SE,        // Katakana Letter SE
    WCH_SO,        // Katakana Letter SO
    WCH_TA,        // Katakana Letter TA
    WCH_TI,        // Katakana Letter TI
    WCH_TU,        // Katakana Letter TU
    WCH_TE,        // Katakana Letter TE
    WCH_TO,        // Katakana Letter TO
    WCH_NA,        // Katakana Letter NA
    WCH_NI,        // Kanakana Letter NI
    WCH_NU,        // Katakana Letter NU
    WCH_NE,        // Katakana Letter NE
    WCH_NO,        // Katakana Letter NO
    WCH_HA,        // Katakana Letter HA
    WCH_HI,        // Katakana Letter HI
    WCH_HU,        // Katakana Letter HU
    WCH_HE,        // Katakana Letter HE
    WCH_HO,        // Katakana Letter HO
    WCH_MA,        // Katakana Letter MA
    WCH_MI,        // Katakana Letter MI
    WCH_MU,        // Katakana Letter MU
    WCH_ME,        // Katakana Letter ME
    WCH_MO,        // Katakana Letter MO
    WCH_YA,        // Katakana Letter YA
    WCH_YU,        // Katakana Letter YU
    WCH_YO,        // Katakana Letter YO
    WCH_RA,        // Katakana Letter RA
    WCH_RI,        // Katakana Letter RI
    WCH_RU,        // Katakana Letter RU
    WCH_RE,        // Katakana Letter RE
    WCH_RO,        // Katakana Letter RO
    WCH_WA,        // Katakana Letter WA
    WCH_NN,        // Katakana Letter N
    WCH_VS,        // Katakana Voiced Sound Mark
    WCH_SVS        // Katakana Semi-Voiced Sound Mark
};

/***************************************************************************\
* OEM Key Name -
\***************************************************************************/

                                    // lo  hi  lo  hi
#define SZ_KEY_NAME_HENKAN          "\x09\x59\xdb\x63\000\000"
#define SZ_KEY_NAME_MUHENKAN        "\x21\x71\x09\x59\xdb\x63\000\000"
#define SZ_KEY_NAME_KANJI           "\x22\x6f\x57\x5b\000\000"
#define SZ_KEY_NAME_EISU_KANA       "\xf1\x82\x70\x65\x20\000\xab\x30\xca\x30\000\000"
#define SZ_KEY_NAME_HANKAKU_ZENKAKU "\x4a\x53\xd2\x89\x2f\000\x68\x51\xd2\x89\000\000"
#define SZ_KEY_NAME_KATAKANA        "\xab\x30\xbf\x30\xab\x30\xca\x30\000\000"
#define SZ_KEY_NAME_HIRAGANA        "\x72\x30\x89\x30\x4c\x30\x6a\x30\000\000"
// FMR Jul.13.1994 KA
// For the GetKeyNameText() API function.
#define SZ_KEY_NAME_BACKSPACE       "\x8C\x5F\x00\x90\000\000"
#define SZ_KEY_NAME_ENTER           "\x39\x65\x4C\x88\000\000"
#define SZ_KEY_NAME_NUMPADENTER     "\x4E\x00\x75\x00\x6d\x00\x20\x00\x39\x65\x4C\x88\000\000"
#define SZ_KEY_NAME_SPACE           "\x7A\x7A\x7D\x76\000\000"
#define SZ_KEY_NAME_INSERT          "\x3F\x63\x65\x51\000\000"
#define SZ_KEY_NAME_DELETE          "\x4A\x52\x64\x96\000\000"
#define SZ_KEY_NAME_KANAKANJI       "\x4b\x30\x6a\x30\x22\x6f\x57\x5b\000\000"
#define SZ_KEY_NAME_SHIFTLEFT       "\xB7\x30\xD5\x30\xC8\x30\xE6\x5D\000\000"
#define SZ_KEY_NAME_SHIFTRIGHT      "\xB7\x30\xD5\x30\xC8\x30\xF3\x53\000\000"
#define SZ_KEY_NAME_EIJI            "\xF1\x82\x57\x5B\000\000"
#define SZ_KEY_NAME_JISHO           "\x58\x53\x9E\x8A\x9E\x8F\xF8\x66\000\000"
#define SZ_KEY_NAME_MASSHOU         "\x58\x53\x9E\x8A\xB9\x62\x88\x6D\000\000"
#define SZ_KEY_NAME_TOUROKU         "\x58\x53\x9E\x8A\x7B\x76\x32\x93\000\000"
#define SZ_KEY_NAME_PRIOR           "\x4D\x52\x4C\x88\000\000"
#define SZ_KEY_NAME_NEXT            "\x21\x6B\x4C\x88\000\000"
#define SZ_KEY_NAME_CANCEL          "\xD6\x53\x88\x6D\000\000"
#define SZ_KEY_NAME_EXECUTE         "\x9F\x5B\x4C\x88\000\000"
#define SZ_KEY_NAME_TAB             "\xBF\x30\xD6\x30\000\000"


//----------------------[ NEC Code Original Start ]-----------------
                    // ff76(ka) ff85(na) for Unicode
#define SZ_KEY_NAME_KANA        "\x76\xff\x85\xff"
#define SZ_KEY_NAME_F1          "\x66\x00\x65\xff\x31\x00"
#define SZ_KEY_NAME_F2          "\x66\x00\x65\xff\x32\x00"
#define SZ_KEY_NAME_F3          "\x66\x00\x65\xff\x33\x00"
#define SZ_KEY_NAME_F4          "\x66\x00\x65\xff\x34\x00"
#define SZ_KEY_NAME_F5          "\x66\x00\x65\xff\x35\x00"
#define SZ_KEY_NAME_F6          "\x66\x00\x65\xff\x36\x00"
#define SZ_KEY_NAME_F7          "\x66\x00\x65\xff\x37\x00"
#define SZ_KEY_NAME_F8          "\x66\x00\x65\xff\x38\x00"
#define SZ_KEY_NAME_F9          "\x66\x00\x65\xff\x39\x00"
#define SZ_KEY_NAME_F10         "\x66\x00\x65\xff\x31\x00\x30\x00"
#define SZ_KEY_NAME_F11         "\x66\x00\x65\xff\x31\x00\x31\x00"
#define SZ_KEY_NAME_F12         "\x66\x00\x65\xff\x31\x00\x32\x00"
#define SZ_KEY_NAME_F13         "\x66\x00\x65\xff\x31\x00\x33\x00"
#define SZ_KEY_NAME_F14         "\x66\x00\x65\xff\x31\x00\x34\x00"
#define SZ_KEY_NAME_F15         "\x66\x00\x65\xff\x31\x00\x35\x00"

//----------------------[ NEC Code Original Start ]-----------------
//This is NEC Document Processer define
//
#define SZ_KEY_NAME_DP_ZENKAKU_HANKAKU "\x68\x51\xd2\x89\x2f\000\x4a\x53\xd2\x89\000\000"
#define SZ_KEY_NAME_DP_KANA            "\x4b\x30\x6a\x30\000\000"
#define SZ_KEY_NAME_DP_KATAKANA        "\xab\x30\xbf\x30\xab\x30\xca\x30\000\000"
#define SZ_KEY_NAME_DP_EISU            "\xf1\x82\x70\x65\000\000"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\fe_kbds\jpn\ibm02\kbdibm02.c ===
/***************************************************************************\
* Module Name: kbdibm02.c
*
* Copyright (c) 1985-92, Microsoft Corporation
*
* History:
\***************************************************************************/

#include <windows.h>
#include <ime.h>
#include "vkoem.h"
#include "kbdjpn.h"
#include "kbdibm02.h"

#if defined(_M_IA64)
#pragma section(".data")
#define ALLOC_SECTION_LDATA __declspec(allocate(".data"))
#else
#pragma data_seg(".data")
#define ALLOC_SECTION_LDATA
#endif

/***************************************************************************\
* ausVK[] - Virtual Scan Code to Virtual Key conversion table for IBM-J 5576-002
\***************************************************************************/

static ALLOC_SECTION_LDATA USHORT ausVK[] = {
    T00, T01, T02, T03, T04, T05, T06, T07,
    T08, T09, T0A, T0B, T0C, T0D, T0E, T0F,
    T10, T11, T12, T13, T14, T15, T16, T17,
    T18, T19, T1A, T1B, T1C, T1D, T1E, T1F,
    T20, T21, T22, T23, T24, T25, T26, T27,
    T28, T29, T2A, T2B, T2C, T2D, T2E, T2F,
    T30, T31, T32, T33, T34, T35,

    /*
     * Right-hand Shift key must have KBDEXT bit set.
     */
    T36 | KBDEXT,

    T37 | KBDMULTIVK,               // numpad_* + Shift/Alt -> SnapShot

    T38, T39,

    T3A | KBDSPECIAL,              // Alphanumeric/Caps key // NLS key

    T3B, T3C, T3D, T3E, T3F, T40, T41, T42,
    T43, T44,

    /*
     * NumLock Key:
     *     KBDEXT     - VK_NUMLOCK is an Extended key
     *     KBDMULTIVK - VK_NUMLOCK or VK_PAUSE (without or with CTRL)
     */
    T45 | KBDEXT | KBDMULTIVK,

    T46 | KBDMULTIVK,

    /*
     * Number Pad keys:
     *     KBDNUMPAD  - digits 0-9 and decimal point.
     *     KBDSPECIAL - require special processing by Windows
     */
    T47 | KBDNUMPAD | KBDSPECIAL,   // Numpad 7 (Home)
    T48 | KBDNUMPAD | KBDSPECIAL,   // Numpad 8 (Up),
    T49 | KBDNUMPAD | KBDSPECIAL,   // Numpad 9 (PgUp),
    T4A,
    T4B | KBDNUMPAD | KBDSPECIAL,   // Numpad 4 (Left),
    T4C | KBDNUMPAD | KBDSPECIAL,   // Numpad 5 (Clear),
    T4D | KBDNUMPAD | KBDSPECIAL,   // Numpad 6 (Right),
    T4E,
    T4F | KBDNUMPAD | KBDSPECIAL,   // Numpad 1 (End),
    T50 | KBDNUMPAD | KBDSPECIAL,   // Numpad 2 (Down),
    T51 | KBDNUMPAD | KBDSPECIAL,   // Numpad 3 (PgDn),
    T52 | KBDNUMPAD | KBDSPECIAL,   // Numpad 0 (Ins),
    T53 | KBDNUMPAD | KBDSPECIAL,   // Numpad . (Del),

    T54, T55, T56, T57, T58, T59, T5A, T5B,
    T5C, T5D, T5E, T5F, T60, T61, T62, T63,
    T64, T65, T66, T67, T68, T69, T6A, T6B,
    T6C, T6D, T6E, T6F,

    T70 | KBDSPECIAL,              // Katakana/Kanji key

    T71, T72,

    T73,                           // | \ Katakana RO key   // NLS key

    T74, T75, T76,

    T77 | KBDSPECIAL,              // SBCS/DBCS key         // NLS key

    T78,

    T79 | KBDSPECIAL,              // Conversion key        // NLS key

    T7A,

    T7B | KBDSPECIAL               // Non-Conversion key    // NLS key
};

static ALLOC_SECTION_LDATA VSC_VK aE0VscToVk[] = {
        { 0x1C, X1C | KBDEXT              },  // Numpad Enter
        { 0x1D, X1D | KBDEXT              },  // RControl
        { 0x33, X33 | KBDEXT              },  // Comma key by 5576-002 special
        { 0x35, X35 | KBDEXT              },  // Numpad Divide
        { 0x37, X37 | KBDEXT              },  // Snapshot
        { 0x38, X38 | KBDEXT | KBDSPECIAL },  // Hiragana key   // NLS key
        { 0x46, X46 | KBDEXT              },  // Break (Ctrl + Pause)
        { 0x47, X47 | KBDEXT              },  // Home
        { 0x48, X48 | KBDEXT              },  // Up
        { 0x49, X49 | KBDEXT              },  // Prior
        { 0x4B, X4B | KBDEXT              },  // Left
        { 0x4D, X4D | KBDEXT              },  // Right
        { 0x4F, X4F | KBDEXT              },  // End
        { 0x50, X50 | KBDEXT              },  // Down
        { 0x51, X51 | KBDEXT              },  // Next
        { 0x52, X52 | KBDEXT              },  // Insert
        { 0x53, X53 | KBDEXT              },  // Delete
        { 0x5B, X5B | KBDEXT              },  // Left Win
        { 0x5C, X5C | KBDEXT              },  // Right Win
        { 0x5D, X5D | KBDEXT              },  // Application
        { 0,      0                       }
};

static ALLOC_SECTION_LDATA VSC_VK aE1VscToVk[] = {
        { 0x1D, Y1D                       },  // Pause
        { 0   ,   0                       }
};

/***************************************************************************\
* aVkToBits[]  - map Virtual Keys to Modifier Bits
*
* See kbd.h for a full description.
*
* US Keyboard has only three shifter keys:
*     SHIFT (L & R) affects alphabnumeric keys,
*     CTRL  (L & R) is used to generate control characters
*     ALT   (L & R) used for generating characters by number with numpad
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_BIT aVkToBits[] = {
    { VK_SHIFT,   KBDSHIFT },
    { VK_CONTROL, KBDCTRL  },
    { VK_MENU,    KBDALT   },
    { VK_KANA,    KBDKANA  },
    { 0,          0        }
};

/***************************************************************************\
* aModification[]  - map character modifier bits to modification number
*
* See kbd.h for a full description.
*
\***************************************************************************/

static ALLOC_SECTION_LDATA MODIFIERS CharModifiers = {
    &aVkToBits[0],
    11,
    {
    //  Modification# //  Keys Pressed  : Explanation
    //  ============= // ============== : =============================
        0,            //                : unshifted characters
        1,            //          SHIFT : capitals, ~!@#$%^&*()_+{}:"<>? etc.
        4,            //     CTRL       : control characters
        6,            //     CTRL SHIFT :
        SHFT_INVALID, // ALT            : invalid
        SHFT_INVALID, // ALT      SHIFT : invalid
        SHFT_INVALID, // ALT CTRL       : invalid
        SHFT_INVALID, // ALT CTRL SHIFT : invalid
        2,            //KANA
        3,            //KANA      SHIFT
        5,            //KANA CTRL
        7             //KANA CTRL SHIFT
    }
};

/***************************************************************************\
*
* aVkToWch2[]  - Virtual Key to WCHAR translation for 2 shift states
* aVkToWch3[]  - Virtual Key to WCHAR translation for 3 shift states
* aVkToWch4[]  - Virtual Key to WCHAR translation for 4 shift states
*
* Table attributes: Unordered Scan, null-terminated
*
* Search this table for an entry with a matching Virtual Key to find the
* corresponding unshifted and shifted WCHAR characters.
*
* Reserved VirtualKey values (first column)
*     -1            - this line contains dead characters (diacritic)
*     0             - terminator
*
* Reserved Attribute values (second column)
*     CAPLOK        - CapsLock affects this key like Shift
*     KANALOK       - The KANA-LOCK key affects this key like KANA
*
* Reserved character values (third through last column)
*     WCH_NONE      - No character
*     WCH_DEAD      - Dead character (diacritic) value is in next line
*
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch4[] = {
    //                               |          |   SHIFT  |  KANA  | K+SHFT |
    //                               |          |==========|========|========|
    {'0'          ,          KANALOK ,'0'       ,WCH_NONE  ,WCH_WA  ,WCH_WO  },
    {'1'          ,          KANALOK ,'1'       ,'!'       ,WCH_NU  ,WCH_NU  },
    {'3'          ,          KANALOK ,'3'       ,'#'       ,WCH_A   ,WCH_AA  },
    {'4'          ,          KANALOK ,'4'       ,'$'       ,WCH_U   ,WCH_UU  },
    {'5'          ,          KANALOK ,'5'       ,'%'       ,WCH_E   ,WCH_EE  },
    {'7'          ,          KANALOK ,'7'       ,0x27      ,WCH_YA  ,WCH_YAA },
    {'8'          ,          KANALOK ,'8'       ,'('       ,WCH_YU  ,WCH_YUU },
    {'9'          ,          KANALOK ,'9'       ,')'       ,WCH_YO  ,WCH_YOO },
    {'A'          , CAPLOK | KANALOK ,'a'       ,'A'       ,WCH_TI  ,WCH_TI  },
    {'B'          , CAPLOK | KANALOK ,'b'       ,'B'       ,WCH_KO  ,WCH_KO  },
    {'C'          , CAPLOK | KANALOK ,'c'       ,'C'       ,WCH_SO  ,WCH_SO  },
    {'D'          , CAPLOK | KANALOK ,'d'       ,'D'       ,WCH_SI  ,WCH_SI  },
    {'E'          , CAPLOK | KANALOK ,'e'       ,'E'       ,WCH_I   ,WCH_II  },
    {'F'          , CAPLOK | KANALOK ,'f'       ,'F'       ,WCH_HA  ,WCH_HA  },
    {'G'          , CAPLOK | KANALOK ,'g'       ,'G'       ,WCH_KI  ,WCH_KI  },
    {'H'          , CAPLOK | KANALOK ,'h'       ,'H'       ,WCH_KU  ,WCH_KU  },
    {'I'          , CAPLOK | KANALOK ,'i'       ,'I'       ,WCH_NI  ,WCH_NI  },
    {'J'          , CAPLOK | KANALOK ,'j'       ,'J'       ,WCH_MA  ,WCH_MA  },
    {'K'          , CAPLOK | KANALOK ,'k'       ,'K'       ,WCH_NO  ,WCH_NO  },
    {'L'          , CAPLOK | KANALOK ,'l'       ,'L'       ,WCH_RI  ,WCH_RI  },
    {'M'          , CAPLOK | KANALOK ,'m'       ,'M'       ,WCH_MO  ,WCH_MO  },
    {'N'          , CAPLOK | KANALOK ,'n'       ,'N'       ,WCH_MI  ,WCH_MI  },
    {'O'          , CAPLOK | KANALOK ,'o'       ,'O'       ,WCH_RA  ,WCH_RA  },
    {'P'          , CAPLOK | KANALOK ,'p'       ,'P'       ,WCH_SE  ,WCH_SE  },
    {'Q'          , CAPLOK | KANALOK ,'q'       ,'Q'       ,WCH_TA  ,WCH_TA  },
    {'R'          , CAPLOK | KANALOK ,'r'       ,'R'       ,WCH_SU  ,WCH_SU  },
    {'S'          , CAPLOK | KANALOK ,'s'       ,'S'       ,WCH_TO  ,WCH_TO  },
    {'T'          , CAPLOK | KANALOK ,'t'       ,'T'       ,WCH_KA  ,WCH_KA  },
    {'U'          , CAPLOK | KANALOK ,'u'       ,'U'       ,WCH_NA  ,WCH_NA  },
    {'V'          , CAPLOK | KANALOK ,'v'       ,'V'       ,WCH_HI  ,WCH_HI  },
    {'W'          , CAPLOK | KANALOK ,'w'       ,'W'       ,WCH_TE  ,WCH_TE  },
    {'X'          , CAPLOK | KANALOK ,'x'       ,'X'       ,WCH_SA  ,WCH_SA  },
    {'Y'          , CAPLOK | KANALOK ,'y'       ,'Y'       ,WCH_NN  ,WCH_NN  },
    {'Z'          , CAPLOK | KANALOK ,'z'       ,'Z'       ,WCH_TU  ,WCH_TUU },
    {VK_OEM_1     ,          KANALOK ,':'       ,'*'       ,WCH_KE  ,WCH_KE  },
    {VK_OEM_2     ,          KANALOK ,'/'       ,'?'       ,WCH_ME  ,WCH_MD  },
    {VK_OEM_3     ,          KANALOK ,'@'       ,'`'       ,WCH_VS  ,WCH_VS  },
    {VK_OEM_7     ,          KANALOK ,'^'       ,'~'       ,WCH_HE  ,WCH_HE  },
    {VK_OEM_8     , 0                ,','       ,','       ,','     ,','     },
    {VK_OEM_COMMA ,          KANALOK ,','       ,'<'       ,WCH_NE  ,WCH_IC  },
    {VK_OEM_PERIOD,          KANALOK ,'.'       ,'>'       ,WCH_RU  ,WCH_IP  },
    {VK_OEM_PLUS  ,          KANALOK ,';'       ,'+'       ,WCH_RE  ,WCH_RE  },
    {VK_TAB       , 0                ,'\t'      ,'\t'      ,'\t'    ,'\t'    },
    {VK_ADD       , 0                ,'+'       ,'+'       ,'+'     ,'+'     },
    {VK_DECIMAL   , 0                ,'.'       ,'.'       ,'.'     ,'.'     },
    {VK_DIVIDE    , 0                ,'/'       ,'/'       ,'/'     ,'/'     },
    {VK_MULTIPLY  , 0                ,'*'       ,'*'       ,'*'     ,'*'     },
    {VK_SUBTRACT  , 0                ,'-'       ,'-'       ,'-'     ,'-'     },
    {0            , 0                ,0         ,0         ,0       ,0       }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS6 aVkToWch6[] = {
    //                      |          |   SHIFT  |  KANA  | K+SHFT |  CONTROL  |  K+CTRL   |
    //                      |          |==========|========|========|===========|===========|
    {VK_BACK      , 0       ,'\b'      ,'\b'      ,'\b'    ,'\b'    , 0x7f      , 0x7f      },
    {VK_CANCEL    , 0       ,0x03      ,0x03      ,0x03    ,0x03    , 0x03      , 0x03      },
    {VK_ESCAPE    , 0       ,0x1b      ,0x1b      ,0x1b    ,0x1b    , 0x1b      , 0x1b      },
    {VK_OEM_4     , KANALOK ,'['       ,'{'       ,WCH_SVS ,WCH_OB  , 0x1b      , 0x1b      },
    {VK_OEM_5     , KANALOK ,'\\'      ,'|'       ,WCH_PS  ,WCH_PS  , 0x1c      , 0x1c      },
    {VK_OEM_102   , KANALOK ,'\\'      ,'_'       ,WCH_RO  ,WCH_RO  , 0x1c      , 0x1c      },
    {VK_OEM_6     , KANALOK ,']'       ,'}'       ,WCH_MU  ,WCH_CB  , 0x1d      , 0x1d      },
    {VK_RETURN    , 0       ,'\r'      ,'\r'      ,'\r'    ,'\r'    , '\n'      , '\n'      },
    {VK_SPACE     , 0       ,' '       ,' '       ,' '     ,' '     , 0x20      , 0x20      },
    {0            , 0       ,0         ,0         ,0       ,0       , 0         , 0         }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS8 aVkToWch8[] = {
    //                      |          |   SHIFT  |  KANA  | K+SHFT |  CONTROL  |  K+CTRL   | SHFT+CTRL |K+SHFT+CTRL|
    //                      |          |==========|========|========|===========|===========|===========|===========|
    {'2'          , KANALOK ,'2'       ,'"'       ,WCH_HU  ,WCH_HU  , WCH_NONE  , WCH_NONE  , 0x00      , 0x00      },
    {'6'          , KANALOK ,'6'       ,'&'       ,WCH_O   ,WCH_OO  , WCH_NONE  , WCH_NONE  , 0x1e      , 0x1e      },
    {VK_OEM_MINUS , KANALOK ,'-'       ,'='       ,WCH_HO  ,WCH_HO  , WCH_NONE  , WCH_NONE  , 0x1f      , 0x1f      },
    {0            , 0       ,0         ,0         ,0       ,0       , 0         , 0         , 0         , 0         }
};

// Put this last so that VkKeyScan interprets number characters
// as coming from the main section of the kbd (aVkToWch2 and
// aVkToWch4) before considering the numpad (aVkToWch1).

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch1[] = {
    //                     |          |   SHIFT  |  KANA  | K+SHFT |
    //                     |          |==========|========|========|
    { VK_NUMPAD0   , 0      ,  '0'    , WCH_NONE ,   '0'  ,WCH_NONE},
    { VK_NUMPAD1   , 0      ,  '1'    , WCH_NONE ,   '1'  ,WCH_NONE},
    { VK_NUMPAD2   , 0      ,  '2'    , WCH_NONE ,   '2'  ,WCH_NONE},
    { VK_NUMPAD3   , 0      ,  '3'    , WCH_NONE ,   '3'  ,WCH_NONE},
    { VK_NUMPAD4   , 0      ,  '4'    , WCH_NONE ,   '4'  ,WCH_NONE},
    { VK_NUMPAD5   , 0      ,  '5'    , WCH_NONE ,   '5'  ,WCH_NONE},
    { VK_NUMPAD6   , 0      ,  '6'    , WCH_NONE ,   '6'  ,WCH_NONE},
    { VK_NUMPAD7   , 0      ,  '7'    , WCH_NONE ,   '7'  ,WCH_NONE},
    { VK_NUMPAD8   , 0      ,  '8'    , WCH_NONE ,   '8'  ,WCH_NONE},
    { VK_NUMPAD9   , 0      ,  '9'    , WCH_NONE ,   '9'  ,WCH_NONE},
    { 0            , 0      ,  '\0'   , 0        ,   0    ,0       }   //null terminator
};

/***************************************************************************\
* aVkToWcharTable: table of pointers to Character Tables
*
* Describes the character tables and the order they should be searched.
*
* Note: the order determines the behavior of VkKeyScan() : this function
*       takes a character and attempts to find a Virtual Key and character-
*       modifier key combination that produces that character.  The table
*       containing the numeric keypad (aVkToWch1) must appear last so that
*       VkKeyScan('0') will be interpreted as one of keys from the main
*       section, not the numpad.  etc.
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHAR_TABLE aVkToWcharTable[] = {
    {  (PVK_TO_WCHARS1)aVkToWch6, 6, sizeof(aVkToWch6[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch8, 8, sizeof(aVkToWch8[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch4, 4, sizeof(aVkToWch4[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch1, 4, sizeof(aVkToWch1[0]) },  // must come last
    {                       NULL, 0, 0                    }
};

/***************************************************************************\
* aKeyNames[], aKeyNamesExt[]  - Scan Code -> Key Name tables
*
* For the GetKeyNameText() API function
*
* Tables for non-extended and extended (KBDEXT) keys.
* (Keys producing printable characters are named by the character itself)
\***************************************************************************/

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNames[] = {
    0x01,    L"Esc",
    0x0e,    L"Backspace",
    0x0f,    L"Tab",
    0x1c,    L"Enter",
    0x1d,    L"Ctrl",
    0x2a,    L"Shift",
    0x36,    L"Right Shift",
    0x37,    L"Num *",
    0x38,    L"Alt",
    0x39,    L"Space",
    0x3a,    L"Caps Lock",
    0x3b,    L"F1",
    0x3c,    L"F2",
    0x3d,    L"F3",
    0x3e,    L"F4",
    0x3f,    L"F5",
    0x40,    L"F6",
    0x41,    L"F7",
    0x42,    L"F8",
    0x43,    L"F9",
    0x44,    L"F10",
    0x45,    L"Pause",
    0x46,    L"Scroll Lock",
    0x47,    L"Num 7",
    0x48,    L"Num 8",
    0x49,    L"Num 9",
    0x4a,    L"Num -",
    0x4b,    L"Num 4",
    0x4c,    L"Num 5",
    0x4d,    L"Num 6",
    0x4e,    L"Num +",
    0x4f,    L"Num 1",
    0x50,    L"Num 2",
    0x51,    L"Num 3",
    0x52,    L"Num 0",
    0x53,    L"Num Del",
    0x54,    L"Sys Req",
    0x57,    L"F11",
    0x58,    L"F12",
    0x70,    (LPWSTR)SZ_KEY_NAME_KATAKANA,        // NLS Key
    0x77,    (LPWSTR)SZ_KEY_NAME_HANKAKU_ZENKAKU, // NLS Key
    0x79,    (LPWSTR)SZ_KEY_NAME_HENKAN,          // NLS Key
    0x7b,    (LPWSTR)SZ_KEY_NAME_MUHENKAN,        // NLS Key
    0   ,    NULL
};

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNamesExt[] = {
    0x1c,    L"Num Enter",
    0x1d,    L"Right Control",
    0x35,    L"Num /",
    0x37,    L"Prnt Scrn",
    0x38,    (LPWSTR)SZ_KEY_NAME_HIRAGANA,        // NLS Key
    0x45,    L"Num Lock",
    0x46,    L"Break",
    0x47,    L"Home",
    0x48,    L"Up",
    0x49,    L"Page Up",
    0x4b,    L"Left",
    0x4d,    L"Right",
    0x4f,    L"End",
    0x50,    L"Down",
    0x51,    L"Page Down",
    0x52,    L"Insert",
    0x53,    L"Delete",
    0x54,    L"<00>",
    0x56,    L"Help",
    0x5B,    L"Left Windows",
    0x5C,    L"Right Windows",
    0x5D,    L"Application",
    0   ,    NULL
};

static ALLOC_SECTION_LDATA KBDTABLES KbdTables = {
    /*
     * Modifier keys
     */
    &CharModifiers,

    /*
     * Characters tables
     */
    aVkToWcharTable,

    /*
     * Diacritics  (none for US English)
     */
    NULL,

    /*
     * Names of Keys  (no dead keys)
     */
    aKeyNames,
    aKeyNamesExt,
    NULL,

    /*
     * Scan codes to Virtual Keys
     */
    ausVK,
    sizeof(ausVK) / sizeof(ausVK[0]),
    aE0VscToVk,
    aE1VscToVk,

    /*
     * No Locale-specific special processing
     */
    0,

    /*
     * No Ligatures
     */
    0, 0, NULL,

    /*
     * Type and subtype
     */
    KEYBOARD_TYPE_JAPAN,
    MAKEWORD(MICROSOFT_KBD_001_TYPE, NLSKBD_OEM_MICROSOFT),
};

PKBDTABLES KbdLayerDescriptor(VOID)
{
    return &KbdTables;
}

/***********************************************************************\
* VkToFuncTable_101[]
*
\***********************************************************************/

static ALLOC_SECTION_LDATA VK_F VkToFuncTable_IBM002[] = {
    {
        VK_DBE_KATAKANA,            // Base Vk
        KBDNLS_TYPE_TOGGLE,         // NLSFEProcType
        KBDNLS_INDEX_NORMAL,        // NLSFEProcCurrent
        0x04, /* 00000100 */        // NLSFEProcSwitch
        {                           // NLSFEProc
            {KBDNLS_KATAKANA,0},             // Base
            {KBDNLS_SEND_PARAM_VK,VK_KANJI}, // Shift
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Control
            {KBDNLS_NOEVENT,0},              // Shift+Control
            {KBDNLS_CODEINPUT,0},            // Alt
            {KBDNLS_CODEINPUT,0},            // Shift+Alt
            {KBDNLS_CODEINPUT,0},            // Control+Alt
            {KBDNLS_CODEINPUT,0}             // Shift+Control+Alt
        },
        {                           // NLSFEProcAlt
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Base
            {KBDNLS_NOEVENT,0},              // Shift
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Control
            {KBDNLS_NOEVENT,0},              // Shift+Control
            {KBDNLS_NOEVENT,0},              // Alt
            {KBDNLS_NOEVENT,0},              // Shift+Alt
            {KBDNLS_NOEVENT,0},              // Control+Alt
            {KBDNLS_NOEVENT,0}               // Shift+Control+Alt
        }
    },
    {
        VK_DBE_ALPHANUMERIC,     // Base Vk
        KBDNLS_TYPE_TOGGLE,      // NLSFEProcType
        KBDNLS_INDEX_NORMAL,     // NLSFEProcCurrent
        0xFE, /* 11111110 */     // NLSFEProcSwitch
        {                        // NLSFEProc
            {KBDNLS_ALPHANUM,0},               // Base
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Shift
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Control
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Shift+Control
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Alt
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Shift+Alt
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}  // Shift+Control+Alt
        },
        {                    // NLSFEProcIndexAlt
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Base
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Shift
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Control
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Shift+Control
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Alt
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Shift+Alt
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}  // Shift+Control+Alt
        }
    },
    {
        VK_DBE_HIRAGANA,         // Base Vk
        KBDNLS_TYPE_NORMAL,      // NLSFEProcType
        KBDNLS_INDEX_NORMAL,     // NLSFEProcCurrent
        0,                       // NLSFEProcSwitch
        {                        // NLSFEProc
            {KBDNLS_HIRAGANA,0}, // Base
            {KBDNLS_HIRAGANA,0}, // Shift
            {KBDNLS_HIRAGANA,0}, // Control
            {KBDNLS_HIRAGANA,0}, // Shift+Control
            {KBDNLS_ROMAN,0},    // Alt
            {KBDNLS_ROMAN,0},    // Shift+Alt
            {KBDNLS_ROMAN,0},    // Control+Alt
            {KBDNLS_ROMAN,0}     // Shift+Control+Alt
        },
        {                    // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},     // Base
            {KBDNLS_NULL,0},     // Shift
            {KBDNLS_NULL,0},     // Control
            {KBDNLS_NULL,0},     // Shift+Control
            {KBDNLS_NULL,0},     // Alt
            {KBDNLS_NULL,0},     // Shift+Alt
            {KBDNLS_NULL,0},     // Control+Alt
            {KBDNLS_NULL,0}      // Shift+Control+Alt
        }
    },
    {
        VK_DBE_SBCSCHAR,         // Base Vk
        KBDNLS_TYPE_NORMAL,      // NLSFEProcType
        KBDNLS_INDEX_NORMAL,     // NLSFEProcCurrent
        0,                       // NLSFEProcSwitch
        {                        // NLSFEProc
            {KBDNLS_SBCSDBCS,0}, // Base
            {KBDNLS_SBCSDBCS,0}, // Shift
            {KBDNLS_SBCSDBCS,0}, // Control
            {KBDNLS_SBCSDBCS,0}, // Shift+Control
            {KBDNLS_NOEVENT,0},    // Alt
            {KBDNLS_NOEVENT,0},    // Shift+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}, // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}  // Shift+Control+Alt
        },
        {                    // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},     // Base
            {KBDNLS_NULL,0},     // Shift
            {KBDNLS_NULL,0},     // Control
            {KBDNLS_NULL,0},     // Shift+Control
            {KBDNLS_NULL,0},     // Alt
            {KBDNLS_NULL,0},     // Shift+Alt
            {KBDNLS_NULL,0},     // Control+Alt
            {KBDNLS_NULL,0}      // Shift+Control+Alt
        }
    },
    {
        VK_NONCONVERT,           // Base Vk
        KBDNLS_TYPE_NORMAL,      // NLSFEProcType
        KBDNLS_INDEX_NORMAL,     // NLSFEProcCurrent
        0,                       // NLSFEProcSwitch
        {                        // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0}, // Base
            {KBDNLS_NOEVENT,0},      // Shift
            {KBDNLS_NOEVENT,0},      // Control
            {KBDNLS_NOEVENT,0},      // Shift+Control
            {KBDNLS_NOEVENT,0},      // Alt
            {KBDNLS_NOEVENT,0},      // Shift+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}, // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}  // Shift+Control+Alt
        },
        {                    // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},     // Base
            {KBDNLS_NULL,0},     // Shift
            {KBDNLS_NULL,0},     // Control
            {KBDNLS_NULL,0},     // Shift+Control
            {KBDNLS_NULL,0},     // Alt
            {KBDNLS_NULL,0},     // Shift+Alt
            {KBDNLS_NULL,0},     // Control+Alt
            {KBDNLS_NULL,0}      // Shift+Control+Alt
        }
    }
};

/***********************************************************************\
* KbdNlsTables
*
\***********************************************************************/

static ALLOC_SECTION_LDATA KBDNLSTABLES KbdNlsTables = {
    0,                      // OEM ID (0 = Microsoft)
    0,                      // Information
    5,                      // Number of VK_F entry
    VkToFuncTable_IBM002,   // Pointer to VK_F array
    0,                      // Pointer to MouseVk entry
    NULL                    // Pointer to MouseVk array
};

PKBDNLSTABLES KbdNlsLayerDescriptor(VOID)
{
    return &KbdNlsTables;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\fe_kbds\jpn\kbdnec\kbdnec.h ===
/****************************** Module Header ******************************\
* Module Name: kbdnec.h
*
* Copyright (c) 1985-98, Microsoft Corporation
*
* Various defines for use by keyboard input code.
*
* History:
* 27-May-1992 KazuM
\***************************************************************************/

/*
 * kbd type should be controlled by cl command-line argument
 */
#define KBD_TYPE 30

/*
 * Include the basis of all keyboard table values
 */
#include "kbd.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\fe_kbds\jpn\kbdnec\sources.inc ===
!IF 0

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


!ENDIF

MINORCOMP=kbdnec

!include ..\..\japan.inc

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\fe_kbds\jpn\jpn\multi.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <kbd.h>

BOOL EnumDynamicSwitchingLayouts(LPCWSTR lpwszBaseDll, PKBDTABLE_MULTI pKbdTableMulti);

BOOL KbdLayerMultiDescriptor(PKBDTABLE_MULTI pKbdTableMulti)
{
    /*
     * Firstly, try to get the setting from the registry.
     */
    if (EnumDynamicSwitchingLayouts(L"kbdjpn", pKbdTableMulti)) {
        return TRUE;
    }

    /*
     * If we failed to get the registry, set the default ones.
     */
    pKbdTableMulti->nTables = 3;

    wcscpy(pKbdTableMulti->aKbdTables[0].wszDllName, L"kbd101.dll");
    pKbdTableMulti->aKbdTables[0].dwType = 4;
    pKbdTableMulti->aKbdTables[0].dwSubType = MAKEWORD(MICROSOFT_KBD_101_TYPE, NLSKBD_OEM_MICROSOFT);

    wcscpy(pKbdTableMulti->aKbdTables[1].wszDllName, L"kbd106.dll");
    pKbdTableMulti->aKbdTables[1].dwType = 7;
    pKbdTableMulti->aKbdTables[1].dwSubType = MAKEWORD(MICROSOFT_KBD_106_TYPE, NLSKBD_OEM_MICROSOFT);

    wcscpy(pKbdTableMulti->aKbdTables[2].wszDllName, L"kbdnec.dll");
    pKbdTableMulti->aKbdTables[2].dwType = 7;
    pKbdTableMulti->aKbdTables[2].dwSubType = MAKEWORD(NEC_KBD_N_MODE_TYPE, NLSKBD_OEM_NEC);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\fe_kbds\jpn\kbdnec95\kbdnec95.h ===
#if defined(_PC98_)
/****************************** Module Header ******************************\
* Module Name: kbdnec95.h
*
* Copyright (c) 1985-98, Microsoft Corporation
*
* Various defines for use by keyboard input code.
*
* History:
* 27-May-1992 KazuM
\***************************************************************************/
#else
/****************************** Module Header ******************************\
* Module Name: kbd106.h
*
* Copyright (c) 1985-91, Microsoft Corporation
*
* Various defines for use by keyboard input code.
*
* History:
\***************************************************************************/
#endif

/*
 * kbd type should be controlled by cl command-line argument
 */
#if defined(_PC98_)
#define KBD_TYPE 37
#else
#define KBD_TYPE 8
#endif

/*
 * Include the basis of all keyboard table values
 */
#include "kbd.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\fe_kbds\jpn\jpn\sources.inc ===
!IF 0

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


!ENDIF

MINORCOMP=kbdjpn

!include ..\..\japan.inc

SOURCES_USED=..\sources.inc

TARGETLIBS=$(SDK_LIB_PATH)\ntdll.lib
LINKLIBS=..\..\..\common\$(ALT_PROJECT)\$(O)\fekbdcom.lib

INCLUDES=$(INCLUDES);..\;..\inc;$(NTUSER_PATH)\inc;..\$(BASE_KEYBOARD_LAYOUT)

C_DEFINES=$(C_DEFINES) -DBASE_KEYBOARD_LAYOUT=$(BASE_KEYBOARD_LAYOUT)

BASE_KEYBOARD_LAYOUT=101

SOURCES=    kbdjpn.rc \
            kbdjpn.c \
            multi.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\fe_kbds\jpn\kbdnec95\kbdnec95.c ===
#if defined(JAPAN) && defined(_PC98_)
/***************************************************************************\
* Module Name: kbdnec95.c
*
* Copyright (c) 1985-97, NEC Corporation
*
* History:
\***************************************************************************/
#else  // _PC98_
/***************************************************************************\
* Module Name: kbd106.c
*
* Copyright (c) 1985-92, Microsoft Corporation
*
* History:
\***************************************************************************/
#endif // _PC98_

#include <windows.h>
#include <ime.h>
#include "vkoem.h"
#include "kbdjpn.h"
#if defined(JAPAN) && defined(_PC98_)
#include "kbdnec95.h"
#else  // _PC98_
#include "kbd106.h"
#endif // _PC98_

#if defined(_M_IA64)
#pragma section(".data")
#define ALLOC_SECTION_LDATA __declspec(allocate(".data"))
#else
#pragma data_seg(".data")
#define ALLOC_SECTION_LDATA
#endif

#if defined(JAPAN) && defined(_PC98_)
/***************************************************************************\
* ausVK[] - Virtual Scan Code to Virtual Key conversion table for NEC 106
\***************************************************************************/
#else // _PC98_
/***************************************************************************\
* ausVK[] - Virtual Scan Code to Virtual Key conversion table for 106
\***************************************************************************/
#endif // _PC98_

static ALLOC_SECTION_LDATA USHORT ausVK[] = {
    T00, T01, T02, T03, T04, T05, T06, T07,
    T08, T09, T0A, T0B, T0C, T0D, T0E, T0F,
    T10, T11, T12, T13, T14, T15, T16, T17,
    T18, T19, T1A, T1B, T1C, T1D, T1E, T1F,
    T20, T21, T22, T23, T24, T25, T26, T27,
#if defined(JAPAN) && defined(_PC98_)
    T28, T29, T2A, T2B, T2C, T2D, T2E, T2F,
    T30, T31, T32, T33, T34,

    /*
     * Conversion key must have KBDSPECIAL bit set (NLS key)
     */
    T35 | KBDSPECIAL,
#else // _PC98_
    T28,

    /*
     * Hankaku/Zenkaku/Kanji key must have KBDSPECIAL bit set (NLS key)
     */
    T29 | KBDSPECIAL,

              T2A, T2B, T2C, T2D, T2E, T2F,
    T30, T31, T32, T33, T34, T35,
#endif // _PC98_

#if defined(JAPAN) && defined(_PC98_)
    T36, T37,
#else //_PC98_
    /*
     * Right-hand Shift key must have KBDEXT bit set.
     */
    T36 | KBDEXT,

    /*
     * numpad_* + Shift/Alt -> SnapShot
     */
    T37 | KBDMULTIVK,
#endif // _PC98_

    T38, T39,

#if defined(JAPAN) && defined(_PC98_)
    T3A,
#else //_PC98_
    /*
     * Alphanumeric/CapsLock key must have KBDSPECIAL bit set (NLS key)
     */
    T3A | KBDSPECIAL,
#endif // _PC98_

                   T3B, T3C, T3D, T3E, T3F,

#if defined(JAPAN) && defined(_PC98_)
    /*
     * Number Pad keys:
     *     KBDNUMPAD  - digits 0-9 and decimal point.
     *     KBDSPECIAL - require special processing by Windows
     */

    T40,                            // Numpad -
    T41,                            // Numpad /
    T42 | KBDNUMPAD | KBDSPECIAL,   // Numpad 7 (Home)
    T43 | KBDNUMPAD | KBDSPECIAL,   // Numpad 8 (Up)
    T44 | KBDNUMPAD | KBDSPECIAL,   // Numpad 9 (PgUp)
    T45,                            // Numpad *
    T46 | KBDNUMPAD | KBDSPECIAL,   // Numpad 4 (Left)
    T47 | KBDNUMPAD | KBDSPECIAL,   // Numpad 5 (Clear)
    T48 | KBDNUMPAD | KBDSPECIAL,   // Numpad 6 (Right)
    T49,                            // Numpad +
    T4A | KBDNUMPAD | KBDSPECIAL,   // Numpad 1 (End)
    T4B | KBDNUMPAD | KBDSPECIAL,   // Numpad 2 (Down)
    T4C | KBDNUMPAD | KBDSPECIAL,   // Numpad 3 (PgDn)
    T4D | KBDNUMPAD | KBDSPECIAL,   // Numpad =
    T4E | KBDNUMPAD | KBDSPECIAL,   // Numpad 0 (Ins)
    T4F,                            // Numpad ,
    T50 | KBDNUMPAD | KBDSPECIAL,   // Numpad . (Del)

    /*
     * Non-Conversion key must have KBDSPECIAL bit set (NLS key)
     */
    T51 | KBDSPECIAL,

    T52, T53,
#else //_PC98_
    T40, T41, T42, T43, T44,

    /*
     * NumLock Key:
     *     KBDEXT     - VK_NUMLOCK is an Extended key
     *     KBDMULTIVK - VK_NUMLOCK or VK_PAUSE (without or with CTRL)
     */
    T45 | KBDEXT | KBDMULTIVK,

    T46 | KBDMULTIVK,

    /*
     * Number Pad keys:
     *     KBDNUMPAD  - digits 0-9 and decimal point.
     *     KBDSPECIAL - require special processing by Windows
     */
    T47 | KBDNUMPAD | KBDSPECIAL,   // Numpad 7 (Home)
    T48 | KBDNUMPAD | KBDSPECIAL,   // Numpad 8 (Up),
    T49 | KBDNUMPAD | KBDSPECIAL,   // Numpad 9 (PgUp),
    T4A,
    T4B | KBDNUMPAD | KBDSPECIAL,   // Numpad 4 (Left),
    T4C | KBDNUMPAD | KBDSPECIAL,   // Numpad 5 (Clear),
    T4D | KBDNUMPAD | KBDSPECIAL,   // Numpad 6 (Right),
    T4E,
    T4F | KBDNUMPAD | KBDSPECIAL,   // Numpad 1 (End),
    T50 | KBDNUMPAD | KBDSPECIAL,   // Numpad 2 (Down),
    T51 | KBDNUMPAD | KBDSPECIAL,   // Numpad 3 (PgDn),
    T52 | KBDNUMPAD | KBDSPECIAL,   // Numpad 0 (Ins),
    T53 | KBDNUMPAD | KBDSPECIAL,   // Numpad . (Del),
#endif // _PC98_

    T54, T55, T56, T57, T58, T59, T5A, T5B,
    T5C, T5D, T5E, T5F, T60, T61, T62, T63,
    T64, T65, T66, T67, T68, T69, T6A, T6B,
    T6C, T6D, T6E, T6F,

#if defined(JAPAN) && defined(_PC98_)
    T70,
#else //_PC98_
    /*
     * Hiragana/Katakana/Roman key must have KBDSPECIAL bit set (NLS key)
     */
    T70 | KBDSPECIAL,
#endif // _PC98_

                             T71, T72, T73,
    T74, T75, T76, T77, T78,

#if defined(JAPAN) && defined(_PC98_)
    T79,
#else //_PC98_
    /*
     * Conversion key must have KBDSPECIAL bit set (NLS key)
     */
    T79 | KBDSPECIAL,
#endif // _PC98_

                                  T7A,

#if defined(JAPAN) && defined(_PC98_)
    T7B,
#else //_PC98_
    /*
     * Non-Conversion key must have KBDSPECIAL bit set (NLS key)
     */
    T7B | KBDSPECIAL,
#endif // _PC98_

    T7C, T7D, T7E, T7F

};

static ALLOC_SECTION_LDATA VSC_VK aE0VscToVk[] = {
#if defined(JAPAN) && defined(_PC98_)
#else //_PC98_
        { 0x1C, X1C | KBDEXT              },  // Numpad Enter
        { 0x1D, X1D | KBDEXT              },  // RControl
        { 0x35, X35 | KBDEXT              },  // Numpad Divide
        { 0x37, X37 | KBDEXT              },  // Snapshot
        { 0x38, X38 | KBDEXT              },  // RMenu
        { 0x46, X46 | KBDEXT              },  // Break (Ctrl + Pause)
        { 0x47, X47 | KBDEXT              },  // Home
        { 0x48, X48 | KBDEXT              },  // Up
        { 0x49, X49 | KBDEXT              },  // Prior
        { 0x4B, X4B | KBDEXT              },  // Left
        { 0x4D, X4D | KBDEXT              },  // Right
        { 0x4F, X4F | KBDEXT              },  // End
        { 0x50, X50 | KBDEXT              },  // Down
        { 0x51, X51 | KBDEXT              },  // Next
        { 0x52, X52 | KBDEXT              },  // Insert
        { 0x53, X53 | KBDEXT              },  // Delete
        { 0x5B, X5B | KBDEXT              },  // Left Win
        { 0x5C, X5C | KBDEXT              },  // Right Win
        { 0x5D, X5D | KBDEXT              },  // Application
#endif // _PC98_
        { 0,      0                       }
};

static ALLOC_SECTION_LDATA VSC_VK aE1VscToVk[] = {
#if defined(JAPAN) && defined(_PC98_)
#else //_PC98_
        { 0x1D, Y1D                       },  // Pause
#endif // _PC98_
        { 0   ,   0                       }
};

/***************************************************************************\
* aVkToBits[]  - map Virtual Keys to Modifier Bits
*
* See kbd.h for a full description.
*
* US Keyboard has only three shifter keys:
*     SHIFT (L & R) affects alphabnumeric keys,
*     CTRL  (L & R) is used to generate control characters
*     ALT   (L & R) used for generating characters by number with numpad
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_BIT aVkToBits[] = {
    { VK_SHIFT,   KBDSHIFT },
    { VK_CONTROL, KBDCTRL  },
    { VK_MENU,    KBDALT   },
    { VK_KANA,    KBDKANA  },
    { 0,          0        }
};

/***************************************************************************\
* aModification[]  - map character modifier bits to modification number
*
* See kbd.h for a full description.
*
\***************************************************************************/

static ALLOC_SECTION_LDATA MODIFIERS CharModifiers = {
    &aVkToBits[0],
    11,
    {
    //  Modification# //  Keys Pressed  : Explanation
    //  ============= // ============== : =============================
        0,            //                : unshifted characters
        1,            //          SHIFT : capitals, ~!@#$%^&*()_+{}:"<>? etc.
        4,            //     CTRL       : control characters
        6,            //     CTRL SHIFT :
        SHFT_INVALID, // ALT            : invalid
        SHFT_INVALID, // ALT      SHIFT : invalid
        SHFT_INVALID, // ALT CTRL       : invalid
        SHFT_INVALID, // ALT CTRL SHIFT : invalid
        2,            //KANA
        3,            //KANA      SHIFT
        5,            //KANA CTRL
        7             //KANA CTRL SHIFT
    }
};

/***************************************************************************\
*
* aVkToWch2[]  - Virtual Key to WCHAR translation for 2 shift states
* aVkToWch3[]  - Virtual Key to WCHAR translation for 3 shift states
* aVkToWch4[]  - Virtual Key to WCHAR translation for 4 shift states
*
* Table attributes: Unordered Scan, null-terminated
*
* Search this table for an entry with a matching Virtual Key to find the
* corresponding unshifted and shifted WCHAR characters.
*
* Reserved VirtualKey values (first column)
*     -1            - this line contains dead characters (diacritic)
*     0             - terminator
*
* Reserved Attribute values (second column)
*     CAPLOK        - CapsLock affects this key like Shift
*     KANALOK       - The KANA-LOCK key affects this key like KANA
*
* Reserved character values (third through last column)
*     WCH_NONE      - No character
*     WCH_DEAD      - Dead character (diacritic) value is in next line
*
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch4[] = {
    //                               |          |   SHIFT  |  KANA  | K+SHFT |
    //                               |          |==========|========|========|
#if defined(JAPAN) && defined(_PC98_)
    {'0'          ,          KANALOK ,'0'       ,'0'       ,WCH_WA  ,WCH_WO  }, //_PC98_
#else //_PC98_
    {'0'          ,          KANALOK ,'0'       ,WCH_NONE  ,WCH_WA  ,WCH_WO  },
#endif // _PC98_
    {'1'          ,          KANALOK ,'1'       ,'!'       ,WCH_NU  ,WCH_NU  },
    {'3'          ,          KANALOK ,'3'       ,'#'       ,WCH_A   ,WCH_AA  },
    {'4'          ,          KANALOK ,'4'       ,'$'       ,WCH_U   ,WCH_UU  },
    {'5'          ,          KANALOK ,'5'       ,'%'       ,WCH_E   ,WCH_EE  },
    {'7'          ,          KANALOK ,'7'       ,0x27      ,WCH_YA  ,WCH_YAA },
    {'8'          ,          KANALOK ,'8'       ,'('       ,WCH_YU  ,WCH_YUU },
    {'9'          ,          KANALOK ,'9'       ,')'       ,WCH_YO  ,WCH_YOO },
    {'A'          , CAPLOK | KANALOK ,'a'       ,'A'       ,WCH_TI  ,WCH_TI  },
    {'B'          , CAPLOK | KANALOK ,'b'       ,'B'       ,WCH_KO  ,WCH_KO  },
    {'C'          , CAPLOK | KANALOK ,'c'       ,'C'       ,WCH_SO  ,WCH_SO  },
    {'D'          , CAPLOK | KANALOK ,'d'       ,'D'       ,WCH_SI  ,WCH_SI  },
    {'E'          , CAPLOK | KANALOK ,'e'       ,'E'       ,WCH_I   ,WCH_II  },
    {'F'          , CAPLOK | KANALOK ,'f'       ,'F'       ,WCH_HA  ,WCH_HA  },
    {'G'          , CAPLOK | KANALOK ,'g'       ,'G'       ,WCH_KI  ,WCH_KI  },
    {'H'          , CAPLOK | KANALOK ,'h'       ,'H'       ,WCH_KU  ,WCH_KU  },
    {'I'          , CAPLOK | KANALOK ,'i'       ,'I'       ,WCH_NI  ,WCH_NI  },
    {'J'          , CAPLOK | KANALOK ,'j'       ,'J'       ,WCH_MA  ,WCH_MA  },
    {'K'          , CAPLOK | KANALOK ,'k'       ,'K'       ,WCH_NO  ,WCH_NO  },
    {'L'          , CAPLOK | KANALOK ,'l'       ,'L'       ,WCH_RI  ,WCH_RI  },
    {'M'          , CAPLOK | KANALOK ,'m'       ,'M'       ,WCH_MO  ,WCH_MO  },
    {'N'          , CAPLOK | KANALOK ,'n'       ,'N'       ,WCH_MI  ,WCH_MI  },
    {'O'          , CAPLOK | KANALOK ,'o'       ,'O'       ,WCH_RA  ,WCH_RA  },
    {'P'          , CAPLOK | KANALOK ,'p'       ,'P'       ,WCH_SE  ,WCH_SE  },
    {'Q'          , CAPLOK | KANALOK ,'q'       ,'Q'       ,WCH_TA  ,WCH_TA  },
    {'R'          , CAPLOK | KANALOK ,'r'       ,'R'       ,WCH_SU  ,WCH_SU  },
    {'S'          , CAPLOK | KANALOK ,'s'       ,'S'       ,WCH_TO  ,WCH_TO  },
    {'T'          , CAPLOK | KANALOK ,'t'       ,'T'       ,WCH_KA  ,WCH_KA  },
    {'U'          , CAPLOK | KANALOK ,'u'       ,'U'       ,WCH_NA  ,WCH_NA  },
    {'V'          , CAPLOK | KANALOK ,'v'       ,'V'       ,WCH_HI  ,WCH_HI  },
    {'W'          , CAPLOK | KANALOK ,'w'       ,'W'       ,WCH_TE  ,WCH_TE  },
    {'X'          , CAPLOK | KANALOK ,'x'       ,'X'       ,WCH_SA  ,WCH_SA  },
    {'Y'          , CAPLOK | KANALOK ,'y'       ,'Y'       ,WCH_NN  ,WCH_NN  },
    {'Z'          , CAPLOK | KANALOK ,'z'       ,'Z'       ,WCH_TU  ,WCH_TUU },
    {VK_OEM_1     ,          KANALOK ,':'       ,'*'       ,WCH_KE  ,WCH_KE  },
    {VK_OEM_2     ,          KANALOK ,'/'       ,'?'       ,WCH_ME  ,WCH_MD  },
#if defined(JAPAN) && defined(_PC98_)
#else //_PC98_
    {VK_OEM_3     ,          KANALOK ,'@'       ,'`'       ,WCH_VS  ,WCH_VS  },
    {VK_OEM_7     ,          KANALOK ,'^'       ,'~'       ,WCH_HE  ,WCH_HE  },
    {VK_OEM_8     , 0                ,WCH_NONE  ,WCH_NONE  ,WCH_NONE,WCH_NONE},
#endif // _PC98_
    {VK_OEM_COMMA ,          KANALOK ,','       ,'<'       ,WCH_NE  ,WCH_IC  },
    {VK_OEM_PERIOD,          KANALOK ,'.'       ,'>'       ,WCH_RU  ,WCH_IP  },
    {VK_OEM_PLUS  ,          KANALOK ,';'       ,'+'       ,WCH_RE  ,WCH_RE  },
    {VK_TAB       , 0                ,'\t'      ,'\t'      ,'\t'    ,'\t'    },
    {VK_ADD       , 0                ,'+'       ,'+'       ,'+'     ,'+'     },
    {VK_DECIMAL   , 0                ,'.'       ,'.'       ,'.'     ,'.'     },
    {VK_DIVIDE    , 0                ,'/'       ,'/'       ,'/'     ,'/'     },
    {VK_MULTIPLY  , 0                ,'*'       ,'*'       ,'*'     ,'*'     },
    {VK_SUBTRACT  , 0                ,'-'       ,'-'       ,'-'     ,'-'     },
#if defined(JAPAN) && defined(_PC98_)
    {VK_SEPARATOR , 0                ,','       ,','       ,','     ,','     }, //<NEC_OCDE OEM
    {VK_OEM_NEC_EQUAL,    0          ,'='       ,'='       ,'='     ,'='     }, //<_PC98_ OEM
#endif // _PC98_
    {0            , 0                ,0         ,0         ,0       ,0       }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS6 aVkToWch6[] = {
    //                      |          |   SHIFT  |  KANA  | K+SHFT |  CONTROL  |  K+CTRL   |
    //                      |          |==========|========|========|===========|===========|
    {VK_BACK      , 0       ,'\b'      ,'\b'      ,'\b'    ,'\b'    , 0x7f      , 0x7f      },
    {VK_CANCEL    , 0       ,0x03      ,0x03      ,0x03    ,0x03    , 0x03      , 0x03      },
    {VK_ESCAPE    , 0       ,0x1b      ,0x1b      ,0x1b    ,0x1b    , 0x1b      , 0x1b      },
#if defined(JAPAN) && defined(_PC98_)
    {VK_OEM_3     , KANALOK ,'@'       ,'~'       ,WCH_VS  ,WCH_VS  , 0x00      , 0x00      },//_PC98_ #931208
    {VK_OEM_4     , KANALOK ,'['       ,'{'       ,WCH_SVS ,WCH_OB  , 0x1b      , 0x1b      },//_PC98_
    {VK_OEM_5     , KANALOK ,'\\'      ,'|'       ,WCH_PS  ,WCH_PS  , 0x1c      , 0x1c      },//_PC98_
    {VK_OEM_6     , KANALOK ,']'       ,'}'       ,WCH_MU  ,WCH_CB  , 0x1d      , 0x1d      },//_PC98_
    {VK_OEM_7     , KANALOK ,'^'       ,'`'       ,WCH_HE  ,WCH_HE  , 0x1e      , 0x1e      },//_PC98_ #931208
    {VK_OEM_8     , KANALOK ,WCH_NONE  ,'_'       ,WCH_RO  ,WCH_RO  , 0x1f      , 0x1f      },//_PC98_ #931208
#else //_PC98_
    {VK_OEM_4     , KANALOK ,'['       ,'{'       ,WCH_SVS ,WCH_OB  , 0x1b      , 0x1b      },
    {VK_OEM_5     , KANALOK ,'\\'      ,'|'       ,WCH_PS  ,WCH_PS  , 0x1c      , 0x1c      },
    {VK_OEM_102   , KANALOK ,'\\'      ,'_'       ,WCH_RO  ,WCH_RO  , 0x1c      , 0x1c      },
    {VK_OEM_6     , KANALOK ,']'       ,'}'       ,WCH_MU  ,WCH_CB  , 0x1d      , 0x1d      },
#endif // _PC98_
    {VK_RETURN    , 0       ,'\r'      ,'\r'      ,'\r'    ,'\r'    , '\n'      , '\n'      },
    {VK_SPACE     , 0       ,' '       ,' '       ,' '     ,' '     , 0x20      , 0x20      },
    {0            , 0       ,0         ,0         ,0       ,0       , 0         , 0         }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS8 aVkToWch8[] = {
    //                      |          |   SHIFT  |  KANA  | K+SHFT |  CONTROL  |  K+CTRL   | SHFT+CTRL |K+SHFT+CTRL|
    //                      |          |==========|========|========|===========|===========|===========|===========|
    {'2'          , KANALOK ,'2'       ,'"'       ,WCH_HU  ,WCH_HU  , WCH_NONE  , WCH_NONE  , 0x00      , 0x00      },
    {'6'          , KANALOK ,'6'       ,'&'       ,WCH_O   ,WCH_OO  , WCH_NONE  , WCH_NONE  , 0x1e      , 0x1e      },
    {VK_OEM_MINUS , KANALOK ,'-'       ,'='       ,WCH_HO  ,WCH_HO  , WCH_NONE  , WCH_NONE  , 0x1f      , 0x1f      },
    {0            , 0       ,0         ,0         ,0       ,0       , 0         , 0         , 0         , 0         }
};

// Put this last so that VkKeyScan interprets number characters
// as coming from the main section of the kbd (aVkToWch2 and
// aVkToWch4) before considering the numpad (aVkToWch1).

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch1[] = {
    //                     |          |   SHIFT  |  KANA  | K+SHFT |
    //                     |          |==========|========|========|
    { VK_NUMPAD0   , 0      ,  '0'    , WCH_NONE ,   '0'  ,WCH_NONE},
    { VK_NUMPAD1   , 0      ,  '1'    , WCH_NONE ,   '1'  ,WCH_NONE},
    { VK_NUMPAD2   , 0      ,  '2'    , WCH_NONE ,   '2'  ,WCH_NONE},
    { VK_NUMPAD3   , 0      ,  '3'    , WCH_NONE ,   '3'  ,WCH_NONE},
    { VK_NUMPAD4   , 0      ,  '4'    , WCH_NONE ,   '4'  ,WCH_NONE},
    { VK_NUMPAD5   , 0      ,  '5'    , WCH_NONE ,   '5'  ,WCH_NONE},
    { VK_NUMPAD6   , 0      ,  '6'    , WCH_NONE ,   '6'  ,WCH_NONE},
    { VK_NUMPAD7   , 0      ,  '7'    , WCH_NONE ,   '7'  ,WCH_NONE},
    { VK_NUMPAD8   , 0      ,  '8'    , WCH_NONE ,   '8'  ,WCH_NONE},
    { VK_NUMPAD9   , 0      ,  '9'    , WCH_NONE ,   '9'  ,WCH_NONE},
    { 0            , 0      ,  '\0'   , 0        ,   0    ,0       }   //null terminator
};

/***************************************************************************\
* aVkToWcharTable: table of pointers to Character Tables
*
* Describes the character tables and the order they should be searched.
*
* Note: the order determines the behavior of VkKeyScan() : this function
*       takes a character and attempts to find a Virtual Key and character-
*       modifier key combination that produces that character.  The table
*       containing the numeric keypad (aVkToWch1) must appear last so that
*       VkKeyScan('0') will be interpreted as one of keys from the main
*       section, not the numpad.  etc.
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHAR_TABLE aVkToWcharTable[] = {
    {  (PVK_TO_WCHARS1)aVkToWch6, 6, sizeof(aVkToWch6[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch8, 8, sizeof(aVkToWch8[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch4, 4, sizeof(aVkToWch4[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch1, 4, sizeof(aVkToWch1[0]) },  // must come last
    {                       NULL, 0, 0                    }
};

/***************************************************************************\
* aKeyNames[], aKeyNamesExt[]  - Scan Code -> Key Name tables
*
* For the GetKeyNameText() API function
*
* Tables for non-extended and extended (KBDEXT) keys.
* (Keys producing printable characters are named by the character itself)
\***************************************************************************/

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNames[] = {
#if defined(JAPAN) && defined(_PC98_)
//    0x00,    L"ESC",            // Esc
    0x0e,    L"BS",             // Backspace
    0x0f,    L"TAB",            // Tab
    0x1c,    L"RETURN",         // Enter
    0x34,    L"SPACE",          // Space
    0x35,    L"XFER",           // NLS Key SZ_KEY_NAME_HIRAGANA
    0x36,    L"ROLL UP",        // Page Down
    0x37,    L"ROLL DOWN",      // Page Up
    0x38,    L"INS",            // Insert
    0x39,    L"DEL",            // Delete
    0x3A,    L"UP",             // Up
    0x3B,    L"LEFT",           // Left
    0x3C,    L"RIGHT",          // Right
    0x3D,    L"DOWN",           // Down
    0x3E,    L"CLR",            // Home
    0x3F,    L"HELP",           // End
    0x40,    L"Num -",
    0x41,    L"Num /",
    0x42,    L"Num 7",
    0x43,    L"Num 8",
    0x44,    L"Num 9",
    0x45,    L"Num *",
    0x46,    L"Num 4",
    0x47,    L"Num 5",
    0x48,    L"Num 6",
    0x49,    L"Num +",
    0x4a,    L"Num 1",
    0x4b,    L"Num 2",
    0x4c,    L"Num 3",
    0x4d,    L"Num =",
    0x4e,    L"Num 0",
    0x4f,    L"Num ,",
    0x50,    L"Num .",
    0x51,    L"NFER",                   //
    0x52,    (LPWSTR)SZ_KEY_NAME_F11,   // vf1
    0x53,    (LPWSTR)SZ_KEY_NAME_F12,   // vf2
    0x54,    (LPWSTR)SZ_KEY_NAME_F13,   // vf3
    0x55,    (LPWSTR)SZ_KEY_NAME_F14,   // vf4
    0x56,    (LPWSTR)SZ_KEY_NAME_F15,   // vf5
    0x60,    L"STOP",                   // Break
    0x61,    L"COPY",                   // Prnt Scr
    0x62,    (LPWSTR)SZ_KEY_NAME_F1,    // F1
    0x63,    (LPWSTR)SZ_KEY_NAME_F2,    // F2
    0x64,    (LPWSTR)SZ_KEY_NAME_F3,    // F3
    0x65,    (LPWSTR)SZ_KEY_NAME_F4,    // F4
    0x66,    (LPWSTR)SZ_KEY_NAME_F5,    // F5
    0x67,    (LPWSTR)SZ_KEY_NAME_F6,    // F6
    0x68,    (LPWSTR)SZ_KEY_NAME_F7,    // F7
    0x69,    (LPWSTR)SZ_KEY_NAME_F8,    // F8
    0x6A,    (LPWSTR)SZ_KEY_NAME_F9,    // F9
    0x6B,    (LPWSTR)SZ_KEY_NAME_F10,   // F10
    0x70,    L"SHIFT",                  // Shift
    0x71,    L"CAPS",                   // Caps Lock
    0x72,    (LPWSTR)SZ_KEY_NAME_KANA,  // NLS Key Katakana
    0x73,    L"GRPH",                   // Alt
    0x74,    L"CTRL",                   // Ctrl
    0x77,    L"Left Windows",
    0x78,    L"Right Windows",
    0x79,    L"Application",
    0x7d,    L"SHIFT",                  // Right Shift
#else //_PC98_
    0x01,    L"Esc",
    0x0e,    L"Backspace",
    0x0f,    L"Tab",
    0x1c,    L"Enter",
    0x1d,    L"Ctrl",
    0x29,    (LPWSTR)SZ_KEY_NAME_HANKAKU_ZENKAKU,  // NLS Key
    0x2a,    L"Shift",
    0x36,    L"Right Shift",
    0x37,    L"Num *",
    0x38,    L"Alt",
    0x39,    L"Space",
    0x3a,    L"Caps Lock",
    0x3b,    L"F1",
    0x3c,    L"F2",
    0x3d,    L"F3",
    0x3e,    L"F4",
    0x3f,    L"F5",
    0x40,    L"F6",
    0x41,    L"F7",
    0x42,    L"F8",
    0x43,    L"F9",
    0x44,    L"F10",
    0x45,    L"Pause",
    0x46,    L"Scroll Lock",
    0x47,    L"Num 7",
    0x48,    L"Num 8",
    0x49,    L"Num 9",
    0x4a,    L"Num -",
    0x4b,    L"Num 4",
    0x4c,    L"Num 5",
    0x4d,    L"Num 6",
    0x4e,    L"Num +",
    0x4f,    L"Num 1",
    0x50,    L"Num 2",
    0x51,    L"Num 3",
    0x52,    L"Num 0",
    0x53,    L"Num Del",
    0x54,    L"Sys Req",
    0x57,    L"F11",
    0x58,    L"F12",
    0x70,    (LPWSTR)SZ_KEY_NAME_HIRAGANA,
    0x79,    (LPWSTR)SZ_KEY_NAME_HENKAN,
    0x7b,    (LPWSTR)SZ_KEY_NAME_MUHENKAN,
    0x7C,    L"F13",
#endif // _PC98_
    0   ,    NULL
};

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNamesExt[] = {
#if defined(JAPAN) && defined(_PC98_)
#else //_PC98_
    0x1c,    L"Num Enter",
    0x1d,    L"Right Control",
    0x35,    L"Num /",
    0x37,    L"Prnt Scrn",
    0x38,    L"Right Alt",
    0x45,    L"Num Lock",
    0x46,    L"Break",
    0x47,    L"Home",
    0x48,    L"Up",
    0x49,    L"Page Up",
    0x4b,    L"Left",
    0x4d,    L"Right",
    0x4f,    L"End",
    0x50,    L"Down",
    0x51,    L"Page Down",
    0x52,    L"Insert",
    0x53,    L"Delete",
    0x5B,    L"Left Windows",
    0x5C,    L"Right Windows",
    0x5D,    L"Application",
#endif // _PC98_
    0   ,    NULL
};

static ALLOC_SECTION_LDATA KBDTABLES KbdTables = {
    /*
     * Modifier keys
     */
    &CharModifiers,

    /*
     * Characters tables
     */
    aVkToWcharTable,

    /*
     * Diacritics  (none for US English)
     */
    NULL,

    /*
     * Names of Keys  (no dead keys)
     */
    aKeyNames,
    aKeyNamesExt,
    NULL,

    /*
     * Scan codes to Virtual Keys
     */
    ausVK,
    sizeof(ausVK) / sizeof(ausVK[0]),
    aE0VscToVk,
    aE1VscToVk,

    /*
     * No Locale-specific special processing
     */
    0,

    /*
     * No Ligatures
     */
    0, 0, NULL,

    /*
     * Type and subtype.
     */
    KEYBOARD_TYPE_JAPAN,    // Japanese Keyboard Layout
    MAKEWORD(NEC_KBD_N_MODE_TYPE, NLSKBD_OEM_NEC),
};

PKBDTABLES KbdLayerDescriptor(VOID)
{
    return &KbdTables;
}

/***********************************************************************\
* VkToFuncTable_106[]
*
\***********************************************************************/

static ALLOC_SECTION_LDATA VK_F VkToFuncTable_106[] = {
    {
        VK_DBE_ALPHANUMERIC,  // Base Vk
        KBDNLS_TYPE_TOGGLE,   // NLSFEProcType
        KBDNLS_INDEX_NORMAL,  // NLSFEProcCurrent
        0x02, /* 00000010 */  // NLSFEProcSwitch
        {                     // NLSFEProc
            {KBDNLS_ALPHANUM,0},               // Base
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Shift
            {KBDNLS_ALPHANUM,0},               // Control
            {KBDNLS_ALPHANUM,0},               // Shift+Control
            {KBDNLS_ALPHANUM,0},               // Alt
            {KBDNLS_ALPHANUM,0},               // Shift+Alt
            {KBDNLS_CODEINPUT,0},              // Control+Alt
            {KBDNLS_CODEINPUT,0}               // Shift+Control+Alt
        },
        {                     // NLSFEProcAlt
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Base
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Shift
            {KBDNLS_NOEVENT,0},                // Control
            {KBDNLS_NOEVENT,0},                // Shift+Control
            {KBDNLS_NOEVENT,0},                // Alt
            {KBDNLS_NOEVENT,0},                // Shift+Alt
            {KBDNLS_NOEVENT,0},                // Control+Alt
            {KBDNLS_NOEVENT,0}                 // Shift+Control+Alt
        }
    },
    {
        VK_DBE_HIRAGANA,     // Base Vk
        KBDNLS_TYPE_TOGGLE,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x08, /* 00001000 */ // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_HIRAGANA,0},             // Base
            {KBDNLS_KATAKANA,0},             // Shift
            {KBDNLS_HIRAGANA,0},             // Control
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Shift+Control
            {KBDNLS_ROMAN,0},                // Alt
            {KBDNLS_ROMAN,0},                // Shift+Alt
            {KBDNLS_ROMAN,0},                // Control+Alt
            {KBDNLS_NOEVENT,0}               // Shift+Control+Alt
        },
        {                    // NLSFEProcIndexAlt
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Base
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Shift
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Control
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Shift+Control
            {KBDNLS_NOEVENT,0},              // Alt
            {KBDNLS_NOEVENT,0},              // Shift+Alt
            {KBDNLS_NOEVENT,0},              // Control+Alt
            {KBDNLS_NOEVENT,0}               // Shift+Control+Alt
        }
    },
    {
        VK_DBE_SBCSCHAR,     // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SBCSDBCS,0},             // Base
            {KBDNLS_SBCSDBCS,0},             // Shift
            {KBDNLS_SBCSDBCS,0},             // Control
            {KBDNLS_SBCSDBCS,0},             // Shift+Control
            {KBDNLS_SEND_PARAM_VK,VK_KANJI}, // Alt
            {KBDNLS_SBCSDBCS,0},             // Shift+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}, // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}  // Shift+Control+Alt
        },
        {                    // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_NONCONVERT,       // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},         // Base
            {KBDNLS_SEND_BASE_VK,0},         // Shift
            {KBDNLS_SEND_BASE_VK,0},         // Control
            {KBDNLS_SEND_BASE_VK,0},         // Shift+Control
            {KBDNLS_SEND_BASE_VK,0},         // Alt
            {KBDNLS_SEND_BASE_VK,0},         // Shift+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}, // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}  // Shift+Control+Alt
        },
        {                         // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    }
};

#if defined(JAPAN) && defined(_PC98_)
static ALLOC_SECTION_LDATA VK_F VkToFuncTable_NEC[] = {
    {
        VK_DBE_SBCSCHAR,     // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SBCSDBCS,0},             // Base
            {KBDNLS_SBCSDBCS,0},             // Shift
            {KBDNLS_SBCSDBCS,0},             // Control
            {KBDNLS_SBCSDBCS,0},             // Shift+Control
            {KBDNLS_SBCSDBCS,0},             // Alt
//            {KBDNLS_SEND_PARAM_VK,VK_KANJI}, // Alt
            {KBDNLS_SBCSDBCS,0},             // Shift+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}, // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}  // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_NONCONVERT,       // Base Vk  PC98_NFER key
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},                             // Base
            {KBDNLS_SEND_BASE_VK,0},                             // Shift
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ALPHANUMERIC},          // Control
            {KBDNLS_SBCSDBCS,0},                                 // Shift+Control
            {KBDNLS_SEND_PARAM_VK,VK_DBE_KATAKANA},              // Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}, // Shift+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_NOCODEINPUT},           // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_FLUSHSTRING}            // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_CONVERT,            // Base Vk  PC98_XFER key
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},                          // Base
            {KBDNLS_SEND_BASE_VK,0},                          // Shift
            {KBDNLS_SEND_PARAM_VK,VK_KANJI},                  // Control
            {KBDNLS_SEND_BASE_VK,0},                          // Shift+Control
            {KBDNLS_ROMAN,0},                                 // Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}, // Shift+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_CODEINPUT},          // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_HIRAGANA}            // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_OEM_NEC_EQUAL,    // Base Vk NEC98_"="  key
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},                  // Base
            {KBDNLS_SEND_BASE_VK,0},                  // Shift
            {KBDNLS_SEND_PARAM_VK,VK_SCROLL},         // Control
            {KBDNLS_SEND_BASE_VK,0},                  // Shift+Control
            {KBDNLS_SEND_BASE_VK,0},                  // Alt
            {KBDNLS_SEND_BASE_VK,0},                  // Shift+Alt
            {KBDNLS_SEND_BASE_VK,0},                  // Control+Alt
            {KBDNLS_SEND_BASE_VK,0}                   // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_HOME,             // Base Vk  PC98_HOME  key
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_HOME_OR_CLEAR,0},         // Base
            {KBDNLS_SEND_BASE_VK,0},          // Shift
            {KBDNLS_HOME_OR_CLEAR,0},         // Control
            {KBDNLS_HOME_OR_CLEAR,0},         // Shift+Control
            {KBDNLS_HOME_OR_CLEAR,0},         // Alt
            {KBDNLS_HOME_OR_CLEAR,0},         // Shift+Alt
            {KBDNLS_HOME_OR_CLEAR,0},         // Control+Alt
            {KBDNLS_HOME_OR_CLEAR,0}          // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_END,              // Base Vk  PC98_HELP  key
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_HELP_OR_END,0},         // Base
            {KBDNLS_HELP_OR_END,0},         // Shift
            {KBDNLS_HELP_OR_END,0},         // Control
            {KBDNLS_HELP_OR_END,0},         // Shift+Control
            {KBDNLS_HELP_OR_END,0},         // Alt
            {KBDNLS_HELP_OR_END,0},         // Shift+Alt
            {KBDNLS_HELP_OR_END,0},         // Control+Alt
            {KBDNLS_HELP_OR_END,0}          // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    }
};

USHORT ausMouseVKey98[] = {
                       VK_NUMPAD5,
                       VK_NUMPAD9,
                       VK_NUMPAD3,
                       VK_NUMPAD1,
                       VK_NUMPAD7,
                       VK_NUMPAD4,
                       VK_NUMPAD8,
                       VK_NUMPAD6,
                       VK_NUMPAD2,
                       VK_NUMPAD0,
                       VK_DECIMAL,
                       VK_MULTIPLY,
                       VK_ADD,
                       VK_SUBTRACT,
                       VK_DIVIDE | KBDEXT,
                       VK_HOME | KBDEXT
                      };

#else //_PC98_
#endif // _PC98_
/***********************************************************************\
* KbdNlsTables
*
\***********************************************************************/

static ALLOC_SECTION_LDATA KBDNLSTABLES KbdNlsTables = {
#if defined(JAPAN) && defined(_PC98_)
    0x0d,                            // OEM ID (0x0d = NEC)
    NLSKBD_INFO_ACCESSIBILITY_KEYMAP,// Information
    6,                               // Number of VK_F entry
    VkToFuncTable_NEC,               // Pointer to VK_F array
    16,                              // Number of MouseVk entry
    ausMouseVKey98                   // Pointer to MouseVk array
#else //_PC98_
    0,                      // OEM ID (0 = Microsoft)
    0,                      // Information
    4,                      // Number of VK_F entry
    VkToFuncTable_106,      // Pointer to VK_F array
    0,                      // Number of MouseVk entry
    NULL                    // Pointer to MouseVk array
#endif // _PC98_
};

PKBDNLSTABLES KbdNlsLayerDescriptor(VOID)
{
    return &KbdNlsTables;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\fe_kbds\jpn\kbdnec\kbdnec.c ===
/***************************************************************************\
* Module Name: kbdnec.c
*
* Copyright (c) 1985-98, Microsoft Corporation
*
* History:
\***************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <ime.h>
#include "vkoem.h"
#include "kbdjpn.h"
#include "kbdnec.h"

#if defined(_M_IA64)
#pragma section(".data")
#define ALLOC_SECTION_LDATA __declspec(allocate(".data"))
#else
#pragma data_seg(".data")
#define ALLOC_SECTION_LDATA
#endif

/***************************************************************************\
* ausVK[] - Virtual Scan Code to Virtual Key conversion table for NEC KBD
\***************************************************************************/

static ALLOC_SECTION_LDATA USHORT ausVK[] = {
    T00, T01, T02, T03, T04, T05, T06, T07,
    T08, T09, T0A, T0B, T0C, T0D, T0E, T0F,
    T10, T11, T12, T13, T14, T15, T16, T17,
    T18, T19, T1A, T1B, T1C, T1D, T1E, T1F,
    T20, T21, T22, T23, T24, T25, T26, T27,
    T28,

    /*
     * Hankaku/Zenkaku/Kanji key must have KBDSPECIAL bit set (NLS key)
     */
    T29 | KBDSPECIAL,

              T2A, T2B, T2C, T2D, T2E, T2F,
    T30, T31, T32, T33, T34, T35,

    /*
     * Right-hand Shift key must have KBDEXT bit set.
     */
    T36 | KBDEXT,

    T37,

    T38, T39,

    T3A,

                   T3B, T3C, T3D, T3E, T3F,
    T40, T41, T42, T43, T44,

    /*
     * NumLock Key:
     *     KBDEXT     - VK_NUMLOCK is an Extended key
     *     KBDMULTIVK - VK_NUMLOCK or VK_PAUSE (without or with CTRL)
     */
    T45 | KBDEXT | KBDMULTIVK,

    T46,

    /*
     * Number Pad keys:
     *     KBDNUMPAD  - digits 0-9 and decimal point.
     *     KBDSPECIAL - require special processing by Windows
     */
    T47 | KBDNUMPAD | KBDSPECIAL,   // Numpad 7 (Home)
    T48 | KBDNUMPAD | KBDSPECIAL,   // Numpad 8 (Up),
    T49 | KBDNUMPAD | KBDSPECIAL,   // Numpad 9 (PgUp),
    T4A,
    T4B | KBDNUMPAD | KBDSPECIAL,   // Numpad 4 (Left),
    T4C | KBDNUMPAD | KBDSPECIAL,   // Numpad 5 (Clear),
    T4D | KBDNUMPAD | KBDSPECIAL,   // Numpad 6 (Right),
    T4E,
    T4F | KBDNUMPAD | KBDSPECIAL,   // Numpad 1 (End),
    T50 | KBDNUMPAD | KBDSPECIAL,   // Numpad 2 (Down),
    T51 | KBDNUMPAD | KBDSPECIAL,   // Numpad 3 (PgDn),
    T52 | KBDNUMPAD | KBDSPECIAL,   // Numpad 0 (Ins),
    T53 | KBDNUMPAD | KBDSPECIAL,   // Numpad . (Del),

    T54, T55, T56, T57, T58,
    T59 | KBDSPECIAL,               // TenKey EQU (VK_SCROLL)
                                  T5A, T5B,

    T5C, T5D, T5E, T5F, T60, T61, T62, T63,
    T64, T65, T66, T67, T68, T69, T6A, T6B,
    T6C, T6D, T6E, T6F,

    /*
     * Hiragana/Katakana/Roman key must have KBDSPECIAL bit set (NLS key)
     */
    T70,

                             T71, T72, T73,
    T74, T75, T76, T77, T78,

    /*
     * Conversion key must have KBDSPECIAL bit set (NLS key)
     */
    T79 | KBDSPECIAL,

                                  T7A,

    /*
     * Non-Conversion key must have KBDSPECIAL bit set (NLS key)
     */
    T7B | KBDSPECIAL,

    T7C, T7D, T7E, T7F
};

static ALLOC_SECTION_LDATA VSC_VK aE0VscToVk[] = {
        { 0x1C, X1C | KBDEXT              },  // Numpad Enter
        { 0x1D, X1D | KBDEXT              },  // RControl
        { 0x35, X35 | KBDEXT              },  // Numpad Divide
        { 0x37, X37 | KBDEXT              },  // Snapshot
        { 0x38, X38 | KBDEXT              },  // RMenu
        { 0x46, X46 | KBDEXT              },  // Break (Ctrl + Pause)
        { 0x47, X47 | KBDEXT | KBDSPECIAL },  // CLR HOME
        { 0x48, X48 | KBDEXT              },  // Up
        { 0x49, X49 | KBDEXT              },  // Prior
        { 0x4B, X4B | KBDEXT              },  // Left
        { 0x4D, X4D | KBDEXT              },  // Right
        { 0x4F, X4F | KBDEXT | KBDSPECIAL },  // HELP
        { 0x50, X50 | KBDEXT              },  // Down
        { 0x51, X51 | KBDEXT              },  // Next
        { 0x52, X52 | KBDEXT              },  // Insert
        { 0x53, X53 | KBDEXT              },  // Delete
        { 0x5B, X5B | KBDEXT              },  // Left Win
        { 0x5C, X5C | KBDEXT              },  // Right Win
        { 0x5D, X5D | KBDEXT              },  // Application
        { 0,      0                       }
};

static ALLOC_SECTION_LDATA VSC_VK aE1VscToVk[] = {
        { 0x1D, Y1D                       },  // Pause
        { 0   ,   0                       }
};

/***************************************************************************\
* aVkToBits[]  - map Virtual Keys to Modifier Bits
*
* See kbd.h for a full description.
*
* US Keyboard has only three shifter keys:
*     SHIFT (L & R) affects alphabnumeric keys,
*     CTRL  (L & R) is used to generate control characters
*     ALT   (L & R) used for generating characters by number with numpad
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_BIT aVkToBits[] = {
    { VK_SHIFT,   KBDSHIFT },
    { VK_CONTROL, KBDCTRL  },
    { VK_MENU,    KBDALT   },
    { VK_KANA,    KBDKANA  },
    { 0,          0        }
};

/***************************************************************************\
* aModification[]  - map character modifier bits to modification number
*
* See kbd.h for a full description.
*
\***************************************************************************/

static ALLOC_SECTION_LDATA MODIFIERS CharModifiers = {
    &aVkToBits[0],
    11,
    {
    //  Modification# //  Keys Pressed  : Explanation
    //  ============= // ============== : =============================
        0,            //                : unshifted characters
        1,            //          SHIFT : capitals, ~!@#$%^&*()_+{}:"<>? etc.
        4,            //     CTRL       : control characters
        6,            //     CTRL SHIFT :
        SHFT_INVALID, // ALT            : invalid
        SHFT_INVALID, // ALT      SHIFT : invalid
        SHFT_INVALID, // ALT CTRL       : invalid
        SHFT_INVALID, // ALT CTRL SHIFT : invalid
        2,            //KANA
        3,            //KANA      SHIFT
        5,            //KANA CTRL
        7             //KANA CTRL SHIFT
    }
};

/***************************************************************************\
*
* aVkToWch2[]  - Virtual Key to WCHAR translation for 2 shift states
* aVkToWch3[]  - Virtual Key to WCHAR translation for 3 shift states
* aVkToWch4[]  - Virtual Key to WCHAR translation for 4 shift states
*
* Table attributes: Unordered Scan, null-terminated
*
* Search this table for an entry with a matching Virtual Key to find the
* corresponding unshifted and shifted WCHAR characters.
*
* Reserved VirtualKey values (first column)
*     -1            - this line contains dead characters (diacritic)
*     0             - terminator
*
* Reserved Attribute values (second column)
*     CAPLOK        - CapsLock affects this key like Shift
*     KANALOK       - The KANA-LOCK key affects this key like KANA
*
* Reserved character values (third through last column)
*     WCH_NONE      - No character
*     WCH_DEAD      - Dead character (diacritic) value is in next line
*
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch4[] = {
    //                               |          |   SHIFT  |  KANA  | K+SHFT |
    //                               |          |==========|========|========|
    {'0'          ,          KANALOK ,'0'       ,'0'       ,WCH_WA  ,WCH_WO  },
    {'1'          ,          KANALOK ,'1'       ,'!'       ,WCH_NU  ,WCH_NU  },
    {'3'          ,          KANALOK ,'3'       ,'#'       ,WCH_A   ,WCH_AA  },
    {'4'          ,          KANALOK ,'4'       ,'$'       ,WCH_U   ,WCH_UU  },
    {'5'          ,          KANALOK ,'5'       ,'%'       ,WCH_E   ,WCH_EE  },
    {'7'          ,          KANALOK ,'7'       ,0x27      ,WCH_YA  ,WCH_YAA },
    {'8'          ,          KANALOK ,'8'       ,'('       ,WCH_YU  ,WCH_YUU },
    {'9'          ,          KANALOK ,'9'       ,')'       ,WCH_YO  ,WCH_YOO },
    {'A'          , CAPLOK | KANALOK ,'a'       ,'A'       ,WCH_TI  ,WCH_TI  },
    {'B'          , CAPLOK | KANALOK ,'b'       ,'B'       ,WCH_KO  ,WCH_KO  },
    {'C'          , CAPLOK | KANALOK ,'c'       ,'C'       ,WCH_SO  ,WCH_SO  },
    {'D'          , CAPLOK | KANALOK ,'d'       ,'D'       ,WCH_SI  ,WCH_SI  },
    {'E'          , CAPLOK | KANALOK ,'e'       ,'E'       ,WCH_I   ,WCH_II  },
    {'F'          , CAPLOK | KANALOK ,'f'       ,'F'       ,WCH_HA  ,WCH_HA  },
    {'G'          , CAPLOK | KANALOK ,'g'       ,'G'       ,WCH_KI  ,WCH_KI  },
    {'H'          , CAPLOK | KANALOK ,'h'       ,'H'       ,WCH_KU  ,WCH_KU  },
    {'I'          , CAPLOK | KANALOK ,'i'       ,'I'       ,WCH_NI  ,WCH_NI  },
    {'J'          , CAPLOK | KANALOK ,'j'       ,'J'       ,WCH_MA  ,WCH_MA  },
    {'K'          , CAPLOK | KANALOK ,'k'       ,'K'       ,WCH_NO  ,WCH_NO  },
    {'L'          , CAPLOK | KANALOK ,'l'       ,'L'       ,WCH_RI  ,WCH_RI  },
    {'M'          , CAPLOK | KANALOK ,'m'       ,'M'       ,WCH_MO  ,WCH_MO  },
    {'N'          , CAPLOK | KANALOK ,'n'       ,'N'       ,WCH_MI  ,WCH_MI  },
    {'O'          , CAPLOK | KANALOK ,'o'       ,'O'       ,WCH_RA  ,WCH_RA  },
    {'P'          , CAPLOK | KANALOK ,'p'       ,'P'       ,WCH_SE  ,WCH_SE  },
    {'Q'          , CAPLOK | KANALOK ,'q'       ,'Q'       ,WCH_TA  ,WCH_TA  },
    {'R'          , CAPLOK | KANALOK ,'r'       ,'R'       ,WCH_SU  ,WCH_SU  },
    {'S'          , CAPLOK | KANALOK ,'s'       ,'S'       ,WCH_TO  ,WCH_TO  },
    {'T'          , CAPLOK | KANALOK ,'t'       ,'T'       ,WCH_KA  ,WCH_KA  },
    {'U'          , CAPLOK | KANALOK ,'u'       ,'U'       ,WCH_NA  ,WCH_NA  },
    {'V'          , CAPLOK | KANALOK ,'v'       ,'V'       ,WCH_HI  ,WCH_HI  },
    {'W'          , CAPLOK | KANALOK ,'w'       ,'W'       ,WCH_TE  ,WCH_TE  },
    {'X'          , CAPLOK | KANALOK ,'x'       ,'X'       ,WCH_SA  ,WCH_SA  },
    {'Y'          , CAPLOK | KANALOK ,'y'       ,'Y'       ,WCH_NN  ,WCH_NN  },
    {'Z'          , CAPLOK | KANALOK ,'z'       ,'Z'       ,WCH_TU  ,WCH_TUU },
    {VK_OEM_1     ,          KANALOK ,':'       ,'*'       ,WCH_KE  ,WCH_KE  },
    {VK_OEM_2     ,          KANALOK ,'/'       ,'?'       ,WCH_ME  ,WCH_MD  },
    {VK_OEM_COMMA ,          KANALOK ,','       ,'<'       ,WCH_NE  ,WCH_IC  },
    {VK_OEM_PERIOD,          KANALOK ,'.'       ,'>'       ,WCH_RU  ,WCH_IP  },
    {VK_OEM_PLUS  ,          KANALOK ,';'       ,'+'       ,WCH_RE  ,WCH_RE  },
    {VK_TAB       , 0                ,'\t'      ,'\t'      ,'\t'    ,'\t'    },
    {VK_ADD       , 0                ,'+'       ,'+'       ,'+'     ,'+'     },
    {VK_DECIMAL   , 0                ,'.'       ,'.'       ,'.'     ,'.'     },
    {VK_DIVIDE    , 0                ,'/'       ,'/'       ,'/'     ,'/'     },
    {VK_MULTIPLY  , 0                ,'*'       ,'*'       ,'*'     ,'*'     },
    {VK_SUBTRACT  , 0                ,'-'       ,'-'       ,'-'     ,'-'     },
    {VK_SEPARATOR , 0                ,','       ,','       ,','     ,','     },
    {VK_OEM_NEC_EQUAL,    0          ,'='       ,'='       ,'='     ,'='     },
    {0            , 0                ,0         ,0         ,0       ,0       }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS6 aVkToWch6[] = {
    //                      |          |   SHIFT  |  KANA  | K+SHFT |  CONTROL  |  K+CTRL   |
    //                      |          |==========|========|========|===========|===========|
    {VK_BACK      , 0       ,'\b'      ,'\b'      ,'\b'    ,'\b'    , 0x7f      , 0x7f      },
    {VK_CANCEL    , 0       ,0x03      ,0x03      ,0x03    ,0x03    , 0x03      , 0x03      },
    {VK_ESCAPE    , 0       ,0x1b      ,0x1b      ,0x1b    ,0x1b    , 0x1b      , 0x1b      },
    {VK_OEM_3     , KANALOK ,'@'       ,'~'       ,WCH_VS  ,WCH_VS  , 0x00      , 0x00      },
    {VK_OEM_4     , KANALOK ,'['       ,'{'       ,WCH_SVS ,WCH_OB  , 0x1b      , 0x1b      },
    {VK_OEM_5     , KANALOK ,'\\'      ,'|'       ,WCH_PS  ,WCH_PS  , 0x1c      , 0x1c      },
    {VK_OEM_6     , KANALOK ,']'       ,'}'       ,WCH_MU  ,WCH_CB  , 0x1d      , 0x1d      },
    {VK_OEM_7     , KANALOK ,'^'       ,'`'       ,WCH_HE  ,WCH_HE  , 0x1e      , 0x1e      },
    {VK_OEM_8     , KANALOK ,WCH_NONE  ,'_'       ,WCH_RO  ,WCH_RO  , 0x1f      , 0x1f      },
    {VK_RETURN    , 0       ,'\r'      ,'\r'      ,'\r'    ,'\r'    , '\n'      , '\n'      },
    {VK_SPACE     , 0       ,' '       ,' '       ,' '     ,' '     , 0x20      , 0x20      },
    {0            , 0       ,0         ,0         ,0       ,0       , 0         , 0         }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS8 aVkToWch8[] = {
    //                      |          |   SHIFT  |  KANA  | K+SHFT |  CONTROL  |  K+CTRL   | SHFT+CTRL |K+SHFT+CTRL|
    //                      |          |==========|========|========|===========|===========|===========|===========|
    {'2'          , KANALOK ,'2'       ,'"'       ,WCH_HU  ,WCH_HU  , WCH_NONE  , WCH_NONE  , 0x00      , 0x00      },
    {'6'          , KANALOK ,'6'       ,'&'       ,WCH_O   ,WCH_OO  , WCH_NONE  , WCH_NONE  , 0x1e      , 0x1e      },
    {VK_OEM_MINUS , KANALOK ,'-'       ,'='       ,WCH_HO  ,WCH_HO  , WCH_NONE  , WCH_NONE  , 0x1f      , 0x1f      },
    {0            , 0       ,0         ,0         ,0       ,0       , 0         , 0         , 0         , 0         }
};

// Put this last so that VkKeyScan interprets number characters
// as coming from the main section of the kbd (aVkToWch2 and
// aVkToWch4) before considering the numpad (aVkToWch1).

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch1[] = {
    //                     |          |   SHIFT  |  KANA  | K+SHFT |
    //                     |          |==========|========|========|
    { VK_NUMPAD0   , 0      ,  '0'    , WCH_NONE ,   '0'  ,WCH_NONE},
    { VK_NUMPAD1   , 0      ,  '1'    , WCH_NONE ,   '1'  ,WCH_NONE},
    { VK_NUMPAD2   , 0      ,  '2'    , WCH_NONE ,   '2'  ,WCH_NONE},
    { VK_NUMPAD3   , 0      ,  '3'    , WCH_NONE ,   '3'  ,WCH_NONE},
    { VK_NUMPAD4   , 0      ,  '4'    , WCH_NONE ,   '4'  ,WCH_NONE},
    { VK_NUMPAD5   , 0      ,  '5'    , WCH_NONE ,   '5'  ,WCH_NONE},
    { VK_NUMPAD6   , 0      ,  '6'    , WCH_NONE ,   '6'  ,WCH_NONE},
    { VK_NUMPAD7   , 0      ,  '7'    , WCH_NONE ,   '7'  ,WCH_NONE},
    { VK_NUMPAD8   , 0      ,  '8'    , WCH_NONE ,   '8'  ,WCH_NONE},
    { VK_NUMPAD9   , 0      ,  '9'    , WCH_NONE ,   '9'  ,WCH_NONE},
    { 0            , 0      ,  '\0'   , 0        ,   0    ,0       }   //null terminator
};

/***************************************************************************\
* aVkToWcharTable: table of pointers to Character Tables
*
* Describes the character tables and the order they should be searched.
*
* Note: the order determines the behavior of VkKeyScan() : this function
*       takes a character and attempts to find a Virtual Key and character-
*       modifier key combination that produces that character.  The table
*       containing the numeric keypad (aVkToWch1) must appear last so that
*       VkKeyScan('0') will be interpreted as one of keys from the main
*       section, not the numpad.  etc.
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHAR_TABLE aVkToWcharTable[] = {
    {  (PVK_TO_WCHARS1)aVkToWch6, 6, sizeof(aVkToWch6[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch8, 8, sizeof(aVkToWch8[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch4, 4, sizeof(aVkToWch4[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch1, 4, sizeof(aVkToWch1[0]) },  // must come last
    {                       NULL, 0, 0                    }
};

/***************************************************************************\
* aKeyNames[], aKeyNamesExt[]  - Scan Code -> Key Name tables
*
* For the GetKeyNameText() API function
*
* Tables for non-extended and extended (KBDEXT) keys.
* (Keys producing printable characters are named by the character itself)
\***************************************************************************/

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNames[] = {
    0x01,    L"Esc",
    0x0e,    L"Backspace",
    0x0f,    L"Tab",
    0x1c,    L"Enter",
    0x1d,    L"Ctrl",
    0x29,    (LPWSTR)SZ_KEY_NAME_HANKAKU_ZENKAKU,  // NLS Key
    0x2a,    L"Shift",
    0x36,    L"Right Shift",
    0x37,    L"Num *",
    0x38,    L"Alt",
    0x39,    L"Space",
    0x3a,    L"Caps Lock",
    0x3b,    L"F1",
    0x3c,    L"F2",
    0x3d,    L"F3",
    0x3e,    L"F4",
    0x3f,    L"F5",
    0x40,    L"F6",
    0x41,    L"F7",
    0x42,    L"F8",
    0x43,    L"F9",
    0x44,    L"F10",
    0x45,    L"Pause",
    0x46,    L"Scroll Lock",
    0x47,    L"Num 7",
    0x48,    L"Num 8",
    0x49,    L"Num 9",
    0x4a,    L"Num -",
    0x4b,    L"Num 4",
    0x4c,    L"Num 5",
    0x4d,    L"Num 6",
    0x4e,    L"Num +",
    0x4f,    L"Num 1",
    0x50,    L"Num 2",
    0x51,    L"Num 3",
    0x52,    L"Num 0",
    0x53,    L"Num Del",
    0x54,    L"Sys Req",
    0x57,    L"F11",
    0x58,    L"F12",
    0x59,    L"Num =",
    0x5C,    L"Num ,",
    0x5D,    L"F13",    // vf3
    0x5E,    L"F14",    // vf4
    0x5F,    L"F15",    // vf5
    0x70,    (LPWSTR)SZ_KEY_NAME_KANA,    // NLS Key Kana
    0x79,    L"XFER",
    0x7b,    L"NFER",
    0   ,    NULL
};

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNamesExt[] = {
    0x1c,    L"Num Enter",
    0x1d,    L"Right Control",
    0x35,    L"Num /",
    0x37,    L"Prnt Scrn",
    0x38,    L"Right Alt",
    0x45,    L"Num Lock",
    0x46,    L"Break",
    0x47,    L"Home",
    0x48,    L"Up",
    0x49,    L"Page Up",
    0x4b,    L"Left",
    0x4d,    L"Right",
    0x4f,    L"End",
    0x50,    L"Down",
    0x51,    L"Page Down",
    0x52,    L"Insert",
    0x53,    L"Delete",
    0x5B,    L"Left Windows",
    0x5C,    L"Right Windows",
    0x5D,    L"Application",
    0   ,    NULL
};

ALLOC_SECTION_LDATA KBDTABLES KbdTablesNec = {
    /*
     * Modifier keys
     */
    &CharModifiers,

    /*
     * Characters tables
     */
    aVkToWcharTable,

    /*
     * Diacritics  (none for US English)
     */
    NULL,

    /*
     * Names of Keys  (no dead keys)
     */
    aKeyNames,
    aKeyNamesExt,
    NULL,

    /*
     * Scan codes to Virtual Keys
     */
    ausVK,
    sizeof(ausVK) / sizeof(ausVK[0]),
    aE0VscToVk,
    aE1VscToVk,

    /*
     * No Locale-specific special processing
     */
    0,

    /*
     * No Ligatures
     */
    0, 0, NULL,

    /*
     * Type and subtype.
     */
    KEYBOARD_TYPE_JAPAN,    // Japanese Keyboard Layout
    MAKEWORD(NEC_KBD_N_MODE_TYPE, NLSKBD_OEM_NEC),
};

PKBDTABLES KbdLayerDescriptor(VOID)
{
    return &KbdTablesNec;
}

/***********************************************************************\
* VkToFuncTable_NEC[]
*
\***********************************************************************/

static ALLOC_SECTION_LDATA VK_F VkToFuncTable_NEC[] = {
    {
        VK_DBE_SBCSCHAR,     // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SBCSDBCS,0},             // Base
            {KBDNLS_SBCSDBCS,0},             // Shift
            {KBDNLS_SBCSDBCS,0},             // Control
            {KBDNLS_SBCSDBCS,0},             // Shift+Control
            {KBDNLS_SBCSDBCS,0},             // Alt
            {KBDNLS_SBCSDBCS,0},             // Shift+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}, // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}  // Shift+Control+Alt
        },
        {                    // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_NONCONVERT,       // Base Vk  PC98_NFER key
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},                             // Base
            {KBDNLS_SEND_BASE_VK,0},                             // Shift
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ALPHANUMERIC},          // Control
            {KBDNLS_SBCSDBCS,0},                                 // Shift+Control
            {KBDNLS_SEND_PARAM_VK,VK_DBE_KATAKANA},              // Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}, // Shift+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_NOCODEINPUT},           // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_FLUSHSTRING}            // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_CONVERT,            // Base Vk  PC98_XFER key
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},                          // Base
            {KBDNLS_SEND_BASE_VK,0},                          // Shift
            {KBDNLS_SEND_PARAM_VK,VK_KANJI},                  // Control
            {KBDNLS_SEND_BASE_VK,0},                          // Shift+Control
            {KBDNLS_ROMAN,0},                                 // Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}, // Shift+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_CODEINPUT},          // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_HIRAGANA}            // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_OEM_NEC_EQUAL,    // Base Vk NEC98_"="  key
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},                  // Base
            {KBDNLS_SEND_BASE_VK,0},                  // Shift
            {KBDNLS_SEND_PARAM_VK,VK_SCROLL},         // Control
            {KBDNLS_SEND_BASE_VK,0},                  // Shift+Control
            {KBDNLS_SEND_BASE_VK,0},                  // Alt
            {KBDNLS_SEND_BASE_VK,0},                  // Shift+Alt
            {KBDNLS_SEND_BASE_VK,0},                  // Control+Alt
            {KBDNLS_SEND_BASE_VK,0}                   // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_HOME,             // Base Vk  PC98_HOME  key
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_HOME_OR_CLEAR,0},         // Base
            {KBDNLS_SEND_BASE_VK,0},          // Shift
            {KBDNLS_HOME_OR_CLEAR,0},         // Control
            {KBDNLS_HOME_OR_CLEAR,0},         // Shift+Control
            {KBDNLS_HOME_OR_CLEAR,0},         // Alt
            {KBDNLS_HOME_OR_CLEAR,0},         // Shift+Alt
            {KBDNLS_HOME_OR_CLEAR,0},         // Control+Alt
            {KBDNLS_HOME_OR_CLEAR,0}          // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_END,              // Base Vk  PC98_HELP  key
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_HELP_OR_END,0},         // Base
            {KBDNLS_HELP_OR_END,0},         // Shift
            {KBDNLS_HELP_OR_END,0},         // Control
            {KBDNLS_HELP_OR_END,0},         // Shift+Control
            {KBDNLS_HELP_OR_END,0},         // Alt
            {KBDNLS_HELP_OR_END,0},         // Shift+Alt
            {KBDNLS_HELP_OR_END,0},         // Control+Alt
            {KBDNLS_HELP_OR_END,0}          // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    }
};

USHORT ausMouseVKey98[] = {
                       VK_CLEAR,           // Numpad 5: Click active button
                       VK_PRIOR,           // Numpad 9: Up & Right
                       VK_NEXT,            // Numpad 3: Down & Right
                       VK_END,             // Numpad 1: Down & Left
                       VK_HOME,            // Numpad 7: Up & Left
                       VK_LEFT,            // Numpad 4: Left
                       VK_UP,              // Numpad 8: Up
                       VK_RIGHT,           // Numpad 6: Right
                       VK_DOWN,            // Numpad 2: Down
                       VK_INSERT,          // Numpad 0: Active button down
                       VK_DELETE,          // Numpad .: Active button up
                       VK_MULTIPLY,
                       VK_ADD,
                       VK_SUBTRACT,
                       VK_DIVIDE | KBDEXT,
                       VK_HOME | KBDEXT
                      };

/***********************************************************************\
* KbdNlsTables
*
\***********************************************************************/

static ALLOC_SECTION_LDATA KBDNLSTABLES KbdNlsTables = {
    0,                      // OEM ID (0 = Microsoft)
    NLSKBD_INFO_ACCESSIBILITY_KEYMAP,// Information
    6,                      // Number of VK_F entry
    VkToFuncTable_NEC,      // Pointer to VK_F array
    16,                     // Number of MouseVk entry
    ausMouseVKey98          // Pointer to MouseVk array
};

ALLOC_SECTION_LDATA KBDNLSTABLES KbdNlsTablesNEC98 = {
    0x0d,                   // OEM ID (0x0d = NEC)
    NLSKBD_INFO_ACCESSIBILITY_KEYMAP,// Information
    6,                      // Number of VK_F entry
    VkToFuncTable_NEC,      // Pointer to VK_F array
    16,                     // Number of MouseVk entry
    ausMouseVKey98          // Pointer to MouseVk array
};

PKBDNLSTABLES KbdNlsLayerDescriptor(VOID)
{
#ifdef W2K_BEHAVIOR
    if (!IsNEC_98) {
        return &KbdNlsTables;
    } else {
        return &KbdNlsTablesNEC98;
    }
#else
    // From Whistler, we don't support NEC 9800 series: no need to
    // have NEC's OEMID in the NLSTABLE.
    return &KbdNlsTables;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\fe_kbds\jpn\kbdnec95\sources.inc ===
!IF 0

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


!ENDIF

MINORCOMP=kbdnec95

!include ..\..\japan.inc

SOURCES_USED=..\sources.inc

C_DEFINES=$(C_DEFINES) -D_PC98_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\fe_kbds\jpn\kbdnecnt\kbdnecnt.h ===
#if defined(_PC98_)
/****************************** Module Header ******************************\
* Module Name: kbdnec.h
*
* Copyright (c) 1985-91, Microsoft Corporation
*
* Various defines for use by keyboard input code.
*
* History:
* 27-May-1992 KazuM
\***************************************************************************/
#else
/****************************** Module Header ******************************\
* Module Name: kbd106.h
*
* Copyright (c) 1985-91, Microsoft Corporation
*
* Various defines for use by keyboard input code.
*
* History:
\***************************************************************************/
#endif

/*
 * kbd type should be controlled by cl command-line argument
 */
#if defined(_PC98_)
#define KBD_TYPE 34
#else
#define KBD_TYPE 8
#endif

/*
 * Include the basis of all keyboard table values
 */
#include "kbd.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\fe_kbds\jpn\kbdnecnt\sources.inc ===
!IF 0

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


!ENDIF

MINORCOMP=kbdnecnt

!include ..\..\japan.inc

SOURCES_USED=..\sources.inc

C_DEFINES=$(C_DEFINES) -D_PC98_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\fe_kbds\jpn\kbdnecnt\kbdnecnt.c ===
#if defined(JAPAN) && defined(_PC98_)
/***************************************************************************\
* Module Name: kbdnec.c
*
* Copyright (c) 1985-92, Microsoft Corporation
*
* History:
\***************************************************************************/
#else  // _PC98_
/***************************************************************************\
* Module Name: kbd106.c
*
* Copyright (c) 1985-92, Microsoft Corporation
*
* History:
\***************************************************************************/
#endif // _PC98_

#include <windows.h>
#include <ime.h>
#include "vkoem.h"
#include "kbdjpn.h"
#if defined(JAPAN) && defined(_PC98_)
#include "kbdnecNT.h"
#else  // _PC98_
#include "kbd106.h"
#endif // _PC98_

#if defined(_M_IA64)
#pragma section(".data")
#define ALLOC_SECTION_LDATA __declspec(allocate(".data"))
#else
#pragma data_seg(".data")
#define ALLOC_SECTION_LDATA
#endif

#if defined(JAPAN) && defined(_PC98_)
/***************************************************************************\
* ausVK[] - Virtual Scan Code to Virtual Key conversion table for NEC 106
\***************************************************************************/
#else // _PC98_
/***************************************************************************\
* ausVK[] - Virtual Scan Code to Virtual Key conversion table for 106
\***************************************************************************/
#endif // _PC98_

static ALLOC_SECTION_LDATA USHORT ausVK[] = {
    T00, T01, T02, T03, T04, T05, T06, T07,
    T08, T09, T0A, T0B, T0C, T0D, T0E, T0F,
    T10, T11, T12, T13, T14, T15, T16, T17,
    T18, T19, T1A, T1B, T1C, T1D, T1E, T1F,
    T20, T21, T22, T23, T24, T25, T26, T27,
#if defined(JAPAN) && defined(_PC98_)
    T28, T29, T2A, T2B, T2C, T2D, T2E, T2F,
#else // _PC98_
    T28,

    /*
     * Hankaku/Zenkaku/Kanji key must have KBDSPECIAL bit set (NLS key)
     */
    T29 | KBDSPECIAL,

              T2A, T2B, T2C, T2D, T2E, T2F,
#endif // _PC98_
    T30, T31, T32, T33, T34, T35,

    /*
     * Right-hand Shift key must have KBDEXT bit set.
     */
    T36 | KBDEXT,

#if defined(JAPAN) && defined(_PC98_)
    T37,
#else //_PC98_
    /*
     * numpad_* + Shift/Alt -> SnapShot
     */
    T37 | KBDMULTIVK,
#endif // _PC98_

    T38, T39,

#if defined(JAPAN) && defined(_PC98_)
    T3A,
#else //_PC98_
    /*
     * Alphanumeric/CapsLock key must have KBDSPECIAL bit set (NLS key)
     */
    T3A | KBDSPECIAL,
#endif // _PC98_

                   T3B, T3C, T3D, T3E, T3F,
    T40, T41, T42, T43, T44,

    /*
     * NumLock Key:
     *     KBDEXT     - VK_NUMLOCK is an Extended key
     *     KBDMULTIVK - VK_NUMLOCK or VK_PAUSE (without or with CTRL)
     */
    T45 | KBDEXT | KBDMULTIVK,

#if defined(JAPAN) && defined(_PC98_)
    T46,
#else //_PC98_
    T46 | KBDMULTIVK,
#endif // _PC98_

    /*
     * Number Pad keys:
     *     KBDNUMPAD  - digits 0-9 and decimal point.
     *     KBDSPECIAL - require special processing by Windows
     */
    T47 | KBDNUMPAD | KBDSPECIAL,   // Numpad 7 (Home)
    T48 | KBDNUMPAD | KBDSPECIAL,   // Numpad 8 (Up),
    T49 | KBDNUMPAD | KBDSPECIAL,   // Numpad 9 (PgUp),
    T4A,
    T4B | KBDNUMPAD | KBDSPECIAL,   // Numpad 4 (Left),
    T4C | KBDNUMPAD | KBDSPECIAL,   // Numpad 5 (Clear),
    T4D | KBDNUMPAD | KBDSPECIAL,   // Numpad 6 (Right),
    T4E,
    T4F | KBDNUMPAD | KBDSPECIAL,   // Numpad 1 (End),
    T50 | KBDNUMPAD | KBDSPECIAL,   // Numpad 2 (Down),
    T51 | KBDNUMPAD | KBDSPECIAL,   // Numpad 3 (PgDn),
    T52 | KBDNUMPAD | KBDSPECIAL,   // Numpad 0 (Ins),
    T53 | KBDNUMPAD | KBDSPECIAL,   // Numpad . (Del),

#if defined(JAPAN) && defined(_PC98_)
    T54, T55, T56, T57, T58,

    T59 | KBDSPECIAL,               // NEC TenKey EQU (VK_SCROLL)

    T5A | KBDSPECIAL,               // NEC No-Conversion key     // NLS key

    T5B, T5C, T5D, T5E, T5F
#else //_PC98_
    T54, T55, T56, T57, T58, T59, T5A, T5B,
    T5C, T5D, T5E, T5F, T60, T61, T62, T63,
    T64, T65, T66, T67, T68, T69, T6A, T6B,
    T6C, T6D, T6E, T6F,

    /*
     * Hiragana/Katakana/Roman key must have KBDSPECIAL bit set (NLS key)
     */
    T70 | KBDSPECIAL,

                             T71, T72, T73,
    T74, T75, T76, T77, T78,

    /*
     * Conversion key must have KBDSPECIAL bit set (NLS key)
     */
    T79 | KBDSPECIAL,

                                  T7A,

    /*
     * Non-Conversion key must have KBDSPECIAL bit set (NLS key)
     */
    T7B | KBDSPECIAL,

    T7C, T7D, T7E, T7F

#endif // _PC98_
};

static ALLOC_SECTION_LDATA VSC_VK aE0VscToVk[] = {
        { 0x1C, X1C | KBDEXT              },  // Numpad Enter
#if defined(JAPAN) && defined(_PC98_)
        { 0x1D, X1D | KBDEXT | KBDSPECIAL },  // Katakana key   // NLS key
#else //_PC98_
        { 0x1D, X1D | KBDEXT              },  // RControl
#endif // _PC98_
        { 0x35, X35 | KBDEXT              },  // Numpad Divide
        { 0x37, X37 | KBDEXT              },  // Snapshot
#if defined(JAPAN) && defined(_PC98_)
        { 0x38, X38 | KBDEXT | KBDSPECIAL },  // Kanji key      // NLS key
#else //_PC98_
        { 0x38, X38 | KBDEXT              },  // RMenu
#endif // _PC98_
        { 0x46, X46 | KBDEXT              },  // Break (Ctrl + Pause)
#if defined(JAPAN) && defined(_PC98_)
        { 0x47, X47 | KBDEXT | KBDSPECIAL },  // Home //_PC98_ for CLEAR key
#else //_PC98_
        { 0x47, X47 | KBDEXT              },  // Home
#endif // _PC98_
        { 0x48, X48 | KBDEXT              },  // Up
        { 0x49, X49 | KBDEXT              },  // Prior
        { 0x4B, X4B | KBDEXT              },  // Left
        { 0x4D, X4D | KBDEXT              },  // Right
#if defined(JAPAN) && defined(_PC98_)
        { 0x4F, X4F | KBDEXT | KBDSPECIAL },  // End  //_PC98_ for HELP key
#else //_PC98_
        { 0x4F, X4F | KBDEXT              },  // End
#endif // _PC98_
        { 0x50, X50 | KBDEXT              },  // Down
        { 0x51, X51 | KBDEXT              },  // Next
        { 0x52, X52 | KBDEXT              },  // Insert
        { 0x53, X53 | KBDEXT              },  // Delete
        { 0x5B, X5B | KBDEXT              },  // Left Win
        { 0x5C, X5C | KBDEXT              },  // Right Win
        { 0x5D, X5D | KBDEXT              },  // Application
        { 0,      0                       }
};

static ALLOC_SECTION_LDATA VSC_VK aE1VscToVk[] = {
        { 0x1D, Y1D                       },  // Pause
        { 0   ,   0                       }
};

/***************************************************************************\
* aVkToBits[]  - map Virtual Keys to Modifier Bits
*
* See kbd.h for a full description.
*
* US Keyboard has only three shifter keys:
*     SHIFT (L & R) affects alphabnumeric keys,
*     CTRL  (L & R) is used to generate control characters
*     ALT   (L & R) used for generating characters by number with numpad
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_BIT aVkToBits[] = {
    { VK_SHIFT,   KBDSHIFT },
    { VK_CONTROL, KBDCTRL  },
    { VK_MENU,    KBDALT   },
    { VK_KANA,    KBDKANA  },
    { 0,          0        }
};

/***************************************************************************\
* aModification[]  - map character modifier bits to modification number
*
* See kbd.h for a full description.
*
\***************************************************************************/

static ALLOC_SECTION_LDATA MODIFIERS CharModifiers = {
    &aVkToBits[0],
    11,
    {
    //  Modification# //  Keys Pressed  : Explanation
    //  ============= // ============== : =============================
        0,            //                : unshifted characters
        1,            //          SHIFT : capitals, ~!@#$%^&*()_+{}:"<>? etc.
        4,            //     CTRL       : control characters
        6,            //     CTRL SHIFT :
        SHFT_INVALID, // ALT            : invalid
        SHFT_INVALID, // ALT      SHIFT : invalid
        SHFT_INVALID, // ALT CTRL       : invalid
        SHFT_INVALID, // ALT CTRL SHIFT : invalid
        2,            //KANA
        3,            //KANA      SHIFT
        5,            //KANA CTRL
        7             //KANA CTRL SHIFT
    }
};

/***************************************************************************\
*
* aVkToWch2[]  - Virtual Key to WCHAR translation for 2 shift states
* aVkToWch3[]  - Virtual Key to WCHAR translation for 3 shift states
* aVkToWch4[]  - Virtual Key to WCHAR translation for 4 shift states
*
* Table attributes: Unordered Scan, null-terminated
*
* Search this table for an entry with a matching Virtual Key to find the
* corresponding unshifted and shifted WCHAR characters.
*
* Reserved VirtualKey values (first column)
*     -1            - this line contains dead characters (diacritic)
*     0             - terminator
*
* Reserved Attribute values (second column)
*     CAPLOK        - CapsLock affects this key like Shift
*     KANALOK       - The KANA-LOCK key affects this key like KANA
*
* Reserved character values (third through last column)
*     WCH_NONE      - No character
*     WCH_DEAD      - Dead character (diacritic) value is in next line
*
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch4[] = {
    //                               |          |   SHIFT  |  KANA  | K+SHFT |
    //                               |          |==========|========|========|
#if defined(JAPAN) && defined(_PC98_)
    {'0'          ,          KANALOK ,'0'       ,'0'       ,WCH_WA  ,WCH_WO  }, //_PC98_
#else //_PC98_
    {'0'          ,          KANALOK ,'0'       ,WCH_NONE  ,WCH_WA  ,WCH_WO  },
#endif // _PC98_
    {'1'          ,          KANALOK ,'1'       ,'!'       ,WCH_NU  ,WCH_NU  },
    {'3'          ,          KANALOK ,'3'       ,'#'       ,WCH_A   ,WCH_AA  },
    {'4'          ,          KANALOK ,'4'       ,'$'       ,WCH_U   ,WCH_UU  },
    {'5'          ,          KANALOK ,'5'       ,'%'       ,WCH_E   ,WCH_EE  },
#if defined(JAPAN) && defined(_PC98_)
    {'7'          ,          KANALOK ,'7'       ,'\''      ,WCH_YA  ,WCH_YAA }, //_PC98_
#else //_PC98_
    {'7'          ,          KANALOK ,'7'       ,0x27      ,WCH_YA  ,WCH_YAA },
#endif // _PC98_
    {'8'          ,          KANALOK ,'8'       ,'('       ,WCH_YU  ,WCH_YUU },
    {'9'          ,          KANALOK ,'9'       ,')'       ,WCH_YO  ,WCH_YOO },
    {'A'          , CAPLOK | KANALOK ,'a'       ,'A'       ,WCH_TI  ,WCH_TI  },
    {'B'          , CAPLOK | KANALOK ,'b'       ,'B'       ,WCH_KO  ,WCH_KO  },
    {'C'          , CAPLOK | KANALOK ,'c'       ,'C'       ,WCH_SO  ,WCH_SO  },
    {'D'          , CAPLOK | KANALOK ,'d'       ,'D'       ,WCH_SI  ,WCH_SI  },
    {'E'          , CAPLOK | KANALOK ,'e'       ,'E'       ,WCH_I   ,WCH_II  },
    {'F'          , CAPLOK | KANALOK ,'f'       ,'F'       ,WCH_HA  ,WCH_HA  },
    {'G'          , CAPLOK | KANALOK ,'g'       ,'G'       ,WCH_KI  ,WCH_KI  },
    {'H'          , CAPLOK | KANALOK ,'h'       ,'H'       ,WCH_KU  ,WCH_KU  },
    {'I'          , CAPLOK | KANALOK ,'i'       ,'I'       ,WCH_NI  ,WCH_NI  },
    {'J'          , CAPLOK | KANALOK ,'j'       ,'J'       ,WCH_MA  ,WCH_MA  },
    {'K'          , CAPLOK | KANALOK ,'k'       ,'K'       ,WCH_NO  ,WCH_NO  },
    {'L'          , CAPLOK | KANALOK ,'l'       ,'L'       ,WCH_RI  ,WCH_RI  },
    {'M'          , CAPLOK | KANALOK ,'m'       ,'M'       ,WCH_MO  ,WCH_MO  },
    {'N'          , CAPLOK | KANALOK ,'n'       ,'N'       ,WCH_MI  ,WCH_MI  },
    {'O'          , CAPLOK | KANALOK ,'o'       ,'O'       ,WCH_RA  ,WCH_RA  },
    {'P'          , CAPLOK | KANALOK ,'p'       ,'P'       ,WCH_SE  ,WCH_SE  },
    {'Q'          , CAPLOK | KANALOK ,'q'       ,'Q'       ,WCH_TA  ,WCH_TA  },
    {'R'          , CAPLOK | KANALOK ,'r'       ,'R'       ,WCH_SU  ,WCH_SU  },
    {'S'          , CAPLOK | KANALOK ,'s'       ,'S'       ,WCH_TO  ,WCH_TO  },
    {'T'          , CAPLOK | KANALOK ,'t'       ,'T'       ,WCH_KA  ,WCH_KA  },
    {'U'          , CAPLOK | KANALOK ,'u'       ,'U'       ,WCH_NA  ,WCH_NA  },
    {'V'          , CAPLOK | KANALOK ,'v'       ,'V'       ,WCH_HI  ,WCH_HI  },
    {'W'          , CAPLOK | KANALOK ,'w'       ,'W'       ,WCH_TE  ,WCH_TE  },
    {'X'          , CAPLOK | KANALOK ,'x'       ,'X'       ,WCH_SA  ,WCH_SA  },
    {'Y'          , CAPLOK | KANALOK ,'y'       ,'Y'       ,WCH_NN  ,WCH_NN  },
    {'Z'          , CAPLOK | KANALOK ,'z'       ,'Z'       ,WCH_TU  ,WCH_TUU },
    {VK_OEM_1     ,          KANALOK ,':'       ,'*'       ,WCH_KE  ,WCH_KE  },
    {VK_OEM_2     ,          KANALOK ,'/'       ,'?'       ,WCH_ME  ,WCH_MD  },
#if defined(JAPAN) && defined(_PC98_)
#else //_PC98_
    {VK_OEM_3     ,          KANALOK ,'@'       ,'`'       ,WCH_VS  ,WCH_VS  },
    {VK_OEM_7     ,          KANALOK ,'^'       ,'~'       ,WCH_HE  ,WCH_HE  },
    {VK_OEM_8     , 0                ,WCH_NONE  ,WCH_NONE  ,WCH_NONE,WCH_NONE},
#endif // _PC98_
    {VK_OEM_COMMA ,          KANALOK ,','       ,'<'       ,WCH_NE  ,WCH_IC  },
    {VK_OEM_PERIOD,          KANALOK ,'.'       ,'>'       ,WCH_RU  ,WCH_IP  },
    {VK_OEM_PLUS  ,          KANALOK ,';'       ,'+'       ,WCH_RE  ,WCH_RE  },
    {VK_TAB       , 0                ,'\t'      ,'\t'      ,'\t'    ,'\t'    },
    {VK_ADD       , 0                ,'+'       ,'+'       ,'+'     ,'+'     },
    {VK_DECIMAL   , 0                ,'.'       ,'.'       ,'.'     ,'.'     },
    {VK_DIVIDE    , 0                ,'/'       ,'/'       ,'/'     ,'/'     },
    {VK_MULTIPLY  , 0                ,'*'       ,'*'       ,'*'     ,'*'     },
    {VK_SUBTRACT  , 0                ,'-'       ,'-'       ,'-'     ,'-'     },
#if defined(JAPAN) && defined(_PC98_)
    {VK_SEPARATOR , 0                ,','       ,','       ,','     ,','     }, //<NEC_OCDE OEM
    {VK_OEM_NEC_EQUAL,    0          ,'='       ,'='       ,'='     ,'='     }, //<_PC98_ OEM
    {VK_NUMPAD0   , 0                ,'0'       ,'0'       ,'0'     ,'0'     },//_PC98_
    {VK_NUMPAD1   , 0                ,'1'       ,'1'       ,'1'     ,'1'     },//_PC98_
    {VK_NUMPAD2   , 0                ,'2'       ,'2'       ,'2'     ,'2'     },//_PC98_
    {VK_NUMPAD3   , 0                ,'3'       ,'3'       ,'3'     ,'3'     },//_PC98_
    {VK_NUMPAD4   , 0                ,'4'       ,'4'       ,'4'     ,'4'     },//_PC98_
    {VK_NUMPAD5   , 0                ,'5'       ,'5'       ,'5'     ,'5'     },//_PC98_
    {VK_NUMPAD6   , 0                ,'6'       ,'6'       ,'6'     ,'6'     },//_PC98_
    {VK_NUMPAD7   , 0                ,'7'       ,'7'       ,'7'     ,'7'     },//_PC98_
    {VK_NUMPAD8   , 0                ,'8'       ,'8'       ,'8'     ,'8'     },//_PC98_
    {VK_NUMPAD9   , 0                ,'9'       ,'9'       ,'9'     ,'9'     },//_PC98_
#endif // _PC98_
    {0            , 0                ,0         ,0         ,0       ,0       }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS6 aVkToWch6[] = {
    //                      |          |   SHIFT  |  KANA  | K+SHFT |  CONTROL  |  K+CTRL   |
    //                      |          |==========|========|========|===========|===========|
    {VK_BACK      , 0       ,'\b'      ,'\b'      ,'\b'    ,'\b'    , 0x7f      , 0x7f      },
    {VK_CANCEL    , 0       ,0x03      ,0x03      ,0x03    ,0x03    , 0x03      , 0x03      },
    {VK_ESCAPE    , 0       ,0x1b      ,0x1b      ,0x1b    ,0x1b    , 0x1b      , 0x1b      },
#if defined(JAPAN) && defined(_PC98_)
    {VK_OEM_3     , KANALOK ,'@'       ,'~'       ,WCH_VS  ,WCH_VS  , 0x00      , 0x00      },//_PC98_ #931208
    {VK_OEM_4     , KANALOK ,'['       ,'{'       ,WCH_SVS ,WCH_OB  , 0x1b      , 0x1b      },//_PC98_
    {VK_OEM_4     , KANALOK ,'['       ,'{'       ,WCH_SVS ,WCH_OB  , 0x1b      , 0x1b      },//_PC98_
    {VK_OEM_5     , KANALOK ,'\\'      ,'|'       ,WCH_PS  ,WCH_PS  , 0x1c      , 0x1c      },//_PC98_
    {VK_OEM_6     , KANALOK ,']'       ,'}'       ,WCH_MU  ,WCH_CB  , 0x1d      , 0x1d      },//_PC98_
    {VK_OEM_7     , KANALOK ,'^'       ,'`'       ,WCH_HE  ,WCH_HE  , 0x1e      , 0x1e      },//_PC98_ #931208
    {VK_OEM_8     , KANALOK ,WCH_NONE  ,'_'       ,WCH_RO  ,WCH_RO  , 0x1f      , 0x1f      },//_PC98_ #931208
#else //_PC98_
    {VK_OEM_4     , KANALOK ,'['       ,'{'       ,WCH_SVS ,WCH_OB  , 0x1b      , 0x1b      },
    {VK_OEM_5     , KANALOK ,'\\'      ,'|'       ,WCH_PS  ,WCH_PS  , 0x1c      , 0x1c      },
    {VK_OEM_102   , KANALOK ,'\\'      ,'_'       ,WCH_RO  ,WCH_RO  , 0x1c      , 0x1c      },
    {VK_OEM_6     , KANALOK ,']'       ,'}'       ,WCH_MU  ,WCH_CB  , 0x1d      , 0x1d      },
#endif // _PC98_
    {VK_RETURN    , 0       ,'\r'      ,'\r'      ,'\r'    ,'\r'    , '\n'      , '\n'      },
    {VK_SPACE     , 0       ,' '       ,' '       ,' '     ,' '     , 0x20      , 0x20      },
    {0            , 0       ,0         ,0         ,0       ,0       , 0         , 0         }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS8 aVkToWch8[] = {
    //                      |          |   SHIFT  |  KANA  | K+SHFT |  CONTROL  |  K+CTRL   | SHFT+CTRL |K+SHFT+CTRL|
    //                      |          |==========|========|========|===========|===========|===========|===========|
    {'2'          , KANALOK ,'2'       ,'"'       ,WCH_HU  ,WCH_HU  , WCH_NONE  , WCH_NONE  , 0x00      , 0x00      },
    {'6'          , KANALOK ,'6'       ,'&'       ,WCH_O   ,WCH_OO  , WCH_NONE  , WCH_NONE  , 0x1e      , 0x1e      },
    {VK_OEM_MINUS , KANALOK ,'-'       ,'='       ,WCH_HO  ,WCH_HO  , WCH_NONE  , WCH_NONE  , 0x1f      , 0x1f      },
    {0            , 0       ,0         ,0         ,0       ,0       , 0         , 0         , 0         , 0         }
};

// Put this last so that VkKeyScan interprets number characters
// as coming from the main section of the kbd (aVkToWch2 and
// aVkToWch4) before considering the numpad (aVkToWch1).

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch1[] = {
    //                     |          |   SHIFT  |  KANA  | K+SHFT |
    //                     |          |==========|========|========|
    { VK_NUMPAD0   , 0      ,  '0'    , WCH_NONE ,   '0'  ,WCH_NONE},
    { VK_NUMPAD1   , 0      ,  '1'    , WCH_NONE ,   '1'  ,WCH_NONE},
    { VK_NUMPAD2   , 0      ,  '2'    , WCH_NONE ,   '2'  ,WCH_NONE},
    { VK_NUMPAD3   , 0      ,  '3'    , WCH_NONE ,   '3'  ,WCH_NONE},
    { VK_NUMPAD4   , 0      ,  '4'    , WCH_NONE ,   '4'  ,WCH_NONE},
    { VK_NUMPAD5   , 0      ,  '5'    , WCH_NONE ,   '5'  ,WCH_NONE},
    { VK_NUMPAD6   , 0      ,  '6'    , WCH_NONE ,   '6'  ,WCH_NONE},
    { VK_NUMPAD7   , 0      ,  '7'    , WCH_NONE ,   '7'  ,WCH_NONE},
    { VK_NUMPAD8   , 0      ,  '8'    , WCH_NONE ,   '8'  ,WCH_NONE},
    { VK_NUMPAD9   , 0      ,  '9'    , WCH_NONE ,   '9'  ,WCH_NONE},
    { 0            , 0      ,  '\0'   , 0        ,   0    ,0       }   //null terminator
};

/***************************************************************************\
* aVkToWcharTable: table of pointers to Character Tables
*
* Describes the character tables and the order they should be searched.
*
* Note: the order determines the behavior of VkKeyScan() : this function
*       takes a character and attempts to find a Virtual Key and character-
*       modifier key combination that produces that character.  The table
*       containing the numeric keypad (aVkToWch1) must appear last so that
*       VkKeyScan('0') will be interpreted as one of keys from the main
*       section, not the numpad.  etc.
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHAR_TABLE aVkToWcharTable[] = {
    {  (PVK_TO_WCHARS1)aVkToWch6, 6, sizeof(aVkToWch6[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch8, 8, sizeof(aVkToWch8[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch4, 4, sizeof(aVkToWch4[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch1, 4, sizeof(aVkToWch1[0]) },  // must come last
    {                       NULL, 0, 0                    }
};

/***************************************************************************\
* aKeyNames[], aKeyNamesExt[]  - Scan Code -> Key Name tables
*
* For the GetKeyNameText() API function
*
* Tables for non-extended and extended (KBDEXT) keys.
* (Keys producing printable characters are named by the character itself)
\***************************************************************************/

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNames[] = {
#if defined(JAPAN) && defined(_PC98_)
    0x01,    L"ESC",            //NEC Esc
    0x0e,    L"BS",             //NEC Backspace
    0x0f,    L"TAB",            //NEC Tab
    0x1c,    L"RETURN",         //NEC Enter
    0x1d,    L"CTRL",           //NEC Ctrl
    0x2a,    L"SHIFT",          //NEC Shift
    0x36,    L"SHIFT",          //NEC Rgiht Shift
#else //_PC98_
    0x01,    L"Esc",
    0x0e,    L"Backspace",
    0x0f,    L"Tab",
    0x1c,    L"Enter",
    0x1d,    L"Ctrl",
    0x29,    (LPWSTR)SZ_KEY_NAME_HANKAKU_ZENKAKU,  // NLS Key
    0x2a,    L"Shift",
    0x36,    L"Right Shift",
#endif // _PC98_
    0x37,    L"Num *",
#if defined(JAPAN) && defined(_PC98_)
    0x38,    L"GRPH",           //NEC Alt
    0x39,    L"SPACE",          //NEC Space
    0x3a,    L"CAPS",           //NEC Caps Lock
    0x3b,    (LPWSTR)SZ_KEY_NAME_F1,    //NEC F1
    0x3c,    (LPWSTR)SZ_KEY_NAME_F2,    //NEC F2
    0x3d,    (LPWSTR)SZ_KEY_NAME_F3,    //NEC F3
    0x3e,    (LPWSTR)SZ_KEY_NAME_F4,    //NEC F4
    0x3f,    (LPWSTR)SZ_KEY_NAME_F5,    //NEC F5
    0x40,    (LPWSTR)SZ_KEY_NAME_F6,    //NEC F6
    0x41,    (LPWSTR)SZ_KEY_NAME_F7,    //NEC F7
    0x42,    (LPWSTR)SZ_KEY_NAME_F8,    //NEC F8
    0x43,    (LPWSTR)SZ_KEY_NAME_F9,    //NEC F9
    0x44,    (LPWSTR)SZ_KEY_NAME_F10,   //NEC F10
#else //_PC98_
    0x38,    L"Alt",
    0x39,    L"Space",
    0x3a,    L"Caps Lock",
    0x3b,    L"F1",
    0x3c,    L"F2",
    0x3d,    L"F3",
    0x3e,    L"F4",
    0x3f,    L"F5",
    0x40,    L"F6",
    0x41,    L"F7",
    0x42,    L"F8",
    0x43,    L"F9",
    0x44,    L"F10",
#endif // _PC98_
    0x45,    L"Pause",
    0x46,    L"Scroll Lock",
    0x47,    L"Num 7",
    0x48,    L"Num 8",
    0x49,    L"Num 9",
    0x4a,    L"Num -",
    0x4b,    L"Num 4",
    0x4c,    L"Num 5",
    0x4d,    L"Num 6",
    0x4e,    L"Num +",
    0x4f,    L"Num 1",
    0x50,    L"Num 2",
    0x51,    L"Num 3",
    0x52,    L"Num 0",
#if defined(JAPAN) && defined(_PC98_)
    0x53,    L"Num .",                    //NEC #931125
#else //_PC98_
    0x53,    L"Num Del",
#endif // _PC98_
    0x54,    L"Sys Req",
#if defined(JAPAN) && defined(_PC98_)
    0x55,    L"",                         //NEC <931125
    0x57,    (LPWSTR)SZ_KEY_NAME_F11,     //NEC
    0x58,    (LPWSTR)SZ_KEY_NAME_F12,     //NEC
    0x59,    L"Num =",                    //NEC
    0x5A,    L"NFER",                     //NEC
    0x5B,    L"Convert",                  //NEC not use
    0x5C,    L"Num ,",                    //NEC
    0x5D,    (LPWSTR)SZ_KEY_NAME_F13,     //NEC
    0x5E,    (LPWSTR)SZ_KEY_NAME_F14,     //NEC
    0x5F,    (LPWSTR)SZ_KEY_NAME_F15,     //NEC
#else  //  _PC98_
    0x57,    L"F11",
    0x58,    L"F12",
    0x70,    (LPWSTR)SZ_KEY_NAME_HIRAGANA,
    0x79,    (LPWSTR)SZ_KEY_NAME_HENKAN,
    0x7b,    (LPWSTR)SZ_KEY_NAME_MUHENKAN,
    0x7C,    L"F13",
#endif // _PC98_
    0   ,    NULL
};

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNamesExt[] = {
#if defined(JAPAN) && defined(_PC98_)
    0x1c,    L"Num Enter",
    0x1d,    (LPWSTR)SZ_KEY_NAME_KANA,  //NEC NLS Key Katakana
    0x35,    L"Num /",
    0x37,    L"COPY",                   //NEC Prnt Scr
    0x38,    L"XFER",                   //NEC NLS Key SZ_KEY_NAME_HIRAGANA
    0x45,    L"Num Lock",
    0x46,    L"STOP",                   //NEC Break
    0x47,    L"CLR",                    //NEC Home #931125
    0x48,    L"UP",                     //NEC Up
    0x49,    L"ROLL DOWN",              //NEC Page Up
    0x4b,    L"LEFT",                   //NEC Left
    0x4d,    L"RIGHT",                  //NEC Right
    0x4f,    L"HELP",                   //NEC End  #931125
    0x50,    L"DOWN",                   //NEC Down
    0x51,    L"ROLL UP",                //NEC Page Down
    0x52,    L"INS",                    //NEC Insert
    0x53,    L"DEL",                    //NEC Delete
    0x54,    L"<00>",
    0x56,    L"HELP",                   //NEC Help
//    0x5C,    L"CLR",                    //NEC Clear
#else //_PC98_
    0x1c,    L"Num Enter",
    0x1d,    L"Right Control",
    0x35,    L"Num /",
    0x37,    L"Prnt Scrn",
    0x38,    L"Right Alt",
    0x45,    L"Num Lock",
    0x46,    L"Break",
    0x47,    L"Home",
    0x48,    L"Up",
    0x49,    L"Page Up",
    0x4b,    L"Left",
    0x4d,    L"Right",
    0x4f,    L"End",
    0x50,    L"Down",
    0x51,    L"Page Down",
    0x52,    L"Insert",
    0x53,    L"Delete",
#endif // _PC98_
    0x5B,    L"Left Windows",
    0x5C,    L"Right Windows",
    0x5D,    L"Application",
    0   ,    NULL
};

static ALLOC_SECTION_LDATA KBDTABLES KbdTables = {
    /*
     * Modifier keys
     */
    &CharModifiers,

    /*
     * Characters tables
     */
    aVkToWcharTable,

    /*
     * Diacritics  (none for US English)
     */
    NULL,

    /*
     * Names of Keys  (no dead keys)
     */
    aKeyNames,
    aKeyNamesExt,
    NULL,

    /*
     * Scan codes to Virtual Keys
     */
    ausVK,
    sizeof(ausVK) / sizeof(ausVK[0]),
    aE0VscToVk,
    aE1VscToVk,

    /*
     * No Locale-specific special processing
     */
    0,

    /*
     * No Ligatures
     */
    0, 0, NULL,

    /*
     * Type and subtype.
     */
    KEYBOARD_TYPE_JAPAN,    // Japanese Keyboard Layout
    MAKEWORD(NEC_KBD_N_MODE_TYPE, NLSKBD_OEM_NEC),
};

PKBDTABLES KbdLayerDescriptor(VOID)
{
    return &KbdTables;
}

/***********************************************************************\
* VkToFuncTable_106[]
*
\***********************************************************************/

static ALLOC_SECTION_LDATA VK_F VkToFuncTable_106[] = {
    {
        VK_DBE_ALPHANUMERIC,  // Base Vk
        KBDNLS_TYPE_TOGGLE,   // NLSFEProcType
        KBDNLS_INDEX_NORMAL,  // NLSFEProcCurrent
        0x02, /* 00000010 */  // NLSFEProcSwitch
        {                     // NLSFEProc
            {KBDNLS_ALPHANUM,0},               // Base
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Shift
            {KBDNLS_ALPHANUM,0},               // Control
            {KBDNLS_ALPHANUM,0},               // Shift+Control
            {KBDNLS_ALPHANUM,0},               // Alt
            {KBDNLS_ALPHANUM,0},               // Shift+Alt
            {KBDNLS_CODEINPUT,0},              // Control+Alt
            {KBDNLS_CODEINPUT,0}               // Shift+Control+Alt
        },
        {                     // NLSFEProcAlt
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Base
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Shift
            {KBDNLS_NOEVENT,0},                // Control
            {KBDNLS_NOEVENT,0},                // Shift+Control
            {KBDNLS_NOEVENT,0},                // Alt
            {KBDNLS_NOEVENT,0},                // Shift+Alt
            {KBDNLS_NOEVENT,0},                // Control+Alt
            {KBDNLS_NOEVENT,0}                 // Shift+Control+Alt
        }
    },
    {
        VK_DBE_HIRAGANA,     // Base Vk
        KBDNLS_TYPE_TOGGLE,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x08, /* 00001000 */ // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_HIRAGANA,0},             // Base
            {KBDNLS_KATAKANA,0},             // Shift
            {KBDNLS_HIRAGANA,0},             // Control
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Shift+Control
            {KBDNLS_ROMAN,0},                // Alt
            {KBDNLS_ROMAN,0},                // Shift+Alt
            {KBDNLS_ROMAN,0},                // Control+Alt
            {KBDNLS_NOEVENT,0}               // Shift+Control+Alt
        },
        {                    // NLSFEProcIndexAlt
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Base
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Shift
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Control
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Shift+Control
            {KBDNLS_NOEVENT,0},              // Alt
            {KBDNLS_NOEVENT,0},              // Shift+Alt
            {KBDNLS_NOEVENT,0},              // Control+Alt
            {KBDNLS_NOEVENT,0}               // Shift+Control+Alt
        }
    },
    {
        VK_DBE_SBCSCHAR,     // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SBCSDBCS,0},             // Base
            {KBDNLS_SBCSDBCS,0},             // Shift
            {KBDNLS_SBCSDBCS,0},             // Control
            {KBDNLS_SBCSDBCS,0},             // Shift+Control
            {KBDNLS_SEND_PARAM_VK,VK_KANJI}, // Alt
            {KBDNLS_SBCSDBCS,0},             // Shift+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}, // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}  // Shift+Control+Alt
        },
        {                    // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_NONCONVERT,       // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},         // Base
            {KBDNLS_SEND_BASE_VK,0},         // Shift
            {KBDNLS_SEND_BASE_VK,0},         // Control
            {KBDNLS_SEND_BASE_VK,0},         // Shift+Control
            {KBDNLS_SEND_BASE_VK,0},         // Alt
            {KBDNLS_SEND_BASE_VK,0},         // Shift+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}, // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}  // Shift+Control+Alt
        },
        {                         // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    }
};

#if defined(JAPAN) && defined(_PC98_)
static ALLOC_SECTION_LDATA VK_F VkToFuncTable_NEC[] = {
    {
        VK_NONCONVERT,       // Base Vk  PC98_NFER key
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},                             // Base
            {KBDNLS_SEND_BASE_VK,0},                             // Shift
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ALPHANUMERIC},          // Control
            {KBDNLS_SBCSDBCS,0},                                 // Shift+Control
            {KBDNLS_SEND_PARAM_VK,VK_DBE_KATAKANA},              // Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}, // Shift+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_NOCODEINPUT},           // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_FLUSHSTRING}            // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_KANJI,            // Base Vk  PC98_XFER key
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SEND_PARAM_VK,VK_CONVERT},                // Base
            {KBDNLS_SEND_PARAM_VK,VK_CONVERT},                // Shift
            {KBDNLS_SEND_BASE_VK,0},                          // Control
            {KBDNLS_SEND_PARAM_VK,VK_CONVERT},                // Shift+Control
            {KBDNLS_ROMAN,0},                                 // Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}, // Shift+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_CODEINPUT},          // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_HIRAGANA}            // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_OEM_NEC_EQUAL,    // Base Vk  PC98_"="  key
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},                  // Base
            {KBDNLS_SEND_BASE_VK,0},                  // Shift
            {KBDNLS_SEND_PARAM_VK,VK_SCROLL},         // Control
            {KBDNLS_SEND_BASE_VK,0},                  // Shift+Control
            {KBDNLS_SEND_BASE_VK,0},                  // Alt
            {KBDNLS_SEND_BASE_VK,0},                  // Shift+Alt
            {KBDNLS_SEND_BASE_VK,0},                  // Control+Alt
            {KBDNLS_SEND_BASE_VK,0}                   // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_HOME,             // Base Vk  PC98_HOME  key
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_HOME_OR_CLEAR,0},         // Base
            {KBDNLS_SEND_BASE_VK,0},          // Shift
            {KBDNLS_HOME_OR_CLEAR,0},         // Control
            {KBDNLS_HOME_OR_CLEAR,0},         // Shift+Control
            {KBDNLS_HOME_OR_CLEAR,0},         // Alt
            {KBDNLS_HOME_OR_CLEAR,0},         // Shift+Alt
            {KBDNLS_HOME_OR_CLEAR,0},         // Control+Alt
            {KBDNLS_HOME_OR_CLEAR,0}          // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_END,              // Base Vk  PC98_HELP  key
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_HELP_OR_END,0},         // Base
            {KBDNLS_HELP_OR_END,0},         // Shift
            {KBDNLS_HELP_OR_END,0},         // Control
            {KBDNLS_HELP_OR_END,0},         // Shift+Control
            {KBDNLS_HELP_OR_END,0},         // Alt
            {KBDNLS_HELP_OR_END,0},         // Shift+Alt
            {KBDNLS_HELP_OR_END,0},         // Control+Alt
            {KBDNLS_HELP_OR_END,0}          // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    }
};

USHORT ausMouseVKey98[] = {
                       VK_NUMPAD5,
                       VK_NUMPAD9,
                       VK_NUMPAD3,
                       VK_NUMPAD1,
                       VK_NUMPAD7,
                       VK_NUMPAD4,
                       VK_NUMPAD8,
                       VK_NUMPAD6,
                       VK_NUMPAD2,
                       VK_NUMPAD0,
                       VK_DECIMAL,
                       VK_MULTIPLY,
                       VK_ADD,
                       VK_SUBTRACT,
                       VK_DIVIDE | KBDEXT,
                       VK_HOME | KBDEXT
                      };

#else //_PC98_
#endif // _PC98_
/***********************************************************************\
* KbdNlsTables
*
\***********************************************************************/

static ALLOC_SECTION_LDATA KBDNLSTABLES KbdNlsTables = {
#if defined(JAPAN) && defined(_PC98_)
    0x0d,                            // OEM ID (0x0d = NEC)
    NLSKBD_INFO_ACCESSIBILITY_KEYMAP,// Information
    5,                               // Number of VK_F entry
    VkToFuncTable_NEC,               // Pointer to VK_F array
    16,                              // Number of MouseVk entry
    ausMouseVKey98                   // Pointer to MouseVk array
#else //_PC98_
    0,                      // OEM ID (0 = Microsoft)
    0,                      // Information
    4,                      // Number of VK_F entry
    VkToFuncTable_106,      // Pointer to VK_F array
    0,                      // Number of MouseVk entry
    NULL                    // Pointer to MouseVk array
#endif // _PC98_
};

PKBDNLSTABLES KbdNlsLayerDescriptor(VOID)
{
    return &KbdNlsTables;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\fe_kbds\jpn\kbdnecat\kbdnecat.h ===
#if defined(_PC98_)
/****************************** Module Header ******************************\
* Module Name: kbdnec.h
*
* Copyright (c) 1985-91, Microsoft Corporation
*
* Various defines for use by keyboard input code.
*
* History:
* 27-May-1992 KazuM
\***************************************************************************/
#else
/****************************** Module Header ******************************\
* Module Name: kbd106.h
*
* Copyright (c) 1985-91, Microsoft Corporation
*
* Various defines for use by keyboard input code.
*
* History:
\***************************************************************************/
#endif

/*
 * kbd type should be controlled by cl command-line argument
 */
#if defined(_PC98_)
#define KBD_TYPE 33
#else
#define KBD_TYPE 8
#endif

/*
 * Include the basis of all keyboard table values
 */
#include "kbd.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\fe_kbds\jpn\kbdnecat\sources.inc ===
!IF 0

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


!ENDIF

MINORCOMP=kbdnecat

!include ..\..\japan.inc

SOURCES_USED=..\sources.inc

C_DEFINES=$(C_DEFINES) -D_PC98_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\fe_kbds\jpn\lk411a\kbdlk41a.h ===
/****************************** Module Header ******************************\
* Module Name: kbdlk41a.h
*
* History:
\***************************************************************************/

#define KBD_TYPE 41

/*
 * Include the basis of all keyboard table values
 */
#include "kbd.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\fe_kbds\jpn\kbdnecat\kbdnecat.c ===
#if defined(_PC98_)
/***************************************************************************\
* Module Name: kbdnec.c
*
* Copyright (c) 1985-92, NEC Corporation
*
* History:
\***************************************************************************/
#else // defined(_PC98_)
/***************************************************************************\
* Module Name: kbd106.c
*
* Copyright (c) 1985-92, Microsoft Corporation
*
* History:
\***************************************************************************/
#endif // defined(_PC98_)

#include <windows.h>
#include <ime.h>
#include "vkoem.h"
#include "kbdjpn.h"
#if defined(_PC98_)
#include "kbdnecAT.h"
#else // defined(_PC98_)
#include "kbd106.h"
#endif // defined(_PC98_)

#if defined(_M_IA64)
#pragma section(".data")
#define ALLOC_SECTION_LDATA __declspec(allocate(".data"))
#else
#pragma data_seg(".data")
#define ALLOC_SECTION_LDATA
#endif

#if defined(_PC98_)
/***************************************************************************\
* ausVK[] - Virtual Scan Code to Virtual Key conversion table for NEC 106
\***************************************************************************/
#else // defined(_PC98_)
/***************************************************************************\
* ausVK[] - Virtual Scan Code to Virtual Key conversion table for 106
\***************************************************************************/
#endif // defined(_PC98_)

static ALLOC_SECTION_LDATA USHORT ausVK[] = {
    T00, T01, T02, T03, T04, T05, T06, T07,
    T08, T09, T0A, T0B, T0C, T0D, T0E, T0F,
    T10, T11, T12, T13, T14, T15, T16, T17,
    T18, T19, T1A, T1B, T1C, T1D, T1E, T1F,
    T20, T21, T22, T23, T24, T25, T26, T27,
    T28,

    /*
     * Hankaku/Zenkaku/Kanji key must have KBDSPECIAL bit set (NLS key)
     */
    T29 | KBDSPECIAL,

              T2A, T2B, T2C, T2D, T2E, T2F,
    T30, T31, T32, T33, T34, T35,

    /*
     * Right-hand Shift key must have KBDEXT bit set.
     */
    T36 | KBDEXT,

#if defined(_PC98_)
    T37,
#else // defined(_PC98_)
    /*
     * numpad_* + Shift/Alt -> SnapShot
     */
    T37 | KBDMULTIVK,
#endif // defined(_PC98_)

    T38, T39,

#if defined(_PC98_)
    T3A,
#else // defined(_PC98_)
    /*
     * Alphanumeric/CapsLock key must have KBDSPECIAL bit set (NLS key)
     */
    T3A | KBDSPECIAL,
#endif // defined(_PC98_)

                   T3B, T3C, T3D, T3E, T3F,
    T40, T41, T42, T43, T44,

    /*
     * NumLock Key:
     *     KBDEXT     - VK_NUMLOCK is an Extended key
     *     KBDMULTIVK - VK_NUMLOCK or VK_PAUSE (without or with CTRL)
     */
    T45 | KBDEXT | KBDMULTIVK,

#if defined(_PC98_)
    T46,
#else // defined(_PC98_)
    T46 | KBDMULTIVK,
#endif // defined(_PC98_)

    /*
     * Number Pad keys:
     *     KBDNUMPAD  - digits 0-9 and decimal point.
     *     KBDSPECIAL - require special processing by Windows
     */
    T47 | KBDNUMPAD | KBDSPECIAL,   // Numpad 7 (Home)
    T48 | KBDNUMPAD | KBDSPECIAL,   // Numpad 8 (Up),
    T49 | KBDNUMPAD | KBDSPECIAL,   // Numpad 9 (PgUp),
    T4A,
    T4B | KBDNUMPAD | KBDSPECIAL,   // Numpad 4 (Left),
    T4C | KBDNUMPAD | KBDSPECIAL,   // Numpad 5 (Clear),
    T4D | KBDNUMPAD | KBDSPECIAL,   // Numpad 6 (Right),
    T4E,
    T4F | KBDNUMPAD | KBDSPECIAL,   // Numpad 1 (End),
    T50 | KBDNUMPAD | KBDSPECIAL,   // Numpad 2 (Down),
    T51 | KBDNUMPAD | KBDSPECIAL,   // Numpad 3 (PgDn),
    T52 | KBDNUMPAD | KBDSPECIAL,   // Numpad 0 (Ins),
    T53 | KBDNUMPAD | KBDSPECIAL,   // Numpad . (Del),

#if defined(_PC98_)
    T54, T55, T56, T57, T58,
    T59 | KBDSPECIAL,               // TenKey EQU (VK_SCROLL)
                                  T5A, T5B,
#else // defined(_PC98_)
    T54, T55, T56, T57, T58, T59, T5A, T5B,
#endif // defined(_PC98_)

    T5C, T5D, T5E, T5F, T60, T61, T62, T63,
    T64, T65, T66, T67, T68, T69, T6A, T6B,
    T6C, T6D, T6E, T6F,

    /*
     * Hiragana/Katakana/Roman key must have KBDSPECIAL bit set (NLS key)
     */
#if defined(_PC98_)
    T70,
#else // defined(_PC98_)
    T70 | KBDSPECIAL,
#endif // defined(_PC98_)

                             T71, T72, T73,
    T74, T75, T76, T77, T78,

    /*
     * Conversion key must have KBDSPECIAL bit set (NLS key)
     */
    T79 | KBDSPECIAL,

                                  T7A,

    /*
     * Non-Conversion key must have KBDSPECIAL bit set (NLS key)
     */
    T7B | KBDSPECIAL,

    T7C, T7D, T7E, T7F
};

static ALLOC_SECTION_LDATA VSC_VK aE0VscToVk[] = {
        { 0x1C, X1C | KBDEXT              },  // Numpad Enter
        { 0x1D, X1D | KBDEXT              },  // RControl
        { 0x35, X35 | KBDEXT              },  // Numpad Divide
        { 0x37, X37 | KBDEXT              },  // Snapshot
        { 0x38, X38 | KBDEXT              },  // RMenu
        { 0x46, X46 | KBDEXT              },  // Break (Ctrl + Pause)
#if defined(_PC98_)
        { 0x47, X47 | KBDEXT | KBDSPECIAL },  // CLR HOME
#else // defined(_PC98_)
        { 0x47, X47 | KBDEXT              },  // Home
#endif // defined(_PC98_)
        { 0x48, X48 | KBDEXT              },  // Up
        { 0x49, X49 | KBDEXT              },  // Prior
        { 0x4B, X4B | KBDEXT              },  // Left
        { 0x4D, X4D | KBDEXT              },  // Right
#if defined(_PC98_)
        { 0x4F, X4F | KBDEXT | KBDSPECIAL },  // HELP
#else // defined(_PC98_)
        { 0x4F, X4F | KBDEXT              },  // End
#endif // defined(_PC98_)
        { 0x50, X50 | KBDEXT              },  // Down
        { 0x51, X51 | KBDEXT              },  // Next
        { 0x52, X52 | KBDEXT              },  // Insert
        { 0x53, X53 | KBDEXT              },  // Delete
        { 0x5B, X5B | KBDEXT              },  // Left Win
        { 0x5C, X5C | KBDEXT              },  // Right Win
        { 0x5D, X5D | KBDEXT              },  // Application
        { 0,      0                       }
};

static ALLOC_SECTION_LDATA VSC_VK aE1VscToVk[] = {
        { 0x1D, Y1D                       },  // Pause
        { 0   ,   0                       }
};

/***************************************************************************\
* aVkToBits[]  - map Virtual Keys to Modifier Bits
*
* See kbd.h for a full description.
*
* US Keyboard has only three shifter keys:
*     SHIFT (L & R) affects alphabnumeric keys,
*     CTRL  (L & R) is used to generate control characters
*     ALT   (L & R) used for generating characters by number with numpad
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_BIT aVkToBits[] = {
    { VK_SHIFT,   KBDSHIFT },
    { VK_CONTROL, KBDCTRL  },
    { VK_MENU,    KBDALT   },
    { VK_KANA,    KBDKANA  },
    { 0,          0        }
};

/***************************************************************************\
* aModification[]  - map character modifier bits to modification number
*
* See kbd.h for a full description.
*
\***************************************************************************/

static ALLOC_SECTION_LDATA MODIFIERS CharModifiers = {
    &aVkToBits[0],
    11,
    {
    //  Modification# //  Keys Pressed  : Explanation
    //  ============= // ============== : =============================
        0,            //                : unshifted characters
        1,            //          SHIFT : capitals, ~!@#$%^&*()_+{}:"<>? etc.
        4,            //     CTRL       : control characters
        6,            //     CTRL SHIFT :
        SHFT_INVALID, // ALT            : invalid
        SHFT_INVALID, // ALT      SHIFT : invalid
        SHFT_INVALID, // ALT CTRL       : invalid
        SHFT_INVALID, // ALT CTRL SHIFT : invalid
        2,            //KANA
        3,            //KANA      SHIFT
        5,            //KANA CTRL
        7             //KANA CTRL SHIFT
    }
};

/***************************************************************************\
*
* aVkToWch2[]  - Virtual Key to WCHAR translation for 2 shift states
* aVkToWch3[]  - Virtual Key to WCHAR translation for 3 shift states
* aVkToWch4[]  - Virtual Key to WCHAR translation for 4 shift states
*
* Table attributes: Unordered Scan, null-terminated
*
* Search this table for an entry with a matching Virtual Key to find the
* corresponding unshifted and shifted WCHAR characters.
*
* Reserved VirtualKey values (first column)
*     -1            - this line contains dead characters (diacritic)
*     0             - terminator
*
* Reserved Attribute values (second column)
*     CAPLOK        - CapsLock affects this key like Shift
*     KANALOK       - The KANA-LOCK key affects this key like KANA
*
* Reserved character values (third through last column)
*     WCH_NONE      - No character
*     WCH_DEAD      - Dead character (diacritic) value is in next line
*
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch4[] = {
    //                               |          |   SHIFT  |  KANA  | K+SHFT |
    //                               |          |==========|========|========|
#if defined(_PC98_)
    {'0'          ,          KANALOK ,'0'       ,'0'       ,WCH_WA  ,WCH_WO  },
#else // defined(_PC98_)
    {'0'          ,          KANALOK ,'0'       ,WCH_NONE  ,WCH_WA  ,WCH_WO  },
#endif // defined(_PC98_)
    {'1'          ,          KANALOK ,'1'       ,'!'       ,WCH_NU  ,WCH_NU  },
    {'3'          ,          KANALOK ,'3'       ,'#'       ,WCH_A   ,WCH_AA  },
    {'4'          ,          KANALOK ,'4'       ,'$'       ,WCH_U   ,WCH_UU  },
    {'5'          ,          KANALOK ,'5'       ,'%'       ,WCH_E   ,WCH_EE  },
    {'7'          ,          KANALOK ,'7'       ,0x27      ,WCH_YA  ,WCH_YAA },
    {'8'          ,          KANALOK ,'8'       ,'('       ,WCH_YU  ,WCH_YUU },
    {'9'          ,          KANALOK ,'9'       ,')'       ,WCH_YO  ,WCH_YOO },
    {'A'          , CAPLOK | KANALOK ,'a'       ,'A'       ,WCH_TI  ,WCH_TI  },
    {'B'          , CAPLOK | KANALOK ,'b'       ,'B'       ,WCH_KO  ,WCH_KO  },
    {'C'          , CAPLOK | KANALOK ,'c'       ,'C'       ,WCH_SO  ,WCH_SO  },
    {'D'          , CAPLOK | KANALOK ,'d'       ,'D'       ,WCH_SI  ,WCH_SI  },
    {'E'          , CAPLOK | KANALOK ,'e'       ,'E'       ,WCH_I   ,WCH_II  },
    {'F'          , CAPLOK | KANALOK ,'f'       ,'F'       ,WCH_HA  ,WCH_HA  },
    {'G'          , CAPLOK | KANALOK ,'g'       ,'G'       ,WCH_KI  ,WCH_KI  },
    {'H'          , CAPLOK | KANALOK ,'h'       ,'H'       ,WCH_KU  ,WCH_KU  },
    {'I'          , CAPLOK | KANALOK ,'i'       ,'I'       ,WCH_NI  ,WCH_NI  },
    {'J'          , CAPLOK | KANALOK ,'j'       ,'J'       ,WCH_MA  ,WCH_MA  },
    {'K'          , CAPLOK | KANALOK ,'k'       ,'K'       ,WCH_NO  ,WCH_NO  },
    {'L'          , CAPLOK | KANALOK ,'l'       ,'L'       ,WCH_RI  ,WCH_RI  },
    {'M'          , CAPLOK | KANALOK ,'m'       ,'M'       ,WCH_MO  ,WCH_MO  },
    {'N'          , CAPLOK | KANALOK ,'n'       ,'N'       ,WCH_MI  ,WCH_MI  },
    {'O'          , CAPLOK | KANALOK ,'o'       ,'O'       ,WCH_RA  ,WCH_RA  },
    {'P'          , CAPLOK | KANALOK ,'p'       ,'P'       ,WCH_SE  ,WCH_SE  },
    {'Q'          , CAPLOK | KANALOK ,'q'       ,'Q'       ,WCH_TA  ,WCH_TA  },
    {'R'          , CAPLOK | KANALOK ,'r'       ,'R'       ,WCH_SU  ,WCH_SU  },
    {'S'          , CAPLOK | KANALOK ,'s'       ,'S'       ,WCH_TO  ,WCH_TO  },
    {'T'          , CAPLOK | KANALOK ,'t'       ,'T'       ,WCH_KA  ,WCH_KA  },
    {'U'          , CAPLOK | KANALOK ,'u'       ,'U'       ,WCH_NA  ,WCH_NA  },
    {'V'          , CAPLOK | KANALOK ,'v'       ,'V'       ,WCH_HI  ,WCH_HI  },
    {'W'          , CAPLOK | KANALOK ,'w'       ,'W'       ,WCH_TE  ,WCH_TE  },
    {'X'          , CAPLOK | KANALOK ,'x'       ,'X'       ,WCH_SA  ,WCH_SA  },
    {'Y'          , CAPLOK | KANALOK ,'y'       ,'Y'       ,WCH_NN  ,WCH_NN  },
    {'Z'          , CAPLOK | KANALOK ,'z'       ,'Z'       ,WCH_TU  ,WCH_TUU },
    {VK_OEM_1     ,          KANALOK ,':'       ,'*'       ,WCH_KE  ,WCH_KE  },
    {VK_OEM_2     ,          KANALOK ,'/'       ,'?'       ,WCH_ME  ,WCH_MD  },
#if defined(_PC98_)
#else // defined(_PC98_)
    {VK_OEM_3     ,          KANALOK ,'@'       ,'`'       ,WCH_VS  ,WCH_VS  },
    {VK_OEM_7     ,          KANALOK ,'^'       ,'~'       ,WCH_HE  ,WCH_HE  },
    {VK_OEM_8     , 0                ,WCH_NONE  ,WCH_NONE  ,WCH_NONE,WCH_NONE},
#endif // defined(_PC98_)
    {VK_OEM_COMMA ,          KANALOK ,','       ,'<'       ,WCH_NE  ,WCH_IC  },
    {VK_OEM_PERIOD,          KANALOK ,'.'       ,'>'       ,WCH_RU  ,WCH_IP  },
    {VK_OEM_PLUS  ,          KANALOK ,';'       ,'+'       ,WCH_RE  ,WCH_RE  },
    {VK_TAB       , 0                ,'\t'      ,'\t'      ,'\t'    ,'\t'    },
    {VK_ADD       , 0                ,'+'       ,'+'       ,'+'     ,'+'     },
    {VK_DECIMAL   , 0                ,'.'       ,'.'       ,'.'     ,'.'     },
    {VK_DIVIDE    , 0                ,'/'       ,'/'       ,'/'     ,'/'     },
    {VK_MULTIPLY  , 0                ,'*'       ,'*'       ,'*'     ,'*'     },
    {VK_SUBTRACT  , 0                ,'-'       ,'-'       ,'-'     ,'-'     },
#if defined(_PC98_)
    {VK_SEPARATOR , 0                ,','       ,','       ,','     ,','     },
    {VK_OEM_NEC_EQUAL,    0          ,'='       ,'='       ,'='     ,'='     },
#endif // defined(_PC98_)
    {0            , 0                ,0         ,0         ,0       ,0       }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS6 aVkToWch6[] = {
    //                      |          |   SHIFT  |  KANA  | K+SHFT |  CONTROL  |  K+CTRL   |
    //                      |          |==========|========|========|===========|===========|
    {VK_BACK      , 0       ,'\b'      ,'\b'      ,'\b'    ,'\b'    , 0x7f      , 0x7f      },
    {VK_CANCEL    , 0       ,0x03      ,0x03      ,0x03    ,0x03    , 0x03      , 0x03      },
    {VK_ESCAPE    , 0       ,0x1b      ,0x1b      ,0x1b    ,0x1b    , 0x1b      , 0x1b      },
#if defined(_PC98_)
    {VK_OEM_3     , KANALOK ,'@'       ,'~'       ,WCH_VS  ,WCH_VS  , 0x00      , 0x00      },
    {VK_OEM_4     , KANALOK ,'['       ,'{'       ,WCH_SVS ,WCH_OB  , 0x1b      , 0x1b      },
    {VK_OEM_5     , KANALOK ,'\\'      ,'|'       ,WCH_PS  ,WCH_PS  , 0x1c      , 0x1c      },
    {VK_OEM_6     , KANALOK ,']'       ,'}'       ,WCH_MU  ,WCH_CB  , 0x1d      , 0x1d      },
    {VK_OEM_7     , KANALOK ,'^'       ,'`'       ,WCH_HE  ,WCH_HE  , 0x1e      , 0x1e      },
    {VK_OEM_8     , KANALOK ,WCH_NONE  ,'_'       ,WCH_RO  ,WCH_RO  , 0x1f      , 0x1f      },
#else // defined(_PC98_)
    {VK_OEM_4     , KANALOK ,'['       ,'{'       ,WCH_SVS ,WCH_OB  , 0x1b      , 0x1b      },
    {VK_OEM_5     , KANALOK ,'\\'      ,'|'       ,WCH_PS  ,WCH_PS  , 0x1c      , 0x1c      },
    {VK_OEM_102   , KANALOK ,'\\'      ,'_'       ,WCH_RO  ,WCH_RO  , 0x1c      , 0x1c      },
    {VK_OEM_6     , KANALOK ,']'       ,'}'       ,WCH_MU  ,WCH_CB  , 0x1d      , 0x1d      },
#endif // defined(_PC98_)
    {VK_RETURN    , 0       ,'\r'      ,'\r'      ,'\r'    ,'\r'    , '\n'      , '\n'      },
    {VK_SPACE     , 0       ,' '       ,' '       ,' '     ,' '     , 0x20      , 0x20      },
    {0            , 0       ,0         ,0         ,0       ,0       , 0         , 0         }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS8 aVkToWch8[] = {
    //                      |          |   SHIFT  |  KANA  | K+SHFT |  CONTROL  |  K+CTRL   | SHFT+CTRL |K+SHFT+CTRL|
    //                      |          |==========|========|========|===========|===========|===========|===========|
    {'2'          , KANALOK ,'2'       ,'"'       ,WCH_HU  ,WCH_HU  , WCH_NONE  , WCH_NONE  , 0x00      , 0x00      },
    {'6'          , KANALOK ,'6'       ,'&'       ,WCH_O   ,WCH_OO  , WCH_NONE  , WCH_NONE  , 0x1e      , 0x1e      },
    {VK_OEM_MINUS , KANALOK ,'-'       ,'='       ,WCH_HO  ,WCH_HO  , WCH_NONE  , WCH_NONE  , 0x1f      , 0x1f      },
    {0            , 0       ,0         ,0         ,0       ,0       , 0         , 0         , 0         , 0         }
};

// Put this last so that VkKeyScan interprets number characters
// as coming from the main section of the kbd (aVkToWch2 and
// aVkToWch4) before considering the numpad (aVkToWch1).

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch1[] = {
    //                     |          |   SHIFT  |  KANA  | K+SHFT |
    //                     |          |==========|========|========|
    { VK_NUMPAD0   , 0      ,  '0'    , WCH_NONE ,   '0'  ,WCH_NONE},
    { VK_NUMPAD1   , 0      ,  '1'    , WCH_NONE ,   '1'  ,WCH_NONE},
    { VK_NUMPAD2   , 0      ,  '2'    , WCH_NONE ,   '2'  ,WCH_NONE},
    { VK_NUMPAD3   , 0      ,  '3'    , WCH_NONE ,   '3'  ,WCH_NONE},
    { VK_NUMPAD4   , 0      ,  '4'    , WCH_NONE ,   '4'  ,WCH_NONE},
    { VK_NUMPAD5   , 0      ,  '5'    , WCH_NONE ,   '5'  ,WCH_NONE},
    { VK_NUMPAD6   , 0      ,  '6'    , WCH_NONE ,   '6'  ,WCH_NONE},
    { VK_NUMPAD7   , 0      ,  '7'    , WCH_NONE ,   '7'  ,WCH_NONE},
    { VK_NUMPAD8   , 0      ,  '8'    , WCH_NONE ,   '8'  ,WCH_NONE},
    { VK_NUMPAD9   , 0      ,  '9'    , WCH_NONE ,   '9'  ,WCH_NONE},
    { 0            , 0      ,  '\0'   , 0        ,   0    ,0       }   //null terminator
};

/***************************************************************************\
* aVkToWcharTable: table of pointers to Character Tables
*
* Describes the character tables and the order they should be searched.
*
* Note: the order determines the behavior of VkKeyScan() : this function
*       takes a character and attempts to find a Virtual Key and character-
*       modifier key combination that produces that character.  The table
*       containing the numeric keypad (aVkToWch1) must appear last so that
*       VkKeyScan('0') will be interpreted as one of keys from the main
*       section, not the numpad.  etc.
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHAR_TABLE aVkToWcharTable[] = {
    {  (PVK_TO_WCHARS1)aVkToWch6, 6, sizeof(aVkToWch6[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch8, 8, sizeof(aVkToWch8[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch4, 4, sizeof(aVkToWch4[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch1, 4, sizeof(aVkToWch1[0]) },  // must come last
    {                       NULL, 0, 0                    }
};

/***************************************************************************\
* aKeyNames[], aKeyNamesExt[]  - Scan Code -> Key Name tables
*
* For the GetKeyNameText() API function
*
* Tables for non-extended and extended (KBDEXT) keys.
* (Keys producing printable characters are named by the character itself)
\***************************************************************************/

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNames[] = {
#if defined(_PC98_)
    0x01,    L"ESC",            // Esc
    0x0e,    L"BS",             // Backspace
    0x0f,    L"TAB",            // Tab
    0x1c,    L"RETURN",         // Enter
    0x1d,    L"CTRL",           // Ctrl
    0x29,    (LPWSTR)SZ_KEY_NAME_HANKAKU_ZENKAKU,  // NLS Key
    0x2a,    L"SHIFT",          // Shift
    0x36,    L"SHIFT",          // Rgiht Shift
#else // defined(_PC98_)
    0x01,    L"Esc",
    0x0e,    L"Backspace",
    0x0f,    L"Tab",
    0x1c,    L"Enter",
    0x1d,    L"Ctrl",
    0x29,    (LPWSTR)SZ_KEY_NAME_HANKAKU_ZENKAKU,  // NLS Key
    0x2a,    L"Shift",
    0x36,    L"Right Shift",
#endif // defined(_PC98_)
    0x37,    L"Num *",
#if defined(_PC98_)
    0x38,    L"GRPH",                   // Alt
    0x39,    L"SPACE",                  // Space
    0x3a,    L"CAPS",                   // Caps Lock
    0x3b,    (LPWSTR)SZ_KEY_NAME_F1,    // F1
    0x3c,    (LPWSTR)SZ_KEY_NAME_F2,    // F2
    0x3d,    (LPWSTR)SZ_KEY_NAME_F3,    // F3
    0x3e,    (LPWSTR)SZ_KEY_NAME_F4,    // F4
    0x3f,    (LPWSTR)SZ_KEY_NAME_F5,    // F5
    0x40,    (LPWSTR)SZ_KEY_NAME_F6,    // F6
    0x41,    (LPWSTR)SZ_KEY_NAME_F7,    // F7
    0x42,    (LPWSTR)SZ_KEY_NAME_F8,    // F8
    0x43,    (LPWSTR)SZ_KEY_NAME_F9,    // F9
    0x44,    (LPWSTR)SZ_KEY_NAME_F10,   // F10
#else // defined(_PC98_)
    0x38,    L"Alt",
    0x39,    L"Space",
    0x3a,    L"Caps Lock",
    0x3b,    L"F1",
    0x3c,    L"F2",
    0x3d,    L"F3",
    0x3e,    L"F4",
    0x3f,    L"F5",
    0x40,    L"F6",
    0x41,    L"F7",
    0x42,    L"F8",
    0x43,    L"F9",
    0x44,    L"F10",
#endif // defined(_PC98_)
    0x45,    L"Pause",
    0x46,    L"Scroll Lock",
    0x47,    L"Num 7",
    0x48,    L"Num 8",
    0x49,    L"Num 9",
    0x4a,    L"Num -",
    0x4b,    L"Num 4",
    0x4c,    L"Num 5",
    0x4d,    L"Num 6",
    0x4e,    L"Num +",
    0x4f,    L"Num 1",
    0x50,    L"Num 2",
    0x51,    L"Num 3",
    0x52,    L"Num 0",
#if defined(_PC98_)
    0x53,    L"Num .",
#else // defined(_PC98_)
    0x53,    L"Num Del",
#endif // defined(_PC98_)
    0x54,    L"Sys Req",
#if defined(_PC98_)
//    0x55,    L"",
    0x57,    (LPWSTR)SZ_KEY_NAME_F11,     // vf1
    0x58,    (LPWSTR)SZ_KEY_NAME_F12,     // vf2
    0x59,    L"Num =",
//    0x5B,    L"Convert",                  // not use
    0x5C,    L"Num ,",
    0x5D,    (LPWSTR)SZ_KEY_NAME_F13,     // vf3
    0x5E,    (LPWSTR)SZ_KEY_NAME_F14,     // vf4
    0x5F,    (LPWSTR)SZ_KEY_NAME_F15,     // vf5
    0x70,    (LPWSTR)SZ_KEY_NAME_KANA,    // NLS Key Katakana
    0x79,    L"XFER",                     // NLS Key SZ_KEY_NAME_HIRAGANA
    0x7b,    L"NFER",                     //
#else // defined(_PC98_)
    0x57,    L"F11",
    0x58,    L"F12",
    0x70,    (LPWSTR)SZ_KEY_NAME_HIRAGANA,
    0x79,    (LPWSTR)SZ_KEY_NAME_HENKAN,
    0x7b,    (LPWSTR)SZ_KEY_NAME_MUHENKAN,
    0x7C,    L"F13",
#endif // defined(_PC98_)
    0   ,    NULL
};

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNamesExt[] = {
#if defined(_PC98_)
    0x1c,    L"Num Enter",
    0x35,    L"Num /",
    0x37,    L"COPY",                   // Prnt Scr
    0x45,    L"Num Lock",
    0x46,    L"STOP",                   // Break
    0x47,    L"CLR",                    // Home
    0x48,    L"UP",                     // Up
    0x49,    L"ROLL DOWN",              // Page Up
    0x4b,    L"LEFT",                   // Left
    0x4d,    L"RIGHT",                  // Right
    0x4f,    L"HELP",                   // End
    0x50,    L"DOWN",                   // Down
    0x51,    L"ROLL UP",                // Page Down
    0x52,    L"INS",                    // Insert
    0x53,    L"DEL",                    // Delete
    0x54,    L"<00>",
    0x56,    L"HELP",                   // Help
//  0x5C,    L"CLR",                    // Clear
#else // defined(_PC98_)
    0x1c,    L"Num Enter",
    0x1d,    L"Right Control",
    0x35,    L"Num /",
    0x37,    L"Prnt Scrn",
    0x38,    L"Right Alt",
    0x45,    L"Num Lock",
    0x46,    L"Break",
    0x47,    L"Home",
    0x48,    L"Up",
    0x49,    L"Page Up",
    0x4b,    L"Left",
    0x4d,    L"Right",
    0x4f,    L"End",
    0x50,    L"Down",
    0x51,    L"Page Down",
    0x52,    L"Insert",
    0x53,    L"Delete",
#endif // defined(_PC98_)
    0x5B,    L"Left Windows",
    0x5C,    L"Right Windows",
    0x5D,    L"Application",
    0   ,    NULL
};

static ALLOC_SECTION_LDATA KBDTABLES KbdTables = {
    /*
     * Modifier keys
     */
    &CharModifiers,

    /*
     * Characters tables
     */
    aVkToWcharTable,

    /*
     * Diacritics  (none for US English)
     */
    NULL,

    /*
     * Names of Keys  (no dead keys)
     */
    aKeyNames,
    aKeyNamesExt,
    NULL,

    /*
     * Scan codes to Virtual Keys
     */
    ausVK,
    sizeof(ausVK) / sizeof(ausVK[0]),
    aE0VscToVk,
    aE1VscToVk,

    /*
     * No Locale-specific special processing
     */
    0,

    /*
     * No Ligatures
     */
    0, 0, NULL,

    /*
     * Type and subtype.
     */
    KEYBOARD_TYPE_JAPAN,    // Japanese Keyboard Layout
    MAKEWORD(NEC_KBD_N_MODE_TYPE, NLSKBD_OEM_NEC),
};

PKBDTABLES KbdLayerDescriptor(VOID)
{
    return &KbdTables;
}

/***********************************************************************\
* VkToFuncTable_106[]
*
\***********************************************************************/

static ALLOC_SECTION_LDATA VK_F VkToFuncTable_106[] = {
    {
        VK_DBE_ALPHANUMERIC,  // Base Vk
        KBDNLS_TYPE_TOGGLE,   // NLSFEProcType
        KBDNLS_INDEX_NORMAL,  // NLSFEProcCurrent
        0x02, /* 00000010 */  // NLSFEProcSwitch
        {                     // NLSFEProc
            {KBDNLS_ALPHANUM,0},               // Base
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Shift
            {KBDNLS_ALPHANUM,0},               // Control
            {KBDNLS_ALPHANUM,0},               // Shift+Control
            {KBDNLS_ALPHANUM,0},               // Alt
            {KBDNLS_ALPHANUM,0},               // Shift+Alt
            {KBDNLS_CODEINPUT,0},              // Control+Alt
            {KBDNLS_CODEINPUT,0}               // Shift+Control+Alt
        },
        {                     // NLSFEProcAlt
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Base
            {KBDNLS_SEND_PARAM_VK,VK_CAPITAL}, // Shift
            {KBDNLS_NOEVENT,0},                // Control
            {KBDNLS_NOEVENT,0},                // Shift+Control
            {KBDNLS_NOEVENT,0},                // Alt
            {KBDNLS_NOEVENT,0},                // Shift+Alt
            {KBDNLS_NOEVENT,0},                // Control+Alt
            {KBDNLS_NOEVENT,0}                 // Shift+Control+Alt
        }
    },
    {
        VK_DBE_HIRAGANA,     // Base Vk
        KBDNLS_TYPE_TOGGLE,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x08, /* 00001000 */ // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_HIRAGANA,0},             // Base
            {KBDNLS_KATAKANA,0},             // Shift
            {KBDNLS_HIRAGANA,0},             // Control
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Shift+Control
            {KBDNLS_ROMAN,0},                // Alt
            {KBDNLS_ROMAN,0},                // Shift+Alt
            {KBDNLS_ROMAN,0},                // Control+Alt
            {KBDNLS_NOEVENT,0}               // Shift+Control+Alt
        },
        {                    // NLSFEProcIndexAlt
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Base
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Shift
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Control
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Shift+Control
            {KBDNLS_NOEVENT,0},              // Alt
            {KBDNLS_NOEVENT,0},              // Shift+Alt
            {KBDNLS_NOEVENT,0},              // Control+Alt
            {KBDNLS_NOEVENT,0}               // Shift+Control+Alt
        }
    },
    {
        VK_DBE_SBCSCHAR,     // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SBCSDBCS,0},             // Base
            {KBDNLS_SBCSDBCS,0},             // Shift
            {KBDNLS_SBCSDBCS,0},             // Control
            {KBDNLS_SBCSDBCS,0},             // Shift+Control
            {KBDNLS_SEND_PARAM_VK,VK_KANJI}, // Alt
            {KBDNLS_SBCSDBCS,0},             // Shift+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}, // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}  // Shift+Control+Alt
        },
        {                    // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_NONCONVERT,       // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},         // Base
            {KBDNLS_SEND_BASE_VK,0},         // Shift
            {KBDNLS_SEND_BASE_VK,0},         // Control
            {KBDNLS_SEND_BASE_VK,0},         // Shift+Control
            {KBDNLS_SEND_BASE_VK,0},         // Alt
            {KBDNLS_SEND_BASE_VK,0},         // Shift+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}, // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}  // Shift+Control+Alt
        },
        {                         // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    }
};

#if defined(_PC98_)
static ALLOC_SECTION_LDATA VK_F VkToFuncTable_NEC[] = {
    {
        VK_DBE_SBCSCHAR,     // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SBCSDBCS,0},             // Base
            {KBDNLS_SBCSDBCS,0},             // Shift
            {KBDNLS_SBCSDBCS,0},             // Control
            {KBDNLS_SBCSDBCS,0},             // Shift+Control
            {KBDNLS_SBCSDBCS,0},             // Alt
//            {KBDNLS_SEND_PARAM_VK,VK_KANJI}, // Alt
            {KBDNLS_SBCSDBCS,0},             // Shift+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}, // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}  // Shift+Control+Alt
        },
        {                    // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_NONCONVERT,       // Base Vk  PC98_NFER key
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},                             // Base
            {KBDNLS_SEND_BASE_VK,0},                             // Shift
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ALPHANUMERIC},          // Control
            {KBDNLS_SBCSDBCS,0},                                 // Shift+Control
            {KBDNLS_SEND_PARAM_VK,VK_DBE_KATAKANA},              // Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}, // Shift+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_NOCODEINPUT},           // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_FLUSHSTRING}            // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_CONVERT,            // Base Vk  PC98_XFER key
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},                          // Base
            {KBDNLS_SEND_BASE_VK,0},                          // Shift
            {KBDNLS_SEND_PARAM_VK,VK_KANJI},                  // Control
            {KBDNLS_SEND_BASE_VK,0},                          // Shift+Control
            {KBDNLS_ROMAN,0},                                 // Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}, // Shift+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_CODEINPUT},          // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_HIRAGANA}            // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_OEM_NEC_EQUAL,    // Base Vk NEC98_"="  key
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},                  // Base
            {KBDNLS_SEND_BASE_VK,0},                  // Shift
            {KBDNLS_SEND_PARAM_VK,VK_SCROLL},         // Control
            {KBDNLS_SEND_BASE_VK,0},                  // Shift+Control
            {KBDNLS_SEND_BASE_VK,0},                  // Alt
            {KBDNLS_SEND_BASE_VK,0},                  // Shift+Alt
            {KBDNLS_SEND_BASE_VK,0},                  // Control+Alt
            {KBDNLS_SEND_BASE_VK,0}                   // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_HOME,             // Base Vk  PC98_HOME  key
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_HOME_OR_CLEAR,0},         // Base
            {KBDNLS_SEND_BASE_VK,0},          // Shift
            {KBDNLS_HOME_OR_CLEAR,0},         // Control
            {KBDNLS_HOME_OR_CLEAR,0},         // Shift+Control
            {KBDNLS_HOME_OR_CLEAR,0},         // Alt
            {KBDNLS_HOME_OR_CLEAR,0},         // Shift+Alt
            {KBDNLS_HOME_OR_CLEAR,0},         // Control+Alt
            {KBDNLS_HOME_OR_CLEAR,0}          // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_END,              // Base Vk  PC98_HELP  key
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_HELP_OR_END,0},         // Base
            {KBDNLS_HELP_OR_END,0},         // Shift
            {KBDNLS_HELP_OR_END,0},         // Control
            {KBDNLS_HELP_OR_END,0},         // Shift+Control
            {KBDNLS_HELP_OR_END,0},         // Alt
            {KBDNLS_HELP_OR_END,0},         // Shift+Alt
            {KBDNLS_HELP_OR_END,0},         // Control+Alt
            {KBDNLS_HELP_OR_END,0}          // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_NUMPAD0,          // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_NUMPAD,0},         // Base
            {KBDNLS_NUMPAD,0},         // Shift
            {KBDNLS_NUMPAD,0},         // Control
            {KBDNLS_NUMPAD,0},         // Shift+Control
            {KBDNLS_NUMPAD,0},         // Alt
            {KBDNLS_NUMPAD,0},         // Shift+Alt
            {KBDNLS_NUMPAD,0},         // Control+Alt
            {KBDNLS_NUMPAD,0}          // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_NUMPAD1,          // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_NUMPAD,0},         // Base
            {KBDNLS_NUMPAD,0},         // Shift
            {KBDNLS_NUMPAD,0},         // Control
            {KBDNLS_NUMPAD,0},         // Shift+Control
            {KBDNLS_NUMPAD,0},         // Alt
            {KBDNLS_NUMPAD,0},         // Shift+Alt
            {KBDNLS_NUMPAD,0},         // Control+Alt
            {KBDNLS_NUMPAD,0}          // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_NUMPAD2,          // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_NUMPAD,0},         // Base
            {KBDNLS_NUMPAD,0},         // Shift
            {KBDNLS_NUMPAD,0},         // Control
            {KBDNLS_NUMPAD,0},         // Shift+Control
            {KBDNLS_NUMPAD,0},         // Alt
            {KBDNLS_NUMPAD,0},         // Shift+Alt
            {KBDNLS_NUMPAD,0},         // Control+Alt
            {KBDNLS_NUMPAD,0}          // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_NUMPAD3,          // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_NUMPAD,0},         // Base
            {KBDNLS_NUMPAD,0},         // Shift
            {KBDNLS_NUMPAD,0},         // Control
            {KBDNLS_NUMPAD,0},         // Shift+Control
            {KBDNLS_NUMPAD,0},         // Alt
            {KBDNLS_NUMPAD,0},         // Shift+Alt
            {KBDNLS_NUMPAD,0},         // Control+Alt
            {KBDNLS_NUMPAD,0}          // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_NUMPAD4,          // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_NUMPAD,0},         // Base
            {KBDNLS_NUMPAD,0},         // Shift
            {KBDNLS_NUMPAD,0},         // Control
            {KBDNLS_NUMPAD,0},         // Shift+Control
            {KBDNLS_NUMPAD,0},         // Alt
            {KBDNLS_NUMPAD,0},         // Shift+Alt
            {KBDNLS_NUMPAD,0},         // Control+Alt
            {KBDNLS_NUMPAD,0}          // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_NUMPAD5,          // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_NUMPAD,0},         // Base
            {KBDNLS_NUMPAD,0},         // Shift
            {KBDNLS_NUMPAD,0},         // Control
            {KBDNLS_NUMPAD,0},         // Shift+Control
            {KBDNLS_NUMPAD,0},         // Alt
            {KBDNLS_NUMPAD,0},         // Shift+Alt
            {KBDNLS_NUMPAD,0},         // Control+Alt
            {KBDNLS_NUMPAD,0}          // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_NUMPAD6,          // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_NUMPAD,0},         // Base
            {KBDNLS_NUMPAD,0},         // Shift
            {KBDNLS_NUMPAD,0},         // Control
            {KBDNLS_NUMPAD,0},         // Shift+Control
            {KBDNLS_NUMPAD,0},         // Alt
            {KBDNLS_NUMPAD,0},         // Shift+Alt
            {KBDNLS_NUMPAD,0},         // Control+Alt
            {KBDNLS_NUMPAD,0}          // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_NUMPAD7,          // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_NUMPAD,0},         // Base
            {KBDNLS_NUMPAD,0},         // Shift
            {KBDNLS_NUMPAD,0},         // Control
            {KBDNLS_NUMPAD,0},         // Shift+Control
            {KBDNLS_NUMPAD,0},         // Alt
            {KBDNLS_NUMPAD,0},         // Shift+Alt
            {KBDNLS_NUMPAD,0},         // Control+Alt
            {KBDNLS_NUMPAD,0}          // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_NUMPAD8,          // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_NUMPAD,0},         // Base
            {KBDNLS_NUMPAD,0},         // Shift
            {KBDNLS_NUMPAD,0},         // Control
            {KBDNLS_NUMPAD,0},         // Shift+Control
            {KBDNLS_NUMPAD,0},         // Alt
            {KBDNLS_NUMPAD,0},         // Shift+Alt
            {KBDNLS_NUMPAD,0},         // Control+Alt
            {KBDNLS_NUMPAD,0}          // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_NUMPAD9,          // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_NUMPAD,0},         // Base
            {KBDNLS_NUMPAD,0},         // Shift
            {KBDNLS_NUMPAD,0},         // Control
            {KBDNLS_NUMPAD,0},         // Shift+Control
            {KBDNLS_NUMPAD,0},         // Alt
            {KBDNLS_NUMPAD,0},         // Shift+Alt
            {KBDNLS_NUMPAD,0},         // Control+Alt
            {KBDNLS_NUMPAD,0}          // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
    {
        VK_DECIMAL,          // Base Vk  PC98_"."  key
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_NUMPAD,0},         // Base
            {KBDNLS_NUMPAD,0},         // Shift
            {KBDNLS_NUMPAD,0},         // Control
            {KBDNLS_NUMPAD,0},         // Shift+Control
            {KBDNLS_NUMPAD,0},         // Alt
            {KBDNLS_NUMPAD,0},         // Shift+Alt
            {KBDNLS_NUMPAD,0},         // Control+Alt
            {KBDNLS_NUMPAD,0}          // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    }
};

USHORT ausMouseVKey98[] = {
                       VK_NUMPAD5,
                       VK_NUMPAD9,
                       VK_NUMPAD3,
                       VK_NUMPAD1,
                       VK_NUMPAD7,
                       VK_NUMPAD4,
                       VK_NUMPAD8,
                       VK_NUMPAD6,
                       VK_NUMPAD2,
                       VK_NUMPAD0,
                       VK_DECIMAL,
                       VK_MULTIPLY,
                       VK_ADD,
                       VK_SUBTRACT,
                       VK_DIVIDE | KBDEXT,
                       VK_HOME | KBDEXT
                      };
#endif // defined(_PC98_)
/***********************************************************************\
* KbdNlsTables
*
\***********************************************************************/

static ALLOC_SECTION_LDATA KBDNLSTABLES KbdNlsTables = {
#if defined(_PC98_)
#if 1
    0,
#else
    0x0d,                            // OEM ID (0x0d = NEC)
#endif
    NLSKBD_INFO_ACCESSIBILITY_KEYMAP,// Information
    16,                              // Number of VK_F entry
    VkToFuncTable_NEC,               // Pointer to VK_F array
    16,                              // Number of MouseVk entry
    ausMouseVKey98                   // Pointer to MouseVk array
#else // defined(_PC98_)
    0,                      // OEM ID (0 = Microsoft)
    0,                      // Information
    4,                      // Number of VK_F entry
    VkToFuncTable_106,      // Pointer to VK_F array
    0,                      // Number of MouseVk entry
    NULL                    // Pointer to MouseVk array
#endif // defined(_PC98_)
};

PKBDNLSTABLES KbdNlsLayerDescriptor(VOID)
{
    return &KbdNlsTables;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\fe_kbds\jpn\lk411a\sources.inc ===
!IF 0

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


!ENDIF

MINORCOMP=kbdlk41a

!include ..\..\japan.inc

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\fe_kbds\jpn\lk411a\kbdlk41a.c ===
/***************************************************************************\
* Module Name: kbdlk41a.c
*
* DEC LK411-AJ keyboard layout driver
*
* History:
* 20-SEP-1996: Nakazato(v-mnakaz, DEC-J) created
\***************************************************************************/

#include <windows.h>
#include <ime.h>
#include "vkoem.h"
#include "kbdjpn.h"
#include "kbdlk41a.h"

#if defined(_M_IA64)
#pragma section(".data")
#define ALLOC_SECTION_LDATA __declspec(allocate(".data"))
#else
#pragma data_seg(".data")
#define ALLOC_SECTION_LDATA
#endif

/***************************************************************************\
* ausVK[] - Virtual Scan Code to Virtual Key conversion table for LK411-AJ
\***************************************************************************/

static ALLOC_SECTION_LDATA USHORT ausVK[] = {
    T00, T01, T02, T03, T04, T05, T06, T07,
    T08, T09, T0A, T0B, T0C, T0D, T0E, T0F,
    T10, T11, T12, T13, T14, T15, T16, T17,
    T18, T19, T1A, T1B, T1C, T1D, T1E, T1F,
    T20, T21, T22, T23, T24, T25, T26, T27,
    T28,

    // LK411-AJ uses "<>" key as SBCS/DBCS (NLS key)
    T29 | KBDSPECIAL,

    T2A, T2B, T2C, T2D, T2E, T2F,
    T30, T31, T32, T33, T34, T35,

     // Right-hand Shift key must have KBDEXT bit set.
    T36 | KBDEXT,

     // numpad_* + Shift/Alt -> SnapShot
    T37 | KBDMULTIVK,

    T38, T39,

     // Lock key(CapsLock) must have KBDSPECIAL bit set (NLS key)
    T3A | KBDSPECIAL,

    T3B, T3C, T3D, T3E, T3F,
    T40, T41, T42, T43, T44,

     // NumLock Key:
     //     KBDEXT     - VK_NUMLOCK is an Extended key
     //     KBDMULTIVK - VK_NUMLOCK or VK_PAUSE (without or with CTRL)
    T45 | KBDEXT | KBDMULTIVK,

    T46 | KBDMULTIVK,

     // Number Pad keys:
     //    KBDNUMPAD  - digits 0-9 and decimal point.
     //    KBDSPECIAL - require special processing by Windows
    T47 | KBDNUMPAD | KBDSPECIAL,   // Numpad 7 (Home)
    T48 | KBDNUMPAD | KBDSPECIAL,   // Numpad 8 (Up),
    T49 | KBDNUMPAD | KBDSPECIAL,   // Numpad 9 (PgUp),
    T4A,
    T4B | KBDNUMPAD | KBDSPECIAL,   // Numpad 4 (Left),
    T4C | KBDNUMPAD | KBDSPECIAL,   // Numpad 5 (Clear),
    T4D | KBDNUMPAD | KBDSPECIAL,   // Numpad 6 (Right),
    T4E,
    T4F | KBDNUMPAD | KBDSPECIAL,   // Numpad 1 (End),
    T50 | KBDNUMPAD | KBDSPECIAL,   // Numpad 2 (Down),
    T51 | KBDNUMPAD | KBDSPECIAL,   // Numpad 3 (PgDn),
    T52 | KBDNUMPAD | KBDSPECIAL,   // Numpad 0 (Ins),
    T53 | KBDNUMPAD | KBDSPECIAL,   // Numpad . (Del),

    T54, T55, T56, T57, T58, T59, T5A, T5B,
    T5C, T5D, T5E, T5F, T60, T61, T62, T63,
    T64, T65, T66, T67, T68, T69, T6A, T6B,
    T6C, T6D, T6E, T6F,

     // Hiragana/Katakana/Roman key must have KBDSPECIAL bit set (NLS key)
    T70 | KBDSPECIAL,

    T71, T72, T73,
    T74, T75, T76, T77, T78,

     // Conversion key must have KBDSPECIAL bit set (NLS key)
    T79 | KBDSPECIAL,

    T7A,

     // Non-Conversion key must have KBDSPECIAL bit set (NLS key)
    T7B | KBDSPECIAL,

    T7C, T7D, T7E, T7F
};


static ALLOC_SECTION_LDATA VSC_VK aE0VscToVk[] = {
        { 0x0F, X0F | KBDEXT | KBDSPECIAL | KBDMULTIVK },       // LK411 added (kana key)
        { 0x1C, X1C | KBDEXT              },  // Numpad Enter
        { 0x1D, X1D | KBDEXT              },  // RControl
        { 0x35, X35 | KBDEXT              },  // Numpad Divide
        { 0x37, X37 | KBDEXT              },  // Snapshot
        { 0x38, X38 | KBDEXT              },  // RMenu
        { 0x3D, X3D | KBDEXT              },  // F13            // LK411 added
        { 0x3E, X3E | KBDEXT              },  // F14            // LK411 added
        { 0x3F, X3F | KBDEXT              },  // F15 (Help)     // LK411 added
        { 0x40, X40 | KBDEXT              },  // F16 (Do)       // LK411 added
        { 0x41, X41 | KBDEXT              },  // F17            // LK411 added
        { 0x46, X46 | KBDEXT              },  // Break (Ctrl + Pause)   // LK411 removed (@@ check)
        { 0x47, X47 | KBDEXT              },  // Home
        { 0x48, X48 | KBDEXT              },  // Up
        { 0x49, X49 | KBDEXT              },  // Prior
        { 0x4B, X4B | KBDEXT              },  // Left
        { 0x4D, X4D | KBDEXT              },  // Right
        { 0x4E, X4E | KBDEXT              },  // Keypad Minus       // LK411
        { 0x4F, X4F | KBDEXT              },  // End
        { 0x50, X50 | KBDEXT              },  // Down
        { 0x51, X51 | KBDEXT              },  // Next
        { 0x52, X52 | KBDEXT              },  // Insert
        { 0x53, X53 | KBDEXT              },  // Delete
//      { 0x5B, X5B | KBDEXT              },  // Left Win       // LK411 remove
//      { 0x5C, X5C | KBDEXT              },  // Right Win      // LK411 remove
//      { 0x5D, X5D | KBDEXT              },  // Application        // LK411 remove
        { 0,      0                       }
};


static ALLOC_SECTION_LDATA VSC_VK aE1VscToVk[] = {
        { 0x1D, Y1D                       },  // Pause
        { 0   ,   0                       }
};



/***************************************************************************\
* aVkToBits[]  - map Virtual Keys to Modifier Bits
*
* See kbd.h for a full description.
*
* US Keyboard has only three shifter keys:
*     SHIFT (L & R) affects alphabnumeric keys,
*     CTRL  (L & R) is used to generate control characters
*     ALT   (L & R) used for generating characters by number with numpad
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_BIT aVkToBits[] = {
    { VK_SHIFT,   KBDSHIFT },   // 1st bit (0001)
    { VK_CONTROL, KBDCTRL  },   // 2nd bit (0010)
    { VK_MENU,    KBDALT   },   // 4th bit (0100)
    { VK_KANA,    KBDKANA  },   // 8th bit (1000)
    { 0,          0        }
};



/***************************************************************************\
* aModification[]  - map character modifier bits to modification number
*
* See kbd.h for a full description.
*
\***************************************************************************/

static ALLOC_SECTION_LDATA MODIFIERS CharModifiers = {
    &aVkToBits[0],
    11,
    {
    //  Modification# // bit    Keys Pressed  : Explanation
    //  ============= // ====  ============== : =============================
        0,            // 0000                 : unshifted characters
        1,            // 0001           SHIFT : capitals, ~!@#$%^&*()_+{}:"<>? etc.
        4,            // 0010      CTRL       : control characters
        6,            // 0011      CTRL SHIFT :
        SHFT_INVALID, // 0100  ALT            : invalid
        SHFT_INVALID, // 0101  ALT      SHIFT : invalid
        SHFT_INVALID, // 0110  ALT CTRL       : invalid
        SHFT_INVALID, // 0111  ALT CTRL SHIFT : invalid
        2,            // 1000  KANA
        3,            // 1001  KANA      SHIFT
        5,            // 1010  KANA CTRL
        7             // 1011  KANA CTRL SHIFT
    }
};



/***************************************************************************\
*
* aVkToWch4[]  - Virtual Key to WCHAR translation for 4 shift states
* aVkToWch6[]  - Virtual Key to WCHAR translation for 6 shift states
* aVkToWch8[]  - Virtual Key to WCHAR translation for 8 shift states
* aVkToWch1[]  - Virtual Key to WCHAR translation for NUMPAD
*
* Table attributes: Unordered Scan, null-terminated
*
* Search this table for an entry with a matching Virtual Key to find the
* corresponding unshifted and shifted WCHAR characters.
*
* Reserved VirtualKey values (first column)
*     -1            - this line contains dead characters (diacritic)
*     0             - terminator
*
* Reserved Attribute values (second column)
*     CAPLOK        - CapsLock affects this key like Shift
*     KANALOK       - The KANA-LOCK key affects this key like KANA
*
* Reserved character values (third through last column)
*     WCH_NONE      - No character
*     WCH_DEAD      - Dead character (diacritic) value is in next line
*
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch4[] = {
    //                               |          |   SHIFT  |  KANA  | K+SHFT |
    //                               |          |==========|========|========|
    {'0'          ,          KANALOK ,'0'       ,')'       ,WCH_WA  ,WCH_WO  },
    {'1'          ,          KANALOK ,'1'       ,'!'       ,WCH_NU  ,WCH_NU  },
    {'3'          ,          KANALOK ,'3'       ,'#'       ,WCH_A   ,WCH_AA  },
    {'4'          ,          KANALOK ,'4'       ,'$'       ,WCH_U   ,WCH_UU  },
    {'5'          ,          KANALOK ,'5'       ,'%'       ,WCH_E   ,WCH_EE  },
    {'7'          ,          KANALOK ,'7'       ,'&'       ,WCH_YA  ,WCH_YAA },
    {'8'          ,          KANALOK ,'8'       ,'*'       ,WCH_YU  ,WCH_YUU },
    {'9'          ,          KANALOK ,'9'       ,'('       ,WCH_YO  ,WCH_YOO },
    {'A'          , CAPLOK | KANALOK ,'a'       ,'A'       ,WCH_TI  ,WCH_TI  },
    {'B'          , CAPLOK | KANALOK ,'b'       ,'B'       ,WCH_KO  ,WCH_KO  },
    {'C'          , CAPLOK | KANALOK ,'c'       ,'C'       ,WCH_SO  ,WCH_SO  },
    {'D'          , CAPLOK | KANALOK ,'d'       ,'D'       ,WCH_SI  ,WCH_SI  },
    {'E'          , CAPLOK | KANALOK ,'e'       ,'E'       ,WCH_I   ,WCH_II  },
    {'F'          , CAPLOK | KANALOK ,'f'       ,'F'       ,WCH_HA  ,WCH_HA  },
    {'G'          , CAPLOK | KANALOK ,'g'       ,'G'       ,WCH_KI  ,WCH_KI  },
    {'H'          , CAPLOK | KANALOK ,'h'       ,'H'       ,WCH_KU  ,WCH_KU  },
    {'I'          , CAPLOK | KANALOK ,'i'       ,'I'       ,WCH_NI  ,WCH_NI  },
    {'J'          , CAPLOK | KANALOK ,'j'       ,'J'       ,WCH_MA  ,WCH_MA  },
    {'K'          , CAPLOK | KANALOK ,'k'       ,'K'       ,WCH_NO  ,WCH_NO  },
    {'L'          , CAPLOK | KANALOK ,'l'       ,'L'       ,WCH_RI  ,WCH_RI  },
    {'M'          , CAPLOK | KANALOK ,'m'       ,'M'       ,WCH_MO  ,WCH_MO  },
    {'N'          , CAPLOK | KANALOK ,'n'       ,'N'       ,WCH_MI  ,WCH_MI  },
    {'O'          , CAPLOK | KANALOK ,'o'       ,'O'       ,WCH_RA  ,WCH_RA  },
    {'P'          , CAPLOK | KANALOK ,'p'       ,'P'       ,WCH_SE  ,WCH_SE  },
    {'Q'          , CAPLOK | KANALOK ,'q'       ,'Q'       ,WCH_TA  ,WCH_TA  },
    {'R'          , CAPLOK | KANALOK ,'r'       ,'R'       ,WCH_SU  ,WCH_SU  },
    {'S'          , CAPLOK | KANALOK ,'s'       ,'S'       ,WCH_TO  ,WCH_TO  },
    {'T'          , CAPLOK | KANALOK ,'t'       ,'T'       ,WCH_KA  ,WCH_KA  },
    {'U'          , CAPLOK | KANALOK ,'u'       ,'U'       ,WCH_NA  ,WCH_NA  },
    {'V'          , CAPLOK | KANALOK ,'v'       ,'V'       ,WCH_HI  ,WCH_HI  },
    {'W'          , CAPLOK | KANALOK ,'w'       ,'W'       ,WCH_TE  ,WCH_TE  },
    {'X'          , CAPLOK | KANALOK ,'x'       ,'X'       ,WCH_SA  ,WCH_SA  },
    {'Y'          , CAPLOK | KANALOK ,'y'       ,'Y'       ,WCH_NN  ,WCH_NN  },
    {'Z'          , CAPLOK | KANALOK ,'z'       ,'Z'       ,WCH_TU  ,WCH_TUU },
    {VK_OEM_1     ,          KANALOK ,';'       ,':'       ,WCH_RE  ,WCH_RE  },
    {VK_OEM_2     ,          KANALOK ,'/'       ,'?'       ,WCH_ME  ,WCH_MD  },
    {VK_OEM_7     ,          KANALOK ,0x27      ,'"'       ,WCH_KE  ,WCH_KE  },
//  {VK_OEM_8     , 0                ,','       ,','       ,','     ,','     },     //LK411 removed
    {VK_OEM_COMMA ,          KANALOK ,','       ,'<'       ,WCH_NE  ,WCH_IC  },
    {VK_OEM_PERIOD,          KANALOK ,'.'       ,'>'       ,WCH_RU  ,WCH_IP  },
    {VK_OEM_PLUS  ,          KANALOK ,'='       ,'+'       ,WCH_HE  ,WCH_HE  },
    {VK_DBE_SBCSCHAR, 0              ,'`'       ,'~'       ,'`'     ,'~'     },     //LK411 added
    {VK_TAB       , 0                ,'\t'      ,'\t'      ,'\t'    ,'\t'    },
    {VK_ADD       , 0                ,'+'       ,'+'       ,'+'     ,'+'     },
    {VK_DECIMAL   , 0                ,'.'       ,'.'       ,'.'     ,'.'     },
    {VK_DIVIDE    , 0                ,'/'       ,'/'       ,'/'     ,'/'     },
    {VK_MULTIPLY  , 0                ,'*'       ,'*'       ,'*'     ,'*'     },
    {VK_SUBTRACT  , 0                ,'-'       ,'-'       ,'-'     ,'-'     },
    {0            , 0                ,0         ,0         ,0       ,0       }
};


static ALLOC_SECTION_LDATA VK_TO_WCHARS6 aVkToWch6[] = {
    //                      |          |   SHIFT  |  KANA  | K+SHFT |  CONTROL  |  K+CTRL   |
    //                      |          |==========|========|========|===========|===========|
    {VK_BACK      , 0       ,'\b'      ,'\b'      ,'\b'    ,'\b'    , 0x7f      , 0x7f      },
    {VK_CANCEL    , 0       ,0x03      ,0x03      ,0x03    ,0x03    , 0x03      , 0x03      },
    {VK_ESCAPE    , 0       ,0x1b      ,0x1b      ,0x1b    ,0x1b    , 0x1b      , 0x1b      },
    {VK_OEM_4     , KANALOK ,'['       ,'{'       ,WCH_RO  ,WCH_VS  , 0x1b      , 0x1b      },  // LK411 modified
    {VK_OEM_5     , KANALOK ,'\\'      ,'|'       ,WCH_OB  ,WCH_CB  , 0x1c      , 0x1c      },  // LK411 modified
    {VK_OEM_6     , KANALOK ,']'       ,'}'       ,WCH_MU  ,WCH_SVS , 0x1d      , 0x1d      },  // LK411 modified
    {VK_RETURN    , 0       ,'\r'      ,'\r'      ,'\r'    ,'\r'    , '\n'      , '\n'      },
    {VK_SPACE     , 0       ,' '       ,' '       ,' '     ,' '     , 0x20      , 0x20      },
    {0            , 0       ,0         ,0         ,0       ,0       , 0         , 0         }
};


static ALLOC_SECTION_LDATA VK_TO_WCHARS8 aVkToWch8[] = {
    //                      |          |   SHIFT  |  KANA  | K+SHFT |  CONTROL  |  K+CTRL   | SHFT+CTRL |K+SHFT+CTRL|
    //                      |          |==========|========|========|===========|===========|===========|===========|
    {'2'          , KANALOK ,'2'       ,'@'       ,WCH_HU  ,WCH_HU  , WCH_NONE  , WCH_NONE  , 0x00      , 0x00      },
    {'6'          , KANALOK ,'6'       ,'^'       ,WCH_O   ,WCH_OO  , WCH_NONE  , WCH_NONE  , 0x1e      , 0x1e      },
    {VK_OEM_MINUS , KANALOK ,'-'       ,'_'       ,WCH_HO  ,WCH_HO  , WCH_NONE  , WCH_NONE  , 0x1f      , 0x1f      },  // LK411
    {0            , 0       ,0         ,0         ,0       ,0       , 0         , 0         , 0         , 0         }
};


// Put this last so that VkKeyScan interprets number characters
// as coming from the main section of the kbd (aVkToWch2 and
// aVkToWch4) before considering the numpad (aVkToWch1).
//
// LK411 doesn't use this table. (Because it doesn't use NUMPAD VK)

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch1[] = {
    //                     |          |   SHIFT  |  KANA  | K+SHFT |
    //                     |          |==========|========|========|
    { VK_NUMPAD0   , 0      ,  '0'    , WCH_NONE ,   '0'  ,WCH_NONE},
    { VK_NUMPAD1   , 0      ,  '1'    , WCH_NONE ,   '1'  ,WCH_NONE},
    { VK_NUMPAD2   , 0      ,  '2'    , WCH_NONE ,   '2'  ,WCH_NONE},
    { VK_NUMPAD3   , 0      ,  '3'    , WCH_NONE ,   '3'  ,WCH_NONE},
    { VK_NUMPAD4   , 0      ,  '4'    , WCH_NONE ,   '4'  ,WCH_NONE},
    { VK_NUMPAD5   , 0      ,  '5'    , WCH_NONE ,   '5'  ,WCH_NONE},
    { VK_NUMPAD6   , 0      ,  '6'    , WCH_NONE ,   '6'  ,WCH_NONE},
    { VK_NUMPAD7   , 0      ,  '7'    , WCH_NONE ,   '7'  ,WCH_NONE},
    { VK_NUMPAD8   , 0      ,  '8'    , WCH_NONE ,   '8'  ,WCH_NONE},
    { VK_NUMPAD9   , 0      ,  '9'    , WCH_NONE ,   '9'  ,WCH_NONE},
    { 0            , 0      ,  '\0'   , 0        ,   0    ,0       }   //null terminator
};


/***************************************************************************\
* aVkToWcharTable: table of pointers to Character Tables
*
* Describes the character tables and the order they should be searched.
*
* Note: the order determines the behavior of VkKeyScan() : this function
*       takes a character and attempts to find a Virtual Key and character-
*       modifier key combination that produces that character.  The table
*       containing the numeric keypad (aVkToWch1) must appear last so that
*       VkKeyScan('0') will be interpreted as one of keys from the main
*       section, not the numpad.  etc.
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHAR_TABLE aVkToWcharTable[] = {
    {  (PVK_TO_WCHARS1)aVkToWch6, 6, sizeof(aVkToWch6[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch8, 8, sizeof(aVkToWch8[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch4, 4, sizeof(aVkToWch4[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch1, 4, sizeof(aVkToWch1[0]) },  // must come last
    {                       NULL, 0, 0                    }
};



/***************************************************************************\
* aKeyNames[], aKeyNamesExt[]  - Scan Code -> Key Name tables
*
* For the GetKeyNameText() API function
*
* Tables for non-extended and extended (KBDEXT) keys.
* (Keys producing printable characters are named by the character itself)
\***************************************************************************/

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNames[] = {
    0x01,    L"Esc",
    0x0e,    L"Backspace",
    0x0f,    L"Tab",
    0x1c,    L"Enter",
    0x1d,    L"Ctrl",
    0x29,    L"<>",
    0x2a,    L"Shift",
    0x36,    L"Right Shift",
    0x37,    L"Num *",
    0x38,    L"Alt",
    0x39,    L"Space",
    0x3a,    L"Caps Lock",
    0x3b,    L"F1",
    0x3c,    L"F2",
    0x3d,    L"F3",
    0x3e,    L"F4",
    0x3f,    L"F5",
    0x40,    L"F6",
    0x41,    L"F7",
    0x42,    L"F8",
    0x43,    L"F9",
    0x44,    L"F10",
    0x45,    L"Num Lock",
    0x46,    L"Scroll Lock",
    0x47,    L"Num 7",
    0x48,    L"Num 8",
    0x49,    L"Num 9",
    0x4a,    L"Num -",
    0x4b,    L"Num 4",
    0x4c,    L"Num 5",
    0x4d,    L"Num 6",
    0x4e,    L"Num +",
    0x4f,    L"Num 1",
    0x50,    L"Num 2",
    0x51,    L"Num 3",
    0x52,    L"Num 0",
    0x53,    L"Num Del",
    0x54,    L"Sys Req",
    0x57,    L"F11",
    0x58,    L"F12",
    0x70,    (LPWSTR)SZ_KEY_NAME_HIRAGANA,
    0x79,    (LPWSTR)SZ_KEY_NAME_HENKAN,
    0x7b,    (LPWSTR)SZ_KEY_NAME_MUHENKAN,
    0   ,    NULL
};


static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNamesExt[] = {
    0x0f,    (LPWSTR)SZ_KEY_NAME_KANA,  //LK411 added, (@@ check), this macro defined by NEC
    0x1c,    L"Num Enter",
    0x1d,    L"Right Control",
    0x35,    L"Num /",
    0x37,    L"Prnt Scrn",
    0x38,    L"Right Alt",
    0x3d,    L"F13",            // LK411 added
    0x3e,    L"F14",            // LK411 added
    0x3f,    L"F15",            // LK411 added (Help)
    0x40,    L"F16",            // LK411 added (Do)
    0x41,    L"F17",            // LK411 added
//  0x45,    L"Num Lock",       // LK411 removed
    0x46,    L"Break",
    0x47,    L"Home",
    0x48,    L"Up",
    0x49,    L"Page Up",
    0x4b,    L"Left",
    0x4d,    L"Right",
    0x4e,    L"Num +",          // LK411 modified(same KP,)
    0x4f,    L"End",
    0x50,    L"Down",
    0x51,    L"Page Down",
    0x52,    L"Insert",
    0x53,    L"Delete",
//  0x54,    L"<00>",           // LK411 removed
//  0x56,    L"Help",           // LK411 removed
//  0x5B,    L"Left Windows",       // LK411 removed
//  0x5C,    L"Right Windows",      // LK411 removed
//  0x5D,    L"Application",        // LK411 removed
    0   ,    NULL
};



static ALLOC_SECTION_LDATA KBDTABLES KbdTables = {
    /*
     * Modifier keys
     */
    &CharModifiers,

    /*
     * Characters tables
     */
    aVkToWcharTable,

    /*
     * Diacritics  (none for US English)
     */
    NULL,

    /*
     * Names of Keys  (no dead keys)
     */
    aKeyNames,
    aKeyNamesExt,
    NULL,

    /*
     * Scan codes to Virtual Keys
     */
    ausVK,
    sizeof(ausVK) / sizeof(ausVK[0]),
    aE0VscToVk,
    aE1VscToVk,

    /*
     * No Locale-specific special processing
     */
    0,

    /*
     * No Ligatures
     */
    0, 0, NULL,

    /*
     * Type and subtype
     */
    KEYBOARD_TYPE_JAPAN,
    MAKEWORD(DEC_KBD_ANSI_LAYOUT_TYPE, NLSKBD_OEM_DEC),
};


PKBDTABLES KbdLayerDescriptor(VOID)
{
    return &KbdTables;
}



/***********************************************************************\
* VkToFuncTable_LK411[]
*
\***********************************************************************/

static ALLOC_SECTION_LDATA VK_F VkToFuncTable_LK411[] = {
    /* LOCK key */
    {
        VK_CAPITAL,           // Base Vk
        KBDNLS_TYPE_TOGGLE,   // NLSFEProcType
        KBDNLS_INDEX_NORMAL,  // NLSFEProcCurrent
        0x32, /* 0011 0010 */ // NLSFEProcSwitch
        {                     // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},         // Base
            {KBDNLS_ALPHANUM,0},             // Shift
            {KBDNLS_NOEVENT,0},              // Control
            {KBDNLS_NOEVENT,0},              // Shift+Control
            {KBDNLS_ALPHANUM,0},             // Alt
            {KBDNLS_ALPHANUM,0},             // Shift+Alt
            {KBDNLS_CODEINPUT,0},            // Control+Alt
            {KBDNLS_CODEINPUT,0}             // Shift+Control+Alt
        },
        {                     // NLSFEProcAlt
            {KBDNLS_ALPHANUM,0},             // Base
            {KBDNLS_ALPHANUM,0},             // Shift
            {KBDNLS_NOEVENT,0},              // Control
            {KBDNLS_NOEVENT,0},              // Shift+Control
            {KBDNLS_ALPHANUM,0},             // Alt
            {KBDNLS_ALPHANUM,0},             // Shift+Alt
            {KBDNLS_NOEVENT,0},              // Control+Alt
            {KBDNLS_NOEVENT,0}               // Shift+Control+Alt
        }
    },

    /* KANA key */
    {
        VK_KANA,              // Base Vk
        KBDNLS_TYPE_TOGGLE,   // NLSFEProcType
        KBDNLS_INDEX_NORMAL,  // NLSFEProcCurrent
        0x08, /* 0000 1000 */ // NLSFEProcSwitch
        {                     // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},         // Base
            {KBDNLS_NOEVENT,0},              // Shift
            {KBDNLS_NOEVENT,0},              // Control
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Shift+Control
            {KBDNLS_NOEVENT,0},              // Alt
            {KBDNLS_NOEVENT,0},              // Shift+Alt
            {KBDNLS_NOEVENT,0},              // Control+Alt
            {KBDNLS_NOEVENT,0}               // Shift+Control+Alt
        },
        {                    // NLSFEProcIndexAlt
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Base
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Shift
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Control
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Shift+Control
            {KBDNLS_NOEVENT,0},              // Alt
            {KBDNLS_NOEVENT,0},              // Shift+Alt
            {KBDNLS_NOEVENT,0},              // Control+Alt
            {KBDNLS_NOEVENT,0}               // Shift+Control+Alt
        }
    },

    /* Hiragana/Katakana key */
    {
        VK_DBE_HIRAGANA,      // Base Vk
        KBDNLS_TYPE_TOGGLE,   // NLSFEProcType
        KBDNLS_INDEX_NORMAL,  // NLSFEProcCurrent
        0x08, /* 0000 1000 */ // NLSFEProcSwitch
        {                     // NLSFEProc
            {KBDNLS_HIRAGANA,0},             // Base
            {KBDNLS_KATAKANA,0},             // Shift
            {KBDNLS_SBCSDBCS,0},             // Control
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Shift+Control
            {KBDNLS_ROMAN,0},                // Alt
            {KBDNLS_ROMAN,0},                // Shift+Alt
            {KBDNLS_ROMAN,0},                // Control+Alt
            {KBDNLS_NOEVENT,0}               // Shift+Control+Alt
        },
        {                    // NLSFEProcIndexAlt
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Base
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Shift
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Control
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Shift+Control
            {KBDNLS_NOEVENT,0},              // Alt
            {KBDNLS_NOEVENT,0},              // Shift+Alt
            {KBDNLS_NOEVENT,0},              // Control+Alt
            {KBDNLS_NOEVENT,0}               // Shift+Control+Alt
        }
    },

    /* SBCS/DBCS key */
    {
        VK_DBE_SBCSCHAR,      // Base Vk
        KBDNLS_TYPE_TOGGLE,   // NLSFEProcType
        KBDNLS_INDEX_NORMAL,  // NLSFEProcCurrent
        0x30, /* 0011 0000 */ // NLSFEProcSwitch
        {                     // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},         // Base  ("<")
            {KBDNLS_SEND_BASE_VK,0},         // Shift (">")
            {KBDNLS_SBCSDBCS,0},             // Control
            {KBDNLS_SBCSDBCS,0},             // Shift+Control
            {KBDNLS_SEND_PARAM_VK,VK_KANJI}, // Alt
            {KBDNLS_SEND_PARAM_VK,VK_KANJI}, // Shift+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}, // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}  // Shift+Control+Alt
        },
        {                    // NLSFEProcIndexAlt
            {KBDNLS_SEND_PARAM_VK,VK_KANJI},  // Base
            {KBDNLS_SEND_PARAM_VK,VK_KANJI},  // Shift
            {KBDNLS_NOEVENT,0},              // Control
            {KBDNLS_NOEVENT,0},              // Shift+Control
            {KBDNLS_SEND_PARAM_VK,VK_KANJI}, // Alt
            {KBDNLS_SEND_PARAM_VK,VK_KANJI}, // Shift+Alt
            {KBDNLS_NOEVENT,0},              // Control+Alt
            {KBDNLS_NOEVENT,0}               // Shift+Control+Alt
        }
    },

    /* CONVERT key */
    {
        VK_CONVERT,          // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},         // Base
            {KBDNLS_SEND_BASE_VK,0},         // Shift
            {KBDNLS_NOEVENT,0},              // Control
            {KBDNLS_NOEVENT,0},              // Shift+Control
            {KBDNLS_SEND_PARAM_VK,VK_KANJI}, // Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}, // Shift+Alt (LK411: Shift+Alt+NoConv -> IME config)
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}, // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}  // Shift+Control+Alt
        },
        {                         // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },

    /* NONE-CONVERT key */
    {
        VK_NONCONVERT,       // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},         // Base
            {KBDNLS_NOEVENT,0},              // Shift
            {KBDNLS_NOEVENT,0},              // Control
            {KBDNLS_NOEVENT,0},              // Shift+Control
            {KBDNLS_SBCSDBCS,0},             // Alt  (LK411: Alt+NoConv -> SBCS/DBCS)
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}, // Shift+Alt (LK411: Shift+Alt+NoConv -> IME config)
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}, // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}  // Shift+Control+Alt
        },
        {                         // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    }
};


/***********************************************************************\
* KbdNlsTables
*
\***********************************************************************/

static ALLOC_SECTION_LDATA KBDNLSTABLES KbdNlsTables = {
    NLSKBD_OEM_DEC,                      // OEM ID
    NLSKBD_INFO_EMURATE_101_KEYBOARD,    // Information
    6,                                   // Number of VK_F entry
    VkToFuncTable_LK411,                 // Pointer to VK_F array
    0,                                   // Pointer to MouseVk entry
    NULL                                 // Pointer to MouseVk array
};


PKBDNLSTABLES KbdNlsLayerDescriptor(VOID)
{
    return &KbdNlsTables;
}

/* EOF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\fe_kbds\jpn\lk411j\sources.inc ===
!IF 0

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


!ENDIF

MINORCOMP=kbdlk41j

!include ..\..\japan.inc

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\fe_kbds\jpn\lk411j\kbdlk41j.c ===
/***************************************************************************\
* Module Name: kbdlk41j.c
*
* DEC LK411-JJ keyboard layout driver
*
* History:
* 20-SEP-1996: Nakazato(v-mnakaz, DEC-J) created
\***************************************************************************/

#include <windows.h>
#include <ime.h>
#include "vkoem.h"
#include "kbdjpn.h"
#include "kbdlk41j.h"

#if defined(_M_IA64)
#pragma section(".data")
#define ALLOC_SECTION_LDATA __declspec(allocate(".data"))
#else
#pragma data_seg(".data")
#define ALLOC_SECTION_LDATA
#endif

/***************************************************************************\
* ausVK[] - Virtual Scan Code to Virtual Key conversion table for LK411-J
\***************************************************************************/

static ALLOC_SECTION_LDATA USHORT ausVK[] = {
    T00, T01, T02, T03, T04, T05, T06, T07,
    T08, T09, T0A, T0B, T0C, T0D, T0E, T0F,
    T10, T11, T12, T13, T14, T15, T16, T17,
    T18, T19, T1A, T1B, T1C, T1D, T1E, T1F,
    T20, T21, T22, T23, T24, T25, T26, T27,
    T28,

    // LK411-JJ doesn't use this key(Use Alt+Conversion key to use IME)
    T29,

    T2A, T2B, T2C, T2D, T2E, T2F,
    T30, T31, T32, T33, T34, T35,

     // Right-hand Shift key must have KBDEXT bit set.
    T36 | KBDEXT,

     // numpad_* + Shift/Alt -> SnapShot
    T37 | KBDMULTIVK,

    T38, T39,

     // Alphanumeric/CapsLock key must have KBDSPECIAL bit set (NLS key)
    T3A | KBDSPECIAL,

    T3B, T3C, T3D, T3E, T3F,
    T40, T41, T42, T43, T44,

     // NumLock Key:
     //     KBDEXT     - VK_NUMLOCK is an Extended key
     //     KBDMULTIVK - VK_NUMLOCK or VK_PAUSE (without or with CTRL)
    T45 | KBDEXT | KBDMULTIVK,

    T46 | KBDMULTIVK,

     // Number Pad keys:
     //    KBDNUMPAD  - digits 0-9 and decimal point.
     //    KBDSPECIAL - require special processing by Windows
    T47 | KBDNUMPAD | KBDSPECIAL,   // Numpad 7 (Home)
    T48 | KBDNUMPAD | KBDSPECIAL,   // Numpad 8 (Up),
    T49 | KBDNUMPAD | KBDSPECIAL,   // Numpad 9 (PgUp),
    T4A,
    T4B | KBDNUMPAD | KBDSPECIAL,   // Numpad 4 (Left),
    T4C | KBDNUMPAD | KBDSPECIAL,   // Numpad 5 (Clear),
    T4D | KBDNUMPAD | KBDSPECIAL,   // Numpad 6 (Right),
    T4E,
    T4F | KBDNUMPAD | KBDSPECIAL,   // Numpad 1 (End),
    T50 | KBDNUMPAD | KBDSPECIAL,   // Numpad 2 (Down),
    T51 | KBDNUMPAD | KBDSPECIAL,   // Numpad 3 (PgDn),
    T52 | KBDNUMPAD | KBDSPECIAL,   // Numpad 0 (Ins),
    T53 | KBDNUMPAD | KBDSPECIAL,   // Numpad . (Del),

    T54, T55, T56, T57, T58, T59, T5A, T5B,
    T5C, T5D, T5E, T5F, T60, T61, T62, T63,
    T64, T65, T66, T67, T68, T69, T6A, T6B,
    T6C, T6D, T6E, T6F,

     // Hiragana/Katakana/Roman key must have KBDSPECIAL bit set (NLS key)
    T70 | KBDSPECIAL,

    T71, T72, T73,
    T74, T75, T76, T77, T78,

     // Conversion key must have KBDSPECIAL bit set (NLS key)
    T79 | KBDSPECIAL,

    T7A,

     // Non-Conversion key must have KBDSPECIAL bit set (NLS key)
    T7B | KBDSPECIAL,

    T7C, T7D, T7E, T7F
};


static ALLOC_SECTION_LDATA VSC_VK aE0VscToVk[] = {
        { 0x0F, X0F | KBDEXT | KBDSPECIAL | KBDMULTIVK },       // LK411 added (kana key)
        { 0x1C, X1C | KBDEXT              },  // Numpad Enter
        { 0x1D, X1D | KBDEXT              },  // RControl
        { 0x35, X35 | KBDEXT              },  // Numpad Divide
        { 0x37, X37 | KBDEXT              },  // Snapshot
        { 0x38, X38 | KBDEXT              },  // RMenu
        { 0x3D, X3D | KBDEXT              },  // F13            // LK411 added
        { 0x3E, X3E | KBDEXT              },  // F14            // LK411 added
        { 0x3F, X3F | KBDEXT              },  // F15 (Help)     // LK411 added
        { 0x40, X40 | KBDEXT              },  // F16 (Do)       // LK411 added
        { 0x41, X41 | KBDEXT              },  // F17            // LK411 added
        { 0x46, X46 | KBDEXT              },  // Break (Ctrl + Pause)   // LK411 removed (@@ check)
        { 0x47, X47 | KBDEXT              },  // Home
        { 0x48, X48 | KBDEXT              },  // Up
        { 0x49, X49 | KBDEXT              },  // Prior
        { 0x4B, X4B | KBDEXT              },  // Left
        { 0x4D, X4D | KBDEXT              },  // Right
        { 0x4E, X4E | KBDEXT              },  // Keypad Minus       // LK411
        { 0x4F, X4F | KBDEXT              },  // End
        { 0x50, X50 | KBDEXT              },  // Down
        { 0x51, X51 | KBDEXT              },  // Next
        { 0x52, X52 | KBDEXT              },  // Insert
        { 0x53, X53 | KBDEXT              },  // Delete
//      { 0x5B, X5B | KBDEXT              },  // Left Win       // LK411 remove
//      { 0x5C, X5C | KBDEXT              },  // Right Win      // LK411 remove
//      { 0x5D, X5D | KBDEXT              },  // Application        // LK411 remove
        { 0,      0                       }
};


static ALLOC_SECTION_LDATA VSC_VK aE1VscToVk[] = {
        { 0x1D, Y1D                       },  // Pause
        { 0   ,   0                       }
};



/***************************************************************************\
* aVkToBits[]  - map Virtual Keys to Modifier Bits
*
* See kbd.h for a full description.
*
* US Keyboard has only three shifter keys:
*     SHIFT (L & R) affects alphabnumeric keys,
*     CTRL  (L & R) is used to generate control characters
*     ALT   (L & R) used for generating characters by number with numpad
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_BIT aVkToBits[] = {
    { VK_SHIFT,   KBDSHIFT },   // 1st bit (0001)
    { VK_CONTROL, KBDCTRL  },   // 2nd bit (0010)
    { VK_MENU,    KBDALT   },   // 4th bit (0100)
    { VK_KANA,    KBDKANA  },   // 8th bit (1000)
    { 0,          0        }
};



/***************************************************************************\
* aModification[]  - map character modifier bits to modification number
*
* See kbd.h for a full description.
*
\***************************************************************************/

static ALLOC_SECTION_LDATA MODIFIERS CharModifiers = {
    &aVkToBits[0],
    11,
    {
    //  Modification# // bit    Keys Pressed  : Explanation
    //  ============= // ====  ============== : =============================
        0,            // 0000                 : unshifted characters
        1,            // 0001           SHIFT : capitals, ~!@#$%^&*()_+{}:"<>? etc.
        4,            // 0010      CTRL       : control characters
        6,            // 0011      CTRL SHIFT :
        SHFT_INVALID, // 0100  ALT            : invalid
        SHFT_INVALID, // 0101  ALT      SHIFT : invalid
        SHFT_INVALID, // 0110  ALT CTRL       : invalid
        SHFT_INVALID, // 0111  ALT CTRL SHIFT : invalid
        2,            // 1000  KANA
        3,            // 1001  KANA      SHIFT
        5,            // 1010  KANA CTRL
        7             // 1011  KANA CTRL SHIFT
    }
};



/***************************************************************************\
*
* aVkToWch4[]  - Virtual Key to WCHAR translation for 4 shift states
* aVkToWch6[]  - Virtual Key to WCHAR translation for 6 shift states
* aVkToWch8[]  - Virtual Key to WCHAR translation for 8 shift states
* aVkToWch1[]  - Virtual Key to WCHAR translation for NUMPAD
*
* Table attributes: Unordered Scan, null-terminated
*
* Search this table for an entry with a matching Virtual Key to find the
* corresponding unshifted and shifted WCHAR characters.
*
* Reserved VirtualKey values (first column)
*     -1            - this line contains dead characters (diacritic)
*     0             - terminator
*
* Reserved Attribute values (second column)
*     CAPLOK        - CapsLock affects this key like Shift
*     KANALOK       - The KANA-LOCK key affects this key like KANA
*
* Reserved character values (third through last column)
*     WCH_NONE      - No character
*     WCH_DEAD      - Dead character (diacritic) value is in next line
*
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch4[] = {
    //                               |          |   SHIFT  |  KANA  | K+SHFT |
    //                               |          |==========|========|========|
    {'0'          ,          KANALOK ,'0'       ,WCH_NONE  ,WCH_WA  ,WCH_WO  },
    {'1'          ,          KANALOK ,'1'       ,'!'       ,WCH_NU  ,WCH_NU  },
    {'3'          ,          KANALOK ,'3'       ,'#'       ,WCH_A   ,WCH_AA  },
    {'4'          ,          KANALOK ,'4'       ,'$'       ,WCH_U   ,WCH_UU  },
    {'5'          ,          KANALOK ,'5'       ,'%'       ,WCH_E   ,WCH_EE  },
    {'7'          ,          KANALOK ,'7'       ,0x27      ,WCH_YA  ,WCH_YAA },
    {'8'          ,          KANALOK ,'8'       ,'('       ,WCH_YU  ,WCH_YUU },
    {'9'          ,          KANALOK ,'9'       ,')'       ,WCH_YO  ,WCH_YOO },
    {'A'          , CAPLOK | KANALOK ,'a'       ,'A'       ,WCH_TI  ,WCH_TI  },
    {'B'          , CAPLOK | KANALOK ,'b'       ,'B'       ,WCH_KO  ,WCH_KO  },
    {'C'          , CAPLOK | KANALOK ,'c'       ,'C'       ,WCH_SO  ,WCH_SO  },
    {'D'          , CAPLOK | KANALOK ,'d'       ,'D'       ,WCH_SI  ,WCH_SI  },
    {'E'          , CAPLOK | KANALOK ,'e'       ,'E'       ,WCH_I   ,WCH_II  },
    {'F'          , CAPLOK | KANALOK ,'f'       ,'F'       ,WCH_HA  ,WCH_HA  },
    {'G'          , CAPLOK | KANALOK ,'g'       ,'G'       ,WCH_KI  ,WCH_KI  },
    {'H'          , CAPLOK | KANALOK ,'h'       ,'H'       ,WCH_KU  ,WCH_KU  },
    {'I'          , CAPLOK | KANALOK ,'i'       ,'I'       ,WCH_NI  ,WCH_NI  },
    {'J'          , CAPLOK | KANALOK ,'j'       ,'J'       ,WCH_MA  ,WCH_MA  },
    {'K'          , CAPLOK | KANALOK ,'k'       ,'K'       ,WCH_NO  ,WCH_NO  },
    {'L'          , CAPLOK | KANALOK ,'l'       ,'L'       ,WCH_RI  ,WCH_RI  },
    {'M'          , CAPLOK | KANALOK ,'m'       ,'M'       ,WCH_MO  ,WCH_MO  },
    {'N'          , CAPLOK | KANALOK ,'n'       ,'N'       ,WCH_MI  ,WCH_MI  },
    {'O'          , CAPLOK | KANALOK ,'o'       ,'O'       ,WCH_RA  ,WCH_RA  },
    {'P'          , CAPLOK | KANALOK ,'p'       ,'P'       ,WCH_SE  ,WCH_SE  },
    {'Q'          , CAPLOK | KANALOK ,'q'       ,'Q'       ,WCH_TA  ,WCH_TA  },
    {'R'          , CAPLOK | KANALOK ,'r'       ,'R'       ,WCH_SU  ,WCH_SU  },
    {'S'          , CAPLOK | KANALOK ,'s'       ,'S'       ,WCH_TO  ,WCH_TO  },
    {'T'          , CAPLOK | KANALOK ,'t'       ,'T'       ,WCH_KA  ,WCH_KA  },
    {'U'          , CAPLOK | KANALOK ,'u'       ,'U'       ,WCH_NA  ,WCH_NA  },
    {'V'          , CAPLOK | KANALOK ,'v'       ,'V'       ,WCH_HI  ,WCH_HI  },
    {'W'          , CAPLOK | KANALOK ,'w'       ,'W'       ,WCH_TE  ,WCH_TE  },
    {'X'          , CAPLOK | KANALOK ,'x'       ,'X'       ,WCH_SA  ,WCH_SA  },
    {'Y'          , CAPLOK | KANALOK ,'y'       ,'Y'       ,WCH_NN  ,WCH_NN  },
    {'Z'          , CAPLOK | KANALOK ,'z'       ,'Z'       ,WCH_TU  ,WCH_TUU },
    {VK_OEM_1     ,          KANALOK ,':'       ,'*'       ,WCH_KE  ,WCH_KE  },
    {VK_OEM_2     ,          KANALOK ,'/'       ,'?'       ,WCH_ME  ,WCH_MD  },
    {VK_OEM_3     ,          KANALOK ,'@'       ,'`'       ,WCH_VS  ,WCH_VS  },
    {VK_OEM_7     ,          KANALOK ,'^'       ,'~'       ,WCH_HE  ,WCH_HE  },
//  {VK_OEM_8     , 0                ,','       ,','       ,','     ,','     },     //LK411 removed
    {VK_OEM_COMMA ,          KANALOK ,','       ,'<'       ,WCH_NE  ,WCH_IC  },
    {VK_OEM_PERIOD,          KANALOK ,'.'       ,'>'       ,WCH_RU  ,WCH_IP  },
    {VK_OEM_PLUS  ,          KANALOK ,';'       ,'+'       ,WCH_RE  ,WCH_RE  },
    {VK_TAB       , 0                ,'\t'      ,'\t'      ,'\t'    ,'\t'    },
    {VK_ADD       , 0                ,'+'       ,'+'       ,'+'     ,'+'     },
    {VK_DECIMAL   , 0                ,'.'       ,'.'       ,'.'     ,'.'     },
    {VK_DIVIDE    , 0                ,'/'       ,'/'       ,'/'     ,'/'     },
    {VK_MULTIPLY  , 0                ,'*'       ,'*'       ,'*'     ,'*'     },
    {VK_SUBTRACT  , 0                ,'-'       ,'-'       ,'-'     ,'-'     },
    {0            , 0                ,0         ,0         ,0       ,0       }
};


static ALLOC_SECTION_LDATA VK_TO_WCHARS6 aVkToWch6[] = {
    //                      |          |   SHIFT  |  KANA  | K+SHFT |  CONTROL  |  K+CTRL   |
    //                      |          |==========|========|========|===========|===========|
    {VK_BACK      , 0       ,'\b'      ,'\b'      ,'\b'    ,'\b'    , 0x7f      , 0x7f      },
    {VK_CANCEL    , 0       ,0x03      ,0x03      ,0x03    ,0x03    , 0x03      , 0x03      },
    {VK_ESCAPE    , 0       ,0x1b      ,0x1b      ,0x1b    ,0x1b    , 0x1b      , 0x1b      },
    {VK_OEM_4     , KANALOK ,'['       ,'{'       ,WCH_SVS ,WCH_OB  , 0x1b      , 0x1b      },
    {VK_OEM_5     , KANALOK ,'\\'      ,'|'       ,WCH_PS  ,WCH_PS  , 0x1c      , 0x1c      },
    {VK_OEM_102   , KANALOK ,WCH_NONE  ,'_'       ,WCH_RO  ,WCH_RO  , 0x1c      , 0x1c      },  // LK411 modified
    {VK_OEM_6     , KANALOK ,']'       ,'}'       ,WCH_MU  ,WCH_CB  , 0x1d      , 0x1d      },
    {VK_RETURN    , 0       ,'\r'      ,'\r'      ,'\r'    ,'\r'    , '\n'      , '\n'      },
    {VK_SPACE     , 0       ,' '       ,' '       ,' '     ,' '     , 0x20      , 0x20      },
    {0            , 0       ,0         ,0         ,0       ,0       , 0         , 0         }
};


static ALLOC_SECTION_LDATA VK_TO_WCHARS8 aVkToWch8[] = {
    //                      |          |   SHIFT  |  KANA  | K+SHFT |  CONTROL  |  K+CTRL   | SHFT+CTRL |K+SHFT+CTRL|
    //                      |          |==========|========|========|===========|===========|===========|===========|
    {'2'          , KANALOK ,'2'       ,'"'       ,WCH_HU  ,WCH_HU  , WCH_NONE  , WCH_NONE  , 0x00      , 0x00      },
    {'6'          , KANALOK ,'6'       ,'&'       ,WCH_O   ,WCH_OO  , WCH_NONE  , WCH_NONE  , 0x1e      , 0x1e      },
    {VK_OEM_MINUS , KANALOK ,'-'       ,'='       ,WCH_HO  ,WCH_HO  , WCH_NONE  , WCH_NONE  , 0x1f      , 0x1f      },
    {0            , 0       ,0         ,0         ,0       ,0       , 0         , 0         , 0         , 0         }
};


// Put this last so that VkKeyScan interprets number characters
// as coming from the main section of the kbd (aVkToWch2 and
// aVkToWch4) before considering the numpad (aVkToWch1).
//
// LK411 doesn't use this table. (Because it doesn't use NUMPAD VK)

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch1[] = {
    //                     |          |   SHIFT  |  KANA  | K+SHFT |
    //                     |          |==========|========|========|
    { VK_NUMPAD0   , 0      ,  '0'    , WCH_NONE ,   '0'  ,WCH_NONE},
    { VK_NUMPAD1   , 0      ,  '1'    , WCH_NONE ,   '1'  ,WCH_NONE},
    { VK_NUMPAD2   , 0      ,  '2'    , WCH_NONE ,   '2'  ,WCH_NONE},
    { VK_NUMPAD3   , 0      ,  '3'    , WCH_NONE ,   '3'  ,WCH_NONE},
    { VK_NUMPAD4   , 0      ,  '4'    , WCH_NONE ,   '4'  ,WCH_NONE},
    { VK_NUMPAD5   , 0      ,  '5'    , WCH_NONE ,   '5'  ,WCH_NONE},
    { VK_NUMPAD6   , 0      ,  '6'    , WCH_NONE ,   '6'  ,WCH_NONE},
    { VK_NUMPAD7   , 0      ,  '7'    , WCH_NONE ,   '7'  ,WCH_NONE},
    { VK_NUMPAD8   , 0      ,  '8'    , WCH_NONE ,   '8'  ,WCH_NONE},
    { VK_NUMPAD9   , 0      ,  '9'    , WCH_NONE ,   '9'  ,WCH_NONE},
    { 0            , 0      ,  '\0'   , 0        ,   0    ,0       }   //null terminator
};


/***************************************************************************\
* aVkToWcharTable: table of pointers to Character Tables
*
* Describes the character tables and the order they should be searched.
*
* Note: the order determines the behavior of VkKeyScan() : this function
*       takes a character and attempts to find a Virtual Key and character-
*       modifier key combination that produces that character.  The table
*       containing the numeric keypad (aVkToWch1) must appear last so that
*       VkKeyScan('0') will be interpreted as one of keys from the main
*       section, not the numpad.  etc.
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHAR_TABLE aVkToWcharTable[] = {
    {  (PVK_TO_WCHARS1)aVkToWch6, 6, sizeof(aVkToWch6[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch8, 8, sizeof(aVkToWch8[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch4, 4, sizeof(aVkToWch4[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch1, 4, sizeof(aVkToWch1[0]) },  // must come last
    {                       NULL, 0, 0                    }
};



/***************************************************************************\
* aKeyNames[], aKeyNamesExt[]  - Scan Code -> Key Name tables
*
* For the GetKeyNameText() API function
*
* Tables for non-extended and extended (KBDEXT) keys.
* (Keys producing printable characters are named by the character itself)
\***************************************************************************/

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNames[] = {
    0x01,    L"Esc",
    0x0e,    L"Backspace",
    0x0f,    L"Tab",
    0x1c,    L"Enter",
    0x1d,    L"Ctrl",
//  0x29,    NULL,              // LK411JJ doesn't use this code
    0x2a,    L"Shift",
    0x36,    L"Right Shift",
    0x37,    L"Num *",
    0x38,    L"Alt",
    0x39,    L"Space",
    0x3a,    L"Caps Lock",
    0x3b,    L"F1",
    0x3c,    L"F2",
    0x3d,    L"F3",
    0x3e,    L"F4",
    0x3f,    L"F5",
    0x40,    L"F6",
    0x41,    L"F7",
    0x42,    L"F8",
    0x43,    L"F9",
    0x44,    L"F10",
    0x45,    L"Num Lock",
    0x46,    L"Scroll Lock",
    0x47,    L"Num 7",
    0x48,    L"Num 8",
    0x49,    L"Num 9",
    0x4a,    L"Num -",
    0x4b,    L"Num 4",
    0x4c,    L"Num 5",
    0x4d,    L"Num 6",
    0x4e,    L"Num +",
    0x4f,    L"Num 1",
    0x50,    L"Num 2",
    0x51,    L"Num 3",
    0x52,    L"Num 0",
    0x53,    L"Num Del",
    0x54,    L"Sys Req",
    0x57,    L"F11",
    0x58,    L"F12",
    0x70,    (LPWSTR)SZ_KEY_NAME_HIRAGANA,
    0x73,    L"_",          // LK411 added
    0x79,    (LPWSTR)SZ_KEY_NAME_HENKAN,
    0x7b,    (LPWSTR)SZ_KEY_NAME_MUHENKAN,
    0x7d,    L"\\",         // LK411 added
    0   ,    NULL
};


static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNamesExt[] = {
    0x0f,    (LPWSTR)SZ_KEY_NAME_KANA,  //LK411 added, (@@ check), this macro defined by NEC
    0x1c,    L"Num Enter",
    0x1d,    L"Right Control",
    0x35,    L"Num /",
    0x37,    L"Prnt Scrn",
    0x38,    L"Right Alt",
    0x3d,    L"F13",            // LK411 added
    0x3e,    L"F14",            // LK411 added
    0x3f,    L"F15",            // LK411 added (Help)
    0x40,    L"F16",            // LK411 added (Do)
    0x41,    L"F17",            // LK411 added
//  0x45,    L"Num Lock",       // LK411 removed
    0x46,    L"Break",
    0x47,    L"Home",
    0x48,    L"Up",
    0x49,    L"Page Up",
    0x4b,    L"Left",
    0x4d,    L"Right",
    0x4e,    L"Num +",          // LK411 modified(same KP,)
    0x4f,    L"End",
    0x50,    L"Down",
    0x51,    L"Page Down",
    0x52,    L"Insert",
    0x53,    L"Delete",
//  0x54,    L"<00>",           // LK411 removed
//  0x56,    L"Help",           // LK411 removed
//  0x5B,    L"Left Windows",       // LK411 removed
//  0x5C,    L"Right Windows",      // LK411 removed
//  0x5D,    L"Application",        // LK411 removed
    0   ,    NULL
};



static ALLOC_SECTION_LDATA KBDTABLES KbdTables = {
    /*
     * Modifier keys
     */
    &CharModifiers,

    /*
     * Characters tables
     */
    aVkToWcharTable,

    /*
     * Diacritics  (none for US English)
     */
    NULL,

    /*
     * Names of Keys  (no dead keys)
     */
    aKeyNames,
    aKeyNamesExt,
    NULL,

    /*
     * Scan codes to Virtual Keys
     */
    ausVK,
    sizeof(ausVK) / sizeof(ausVK[0]),
    aE0VscToVk,
    aE1VscToVk,

    /*
     * No Locale-specific special processing
     */
    0,

    /*
     * No Ligatures
     */
    0, 0, NULL,

    /*
     * Type and subtype
     */
    KEYBOARD_TYPE_JAPAN,
    MAKEWORD(DEC_KBD_JIS_LAYOUT_TYPE, NLSKBD_OEM_DEC),
};


PKBDTABLES KbdLayerDescriptor(VOID)
{
    return &KbdTables;
}



/***********************************************************************\
* VkToFuncTable_LK411[]
*
\***********************************************************************/

static ALLOC_SECTION_LDATA VK_F VkToFuncTable_LK411[] = {
    /* LOCK key */
    {
        VK_CAPITAL,           // Base Vk
        KBDNLS_TYPE_TOGGLE,   // NLSFEProcType
        KBDNLS_INDEX_NORMAL,  // NLSFEProcCurrent
        0x32, /* 0011 0010 */ // NLSFEProcSwitch
        {                     // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},         // Base
            {KBDNLS_ALPHANUM,0},             // Shift
            {KBDNLS_NOEVENT,0},              // Control
            {KBDNLS_NOEVENT,0},              // Shift+Control
            {KBDNLS_ALPHANUM,0},             // Alt
            {KBDNLS_ALPHANUM,0},             // Shift+Alt
            {KBDNLS_CODEINPUT,0},            // Control+Alt
            {KBDNLS_CODEINPUT,0}             // Shift+Control+Alt
        },
        {                     // NLSFEProcAlt
            {KBDNLS_ALPHANUM,0},             // Base
            {KBDNLS_ALPHANUM,0},             // Shift
            {KBDNLS_NOEVENT,0},              // Control
            {KBDNLS_NOEVENT,0},              // Shift+Control
            {KBDNLS_ALPHANUM,0},             // Alt
            {KBDNLS_ALPHANUM,0},             // Shift+Alt
            {KBDNLS_NOEVENT,0},              // Control+Alt
            {KBDNLS_NOEVENT,0}               // Shift+Control+Alt
        }
    },

    /* KANA key */
    {
        VK_KANA,              // Base Vk
        KBDNLS_TYPE_TOGGLE,   // NLSFEProcType
        KBDNLS_INDEX_NORMAL,  // NLSFEProcCurrent
        0x08, /* 0000 1000 */ // NLSFEProcSwitch
        {                     // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},         // Base
            {KBDNLS_NOEVENT,0},              // Shift
            {KBDNLS_NOEVENT,0},              // Control
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Shift+Control
            {KBDNLS_NOEVENT,0},              // Alt
            {KBDNLS_NOEVENT,0},              // Shift+Alt
            {KBDNLS_NOEVENT,0},              // Control+Alt
            {KBDNLS_NOEVENT,0}               // Shift+Control+Alt
        },
        {                    // NLSFEProcIndexAlt
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Base
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Shift
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Control
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Shift+Control
            {KBDNLS_NOEVENT,0},              // Alt
            {KBDNLS_NOEVENT,0},              // Shift+Alt
            {KBDNLS_NOEVENT,0},              // Control+Alt
            {KBDNLS_NOEVENT,0}               // Shift+Control+Alt
        }
    },

    /* Hiragana/Katakana key */
    {
        VK_DBE_HIRAGANA,      // Base Vk
        KBDNLS_TYPE_TOGGLE,   // NLSFEProcType
        KBDNLS_INDEX_NORMAL,  // NLSFEProcCurrent
        0x08, /* 0000 1000 */ // NLSFEProcSwitch
        {                     // NLSFEProc
            {KBDNLS_HIRAGANA,0},             // Base
            {KBDNLS_KATAKANA,0},             // Shift
            {KBDNLS_SBCSDBCS,0},             // Control
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Shift+Control
            {KBDNLS_ROMAN,0},                // Alt
            {KBDNLS_ROMAN,0},                // Shift+Alt
            {KBDNLS_ROMAN,0},                // Control+Alt
            {KBDNLS_NOEVENT,0}               // Shift+Control+Alt
        },
        {                    // NLSFEProcIndexAlt
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Base
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Shift
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Control
            {KBDNLS_SEND_PARAM_VK,VK_KANA},  // Shift+Control
            {KBDNLS_NOEVENT,0},              // Alt
            {KBDNLS_NOEVENT,0},              // Shift+Alt
            {KBDNLS_NOEVENT,0},              // Control+Alt
            {KBDNLS_NOEVENT,0}               // Shift+Control+Alt
        }
    },

#if 0
    // LK411-JJ keyboad doesn't have SBCS/DBCS key.
    /* SBCS/DBCS key */
    {
        VK_DBE_SBCSCHAR,     // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SBCSDBCS,0},             // Base
            {KBDNLS_SBCSDBCS,0},             // Shift
            {KBDNLS_SBCSDBCS,0},             // Control
            {KBDNLS_SBCSDBCS,0},             // Shift+Control
            {KBDNLS_SEND_PARAM_VK,VK_KANJI}, // Alt
            {KBDNLS_NOEVENT,0},              // Shift+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}, // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}  // Shift+Control+Alt
        },
        {                    // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },
#endif

    /* CONVERT key */
    {
        VK_CONVERT,           // Base Vk
        KBDNLS_TYPE_NORMAL,   // NLSFEProcType
        KBDNLS_INDEX_NORMAL,  // NLSFEProcCurrent
        0x0,                  // NLSFEProcSwitch
        {                     // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},         // Base
            {KBDNLS_SEND_BASE_VK,0},         // Shift
            {KBDNLS_NOEVENT,0},              // Control
            {KBDNLS_NOEVENT,0},              // Shift+Control
            {KBDNLS_SEND_PARAM_VK,VK_KANJI}, // Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}, // Shift+Alt (LK411: Shift+Alt+NoConv -> IME config)
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}, // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}  // Shift+Control+Alt
        },
        {                     // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    },

    /* NONE-CONVERT key */
    {
        VK_NONCONVERT,       // Base Vk
        KBDNLS_TYPE_NORMAL,  // NLSFEProcType
        KBDNLS_INDEX_NORMAL, // NLSFEProcCurrent
        0x0,                 // NLSFEProcSwitch
        {                    // NLSFEProc
            {KBDNLS_SEND_BASE_VK,0},         // Base
            {KBDNLS_NOEVENT,0},              // Shift
            {KBDNLS_NOEVENT,0},              // Control
            {KBDNLS_NOEVENT,0},              // Shift+Control
            {KBDNLS_SBCSDBCS,0},             // Alt  (LK411: Alt+NoConv -> SBCS/DBCS)
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERIMECONFIGMODE}, // Shift+Alt (LK411: Shift+Alt+NoConv -> IME config)
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}, // Control+Alt
            {KBDNLS_SEND_PARAM_VK,VK_DBE_ENTERWORDREGISTERMODE}  // Shift+Control+Alt
        },
        {                         // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},  // Base
            {KBDNLS_NULL,0},  // Shift
            {KBDNLS_NULL,0},  // Control
            {KBDNLS_NULL,0},  // Shift+Control
            {KBDNLS_NULL,0},  // Alt
            {KBDNLS_NULL,0},  // Shift+Alt
            {KBDNLS_NULL,0},  // Control+Alt
            {KBDNLS_NULL,0}   // Shift+Control+Alt
        }
    }
};


/***********************************************************************\
* KbdNlsTables
*
\***********************************************************************/

static ALLOC_SECTION_LDATA KBDNLSTABLES KbdNlsTables = {
    NLSKBD_OEM_DEC,                      // OEM ID
    NLSKBD_INFO_EMURATE_106_KEYBOARD,    // Information
    5,                                   // Number of VK_F entry
    VkToFuncTable_LK411,                 // Pointer to VK_F array
    0,                                   // Pointer to MouseVk entry
    NULL                                 // Pointer to MouseVk array
};


PKBDNLSTABLES KbdNlsLayerDescriptor(VOID)
{
    return &KbdNlsTables;
}

/* EOF */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\fe_kbds\kor\korea.inc ===
#****************************** File Header ******************************\
# File Name: Sources.inc for JPN KBDs
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific SOURCES file.
#
# History:
# May-14-1999 HiroYama Created
#***************************************************************************/

!include ..\..\..\fekbds.inc

C_DEFINES=$(C_DEFINES) -DKOREA

SOURCES_USED=..\..\korea.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\fe_kbds\jpn\lk411j\kbdlk41j.h ===
/****************************** Module Header ******************************\
* Module Name: kbdlk41j.h
*
* History:
\***************************************************************************/

#define KBD_TYPE 40

/*
 * Include the basis of all keyboard table values
 */
#include "kbd.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\fe_kbds\kor\101a\kbd101a.c ===
/***************************************************************************\
* Module Name: kbd101a.c (Type A)
*
* Copyright (c) 1985-92, Microsoft Corporation
*
* Keyboard Type A :  Hangeul Toggle : Right Alt
*                    Junja   Toggle : Left  Alt + '='
*                    Hanja   Toggle : Right Ctrl
\***************************************************************************/

#include <windows.h>
#include <ime.h>
#include "vkoem.h"
#include "kbd101a.h"

#if defined(_M_IA64)
#pragma section(".data")
#define ALLOC_SECTION_LDATA __declspec(allocate(".data"))
#else
#pragma data_seg(".data")
#define ALLOC_SECTION_LDATA
#endif

/***************************************************************************\
* ausVK[] - Virtual Scan Code to Virtual Key conversion table for 101
\***************************************************************************/

static ALLOC_SECTION_LDATA USHORT ausVK[] = {
    T00, T01, T02, T03, T04, T05, T06, T07,
    T08, T09, T0A, T0B, T0C,

    /*
     * '='/'+' key must have KBDSPECIAL bit set (NLS key)
     */
    T0D | KBDSPECIAL,

                                  T0E, T0F,
    T10, T11, T12, T13, T14, T15, T16, T17,
    T18, T19, T1A, T1B, T1C, T1D, T1E, T1F,
    T20, T21, T22, T23, T24, T25, T26, T27,
    T28, T29, T2A, T2B, T2C, T2D, T2E, T2F,
    T30, T31, T32, T33, T34, T35,

    /*
     * Right-hand Shift key must have KBDEXT bit set.
     */
    T36 | KBDEXT,

    /*
     * numpad_* + Shift/Alt -> SnapShot
     */
    T37 | KBDMULTIVK,

    T38, T39, T3A, T3B, T3C, T3D, T3E, T3F,
    T40, T41, T42, T43, T44,

    /*
     * NumLock Key:
     *     KBDEXT     - VK_NUMLOCK is an Extended key
     *     KBDMULTIVK - VK_NUMLOCK or VK_PAUSE (without or with CTRL)
     */
    T45 | KBDEXT | KBDMULTIVK,

    T46 | KBDMULTIVK,

    /*
     * Number Pad keys:
     *     KBDNUMPAD  - digits 0-9 and decimal point.
     *     KBDSPECIAL - require special processing by Windows
     */
    T47 | KBDNUMPAD | KBDSPECIAL,   // Numpad 7 (Home)
    T48 | KBDNUMPAD | KBDSPECIAL,   // Numpad 8 (Up),
    T49 | KBDNUMPAD | KBDSPECIAL,   // Numpad 9 (PgUp),
    T4A,
    T4B | KBDNUMPAD | KBDSPECIAL,   // Numpad 4 (Left),
    T4C | KBDNUMPAD | KBDSPECIAL,   // Numpad 5 (Clear),
    T4D | KBDNUMPAD | KBDSPECIAL,   // Numpad 6 (Right),
    T4E,
    T4F | KBDNUMPAD | KBDSPECIAL,   // Numpad 1 (End),
    T50 | KBDNUMPAD | KBDSPECIAL,   // Numpad 2 (Down),
    T51 | KBDNUMPAD | KBDSPECIAL,   // Numpad 3 (PgDn),
    T52 | KBDNUMPAD | KBDSPECIAL,   // Numpad 0 (Ins),
    T53 | KBDNUMPAD | KBDSPECIAL,   // Numpad . (Del),

    T54, T55, T56, T57, T58, T59, T5A, T5B,
    T5C, T5D, T5E, T5F, T60, T61, T62, T63,
    T64, T65, T66, T67, T68, T69, T6A, T6B,
    T6C, T6D, T6E, T6F, T70, T71, T72, T73,
    T74, T75, T76, T77, T78, T79, T7A, T7B,
    T7C, T7D, T7E, T7F
};

static ALLOC_SECTION_LDATA VSC_VK aE0VscToVk[] = {
        { 0x10, X10 | KBDEXT              },  // Speedracer: Previous Track
        { 0x19, X19 | KBDEXT              },  // Speedracer: Next Track
        { 0x1C, X1C | KBDEXT              },  // Numpad Enter
        { 0x1D, X1D | KBDEXT | KBDSPECIAL },  // RControl // Hanja NLS key
        { 0x20, X20 | KBDEXT              },  // Speedracer: Volume Mute
        { 0x21, X21 | KBDEXT              },  // Speedracer: Launch App 2
        { 0x22, X22 | KBDEXT              },  // Speedracer: Media Play/Pause
        { 0x24, X24 | KBDEXT              },  // Speedracer: Media Stop
        { 0x2E, X2E | KBDEXT              },  // Speedracer: Volume Down
        { 0x30, X30 | KBDEXT              },  // Speedracer: Volume Up
        { 0x32, X32 | KBDEXT              },  // Speedracer: Browser Home
        { 0x35, X35 | KBDEXT              },  // Numpad Divide
        { 0x37, X37 | KBDEXT              },  // Snapshot
        { 0x38, X38 | KBDEXT | KBDSPECIAL },  // RMenu    // Hangeul NLS key
        { 0x46, X46 | KBDEXT              },  // Break (Ctrl + Pause)
        { 0x47, X47 | KBDEXT              },  // Home
        { 0x48, X48 | KBDEXT              },  // Up
        { 0x49, X49 | KBDEXT              },  // Prior
        { 0x4B, X4B | KBDEXT              },  // Left
        { 0x4D, X4D | KBDEXT              },  // Right
        { 0x4F, X4F | KBDEXT              },  // End
        { 0x50, X50 | KBDEXT              },  // Down
        { 0x51, X51 | KBDEXT              },  // Next
        { 0x52, X52 | KBDEXT              },  // Insert
        { 0x53, X53 | KBDEXT              },  // Delete
        { 0x5B, X5B | KBDEXT              },  // Left Win
        { 0x5C, X5C | KBDEXT              },  // Right Win
        { 0x5D, X5D | KBDEXT              },  // Applications
        { 0x5F, X5F | KBDEXT              },  // Speedracer: Sleep
        { 0x65, X65 | KBDEXT              },  // Speedracer: Browser Search
        { 0x66, X66 | KBDEXT              },  // Speedracer: Browser Favorites
        { 0x67, X67 | KBDEXT              },  // Speedracer: Browser Refresh
        { 0x68, X68 | KBDEXT              },  // Speedracer: Browser Stop
        { 0x69, X69 | KBDEXT              },  // Speedracer: Browser Forward
        { 0x6A, X6A | KBDEXT              },  // Speedracer: Browser Back
        { 0x6B, X6B | KBDEXT              },  // Speedracer: Launch App 1
        { 0x6C, X6C | KBDEXT              },  // Speedracer: Launch Mail
        { 0x6D, X6D | KBDEXT              },  // Speedracer: Launch Media Selector
        { 0xF1, XF1 | KBDEXT | KBDSPECIAL },  // Hanja
        { 0xF2, XF2 | KBDEXT | KBDSPECIAL },  // Hangeul
        { 0,      0                       }
};

static ALLOC_SECTION_LDATA VSC_VK aE1VscToVk[] = {
        { 0x1D, Y1D                       },  // Pause
        { 0   ,   0                       }
};

/***************************************************************************\
* aVkToBits[]  - map Virtual Keys to Modifier Bits
*
* See kbd.h for a full description.
*
* US Keyboard has only three shifter keys:
*     SHIFT (L & R) affects alphabnumeric keys,
*     CTRL  (L & R) is used to generate control characters
*     ALT   (L & R) used for generating characters by number with numpad
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_BIT aVkToBits[] = {
    { VK_SHIFT,   KBDSHIFT },
    { VK_CONTROL, KBDCTRL  },
    { VK_MENU,    KBDALT   },
    { 0,          0        }
};

/***************************************************************************\
* aModification[]  - map character modifier bits to modification number
*
* See kbd.h for a full description.
*
\***************************************************************************/

static ALLOC_SECTION_LDATA MODIFIERS CharModifiers = {
    &aVkToBits[0],
    3,
    {
    //  Modification# //  Keys Pressed  : Explanation
    //  ============= // ============== : =============================
        0,            //                : unshifted characters
        1,            //          SHIFT : capitals, ~!@#$%^&*()_+{}:"<>? etc.
        2,            //     CTRL       : control characters
        3,            //     CTRL SHIFT :
                      // ALT            : invalid
                      // ALT      SHIFT : invalid
                      // ALT CTRL       : invalid
                      // ALT CTRL SHIFT : invalid
    }
};

/***************************************************************************\
*
* aVkToWch2[]  - Virtual Key to WCHAR translation for 2 shift states
* aVkToWch3[]  - Virtual Key to WCHAR translation for 3 shift states
* aVkToWch4[]  - Virtual Key to WCHAR translation for 4 shift states
*
* Table attributes: Unordered Scan, null-terminated
*
* Search this table for an entry with a matching Virtual Key to find the
* corresponding unshifted and shifted WCHAR characters.
*
* Reserved VirtualKey values (first column)
*     -1            - this line contains dead characters (diacritic)
*     0             - terminator
*
* Reserved Attribute values (second column)
*     CAPLOK        - CapsLock affects this key like Shift
*
* Reserved character values (third through last column)
*     WCH_NONE      - No character
*     WCH_DEAD      - Dead character (diacritic) value is in next line
*
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHARS2 aVkToWch2[] = {
    {'0'          , 0      ,'0'       ,')'       },
    {'1'          , 0      ,'1'       ,'!'       },
    {'3'          , 0      ,'3'       ,'#'       },
    {'4'          , 0      ,'4'       ,'$'       },
    {'5'          , 0      ,'5'       ,'%'       },
    {'7'          , 0      ,'7'       ,'&'       },
    {'8'          , 0      ,'8'       ,'*'       },
    {'9'          , 0      ,'9'       ,'('       },
    {'A'          , CAPLOK ,'a'       ,'A'       },
    {'B'          , CAPLOK ,'b'       ,'B'       },
    {'C'          , CAPLOK ,'c'       ,'C'       },
    {'D'          , CAPLOK ,'d'       ,'D'       },
    {'E'          , CAPLOK ,'e'       ,'E'       },
    {'F'          , CAPLOK ,'f'       ,'F'       },
    {'G'          , CAPLOK ,'g'       ,'G'       },
    {'H'          , CAPLOK ,'h'       ,'H'       },
    {'I'          , CAPLOK ,'i'       ,'I'       },
    {'J'          , CAPLOK ,'j'       ,'J'       },
    {'K'          , CAPLOK ,'k'       ,'K'       },
    {'L'          , CAPLOK ,'l'       ,'L'       },
    {'M'          , CAPLOK ,'m'       ,'M'       },
    {'N'          , CAPLOK ,'n'       ,'N'       },
    {'O'          , CAPLOK ,'o'       ,'O'       },
    {'P'          , CAPLOK ,'p'       ,'P'       },
    {'Q'          , CAPLOK ,'q'       ,'Q'       },
    {'R'          , CAPLOK ,'r'       ,'R'       },
    {'S'          , CAPLOK ,'s'       ,'S'       },
    {'T'          , CAPLOK ,'t'       ,'T'       },
    {'U'          , CAPLOK ,'u'       ,'U'       },
    {'V'          , CAPLOK ,'v'       ,'V'       },
    {'W'          , CAPLOK ,'w'       ,'W'       },
    {'X'          , CAPLOK ,'x'       ,'X'       },
    {'Y'          , CAPLOK ,'y'       ,'Y'       },
    {'Z'          , CAPLOK ,'z'       ,'Z'       },
    {VK_OEM_1     , 0      ,';'       ,':'       },
    {VK_OEM_2     , 0      ,'/'       ,'?'       },
    {VK_OEM_3     , 0      ,'`'       ,'~'       },
    {VK_OEM_7     , 0      ,0x27      ,'"'       },
    {VK_OEM_8     , 0      ,WCH_NONE  ,WCH_NONE  },
    {VK_OEM_COMMA , 0      ,','       ,'<'       },
    {VK_OEM_PERIOD, 0      ,'.'       ,'>'       },
    {VK_OEM_PLUS  , 0      ,'='       ,'+'       },
    {VK_TAB       , 0      ,'\t'      ,'\t'      },
    {VK_ADD       , 0      ,'+'       ,'+'       },
    {VK_DECIMAL   , 0      ,'.'       ,'.'       },
    {VK_DIVIDE    , 0      ,'/'       ,'/'       },
    {VK_MULTIPLY  , 0      ,'*'       ,'*'       },
    {VK_SUBTRACT  , 0      ,'-'       ,'-'       },
    {0            , 0      ,0         ,0         }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS3 aVkToWch3[] = {
    //                     |          |   SHIFT  |  CONTROL  |
    //                     |          |==========|===========|
    {VK_BACK      , 0      ,'\b'      ,'\b'      , 0x7f      },
    {VK_CANCEL    , 0      ,0x03      ,0x03      , 0x03      },
    {VK_ESCAPE    , 0      ,0x1b      ,0x1b      , 0x1b      },
    {VK_OEM_4     , 0      ,'['       ,'{'       , 0x1b      },
    {VK_OEM_5     , 0      ,'\\'      ,'|'       , 0x1c      },
    {VK_OEM_102   , 0      ,'\\'      ,'|'       , 0x1c      },
    {VK_OEM_6     , 0      ,']'       ,'}'       , 0x1d      },
    {VK_RETURN    , 0      ,'\r'      ,'\r'      , '\n'      },
    {VK_SPACE     , 0      ,' '       ,' '       , 0x20      },
    {0            , 0      ,0         ,0         , 0         }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch4[] = {
    //                     |          |   SHIFT  |  CONTROL  | SHFT+CTRL |
    //                     |          |==========|===========|===========|
    {'2'          , 0      ,'2'       ,'@'       , WCH_NONE  , 0x00      },
    {'6'          , 0      ,'6'       ,'^'       , WCH_NONE  , 0x1e      },
    {VK_OEM_MINUS , 0      ,'-'       ,'_'       , WCH_NONE  , 0x1f      },
    {0            , 0      ,0         ,0         , 0         , 0         }
};

// Put this last so that VkKeyScan interprets number characters
// as coming from the main section of the kbd (aVkToWch2 and
// aVkToWch4) before considering the numpad (aVkToWch1).

static ALLOC_SECTION_LDATA VK_TO_WCHARS1 aVkToWch1[] = {
    { VK_NUMPAD0   , 0      ,  '0'   },
    { VK_NUMPAD1   , 0      ,  '1'   },
    { VK_NUMPAD2   , 0      ,  '2'   },
    { VK_NUMPAD3   , 0      ,  '3'   },
    { VK_NUMPAD4   , 0      ,  '4'   },
    { VK_NUMPAD5   , 0      ,  '5'   },
    { VK_NUMPAD6   , 0      ,  '6'   },
    { VK_NUMPAD7   , 0      ,  '7'   },
    { VK_NUMPAD8   , 0      ,  '8'   },
    { VK_NUMPAD9   , 0      ,  '9'   },
    { 0            , 0      ,  '\0'  }   //null terminator
};

/***************************************************************************\
* aVkToWcharTable: table of pointers to Character Tables
*
* Describes the character tables and the order they should be searched.
*
* Note: the order determines the behavior of VkKeyScan() : this function
*       takes a character and attempts to find a Virtual Key and character-
*       modifier key combination that produces that character.  The table
*       containing the numeric keypad (aVkToWch1) must appear last so that
*       VkKeyScan('0') will be interpreted as one of keys from the main
*       section, not the numpad.  etc.
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHAR_TABLE aVkToWcharTable[] = {
    {  (PVK_TO_WCHARS1)aVkToWch3, 3, sizeof(aVkToWch3[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch4, 4, sizeof(aVkToWch4[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch2, 2, sizeof(aVkToWch2[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch1, 1, sizeof(aVkToWch1[0]) },  // must come last
    {                       NULL, 0, 0                    }
};

/***************************************************************************\
* aKeyNames[], aKeyNamesExt[]  - Scan Code -> Key Name tables
*
* For the GetKeyNameText() API function
*
* Tables for non-extended and extended (KBDEXT) keys.
* (Keys producing printable characters are named by the character itself)
\***************************************************************************/

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNames[] = {
    0x01,    L"Esc",
    0x0e,    L"Backspace",
    0x0f,    L"Tab",
    0x1c,    L"Enter",
    0x1d,    L"Ctrl",
    0x2a,    L"Shift",
    0x36,    L"Right Shift",
    0x37,    L"Num *",
    0x38,    L"Alt",
    0x39,    L"Space",
    0x3a,    L"Caps Lock",
    0x3b,    L"F1",
    0x3c,    L"F2",
    0x3d,    L"F3",
    0x3e,    L"F4",
    0x3f,    L"F5",
    0x40,    L"F6",
    0x41,    L"F7",
    0x42,    L"F8",
    0x43,    L"F9",
    0x44,    L"F10",
    0x45,    L"Pause",
    0x46,    L"Scroll Lock",
    0x47,    L"Num 7",
    0x48,    L"Num 8",
    0x49,    L"Num 9",
    0x4a,    L"Num -",
    0x4b,    L"Num 4",
    0x4c,    L"Num 5",
    0x4d,    L"Num 6",
    0x4e,    L"Num +",
    0x4f,    L"Num 1",
    0x50,    L"Num 2",
    0x51,    L"Num 3",
    0x52,    L"Num 0",
    0x53,    L"Num Del",
    0x54,    L"Sys Req",
    0x57,    L"F11",
    0x58,    L"F12",
    0x7C,    L"F13",
    0x7D,    L"F14",
    0x7E,    L"F15",
    0x7F,    L"F16",
    0x80,    L"F17",
    0x81,    L"F18",
    0x82,    L"F19",
    0x83,    L"F20",
    0x84,    L"F21",
    0x85,    L"F22",
    0x86,    L"F23",
    0x87,    L"F24",
    0   ,    NULL
};

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNamesExt[] = {
    0x1c,    L"Num Enter",
    0x1d,    L"Right Control",
    0x35,    L"Num /",
    0x37,    L"Prnt Scrn",
    0x38,    L"Right Alt",
    0x45,    L"Num Lock",
    0x46,    L"Break",
    0x47,    L"Home",
    0x48,    L"Up",
    0x49,    L"Page Up",
    0x4b,    L"Left",
    0x4d,    L"Right",
    0x4f,    L"End",
    0x50,    L"Down",
    0x51,    L"Page Down",
    0x52,    L"Insert",
    0x53,    L"Delete",
    0x5B,    L"Left Windows",
    0x5C,    L"Right Windows",
    0x5D,    L"Application",
    0xF1,    L"Hanja",
    0xF2,    L"Hangeul",
    0   ,    NULL
};

ALLOC_SECTION_LDATA KBDTABLES KbdTables101a = {
    /*
     * Modifier keys
     */
    &CharModifiers,

    /*
     * Characters tables
     */
    aVkToWcharTable,

    /*
     * Diacritics  (none for US English)
     */
    NULL,

    /*
     * Names of Keys  (no dead keys)
     */
    aKeyNames,
    aKeyNamesExt,
    NULL,

    /*
     * Scan codes to Virtual Keys
     */
    ausVK,
    sizeof(ausVK) / sizeof(ausVK[0]),
    aE0VscToVk,
    aE1VscToVk,

    /*
     * No Locale-specific special processing
     */
    0,

    /*
     * No Ligatures
     */
    0, 0, NULL,

    /*
     * Type and subtype
     */
    KEYBOARD_TYPE_KOREA,
    MAKEWORD(MICROSOFT_KBD_101A_TYPE, NLSKBD_OEM_MICROSOFT),
};

PKBDTABLES KbdLayerDescriptor(VOID)
{
    return &KbdTables101a;
}

/***********************************************************************\
* VkToFuncTable_101a[]
*
\***********************************************************************/

static ALLOC_SECTION_LDATA VK_F VkToFuncTable_101a[] = {
    {
        VK_OEM_PLUS,                 // Base Vk
        KBDNLS_TYPE_NORMAL,          // NLSFEProcType
        KBDNLS_INDEX_NORMAL,         // NLSFEProcCurrent
        0x0,                         // NLSFEProcSwitch
        {                            // NLSFEProcIndex
            {KBDNLS_SEND_BASE_VK,0},         // Base
            {KBDNLS_SEND_BASE_VK,0},         // Shift
            {KBDNLS_SEND_BASE_VK,0},         // Control
            {KBDNLS_SEND_BASE_VK,0},         // Shift+Control
            {KBDNLS_SEND_PARAM_VK,VK_JUNJA}, // Alt
            {KBDNLS_SEND_BASE_VK,0},         // Shift+Alt
            {KBDNLS_SEND_BASE_VK,0},         // Control+Alt
            {KBDNLS_SEND_BASE_VK,0}          // Shift+Control+Alt
        },
        {                            // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},                 // Base
            {KBDNLS_NULL,0},                 // Shift
            {KBDNLS_NULL,0},                 // Control
            {KBDNLS_NULL,0},                 // Shift+Control
            {KBDNLS_NULL,0},                 // Alt
            {KBDNLS_NULL,0},                 // Shift+Alt
            {KBDNLS_NULL,0},                 // Control+Alt
            {KBDNLS_NULL,0}                  // Shift+Control+Alt
        }
    }
};

/***********************************************************************\
* KbdNlsTables
*
\***********************************************************************/

ALLOC_SECTION_LDATA KBDNLSTABLES KbdNlsTables101a = {
    0,                      // OEM ID (0 = Microsoft)
    0,                      // Information
    1,                      // Number of VK_F entry
    VkToFuncTable_101a,     // Pointer to VK_F array
    0,                      // Number of MouseVk entry
    NULL                    // Pointer to MouseVk array
};

PKBDNLSTABLES KbdNlsLayerDescriptor(VOID)
{
    return &KbdNlsTables101a;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\fe_kbds\kor\101a\kbd101a.h ===
/****************************** Module Header ******************************\
* Module Name: kbd101.h
*
* Copyright (c) 1985-91, Microsoft Corporation
*
* Various defines for use by keyboard input code.
*
* History:
\***************************************************************************/

/*
 * kbd type should be controlled by cl command-line argument
 */
#define KBD_TYPE 10

/*
 * Include the basis of all keyboard table values
 */
#include "kbd.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\fe_kbds\kor\101b\kbd101b.h ===
/****************************** Module Header ******************************\
* Module Name: kbd101.h
*
* Copyright (c) 1985-91, Microsoft Corporation
*
* Various defines for use by keyboard input code.
*
* History:
\***************************************************************************/

/*
 * kbd type should be controlled by cl command-line argument
 */
#define KBD_TYPE 11

/*
 * Include the basis of all keyboard table values
 */
#include "kbd.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\fe_kbds\kor\101c\kbd101c.h ===
/****************************** Module Header ******************************\
* Module Name: kbd101.h
*
* Copyright (c) 1985-91, Microsoft Corporation
*
* Various defines for use by keyboard input code.
*
* History:
\***************************************************************************/

/*
 * kbd type should be controlled by cl command-line argument
 */
#define KBD_TYPE 12

/*
 * Include the basis of all keyboard table values
 */
#include "kbd.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\fe_kbds\kor\101a\sources.inc ===
!IF 0

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


!ENDIF

MINORCOMP=kbd101a

!include ..\..\korea.inc

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\fe_kbds\kor\101b\sources.inc ===
!IF 0

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


!ENDIF

MINORCOMP=kbd101b

!include ..\..\korea.inc

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\fe_kbds\kor\101b\kbd101b.c ===
/***************************************************************************\
* Module Name: kbd101b.c (Type B)
*
* Copyright (c) 1985-92, Microsoft Corporation
*
* Keyboard Type B :  Hangeul Toggle : Right Ctrl
*                    Junja   Toggle : Left  Alt + '='
*                    Hanja   Toggle : Right Alt
\***************************************************************************/

#include <windows.h>
#include <ime.h>
#include "vkoem.h"
#include "kbd101b.h"

#if defined(_M_IA64)
#pragma section(".data")
#define ALLOC_SECTION_LDATA __declspec(allocate(".data"))
#else
#pragma data_seg(".data")
#define ALLOC_SECTION_LDATA
#endif

/***************************************************************************\
* ausVK[] - Virtual Scan Code to Virtual Key conversion table for 101
\***************************************************************************/

static ALLOC_SECTION_LDATA USHORT ausVK[] = {
    T00, T01, T02, T03, T04, T05, T06, T07,
    T08, T09, T0A, T0B, T0C,

    /*
     * '='/'+' key must have KBDSPECIAL bit set (NLS key)
     */
    T0D | KBDSPECIAL,

                                  T0E, T0F,
    T10, T11, T12, T13, T14, T15, T16, T17,
    T18, T19, T1A, T1B, T1C, T1D, T1E, T1F,
    T20, T21, T22, T23, T24, T25, T26, T27,
    T28, T29, T2A, T2B, T2C, T2D, T2E, T2F,
    T30, T31, T32, T33, T34, T35,

    /*
     * Right-hand Shift key must have KBDEXT bit set.
     */
    T36 | KBDEXT,

    /*
     * '='/'+' key must have KBDSPECIAL bit set (NLS key)
     */
    T37 | KBDMULTIVK,

    T38, T39, T3A, T3B, T3C, T3D, T3E, T3F,
    T40, T41, T42, T43, T44,

    /*
     * NumLock Key:
     *     KBDEXT     - VK_NUMLOCK is an Extended key
     *     KBDMULTIVK - VK_NUMLOCK or VK_PAUSE (without or with CTRL)
     */
    T45 | KBDEXT | KBDMULTIVK,

    T46 | KBDMULTIVK,

    /*
     * Number Pad keys:
     *     KBDNUMPAD  - digits 0-9 and decimal point.
     *     KBDSPECIAL - require special processing by Windows
     */
    T47 | KBDNUMPAD | KBDSPECIAL,   // Numpad 7 (Home)
    T48 | KBDNUMPAD | KBDSPECIAL,   // Numpad 8 (Up),
    T49 | KBDNUMPAD | KBDSPECIAL,   // Numpad 9 (PgUp),
    T4A,
    T4B | KBDNUMPAD | KBDSPECIAL,   // Numpad 4 (Left),
    T4C | KBDNUMPAD | KBDSPECIAL,   // Numpad 5 (Clear),
    T4D | KBDNUMPAD | KBDSPECIAL,   // Numpad 6 (Right),
    T4E,
    T4F | KBDNUMPAD | KBDSPECIAL,   // Numpad 1 (End),
    T50 | KBDNUMPAD | KBDSPECIAL,   // Numpad 2 (Down),
    T51 | KBDNUMPAD | KBDSPECIAL,   // Numpad 3 (PgDn),
    T52 | KBDNUMPAD | KBDSPECIAL,   // Numpad 0 (Ins),
    T53 | KBDNUMPAD | KBDSPECIAL,   // Numpad . (Del),

    T54, T55, T56, T57, T58, T59, T5A, T5B,
    T5C, T5D, T5E, T5F, T60, T61, T62, T63,
    T64, T65, T66, T67, T68, T69, T6A, T6B,
    T6C, T6D, T6E, T6F, T70, T71, T72, T73,
    T74, T75, T76, T77, T78, T79, T7A, T7B,
    T7C, T7D, T7E, T7F

};

static ALLOC_SECTION_LDATA VSC_VK aE0VscToVk[] = {
        { 0x10, X10 | KBDEXT              },  // Speedracer: Previous Track
        { 0x19, X19 | KBDEXT              },  // Speedracer: Next Track
        { 0x1C, X1C | KBDEXT              },  // Numpad Enter
        { 0x1D, X1D | KBDEXT | KBDSPECIAL },  // RControl // Hanja key NLS key
        { 0x20, X20 | KBDEXT              },  // Speedracer: Volume Mute
        { 0x21, X21 | KBDEXT              },  // Speedracer: Launch App 2
        { 0x22, X22 | KBDEXT              },  // Speedracer: Media Play/Pause
        { 0x24, X24 | KBDEXT              },  // Speedracer: Media Stop
        { 0x2E, X2E | KBDEXT              },  // Speedracer: Volume Down
        { 0x30, X30 | KBDEXT              },  // Speedracer: Volume Up
        { 0x32, X32 | KBDEXT              },  // Speedracer: Browser Home
        { 0x35, X35 | KBDEXT              },  // Numpad Divide
        { 0x37, X37 | KBDEXT              },  // Snapshot
        { 0x38, X38 | KBDEXT | KBDSPECIAL },  // RMenu    // Hangeul key NLS key
        { 0x46, X46 | KBDEXT              },  // Break (Ctrl + Pause)
        { 0x47, X47 | KBDEXT              },  // Home
        { 0x48, X48 | KBDEXT              },  // Up
        { 0x49, X49 | KBDEXT              },  // Prior
        { 0x4B, X4B | KBDEXT              },  // Left
        { 0x4D, X4D | KBDEXT              },  // Right
        { 0x4F, X4F | KBDEXT              },  // End
        { 0x50, X50 | KBDEXT              },  // Down
        { 0x51, X51 | KBDEXT              },  // Next
        { 0x52, X52 | KBDEXT              },  // Insert
        { 0x53, X53 | KBDEXT              },  // Delete
        { 0x5B, X5B | KBDEXT              },  // Left Win
        { 0x5C, X5C | KBDEXT              },  // Right Win
        { 0x5D, X5D | KBDEXT              },  // Applications
        { 0x5F, X5F | KBDEXT              },  // Speedracer: Sleep
        { 0x65, X65 | KBDEXT              },  // Speedracer: Browser Search
        { 0x66, X66 | KBDEXT              },  // Speedracer: Browser Favorites
        { 0x67, X67 | KBDEXT              },  // Speedracer: Browser Refresh
        { 0x68, X68 | KBDEXT              },  // Speedracer: Browser Stop
        { 0x69, X69 | KBDEXT              },  // Speedracer: Browser Forward
        { 0x6A, X6A | KBDEXT              },  // Speedracer: Browser Back
        { 0x6B, X6B | KBDEXT              },  // Speedracer: Launch App 1
        { 0x6C, X6C | KBDEXT              },  // Speedracer: Launch Mail
        { 0x6D, X6D | KBDEXT              },  // Speedracer: Launch Media Selector
        { 0xF1, XF1 | KBDEXT | KBDSPECIAL },  // Hanja
        { 0xF2, XF2 | KBDEXT | KBDSPECIAL },  // Hangeul
        { 0,      0                       }
};

static ALLOC_SECTION_LDATA VSC_VK aE1VscToVk[] = {
        { 0x1D, Y1D                       },  // Pause
        { 0   ,   0                       }
};

/***************************************************************************\
* aVkToBits[]  - map Virtual Keys to Modifier Bits
*
* See kbd.h for a full description.
*
* US Keyboard has only three shifter keys:
*     SHIFT (L & R) affects alphabnumeric keys,
*     CTRL  (L & R) is used to generate control characters
*     ALT   (L & R) used for generating characters by number with numpad
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_BIT aVkToBits[] = {
    { VK_SHIFT,   KBDSHIFT },
    { VK_CONTROL, KBDCTRL  },
    { VK_MENU,    KBDALT   },
    { 0,          0        }
};

/***************************************************************************\
* aModification[]  - map character modifier bits to modification number
*
* See kbd.h for a full description.
*
\***************************************************************************/

static ALLOC_SECTION_LDATA MODIFIERS CharModifiers = {
    &aVkToBits[0],
    3,
    {
    //  Modification# //  Keys Pressed  : Explanation
    //  ============= // ============== : =============================
        0,            //                : unshifted characters
        1,            //          SHIFT : capitals, ~!@#$%^&*()_+{}:"<>? etc.
        2,            //     CTRL       : control characters
        3,            //     CTRL SHIFT :
                      // ALT            : invalid
                      // ALT      SHIFT : invalid
                      // ALT CTRL       : invalid
                      // ALT CTRL SHIFT : invalid
    }
};

/***************************************************************************\
*
* aVkToWch2[]  - Virtual Key to WCHAR translation for 2 shift states
* aVkToWch3[]  - Virtual Key to WCHAR translation for 3 shift states
* aVkToWch4[]  - Virtual Key to WCHAR translation for 4 shift states
*
* Table attributes: Unordered Scan, null-terminated
*
* Search this table for an entry with a matching Virtual Key to find the
* corresponding unshifted and shifted WCHAR characters.
*
* Reserved VirtualKey values (first column)
*     -1            - this line contains dead characters (diacritic)
*     0             - terminator
*
* Reserved Attribute values (second column)
*     CAPLOK        - CapsLock affects this key like Shift
*
* Reserved character values (third through last column)
*     WCH_NONE      - No character
*     WCH_DEAD      - Dead character (diacritic) value is in next line
*
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHARS2 aVkToWch2[] = {
    {'0'          , 0      ,'0'       ,')'       },
    {'1'          , 0      ,'1'       ,'!'       },
    {'3'          , 0      ,'3'       ,'#'       },
    {'4'          , 0      ,'4'       ,'$'       },
    {'5'          , 0      ,'5'       ,'%'       },
    {'7'          , 0      ,'7'       ,'&'       },
    {'8'          , 0      ,'8'       ,'*'       },
    {'9'          , 0      ,'9'       ,'('       },
    {'A'          , CAPLOK ,'a'       ,'A'       },
    {'B'          , CAPLOK ,'b'       ,'B'       },
    {'C'          , CAPLOK ,'c'       ,'C'       },
    {'D'          , CAPLOK ,'d'       ,'D'       },
    {'E'          , CAPLOK ,'e'       ,'E'       },
    {'F'          , CAPLOK ,'f'       ,'F'       },
    {'G'          , CAPLOK ,'g'       ,'G'       },
    {'H'          , CAPLOK ,'h'       ,'H'       },
    {'I'          , CAPLOK ,'i'       ,'I'       },
    {'J'          , CAPLOK ,'j'       ,'J'       },
    {'K'          , CAPLOK ,'k'       ,'K'       },
    {'L'          , CAPLOK ,'l'       ,'L'       },
    {'M'          , CAPLOK ,'m'       ,'M'       },
    {'N'          , CAPLOK ,'n'       ,'N'       },
    {'O'          , CAPLOK ,'o'       ,'O'       },
    {'P'          , CAPLOK ,'p'       ,'P'       },
    {'Q'          , CAPLOK ,'q'       ,'Q'       },
    {'R'          , CAPLOK ,'r'       ,'R'       },
    {'S'          , CAPLOK ,'s'       ,'S'       },
    {'T'          , CAPLOK ,'t'       ,'T'       },
    {'U'          , CAPLOK ,'u'       ,'U'       },
    {'V'          , CAPLOK ,'v'       ,'V'       },
    {'W'          , CAPLOK ,'w'       ,'W'       },
    {'X'          , CAPLOK ,'x'       ,'X'       },
    {'Y'          , CAPLOK ,'y'       ,'Y'       },
    {'Z'          , CAPLOK ,'z'       ,'Z'       },
    {VK_OEM_1     , 0      ,';'       ,':'       },
    {VK_OEM_2     , 0      ,'/'       ,'?'       },
    {VK_OEM_3     , 0      ,'`'       ,'~'       },
    {VK_OEM_7     , 0      ,0x27      ,'"'       },
    {VK_OEM_8     , 0      ,WCH_NONE  ,WCH_NONE  },
    {VK_OEM_COMMA , 0      ,','       ,'<'       },
    {VK_OEM_PERIOD, 0      ,'.'       ,'>'       },
    {VK_OEM_PLUS  , 0      ,'='       ,'+'       },
    {VK_TAB       , 0      ,'\t'      ,'\t'      },
    {VK_ADD       , 0      ,'+'       ,'+'       },
    {VK_DECIMAL   , 0      ,'.'       ,'.'       },
    {VK_DIVIDE    , 0      ,'/'       ,'/'       },
    {VK_MULTIPLY  , 0      ,'*'       ,'*'       },
    {VK_SUBTRACT  , 0      ,'-'       ,'-'       },
    {0            , 0      ,0         ,0         }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS3 aVkToWch3[] = {
    //                     |          |   SHIFT  |  CONTROL  |
    //                     |          |==========|===========|
    {VK_BACK      , 0      ,'\b'      ,'\b'      , 0x7f      },
    {VK_CANCEL    , 0      ,0x03      ,0x03      , 0x03      },
    {VK_ESCAPE    , 0      ,0x1b      ,0x1b      , 0x1b      },
    {VK_OEM_4     , 0      ,'['       ,'{'       , 0x1b      },
    {VK_OEM_5     , 0      ,'\\'      ,'|'       , 0x1c      },
    {VK_OEM_102   , 0      ,'\\'      ,'|'       , 0x1c      },
    {VK_OEM_6     , 0      ,']'       ,'}'       , 0x1d      },
    {VK_RETURN    , 0      ,'\r'      ,'\r'      , '\n'      },
    {VK_SPACE     , 0      ,' '       ,' '       , 0x20      },
    {0            , 0      ,0         ,0         , 0         }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch4[] = {
    //                     |          |   SHIFT  |  CONTROL  | SHFT+CTRL |
    //                     |          |==========|===========|===========|
    {'2'          , 0      ,'2'       ,'@'       , WCH_NONE  , 0x00      },
    {'6'          , 0      ,'6'       ,'^'       , WCH_NONE  , 0x1e      },
    {VK_OEM_MINUS , 0      ,'-'       ,'_'       , WCH_NONE  , 0x1f      },
    {0            , 0      ,0         ,0         , 0         , 0         }
};

// Put this last so that VkKeyScan interprets number characters
// as coming from the main section of the kbd (aVkToWch2 and
// aVkToWch4) before considering the numpad (aVkToWch1).

static ALLOC_SECTION_LDATA VK_TO_WCHARS1 aVkToWch1[] = {
    { VK_NUMPAD0   , 0      ,  '0'   },
    { VK_NUMPAD1   , 0      ,  '1'   },
    { VK_NUMPAD2   , 0      ,  '2'   },
    { VK_NUMPAD3   , 0      ,  '3'   },
    { VK_NUMPAD4   , 0      ,  '4'   },
    { VK_NUMPAD5   , 0      ,  '5'   },
    { VK_NUMPAD6   , 0      ,  '6'   },
    { VK_NUMPAD7   , 0      ,  '7'   },
    { VK_NUMPAD8   , 0      ,  '8'   },
    { VK_NUMPAD9   , 0      ,  '9'   },
    { 0            , 0      ,  '\0'  }   //null terminator
};

/***************************************************************************\
* aVkToWcharTable: table of pointers to Character Tables
*
* Describes the character tables and the order they should be searched.
*
* Note: the order determines the behavior of VkKeyScan() : this function
*       takes a character and attempts to find a Virtual Key and character-
*       modifier key combination that produces that character.  The table
*       containing the numeric keypad (aVkToWch1) must appear last so that
*       VkKeyScan('0') will be interpreted as one of keys from the main
*       section, not the numpad.  etc.
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHAR_TABLE aVkToWcharTable[] = {
    {  (PVK_TO_WCHARS1)aVkToWch3, 3, sizeof(aVkToWch3[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch4, 4, sizeof(aVkToWch4[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch2, 2, sizeof(aVkToWch2[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch1, 1, sizeof(aVkToWch1[0]) },  // must come last
    {                       NULL, 0, 0                    }
};

/***************************************************************************\
* aKeyNames[], aKeyNamesExt[]  - Scan Code -> Key Name tables
*
* For the GetKeyNameText() API function
*
* Tables for non-extended and extended (KBDEXT) keys.
* (Keys producing printable characters are named by the character itself)
\***************************************************************************/

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNames[] = {
    0x01,    L"Esc",
    0x0e,    L"Backspace",
    0x0f,    L"Tab",
    0x1c,    L"Enter",
    0x1d,    L"Ctrl",
    0x2a,    L"Shift",
    0x36,    L"Right Shift",
    0x37,    L"Num *",
    0x38,    L"Alt",
    0x39,    L"Space",
    0x3a,    L"Caps Lock",
    0x3b,    L"F1",
    0x3c,    L"F2",
    0x3d,    L"F3",
    0x3e,    L"F4",
    0x3f,    L"F5",
    0x40,    L"F6",
    0x41,    L"F7",
    0x42,    L"F8",
    0x43,    L"F9",
    0x44,    L"F10",
    0x45,    L"Pause",
    0x46,    L"Scroll Lock",
    0x47,    L"Num 7",
    0x48,    L"Num 8",
    0x49,    L"Num 9",
    0x4a,    L"Num -",
    0x4b,    L"Num 4",
    0x4c,    L"Num 5",
    0x4d,    L"Num 6",
    0x4e,    L"Num +",
    0x4f,    L"Num 1",
    0x50,    L"Num 2",
    0x51,    L"Num 3",
    0x52,    L"Num 0",
    0x53,    L"Num Del",
    0x54,    L"Sys Req",
    0x57,    L"F11",
    0x58,    L"F12",
    0x7C,    L"F13",
    0x7D,    L"F14",
    0x7E,    L"F15",
    0x7F,    L"F16",
    0x80,    L"F17",
    0x81,    L"F18",
    0x82,    L"F19",
    0x83,    L"F20",
    0x84,    L"F21",
    0x85,    L"F22",
    0x86,    L"F23",
    0x87,    L"F24",
    0   ,    NULL
};

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNamesExt[] = {
    0x1c,    L"Num Enter",
    0x1d,    L"Right Control",
    0x35,    L"Num /",
    0x37,    L"Prnt Scrn",
    0x38,    L"Right Alt",
    0x45,    L"Num Lock",
    0x46,    L"Break",
    0x47,    L"Home",
    0x48,    L"Up",
    0x49,    L"Page Up",
    0x4b,    L"Left",
    0x4d,    L"Right",
    0x4f,    L"End",
    0x50,    L"Down",
    0x51,    L"Page Down",
    0x52,    L"Insert",
    0x53,    L"Delete",
    0x5B,    L"Left Windows",
    0x5C,    L"Right Windows",
    0x5D,    L"Application",
    0xF1,    L"Hanja",
    0xF2,    L"Hangeul",
    0   ,    NULL
};

static ALLOC_SECTION_LDATA KBDTABLES KbdTables = {
    /*
     * Modifier keys
     */
    &CharModifiers,

    /*
     * Characters tables
     */
    aVkToWcharTable,

    /*
     * Diacritics  (none for US English)
     */
    NULL,

    /*
     * Names of Keys  (no dead keys)
     */
    aKeyNames,
    aKeyNamesExt,
    NULL,

    /*
     * Scan codes to Virtual Keys
     */
    ausVK,
    sizeof(ausVK) / sizeof(ausVK[0]),
    aE0VscToVk,
    aE1VscToVk,

    /*
     * No Locale-specific special processing
     */
    0,

    /*
     * No Ligatures
     */
    0, 0, NULL,

    /*
     * Type and subtype
     */
    KEYBOARD_TYPE_KOREA,
    MAKEWORD(MICROSOFT_KBD_101B_TYPE, NLSKBD_OEM_MICROSOFT),
};

PKBDTABLES KbdLayerDescriptor(VOID)
{
    return &KbdTables;
}

/***********************************************************************\
* VkToFuncTable_101b[]
*
\***********************************************************************/

static ALLOC_SECTION_LDATA VK_F VkToFuncTable_101b[] = {
    {
        VK_OEM_PLUS,           // Base Vk
        KBDNLS_TYPE_NORMAL,    // NLSFEProcType
        KBDNLS_INDEX_NORMAL,   // NLSFEProcCurrent
        0x0,                   // NLSFEProcSwitch
        {                      // NLSFEProcIndex
            {KBDNLS_SEND_BASE_VK,0},         // Base
            {KBDNLS_SEND_BASE_VK,0},         // Shift
            {KBDNLS_SEND_BASE_VK,0},         // Control
            {KBDNLS_SEND_BASE_VK,0},         // Shift+Control
            {KBDNLS_SEND_PARAM_VK,VK_JUNJA}, // Alt
            {KBDNLS_SEND_BASE_VK,0},         // Shift+Alt
            {KBDNLS_SEND_BASE_VK,0},         // Control+Alt
            {KBDNLS_SEND_BASE_VK,0}          // Shift+Control+Alt
        },
        {                           // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},                 // Base
            {KBDNLS_NULL,0},                 // Shift
            {KBDNLS_NULL,0},                 // Control
            {KBDNLS_NULL,0},                 // Shift+Control
            {KBDNLS_NULL,0},                 // Alt
            {KBDNLS_NULL,0},                 // Shift+Alt
            {KBDNLS_NULL,0},                 // Control+Alt
            {KBDNLS_NULL,0}                  // Shift+Control+Alt
        }
    }
};

/***********************************************************************\
* KbdNlsTables
*
\***********************************************************************/

static ALLOC_SECTION_LDATA KBDNLSTABLES KbdNlsTables = {
    0,                      // OEM ID (0 = Microsoft)
    0,                      // Information
    1,                      // Number of VK_F entry
    VkToFuncTable_101b,     // Pointer to VK_F array
    0,                      // Number of MouseVk entry
    NULL                    // Pointer to MouseVk array
};

PKBDNLSTABLES KbdNlsLayerDescriptor(VOID)
{
    return &KbdNlsTables;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\fe_kbds\kor\101c\kbd101c.c ===
/***************************************************************************\
* Module Name: kbd101c.c (Type C)
*
* Copyright (c) 1985-92, Microsoft Corporation
*
* Keyboard Type C :  Hangeul Toggle : Shift + ' '
*                    Junja   Toggle : Left  Alt + '='
*                    Hanja   Toggle : Control + ' '
\***************************************************************************/

#include <windows.h>
#include <ime.h>
#include "vkoem.h"
#include "kbd101c.h"

#if defined(_M_IA64)
#pragma section(".data")
#define ALLOC_SECTION_LDATA __declspec(allocate(".data"))
#else
#pragma data_seg(".data")
#define ALLOC_SECTION_LDATA
#endif

/***************************************************************************\
* ausVK[] - Virtual Scan Code to Virtual Key conversion table for 101
\***************************************************************************/

static ALLOC_SECTION_LDATA USHORT ausVK[] = {
    T00, T01, T02, T03, T04, T05, T06, T07,
    T08, T09, T0A, T0B, T0C,

    /*
     * '='/'+' key must have KBDSPECIAL bit set (NLS key)
     */
    T0D | KBDSPECIAL,

                                  T0E, T0F,
    T10, T11, T12, T13, T14, T15, T16, T17,
    T18, T19, T1A, T1B, T1C, T1D, T1E, T1F,
    T20, T21, T22, T23, T24, T25, T26, T27,
    T28, T29, T2A, T2B, T2C, T2D, T2E, T2F,
    T30, T31, T32, T33, T34, T35,

    /*
     * Right-hand Shift key must have KBDEXT bit set.
     */
    T36 | KBDEXT,

    /*
     * numpad_* + Shift/Alt -> SnapShot
     */
    T37 | KBDMULTIVK,

    T38,

    /*
     * ' ' key must have KBDSPECIAL bit set (NLS key)
     */
    T39 | KBDSPECIAL,

              T3A, T3B, T3C, T3D, T3E, T3F,
    T40, T41, T42, T43, T44,

    /*
     * NumLock Key:
     *     KBDEXT     - VK_NUMLOCK is an Extended key
     *     KBDMULTIVK - VK_NUMLOCK or VK_PAUSE (without or with CTRL)
     */
    T45 | KBDEXT | KBDMULTIVK,

    T46 | KBDMULTIVK,

    /*
     * Number Pad keys:
     *     KBDNUMPAD  - digits 0-9 and decimal point.
     *     KBDSPECIAL - require special processing by Windows
     */
    T47 | KBDNUMPAD | KBDSPECIAL,   // Numpad 7 (Home)
    T48 | KBDNUMPAD | KBDSPECIAL,   // Numpad 8 (Up),
    T49 | KBDNUMPAD | KBDSPECIAL,   // Numpad 9 (PgUp),
    T4A,
    T4B | KBDNUMPAD | KBDSPECIAL,   // Numpad 4 (Left),
    T4C | KBDNUMPAD | KBDSPECIAL,   // Numpad 5 (Clear),
    T4D | KBDNUMPAD | KBDSPECIAL,   // Numpad 6 (Right),
    T4E,
    T4F | KBDNUMPAD | KBDSPECIAL,   // Numpad 1 (End),
    T50 | KBDNUMPAD | KBDSPECIAL,   // Numpad 2 (Down),
    T51 | KBDNUMPAD | KBDSPECIAL,   // Numpad 3 (PgDn),
    T52 | KBDNUMPAD | KBDSPECIAL,   // Numpad 0 (Ins),
    T53 | KBDNUMPAD | KBDSPECIAL,   // Numpad . (Del),

    T54, T55, T56, T57, T58, T59, T5A, T5B,
    T5C, T5D, T5E, T5F, T60, T61, T62, T63,
    T64, T65, T66, T67, T68, T69, T6A, T6B,
    T6C, T6D, T6E, T6F, T70, T71, T72, T73,
    T74, T75, T76, T77, T78, T79, T7A, T7B,
    T7C, T7D, T7E, T7F

};

static ALLOC_SECTION_LDATA VSC_VK aE0VscToVk[] = {
        { 0x10, X10 | KBDEXT              },  // Speedracer: Previous Track
        { 0x19, X19 | KBDEXT              },  // Speedracer: Next Track
        { 0x1C, X1C | KBDEXT              },  // Numpad Enter
        { 0x1D, X1D | KBDEXT              },  // RControl
        { 0x20, X20 | KBDEXT              },  // Speedracer: Volume Mute
        { 0x21, X21 | KBDEXT              },  // Speedracer: Launch App 2
        { 0x22, X22 | KBDEXT              },  // Speedracer: Media Play/Pause
        { 0x24, X24 | KBDEXT              },  // Speedracer: Media Stop
        { 0x2E, X2E | KBDEXT              },  // Speedracer: Volume Down
        { 0x30, X30 | KBDEXT              },  // Speedracer: Volume Up
        { 0x32, X32 | KBDEXT              },  // Speedracer: Browser Home
        { 0x35, X35 | KBDEXT              },  // Numpad Divide
        { 0x37, X37 | KBDEXT              },  // Snapshot
        { 0x38, X38 | KBDEXT              },  // RMenu
        { 0x46, X46 | KBDEXT              },  // Break (Ctrl + Pause)
        { 0x47, X47 | KBDEXT              },  // Home
        { 0x48, X48 | KBDEXT              },  // Up
        { 0x49, X49 | KBDEXT              },  // Prior
        { 0x4B, X4B | KBDEXT              },  // Left
        { 0x4D, X4D | KBDEXT              },  // Right
        { 0x4F, X4F | KBDEXT              },  // End
        { 0x50, X50 | KBDEXT              },  // Down
        { 0x51, X51 | KBDEXT              },  // Next
        { 0x52, X52 | KBDEXT              },  // Insert
        { 0x53, X53 | KBDEXT              },  // Delete
        { 0x5B, X5B | KBDEXT              },  // Left Win
        { 0x5C, X5C | KBDEXT              },  // Right Win
        { 0x5D, X5D | KBDEXT              },  // Applications
        { 0x5F, X5F | KBDEXT              },  // Speedracer: Sleep
        { 0x65, X65 | KBDEXT              },  // Speedracer: Browser Search
        { 0x66, X66 | KBDEXT              },  // Speedracer: Browser Favorites
        { 0x67, X67 | KBDEXT              },  // Speedracer: Browser Refresh
        { 0x68, X68 | KBDEXT              },  // Speedracer: Browser Stop
        { 0x69, X69 | KBDEXT              },  // Speedracer: Browser Forward
        { 0x6A, X6A | KBDEXT              },  // Speedracer: Browser Back
        { 0x6B, X6B | KBDEXT              },  // Speedracer: Launch App 1
        { 0x6C, X6C | KBDEXT              },  // Speedracer: Launch Mail
        { 0x6D, X6D | KBDEXT              },  // Speedracer: Launch Media Selector
        { 0xF1, XF1 | KBDEXT | KBDSPECIAL },  // Hanja
        { 0xF2, XF2 | KBDEXT | KBDSPECIAL },  // Hangeul
        { 0,      0                       }
};

static ALLOC_SECTION_LDATA VSC_VK aE1VscToVk[] = {
        { 0x1D, Y1D                       },  // Pause
        { 0   ,   0                       }
};

/***************************************************************************\
* aVkToBits[]  - map Virtual Keys to Modifier Bits
*
* See kbd.h for a full description.
*
* US Keyboard has only three shifter keys:
*     SHIFT (L & R) affects alphabnumeric keys,
*     CTRL  (L & R) is used to generate control characters
*     ALT   (L & R) used for generating characters by number with numpad
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_BIT aVkToBits[] = {
    { VK_SHIFT,   KBDSHIFT },
    { VK_CONTROL, KBDCTRL  },
    { VK_MENU,    KBDALT   },
    { 0,          0        }
};

/***************************************************************************\
* aModification[]  - map character modifier bits to modification number
*
* See kbd.h for a full description.
*
\***************************************************************************/

static ALLOC_SECTION_LDATA MODIFIERS CharModifiers = {
    &aVkToBits[0],
    3,
    {
    //  Modification# //  Keys Pressed  : Explanation
    //  ============= // ============== : =============================
        0,            //                : unshifted characters
        1,            //          SHIFT : capitals, ~!@#$%^&*()_+{}:"<>? etc.
        2,            //     CTRL       : control characters
        3,            //     CTRL SHIFT :
                      // ALT            : invalid
                      // ALT      SHIFT : invalid
                      // ALT CTRL       : invalid
                      // ALT CTRL SHIFT : invalid
    }
};

/***************************************************************************\
*
* aVkToWch2[]  - Virtual Key to WCHAR translation for 2 shift states
* aVkToWch3[]  - Virtual Key to WCHAR translation for 3 shift states
* aVkToWch4[]  - Virtual Key to WCHAR translation for 4 shift states
*
* Table attributes: Unordered Scan, null-terminated
*
* Search this table for an entry with a matching Virtual Key to find the
* corresponding unshifted and shifted WCHAR characters.
*
* Reserved VirtualKey values (first column)
*     -1            - this line contains dead characters (diacritic)
*     0             - terminator
*
* Reserved Attribute values (second column)
*     CAPLOK        - CapsLock affects this key like Shift
*
* Reserved character values (third through last column)
*     WCH_NONE      - No character
*     WCH_DEAD      - Dead character (diacritic) value is in next line
*
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHARS2 aVkToWch2[] = {
    {'0'          , 0      ,'0'       ,')'       },
    {'1'          , 0      ,'1'       ,'!'       },
    {'3'          , 0      ,'3'       ,'#'       },
    {'4'          , 0      ,'4'       ,'$'       },
    {'5'          , 0      ,'5'       ,'%'       },
    {'7'          , 0      ,'7'       ,'&'       },
    {'8'          , 0      ,'8'       ,'*'       },
    {'9'          , 0      ,'9'       ,'('       },
    {'A'          , CAPLOK ,'a'       ,'A'       },
    {'B'          , CAPLOK ,'b'       ,'B'       },
    {'C'          , CAPLOK ,'c'       ,'C'       },
    {'D'          , CAPLOK ,'d'       ,'D'       },
    {'E'          , CAPLOK ,'e'       ,'E'       },
    {'F'          , CAPLOK ,'f'       ,'F'       },
    {'G'          , CAPLOK ,'g'       ,'G'       },
    {'H'          , CAPLOK ,'h'       ,'H'       },
    {'I'          , CAPLOK ,'i'       ,'I'       },
    {'J'          , CAPLOK ,'j'       ,'J'       },
    {'K'          , CAPLOK ,'k'       ,'K'       },
    {'L'          , CAPLOK ,'l'       ,'L'       },
    {'M'          , CAPLOK ,'m'       ,'M'       },
    {'N'          , CAPLOK ,'n'       ,'N'       },
    {'O'          , CAPLOK ,'o'       ,'O'       },
    {'P'          , CAPLOK ,'p'       ,'P'       },
    {'Q'          , CAPLOK ,'q'       ,'Q'       },
    {'R'          , CAPLOK ,'r'       ,'R'       },
    {'S'          , CAPLOK ,'s'       ,'S'       },
    {'T'          , CAPLOK ,'t'       ,'T'       },
    {'U'          , CAPLOK ,'u'       ,'U'       },
    {'V'          , CAPLOK ,'v'       ,'V'       },
    {'W'          , CAPLOK ,'w'       ,'W'       },
    {'X'          , CAPLOK ,'x'       ,'X'       },
    {'Y'          , CAPLOK ,'y'       ,'Y'       },
    {'Z'          , CAPLOK ,'z'       ,'Z'       },
    {VK_OEM_1     , 0      ,';'       ,':'       },
    {VK_OEM_2     , 0      ,'/'       ,'?'       },
    {VK_OEM_3     , 0      ,'`'       ,'~'       },
    {VK_OEM_7     , 0      ,0x27      ,'"'       },
    {VK_OEM_8     , 0      ,WCH_NONE  ,WCH_NONE  },
    {VK_OEM_COMMA , 0      ,','       ,'<'       },
    {VK_OEM_PERIOD, 0      ,'.'       ,'>'       },
    {VK_OEM_PLUS  , 0      ,'='       ,'+'       },
    {VK_TAB       , 0      ,'\t'      ,'\t'      },
    {VK_ADD       , 0      ,'+'       ,'+'       },
    {VK_DECIMAL   , 0      ,'.'       ,'.'       },
    {VK_DIVIDE    , 0      ,'/'       ,'/'       },
    {VK_MULTIPLY  , 0      ,'*'       ,'*'       },
    {VK_SUBTRACT  , 0      ,'-'       ,'-'       },
    {0            , 0      ,0         ,0         }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS3 aVkToWch3[] = {
    //                     |          |   SHIFT  |  CONTROL  |
    //                     |          |==========|===========|
    {VK_BACK      , 0      ,'\b'      ,'\b'      , 0x7f      },
    {VK_CANCEL    , 0      ,0x03      ,0x03      , 0x03      },
    {VK_ESCAPE    , 0      ,0x1b      ,0x1b      , 0x1b      },
    {VK_OEM_4     , 0      ,'['       ,'{'       , 0x1b      },
    {VK_OEM_5     , 0      ,'\\'      ,'|'       , 0x1c      },
    {VK_OEM_102   , 0      ,'\\'      ,'|'       , 0x1c      },
    {VK_OEM_6     , 0      ,']'       ,'}'       , 0x1d      },
    {VK_RETURN    , 0      ,'\r'      ,'\r'      , '\n'      },
    {VK_SPACE     , 0      ,' '       ,' '       , 0x20      },
    {0            , 0      ,0         ,0         , 0         }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch4[] = {
    //                     |          |   SHIFT  |  CONTROL  | SHFT+CTRL |
    //                     |          |==========|===========|===========|
    {'2'          , 0      ,'2'       ,'@'       , WCH_NONE  , 0x00      },
    {'6'          , 0      ,'6'       ,'^'       , WCH_NONE  , 0x1e      },
    {VK_OEM_MINUS , 0      ,'-'       ,'_'       , WCH_NONE  , 0x1f      },
    {0            , 0      ,0         ,0         , 0         , 0         }
};

// Put this last so that VkKeyScan interprets number characters
// as coming from the main section of the kbd (aVkToWch2 and
// aVkToWch4) before considering the numpad (aVkToWch1).

static ALLOC_SECTION_LDATA VK_TO_WCHARS1 aVkToWch1[] = {
    { VK_NUMPAD0   , 0      ,  '0'   },
    { VK_NUMPAD1   , 0      ,  '1'   },
    { VK_NUMPAD2   , 0      ,  '2'   },
    { VK_NUMPAD3   , 0      ,  '3'   },
    { VK_NUMPAD4   , 0      ,  '4'   },
    { VK_NUMPAD5   , 0      ,  '5'   },
    { VK_NUMPAD6   , 0      ,  '6'   },
    { VK_NUMPAD7   , 0      ,  '7'   },
    { VK_NUMPAD8   , 0      ,  '8'   },
    { VK_NUMPAD9   , 0      ,  '9'   },
    { 0            , 0      ,  '\0'  }   //null terminator
};

/***************************************************************************\
* aVkToWcharTable: table of pointers to Character Tables
*
* Describes the character tables and the order they should be searched.
*
* Note: the order determines the behavior of VkKeyScan() : this function
*       takes a character and attempts to find a Virtual Key and character-
*       modifier key combination that produces that character.  The table
*       containing the numeric keypad (aVkToWch1) must appear last so that
*       VkKeyScan('0') will be interpreted as one of keys from the main
*       section, not the numpad.  etc.
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHAR_TABLE aVkToWcharTable[] = {
    {  (PVK_TO_WCHARS1)aVkToWch3, 3, sizeof(aVkToWch3[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch4, 4, sizeof(aVkToWch4[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch2, 2, sizeof(aVkToWch2[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch1, 1, sizeof(aVkToWch1[0]) },  // must come last
    {                       NULL, 0, 0                    }
};

/***************************************************************************\
* aKeyNames[], aKeyNamesExt[]  - Scan Code -> Key Name tables
*
* For the GetKeyNameText() API function
*
* Tables for non-extended and extended (KBDEXT) keys.
* (Keys producing printable characters are named by the character itself)
\***************************************************************************/

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNames[] = {
    0x01,    L"Esc",
    0x0e,    L"Backspace",
    0x0f,    L"Tab",
    0x1c,    L"Enter",
    0x1d,    L"Ctrl",
    0x2a,    L"Shift",
    0x36,    L"Right Shift",
    0x37,    L"Num *",
    0x38,    L"Alt",
    0x39,    L"Space",
    0x3a,    L"Caps Lock",
    0x3b,    L"F1",
    0x3c,    L"F2",
    0x3d,    L"F3",
    0x3e,    L"F4",
    0x3f,    L"F5",
    0x40,    L"F6",
    0x41,    L"F7",
    0x42,    L"F8",
    0x43,    L"F9",
    0x44,    L"F10",
    0x45,    L"Pause",
    0x46,    L"Scroll Lock",
    0x47,    L"Num 7",
    0x48,    L"Num 8",
    0x49,    L"Num 9",
    0x4a,    L"Num -",
    0x4b,    L"Num 4",
    0x4c,    L"Num 5",
    0x4d,    L"Num 6",
    0x4e,    L"Num +",
    0x4f,    L"Num 1",
    0x50,    L"Num 2",
    0x51,    L"Num 3",
    0x52,    L"Num 0",
    0x53,    L"Num Del",
    0x54,    L"Sys Req",
    0x57,    L"F11",
    0x58,    L"F12",
    0x7C,    L"F13",
    0x7D,    L"F14",
    0x7E,    L"F15",
    0x7F,    L"F16",
    0x80,    L"F17",
    0x81,    L"F18",
    0x82,    L"F19",
    0x83,    L"F20",
    0x84,    L"F21",
    0x85,    L"F22",
    0x86,    L"F23",
    0x87,    L"F24",
    0   ,    NULL
};

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNamesExt[] = {
    0x1c,    L"Num Enter",
    0x1d,    L"Right Control",
    0x35,    L"Num /",
    0x37,    L"Prnt Scrn",
    0x38,    L"Right Alt",
    0x45,    L"Num Lock",
    0x46,    L"Break",
    0x47,    L"Home",
    0x48,    L"Up",
    0x49,    L"Page Up",
    0x4b,    L"Left",
    0x4d,    L"Right",
    0x4f,    L"End",
    0x50,    L"Down",
    0x51,    L"Page Down",
    0x52,    L"Insert",
    0x53,    L"Delete",
    0x5B,    L"Left Windows",
    0x5C,    L"Right Windows",
    0x5D,    L"Application",
    0xF1,    L"Hanja",
    0xF2,    L"Hangeul",
    0   ,    NULL
};

static ALLOC_SECTION_LDATA KBDTABLES KbdTables = {
    /*
     * Modifier keys
     */
    &CharModifiers,

    /*
     * Characters tables
     */
    aVkToWcharTable,

    /*
     * Diacritics  (none for US English)
     */
    NULL,

    /*
     * Names of Keys  (no dead keys)
     */
    aKeyNames,
    aKeyNamesExt,
    NULL,

    /*
     * Scan codes to Virtual Keys
     */
    ausVK,
    sizeof(ausVK) / sizeof(ausVK[0]),
    aE0VscToVk,
    aE1VscToVk,

    /*
     * No Locale-specific special processing
     */
    0,

    /*
     * No Ligatures
     */
    0, 0, NULL,

    /*
     * Type and subtype
     */
    KEYBOARD_TYPE_KOREA,
    MAKEWORD(MICROSOFT_KBD_101C_TYPE, NLSKBD_OEM_MICROSOFT),
};

PKBDTABLES KbdLayerDescriptor(VOID)
{
    return &KbdTables;
}

/***********************************************************************\
* VkToFuncTable_101c[]
*
\***********************************************************************/

static ALLOC_SECTION_LDATA VK_F VkToFuncTable_101c[] = {
    {
        VK_OEM_PLUS,           // Base Vk
        KBDNLS_TYPE_NORMAL,    // NLSFEProcType
        KBDNLS_INDEX_NORMAL,   // NLSFEProcCurrent
        0x0,                   // NLSFEProcSwitch
        {                      // NLSFEProcIndex
            {KBDNLS_SEND_BASE_VK,0},         // Base
            {KBDNLS_SEND_BASE_VK,0},         // Shift
            {KBDNLS_SEND_BASE_VK,0},         // Control
            {KBDNLS_SEND_BASE_VK,0},         // Shift+Control
            {KBDNLS_SEND_PARAM_VK,VK_JUNJA}, // Alt
            {KBDNLS_SEND_BASE_VK,0},         // Shift+Alt
            {KBDNLS_SEND_BASE_VK,0},         // Control+Alt
            {KBDNLS_SEND_BASE_VK,0}          // Shift+Control+Alt
        },
        {                           // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},                 // Base
            {KBDNLS_NULL,0},                 // Shift
            {KBDNLS_NULL,0},                 // Control
            {KBDNLS_NULL,0},                 // Shift+Control
            {KBDNLS_NULL,0},                 // Alt
            {KBDNLS_NULL,0},                 // Shift+Alt
            {KBDNLS_NULL,0},                 // Control+Alt
            {KBDNLS_NULL,0}                  // Shift+Control+Alt
        }
    },
    {
        VK_SPACE,              // Base Vk
        KBDNLS_TYPE_NORMAL,    // NLSFEProcType
        KBDNLS_INDEX_NORMAL,   // NLSFEProcCurrent
        0x0,                   // NLSFEProcSwitch
        {                      // NLSFEProcIndex
            {KBDNLS_SEND_BASE_VK,0},           // Base
            {KBDNLS_SEND_PARAM_VK,VK_HANGEUL}, // Shift
            {KBDNLS_SEND_PARAM_VK,VK_HANJA},   // Control
            {KBDNLS_SEND_BASE_VK,0},           // Shift+Control
            {KBDNLS_SEND_BASE_VK,0},           // Alt
            {KBDNLS_SEND_BASE_VK,0},           // Shift+Alt
            {KBDNLS_SEND_BASE_VK,0},           // Control+Alt
            {KBDNLS_SEND_BASE_VK,0}            // Shift+Control+Alt
        },
        {                           // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},                   // Base
            {KBDNLS_NULL,0},                   // Shift
            {KBDNLS_NULL,0},                   // Control
            {KBDNLS_NULL,0},                   // Shift+Control
            {KBDNLS_NULL,0},                   // Alt
            {KBDNLS_NULL,0},                   // Shift+Alt
            {KBDNLS_NULL,0},                   // Control+Alt
            {KBDNLS_NULL,0}                    // Shift+Control+Alt
        }
    }
};

/***********************************************************************\
* KbdNlsTables
*
\***********************************************************************/

static ALLOC_SECTION_LDATA KBDNLSTABLES KbdNlsTables = {
    0,                      // OEM ID (0 = Microsoft)
    0,                      // Information
    2,                      // Number of VK_F entry
    VkToFuncTable_101c,     // Pointer to VK_F array
    0,                      // Number of MouseVk entry
    NULL                    // Pointer to MouseVk array
};

PKBDNLSTABLES KbdNlsLayerDescriptor(VOID)
{
    return &KbdNlsTables;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\fe_kbds\kor\103\kbd103.h ===
/****************************** Module Header ******************************\
* Module Name: kbd101.h
*
* Copyright (c) 1985-91, Microsoft Corporation
*
* Various defines for use by keyboard input code.
*
* History:
\***************************************************************************/

/*
 * kbd type should be controlled by cl command-line argument
 */
#define KBD_TYPE 13

/*
 * Include the basis of all keyboard table values
 */
#include "kbd.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\fe_kbds\kor\103\kbd103.c ===
/***************************************************************************\
* Module Name: kbd103.c
*
* Copyright (c) 1985-92, Microsoft Corporation
*
* Keyboard Type * :  Hangeul Toggle : Hangeul Key
*                    Junja   Toggle : Left  Alt + '='
*                    Hanja   Toggle : Hanja Key
* History: 8/19/94 ported by MSCH bklee
\***************************************************************************/

#include <windows.h>
#include <ime.h>
#include "vkoem.h"
#include "kbd103.h"

#if defined(_M_IA64)
#pragma section(".data")
#define ALLOC_SECTION_LDATA __declspec(allocate(".data"))
#else
#pragma data_seg(".data")
#define ALLOC_SECTION_LDATA
#endif

/***************************************************************************\
* ausVK[] - Virtual Scan Code to Virtual Key conversion table for 103
\***************************************************************************/

static ALLOC_SECTION_LDATA USHORT ausVK[] = {
    T00, T01, T02, T03, T04, T05, T06, T07,
    T08, T09, T0A, T0B, T0C,

    /*
     * '='/'+' key must have KBDSPECIAL bit set (NLS key)
     */
    T0D | KBDSPECIAL,

                                  T0E, T0F,
    T10, T11, T12, T13, T14, T15, T16, T17,
    T18, T19, T1A, T1B, T1C, T1D, T1E, T1F,
    T20, T21, T22, T23, T24, T25, T26, T27,
    T28, T29, T2A, T2B, T2C, T2D, T2E, T2F,
    T30, T31, T32, T33, T34, T35,

    /*
     * Right-hand Shift key must have KBDEXT bit set.
     */
    T36 | KBDEXT,

    /*
     * numpad_* + Shift/Alt -> SnapShot
     */
    T37 | KBDMULTIVK,

    T38, T39, T3A, T3B, T3C, T3D, T3E, T3F,
    T40, T41, T42, T43, T44,

    /*
     * NumLock Key:
     *     KBDEXT     - VK_NUMLOCK is an Extended key
     *     KBDMULTIVK - VK_NUMLOCK or VK_PAUSE (without or with CTRL)
     */
    T45 | KBDEXT | KBDMULTIVK,

    T46 | KBDMULTIVK,

    /*
     * Number Pad keys:
     *     KBDNUMPAD  - digits 0-9 and decimal point.
     *     KBDSPECIAL - require special processing by Windows
     */
    T47 | KBDNUMPAD | KBDSPECIAL,   // Numpad 7 (Home)
    T48 | KBDNUMPAD | KBDSPECIAL,   // Numpad 8 (Up),
    T49 | KBDNUMPAD | KBDSPECIAL,   // Numpad 9 (PgUp),
    T4A,
    T4B | KBDNUMPAD | KBDSPECIAL,   // Numpad 4 (Left),
    T4C | KBDNUMPAD | KBDSPECIAL,   // Numpad 5 (Clear),
    T4D | KBDNUMPAD | KBDSPECIAL,   // Numpad 6 (Right),
    T4E,
    T4F | KBDNUMPAD | KBDSPECIAL,   // Numpad 1 (End),
    T50 | KBDNUMPAD | KBDSPECIAL,   // Numpad 2 (Down),
    T51 | KBDNUMPAD | KBDSPECIAL,   // Numpad 3 (PgDn),
    T52 | KBDNUMPAD | KBDSPECIAL,   // Numpad 0 (Ins),
    T53 | KBDNUMPAD | KBDSPECIAL,   // Numpad . (Del),

    T54, T55, T56, T57, T58, T59, T5A, T5B,
    T5C, T5D, T5E, T5F, T60, T61, T62, T63,
    T64, T65, T66, T67, T68, T69, T6A, T6B,
    T6C, T6D, T6E, T6F, T70, T71, T72, T73,
    T74, T75, T76, T77, T78, T79, T7A, T7B,
    T7C, T7D, T7E, T7F

};

static ALLOC_SECTION_LDATA VSC_VK aE0VscToVk[] = {
        { 0x10, X10 | KBDEXT              },  // Speedracer: Previous Track
        { 0x19, X19 | KBDEXT              },  // Speedracer: Next Track
        { 0x1C, X1C | KBDEXT              },  // Numpad Enter
        { 0x1D, X1D | KBDEXT              },  // RControl
        { 0x20, X20 | KBDEXT              },  // Speedracer: Volume Mute
        { 0x21, X21 | KBDEXT              },  // Speedracer: Launch App 2
        { 0x22, X22 | KBDEXT              },  // Speedracer: Media Play/Pause
        { 0x24, X24 | KBDEXT              },  // Speedracer: Media Stop
        { 0x2E, X2E | KBDEXT              },  // Speedracer: Volume Down
        { 0x30, X30 | KBDEXT              },  // Speedracer: Volume Up
        { 0x32, X32 | KBDEXT              },  // Speedracer: Browser Home
        { 0x35, X35 | KBDEXT              },  // Numpad Divide
        { 0x37, X37 | KBDEXT              },  // Snapshot
        { 0x38, X38 | KBDEXT              },  // RMenu
        { 0x46, X46 | KBDEXT              },  // Break (Ctrl + Pause)
        { 0x47, X47 | KBDEXT              },  // Home
        { 0x48, X48 | KBDEXT              },  // Up
        { 0x49, X49 | KBDEXT              },  // Prior
        { 0x4B, X4B | KBDEXT              },  // Left
        { 0x4D, X4D | KBDEXT              },  // Right
        { 0x4F, X4F | KBDEXT              },  // End
        { 0x50, X50 | KBDEXT              },  // Down
        { 0x51, X51 | KBDEXT              },  // Next
        { 0x52, X52 | KBDEXT              },  // Insert
        { 0x53, X53 | KBDEXT              },  // Delete
        { 0x5B, X5B | KBDEXT              },  // Left Win
        { 0x5C, X5C | KBDEXT              },  // Right Win
        { 0x5D, X5D | KBDEXT              },  // Applications
        { 0x5F, X5F | KBDEXT              },  // Speedracer: Sleep
        { 0x65, X65 | KBDEXT              },  // Speedracer: Browser Search
        { 0x66, X66 | KBDEXT              },  // Speedracer: Browser Favorites
        { 0x67, X67 | KBDEXT              },  // Speedracer: Browser Refresh
        { 0x68, X68 | KBDEXT              },  // Speedracer: Browser Stop
        { 0x69, X69 | KBDEXT              },  // Speedracer: Browser Forward
        { 0x6A, X6A | KBDEXT              },  // Speedracer: Browser Back
        { 0x6B, X6B | KBDEXT              },  // Speedracer: Launch App 1
        { 0x6C, X6C | KBDEXT              },  // Speedracer: Launch Mail
        { 0x6D, X6D | KBDEXT              },  // Speedracer: Launch Media Selector
        { 0xF1, XF1 | KBDEXT | KBDSPECIAL },  // Hanja
        { 0xF2, XF2 | KBDEXT | KBDSPECIAL },  // Hangeul
        { 0,      0                       }
};

static ALLOC_SECTION_LDATA VSC_VK aE1VscToVk[] = {
        { 0x1D, Y1D                       },  // Pause
        { 0   ,   0                       }
};

/***************************************************************************\
* aVkToBits[]  - map Virtual Keys to Modifier Bits
*
* See kbd.h for a full description.
*
* US Keyboard has only three shifter keys:
*     SHIFT (L & R) affects alphabnumeric keys,
*     CTRL  (L & R) is used to generate control characters
*     ALT   (L & R) used for generating characters by number with numpad
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_BIT aVkToBits[] = {
    { VK_SHIFT,   KBDSHIFT },
    { VK_CONTROL, KBDCTRL  },
    { VK_MENU,    KBDALT   },
    { 0,          0        }
};

/***************************************************************************\
* aModification[]  - map character modifier bits to modification number
*
* See kbd.h for a full description.
*
\***************************************************************************/

static ALLOC_SECTION_LDATA MODIFIERS CharModifiers = {
    &aVkToBits[0],
    3,
    {
    //  Modification# //  Keys Pressed  : Explanation
    //  ============= // ============== : =============================
        0,            //                : unshifted characters
        1,            //          SHIFT : capitals, ~!@#$%^&*()_+{}:"<>? etc.
        2,            //     CTRL       : control characters
        3,            //     CTRL SHIFT :
                      // ALT            : invalid
                      // ALT      SHIFT : invalid
                      // ALT CTRL       : invalid
                      // ALT CTRL SHIFT : invalid
    }
};

/***************************************************************************\
*
* aVkToWch2[]  - Virtual Key to WCHAR translation for 2 shift states
* aVkToWch3[]  - Virtual Key to WCHAR translation for 3 shift states
* aVkToWch4[]  - Virtual Key to WCHAR translation for 4 shift states
*
* Table attributes: Unordered Scan, null-terminated
*
* Search this table for an entry with a matching Virtual Key to find the
* corresponding unshifted and shifted WCHAR characters.
*
* Reserved VirtualKey values (first column)
*     -1            - this line contains dead characters (diacritic)
*     0             - terminator
*
* Reserved Attribute values (second column)
*     CAPLOK        - CapsLock affects this key like Shift
*
* Reserved character values (third through last column)
*     WCH_NONE      - No character
*     WCH_DEAD      - Dead character (diacritic) value is in next line
*
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHARS2 aVkToWch2[] = {
    {'0'          , 0      ,'0'       ,')'       },
    {'1'          , 0      ,'1'       ,'!'       },
    {'3'          , 0      ,'3'       ,'#'       },
    {'4'          , 0      ,'4'       ,'$'       },
    {'5'          , 0      ,'5'       ,'%'       },
    {'7'          , 0      ,'7'       ,'&'       },
    {'8'          , 0      ,'8'       ,'*'       },
    {'9'          , 0      ,'9'       ,'('       },
    {'A'          , CAPLOK ,'a'       ,'A'       },
    {'B'          , CAPLOK ,'b'       ,'B'       },
    {'C'          , CAPLOK ,'c'       ,'C'       },
    {'D'          , CAPLOK ,'d'       ,'D'       },
    {'E'          , CAPLOK ,'e'       ,'E'       },
    {'F'          , CAPLOK ,'f'       ,'F'       },
    {'G'          , CAPLOK ,'g'       ,'G'       },
    {'H'          , CAPLOK ,'h'       ,'H'       },
    {'I'          , CAPLOK ,'i'       ,'I'       },
    {'J'          , CAPLOK ,'j'       ,'J'       },
    {'K'          , CAPLOK ,'k'       ,'K'       },
    {'L'          , CAPLOK ,'l'       ,'L'       },
    {'M'          , CAPLOK ,'m'       ,'M'       },
    {'N'          , CAPLOK ,'n'       ,'N'       },
    {'O'          , CAPLOK ,'o'       ,'O'       },
    {'P'          , CAPLOK ,'p'       ,'P'       },
    {'Q'          , CAPLOK ,'q'       ,'Q'       },
    {'R'          , CAPLOK ,'r'       ,'R'       },
    {'S'          , CAPLOK ,'s'       ,'S'       },
    {'T'          , CAPLOK ,'t'       ,'T'       },
    {'U'          , CAPLOK ,'u'       ,'U'       },
    {'V'          , CAPLOK ,'v'       ,'V'       },
    {'W'          , CAPLOK ,'w'       ,'W'       },
    {'X'          , CAPLOK ,'x'       ,'X'       },
    {'Y'          , CAPLOK ,'y'       ,'Y'       },
    {'Z'          , CAPLOK ,'z'       ,'Z'       },
    {VK_OEM_1     , 0      ,';'       ,':'       },
    {VK_OEM_2     , 0      ,'/'       ,'?'       },
    {VK_OEM_3     , 0      ,'`'       ,'~'       },
    {VK_OEM_7     , 0      ,0x27      ,'"'       },
    {VK_OEM_8     , 0      ,WCH_NONE  ,WCH_NONE  },
    {VK_OEM_COMMA , 0      ,','       ,'<'       },
    {VK_OEM_PERIOD, 0      ,'.'       ,'>'       },
    {VK_OEM_PLUS  , 0      ,'='       ,'+'       },
    {VK_TAB       , 0      ,'\t'      ,'\t'      },
    {VK_ADD       , 0      ,'+'       ,'+'       },
    {VK_DECIMAL   , 0      ,'.'       ,'.'       },
    {VK_DIVIDE    , 0      ,'/'       ,'/'       },
    {VK_MULTIPLY  , 0      ,'*'       ,'*'       },
    {VK_SUBTRACT  , 0      ,'-'       ,'-'       },
    {0            , 0      ,0         ,0         }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS3 aVkToWch3[] = {
    //                     |          |   SHIFT  |  CONTROL  |
    //                     |          |==========|===========|
    {VK_BACK      , 0      ,'\b'      ,'\b'      , 0x7f      },
    {VK_CANCEL    , 0      ,0x03      ,0x03      , 0x03      },
    {VK_ESCAPE    , 0      ,0x1b      ,0x1b      , 0x1b      },
    {VK_OEM_4     , 0      ,'['       ,'{'       , 0x1b      },
    {VK_OEM_5     , 0      ,'\\'      ,'|'       , 0x1c      },
    {VK_OEM_102   , 0      ,'\\'      ,'|'       , 0x1c      },
    {VK_OEM_6     , 0      ,']'       ,'}'       , 0x1d      },
    {VK_RETURN    , 0      ,'\r'      ,'\r'      , '\n'      },
    {VK_SPACE     , 0      ,' '       ,' '       , 0x20      },
    {0            , 0      ,0         ,0         , 0         }
};

static ALLOC_SECTION_LDATA VK_TO_WCHARS4 aVkToWch4[] = {
    //                     |          |   SHIFT  |  CONTROL  | SHFT+CTRL |
    //                     |          |==========|===========|===========|
    {'2'          , 0      ,'2'       ,'@'       , WCH_NONE  , 0x00      },
    {'6'          , 0      ,'6'       ,'^'       , WCH_NONE  , 0x1e      },
    {VK_OEM_MINUS , 0      ,'-'       ,'_'       , WCH_NONE  , 0x1f      },
    {0            , 0      ,0         ,0         , 0         , 0         }
};

// Put this last so that VkKeyScan interprets number characters
// as coming from the main section of the kbd (aVkToWch2 and
// aVkToWch4) before considering the numpad (aVkToWch1).

static ALLOC_SECTION_LDATA VK_TO_WCHARS1 aVkToWch1[] = {
    { VK_NUMPAD0   , 0      ,  '0'   },
    { VK_NUMPAD1   , 0      ,  '1'   },
    { VK_NUMPAD2   , 0      ,  '2'   },
    { VK_NUMPAD3   , 0      ,  '3'   },
    { VK_NUMPAD4   , 0      ,  '4'   },
    { VK_NUMPAD5   , 0      ,  '5'   },
    { VK_NUMPAD6   , 0      ,  '6'   },
    { VK_NUMPAD7   , 0      ,  '7'   },
    { VK_NUMPAD8   , 0      ,  '8'   },
    { VK_NUMPAD9   , 0      ,  '9'   },
    { 0            , 0      ,  '\0'  }   //null terminator
};

/***************************************************************************\
* aVkToWcharTable: table of pointers to Character Tables
*
* Describes the character tables and the order they should be searched.
*
* Note: the order determines the behavior of VkKeyScan() : this function
*       takes a character and attempts to find a Virtual Key and character-
*       modifier key combination that produces that character.  The table
*       containing the numeric keypad (aVkToWch1) must appear last so that
*       VkKeyScan('0') will be interpreted as one of keys from the main
*       section, not the numpad.  etc.
\***************************************************************************/

static ALLOC_SECTION_LDATA VK_TO_WCHAR_TABLE aVkToWcharTable[] = {
    {  (PVK_TO_WCHARS1)aVkToWch3, 3, sizeof(aVkToWch3[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch4, 4, sizeof(aVkToWch4[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch2, 2, sizeof(aVkToWch2[0]) },
    {  (PVK_TO_WCHARS1)aVkToWch1, 1, sizeof(aVkToWch1[0]) },  // must come last
    {                       NULL, 0, 0                    }
};

/***************************************************************************\
* aKeyNames[], aKeyNamesExt[]  - Scan Code -> Key Name tables
*
* For the GetKeyNameText() API function
*
* Tables for non-extended and extended (KBDEXT) keys.
* (Keys producing printable characters are named by the character itself)
\***************************************************************************/

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNames[] = {
    0x01,    L"Esc",
    0x0e,    L"Backspace",
    0x0f,    L"Tab",
    0x1c,    L"Enter",
    0x1d,    L"Ctrl",
    0x2a,    L"Shift",
    0x36,    L"Right Shift",
    0x37,    L"Num *",
    0x38,    L"Alt",
    0x39,    L"Space",
    0x3a,    L"Caps Lock",
    0x3b,    L"F1",
    0x3c,    L"F2",
    0x3d,    L"F3",
    0x3e,    L"F4",
    0x3f,    L"F5",
    0x40,    L"F6",
    0x41,    L"F7",
    0x42,    L"F8",
    0x43,    L"F9",
    0x44,    L"F10",
    0x45,    L"Pause",
    0x46,    L"Scroll Lock",
    0x47,    L"Num 7",
    0x48,    L"Num 8",
    0x49,    L"Num 9",
    0x4a,    L"Num -",
    0x4b,    L"Num 4",
    0x4c,    L"Num 5",
    0x4d,    L"Num 6",
    0x4e,    L"Num +",
    0x4f,    L"Num 1",
    0x50,    L"Num 2",
    0x51,    L"Num 3",
    0x52,    L"Num 0",
    0x53,    L"Num Del",
    0x54,    L"Sys Req",
    0x57,    L"F11",
    0x58,    L"F12",
    0x7C,    L"F13",
    0x7D,    L"F14",
    0x7E,    L"F15",
    0x7F,    L"F16",
    0x80,    L"F17",
    0x81,    L"F18",
    0x82,    L"F19",
    0x83,    L"F20",
    0x84,    L"F21",
    0x85,    L"F22",
    0x86,    L"F23",
    0x87,    L"F24",
    0   ,    NULL
};

static ALLOC_SECTION_LDATA VSC_LPWSTR aKeyNamesExt[] = {
    0x1c,    L"Num Enter",
    0x1d,    L"Right Control",
    0x35,    L"Num /",
    0x37,    L"Prnt Scrn",
    0x38,    L"Right Alt",
    0x45,    L"Num Lock",
    0x46,    L"Break",
    0x47,    L"Home",
    0x48,    L"Up",
    0x49,    L"Page Up",
    0x4b,    L"Left",
    0x4d,    L"Right",
    0x4f,    L"End",
    0x50,    L"Down",
    0x51,    L"Page Down",
    0x52,    L"Insert",
    0x53,    L"Delete",
    0x5B,    L"Left Windows",
    0x5C,    L"Right Windows",
    0x5D,    L"Application",
    0xf1,    L"Hanja",
    0xf2,    L"Hangeul",
    0   ,    NULL
};

ALLOC_SECTION_LDATA KBDTABLES KbdTables103 = {
    /*
     * Modifier keys
     */
    &CharModifiers,

    /*
     * Characters tables
     */
    aVkToWcharTable,

    /*
     * Diacritics  (none for US English)
     */
    NULL,

    /*
     * Names of Keys  (no dead keys)
     */
    aKeyNames,
    aKeyNamesExt,
    NULL,

    /*
     * Scan codes to Virtual Keys
     */
    ausVK,
    sizeof(ausVK) / sizeof(ausVK[0]),
    aE0VscToVk,
    aE1VscToVk,

    /*
     * No Locale-specific special processing
     */
    0,

    /*
     * No Ligatures
     */
    0, 0, NULL,

    /*
     * Type and subtype
     */
    KEYBOARD_TYPE_KOREA,
    MAKEWORD(MICROSOFT_KBD_103_TYPE, NLSKBD_OEM_MICROSOFT),
};

PKBDTABLES KbdLayerDescriptor(VOID)
{
    return &KbdTables103;
}

/***********************************************************************\
* VkToFuncTable_103[]
*
\***********************************************************************/

static ALLOC_SECTION_LDATA VK_F VkToFuncTable_103[] = {
    {
        VK_OEM_PLUS,           // Base Vk
        KBDNLS_TYPE_NORMAL,    // NLSFEProcType
        KBDNLS_INDEX_NORMAL,   // NLSFEProcCurrent
        0x0,                   // NLSFEProcSwitch
        {                      // NLSFEProcIndex
            {KBDNLS_SEND_BASE_VK,0},         // Base
            {KBDNLS_SEND_BASE_VK,0},         // Shift
            {KBDNLS_SEND_BASE_VK,0},         // Control
            {KBDNLS_SEND_BASE_VK,0},         // Shift+Control
            {KBDNLS_SEND_PARAM_VK,VK_JUNJA}, // Alt
            {KBDNLS_SEND_BASE_VK,0},         // Shift+Alt
            {KBDNLS_SEND_BASE_VK,0},         // Control+Alt
            {KBDNLS_SEND_BASE_VK,0}          // Shift+Control+Alt
        },
        {                      // NLSFEProcIndexAlt
            {KBDNLS_NULL,0},                 // Base
            {KBDNLS_NULL,0},                 // Shift
            {KBDNLS_NULL,0},                 // Control
            {KBDNLS_NULL,0},                 // Shift+Control
            {KBDNLS_NULL,0},                 // Alt
            {KBDNLS_NULL,0},                 // Shift+Alt
            {KBDNLS_NULL,0},                 // Control+Alt
            {KBDNLS_NULL,0}                  // Shift+Control+Alt
        }
    }
};

/***********************************************************************\
* KbdNlsTables
*
\***********************************************************************/

ALLOC_SECTION_LDATA KBDNLSTABLES KbdNlsTables103 = {
    0,                      // OEM ID (0 = Microsoft)
    0,                      // Information
    1,                      // Number of VK_F entry
    VkToFuncTable_103,      // Pointer to VK_F array
    0,                      // Number of MouseVk entry
    NULL                    // Pointer to MouseVk array
};

PKBDNLSTABLES KbdNlsLayerDescriptor(VOID)
{
    return &KbdNlsTables103;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\fe_kbds\kor\103\sources.inc ===
!IF 0

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


!ENDIF

MINORCOMP=kbd103

!include ..\..\korea.inc

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\fe_kbds\kor\101c\sources.inc ===
!IF 0

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


!ENDIF

MINORCOMP=kbd101c

!include ..\..\korea.inc

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\fe_kbds\kor\kor\kbdkor.c ===
/***************************************************************************\
* Module Name: kbdkor.c (Type A)
*
* Copyright (c) 1985-92, Microsoft Corporation
*
* Keyboard Type A :  Hangeul Toggle : Right Alt
*                    Junja   Toggle : Left  Alt + '='
*                    Hanja   Toggle : Right Ctrl
\***************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <ime.h>
#include "vkoem.h"

#include "..\101a\kbd101a.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\kbdus\daytona\makefile.inc ===
!INCLUDE ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\fe_kbds\kor\kor\multi.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <kbd.h>

BOOL EnumDynamicSwitchingLayouts(LPCWSTR lpwszBaseDll, PKBDTABLE_MULTI pKbdTableMulti);


BOOL KbdLayerMultiDescriptor(PKBDTABLE_MULTI pKbdTableMulti)
{
    /*
     * Firstly, try to get the setting from the registry.
     */
    if (EnumDynamicSwitchingLayouts(L"kbdjpn", pKbdTableMulti)) {
        return TRUE;
    }

    /*
     * If we failed to get the registry, set the default ones.
     */
    pKbdTableMulti->nTables = 2;

    wcscpy(pKbdTableMulti->aKbdTables[0].wszDllName, L"kbd101a.dll");
    pKbdTableMulti->aKbdTables[0].dwType = 4;
    pKbdTableMulti->aKbdTables[0].dwSubType = 0;

    wcscpy(pKbdTableMulti->aKbdTables[1].wszDllName, L"kbd103.dll");
    pKbdTableMulti->aKbdTables[1].dwType = 8;
    pKbdTableMulti->aKbdTables[1].dwSubType = 6;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\kbdus\wow6432\makefile.inc ===
!INCLUDE ..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kbd\fe_kbds\kor\kor\sources.inc ===
!IF 0

Copyright (c) 1989-2000  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


!ENDIF

MINORCOMP=kbdkor

!include ..\..\korea.inc

SOURCES_USED=..\sources.inc

TARGETLIBS=$(SDK_LIB_PATH)\ntdll.lib
LINKLIBS=..\..\..\common\$(ALT_PROJECT)\$(O)\fekbdcom.lib

#INCLUDES=$(INCLUDES);..\;..\inc;$(NTUSER_PATH)\inc;..\$(BASE_KEYBOARD_LAYOUT)


SOURCES=    kbdkor.rc \
            kbdkor.c \
            multi.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kdexts\genuedef.c ===
LIBRARY USEREXTS

;
; This file generates userexts.def or userkdx.def depending on the
; state of KERNEL.  This allows one file (exts.h) to
; be used to generate extension exports, entrypoints, and help text.
;
; To add an extension, add the appropriate entry to exts.h and matching
; code to userexts.c
;

EXPORTS
#define DOIT(name, helpstring1, helpstring2, validflags, argtype) name
#include "exts.h"

;--------------------------------------------------------------------
;
; these are the extension service functions provided for the debugger
;
;--------------------------------------------------------------------

    WinDbgExtensionDllInit
    ExtensionApiVersion
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kdexts\exts.h ===
/************************************************************************\
*
* MODULE: exts.h
*
* DESCRIPTION: macro driving file for use with stdexts.h and stdexts.c.
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* 6/9/1995 SanfordS Created
*
\************************************************************************/

DOIT(   help
        ,"help -v [cmd]                 - Displays this list or gives details on command\n"
        ,"  help      - To dump short help text on all commands.\n"
         "  help -v   - To dump long help text on all commands.\n"
         "  help cmd  - To dump long help on given command.\n"
        ,"v"
        ,CUSTOM)

#ifdef KERNEL
DOIT(   atom
        ,"atom                          - Dump atoms or atom tables\n"
        ,"atom -gl [atom]\n"
        ,"gl"
        ,STDARGS1)
#endif // KERNEL

#ifndef KERNEL
DOIT(   cbp
        ,"cbp                           - Breaks into the Debugger on CSRSS.EXE\n"
        ,""
        ,""
        ,NOARGS)
#endif

#ifndef KERNEL
DOIT(   dci
        ,"dci                           - Dump process client info.\n"
        ,""
        ,""
        ,NOARGS)
#endif //!KERNEL

#ifdef KERNEL
DOIT(   dcls
        ,"dcls [pcls]                   - Dump window class\n"
        ,"  dcls -v     - for verbose info.\n"
         "  dcls        - to list all classes.\n"
         "  dcls -p ppi - to list all classes for process ppi\n"
        ,"pv"
        ,STDARGS1)
#endif // KERNEL

#ifdef KERNEL
DOIT(   dcur
        ,"dcur -aivp [pcur]             - Dump cursors\n"
        ,"  dcur         - dump all cursor objects.\n"
         "  dcur -i <id> - dump cursors with given res id.\n"
         "  dcur -p <ppi>- dump cursors owned by ppi.\n"
         "  dcur -v      - dump in verbose format.\n"
         "  dcur -a      - expand dump of ACONs.\n"
         "  dcur <pcur>  - dump given cursor handle or pointer.\n"
        ,"aivp"
        ,STDARGS1)
#endif // KERNEL

#ifdef KERNEL
DOIT(   dde
        ,"dde -vr [conv|window|xact]    - Dump DDE tracking information\n"
        ,"  v - verbose\n"
         "  r - recurse to inner structures 1 level\n"
         "  window object - dumps all convs associated w/window\n"
         "  conv object - dumps conversation.\n"
         "  xact object - dumps transaction.\n"
        ,"vr"
        ,STDARGS1)
#endif // KERNEL

#ifdef KERNEL
DOIT(   ddl
        ,"ddl [pdesk]                   - Dump desktop log\n"
        ,"  ddl pdesk    - dumps the desktop log for pdesk.\n"
         "  ddl -v pdesk - dumps the desktop log for pdesk with stack traces.\n"
        ,"v"
        ,STDARGS1)
#endif // KERNEL

#ifdef OLD_DEBUGGER
#ifndef KERNEL
DOIT(   ddeml
        ,"ddeml -v [i<inst>] [t<type>] [hObj|pObj] - Dump DDEML state information\n"
        ,"  ddeml                     - lists all ddeml instances for this process\n"
         "  ddeml t<type>             - lists all ddeml objects of the given type\n"
         "  type 0 = All types\n"
         "  type 1 = Instances\n"
         "  type 2 = Server Conversations\n"
         "  type 3 = Client Conversations\n"
         "  type 4 = Conversation Lists\n"
         "  type 5 = Transactions\n"
         "  type 6 = Data Handles\n"
         "  type 7 = Zombie Conversations\n"
         "  ddeml i<instance> t<type> - restricts listing to one instance.\n"
         "  ddeml hObj                - dumps ddeml object\n"
         "  adding a 'v' simply turns lists into dumps.\n"
        ,"v"
        ,CUSTOM)
#endif //!KERNEL
#endif // OLD_DEBUGGER

#ifdef KERNEL
DOIT(   ddesk
        ,"ddesk -vhd <pdesk>            - Displays objects allocated in desktop\n"
        ,"  ddesk               - dumps list of desktops\n"
         "  ddesk address       - dumps simple statistics for desktop\n"
         "  ddesk -v address    - dumps verbose statistics for desktop\n"
         "  ddesk -h address    - dumps statistics for desktop plus handle list\n"
         "  ddesk -[vh]d ...    - dumps DLL name for hooks (slow)\n"
        ,"vhd"
        ,STDARGS1)
#endif // KERNEL

#ifdef KERNEL
DOIT(   ddk
        ,"ddk <pKbdTbl>                 - Dump deadkey table\n"
        ,"  ddk pKbdTbl   - Dump the deadkey table at pKbdTbl\n"
        ,""
        ,STDARGS1)
#endif // KERNEL

DOIT(   df
        ,"df [flags] | [-p pid]         - Displays or sets debug flags\n"
        ,"  df            - display debug flags\n"
         "  df [flags]  - enter new flags in format <Detail><Print><Prompt> \n"
         "      <Detail>    = [0-3] Print File/Line = 1, Hide PID/Component = 2\n"
         "      <Print>     = [0-7] Errors = 1, Warnings = 2, Verbose = 4\n"
         "      <Prompt>    = [0-7] Errors = 1, Warnings = 2, Verbose = 4\n"
         "    The default is 031\n"
         "  df -p pid   - shows rips only for this pid or 0 for all\n"
        ,"px"
        ,CUSTOM)

DOIT(   dhe
        ,"dhe [pointer|handle] | [-t[o[p]] type [pti/ppi]] - Dump handle entry(ies)\n"
        ,"  dhe            - dumps all handle entrys\n"
         "      -t dumps of all handles of the given type\n"
         "      -o all handles owned by pti/ppi\n"
         "      -op all handles owned by ppi or any thread in this process\n"
        ,"orpt"
        ,STDARGS2)

#ifdef KERNEL
DOIT(   dhard
        ,"dhard                         - Dump hard error list\n"
        ,""
        ,""
        ,NOARGS)
#endif //KERNEL

#ifdef KERNEL
DOIT(   dhid
        ,"dhid [-pv] [ppi]              - Dump HID info\n"
        ,"  dhid           - dumps global HID information\n"
         "  dhid -p        - dumps global HID information and process requests\n"
         "  dhid -p ppi    - dumps global HID info and proc requests of ppi (faster)\n"
         "  dhid -v        - verbose (can be combined with -p)\n"
        ,"pv"
        ,STDARGS1)

#endif

#ifdef KERNEL
DOIT(   dhk
        ,"dhk -ag[d] [pti]              - Dump hooks\n"
        ,"  dhk            - dumps local hooks on the foreground thread\n"
         "  dhk -g         - dumps global hooks\n"
         "  dhk pti        - dumps local hooks on THREADINFO at pti\n"
         "  dhk -g pti     - dumps global hooks and local hooks on THREADINFO at pti\n"
         "  dhk -a         - dumps local hooks for all threads\n"
         "  dhk -ag        - dumps global hooks and local hooks for all threads\n"
         "  dhk -[ag]d ... - dumps DLL name (slow)\n"
         ,"gad"
         ,STDARGS1)
#endif

#ifdef KERNEL
DOIT(   dhot
        ,"dhot                          - Dump registered hotkeys\n"
        ,"  dhot            - dumps all registered hotkeys\n"
         "  dhot photkey    - dumps HOTKEY photkey\n"
         "  dhot -r photkey - dumps all registered hotkeys after/including photkey"
        ,"r"
        ,STDARGS1)
#endif

#ifdef KERNEL
DOIT(   dhnr
        ,"dhnr                          - Dump HID notification record\n"
        ,"  dhnr [-vn]              - dumps all notification record (-n for pathname)\n"
         "  dhnr iseq               - dumps iseq notification record\n"
         "  dhnr -p[vn] <ptr>       - dumps notification record at addres <ptr>\n"
         "  dhnr -d[vnm] <pDevInfo> - dumps records of pDevInfo (-m to match pathname)\n"
        ,"pvndm"
        ,STDARGS1)
#endif

#ifdef KERNEL
DOIT(   dhs
        ,"dhs -vpty [id|type]           - Dump handle table statistics\n"
        ,"  dhs           - dumps simple statistics for whole table\n"
         "  dhs -t id     - dumps simple statistics for objects created by thread id\n"
         "  dhs -p id     - dumps simple statistics for objects created by process id\n"
         "  dhs -v        - dumps verbose statistics\n"
         "  dhs -y type   - dumps statistics for objects of type.\n"
        ,"tpvy"
        ,STDARGS1)
#endif

#ifdef KERNEL
DOIT(   di
        ,"di                            - Displays USER input processing globals.\n"
        ,""
        ,""
        ,NOARGS)
#endif // KERNEL

DOIT(   dimc
        ,"dimc [-hrvus] -[wci] [imc|wnd,etc.] - Dump Input Context\n"
        ,"  dimc [opts] <himc|pimc>      - dumps kernel side imc\n"
         "  dimc [opts] -w wnd           - dumps kernel side imc of wnd\n"
         "  dimc [opts] -c <pClientImc>     - dumps client side imc\n"
         "  dimc [opts] -i <pInputContext>  - dumps inputcontext\n"
         "       -h                      - show open, conversion, sentence mode and handles\n"
         "       -d                      - show hCompStr, hCanInfo etc (includes -h).\n"
         "       -r                      - recurse pImeModeSaver\n"
         "       -v                      - verbose\n"
         "       -u                      - assume UNICODE (use with -i)\n"
         "       -s                      - show relatively raw Composition String\n"
         "       -a                      - all (except -v)\n"
        ,"wcihdrvusa"
        ,STDARGS1)


#ifdef KERNEL
DOIT(   dimk
        ,"dimk [pImeHotKeyObj]          - Dump IME Hotkeys\n"
        ,""
        ,""
        ,STDARGS1)
#endif

#ifdef OLD_DEBUGGER
#ifndef KERNEL
DOIT(   dimedpi
        ,""
        ,"  dimedpi          - Dump all IMEDPI\n"
         "  dimedpi <addr>   - Dump IMEDPI at <addr>\n"
         "  dimedpi -v       - Dump with !dso format\n"
         "  dimedpi -i       - Dump ImeInfo\n"
        ,"vi"
        ,STDARGS1)
#endif // !KERNEL
#endif  // OLD_DEBUGGER

#ifdef KERNEL
DOIT(   dinp
        ,"dinp -v [pDeviceInfo]         - Dump input diagnostics\n"
        ,"  dinp <addr>    - Complete DeviceInfo struct at <addr>\n"
         "  dinp           - Short summary of all input devices\n"
         "  dinp -i <addr> - Dump input records for DeviceInfo struct at <addr>\n"
         "  dinp -v        - Dump complete DeviceInfo for all devices\n"
        ,"iv"
        ,STDARGS1)

DOIT(   _dinp
        ,"\0_dinp -v [pDeviceInfo]         - Dump input diagnostics\n"
        ,"  dinp <addr>    - Complete DeviceInfo struct at <addr>\n"
         "  dinp           - Short summary of all input devices\n"
         "  dinp -i <addr> - Dump input records for DeviceInfo struct at <addr>\n"
         "  dinp -v        - Dump complete DeviceInfo for all devices\n"
        ,"iv"
        ,STDARGS1)
#endif

#ifdef KERNEL
DOIT(   dkl
        ,"dkl -akv <pkl>                - Dump keyboard layout structures\n"
        ,"  dkl [-v] pkl    - Dump the keyboard layout structure at pkl\n"
         "  dkl -a[v] [pkl] - Dump all keyboard layout structures beginning with pkl\n"
         "  dkl -k          - Dump pklActive for all threads\n"
        ,"akv"
        ,STDARGS1)
#endif


DOIT(   _disi
        ,""
        ,"\0_disi <pinput>                 - Dump event injection union\n"
         ""
        ,""
        ,STDARGS1)

DOIT(   _ddlgt
        ,""
        ,"ddlgt <pdlgTemplate>          - Dump dialog template\n"
         "  ddlgt -v <pdlgTemplate>     - verbose\n"
         "  ddlgt -r <pdlgTemplate>     - print dialog items\n"
        ,"vr"
        ,STDARGS1)


DOIT(   dll
        ,"dll [*]addr [l#] [b#] [o#] [c#] [t[addr]] - Dump linked list (can Ctrl-C)\n"
        ,"  dll addr    - dumps list starting at addr 8 DWORDs each structure,\n"
         "                assumes link is first DWORD, w/NULL termination.\n"
         "  dll *addr   - same except starts at *addr\n"
         "  dll         - dumps next group of structures w/same options\n"
         "  \nOptions:\n"
         "  dll addr l3 - dumps 3 DWORDs per structure (default 8)\n"
         "  dll addr b2 - starts dump 2 DWORDs back - for LIST_ENTRYs (default 0)\n"
         "  dll addr o4 - next link is 4 DWORDs from top of structure (default 0)\n"
         "  dll addr c5 - dumps 5 structures only (defaults to 25)\n"
         "  dll addr l3 b2 o4 c5 - combines the option of the four previous lines\n"
         "  dll addr t  - counts (not dumps) items in list, tests for loop\n"
         "  dll addr t<addr>  - as above, halts if item at <addr> is found\n"
         "  dll addr t c5000  - as above, but limit c5000 (t default is c100000)\n"
        ,""
        ,CUSTOM)

#ifdef KERNEL
DOIT(   dlr
        ,"dlr -lsc <pointer|handle>          - Displays assignment locks for object\n"
        ,"  dlr <pointer|handle>    - dumps lock record\n"
         "  dlr -l                  - dump current lock record flags\n"
         "  dlr -s <hex>            - set lock record flag\n"
         "  dlr -c <hex>            - clear lock record flag\n"
         "     flag 0 is to record simple locks\n"
        ,"lcs"
        ,CUSTOM)
#endif //KERNEL

DOIT(   dm
        ,"dm -vris <menu|window>        - Dumps a menu\n"
        ,"  -v   - Verbose information mode\n"
         "  -r   - Recurse through sub-menus\n"
         "  -i   - Ignore items in the menu\n"
         "  -s   - dump a window's System menu\n"
        ,"virs"
        ,STDARGS1)

DOIT(   dmon
        ,"dmon <pMonitor>               - Dump MONITOR\n"
        ,"  dmon <pMonitor> - dump MONITOR at address\n"
        ,""
        ,STDARGS1)

#ifdef KERNEL
DOIT(   dmq
        ,"dmq [-act] [pq]               - Messages in queues\n"
        ,"  dmq [pq]     - lists messages in queue specified (default gpqForeground)\n"
         "  dmq -a       - lists messages in all queues\n"
         "  dmq -c [pq]  - counts messages in pq or all queues\n"
         "  dmq -t <pti> - dump messages in pti\n"
        ,"act"
        ,STDARGS1)
#endif

#ifdef KERNEL
DOIT(   dms
        ,"dms <MenuState>               - Dumps a pMenuState\n"
        ,""
        ,""
        ,STDARGS1)
#endif // KERNEL

#ifdef KERNEL
DOIT(   dp
        ,"dp -vcpt  [id]                - Displays simple process information\n"
        ,"  dp            - dumps simple process info of all W32 processes\n"
         "  dp -v         - verbose output\n"
         "  dp id/pep     - dumps process with given id or PEPROCESS pointer\n"
         "  dp -p ppi     - takes a ppi instead of a process id/pep\n"
         "  dp -c         - dumps current process for the current processor.\n"
         "  dp -t         - dumps threads for given process.\n"
        ,"vpct"
        ,STDARGS1)
#endif
#ifdef OLD_DEBUGGER

#ifndef KERNEL
DOIT(   dped
        ,"dped <ped>                    - Dump PEDitControl structure\n"
        ,""
        ,""
        ,STDARGS1)
#endif //!KERNEL
#endif // OLD_DEBUGGER

#ifdef KERNEL
DOIT(   dpi
        ,"dpi [ppi]                     - Displays PROCESSINFO structure specified\n"
        ,"  dpi -c         - dumps PROCESSINFO for current process\n"
         "  dpi address    - dumps PROCESSINFO structure at address\n"
         "  dpi            - dumps all PROCESSINFO structures\n"
        ,"c"
        ,STDARGS1)
#endif // KERNEL

#ifdef KERNEL
DOIT(   dpm
        ,"dpm <ppopupmenu>              - Dumps a popupmenu\n"
        ,""
        ,""
        ,STDARGS1)
#endif // KERNEL

#ifdef KERNEL
DOIT(   dq
        ,"dq -t [pq]                    - Displays Q structure specified\n"
        ,"  dq address    - dumps queue structure at address\n"
         "  dq -t address - dumps queue structure at address plus THREADINFO\n"
         "  dq -a         - dumps all queues\n"
         "  dq            - dumps gpqForeground\n"
        ,"at"
        ,STDARGS1)
#endif // KERNEL

DOIT(   dsi
        ,"dsi [-bchmopvw]               - Displays SERVERINFO struct\n"
        ,"dsi -b    - adds mpFnid_serverCBWndProc info.\n"
         "dsi -c    - adds aszSysColor info.\n"
         "dsi -h    - adds SHAREDINFO info.\n"
         "dsi -m    - adds system metrics data.\n"
         "dsi -o    - adds oemInfo info.\n"
         "dsi -p    - adds mpFnidPfn info.\n"
         "dsi -v    - verbose shows rarely needed fields.\n"
         "dsi -w    - adds aStoCidPfn info.\n"
        ,"bchjmopvw"
        ,STDARGS0)


#ifdef KERNEL
DOIT(   dsms
        ,"dsms -vl [psms]               - Displays SMS (SendMessage structure) specified\n"
        ,"  dsms           - dumps all send message structures\n"
         "  dsms -c        - counts messages, doesn't display any\n"
         "  dsms -v        - dumps all verbose\n"
         "  dsms -w        - dumps a bit verbose info\n"
         "  dsms -m msg    - dumps all sms with message == msg\n"
         "  dsms address   - dumps specific sms\n"
         "  dsms -v address- dumps verbose\n"
         "  dsms -r pti    - dumps sms with receiver == pti\n"
         "  dsms -s pti    - dumps sms with sender == pti\n"
//         "  dsms -l address- dumps SendList of sms\n"
        ,"clmvsrw"
        ,STDARGS1)
#endif // KERNEL

#ifdef KERNEL
DOIT(   dt
        ,"dt -gvcp [id]                 - Displays simple thread information\n"
        ,"  dt            - dumps simple thread info of all window threads\n"
         "  dt -c         - dumps current thread for current processor.\n"
         "  dt -g         - dump GUI threads only\n"
         "  dt id/pet     - dumps thread with given id or PETHREAD pointer\n"
         "  dt -p pti     - takes a pti instead of a thread id/pet\n"
         "  dt -s [...]   - displays wait state\n"
         "  dt -v         - verbose output\n"
        ,"cgpsv"
        ,STDARGS1)
#endif

#ifdef KERNEL
DOIT(   dtdb
        ,"dtdb [ptdb]                   - Dump Task Database\n"
        ,"  dtdb <ptdb>   - dumps given ptdb.\n"
         "  dtdb          - dumps all dtdbs.\n"
        ,""
        ,STDARGS1)
#endif // KERNEL

#ifdef KERNEL
DOIT(   dti
        ,"dti [pti]                     - Displays THREADINFO structure\n"
        ,"  dti            - dumps THREADINFO structure of foreground thread\n"
         "  dti address    - dumps THREADINFO structure at address\n"
        ,"c"
        ,STDARGS1)
#endif // KERNEL

#ifdef KERNEL
DOIT(   dtl
        ,"dtl [-t] [pointer|handle]     - Displays thread locks\n"
        ,"dtl pObj      - dump thread locks for object/pool/kernel-object\n"
         "dtl -t pti    - dump thread locks for thread\n"
         "dtl           - dump all thread locks\n"
        ,"t"
        ,STDARGS1)
#endif //KERNEL

#ifdef KERNEL
DOIT(   dtmr
        ,"dtmr [ptmr]                   - Dumps timer structure.\n"
        ,"  dtmr <ptmr> - dump timer.\n"
         "  dtmr        - dump all timers.\n"
        ,""
        ,STDARGS1)
#endif // KERNEL

#ifdef OLD_DEBUGGER
DOIT(   du
        ,"du [pointer|handle]           - Generic object dumping routine\n"
        ,"  Attempts to dump the object appropriately.\n"
         "  If no object is given - WARNING - ALL objects are dumped.\n"
        ,""
        ,STDARGS1)
#endif // OLD_DEBUGGER

#ifdef KERNEL
DOIT(   dupm
        ,"dupm                          - User Preference Bitmask\n"
        ,""
        ,""
        ,NOARGS)
#endif //KERNEL

#ifdef OLD_DEBUGGER
#ifdef KERNEL
DOIT(   dumphmgr
        ,"dumphmgr [-s]                 - Dumps object allocation counts (dbg only)\n"
        ,""
        ,"s"
        ,STDARGS0)
#endif //KERNEL
#endif // OLD_DEBUGGER

DOIT(   dw
        ,"dw -aefhvsprwoz [hwnd/pwnd]   - Displays information on windows in system\n"
        ,
         "  dw hwnd/pwnd  - dumps simple window info for window at pwnd\n"
         "  dw            - dumps simple window info for all top level windows of current\n"
         "                  desktop.\n"
         "  dw -v [pwnd]  - dumps verbose window info\n"
         "  dw -a         - added to any of the other commands - applies to all desktops.\n"
         "  dw -f [pwnd]  - dumps flags for window at pwnd or all toplevel windows\n"
         "  dw -h         - add -h to show wndproc symbol - slower.\n"
         "  dw -o pwnd    - dumps properties of pwnd.\n"
         "  dw -p pwnd    - dumps info for all child windows of window at pwnd\n"
         "  dw -r [pwnd]  - dumps relationship of windows beneath pwnd or desktop window\n"
         "  dw -s pwnd    - dumps info for all sibling windows of window at pwnd\n"
         "  dw -t <pti>   - Like EnumThreadWindows\n"
         "  dw -w pwnd    - dumps window words of pwnd.\n"
         "  dw -z         - Added to show z-ordering/activation relevant info\n"
        ,"afhvsprtwoz"
        ,STDARGS1)

#ifdef OLD_DEBUGGER
#ifdef KERNEL
DOIT(   dwe
        ,"dwe [-n] [addr]               - Displays WinEvent hooks/notifies\n"
        ,
         "  dwe <peh>    - dump EVENTHOOK struct.\n"
         "  dwe          - dump all EVENTHOOKS.\n"
         "  dwe -n <pn>  - dump NOTIFY struct.\n"
         "  dwe -n       - dump all NOTIFYs.\n"
        ,"n"
        ,STDARGS1)
#endif // KERNEL

#ifdef KERNEL
DOIT(   dwpi
        ,"dwpi -p [pwpi | ppi]          - Displays WOWPROCESSINFO structure specified\n"
        ,"  dwpi <pwpi>   - dump a pwpi structure.\n"
         "  dwpi -p <ppi> - dump pwpis for this process.\n"
         "  dwpi          - dump all pwpis.\n"
        ,"p"
        ,STDARGS1)
#endif // KERNEL
#endif // OLD_DEBUGGER

#ifdef KERNEL
DOIT(   dws
        ,"dws [pws]                     - Dump windowstations\n"
        ,"  dws <pws>     - dump windows station\n"
         "  dws           - dump all window stations\n"
        ,""
        ,STDARGS1)
DOIT(   dpa
        ,"dpa -cvsfrp                   - Dump pool allocations\n"
        ,"  dpa -c        - dump current pool allocations statistics\n"
         "  dpa -v        - dump all the current pool allocations\n"
         "  dpa -vs       - include stack traces\n"
         "  dpa -f        - dump failed allocations\n"
         "  dpa -r        - dump free pool\n"
         "  dpa -p <ptr>  - dump the allocation containing pointer 'ptr'\n"
        ,"cvsfrp"
        ,STDARGS1)

DOIT(   dcss
        ,"dcss                          - Dump critical section stack traces\n"
        ,"  dcss           - dump all stack straces\n"
        ,""
        ,STDARGS0)

#ifdef OLD_DEBUGGER
DOIT(   dvs
        ,"dvs -s                        - Dump sections and mapped views\n"
        ,"  dvs -s        - dump stack traces also\n"
        ,"s"
        ,STDARGS1)
DOIT(   dfa
        ,"dfa                           - Dump allocation fail stack trace\n"
        ,"  dfa           - dump allocation fail stack trace\n"
        ,""
        ,STDARGS1)
DOIT(   dha
        ,"dha    address                - Dump heap allocations. Also verifies the heap the address belongs to\n"
        ,"  dha -v        - Prints out all allocations in the heap\n"
         "  dha -a        - apply the command to all heaps.  \nWith no address specified, it checks all allocations in all heaps\n"
        ,"va"
        ,STDARGS1)
#endif // OLD_DEBUGGER
#endif // KERNEL

DOIT(   dy
        ,"dy [pdi]                      - Dump DISPLAYINFO\n"
        ,"  dy             - dump gpDispInfo\n"
         "  dy address     - dump DISPLAYINFO at address\n"
        ,""
        ,STDARGS1)

DOIT(   find
        ,"find baseaddr addr [o#]       - Find linked list element\n"
        ,"  find baseaddr addr      - searches list for addr starting at baseaddr,\n"
         "                            assumes link is first DWORD, w/NULL termination.\n"
         "  find baseaddr addr o4   - next link is 4 DWORDS from start of structure\n"
        ,""
        ,CUSTOM)

#ifdef OLD_DEBUGGER
DOIT(   fno
        ,"fno <address>                 - Find nearest object.\n"
        ,"  Locates the nearest public USER objects to the given address.\n"
        ,""
        ,STDARGS1)

DOIT(   frr
        ,"frr <psrcLo> <psrcHi> <prefLo> [prefHi] - Find Range Reference\n"
        ,"  Used to search memory within the src range for references to\n"
         "  addresses within the ref range.\n"
        ,""
        ,STDARGS4)

#endif // OLD_DEBUGGER

#ifdef KERNEL
DOIT(   gflags
        ,"\0gflags [-v]                   - Displays NT Global Flags\n"
        ,"  gflags      - Dump and interpret the NT global flags\n"
         "  gflags -v   - A little bit verbose\n"
        ,"v"
        ,STDARGS0)

#endif // KERNEL

#ifdef KERNEL
DOIT(   kbd
        ,"kbd -au [pq]                  - Displays key state for queue\n"
        ,"  kbd            - key state for foreground queue\n"
         "  kbd pq         - key state for queue structure at pq\n"
         "  kbd -a         - key state for all queues\n"
         "  kbd -u pb      - wParam of WM_UPDATEKEYSTATE event\n"
         "  kbd -k vk      - check given vkey status\n"
         "  kbd -s         - show all vk status\n"
        ,"auks"
        ,STDARGS1)
#endif // KERNEL

DOIT(   sas
        ,"sas [-s] <addr> [length]      - Stack Analysis Stuff\n"
        ,"sas -d [-s] <number> - to just analyze a number.\n"
         " length defaults to 25.\n"
         " -s suppresses symbolic output.\n"
        ,"ds"
        ,STDARGS2)

#if DEBUGTAGS
DOIT(   tag
        ,"tag [<tag #> [<flags>]]         - Displays or sets tags\n"
        ,"  tag               - display all tags\n"
         "  tag <tag #>         - display one tag\n"
         "  tag <tag #> <flags> - change tag settings\n"
         "       <flags> = [0-3] Disabled = 0, Enabled = 1, Print = 2, Prompt = 3\n"
        ,""
        ,CUSTOM)
#endif // DEBUGTAGS

DOIT(   test
        ,"test                          - Test basic debug functions.\n"
        ,""
        ,""
        ,NOARGS)

DOIT(   uver
        ,"uver                          - show versions of user and exts.\n"
        ,""
        ,""
        ,NOARGS)


DOIT(   vkey
        ,""
        ,"vkey                          - show vkey values\n"
         "  vkey hex          - display VK symbol\n"
         "  vkey VK_*         - display hex value for VK_ symbol\n"
         "  vkey -a           - display all common VK values\n"
         "  vkey -o           - display all common VK values in one column\n"
        ,"ao"
        ,CUSTOM)

#ifdef KERNEL

DOIT(   hh
        ,"hh                            - dumps gdwHydraHint.\n"
        ,"hh hydrahint        - dumps a specified DWORD as a hydra hint\n"
        ,""
        ,STDARGS1)
#endif // KERNEL

#ifdef OLD_DEBUGGER
#ifndef KERNEL
DOIT(   kc
        ,"kc pwnd                       - Displays information on Keyboard Cues\n"
        ,""
        ,""
        ,STDARGS1)
#endif // !KERNEL
#endif // OLD_DEBUGGER

DOIT(   wm
        ,"wm, vkey, ddlgt, disi: see each help\n"
        ,"wm <msg>                      - Displays window message symbol\n"
         "  wm exp            - display WM_ symb\n"
         "  wm WM_            - display message value\n"
         "  wm -a             - display all common window messages\n"
        ,"a"
        ,CUSTOM)

DOIT(   _wm
        ,""
        ,"_wm <msg>                      - Displays window message symbol\n"
         "  _wm exp           - display WM_ symb\n"
         "  _wm WM_           - display message value\n"
         "  _wm -a            - display all common window messages\n"
        ,"a"
        ,CUSTOM)

#ifdef KERNEL
DOIT(   hogs
        ,"hogs [N]                          - Dump CPU hogs\n"
        ,"hogs                - dump the kerneltime of all threads in descending order\n"
        "hogs N              - dump the N threads using the most kerneltime\n"
        ,""
        ,STDARGS1)
#endif // KERNEL

DOIT(   pred
        ,"\0pred                              - dump ia64 predicate registers\n"
        ,"pred xxxx           - dump predicate registers\n"
        ,""
        ,STDARGS1)


DOIT(   chkfre
        ,"\0chkfre [-c] [-f]\n"
        ,""
        ,"cfr"
        ,STDARGS1)

#ifdef KERNEL
DOIT(   dghost
        ,"dghost                          - Dump ghost thread associated information.\n"
        ,""
        ,""
        ,NOARGS)

DOIT(   dce,
        ,"dce                             - Dumps DC Cache Entry information.\n"
        ,
         "  dce -c pwndClip   - Clipping PWND\n"
         "  dce -f DCXxxx     - DCX flag filter\n"
         "  dce -h hdc        - HDC\n"
         "  dce -o pwndOrg    - Original PWND\n"
         "  dce -r hrgnClip   - Clipping region\n"
         "  dce -t pti        - pThreadInfo\n"
         "  dce -v            - Verbose\n"
        ,"cfhortv"
        ,STDARGS1)

#endif // KERNEL

#ifndef KERNEL
DOIT(   msft
        ,"msft                            - Dump the current stock price\n"
        ,""
        ,""
        ,NOARGS)
#endif // !KERNEL

DOIT(   daccel
        ,"daccel <pAccelTable | hAccelTable> - Dump the given accelerator table\n"
        ,""
        ,""
        ,STDARGS1)

#ifdef KERNEL
DOIT(   heapff
        ,"heapff <pHeapBlock> - Looks for the given heap address in our list of freed heap.\n"
        ,""
        ,""
        ,STDARGS1)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kdexts\precomp.h ===
#ifndef USEREXTS
#define USEREXTS

// This is a 64 bit aware debugger extension
#define KDEXT_64BIT

#define NOWINBASEINTERLOCK
#include "ntosp.h"

#include <w32p.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <excpt.h>
#include <atom.h>
#include <stdio.h>
#include <limits.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <string.h>
#include <ntstatus.h>
#include <windows.h>
#include <ntddvdeo.h>
#include <ntcsrsrv.h>
#include <wmistr.h>
#include <wmidata.h>

#endif /* USEREXTS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kdexts\kdexts.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    kdexts.c

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

Author:

    Wesley Witt (wesw) 26-Aug-1993

Environment:

    User Mode

--*/

#include "precomp.h"
#pragma hdrstop

#include <imagehlp.h>
#include <wdbgexts.h>
#include <ntsdexts.h>
#include <ntverp.h>

//
// globals
//
EXT_API_VERSION        ApiVersion = { VER_PRODUCTVERSION_W >> 8,
                                      VER_PRODUCTVERSION_W & 0xff,
                                      EXT_API_VERSION_NUMBER64, 0 };
WINDBG_EXTENSION_APIS  ExtensionApis;
USHORT                 SavedMajorVersion;
USHORT                 SavedMinorVersion;
BOOL                   bDebuggingChecked;


VOID
WinDbgExtensionDllInit(
    WINDBG_EXTENSION_APIS *lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion)
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    bDebuggingChecked = (SavedMajorVersion == 0x0c);
}

DECLARE_API( version )
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif // DBG

    UNREFERENCED_PARAMETER(args);
    UNREFERENCED_PARAMETER(dwProcessor);
    UNREFERENCED_PARAMETER(dwCurrentPc);
    UNREFERENCED_PARAMETER(hCurrentThread);
    UNREFERENCED_PARAMETER(hCurrentProcess);

    dprintf( "%s Extension dll for Build %d debugging %s kernel for Build %d\n",
             DebuggerType,
             VER_PRODUCTBUILD,
             SavedMajorVersion == 0x0c ? "Checked" : "Free",
             SavedMinorVersion
           );
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID)
{
    return &ApiVersion;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kdexts\process.h ===
/****************************** Module Header ******************************\
* Module Name: process.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains processor specific routines.
*
* History:
* 25-Oct-1995 JimA      Created.
\***************************************************************************/

#include "precomp.h"

#include <imagehlp.h>
#include <wdbgexts.h>
#include <ntsdexts.h>

#include <stdexts.h>

extern ULONG (*GetEThreadFieldInfo)(ETHREADFIELD, PULONG);
extern ULONG (*GetEProcessFieldInfo)(EPROCESSFIELD, PULONG);                                    

PVOID GetEProcessData(
    PEPROCESS pEProcess,
    EPROCESSFIELD epf,
    PVOID pBuffer)
{
    PVOID pvData;
    ULONG ulSize;

    pvData = (PBYTE)pEProcess + GetEProcessFieldInfo(epf, &ulSize);
    if (pBuffer != NULL) {
        if (!tryMoveBlock(pBuffer, pvData, ulSize)) {
            DEBUGPRINT("GetEProcessData failed to move block. EProcess:%p epf:%d \n", pEProcess, epf);
            return NULL;
        }
    }
    return pvData;
}

PVOID GetEThreadData(
    PETHREAD pEThread,
    ETHREADFIELD etf,
    PVOID pBuffer)
{
    PVOID pvData;
    ULONG ulSize;

    pvData = (PBYTE)pEThread + GetEThreadFieldInfo(etf, &ulSize);
    if (pBuffer != NULL) {
        if (!tryMoveBlock(pBuffer, pvData, ulSize)) {
            DEBUGPRINT("GetEThreadData failed to move block. EThread:%p etf:%d \n", pEThread, etf);
            return NULL;
        }
    }
    return pvData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kdexts\userkdx.h ===
/****************************** Module Header ******************************\
* Module Name: userkdx.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Common include files for kd and ntsd.
* A preprocessed version of this file is passed to structo.exe to build
*  the struct field name-offset tables.
*
* History:
* 04-16-1996 GerardoB Created
\***************************************************************************/
#ifndef _USERKDX_
#define _USERKDX_

#include "precomp.h"
#pragma hdrstop

#ifdef KERNEL
#include <stddef.h>
#include <windef.h>
#define _USERK_
#include "heap.h"
#undef _USERK_
#include <wingdi.h>
#include <w32gdip.h>
#include <kbd.h>
#include <ntgdistr.h>
#include <winddi.h>
#include <gre.h>
#include <ddeml.h>
#include <ddetrack.h>
#include <w32err.h>
#include "immstruc.h"
#include <winuserk.h>
#include <usergdi.h>
#include <zwapi.h>
#include <userk.h>
#include <access.h>
#include <hmgshare.h>

#else // KERNEL

#include "usercli.h"

#include "usersrv.h"
#include <ntcsrdll.h>
#include "csrmsg.h"
#include <wininet.h>
#endif // KERNEL

#include "conapi.h"

#include <imagehlp.h>
#include <wdbgexts.h>
#include <ntsdexts.h>
#define NOEXTAPI

// IMM stuff
#include "immuser.h"

#endif /* _USERKDX_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kdexts\kd\daytona\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kdexts\kd\makefile.inc ===
HDEPENDENCIES=..\..\exts.h $(WINDOWS_INC_PATH)\stdexts.h

GENUEDEFDEFINES=/DKERNEL /D_$(ALT_PROJECT)_
!if !$(FREEBUILD)
GENUEDEFDEFINES=$(GENUEDEFDEFINES) /DDEBUGTAGS=1
!endif

$(O)\userkdx.def: ..\..\genuedef.c $(HDEPENDENCIES)
        $(CXX_COMPILER_NAME) $(GENUEDEFDEFINES) /EP ..\..\genuedef.c >$@

#
# Dependencies for dummy targets
#
..\kdexts.c:            ..\..\kdexts.c
..\userexts.c:          ..\..\userkdx.h \
                        ..\..\userexts.c \
                        $(HDEPENDENCIES) \
                        $(WINDOWS_INC_PATH)\stdexts.c \
                        $(O)\wm.txt $(O)\vktbl.txt

..\userexts.rc:         ..\..\userexts.rc

..\..\precomp.h: ..\..\userkdx.h
..\..\userkdx.h: $(NTUSER_PATH)\kernel\userk.h \
                 $(NTUSER_PATH)\inc\user.h \
                 $(NTUSER_PATH)\inc\ntuser.h \
                 $(WINDOWS_INC_PATH)\winuserp.h \
                 $(WINDOWS_INC_PATH)\immp.h \
                 $(WINCORE_PATH)\w32inc\winuserk.h

$(O)\ptagdbg.h: $(NTUSER_PATH)\kdexts\ptagdbg.bat $(NTUSER_PATH)\kernel\ptag.lst
    $(NTUSER_PATH)\kdexts\ptagdbg.bat $(NTUSER_PATH)\kernel\ptag.lst $(O)\ptagdbg.h

$(O)\wm.txt: $(PROJECT_ROOT)\Published\winuser.w $(WINDOWS_INC_PATH)\winuserp.h
    perl $(NTUSER_PATH)\kdexts\wm.pl $(PROJECT_ROOT)\Published\winuser.w > $(O)\wm.txt

VKTBL_SRCS=$(PROJECT_ROOT)\Published\winuser.w  \
           $(WINDOWS_INC_PATH)\vkoem.h          \
           $(PROJECT_ROOT)\Published\ime.w

$(O)\vktbl.txt: $(VKTBL_SRCS)
    perl $(NTUSER_PATH)\kdexts\vkeytbl.pl $(VKTBL_SRCS) > $(O)\vktbl.txt
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kdexts\stdext64.c ===
/****************************** Module Header ******************************\
* Module Name: stdexts.c
*
* Copyright (c) 1995-1998, Microsoft Corporation
*
* This module contains standard routines for creating sane debuging extensions.
* It is meant to be included after stdexts.h in one of the files comprising
* the debug extsnsions for a given product or module.
*
* History:
* 11-Apr-1995 Sanfords  Created
\***************************************************************************/

HANDLE                  hCurrentProcess;
HANDLE                  hCurrentThread;
ULONG64                 dwCurrentPc;
WINDBG_EXTENSION_APIS  *lpExtensionApis;
DWORD                   dwProcessor;

PSTR pszAccessViolation = "%s: Access violation on \"%s\".\n";
PSTR pszMoveException   = "%s: exception in moveBlock()\n";
PSTR pszReadFailure     = "%s: lpReadProcessMemoryRoutine failed!\n";
PSTR pszCantContinue    = "%s: Non-continuable exception.\n";
BOOL fCtrlCHit = FALSE;


/*
 * This function returns TRUE once the user has hit a Ctrl-C.
 * This allows proper operation of nested SAFEWHILE loops so
 * that all levels exit.
 *
 * The globall fCtrlCHit flag needs to be reset manually and
 * is done so in the CommandEP function.
 */
BOOL IsCtrlCHit(
    VOID)
{
    if ((lpExtensionApis->lpCheckControlCRoutine)()) {
        fCtrlCHit = TRUE;
    }

    return fCtrlCHit;
}



VOID moveBlock(
    PVOID pdst,
    ULONG64 src,
    DWORD size)
{
    BOOL fSuccess = TRUE;
    ULONG Result;

    try {
        if (IsWinDbg()) {
            if (!ReadMem(src, pdst, size, &Result)) {
                fSuccess = FALSE;
             }
        } else {
            if (!NT_SUCCESS(NtReadVirtualMemory(hCurrentProcess,
                    (PVOID)src, pdst, size, NULL))) {
                fSuccess = FALSE;
            }
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        Print(pszMoveException, pszExtName);
        fSuccess = FALSE;
    }
    if (!fSuccess) {
        DEBUGPRINT("%s: moveBlock(%p, %p, %x) failed.\n",
                pszExtName, pdst, src, size);
        OUTAHERE();
    }
}


BOOL tryMoveBlock(
    PVOID pdst,
    ULONG64 src,
    DWORD size)
{
    BOOL fSuccess = TRUE;
    ULONG Result;

    try {
        if (IsWinDbg()) {
            if (!ReadMem(src, pdst, size, &Result)) {
                DEBUGPRINT("%s: tryMoveBlock(%p, %p, %x) failed.\n", pszExtName, pdst, src, size);
                fSuccess = FALSE;
             }
        } else {
            if (!NT_SUCCESS(NtReadVirtualMemory(hCurrentProcess, (PVOID)src, pdst, size, NULL))) {
                DEBUGPRINT("%s: tryMoveBlock(%p, %p, %x) failed.\n", pszExtName, pdst, src, size);
                fSuccess = FALSE;
            }
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        DEBUGPRINT("%s: tryMoveBlock(%p, %p, %x) faulted.\n", pszExtName, pdst, src, size);
        fSuccess = FALSE;
    }

    return fSuccess;
}



VOID moveExp(
    PULONG64 pdst,
    LPSTR pszExp)
{
    BOOL fSuccess = TRUE;

    try {
        *pdst = EvalExp(pszExp);
    } except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        Print(pszAccessViolation, pszExtName, pszExp);
        fSuccess = FALSE;
    }

    if (!fSuccess) {
        Print("%s: moveExp failed on %s.\n", pszExtName, pszExp);
        OUTAHERE();
    }
}


BOOL tryMoveExp(
    PULONG64 pdst,
    LPSTR pszExp)
{
    BOOL fSuccess = TRUE;

    try {
        *pdst = EvalExp(pszExp);
    } except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        Print(pszAccessViolation, pszExtName, pszExp);
        DEBUGPRINT("%s: tryMoveExp(%p, %s) faulted.\n", pszExtName, pdst, pszExp);
        fSuccess = FALSE;
    }

    return fSuccess;
}


VOID moveExpValue(
    PVOID pdst,
    LPSTR pszExp)
{
    DWORD dw;
    ULONG64 addr;

    if (tryMoveExp(&addr, pszExp)) {
        if (tryMoveBlock(&dw, addr, sizeof(DWORD))) {
            *((PDWORD)pdst) = dw;
            return;
        }
    }
    Print("%s: moveExpValue failed on %s.\n", pszExtName, pszExp);
    OUTAHERE();
}


BOOL tryMoveExpValue(
    PVOID pdst,
    LPSTR pszExp)
{
    DWORD dw;
    ULONG64 addr;

    if (tryMoveExp(&addr, pszExp)) {
        if (tryMove(dw, addr)) {
            *((PDWORD)pdst) = dw;
            return TRUE;
        }
    }
    DEBUGPRINT("%s: tryMoveExpValue failed on %s.\n", pszExtName, pszExp);
    return FALSE;
}


BOOL tryMoveExpPtr(
    PULONG64 pdst,
    LPSTR pszExp)
{
    BOOL fSuccess = TRUE;

    try {
        *pdst = EvalExp(pszExp);
    } except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        Print(pszAccessViolation, pszExtName, pszExp);
        DEBUGPRINT("%s: tryMoveExpPtr(%p, %s) faulted.\n", pszExtName, pdst, pszExp);
        fSuccess = FALSE;
    }

    return fSuccess;
}


VOID moveExpValuePtr(
    PULONG64 pdst,
    LPSTR pszExp)
{
    ULONG64 dw;

    if (tryMoveExpPtr(&dw, pszExp)) {
        if (tryMoveBlock(&dw, dw, sizeof(dw))) {
            *pdst = dw;
            return;
        }
    }

    Print("%s: moveExpValue failed on %s.\n", pszExtName, pszExp);
    OUTAHERE();
}


ULONG64 EvalExp(
    LPSTR psz)
{
    ULONG64 p;

    p = (lpExtensionApis->lpGetExpressionRoutine)(psz);
    if (p == 0) {
        Print("%s: EvalExp failed to evaluate %s.\n", pszExtName, psz);
    }

    return p;
}



ULONG64 OptEvalExp(
    LPSTR psz)
{
    while (*psz == ' ') {
        psz++;
    }

    if (*psz == '\0') {
        return 0;
    }

    return EvalExp(psz);
}



ULONG64 OptEvalExp2(
    LPSTR *ppsz)
{
    LPSTR psz = *ppsz;
    ULONG64 dwRet = 0;

    while (*psz == ' ') {
        psz++;
    }

    if (*psz != '\0') {
        dwRet = EvalExp(psz);
        while (*psz != '\0' && *psz != ' ') {
            psz++;
        }
    }
    *ppsz = psz;

    return dwRet;
}


DWORD StringToOpts(
    LPSTR psz)
{
    DWORD opts = 0;

    while (*psz != '\0' && *psz != ' ') {
        if (*psz >= 'a' && *psz <= 'z') {
            opts |= 1 << (*psz - 'a');
        } else if (*psz >= 'A' && *psz <= 'Z') {
            opts |= 1 << (*psz - 'A');
        } else {
            return OPTS_ERROR;     // any non-letter option is an error.
        }
        psz++;
    }

    return opts;
}


/*
 * Function to convert an option string to a DWORD of flags.  pszLegalArgs
 * is used to allow option validation at the same time.
 *
 * *ppszArgs is set to point to after the options on exit.
 * On error, returns OPTS_ERROR.
 */
DWORD GetOpts(
    LPSTR *ppszArgs,
    LPSTR pszLegalArgs OPTIONAL)
{
    DWORD Opts = 0;
    LPSTR pszArgs = *ppszArgs;

    /*
     * Skip whitespace
     */
    while (*pszArgs == ' ') {
        pszArgs++;
    }
    /*
     * process '-' prepended options.
     */
    while (*pszArgs == '-') {
        pszArgs++;
        Opts = StringToOpts(pszArgs);
        /*
         * skip to whitespace or end.
         */
        while (*pszArgs != '\0' && *pszArgs != ' ') {
            pszArgs++;
        }
        /*
         * skip trailing whitespace.
         */
        while (*pszArgs == ' ') {
            pszArgs++;
        }
        *ppszArgs = pszArgs;

        /*
         * optionally validate against LegalArgs
         */
        if (pszLegalArgs != NULL && ((Opts & StringToOpts(pszLegalArgs)) != Opts)) {
            Opts = OPTS_ERROR;
            Print("Bad options.\n");
            return Opts;
        }
    }

    return Opts;
}


/*
 * Dispatcher function used by generated entrypoint functions.
 */
VOID CommonEP(
    PVOID pFunction,
    LPSTR pszName,
    int type,
    LPSTR pszLegalOpts,
    HANDLE hcp,
    HANDLE hct,
    ULONG64 dwcp,
    DWORD dwp,
    LPSTR lpas)
{
    BOOL dwOptions, fSuccess;
    ULONG64 param1, param2, param3;

    hCurrentProcess = hcp;
    hCurrentThread = hct;
    dwCurrentPc = dwcp;
    dwProcessor = dwp;
    lpExtensionApis = &ExtensionApis;

    fCtrlCHit = FALSE;  // reset this with each command. (SAFEWHILE fix)
    switch (type) {
    case NOARGS:
        fSuccess = ((TYPE_NOARGS)pFunction)();
        goto Exit;
    }

    dwOptions = GetOpts(&lpas, pszLegalOpts);
    if (dwOptions == OPTS_ERROR) {
        fSuccess = Ihelp(0, pszName);
        goto Exit;
    }

    try {
        switch (type) {
        case CUSTOM:
            fSuccess = ((TYPE_CUSTOM)pFunction)(dwOptions, lpas);
            break;

        case STDARGS0:
            fSuccess = ((TYPE_STDARGS0)pFunction)(dwOptions);
            break;

        case STDARGS1:
            fSuccess = ((TYPE_STDARGS1)pFunction)(dwOptions, OptEvalExp(lpas));
            break;

        case STDARGS2:
            param1 = OptEvalExp2(&lpas);
            fSuccess = ((TYPE_STDARGS2)pFunction)(dwOptions, param1, OptEvalExp(lpas));
            break;

        case STDARGS3:
            param1 = OptEvalExp2(&lpas);
            param2 = OptEvalExp2(&lpas);
            fSuccess = ((TYPE_STDARGS3)pFunction)(dwOptions, param1, param2, OptEvalExp(lpas));
            break;

        case STDARGS4:
            param1 = OptEvalExp2(&lpas);
            param2 = OptEvalExp2(&lpas);
            param3 = OptEvalExp2(&lpas);
            fSuccess = ((TYPE_STDARGS4)pFunction)(dwOptions, param1, param2, param3, OptEvalExp(lpas));
            break;

        default:
            Print("CommonEP: Don't recognize function type %d.\n", type);
            break;
        }
    } except (GetExceptionCode() == STATUS_NONCONTINUABLE_EXCEPTION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        Print(pszCantContinue, pszExtName);
    }

Exit:
    if (!fSuccess) {
        Print("%s failed.\n", pszName);
        Ihelp(0, pszName);
    }
}

/*
 * Entrypoint functions (generated from exts.h)
 */
#define DOIT(name, h1, h2, opts, type)                  \
VOID name##(                                            \
    HANDLE hcp,                                         \
    HANDLE hct,                                         \
    ULONG64 dwcp,                                       \
    DWORD dwp,                                          \
    LPSTR lpas)                                         \
{                                                       \
    CommonEP(I##name, #name, type, opts, hcp, hct, dwcp, dwp, lpas); \
}
#include "exts.h"
#undef DOIT


/*
 * Standard help extension - present in all standard extensions.
 */
BOOL Ihelp(
    DWORD opts,
    LPSTR lpas)
{
#define DOIT(name, help1, help2, opts, type)  { #name, help1, help2 },

    static struct {
        LPSTR pszCmdName;
        LPSTR pszHelp1;
        LPSTR pszHelp2;
    } he[] = {
#include "exts.h"
    };
#undef DOIT
    int i;

    while (*lpas == ' ') {
        lpas++;
    }

    if (*lpas == '\0') {
        Print("-------------- %s Debug Extension help:--------------\n\n", pszExtName);
        for (i = 0; i < sizeof(he) / sizeof(he[0]); i++) {
            if (IsCtrlCHit()) {
                break;
            }
            Print(he[i].pszHelp1);
            if (opts & OFLAG(v)) {
                Print(he[i].pszHelp2);
            }
        }
        return TRUE;
    } else {
        for (i = 0; i < sizeof(he) / sizeof(he[0]); i++) {
            if (IsCtrlCHit()) {
                break;
            }
            if (strcmp(lpas, he[i].pszCmdName) == 0) {
                Print(he[i].pszHelp1);
                Print(he[i].pszHelp2);
                return TRUE;
            }
        }
        Print("%s is not supported.\n", lpas);
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kdexts\stdext64.h ===
/****************************** Module Header ******************************\
* Module Name: stdexts.h
*
* Copyright (c) 1995-1998, Microsoft Corporation
*
* This module contains standard routines for creating sane debuging extensions.
*
* History:
* 11-Apr-1995 Sanfords  Created
\***************************************************************************/

#ifdef NOEXTAPI
#undef NOEXTAPI
#endif // !NOEXTAPI

#define NOEXTAPI
#include <wdbgexts.h>

/*
 * Preceeding this header the following must have been defined:
 * PSTR pszExtName;
 *
 * This module includes "exts.h" which defines what exported functions are
 * supported by each extension and contains all help text and legal option
 * information.  At a minimum exts.h must have:

DOIT(   help
        ,"help -v [cmd]                 - Displays this list or gives details on command\n"
        ,"  help      - To dump short help text on all commands.\n"
         "  help -v   - To dump long help text on all commands.\n"
         "  help cmd  - To dump long help on given command.\n"
        ,"v"
        ,CUSTOM)

 */


extern HANDLE                  hCurrentProcess;
extern HANDLE                  hCurrentThread;
extern ULONG64                 dwCurrentPc;
extern WINDBG_EXTENSION_APIS  *lpExtensionApis;
extern DWORD                   dwProcessor;
extern WINDBG_EXTENSION_APIS   ExtensionApis;

#define Print           (lpExtensionApis->lpOutputRoutine)
#define OUTAHERE()      RtlRaiseStatus(STATUS_NONCONTINUABLE_EXCEPTION);
#define GetSym          (lpExtensionApis->lpGetSymbolRoutine)
#define ReadMem         (lpExtensionApis->lpReadProcessMemoryRoutine)
#define IsWinDbg()      (lpExtensionApis->nSize >= sizeof(WINDBG_EXTENSION_APIS))
#define SAFEWHILE(exp)  while (!IsCtrlCHit() && (exp))

extern PSTR pszAccessViolation;
extern PSTR pszMoveException;
extern PSTR pszReadFailure;

#define OPTS_ERROR 0xFFFFFFFF

#define OFLAG(l)        (1L << ((DWORD)#@l - (DWORD)'a'))
#define move(dst, src)  moveBlock(&(dst), src, sizeof(dst))
#define tryMove(dst, src)  tryMoveBlock(&(dst), src, sizeof(dst))
#define tryDword(pdst, src) tryMoveBlock(pdst, src, sizeof(DWORD))
//#define DEBUGPRINT      Print       // set this when debuging your extensions
#define DEBUGPRINT

VOID moveBlock(PVOID pdst, ULONG64 src, DWORD size);
BOOL tryMoveBlock(PVOID pdst, ULONG64 src, DWORD size);
VOID moveExp(PVOID pdst, LPSTR pszExp);
BOOL tryMoveExp(PVOID pdst, LPSTR pszExp);
VOID moveExpValue(PVOID pdst, LPSTR pszExp);
BOOL tryMoveExpValue(PVOID pdst, LPSTR pszExp);
BOOL tryMoveExpPtr(PULONG64 pdst, LPSTR pszExp);
VOID moveExpValuePtr(PULONG64 pdst, LPSTR pszExp);
BOOL IsCtrlCHit(VOID);

ULONG64 OptEvalExp(LPSTR psz);
ULONG64 OptEvalExp2(LPSTR *ppsz);
DWORD StringToOpts(LPSTR psz);
DWORD GetOpts(LPSTR *ppszArgs, LPSTR pszLegalArgs);
VOID PrintHuge(LPSTR psz);
ULONG64 EvalExp(LPSTR psz);

/*
 * entrypoint function type values
 */
#define NOARGS      0
#define STDARGS0    1
#define STDARGS1    2
#define STDARGS2    3
#define STDARGS3    4
#define STDARGS4    5
#define CUSTOM      9

/*
 * worker function prototype types
 */
typedef BOOL (* TYPE_NOARGS)(VOID);
typedef BOOL (* TYPE_STDARGS0)(DWORD);
typedef BOOL (* TYPE_STDARGS1)(DWORD, ULONG64);
typedef BOOL (* TYPE_STDARGS2)(DWORD, ULONG64, ULONG64);
typedef BOOL (* TYPE_STDARGS3)(DWORD, ULONG64, ULONG64, ULONG64);
typedef BOOL (* TYPE_STDARGS4)(DWORD, ULONG64, ULONG64, ULONG64, ULONG64);
typedef BOOL (* TYPE_CUSTOM)(DWORD, LPSTR);

/*
 * worker function proto-prototypes
 */
#define PROTO_NOARGS(name, opts)   BOOL I##name(VOID)
#define PROTO_STDARGS0(name, opts) BOOL I##name(DWORD options)
#define PROTO_STDARGS1(name, opts) BOOL I##name(DWORD options, ULONG64 param1)
#define PROTO_STDARGS2(name, opts) BOOL I##name(DWORD options, ULONG64 param1, ULONG64 param2)
#define PROTO_STDARGS3(name, opts) BOOL I##name(DWORD options, ULONG64 param1, ULONG64 param2, ULONG64 param3)
#define PROTO_STDARGS4(name, opts) BOOL I##name(DWORD options, ULONG64 param1, ULONG64 param2, ULONG64 param3, ULONG64 param4)
#define PROTO_CUSTOM(name, opts)   BOOL I##name(DWORD options, LPSTR pszArg)

/*
 * worker function prototypes (generated from exts.h)
 */
#define DOIT(name, h1, h2, opts, type) PROTO_##type(name, opts);
#include "exts.h"
#undef DOIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kdexts\kd\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

!include $(WINCORE_PATH)\core.inc

TARGETNAME=userkdx
TARGETTYPE=DYNLINK
TARGETPATH=$(_OBJ_DIR)

TARGETLIBS=$(SDK_LIB_PATH)\kernel32.lib

USE_MSVCRT=1

KERNEL=1

C_DEFINES=$(C_DEFINES) $(USER_C_DEFINES) -DUNICODE -D_USER32_ -DKERNEL -D_CROSS_PLATFORM_ -DTRACK_PNP_NOTIFICATION

!IFNDEF MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3
!ENDIF
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

INCLUDES=..\..;                                      \
        $(NTUSER_PATH)\kernel;                       \
        $(NTUSER_PATH)\kernel\$(O);                  \
        $(NTUSER_PATH)\kernel\$(ALT_PROJECT);        \
        $(NTUSER_PATH)\kernel\$(ALT_PROJECT)\$(O);   \
        $(NTUSER_PATH)\inc;                          \
        $(NTUSER_PATH)\inc\$(ALT_PROJECT);           \
        $(WINCORE_PATH)\w32inc;                      \
        $(WINCORE_PATH)\w32inc\$(O);                 \
        $(NTGDI_PATH)\inc;                           \
        $(WINCORE_PATH)\w32inc;                      \
        $(NTCON_PATH)\inc;                           \
        $(BASE_INC_PATH)

SOURCES=..\kdexts.c    \
        ..\userexts.c  \
        ..\userexts.rc

NTTARGETFILE0=$(O)\userkdx.def $(O)\wm.txt $(O)\vktbl.txt $(O)\ptagdbg.h
DLLDEF=$(O)\userkdx.def
UMTYPE=console

SOURCES_USED=..\sources.inc $(WINCORE_PATH)\core.inc

SUBSYSTEM_VERSION=4.0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kdexts\kd\kdexts.c ===
/****************************** Module Header ******************************\
* Module Name: kdexts.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This file is included in the SOURCES= line of sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#include "..\kdexts.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kdexts\ntsd\daytona\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kdexts\kd\userexts.c ===
/****************************** Module Header ******************************\
* Module Name: userexts.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This file is included in the SOURCES= line of sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "..\userexts.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kdexts\userexts.c ===
/****************************** Module Header ******************************\
* Module Name: userexts.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains user related debugging extensions.
*
* History:
* 17-May-1991 DarrinM   Created.
* 22-Jan-1992 IanJa     ANSI/Unicode neutral (all debug output is ANSI)
* 23-Mar-1993 JerrySh   Moved from winsrv.dll to userexts.dll
* 21-Oct-1993 JerrySh   Modified to work with WinDbg
* 18-Oct-1994 ChrisWil  Added Object Tracking extent.
* 26-May-1995 Sanfords  Made it more general for the good of humanity.
* 09-Jun-1995 SanfordS  Made to fit stdexts motif and to dual compile for
*                       either USER or KERNEL mode.
\***************************************************************************/
#include "userkdx.h"
#include "vkoem.h"

#ifdef KERNEL
CONST PSTR pszExtName = "USERKDX";
#else
CONST PSTR pszExtName = "USEREXTS";
#endif

#include <stdext64.h>
#include <stdext64.c>

/***************************************************************************\
* Constants
\***************************************************************************/
#define CDWORDS 16
#define BF_MAX_WIDTH    80
#define BF_COLUMN_WIDTH 19

#define PTR             ULONG64
#define NULL_POINTER    ((PTR)(0))

// If you want to debug the extension, enable this.
#if 0
#undef DEBUGPRINT
#define DEBUGPRINT  Print
#endif

/***************************************************************************\
* Global variables
\***************************************************************************/
BOOL bShowFlagNames = TRUE;
char gach1[80];
char gach2[80];
char gach3[80];
int giBFColumn;                     // bit field: current column
char gaBFBuff[BF_MAX_WIDTH + 1];    // bit field: buffer

// used in dsi() and dinp()
typedef struct {
    int     iMetric;
    LPSTR   pstrMetric;
} SYSMET_ENTRY;
#define SMENTRY(sm) {SM_##sm, #sm}

/***************************************************************************\
* Macros
\***************************************************************************/

#define TestWWF(pww, flag)   (*(((PBYTE)(pww)) + (int)HIBYTE(flag)) & LOBYTE(flag))

VOID ShowProgress(ULONG i);

#define CHKBREAK()  do { if (IsCtrlCHit()) return TRUE; } while (FALSE)


#ifdef KERNEL // ########### KERNEL MODE ONLY MACROS ###############

#define VAR(v)  "win32k!" #v
#define SYM(s)  "win32k!" #s
#define FIXKP(p) p
#define RebaseSharedPtr(p)       (p)

#define FOREACHWINDOWSTATION(pwinsta)               \
    pwinsta = GetGlobalPointer(VAR(grpWinStaList)); \
    SAFEWHILE (pwinsta != 0) {

#define NEXTEACHWINDOWSTATION(pwinsta)              \
        GetFieldValue(pwinsta, SYM(tagWINDOWSTATION), "rpwinstaNext", pwinsta);    \
    }



#define FOREACHDESKTOP(pdesk)                       \
    {                                               \
        ULONG64 pwinsta;                            \
                                                    \
        FOREACHWINDOWSTATION(pwinsta)               \
        GetFieldValue(pwinsta, SYM(WINDOWSTATION), "rpdeskList", pdesk);    \
        SAFEWHILE (pdesk != 0) {

#define NEXTEACHDESKTOP(pdesk)                      \
            GetFieldValue(pdesk, SYM(DESKTOP), "rpdeskNext", pdesk);        \
        }                                           \
        NEXTEACHWINDOWSTATION(pwinsta)              \
    }

VOID PrintStackTrace(
    ULONG64 pStackTrace,
    int    tracesCount);

typedef ULONG (WDBGAPI *PPI_CALLBACK)(ULONG64 ppi, PVOID Data);

typedef struct _PPI_CONTEXT {
    PPI_CALLBACK    CallbackRoutine;
    PVOID           Data;
} PPI_CONTEXT;

ULONG
ForEachPpiCallback(
    PFIELD_INFO   NextProcess,
    PVOID         Context)
{
    ULONG64 pEProcess = NextProcess->address;
    ULONG64 ppi = 0;
    PPI_CONTEXT *pPpiContext = (PPI_CONTEXT *)Context;

    /*
     * Dump Win32 Processes only
     */

    GetFieldValue(pEProcess, "nt!EPROCESS", "Win32Process", ppi);
    if (ppi) {
        return pPpiContext->CallbackRoutine(ppi, pPpiContext->Data);
    }

    return FALSE;
}

BOOL
ForEachPpi(
    PPI_CALLBACK CallbackRoutine,
    PVOID        Data)
{
    ULONG64 ProcessHead;
    ULONG64 NextProcess;
    PPI_CONTEXT PpiContext;

    ProcessHead = EvalExp("PsActiveProcessHead");
    if (!ProcessHead) {
        Print("Unable to get value of PsActiveProcessHead\n");
        return FALSE;
    }

    if (GetFieldValue(ProcessHead, "nt!_LIST_ENTRY", "Flink", NextProcess)) {
        Print("Unable to get value of PsActiveProcessHead\n");
        return FALSE;
    }
    if (NextProcess == 0) {
        Print("PsActiveProcessHead->Flink is NULL!\n");
        return FALSE;
    }

    PpiContext.CallbackRoutine = CallbackRoutine;
    PpiContext.Data = Data;
    ListType("nt!_EPROCESS",
             NextProcess,
             1,
             "ActiveProcessLinks.Flink",
             &PpiContext,
             ForEachPpiCallback);

    return TRUE;
}


typedef ULONG (WDBGAPI *PTI_CALLBACK)(ULONG64 pti, PVOID Data);

typedef struct _PTI_CONTEXT {
    PTI_CALLBACK    CallbackRoutine;
    PVOID           Data;
} PTI_CONTEXT;

ULONG
ForEachPtiCallback(
    ULONG64 ppi,
    PVOID   Data)
{
    ULONG64 pti = 0;
    PTI_CONTEXT *pPtiContext = (PTI_CONTEXT *)Data;

    if (GetFieldValue(ppi, SYM(PROCESSINFO), "ptiList", pti)) {
                    DEBUGPRINT("ForEachPti: Can't get ptiList from ppi 0x%p.\n", ppi);
    }

    SAFEWHILE (pti != 0) {
        pPtiContext->CallbackRoutine(pti, pPtiContext->Data);
        if (GetFieldValue(pti, SYM(THREADINFO), "ptiSibling", pti)) {
            DEBUGPRINT("ForEachPti: Can't get ptiSibling from pti 0x%p.\n", pti);
        }
    }

    return FALSE;
}

ULONG
ForEachPti(
    PTI_CALLBACK CallbackRoutine,
    PVOID        Data)
{
    PTI_CONTEXT PtiContext;

    PtiContext.CallbackRoutine = CallbackRoutine;
    PtiContext.Data = Data;
    return ForEachPpi(ForEachPtiCallback, &PtiContext);
}


#else //!KERNEL  ############## USER MODE ONLY MACROS ################

VOID PrivateSetRipFlags(DWORD dwRipFlags, DWORD pid);

#define VAR(v)  "user32!" #v
#define SYM(s)  "user32!" #s
#define FIXKP(p) FixKernelPointer(p)

#endif //!KERNEL ############## EITHER MODE MACROS ###################

#define GETSHAREDINFO(psi) moveExp(&psi, VAR(gSharedInfo))


#define FOREACHHANDLEENTRY(phe, i)                                   \
    {                                                                \
        ULONG64 pshi, psi, cHandleEntries;                           \
        ULONG dwHESize = GetTypeSize(SYM(HANDLEENTRY));              \
                                                                     \
        GETSHAREDINFO(pshi);                                         \
        if (GetFieldValue(pshi, SYM(SHAREDINFO), "psi", psi)) {      \
            Print("FOREACHHANDLEENTRY:Could not get SERVERINFO from SHAREDINFO %p\n", pshi); \
        }                                                            \
        GetFieldValue(pshi, SYM(SHAREDINFO), "aheList", phe);        \
        GetFieldValue(psi, SYM(SERVERINFO), "cHandleEntries", cHandleEntries); \
        for (i = 0; cHandleEntries; cHandleEntries--, i++, phe += dwHESize) {  \
            if (IsCtrlCHit()) {                                      \
                break;                                               \
            }

#define NEXTEACHHANDLEENTRY()                                        \
        }                                                            \
    }

/*
 * Use these macros to print field values, globals, local values, etc.
 * This assures consistent formating plus make the extensions easier to read and to maintain.
 */
#define STRWD1 "67"
#define STRWD2 "28"
#define DWSTR1 "%08lx %." STRWD1 "s"
#define DWSTR2 "%08lx %-" STRWD2 "." STRWD2 "s"
#define PTRSTR1 "%08p %-" STRWD1 "s"
#define PTRSTR2 "%08p %-" STRWD2 "." STRWD2 "s"
#define DWPSTR1 "%08p %." STRWD1 "s"
#define DWPSTR2 "%08p %-" STRWD2 "." STRWD2 "s"
#define PRTFDW1(f1) Print(DWSTR1 "\n", ReadField(f1), #f1)
#define PRTVDW1(s1, v1) Print(DWSTR1 "\n", v1, #s1)
#define PRTFDW2(f1, f2) Print(DWSTR2 "\t" DWSTR2 "\n", (DWORD)ReadField(f1), #f1, (DWORD)ReadField(f2), #f2)
#define PRTVDW2(s1, v1, s2, v2) Print(DWSTR2 "\t" DWPSTR2 "\n", v1, #s1, v2, #s2)
#define PRTFRC(p, rc) Print("%-" STRWD2 "s{%#lx, %#lx, %#lx, %#lx}\n", #rc, ##p##rc.left, ##p##rc.top, ##p##rc.right, ##p##rc.bottom)
#define PRTFPT(pt) Print("%-" STRWD2 "s{0x%x, 0x%x}\n", #pt, ReadField(pt.x), ReadField(pt.y))
#define PRTVPT(s, pt) Print("%-" STRWD2 "s{0x%x, 0x%x}\n", #s, pt.x, pt.y)
#define PRTFDWP1(f1) Print(DWPSTR1 "\n", ReadField(f1), #f1)
#define PRTFDWP2(f1, f2) Print(DWPSTR2 "\t" DWPSTR2 "\n", ReadField(f1), #f1, ReadField(f2), #f2)
#define PRTFDWPDW(f1, f2) Print(DWPSTR2 "\t" DWSTR2 "\n", ReadField(f1), #f1, ReadField(f2), #f2)
#define PRTFDWDWP(p, f1, f2) Print(DWSTR2 "\t" DWPSTR2 "\n", (DWORD)##p##f1, #f1, (DWORD_PTR)##p##f2, #f2)

/*
 * Bit Fields
 */
#define BEGIN_PRTFFLG(p, type) InitTypeRead(p, type)
#define PRTFFLG(f)   PrintBitField(#f, (BOOL)!!(ReadField(f)))
#define END_PRTFFLG()   PrintEndBitField()


#define PRTGDW1(g1) \
        { DWORD _dw1; \
            moveExpValue(&_dw1, VAR(g1)); \
            Print(DWSTR1 "\n", _dw1, #g1); }

#define PRTGDW2(g1, g2) \
        { DWORD _dw1, _dw2; \
            moveExpValue(&_dw1, VAR(g1)); \
            moveExpValue(&_dw2, VAR(g2)); \
            Print(DWSTR2 "\t" DWSTR2 "\n",  _dw1, #g1, _dw2, #g2); }

#define PRTGPTR1(g1) \
    Print(PTRSTR1 "\n", GetGlobalPointer(VAR(g1)), #g1)

#define PRTGPTR2(g1, g2) \
    Print(PTRSTR2 "\t" PTRSTR2 "\n", GetGlobalPointer(VAR(g1)), #g1, GetGlobalPointer(VAR(g2)), #g2)


/* This macro requires char ach[...]; to be previously defined */
#define PRTWND(s, pwnd) \
        { DebugGetWindowTextA(pwnd, ach, ARRAY_SIZE(ach)); \
            Print("%-" STRWD2 "s" DWPSTR2 "\n", #s, pwnd, ach); }

#define PRTGWND(gpwnd) \
        { ULONG64 _pwnd; \
            moveExpValuePtr(&_pwnd, VAR(gpwnd)); \
            DebugGetWindowTextA(_pwnd, ach, ARRAY_SIZE(ach)); \
            Print("%-" STRWD2 "s" DWPSTR2 "\n", #gpwnd, _pwnd, ach); }

#ifdef LATER    // macros above need fix... and callers as well that mix up DWORD and PVOID.
#define PRTGDW1(g1) \
        {\
            DWORD _dw1 = GetGlobalDWord(VAR(g1)); \
            Print(DWSTR1 "\n", _dw1, #g1); \
        }

#define PRTGDW2(g1, g2) \
        {\
            DWORD _dw1 = GetGlobalDWord(VAR(g1)); \
            DWORD _dw2 = GetGlobalDWord(VAR(g2)); \
            Print(DWSTR2 "\t" DWSTR2 "\n", _dw1, #g1, _dw2, #g2); \
        }

#define PRTGWND(gpwnd) \
        { ULONG64 _pwnd = GetGlobalPointer(VAR(gpwnd)); \
            DebugGetWindowTextA(_pwnd, ach); \
            Print("%-" STRWD2 "s" DWPSTR2 "\n", #gpwnd, _pwnd, ach); }
#endif  // LATER



/****************************************************************************\
* PROTOTYPES
*  Note that all Ixxx proc prototypes are generated by stdexts.h
\****************************************************************************/
#ifdef KERNEL

BOOL GetAndDumpHE(ULONG64 dwT, PULONG64 phe, BOOL fPointerTest);
LPSTR ProcessName(ULONG64 ppi);

#else // !KERNEL

ULONG64 FixKernelPointer(ULONG64 pKernel);
BOOL DumpConvInfo(PCONV_INFO pcoi);
VOID PrivateSetDbgTag(int tag, DWORD dwDBGTAGFlags);

#endif // !KERNEL

LPSTR GetFlags(WORD wType, DWORD dwFlags, LPSTR pszBuf, BOOL fPrintZero);
BOOL HtoHE(ULONG64 h, ULONG64 *pphe);
ULONG64 GetPfromH(ULONG64 h, ULONG64 *pphe);
BOOL getHEfromP(ULONG64 *pphe, ULONG64 p);
ULONG64 HorPtoP(ULONG64 p, int type);
BOOL DebugGetWindowTextA(ULONG64 pwnd, char *achDest, DWORD dwLength);
BOOL DebugGetClassNameA(ULONG64 lpszClassName, char *achDest);
BOOL dwrWorker(ULONG64 pwnd, int tab);
BOOL CopyUnicodeString(
    IN  ULONG64 pData,
    IN  char * pszStructName,
    IN  char * pszFieldName,
    OUT WCHAR *pszDest,
    IN  ULONG cchMax);

BOOL IsRemoteSession(
    VOID)
{
    PPEB ppeb = NtCurrentPeb();

    return (ppeb->SessionId != 0);
}

int PtrWidth(
    VOID)
{
    static int width = 0;

    if (width) {
        return width;
    }

    if (IsPtr64()) {
        return (width = 17);
    } else {
        return (width = 8);
    }
}


/****************************************************************************\
* Flags stuff
\****************************************************************************/

typedef struct _WFLAGS {
    PSZ     pszText;
    WORD    wFlag;
} WFLAGS;

#define WF_ENTRY(flag)  #flag, flag

CONST WFLAGS aWindowFlags[] = { // sorted alphabetically
    WF_ENTRY(BFBITMAP),
    WF_ENTRY(BFBOTTOM),
    WF_ENTRY(BFCENTER),
    WF_ENTRY(BFFLAT),
    WF_ENTRY(BFICON),
    WF_ENTRY(BFLEFT),
    WF_ENTRY(BFMULTILINE),
    WF_ENTRY(BFNOTIFY),
    WF_ENTRY(BFPUSHLIKE),
    WF_ENTRY(BFRIGHT),
    WF_ENTRY(BFRIGHTBUTTON),
    WF_ENTRY(BFTOP),
    WF_ENTRY(BFVCENTER),
    WF_ENTRY(CBFAUTOHSCROLL),
    WF_ENTRY(CBFBUTTONUPTRACK),
    WF_ENTRY(CBFDISABLENOSCROLL),
    WF_ENTRY(CBFDROPDOWN),
    WF_ENTRY(CBFDROPDOWNLIST),
    WF_ENTRY(CBFDROPPABLE),
    WF_ENTRY(CBFDROPTYPE),
    WF_ENTRY(CBFEDITABLE),
    WF_ENTRY(CBFHASSTRINGS),
    WF_ENTRY(CBFLOWERCASE),
    WF_ENTRY(CBFNOINTEGRALHEIGHT),
    WF_ENTRY(CBFOEMCONVERT),
    WF_ENTRY(CBFOWNERDRAW),
    WF_ENTRY(CBFOWNERDRAWFIXED),
    WF_ENTRY(CBFOWNERDRAWVAR),
    WF_ENTRY(CBFSIMPLE),
    WF_ENTRY(CBFSORT),
    WF_ENTRY(CBFUPPERCASE),
    WF_ENTRY(DF3DLOOK),
    WF_ENTRY(DFCONTROL),
    WF_ENTRY(DFLOCALEDIT),
    WF_ENTRY(DFNOFAILCREATE),
    WF_ENTRY(DFSYSMODAL),
    WF_ENTRY(EFAUTOHSCROLL),
    WF_ENTRY(EFAUTOVSCROLL),
    WF_ENTRY(EFCOMBOBOX),
    WF_ENTRY(EFLOWERCASE),
    WF_ENTRY(EFMULTILINE),
    WF_ENTRY(EFNOHIDESEL),
    WF_ENTRY(EFNUMBER),
    WF_ENTRY(EFOEMCONVERT),
    WF_ENTRY(EFPASSWORD),
    WF_ENTRY(EFREADONLY),
    WF_ENTRY(EFUPPERCASE),
    WF_ENTRY(EFWANTRETURN),
    WF_ENTRY(SBFSIZEBOX),
    WF_ENTRY(SBFSIZEBOXBOTTOMRIGHT),
    WF_ENTRY(SBFSIZEBOXTOPLEFT),
    WF_ENTRY(SBFSIZEGRIP),
    WF_ENTRY(SFCENTERIMAGE),
    WF_ENTRY(SFEDITCONTROL),
    WF_ENTRY(SFELLIPSISMASK),
    WF_ENTRY(SFNOPREFIX),
    WF_ENTRY(SFNOTIFY),
    WF_ENTRY(SFREALSIZECONTROL),
    WF_ENTRY(SFREALSIZEIMAGE),
    WF_ENTRY(SFRIGHTJUST),
    WF_ENTRY(SFSUNKEN),
    WF_ENTRY(WEFACCEPTFILES),
    WF_ENTRY(WEFAPPWINDOW),
    WF_ENTRY(WEFCLIENTEDGE),
    WF_ENTRY(WEFCOMPOSITED),
    WF_ENTRY(WEFCONTEXTHELP),
    WF_ENTRY(WEFCONTROLPARENT),
    WF_ENTRY(WEFDLGMODALFRAME),
    WF_ENTRY(WEFDRAGOBJECT),
#ifdef REDIRECTION
    WF_ENTRY(WEFEXTREDIRECTED),
#endif
    WF_ENTRY(WEFGHOSTMAKEVISIBLE),
#ifdef LAME_BUTTON
    WF_ENTRY(WEFLAMEBUTTON),
#endif // LAME_BUTTON
    WF_ENTRY(WEFLEFTSCROLL),
    WF_ENTRY(WEFMDICHILD),
    WF_ENTRY(WEFNOACTIVATE),
    WF_ENTRY(WEFNOPARENTNOTIFY),
    WF_ENTRY(WEFRIGHT),
    WF_ENTRY(WEFRTLREADING),
    WF_ENTRY(WEFSTATICEDGE),
    WF_ENTRY(WEFLAYERED),
    WF_ENTRY(WEFTOOLWINDOW),
    WF_ENTRY(WEFTOPMOST),
    WF_ENTRY(WEFTRANSPARENT),
    WF_ENTRY(WEFTRUNCATEDCAPTION),
    WF_ENTRY(WEFWINDOWEDGE),
    WF_ENTRY(WFALWAYSSENDNCPAINT),
    WF_ENTRY(WFANSICREATOR),
    WF_ENTRY(WFANSIPROC),
    WF_ENTRY(WFANYHUNGREDRAW),
    WF_ENTRY(WFBEINGACTIVATED),
    WF_ENTRY(WFBORDER),
    WF_ENTRY(WFBOTTOMMOST),
    WF_ENTRY(WFCAPTION),
    WF_ENTRY(WFCEPRESENT),
    WF_ENTRY(WFCHILD),
    WF_ENTRY(WFCLIPCHILDREN),
    WF_ENTRY(WFCLIPSIBLINGS),
    WF_ENTRY(WFCLOSEBUTTONDOWN),
    WF_ENTRY(WFCPRESENT),
    WF_ENTRY(WFDESTROYED),
    WF_ENTRY(WFDIALOGWINDOW),
    WF_ENTRY(WFDISABLED),
    WF_ENTRY(WFDLGFRAME),
    WF_ENTRY(WFDONTVALIDATE),
    WF_ENTRY(WFERASEBKGND),
    WF_ENTRY(WFFRAMEON),
    WF_ENTRY(WFFULLSCREEN),
    WF_ENTRY(WFGOTQUERYSUSPENDMSG),
    WF_ENTRY(WFGOTSUSPENDMSG),
    WF_ENTRY(WFGROUP),
    WF_ENTRY(WFHASPALETTE),
    WF_ENTRY(WFHASSPB),
    WF_ENTRY(WFHELPBUTTONDOWN),
    WF_ENTRY(WFHIDDENPOPUP),
    WF_ENTRY(WFHPRESENT),
    WF_ENTRY(WFHSCROLL),
    WF_ENTRY(WFICONICPOPUP),
    WF_ENTRY(WFINDESTROY),
    WF_ENTRY(WFINTERNALPAINT),
    WF_ENTRY(WFLINEDNBUTTONDOWN),
    WF_ENTRY(WFLINEUPBUTTONDOWN),
    WF_ENTRY(WFMAXBOX),
    WF_ENTRY(WFMAXFAKEREGIONAL),
    WF_ENTRY(WFMAXIMIZED),
    WF_ENTRY(WFMENUDRAW),
    WF_ENTRY(WFMINBOX),
    WF_ENTRY(WFMINIMIZED),
    WF_ENTRY(WFMPRESENT),
    WF_ENTRY(WFMSGBOX),
    WF_ENTRY(WFNOANIMATE),
    WF_ENTRY(WFNOIDLEMSG),
    WF_ENTRY(WFNONCPAINT),
    WF_ENTRY(WFOLDUI),
    WF_ENTRY(WFPAGEUPBUTTONDOWN),
    WF_ENTRY(WFPAGEDNBUTTONDOWN),
    WF_ENTRY(WFPAINTNOTPROCESSED),
    WF_ENTRY(WFPIXIEHACK),
    WF_ENTRY(WFPOPUP),
    WF_ENTRY(WFREALLYMAXIMIZABLE),
    WF_ENTRY(WFREDRAWFRAMEIFHUNG),
    WF_ENTRY(WFREDRAWIFHUNG),
    WF_ENTRY(WFREDUCEBUTTONDOWN),
    WF_ENTRY(WFSCROLLBUTTONDOWN),
    WF_ENTRY(WFSENDERASEBKGND),
    WF_ENTRY(WFSENDNCPAINT),
    WF_ENTRY(WFSENDSIZEMOVE),
    WF_ENTRY(WFSERVERSIDEPROC),
    WF_ENTRY(WFSHELLHOOKWND),
    WF_ENTRY(WFSIZEBOX),
    WF_ENTRY(WFSMQUERYDRAGICON),
    WF_ENTRY(WFSTARTPAINT),
    WF_ENTRY(WFSYNCPAINTPENDING),
    WF_ENTRY(WFSYSMENU),
    WF_ENTRY(WFTABSTOP),
    WF_ENTRY(WFTILED),
    WF_ENTRY(WFTITLESET),
    WF_ENTRY(WFTOGGLETOPMOST),
    WF_ENTRY(WFTOPLEVEL),
    WF_ENTRY(WFUPDATEDIRTY),
    WF_ENTRY(WFVERTSCROLLTRACK),
    WF_ENTRY(WFVISIBLE),
    WF_ENTRY(WFVPRESENT),
    WF_ENTRY(WFVSCROLL),
    WF_ENTRY(WFWIN31COMPAT),
    WF_ENTRY(WFWIN40COMPAT),
    WF_ENTRY(WFWIN50COMPAT),
    WF_ENTRY(WFWMPAINTSENT),
    WF_ENTRY(WFZOOMBUTTONDOWN),
};

CONST PCSTR aszTypeNames[/*TYPE_CTYPES*/] = {
    "Free",
    "Window",
    "Menu",
    "Icon/Cursor",
    "WPI(SWP) struct",
    "Hook",
    "Clipboard Data",
    "CallProcData",
    "Accelerator",
    "DDE access",
    "DDE conv",
    "DDE Transaction",
    "Monitor",
    "Keyboard Layout",
    "Keyboard File",
    "WinEvent hook",
    "Timer",
    "Input Context",
#ifdef GENERIC_INPUT
    "HID Raw Data",
    "DEVICE INFO",
 #ifdef GI_PROCESSOR
    "Pre/PostProcessor",
 #endif
#endif // GENERIC_INPUT
    "unknown",
};

#include "ptagdbg.h"   // derived from ntuser\kernel\ptag.lst and .\ptagdbg.bat

#define NO_FLAG (LPCSTR)(LONG_PTR)0xFFFFFFFF  // use this for non-meaningful entries.
#define _MASKENUM_START         (NO_FLAG-1)
#define _MASKENUM_END           (NO_FLAG-2)
#define _SHIFT_BITS             (NO_FLAG-3)
#define _CONTINUE_ON            (NO_FLAG-4)

#define MASKENUM_START(mask)    _MASKENUM_START, (LPCSTR)(mask)
#define MASKENUM_END(shift)     _MASKENUM_END, (LPCSTR)(shift)
#define SHIFT_BITS(n)           _SHIFT_BITS, (LPCSTR)(n)
#define CONTINUE_ON(arr)        _CONTINUE_ON, (LPCSTR)(arr)

CONST PCSTR apszSmsFlags[] = {
   "SMF_REPLY"                , // 0x0001
   "SMF_RECEIVERDIED"         , // 0x0002
   "SMF_SENDERDIED"           , // 0x0004
   "SMF_RECEIVERFREE"         , // 0x0008
   "SMF_RECEIVEDMESSAGE"      , // 0x0010
    NO_FLAG                   , // 0x0020
    NO_FLAG                   , // 0x0040
    NO_FLAG                   , // 0x0080
   "SMF_CB_REQUEST"           , // 0x0100
   "SMF_CB_REPLY"             , // 0x0200
   "SMF_CB_CLIENT"            , // 0x0400
   "SMF_CB_SERVER"            , // 0x0800
   "SMF_WOWRECEIVE"           , // 0x1000
   "SMF_WOWSEND"              , // 0x2000
   "SMF_RECEIVERBUSY"         , // 0x4000
    NULL                        // 0x8000
};

CONST PCSTR apszTifFlags[] = {
   "TIF_INCLEANUP"                   , // 0x00000001
   "TIF_16BIT"                       , // 0x00000002
   "TIF_SYSTEMTHREAD"                , // 0x00000004
   "TIF_CSRSSTHREAD"                 , // 0x00000008
   "TIF_TRACKRECTVISIBLE"            , // 0x00000010
   "TIF_ALLOWFOREGROUNDACTIVATE"     , // 0x00000020
   "TIF_DONTATTACHQUEUE"             , // 0x00000040
   "TIF_DONTJOURNALATTACH"           , // 0x00000080
   "TIF_WOW64"                       , // 0x00000100
   "TIF_INACTIVATEAPPMSG"            , // 0x00000200
   "TIF_SPINNING"                    , // 0x00000400
   "TIF_PALETTEAWARE"                , // 0x00000800
   "TIF_SHAREDWOW"                   , // 0x00001000
   "TIF_FIRSTIDLE"                   , // 0x00002000
   "TIF_WAITFORINPUTIDLE"            , // 0x00004000
   "TIF_MOVESIZETRACKING"            , // 0x00008000
   "TIF_VDMAPP"                      , // 0x00010000
   "TIF_DOSEMULATOR"                 , // 0x00020000
   "TIF_GLOBALHOOKER"                , // 0x00040000
   "TIF_DELAYEDEVENT"                , // 0x00080000
   "TIF_MSGPOSCHANGED"               , // 0x00100000
   "TIF_SHUTDOWNCOMPLETE"            , // 0x00200000
   "TIF_IGNOREPLAYBACKDELAY"         , // 0x00400000
   "TIF_ALLOWOTHERACCOUNTHOOK"       , // 0x00800000
   "TIF_GUITHREADINITIALIZED"        , // 0x01000000
   "TIF_DISABLEIME"                  , // 0x02000000
   "TIF_INGETTEXTLENGTH"             , // 0x04000000
   "TIF_ANSILENGTH"                  , // 0x08000000
   "TIF_DISABLEHOOKS"                , // 0x10000000
   "TIF_RESTRICTED"                  , // 0x20000000
   "TIF_QUITPOSTED"                  , // 0x40000000
    NULL                               // no more
};

CONST PCSTR apszQsFlags[] = {
     "QS_KEY"             , //  0x0001
     "QS_MOUSEMOVE"       , //  0x0002
     "QS_MOUSEBUTTON"     , //  0x0004
     "QS_POSTMESSAGE"     , //  0x0008
     "QS_TIMER"           , //  0x0010
     "QS_PAINT"           , //  0x0020
     "QS_SENDMESSAGE"     , //  0x0040
     "QS_HOTKEY"          , //  0x0080
     "QS_ALLPOSTMESSAGE"  , //  0x0100
     "QS_SMSREPLY"        , //  0x0200
     "QS_RAWINPUT"        , //  0x0400
     "QS_THREADATTACHED"  , //  0x0800
     "QS_EXCLUSIVE"       , //  0x1000
     "QS_EVENT"           , //  0x2000
     "QS_TRANSFER"        , //  0X4000
     NULL                   //  0x8000
};

CONST PCSTR apszMfFlags[] = {
    "MF_GRAYED"             , // 0x0001
    "MF_DISABLED"           , // 0x0002
    "MF_BITMAP"             , // 0x0004
    "MF_CHECKED"            , // 0x0008
    "MF_POPUP"              , // 0x0010
    "MF_MENUBARBREAK"       , // 0x0020
    "MF_MENUBREAK"          , // 0x0040
    "MF_HILITE"             , // 0x0080
    "MF_OWNERDRAW"          , // 0x0100
    "MF_USECHECKBITMAPS"    , // 0x0200
    NO_FLAG                 , // 0x0400
    "MF_SEPARATOR"          , // 0x0800
    "MF_DEFAULT"            , // 0x1000
    "MF_SYSMENU"            , // 0x2000
    "MF_RIGHTJUSTIFY"       , // 0x4000
    "MF_MOUSESELECT"        , // 0x8000
     NULL
};

CONST PCSTR apszCsfFlags[] = {
    "CSF_SERVERSIDEPROC"      , // 0x0001
    "CSF_ANSIPROC"            , // 0x0002
    "CSF_WOWDEFERDESTROY"     , // 0x0004
    "CSF_SYSTEMCLASS"         , // 0x0008
    "CSF_WOWCLASS"            , // 0x0010
    "CSF_WOWEXTRA"            , // 0x0020
    "CSF_CACHEDSMICON"        , // 0x0040
    "CSF_WIN40COMPAT"         , // 0x0080
    "CSF_VERSIONCLASS"        , // 0x0100
    NULL                        //
};

CONST PCSTR apszCsFlags[] = {
    "CS_VREDRAW"          , // 0x0001
    "CS_HREDRAW"          , // 0x0002
    "CS_KEYCVTWINDOW"     , // 0x0004
    "CS_DBLCLKS"          , // 0x0008
    NO_FLAG               , // 0x0010
    "CS_OWNDC"            , // 0x0020
    "CS_CLASSDC"          , // 0x0040
    "CS_PARENTDC"         , // 0x0080
    "CS_NOKEYCVT"         , // 0x0100
    "CS_NOCLOSE"          , // 0x0200
    NO_FLAG               , // 0x0400
    "CS_SAVEBITS"         , // 0x0800
    "CS_BYTEALIGNCLIENT"  , // 0x1000
    "CS_BYTEALIGNWINDOW"  , // 0x2000
    "CS_GLOBALCLASS"      , // 0x4000
    NO_FLAG               , // 0x8000
    "CS_IME"              , // 0x10000
    "CS_DROPSHADOW"       , // 0x20000
    NULL                    // no more
};

CONST PCSTR apszQfFlags[] = {
    "QF_UPDATEKEYSTATE"         , // 0x0000001
    "used to be ALTTAB"         , // 0x0000002
    "QF_FMENUSTATUSBREAK"       , // 0x0000004
    "QF_FMENUSTATUS"            , // 0x0000008
    "QF_FF10STATUS"             , // 0x0000010
    "QF_MOUSEMOVED"             , // 0x0000020
    "QF_ACTIVATIONCHANGE"       , // 0x0000040
    "QF_TABSWITCHING"           , // 0x0000080
    "QF_KEYSTATERESET"          , // 0x0000100
    "QF_INDESTROY"              , // 0x0000200
    "QF_LOCKNOREMOVE"           , // 0x0000400
    "QF_FOCUSNULLSINCEACTIVE"   , // 0x0000800
    NO_FLAG                     , // 0x0001000
    NO_FLAG                     , // 0x0002000
    "QF_DIALOGACTIVE"           , // 0x0004000
    "QF_EVENTDEACTIVATEREMOVED" , // 0x0008000
    NO_FLAG                     , // 0x0010000
    "QF_TRACKMOUSELEAVE"        , // 0x0020000
    "QF_TRACKMOUSEHOVER"        , // 0x0040000
    "QF_TRACKMOUSEFIRING"       , // 0x0080000
    "QF_CAPTURELOCKED"          , // 0x00100000
    "QF_ACTIVEWNDTRACKING"      , // 0x00200000
    NULL
};

CONST PCSTR apszW32pfFlags[] = {
    "W32PF_CONSOLEAPPLICATION"       , // 0x00000001
    "W32PF_FORCEOFFFEEDBACK"         , // 0x00000002
    "W32PF_STARTGLASS"               , // 0x00000004
    "W32PF_WOW"                      , // 0x00000008
    "W32PF_READSCREENACCESSGRANTED"  , // 0x00000010
    "W32PF_INITIALIZED"              , // 0x00000020
    "W32PF_APPSTARTING"              , // 0x00000040
    "W32PF_WOW64"                    , // 0x00000080
    "W32PF_ALLOWFOREGROUNDACTIVATE"  , // 0x00000100
    "W32PF_OWNDCCLEANUP"             , // 0x00000200
    "W32PF_SHOWSTARTGLASSCALLED"     , // 0x00000400
    "W32PF_FORCEBACKGROUNDPRIORITY"  , // 0x00000800
    "W32PF_TERMINATED"               , // 0x00001000
    "W32PF_CLASSESREGISTERED"        , // 0x00002000
    "W32PF_THREADCONNECTED"          , // 0x00004000
    "W32PF_PROCESSCONNECTED"         , // 0x00008000
    "W32PF_WAKEWOWEXEC"              , // 0x00010000
    "W32PF_WAITFORINPUTIDLE"         , // 0x00020000
    "W32PF_IOWINSTA"                 , // 0x00040000
    "W32PF_CONSOLEFOREGROUND"        , // 0x00080000
    "W32PF_OLELOADED"                , // 0x00100000
    "W32PF_SCREENSAVER"              , // 0x00200000
    "W32PF_IDLESCREENSAVER"          , // 0x00400000
    NULL
};


CONST PCSTR apszHeFlags[] = {
   "HANDLEF_DESTROY"               , // 0x0001
   "HANDLEF_INDESTROY"             , // 0x0002
   "HANDLEF_INWAITFORDEATH"        , // 0x0004
   "HANDLEF_FINALDESTROY"          , // 0x0008
   "HANDLEF_MARKED_OK"             , // 0x0010
   "HANDLEF_GRANTED"               , // 0x0020
    NULL                             // 0x0040
};


CONST PCSTR apszHdataFlags[] = {
     "HDATA_APPOWNED"          , // 0x0001
     NO_FLAG                   , // 0x0002
     NO_FLAG                   , // 0x0004
     NO_FLAG                   , // 0x0008
     NO_FLAG                   , // 0x0010
     NO_FLAG                   , // 0x0020
     NO_FLAG                   , // 0x0040
     NO_FLAG                   , // 0x0080
     "HDATA_EXECUTE"           , // 0x0100
     "HDATA_INITIALIZED"       , // 0x0200
     NO_FLAG                   , // 0x0400
     NO_FLAG                   , // 0x0800
     NO_FLAG                   , // 0x1000
     NO_FLAG                   , // 0x2000
     "HDATA_NOAPPFREE"         , // 0x4000
     "HDATA_READONLY"          , // 0x8000
     NULL
};

CONST PCSTR apszXiFlags[] = {
     "XIF_SYNCHRONOUS"    , // 0x0001
     "XIF_COMPLETE"       , // 0x0002
     "XIF_ABANDONED"      , // 0x0004
     NULL
};

CONST PCSTR apszIifFlags[] = {
     "IIF_IN_SYNC_XACT"   , // 0x0001
     NO_FLAG              , // 0x0002
     NO_FLAG              , // 0x0004
     NO_FLAG              , // 0x0008
     NO_FLAG              , // 0x0010
     NO_FLAG              , // 0x0020
     NO_FLAG              , // 0x0040
     NO_FLAG              , // 0x0080
     NO_FLAG              , // 0x0100
     NO_FLAG              , // 0x0200
     NO_FLAG              , // 0x0400
     NO_FLAG              , // 0x0800
     NO_FLAG              , // 0x1000
     NO_FLAG              , // 0x2000
     NO_FLAG              , // 0x4000
     "IIF_UNICODE"        , // 0x8000
     NULL
};

CONST PCSTR apszTmrfFlags[] = {
     "TMRF_READY"         , // 0x0001
     "TMRF_SYSTEM"        , // 0x0002
     "TMRF_RIT"           , // 0x0004
     "TMRF_INIT"          , // 0x0008
     "TMRF_ONESHOT"       , // 0x0010
     "TMRF_WAITING"       , // 0x0020
     "TMRF_PTIWINDOW"     , // 0x0040
     NULL                 , // 0x0080
};


CONST PCSTR apszSbFlags[] = {
    "SB_VERT"             , // 0x0001
    "SB_CTL"              , // 0x0002
     NULL                 , // 0x0004
};


CONST PCSTR apszCSFlags[] = {
    "FS_LATIN1"           , // 0x00000001L
    "FS_LATIN2"           , // 0x00000002L
    "FS_CYRILLIC"         , // 0x00000004L
    "FS_GREEK"            , // 0x00000008L
    "FS_TURKISH"          , // 0x00000010L
    "FS_HEBREW"           , // 0x00000020L
    "FS_ARABIC"           , // 0x00000040L
    "FS_BALTIC"           , // 0x00000080L
    "FS_VIETNAMESE"       , // 0x00000100L
     NO_FLAG              , // 0x00000200L
     NO_FLAG              , // 0x00000400L
     NO_FLAG              , // 0x00000800L
     NO_FLAG              , // 0x00001000L
     NO_FLAG              , // 0x00002000L
     NO_FLAG              , // 0x00004000L
     NO_FLAG              , // 0x00008000L
    "FS_THAI"             , // 0x00010000L
    "FS_JISJAPAN"         , // 0x00020000L
    "FS_CHINESESIMP"      , // 0x00040000L
    "FS_WANSUNG"          , // 0x00080000L
    "FS_CHINESETRAD"      , // 0x00100000L
    "FS_JOHAB"            , // 0x00200000L
     NO_FLAG              , // 0x00400000L
     NO_FLAG              , // 0x00800000L
     NO_FLAG              , // 0x01000000L
     NO_FLAG              , // 0x02000000L
     NO_FLAG              , // 0x04000000L
     NO_FLAG              , // 0x08000000L
     NO_FLAG              , // 0x10000000L
     NO_FLAG              , // 0x20000000L
     NO_FLAG              , // 0x40000000L
    "FS_SYMBOL"           , // 0x80000000L
    NULL
};


CONST PCSTR apszMenuTypeFlags[] = {
    NO_FLAG               , // 0x0001
    NO_FLAG               , // 0x0002
    "MFT_BITMAP"          , // 0x0004 MF_BITMAP
    NO_FLAG               , // 0x0008
    "MF_POPUP"            , // 0x0010
    "MFT_MENUBARBREAK"    , // 0x0020 MF_MENUBARBREAK
    "MFT_MENUBREAK"       , // 0x0040 MF_MENUBREAK
    NO_FLAG               , // 0x0080
    "MFT_OWNERDRAW"       , // 0x0100 MF_OWNERDRAW
    NO_FLAG               , // 0x0200
    NO_FLAG               , // 0x0400
    "MFT_SEPARATOR"       , // 0x0800 MF_SEPARATOR
    NO_FLAG               , // 0x1000
    "MF_SYSMENU"          , // 0x2000
    "MFT_RIGHTJUSTIFY"    , // 0x4000 MF_RIGHTJUSTIFY
    NULL
};

CONST PCSTR apszMenuStateFlags[] = {
    "MF_GRAYED"           , // 0x0001
    "MF_DISABLED"         , // 0x0002
    NO_FLAG               , // 0x0004
    "MFS_CHECKED"         , // 0x0008 MF_CHECKED
    NO_FLAG               , // 0x0010
    NO_FLAG               , // 0x0020
    NO_FLAG               , // 0x0040
    "MFS_HILITE"          , // 0x0080 MF_HILITE
    NO_FLAG               , // 0x0100
    NO_FLAG               , // 0x0200
    NO_FLAG               , // 0x0400
    NO_FLAG               , // 0x0800
    "MFS_DEFAULT"         , // 0x1000 MF_DEFAULT
    NO_FLAG               , // 0x2000
    NO_FLAG               , // 0x4000
    "MF_MOUSESELECT"      , // 0x8000
    NULL
};


CONST PCSTR apszCursorfFlags[] = {
    "CURSORF_FROMRESOURCE", //    0x0001
    "CURSORF_GLOBAL",       //    0x0002
    "CURSORF_LRSHARED",     //    0x0004
    "CURSORF_ACON",         //    0x0008
    "CURSORF_WOWCLEANUP"  , //    0x0010
    NO_FLAG               , //    0x0020
    "CURSORF_ACONFRAME",    //    0x0040
    "CURSORF_SECRET",       //    0x0080
    "CURSORF_LINKED",       //    0x0100
    "CURSORF_SYSTEM",       //    0x0200
    "CURSORF_SHADOW",       //    0x0400
    NULL
};

CONST PCSTR apszMonfFlags[] = {
    "MONF_VISIBLE",         // 0x01
    "MONF_PALETTEDISPLAY",  // 0x02
    NULL,
};

CONST PCSTR apszSifFlags[] = {
    "PUSIF_PALETTEDISPLAY",         // 0x00000001
    "PUSIF_SNAPTO",                 // 0x00000002
    "PUSIF_COMBOBOXANIMATION",      // 0x00000004
    "PUSIF_LISTBOXSMOOTHSCROLLING", // 0x00000008
    NO_FLAG,                        // 0x00000010
    "PUSIF_KEYBOARDCUES",           // 0x00000020
    NO_FLAG,                        // 0x00000040
    NO_FLAG,                        // 0x00000080
    NO_FLAG,                        // 0x00000100
    NO_FLAG,                        // 0x00000200
    NO_FLAG,                        // 0x00000400
    NO_FLAG,                        // 0x00000800
    NO_FLAG,                        // 0x00001000
    NO_FLAG,                        // 0x00002000
    NO_FLAG,                        // 0x00004000
    NO_FLAG,                        // 0x00008000
    NO_FLAG,                        // 0x00010000
    NO_FLAG,                        // 0x00020000
    NO_FLAG,                        // 0x00040000
    NO_FLAG,                        // 0x00080000
    NO_FLAG,                        // 0x00100000
    NO_FLAG,                        // 0x00200000
    NO_FLAG,                        // 0x00400000
    NO_FLAG,                        // 0x00800000
    NO_FLAG,                        // 0x01000000
    NO_FLAG,                        // 0x02000000
    NO_FLAG,                        // 0x04000000
    NO_FLAG,                        // 0x08000000
    NO_FLAG,                        // 0x10000000
    NO_FLAG,                        // 0x20000000
    NO_FLAG,                        // 0x40000000
    "PUSIF_UIEFFECTS",              // 0x80000000
    NULL,
};

CONST PCSTR apszRipFlags[] = {
    "RIPF_PROMPTONERROR",   // 0x0001
    "RIPF_PROMPTONWARNING", // 0x0002
    "RIPF_PROMPTONVERBOSE", // 0x0004
    NO_FLAG,                // 0x0008
    "RIPF_PRINTONERROR",    // 0x0010
    "RIPF_PRINTONWARNING",  // 0x0020
    "RIPF_PRINTONVERBOSE",  // 0x0040
    NO_FLAG,                // 0x0080
    "RIPF_PRINTFILELINE",   // 0x0100
    NULL
};

CONST PCSTR apszSRVIFlags[] = {
    "SRVIF_CHECKED",        // 0x0001
    "SRVIF_WINEVENTHOOKS",  // 0x0002
    "SRVIF_DBCS",           // 0x0004
    "SRVIF_IME",            // 0x0008
    "SRVIF_MIDEAST",        // 0x0010
    "SRVIF_HOOKED",         // 0x0020
    NULL
};

CONST PCSTR apszPROPFlags[] = {
    "PROPF_INTERNAL",       // 0x0001
    "PROPF_STRING",         // 0x0002
    "PROPF_NOPOOL",         // 0x0004
};

CONST PCSTR apszLpkEntryPoints[] = {
    "LpkTabbedTextOut"    , // 0x00000001L
    "LpkPSMTextOut"       , // 0x00000002L
    "LpkDrawTextEx"       , // 0x00000004L
    "LpkEditControl"      , // 0x00000008L
    NULL
};

/*
 * We need one of these per DWORD
 */
CONST PCSTR aszUserPreferencesMask0[sizeof(DWORD) * 8] = {
    "ACTIVEWINDOWTRACKING",     /*    0x1000 */
    "MENUANIMATION",            /*    0x1002 */
    "COMBOBOXANIMATION",        /*    0x1004 */
    "LISTBOXSMOOTHSCROLLING",   /*    0x1006 */
    "GRADIENTCAPTIONS",         /*    0x1008 */
    "KEYBOARDCUES",             /*    0x100A */
    "ACTIVEWNDTRKZORDER",       /*    0x100C */
    "HOTTRACKING",              /*    0x100E */
    NO_FLAG,                    /*    0x1010 */
    "MENUFADE",                 /*    0x1012 */
    "SELECTIONFADE",            /*    0x1014 */
    "TOOLTIPANIMATION",         /*    0x1016 */
    "TOOLTIPFADE",              /*    0x1018 */
    "CURSORSHADOW",             /*    0x101A */
    NO_FLAG,                    /*    0x101C */
    NO_FLAG,                    /*    0x101E */
    NO_FLAG,                    /*    0x1020 */
    NO_FLAG,                    /*    0x1022 */
    NO_FLAG,                    /*    0x1024 */
    NO_FLAG,                    /*    0x1026 */
    NO_FLAG,                    /*    0x1028 */
    NO_FLAG,                    /*    0x102A */
    NO_FLAG,                    /*    0x102C */
    NO_FLAG,                    /*    0x102E */
    NO_FLAG,                    /*    0x1030 */
    NO_FLAG,                    /*    0x1032 */
    NO_FLAG,                    /*    0x1034 */
    NO_FLAG,                    /*    0x1036 */
    NO_FLAG,                    /*    0x1038 */
    NO_FLAG,                    /*    0x103A */
    NO_FLAG,                    /*    0x103C */
    "UIEFFECTS",                /*    0x103E */
};

CONST PCSTR aszUserPreferences[SPI_DWORDRANGECOUNT] = {
    "FOREGROUNDLOCKTIMEOUT",    /*    0x2000 */
    "ACTIVEWNDTRKTIMEOUT",      /*    0x2002 */
    "FOREGROUNDFLASHCOUNT",     /*    0x2004 */
    "CARETWIDTH",               /*    0x2006 */
};

CONST PCSTR aszKeyEventFlags[] = {
    "KEYEVENTF_EXTENDEDKEY",    // 0x0001
    "KEYEVENTF_KEYUP",          // 0x0002
    "KEYEVENTF_UNICODE",        // 0x0004
    "KEYEVENTF_SCANCODE",       // 0x0008
    NULL,
};

CONST PCSTR aszMouseEventFlags[] = {
    "MOUSEEVENTF_MOVE",         // 0x0001
    "MOUSEEVENTF_LEFTDOWN",     // 0x0002
    "MOUSEEVENTF_LEFTUP",       // 0x0004
    "MOUSEEVENTF_RIGHTDOWN",    // 0x0008
    "MOUSEEVENTF_RIGHTUP",      // 0x0010
    "MOUSEEVENTF_MIDDLEDOWN",   // 0x0020
    "MOUSEEVENTF_MIDDLEUP",     // 0x0040
    NO_FLAG,                    // 0x0080
    NO_FLAG,                    // 0x0100
    NO_FLAG,                    // 0x0200
    NO_FLAG,                    // 0x0400
    "MOUSEEVENTF_WHEEL",        // 0x0800
    NO_FLAG,                    // 0x1000
    NO_FLAG,                    // 0x2000
    "MOUSEEVENTF_VIRTUALDESK",  // 0x4000
    "MOUSEEVENTF_ABSOLUTE",     // 0x8000
    NULL,
};

const char* aszWindowStyle[] = {
    NO_FLAG,                    // 0x00000001
    NO_FLAG,                    // 0x00000002
    NO_FLAG,                    // 0x00000004
    NO_FLAG,                    // 0x00000008
    NO_FLAG,                    // 0x00000010
    NO_FLAG,                    // 0x00000020
    NO_FLAG,                    // 0x00000040
    NO_FLAG,                    // 0x00000080
    NO_FLAG,                    // 0x00000100
    NO_FLAG,                    // 0x00000200
    NO_FLAG,                    // 0x00000400
    NO_FLAG,                    // 0x00000800
    NO_FLAG,                    // 0x00001000
    NO_FLAG,                    // 0x00002000
    NO_FLAG,                    // 0x00004000
    NO_FLAG,                    // 0x00008000
    "WS_TABSTOP",               // 0x00010000
    "WS_GROUP",                 // 0x00020000
    "WS_THICKFRAME",            // 0x00040000
    "WS_SYSMENU",               // 0x00080000
    "WS_HSCROLL",               // 0x00100000
    "WS_VSCROLL",               // 0x00200000
    "WS_DLGFRAME",              // 0x00400000
    "WS_BORDER",                // 0x00800000
    "WS_MAXIMIZE",              // 0x01000000
    "WS_CLIPCHILDREN",          // 0x02000000
    "WS_CLIPSIBLINGS",          // 0x04000000
    "WS_DISABLED",              // 0x08000000
    "WS_VISIBLE",               // 0x10000000
    "WS_MINIMIZE",              // 0x20000000
    "WS_CHILD",                 // 0x40000000
    "WS_POPUP",                 // 0x80000000
    NULL,
};

const char* aszDialogStyle[] = {
    "DS_ABSALIGN",              // 0x00000001
    "DS_SYSMODAL",              // 0x00000002
    "DS_3DLOOK",                // 0x00000004
    "DS_FIXEDSYS",              // 0x00000008
    "DS_NOFAILCREATE",          // 0x00000010
    "DS_LOCALEDIT",             // 0x00000020
    "DS_SETFONT",               // 0x00000040
    "DS_MODALFRAME",            // 0x00000080
    "DS_NOIDLEMSG",             // 0x00000100
    "DS_SETFOREGROUND",         // 0x00000200
    "DS_CONTROL",               // 0x00000400
    "DS_CENTER",                // 0x00000800
    "DS_CENTERMOUSE",           // 0x00001000
    "DS_CONTEXTHELP",           // 0x00002000
    NO_FLAG,                    // 0x00004000
    NO_FLAG,                    // 0x00008000

    CONTINUE_ON(aszWindowStyle + 16),
};


const char* aszButtonStyle[] = {
    MASKENUM_START(BS_TYPEMASK),
    "BS_PUSHBUTTON",            // 0
    "BS_DEFPUSHBUTTON",         // 1
    "BS_CHECKBOX",              // 2
    "BS_AUTOCHECKBOX",          // 3
    "BS_RADIOBUTTON",           // 4
    "BS_3STATE",                // 5
    "BS_AUTO3STATE",            // 6
    "BS_GROUPBOX",              // 7
    "BS_USERBUTTON",            // 8
    "BS_AUTORADIOBUTTON",       // 9
    "BS_PUSHBOX",               // a
    "BS_OWNERDRAW",             // b
    MASKENUM_END(4),

    NO_FLAG,                    // 0x00000010
    "BS_LEFTTEXT",              // 0x00000020

    MASKENUM_START(BS_IMAGEMASK),
    "BS_TEXT",                  // 0
    "BS_ICON",
    "BS_BITMAP",
    MASKENUM_END(2),

    MASKENUM_START(BS_HORZMASK),
    NO_FLAG,
    "BS_LEFT",
    "BS_RIGHT",
    "BS_CENTER",
    MASKENUM_END(2),

    MASKENUM_START(BS_VERTMASK),
    NO_FLAG,
    "BS_TOP", "BS_BOTTOM", "BS_VCENTER",
    MASKENUM_END(2),

    "BS_PUSHLIKE",              // 0x00001000
    "BS_MULTILINE",             // 0x00002000
    "BS_NOTIFY",                // 0x00004000
    "BS_FLAT",                  // 0x00008000

    CONTINUE_ON(aszWindowStyle + 16),
};

const char* aszComboBoxStyle[] = {
    MASKENUM_START(0x0f),
    NO_FLAG,                    // 0
    "CBS_SIMPLE",               // 1
    "CBS_DROPDOWN",             // 2
    "CBS_DROPDOWNLIST",         // 3
    MASKENUM_END(4),

    "CBS_OWNERDRAWFIXED",       // 0x0010L
    "CBS_OWNERDRAWVARIABLE",    // 0x0020L
    "CBS_AUTOHSCROLL",          // 0x0040L
    "CBS_OEMCONVERT",           // 0x0080L
    "CBS_SORT",                 // 0x0100L
    "CBS_HASSTRINGS",           // 0x0200L
    "CBS_NOINTEGRALHEIGHT",     // 0x0400L
    "CBS_DISABLENOSCROLL",      // 0x0800L
    NO_FLAG,                    // 0x1000L
    "CBS_UPPERCASE",            // 0x2000L
    "CBS_LOWERCASE",            // 0x4000L
    NO_FLAG,                    // 0x8000L

    CONTINUE_ON(aszWindowStyle + 16),
};

const char* aszStaticStyle[] = {
    MASKENUM_START(SS_TYPEMASK),
    "SS_LEFT",              // 0x00000000L
    "SS_CENTER",            // 0x00000001L
    "SS_RIGHT",             // 0x00000002L
    "SS_ICON",              // 0x00000003L
    "SS_BLACKRECT",         // 0x00000004L
    "SS_GRAYRECT",          // 0x00000005L
    "SS_WHITERECT",         // 0x00000006L
    "SS_BLACKFRAME",        // 0x00000007L
    "SS_GRAYFRAME",         // 0x00000008L
    "SS_WHITEFRAME",        // 0x00000009L
    "SS_USERITEM",          // 0x0000000AL
    "SS_SIMPLE",            // 0x0000000BL
    "SS_LEFTNOWORDWRAP",    // 0x0000000CL
    "SS_OWNERDRAW",         // 0x0000000DL
    "SS_BITMAP",            // 0x0000000EL
    "SS_ENHMETAFILE",       // 0x0000000FL
    "SS_ETCHEDHORZ",        // 0x00000010L
    "SS_ETCHEDVERT",        // 0x00000011L
    "SS_ETCHEDFRAME",       // 0x00000012L
    MASKENUM_END(5),

    NO_FLAG,                // 0x00000020L
    "SS_REALSIZECONTROL",   // 0x00000040L
    "SS_NOPREFIX",          // 0x00000080L /* Don't do "&" character translation */
    "SS_NOTIFY",            // 0x00000100L
    "SS_CENTERIMAGE",       // 0x00000200L
    "SS_RIGHTJUST",         // 0x00000400L
    "SS_REALSIZEIMAGE",     // 0x00000800L
    "SS_SUNKEN",            // 0x00001000L
    "SS_EDITCONTROL",       // 0x00002000L ;internal

    MASKENUM_START(SS_ELLIPSISMASK),
    NO_FLAG,
    "SS_ENDELLIPSIS",       // 0x00004000L
    "SS_PATHELLIPSIS",      // 0x00008000L
    "SS_WORDELLIPSIS",      // 0x0000C000L
    MASKENUM_END(2),

    CONTINUE_ON(aszWindowStyle + 16),
};

const char* aszListBoxStyle[] = {
    "LBS_NOTIFY",               // 0x0001L
    "LBS_SORT",                 // 0x0002L
    "LBS_NOREDRAW",             // 0x0004L
    "LBS_MULTIPLESEL",          // 0x0008L
    "LBS_OWNERDRAWFIXED",       // 0x0010L
    "LBS_OWNERDRAWVARIABLE",    // 0x0020L
    "LBS_HASSTRINGS",           // 0x0040L
    "LBS_USETABSTOPS",          // 0x0080L
    "LBS_NOINTEGRALHEIGHT",     // 0x0100L
    "LBS_MULTICOLUMN",          // 0x0200L
    "LBS_WANTKEYBOARDINPUT",    // 0x0400L
    "LBS_EXTENDEDSEL",          // 0x0800L
    "LBS_DISABLENOSCROLL",      // 0x1000L
    "LBS_NODATA",               // 0x2000L
    "LBS_NOSEL",                // 0x4000L
    NO_FLAG,                    // 0x8000L

    CONTINUE_ON(aszWindowStyle + 16),
};

const char* aszEditStyle[] = {
    MASKENUM_START(ES_FMTMASK),
    "ES_LEFT",              // 0x0000L
    "ES_CENTER",            // 0x0001L
    "ES_RIGHT",             // 0x0002L
    MASKENUM_END(2),

    "ES_MULTILINE",         // 0x0004L
    "ES_UPPERCASE",         // 0x0008L
    "ES_LOWERCASE",         // 0x0010L
    "ES_PASSWORD",          // 0x0020L
    "ES_AUTOVSCROLL",       // 0x0040L
    "ES_AUTOHSCROLL",       // 0x0080L
    "ES_NOHIDESEL",         // 0x0100L
    "ES_COMBOBOX",          // 0x0200L     ;internal
    "ES_OEMCONVERT",        // 0x0400L
    "ES_READONLY",          // 0x0800L
    "ES_WANTRETURN",        // 0x1000L
    "ES_NUMBER",            // 0x2000L     ;public_winver_400
    NO_FLAG,                // 0x4000L
    NO_FLAG,                // 0x8000L

    CONTINUE_ON(aszWindowStyle + 16),
};

const char* aszScrollBarStyle[] = {
    "SBS_HORZ",                     // 0x0000L
    "SBS_VERT",                     // 0x0001L
    "SBS_TOPALIGN",                 // 0x0002L
    "SBS_LEFTALIGN",                // 0x0002L
    "SBS_BOTTOMALIGN",              // 0x0004L
    "SBS_RIGHTALIGN",               // 0x0004L
    "SBS_SIZEBOXTOPLEFTALIGN",      // 0x0002L
    "SBS_SIZEBOXBOTTOMRIGHTALIGN",  // 0x0004L
    "SBS_SIZEBOX",                  // 0x0008L
    "SBS_SIZEGRIP",                 // 0x0010L
    SHIFT_BITS(8),                  // 8 bits

    CONTINUE_ON(aszWindowStyle + 16),
};

const char* aszWindowExStyle[] = {
    "WS_EX_DLGMODALFRAME",      // 0x00000001L
    "WS_EX_DRAGOBJECT",         // 0x00000002L  ;internal
    "WS_EX_NOPARENTNOTIFY",     // 0x00000004L
    "WS_EX_TOPMOST",            // 0x00000008L
    "WS_EX_ACCEPTFILES",        // 0x00000010L
    "WS_EX_TRANSPARENT",        // 0x00000020L
    "WS_EX_MDICHILD",           // 0x00000040L
    "WS_EX_TOOLWINDOW",         // 0x00000080L
    "WS_EX_WINDOWEDGE",         // 0x00000100L
    "WS_EX_CLIENTEDGE",         // 0x00000200L
    "WS_EX_CONTEXTHELP",        // 0x00000400L
    NO_FLAG,                    // 0x00000800L

    "WS_EX_RIGHT",              // 0x00001000L
//  "WS_EX_LEFT",               // 0x00000000L
    "WS_EX_RTLREADING",         // 0x00002000L
//  "WS_EX_LTRREADING",         // 0x00000000L
    "WS_EX_LEFTSCROLLBAR",      // 0x00004000L
//  "WS_EX_RIGHTSCROLLBAR",     // 0x00000000L
    NO_FLAG,                    // 0x00008000L

    "WS_EX_CONTROLPARENT",      // 0x00010000L
    "WS_EX_STATICEDGE",         // 0x00020000L
    "WS_EX_APPWINDOW",          // 0x00040000L
    "WS_EX_LAYERED",            // 0x00080000
    NULL
};

const char* aszClientImcFlags[] = {
    "IMCF_UNICODE",         // 0x0001
    "IMCF_ACTIVE",          // 0x0002
    "IMCF_CHGMSG",          // 0x0004
    "IMCF_SAVECTRL",        // 0x0008
    "IMCF_PROCESSEVENT",    // 0x0010
    "IMCF_FIRSTSELECT",     // 0x0020
    "IMCF_INDESTROY",       // 0x0040
    "IMCF_WINNLSDISABLE",   // 0x0080
    "IMCF_DEFAULTIMC",      // 0x0100
    NULL,
};

const char* aszConversionModes[] = {
    "IME_CMODE_NATIVE",                 // 0x0001
    "IME_CMODE_KATAKANA",               // 0x0002  // only effect under IME_CMODE_NATIVE
    NO_FLAG,                            // 0x0004
    "IME_CMODE_FULLSHAPE",              // 0x0008
    "IME_CMODE_ROMAN",                  // 0x0010
    "IME_CMODE_CHARCODE",               // 0x0020
    "IME_CMODE_HANJACONVERT",           // 0x0040
    "IME_CMODE_SOFTKBD",                // 0x0080
    "IME_CMODE_NOCONVERSION",           // 0x0100
    "IME_CMODE_EUDC",                   // 0x0200
    "IME_CMODE_SYMBOL",                 // 0x0400
    "IME_CMODE_FIXED",                  // 0x0800
    NULL
};

const char* aszSentenceModes[] = {
    "IME_SMODE_PLAURALCLAUSE",          // 0x0001
    "IME_SMODE_SINGLECONVERT",          // 0x0002
    "IME_SMODE_AUTOMATIC",              // 0x0004
    "IME_SMODE_PHRASEPREDICT",          // 0x0008
    "IME_SMODE_CONVERSATION",           // 0x0010
    NULL
};

const char* aszImeInit[] = {
    "INIT_STATUSWNDPOS",            // 0x00000001
    "INIT_CONVERSION",              // 0x00000002
    "INIT_SENTENCE",                // 0x00000004
    "INIT_LOGFONT",                 // 0x00000008
    "INIT_COMPFORM",                // 0x00000010
    "INIT_SOFTKBDPOS",              // 0x00000020
    NULL
};

const char* aszImeSentenceMode[] = {
    "IME_SMODE_PLAURALCLAUSE",      // 0x0001
    "IME_SMODE_SINGLECONVERT",      // 0x0002
    "IME_SMODE_AUTOMATIC",          // 0x0004
    "IME_SMODE_PHRASEPREDICT",      // 0x0008
    "IME_SMODE_CONVERSATION",       // 0x0010
    NULL
};

const char* aszImeConversionMode[] = {
    "IME_CMODE_NATIVE",             // 0x0001
    "IME_CMODE_KATAKANA",           // 0x0002  // only effect under IME_CMODE_NATIVE
    NO_FLAG,
    "IME_CMODE_FULLSHAPE",          // 0x0008
    "IME_CMODE_ROMAN",              // 0x0010
    "IME_CMODE_CHARCODE",           // 0x0020
    "IME_CMODE_HANJACONVERT",       // 0x0040
    "IME_CMODE_SOFTKBD",            // 0x0080
    "IME_CMODE_NOCONVERSION",       // 0x0100
    "IME_CMODE_EUDC",               // 0x0200
    "IME_CMODE_SYMBOL",             // 0x0400
    "IME_CMODE_FIXED",              // 0x0800
    NULL
};

const char* aszImeDirtyFlags[] = {
    "IMSS_UPDATE_OPEN",             // 0x0001
    "IMSS_UPDATE_CONVERSION",       // 0x0002
    "IMSS_UPDATE_SENTENCE",         // 0x0004
    NO_FLAG,                        // 0x0008
    NO_FLAG,                        // 0x0010
    NO_FLAG,                        // 0x0020
    NO_FLAG,                        // 0x0040
    NO_FLAG,                        // 0x0080
    "IMSS_INIT_OPEN",               // 0x0100
    NULL
};

const char* aszImeCompFormFlags[] = {
//  "CFS_DEFAULT",                  // 0x0000
    "CFS_RECT",                     // 0x0001
    "CFS_POINT",                    // 0x0002
    "CFS_SCREEN",                   // 0x0004          @Internal
    "CFS_VERTICAL",                 // 0x0008          @Internal
    "CFS_HIDDEN",                   // 0x0010          @Internal
    "CFS_FORCE_POSITION",           // 0x0020
    "CFS_CANDIDATEPOS",             // 0x0040
    "CFS_EXCLUDE",                  // 0x0080
    NULL
};


const char* aszEdUndoType[] = {
    "UNDO_INSERT",                  // 0x0001
    "UNDO_DELETE",                  // 0x0002
    NULL,
};

const char* aszDeviceInfoActionFlags[] = {
    "GDIAF_ARRIVED",                // 0x0001
    "GDIAF_QUERYREMOVE",            // 0x0002
    "GDIAF_REMOVECANCELLED",        // 0x0004
    "GDIAF_DEPARTED",               // 0x0008
    "GDIAF_IME_STATUS",             // 0x0010
    "GDIAF_REFRESH_MOUSE",          // 0x0020
    NO_FLAG,                        // 0x0040
    "GDIAF_FREEME",                 // 0x0080
    "GDIAF_PNPWAITING",             // 0x0100
    "GDIAF_RETRYREAD",              // 0x0200
    "GDIAF_RECONNECT",              // 0x0400
    "GDIAF_STARTREAD",              // 0x0800   // the device needs to be started
    "GDIAF_STOPREAD",               // 0x1000   // the device needs to be stopped
    NULL,
};

const char* aszHidProcessMask[] = {
    "TRIM_RAWMOUSE",                // 0x0001
    "TRIM_RAWKEYBOARD",             // 0x0002
    "TRIM_NOLEGACYMOUSE",           // 0x0004
    "TRIM_NOLEGACYKEYBOARD",        // 0x0008
    NULL,
};

const char* aszHookFlags[] = {
    "HF_GLOBAL",                    // 0x0001
    "HF_ANSI",                      // 0x0002
    "HF_NEEDHC_SKIP",               // 0x0004
    "HF_HUNG",                      // 0x0008      // Hook Proc hung don't call if system
    "HF_HOOKFAULTED",               // 0x0010      // Hook Proc faulted
    "HF_NOPLAYBACKDELAY",           // 0x0020      // Ignore requested delay
    "HF_DESTROYED",                 // 0x0080      // Set by FreeHook
    // DEBUG only flags
    "HF_INCHECKWHF",                // 0x0100      // fsHooks is being updated
    "HF_FREED",                     // 0x0200      // Object has been freed.
    NULL,
};


const char * aszDcxFlags[] = {
    "DCX_WINDOW",                   // 0x00000001L
    "DCX_CACHE",                    // 0x00000002L
    "DCX_NORESETATTRS",             // 0x00000004L
    "DCX_CLIPCHILDREN",             // 0x00000008L
    "DCX_CLIPSIBLINGS",             // 0x00000010L
    "DCX_PARENTCLIP",               // 0x00000020L
    "DCX_EXCLUDERGN",               // 0x00000040L
    "DCX_INTERSECTRGN",             // 0x00000080L
    "DCX_EXCLUDEUPDATE",            // 0x00000100L
    "DCX_INTERSECTUPDATE",          // 0x00000200L
    "DCX_LOCKWINDOWUPDATE",         // 0x00000400L
    "DCX_INVALID",                  // 0x00000800L
    "DCX_INUSE",                    // 0x00001000L
    "DCX_SAVEDRGNINVALID",          // 0x00002000L
    "DCX_REDIRECTED",               // 0x00004000L
    "DCX_OWNDC",                    // 0x00008000L
    "DCX_USESTYLE",                 // 0x00010000L
    "DCX_NEEDFONT",                 // 0x00020000L
    "DCX_NODELETERGN",              // 0x00040000L
    "DCX_NOCLIPCHILDREN",           // 0x00080000L
    "DCX_NORECOMPUTE",              // 0x00100000L
    "DCX_VALIDATE",                 // 0x00200000L
    "DCX_DESTROYTHIS",              // 0x00400000L
    "DCX_CREATEDC",                 // 0x00800000L
    "DCX_REDIRECTEDBITMAP",         // 0x08000000L
    "DCX_PWNDORGINVISIBLE",         // 0x10000000L
    "DCX_NOMIRROR",                 // 0x40000000L
    "DCX_DONTRIPONDESTROY",         // 0x80000000L
    NULL
};



enum GF_FLAGS {
    GF_SMS,
    GF_TIF,
    GF_QS,
    GF_MF,
    GF_CSF,
    GF_CS,
    GF_QF,
    GF_W32PF,
    GF_HE,
    GF_HDATA,
    GF_XI,
    GF_IIF,
    GF_TMRF,
    GF_SB,
    GF_CHARSETS,
    GF_MENUTYPE,
    GF_MENUSTATE,
    GF_CURSORF,
    GF_MON,
    GF_SI,
    GF_RIP,
    GF_SRVI,
    GF_PROP,
    GF_UPM0,
    GF_KI,
    GF_MI,
    GF_DS,
    GF_WS,
    GF_ES,
    GF_BS,
    GF_CBS,
    GF_SS,
    GF_LBS,
    GF_SBS,
    GF_WSEX,
    GF_CLIENTIMC,
    GF_CONVERSION,
    GF_SENTENCE,
    GF_IMEINIT,
    GF_IMEDIRTY,
    GF_IMECOMPFORM,
    GF_EDUNDO,
    GF_DIAF,
    GF_HIDPROCESSMASK,
    GF_HOOKFLAGS,
    GF_DCXFLAGS,

    GF_LPK,
    GF_MAX
};

CONST PCSTR* aapszFlag[GF_MAX] = {
    apszSmsFlags,
    apszTifFlags,
    apszQsFlags,
    apszMfFlags,
    apszCsfFlags,
    apszCsFlags,
    apszQfFlags,
    apszW32pfFlags,
    apszHeFlags,
    apszHdataFlags,
    apszXiFlags,
    apszIifFlags,
    apszTmrfFlags,
    apszSbFlags,
    apszCSFlags,
    apszMenuTypeFlags,
    apszMenuStateFlags,
    apszCursorfFlags,
    apszMonfFlags,
    apszSifFlags,
    apszRipFlags,
    apszSRVIFlags,
    apszPROPFlags,
    aszUserPreferencesMask0,
    aszKeyEventFlags,
    aszMouseEventFlags,
    aszDialogStyle,
    aszWindowStyle,
    aszEditStyle,
    aszButtonStyle,
    aszComboBoxStyle,
    aszStaticStyle,
    aszListBoxStyle,
    aszScrollBarStyle,
    aszWindowExStyle,
    aszClientImcFlags,
    aszConversionModes,
    aszSentenceModes,
    aszImeInit,
    aszImeDirtyFlags,
    aszImeCompFormFlags,
    aszEdUndoType,
    aszDeviceInfoActionFlags,
    aszHidProcessMask,
    aszHookFlags,
    aszDcxFlags,

    apszLpkEntryPoints,
};

/************************************************************************\
* GetFlags
*
* Converts a 32bit set of flags into an appropriate string. pszBuf should
* be large enough to hold this string, no checks are done. pszBuf can be
* NULL, allowing use of a local static buffer but note that this is not
* reentrant. Output string has the form: "FLAG1 | FLAG2 ..." or "0".
*
* 6/9/1995 Created SanfordS
\************************************************************************/
LPSTR GetFlags(
    WORD    wType,
    DWORD   dwFlags,
    LPSTR   pszBuf,
    BOOL    fPrintZero)
{
    static char szT[512];
    WORD i;
    BOOL fFirst = TRUE;
    BOOL fNoMoreNames = FALSE;
    CONST PCSTR *apszFlags;
    LPSTR apszFlagNames[sizeof(DWORD) * 8], pszT;
    const char** ppszNextFlag;
    UINT uFlagsCount, uNextFlag;
    DWORD dwUnnamedFlags, dwLoopFlag;
    DWORD dwShiftBits;
    DWORD dwOrigFlags;

    if (pszBuf == NULL) {
        pszBuf = szT;
    }
    if (!bShowFlagNames) {
        sprintf(pszBuf, "%x", dwFlags);
        return pszBuf;
    }

    if (wType >= GF_MAX) {
        strcpy(pszBuf, "Invalid flag type.");
        return pszBuf;
    }

    /*
     * Initialize output buffer and names array
     */
    *pszBuf = '\0';
    RtlZeroMemory(apszFlagNames, sizeof(apszFlagNames));

    apszFlags = aapszFlag[wType];

    /*
     * Build a sorted array containing the names of the flags in dwFlags
     */
    uFlagsCount = 0;
    dwUnnamedFlags = dwOrigFlags = dwFlags;
    dwLoopFlag = 1;
    dwShiftBits = 0;

reentry:
    for (i = 0; dwFlags; dwFlags >>= 1, i++, dwLoopFlag <<= 1, ++dwShiftBits) {
        const char* lpszFlagName = NULL;

        /*
         * Bail if we reached the end of the flag names array
         */
        if (apszFlags[i] == NULL) {
            break;
        }

        if (apszFlags[i] == _MASKENUM_START) {
            //
            // Masked enumerative items.
            //
            DWORD en = 0;
            DWORD dwMask = (DWORD)(ULONG_PTR)apszFlags[++i];

            // First, clear up the handled bits.
            dwUnnamedFlags &= ~dwMask;
            lpszFlagName = NULL;
            for (++i; apszFlags[i] != NULL && apszFlags[i] != _MASKENUM_END; ++i, ++en) {
                if ((dwOrigFlags & dwMask) == (en << dwShiftBits )) {
                    if (apszFlags[i] != NO_FLAG) {
                        lpszFlagName = apszFlags[i];
                    }
                }
            }
            //
            // Shift the bits and get ready for the next item.
            // Next item right after _MASKENUM_END holds the bits to shift.
            //
            dwFlags >>= (int)(ULONG_PTR)apszFlags[++i] - 1;
            dwLoopFlag <<= (int)(ULONG_PTR)apszFlags[i] - 1;
            dwShiftBits += (int)(ULONG_PTR)apszFlags[i] - 1;
            if (lpszFlagName == NULL) {
                //
                // Could not find the match. Skip to the next item.
                //
                continue;
            }
        } else if (apszFlags[i] == _CONTINUE_ON) {
            //
            // Refer the other item array. Pointer to the array is stored at [i+1].
            //
            apszFlags = (LPSTR*)apszFlags[i + 1];
            goto reentry;
        } else if (apszFlags[i] == _SHIFT_BITS) {
            //
            // To save some space, just shift some bits..
            //
            dwFlags >>= (int)(ULONG_PTR)apszFlags[++i] - 1;
            dwLoopFlag <<= (int)(ULONG_PTR)apszFlags[i] - 1;
            dwShiftBits += (int)(ULONG_PTR)apszFlags[i] - 1;
            continue;
        } else {
            /*
             * Continue if this bit is not set or we don't have a name for it.
             */
            if (!(dwFlags & 1) || (apszFlags[i] == NO_FLAG)) {
                continue;
            }
            lpszFlagName = apszFlags[i];
        }

        /*
         * Find the sorted position where this name should go
         */
        ppszNextFlag = apszFlagNames;
        uNextFlag = 0;
        while (uNextFlag < uFlagsCount) {
            if (strcmp(*ppszNextFlag, lpszFlagName) > 0) {
                break;
            }
            ppszNextFlag++;
            uNextFlag++;
        }
        /*
         * Insert the new name
         */
        RtlMoveMemory((char*)(ppszNextFlag + 1), ppszNextFlag, (uFlagsCount - uNextFlag) * sizeof(DWORD));
        *ppszNextFlag = lpszFlagName;
        uFlagsCount++;
        /*
         * We got a name so clear it from the unnamed bits.
         */
        dwUnnamedFlags &= ~dwLoopFlag;
    }

    /*
     * Build the string now
     */
    ppszNextFlag = apszFlagNames;
    pszT = pszBuf;
    /*
     * Add the first name
     */
    if (uFlagsCount > 0) {
        pszT += sprintf(pszT, "%s", *ppszNextFlag++);
        uFlagsCount--;
    }
    /*
     * Concatenate all other names with " |"
     */
    while (uFlagsCount > 0) {
        pszT += sprintf(pszT, " | %s", *ppszNextFlag++);
        uFlagsCount--;
    }
    /*
     * If there are unamed bits, add them at the end
     */
    if (dwUnnamedFlags != 0) {
        pszT += sprintf(pszT, " | %#lx", dwUnnamedFlags);
    }
    /*
     * Print zero if needed and asked to do so
     */
    if (fPrintZero && (pszT == pszBuf)) {
        sprintf(pszBuf, "0");
    }

    return pszBuf;
}

///////////////////////////////////////////////////////////////////////////
//
// Enumerated items with mask
//
///////////////////////////////////////////////////////////////////////////

typedef struct {
    LPCSTR  name;
    DWORD   value;
} EnumItem;

#define EITEM(a)     { #a, a }

const EnumItem aClsTypes[] = {
    EITEM(ICLS_BUTTON),
    EITEM(ICLS_EDIT),
    EITEM(ICLS_STATIC),
    EITEM(ICLS_LISTBOX),
    EITEM(ICLS_SCROLLBAR),
    EITEM(ICLS_COMBOBOX),
    EITEM(ICLS_CTL_MAX),
    EITEM(ICLS_DESKTOP),
    EITEM(ICLS_DIALOG),
    EITEM(ICLS_MENU),
    EITEM(ICLS_SWITCH),
    EITEM(ICLS_ICONTITLE),
    EITEM(ICLS_MDICLIENT),
    EITEM(ICLS_COMBOLISTBOX),
    EITEM(ICLS_DDEMLEVENT),
    EITEM(ICLS_DDEMLMOTHER),
    EITEM(ICLS_DDEML16BIT),
    EITEM(ICLS_DDEMLCLIENTA),
    EITEM(ICLS_DDEMLCLIENTW),
    EITEM(ICLS_DDEMLSERVERA),
    EITEM(ICLS_DDEMLSERVERW),
    EITEM(ICLS_IME),
    EITEM(ICLS_TOOLTIP),
    NULL,
};

const EnumItem aCharSets[] = {
    EITEM(ANSI_CHARSET),
    EITEM(DEFAULT_CHARSET),
    EITEM(SYMBOL_CHARSET),
    EITEM(SHIFTJIS_CHARSET),
    EITEM(HANGEUL_CHARSET),
    EITEM(HANGUL_CHARSET),
    EITEM(GB2312_CHARSET),
    EITEM(CHINESEBIG5_CHARSET),
    EITEM(OEM_CHARSET),
    EITEM(JOHAB_CHARSET),
    EITEM(HEBREW_CHARSET),
    EITEM(ARABIC_CHARSET),
    EITEM(GREEK_CHARSET),
    EITEM(TURKISH_CHARSET),
    EITEM(VIETNAMESE_CHARSET),
    EITEM(THAI_CHARSET),
    EITEM(EASTEUROPE_CHARSET),
    EITEM(RUSSIAN_CHARSET),
    NULL,
};

const EnumItem aImeHotKeys[] = {
    // Windows for Simplified Chinese Edition hot key ID from 0x10 - 0x2F
    EITEM(IME_CHOTKEY_IME_NONIME_TOGGLE),
    EITEM(IME_CHOTKEY_SHAPE_TOGGLE),
    EITEM(IME_CHOTKEY_SYMBOL_TOGGLE),
    // Windows for Japanese Edition hot key ID from 0x30 - 0x4F
    EITEM(IME_JHOTKEY_CLOSE_OPEN),
    // Windows for Korean Edition hot key ID from 0x50 - 0x6F
    EITEM(IME_KHOTKEY_SHAPE_TOGGLE),
    EITEM(IME_KHOTKEY_HANJACONVERT),
    EITEM(IME_KHOTKEY_ENGLISH),
    // Windows for Traditional Chinese Edition hot key ID from 0x70 - 0x8F
    EITEM(IME_THOTKEY_IME_NONIME_TOGGLE),
    EITEM(IME_THOTKEY_SHAPE_TOGGLE),
    EITEM(IME_THOTKEY_SYMBOL_TOGGLE),
    // direct switch hot key ID from 0x100 - 0x11F
    EITEM(IME_HOTKEY_DSWITCH_FIRST),
    EITEM(IME_HOTKEY_DSWITCH_LAST),
    // IME private hot key from 0x200 - 0x21F
    EITEM(IME_ITHOTKEY_RESEND_RESULTSTR),
    EITEM(IME_ITHOTKEY_PREVIOUS_COMPOSITION),
    EITEM(IME_ITHOTKEY_UISTYLE_TOGGLE),
    EITEM(IME_ITHOTKEY_RECONVERTSTRING),
    EITEM(IME_HOTKEY_PRIVATE_LAST),
    NULL,
};

const EnumItem aCandidateListStyle[] = {
    EITEM(IME_CAND_UNKNOWN),//                0x0000
    EITEM(IME_CAND_READ),//                   0x0001
    EITEM(IME_CAND_CODE),//                   0x0002
    EITEM(IME_CAND_MEANING),//                0x0003
    EITEM(IME_CAND_RADICAL),//                0x0004
    EITEM(IME_CAND_STROKE),//                 0x0005
    NULL
};

// TODO: put charset here

enum {
    EI_CLSTYPE = 0,
    EI_CHARSETTYPE,
    EI_IMEHOTKEYTYPE,
    EI_IMECANDIDATESTYLE,
    EI_MAX
};

typedef struct {
    DWORD dwMask;
    const EnumItem* items;
} MaskedEnum;

const MaskedEnum aEnumItems[] = {
    ~0,             aClsTypes,
    ~0,             aCharSets,
    ~0,             aImeHotKeys,
    ~0,             aCandidateListStyle,
};

LPCSTR GetMaskedEnum(WORD wType, DWORD dwValue, LPSTR buf)
{
    const EnumItem* item;
    static char ach[32];

    if (wType >= EI_MAX) {
        strcpy(buf, "Invalid type.");
        return buf;
    }

    dwValue &= aEnumItems[wType].dwMask;

    item = aEnumItems[wType].items;

    for (; item->name; ++item) {
        if (item->value == dwValue) {
            if (buf) {
                strcpy(buf, item->name);
                return buf;
            }
            return item->name;
        }
    }

    if (buf) {
        *buf = 0;
        return buf;
    }

    sprintf(ach, "%x", wType);
    return ach;
}

#define WM_ITEM(x, fInternal)  { x, #x, fInternal }

CONST struct {
    DWORD msg;
    PCSTR pszMsg;
    BOOLEAN fInternal;
} gaMsgs[] = {
    #include "wm.txt"
};

#undef WM_ITEM



/************************************************************************\
* Helper Procedures: dso etc.
*
* 04/19/2000 Created Hiro
\************************************************************************/

// to workaround nosy InitTypeRead
#define _InitTypeRead(Addr, lpszType)   GetShortField(Addr, (PUCHAR)lpszType, 1)

#define CONTINUE    EXCEPTION_EXECUTE_HANDLER

#define RAISE_EXCEPTION() RaiseException(EXCEPTION_ACCESS_VIOLATION, 0, 0, NULL)

#define BAD_SYMBOL(symbol) \
    Print("Failed to get %s: bad symbol?\n", symbol); \
    RAISE_EXCEPTION()

#define CANT_GET_VALUE(symbol, p) \
    Print("Failed to get %s @ 0x%p: invalid address, or memory is paged out?\n", symbol, p); \
    RAISE_EXCEPTION()



BOOL dso(
    char* szStruct,
    ULONG64 address,
    ULONG dwOption)
{
    SYM_DUMP_PARAM symDump = {
        sizeof(symDump), szStruct, dwOption, // 0 for default dump like dt
        address,
        NULL, NULL, NULL, 0, NULL
    };

    return Ioctl(IG_DUMP_SYMBOL_INFO, &symDump, symDump.size);
}

ULONG64 GetPointer(
    ULONG64 addr)
{
    ULONG64 p = 0;
    if (!ReadPointer(addr, &p)) {
        CANT_GET_VALUE("a pointer", addr);
    }
    return p;
}

DWORD GetDWord(
    ULONG64 addr)
{
    ULONG64 dw = 0xbaadbaad;

    if (!GetFieldData(addr, "DWORD", NULL, sizeof(dw), &dw)) {
        CANT_GET_VALUE("DWORD", addr);
    }
    return (DWORD)dw;
}

WORD GetWord(
    ULONG64 addr)
{
    ULONG64 w = 0xbaad;

    if (!GetFieldData(addr, "WORD", NULL, sizeof(w), &w)) {
        CANT_GET_VALUE("WORD", addr);
    }
    return (WORD)w;
}

BYTE GetByte(
    ULONG64 addr)
{
    ULONG64 b = 0;

    if (GetFieldData(addr, "BYTE", NULL, sizeof(b), &b)) {
        CANT_GET_VALUE("BYTE", addr);
    }
    return (BYTE)b;
}

ULONG
GetUlongFromAddress(
    ULONG64 Location)
{
    ULONG Value;
    ULONG result;

    if ((!ReadMemory(Location, &Value, sizeof(ULONG), &result)) ||
        (result < sizeof(ULONG))) {
        Print("GetUlongFromAddress: unable to read from 0x%I64x\n", Location);
        RAISE_EXCEPTION();
    }

    return Value;
}

ULONG64 GetGlobalPointer(
    LPSTR symbol)
{
    ULONG64 pp;
    ULONG64 p = 0;

    pp = EvalExp(symbol);
    if (pp == 0) {
        BAD_SYMBOL(symbol);
    } else if (!ReadPointer(pp, &p)) {
        CANT_GET_VALUE(symbol, pp);
    }
    return p;
}

ULONG64 GetGlobalMemberAddress(
    LPSTR symbol,
    LPSTR type,
    LPSTR field)
{
    ULONG64 pVar = EvalExp(symbol);
    ULONG offset;

    if (pVar == 0) {
        BAD_SYMBOL(symbol);
    }

    if (GetFieldOffset(type, field, &offset)) {
        BAD_SYMBOL(type);
    }

    return pVar + offset;
}

ULONG64 GetGlobalMember(
    LPSTR symbol,
    LPSTR type,
    LPSTR field)
{
    ULONG64 pVar = EvalExp(symbol);
    ULONG64 val;

    if (pVar == 0) {
        BAD_SYMBOL(symbol);
    }

    if (GetFieldValue(pVar, type, field, val)) {
        CANT_GET_VALUE(symbol, pVar);
    }

    return val;
}

#if 0
DWORD GetGlobalDWord(LPSTR symbol)
{
    ULONG64 pdw;
    ULONG64 dw = 0;

    pdw = EvalExp(symbol);
    if (pdw == 0) {
        BAD_SYMBOL(symbol);
    } else if (!GetFieldData(pdw, "DWORD", NULL, sizeof(dw), &dw)) {
        CANT_GET_VALUE(symbol, pdw);
    }
    return dw;
}

WORD GetGlobalWord(LPSTR symbol)
{
    ULONG64 pw;
    WORD w = 0;

    pw = EvalExp(symbol);
    if (pw == 0) {
        BAD_SYMBOL(symbol);
    } else if (!GetFieldData(pw, (PUCHAR)"WORD", NULL, sizeof(w), (PVOID)&w)) {
        CANT_GET_VALUE(symbol, pw);
    }
    return w;
}

BYTE GetGlobalByte(LPSTR symbol)
{
    ULONG64 pb;
    BYTE b = 0;

    pb = EvalExp(symbol);
    if (pb == 0) {
        BAD_SYMBOL(symbol);
    } else if (!GetFieldData(pb, (PUCHAR)"BYTE", NULL, sizeof(b), (PVOID)&b)) {
        CANT_GET_VALUE(symbol, pb);
    }
    return b;
}
#endif

ULONG64 GetArrayElement(
    ULONG64 pAddr,
    LPSTR lpszStruc,
    LPSTR lpszField,
    ULONG64 index,
    LPSTR lpszType)
{
    static ULONG ulOffsetBase, ulSize;
    ULONG64 result = 0;

    if (lpszField) {
        GetFieldOffset(lpszStruc, lpszField, &ulOffsetBase);
        ulSize = GetTypeSize(lpszType);
    }
    ReadMemory(pAddr + ulOffsetBase + ulSize * index, &result, ulSize, NULL);

    return result;
}

ULONG64 GetArrayElementPtr(
    ULONG64 pAddr,
    LPSTR lpszStruc,
    LPSTR lpszField,
    ULONG64 index)
{
    static ULONG ulOffsetBase, ulSize;
    ULONG64 result = 0;

    if (lpszField) {
        GetFieldOffset(lpszStruc, lpszField, &ulOffsetBase);
    }
    if (ulSize == 0) {
        ulSize = GetTypeSize("PVOID");
    }
    ReadPointer(pAddr + ulOffsetBase + ulSize * index, &result);

    return result;
}

/*
 * Show progress in time consuming commands
 * 10/15/2000 hiroyama
 */
VOID ShowProgress(
    ULONG i)
{
    static const char* clock[] = {
        "\r-\r",
        "\r\\\r",
        "\r|\r",
        "\r/\r",
    };

    /*
     * Show the progress :-)
     */
    Print(clock[i % ARRAY_SIZE(clock)]);
}

#define DOWNCAST(type, value)  ((type)(ULONG_PTR)(value))

#ifdef KERNEL
BOOL HasValidSymbols(VOID)
{
    if (EvalExp(VAR(gptiRit))) {
        return TRUE;
    }
    return FALSE;
}
#endif

/*
 * IsChk: returns TRUE if the window manager is CHK,
 * could return TRUE regardless the entire system is FRE.
 */

int gfChk = -1;

BOOL IsChk(VOID)
{
    ULONG64 psi;

    if (gfChk != -1) {
        return gfChk;
    }

    psi = GetGlobalPointer(SYM(gpsi));
    if (psi == 0) {
        Print("Cannot get gpsi, assuming chk\n");
        return TRUE;
    }

    if ((DWORD)GetArrayElement(psi, SYM(SERVERINFO), "aiSysMet", SM_DEBUG, "DWORD")) {
        return gfChk = TRUE;
    }

    return gfChk = FALSE;
}

#ifdef KERNEL
/*
 * Debugger specific object routines:
 * copied from ntos/tools/kdexts2/precomp.h
 * (and fixed bugs)
 */

ULONG gObjectHeaderOffset;

__inline
ULONG64
KD_OBJECT_TO_OBJECT_HEADER(
    ULONG64 o)
{
    if (gObjectHeaderOffset == 0 && GetFieldOffset("nt!_OBJECT_HEADER", "Body", &gObjectHeaderOffset)) {
        return 0;
    }
    return o - gObjectHeaderOffset;
}

__inline
ULONG64
KD_OBJECT_HEADER_TO_OBJECT(
    ULONG64 o)
{
    if (gObjectHeaderOffset && GetFieldOffset("nt!_OBJECT_HEADER", "Body", &gObjectHeaderOffset)) {
        return 0;
    }
    return o + gObjectHeaderOffset;
}

__inline
VOID
KD_OBJECT_HEADER_TO_QUOTA_INFO(
    ULONG64 oh,
    PULONG64 pOutH
    )
{
    ULONG QuotaInfoOffset=0;
    GetFieldValue(oh, "nt!__OBJECT_HEADER", "QuotaInfoOffset", QuotaInfoOffset);
    *pOutH = (QuotaInfoOffset == 0 ? 0 : ((oh) - QuotaInfoOffset));
}


__inline
VOID
KD_OBJECT_HEADER_TO_HANDLE_INFO (
    ULONG64 oh,
    PULONG64 pOutH
    )
{
    ULONG HandleInfoOffset=0;
    GetFieldValue(oh, "nt!__OBJECT_HEADER", "HandleInfoOffset", HandleInfoOffset);
    *pOutH = (HandleInfoOffset == 0 ? 0 : ((oh) - HandleInfoOffset));
}

__inline
VOID
KD_OBJECT_HEADER_TO_NAME_INFO(
    ULONG64  oh,
    PULONG64 pOutH
    )
{
    ULONG NameInfoOffset=0;
    GetFieldValue(oh, "nt!_OBJECT_HEADER", "NameInfoOffset", NameInfoOffset);
    *pOutH = (NameInfoOffset == 0 ? 0 : ((oh) - NameInfoOffset));
}

#if 0
__inline
VOID
KD_OBJECT_HEADER_TO_CREATOR_INFO(
    ULONG64  oh,
    PULONG64 pOutH
    )
{
    ULONG Flags=0;
    GetFieldValue(oh, "_OBJECT_HEADER", "Flags", Flags);
    *pOutH = ((Flags & OB_FLAG_CREATOR_INFO) == 0 ? 0 : ((oh) - GetTypeSize("_OBJECT_HEADER_CREATOR_INFO")));
}
#endif


/*
 * Object helper routines
 */

#endif


#ifdef KERNEL


/************************************************************************\
* Procedure: GetObjectName
* Get the generic object name (not a file, symlink etc.)
*
* 10/15/2000 Hiroyama Created
\************************************************************************/
VOID GetObjectName(
    ULONG64 ptr,
    LPWSTR pwsz,
    ULONG cchMax)
{
    ULONG64 pHead;
    ULONG64 pNameInfo;
    ULONG64 pBuffer;
    ULONG length;
    WCHAR ach[80];

    pwsz[0] = 0;
    pHead = KD_OBJECT_TO_OBJECT_HEADER(ptr);
    DEBUGPRINT("pHead=%p\n", pHead);
    if (pHead == NULL_POINTER) {
        return;
    }
    KD_OBJECT_HEADER_TO_NAME_INFO(pHead, &pNameInfo);
    DEBUGPRINT("pNameInfo=%p\n", pNameInfo);
    if (pNameInfo == NULL_POINTER) {
        return;
    }
    GetFieldValue(pNameInfo, "nt!_OBJECT_HEADER_NAME_INFO", "Name.Buffer", pBuffer);
    DEBUGPRINT("pBuffer=%p\n", pBuffer);
    if (pBuffer == NULL_POINTER) {
        return;
    }
    GetFieldValue(pNameInfo, "nt!_OBJECT_HEADER_NAME_INFO", "Name.Length", length);
    DEBUGPRINT("length=%x\n", length);
    if (length == 0) {
        return;
    }
    move(ach, pBuffer);
    wcsncpy(pwsz, ach, cchMax);
    pwsz[min(cchMax - 1, length / sizeof(WCHAR))] = 0;
}

/************************************************************************\
* Procedure: GetProcessName
*
* 06/27/97 GerardoB Created
*
\************************************************************************/
BOOL
GetProcessName(
    ULONG64 pEProcess,
    LPWSTR lpBuffer)
{
    UCHAR ImageFileName[16];
    if (!GetFieldValue(pEProcess, "nt!EPROCESS", "ImageFileName", ImageFileName)) {
        swprintf(lpBuffer, L"%.16hs", ImageFileName);
        return TRUE;
    } else {
        Print("Unable to read _EPROCESS at %p\n", pEProcess);
        return FALSE;
    }
}

/************************************************************************\
* GetAppName
*
* 10/6/1995 Created JimA
\************************************************************************/
BOOL
GetAppName(
    ULONG64 pEThread,
    ULONG64 pti,
    LPWSTR lpBuffer,
    DWORD cbBuffer)
{
    ULONG64 pstrAppName = 0;
    ULONG64 Buffer;
    USHORT Length;
    BOOL fRead = FALSE;

    GetFieldValue(pti, SYM(THREADINFO), "pstrAppName", pstrAppName);
    if (pstrAppName != 0) {
        if (!GetFieldValue(pstrAppName, SYM(UNICODE_STRING), "Buffer", Buffer)) {
            GetFieldValue(pstrAppName, SYM(UNICODE_STRING), "Length", Length);
            cbBuffer = min(cbBuffer - sizeof(WCHAR), Length);
            if (tryMoveBlock(lpBuffer, Buffer, cbBuffer)) {
                lpBuffer[cbBuffer / sizeof(WCHAR)] = 0;
                fRead = TRUE;
            }
        }
    } else {
        ULONG64 pEProcess;
        GetFieldValue(pEThread, "nt!ETHREAD", "ThreadsProcess", pEProcess);
        fRead = GetProcessName(pEProcess, lpBuffer);
    }

    if (!fRead) {
        wcsncpy(lpBuffer, L"<unknown name>", cbBuffer / sizeof(WCHAR));
    }

    return fRead;
}


#define INVALID_SESSION_ID   ((ULONG)0xbadbad)

BOOL _GetProcessSessionId(ULONG64 Process, PULONG SessionId)
{
    ULONG64 SessionPointer;

    *SessionId = INVALID_SESSION_ID;

    GetFieldValue(Process, "nt!_EPROCESS", "Session", SessionPointer);
    if (SessionPointer != 0) {
        if (GetFieldValue(SessionPointer, "nt!_MM_SESSION_SPACE",
                          "SessionId", *SessionId)) {
            Print("Could not find _MM_SESSION_SPACE type at %p.\n", SessionPointer);
            return FALSE;
        }
    }

    return TRUE;
}

ULONG GetProcessSessionId(ULONG64 Process)
{
    ULONG sid;

    _GetProcessSessionId(Process, &sid);
    return sid;
}

#endif // KERNEL

#ifdef OLD_DEBUGGER

#ifdef KERNEL
/************************************************************************\
* PrintMessages
*
* Prints out qmsg structures.
*
* 6/9/1995 Created SanfordS
\************************************************************************/
BOOL PrintMessages(
    PQMSG pqmsgRead)
{
    QMSG qmsg;
    ASYNCSENDMSG asm;
    char *aszEvents[] = {
        "MSG",  // QEVENT_MESSAGE
        "SHO",  // QEVENT_SHOWWINDOW"
        "CMD",  // QEVENT_CANCLEMODE"
        "SWP",  // QEVENT_SETWINDOWPOS"
        "UKS",  // QEVENT_UPDATEKEYSTATE"
        "DEA",  // QEVENT_DEACTIVATE"
        "ACT",  // QEVENT_ACTIVATE"
        "PST",  // QEVENT_POSTMESSAGE"
        "EXE",  // QEVENT_EXECSHELL"
        "CMN",  // QEVENT_CANCELMENU"
        "DSW",  // QEVENT_DESTROYWINDOW"
        "ASY",  // QEVENT_ASYNCSENDMSG"
        "HNG",  // QEVENT_HUNGTHREAD"
        "CMT",  // QEVENT_CANCELMOUSEMOVETRK"
        "NWE",  // QEVENT_NOTIFYWINEVENT"
        "RAC",  // QEVENT_RITACCESSIBILITY"
        "RSO",  // QEVENT_RITSOUND"
        "?  ",  // "?"
        "?  ",  // "?"
        "?  "   // "?"
    };
    #define NQEVENT (ARRAY_SIZE(aszEvents))

    Print("typ pqmsg    hwnd    msg  wParam   lParam   time     ExInfo   dwQEvent pti\n");
    Print("-------------------------------------------------------------------------------\n");

    SAFEWHILE (TRUE) {
        move(qmsg, FIXKP(pqmsgRead));
        if (qmsg.dwQEvent < NQEVENT) {
            Print("%s %08lx ", aszEvents[qmsg.dwQEvent], pqmsgRead);
        } else {
            Print("??? %08lx ", pqmsgRead);
        }

        switch (qmsg.dwQEvent) {
        case QEVENT_ASYNCSENDMSG:
            move(asm, (PVOID)qmsg.msg.wParam);

            Print("%07lx %04lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
                asm.hwnd, asm.message, asm.wParam, asm.lParam,
                qmsg.msg.time, qmsg.ExtraInfo, qmsg.dwQEvent, qmsg.pti);
            break;

        case 0:
        default:
            Print("%07lx %04lx %08lx %08lx %08lx %08lx %08lx %08lx\n",
                qmsg.msg.hwnd, qmsg.msg.message, qmsg.msg.wParam, qmsg.msg.lParam,
                qmsg.msg.time, qmsg.ExtraInfo, qmsg.dwQEvent, qmsg.pti);
            break;

        }

        if (qmsg.pqmsgNext != NULL) {
            if (pqmsgRead == qmsg.pqmsgNext) {
                Print("loop found in message list!");
                return FALSE;
            }
            pqmsgRead = qmsg.pqmsgNext;
        } else {
            return TRUE;
        }
    }
    return TRUE;
}
#endif // KERNEL

#endif // OLD_DEBUGGER

/************************************************************************\
* GetAndDumpHE
*
* Dumps given handle (dwT) and returns its phe.
*
* 6/9/1995 Documented SanfordS
\************************************************************************/
BOOL
GetAndDumpHE(
    ULONG64  dwT,
    PULONG64 phe,
    BOOL fPointerTest)
{

    DWORD dw;
    ULONG64 pheT, phead;
    ULONG64 pshi, psi, h;
    ULONG_PTR cHandleEntries;


    /*
     * Evaluate the argument string and get the address of the object to
     * dump. Take either a handle or a pointer to the object.
     */
    dw = HMIndexFromHandle(dwT);

    /*
     * First see if it is a pointer because the handle index is only part of
     * the 32 bit DWORD, and we may mistake a pointer for a handle.
     */
    if (!fPointerTest && IS_PTR(dwT)) {
        if (GetFieldValue(dwT, SYM(HEAD), "h", h) == 0) {
            if (GetAndDumpHE(h, phe, TRUE)) {
                return TRUE;
            }
        }
    }

    /*
     * Is it a handle? Does its index fit our table length?
     */
    GETSHAREDINFO(pshi);

    GetFieldValue(pshi, SYM(SHAREDINFO), "psi", psi);
    GetFieldValue(psi, SYM(SERVERINFO), "cHandleEntries", cHandleEntries);
    if (dw >= cHandleEntries) {
        return FALSE;
    }

    /*
     * Grab the handle entry and see if it is ok.
     */
    GetFieldValue(pshi, SYM(SHAREDINFO), "aheList", pheT);
    pheT += (dw * GetTypeSize("HANDLEENTRY"));

    *phe = pheT;

    /*
     * If the type is too big, it's not a handle.
     */
    InitTypeRead(pheT, HANDLEENTRY);

    if (ReadField(bType) >= TYPE_CTYPES) {
        pheT = 0;
    } else {
        phead = ReadField(phead);
        if (ReadField(bType) != TYPE_FREE) {
            /*
             * See if the object references this handle entry: the clincher
             * for a handle, if it is not FREE.
             */
            GetFieldValue(phead, SYM(HEAD), "h", h);
            if (HMIndexFromHandle(h) != dw)
                pheT = 0;
        }
    }

    if (pheT == 0) {
        if (!fPointerTest) {
            Print("0x%p is not a valid object or handle.\n", dwT);
        }
        return FALSE;
    }

    /*
     * Dump the ownership info and the handle entry info
     */
    GetFieldValue(phead, SYM(HEAD), "h", h);
#ifdef Idhe
    Idhe(0, h, 0);
#endif
    Print("\n");

    return TRUE;
}

/************************************************************************\
* HtoHE
*
* Extracts HE and phe from given handle. Handle can be just an index.
* Assumes h is a valid handle. Returns FALSE only if it's totally wacko.
*
* 6/9/1995 Created SanfordS
\************************************************************************/
BOOL HtoHE(
    ULONG64 h,
    ULONG64 *pphe OPTIONAL)
{
    ULONG64 psi;
    ULONG64 pheT;
    ULONG64 cHandleEntries;
    DWORD index;

    index = HMIndexFromHandle(h);
    GETSHAREDINFO(psi);
    if (psi == 0) {
        RAISE_EXCEPTION();
    }
    if (GetFieldValue(psi, SYM(SHAREDINFO), "aheList", pheT)) {
        DEBUGPRINT("HtoHE(%I64x): Couldn't get aheList. Bad symbols?\n", h);
        return FALSE;
    }

    if (GetFieldValue(psi, SYM(SHAREDINFO), "psi", psi)) {
        DEBUGPRINT("HtoHE(%I64x): Couldn't get psi. Bad symbols?\n", h);
        return FALSE;
    }

    if (GetFieldValue(psi, SYM(SERVERINFO), "cHandleEntries", cHandleEntries)) {
        DEBUGPRINT("HtoHE(%I64x): Couldn't get cHandleEntries. Bad symbols?\n", h);
        return FALSE;
    }

    if (index >= cHandleEntries) {
        DEBUGPRINT("HtoHE(%I64x): index %d is too large.\n", h, index);
        return FALSE;
    }
    pheT += index * GetTypeSize(SYM(HANDLEENTRY));

    if (pphe != NULL) {
        *pphe = pheT;
    }

    return TRUE;
}

/************************************************************************\
* GetPfromH
*
* Converts a handle to a pointer and extracts he and phe info. Returns a
* pointer to the object's HANDLEENTRY or NULL on failure.
*
* 6/9/1995 Created SanfordS
\************************************************************************/
ULONG64 GetPfromH(
    ULONG64 h,
    ULONG64 *pphe OPTIONAL)
{
    ULONG64 pheT;
    ULONG64 phead;

    if (!HtoHE(h, &pheT)) {
        DEBUGPRINT("GetPfromH(%p): failed to get HE.\n", h);
        return 0;
    }

    if (GetFieldValue(pheT, SYM(HANDLEENTRY), "phead", phead)) {
        DEBUGPRINT("GetPfromH(%p): failed to get phead.\n", h);
        return 0;
    }

    if (pphe != NULL) {
        *pphe = pheT;
    }

    return FIXKP(phead);
}


/************************************************************************\
* getHEfromP
*
* Converts a pointer to a handle and extracts the he and phe info.
*
* 6/9/1995 Created SanfordS
\************************************************************************/
BOOL getHEfromP(
    ULONG64 *pphe,
    ULONG64 p)
{
    ULONG64 pLookup, h;

    p = FIXKP(p);

    GetFieldValue(p, SYM(THROBJHEAD), "h", h);
    pLookup = GetPfromH(h, pphe);
    if (FIXKP(pLookup) != p) {
        DEBUGPRINT("getHEfromP(%p): invalid.\n", p);
        return FALSE;
    }

    return TRUE;
}


/************************************************************************\
* HorPtoP
*
* Generic function to accept either a user handle or pointer value and
* validate it and convert it to a pointer. type=-1 to allow any non-free
* type. type=-2 to allow any type.
*
* 6/9/1995 Created SanfordS
\************************************************************************/
ULONG64 HorPtoP(
    ULONG64 p,
    int type)
{
    ULONG64 phe;
    ULONG64 pT;
    ULONG64 phead;
    int bType;


    if (p == 0) {
        return 0;
    }

    p = FIXKP(p);
    if (ReadPointer(p, &pT) && getHEfromP(&phe, p)) {
        /*
         * It was a pointer
         */
        GetFieldValue(phe, SYM(HANDLEENTRY), "bType", bType);
        if ((type == -2 || bType != TYPE_FREE) &&
                bType < TYPE_CTYPES &&
                (type < 0 || bType == type)) {
            GetFieldValue(phe, SYM(HANDLEENTRY), "phead", phead);
            return FIXKP(phead);
        }
    }

    pT = GetPfromH(p, NULL);
    if (pT == 0) {
        Print("WARNING: dumping %p even though it's not a valid pointer or handle!\n", (ULONG_PTR)p);
        return p;  // let it pass anyway so we can see how it got corrupted.
    }

    return FIXKP(pT);
}

/************************************************************************\
* Procedure: DebugGetWindowTextA
*
* Description: Places pwnd title into achDest.
*
* 06/09/1995 Created                      SanfordS
* 11/18/2000 Added dwLength parameter     JasonSch
*
\************************************************************************/
BOOL DebugGetWindowTextA(
    ULONG64 pwnd,
    char *achDest,
    DWORD dwLength)
{
    ULONG Length;
    ULONG64 Buffer;
    WCHAR *lpwstr;

    if (pwnd == 0) {
        achDest[0] = '\0';
        return FALSE;
    }

    pwnd = FIXKP(pwnd);
    if (GetFieldValue(pwnd, SYM(WND), "strName.Length", Length) ||
        GetFieldValue(pwnd, SYM(WND), "strName.Buffer", Buffer)) {
        strcpy(achDest, "<< Can't get WND >>");
        return FALSE;
    }

    if (Length == 0) {
        strcpy(achDest, "<null>");
    } else {
        ULONG cbText = min(dwLength - 1, Length + sizeof(WCHAR));

        lpwstr = LocalAlloc(LPTR, cbText);
        if (!(tryMoveBlock(lpwstr, FIXKP(Buffer), cbText))) {
            strcpy(achDest, "<< Can't get title >>");
            LocalFree(lpwstr);
            return FALSE;
        }

        RtlUnicodeToMultiByteN(achDest, dwLength, NULL, lpwstr, cbText);
        achDest[cbText] = '\0';
        LocalFree(lpwstr);
    }
    return TRUE;
}

/************************************************************************\
* DebugGetClassNameA
*
* Placed pcls name into achDest.  No checks for size are made.
*
* 6/9/1995 Created SanfordS
\************************************************************************/
BOOL DebugGetClassNameA(
    ULONG64 lpszClassName,
    char *achDest)
{
    CHAR ach[80];

    if (lpszClassName == 0) {
        strcpy(achDest, "<null>");
    } else {
        if (!tryMove(ach, FIXKP(lpszClassName))) {
            strcpy(achDest, "<inaccessible>");
        } else {
            strcpy(achDest, ach);
        }
        strcpy(achDest, ach);
    }
    return TRUE;
}

/************************************************************************\
* PrintBitField, PrintEndBitField
*
* Printout specified boolean value in a structure. Assuming
* strlen(pszFieldName) will not exceeds BF_COLUMN_WIDTH.
*
* 10/12/1997 Created HiroYama
\************************************************************************/
VOID PrintBitField(
    LPSTR pszFieldName,
    BOOL fValue)
{
    int iWidth;
    int iStart = giBFColumn;

    sprintf(gach1, fValue ? "*%-s " : " %-s ", pszFieldName);

    iWidth = (strlen(gach1) + BF_COLUMN_WIDTH - 1) / BF_COLUMN_WIDTH;
    iWidth *= BF_COLUMN_WIDTH;

    if ((giBFColumn += iWidth) >= BF_MAX_WIDTH) {
        giBFColumn = iWidth;
        Print("%s\n", gaBFBuff);
        iStart = 0;
    }

    sprintf(gaBFBuff + iStart, "%-*s", iWidth, gach1);
}

VOID PrintEndBitField(
    VOID)
{
    if (giBFColumn != 0) {
        giBFColumn = 0;
        Print("%s\n", gaBFBuff);
    }
}

CONST char *pszObjStr[] = {
                     "Free",
                     "Window",
                     "Menu",
                     "Cursor",
                     "SetWindowPos",
                     "Hook",
                     "Thread Info",
                     "Clip Data",
                     "Call Proc",
                     "Accel Table",
                     "WindowStation",
                     "DeskTop",
                     "DdeAccess",
                     "DdeConv",
                     "DdeExact",
                     "Monitor",
                     "Ctypes",
                     "Console",
                     "Generic"
                    };


#ifdef KERNEL
/***********************************************************************\
* GetGdiHandleType
*
* Returns a static buffer address which will contain a > 0 length string
* if the type makes sense.
*
* 12/1/1995 Created SanfordS
\***********************************************************************/
LPCSTR GetGDIHandleType(
    HOBJ ho)
{
    ULONG64 pent;                           // base address of hmgr entries
    ULONG ulTemp;
    static CHAR szT[20];
    ULONG gcMaxHmgr, index;
    DWORD dwEntrySize = GetTypeSize(SYM(ENTRY));

// filched from gre\hmgr.h
#define INDEX_MASK          ((1 << INDEX_BITS) - 1)
#define HmgIfromH(h)          ((ULONG)(h) & INDEX_MASK)

    szT[0] = '\0';
    pent = GetGlobalPointer(VAR(gpentHmgr));
    moveExpValue(&gcMaxHmgr, VAR(gcMaxHmgr));
    index = HmgIfromH((ULONG_PTR) ho);
    if (index > gcMaxHmgr) {
        return szT;
    }

    InitTypeRead(pent + index * dwEntrySize, SYM(ENTRY));
    if ((USHORT)ReadField(FullUnique) != ((ULONG_PTR)ho >> 16)) {
        return szT;
    }

    if ((HOBJ)ReadField(einfo.pobj.hHmgr) != ho) {
        return szT;
    }
    ulTemp = (ULONG) ReadField(Objt);

    switch(ulTemp) {
    case DEF_TYPE:
        strcpy(szT, "DEF");
        break;

    case DC_TYPE:
        strcpy(szT, "DC");
        break;

    case RGN_TYPE:
        strcpy(szT, "RGN");
        break;

    case SURF_TYPE:
        strcpy(szT, "SURF");
        break;

    case PATH_TYPE:
        strcpy(szT, "PATH");
        break;

    case PAL_TYPE:
        strcpy(szT, "PAL");
        break;

    case ICMLCS_TYPE:
        strcpy(szT, "ICMLCS");
        break;

    case LFONT_TYPE:
        strcpy(szT, "LFONT");
        break;

    case RFONT_TYPE:
        strcpy(szT, "RFONT");
        break;

    case PFE_TYPE:
        strcpy(szT, "PFE");
        break;

    case PFT_TYPE:
        strcpy(szT, "PFT");
        break;

    case ICMCXF_TYPE:
        strcpy(szT, "ICMCXF");
        break;

    case SPRITE_TYPE:
        strcpy(szT, "SPRITE");
        break;

    case SPACE_TYPE:
        strcpy(szT, "SPACE");
        break;

    case META_TYPE:
        strcpy(szT, "META");
        break;

    case EFSTATE_TYPE:
        strcpy(szT, "EFSTATE");
        break;

    case BMFD_TYPE:
        strcpy(szT, "BMFD");
        break;

    case VTFD_TYPE:
        strcpy(szT, "VTFD");
        break;

    case TTFD_TYPE:
        strcpy(szT, "TTFD");
        break;

    case RC_TYPE:
        strcpy(szT, "RC");
        break;

    case TEMP_TYPE:
        strcpy(szT, "TEMP");
        break;

    case DRVOBJ_TYPE:
        strcpy(szT, "DRVOBJ");
        break;

    case DCIOBJ_TYPE:
        strcpy(szT, "DCIOBJ");
        break;

    case SPOOL_TYPE:
        strcpy(szT, "SPOOL");
        break;

    default:
        ulTemp = LO_TYPE((USHORT)ReadField(FullUnique) << TYPE_SHIFT);
        switch (ulTemp) {
        case LO_BRUSH_TYPE:
            strcpy(szT, "BRUSH");
            break;

        case LO_PEN_TYPE:
            strcpy(szT, "LO_PEN");
            break;

        case LO_EXTPEN_TYPE:
            strcpy(szT, "LO_EXTPEN");
            break;

        case CLIENTOBJ_TYPE:
            strcpy(szT, "CLIENTOBJ");
            break;

        case LO_METAFILE16_TYPE:
            strcpy(szT, "LO_METAFILE16");
            break;

        case LO_METAFILE_TYPE:
            strcpy(szT, "LO_METAFILE");
            break;

        case LO_METADC16_TYPE:
            strcpy(szT, "LO_METADC16");
            break;
        }
    }
    return szT;
}

#endif // KERNEL


VOID DirectAnalyze(
ULONG_PTR dw,
ULONG_PTR adw,
BOOL fNoSym)
{
    DWORD       index, cHandleEntries, dwHESize, dwHandleOffset;
    ULONG64     dwOffset, pshi, psi, phe;
    WORD        uniq, w, aw;
    CHAR        ach[80];
#ifdef KERNEL
    LPCSTR      psz;
#endif

    GETSHAREDINFO(pshi);
    GetFieldValue(pshi, SYM(SHAREDINFO), "psi", psi);

    dwHESize = GetTypeSize(SYM(HANDLEENTRY));
    GetFieldOffset(SYM(SHAREDINFO), "aheList", &dwHandleOffset);

    if (HIWORD(dw) != 0) {
        /*
         * See if its a handle
         */
        index = HMIndexFromHandle((ULONG)dw);
        GetFieldValue(psi, SYM(SERVERINFO), "cHandleEntries", cHandleEntries);
        if (index < cHandleEntries) {
            uniq = HMUniqFromHandle(dw);
            ReadPointer(pshi + dwHandleOffset, &phe);
            phe += index * dwHESize;
            InitTypeRead(phe, HANDLEENTRY);
            if (((WORD)ReadField(wUniq)) == uniq) {
                Print("= a %s handle. ", pszObjStr[(ULONG)ReadField(bType)]);
                fNoSym = TRUE;
            }
        }

#ifdef KERNEL
        /*
         * See if it's a GDI object handle
         */
        psz = GetGDIHandleType((HOBJ)dw);
        if (*psz) {
            Print("= a GDI %s type handle. ", psz);
            fNoSym = TRUE;
        }
#endif // KERNEL

        /*
         * See if it's an object pointer
         */
        if (InitTypeRead(dw, SYM(HEAD))) {
            if ((ULONG)ReadField(h)) {
                index = HMIndexFromHandle((ULONG)ReadField(h));
                if (index < cHandleEntries) {
                    ReadPointer(pshi + dwHandleOffset + index * dwHESize, &phe);
                    if (((ULONG_PTR)ReadField(phead)) == dw) {
                        Print("= a pointer to a %s.", pszObjStr[ReadField(bType)]);
                        fNoSym = TRUE;
                    }
                }
            }
            /*
             * Does this reference the stack itself?
             */
            w = HIWORD(dw);
            aw = HIWORD(adw);
            if (w == aw || w == aw - 1 || w == aw + 1) {
                Print("= Stack Reference ");
                fNoSym = TRUE;
            }
            if (!fNoSym) {
                /*
                 * Its accessible so print its symbolic reference
                 */
                GetSym(dw, ach, &dwOffset);
                if (*ach) {
                    Print("= symbol \"%s\"", ach);
                    if (dwOffset) {
                        Print(" + %p", dwOffset);
                    }
                }
            }
        }
    }
    Print("\n");
}

/***********************************************************************\
* Isas
*
* Analyzes the stack.  Looks at a range of dwords and tries to make
* sense out of them.  Identifies handles, user objects, and code
* addresses.
*
* 11/30/1995 Created SanfordS
\***********************************************************************/
BOOL Isas(
    DWORD opts,
    ULONG64 param1,
    ULONG64 param2)
{
    DWORD count = (DWORD)(UINT_PTR)param2;
    DWORD_PTR dw;
    DWORD dwPointerSize = GetTypeSize("PVOID");

    if (param1 == 0) {
        return FALSE;
    }

    if (opts & OFLAG(d)) {
        DirectAnalyze((ULONG_PTR)param1, 0, opts & OFLAG(s));
    } else {
        if (count == 0) {
            count = 25;    // default span
        }
        Print("--- Stack analysis ---\n");
        for ( ; count; count--, param1 += dwPointerSize) {
            if (IsCtrlCHit()) {
                break;
            }
            Print("[0x%p]: ", (ULONG_PTR)param1);
            if (tryMove(dw, param1)) {
                DirectAnalyze(dw, (DWORD_PTR)param1, OFLAG(s) & opts);
            } else {
                Print("No access\n");
            }
        }
    }
    return TRUE;
}

#ifdef KERNEL

typedef VOID (*AtomPrint)(DWORD dwOneShot, RTL_ATOM atom, USHORT usRefCount,
                         const WCHAR* pwszName, UCHAR uNameLength, UCHAR uFlags);

VOID DefAtomPrint(
    DWORD dwOneShot,
    RTL_ATOM atom,
    USHORT usRefCount,
    const WCHAR* pwszName,
    UCHAR uNameLength,
    UCHAR uFlags)
{
    Print("%*s%hx(%2d) = %ls (%d)%s\n",
            dwOneShot, dwOneShot ? " " : "",  // hack: fOneShot is also used as a prefix spaces...
            atom,
            usRefCount,
            pwszName,
            uNameLength,
            uFlags & RTL_ATOM_PINNED ? " pinned" : "");
}

/************************************************************************\
* DumpAtomTable
*
* Dumps an atom or entire atom table.
*
* 6/9/1995 Created SanfordS
\************************************************************************/
BOOL DumpAtomTable(
    ULONG64 table,
    RTL_ATOM atomFind,
    DWORD dwOneShot,
    AtomPrint pfnPrint)
{
    ULONG i;
    ULONG cBuckets;
    ULONG cb, cbPtr, cbBuckets;
    ULONG64 pate;
    RTL_ATOM atom;
    UCHAR Flags;
    USHORT RefCount;
    UCHAR NameLength;
    WCHAR *pName;

    if (pfnPrint == NULL) {
        pfnPrint = DefAtomPrint;
    }

    if (!dwOneShot) {
        Print("\n");
    }

    cbPtr = GetTypeSize("PVOID");
    GetFieldValue(table, "nt!_RTL_ATOM_TABLE", "NumberOfBuckets", cBuckets);
    GetFieldOffset("nt!_RTL_ATOM_TABLE", "Buckets", &cbBuckets);

    for (i = 0; i < cBuckets; i++) {
        ShowProgress(i);
        ReadPointer(table + cbBuckets + i * cbPtr, &pate);

        if (atomFind == 0 && pate != 0 && !dwOneShot) {
            Print("   Bucket %d\n", i);
        }

        while (pate != NULL_POINTER) {
            GetFieldValue(pate, "nt!_RTL_ATOM_TABLE_ENTRY", "Atom", atom);
            GetFieldValue(pate, "nt!_RTL_ATOM_TABLE_ENTRY", "Flags", Flags);
            GetFieldValue(pate, "nt!_RTL_ATOM_TABLE_ENTRY", "ReferenceCount", RefCount);
            GetFieldValue(pate, "nt!_RTL_ATOM_TABLE_ENTRY", "NameLength", NameLength);
            GetFieldOffset("nt!_RTL_ATOM_TABLE_ENTRY", "Name", &cb);

            pName = LocalAlloc(LPTR, sizeof(WCHAR) * (NameLength + 1));
            ReadMemory(pate + cb, (PVOID)pName, sizeof(WCHAR) * NameLength, &cb);
            pName[NameLength] = L'\0';

            if (atomFind == 0 || atom == atomFind) {
                pfnPrint(dwOneShot, atom, RefCount, pName, NameLength, Flags);

                if (atom == atomFind) {
                    LocalFree(pName);
                    return TRUE;
                }
            }

            LocalFree(pName);
            GetFieldValue(pate, "nt!_RTL_ATOM_TABLE_ENTRY", "HashLink", pate);
        }
    }

    return FALSE;
}

/************************************************************************\
* Iatom
*
* Dumps an atom or the entire local USER atom table.
*
* 6/9/1995 Created SanfordS
\************************************************************************/
BOOL Iatom(
    DWORD opts,
    ULONG64 atom)
{
    ULONG64 table;
    ULONG64 pwinsta;

    UNREFERENCED_PARAMETER(opts);

    table = GetGlobalPointer(VAR(UserAtomTableHandle));

    if (table != NULL_POINTER) {
        Print("\nPrivate atom table for WIN32K ");
        DumpAtomTable(table, (RTL_ATOM)atom, FALSE, NULL);
    }

    FOREACHWINDOWSTATION(pwinsta)

        GetFieldValue(pwinsta, SYM(WINDOWSTATION), "pGlobalAtomTable", table);

        if (table != NULL_POINTER) {
            Print(" \nGlobal atom table for window station %lx ", pwinsta);
            DumpAtomTable(table, (RTL_ATOM)atom, FALSE, NULL);
        }

    NEXTEACHWINDOWSTATION(pwinsta);

    return TRUE;
}
#endif // KERNEL

#ifdef OLD_DEBUGGER
#ifndef KERNEL
/************************************************************************\
* DumpConvInfo
*
* Dumps DDEML client conversation info structures.
*
* 6/9/1995 Created SanfordS
\************************************************************************/
BOOL DumpConvInfo(
    PCONV_INFO pcoi)
{
    CL_CONV_INFO coi;
    ADVISE_LINK al;
    XACT_INFO xi;

    move(coi, pcoi);
    Print("    next              = 0x%08lx\n", coi.ci.next);
    Print("    pcii              = 0x%08lx\n", coi.ci.pcii);
    Print("    hUser             = 0x%08lx\n", coi.ci.hUser);
    Print("    hConv             = 0x%08lx\n", coi.ci.hConv);
    Print("    laService         = 0x%04x\n",  coi.ci.laService);
    Print("    laTopic           = 0x%04x\n",  coi.ci.laTopic);
    Print("    hwndPartner       = 0x%08lx\n", coi.ci.hwndPartner);
    Print("    hwndConv          = 0x%08lx\n", coi.ci.hwndConv);
    Print("    state             = 0x%04x\n",  coi.ci.state);
    Print("    laServiceRequested= 0x%04x\n",  coi.ci.laServiceRequested);
    Print("    pxiIn             = 0x%08lx\n", coi.ci.pxiIn);
    Print("    pxiOut            = 0x%08lx\n", coi.ci.pxiOut);
    SAFEWHILE (coi.ci.pxiOut) {
        move(xi, coi.ci.pxiOut);
        Print("      hXact           = (0x%08lx)->0x%08lx\n", xi.hXact, coi.ci.pxiOut);
        coi.ci.pxiOut = xi.next;
    }
    Print("    dmqIn             = 0x%08lx\n", coi.ci.dmqIn);
    Print("    dmqOut            = 0x%08lx\n", coi.ci.dmqOut);
    Print("    aLinks            = 0x%08lx\n", coi.ci.aLinks);
    Print("    cLinks            = 0x%08lx\n", coi.ci.cLinks);
    SAFEWHILE (coi.ci.cLinks--) {
        move(al, coi.ci.aLinks++);
        Print("      pLinkCount = 0x%08x\n", al.pLinkCount);
        Print("      wType      = 0x%08x\n", al.wType);
        Print("      state      = 0x%08x\n", al.state);
        if (coi.ci.cLinks) {
            Print("      ---\n");
        }
    }
    if (coi.ci.state & ST_CLIENT) {
        Print("    hwndReconnect     = 0x%08lx\n", coi.hwndReconnect);
        Print("    hConvList         = 0x%08lx\n", coi.hConvList);
    }

    return TRUE;
}
#endif // !KERNEL

#endif // OLD_DEBUGGER

#ifndef KERNEL
/************************************************************************\
* FixKernelPointer
*
* Converts a kernel object pointer into its client-side equivalent. Client
* pointers and NULL are unchanged.
*
* 6/15/1995 Created SanfordS
\************************************************************************/
ULONG64
FixKernelPointer(
    ULONG64 pKernel)
{
    static ULONG64 pteb = 0;
    static ULONG64 ulClientDelta;
    static ULONG64 HighestUserAddress;

    if (pKernel == 0) {
        return 0;
    }
    if (HighestUserAddress == 0) {
        SYSTEM_BASIC_INFORMATION SystemInformation;

        if (NT_SUCCESS(NtQuerySystemInformation(SystemBasicInformation,
                                                 &SystemInformation,
                                                 sizeof(SystemInformation),
                                                 NULL))) {
            HighestUserAddress = SystemInformation.MaximumUserModeAddress;
        } else {
            // Query failed.  Assume usermode is the low half of the address
            // space.
            HighestUserAddress = MAXINT_PTR;
        }
    }

    if (!IsPtr64()) {
        pKernel = (ULONG)pKernel;
    }

    if (pKernel <= HighestUserAddress) {
        return pKernel;
    }
    if (pteb == 0) {
        ULONG pciOffset;

        GetTebAddress(&pteb);
        GetFieldOffset(SYM(TEB), "Win32ClientInfo", &pciOffset);
        GetFieldValue(pteb + pciOffset, SYM(CLIENTINFO), "ulClientDelta", ulClientDelta);
    }
    return (pKernel - ulClientDelta);
}

ULONG64
RebaseSharedPtr(ULONG64 p)
{
    ULONG64         pshi = 0;
    ULONG64         ulSharedDelta;

    if (p == 0) {
        return 0;
    }

    moveExp(&pshi, VAR(gSharedInfo));
    if (pshi == 0) {
        RAISE_EXCEPTION();
    }
    if (!GetFieldValue(pshi, SYM(SHAREDINFO), "ulSharedDelta", ulSharedDelta)) {
        RAISE_EXCEPTION();
    }

    return p - ulSharedDelta;
}

#endif // !KERNEL

/************************************************************************\
* Procedure: GetVKeyName
*
* 08/09/98 HiroYama     Created
*
\************************************************************************/

typedef struct {
    DWORD dwVKey;
    const char* name;
} VKeyDef;

int compareVKey(const VKeyDef* a, const VKeyDef* b)
{
    return a->dwVKey - b->dwVKey;
}

#define VKEY_ITEM(x) { x, #x }

const VKeyDef gVKeyDef[] = {
#include "vktbl.txt"
};

const char* _GetVKeyName(DWORD dwVKey, int n)
{
    int i;

    /*
     * If dwVKey is one of alphabets or numerics, there's no VK_ macro defined.
     */
    if ((dwVKey >= 'A' && dwVKey <= 'Z') || (dwVKey >= '0' && dwVKey <= '9')) {
        static char buffer[] = "VK_*";

        if (n != 0) {
            return "";
        }
        buffer[ARRAY_SIZE(buffer) - 2] = (BYTE)dwVKey;
        return buffer;
    }

    /*
     * Search the VKEY table.
     */
    for (i = 0; i < ARRAY_SIZE(gVKeyDef); ++i) {
        const VKeyDef* result = gVKeyDef + i;

        if (result->dwVKey == dwVKey) {
            for (; i < ARRAY_SIZE(gVKeyDef); ++i) {
                if (gVKeyDef[i].dwVKey != dwVKey) {
                    return "";
                }
                if (&gVKeyDef[i] - result == n) {
                    return gVKeyDef[i].name;
                }
            }
        }
    }

    /*
     * VKey name is not found.
     */
    return "";
}

const char* GetVKeyName(DWORD dwVKey)
{
    static char buf[256];
    const char* delim = "";
    int n = 0;

    buf[0] = 0;

    for (n = 0; n < ARRAY_SIZE(gVKeyDef); ++n) {
        const char* name = _GetVKeyName(dwVKey, n);
        if (*name) {
            strcat(buf, delim);
            strcat(buf, name);
            delim = " / ";
        } else {
            break;
        }
    }
    return buf;
}

#undef VKEY_ITEM

#ifdef KERNEL
/************************************************************************\
* Procedure: DumpClassList
*
*
* 05/18/98 GerardoB     Extracted from Idcls
\************************************************************************/
VOID DumpClassList(
    DWORD opts,
    ULONG64 pcls,
    BOOL fPrivate)
{
    ULONG64 pclsClone;
    ULONG64 pclsNext;

    SAFEWHILE (pcls != 0) {
        if (GetFieldValue(pcls, SYM(CLS), "pclsClone", pclsClone)) {
            Print("  Private class\t\tPCLS @ 0x%p - inaccessible, skipping...\n", pcls);
            break;
        }
        Print("  %s class\t\t", fPrivate ? "Private" : "Public ");
        Idcls(opts, pcls);

        if (pclsClone != 0) {
            SAFEWHILE (pclsClone != 0) {
                if (GetFieldValue(pclsClone, SYM(CLS), "pclsNext", pclsNext)) {
                    Print("Could not access clone class at %p, skipping clones...\n", pclsClone);
                    break;
                }
                Print("  %s class clone\t", fPrivate ? "Private" : "Public ");
                Idcls(opts, pclsClone);
                pclsClone = pclsNext;
            }
        }

        GetFieldValue(pcls, SYM(CLS), "pclsNext", pcls);
    }
}

ULONG
dclsCallback(
    ULONG64 ppi,
    PVOID   Data)
{
    DWORD opts = PtrToUlong(Data);
    ULONG64 pcls;

    UNREFERENCED_PARAMETER(Data);

    Print("\nClasses for process %p:\n", ppi);

    GetFieldValue(ppi, SYM(PROCESSINFO), "pclsPrivateList", pcls);
    DumpClassList(opts, pcls, TRUE);

    GetFieldValue(ppi, SYM(PROCESSINFO), "pclsPublicList", pcls);
    DumpClassList(opts, pcls, FALSE);

    return FALSE;
}

/************************************************************************\
* Idcls
*
* Dumps window class structures
*
* 6/9/1995 Created SanfordS
\************************************************************************/
BOOL Idcls(
    DWORD opts,
    ULONG64 param1)
{
    char ach[120];
    ULONG64 dwOffset;
    ULONG64 pcls = param1;

    if (param1 == 0) {

        ForEachPpi(dclsCallback, ULongToPtr(opts));

        Print("\nGlobal Classes:\n");
        pcls = GetGlobalPointer(VAR(gpclsList));
        SAFEWHILE (pcls) {
            Print("  Global Class\t\t");
            Idcls(opts, pcls);
            GetFieldValue(pcls, SYM(CLS), "pclsNext", pcls);
        }
        return TRUE;
    }

    /*
     * Dump class list for a process
     */
    if (opts & OFLAG(p)) {
        opts &= ~OFLAG(p);
        Print("\nClasses for process %p:\n", param1);

        GetFieldValue(param1, SYM(PROCESSINFO), "pclsPrivateList", pcls);
        DumpClassList(opts, pcls, TRUE);

        GetFieldValue(param1, SYM(PROCESSINFO), "pclsPublicList", pcls);
        DumpClassList(opts, pcls, FALSE);

        return TRUE;
    }

    InitTypeRead(pcls, CLS);

    DebugGetClassNameA(ReadField(lpszAnsiClassName), ach);
    Print("PCLS @ 0x%p \t(%s)\n", pcls, ach);
    if (opts & OFLAG(v)) {
        Print("\t pclsNext                      0x%p\n"
              "\t atomClassNameAtom (V)         0x%04x\n"
              "\t atomNVClassNameAtom (NV)      0x%04x\n"
              "\t fnid                          0x%04x\n"
              "\t pDCE                          0x%p\n"
              "\t cWndReferenceCount            0x%08lx\n"
              "\t flags                         %s\n",

              ReadField(pclsNext),
              (ULONG)ReadField(atomClassName),
              (ULONG)ReadField(atomNVClassName),
              (ULONG)ReadField(fnid),
              ReadField(pdce),
              (ULONG)ReadField(cWndReferenceCount),
              GetFlags(GF_CSF, (WORD)ReadField(CSF_flags), NULL, TRUE));

        if (ReadField(lpszClientAnsiMenuName)) {
            move(ach, ReadField(lpszClientAnsiMenuName));
            ach[sizeof(ach) - 1] = '\0';
        } else {
            ach[0] = '\0';
        }
        Print("\t lpszClientMenu                0x%p (%s)\n",
              ReadField(lpszClientUnicodeMenuName),
              ach);

        Print("\t hTaskWow                      0x%08lx\n"
              "\t spcpdFirst                    0x%p\n"
              "\t pclsBase                      0x%p\n"
              "\t pclsClone                     0x%p\n",
              (ULONG)ReadField(hTaskWow),
              ReadField(spcpdFirst),
              ReadField(pclsBase),
              ReadField(pclsClone));

        GetSym(ReadField(lpfnWndProc), ach, &dwOffset);
        Print("\t style                         %s\n"
              "\t lpfnWndProc                   0x%p = \"%s\" \n"
              "\t cbclsExtra                    0x%08lx\n"
              "\t cbwndExtra                    0x%08lx\n"
              "\t hModule                       0x%p\n"
              "\t spicn                         0x%p\n"
              "\t spcur                         0x%p\n"
              "\t hbrBackground                 0x%p\n"
              "\t spicnSm                       0x%p\n",
              GetFlags(GF_CS, (DWORD)ReadField(style), NULL, TRUE),
              ReadField(lpfnWndProc), ach,
              (ULONG)ReadField(cbclsExtra),
              (ULONG)ReadField(cbwndExtra),
              ReadField(hModule),
              ReadField(spicn),
              ReadField(spcur),
              ReadField(hbrBackground),
              ReadField(spicnSm));
    }

    return TRUE;
}
#endif // KERNEL

#ifdef KERNEL



LPSTR ProcessName(
    ULONG64 ppi)
{
    ULONG64 pEProcess;
    static UCHAR ImageFileName[16];

    GetFieldValue(ppi, "win32k!W32PROCESS", "Process", pEProcess);
    GetFieldValue(pEProcess, "nt!EPROCESS", "ImageFileName", ImageFileName);
    if (ImageFileName[0]) {
        return ImageFileName;
    } else {
        return "System";
    }
}

#endif // KERNEL

#ifdef KERNEL


VOID PrintCurHeader()
{
    Print("P = Process Owned.\n");
    Print("P pcursor    flags  rt   Res/Name   ModAtom  bpp cx  cy  xHot yHot hbmMask    hbmColor   hbmUserAlpha\n");
}


VOID PrintCurData(
    ULONG64 pcur,
    DWORD opts)
{
    InitTypeRead(pcur, CURSOR);

    if ((opts & OFLAG(x)) &&
        (((DWORD) ReadField(CURSORF_flags)) & (CURSORF_ACONFRAME | CURSORF_LINKED))) {
        return; // skip acon frame or linked objects.
    }

    if (((DWORD) ReadField(CURSORF_flags)) & CURSORF_ACON) {

        if (opts & OFLAG(a)) {
            Print("--------------\n");
        }

        if (opts & OFLAG(o)) {
            Print("\nOwner:%#010p (%s)\n", ReadField(head.ppi), ProcessName(ReadField(head.ppi)));
        }

        if (opts & OFLAG(v)) {
            Print("\nACON @ 0x%p:\n", pcur);
            Print("  ppiOwner       = %#010p\n", ReadField(head.ppi));
            Print("  CURSORF_flags  = %s\n", GetFlags(GF_CURSORF, (DWORD) ReadField(CURSORF_flags), NULL, TRUE));
            Print("  strName        = %#010p\n", ReadField(strName.Buffer));
            Print("  atomModName    = %#x\n", (DWORD) ReadField(atomModName));
            Print("  rt             = %#x\n", (DWORD) ReadField(rt));
        } else {
            ULONG64 cpcur = 0;
            GetFieldValue(pcur, SYM(ACON), "cpcur", cpcur);

            Print("%c %#010p %#6x %#4x %#010p %#8x --- ACON (%d frames)\n",
                ReadField(head.ppi) ? 'P' : ' ',
                pcur,
                (DWORD) ReadField(CURSORF_flags),
                (DWORD) ReadField(rt),
                ReadField(strName.Buffer),
                (DWORD) ReadField(atomModName),
                (DWORD) cpcur);
        }

        if (opts & OFLAG(a)) {
            int i = 0;
            ULONG cbElement = 0;
            ULONG cbArrayOffset = 0;
            ULONG64 curFrame = 0;

            InitTypeRead(pcur, ACON);

            cbElement = GetTypeSize("PCURSOR");
            GetFieldOffset(SYM(ACON), "aspcur", &cbArrayOffset);

            Print("%d animation sequences, currently at step %d.\n",
                  (DWORD) ReadField(cicur),
                  (DWORD) ReadField(iicur));

            i = (int) ReadField(cpcur);
            while (i--) {
                ReadPointer(pcur + cbArrayOffset + (i * cbElement), &curFrame);
                PrintCurData(curFrame, opts & ~(OFLAG(x) | OFLAG(o)));
            }
            Print("--------------\n");
        }
    } else {
        if (opts & OFLAG(v)) {
            Print("\nCursor/Icon @ 0x%p:\n", pcur);
            Print("  ppiOwner       = %#010p (%s)\n", ReadField(head.ppi), ProcessName(ReadField(head.ppi)));
            Print("  pcurNext       = %#010p\n", ReadField(pcurNext));
            Print("  CURSORF_flags  = %s\n", GetFlags(GF_CURSORF, (DWORD) ReadField(CURSORF_flags), NULL, TRUE));
            Print("  strName        = %#010p\n", ReadField(strName.Buffer));
            Print("  atomModName    = %#x\n", (DWORD) ReadField(atomModName));
            Print("  rt             = %#x\n", (DWORD) ReadField(rt));
            Print("  bpp            = %d\n", (DWORD) ReadField(bpp));
            Print("  cx             = %d\n", (DWORD) ReadField(cx));
            Print("  cy             = %d\n", (DWORD) ReadField(cy));
            Print("  xHotspot       = %d\n", (DWORD) ReadField(xHotspot));
            Print("  yHotspot       = %d\n", (DWORD) ReadField(yHotspot));
            Print("  hbmMask        = %#x\n", (DWORD) ReadField(hbmMask));
            Print("  hbmColor       = %#x\n", (DWORD) ReadField(hbmColor));
            Print("  hbmUserAlpha   = %#x\n", (DWORD) ReadField(hbmUserAlpha));
        } else {
            if (opts & OFLAG(o)) {
                Print("\nOwner:%#010p (%s)\n", ReadField(head.ppi), ProcessName(ReadField(head.ppi)));
            }
            Print("%c %#010p %#06x %#04x %#010p %#08x %3d %3d %3d %4d %4d %#010x %#010x %#010x\n",
                ReadField(head.ppi) ? 'P' : ' ',
                pcur,
                (DWORD) ReadField(CURSORF_flags),
                (DWORD) ReadField(rt),
                ReadField(strName.Buffer),
                (DWORD) ReadField(atomModName),
                (DWORD) ReadField(bpp),
                (DWORD) ReadField(cx),
                (DWORD) ReadField(cy),
                (DWORD) ReadField(xHotspot),
                (DWORD) ReadField(yHotspot),
                (DWORD) ReadField(hbmMask),
                (DWORD) ReadField(hbmColor),
                (DWORD) ReadField(hbmUserAlpha));
        }
    }
}

typedef struct tagMyCurData
{
    ULONG64 ppiDesired;
    ULONG idDesired;
    DWORD opts;
} MyCurData;

ULONG WDBGAPI PrintPpiCurData(ULONG64 ppi, PVOID Data)
{
    ULONG64 pcur = 0;

    MyCurData * pMyCurData = (MyCurData *)Data;
    if (pMyCurData == NULL) {
        return 0;
    }

    InitTypeRead(ppi, PROCESSINFO);

    if (ReadField(pCursorCache)) {
        Print("\nCache for process %#010p (%s):\n", ppi, ProcessName(ppi));
        pcur = ReadField(pCursorCache);
        while (pcur) {
            InitTypeRead(pcur, CURSOR);
            if ((pMyCurData->idDesired == 0) || ((ULONG) ReadField(strName.Buffer) == pMyCurData->idDesired)) {
                if (ReadField(head.ppi) != ppi) {
                    Print("Wrong cache! Owned by %#010p! --v\n", ReadField(head.ppi));
                }
                PrintCurData(pcur, pMyCurData->opts);
            }
            pcur = ReadField(pcurNext);
        }
    }

    return 0;
}

/************************************************************************\
* Idcur
*
* Dump cursor structures.
*
* 6/9/1995 Created SanfordS
\************************************************************************/
BOOL Idcur(
    DWORD opts,
    ULONG64 param1)
{
    ULONG64 ppi = 0;
    ULONG64 ppiDesired = 0;
    ULONG idDesired = 0;
    ULONG64 pcur = 0;
    ULONG64 phe = 0;
    int cCursors = 0;
    int i;

    if (OFLAG(p) & opts) {
        ppiDesired = param1;
        param1 = 0;
    } else if (OFLAG(i) & opts) {
        idDesired = (ULONG) param1;
        param1 = 0;
    }

    if (param1 == 0) {
        if (!(OFLAG(v) & opts)) {
            PrintCurHeader();
        }

        pcur = GetGlobalPointer(VAR(gpcurFirst));

        if (pcur != 0 && ppiDesired == 0) {
            Print("\nGlobal cache:\n");

            while (pcur) {
                InitTypeRead(pcur, CURSOR);

                if (!idDesired || ((ULONG) ReadField(strName.Buffer) == idDesired)) {
                    if (ReadField(head.ppi) != 0) {
                        Print("Wrong cache! Owned by %010p! --v\n", ReadField(head.ppi));
                    }
                    PrintCurData(pcur, opts);
                }
                pcur = ReadField(pcurNext);
            }
        }

        if (ppiDesired == 0 || ppiDesired == ppi) {
            MyCurData myCurData;

            myCurData.ppiDesired = ppiDesired;
            myCurData.idDesired = idDesired;
            myCurData.opts = opts;

            ForEachPpi(PrintPpiCurData, &myCurData);
        }

        Print("\nNon-cached cursor objects:\n");

        FOREACHHANDLEENTRY(phe, i)
            InitTypeRead(phe, HANDLEENTRY);

            if (ReadField(bType) == TYPE_CURSOR) {
                pcur = ReadField(phead);
                InitTypeRead(pcur, CURSOR);

                if (!(ReadField(CURSORF_flags) & (CURSORF_LINKED | CURSORF_ACONFRAME)) &&
                        (!idDesired || ((ULONG) ReadField(strName.Buffer) == idDesired)) &&
                        (ppiDesired == 0 || ppiDesired == ReadField(head.ppi))) {
                    PrintCurData(pcur, opts | OFLAG(x) | OFLAG(o));
                }
                cCursors++;
            }
        NEXTEACHHANDLEENTRY()

        Print("\n%d Cursors/Icons Total.\n", cCursors);
        return TRUE;
    }

    pcur = HorPtoP(param1, TYPE_CURSOR);
    if (pcur == 0) {
        Print("%010p : Invalid cursor handle or pointer.\n", param1);
        return FALSE;
    }

    if (!(OFLAG(v) & opts)) {
        PrintCurHeader();
    }

    PrintCurData(pcur, opts);
    return TRUE;
}
#endif // KERNEL


#ifdef KERNEL
/************************************************************************\
* ddeexact
*
* Dumps DDEML transaction structures.
*
* 6/9/1995 Created SanfordS
\************************************************************************/
BOOL dddexact(
    ULONG64 pxs,
    DWORD opts)
{
    InitTypeRead(pxs, SYM(XSTATE));
    if (opts & OFLAG(v)) {
        Print("    XACT:0x%p\n", pxs);
        Print("      snext = 0x%#p\n", ReadField(snext));
        Print("      fnResponse = 0x%#p\n", ReadField(fnResponse));
        Print("      hClient = 0x%08lx\n", (ULONG)ReadField(hClient));
        Print("      hServer = 0x%08lx\n", (ULONG)ReadField(hServer));
        Print("      pIntDdeInfo = 0x%#p\n", ReadField(pIntDdeInfo));
    } else {
        Print("0x%#p(0x%08lx) ", pxs, (ULONG)ReadField(flags));
    }
    return TRUE;
}
#endif // KERNEL


#ifdef KERNEL
/************************************************************************\
* ddeconv
*
* Dumps DDE tracking layer conversation structures.
*
* 6/9/1995 Created SanfordS
\************************************************************************/
BOOL dddeconv(
    ULONG64 pDdeconv,
    DWORD opts)
{
    ULONG64 pxs;
    int cX;
    DWORD dwOffset, dwQosOffset;

    InitTypeRead(pDdeconv, SYM(DDECONV));
    Print("  CONVERSATION-PAIR(0x%p:0x%p)\n", pDdeconv, ReadField(spartnerConv));
    if (opts & OFLAG(v)) {
        Print("    snext        = 0x%p\n", ReadField(snext));
        Print("    spwnd        = 0x%p\n", ReadField(spwnd));
        Print("    spwndPartner = 0x%p\n", ReadField(spwndPartner));
    }
    if (opts & (OFLAG(v) | OFLAG(r))) {
        if (ReadField(spxsOut)){
            pxs = ReadField(spxsOut);
            cX = 0;
            SAFEWHILE (pxs) {
                if ((opts & OFLAG(r)) && !cX++) {
                    Print("    Transaction chain:");
                } else {
                    Print("    ");
                }
                dddexact(pxs, opts);
                if (opts & OFLAG(r)) {
                    GetFieldValue(pxs, SYM(STATE), "snext", pxs);
                } else {
                    pxs = 0;
                }
                if (!pxs) {
                    Print("\n");
                }
            }
        }
    }
    if (opts & OFLAG(v)) {
        Print("    pfl          = 0x%p\n", ReadField(pfl));
        Print("    flags        = 0x%08lx\n", (ULONG)ReadField(flags));
        if ((opts & OFLAG(v)) && (opts & OFLAG(r)) && ReadField(pddei)) {
            GetFieldOffset(SYM(DDECONV), "pddei", &dwOffset);
            GetFieldOffset(SYM(DDEIMP), "qos", &dwQosOffset);
            InitTypeRead(pDdeconv + dwOffset + dwQosOffset,  SYM(DDEI));
            Print("    pddei    = 0x%08lx\n", pDdeconv+ dwOffset);
            Print("    Impersonation info:\n");
            Print("      qos.Length                 = 0x%08lx\n", (ULONG)ReadField(Length));
            Print("      qos.ImpersonationLevel     = 0x%08lx\n", (ULONG)ReadField(ImpersonationLevel));
            Print("      qos.ContextTrackingMode    = 0x%08lx\n", (ULONG)ReadField(ContextTrackingMode));
            Print("      qos.EffectiveOnly          = 0x%08lx\n", (ULONG)ReadField(EffectiveOnly));
            InitTypeRead(pDdeconv + dwOffset, SYM(DDEIMP));
            GetFieldOffset(SYM(DDEIMP), "ClientContext", &dwOffset);
            Print("      ClientContext              = 0x%#p\n", pDdeconv + dwOffset);
            Print("      cRefInit                   = 0x%08lx\n", (ULONG)ReadField(cRefInit));
            Print("      cRefConv                   = 0x%08lx\n", (ULONG)ReadField(cRefConv));
        }
    }
    return TRUE;
}
#endif // KERNEL


#ifdef KERNEL
/************************************************************************\
* Idde
*
* Dumps DDE tracking layer state and structures.
*
* 6/9/1995 Created SanfordS
\************************************************************************/
BOOL Idde(
    DWORD opts,
    ULONG64 param1)
{
    ULONG64 pshi, psi, cHandleEntries, pheList, h, pPropList, ptr;
    ULONG64 pObj = 0;
    UINT i, iFirstFree;
    DWORD atomDdeTrack, dwOffset;
    DWORD dwHESize = GetTypeSize(SYM(HANDLEENTRY));
    DWORD dwPropSize = GetTypeSize(SYM(PROP));
    BYTE bType;

    moveExpValue(&atomDdeTrack, VAR(atomDDETrack));

    GETSHAREDINFO(pshi);

    GetFieldOffset(SYM(SHAREDINFO), "psi", &dwOffset);
    ReadPointer(pshi + dwOffset, &psi);

    GetFieldOffset(SYM(SHAREDINFO), "aheList", &dwOffset);
    ReadPointer(pshi + dwOffset, &pheList);

    GetFieldValue(psi, SYM(SERVERINFO), "cHandleEntries", cHandleEntries);

    if (param1) {
        /*
         * get object param.
         */
        i = HMIndexFromHandle((ULONG_PTR)param1);
        if (i >= cHandleEntries) {
            GetFieldValue(param1, SYM(HEAD), "h", h);
            i = HMIndexFromHandle(h);
        }
        if (i >= cHandleEntries) {
            Print("0x%08lx is not a valid object.\n", h);
            return FALSE;
        }
        GetFieldOffset(SYM(HANDLEENTRY), "phead", &dwOffset);
        ReadPointer(pheList + i * dwHESize + dwOffset, &pObj);
        /*
         * verify type.
         */
        GetFieldValue(pheList + i * dwHESize, SYM(HANDLEENTRY), "bType", bType);
        switch (bType) {
        case TYPE_WINDOW:
            GetFieldOffset(SYM(WND), "ppropList", &dwOffset);
            ReadPointer(pObj + dwOffset, &pPropList);
            GetFieldValue(pPropList, SYM(PROPLIST), "iFirstFree", iFirstFree);
            for (i = 0; i < iFirstFree; i++) {
                if (i == 0) {
                    Print("Window 0x%08lx conversations:\n", h);
                }
                GetFieldOffset(SYM(PROPLIST), "aprop", &dwOffset);
                ReadPtr(pPropList + dwOffset + i * dwPropSize, &ptr);
                InitTypeRead(ptr, SYM(PROP));
                if (ReadField(atomKey) == (ATOM)MAKEINTATOM(atomDdeTrack)) {
                    Print("  ");
                    dddeconv(ReadField(hData), opts);
                }
            }
            return TRUE;

        case TYPE_DDECONV:
        case TYPE_DDEXACT:
            break;

        default:
            Print("0x%08lx is not a valid window, conversation or transaction object.\n", h);
            return FALSE;
        }
    }

    /*
     * look for all qualifying objects in the object table.
     */

    Print("DDE objects:\n");
    for (i = 0; i < cHandleEntries; i++) {
        InitTypeRead(pheList + i * dwHESize , SYM(HANDLEENTRY));
        if ((BYTE)ReadField(bType) == TYPE_DDECONV && ((pObj == FIXKP(ReadField(phead))) || pObj == 0)) {
            dddeconv(FIXKP(ReadField(phead)), opts);
        }

        if ((BYTE)ReadField(bType) == TYPE_DDEXACT && (pObj == 0 || pObj == FIXKP(ReadField(phead)))) {
            if (!(opts & OFLAG(v))) {
                Print("  XACT:");
            }
            dddexact(FIXKP(ReadField(phead)), opts);
            Print("\n");
        }
    }
    return TRUE;
}
#endif // KERNEL



#ifdef OLD_DEBUGGER
#ifndef KERNEL
/************************************************************************\
* Iddeml
*
* Dumps the DDEML state for this client process.
*
* 6/9/1995 Created SanfordS
\************************************************************************/
BOOL Iddeml(
    DWORD opts,
    LPSTR lpas)
{
    CHANDLEENTRY he, *phe;
    int cHandles, ch, i;
    DWORD Type;
    DWORD_PTR Instance, Object, Pointer;
    CL_INSTANCE_INFO cii, *pcii;
    ATOM ns;
    SERVER_LOOKUP sl;
    LINK_COUNT lc;
    CL_CONV_INFO cci;
    PCL_CONV_INFO pcci;
    CONVLIST cl;
    HWND hwnd, *phwnd;
    XACT_INFO xi;
    DDEMLDATA dd;
    CONV_INFO ci;

    moveExpValue(&cHandles, "user32!cHandlesAllocated");

    Instance = 0;
    Type = 0;
    Object = 0;
    Pointer = 0;
    SAFEWHILE (*lpas) {
        SAFEWHILE (*lpas == ' ')
            lpas++;

        if (*lpas == 'i') {
            lpas++;
            Instance = (DWORD_PTR)EvalExp(lpas);
            SAFEWHILE (*lpas != ' ' && *lpas != 0)
                lpas++;
            continue;
        }
        if (*lpas == 't') {
            lpas++;
            Type = (DWORD)(DWORD_PTR)EvalExp(lpas);
            SAFEWHILE (*lpas != ' ' && *lpas != 0)
                lpas++;
            continue;
        }
        if (*lpas) {
            Object = Pointer = (DWORD_PTR)EvalExp(lpas);
            SAFEWHILE (*lpas != ' ' && *lpas != 0)
                lpas++;
        }
    }

    /*
     * for each instance for this process...
     */

    pcii = GetGlobalPointer("user32!pciiList");
    if (pcii == NULL) {
        Print("No Instances exist.\n");
        return TRUE;
    }
    move(cii, pcii);
    SAFEWHILE (pcii != NULL) {
        pcii = cii.next;
        if (Instance == 0 || (Instance == (DWORD_PTR)cii.hInstClient)) {
            Print("Objects for instance 0x%p:\n", cii.hInstClient);
            ch = cHandles;
            phe = GetGlobalPointer("user32!aHandleEntry");
            SAFEWHILE (ch--) {
                move(he, phe++);
                if (he.handle == 0) {
                    continue;
                }
                if (InstFromHandle(cii.hInstClient) != InstFromHandle(he.handle)) {
                    continue;
                }
                if (Type && TypeFromHandle(he.handle) != Type) {
                    continue;
                }
                if (Object && (he.handle != (HANDLE)Object) &&
                    Pointer && he.dwData != Pointer) {
                    continue;
                }
                Print("  (0x%08lx)->0x%08lx ", he.handle, he.dwData);
                switch (TypeFromHandle(he.handle)) {
                case HTYPE_INSTANCE:
                    Print("Instance\n");
                    if (opts & OFLAG(v)) {
                        Print("    next               = 0x%08lx\n", cii.next);
                        Print("    hInstServer        = 0x%08lx\n", cii.hInstServer);
                        Print("    hInstClient        = 0x%08lx\n", cii.hInstClient);
                        Print("    MonitorFlags       = 0x%08lx\n", cii.MonitorFlags);
                        Print("    hwndMother         = 0x%08lx\n", cii.hwndMother);
                        Print("    hwndEvent          = 0x%08lx\n", cii.hwndEvent);
                        Print("    hwndTimeout        = 0x%08lx\n", cii.hwndTimeout);
                        Print("    afCmd              = 0x%08lx\n", cii.afCmd);
                        Print("    pfnCallback        = 0x%08lx\n", cii.pfnCallback);
                        Print("    LastError          = 0x%08lx\n", cii.LastError);
                        Print("    tid                = 0x%08lx\n", cii.tid);
                        Print("    plaNameService     = 0x%08lx\n", cii.plaNameService);
                        Print("    cNameServiceAlloc  = 0x%08lx\n", cii.cNameServiceAlloc);
                        SAFEWHILE (cii.cNameServiceAlloc--) {
                            move(ns, cii.plaNameService++);
                            Print("      0x%04lx\n", ns);
                        }
                        Print("    aServerLookup      = 0x%08lx\n", cii.aServerLookup);
                        Print("    cServerLookupAlloc = 0x%08lx\n", cii.cServerLookupAlloc);
                        SAFEWHILE (cii.cServerLookupAlloc--) {
                            move(sl, cii.aServerLookup++);
                            Print("      laService  = 0x%04x\n", sl.laService);
                            Print("      laTopic    = 0x%04x\n", sl.laTopic);
                            Print("      hwndServer = 0x%08lx\n", sl.hwndServer);
                            if (cii.cServerLookupAlloc) {
                                Print("      ---\n");
                            }
                        }
                        Print("    ConvStartupState   = 0x%08lx\n", cii.ConvStartupState);
                        Print("    flags              = %s\n",
                                GetFlags(GF_IIF, cii.flags, NULL, TRUE));
                        Print("    cInDDEMLCallback   = 0x%08lx\n", cii.cInDDEMLCallback);
                        Print("    pLinkCount         = 0x%08lx\n", cii.pLinkCount);
                        SAFEWHILE (cii.pLinkCount) {
                            move(lc, cii.pLinkCount);
                            cii.pLinkCount = lc.next;
                            Print("      next    = 0x%08lx\n", lc.next);
                            Print("      laTopic = 0x%04x\n", lc.laTopic);
                            Print("      gaItem  = 0x%04x\n", lc.gaItem);
                            Print("      laItem  = 0x%04x\n", lc.laItem);
                            Print("      wFmt    = 0x%04x\n", lc.wFmt);
                            Print("      Total   = 0x%04x\n", lc.Total);
                            Print("      Count   = 0x%04x\n", lc.Count);
                            if (cii.pLinkCount != NULL) {
                                Print("      ---\n");
                            }
                        }
                    }
                    break;

                case HTYPE_ZOMBIE_CONVERSATION:
                    Print("Zombie Conversation\n");
                    if (opts & OFLAG(v)) {
                        DumpConvInfo((PCONV_INFO)he.dwData);
                    }
                    break;

                case HTYPE_SERVER_CONVERSATION:
                    Print("Server Conversation\n");
                    if (opts & OFLAG(v)) {
                        DumpConvInfo((PCONV_INFO)he.dwData);
                    }
                    break;

                case HTYPE_CLIENT_CONVERSATION:
                    Print("Client Conversation\n");
                    if (opts & OFLAG(v)) {
                        DumpConvInfo((PCONV_INFO)he.dwData);
                    }
                    break;

                case HTYPE_CONVERSATION_LIST:

                    if (IsRemoteSession()) {
                        Print("!ddeml for Conversation List doesn't work on HYDRA systems\n");
                    } else {
                        Print("Conversation List\n");
                        if (opts & OFLAG(v)) {
                            move(cl, (PVOID)he.dwData);
                            Print("    pcl   = 0x%08lx\n", he.dwData);
                            Print("    chwnd = 0x%08lx\n", cl.chwnd);
                            i = 0;
                            phwnd = (HWND *)&((PCONVLIST)he.dwData)->ahwnd;
                            SAFEWHILE (cl.chwnd--) {
                                move(hwnd, phwnd++);
                                Print("    ahwnd[%d] = 0x%08lx\n", i, hwnd);
                                pcci = (PCL_CONV_INFO)GetWindowLongPtr(hwnd, GWLP_PCI);
                                SAFEWHILE (pcci) {
                                    move(cci, pcci);
                                    pcci = (PCL_CONV_INFO)cci.ci.next;
                                    Print("      hConv = 0x%08lx\n", cci.ci.hConv);
                                }
                                i++;
                            }
                        }
                    }
                    break;

                case HTYPE_TRANSACTION:
                    Print("Transaction\n");
                    if (opts & OFLAG(v)) {
                        move(xi, (PVOID)he.dwData);
                        Print("    next         = 0x%08lx\n", xi.next);
                        Print("    pcoi         = 0x%08lx\n", xi.pcoi);
                        move(ci, xi.pcoi);
                        Print("      hConv      = 0x%08lx\n", ci.hConv);
                        Print("    hUser        = 0x%08lx\n", xi.hUser);
                        Print("    hXact        = 0x%08lx\n", xi.hXact);
                        Print("    pfnResponse  = 0x%08lx\n", xi.pfnResponse);
                        Print("    gaItem       = 0x%04x\n",  xi.gaItem);
                        Print("    wFmt         = 0x%04x\n",  xi.wFmt);
                        Print("    wType;       = 0x%04x\n",  xi.wType);
                        Print("    wStatus;     = 0x%04x\n",  xi.wStatus);
                        Print("    flags;       = %s\n",
                                GetFlags(GF_XI, xi.flags, NULL, TRUE));
                        Print("    state;       = 0x%04x\n",  xi.state);
                        Print("    hDDESent     = 0x%08lx\n", xi.hDDESent);
                        Print("    hDDEResult   = 0x%08lx\n", xi.hDDEResult);
                    }
                    break;

                case HTYPE_DATA_HANDLE:
                    Print("Data Handle\n");
                    if (opts & OFLAG(v)) {
                        move(dd, (PVOID)he.dwData);
                        Print("    hDDE     = 0x%08lx\n", dd.hDDE);
                        Print("    flags    = %s\n",
                                GetFlags(GF_HDATA, (WORD)dd.flags, NULL, TRUE));
                    }
                    break;
                }
            }
        }
        if (pcii != NULL) {
            move(cii, pcii);
        }
    }
    return TRUE;
}
#endif // !KERNEL
#endif // OLD_DEBUGGER


#ifdef KERNEL

/*
 * Hook helper routines
 */
VOID IterateHooks(
    ULONG64 phk,
    BOOL fLocalHook,
    BOOL fDumpDllName)
{
    int iHook;
    ULONG64 offPfn;
    ULONG64 pti;
    UINT flags;
    int ihmod;
    ULONG64 patomTable;
    ULONG64 patomSysLoaded;
    ATOM atom;

    patomTable = GetGlobalPointer(VAR(UserAtomTableHandle));
    patomSysLoaded = EvalExp(SYM(aatomSysLoaded));

    SAFEWHILE (phk != 0) {

        GetFieldValue(phk, SYM(tagHOOK), "iHook", iHook);
        GetFieldValue(phk, SYM(tagHOOK), "offPfn", offPfn);
        GetFieldValue(phk, SYM(tagHOOK), "flags", flags);
        GetFieldValue(phk, SYM(tagHOOK), "ihmod", ihmod);
        GetFieldValue(phk, SYM(tagHOOK), "head.pti", pti);

        Print("\t  0x%p iHook %d, offPfn=0x%08p, ihmod=%d\n",
              phk, iHook, offPfn, ihmod);
        if (!fLocalHook) {
            /*
             * Dump the threadinfo of the hook originator.
             */
            Print("\t  ");
            Idt(OFLAG(p), pti);
        }
        Print("\t    flags: %s\n", GetFlags(GF_HOOKFLAGS, flags, NULL, TRUE));

        if (ihmod >= 0 && patomTable != NULL_POINTER) {
            /*
             * Dump the hook DLL name.
             */
            ReadMemory(patomSysLoaded + sizeof(ATOM) * ihmod, &atom, sizeof(ATOM), NULL);
            if (fDumpDllName && atom) {
                if (!DumpAtomTable(patomTable, (RTL_ATOM)atom, 12, NULL)) {
                    Print("%12catom: %04x (unable to get the dll name)\n", ' ', (DWORD)atom);
                }
            }
        }

        GetFieldValue(phk, SYM(tagHOOK), "phkNext", phk);
    }
}

VOID DumpHooks(ULONG64 pDeskInfo, LPSTR psz, int i, BOOL fDumpDllName)
{
    ULONG64 phk = GetArrayElementPtr(pDeskInfo, SYM(tagDESKTOPINFO), "aphkStart", i + 1);
    if (phk) {
        Print("\t %s\n", psz);
        IterateHooks(phk, FALSE, fDumpDllName);
    }
}

VOID DumpLHooks(ULONG64 pti, LPSTR psz, int i, BOOL fDumpDllName)
{
    ULONG64 phk = GetArrayElementPtr(pti, SYM(tagTHREADINFO), "aphkStart", i + 1);
    if (phk) {
        Print("\t %s\n", psz);
        IterateHooks(phk, TRUE, fDumpDllName);
    }
}



/***************************************************************************\
* ddesk           - dumps list of desktops
* ddesk address   - dumps simple statistics for desktop
* ddesk v address - dumps verbose statistics for desktop
* ddesk h address - dumps statistics for desktop plus handle list
*
* Dump handle table statistics.
*
* 02/21/1992 ScottLu    Created.
* 06/09/1995 SanfordS   Made to fit stdexts motif.
* 10/15/2000 Hiroyama   Ported to ia64.
\***************************************************************************/
BOOL Iddesk(
    DWORD opts,
    ULONG64 param1)
{
    try {
        ULONG64 pwinsta = NULL_POINTER; // PWINDOWSTATION
        ULONG64 pdesk;  // PDESKTOP
        ULONG64 pHead;  // OBJECT_HEADER
        ULONG64 pDeskInfo;
        DWORD acHandles[TYPE_CTYPES + 1];
        BOOL abTrack[TYPE_CTYPES + 1];
        ULONG64 phe;    // PHE
        DWORD i;
        WCHAR ach[80];
        BOOL fMatch;
        ULONG offsetPHead;  // to reduce the symbol lookup
        ULONG offsetBType;
        ULONG offsetBFlags;
        BYTE bType;
        BOOL fDumpDllName = opts & OFLAG(d);

        /*
         * If there is no address, list all desktops on all terminals.
         */
        if (param1 == NULL_POINTER) {

            FOREACHWINDOWSTATION(pwinsta)

                GetObjectName(pwinsta, ach, ARRAY_SIZE(ach));
                Print("Windowstation: @ 0x%p %ws\n", pwinsta, ach);
                Print("Other desktops:\n");
                GetFieldValue(pwinsta, SYM(tagWINDOWSTATION), "rpdeskList", pdesk);

                SAFEWHILE (pdesk) {
                    Print(" Desktop at 0x%p\n", pdesk);
                    Iddesk(opts & (OFLAG(v) | OFLAG(h) | OFLAG(d)), pdesk);
                    GetFieldValue(pdesk, SYM(tagDESKTOP), "rpdeskNext", pdesk);
                }

                Print("\n");

            NEXTEACHWINDOWSTATION(pwinsta)

            return TRUE;
        }

        pdesk = param1;

        GetObjectName(pdesk, ach, ARRAY_SIZE(ach));
        Print(" Name: %ws\n", ach);

        pHead = KD_OBJECT_TO_OBJECT_HEADER(pdesk);
        if (pHead == NULL_POINTER) {
            Print("can't get pHeader\n");
            return TRUE;
        }

        /*
         * Dump Header info
         */
        _InitTypeRead(pHead, "nt!_OBJECT_HEADER");
        Print(" # Opens         = %d\n", ReadField(HandleCount));

        /*
         * Dump some key info
         */
        _InitTypeRead(pdesk, SYM(tagDESKTOP));
        Print(" Heap            = %#p\n", ReadField(pheapDesktop));
        Print(" Windowstation   = %#p\n", ReadField(rpwinstaParent));
        Print(" Message pwnd    = %#p\n", ReadField(spwndMessage));
        Print(" Menu pwnd       = %#p\n", ReadField(spwndMenu));
        Print(" System pmenu    = %#p\n", ReadField(spmenuSys));
        Print(" Console thread  = 0x%x\n", ReadField(dwConsoleThreadId));
        Print(" PtiList.Flink   = %#p\n", ReadField(PtiList.Flink));

        /*
         * Dump DESKTOPINFO
         */
        pDeskInfo = ReadField(pDeskInfo);
        _InitTypeRead(pDeskInfo, SYM(tagDESKTOPINFO));
        Print(" Desktop pwnd    = %#p\n", ReadField(spwnd));
        Print("\tfsHooks     = 0x%08lx\n", ReadField(fsHooks));

        DumpHooks(pDeskInfo, "WH_MSGFILTER", WH_MSGFILTER, fDumpDllName);
        DumpHooks(pDeskInfo, "WH_JOURNALRECORD", WH_JOURNALRECORD, fDumpDllName);
        DumpHooks(pDeskInfo, "WH_JOURNALPLAYBACK", WH_JOURNALPLAYBACK, fDumpDllName);
        DumpHooks(pDeskInfo, "WH_KEYBOARD", WH_KEYBOARD, fDumpDllName);
        DumpHooks(pDeskInfo, "WH_GETMESSAGE", WH_GETMESSAGE, fDumpDllName);
        DumpHooks(pDeskInfo, "WH_CALLWNDPROC", WH_CALLWNDPROC, fDumpDllName);
        DumpHooks(pDeskInfo, "WH_CALLWNDPROCRET", WH_CALLWNDPROCRET, fDumpDllName);
        DumpHooks(pDeskInfo, "WH_CBT", WH_CBT, fDumpDllName);
        DumpHooks(pDeskInfo, "WH_SYSMSGFILTER", WH_SYSMSGFILTER, fDumpDllName);
        DumpHooks(pDeskInfo, "WH_MOUSE", WH_MOUSE, fDumpDllName);
        DumpHooks(pDeskInfo, "WH_HARDWARE", WH_HARDWARE, fDumpDllName);
        DumpHooks(pDeskInfo, "WH_DEBUG", WH_DEBUG, fDumpDllName);
        DumpHooks(pDeskInfo, "WH_SHELL", WH_SHELL, fDumpDllName);
        DumpHooks(pDeskInfo, "WH_FOREGROUNDIDLE", WH_FOREGROUNDIDLE, fDumpDllName);
        DumpHooks(pDeskInfo, "WH_KEYBOARD_LL", WH_KEYBOARD_LL, fDumpDllName);
        DumpHooks(pDeskInfo, "WH_MOUSE_LL", WH_MOUSE_LL, fDumpDllName);

        if (opts & OFLAG(h)) {
            /*
             * Find all objects allocated from the desktop.
             */
            for (i = 0; i < ARRAY_SIZE(acHandles); i++) {
                abTrack[i] = FALSE;
                acHandles[i] = 0;
            }
            abTrack[TYPE_WINDOW] = abTrack[TYPE_MENU] =
                    abTrack[TYPE_CALLPROC] =
                    abTrack[TYPE_HOOK] = TRUE;

            if (opts & OFLAG(v)) {
                Print("Handle          Type\n");
                Print("--------------------\n");
            }

            GetFieldOffset(SYM(HANDLEENTRY), "phead", &offsetPHead);
            DEBUGPRINT("offsetPHead=%x\n", offsetPHead);
            GetFieldOffset(SYM(HANDLEENTRY), "bType", &offsetBType);
            DEBUGPRINT("offsetBType=%x\n", offsetBType);
            GetFieldOffset(SYM(HANDLEENTRY), "bFlags", &offsetBFlags);

            FOREACHHANDLEENTRY(phe, i)
                fMatch = FALSE;
                if ((i & 0x3) == 0) {
                    ShowProgress(i >> 2);
                }
                move(bType, phe + offsetBType);

                if (bType >= TYPE_CTYPES) {
                    bType = TYPE_CTYPES; // unknown;
                }

                try {
                    ULONG64 phead;
                    ULONG64 rpdesk = NULL_POINTER;

                    switch (bType) {
                    case TYPE_WINDOW:
                        {
                            static ULONG offset = 0;
                            ReadPointer(phe + offsetPHead, &phead);
                            if (offset == 0) {
                                GetFieldOffset(SYM(WND), "head.rpdesk", &offset);
                                DEBUGPRINT("offset=%x\n", offset);
                            }
                            ReadPointer(phead + offset, &rpdesk);
                            DEBUGPRINT("rpdesk=0x%p @ 0x%p phead=0x%p ", rpdesk, phead + offset, phead);
                        }
                        break;
                    case TYPE_MENU:
                        {
                            static ULONG offset = 0;
                            ReadPointer(phe + offsetPHead, &phead);
                            if (offset == 0) {
                                GetFieldOffset(SYM(tagMENU), "head.rpdesk", &offset);
                            }
                            ReadPointer(phead + offset, &rpdesk);
                        }
                        break;
                    case TYPE_CALLPROC:
                        {
                            static ULONG offset = 0;
                            ReadPointer(phe + offsetPHead, &phead);
                            if (offset == 0) {
                                GetFieldOffset(SYM(CALLPROCDATA), "head.rpdesk", &offset);
                            }
                            ReadPointer(phead + offset, &rpdesk);
                        }
                        break;
                    case TYPE_HOOK:
                        {
                            static ULONG offset = 0;
                            ReadPointer(phe + offsetPHead, &phead);
                            if (offset == 0) {
                                GetFieldOffset(SYM(tagHOOK), "head.rpdesk", &offset);
                            }
                            ReadPointer(phead + offset, &rpdesk);
                        }
                        break;
#if defined(GI_PROCESSOR) && defined(TYPE_RAWINPUT_PROCESSOR)
                    case TYPE_RAWINPUT_PROCESSOR:
                        {
                            static ULONG offset = 0;
                            ReadPointer(phe + offsetPHead, &phead);
                            if (offset == 0) {
                                GetFieldOffset(SYM(tagRAWINPUT_PROCESSOR), "head.rpdesk", &offset);
                            }
                            ReadPointer(phead + offset, &rpdesk);
                        }
                        break;
#endif
                    default:
                        break;
                    }
                    if (rpdesk == pdesk) {
                        fMatch = TRUE;
                        if (bType == TYPE_WINDOW) {
                            DEBUGPRINT("matched\n");
                        }
                    } else if (bType == TYPE_WINDOW) {
                        DEBUGPRINT("unmatched\n");
                    }
                } except (CONTINUE) {
                    Print("Exception!\n");
                }

                if (!fMatch) {
                    continue;
                }

                acHandles[bType]++;

                if (opts & OFLAG(v)) {
                    BYTE bFlags;
                    move(bFlags, phe + offsetBFlags);
                    Print("\r0x%08lx %c    %s\n",
                            i,
                            (bFlags & HANDLEF_DESTROY) ? '*' : ' ',
                            aszTypeNames[bType]);
                }
            NEXTEACHHANDLEENTRY()

            Print("\r");

            if (!(opts & OFLAG(v))) {
                Print("  \n");
                Print("Count           Type\n");
                Print("--------------------\n");
                for (i = 0; i < ARRAY_SIZE(acHandles); i++) {
                    if (abTrack[i])
                        Print("0x%08lx      %s\n", acHandles[i], aszTypeNames[i]);
                }
            }
        }
    } except (CONTINUE) {
        Print("AV!\n");
    }
    Print("   \n");
    return TRUE;
}
#endif // KERNEL

BOOL IsNumChar(int c, int base)
{
    return ('0' <= c && c <= '9') ||
           (base == 16 && (('a' <= c && c <= 'f') || ('A' <= c && c <= 'F')));
}

NTSTATUS
GetInteger(LPSTR psz, int base, int * pi, LPSTR * ppsz)
{
    NTSTATUS Status = STATUS_INVALID_PARAMETER;

    for (;;) {
        if (IsNumChar(*psz, base)) {
            Status = RtlCharToInteger(psz, base, pi);
            if (ppsz && NT_SUCCESS(Status)) {
                while (IsNumChar(*psz++, base))
                    /* do nothing */;

                *ppsz = psz;
            }

            break;
        }

        if (*psz != ' ' && *psz != '\t') {
            break;
        }

        psz++;
    }

    return Status;
}


BOOL Idf(DWORD opts, LPSTR pszName)
{
    static char *szLevels[8] = {
        "<none>",
        "Errors",
        "Warnings",
        "Errors and Warnings",
        "Verbose",
        "Errors and Verbose",
        "Warnings and Verbose",
        "Errors, Warnings, and Verbose"
    };

    NTSTATUS    Status;
    ULONG       ulFlags;
    ULONG64     psi;
    WORD        wRipFlags;
    DWORD       wPID;
    ULONG       offsetRIPPID;
    ULONG       offsetRIPFlags;

    if (opts & OFLAG(x)) {
        /*
         * !df -x foo
         * This is an undocumented way to start a remote CMD session named
         * "foo" on the machine that the debugger is running on.
         * Sometimes useful to assist in debugging.
         * Sometimes useful when trying to do dev work from home: if you don't
         * already have a remote cmd.exe session to connect to, you probably
         * have a remote debug session.  You can use this debug extension to
         * start a remote cmd session.
         */
        BOOL bRet;
        char ach[80];
        PROCESS_INFORMATION ProcessInfo;
        STARTUPINFOA StartupInfoA;

        if (pszName[0] == '\0') {
            Print("must provide a name.  eg; \"!df -x fred\"\n");
            return TRUE;
        }
        sprintf(ach, "remote.exe /s cmd.exe %s", pszName);

        RtlZeroMemory(&StartupInfoA, sizeof(STARTUPINFOA));
        StartupInfoA.cb = sizeof(STARTUPINFOA);
        StartupInfoA.lpTitle = pszName;
        StartupInfoA.dwFlags = STARTF_USESHOWWINDOW;
        StartupInfoA.wShowWindow = SW_SHOWMINIMIZED; // SW_HIDE is *too* sneaky
        bRet = CreateProcessA(
                NULL,            // get executable name from command line
                ach,             // CommandLine
                NULL,            // Process Attr's
                NULL,            // Thread Attr's
                FALSE,           // Inherit Handle
                CREATE_NEW_CONSOLE, // Creation Flags
                NULL,            // Environ
                NULL,            // Cur Dir
                &StartupInfoA,   // StartupInfo
                &ProcessInfo );  // ProcessInfo

        if (bRet) {
            Print("Successfully created a minimized remote cmd process\n");
            Print("use \"remote /c <machine> %s\" to connect\n", pszName);
            Print("use \"exit\" to kill the remote cmd process\n");
        }

        NtClose(ProcessInfo.hProcess);
        NtClose(ProcessInfo.hThread);
        return TRUE;
    }

    psi = GetGlobalPointer(VAR(gpsi));
    GetFieldOffset(SYM(SERVERINFO), "wRIPPID", &offsetRIPPID);
    GetFieldOffset(SYM(SERVERINFO), "wRIPFlags", &offsetRIPFlags);

    if (opts & OFLAG(p)) {

        Status = GetInteger(pszName, 16, &wPID, NULL);

#ifdef KERNEL

        (lpExtensionApis->lpWriteProcessMemoryRoutine)(
                psi + offsetRIPPID,
                (PVOID)&wPID,
                sizeof(wPID),
                NULL);
#else
        if (!IsRemoteSession()) {
            PrivateSetRipFlags(-1, (DWORD)wPID);
        } else {
            Print("!df -p doesn't work on HYDRA systems\n");
        }
#endif

        move(wPID, psi + offsetRIPPID);
        Print("Set Rip process to %ld (0x%lX)\n", (DWORD)wPID, (DWORD)wPID);

        return TRUE;
    }



    move(wRipFlags, psi + offsetRIPFlags);
    move(wPID, psi + offsetRIPPID);

    Status = GetInteger(pszName, 16, &ulFlags, NULL);


    if (NT_SUCCESS(Status) && !(ulFlags & ~RIPF_VALIDUSERFLAGS)) {
#ifdef KERNEL
        wRipFlags = (WORD)((wRipFlags & ~RIPF_VALIDUSERFLAGS) | ulFlags);


        (lpExtensionApis->lpWriteProcessMemoryRoutine)(
                psi + offsetRIPFlags,
                (PVOID)&wRipFlags,
                sizeof(wRipFlags),
                NULL);
#else
        PrivateSetRipFlags(ulFlags, -1);
#endif

        move(wRipFlags, psi + offsetRIPFlags);
    }

    Print("Flags = %.3x\n", wRipFlags & RIPF_VALIDUSERFLAGS);
    Print("  Print Process/Component %sabled\n", (wRipFlags & RIPF_HIDEPID) ? "dis" : "en");
    Print("  Print File/Line %sabled\n", (wRipFlags & RIPF_PRINTFILELINE) ? "en" : "dis");
    Print("  Print on %s\n",  szLevels[(wRipFlags & RIPF_PRINT_MASK)  >> RIPF_PRINT_SHIFT]);
    Print("  Prompt on %s\n", szLevels[(wRipFlags & RIPF_PROMPT_MASK) >> RIPF_PROMPT_SHIFT]);

    if (wPID == 0) {
        Print("  All process RIPs are shown\n");
    } else {
        Print("  RIPs shown for process %ld (0x%lX)\n", (DWORD)wPID, (DWORD)wPID);
    }

    return TRUE;
}

#ifdef KERNEL
/***************************************************************************\
* dhot - dump hotkeys
*
* dhot       - dumps all hotkeys
*
* 10/21/94 IanJa        Created.
* 6/9/1995 SanfordS     made to fit stdexts motif
\***************************************************************************/
BOOL Idhot(
    DWORD opts,
    ULONG64 phk)
{
    WORD fsModifiers;
    UINT vk;
    ULONG64 pwnd;
    ULONG64 pti;
    int id;
    BOOL bRecursive;

    UNREFERENCED_PARAMETER(opts);

    if (!phk) {
        bRecursive = TRUE;
        phk = GetGlobalPointer(VAR(gphkFirst));
    } else if (opts & OFLAG(r)) {
        bRecursive = TRUE;
    } else {
        bRecursive = FALSE;
    }

    SAFEWHILE (phk != 0) {

        Print("photkey @ 0x%p\n", phk);
        GetFieldValue(phk, SYM(HOTKEY), "vk", vk);
        GetFieldValue(phk, SYM(HOTKEY), "fsModifiers", fsModifiers);

        Print("  fsModifiers %lx, vk %x - ",
            fsModifiers, vk);

        Print("%s%s%s%sVK:%x %s",
            fsModifiers & MOD_SHIFT   ? "Shift + " : "",
            fsModifiers & MOD_ALT     ? "Alt + "   : "",
            fsModifiers & MOD_CONTROL ? "Ctrl + "  : "",
            fsModifiers & MOD_WIN     ? "Win + "   : "",
            vk, GetVKeyName(vk));

        GetFieldValue(phk, SYM(HOTKEY), "id", id);
        GetFieldValue(phk, SYM(HOTKEY), "pti", pti);
        GetFieldValue(phk, SYM(HOTKEY), "spwnd", pwnd);

        Print("\n  id   %x\n", id);
        Print("  pti  %lx\n", pti);
        Print("  pwnd %lx = ", pwnd);
        if (pwnd == (ULONG64)PWND_FOCUS) {
            Print("PWND_FOCUS\n");
        } else if (pwnd == (ULONG64)PWND_INPUTOWNER) {
            Print("PWND_INPUTOWNER\n");
        } else {
            CHAR ach[80];
            /*
             * Print title string.
             */
            DebugGetWindowTextA(pwnd, ach, ARRAY_SIZE(ach));
            Print("\"%s\"\n", ach);
        }
        Print("\n");

        GetFieldValue(phk, SYM(HOTKEY), "phkNext", phk);

        if (!bRecursive) {
            break;
        }
    }

    return TRUE;
}
#endif // KERNEL

#ifdef KERNEL
/***************************************************************************\
* dhk - dump hooks
*
* dhk           - dumps local hooks on the foreground thread
* dhk g         - dumps global hooks
* dhk address   - dumps local hooks on THREADINFO at address
* dhk g address - dumps global hooks and local hooks on THREADINFO at address
* dhk *         - dumps local hooks for all threads
* dhk g *       - dumps global hooks and local hooks for all threads
*
* 10/21/94 IanJa        Created.
* 6/9/1995 SanfordS     made to fit stdexts motif
\***************************************************************************/

ULONG dhkCallback(ULONG64 pti, PVOID pData)
{
    UNREFERENCED_PARAMETER(pData);

    Idhk(OFLAG(r), pti);

    return FALSE;
}

BOOL Idhk(
    DWORD opts,
    ULONG64 param1)
{
    DWORD dwFlags;
    ULONG64 pti;
    ULONG64 pq = NULL_POINTER;
    BOOL fDumpDllName = opts & OFLAG(d);
    static ULONG64 gptiHkForeground;


#define DHKF_GLOBAL_HOOKS   1
#define DHKF_PTI_GIVEN      2

    dwFlags = 0;

    pti = NULL_POINTER;
    if (opts & OFLAG(g)) { // global hooks
        dwFlags |= DHKF_GLOBAL_HOOKS;
    }

    if ((opts & OFLAG(r)) == 0) {   // -r cannot be specified from the command line
        // first time sets gptiHkForeground
        pq = GetGlobalPointer(VAR(gpqForeground));
        if (pq) {
            GetFieldValue(pq, SYM(tagQ), "ptiKeyboard", gptiHkForeground);
        } else {
            // Happens during winlogon
            gptiHkForeground = NULL_POINTER;
        }
    }

    if (param1 == 0) {  // n.b. call from dhkCallback should always set param1
        if (opts & OFLAG(c)) {
            // !dhk -c: Use the current thread.
            pti = GetGlobalPointer(VAR(gptiCurrent));
        } else if (pq == NULL_POINTER) {
            // Happens during winlogon
            Print("No foreground queue!\n");
            return TRUE;
        } else {
            pti = gptiHkForeground;
        }
    } else {
        dwFlags |= DHKF_PTI_GIVEN;
        pti = param1;
    }

    if ((dwFlags & DHKF_PTI_GIVEN || !(dwFlags & DHKF_GLOBAL_HOOKS)) && (opts & OFLAG(a)) == 0) {
        DWORD fsHooks;

        GetFieldValue(pti, SYM(tagTHREADINFO), "fsHooks", fsHooks);
        if (fsHooks || (opts & OFLAG(r)) == 0) {
            Print("Local hooks on PTHREADINFO @ 0x%p%s:\n", pti,
                  pti == gptiHkForeground ? " (foreground thread)" : "");
            Idt(OFLAG(p), pti);
            DumpLHooks(pti, "WH_MSGFILTER", WH_MSGFILTER, fDumpDllName);
            DumpLHooks(pti, "WH_JOURNALRECORD", WH_JOURNALRECORD, fDumpDllName);
            DumpLHooks(pti, "WH_JOURNALPLAYBACK", WH_JOURNALPLAYBACK, fDumpDllName);
            DumpLHooks(pti, "WH_KEYBOARD", WH_KEYBOARD, fDumpDllName);
            DumpLHooks(pti, "WH_GETMESSAGE", WH_GETMESSAGE, fDumpDllName);
            DumpLHooks(pti, "WH_CALLWNDPROC", WH_CALLWNDPROC, fDumpDllName);
            DumpLHooks(pti, "WH_CALLWNDPROCRET", WH_CALLWNDPROCRET, fDumpDllName);
            DumpLHooks(pti, "WH_CBT", WH_CBT, fDumpDllName);
            DumpLHooks(pti, "WH_SYSMSGFILTER", WH_SYSMSGFILTER, fDumpDllName);
            DumpLHooks(pti, "WH_MOUSE", WH_MOUSE, fDumpDllName);
            DumpLHooks(pti, "WH_HARDWARE", WH_HARDWARE, fDumpDllName);
            DumpLHooks(pti, "WH_DEBUG", WH_DEBUG, fDumpDllName);
            DumpLHooks(pti, "WH_SHELL", WH_SHELL, fDumpDllName);
            DumpLHooks(pti, "WH_FOREGROUNDIDLE", WH_FOREGROUNDIDLE, fDumpDllName);
            DumpLHooks(pti, "WH_KEYBOARD_LL", WH_KEYBOARD_LL, fDumpDllName);
            DumpLHooks(pti, "WH_MOUSE_LL", WH_MOUSE_LL, fDumpDllName);
        }
    }

    if (dwFlags & DHKF_GLOBAL_HOOKS) {
        ULONG64 pDeskInfo;
        ULONG64 rpdesk;
        DWORD fsHooks;

        GetFieldValue(pti, SYM(tagTHREADINFO), "pDeskInfo", pDeskInfo);
        GetFieldValue(pti, SYM(tagTHREADINFO), "rpdesk", rpdesk);
        GetFieldValue(pDeskInfo, SYM(DESKTOPINFO), "fsHooks", fsHooks);

        Print("Global hooks for Desktop @ 0x%p:\n", rpdesk);
        Print("\tfsHooks            0x%08lx\n", fsHooks);

        DumpHooks(pDeskInfo, "WH_MSGFILTER", WH_MSGFILTER, fDumpDllName);
        DumpHooks(pDeskInfo, "WH_JOURNALRECORD", WH_JOURNALRECORD, fDumpDllName);
        DumpHooks(pDeskInfo, "WH_JOURNALPLAYBACK", WH_JOURNALPLAYBACK, fDumpDllName);
        DumpHooks(pDeskInfo, "WH_KEYBOARD", WH_KEYBOARD, fDumpDllName);
        DumpHooks(pDeskInfo, "WH_GETMESSAGE", WH_GETMESSAGE, fDumpDllName);
        DumpHooks(pDeskInfo, "WH_CALLWNDPROC", WH_CALLWNDPROC, fDumpDllName);
        DumpHooks(pDeskInfo, "WH_CALLWNDPROCRET", WH_CALLWNDPROCRET, fDumpDllName);
        DumpHooks(pDeskInfo, "WH_CBT", WH_CBT, fDumpDllName);
        DumpHooks(pDeskInfo, "WH_SYSMSGFILTER", WH_SYSMSGFILTER, fDumpDllName);
        DumpHooks(pDeskInfo, "WH_MOUSE", WH_MOUSE, fDumpDllName);
        DumpHooks(pDeskInfo, "WH_HARDWARE", WH_HARDWARE, fDumpDllName);
        DumpHooks(pDeskInfo, "WH_DEBUG", WH_DEBUG, fDumpDllName);
        DumpHooks(pDeskInfo, "WH_SHELL", WH_SHELL, fDumpDllName);
        DumpHooks(pDeskInfo, "WH_FOREGROUNDIDLE", WH_FOREGROUNDIDLE, fDumpDllName);
        DumpHooks(pDeskInfo, "WH_KEYBOARD_LL", WH_KEYBOARD_LL, fDumpDllName);
        DumpHooks(pDeskInfo, "WH_MOUSE_LL", WH_MOUSE_LL, fDumpDllName);
    }

    if (opts & OFLAG(a)) {
        ForEachPti(dhkCallback, NULL);
    }

    return TRUE;
}
#endif // KERNEL

#if DEBUGTAGS || DBG
BOOL Itag(DWORD opts, LPSTR pszName)
{
    NTSTATUS    Status;
    ULONG64     psi, pdbgtag;
    DWORD       dwAchNameOffset, dwAchDescOffset;
    char        achName[DBGTAG_NAMELENGTH];
    char        achDesc[DBGTAG_DESCRIPTIONLENGTH];
    int         tag = -1;
    DWORD       dwDBGTAGFlags, dwDBGTAGFlagsNew, dwOffset;
    DWORD       dwSize;
    int         i, iStart, iEnd;
    char        szT[100];

    UNREFERENCED_PARAMETER(opts);

    GetFieldOffset(SYM(SERVERINFO), "adwDBGTAGFlags", &dwOffset);

    /*
     * Get the tag index.
     */
    psi = GetGlobalPointer(VAR(gpsi));
    if (!psi) {
        Print("Couldn't get win32k!gpsi; bad symbols?\n");
        return TRUE;
    }

    Status = GetInteger(pszName, 10, &tag, &pszName);

    if (*pszName != '\0' && !NT_SUCCESS(Status)) {
        Print("ERROR: Dwayne, you must refer to tags by their number, not their name. How long have you been here?\n\n");
        return FALSE;
    }

    if (!NT_SUCCESS(Status) || tag < 0 || DBGTAG_Max <= tag) {
        tag = -1;
    } else {
        /*
         * Get the flag value.
         */
        Status = GetInteger(pszName, 16, &dwDBGTAGFlagsNew, NULL);
        if (NT_SUCCESS(Status) && !(dwDBGTAGFlagsNew & ~DBGTAG_VALIDUSERFLAGS)) {

            /*
             * Set the flag value.
             */
#ifdef KERNEL
            ReadMemory(psi + dwOffset + tag * sizeof(DWORD), &dwDBGTAGFlags, sizeof(DWORD), NULL);
            COPY_FLAG(dwDBGTAGFlags, dwDBGTAGFlagsNew, DBGTAG_VALIDUSERFLAGS);
            WriteMemory((psi + dwOffset + tag * sizeof(DWORD)), &dwDBGTAGFlags, sizeof(dwDBGTAGFlags), NULL);
#else
            if (!IsRemoteSession()) {
                PrivateSetDbgTag(tag, dwDBGTAGFlagsNew);
            } else {
                Print("!tag doesn't work on HYDRA systems\n");
            }
#endif

        }
    }

    /*
     * Print the header.
     */
    Print(  "%-5s%-7s%-*s%-*s\n",
            "Tag",
            "Flags",
            DBGTAG_NAMELENGTH,
            "Name",
            DBGTAG_DESCRIPTIONLENGTH,
            "Description");

    for (i = 0; i < 12 + DBGTAG_NAMELENGTH + DBGTAG_DESCRIPTIONLENGTH; i++) {
        szT[i] = '-';
    }
    szT[i++] = '\n';
    szT[i] = 0;
    Print(szT);

    if (tag != -1) {
        iStart = iEnd = tag;
    } else {
        iStart = 0;
        iEnd = DBGTAG_Max - 1;
    }

    psi += dwOffset;
    pdbgtag = EvalExp(VAR(gadbgtag));
    if (!pdbgtag) {
        strcpy(achName, "(Not available)");
        strcpy(achDesc, "(Not available)");
    }

    GetFieldOffset(SYM(DBGTAG), "achName", &dwAchNameOffset);
    GetFieldOffset(SYM(DBGTAG), "achDescription", &dwAchDescOffset);
    dwSize = GetTypeSize(SYM(DBGTAG));

    for (i = iStart; i <= iEnd; i++) {
        ReadMemory(psi + i * sizeof(DWORD), &dwDBGTAGFlags, sizeof(DWORD), NULL);
        if (pdbgtag) {
            if (!ReadMemory(pdbgtag + dwAchNameOffset + i * dwSize, achName, DBGTAG_NAMELENGTH, NULL)) {
                strcpy(achName, "(Not available)");
            }
            if (!ReadMemory(pdbgtag + dwAchDescOffset + i * dwSize, achDesc, DBGTAG_DESCRIPTIONLENGTH, NULL)) {
                strcpy(achDesc, "(Not available)");
            }
        }

        Print(  "%-5d%-7d%-*s%-*s\n",
                i,
                dwDBGTAGFlags & DBGTAG_VALIDUSERFLAGS,
                DBGTAG_NAMELENGTH,
                achName,
                DBGTAG_DESCRIPTIONLENGTH,
                achDesc);
    }

    return TRUE;
}

#endif // if DEBUGTAGS

/************************************************************************\
* Idhe
*
* Dump Handle Entry.
*
* 6/9/1995 Created SanfordS
\************************************************************************/
BOOL Idhe(
    DWORD opts,
    ULONG64 param1,
    ULONG64 param2)
{
                            /* 123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 */
    static char szHeader [] = "Phe         Handle      phead       pOwner      cLockObj   Type           Flags\n";
    static char szFormat [] = "%p    %p    %p    %p     %7x   %-15s %#4lx\n";
    int i;
    UINT uHandleCount = 0;
    BYTE bType, bFlags;
    ULONG64 dw, phe, pheT, pOwner, pHead, h;
    DWORD cLockObj;
    WORD wUniq;
#ifdef KERNEL
    ULONG64 pahti = 0, ppi;
    ULONG dwHtiSize = GetTypeSize(SYM(HANDLETYPEINFO));
    BOOL bObjectCreateFlags;
#endif // KERNEL

    /*
     * If only the owner was provided, copy it to param2 so it's always in the
     * same place.
     */
    if (!(opts & OFLAG(t)) && (opts & OFLAG(o))) {
        param2 = param1;
    }

    /*
     * If not a recursive call, print what we're dumping.
     */
    if (!(opts & OFLAG(r)) && (opts & (OFLAG(t) | OFLAG(o) | OFLAG(p)))) {
        Print("Dumping handles");
        if (opts & OFLAG(t)) {
            if ((UINT_PTR)param1 >= TYPE_CTYPES) {
                Print("\nInvalid Type: %#lx\n", param1);
                return FALSE;
            }
            Print(" of type %d (%s)", (ULONG)param1, aszTypeNames[(UINT_PTR)param1]);
        }
        if (opts & OFLAG(o)) {
            Print(" owned by %p", param2);
        }
        if (opts & OFLAG(p)) {
            Print(" or any thread on this process");
        }
        Print("\n");
    }

#ifdef KERNEL
    /*
     * If dumping handles for any thread in the process, we need the type flags.
     */
    if (opts & OFLAG(p)) {
        pahti = EvalExp(VAR(gahti));
        if (!pahti) {
            Print("Couldn't get win32k!gahti\n");
            return TRUE;
        }
    }
#endif // KERNEL

    /*
     * If a handle/phe was provided, just dump it.
     */
    if (!(opts & ~OFLAG(r)) && param1 != 0) {
        dw = HorPtoP(param1, -2);
        if (dw == 0) {
            Print("0x%p is not a valid object or handle.\n", param1);
            return FALSE;
        }
    } else {
        /*
         * Walk the handle table
         */
        Print(szHeader);
        FOREACHHANDLEENTRY(phe, i)
            /* Skip free handles */
            GetFieldValue(phe, SYM(HANDLEENTRY), "bType", bType);
            if (bType == TYPE_FREE) {
                continue;
            }

            /* Type check */
            if ((opts & OFLAG(t)) && bType != (BYTE)param1) {
                continue;
            }

            /* thread check */
            GetFieldValue(phe, SYM(HANDLEENTRY), "pOwner", pOwner);
            if ((opts & OFLAG(o)) && FIXKP(pOwner) != param2) {
                /* check for thread owned objects owned by the requested process */
                if (opts & OFLAG(p)) {
                    #ifndef KERNEL
                        continue;
                    #else

                        GetFieldValue(pahti + bType * dwHtiSize, SYM(HANDLETYPEINFO), "bObjectCreateFlags", bObjectCreateFlags);
                        if (bObjectCreateFlags & OCF_PROCESSOWNED) {
                            continue;
                        }
                        if (!(bObjectCreateFlags & OCF_THREADOWNED)) {
                            continue;
                        }
                        GetFieldValue(pOwner, SYM(THREADINFO), "ppi", ppi);
                        if (ppi != param2) {
                            continue;
                        }
                    #endif // !KERNEL
                } else {
                    continue;
                }
            }

            GetFieldValue(phe, SYM(HANDLEENTRY), "phead", pHead);
            if (pHead) {
                Idhe(OFLAG(r), pHead, 0);
                uHandleCount++;
            }
        NEXTEACHHANDLEENTRY()
        Print("%d handle(s)\n", uHandleCount);
        return TRUE;
    }

    if (!getHEfromP(&pheT, dw)) {
        Print("%p is not a USER handle manager object.\n", param1);
        return FALSE;
    }

#ifdef KERNEL
    /*
     * If printing only one entry, print info about the owner
     */
    if (!(opts & OFLAG(r))) {
        GetFieldValue(pheT, SYM(HANDLEENTRY), "pOwner", pOwner);
        if (pOwner != 0) {
            if (!(opts & OFLAG(p))) {
                pahti = EvalExp(VAR(gahti));
            }
            GetFieldValue(pheT, SYM(HANDLEENTRY), "bType", bType);
            GetFieldValue(pahti + bType * dwHtiSize, SYM(HANDLETYPEINFO), "bObjectCreateFlags", bObjectCreateFlags);
            if (bObjectCreateFlags & OCF_PROCESSOWNED) {
                Idp(OFLAG(p), pOwner);
            } else if (bObjectCreateFlags & OCF_THREADOWNED) {
                Idt(OFLAG(p), pOwner);
            }
        }
    }
#endif // KERNEL

    GetFieldValue(dw, SYM(HEAD), "cLockObj", cLockObj);
    GetFieldValue(dw, SYM(HEAD), "h", h);
    GetFieldValue(pheT, SYM(HANDLEENTRY), "phead", pHead);
    GetFieldValue(pheT, SYM(HANDLEENTRY), "pOwner", pOwner);
    GetFieldValue(pheT, SYM(HANDLEENTRY), "bType", bType);
    GetFieldValue(pheT, SYM(HANDLEENTRY), "bFlags", bFlags);
    GetFieldValue(pheT, SYM(HANDLEENTRY), "wUniq", wUniq);

    /*
     * If only dumping one, use !dso like format. Otherwise, print a table.
     */
    if (!(opts & OFLAG(r))) {
        Print("0x%08x handle @ 0x%p\n", (DWORD)h, pheT);
        Print("%4c0x%04x %-16s 0x%p %s\n",
              ' ', (DWORD)(WORD)wUniq, "wUniq", pOwner, "pOwner");
        Print("0x%p %-16s 0x%08x cLockObj\n",
              pHead, "pHead", (DWORD)cLockObj);
        Print(DWSTR1 " - %s\n", bType, "bType", aszTypeNames[bType]);
        Print(DWSTR1 " - %s\n", bFlags,"bFlags",  GetFlags(GF_HE, bFlags, NULL, TRUE));
    } else {
        Print(szFormat,
              pheT, h, FIXKP(pHead), FIXKP(pOwner),
              cLockObj, aszTypeNames[(DWORD)bType], (DWORD)bFlags);
    }

    return TRUE;
}

#ifdef KERNEL
/***************************************************************************\
* dhs           - dumps simple statistics for whole table
* dhs t id      - dumps simple statistics for objects created by thread id
* dhs p id      - dumps simple statistics for objects created by process id
* dhs v         - dumps verbose statistics for whole table
* dhs v t id    - dumps verbose statistics for objects created by thread id.
* dhs v p id    - dumps verbose statistics for objects created by process id.
* dhs y type    - just dumps that type
*
* Dump handle table statistics.
*
* 02-21-92 ScottLu      Created.
* 6/9/1995 SanfordS     made to fit stdexts motif
\***************************************************************************/
BOOL Idhs(
    DWORD opts,
    ULONG64 param1)
{
    ULONG64 phe, pOwner, pEprocess, pEThread, pahti;
    DWORD dwT, acHandles[TYPE_CTYPES], dwSize, handle;
    DWORD cHandlesUsed, cHandlesSkipped, idProcess, i;
    BYTE bType, bObjectCreateFlags, bFlags;
    int Type, cLocalHandleEntries = 0;

    pahti = EvalExp(VAR(gahti));
    if (!pahti) {
        return TRUE;
    }
    dwSize = GetTypeSize(SYM(HANDLETYPEINFO));

    /*
     * Evaluate the argument string and get the address of the object to
     * dump. Take either a handle or a pointer to the object.
     */
    if (opts & OFLAG(y)) {
        Type = (ULONG)(ULONG_PTR)param1;
    } else if (opts & (OFLAG(t) | OFLAG(p))) {
        dwT = (ULONG)(ULONG_PTR)param1;
    }

    cHandlesSkipped = 0;
    cHandlesUsed = 0;
    for (i = 0; i < TYPE_CTYPES; i++) {
        acHandles[i] = 0;
    }

    if (param1) {
        if (opts & OFLAG(p)) {
            Print("Handle dump for client process id 0x%lx only:\n\n", dwT);
        } else if (opts & OFLAG(t)) {
            Print("Handle dump for client thread id 0x%lx only:\n\n", dwT);
        } else if (opts & OFLAG(y)) {
            Print("Handle dump for %s objects:\n\n", aszTypeNames[Type]);
        }
    } else {
        Print("Handle dump for all processes and threads:\n\n");
    }

    if (opts & OFLAG(v)) {
        Print("Handle          Type\n");
        Print("--------------------\n");
    }

    FOREACHHANDLEENTRY(phe, i)
        ShowProgress(i);
        ++cLocalHandleEntries;
        GetFieldValue(phe, SYM(HANDLEENTRY), "bFlags", bFlags);
        GetFieldValue(phe, SYM(HANDLEENTRY), "bType", bType);
        if ((opts & OFLAG(y)) && bType != Type) {
            continue;
        }

        GetFieldValue(phe, SYM(HANDLEENTRY), "pOwner", pOwner);
        GetFieldValue(pahti + bType * dwSize, SYM(HANDLETYPEINFO), "bObjectCreateFlags", bObjectCreateFlags);
        if (opts & OFLAG(p)) {
            if (bObjectCreateFlags & OCF_PROCESSOWNED) {
                if (pOwner == 0) {
                    continue;
                }

                GetFieldValue(pOwner, SYM(PROCESSINFO), "Process", pEprocess);
                GetFieldValue(pEprocess, "nt!EPROCESS", "UniqueProcessId", idProcess);
                if (idProcess == 0) {
                    // Print("Unable to read _EPROCESS at %p\n", pEprocess);
                    continue;
                }

                if (idProcess != dwT) {
                    continue;
                }
            } else {
                continue;
            }
        } else if (opts & OFLAG(t)) {
            if (!(bObjectCreateFlags & OCF_PROCESSOWNED)) {
                if (pOwner == 0) {
                    continue;
                }

                GetFieldValue(pOwner, SYM(THREADINFO), "pEThread", pEThread);
                GetFieldValue(pEThread, "nt!ETHREAD", "Cid.UniqueThread", handle);
                if (handle != dwT) {
                    continue;
                }
            } else {
                continue;
            }
        }

        acHandles[bType]++;

        if (bType == TYPE_FREE) {
            continue;
        }

        cHandlesUsed++;

        if (opts & OFLAG(v)) {
            Print("0x%08lx %c    %s\n",
                    i,
                    (bFlags & HANDLEF_DESTROY) ? '*' : ' ',
                    aszTypeNames[bType]);
        }

    NEXTEACHHANDLEENTRY()

    Print("\r");

    if (!(opts & OFLAG(v))) {
        Print("Count           Type\n");
        Print("--------------------\n");
        for (i = 0; i < TYPE_CTYPES; i++) {
            if ((opts & OFLAG(y)) && Type != (int)i) {
                continue;
            }
            Print("0x%08lx      (%d) %s\n", acHandles[i], i, aszTypeNames[i]);
        }
    }

    if (!(opts & OFLAG(y))) {
        Print("\nTotal Accessible Handles: 0x%lx\n", cLocalHandleEntries);
        Print("Used Accessible Handles: 0x%lx\n", cHandlesUsed);
        Print("Free Accessible Handles: 0x%lx\n", cLocalHandleEntries - cHandlesUsed);
    }

    return TRUE;
}
#endif // KERNEL

#ifdef KERNEL
/***************************************************************************\
* di - dumps interesting globals in USER related to input.
*
* 11-14-91 DavidPe      Created.
* 6/9/1995 SanfordS     made to fit stdexts motif
\***************************************************************************/
BOOL Idi(
    VOID)
{
    char            ach[80];

    PRTGPTR2(gptiCurrent, grpdeskRitInput);
    PRTGPTR2(gpqForeground, gpqForegroundPrev);
    PRTGPTR2(gptiForeground, gpqCursor);
    PRTGPTR1(gptiBlockInput);

    {
        DWORD           dw;
        ULONG64         ptr1;

        dw = DOWNCAST(DWORD, GetGlobalMember(VAR(glinp), SYM(LASTINPUT), "timeLastInputMessage"));
        ptr1 = GetGlobalMember(VAR(glinp), SYM(LASTINPUT), "ptiLastWoken");
        PRTVDW2(glinp.timeLastInputMessage, dw, glinp.ptiLastWoken, ptr1);
        PRTGDW1(gwMouseOwnerButton);
    }

    {
        POINT ptCursor;
        ULONG64 psi = GetGlobalPointer(VAR(gpsi));

        GetFieldValue(psi, SYM(tagSERVERINFO), "ptCursor", ptCursor);
        PRTVPT(gpsi->ptCursor, ptCursor);
    }

    {
        ULONG64 pdesk = GetGlobalPointer(VAR(grpdeskRitInput));
        if (pdesk != NULL_POINTER) {
            ULONG64 pDeskInfo;
            ULONG64 spwnd;

            GetFieldValue(pdesk, SYM(tagDESKTOP), "pDeskInfo", pDeskInfo);
            GetFieldValue(pDeskInfo, SYM(tagDESKTOPINFO), "spwnd", spwnd);
            PRTWND(Desktop window, spwnd);
        }
    }

    {
        ULONG64 pq = GetGlobalPointer(VAR(gpqForeground));

        if (pq) {
            ULONG64 spwndFocus, spwndActive;

            GetFieldValue(pq, SYM(tagQ), "spwndFocus", spwndFocus);
            GetFieldValue(pq, SYM(tagQ), "spwndActive", spwndActive);
            PRTWND(gpqForeground->spwndFocus, spwndFocus);
            PRTWND(gpqForeground->spwndActive, spwndActive);
        }
    }

    PRTGWND(gspwndScreenCapture);
    PRTGWND(gspwndInternalCapture);
    PRTGWND(gspwndMouseOwner);

    return TRUE;
}
#endif // KERNEL


/************************************************************************\
* Idll
*
* Dump Linked Lists.
*
* ???????? Scottlu  Created
* 6/9/1995 SanfordS made to fit stdexts motif
\************************************************************************/
BOOL Idll(
    DWORD opts,
    LPSTR lpas)
{
    static DWORD iOffset;
    static DWORD cStructs;
    static DWORD cDwords;
    static DWORD cDwordsBack;
    static ULONG64 dw, dwHalfSpeed;
    ULONG64 dwT;
    DWORD cBytesBack;
    DWORD i, j;
    BOOL fIndirectFirst;
    BOOL fTestAndCountOnly = FALSE;
    ULONG64 dwFind = 0;
    DWORD adw[CDWORDS];
    ULONG64 dwValue;

    UNREFERENCED_PARAMETER(opts);

    /*
     * Evaluate the argument string and get the address of the object to
     * dump. Take either a handle or a pointer to the object.
     */
    while (*lpas == ' ') {
        lpas++;
    }

    /*
     * If there are no arguments, keep walking from the last
     * pointer.
     */
    if (*lpas != 0) {
        /*
         * If the address has a '*' in front of it, it means start with the
         * pointer stored at that address.
         */
        fIndirectFirst = FALSE;
        if (*lpas == '*') {
            lpas++;
            fIndirectFirst = TRUE;
        }

        /*
         * Scan past the address.
         */
        dw = dwValue = GetExpression(lpas);

        if (fIndirectFirst) {
            ReadPointer(dw, &dw);
        }
        dwHalfSpeed = dw;

        cStructs = 25;
        cDwords = 8;
        iOffset = cDwordsBack = 0;

        SAFEWHILE (TRUE) {
            while (*lpas == ' ') {
                lpas++;
            }

            switch(*lpas) {
            case 'l':
                /*
                 * length of each structure.
                 */
                lpas++;
                cDwords = (DWORD)(DWORD_PTR)GetExpression(lpas);
                if (cDwords > CDWORDS) {
                    Print("\nl%d? - %d DWORDs maximum\n\n", cDwords, CDWORDS);
                    cDwords = CDWORDS;
                }
                break;

            case 'b':
                /*
                 * Go back cDwordsBack and dump cDwords from there
                 * (useful for LIST_ENTRYs, where Flink doesn't point to
                 * the start of the struct). cDwordsBack can be negative,
                 * to allow people to start dumping from a certain offset
                 * within the structure.
                 */
                lpas++;
                cDwordsBack = (DWORD)(DWORD_PTR)GetExpression(lpas);
                if (cDwordsBack >= CDWORDS) {
                    Print("\nb%d? - %d DWORDs maximum\n\n", cDwordsBack, CDWORDS - 1);
                    cDwordsBack = CDWORDS - 1;
                }
                break;

            case 'o':
                /*
                 * Offset of 'next' pointer.
                 */
                lpas++;
                iOffset = (DWORD)(DWORD_PTR)GetExpression(lpas);
                break;

            case 'c':
                /*
                 * Count of structures to dump
                 */
                lpas++;
                cStructs = (DWORD)(DWORD_PTR)GetExpression(lpas);
                break;

            case 'f':
                /*
                 * Find element at given address
                 */
                lpas++;
                dwFind = EvalExp(lpas);
                break;

            case 't':
                /*
                 * Test list for loop, and count
                 */
                fTestAndCountOnly = TRUE;
                cStructs = 0x100000;

            default:
                break;
            }

            while (*lpas && *lpas != ' ')
                lpas++;

            if (*lpas == 0)
                break;
        }

        if (cDwordsBack > cDwords) {
            Print("backing up %d DWORDS per struct (b%d): ",
                    cDwordsBack, cDwordsBack);
            Print("increasing l%d to l%d so next link is included\n",
                    cDwords, cDwordsBack + 1);
            cDwords = cDwordsBack + 1;
        }

        for (i = 0; i < CDWORDS; i++) {
            adw[i] = 0;
        }
    }

    cBytesBack = cDwordsBack * sizeof(DWORD);

    for (i = 0; i < cStructs; i++) {
        moveBlock(adw, (dw - cBytesBack), sizeof(DWORD) * cDwords);

        if (!fTestAndCountOnly) {
            Print("---- 0x%lx:\n", i);
            for (j = 0; j < cDwords; j += 4) {
                switch (cDwords - j) {
                case 1:
                    Print("%p:  %08lx\n",
                            dw + j * sizeof(DWORD),
                            adw[j + 0]);
                    break;

                case 2:
                    Print("%p:  %08lx %08lx\n",
                            dw + j * sizeof(DWORD),
                            adw[j + 0], adw[j + 1]);
                    break;

                case 3:
                    Print("%p:  %08lx %08lx %08lx\n",
                            dw + j * sizeof(DWORD),
                            adw[j + 0], adw[j + 1], adw[j + 2]);
                    break;

                default:
                    Print("%p:  %08lx %08lx %08lx %08lx\n",
                            dw + j * sizeof(DWORD),
                            adw[j + 0], adw[j + 1], adw[j + 2], adw[j + 3]);
                }
            }
        } else if ((i & 0xff) == 0xff) {
            Print("item 0x%lx at %p...\n", i+1, dw);
        }

        if (dwFind == dw) {
            Print("====== FOUND ITEM ======\n");
            break;
        }

        /*
         * Give a chance to break out every 16 items
         */
        if ((i & 0xf) == 0xf) {
            if (IsCtrlCHit()) {
                Print("terminated by Ctrl-C on item 0x%lx at %p...\n", i, dw);
                break;
            }
        }

        /*
         * Advance to next item.
         */
        dwT = dw + iOffset * sizeof(DWORD);
        ReadPointer(dwT, &dw);

        if (fTestAndCountOnly) {
            /*
             * Advance dwHalfSpeed every other time round the loop: if
             * dw ever catches up to dwHalfSpeed, then we have a loop!
             */
            if (i & 1) {
                dwT = dwHalfSpeed + iOffset * sizeof(DWORD);
                ReadPointer(dwT, &dwHalfSpeed);
            }
            if (dw == dwHalfSpeed) {
                Print("!!! Loop Detected on item 0x%lx at %lx...\n", i, dw);
                break;
            }
        }

        if (dw == 0) {
            break;
        }
    }
    Print("---- Total 0x%lx items ----\n", i+1);

    return TRUE;
}


/************************************************************************\
* Ifind
*
* Find Linked List Element
*
* 11/22/95 JimA         Created.
\************************************************************************/
BOOL Ifind(
    DWORD opts,
    LPSTR lpas)
{
    DWORD iOffset = 0;
    ULONG64 dwBase, dwAddr, dwTest, dwT, dwLast = 0;

    UNREFERENCED_PARAMETER(opts);

    /*
     * Evaluate the argument string and get the address of the object to
     * dump. Take either a handle or a pointer to the object.
     */
    while (*lpas == ' ') {
        lpas++;
    }

    /*
     * If there are no arguments, keep walking from the last
     * pointer.
     */
    if (*lpas != 0) {

        /*
         * Scan past the addresses.
         */
        dwBase = EvalExp(lpas);
        while (*lpas && *lpas != ' ') {
            lpas++;
        }
        dwAddr = EvalExp(lpas);
        while (*lpas && *lpas != ' ') {
            lpas++;
        }

        iOffset = 0;

        SAFEWHILE (*lpas != 0) {
            while (*lpas == ' ') {
                lpas++;
            }

            switch(*lpas) {
            case 'o':
                /*
                 * Offset of 'next' pointer.
                 */
                lpas++;
                iOffset = (DWORD)(DWORD_PTR)EvalExp(lpas);
                break;

            default:
                break;
            }

            while (*lpas && *lpas != ' ') {
                lpas++;
            }
        }
    }

    dwTest = dwBase;
    while (dwTest && (ULONG_PTR)dwTest != (ULONG_PTR)dwAddr) {
        dwLast = dwTest;
        dwT = dwTest + iOffset * sizeof(DWORD);
        move(dwTest, dwT);
    }

    if (dwTest == 0) {
        Print("Address %#p not found\n", dwAddr);
    } else {
        Print("Address %#p found, previous = %#p\n", dwAddr, dwLast);
    }

    return TRUE;
}

#ifdef KERNEL
/***************************************************************************\
* dlr handle|pointer
*
* Dumps lock list for object
*
* 02-27-92 ScottLu      Created.
* 6/9/1995 SanfordS     made to fit stdexts motif
\***************************************************************************/

#define LR_FLAG(x)  (1 << (x))
#define LR_SIMPLELOCK   0

BOOL Idlr(DWORD opts, LPSTR lpszParam)
{
    ULONG64 phe;
    ULONG64 param;
#if DBG
    ULONG64 plrT;
    ULONG64 pTrace;
    ULONG cbPtr;
#endif

    ULONG64  psi;
    ULONG    cbOffset;
#ifdef DEBUGTAGS
    DWORD    dwDBGTAGFlags;
    DWORD    dwLockRecordFlags;
#endif // DEBUGTAGS

    psi = GetGlobalPointer(VAR(gpsi));

    if (GetFieldOffset(SYM(SERVERINFO), "adwDBGTAGFlags", &cbOffset)) {
        Print("failed to get the SERVERINFO::adwDBGTAGFlags\n");
        return TRUE;

    }
#ifdef DEBUGTAGS
    dwDBGTAGFlags = (DWORD)GetArrayElement(psi, SYM(SERVERINFO), "adwDBGTAGFlags", DBGTAG_TrackLocks, "DWORD");

    dwDBGTAGFlags &= DBGTAG_VALIDUSERFLAGS;

    moveExpValue(&dwLockRecordFlags, VAR(gdwLockRecordFlags));

    if (opts & (OFLAG(s) | OFLAG(c))) {
        DWORD flag;
        if (!NT_SUCCESS(GetInteger(lpszParam, 0x10, &flag, NULL))) {
            Print("Invalid arg: '%s'\n", lpszParam);
            return FALSE;
        }
        if (opts & OFLAG(s)) {
            dwLockRecordFlags |= LR_FLAG(flag);
        } else {
            dwLockRecordFlags &= ~LR_FLAG(flag);
        }
        Print("7\n");
        WriteMemory(EvalExp(VAR(gdwLockRecordFlags)), &dwLockRecordFlags, sizeof dwLockRecordFlags, NULL);
        Print("8\n");

        // for to display it
        opts |= OFLAG(l);
    }

    if (opts & OFLAG(l)) {
        #define HT(type)    { type, #type }
        static const struct {
            DWORD dwType;
            char* lpszName;
        } flags[] = {
            //{ LR_SIMPLELOCK, "Rec SimpleLock" },
            { LR_SIMPLELOCK, "Reserved" },
            HT(TYPE_WINDOW),
            HT(TYPE_MENU),
            HT(TYPE_CURSOR),
            HT(TYPE_SETWINDOWPOS),
            HT(TYPE_HOOK),
            HT(TYPE_CLIPDATA),
            HT(TYPE_CALLPROC),
            HT(TYPE_ACCELTABLE),
            HT(TYPE_DDEACCESS),
            HT(TYPE_DDECONV),
            HT(TYPE_DDEXACT),
            HT(TYPE_MONITOR),
            HT(TYPE_KBDLAYOUT),
            HT(TYPE_KBDFILE),
            HT(TYPE_WINEVENTHOOK),
            HT(TYPE_TIMER),
            HT(TYPE_INPUTCONTEXT),
            HT(TYPE_HIDDATA),
            HT(TYPE_DEVICEINFO),
        };
        #undef HT
        UINT i;

        Print("gdwLockRecordFlags: %08x\n", dwLockRecordFlags);

        for (i = 0; i < ARRAY_SIZE(flags); ++i) {
            char prefix = ' ';
            if (dwLockRecordFlags & LR_FLAG(flags[i].dwType)) {
                prefix = '*';
            }
            Print(" %02x %c%-18s", (DWORD)flags[i].dwType, prefix, flags[i].lpszName);
            if ((i + 1) % 3 == 0) {
                Print("\n");
            }
        }
        Print("\n");

        return TRUE;
    }
#else
    UNREFERENCED_PARAMETER(opts);
#endif

    if (*lpszParam == '\0') {
        Print("no arg!!\n");
        return FALSE;
    }
    param = EvalExp(lpszParam);

    if (!GetAndDumpHE(param, &phe, FALSE)) {
        Print("!dlr: GetAndDumpHE failed\n");
        return FALSE;
    }

    /*
     * We have the handle entry: 'he' is filled in.  Now dump the
     * lock records. Remember the 1st record is the last transaction!!
     */
#if DBG
    GetFieldValue(phe, SYM(HANDLEENTRY), "plr", plrT);


    if (plrT != 0) {
        Print("phe %p Dumping the lock records\n"
              "----------------------------------------------\n"
              "address  cLock\n"
              "----------------------------------------------\n", phe);
    }

    SAFEWHILE (plrT != 0) {
        ULONG64     dw;
        int         i;
        char        ach[80];

        InitTypeRead(plrT, LOCKRECORD);

        Print("%p %08d\n", ReadField(ppobj), ReadField(cLockObj));

        GetFieldOffset(SYM(LOCKRECORD), "trace", &cbOffset);
        cbPtr = GetTypeSize("PVOID");


        for (i = 0; i < LOCKRECORD_STACK; i++) {
            ReadPointer(plrT + cbOffset + i * cbPtr, &pTrace);
            GetSym(pTrace, ach, &dw);
            Print("                  %s", ach);
            if (dw != 0) {
                Print("+0x%x", dw);
            }
            Print("\n");
        }

        plrT = ReadField(plrNext);
    }
#endif // DBG
    return TRUE;
}
#endif // KERNEL


VOID DumpMenu(
    UINT uIndent,
    DWORD opts,
    ULONG64 pMenu)
{
    DWORD fFlags, cxMenu, cyMenu, dwContextHelpId, cch, dwSize;
    UINT cAlloced, cItems, i;
    INT iItem;
    WCHAR szBufW[128];
    char szIndent[256];
    ULONG dwOffset;
    ULONG64 pwnd, pitem;

    /*
     * Compute our indent
     */
    for (i = 0; i < uIndent; szIndent[i++] = ' ')
        /* do nothing */;
    szIndent[i] = '\0';

    dwSize = GetTypeSize("ITEM");

    /*
     * Print the menu header
     */
    if (!(opts & OFLAG(v))) {
        Print("0x%p  %s", pMenu, szIndent);
    } else {
        Print("%sPMENU @ 0x%p:\n", szIndent, pMenu);
    }

    /*
     * Try and get the menu
     */
    if (InitTypeRead(pMenu, MENU)) {
        Print("Couldn't read PMENU at %p\n", pMenu);
        return;
    }

    /*
     * Print the information for this menu
     */
    fFlags = (DWORD)ReadField(fFlags);
    cxMenu = (DWORD)ReadField(cxMenu);
    cyMenu = (DWORD)ReadField(cyMenu);
    dwContextHelpId = (DWORD)ReadField(dwContextHelpId);
    cAlloced = (UINT)ReadField(cAlloced);
    cItems = (UINT)ReadField(cItems);
    iItem = (INT)ReadField(iItem);
    pwnd = ReadField(spwndNotify);
    if (!(opts & OFLAG(v))) {
        Print("PMENU: fFlags=0x%lX, cItems=%lu, iItem=%lu, spwndNotify=0x%p\n",
              fFlags, cItems, iItem, pwnd);
    } else {
        Print("%s     fFlags............ %s\n"
              "%s     location.......... (%lu, %lu)\n",
              szIndent, GetFlags(GF_MF, (WORD)fFlags, NULL, TRUE),
              szIndent, cxMenu, cyMenu);
        Print("%s     spwndNotify....... 0x%p\n"
              "%s     dwContextHelpId... 0x%08lX\n"
              "%s     items............. %lu items in block of %lu\n",
              szIndent, pwnd,
              szIndent, dwContextHelpId,
              szIndent, cItems, cAlloced);
    }

    GetFieldOffset(SYM(MENU), "rgItems", &dwOffset);
    pitem = (ULONG_PTR)pMenu + dwOffset;
    if (ReadPointer(FIXKP(pitem), &pitem)) {
        i = 0;
        SAFEWHILE (i < cItems) {
            /*
             * Get the menu item
             */
            InitTypeRead(FIXKP(pitem), ITEM);
            if (!(opts & OFLAG(i))) {
                /*
                 * Print the info for this item.
                 */
                if (!(opts & OFLAG(v))) {
                    Print("0x%p      %s%lu: ID=0x%08lX hbmp=0x%p", pitem, szIndent, i, (INT)(WORD)ReadField(wID), (ULONG_PTR)ReadField(hbmp));
                    cch = (DWORD)ReadField(cch);
                    if (cch && CopyUnicodeString(pitem, SYM(ITEM), "lpstr", szBufW, (cch * sizeof(WCHAR)))) {
                        szBufW[cch] = 0;
                        Print("  %ws%\n", szBufW);
                    } else {
                        Print(", fType=%s", GetFlags(GF_MENUTYPE, (WORD)ReadField(fType), NULL, TRUE));
                        if (((UINT)ReadField(fType) & MF_SEPARATOR) == 0) {
                             Print(", lpstr=0x%p", ReadField(lpstr));
                        }
                        Print("\n");
                    }
                } else {
                    Print("%s   Item #%d @ 0x%p:\n", szIndent, i, pitem);
                    /*
                     * Print the details for this item.
                     */
                    Print("%s         ID........... 0x%08lX (%lu)\n"
                          "%s         lpstr.... 0x%p",
                          szIndent, (WORD)ReadField(wID), (WORD)ReadField(wID),
                          szIndent, ReadField(lpstr));
                    if (cch && CopyUnicodeString(pitem, SYM(ITEM), "lpstr", szBufW, (cch*sizeof(WCHAR)))) {
                        szBufW[cch] = 0;
                        Print("  %ws%\n", szBufW);
                    } else {
                        Print("\n");
                    }
                    Print("%s         fType........ %s\n"
                          "%s         fState....... %s\n"
                          "%s         dwItemData... 0x%p\n",
                          szIndent, GetFlags(GF_MENUTYPE, (WORD)ReadField(fType), NULL, TRUE),
                          szIndent, GetFlags(GF_MENUSTATE, (WORD)ReadField(fState), NULL, TRUE),
                          szIndent, (ULONG_PTR)ReadField(dwItemData));
                    Print("%s         checks....... on=0x%p, off=0x%p\n"
                          "%s         location..... @(0n%lu, 0n%lu) size=(0n%lu, 0n%lu)\n",
                          szIndent, ReadField(hbmpChecked), ReadField(hbmpUnchecked),
                          szIndent, (DWORD)ReadField(xItem), (DWORD)ReadField(yItem), (DWORD)ReadField(cxItem), (DWORD)ReadField(cyItem));
                    Print("%s         underline.... x=%lu, width=%lu\n"
                          "%s         dxTab........ %lu\n"
                          "%s         spSubMenu.... 0x%p\n",
                          szIndent, (DWORD)ReadField(ulX), (DWORD)ReadField(ulWidth),
                          szIndent, (DWORD)ReadField(dxTab),
                          szIndent, ReadField(spSubMenu));
                }
            }

            /*
             * If requested, traverse through sub-menus
             */
            if (opts & OFLAG(r)) {
                pMenu = HorPtoP(ReadField(spSubMenu), TYPE_MENU);
                if (pMenu) {
                    DumpMenu(uIndent + 8, opts, pMenu);
                }
            }
            pitem += dwSize;
            ++i;
        }
    }
}

/************************************************************************\
* Idm
*
* Dumps Menu structures
*
* 6/9/1995 Created SanfordS
\************************************************************************/
BOOL Idm(
    DWORD opts,
    ULONG64 param1)
{
    ULONG64 pvObject, phe;
    BYTE bType;

    if (param1 == 0) {
        return FALSE;
    }

    pvObject = HorPtoP(FIXKP(param1), -1);
    if (pvObject == 0) {
        Print("dm: Could not convert 0x%p to an object.\n", pvObject);
        return TRUE;
    }

    if (!getHEfromP(&phe, pvObject)) {
        Print("dm: Could not get header for object 0x%p.\n", pvObject);
        return TRUE;
    }

    GetFieldValue(phe, SYM(HANDLEENTRY), "bType", bType);
    switch (bType) {
    case TYPE_WINDOW:
        Print("--- Dump Menu for %s object @ 0x%p ---\n", pszObjStr[bType], FIXKP(pvObject));
        if (InitTypeRead(pvObject, WND)) {
            Print("dm: Could not read object at 0x%p.\n", pvObject);
            return TRUE;
        }

        if (opts & OFLAG(s)) {
            /*
             * Display window's system menu
             */
            if ((pvObject = FIXKP(ReadField(spmenuSys))) == 0) {
                Print("dm: This window does not have a system menu.\n");
                return TRUE;
            }
        } else {
            if ((DWORD)ReadField(style) & WS_CHILD) {
                /*
                 * Child windows don't have menus
                 */
                Print("dm: Child windows do not have menus.\n");
                return TRUE;
            }

            if ((pvObject = FIXKP(ReadField(spmenu))) == 0) {
                Print("dm: This window does not have a menu.\n");
                return TRUE;
            }
        }

        /* >>>>  F A L L   T H R O U G H   <<<< */

    case TYPE_MENU:
        DumpMenu(0, opts, pvObject);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

#ifdef KERNEL
/***************************************************************************\
* dmq - dump messages on queue
*
* dmq address - dumps messages in queue structure at address.
* dmq -a      - dump messages for all queues
* dmq -c      - count messages for all queues
*
* 11-13-91 DavidPe      Created.
* 6/9/1995 SanfordS     made to fit stdexts motif
* 11/05/2000 Hiroyama   new 64bit clean code
\***************************************************************************/

typedef struct tagQSTAT {
    DWORD dwInput, dwPosted, dwQueues, dwThreads;
    DWORD opts;
} QSTAT, *PQSTAT;

/*
 * PrintMessages
 * N.b. resets InitTypeRead
 */
BOOL PrintMessages(ULONG64 pqmsgRead, ULONG64 pti)
{
    ULONG64 asmsg;    // ASYNCSENDMSG
    char *aszEvents[] = {
        "MSG",  // QEVENT_MESSAGE
        "SHO",  // QEVENT_SHOWWINDOW"
        "CMD",  // QEVENT_CANCLEMODE"
        "SWP",  // QEVENT_SETWINDOWPOS"
        "UKS",  // QEVENT_UPDATEKEYSTATE"
        "DEA",  // QEVENT_DEACTIVATE"
        "ACT",  // QEVENT_ACTIVATE"
        "PST",  // QEVENT_POSTMESSAGE"
        "EXE",  // QEVENT_EXECSHELL"
        "CMN",  // QEVENT_CANCELMENU"
        "DSW",  // QEVENT_DESTROYWINDOW"
        "ASY",  // QEVENT_ASYNCSENDMSG"
        "HNG",  // QEVENT_HUNGTHREAD"
        "CMT",  // QEVENT_CANCELMOUSEMOVETRK"
        "NWE",  // QEVENT_NOTIFYWINEVENT"
        "RAC",  // QEVENT_RITACCESSIBILITY"
        "RSO",  // QEVENT_RITSOUND"
        "?  ",  // "?"
        "?  ",  // "?"
        "?  "   // "?"
    };
    #define NQEVENT (ARRAY_SIZE(aszEvents))

#if 0
    Print("typ pqmsg    hwnd    msg  wParam   lParam   time     ExInfo   dwQEvent pti\n");
    Print("-------------------------------------------------------------------------------\n");
#else
    Print("typ %-*s %-*s msg  %-*s %-*s time     %-*s dwQEvent pti\n",
          PtrWidth(), "pqmsg",
          PtrWidth(), "hwnd",
          PtrWidth(), "wParam",
          PtrWidth(), "lParam",
          PtrWidth(), "ExInfo");
    Print("----------------------------------------------------------------------------------\n");
#endif

    SAFEWHILE (TRUE) {
        _InitTypeRead(pqmsgRead, SYM(tagQMSG));
        if (ReadField(dwQEvent) < NQEVENT) {
            Print("%s %p ", aszEvents[ReadField(dwQEvent)], pqmsgRead);
        } else {
            Print("??? %p ", pqmsgRead);
        }

        switch (ReadField(dwQEvent)) {
        case QEVENT_ASYNCSENDMSG:
            asmsg = ReadField("msg.wParam");
            _InitTypeRead(asmsg, SYM(ASYNCSENDMSG));

            Print("%08p %04lx %08p %08p %08lx %08p %08lx %08p %c\n",
                  ReadField(hwnd), (DWORD)ReadField(message), ReadField(wParam), ReadField(lParam),
                  (DWORD)ReadField(msg.time), ReadField(ExtraInfo), (DWORD)ReadField(dwQEvent), ReadField(pti),
                  pti && ReadField(pti) == pti ? '*' : ' ');
            break;

        case 0:
        default:
            Print("%08p %04lx %08p %08p %08lx %08p %08lx %08p %c\n",
                  ReadField(msg.hwnd), (DWORD)ReadField(msg.message), ReadField(msg.wParam), ReadField(msg.lParam),
                  (DWORD)ReadField(msg.time), ReadField(ExtraInfo), (DWORD)ReadField(dwQEvent), ReadField(pti),
                  pti && ReadField(pti) == pti ? '*' : ' ');
            break;

        }

        _InitTypeRead(pqmsgRead, SYM(tagQMSG));
        if (ReadField(pqmsgNext) != NULL_POINTER) {
            if (pqmsgRead == ReadField(pqmsgNext)) {
                Print("<ALERT!> loop found in message list!");
                return FALSE;
            }
            pqmsgRead = ReadField(pqmsgNext);
        } else {
            return TRUE;
        }
    }
    return TRUE;
}

/*
 * DumpQMsg --- dumps or counts messages in a queue
 * N.b. resets InitTypeRead
 */
BOOL DumpQMsg(
    ULONG64 pq,
    PQSTAT qs,
    ULONG64 pti)
{
    ULONG64 ptiTmp;
    BOOL bMsgsPresent = FALSE;

    _InitTypeRead(pq, SYM(tagQ));

    // LATER: error handling in case pq is not accessible?

    if ((qs->opts & OFLAG(c)) == 0) {
        Print("Messages for queue 0x%p pti=%p\n", pq, pti);
    }

    if (pti) {
        if (ReadField(ptiKeyboard) == pti || ReadField(ptiMouse) == pti) {
            qs->dwQueues++;
        }
    }

    if (ReadField(ptiKeyboard) != NULL_POINTER) {
        ULONG64 pqmsgRead;

        ptiTmp = ReadField(ptiKeyboard);

        GetFieldValue(ptiTmp, SYM(tagTHREADINFO), "mlPost.pqmsgRead", pqmsgRead);

        if (!(qs->opts & OFLAG(c)) && pqmsgRead) {
            // If not counter only, and post messages exist, dump them all.
            bMsgsPresent = TRUE;
            Print("==== PostMessage queue ====\n");
            PrintMessages(FIXKP(pqmsgRead), NULL_POINTER);
        }
    } else {
        Print("<ALERT!> ptiKeyboard is NULL for pq=%p!\n", pq);
    }

    _InitTypeRead(pq, SYM(tagQ));

    if (!(qs->opts & OFLAG(c)) && ReadField(mlInput.pqmsgRead)) {
        // If not counter only, and input messages exist, dump them all.
        bMsgsPresent = TRUE;
        Print(    "==== Input queue ==========\n");
        if (ReadField(mlInput.pqmsgRead) != NULL_POINTER) {
            PrintMessages(FIXKP(ReadField(mlInput.pqmsgRead)), pti);
        }
    }

    _InitTypeRead(pq, SYM(tagQ));

    if (qs->opts & OFLAG(c)) {
        DWORD dwTimePosted;
        DWORD dwTimeInput = 0;
        DWORD dwOldest, dwNewest;

        if (ReadField(mlInput.cMsgs)) {
            qs->dwInput += (DWORD)ReadField(mlInput.cMsgs);
            GetFieldValue(ReadField(mlInput.pqmsgRead), SYM(tagQMSG), "msg.time", dwOldest);
            GetFieldValue(ReadField(mlInput.pqmsgWriteLast), SYM(tagQMSG), "msg.time", dwNewest);
            dwTimeInput = dwNewest - dwOldest;
        }
        Print("%08p%c %8x %8x\t%08p",
              pq,
              ((ReadField(ptiKeyboard) != pti) && (ReadField(ptiMouse) != pti)) ? '*' : ' ',
              (DWORD)ReadField(mlInput.cMsgs), dwTimeInput,
              ReadField(ptiKeyboard));
        //
        // it would be good to print the ptiStatic too, maybe like this:
        // e1b978a8         0         0    e1ba3368        0         0
        // e1b9aca8*        0         0    e1b8b2e8        0         0
        //   (thread who's queue this is : e1a3ca28        0         0)
        //

        // Dump post message statics
        dwTimePosted = 0;
        _InitTypeRead(ptiTmp, SYM(tagTHREADINFO));
        if (ReadField(mlPost.cMsgs)) {
            qs->dwPosted += (DWORD)ReadField(mlPost.cMsgs);
            GetFieldValue(ReadField(mlPost.pqmsgRead), SYM(tagQMSG), "msg.time", dwOldest);
            GetFieldValue(ReadField(mlPost.pqmsgWriteLast), SYM(tagQMSG), "msg.time", dwNewest);
            dwTimePosted = dwNewest - dwOldest;
        }
        Print(" %8x %8x\n", (DWORD)ReadField(mlPost.cMsgs), dwTimePosted);
    } else {
        if (bMsgsPresent) {
            Print("\n");
        }
    }

    return TRUE;
}

ULONG dmqCallback(
    ULONG64 pti,
    PVOID pData)
{
    PQSTAT qs = (PQSTAT)pData;

    _InitTypeRead(pti, SYM(tagTHREADINFO));
    DumpQMsg(ReadField(pq), qs, pti);

    _InitTypeRead(pti, SYM(tagTHREADINFO));
    if (ReadField(pqAttach)) {
        Print(" -> pqAttach=%p", ReadField(pqAttach));
        // LATER: dump pqAttach as well?
    }

    return FALSE;
}


BOOL Idmq(
    DWORD opts,
    ULONG64 param1)
{
    try {
        static const char separator[] = "=================";
        ULONG64 pq;

        // firstly check the symbols etc.'s legitimacy
        pq = GetGlobalPointer(VAR(gpqForeground));

        if (param1 == NULL_POINTER) {
            if ((opts & OFLAG(a)) == 0) {
                Print("uses gpqForeground\n");
            }
        }

        if (opts & OFLAG(c)) {
            Print("Summary of%s message queues (\"age\" is newest time - oldest time)\n",
                  param1 == NULL_POINTER ? " all" : "");
            //Print("Queue      # Input    age   \t Thread  # Posted    age\n");
            //Print("========  ========  ========\t======== ========  ========\n");
            Print("%-*s  %-*s %-*s\t%-*s %-*s %-*s\n",
                  PtrWidth(), "queue",
                  PtrWidth(), "# input",
                  PtrWidth(), "age",
                  PtrWidth(), "Thread",
                  PtrWidth(), "# posted",
                  PtrWidth(), "age");
            Print("%*.*s  %*.*s %*.*s\t%*.*s %*.*s %*.*s\n",
                  PtrWidth(), PtrWidth(), separator,
                  PtrWidth(), PtrWidth(), separator,
                  PtrWidth(), PtrWidth(), separator,
                  PtrWidth(), PtrWidth(), separator,
                  PtrWidth(), PtrWidth(), separator,
                  PtrWidth(), PtrWidth(), separator);
        }

        if (param1 == NULL_POINTER) {
            if (opts & OFLAG(t)) {
                // pti is required with -t
                return FALSE;
            }
            if (opts & (/*OFLAG(c) |*/ OFLAG(a))) {
                /*
                 * do it for all the queues
                 */
                QSTAT qs = { 0, };
                qs.opts = opts & OFLAG(c);
                ForEachPti(dmqCallback, &qs);
                if (opts & OFLAG(c)) {
                    Print(" \n");
                    Print("Queues     # Input          \t Threads # Posted\n");
                    Print("========  ========  ========\t======== ========\n");
                    Print("%8x  %8x          \t%8x %8x\n",
                          qs.dwQueues, qs.dwInput, qs.dwThreads, qs.dwPosted);
                }
                return TRUE;
            } else {
                // use gpqForeground
                if (pq == NULL_POINTER) {
                    Print("no foreground queue (gpqForeground == NULL)!\n");
                    return TRUE;
                }
            }
        } else {
            // param1 is pq or pti
            pq = param1;
        }

        if (opts & OFLAG(t)) {
            // param1 is pti
            QSTAT qs = { 0, };
            qs.opts = opts & OFLAG(c);

            _InitTypeRead(param1, SYM(tagTHREADINFO));
            DumpQMsg(ReadField(pq), &qs, param1);
            _InitTypeRead(param1, SYM(tagTHREADINFO));
            if (ReadField(pqAttach)) {
                Print("paAttach\n");
                DumpQMsg(ReadField(pqAttach), &qs, param1);
            }
        } else {
            // param1 is pq
            ULONG64 ptiKeyboard;
            QSTAT qs = { 0, };
            qs.opts = opts & OFLAG(c);
            GetFieldValue(pq, SYM(tagQ), "ptiKeyboard", ptiKeyboard);
            DumpQMsg(pq, &qs, ptiKeyboard);
        }
    } except (CONTINUE) {
    }

    return TRUE;
}
#endif  // KERNEL


#ifdef OLD_DEBUGGER
#ifdef KERNEL
/***************************************************************************\
* dwe - dump winevents
*
* dwe           - dumps all EVENTHOOKs.
* dwe <addr>    - dumps EVENTHOOK at address.
* dwe -n        - dumps all NOTIFYs.
* dwe -n <addr> - dumps NOTIFY at address.
*
* 1997-07-10 IanJa      Created.
\***************************************************************************/
BOOL Idwe(
    DWORD opts,
    ULONG64 param1)
{
    EVENTHOOK EventHook, *pEventHook;
    NOTIFY Notify, *pNotify;
    PVOID pobj;
    char ach[100];

    pobj = FIXKP(param1);

    if (opts & OFLAG(n)) {
        if (pobj) {
            move(Notify, pobj);
            sprintf(ach, "NOTIFY 0x%p\n", pobj);
            Idso(0, ach);
            return 1;
        }
        pNotify = GetGlobalPointer(VAR(gpPendingNotifies));
        Print("Pending Notifications:\n");
        gnIndent += 2;
        SAFEWHILE (pNotify != NULL) {
            sprintf(ach, "NOTIFY  0x%p\n", pNotify);
            Idso(0, ach);
            move(pNotify, &pNotify->pNotifyNext);
        }
        gnIndent -= 2;
        return TRUE;
    }

    if (pobj) {
        move(EventHook, pobj);
        sprintf(ach, "EVENTHOOK 0x%p\n", pobj);
        Idso(0, ach);
        return 1;
    }
    pEventHook = GetGlobalPointer(VAR(gpWinEventHooks));
    Print("WinEvent hooks:\n");
    gnIndent += 2;
    SAFEWHILE (pEventHook != NULL) {
        sprintf(ach, "EVENTHOOK  0x%p\n", pEventHook);
        Idso(0, ach);
        move(pEventHook, &pEventHook->pehNext);
    }
    gnIndent -= 2;
    Print("\n");
    return TRUE;
}
#endif // KERNEL


#ifndef KERNEL
/************************************************************************\
* Idped
*
* Dumps Edit Control Structures (PEDs)
*
* 6/9/1995 Created SanfordS
\************************************************************************/
BOOL Idped(
    DWORD opts,
    ULONG64 param1)
{
    PED   ped;
    ED    ed;
    DWORD pText;

    UNREFERENCED_PARAMETER(opts);

    ped = param1;

    move(ed, ped);
    move(pText, ed.hText);


    Print("PED Handle: %lX\n", ped);
    Print("hText      %lX (%lX)\n", ed.hText, pText);
    PRTFDW2(ed., cchAlloc, cchTextMax);
    PRTFDW2(ed., cch, cLines);
    PRTFDW2(ed., ichMinSel, ichMaxSel);
    PRTFDW2(ed., ichCaret, iCaretLine);
    PRTFDW2(ed., ichScreenStart, ichLinesOnScreen);
    PRTFDW2(ed., xOffset, charPasswordChar);
    PRTFDWDWP(ed., cPasswordCharWidth, hwnd);
    PRTFDWP1(ed., pwnd);
    PRTFRC(ed., rcFmt);
    PRTFDWP1(ed., hwndParent);
    PRTFPT(ed., ptPrevMouse);
    PRTFDW1(ed., prevKeys);

    BEGIN_PRTFFLG();
    PRTFFLG(ed, fSingle);
    PRTFFLG(ed, fNoRedraw);
    PRTFFLG(ed, fMouseDown);
    PRTFFLG(ed, fFocus);
    PRTFFLG(ed, fDirty);
    PRTFFLG(ed, fDisabled);
    PRTFFLG(ed, fNonPropFont);
    PRTFFLG(ed, fNonPropDBCS);
    PRTFFLG(ed, fBorder);
    PRTFFLG(ed, fAutoVScroll);
    PRTFFLG(ed, fAutoHScroll);
    PRTFFLG(ed, fNoHideSel);
    PRTFFLG(ed, fDBCS);
    PRTFFLG(ed, fFmtLines);
    PRTFFLG(ed, fWrap);
    PRTFFLG(ed, fCalcLines);
    PRTFFLG(ed, fEatNextChar);
    PRTFFLG(ed, fStripCRCRLF);
    PRTFFLG(ed, fInDialogBox);
    PRTFFLG(ed, fReadOnly);
    PRTFFLG(ed, fCaretHidden);
    PRTFFLG(ed, fTrueType);
    PRTFFLG(ed, fAnsi);
    PRTFFLG(ed, fWin31Compat);
    PRTFFLG(ed, f40Compat);
    PRTFFLG(ed, fFlatBorder);
    PRTFFLG(ed, fSawRButtonDown);
    PRTFFLG(ed, fInitialized);
    PRTFFLG(ed, fSwapRoOnUp);
    PRTFFLG(ed, fAllowRTL);
    PRTFFLG(ed, fDisplayCtrl);
    PRTFFLG(ed, fRtoLReading);
    PRTFFLG(ed, fInsertCompChr);
    PRTFFLG(ed, fReplaceCompChr);
    PRTFFLG(ed, fNoMoveCaret);
    PRTFFLG(ed, fResultProcess);
    PRTFFLG(ed, fKorea);
    PRTFFLG(ed, fInReconversion);
    END_PRTFFLG();

    PRTFDWDWP(ed., cbChar, chLines);
    PRTFDWDWP(ed., format, lpfnNextWord);
    PRTFDW1(ed., maxPixelWidth);

    {
        const char* p = "**INVALID**";

        if (ed.undoType < UNDO_DELETE) {
            p = GetFlags(GF_EDUNDO, 0, NULL, TRUE);
        }
        Print(DWSTR2 "\t" "%08x undoType (%s)\n", ed.hDeletedText, "hDeleteText", ed.undoType, p);
    }

    PRTFDW2(ed., ichDeleted, cchDeleted);
    PRTFDW2(ed., ichInsStart, ichInsEnd);

    PRTFDWPDW(ed., hFont, aveCharWidth);
    PRTFDW2(ed., lineHeight, charOverhang);
    PRTFDW2(ed., cxSysCharWidth, cySysCharHeight);
    PRTFDWP2(ed., listboxHwnd, pTabStops);
    PRTFDWP1(ed., charWidthBuffer);
//    PRTFDW2(ed., hkl, wMaxNegA);
    PRTFDW1(ed., wMaxNegA);
    PRTFDW2(ed., wMaxNegAcharPos, wMaxNegC);
    PRTFDW2(ed., wMaxNegCcharPos, wLeftMargin);
    PRTFDW2(ed., wRightMargin, ichStartMinSel);
    PRTFDWDWP(ed., ichStartMaxSel, pLpkEditCallout);
    PRTFDWP2(ed., hCaretBitmap, hInstance);
    PRTFDW2(ed., seed, fEncoded);
    PRTFDW2(ed., iLockLevel, wImeStatus);
    return TRUE;
}
#endif // !KERNEL
#endif // OLD_DEBUGGER

#ifndef KERNEL
/************************************************************************\
* Idci
*
* Dumps Client Info
*
* 6/15/1995 Created SanfordS
\************************************************************************/
BOOL Idci(
    VOID)
{
    ULONG64 pteb = 0;

    GetTebAddress(&pteb);
    if (pteb) {
        ULONG pciOffset;

        GetFieldOffset(SYM(TEB), "Win32ClientInfo", &pciOffset);
        InitTypeRead(pteb + pciOffset, CLIENTINFO);

        Print("PCLIENTINFO @ 0x%p:\n", pteb + pciOffset);
        // DWORD dwExpWinVer;
        Print("\tdwExpWinVer            %08lx\n", (ULONG)ReadField(dwExpWinVer));
        // DWORD dwCompatFlags;
        Print("\tdwCompatFlags          %08lx\n", (ULONG)ReadField(dwCompatFlags));
        // DWORD dwTIFlags;
        Print("\tdwTIFlags              %08lx\n", (ULONG)ReadField(dwTIFlags));
        // PDESKTOPINFO pDeskInfo;
        Print("\tpDeskInfo              %p\n",    ReadField(pDeskInfo));
        // ULONG ulClientDelta;
        Print("\tulClientDelta          %p\n",    ReadField(ulClientDelta));
        // struct tagHOOK *phkCurrent;
        Print("\tphkCurrent             %p\n",    ReadField(phkCurrent));
        // DWORD fsHooks;
        Print("\tfsHooks                %08lx\n", (ULONG)ReadField(fsHooks));
        // CALLBACKWND CallbackWnd;
        Print("\tCallbackWnd.hwnd       %p\n",    ReadField(CallbackWnd.hwnd));
        // DWORD cSpins;
        Print("\tcSpins                 %08lx\n", (ULONG)ReadField(cSpins));
        Print("\tCodePage               %d\n",    (ULONG)ReadField(CodePage));

    } else {
        Print("Unable to get TEB info.\n");
    }
    return TRUE;
}
#endif // !KERNEL

#ifdef KERNEL
/************************************************************************\
* Idpi
*
* Dumps ProcessInfo structs
*
* 6/9/1995 Created SanfordS
\************************************************************************/
ULONG
dpiCallback(
    ULONG64 ppi,
    PVOID   Data)
{
    UNREFERENCED_PARAMETER(Data);

    Idpi(0, ppi);
    Print("\n");

    return FALSE;
}

BOOL Idpi(
    DWORD opts,
    ULONG64 param1)
{
    ULONG64 pW32Process;
    ULONG64 ppi;
    ULONG64 pEProcess;
    ULONG64 pdv;
    ULONG64 ulUniqueProcessId;

    /*
     * If he just wants the current process, locate it.
     */
    if (opts & OFLAG(c)) {
        Print("Current Process:\n");
        GetCurrentProcessAddr(dwProcessor, 0, &param1);

        if (param1 == 0) {
            Print("Unable to get current process pointer.\n");
            return FALSE;
        }

        if (GetFieldValue(param1, "nt!EPROCESS", "Win32Process", pW32Process)) {
            Print("Unable to read _EPROCESS at %p\n", param1);
            return FALSE;
        }
        param1 = pW32Process;
    } else if (param1 == 0) {
        Print("**** NT ACTIVE WIN32 PROCESSINFO DUMP ****\n");
        ForEachPpi(dpiCallback, NULL);
        return TRUE;
    }

    ppi = FIXKP(param1);

    if (GetFieldValue(ppi, SYM(PROCESSINFO), "Process", pEProcess)) {
        Print("Can't get PROCESSINFO from %p.\n", ppi);
        return FALSE;
    }

    if (GetFieldValue(pEProcess, "nt!EPROCESS", "UniqueProcessId", ulUniqueProcessId)) {
        Print("Unable to read _EPROCESS at %p\n", pEProcess);
        return FALSE;
    }

    Print("---PPROCESSINFO @ 0x%p for process 0x%p (%s):\n",
            ppi,
            ulUniqueProcessId,
            ProcessName(ppi));
    InitTypeRead(ppi, PROCESSINFO);
    Print("\tppiNext           0x%p\n", ReadField(ppiNext));
    Print("\trpwinsta          0x%p\n", ReadField(rpwinsta));
    Print("\thwinsta           0x%p\n", ReadField(hwinsta));
    Print("\tamwinsta          0x%08lx\n", (ULONG)ReadField(amwinsta));
    Print("\tptiMainThread     0x%p\n", ReadField(ptiMainThread));
    Print("\tcThreads          0x%08lx\n", (ULONG)ReadField(cThreads));
    Print("\trpdeskStartup     0x%p\n", ReadField(rpdeskStartup));
    Print("\thdeskStartup      0x%p\n", ReadField(hdeskStartup));
    Print("\tpclsPrivateList   0x%p\n", ReadField(pclsPrivateList));
    Print("\tpclsPublicList    0x%p\n", ReadField(pclsPublicList));
    Print("\tflags             %s\n",
            GetFlags(GF_W32PF, (DWORD)ReadField(W32PF_Flags), NULL, TRUE));
    Print("\tdwHotkey          0x%08lx\n", (ULONG)ReadField(dwHotkey));
    Print("\tpWowProcessInfo   0x%p\n", ReadField(pwpi));
    Print("\tluidSession       0x%08lx:0x%08lx\n", (ULONG)ReadField(luidSession.HighPart),
            (ULONG)ReadField(luidSession.LowPart));
    Print("\tdwX,dwY           (0x%x, 0x%x)\n", (ULONG)ReadField(usi.dwX), (ULONG)ReadField(usi.dwY));
    Print("\tdwXSize,dwYSize   (0x%x, 0x%x)\n", (ULONG)ReadField(usi.dwXSize), (ULONG)ReadField(usi.dwYSize));
    Print("\tdwFlags           0x%08x\n", (ULONG)ReadField(usi.dwFlags));
    Print("\twShowWindow       0x%04x\n", (ULONG)ReadField(usi.wShowWindow));
    Print("\tpCursorCache      0x%p\n", ReadField(pCursorCache));
    Print("\tdwLpkEntryPoints  %s\n",
            GetFlags(GF_LPK, (DWORD)ReadField(dwLpkEntryPoints), NULL, TRUE));

    /*
     * List desktop views
     */
    pdv = ReadField(pdvList);
    Print("Desktop views:\n");
    while (pdv != 0) {
        InitTypeRead(pdv, DESKTOPVIEW);
        Print("\tpdesk = %p, ulClientDelta = %p\n", ReadField(pdesk), ReadField(ulClientDelta));
        pdv = ReadField(pdvNext);
    }

    return TRUE;
}
#endif // KERNEL

#ifdef KERNEL
/***************************************************************************\
* dpm - dump popupmenu
*
* dpm address    - dumps menu info for menu at address
*
* 02/13/1995 JohnC      Created.
* 06/09/1995 SanfordS   Made to fit stdexts motif.
\***************************************************************************/
BOOL Idpm(
    DWORD opts,
    ULONG64 ppopupmenu)
{
    UNREFERENCED_PARAMETER(opts);

    ppopupmenu = FIXKP(ppopupmenu);

    Print("PPOPUPMENU @ 0x%p\n", ppopupmenu);

    BEGIN_PRTFFLG(ppopupmenu, SYM(POPUPMENU));
    PRTFFLG(fIsMenuBar);
    PRTFFLG(fHasMenuBar);
    PRTFFLG(fIsSysMenu);
    PRTFFLG(fIsTrackPopup);
    PRTFFLG(fDroppedLeft);
    PRTFFLG(fHierarchyDropped);
    PRTFFLG(fRightButton);
    PRTFFLG(fToggle);
    PRTFFLG(fSynchronous);
    PRTFFLG(fFirstClick);
    PRTFFLG(fDropNextPopup);
    PRTFFLG(fNoNotify);
    PRTFFLG(fAboutToHide);
    PRTFFLG(fShowTimer);
    PRTFFLG(fHideTimer);
    PRTFFLG(fDestroyed);
    PRTFFLG(fDelayedFree);
    PRTFFLG(fFlushDelayedFree);
    PRTFFLG(fFreed);
    PRTFFLG(fInCancel);
    PRTFFLG(fTrackMouseEvent);
    PRTFFLG(fSendUninit);
    END_PRTFFLG();

    PRTFDWP2(spwndNotify, spwndPopupMenu);
    PRTFDWP2(spwndNextPopup, spwndPrevPopup);
    PRTFDWP2(spmenu, spmenuAlternate);
    PRTFDWP2(spwndActivePopup, ppopupmenuRoot);
    PRTFDWPDW(ppmDelayedFree, posSelectedItem);
    PRTFDW1(posDropped);

    return TRUE;
}
#endif // KERNEL

#ifdef KERNEL
/***************************************************************************\
* dms - dump pMenuState
*
* dms address
*
* 05-15-96 Created GerardoB
\***************************************************************************/
BOOL Idms(
    DWORD opts,
    ULONG64 param1)
{
    UNREFERENCED_PARAMETER(opts);

    param1 = FIXKP(param1);
    Print("PMENUSTATE @ 0x%p\n", param1);

    BEGIN_PRTFFLG(FIXKP(param1), MENUSTATE);
    PRTFFLG(fMenuStarted);
    PRTFFLG(fIsSysMenu);
    PRTFFLG(fInsideMenuLoop);
    PRTFFLG(fButtonDown);
    PRTFFLG(fInEndMenu);
    PRTFFLG(fUnderline);
    PRTFFLG(fButtonAlwaysDown);
    PRTFFLG(fDragging);
    PRTFFLG(fModelessMenu);
    PRTFFLG(fInCallHandleMenuMessages);
    PRTFFLG(fDragAndDrop);
    PRTFFLG(fAutoDismiss);
    PRTFFLG(fIgnoreButtonUp);
    PRTFFLG(fMouseOffMenu);
    PRTFFLG(fInDoDragDrop);
    PRTFFLG(fActiveNoForeground);
    PRTFFLG(fNotifyByPos);
    END_PRTFFLG();

    PRTFDWP1(pGlobalPopupMenu);
    PRTFPT(ptMouseLast);
    PRTFDW2(mnFocus, cmdLast);
    PRTFDWP1(ptiMenuStateOwner);

    return TRUE;
}
#endif // KERNEL

#ifdef KERNEL
/***************************************************************************\
* dq - dump queue
*
* dq address   - dumps queue structure at address
* dq t address - dumps queue structure at address plus THREADINFO
*
* 06-20-91 ScottLu      Created.
* 11-14-91 DavidPe      Added THREADINFO option.
* 6/9/1995 SanfordS     made to fit stdexts motif
\***************************************************************************/
ULONG
dqCallback(
    ULONG64 pti,
    PVOID   Data)
{
    ULONG64 pq;

    GetFieldValue(pti, SYM(THREADINFO), "pq", pq);
    Idq(PtrToUlong(Data), pq);

    return FALSE;
}

BOOL Idq(
    DWORD opts,
    ULONG64 pq)
{
    char ach[80];

    if (opts & OFLAG(a)) {
        Print("Dumping all queues:\n");

        ForEachPti(dqCallback, ULongToPtr(opts & ~OFLAG(a)));
        return TRUE;
#ifdef SOME_OTHER_DELUSION
        HANDLEENTRY he, *phe;
        int i;


        FOREACHHANDLEENTRY(phe, he, i)
            if (he.bType == TYPE_INPUTQUEUE) {
                Idq(opts & ~OFLAG(a), FIXKP(he.phead));
                Print("\n");
            }
        NEXTEACHHANDLEENTRY()
        return TRUE;
#endif
    }

    if (pq == 0) {
        Print("Dumping foreground queue:\n");
        pq = GetGlobalPointer(VAR(gpqForeground));
        if (pq == 0) {
            Print("no foreground queue (gpqForeground == NULL)!\n");
            return TRUE;
        }
    } else {
        pq = FIXKP(pq);
    }

    /*
     * Print out simple thread info for pq->ptiKeyboard
     */
    _InitTypeRead(pq, SYM(tagQ));
    if (ReadField(ptiKeyboard)) {
        Idt(OFLAG(p), ReadField(ptiKeyboard));
    }

    /*
     * Don't Print() with more than 16 arguments at once because it'll blow
     * up.
     */
    Print("PQ @ 0x%p\n", pq);
    Print(
          "\tmlInput.pqmsgRead      0x%p\n"
          "\tmlInput.pqmsgWriteLast 0x%p\n"
          "\tmlInput.cMsgs          0x%08lx\n",
          ReadField(mlInput.pqmsgRead),
          ReadField(mlInput.pqmsgWriteLast),
          (ULONG)ReadField(mlInput.cMsgs));

    Print("\tptiSysLock             0x%p\n"
          "\tidSysLock              0x%p\n"
          "\tidSysPeek              0x%p\n",
          ReadField(ptiSysLock),
          ReadField(idSysLock),
          ReadField(idSysPeek));

    Print("\tptiMouse               0x%p\n"
          "\tptiKeyboard            0x%p\n",
          ReadField(ptiMouse),
          ReadField(ptiKeyboard));

    Print("\tspcurCurrent           0x%p\n"
          "\tiCursorLevel           0x%08lx\n",
          ReadField(spcurCurrent),
          (ULONG)ReadField(iCursorLevel));

    DebugGetWindowTextA(ReadField(spwndCapture), ach, ARRAY_SIZE(ach));
    Print("\tspwndCapture           0x%p     \"%s\"\n",
          ReadField(spwndCapture), ach);
    DebugGetWindowTextA(ReadField(spwndFocus), ach, ARRAY_SIZE(ach));
    Print("\tspwndFocus             0x%p     \"%s\"\n",
          ReadField(spwndFocus), ach);
    DebugGetWindowTextA(ReadField(spwndActive), ach, ARRAY_SIZE(ach));
    Print("\tspwndActive            0x%p     \"%s\"\n",
          ReadField(spwndActive), ach);
    DebugGetWindowTextA(ReadField(spwndActivePrev), ach, ARRAY_SIZE(ach));
    Print("\tspwndActivePrev        0x%p     \"%s\"\n",
          ReadField(spwndActivePrev), ach);

    Print("\tcodeCapture            0x%04lx\n"
          "\tmsgDblClk              0x%04lx\n"
          "\ttimeDblClk             0x%08lx\n",
          (ULONG)ReadField(codeCapture),
          (ULONG)ReadField(msgDblClk),
          (ULONG)ReadField(timeDblClk));

    Print("\thwndDblClk             0x%p\n",
          ReadField(hwndDblClk));

    Print("\tptDblClk               { %d, %d }\n",
          (ULONG)ReadField(ptDblClk.x),
          (ULONG)ReadField(ptDblClk.y));

    Print("\tQF_flags               0x%08lx %s\n"
          "\tcThreads               0x%08lx\n"
          "\tcLockCount             0x%08lx\n",
          (ULONG)ReadField(QF_flags), GetFlags(GF_QF, (DWORD)ReadField(QF_flags), NULL, FALSE),
          (DWORD) ReadField(cThreads),
          (DWORD) ReadField(cLockCount));

    Print("\tmsgJournal             0x%08lx\n"
          "\tExtraInfo              0x%08lx\n",
          (ULONG)ReadField(msgJournal),
          (ULONG)ReadField(ExtraInfo));

    /*
     * Dump THREADINFO if user specified 't'.
     */
    if (opts & OFLAG(t)) {
        Idti(0, ReadField(ptiKeyboard));
    }
    return TRUE;
}
#endif // KERNEL

/***************************************************************************\
* dsi dump serverinfo struct
*
* 02-27-92 ScottLu      Created.
* 6/9/1995 SanfordS     Made to fit stdexts motif.
\***************************************************************************/
BOOL Idsi(
    DWORD opts)
{
    try {
        ULONG64 psi;
        UINT i;
        char ach[80];
        ULONG64 ulOffset;
        PSERVERINFO pServerInfo;    // dummy for ARRAY_SIZE
        static const char* fnid[FNID_ARRAY_SIZE] = {
            "FNID_SCROLLBAR",               // xxxSBWndProc
            "FNID_ICONTITLE",               // xxxDefWindowProc
            "FNID_MENU",                    // xxxMenuWindowProc
            "FNID_DESKTOP",                 // xxxDesktopWndProc
            "FNID_DEFWINDOWPROC",           // xxxDefWindowProc
            "FNID_MESSAGEWND",              // xxxDefWindowProc
            "FNID_SWITCH",                  // xxxSwitchWndProc

            "FNID_BUTTON",                  // No server side proc
            "FNID_COMBOBOX",                // No server side proc
            "FNID_COMBOLISTBOX",            // No server side proc
            "FNID_DIALOG",                  // No server side proc
            "FNID_EDIT",                    // No server side proc
            "FNID_LISTBOX",                 // No server side proc
            "FNID_MDICLIENT",               // No server side proc
            "FNID_STATIC",                  // No server side proc
            "FNID_IME",                     // No server side proc

            "FNID_HKINLPCWPEXSTRUCT",
            "FNID_HKINLPCWPRETEXSTRUCT",
            "FNID_DEFFRAMEPROC",            // No server side proc
            "FNID_DEFMDICHILDPROC",         // No server side proc
            "FNID_MB_DLGPROC",              // No server side proc
            "FNID_MDIACTIVATEDLGPROC",      // No server side proc
            "FNID_SENDMESSAGE",

            "FNID_SENDMESSAGEFF",
            "FNID_SENDMESSAGEEX",
            "FNID_CALLWINDOWPROC",
            "FNID_SENDMESSAGEBSM",
            "FNID_TOOLTIP",                 // xxxTooltipWndProc
            "FNID_GHOST",                   // xxxGhostWndProc
            "FNID_SENDNOTIFYMESSAGE",
            "FNID_SENDMESSAGECALLBACK",
            "0x2b9",
        };

        psi = GetGlobalPointer(SYM(gpsi));
        if (psi == 0) {
            return TRUE;
        }

        Print("PSERVERINFO @ 0x%p\n", psi);

        _InitTypeRead(psi, SYM(SERVERINFO));

        Print(  "\tRIPFlags                 0x%04lx %s\n", (DWORD)ReadField(wRIPFlags),  GetFlags(GF_RIP, (DWORD)ReadField(wRIPFlags), NULL, FALSE));
        Print(  "\tSRVIFlags                0x%04lx %s\n", (DWORD)ReadField(wSRVIFlags), GetFlags(GF_SRVI, (DWORD)ReadField(wSRVIFlags), NULL, FALSE));
        Print(  "\tPUSIFlags                0x%08lx %s\n", (DWORD)ReadField(PUSIFlags),  GetFlags(GF_SI, (DWORD)ReadField(PUSIFlags), NULL, FALSE));

        Print(  "\tcHandleEntries           0x%08p\n"
                "\tcbHandleTable            0x%08p\n"
                "\tnEvents                  0x%08p\n",
                ReadField(cHandleEntries),
                ReadField(cbHandleTable),
                ReadField(nEvents));

        if (opts & OFLAG(p)) {
            Print("\t" "mpFnidPfn:\n");
            i = 0;
            SAFEWHILE (i < FNID_ARRAY_SIZE) {
                ULONG64 pfn = GetArrayElementPtr(psi, SYM(SERVERINFO), i == 0 ? "mpFnidPfn" : NULL, i);

                GetSym(pfn, ach, &ulOffset);
                Print("%10c%-26s = %p %s", ' ', fnid[i], pfn, ach);
                if (ulOffset) {
                    Print("+0x%x", (DWORD)ulOffset);
                }
                Print("\n");
                ++i;
            }
        }

        if (opts & OFLAG(w)) {
            Print("\t" "aStoCidPfn:\n");
            i = 0;
            SAFEWHILE (i < ARRAY_SIZE(pServerInfo->aStoCidPfn)) {
                ULONG64 pfn = GetArrayElementPtr(psi, SYM(SERVERINFO), i == 0 ? "aStoCidPfn" : NULL, i);

                GetSym(pfn, ach, &ulOffset);
                Print("%10c%-20s = %p %s", ' ', fnid[i], pfn, ach);
                if (ulOffset) {
                    Print("+0x%x", (DWORD)ulOffset);
                }
                Print("\n");
                ++i;
            }
        }

        if (opts & OFLAG(b)) {
            ULONG cbWnd = GetTypeSize(SYM(WND));

            Print("\t" "mpFnid_serverCBWndProc:\n");
            i = 0;
            SAFEWHILE (i < ARRAY_SIZE(pServerInfo->mpFnid_serverCBWndProc)) {
                WORD cb = (WORD)GetArrayElement(psi, SYM(SERVERINFO), i == 0 ? "mpFnid_serverCBWndProc" : NULL, i, "WORD");
                Print("%10c%-26s = %08lx", ' ', fnid[i], cb);
                if (cb) {
                    Print(" = sizeof(WND) + 0x%x", cb - cbWnd);
                }
                Print("\n");
                ++i;
            }
        }

        if (opts & OFLAG(m)) {

            /*
             * Add entries to this table in alphabetical order with
             * the prefix removed.
             */
            static const SYSMET_ENTRY aSysMet[SM_CMETRICS] = {
                SMENTRY(ARRANGE),
                SMENTRY(CXBORDER),
                SMENTRY(CYBORDER),
                SMENTRY(CYCAPTION),
                SMENTRY(CLEANBOOT),
                SMENTRY(CXCURSOR),
                SMENTRY(CYCURSOR),
                SMENTRY(DBCSENABLED),
                SMENTRY(DEBUG),
                SMENTRY(CXDLGFRAME),
                SMENTRY(CYDLGFRAME),
                SMENTRY(CXDOUBLECLK),
                SMENTRY(CYDOUBLECLK),
                SMENTRY(CXDRAG),
                SMENTRY(CYDRAG),
                SMENTRY(CXEDGE),
                SMENTRY(CYEDGE),
                SMENTRY(CXFRAME),
                SMENTRY(CYFRAME),
                SMENTRY(CXFULLSCREEN),
                SMENTRY(CYFULLSCREEN),
                SMENTRY(CXICON),
                SMENTRY(CYICON),
                SMENTRY(CXICONSPACING),
                SMENTRY(CYICONSPACING),
                SMENTRY(IMMENABLED),
                SMENTRY(CYKANJIWINDOW),
                SMENTRY(CXMAXIMIZED),
                SMENTRY(CYMAXIMIZED),
                SMENTRY(CXMAXTRACK),
                SMENTRY(CYMAXTRACK),
                SMENTRY(CYMENU),
                SMENTRY(CXMENUCHECK),
                SMENTRY(CYMENUCHECK),
                SMENTRY(MENUDROPALIGNMENT),
                SMENTRY(CXMENUSIZE),
                SMENTRY(CYMENUSIZE),
                SMENTRY(MIDEASTENABLED),
                SMENTRY(CXMIN),
                SMENTRY(CYMIN),
                SMENTRY(CXMINIMIZED),
                SMENTRY(CYMINIMIZED),
                SMENTRY(CXMINSPACING),
                SMENTRY(CYMINSPACING),
                SMENTRY(CXMINTRACK),
                SMENTRY(CYMINTRACK),
                SMENTRY(CMONITORS),
                SMENTRY(CMOUSEBUTTONS),
                SMENTRY(MOUSEPRESENT),
                SMENTRY(MOUSEWHEELPRESENT),
                SMENTRY(NETWORK),
                SMENTRY(PENWINDOWS),
                SMENTRY(RESERVED1),
                SMENTRY(RESERVED2),
                SMENTRY(RESERVED3),
                SMENTRY(RESERVED4),
                SMENTRY(SAMEDISPLAYFORMAT),
                SMENTRY(CXSCREEN),
                SMENTRY(CYSCREEN),
                SMENTRY(CXVSCROLL),
                SMENTRY(CYHSCROLL),
                SMENTRY(CYVSCROLL),
                SMENTRY(CXHSCROLL),
                SMENTRY(SECURE),
                SMENTRY(SHOWSOUNDS),
                SMENTRY(CXSIZE),
                SMENTRY(CYSIZE),
                SMENTRY(SLOWMACHINE),
                SMENTRY(CYSMCAPTION),
                SMENTRY(CXSMICON),
                SMENTRY(CYSMICON),
                SMENTRY(CXSMSIZE),
                SMENTRY(CYSMSIZE),
                SMENTRY(SWAPBUTTON),
                SMENTRY(CYVTHUMB),
                SMENTRY(CXHTHUMB),
                SMENTRY(UNUSED_64),
                SMENTRY(UNUSED_65),
                SMENTRY(UNUSED_66),
                SMENTRY(XVIRTUALSCREEN),
                SMENTRY(YVIRTUALSCREEN),
                SMENTRY(CXVIRTUALSCREEN),
                SMENTRY(CYVIRTUALSCREEN),
                // Windows 2000
                SMENTRY(CMONITORS),
                SMENTRY(SAMEDISPLAYFORMAT),
                // Whistler
                SMENTRY(SHUTTINGDOWN),
            };

            Print("\taiSysMet:\n");
            i = 0;
            SAFEWHILE (i < SM_CMETRICS) {
                DWORD v = (DWORD)GetArrayElement(psi, SYM(SERVERINFO), i == 0 ? "aiSysMet" : NULL, aSysMet[i].iMetric, "DWORD");
                Print(  "\t\tSM_%-18s = 0x%08lx = %d\n", aSysMet[i].pstrMetric, v, v);
                ++i;
            }
        }
        if (opts & OFLAG(c)) {
            static LPSTR aszSysColor[COLOR_MAX] = {
              //012345678901234567890
                "SCROLLBAR",
                "BACKGROUND",
                "ACTIVECAPTION",
                "INACTIVECAPTION",
                "MENU",
                "WINDOW",
                "WINDOWFRAME",
                "MENUTEXT",
                "WINDOWTEXT",
                "CAPTIONTEXT",
                "ACTIVEBORDER",
                "INACTIVEBORDER",
                "APPWORKSPACE",
                "HIGHLIGHT",
                "HIGHLIGHTTEXT",
                "BTNFACE",
                "BTNSHADOW",
                "GRAYTEXT",
                "BTNTEXT",
                "INACTIVECAPTIONTEXT",
                "BTNHIGHLIGHT",
                "3DDKSHADOW",
                "3DLIGHT",
                "INFOTEXT",
                "INFOBK",
                "3DALTFACE",
                "HOTLIGHT",
                // new in Windows 2000
                "GRADIENTACTIVECAPTION",
                "GRADIENTINACTIVECAPTION",
                "MENUHILIGHT",
                "MENUBAR",
            };
            COLORREF colors[COLOR_MAX];
            COLORREF colorsUnmatched[COLOR_MAX];

            for (i = 0; i < COLOR_MAX; ++i) {
                colors[i] = (COLORREF)GetArrayElement(psi, SYM(SERVERINFO), i == 0 ? "argbSystem" : NULL, i, SYM(COLORREF));
            }

            for (i = 0; i < COLOR_MAX; ++i) {
                colorsUnmatched[i] = (COLORREF)GetArrayElement(psi, SYM(SERVERINFO), i == 0 ? "argbSystemUnmatched" : NULL, i, SYM(COLORREF));
            }

            Print("\targbSystem:\n\t\tCOLOR%28sSYSRGB\t\tUnmatched\tSYSHBR\n", "");
            i = 0;
            SAFEWHILE (i < COLOR_MAX) {
                Print("\t\tCOLOR_%-25s: (%02x,%02x,%02x)\t(%02x,%02x,%02x)\t0x%08p\n",
                      aszSysColor[i],
                      GetRValue(colors[i]), GetGValue(colors[i]), GetBValue(colors[i]),
                      GetRValue(colorsUnmatched[i]), GetGValue(colorsUnmatched[i]), GetBValue(colorsUnmatched[i]),
                      (KHBRUSH)GetArrayElement(psi, SYM(SERVERINFO), i == 0 ? "ahbrSystem" : NULL, i, SYM(KHBRUSH)));
                ++i;
            }
        }

        if (opts & OFLAG(o)) {
    #if 0   // LATER
            OEMBITMAPINFO oembmi[OBI_COUNT];

            for (i = 0; i < OBI_COUNT; ++i) {

            }

            Print("\toembmi @ 0x%p:\n\t\tx       \ty       \tcx       \tcy\n", &psi->oembmi);
            for (i = 0; i < OBI_COUNT; i++) {
                Print("\tbm[%d]:\t%08x\t%08x\t%08x\t%08x\n",
                        i,
                        si.oembmi[i].x ,
                        si.oembmi[i].y ,
                        si.oembmi[i].cx,
                        si.oembmi[i].cy);
            }
    #else
            Print("\tOEMINFO:\n");
    #endif
            _InitTypeRead(psi, SYM(SERVERINFO));

            Print(
                    "\t\tPlanes             = %d\n"
                    "\t\tBitsPixel          = %d\n"
                    "\t\tBitCount           = %d\n"
                    "\t\tdmLogPixels        = %d\n"
                    "\t\trcScreen           = (%d,%d)-(%d,%d) %dx%d\n"
                    ,
                    (BYTE)ReadField(Planes)           ,
                    (BYTE)ReadField(BitsPixel)        ,
                    (WORD)ReadField(BitCount)         ,
                    (UINT)ReadField(dmLogPixels),
                    (LONG)ReadField(rcScreen.left), (LONG)ReadField(rcScreen.top),
                        (LONG)ReadField(rcScreen.right), (LONG)ReadField(rcScreen.bottom),
                    (LONG)ReadField(rcScreen.right)-(LONG)ReadField(si.rcScreen.left),
                        (LONG)ReadField(rcScreen.bottom)-(LONG)ReadField(si.rcScreen.top));

        }

        if (opts & OFLAG(v)) {
            ULONG ulOffsetTmp; // req

            GetFieldOffset(SYM(SERVERINFO), "tmSysFont", &ulOffsetTmp);
            Print(
                    "\tptCursor                 {%d, %d}\n"
                    "\tgclBorder                0x%08lx\n"
                    "\tdtScroll                 0x%08lx\n"
                    "\tdtLBSearch               0x%08lx\n"
                    "\tdtCaretBlink             0x%08lx\n"
                    "\tdwDefaultHeapBase        0x%08lx\n"
                    "\tdwDefaultHeapSize        0x%08lx\n"
                    "\twMaxLeftOverlapChars     0x%08lx\n"
                    "\twMaxRightOverlapchars    0x%08lx\n"
                    "\tuiShellMsg               0x%08lx\n"
                    "\tcxSysFontChar            0x%08lx\n"
                    "\tcySysFontChar            0x%08lx\n"
                    "\tcxMsgFontChar            0x%08lx\n"
                    "\tcyMsgFontChar            0x%08lx\n"
                    "\ttmSysFont                0x%p\n"
                    "\tatomIconSmProp           0x%04lx\n"
                    "\tatomIconProp             0x%04lx\n"
                    "\thIconSmWindows           0x%08lp\n"
                    "\thIcoWindows              0x%08lp\n"
                    "\thCaptionFont             0x%08lp\n"
                    "\thMsgFont                 0x%08lp\n"
                    "\tatomContextHelpIdProp    0x%08lx\n",
                    (LONG)ReadField(ptCursor.x),
                    (LONG)ReadField(ptCursor.y),
                    (int)ReadField(gclBorder),
                    (UINT)ReadField(dtScroll),
                    (UINT)ReadField(dtLBSearch),
                    (UINT)ReadField(dtCaretBlink),
                    (DWORD)ReadField(dwDefaultHeapBase),
                    (DWORD)ReadField(dwDefaultHeapSize),
                    (int)ReadField(wMaxLeftOverlapChars),
                    (int)ReadField(wMaxRightOverlapChars),
                    (UINT)ReadField(uiShellMsg),
                    (int)ReadField(cxSysFontChar),
                    (int)ReadField(cySysFontChar),
                    (int)ReadField(cxMsgFontChar),
                    (int)ReadField(cyMsgFontChar),
                    psi + ulOffsetTmp,
                    (ATOM)ReadField(atomIconSmProp),
                    (ATOM)ReadField(atomIconProp),
                    ReadField(hIconSmWindows),
                    ReadField(hIcoWindows),
                    ReadField(hCaptionFont),
                    ReadField(hMsgFont),
                    (ATOM)ReadField(atomContextHelpIdProp));
        }

        if (opts & OFLAG(h)) {
            ULONG64 pshi = 0;

            pshi = EvalExp(VAR(gSharedInfo));
            if (pshi == 0) {
                return TRUE;
            }
            _InitTypeRead(pshi, SYM(SHAREDINFO));
            Print("\nSHAREDINFO @ 0x%p:\n", pshi);
            Print("\taheList                  0x%p\n", ReadField(aheList));
        }
    } except (CONTINUE) {
    }

    return TRUE;
}

#ifdef KERNEL
/***************************************************************************\
* dsms - dump send message structures
*
* dsms           - dumps all send message structures
* dsms v         - dumps all verbose
* dsms address   - dumps specific sms
* dsms v address - dumps verbose
* dsms l [address] - dumps sendlist of sms
*
*
* 06-20-91 ScottLu      Created.
* 6/9/1995 SanfordS     made to fit stdexts motif
\***************************************************************************/
BOOL Idsms(
    DWORD opts,
    ULONG64 param1)
{
    ULONG64 psms;
    ULONG offsetPsmsNext;
    ULONG offsetSender;
    ULONG offsetReceiver;
    UINT c = 0;
    UINT cm = 0;

    GetFieldOffset(SYM(tagSMS), "psmsNext", &offsetPsmsNext);
    GetFieldOffset(SYM(tagSMS), "ptiSender", &offsetSender);
    GetFieldOffset(SYM(tagSMS), "ptiReceiver", &offsetReceiver);

    if ((opts & (OFLAG(m) | OFLAG(s) | OFLAG(r))) || (param1 == 0)) {
        psms = GetGlobalPointer(VAR(gpsmsList));

        if (psms == NULL_POINTER) {
            Print("No send messages currently in the list.\n");
            return TRUE;
        }

        if (opts & OFLAG(c)) {
            UINT i = 0;

            // just count the messages
            SAFEWHILE (psms != 0) {
                UINT cPrev = c;

                if ((i++ & 0xf) == 0) {
                    ShowProgress(i >> 4);
                }
                if (opts & OFLAG(s)) {
                    if (GetPointer(psms + offsetSender) == param1) {
                        ++c;
                    }
                } else if (opts & OFLAG(r)) {
                    if (GetPointer(psms + offsetReceiver) == param1) {
                        ++c;
                    }
                } else {
                    ++c;
                }

                if (c != cPrev && (c % 400) == 0) {
                    Print("%d (0x%lx)...\n", c, c);
                }
                psms = GetPointer(psms + offsetPsmsNext);
            }
        } else if (opts & OFLAG(m)) {
            // show messages with msg == param1
            SAFEWHILE (psms != NULL_POINTER) {
                UINT uMsg;

                c++;
                //move(sms, psms);
                GetFieldValue(psms, SYM(tagSMS), "UINT", uMsg);
                if (uMsg == (UINT)param1) {
                    cm++;
                    Idsms(opts & ~OFLAG(m), psms);
                }
                psms = GetPointer(psms + offsetPsmsNext);
            }
            Print("%d messages == 0x%x (out of a total of %d).\n", cm, (UINT)param1, c);
            return TRUE;
        } else {
            SAFEWHILE (psms != NULL_POINTER) {
                if (param1 == NULL_POINTER ||
                        ((opts & OFLAG(s)) && GetPointer(psms + offsetSender) == param1) ||
                        ((opts & OFLAG(r)) && GetPointer(psms + offsetReceiver) == param1)) {
                    c++;
                    DEBUGPRINT("calling Idsms(opts=%x, psms=%p)\n", opts, psms);
                    if (!Idsms(opts & ~(OFLAG(s) | OFLAG(r)), psms)) {
                        DEBUGPRINT("error!\n");
                        Print("%d (0x%lx) messages.\n", c, c);
                        return FALSE;
                    }
                }
                psms = GetPointer(psms + offsetPsmsNext);
            }
        }
        Print("%d (0x%lx) messages.\n", c, c);
        return TRUE;
    }

    psms = param1;

    Print("PSMS @ 0x%p\n", psms);
    _InitTypeRead(psms, SYM(tagSMS));

    Print("SEND: ");
    if (ReadField(ptiSender) != NULL_POINTER) {
        Idt(OFLAG(p), ReadField(ptiSender));
    } else if (ReadField(ptiCallBackSender) != NULL_POINTER) {
        Print("*");
        Idt(OFLAG(p), ReadField(ptiCallBackSender));
    } else {
        Print("NULL\n");
    }

    Print("RECV:");
    if (ReadField(ptiReceiver) != NULL_POINTER) {
        Print(" ");
        Idt(OFLAG(p), ReadField(ptiReceiver));
    } else {
        Print("NULL\n");
    }

    if (opts & OFLAG(v)) {
        char ach[80];

        Print("\tpsmsNext           0x%08p\n"
              "\tpsmsSendList       0x%08p (chk only)\n"
              "\tpsmsSendNext       0x%08p (chk only)\n"
              "\tpsmsReceiveNext    0x%08p\n"
              "\ttSent              0x%08lx\n"
              "\tptiSender          0x%08p\n"
              "\tptiCallBackSender  0x%08p\n"
              "\tptiReceiver        0x%08p\n"
              "\tlRet               0x%08p\n"
              "\tflags              %s\n"
              "\twParam             0x%08p\n"
              "\tlParam             0x%08p\n"
              "\tmessage            0x%08lx\n",
              ReadField(psmsNext),
              IsChk() ? ReadField(psmsSendList) : NULL_POINTER,
              IsChk() ? ReadField(psmsSendNext) : NULL_POINTER,
              ReadField(psmsReceiveNext),
              (DWORD)ReadField(tSent),
              ReadField(ptiSender),
              ReadField(ptiCallBackSender),
              ReadField(ptiReceiver),
              ReadField(lRet),
              GetFlags(GF_SMS, (WORD)ReadField(flags), NULL, TRUE),
              ReadField(wParam),
              ReadField(lParam),
              (DWORD)ReadField(message));
        DebugGetWindowTextA(ReadField(spwnd), ach, ARRAY_SIZE(ach));
        Print("\tspwnd              0x%08p     \"%s\"\n", ReadField(spwnd), ach);
    } else if (opts & OFLAG(w)) {
        // a bit of verbose
        char ach[80];

        DebugGetWindowTextA(ReadField(spwnd), ach, ARRAY_SIZE(ach));

        Print("  MSG: %08lx %08p %08p / lRet: %08p / tSend: %08lx\n",
              (DWORD)ReadField(message), ReadField(wParam), ReadField(lParam),
              ReadField(lRet), (DWORD)ReadField(tSent));
        Print("  pwnd: %p \"%s\"\n", ReadField(spwnd), ach);
    }

#ifdef LATER
    if (IsChk()) {
        if (opts & OFLAG(l)) {
            DWORD idThread;
            ULONG64 psmsList;   // PSMS
            DWORD idThreadSender, idThreadReceiver;
            CLIENT_ID Cid;

            psmsList = ReadField(psmsSendList);
            if (psmsList == NULL_POINTER) {
                Print("%p : Empty List\n", psms);
            } else {
                Print("%p : [tidSender](msg)[tidReceiver]\n", psms);
            }
            SAFEWHILE (psmsList != NULL_POINTER) {
                ULONG64 ptiSender;
                //move(sms, psmsList);
                GetFieldValue(psmsList, SYM(tagSMS), ptiSender, ptiSender);
                if (ptiSender == NULL_POINTER) {
                    idThread = 0;
                } else {
                    ULONG64 pEThread;

                    GetFieldValue(ptiSender, SYM(THREADINFO), "pEThread", pETHread);

                    // up to here
                    GetEThreadData(ti.pEThread, EThreadCid, &Cid);
                    idThreadSender = PtrToUlong(Cid.UniqueThread);
                }
                if (sms.ptiReceiver == NULL_POINTER) {
                    idThread = 0;
                } else {
                    move(ti, sms.ptiReceiver);
                    GetEThreadData(ti.pEThread, EThreadCid, &Cid);
                    idThreadReceiver = PtrToUlong(Cid.UniqueThread);
                }
                Print("%p : [%x](%x)[%x]\n", psmsList, idThreadSender, sms.message,
                        idThreadReceiver);

                if (psmsList == sms.psmsSendNext) {
                    Print("Loop in list?\n");
                    return FALSE;
                }

                psmsList = sms.psmsSendNext;
            }
            Print("\n");
        }
    }
#endif
    return TRUE;
}
#endif // KERNEL


#ifdef KERNEL
/***************************************************************************\
* dt - dump thread
*
* dt            - dumps simple thread info of all threads which have queues
*                 on server
* dt v          - dumps verbose thread info of all threads which have queues
*                 on server
* dt id         - dumps simple thread info of single server thread id
* dt v id       - dumps verbose thread info of single server thread id
*
* 06-20-91 ScottLu      Created.
* 6/9/1995 SanfordS     made to fit stdexts motif
\***************************************************************************/
BOOL DumpThread(
    DWORD opts,
    ULONG64 pEThread)
{
    WCHAR ach[256];
    ULONG64 pq;
    ULONG64 ppi;
    ULONG64 pEThreadT;
    ULONG64 pti = 0;
    ULONG64 pcti;
    CLIENTTHREADINFO cti;
    ULONG64 psms;
    ULONG64 ProcessId;
    ULONG64 pEProcess;
    ULONG64 ThreadId;

    GetFieldValue(pEThread, "nt!ETHREAD", "Tcb.Win32Thread", pti);
    GetFieldValue(pEThread, "nt!ETHREAD", "Cid.UniqueProcess", ProcessId);
    GetFieldValue(pEThread, "nt!ETHREAD", "Cid.UniqueThread", ThreadId);
    if (GetFieldValue(pti, "win32k!W32THREAD", "pEThread", pEThreadT)) {
        if (!(opts & OFLAG(g))) {
            Print("  et 0x%p t 0x???????? q 0x???????? i %2x.%-3lx <unknown name>\n",
                pEThread,
                (ULONG)ProcessId,
                (ULONG)ThreadId);
        }
        return TRUE;
    }

    if (pEThreadT != pEThread || pti == 0) {
        return FALSE;
    } else { // Good thread

        /*
         * Print out simple thread info if this is in simple mode. Print
         * out queue info if in verbose mode (printing out queue info
         * also prints out simple thread info).
         */
        if (!(opts & OFLAG(v))) {
            PWCHAR pwch;

            GetAppName(pEThread, pti, ach, sizeof(ach));
            pwch = wcsrchr(ach, L'\\');
            if (pwch == NULL_POINTER) {
                pwch = ach;
            } else {
                pwch++;
            }

            GetFieldValue(pti, SYM(THREADINFO), "pq", pq);
            GetFieldValue(pti, SYM(THREADINFO), "ppi", ppi);
            GetFieldValue(pEThread, "nt!ETHREAD", "ThreadsProcess", pEProcess);
            Print("  s %-2d et 0x%p t 0x%p q 0x%p ppi 0x%p i %2x.%-3lx %ws\n",
                    GetProcessSessionId(pEProcess),
                    pEThread,
                    pti,
                    pq,
                    ppi,
                    (ULONG)ProcessId,
                    (ULONG)ThreadId,
                    pwch);

            /*
             * Dump thread input state if required
             */
            if (opts & OFLAG(s)) {
                #define DT_INDENT "\t"
                GetFieldValue(pti, SYM(THREADINFO), "pcti", pcti);
                move(cti, pcti);

                if (cti.fsWakeMask == 0) {
                    Print(DT_INDENT "Not waiting for USER input events.\n");
                } else if ((cti.fsWakeMask & (QS_ALLINPUT | QS_EVENT)) == (QS_ALLINPUT | QS_EVENT)) {
                    Print(DT_INDENT "Waiting for any USER input event (== in GetMessage).\n");
                } else if ((cti.fsWakeMask == (QS_SMSREPLY | QS_SENDMESSAGE))
                            || (cti.fsWakeMask == QS_SMSREPLY)) {
                    GetFieldValue(pti, SYM(THREADINFO), "psmsSent", psms);
                    InitTypeRead(psms, SMS);
                    Print(DT_INDENT "Waiting on thread 0x%p to reply to this SendMessage:\n", ReadField(ptiReceiver));
                    Print(DT_INDENT "pwnd:0x%p message:%#lx wParam:0x%p lParam:0x%p\n",
                            ReadField(pwnd), (UINT)ReadField(message), ReadField(wParam), ReadField(lParam));
                    if (cti.fsChangeBits & QS_SMSREPLY) {
                        Print(DT_INDENT "The receiver thread has replied to the message.\n");
                    }
                } else {
                    Print(DT_INDENT "Waiting for: %s\n",
                                      GetFlags(GF_QS, (WORD)cti.fsWakeMask, NULL, TRUE));
                }
            }

        } else {
            Idti(0, pti);
            Print("--------\n");
        }
    }
    return TRUE;
}

typedef struct _THREAD_DUMP_CONTEXT {
    DWORD opts;
    ULONG64 ThreadToDump;
} THREAD_DUMP_CONTEXT;

ULONG
DumpThreadsCallback (
    PFIELD_INFO   NextThread,
    PVOID         Context)
{
    ULONG64 pEThread = NextThread->address;
    ULONG64 ThreadId;
    THREAD_DUMP_CONTEXT *pTDC = (THREAD_DUMP_CONTEXT *)Context;

    ULONG64 UserProbeAddress;
    ULONG Result;

    //
    // Read the user probe address from the target system.
    //
    // N.B. The user probe address is constant on MIPS, Alpha, and the PPC.
    //      On the x86, it may not be defined for the target system if it
    //      does not contain the code to support 3gb of user address space.
    //

    UserProbeAddress = GetExpression("nt!MmUserProbeAddress");
    if ((UserProbeAddress == 0) ||
        (ReadMemory(UserProbeAddress,
                    &UserProbeAddress,
                    sizeof(UserProbeAddress),
                    &Result) == FALSE)) {
        UserProbeAddress = 0x7fff0000;
    }

    /*
     * ThreadToDump is either 0 (all windows threads) or its
     * a TID ( < UserProbeAddress or its a pEThread.
     */
    GetFieldValue(pEThread, "nt!ETHREAD", "Cid.UniqueThread", ThreadId);
    if (pTDC->ThreadToDump == 0 ||

            (pTDC->ThreadToDump < UserProbeAddress &&
                pTDC->ThreadToDump == ThreadId) ||

            (pTDC->ThreadToDump >= UserProbeAddress &&
                pTDC->ThreadToDump == pEThread)) {

        if (!DumpThread(pTDC->opts, pEThread) && pTDC->ThreadToDump != 0) {
            Print("Sorry, EThread %p is not a Win32 thread.\n",
                    pEThread);
        }

        if (pTDC->ThreadToDump != 0) {
            return TRUE;
        }


    } // Chosen Thread

   return FALSE;
}

VOID DumpProcessThreads(
    DWORD opts,
    ULONG64 pEProcess,
    ULONG64 ThreadToDump)
{
    ULONG64 pW32Process;
    ULONG64 NextThread;
    THREAD_DUMP_CONTEXT TDC = {
        opts,
        ThreadToDump
    };

    /*
     * Dump threads of Win32 Processes only
     */
    if ((GetFieldValue(pEProcess, "nt!EPROCESS", "Win32Process", pW32Process))
            || (pW32Process == 0)) {
        return;
    }

    GetFieldValue(pEProcess, "nt!EPROCESS", "Pcb.ThreadListHead.Flink", NextThread);

    ListType("nt!ETHREAD", NextThread, 1, "Tcb.ThreadListEntry.Flink", &TDC, DumpThreadsCallback);
}

ULONG
DumpProcessThreadsCallback (
    PFIELD_INFO   NextProcess,
    PVOID         Context)
{
    THREAD_DUMP_CONTEXT *pTDC = (THREAD_DUMP_CONTEXT *)Context;

    DumpProcessThreads(pTDC->opts, NextProcess->address, pTDC->ThreadToDump);

    return FALSE;
}

BOOL Idt(
    DWORD opts,
    ULONG64 param1)
{
    ULONG64 ThreadToDump;
    ULONG64 NextProcess;
    ULONG64 ProcessHead;
    ULONG64 pEThread;
    ULONG64 pti;
    THREAD_DUMP_CONTEXT TDC;

    ThreadToDump = param1;

    /*
     * If its a pti, validate it, and turn it into and idThread.
     */
    if (opts & OFLAG(p)) {
        if (!param1) {
            Print("Expected a pti parameter.\n");
            return FALSE;
        }

        pti = FIXKP(param1);

        if (pti == 0) {
            Print("WARNING: bad pti given!\n");
            pti = param1;
        } else {
            GetFieldValue(pti, SYM(tagTHREADINFO), "pEThread", pEThread);
            if (!DumpThread(opts, pEThread)) {
                /*
                 * This thread either doesn't have a pti or something
                 * is whacked out.  Just skip it if we want all
                 * threads.
                 */
                Print("Sorry, EThread %p is not a Win32 thread.\n",
                        pEThread);
                return FALSE;
            }
            return TRUE;
        }
    }

    /*
     * If he just wants the current thread, located it.
     */
    if (opts & OFLAG(c)) {
        Print("Current Thread:");
        GetCurrentThreadAddr(dwProcessor, &ThreadToDump);

        if (ThreadToDump == 0) {
            Print("Unable to get current thread pointer.\n");
            return FALSE;
        }
        pEThread = ThreadToDump;
        if (!DumpThread(opts, pEThread)) {
            /*
             * This thread either doesn't have a pti or something
             * is whacked out. Just skip it if we want all
             * threads.
             */
            Print("Sorry, EThread %p is not a Win32 thread.\n",
                    pEThread);
            return FALSE;
        }
        return TRUE;
    /*
     * else he must want all window threads.
     */
    } else if (ThreadToDump == 0) {
        Print("**** NT ACTIVE WIN32 THREADINFO DUMP ****\n");
    }

    ProcessHead = EvalExp("PsActiveProcessHead");
    if (!ProcessHead) {
        Print("Unable to get value of PsActiveProcessHead\n");
        return FALSE;
    }

    if (GetFieldValue(ProcessHead, "nt!LIST_ENTRY", "Flink", NextProcess)) {
        Print("Unable to get value of PsActiveProcessHead\n");
        return FALSE;
    }
    if (NextProcess == 0) {
        Print("PsActiveProcessHead->Flink is NULL!\n");
        return FALSE;
    }

    TDC.opts = opts;
    TDC.ThreadToDump = ThreadToDump;
    ListType("nt!EPROCESS", NextProcess, 1, "ActiveProcessLinks.Flink", &TDC, DumpProcessThreadsCallback);

    if (opts & OFLAG(c)) {
        Print("%p is not a windows thread.\n", ThreadToDump);
    }

    return TRUE;
}
#endif // KERNEL

#ifdef KERNEL
/***************************************************************************\
* dp - dump process
*
*
* 06-27-97 GerardoB     Created.
\***************************************************************************/


BOOL DumpProcess(
    DWORD opts,
    ULONG64 pEProcess)
{
    WCHAR ach[256];
    ULONG W32PF_Flags;
    ULONG64 ppi;
    ULONG ulSessionId;
    ULONG64 ulUniqueProcessId;
    ULONG64 pEProcessT;

    GetFieldValue(pEProcess, "nt!EPROCESS", "Win32Process", ppi);
    GetFieldValue(pEProcess, "nt!EPROCESS", "UniqueProcessId", ulUniqueProcessId);
    _GetProcessSessionId(pEProcess, &ulSessionId);

    if (GetFieldValue(ppi, "win32k!W32PROCESS", "Process", pEProcessT)) {
        Print("sid %2d ep 0x%p p 0x???????? f 0x???????? i %3I64x <unknown name>\n",
                ulSessionId,
                pEProcess,
                ulUniqueProcessId);
        return TRUE;
    }

    if (pEProcessT != pEProcess || ppi == 0) {
        return FALSE;
    } else { // Good process
        /*
         * Print out simple process info if this is in simple mode.
         */
        if (!(opts & OFLAG(v))) {
            PWCHAR pwch;

            GetProcessName(pEProcess, ach);
            pwch = wcsrchr(ach, L'\\');
            if (pwch == NULL) {
                pwch = ach;
            } else {
                pwch++;
            }

            GetFieldValue(ppi, "win32k!W32PROCESS", "W32PF_Flags", W32PF_Flags);
            Print("sid %2d ep 0x%p p 0x%p f 0x%08lx i %3I64x %ws\n",
                    ulSessionId,
                    pEProcess,
                    ppi,
                    W32PF_Flags,
                    ulUniqueProcessId,
                    pwch);
        } else {
            Idpi(0, ppi);
            Print("--------\n");
        }

        /*
         * Dump all threads if required
         */
        if (opts & OFLAG(t)) {
            DumpProcessThreads(opts, pEProcess, 0);
        }
    }
    return TRUE;
}

typedef struct _PROCESS_DUMP_CONTEXT {
    DWORD opts;
    ULONG64 ProcessToDump;
} PROCESS_DUMP_CONTEXT;

ULONG
DumpProcessCallback(
    PFIELD_INFO   NextProcess,
    PVOID         Context)
{
    ULONG64 pEProcess = NextProcess->address;
    ULONG64 pW32Process;
    ULONG64 ulUniqueProcessId;
    PROCESS_DUMP_CONTEXT *pPDC = (PROCESS_DUMP_CONTEXT *)Context;

    ULONG64 UserProbeAddress;
    ULONG Result;

    //
    // Read the user probe address from the target system.
    //
    // N.B. The user probe address is constant on MIPS, Alpha, and the PPC.
    //      On the x86, it may not be defined for the target system if it
    //      does not contain the code to support 3gb of user address space.
    //

    UserProbeAddress = GetExpression("nt!MmUserProbeAddress");
    if ((UserProbeAddress == 0) ||
        (ReadMemory(UserProbeAddress,
                    &UserProbeAddress,
                    sizeof(UserProbeAddress),
                    &Result) == FALSE)) {
        UserProbeAddress = 0x7fff0000;
    }

    /*
     * Dump threads of Win32 Processes only
     */
    if (GetFieldValue(pEProcess, "nt!EPROCESS", "Win32Process", pW32Process) || pW32Process == 0) {
        return FALSE;
    }

    GetFieldValue(pEProcess, "nt!EPROCESS", "UniqueProcessId", ulUniqueProcessId);
    /*
     * ProcessToDump is either 0 (all windows processes) or its
     * a TID ( < UserProbeAddress or its a pEPRocess.
     */
    if (pPDC->ProcessToDump == 0 ||

            (pPDC->ProcessToDump < UserProbeAddress &&
                pPDC->ProcessToDump == ulUniqueProcessId) ||

            (pPDC->ProcessToDump >= UserProbeAddress &&
                pPDC->ProcessToDump == pEProcess)) {

        if (!DumpProcess(pPDC->opts, pEProcess) && (pPDC->ProcessToDump != 0)) {
            Print("Sorry, EProcess %p is not a Win32 process.\n",
                    pEProcess);
        }

        if (pPDC->ProcessToDump != 0) {
            return TRUE;
        }
    }

    return FALSE;
}

BOOL Idp(
    DWORD opts,
    ULONG64 param1)
{
    ULONG64 ProcessToDump;
    ULONG64 ppi;
    ULONG64 pEProcess;
    ULONG64 NextProcess;
    ULONG64 ProcessHead;
    PROCESS_DUMP_CONTEXT PDC;

    ProcessToDump = param1;

    /*
     * If it's a ppi, validate it.
     */
    if (opts & OFLAG(p)) {
        if (!param1) {
            Print("Expected a ppi parameter.\n");
            return FALSE;
        }

        ppi = FIXKP(param1);

        if (ppi == 0) {
            Print("WARNING: bad ppi given!\n");
            ppi = param1;
        } else {
            GetFieldValue(ppi, "win32k!W32PROCESS", "Process", pEProcess);
            if (!DumpProcess(opts, pEProcess)) {
                Print("EProcess %p is not a Win32 process.\n", pEProcess);
                return FALSE;
            }
            return TRUE;
        }
    }

    /*
     * If he just wants the current process, locate it.
     */
    if (opts & OFLAG(c)) {
        Print("Current Process: ");
        GetCurrentProcessAddr(dwProcessor, 0, &ProcessToDump);

        if (ProcessToDump == 0) {
            Print("Unable to get current process pointer.\n");
            return FALSE;
        }
        pEProcess = ProcessToDump;
        if (!DumpProcess(opts, pEProcess)) {
            Print("Sorry, EProcess %p is not a Win32 process.\n", pEProcess);
            return FALSE;
        }
        return TRUE;
    /*
     * else he must want all window threads.
     */
    } else if (ProcessToDump == 0) {
        Print("**** NT ACTIVE WIN32 PROCESSINFO DUMP ****\n");
    }

    ProcessHead = EvalExp("PsActiveProcessHead");
    if (!ProcessHead) {
        Print("Unable to get value of PsActiveProcessHead\n");
        return FALSE;
    }

    if (GetFieldValue(ProcessHead, "nt!LIST_ENTRY", "Flink", NextProcess)) {
        Print("Unable to get value of PsActiveProcessHead\n");
        return FALSE;
    }
    if (NextProcess == 0) {
        Print("PsActiveProcessHead->Flink is NULL!\n");
        return FALSE;
    }

    PDC.opts = opts;
    PDC.ProcessToDump = ProcessToDump;
    ListType("nt!EPROCESS", NextProcess, 1, "ActiveProcessLinks.Flink", &PDC, DumpProcessCallback);

    if (opts & OFLAG(c)) {
        Print("%p is not a windows process.\n", ProcessToDump);
    }

    return TRUE;
}
#endif // KERNEL



#ifdef KERNEL
/***************************************************************************\
* dtdb - dump TDB
*
* dtdb address - dumps TDB structure at address
*
* 14-Sep-1993 DaveHart  Created.
* 6/9/1995 SanfordS     made to fit stdexts motif
\***************************************************************************/
ULONG
dtdbCallback(
    ULONG64 pti,
    PVOID   Data)
{
    ULONG64 ptdb;

    UNREFERENCED_PARAMETER(Data);

    GetFieldValue(pti, SYM(THREADINFO), "ptdb", ptdb);
    SAFEWHILE (ptdb) {
        Idtdb(0, ptdb);
        GetFieldValue(ptdb, SYM(TDB), "ptdbNext", ptdb);
    }

    return FALSE;
}

BOOL Idtdb(
    DWORD opts,
    ULONG64 param1)
{

    ULONG64 ptdb;

    UNREFERENCED_PARAMETER(opts);

    if (param1 == 0) {
        Print("Dumping all ptdbs:\n");
        ForEachPti(dtdbCallback, NULL);
        return TRUE;
    }

    ptdb = param1;

    if (ptdb == 0) {
        Print("Must supply a TDB address.\n");
        return FALSE;
    }

    InitTypeRead(ptdb, TDB);

    Print("TDB (non preemptive scheduler task database) @ 0x%p\n", ptdb);
    Print("\tptdbNext          0x%p\n", ReadField(ptdbNext));
    Print("\tnEvents           0x%08lx\n", (ULONG)ReadField(nEvents));
    Print("\tnPriority         0x%08lx\n", (ULONG)ReadField(nPriority));
    Print("\tpti               0x%p\n", ReadField(pti));

    return TRUE;
}
#endif // KERNEL

#ifndef KERNEL
/************************************************************************\
* Icbp
*
* Breaks into the debugger in context of csrss.exe.
*
* fSuccess
*
* 6/1/98 JerrySh
\************************************************************************/
BOOL Icbp(
    VOID)
{
    DWORD dwProcessId;
    DWORD dwThreadId;
    BOOL fServerProcess;
    USER_API_MSG m;
    PACTIVATEDEBUGGERMSG a = &m.u.ActivateDebugger;

    moveExpValue(&fServerProcess, VAR(gfServerProcess));

    if (fServerProcess) {
        Print("Already debugging server process!\n");
    } else {
        /*
         * Get the process and thread ID of a CSRSS thread.
         */
        dwThreadId = GetWindowThreadProcessId(GetDesktopWindow(), &dwProcessId);
        a->ClientId.UniqueProcess = LongToHandle(dwProcessId);
        a->ClientId.UniqueThread = LongToHandle(dwThreadId);

        /*
         * Tell CSRSS to break on itself.
         */
        CsrClientCallServer((PCSR_API_MSG)&m,
                             NULL,
                             CSR_MAKE_API_NUMBER(USERSRV_SERVERDLL_INDEX, UserpActivateDebugger),
                             sizeof(*a));
    }

    return TRUE;
}

#endif // !KERNEL

#ifdef KERNEL
/***************************************************************************\
* dkl - dump keyboard layout
*
* dkl address      - dumps keyboard layout structure at address
*
* 05/21/95 GregoryW        Created.
\***************************************************************************/
const char* GetCharSetText(
    const BYTE bCharSet)
{
    static struct _tagBASECHARSET {
        const char* pstrCS;
        DWORD dwValue;
    } const CrackCS[] = {
        {"ANSI_CHARSET"            ,0   },
        {"DEFAULT_CHARSET"         ,1   },
        {"SYMBOL_CHARSET"          ,2   },
        {"SHIFTJIS_CHARSET"        ,128 },
        {"HANGEUL_CHARSET"         ,129 },
        {"GB2312_CHARSET"          ,134 },
        {"CHINESEBIG5_CHARSET"     ,136 },
        {"OEM_CHARSET"             ,255 },
        {"JOHAB_CHARSET"           ,130 },
        {"HEBREW_CHARSET"          ,177 },
        {"ARABIC_CHARSET"          ,178 },
        {"GREEK_CHARSET"           ,161 },
        {"TURKISH_CHARSET"         ,162 },
        {"THAI_CHARSET"            ,222 },
        {"EASTEUROPE_CHARSET"      ,238 },
        {"RUSSIAN_CHARSET"         ,204 },
        {"MAC_CHARSET"             ,77  }
    };

    UINT i;

    for (i = 0; i < ARRAY_SIZE(CrackCS); ++i) {
        if (CrackCS[i].dwValue == bCharSet) {
            break;
        }
    }

    if (i < ARRAY_SIZE(CrackCS)) {
        return CrackCS[i].pstrCS;
    }

    return "ILLEGAL VALUE";
}

BOOL DumpKF(
    DWORD opts,
    DWORD n,
    ULONG64 spkf,
    BOOL fActive)
{
    ULONG offTmp;
    ULONG64 pKbdTbl;
    DWORD fLocaleFlags;
    WCHAR awchKF[9];        // size should match KBDFILE::awchKF
    WCHAR awchDllName[32];  // size should match KBDFILE::awchDllName
    DWORD dwType, dwSubType;

    if (spkf == 0) {
        Print("  spkf          0x%p (NONE!)\n", NULL_POINTER);
        return TRUE;
    }

    _InitTypeRead(spkf, SYM(tagKBDFILE));

    Print("  %c" "spkf[%02x]    0x%p (cLockObj = %d)\n",
          fActive ? '*' : ' ',
          n, spkf, ReadField(head.cLockObj));
    if (opts & OFLAG(v)) {
        Print("     pkfNext       0x%p\n", ReadField(pkfNext));
        GetFieldOffset(SYM(tagKBDFILE), "awchKF", &offTmp);
        if (offTmp) {
            tryMoveBlock(awchKF, spkf + offTmp, sizeof(awchKF));
            awchKF[ARRAY_SIZE(awchKF) - 1] = 0;
            Print("     awchKF[]      L\"%ws\"\n", awchKF);
        }
    }

    GetFieldOffset(SYM(tagKBDFILE), "awchDllName", &offTmp);

    if (offTmp) {
        tryMoveBlock(awchDllName, spkf + offTmp, sizeof(awchDllName));
        awchDllName[ARRAY_SIZE(awchDllName) - 1] = 0;
        Print("     DllName[]     L\"%ws\"\n", awchDllName);
    }

    pKbdTbl = ReadField(pKbdTbl);
    GetFieldValue(pKbdTbl, SYM(tagKbdLayer), "dwType", dwType);
    GetFieldValue(pKbdTbl, SYM(tagKbdLayer), "dwSubType", dwSubType);
    Print("     Type:Sub       (%x:%x)\n", dwType, dwSubType);

    if (opts & OFLAG(v)) {

        Print("     hBase          0x%08lx\n", ReadField(hBase));
        Print("     pKbdTbl       0x%p\n", pKbdTbl);

        /*
         * Dump pKbdTbl
         */
        GetFieldValue(pKbdTbl, SYM(tagKbdLayer), "fLocaleFlags", fLocaleFlags);
        Print("        fLocaleFlags 0x%08lx\n", fLocaleFlags);
    }

    return TRUE;
}

typedef struct {
    ULONG64 hkl;
    UINT n;
} KLCOUNT, *PKLCOUNT;

typedef struct {
    DWORD opts;
    KLCOUNT kl[128];
} KLCALLBACKINFO, *PKLCALLBACKINFO;

ULONG WDBGAPI ThreadKLCallback(ULONG64 pti, PVOID Data)
{
    ULONG64 pkl;
    ULONG64 hkl, hklPrev;
    PKLCALLBACKINFO pInfo = (PKLCALLBACKINFO)Data;
    UINT i;

    InitTypeRead(pti, win32k!THREADINFO);

    pkl = ReadField(spklActive);
    hklPrev = ReadField(hklPrev);

    Print("  pti 0x%p  ", pti);

    GetFieldValue(pkl, SYM(tagKL), "hkl", hkl);

    Print("  spklActive %p   hkl %08x (prev: %08x)\n", pkl, (DWORD)hkl, (DWORD)hklPrev);

    /*
     * Count the KL usage.
     */
    for (i = 0; i < ARRAY_SIZE(pInfo->kl); ++i) {
        if (pInfo->kl[i].hkl == 0) {
            pInfo->kl[i].hkl = hkl;
            ++pInfo->kl[i].n;
            break;
        } else if (pInfo->kl[i].hkl == hkl) {
            ++pInfo->kl[i].n;
            break;
        }
    }

    return FALSE;
}


ULONG WDBGAPI KLProcessCallback(
    ULONG64 ppi,
    PVOID Data)
{
    PKLCALLBACKINFO pInfo = (PKLCALLBACKINFO)Data;
    ULONG64 pEProcess;
    WCHAR awchProcessName[MAX_PATH];
    PTI_CONTEXT ptic;
    W32PID W32Pid;

    GetFieldValue(ppi, SYM(_W32PROCESS), "Process", pEProcess);
    if (!GetProcessName(pEProcess, awchProcessName)) {
        awchProcessName[0] = 0;
    }
    GetFieldValue(pEProcess, SYM(_W32PROCESS), "W32Pid", W32Pid);
    Print("Process 0x%p (ppi 0x%p) [%ws]\n", pEProcess, ppi, awchProcessName);

    ptic.CallbackRoutine = ThreadKLCallback;
    ptic.Data = Data;
    ForEachPtiCallback(ppi, &ptic);

    return FALSE;
}

BOOL Idkl(
    DWORD opts,
    ULONG64 param1)
{
    try {
        ULONG64 gpkl = NULL_POINTER;
        ULONG64 pkl, pklAnchor;
        ULONG64 pkfActive;
        UINT i, nTables;
        UINT iBaseCharset;
        DWORD dwFontSigs;

        if (opts & OFLAG(k)) {
            /*
             * Dump all the thread and its KL information.
             */
            KLCALLBACKINFO info;

            if (param1) {
                return FALSE;
            }

            RtlZeroMemory(&info, sizeof info);
            info.opts = opts & ~OFLAG(k);
            ForEachPpi(KLProcessCallback, &info);

            // Print the summary.
            Print("\nSummary:\n");
            for (i = 0; i < ARRAY_SIZE(info.kl) && info.kl[i].hkl; ++i) {
                Print("%08x 0n%d\n", (DWORD)info.kl[i].hkl, info.kl[i].n);
            }
            return TRUE;
        }

        if (param1 == 0) {
            BYTE bCharSet;
            gpkl = GetGlobalPointer(VAR(gpkl));

            if (opts & OFLAG(a)) {
                Print("Using gspklBaseLayout\n");
                pkl = GetGlobalPointer(VAR(gspklBaseLayout));
            } else {
                Print("Using gpkl\n");
                pkl = gpkl;
            }
            moveExpValue(&bCharSet, VAR(gSystemCPCharSet));
            Print("gpKL:%p  gSystemCPCharSet:%s\n", gpkl, GetCharSetText(bCharSet));
        } else {
            pkl = FIXKP(param1);
        }

        if (pkl == NULL_POINTER) {
            return FALSE;
        }

        _InitTypeRead(pkl, SYM(tagKL));

        Print("KL @ 0x%p (cLockObj = %d) %c\n", pkl, (DWORD)ReadField(head.cLockObj),
              pkl == gpkl ? '*' : ' ');
        Print("  hkl            0x%08p\n", ReadField(hkl));
        Print("  KLID             %08x\n", ReadField(dwKLID));
        if (opts & OFLAG(v)) {
            Print("  pklNext       0x%p\n", ReadField(pklNext));
            Print("  pklPrev       0x%p\n", ReadField(pklPrev));
            Print("  dwKL_Flags    0x%08p\n", ReadField(dwKL_Flags));
            Print("  piiex         0x%p\n", ReadField(piiex));
            GetFieldValue(pkl, SYM(tagKL), "dwFontSigs", dwFontSigs);
            Print("  dwFontSigs     %s\n", GetFlags(GF_CHARSETS, dwFontSigs, NULL, TRUE));
            GetFieldValue(pkl, SYM(tagKL), "iBaseCharset", iBaseCharset);
            Print("  iBaseCharset   %s\n", GetCharSetText((BYTE)iBaseCharset));
        }

        _InitTypeRead(pkl, SYM(tagKL));
        Print("  Codepage       %d\n", (WORD)ReadField(CodePage));

        pkfActive = ReadField(spkf);
        DumpKF(opts, 0, ReadField(spkfPrimary), ReadField(spkfPrimary) == pkfActive);

        _InitTypeRead(pkl, SYM(tagKL));

        /*
         * Dump extra tables
         */
        nTables = (UINT)ReadField(uNumTbl);
        Print("  Extra Tables: %x\n", nTables);
        if (nTables > 0) {
            ULONG64 ppkfExtra = ReadField(pspkfExtra);
            for (i = 0; i < nTables && !IsCtrlCHit(); ++i) {
                ULONG64 pkf;
                ReadPointer(ppkfExtra + GetTypeSize("PVOID") * i, &pkf);

                DumpKF(opts, i + 1, pkf, pkf == pkfActive);
            }
        }

        if (opts & OFLAG(a)) {
            ULONG64 pklNext;

            opts &= ~OFLAG(a);

            pklAnchor = pkl;
            GetFieldValue(pkl, SYM(tagKL), "pklNext", pklNext);

            SAFEWHILE (pklNext && pklNext != pklAnchor) {
                pkl = pklNext;
                if (!Idkl(opts, pkl)) {
                    return FALSE;
                }

                if (GetFieldValue(pkl, SYM(tagKL), "pklNext", pklNext)) {
                    break;
                }
            }
        }
    } except (CONTINUE) {
    }

    return TRUE;
}


/***************************************************************************\
* ddk - dump deadkey table
*
* ddk address      - dumps deadkey table address
*
* 09/28/95 GregoryW        Created.
\***************************************************************************/

BOOL Iddk(
    DWORD opts,
    ULONG64 param1)
{
    try {
        ULONG64 pKbdTbl;    // KBDTABLES
        ULONG64 pDeadKey;   // DEADKEY
        ULONG cbDeadKey;

        UNREFERENCED_PARAMETER(opts);

        if (param1 == NULL_POINTER) {
            Print("Expected address\n");
            return FALSE;
        }

        cbDeadKey = GetTypeSize(SYM(DEADKEY));
        if (cbDeadKey == 0) {
            Print("cannot get sizeof(DEADKEY), invalid symbol?\n");
            return TRUE;
        }

        pKbdTbl = param1;

        GetFieldValue(pKbdTbl, SYM(KBDTABLES), "pDeadKey", pDeadKey);
        if (pDeadKey == NULL_POINTER) {
            Print("No deadkey table for this layout\n");
            return TRUE;
        }

        SAFEWHILE (TRUE) {
            DWORD dwBoth;
            WCHAR wchComposed;
            USHORT uFlags;

            _InitTypeRead(pDeadKey, SYM(DEADKEY));
            dwBoth = DOWNCAST(DWORD, ReadField(dwBoth));
            if (dwBoth == 0) {
                break;
            }
            wchComposed = DOWNCAST(WCHAR, ReadField(wchComposed));
            uFlags = DOWNCAST(USHORT, ReadField(uFlags));
            Print("d 0x%04x  ch 0x%04x  => 0x%04x, f=%x\n", HIWORD(dwBoth), LOWORD(dwBoth), wchComposed, uFlags);
            pDeadKey += cbDeadKey;
        }
    } except (CONTINUE) {
    }
    return TRUE;
}

#endif // KERNEL

#ifdef KERNEL
/***************************************************************************\
* dti - dump THREADINFO
*
* dti address - dumps THREADINFO structure at address
*
* 11-13-91 DavidPe      Created.
* 6/9/1995 SanfordS     made to fit stdexts motif
\***************************************************************************/
BOOL Idti(
    DWORD opts,
    ULONG64 param1)
{
    ULONG64 pti, pwinsta;
    CLIENTTHREADINFO cti;
    ULONG64 pThread;
    ULONG64 pEProcess;
    UCHAR PriorityClass;
    WCHAR szDesktop[256], szWindowStation[256];

    UNREFERENCED_PARAMETER(opts);

    if (param1 == 0) {
        ULONG64 pq;

        if (opts & OFLAG(c)) {
            // !dti -c: Use the current thread.
            pti = GetGlobalPointer(VAR(gptiCurrent));
        } else {
            Print("No pti specified: using foreground thread\n");
            pq = GetGlobalPointer(VAR(gpqForeground));
            if (pq == 0) {
                Print("No foreground queue!\n");
                return FALSE;
            }
            GetFieldValue(pq, SYM(Q), "ptiKeyboard", pti);
        }
    } else {
        pti = FIXKP(param1);
    }

    if (pti == 0) {
        return FALSE;
    }

    Idt(OFLAG(p), pti);

    _InitTypeRead(pti, SYM(tagTHREADINFO));
    move(cti, ReadField(pcti));

    Print("PTHREADINFO @ 0x%p\n", pti);

    Print("\tPtiLink.Flink          0x%p\n"
          "\tptl                    0x%p\n"
          "\tptlW32                 0x%p\n"
          "\tppi                    0x%p\n"
          "\tpq                     0x%p\n"
          "\tspklActive             0x%p\n"
          "\tmlPost.pqmsgRead       0x%p\n"
          "\tmlPost.pqmsgWriteLast  0x%p\n"
          "\tmlPost.cMsgs           0x%08lx\n",
          ReadField(PtiLink.Flink),
          ReadField(ptl),
          ReadField(ptlW32),
          ReadField(ppi),
          ReadField(pq),
          ReadField(spklActive),
          ReadField(mlPost.pqmsgRead),
          ReadField(mlPost.pqmsgWriteLast),
          (ULONG)ReadField(mlPost.cMsgs));

    Print("\tspwndDefaultIme        0x%p\n"
          "\tspDefaultImc           0x%p\n"
          "\thklPrev                0x%08lx\n",
          ReadField(spwndDefaultIme),
          ReadField(spDefaultImc),
          ReadField(hklPrev));

    Print("\trpdesk                 0x%p",
          ReadField(rpdesk));
    // If the pti has a desktop, display it and windowstation.
    if (ReadField(rpdesk)) {
        GetObjectName(ReadField(rpdesk), szDesktop, ARRAY_SIZE(szDesktop));
        GetFieldValue(ReadField(rpdesk), SYM(DESKTOP), "rpwinstaParent", pwinsta);
        GetObjectName(pwinsta, szWindowStation, ARRAY_SIZE(szWindowStation));
        Print(" (%ws\\%ws)", szWindowStation, szDesktop);
    }
    Print("\n");

    Print("\thdesk                  0x%08lx\n",
          ReadField(hdesk));
    Print("\tamdesk                 0x%08lx\n",
          (ULONG)ReadField(amdesk));

    Print("\tpDeskInfo              0x%p\n"
          "\tpClientInfo            0x%p\n",
          ReadField(pDeskInfo),
          ReadField(pClientInfo));

    Print("\tTIF_flags              %s\n",
          GetFlags(GF_TIF, (DWORD)ReadField(TIF_flags), NULL, TRUE));
    Print("\tsphkCurrent            0x%p\n"
          "\tpEventQueueServer      0x%p\n"
          "\thEventQueueClient      0x%p\n",
          ReadField(sphkCurrent),
          ReadField(pEventQueueServer),
          ReadField(hEventQueueClient));

    Print("\tfsChangeBits           %s\n",
            GetFlags(GF_QS, (WORD)cti.fsChangeBits, NULL, TRUE));
    Print("\tfsChangeBitsRemoved    %s\n",
            GetFlags(GF_QS, (WORD)ReadField(fsChangeBitsRemoved), NULL, TRUE));
    Print("\tfsWakeBits             %s\n",
            GetFlags(GF_QS, (WORD)cti.fsWakeBits, NULL, TRUE));
    Print("\tfsWakeMask             %s\n",
            GetFlags(GF_QS, (WORD)cti.fsWakeMask, NULL, TRUE));

    Print("\tcPaintsReady           0x%04x\n"
          "\tcTimersReady           0x%04x\n"
          "\ttimeLast               0x%08lx\n"
          "\tptLast.x               0x%08lx\n"
          "\tptLast.y               0x%08lx\n"
          "\tidLast                 0x%p\n",
          (ULONG)ReadField(cPaintsReady),
          (ULONG)ReadField(cTimersReady),
          (ULONG)ReadField(timeLast),
          (ULONG)ReadField(ptLast.x),
          (ULONG)ReadField(ptLast.y),
          ReadField(idLast));

    Print("\texitCode               0x%08lx\n"
          "\tpSBTrack               0x%p\n"
          "\tpsmsSent               0x%p\n"
          "\tpsmsCurrent            0x%p\n",
          (ULONG)ReadField(exitCode),
          ReadField(pSBTrack),
          ReadField(psmsSent),
          ReadField(psmsCurrent));

    Print("\tfsHooks                0x%08lx\n"
          "\taphkStart              0x%p l%x\n"
          "\tsphkCurrent            0x%p\n",
          (ULONG)ReadField(fsHooks),
          ReadField(aphkStart), CWINHOOKS,
          ReadField(sphkCurrent));
    Print("\tpsmsReceiveList        0x%p\n",
          ReadField(psmsReceiveList));
    Print("\tptdb                   0x%p\n"
          "\tThread                 0x%p\n",
          ReadField(ptdb),
          ReadField(pEThread));

    pThread = ReadField(pEThread);
    GetFieldValue(pThread, "nt!ETHREAD", "ThreadsProcess", pEProcess);
    GetFieldValue(pEProcess, "nt!EPROCESS", "PriorityClass", PriorityClass);
    Print("\t  PriorityClass %d\n",
          PriorityClass);

    _InitTypeRead(pti, SYM(tagTHREADINFO));

    Print("\tcWindows               0x%08lx\n"
          "\tcVisWindows            0x%08lx\n"
          "\tpqAttach               0x%p\n"
          "\tiCursorLevel           0x%08lx\n",
          (ULONG)ReadField(cWindows),
          (ULONG)ReadField(cVisWindows),
          ReadField(pqAttach),
          (ULONG)ReadField(iCursorLevel));

    Print("\tpMenuState             0x%p\n",
          ReadField(pMenuState));

    return TRUE;
}
#endif // KERNEL

#ifdef KERNEL

BOOL ScanThreadlocks(ULONG64 pti, char chType, ULONG64 pvSearch);

ULONG WDBGAPI DumpThreadLocksCallback(ULONG64 pti, PVOID pOpt)
{
    UNREFERENCED_PARAMETER(pOpt);

    Idtl(OFLAG(t) | OFLAG(x), pti);
    return 0;
}

ULONG WDBGAPI ScanThreadLocksCallback(ULONG64 pti, PVOID pOpt)
{
    ScanThreadlocks(pti, 'o', *(ULONG64*)pOpt);
    ScanThreadlocks(pti, 'k', *(ULONG64*)pOpt);
    return 0;
}

/***************************************************************************\
* dtl handle|pointer
*
* !dtl <addr>       Dumps all THREAD locks for object at <addr>
* !dtl -t <pti>     Dumps all THREAD locks made by thread <pti>
* !dtl              Dumps all THREAD locks made by all threads
*
* 02/27/1992 ScottLu      Created.
* 06/09/1995 SanfordS     Made to fit stdexts motif.
\***************************************************************************/
BOOL Idtl(
    DWORD opts,
    ULONG64 param1)
{
    ULONG64 pti;

    if (param1 == 0) {
        Print("Dumping all thread locks:\n");
        Print("pti        pObj     Caller\n");
        ForEachPti(DumpThreadLocksCallback, NULL);
        return TRUE;
    }

    if (opts & OFLAG(t)) {
        pti = FIXKP(param1);
        if (pti == 0) {
            return FALSE;
        }

        /*
         * Regular thread-locked objects.
         */
        if (!(opts & OFLAG(x))) { // x is not legal from user - internal only
            Print("pti        pObj     Caller\n");
        }
        ScanThreadlocks(pti, 'o', 0);
        ScanThreadlocks(pti, 'k', 0);
        return TRUE;
    }


    if (!param1) {
        return FALSE;
    }

    Print("Thread Locks for object %p:\n", param1);
    Print("pti        pObj     Caller\n");

    ForEachPti(ScanThreadLocksCallback, &param1);

    Print("--- End Thread Lock List ---\n");

    return TRUE;
}

/*
 * Scans all threadlocked objects belonging to thread pti of type chType
 * (o == regular objects, k == kernel objects, p == pool). Display each
 * threadlock, or if pvSearch is non-NULL, just those locks on the object
 * at pvSearch.
 */
BOOL
ScanThreadlocks(
    ULONG64 pti,
    char    chType,
    ULONG64 pvSearch)
{
    ULONG64 ptl;

    if (pti == 0) {
        return FALSE;
    }

    if (_InitTypeRead(pti, SYM(THREADINFO))) {
        Print("Idtl: Can't get pti data from %p.\n", (ULONG_PTR)pti);
        return FALSE;
    }
    switch (chType) {
    case 'o':
        ptl = ReadField(ptl);
        break;
    case 'k':
        ptl = ReadField(ptlW32);
        break;
    default:
        Print("Internal error, bad chType '%c' in ScanThreadlocks\n", chType);
        return FALSE;
    }

    SAFEWHILE (ptl) {
        char ach[80];
        ULONG64 dwOffset;

        if (_InitTypeRead(ptl, SYM(TL))) {
            Print("Idtl: Can't get ptl data from %p.\n", (ULONG_PTR)ptl);
            return FALSE;
        }

        if (!pvSearch || ReadField(pobj) == pvSearch) {
            Print("0x%p 0x%p", pti, ReadField(pobj));
            GetSym(ReadField(pfnCaller), ach, &dwOffset);
            Print(" %s", ach);
            if (dwOffset) {
                Print("+0x%x", (ULONG)dwOffset);
            }
            if (chType == 'k') {
                GetSym(ReadField(pfnFree), ach, &dwOffset);
                Print(" (%s)", ach);
                if (dwOffset) {
                    Print("+0x%x", (ULONG)dwOffset);
                }
            }
            Print("\n");
        }
        ptl = ReadField(next);
    }

    return TRUE;
}
#endif // KERNEL

#ifdef KERNEL
/************************************************************************\
* Idtmr
*
* Dumps timer structures
*
* 06/09/1995 Created SanfordS
* 10/18/2000 Mohamed Fathalla (mohamed) Port to 64 bit.
\************************************************************************/
BOOL Idtmr(
    DWORD opts,
    ULONG64 ptmr)
{
    ULONG64 pti;

    UNREFERENCED_PARAMETER(opts);

    if (ptmr == 0) {
        ptmr = GetGlobalPointer(VAR(gptmrFirst));
        SAFEWHILE (ptmr) {
            Idtmr(0, ptmr);
            Print("\n");
            InitTypeRead(ptmr, TIMER);
            ptmr = ReadField(ptmrNext);
        }
        return TRUE;
    }

    InitTypeRead(ptmr, TIMER);
    Print("Timer %p:\n"
          "  ptmrNext       = %p\n"
          "  pti            = %p",
          ptmr,
          ReadField(ptmrNext),
          ReadField(pti));

    pti = ReadField(pti);
    if (pti && InitTypeRead(pti, THREADINFO)) {
        WCHAR awch[64];

        if (GetAppName(ReadField(pEThread), pti, awch, ARRAY_SIZE(awch))) {
            ULONG handleProcess,
                  handleThread;
            PWCHAR pwch = wcsrchr(awch, L'\\');

            if (pwch == NULL) {
                pwch = awch;
            } else {
                pwch++;
            }

            GetFieldValue(ReadField(pEThread), "nt!ETHREAD", "Cid.UniqueThread", handleProcess);
            GetFieldValue(ReadField(pEThread), "nt!ETHREAD", "Cid.UniqueThread", handleThread);
            Print("  q %p i %2x.%-3lx %ws",
                    ReadField(pq),
                    handleProcess,
                    handleThread,
                    pwch);
        }
    }
    InitTypeRead(ptmr, TIMER);
    Print("\n"
          "  spwnd          = %p",
          ReadField(spwnd));
    if (ReadField(spwnd)) {
        char ach[80];

        DebugGetWindowTextA(ReadField(spwnd), ach, ARRAY_SIZE(ach));
        Print("  \"%s\"", ach);
    }
    Print("\n"
          "  nID            = %x\n"
          "  cmsCountdown   = %x\n"
          "  cmsRate        = %x\n"
          "  flags          = %s\n"
          "  pfn            = %p\n"
          "  ptiOptCreator  = %p\n",
          (ULONG) ReadField(nID),
          (ULONG) ReadField(cmsCountdown),
          (ULONG) ReadField(cmsRate),
          GetFlags(GF_TMRF, (WORD)ReadField(flags), NULL, TRUE),
          ReadField(pfn),
          ReadField(ptiOptCreator));

    return TRUE;
}
#endif // KERNEL


#ifdef OLD_DEBUGGER
/************************************************************************\
* Idu
*
* Dump unknown object.  Does what it can figure out.
*
* 6/9/1995 Created SanfordS
\************************************************************************/
BOOL Idu(
    DWORD opts,
    ULONG64 param1)
{
    HANDLEENTRY he, *phe;
    int i;
    DWORD dw;

    UNREFERENCED_PARAMETER(opts);

    if (param1 == 0) {
        FOREACHHANDLEENTRY(phe, he, i)
            if (he.bType != TYPE_FREE && tryDword(&dw, FIXKP(he.phead))) {
                Idu(OFLAG(x), he.phead);
            }
        NEXTEACHHANDLEENTRY()
        return TRUE;
    }

    param1 = HorPtoP(FIXKP(param1), -1);
    if (param1 == 0) {
        return FALSE;
    }

    if (!getHEfromP(NULL, &he, param1)) {
        return FALSE;
    }

    Print("--- %s object @ 0x%p ---\n", pszObjStr[he.bType], FIXKP(param1));
    switch (he.bType) {
    case TYPE_WINDOW:
        return Idw(0, param1);

    case TYPE_MENU:
        return Idm(0, param1);

#ifdef KERNEL
    case TYPE_CURSOR:
        return Idcur(0, param1);

    case TYPE_HOOK:
        return Idhk(OFLAG(a) | OFLAG(g), NULL);

    case TYPE_DDECONV:
    case TYPE_DDEXACT:
        return Idde(0, param1);
#endif // KERNEL

    case TYPE_MONITOR:
        // LATER: - add dmon command
    case TYPE_CALLPROC:
    case TYPE_ACCELTABLE:
    case TYPE_SETWINDOWPOS:
    case TYPE_DDEACCESS:
    default:
        Print("not supported.\n", pszObjStr[he.bType]);
    }
    return TRUE;
}



#ifdef KERNEL
/***************************************************************************\
* dumphmgr - dumps object allocation counts for handle-table.
*
* 10-18-94 ChrisWil     Created.
* 6/9/1995 SanfordS     made to fit stdexts motif
* 06-18-97 MCostea      made it work
\***************************************************************************/
BOOL Idumphmgr(
    DWORD opts)
{
    PERFHANDLEINFO aLocalHti[TYPE_CTYPES], aLocalPrevHti[TYPE_CTYPES];
    PPERFHANDLEINFO pgahti;

    LONG lTotalAlloc, lTotalMax, lTotalCurrent;
    LONG lPrevTotalAlloc, lPrevTotalMax, lPrevTotalCurrent;
    SIZE_T lTotalSize, lPrevTotalSize;

    int idx;

    pgahti = EvalExp(VAR(gaPerfhti));
    if (!pgahti) {
        Print("\n!dumphmgr works only with debug versions of win32k.sys\n\n");
        return TRUE;
    }
    move(aLocalHti, pgahti);

    pgahti = EvalExp(VAR(gaPrevhti));
    if (!pgahti) {
        return TRUE;
    }

    move(aLocalPrevHti, pgahti);

    lTotalSize = lTotalAlloc = lTotalMax = lTotalCurrent = 0;
    lPrevTotalSize = lPrevTotalAlloc = lPrevTotalMax = lPrevTotalCurrent = 0;

    if (aLocalPrevHti[TYPE_WINDOW].lTotalCount) {
        Print("\nThe snapshot values come under the current ones\n");

        Print("Type             Allocated         Maximum       Count             Size\n");
        Print("______________________________________________________________________________");
        for (idx = 1; idx < TYPE_CTYPES; idx++) {
            Print("\n%-15s  %8d %-+6d %7d %-+5d %6d %-+5d  %9d %-+d",
                  aszTypeNames[idx],
                  aLocalHti[idx].lTotalCount, aLocalHti[idx].lTotalCount - aLocalPrevHti[idx].lTotalCount,
                  aLocalHti[idx].lMaxCount, aLocalHti[idx].lMaxCount - aLocalPrevHti[idx].lMaxCount,
                  aLocalHti[idx].lCount, aLocalHti[idx].lCount - aLocalPrevHti[idx].lCount,
                  aLocalHti[idx].lSize, aLocalHti[idx].lSize - aLocalPrevHti[idx].lSize);
            if (aLocalPrevHti[TYPE_WINDOW].lTotalCount) {
                Print("\n                 %8d        %7d       %6d        %9d",
                      aLocalPrevHti[idx].lTotalCount,
                      aLocalPrevHti[idx].lMaxCount,
                      aLocalPrevHti[idx].lCount,
                      aLocalPrevHti[idx].lSize);
                lPrevTotalAlloc   += aLocalPrevHti[idx].lTotalCount;
                lPrevTotalMax     += aLocalPrevHti[idx].lMaxCount;
                lPrevTotalCurrent += aLocalPrevHti[idx].lCount;
                lPrevTotalSize    += aLocalPrevHti[idx].lSize;

            }
            lTotalAlloc   += aLocalHti[idx].lTotalCount;
            lTotalMax     += aLocalHti[idx].lMaxCount;
            lTotalCurrent += aLocalHti[idx].lCount;
            lTotalSize    += aLocalHti[idx].lSize;
        }
        Print("\n______________________________________________________________________________\n");
        Print("Totals           %8d %-+6d %7d %-+5d %6d %+-5d  %9d %-+d\n",
              lTotalAlloc, lTotalAlloc - lPrevTotalAlloc,
              lTotalMax, lTotalMax - lPrevTotalMax,
              lTotalCurrent, lTotalCurrent - lPrevTotalCurrent,
              lTotalSize, lTotalSize - lPrevTotalSize);
        Print("                 %8d        %7d       %6d        %9d\n",
              lPrevTotalAlloc, lPrevTotalMax, lPrevTotalCurrent, lPrevTotalSize);

    } else {
        Print("Type               Allocated  Maximum  Count   Size\n");
        Print("______________________________________________________");
        for (idx = 1; idx < TYPE_CTYPES; idx++) {
            Print("\n%-17s  %9d  %7d  %6d  %d",
                  aszTypeNames[idx],
                  aLocalHti[idx].lTotalCount,
                  aLocalHti[idx].lMaxCount,
                  aLocalHti[idx].lCount,
                  aLocalHti[idx].lSize);
            lTotalAlloc   += aLocalHti[idx].lTotalCount;
            lTotalMax     += aLocalHti[idx].lMaxCount;
            lTotalCurrent += aLocalHti[idx].lCount;
            lTotalSize    += aLocalHti[idx].lSize;
        }
        Print("\n______________________________________________________\n");
        Print("Current totals     %9d  %7d  %6d  %d\n",
              lTotalAlloc, lTotalMax, lTotalCurrent, lTotalSize);
    }

    /*
     * If the argument-list contains the Snap option,
     * then copy the current counts to the previous ones
     */
    if (opts & OFLAG(s)) {
        (lpExtensionApis->lpWriteProcessMemoryRoutine)(
                (ULONG_PTR)&(pgahti[0]),
                (PVOID)aLocalHti,
                sizeof(aLocalHti),
                NULL);
    }

    return TRUE;
}
#endif // KERNEL
#endif // OLD_DEBUGGER


/************************************************************************\
* dwrWorker
*
* Dumps pwnd structures compactly to show relationships.
*
* 6/9/1995 Created SanfordS
\************************************************************************/
BOOL dwrWorker(
    ULONG64 pwnd,
    int tab)
{
    ULONG64 pcls;
    ULONG64 lpszAnsiClassName;
    ULONG64 pwndChild;
    ULONG64 pwndOwner;
    ULONG atomClassName;
    ULONG atomNVClassName;

    if (pwnd == 0) {
        return FALSE;
    }

    do {
        pwnd = FIXKP(pwnd);
        DebugGetWindowTextA(pwnd, gach1, ARRAY_SIZE(gach1));
        GetFieldValue(pwnd, SYM(WND), "pcls", pcls);
        GetFieldValue(pcls, SYM(CLS), "atomClassName", atomClassName);
        GetFieldValue(pcls, SYM(CLS), "atomNVClassName", atomNVClassName);
        GetFieldValue(pcls, SYM(CLS), "lpszAnsiClassName", lpszAnsiClassName);
        if (atomNVClassName < 0xC000) {
            switch (atomNVClassName) {
            case WC_DIALOG:
                strcpy(gach1, "WC_DIALOG");
                break;

            case DESKTOPCLASS:
                strcpy(gach1, "DESKTOP");
                break;

            case SWITCHWNDCLASS:
                strcpy(gach1, "SWITCHWND");
                break;

            case ICONTITLECLASS:
                strcpy(gach1, "ICONTITLE");
                break;

            default:
                if (atomNVClassName == 0) {
                    move(gach1, FIXKP(lpszAnsiClassName));
                } else {
                    sprintf(gach2, "0x%04x", atomNVClassName);
                }
            }
        } else {
            DebugGetClassNameA(lpszAnsiClassName, gach2);
        }

        if (atomClassName && (atomClassName < 0xC000)) {
            sprintf(gach3, "0x%04x", atomClassName);
        }

        Print("%08p%*s [%s|%s|%s]", pwnd, tab, "", gach1, gach2, gach3);
        GetFieldValue(pwnd, SYM(WND), "spwndOwner", pwndOwner);
        if (pwndOwner != 0) {
            Print(" <- Owned by:%08x", FIXKP(pwndOwner));
        }
        Print("\n");
        GetFieldValue(pwnd, SYM(WND), "spwndChild", pwndChild);
        if (pwndChild != 0) {
            dwrWorker(pwndChild, tab + 2);
        }
        GetFieldValue(pwnd, SYM(WND), "spwndNext", pwnd);
    } SAFEWHILE (pwnd && tab > 0);
    return TRUE;
}


/************************************************************************\
* Idw
*
* Dumps pwnd structures
*
* 6/9/1995 Created SanfordS
\************************************************************************/
BOOL Idw(
    DWORD opts,
    ULONG64 param1)
{
    WW ww;
    ULONG64 lpfnWndProc;
    RECT rcWindow;
    RECT rcClient;
    ULONG64 pcls;
    ULONG64 pwnd = param1;
    char ach[256];
    ULONG64 dwOffset;
    ULONG ix;
    DWORD tempDWord;
    DWORD dwWOW;

    try {

        if (opts & OFLAG(a)) {
#ifdef KERNEL
            ULONG64 pdesk;
            ULONG64 pDeskInfo;
            ULONG64 pwnd;
            WCHAR wach[80];

            if (param1 != 0) {
                Print("window parameter ignored with -a option.\n");
            }
            FOREACHDESKTOP(pdesk)
                if (!GetFieldValue(pdesk, SYM(DESKTOP), "pDeskInfo", pDeskInfo)) {
                    ULONG64 pHead;
                    ULONG ObjectHeaderOffset;
                    UCHAR NameInfoOffset;
                    ULONG64 NameBuffer;
                    ULONG NameLength;

                    GetFieldOffset("nt!OBJECT_HEADER", "Body", &ObjectHeaderOffset);
                    pHead = pdesk - ObjectHeaderOffset;
                    GetFieldValue(pHead, "nt!OBJECT_HEADER", "NameInfoOffset", NameInfoOffset);
                    pHead -= NameInfoOffset;
                    GetFieldValue(pHead, "nt!OBJECT_HEADER_NAME_INFO", "Name.Buffer", NameBuffer);
                    GetFieldValue(pHead, "nt!OBJECT_HEADER_NAME_INFO", "Name.Length", NameLength);
                    moveBlock(wach, FIXKP(NameBuffer), NameLength);
                    wach[NameLength / sizeof(WCHAR)] = L'\0';
                    Print("\n----Windows for %ws desktop @ 0x%p:\n\n", wach, pdesk);
                    GetFieldValue(pDeskInfo, SYM(DESKTOPINFO), "spwnd", pwnd);
                    if (!Idw((opts & ~OFLAG(a)) | OFLAG(p), pwnd)) {
                        return FALSE;
                    }
                }
            NEXTEACHDESKTOP(pdesk)
#else // !KERNEL
            ULONG64 pteb = 0;

            GetTebAddress(&pteb);
            if (pteb) {
                ULONG pciOffset;
                ULONG64 pdi;

                GetFieldOffset(SYM(TEB), "Win32ClientInfo", &pciOffset);
                GetFieldValue(pteb + pciOffset, SYM(CLIENTINFO), "pDeskInfo", pdi);
                GetFieldValue(pdi, SYM(DESKTOPINFO), "spwnd", pwnd);
                return Idw(opts & ~OFLAG(a) | OFLAG(p), FIXKP(pwnd));
            }
#endif // !KERNEL
            return TRUE;
        }

        /*
         * t is like EnumThreadWindows.
         */
        if (opts & OFLAG(t)) {
#ifdef KERNEL
            ULONG64 pti, ptiWnd;
            ULONG64 pdesk;
            ULONG64 pdi;
            /*
             * Get the desktop's first child window
             */
            pti = param1;
            if (GetFieldValue(pti, SYM(THREADINFO), "rpdesk", pdesk)
                    || GetFieldValue(pdesk, SYM(DESKTOP), "pDeskInfo", pdi)
                    || GetFieldValue(pdi, SYM(DESKTOPINFO), "spwnd", pwnd)
                    || GetFieldValue(pwnd, SYM(WND), "spwndChild", pwnd)) {
                return FALSE;
            }
            /*
             * Walk the sibling chain looking for pwnd owned by pti.
             */
            SAFEWHILE (pwnd) {
                if (!GetFieldValue(pwnd, SYM(WND), "head.pti", ptiWnd) && (ptiWnd == pti)) {
                    if (!Idw(opts & ~OFLAG(t), pwnd)) {
                        return FALSE;
                    }
                }
                if (GetFieldValue(pwnd, SYM(WND), "spwndNext", pwnd)) {
                    return FALSE;
                }
            }
            return TRUE;

#else // !KERNEL
            Print("t parameter not supported for NTSD at this point\n");
#endif // !KERNEL
        }

        /*
         * See if the user wants all top level windows.
         */
        if (param1 == 0 || opts & (OFLAG(p) | OFLAG(s))) {
            /*
             * Make sure there was also a window argument if p or s.
             */

            if (param1 == 0 && (opts & (OFLAG(p) | OFLAG(s)))) {
                Print("Must specify window with '-p' or '-s' options.\n");
                return FALSE;
            }

            if (param1 && (pwnd = HorPtoP(pwnd, TYPE_WINDOW)) == 0) {
                return FALSE;
            }

            if (opts & OFLAG(p)) {
                Print("pwndParent = 0x%p\n", pwnd);
                if (GetFieldValue(FIXKP(pwnd), SYM(WND), "spwndChild", pwnd)) {
                    Print("<< Can't get WND >>\n");
                    return TRUE; // we don't need to have the flags explained!
                }
                SAFEWHILE (pwnd) {
                    if (!Idw(opts & ~OFLAG(p), pwnd)) {
                        return FALSE;
                    }
                    GetFieldValue(FIXKP(pwnd), SYM(WND), "spwndNext", pwnd);
                }
                return TRUE;

            } else if (opts & OFLAG(s)) {
                GetFieldValue(FIXKP(pwnd), SYM(WND), "spwndParent", pwnd);
                return Idw((opts | OFLAG(p)) & ~OFLAG(s), pwnd);

            } else {    // pwnd == NULL & !p & !s
#ifdef KERNEL
                ULONG64 pdesk = 0;
                ULONG64 pDeskInfo, pwnd;
                ULONG64 pti, pq;

                pq = GetGlobalPointer(VAR(gpqForeground));
                GetFieldValue(pq, SYM(Q), "ptiKeyboard", pti);
                GetFieldValue(pti, SYM(THREADINFO), "rpdesk", pdesk);
                if (pdesk == 0) {
                    Print("Foreground thread doesn't have a desktop.\n");
                    Print("Using grpdeskRitInput ...\n");

                    pdesk = GetGlobalPointer(SYM(grpdeskRitInput));
                    if (pdesk == 0) {
                        Print("grpdeskRitInput is NULL!\n");
                        return FALSE;
                    }
                    GetFieldValue(pdesk, SYM(DESKTOP), "pDeskInfo", pDeskInfo);
                    GetFieldValue(pDeskInfo, SYM(DESKTOPINFO), "spwnd", pwnd);
                } else {
                    GetFieldValue(pti, SYM(THREADINFO), "pDeskInfo", pDeskInfo);
                    GetFieldValue(pDeskInfo, SYM(DESKTOPINFO), "spwnd", pwnd);
                }

                Print("pwndDesktop = 0x%p\n", (ULONG_PTR)pwnd);
                return Idw(opts | OFLAG(p), pwnd);
#else  // !KERNEL
                return Idw(opts | OFLAG(a), 0);
#endif // !KERNEL
            }
        }

        if (param1 && (pwnd = HorPtoP(param1, TYPE_WINDOW)) == 0) {
            Print("Idw: 0x%p is not a pwnd.\n", param1);
            return FALSE;
        }

        if (opts &  OFLAG(r)) {
            dwrWorker(FIXKP(pwnd), 0);
            return TRUE;
        }

        InitTypeRead(pwnd, WND);
        lpfnWndProc = ReadField(lpfnWndProc);
        ww.state    = (DWORD)ReadField(state);
        ww.state2   = (DWORD)ReadField(state2);
        ww.ExStyle  = (DWORD)ReadField(ExStyle);
        ww.style    = (DWORD)ReadField(style);

#ifdef KERNEL
        /*
         * Print simple thread info.
         */
        if (ReadField(head.pti)) {
            Idt(OFLAG(p), ReadField(head.pti));
        }
#endif // KERNEL

        /*
         * Print pwnd.
         */
        Print("pwnd    = 0x%p", pwnd);
        /*
         * Show z-ordering/activation relevant info
         */
        if (opts & OFLAG(z)) {
            ULONG64 pwndOwner;

            if (ReadField(ExStyle) & WS_EX_TOPMOST) {
                Print(" TOPMOST");
            }
            if (!(ReadField(style) & WS_VISIBLE)) {
                Print(" HIDDEN");
            }
            if (ReadField(style) & WS_DISABLED) {
                Print(" DISABLED");
            }
            pwndOwner = ReadField(spwndOwner);
            if (pwndOwner != 0) {
                DebugGetWindowTextA(pwndOwner, ach, ARRAY_SIZE(ach));
                Print(" OWNER:0x%p \"%s\"", pwndOwner, ach);
            }
        }
        Print("\n");

        if (!(opts & OFLAG(v))) {

            /*
             * Print title string.
             */
            DebugGetWindowTextA(pwnd, ach, ARRAY_SIZE(ach));
            Print("title   = \"%s\"\n", ach);

            /*
             * Print wndproc symbol string.
             */
            if (IsWOWProc (lpfnWndProc)) {
            UnMarkWOWProc(lpfnWndProc,dwWOW);
            Print("wndproc = %04lx:%04lx (WOW) (%s)",
                    HIWORD(dwWOW),LOWORD(dwWOW),
                    TestWWF(&ww, WFANSIPROC) ? "ANSI" : "Unicode");
            } else {
                GetSym(lpfnWndProc, ach, &dwOffset);
                Print("wndproc = 0x%p = \"%s\" (%s)", lpfnWndProc, ach,
                    TestWWF(&ww, WFANSIPROC) ? "ANSI" : "Unicode");
            }

            /*
             * Display the class name/atom.
             */
            GetFieldValue(pwnd, SYM(WND), "pcls", pcls);
            pcls = FIXKP(pcls);
            InitTypeRead(pcls, CLS);

            DebugGetClassNameA(ReadField(lpszAnsiClassName), ach);
            Print(" Class(V): 0x%04p, (NV): 0x%04p Name:\"%s\"\n", ReadField(atomClassName), ReadField(atomNVClassName), ach);
        } else {
            /*
             * Get the PWND structure.  Ignore class-specific data for now.
             */
            InitTypeRead(pwnd, WND);
            Print("\tpti                0x%p\n", FIXKP(ReadField(head.pti)));
            Print("\thandle             0x%p\n", ReadField(head.h));

            DebugGetWindowTextA(ReadField(spwndNext), ach, ARRAY_SIZE(ach));
            Print("\tspwndNext          0x%p     \"%s\"\n", ReadField(spwndNext), ach);
            DebugGetWindowTextA(ReadField(spwndPrev), ach, ARRAY_SIZE(ach));
            Print("\tspwndPrev          0x%p     \"%s\"\n", ReadField(spwndPrev), ach);
            DebugGetWindowTextA(ReadField(spwndParent), ach, ARRAY_SIZE(ach));
            Print("\tspwndParent        0x%p     \"%s\"\n", ReadField(spwndParent), ach);
            DebugGetWindowTextA(ReadField(spwndChild), ach, ARRAY_SIZE(ach));
            Print("\tspwndChild         0x%p     \"%s\"\n", ReadField(spwndChild), ach);
            DebugGetWindowTextA(ReadField(spwndOwner), ach, ARRAY_SIZE(ach));
            Print("\tspwndOwner         0x%p     \"%s\"\n", ReadField(spwndOwner), ach);

            GetFieldValue(pwnd, SYM(WND), "rcWindow", rcWindow);
            Print("\trcWindow           (%d,%d)-(%d,%d) %dx%d\n",
                    rcWindow.left, rcWindow.top,
                    rcWindow.right, rcWindow.bottom,
                    rcWindow.right - rcWindow.left,
                    rcWindow.bottom - rcWindow.top);

            GetFieldValue(pwnd, SYM(WND), "rcClient", rcClient);
            Print("\trcClient           (%d,%d)-(%d,%d) %dx%d\n",
                    rcClient.left, rcClient.top,
                    rcClient.right, rcClient.bottom,
                    rcClient.right - rcClient.left,
                    rcClient.bottom - rcClient.top);

            if (IsWOWProc (lpfnWndProc)) {
                UnMarkWOWProc(lpfnWndProc,dwWOW);
                Print("\tlpfnWndProc        %04lx:%04lx (WOW) (%s)\n",
                        HIWORD(dwWOW),LOWORD(dwWOW),
                        TestWWF(&ww, WFANSIPROC) ? "ANSI" : "Unicode");
            } else {
                GetSym(lpfnWndProc, ach, &dwOffset);
                Print("\tlpfnWndProc        0x%p     (%s) %s\n", lpfnWndProc, ach,
                    TestWWF(&ww, WFANSIPROC) ? "ANSI" : "Unicode");
            }
            pcls = ReadField(pcls);
            pcls = FIXKP(pcls);
            InitTypeRead(pcls, CLS);
            DebugGetClassNameA(ReadField(lpszAnsiClassName), ach);

            Print("\tpcls              0x%p     (V):0x%04p     (NV):0x%04p     Name:\"%s\"\n",
                    pcls, ReadField(atomClassName), ReadField(atomNVClassName), ach);

            _InitTypeRead(pwnd, SYM(tagWND));
            Print("\thrgnUpdate         0x%p\n",
                    ReadField(hrgnUpdate));
            DebugGetWindowTextA(ReadField(spwndLastActive), ach, ARRAY_SIZE(ach));
            Print("\tspwndLastActive    0x%p     \"%s\"\n",
                  ReadField(spwndLastActive), ach);
            Print("\tppropList          0x%p\n"
                  "\tpSBInfo            0x%p\n",
                  ReadField(ppropList),
                  ReadField(pSBInfo));

            if (ReadField(pSBInfo)) {
                SBINFO asb;

                moveBlock(&asb, FIXKP(ReadField(pSBInfo)), sizeof(asb));
                Print("\t  SBO_FLAGS =      %s\n"
                      "\t  SBO_HMIN  =      %d\n"
                      "\t  SBO_HMAX  =      %d\n"
                      "\t  SBO_HPAGE =      %d\n"
                      "\t  SBO_HPOS  =      %d\n"
                      "\t  SBO_VMIN  =      %d\n"
                      "\t  SBO_VMAX  =      %d\n"
                      "\t  SBO_VPAGE =      %d\n"
                      "\t  SBO_VPOS  =      %d\n",
                        GetFlags(GF_SB, (WORD)asb.WSBflags, NULL, TRUE),
                        asb.Horz.posMin,
                        asb.Horz.posMax,
                        asb.Horz.page,
                        asb.Horz.pos,
                        asb.Vert.posMin,
                        asb.Vert.posMax,
                        asb.Vert.page,
                        asb.Vert.pos);
            }
            Print("\tspmenuSys          0x%p\n"
                  "\tspmenu/id          0x%p\n",
                  ReadField(spmenuSys),
                  ReadField(spmenu));
            Print("\thrgnClip           0x%p\n",
                  ReadField(hrgnClip));


            /*
             * Print title string.
             */
            DebugGetWindowTextA(pwnd, ach, ARRAY_SIZE(ach));
            Print("\tpName              \"%s\"\n",
                  ach);
            Print("\tdwUserData         0x%p\n",
                  (ULONG_PTR)ReadField(dwUserData));
            Print("\tstate              0x%08lx\n"
                  "\tstate2             0x%08lx\n"
                  "\tExStyle            0x%08lx\n"
                  "\tstyle              0x%08lx\n"
                  "\tfnid               0x%08lx\n"
                  "\thImc               0x%08p\n"
                  "\tbFullScreen        0y%d\n"
                  "\thModule            0x%08lx\n"
#ifdef LAME_BUTTON
                  "\tpStackTrace        0x%p\n"
#endif // LAME_BUTTON
                  "\tpActCtx            0x%p\n",
                  ww.state,
                  ww.state2,
                  ww.ExStyle,
                  ww.style,
                  (DWORD)(WORD)ReadField(fnid),
                  ReadField(hImc),
                  TestWWF(&ww, WFFULLSCREENMASK),
                  ReadField(hModule),
#ifdef LAME_BUTTON
                  ReadField(pStackTrace),
#endif // LAME_BUTTON
                  ReadField(pActCtx));
        }

        /*
         * Print out all the flags
         */
        if (opts & OFLAG(f)) {
            int i;
            WORD wFlag;
            ULONG cbHead;
            PBYTE pbyte = (PBYTE)(&(ww.state));

            cbHead = GetTypeSize(SYM(THRDESKHEAD));
            for (i = 0; i < ARRAY_SIZE(aWindowFlags); i++) {
                wFlag = aWindowFlags[i].wFlag;
                if (pbyte[HIBYTE(wFlag)] & LOBYTE(wFlag)) {
                    Print("\t%-18s\t%p:%02lx\n",
                            aWindowFlags[i].pszText,
                            pwnd + cbHead + HIBYTE(wFlag),
                            LOBYTE(wFlag));
                }
            }
        }

        if (opts & OFLAG(w)) {
            ULONG cbwnd = GetTypeSize(SYM(WND));
            ULONG cbwndExtra = (ULONG)ReadField(cbwndExtra);

            Print("\t%d window bytes: ", cbwndExtra);
            if (cbwndExtra) {
                for (ix=0; ix < cbwndExtra; ix += 4) {
                     ULONG64 pdw;

                     pdw = pwnd + cbwnd + ix;
                     move(tempDWord, pdw);
                     Print("%08x ", tempDWord);
                }
            }
            Print("\n");
        }

        /*
         * Print window properties.
         */
        if (opts & OFLAG(o)) {
            ULONG64     psi;
            ULONG64     ppropList;
            ULONG       iFirstFree;
            ULONG       cEntries;
            ULONG       cbProp;
            ULONG       cbOffset;
            ULONG64     pprop;
            UINT        i, j;

            struct {
                LPSTR   pstrName;
                ATOM    atom;
                BOOLEAN bGlobal;
                LPSTR   pstrSymbol;
            } apropatom[] =
            {
                "Icon",         0,  FALSE, "atomIconProp",
                "IconSM",       0,  FALSE, "atomIconSmProp",
                "ContextHelpID",0,  FALSE, "atomContextHelpIdProp",
                "Checkpoint",   0,  TRUE,  VAR(atomCheckpointProp),
                "Flash State",  0,  TRUE,  VAR(gaFlashWState),
                "DDETrack",     0,  TRUE,  VAR(atomDDETrack),
                "QOS",          0,  TRUE,  VAR(atomQOS),
                "DDEImp",       0,  TRUE,  VAR(atomDDEImp),
                "WNDOBJ",       0,  TRUE,  VAR(atomWndObj),
                "IMELevel",     0,  TRUE,  VAR(atomImeLevel),
            };


            /*
             * Get the atom values for internal properties and put them in apropatom.atom
             */
            psi = GetGlobalPointer(VAR(gpsi));
            for (i = 0; i < ARRAY_SIZE(apropatom); i++) {
                if (!apropatom[i].bGlobal) {

                    /*
                     * The atom is stored in psi.
                     */
                    GetFieldValue(psi, SYM(SERVERINFO), apropatom[i].pstrSymbol, apropatom[0].atom);
                } else {

                    /*
                     * The atom is a global.
                     */
                    moveExpValue(&apropatom[i].atom, apropatom[i].pstrSymbol);
                }
            }

            /*
             * Print the property list structure.
             */
            GetFieldValue(pwnd, SYM(WND), "ppropList", ppropList);
            if (!ppropList) {
                Print("\tNULL Property List\n");
            } else {
                InitTypeRead(ppropList, PROPLIST);
                iFirstFree = (ULONG)ReadField(iFirstFree);
                cEntries = (ULONG)ReadField(cEntries);
                Print("\tProperty List @ 0x%p : %d Properties, %d total entries, %d free entries\n",
                        ppropList,
                        iFirstFree,
                        cEntries,
                        cEntries - iFirstFree);

                /*
                 * Print each property.
                 */
                GetFieldOffset(SYM(PROPLIST), "aprop", &cbOffset);
                pprop = ppropList + cbOffset;
                cbProp = GetTypeSize(SYM(PROP));
                for (i = 0; !IsCtrlCHit() && i < iFirstFree; i++, pprop += cbProp) {
                    LPSTR pstrInternal;

                    InitTypeRead(pprop, PROP);

                    /*
                     * Find name for internal property.
                     */
                    pstrInternal = "";
                    if (ReadField(fs) & PROPF_INTERNAL) {
                        for (j = 0; j < ARRAY_SIZE(apropatom); j++) {
                            if (ReadField(atomKey) == apropatom[j].atom) {
                                pstrInternal = apropatom[j].pstrName;
                                break;
                            }
                        }
                    }

                    Print("\tProperty %d\n", i);
                    Print("\t\tatomKey     0x%04x %s\n", (ULONG)ReadField(atomKey), pstrInternal);
                    Print("\t\tfs          0x%04x %s\n", (ULONG)ReadField(fs), GetFlags(GF_PROP, (DWORD)ReadField(fs), NULL, FALSE));
                    Print("\t\thData       0x%p (%I64d)\n", ReadField(hData), ReadField(hData));

            #ifdef KERNEL
                    if (ReadField(fs) & PROPF_INTERNAL) {
                        if (j == 3) {
                            CHECKPOINT  cp;
                            ULONG64 pcp = ReadField(hData);
                            move(cp, pcp);
                            Print("\t\tCheckPoint:\n");
                            Print("\t\trcNormal (%d,%d),(%d,%d) %dx%d\n",
                                    cp.rcNormal.left,
                                    cp.rcNormal.top,
                                    cp.rcNormal.right,
                                    cp.rcNormal.bottom,
                                    cp.rcNormal.right - cp.rcNormal.left,
                                    cp.rcNormal.bottom - cp.rcNormal.top);

                            Print("\t\tptMin    (%d,%d)\n",                cp.ptMin.x, cp.ptMin.y);
                            Print("\t\tptMax    (%d,%d)\n",                cp.ptMax.x, cp.ptMax.y);
                            Print("\t\tfDragged:%d\n",                     cp.fDragged);
                            Print("\t\tfWasMaximizedBeforeMinimized:%d\n", cp.fWasMaximizedBeforeMinimized);
                            Print("\t\tfWasMinimizedBeforeMaximized:%d\n", cp.fWasMinimizedBeforeMaximized);
                            Print("\t\tfMinInitialized:%d\n",              cp.fMinInitialized);
                            Print("\t\tfMaxInitiailized:%d\n",             cp.fMaxInitialized);
                        }
                    }
            #endif // ifdef KERNEL

                    Print("\n");
                }
            }
        }

        Print("---\n");

    } except (CONTINUE) {
    }

    return TRUE;
}

#ifdef KERNEL

/***************************************************************************\
* dws   - dump windows stations
* dws h - dump windows stations plus handle list
*
* Dump WindowStation
*
* 8-11-94 SanfordS  Created
* 6/9/1995 SanfordS made to fit stdexts motif
\***************************************************************************/
BOOL Idws(
    DWORD opts,
    ULONG64 param1)
{
    PTR pwinsta;
    WCHAR ach[80];
    PTR pHead;
    PTR pNameBuffer;
    ULONG ObjectHeaderOffset;
    UCHAR NameInfoOffset;
    PTR NameBuffer;
    ULONG NameLength;
    ULONG cOpen;

    UNREFERENCED_PARAMETER(opts);

    if (param1 == 0) {

        FOREACHWINDOWSTATION(pwinsta)

            Idws(0, pwinsta);
            Print("\n");

        NEXTEACHWINDOWSTATION(pwinsta)

        return TRUE;
    }

    pwinsta = param1;

    GetFieldOffset("nt!OBJECT_HEADER", "Body", &ObjectHeaderOffset);
    pHead = pwinsta - ObjectHeaderOffset;
    GetFieldValue(pHead, "nt!OBJECT_HEADER", "NameInfoOffset", NameInfoOffset);
    pNameBuffer = pHead - NameInfoOffset;
    GetFieldValue(pNameBuffer, "nt!OBJECT_HEADER_NAME_INFO", "Name.Buffer", NameBuffer);
    GetFieldValue(pNameBuffer, "nt!OBJECT_HEADER_NAME_INFO", "Name.Length", NameLength);
    moveBlock(ach, FIXKP(NameBuffer), NameLength);
    ach[NameLength / sizeof(WCHAR)] = L'\0';


    Print("Windowstation: %ws @ 0x%p\n", ach, pwinsta);
    Print(" OBJECT_HEADER @ 0x%p\n", pHead);

    GetFieldValue(pHead, "nt!OBJECT_HEADER", "HandleCount", cOpen);
    Print("  HandleCount        = 0n%d\n", cOpen);
    GetFieldValue(pHead, "nt!OBJECT_HEADER", "PointerCount", cOpen);
    Print("  PointerCount       = 0n%d\n", cOpen);

    InitTypeRead(pwinsta, WINDOWSTATION);
    Print("  pTerm              = %p\n", ReadField(pTerm));
    Print("  rpdeskList         = %p\n", ReadField(rpdeskList));
    Print("  dwFlags            = 0x%08x\n", (DWORD)ReadField(dwWSF_Flags));
    Print("  spklList           = %p\n", ReadField(spklList));
    Print("  ptiClipLock        = %p\n", ReadField(ptiClipLock));
    Print("  spwndClipOpen      = %p\n", ReadField(spwndClipOpen));
    Print("  spwndClipViewer    = %p\n", ReadField(spwndClipViewer));
    Print("  spwndClipOwner     = %p\n", ReadField(spwndClipOwner));
    Print("  pClipBase          = %p\n", ReadField(pClipBase));
    Print("  cNumClipFormats    = 0x%0lx\n", (DWORD)ReadField(cNumClipFormats));
    Print("  ptiDrawingClipboard= %p\n", ReadField(ptiDrawingClipboard));
    Print("  fClipboardChanged  = %d\n",   ReadField(fClipboardChanged));
    Print("  pGlobalAtomTable   = %p\n", ReadField(pGlobalAtomTable));
    Print("  luidUser           = %0lx.%lx\n", (ULONG)ReadField(luidUser.HighPart),
            (ULONG)ReadField(luidUser.LowPart));

    return TRUE;
}

#endif // KERNEL

#ifdef OLD_DEBUGGER

#ifdef KERNEL
/************************************************************************\
* Idwpi
*
* Dumps WOWPROCESSINFO structs
*
* 6/9/1995 Created SanfordS
\************************************************************************/
BOOL Idwpi(
    DWORD opts,
    ULONG64 param1)
{
    PWOWPROCESSINFO pwpi;
    WOWPROCESSINFO wpi;
    PPROCESSINFO ppi;

    if (param1 == 0) {
        FOREACHPPI(ppi)
            Print("Process %p.\n", FIXKP(ppi));
            move(pwpi, FIXKP(&ppi->pwpi));
            SAFEWHILE (pwpi) {
                Idwpi(0, pwpi);
                Print("\n");
                move(pwpi, FIXKP(&pwpi->pwpiNext));
            }
        NEXTEACHPPI()
        return TRUE;
    }

    if (opts & OFLAG(p)) {
        ppi = (PPROCESSINFO)FIXKP(param1);
        move(pwpi, &ppi->pwpi);
        if (pwpi == NULL) {
            Print("No pwpis for this process.\n");
            return TRUE;
        }
        SAFEWHILE (pwpi) {
            Idwpi(0, pwpi);
            Print("\n");
            move(pwpi, &pwpi->pwpiNext);
        }
        return TRUE;
    }

    pwpi = (PWOWPROCESSINFO)FIXKP(param1);
    move(wpi, pwpi);

    Print("PWOWPROCESSINFO @ 0x%p\n", pwpi);
    Print("\tpwpiNext             0x%08lx\n", wpi.pwpiNext);
    Print("\tptiScheduled         0x%08lx\n", wpi.ptiScheduled);
    Print("\tnTaskLock            0x%08lx\n", wpi.nTaskLock);
    Print("\tptdbHead             0x%08lx\n", wpi.ptdbHead);
    Print("\tlpfnWowExitTask      0x%08lx\n", wpi.lpfnWowExitTask);
    Print("\tpEventWowExec        0x%08lx\n", wpi.pEventWowExec);
    Print("\thEventWowExecClient  0x%08lx\n", wpi.hEventWowExecClient);
    Print("\tnSendLock            0x%08lx\n", wpi.nSendLock);
    Print("\tnRecvLock            0x%08lx\n", wpi.nRecvLock);
    Print("\tCSOwningThread       0x%08lx\n", wpi.CSOwningThread);
    Print("\tCSLockCount          0x%08lx\n", wpi.CSLockCount);
    return TRUE;
}
#endif // KERNEL

#ifdef KERNEL

BOOL DHAVerifyHeap(
    PWIN32HEAP pHeap,
    BOOL bVerbose)
{
    DbgHeapHead Alloc, *pAlloc = pHeap->pFirstAlloc;
    int sizeHead, counter = 0;
    char szHeadOrTail[HEAP_CHECK_SIZE];

    if (pAlloc == NULL) {
        return FALSE;
    }

    sizeHead = pHeap->dwFlags & WIN32_HEAP_USE_GUARDS ?
               sizeof(pHeap->szHead) : 0;

    do {
        if (!tryMove(Alloc, pAlloc)) {
            Print("Failed to read pAlloc from %p\n", pAlloc);
            return FALSE;
        }
        /*
         * Check the mark, header and tail
         */
        if (Alloc.mark != HEAP_ALLOC_MARK) {
            Print("!!! Bad mark found in allocation use !dso DbgHeapHead %p\n", pAlloc);
        }
        if (sizeHead) {
            if (!tryMove(szHeadOrTail, (PBYTE)pAlloc-sizeof(szHeadOrTail))) {
                Print("Failed to read szHead from %p\n", (PBYTE)pAlloc-sizeof(szHeadOrTail));
                return FALSE;
            }
            if (!RtlEqualMemory(szHeadOrTail, pHeap->szHead, sizeHead)) {
                Print("Head pattern corrupted for allocation %#p\n", pAlloc);
            }
            if (!tryMove(szHeadOrTail, (PBYTE)pAlloc + sizeof(DbgHeapHead) + Alloc.size)) {
                Print("Failed to read szHead from %p\n", (PBYTE)pAlloc + sizeof(DbgHeapHead) + Alloc.size);
                return FALSE;
            }
            if (!RtlEqualMemory(szHeadOrTail, pHeap->szTail, sizeHead)) {
                Print("Tail pattern corrupted for allocation %#p\n", pAlloc);
            }
        }
        if (bVerbose) {
            Print("Allocation %#p, tag %04d size %08d\n", pAlloc, Alloc.tag, Alloc.size);
        }
        if (counter++ > 100) {
            Print(".");
            counter = 0;
        }
        pAlloc = Alloc.pNext;
    } while (pAlloc != NULL);

    if (bVerbose) {
        Print("To dump an allocation use \"dt DBGHEAPHEAD address\"\n");
    }

    return TRUE;
}

/************************************************************************\
* Idha
*
* Walks the global array of heaps gWin32Heaps looking for an allocation that
* contain the address passed in.  Then does a sanity check on the entire heap
* the allocations belongs to. DHAVerifyHeap is a helper procedure.  Note that
* the passed in parameter is already mapped.
*
* 12/7/1998 Created MCostea
\************************************************************************/
BOOL Idha(
    DWORD opts,
    PVOID pointer)
{
    int ind, counter;
    SIZE_T sizeHead;
    WIN32HEAP localgWin32Heaps[MAX_HEAPS];

    if (pointer == 0 && (opts & OFLAG(a) ==0)) {
        Print("Wrong usage: dha takes a pointer as a parameter\n");
        return FALSE;
    }

    if (!tryMoveBlock(localgWin32Heaps, EvalExp(VAR(gWin32Heaps)), sizeof(localgWin32Heaps)))
    {
        Print("Can't read the heap globals fix symbols and !reload win32k.sys\n");
        return TRUE;
    }

    /*
     * Walk gWin32Heaps array and look for an allocation containing this pointer
     */
    for (ind = counter = 0; ind < MAX_HEAPS; ind++) {

        /*
         * Is the address in this heap?
         */
        if ((opts & OFLAG(a)) == 0) {
            if ((PVOID)localgWin32Heaps[ind].heap > pointer ||
                (PBYTE)localgWin32Heaps[ind].heap + localgWin32Heaps[ind].heapReserveSize < (PBYTE)pointer) {

                continue;
            }
        }

        Print("\nHeap number %d ", ind);
        Print("at address %p, flags %d is ", localgWin32Heaps[ind].heap, localgWin32Heaps[ind].dwFlags);


        if (localgWin32Heaps[ind].dwFlags & WIN32_HEAP_INUSE) {

            DbgHeapHead  Alloc, *pAlloc;

            Print("in use\n");
            if (localgWin32Heaps[ind].pFirstAlloc == NULL)
                continue;

            pAlloc = localgWin32Heaps[ind].pFirstAlloc;
            if (localgWin32Heaps[ind].dwFlags & WIN32_HEAP_USE_GUARDS) {
                sizeHead =  sizeof(localgWin32Heaps[0].szHead);
                Print("    has string quards szHead %s, szTail %s\n",
                        localgWin32Heaps[0].szHead,
                        localgWin32Heaps[0].szTail);
            } else {
                sizeHead =  0;
                Print("no string quards\n");
            }

            if (opts & OFLAG(a)) {
                if (DHAVerifyHeap(&localgWin32Heaps[ind], opts & OFLAG(v))) {
                    Print("WIN32HEAP at %p is healthy\n", localgWin32Heaps[ind].heap);
                }
                continue;
            }
            do {
                if (!tryMove(Alloc, pAlloc)) {
                    Print("Failed to read pAlloc %p\n", pAlloc);
                    return TRUE;
                }
                if ((PBYTE)pAlloc - sizeHead < (PBYTE)pointer &&
                    (PBYTE)pAlloc + sizeof(DbgHeapHead) + Alloc.size + sizeHead > (PBYTE)pointer) {

                    /*
                     * Found the allocation
                     */
                    Print("Found allocation %p ", pAlloc);
                    if (pointer == (PBYTE)pAlloc + sizeof(DbgHeapHead)) {
                        Print("as the begining of a heap allocated block\n");
                    } else {
                        Print("inside a heap allocated block\n");
                    }
                    Print("tag %04d size %08d now verify the heap\n", Alloc.tag, Alloc.size);
                    /*
                     * Verify the entire heap for corruption
                     */
                    if (DHAVerifyHeap(&localgWin32Heaps[ind], opts & OFLAG(v))) {
                        Print("WIN32HEAP at %p is healthy\n", localgWin32Heaps[ind].heap);
                    }
                    return TRUE;
                } else {
                    pAlloc = Alloc.pNext;
                    if (counter++ > 100) {
                        counter = 0;
                        Print(".");
                    }
                }

            } while (pAlloc != NULL);
        } else {
            Print("NOT in use\n");
        }
    }
    Print("No heap contains this pointer %p\n", pointer);
    return TRUE;
}
#endif // KERNEL
#endif // OLD_DEBUGGER

#ifdef KERNEL
/***************************************************************************\
* ddl   - dump desktop log
*
* 12-03-97 CLupu  Created
\***************************************************************************/
BOOL Iddl(
    DWORD opts,
    ULONG64 param1)
{
#ifdef LOGDESKTOPLOCKS
    ULONG64                 pdesk, pLog, pObjHeader, pStack, ptr, dwOffset64;
    ULONG                   dwOffset, dwTraceOffset, dwPVOIDSize, dwLogDSize;
    OBJECT_HEADER           Head;
    BOOL                    bExtra = FALSE;
    int                     i, ind, nLockCount, nLogCrt;
    LONG                    HandleCount, PointerCount;
    WORD                    type, tag;
    CHAR                    symbol[160];
    ULONG_PTR               extra;

    if (param1 == 0) {
        Print("Use !ddl pdesk\n");
        return TRUE;
    }

    pdesk = param1;
    GetFieldOffset("nt!OBJECT_HEADER", "Body", &dwOffset);
    pObjHeader = pdesk - dwOffset;

    Print("Desktop locks:\n\n");
    GetFieldValue(pObjHeader, "nt!OBJECT_HEADER", "HandleCount", HandleCount);
    GetFieldValue(pObjHeader, "nt!OBJECT_HEADER", "PointerCount", PointerCount);
    Print("# HandleCount      = %d\n", HandleCount);
    Print("# PointerCount     = %d\n", PointerCount);

    if (GetFieldValue(pdesk, SYM(DESKTOP), "nLockCount", nLockCount)) {
        Print("Couldn't get PointerCount for pdesk %p\n", pdesk);
    }
    Print("# Log PointerCount = %d\n\n", nLockCount);

    GetFieldValue(pdesk, SYM(DESKTOP), "pLog", pLog);

    if (opts & OFLAG(v)) {
        bExtra = TRUE;
    }

    dwLogDSize = GetTypeSize("LogD");
    dwPVOIDSize = GetTypeSize("PVOID");
    GetFieldOffset(SYM(LogD), "trace", &dwTraceOffset);
    GetFieldValue(pdesk, SYM(DESKTOP), "nLogCrt", nLogCrt);
    for (i = 0; i < nLogCrt; i++) {
        if (IsCtrlCHit()) {
            break;
        }
        GetFieldValue(pLog, "LogD", "tag", tag);
        GetFieldValue(pLog, "LogD", "type", type);
        GetFieldValue(pLog, "LogD", "extra", extra);

        Print("%s Tag %6d Extra %8lx\n",
              (type ? "LOCK  " : "UNLOCK"),
               tag, extra);

        if (bExtra) {
            Print("----------------------------------------------\n");

            for (ind = 0; ind < 6; ind++) {
                pStack = pLog + dwTraceOffset + dwPVOIDSize * ind;
                ReadPointer(pStack, &ptr);
                if (ptr == 0) {
                    break;
                }

                GetSym(ptr, symbol, &dwOffset64);
                if (*symbol) {
                    Print("\t%s", symbol);
                    if (dwOffset64) {
                        Print(" +0x%x\n", (ULONG)dwOffset64);
                    }
                }
            }
            Print("\n");
        }
        pLog += dwLogDSize;
    }
    return TRUE;
#else
    Print("!ddl is available only on LOGDESKTOPLOCKS enabled builds of win32k.sys\n");
    return FALSE;
    UNREFERENCED_PARAMETER(opts);
    UNREFERENCED_PARAMETER(param1);
#endif // LOGDESKTOPLOCKS
}
#endif // KERNEL

#ifdef KERNEL
/***************************************************************************\
* dcss   - dump critical section stack
*
* Dump critical section stack
*
* 12-27-1996 CLupu    Created
* 06-26-2001 JasonSch Made Win64-clean.
\***************************************************************************/
BOOL Idcss(
    DWORD opts)
{
    int        nFrames;
    ULONG64    pStack;

    UNREFERENCED_PARAMETER(opts);

    moveExp(&pStack, SYM(gCritStack));
    _InitTypeRead(pStack, SYM(CRITSTACK));

    if ((nFrames = (int)ReadField(nFrames)) > 0) {

        DumpThread(0, ReadField(thread));
#if 0
        Print("\nthread : 0x%p\n", ReadField(thread));
#endif
        Print("--- Critical section stack trace ---\n");

        PrintStackTrace(ReadField(trace), nFrames);
    }

    return TRUE;
}

#ifdef OLD_DEBUGGER
BOOL Idvs(
    DWORD opts,
    ULONG64 param1)
{
    PWin32Section pSection;
    Win32Section  Section;
    PWin32MapView pView;
    Win32MapView  View;
    BOOL          bIncludeStackTrace = FALSE;

    UNREFERENCED_PARAMETER(opts);
    UNREFERENCED_PARAMETER(param1);

    if (EvalExp(VAR(gpSections)) == NULL) {
        Print("!dvs is available if TRACE_MAP_VIEWS is defined\n");
        return FALSE;
    }

    pSection = GetGlobalPointer(VAR(gpSections));

    if (opts & OFLAG(s)) {
        bIncludeStackTrace = TRUE;
    }

    while (pSection != NULL) {
        if (!tryMove(Section, pSection)) {
            Print("!dvs: Could not get pSection structure for %#p\n", pSection);
            return FALSE;
        }

        Print(">>--------------------------------------\n");

        Print("Section          %#p\n"
              "   pFirstView    %#p\n"
              "   SectionObject %#p\n"
              "   SectionSize   0x%x\n"
              "   SectionTag    0x%x\n",
              pSection,
              Section.pFirstView,
              Section.SectionObject,
              Section.SectionSize,
              Section.SectionTag);

        if (bIncludeStackTrace) {
#ifdef MAP_VIEW_STACK_TRACE
            ULONG64 dwOffset;
            CHAR  symbol[160];
            int   ind;

            for (ind = 0; ind < MAP_VIEW_STACK_TRACE_SIZE; ind++) {
                if (Section.trace[ind] == 0) {
                    break;
                }

                GetSym((PVOID)Section.trace[ind], symbol, &dwOffset);
                if (*symbol) {
                    Print("   %s", symbol);
                    if (dwOffset) {
                        Print("+0x%p\n", dwOffset);
                    }
                }
            }
            Print("\n");
#endif // MAP_VIEW_STACK_TRACE
        }

        pView = Section.pFirstView;

        while (pView != NULL) {
            if (!tryMove(View, pView)) {
                Print("!dvs: Could not get pView structure for %#p\n", pView);
                return FALSE;
            }

            Print("Views: ---------------------------------\n"
                  " View          %#p\n"
                  "    pViewBase  %#p\n"
                  "    ViewSize   %#p\n",
                  pView,
                  View.pViewBase,
                  View.ViewSize);

            if (bIncludeStackTrace) {
#ifdef MAP_VIEW_STACK_TRACE
                ULONG64 dwOffset;
                CHAR  symbol[160];
                int   ind;

                for (ind = 0; ind < MAP_VIEW_STACK_TRACE_SIZE; ind++) {
                    if (View.trace[ind] == 0) {
                        break;
                    }

                    GetSym((PVOID)View.trace[ind], symbol, &dwOffset);
                    if (*symbol) {
                        Print("    %s", symbol);
                        if (dwOffset) {
                            Print("+%p\n", dwOffset);
                        }
                    }
                }
                Print("\n");
#endif // MAP_VIEW_STACK_TRACE
            }

            pView = View.pNext;
        }

        pSection = Section.pNext;
    }

    return TRUE;
}

BOOL Idfa(
    DWORD opts,
    ULONG64 param1)
{
    ULONG64    dwOffset;
    CHAR       symbol[160];
    int        ind;
    PVOID*     pTrace;
    PVOID      trace;
    DWORD      dwAllocFailIndex;
    DWORD*     pdwAllocFailIndex;
    PEPROCESS  pep;
    PEPROCESS* ppep;
    PETHREAD   pet;
    PETHREAD*  ppet;

    UNREFERENCED_PARAMETER(opts);
    UNREFERENCED_PARAMETER(param1);

    if (EvalExp(VAR(gdwAllocFailIndex)) == NULL) {
        Print("!dfa is available only in debug versions of win32k.sys\n");
        return FALSE;
    }

    moveExp(&pdwAllocFailIndex, VAR(gdwAllocFailIndex));
    if (!tryMove(dwAllocFailIndex, pdwAllocFailIndex)) {
        Print("dfa failure");
        return FALSE;
    }

    moveExp(&ppep, VAR(gpepRecorded));
    if (!tryMove(pep, ppep)) {
        Print("dfa failure");
        return FALSE;
    }
    moveExp(&ppet, VAR(gpetRecorded));
    if (!tryMove(pet, ppet)) {
        Print("dfa failure");
        return FALSE;
    }

    Print("Fail allocation index %d 0x%04x\n", dwAllocFailIndex, dwAllocFailIndex);
    Print("pEProcess %#p pEThread %#p\n\n", pep, pet);

    moveExp(&pTrace, VAR(gRecordedStackTrace));

    for (ind = 0; ind < 12; ind++) {

        if (!tryMove(trace, pTrace)) {
            Print("dfa failure");
            return FALSE;
        }

        if (trace == 0) {
            break;
        }

        GetSym((PVOID)trace, symbol, &dwOffset);
        if (*symbol) {
            Print("\t%s", symbol);
            if (dwOffset) {
                Print("+%p\n", dwOffset);
            }
        }

        pTrace++;
    }
    Print("\n");
    return TRUE;
}
#endif // OLD_DEBUGGER

VOID PrintStackTrace(
    ULONG64 pStackTrace,
    int    tracesCount)
{
    int       traceInd;
    ULONG64   dwOffset, pSymbol;
    CHAR      symbol[160];
    DWORD     dwPointerSize = GetTypeSize("PVOID");

    for (traceInd = 0; traceInd < tracesCount; traceInd++) {
        ReadPointer(pStackTrace, &pSymbol);
        if (pSymbol == 0) {
            break;
        }

        GetSym(pSymbol, symbol, &dwOffset);
        if (*symbol) {
            Print("\t%s", symbol);
            if (dwOffset) {
                Print("+%p\n", dwOffset);
            } else {
                Print("\n");
            }
        }

        pStackTrace += dwPointerSize;
    }
    Print("\n");
}

/***************************************************************************\
* dpa - dump pool allocations
*
* Dump pool allocations.
*
* 12-27-96 CLupu  Created
\***************************************************************************/
BOOL Idpa(
    DWORD opts,
    ULONG64 param1)
{
    try {
        ULONG64          pAllocList;
        DWORD            dwPoolFlags;
        DWORD            dwSize = GetTypeSize(SYM(tagWin32PoolHead));
        BOOL             bIncludeStackTrace = FALSE;

        moveExpValue(&dwPoolFlags, VAR(gdwPoolFlags));
        if (!(dwPoolFlags & POOL_HEAVY_ALLOCS)) {
            Print("win32k.sys doesn't have pool instrumentation !\n");
            return FALSE;
        }

        if (opts & OFLAG(s)) {
            if (dwPoolFlags & POOL_CAPTURE_STACK) {
                bIncludeStackTrace = TRUE;
            } else {
                Print("win32k.sys doesn't have stack traces enabled for pool allocations\n");
            }
        }

        moveExp(&pAllocList, VAR(gAllocList));
        if (!pAllocList) {
            Print("Could not get Win32AllocStats structure win32k!gAllocList\n");
            return FALSE;
        }

        _InitTypeRead(pAllocList, SYM(tagWin32AllocStats));
        if (opts & OFLAG(c)) {
            Print("- pool instrumentation enabled for win32k.sys\n");
            if (dwPoolFlags & POOL_CAPTURE_STACK) {
                Print("- stack traces enabled for pool allocations\n");
            } else {
                Print("- stack traces disabled for pool allocations\n");
            }


            if (dwPoolFlags & POOL_KEEP_FAIL_RECORD) {
                Print("- records of failed allocations enabled\n");
            } else {
                Print("- records of failed allocations disabled\n");
            }

            if (dwPoolFlags & POOL_KEEP_FREE_RECORD) {
                Print("- records of free pool enabled\n");
            } else {
                Print("- records of free pool disabled\n");
            }

            Print("\n");

            Print("    CrtM         CrtA         MaxM         MaxA       Head\n");
            Print("------------|------------|------------|------------|------------|\n");
            InitTypeRead(pAllocList, Win32AllocStats);
            Print(" 0x%08x   0x%08x   0x%08x   0x%08x   0x%I64x\n",
                  (ULONG)ReadField(dwCrtMem),
                  (ULONG)ReadField(dwCrtAlloc),
                  (ULONG)ReadField(dwMaxMem),
                  (ULONG)ReadField(dwMaxAlloc),
                  ReadField(pHead));

            return TRUE;
        }

        _InitTypeRead(pAllocList, SYM(tagWin32AllocStats));
        if (opts & OFLAG(f)) {

            DWORD        dwFailRecordCrtIndex, dwFailRecordTotalFailures;
            DWORD        dwFailRecords, Ind, dwFailuresToDump;
            ULONG64      pFailRecord, pFailRecordOrg;

            if (!(dwPoolFlags & POOL_KEEP_FAIL_RECORD)) {
                Print("win32k.sys doesn't have records of failed allocations!\n");
                return TRUE;
            }

            dwFailRecordTotalFailures = (DWORD)EvalExp(VAR(gdwFailRecordTotalFailures));
            if (dwFailRecordTotalFailures == 0) {
                Print("No allocation failure in win32k.sys!\n");
                return TRUE;
            }

            dwFailRecordCrtIndex = (DWORD)EvalExp(VAR(gdwFailRecordCrtIndex));
            dwFailRecords = (DWORD)EvalExp(VAR(gdwFailRecords));
            if (dwFailRecordTotalFailures < dwFailRecords) {
                dwFailuresToDump = dwFailRecordTotalFailures;
            } else {
                dwFailuresToDump = dwFailRecords;
            }

            pFailRecord = GetGlobalPointer(VAR(gparrFailRecord));
            if (!pFailRecord) {
                Print("\nCouldn't get gparrFailRecord!\n");
                return FALSE;
            }

            pFailRecordOrg = pFailRecord;

            Print("\nFailures to dump : %d\n\n", dwFailuresToDump);

            for (Ind = 0; Ind < dwFailuresToDump; Ind++) {
                DWORD      tag[2] = {0, 0};

                if (dwFailRecordCrtIndex == 0) {
                    dwFailRecordCrtIndex = dwFailRecords - 1;
                } else {
                    dwFailRecordCrtIndex--;
                }

                pFailRecord = pFailRecordOrg + dwFailRecordCrtIndex;

                _InitTypeRead(pFailRecord, SYM(tagPOOLRECORD));

                tag[0] = (DWORD)(DWORD_PTR)ReadField(ExtraData);

                Print("Allocation for tag '%s' size 0x%x failed\n",
                      &tag,
                      (ULONG)ReadField(size));

                PrintStackTrace(ReadField(pTrace), RECORD_STACK_TRACE_SIZE);
            }
        }

        _InitTypeRead(pAllocList, SYM(tagWin32AllocStats));
        if (opts & OFLAG(r)) {

            DWORD        dwFreeRecordCrtIndex, dwFreeRecordTotalFrees;
            DWORD        dwFreeRecords, Ind, dwFreesToDump;
            ULONG64      pFreeRecord, pFreeRecordOrg;

            if (!(dwPoolFlags & POOL_KEEP_FREE_RECORD)) {
                Print("win32k.sys doesn't have records of free pool !\n");
                return FALSE;
            }

            dwFreeRecordTotalFrees = (DWORD)EvalExp(VAR(gdwFreeRecordTotalFrees));
            if (dwFreeRecordTotalFrees == 0) {
                Print("No free pool in win32k.sys !\n");
                return FALSE;
            }

            dwFreeRecordCrtIndex = (DWORD)EvalExp(VAR(gdwFreeRecordCrtIndex));
            dwFreeRecords = (DWORD)EvalExp(VAR(gdwFreeRecords));
            if (dwFreeRecordTotalFrees < dwFreeRecords) {
                dwFreesToDump = dwFreeRecordTotalFrees;
            } else {
                dwFreesToDump = dwFreeRecords;
            }

            pFreeRecord = GetGlobalPointer(VAR(gparrFreeRecord));
            if (!pFreeRecord) {
                Print("\nCouldn't get gparrFreeRecord!\n");
                return FALSE;
            }

            pFreeRecordOrg = pFreeRecord;

            Print("\nFrees to dump : %d\n\n", dwFreesToDump);

            for (Ind = 0; Ind < dwFreesToDump; Ind++) {
                if (dwFreeRecordCrtIndex == 0) {
                    dwFreeRecordCrtIndex = dwFreeRecords - 1;
                } else {
                    dwFreeRecordCrtIndex--;
                }

                pFreeRecord = pFreeRecordOrg + dwFreeRecordCrtIndex;

                /*
                 * Dump
                 */
                _InitTypeRead(pFreeRecord, SYM(tagPOOLRECORD));
                Print("Free pool for p %#p size 0x%x\n",
                      ReadField(ExtraData),
                      (ULONG)ReadField(size));

                PrintStackTrace(ReadField(pTrace), RECORD_STACK_TRACE_SIZE);
            }
        }

        _InitTypeRead(pAllocList, SYM(tagWin32AllocStats));
        if (opts & OFLAG(v)) {
            ULONG64 ph = ReadField(pHead);

            while (ph != 0) {
                _InitTypeRead(ph, SYM(tagWin32PoolHead));
                Print("p %#p pHead %#p size %x\n",
                      ph + dwSize, ph, (ULONG)ReadField(size));

                    if (bIncludeStackTrace) {
                        ULONG64   dwOffset;
                        CHAR      symbol[160];
                        int       ind;
                        ULONG64   trace;
                        ULONG64   pTrace;

                        pTrace = ReadField(pTrace);
                        for (ind = 0; ind < POOL_ALLOC_TRACE_SIZE; ind++) {
                            ReadPointer(pTrace, &trace);
                            if (trace == 0) {
                                break;
                            }

                        GetSym(trace, symbol, &dwOffset);
                        if (*symbol) {
                            Print("\t%s", symbol);
                            if (dwOffset != 0) {
                                Print("+0x%I64x", dwOffset);
                            }
                            Print("\n");
                        }

                        ++pTrace;
                    }
                    Print("\n");
                }

                ph = (ULONG_PTR)ReadField(pNext);
            }
            return TRUE;
        }

        _InitTypeRead(pAllocList, SYM(tagWin32AllocStats));
        if (opts & OFLAG(p)) {
            ULONG64        ph;
            DWORD          dwSize = GetTypeSize(SYM(tagWin32PoolHead));

            if (param1 == 0) {
                return TRUE;
            }

            ph = ReadField(pHead);
            while (ph != 0) {
                if ((param1 - ph) >= ((ULONG)ReadField(size) + dwSize)) {
                    Print("p %#p pHead %#p size %x\n",
                          ph + 1, ph, (ULONG)ReadField(size));

                    PrintStackTrace(ReadField(pTrace), RECORD_STACK_TRACE_SIZE);
                    return TRUE;
                }

                ph = ReadField(pNext);
            }
            return TRUE;
        }
    } except (CONTINUE) {
    }
    return TRUE;
}
#endif // KERNEL


#ifdef OLD_DEBUGGER
/************************************************************************\
* Ifno
*
* Find Nearest Objects - helps in figureing out references
* to freed objects or stale pointers.
*
* 6/9/1995 Created SanfordS
\************************************************************************/
BOOL Ifno(
    DWORD opts,
    ULONG64 param1)
{
    HANDLEENTRY he, heBest, heAfter, *phe;
    DWORD i;
    DWORD hBest, hAfter;
    DWORD_PTR dw;

    UNREFERENCED_PARAMETER(opts);

    if (param1 == 0) {
        Print("Expected an address.\n");
        return FALSE;
    }

    dw = (DWORD_PTR)FIXKP(param1);
    heBest.phead = NULL;
    heAfter.phead = (PVOID)-1;

    if (dw != (DWORD_PTR)param1) {
        /*
         * no fixups needed - he's looking the kernel address range.
         */
        FOREACHHANDLEENTRY(phe, he, i)
            if ((DWORD_PTR)he.phead <= dw &&
                    heBest.phead < he.phead &&
                    he.bType != TYPE_FREE) {
                heBest = he;
                hBest = i;
            }
            if ((DWORD_PTR)he.phead > dw &&
                    heAfter.phead > he.phead &&
                    he.bType != TYPE_FREE) {
                heAfter = he;
                hAfter = i;
            }
        NEXTEACHHANDLEENTRY()

        if (heBest.phead != NULL) {
            Print("Nearest guy before %#p is a %s object located at %#p (i=%x).\n",
                    dw, aszTypeNames[heBest.bType], heBest.phead, hBest);
        }
        if (heAfter.phead != (PVOID)-1) {
            Print("Nearest guy after %#p is a %s object located at %#p. (i=%x)\n",
                    dw, aszTypeNames[heAfter.bType], heAfter.phead, hAfter);
        }
    } else {
        /*
         * fixups are needed.
         */
        FOREACHHANDLEENTRY(phe, he, i)
            if ((DWORD_PTR)FIXKP(he.phead) <= dw &&
                    heBest.phead < he.phead &&
                    he.bType != TYPE_FREE) {
                heBest = he;
                hBest = i;
            }
            if ((DWORD_PTR)FIXKP(he.phead) > dw &&
                    heAfter.phead > he.phead &&
                    he.bType != TYPE_FREE) {
                heAfter = he;
                hAfter = i;
            }
        NEXTEACHHANDLEENTRY()

        if (heBest.phead != NULL) {
            Print("Nearest guy before %#p is a %s object located at %#p (i=%x).\n",
                    dw, aszTypeNames[heBest.bType], FIXKP(heBest.phead), hBest);
        }
        if (heAfter.phead != (PVOID)-1) {
            Print("Nearest guy after %#p is a %s object located at %#p. (i=%x)\n",
                    dw, aszTypeNames[heAfter.bType], FIXKP(heAfter.phead), hAfter);
        }
    }
    return TRUE;
}




/************************************************************************\
* Ifrr
*
* Finds Range References - helpful for finding stale pointers.
*
* fSuccess
*
* 6/9/1995 Created SanfordS
\************************************************************************/
BOOL Ifrr(
    DWORD opts,
    ULONG64 param1,
    ULONG64 param2,
    ULONG64 param3,
    ULONG64 param4)
{
    DWORD_PTR pSrc1 = (DWORD_PTR)param1;
    DWORD_PTR pSrc2 = (DWORD_PTR)param2;
    DWORD_PTR pRef1 = (DWORD_PTR)param3;
    DWORD_PTR pRef2 = (DWORD_PTR)param4;
    DWORD_PTR dw;
    DWORD_PTR buffer[PAGE_SIZE / sizeof(DWORD_PTR)];

    UNREFERENCED_PARAMETER(opts);

    if (pSrc2 < pSrc1) {
        Print("Source range improper.  Values reversed.\n");
        dw = pSrc1;
        pSrc1 = pSrc2;
        pSrc2 = dw;
    }
    if (pRef2 == 0) {
        pRef2 = pRef1;
    }
    if (pRef2 < pRef1) {
        Print("Reference range improper.  Values reversed.\n");
        dw = pRef1;
        pRef1 = pRef2;
        pRef2 = dw;
    }

    pSrc1 &= MAXULONG_PTR - PAGE_SIZE + 1;  // PAGE aligned
    pSrc2 = (pSrc2 + (sizeof(DWORD_PTR)-1)) & (MAXULONG_PTR - (sizeof(DWORD_PTR)-1));   // dword_ptr aligned

    Print("Searching range (%#p-%#p) for references to (%#p-%#p)...",
            pSrc1, pSrc2, pRef1, pRef2);

    for (; pSrc1 < pSrc2; pSrc1 += PAGE_SIZE) {
        BOOL fSuccess;

        if (!(pSrc1 & 0xFFFFFF)) {
            Print("\nSearching %#p...", pSrc1);
        }
        fSuccess = tryMoveBlock(buffer, (PVOID)pSrc1, sizeof(buffer));
        if (!fSuccess) {
            /*
             * Skip to next page
             */
        } else {
            for (dw = 0; dw < ARRAY_SIZE(buffer); dw++) {
                if (buffer[dw] >= pRef1 && buffer[dw] <= pRef2) {
                    Print("\n[%#p] = %#p ",
                            pSrc1 + dw * sizeof(DWORD_PTR),
                            buffer[dw]);
                }
            }
        }
        if (IsCtrlCHit()) {
            Print("\nSearch aborted.\n");
            return TRUE;
        }
    }
    Print("\nSearch complete.\n");
    return TRUE;
}


#ifdef KERNEL
//PGDI_DEVICE undefined
#if 0
VOID ddGdiDevice(
PGDI_DEVICE pGdiDevice)
{
    Print("\t\tGDI_DEVICE\n");
    Print("\t\tcRefCount       = %d\n",     pGdiDevice->cRefCount);
    Print("\t\thDevInfo        = 0x%.8x\n", pGdiDevice->hDevInfo);
    Print("\t\thDev            = 0x%.8x\n", pGdiDevice->hDev);
    Print("\t\trcScreen        = (%d,%d)-(%d,%d) %dx%d\n",
            pGdiDevice->rcScreen.left, pGdiDevice->rcScreen.top,
            pGdiDevice->rcScreen.right, pGdiDevice->rcScreen.bottom,
            pGdiDevice->rcScreen.right - pGdiDevice->rcScreen.left,
            pGdiDevice->rcScreen.bottom - pGdiDevice->rcScreen.top);
    Print("\t\tDEVMODEW\n");
}
#endif
#endif


#endif // OLD_DEBUGGER

VOID
DumpMonitor(
    ULONG64 param1,
    LPSTR pstrPrefix)
{
    DWORD dwMONFlags;
    RECT rc;

    InitTypeRead(param1, MONITOR);

    Print("%shead.h             = 0x%.8x\n", pstrPrefix, ReadField(head.h));
    Print("%shead.cLockObj      = 0x%.8x\n", pstrPrefix, ReadField(head.cLockObj));
    Print("%spMonitorNext       = 0x%p\n", pstrPrefix, ReadField(pMonitorNext));
    dwMONFlags = (DWORD)ReadField(dwMONFlags);
    Print("%sdwMONFlags         = 0x%.8x %s\n", pstrPrefix, dwMONFlags, GetFlags(GF_MON, dwMONFlags, NULL, FALSE));

    GetFieldValue(param1, SYM(MONITOR), "rcMonitor", rc);

    Print("%srcMonitor          = (%d,%d)-(%d,%d) %dx%d\n",
            pstrPrefix, rc.left, rc.top, rc.right, rc.bottom, rc.right - rc.left, rc.bottom - rc.top);

    GetFieldValue(param1, SYM(MONITOR), "rcWork", rc);

    Print("%srcWork             = (%d,%d)-(%d,%d) %dx%d\n",
            pstrPrefix, rc.left, rc.top, rc.right, rc.bottom, rc.right - rc.left, rc.bottom - rc.top);

    Print("%shrgnMonitor        = 0x%.8x\n", pstrPrefix, ReadField(hrgnMonitor));
    Print("%scFullScreen        = %d\n",     pstrPrefix, (short)ReadField(cFullScreen));
    Print("%scwndStack          = %d\n",     pstrPrefix, (short)ReadField(cWndStack));

#ifdef SUBPIXEL_MOUSE
    {
        DWORD dwOffset;
        FIXPOINT xTxf[SM_POINT_CNT], yTxf[SM_POINT_CNT];
        FIXPOINT slope[SM_POINT_CNT - 1], yint[SM_POINT_CNT - 1];

        GetFieldOffset(SYM(MONITOR), "xTxf", &dwOffset);
        move(xTxf, param1 + dwOffset);
        GetFieldOffset(SYM(MONITOR), "yTxf", &dwOffset);
        move(yTxf, param1 + dwOffset);
        GetFieldOffset(SYM(MONITOR), "slope", &dwOffset);
        move(slope, param1 + dwOffset);
        GetFieldOffset(SYM(MONITOR), "yint", &dwOffset);
        move(yint, param1 + dwOffset);
        Print("%sxTxf = {", pstrPrefix);
        for (dwOffset = 0; dwOffset < SM_POINT_CNT; ++dwOffset) {
            Print("0x%I64x", xTxf[dwOffset]);
            if (dwOffset != SM_POINT_CNT - 1) {
                Print(", ");
            }
        }
        Print("}\n");

        Print("%syTxf = {", pstrPrefix);
        for (dwOffset = 0; dwOffset < SM_POINT_CNT; ++dwOffset) {
            Print("0x%I64x", yTxf[dwOffset]);
            if (dwOffset != SM_POINT_CNT - 1) {
                Print(", ");
            }
        }
        Print("}\n");

        Print("%sslope = {", pstrPrefix);
        for (dwOffset = 0; dwOffset < SM_POINT_CNT - 1; ++dwOffset) {
            Print("0x%I64x", slope[dwOffset]);
            if (dwOffset != SM_POINT_CNT - 2) {
                Print(", ");
            }
        }
        Print("}\n");

        Print("%syint = {", pstrPrefix);
        for (dwOffset = 0; dwOffset < SM_POINT_CNT - 1; ++dwOffset) {
            Print("0x%I64x", yint[dwOffset]);
            if (dwOffset != SM_POINT_CNT - 2) {
                Print(", ");
            }
        }
        Print("}\n");
    }
#endif // SUBPIXEL_MOUSE
}

BOOL Idmon(
    DWORD opts,
    ULONG64 param1)
{
    UNREFERENCED_PARAMETER(opts);

    if (param1 == NULL_POINTER) {
        return FALSE;
    }

    Print("Dumping MONITOR at %p\n", param1);
    DumpMonitor(param1, "\t");

    return TRUE;
}

BOOL Idy(
    DWORD opts,
    ULONG64 param1)
{
    ULONG64         pdi, gpdi, pMonitor, pshi;
    ULONG64         psi;
    ULONG           i;
    BOOLEAN         fBool;
    ULONG           cMonitors;
    RECT            rcScreen;
    WORD            dmLogPixels;

    UNREFERENCED_PARAMETER(opts);

    GETSHAREDINFO(pshi);
    GetFieldValue((ULONG64)pshi, SYM(SHAREDINFO), "pDispInfo", gpdi);

    if (param1) {
        pdi = param1;
    } else {
        pdi = gpdi;
    }

    psi = GetGlobalPointer(VAR(gpsi));
    GetFieldValue(psi, SYM(SERVERINFO), "rcScreen", rcScreen);
    GetFieldValue(psi, SYM(SERVERINFO), "dmLogPixels", dmLogPixels);

    InitTypeRead(pdi, DISPLAYINFO);
    cMonitors = (ULONG)ReadField(cMonitors);

    Print("Dumping DISPLAYINFO at 0x%.8x\n", pdi);
    Print("\thDev                  = 0x%.8x\n", ReadField(hDev));
    Print("\thdcScreen             = 0x%.8x\n", ReadField(hdcScreen));

    Print("\thdcBits               = 0x%.8x\n", ReadField(hdcBits));

    Print("\thdcGray               = 0x%.8x\n", ReadField(hdcGray));
    Print("\thbmGray               = 0x%.8x\n", ReadField(hbmGray));
    Print("\tcxGray                = %d\n",     ReadField(cxGray));
    Print("\tcyGray                = %d\n",     ReadField(cyGray));
    Print("\tpdceFirst             = 0x%.8x\n", ReadField(pdceFirst));
    Print("\tpspbFirst             = 0x%.8x\n", ReadField(pspbFirst));
    Print("\tcMonitors (visible)   = %d\n",               cMonitors);

    Print("\tpMonitorPrimary       = 0x%.8x\n", RebaseSharedPtr(ReadField(pMonitorPrimary)));
    Print("\tpMonitorFirst         = 0x%.8x\n", RebaseSharedPtr(ReadField(pMonitorFirst)));

    Print("\trcScreen              = (%d,%d)-(%d,%d) %dx%d\n",

                                     rcScreen.left, rcScreen.top,
                                     rcScreen.right, rcScreen.bottom,
                                     rcScreen.right - rcScreen.left,
                                     rcScreen.bottom - rcScreen.top);

    Print("\thrgnScreen            = 0x%.8x\n", ReadField(hrgnScreen));
    Print("\tdmLogPixels           = %d\n",     (WORD)ReadField(dmLogPixels));
    Print("\tBitCountMax           = %d\n",     (WORD)ReadField(BitCountMax));
    GetFieldValue(pdi, SYM(DISPLAYINFO), "fDesktopIsRect", fBool);
    Print("\tfDesktopIsRect        = %d\n",     fBool);
    GetFieldValue(pdi, SYM(DISPLAYINFO), "fAnyPalette", fBool);
    Print("\tfAnyPalette           = %d\n",     fBool);
    Print("\n");

    if (pdi == gpdi) {
        if (dmLogPixels != (WORD)ReadField(dmLogPixels)) {
            Print("\n\n");
            Print("ERROR - dmLogPixels doesn't match in gpsi (%d) and gpDispInfo (%d)\n",
                  dmLogPixels, (WORD)ReadField(dmLogPixels));
            Print("\n\n");
        }

    }

    for (   pMonitor = ReadField(pMonitorFirst), i = 1;
            pMonitor;
            GetFieldValue(pMonitor, SYM(MONITOR), "pMonitorNext", pMonitor), i++) {

        pMonitor = RebaseSharedPtr(pMonitor);
        Print("\tMonitor %d, pMonitor = 0x%.8x\n", i, pMonitor);
        DumpMonitor(pMonitor, "\t\t");
        Print("\n");
    }

    return TRUE;
}

#ifdef KERNEL
/***************************************************************************\
* kbd [queue]
*
* Loads a DLL containing more debugging extensions
*
* 10/27/92 IanJa        Created.
* 6/9/1995 SanfordS     made to fit stdexts motif
\***************************************************************************/
typedef struct {
    int iVK;
    LPSTR pszVK;
} VK, *PVK;

VK aVK[] = {
    { VK_SHIFT,    "SHIFT"    },
    { VK_LSHIFT,   "LSHIFT"   },
    { VK_RSHIFT,   "RSHIFT"   },
    { VK_CONTROL,  "CONTROL"  },
    { VK_LCONTROL, "LCONTROL" },
    { VK_RCONTROL, "RCONTROL" },
    { VK_MENU,     "MENU"     },
    { VK_LMENU,    "LMENU"    },
    { VK_RMENU,    "RMENU"    },
    { VK_NUMLOCK,  "NUMLOCK"  },
    { VK_CAPITAL,  "CAPITAL"  },
    { VK_LBUTTON,  "LBUTTON"  },
    { VK_MBUTTON,  "MBUTTON"  },
    { VK_RBUTTON,  "RBUTTON"  },
    { VK_XBUTTON1, "XBUTTON1" },
    { VK_XBUTTON2, "XBUTTON2" },
    { VK_RETURN ,  "ENTER"    },
    { VK_KANA,     "KANA/HANJA" },
    { VK_OEM_8,    "OEM_8"    },
    // { 0x52      ,  "R"        },  // your key goes here
    { 0,           NULL       }
};

ULONG WDBGAPI KbdPti(ULONG64 pti, PVOID pOpt)
{
    Ikbd(DOWNCAST(DWORD, pOpt), pti);
    return 0;
}

BOOL Ikbd(
    DWORD opts,
    ULONG64 param1)
{
    if (opts & OFLAG(a)) {
        ForEachPti(KbdPti, ULongToPtr(opts & ~OFLAG(a)));
        return TRUE;
    }

    try {
        ULONG64 pq;
        ULONG64 ptiKeyboard;
        PBYTE pb, pbr;
        int i;
        BYTE afKeyState[CBKEYSTATE + CBKEYSTATERECENTDOWN];
        ULONG64 pgafAsyncKeyState;
        BYTE  afAsyncKeyState[CBKEYSTATE];
        ULONG64 pgafRawKeyState;
        BYTE  afRawKeyState[CBKEYSTATE];
        UINT  PhysModifiers;
        BYTE  vkey;

        /*
         * If 'u' was specified, make sure there was also an address
         */
        if (opts & OFLAG(u)) {
            if (param1 == 0) {
                Print("provide arg 2 of ProcessUpdateKeyEvent(), or WM_UPDATEKEYSTATE wParam\n");
                return FALSE;
            }
            move(afKeyState, param1);
            pb = afKeyState;
            pbr = afKeyState + CBKEYSTATE;
            Print("Key State:   === NEW STATE ====   Asynchronous    Physical\n");

        } else {
            if (opts & OFLAG(k)) {
                vkey = (BYTE)param1;
                param1 = NULL_POINTER;
            }
            if (param1) {
                pq = param1;
            } else {
                pq = GetGlobalPointer(VAR(gpqForeground));
            }

            /*
             * Print out simple thread info for pq->ptiLock.
             */
            GetFieldValue(pq, SYM(tagQ), "ptiKeyboard", ptiKeyboard);
            if (ptiKeyboard) {
                Idt(OFLAG(p), ptiKeyboard);
            }

            GetFieldValue(pq, SYM(tagQ), "afKeyState", afKeyState);
            pb = afKeyState;
            pbr = afKeyState + CBKEYSTATE;
            Print("Key State:   QUEUE %p       Asynchronous    Raw\n", pq);
        }

        moveExp(&pgafAsyncKeyState, VAR(gafAsyncKeyState));
        move(afAsyncKeyState, pgafAsyncKeyState);

        moveExp(&pgafRawKeyState, VAR(gafRawKeyState));
        move(afRawKeyState, pgafRawKeyState);

        Print("             Down Toggle Recent   Down Toggle     Down Toggle\n");

        if (opts & OFLAG(s)) {
            for (vkey = 1; vkey < VK_UNKNOWN; ++vkey) {
                Print("%02x %10.10s:\t%d    %d     %d        %d     %d         %d     %d\n",
                    vkey,
                    _GetVKeyName(vkey, 0),
                    TestKeyDownBit(pb, vkey) != 0,
                    TestKeyToggleBit(pb, vkey) != 0,
                    TestKeyRecentDownBit(pbr, vkey) != 0,
                    TestKeyDownBit(afAsyncKeyState, vkey) != 0,
                    TestKeyToggleBit(afAsyncKeyState, vkey) != 0,
                    TestKeyDownBit(afRawKeyState, vkey) != 0,
                    TestKeyToggleBit(afRawKeyState, vkey) != 0);
            }
        } else {
            for (i = 0; aVK[i].pszVK != NULL; i++) {
                Print("VK_%s:\t%d    %d     %d        %d     %d         %d     %d\n",
                    aVK[i].pszVK,
                    TestKeyDownBit(pb, aVK[i].iVK) != 0,
                    TestKeyToggleBit(pb, aVK[i].iVK) != 0,
                    TestKeyRecentDownBit(pbr, aVK[i].iVK) != 0,
                    TestKeyDownBit(afAsyncKeyState, aVK[i].iVK) != 0,
                    TestKeyToggleBit(afAsyncKeyState, aVK[i].iVK) != 0,
                    TestKeyDownBit(afRawKeyState, aVK[i].iVK) != 0,
                    TestKeyToggleBit(afRawKeyState, aVK[i].iVK) != 0);
            }

            if (opts & OFLAG(k)) {
                Print("%s:\t%d    %d     %d        %d     %d         %d     %d\n",
                    GetVKeyName(vkey),
                    TestKeyDownBit(pb, vkey) != 0,
                    TestKeyToggleBit(pb, vkey) != 0,
                    TestKeyRecentDownBit(pbr, vkey) != 0,
                    TestKeyDownBit(afAsyncKeyState, vkey) != 0,
                    TestKeyToggleBit(afAsyncKeyState, vkey) != 0,
                    TestKeyDownBit(afRawKeyState, vkey) != 0,
                    TestKeyToggleBit(afRawKeyState, vkey) != 0);
            }
        }

        moveExpValue(&PhysModifiers, VAR(gfsSASModifiersDown));
        Print("PhysModifiers = %x\n", PhysModifiers);
    } except(CONTINUE) {
    }

    return TRUE;
}
#endif // KERNEL



/************************************************************************\
* Itest
*
* Tests the basic stdexts macros and functions - a good check on the
* debugger extensions in general before you waste time debuging entensions.
*
* 6/9/1995 Created SanfordS
\************************************************************************/
BOOL Itest()
{
    ULONG64 p;
    ULONG64 cch;
    CHAR ach[80];

    Print("Print test!\n");
    SAFEWHILE (TRUE) {
        Print("SAFEWHILE test...  Hit Ctrl-C NOW!\n");
    }
    p = EvalExp(VAR(gpsi));
    Print("EvalExp(%s) = %#p\n", VAR(gpsi), p);
    GetSym(p, ach, &cch);
    Print("GetSym(%#p) = %s\n", p, ach);
    if (IsWinDbg()) {
        Print("I think windbg is calling me.\n");
    } else {
        Print("I don't think windbg is calling me.\n");
    }
    Print("MoveBlock test...\n");
    moveBlock(&p, EvalExp(VAR(gpsi)), sizeof(p));
    Print("MoveBlock(%#p) = %#p.\n", EvalExp(VAR(gpsi)), p);

    Print("moveExp test...\n");
    moveExp(&p, VAR(gpsi));
    Print("moveExp(%s) = %p.\n", VAR(gpsi), p);

    Print("moveExpValue test...\n");
    p = GetGlobalPointer(VAR(gpsi));
    Print("moveExpValue(%s) = %#p.\n", VAR(gpsi), p);

    Print("Basic tests complete.\n");
    return TRUE;
}


/************************************************************************\
* Iuver
*
* Dumps versions of extensions and winsrv/win32k
*
* 6/15/1995 Created SanfordS
\************************************************************************/
BOOL Iuver()
{
    try {
        ULONG64 psi, wSRVIFlags;
        BOOL bExtsIs64 = (sizeof(VOID*) == 8);

#if DBG
        Print("USEREXTS version: Checked %s.\n"
              "WIN32K.SYS version: ", bExtsIs64 ? "ia64" : "x86");
#else
        Print("USEREXTS version: Free %s.\n"
              "WIN32K.SYS version: ", bExtsIs64 ? "ia64" : "x86");
#endif

        psi = GetGlobalPointer(VAR(gpsi));
        GetFieldValue(psi, SYM(SERVERINFO), "wSRVIFlags", wSRVIFlags);

        Print((wSRVIFlags & SRVIF_CHECKED) ? "Checked" : "Free");
        Print(" %s", IsPtr64() ? "ia64" : "x86");
        Print(".\n");
    } except (CONTINUE) {
    }

    return TRUE;
}


#ifdef KERNEL

#ifdef OBSOLETE
#define DUMPSTATUS(status) if (tryMoveExpValue(&Status, VAR(g ## status))) { \
                               Print("g%s = %lx\n", #status, Status);        \
                           }
#define DUMPTIME(time)     if (tryMoveExpValue(&Time, VAR(g ## time))) {     \
                               Print("g%s = %lx\n", #time, Time);            \
                           }
#else
#define DUMPSTATUS(status) moveExpValue(&Status, VAR(g ## status));         \
                           Print("g%s = %lx\n", #status, Status);

#define DUMPTIME(time)     moveExpValue(&Time, VAR(g ## time));             \
                           Print("g%s = %lx\n", #time, Time);

#endif

/***************************************************************************\
* dinp - dump input diagnostics
* dinp -v   verbose
* dinp -i   show input records
*
* 04/13/98  IanJa       Created.
\***************************************************************************/

int gnIndent;

BOOL Idinp(
    DWORD opts,
    ULONG64 param1)
{
    try {
        DWORD    Time;
        ULONG64 pDeviceInfo;
        ULONG64 v;
        DWORD dw;
        int i = 0;
        DWORD nKbd = 0;
        BOOL bVerbose = FALSE;

#if 0
        {
            NTSTATUS Status;

            DUMPSTATUS(KbdIoctlLEDSStatus);
        }
#endif

        DUMPTIME(MouseProcessMiceInputTime);
        DUMPTIME(MouseQueueMouseEventTime);
        DUMPTIME(MouseUnqueueMouseEventTime);

        if (opts & OFLAG(v)) {
            bVerbose = TRUE;
        }

        pDeviceInfo = GetGlobalPointer(VAR(gpDeviceInfoList));
        if (pDeviceInfo == NULL_POINTER) {
            Print("win32k!gpDeviceInfoList is NULL\n");
        }
        SAFEWHILE (pDeviceInfo) {
            if (param1 && (param1 != pDeviceInfo)) {
                // skip it
            } else {
                WCHAR awchBuffer[100];
                DWORD cbBuffer;
                BYTE type;
                ULONG64 h;
                ULONG64 cLockObj;

                _InitTypeRead(pDeviceInfo, SYM(tagDEVICEINFO));

                Print("#%d: ", i);

                type = (BYTE)ReadField(type);
                switch (type) {
                case DEVICE_TYPE_MOUSE:
                    Print("MOU");
                    break;
                case DEVICE_TYPE_KEYBOARD:
                    Print("KBD");
                    ++nKbd;
                    break;
    #ifdef DEVICE_TYPE_HID
                case DEVICE_TYPE_HID:
                    Print("HID");
                    break;
    #endif
                default:
                    Print("%2d?", type);
                }

                h = ReadField(head.h);
                cLockObj = ReadField(head.cLockObj);
                Print("  @ 0x%p  h:0x%p (lock:0x%x) ", pDeviceInfo, h, (DWORD)cLockObj);

                v = ReadField(usActions);
                if (v) {
                    Print("\n Pending action: %x %s", (USHORT)v,
                            GetFlags(GF_DIAF, (USHORT)v, NULL, TRUE));
                }

                v = ReadField(ustrName.Length);

                if (v) {
                    cbBuffer = min((ULONG)v, sizeof(awchBuffer) - sizeof(WCHAR));
                    v = ReadField(ustrName.Buffer);
                    if (tryMoveBlock(awchBuffer, v, cbBuffer)) {
                        Print("\n    %.*ws\n", cbBuffer / sizeof(WCHAR), awchBuffer);
                    } else {
                        Print("\n");
                    }
                } else {
                    Print("\n    NO-NAME!\n");
                }

                switch (type) {
                case DEVICE_TYPE_KEYBOARD:
                    Print("  Type: %04x  SubType: %04x (%x, %x)\n",
                          (DWORD)ReadField(keyboard.IdEx.Type),
                          (DWORD)ReadField(keyboard.IdEx.Subtype),
                          (DWORD)ReadField(keyboard.Attr.KeyboardIdentifier.Type),
                          (DWORD)ReadField(keyboard.Attr.KeyboardIdentifier.Subtype));
                    break;
                }

                if (bVerbose || (param1 == pDeviceInfo)) {
                    ULONG offset, offset2;

                    gnIndent += 2;
                    dso(SYM(tagGENERIC_DEVICE_INFO), pDeviceInfo, 0);
                    gnIndent += 2;
                    GetFieldOffset(SYM(tagDEVICEINFO), "iosb", &offset);
                    Print("  IOSB @ 0x%p\n", pDeviceInfo + offset);
                    dso(SYM(_IO_STATUS_BLOCK), pDeviceInfo + offset, 0);
                    gnIndent -= 2;

                    switch (type) {
                    case DEVICE_TYPE_MOUSE:
                        GetFieldOffset(SYM(tagDEVICEINFO), "mouse", &offset);
                        Print("  MOUSE_DEVICE_INFO @ 0x%p\n", pDeviceInfo + offset);
                        dso(SYM(tagMOUSE_DEVICE_INFO), pDeviceInfo + offset, 0);

                        gnIndent += 2;
                        GetFieldOffset(SYM(tagMOUSE_DEVICE_INFO), "Attr", &offset2);
                        Print("  Attr @ 0x%p\n", pDeviceInfo + offset + offset2);
                        dso(SYM(_MOUSE_ATTRIBUTES), pDeviceInfo + offset + offset2, 0);
                        gnIndent -= 2;
                        break;
                    case DEVICE_TYPE_KEYBOARD:
                        GetFieldOffset(SYM(tagDEVICEINFO), "keyboard", &offset);
                        Print("  KEYBOARD_DEVICE_INFO @ 0x%p\n", pDeviceInfo + offset);
                        dso(SYM(tagKEYBOARD_DEVICE_INFO), pDeviceInfo + offset, 0);

                        gnIndent += 2;
                        GetFieldOffset(SYM(tagKEYBOARD_DEVICE_INFO), "Attr", &offset2);
                        Print("  KEYBOARD_ATTRIBUTES @ 0x%p\n", pDeviceInfo + offset + offset2);
                        dso(SYM(_KEYBOARD_ATTRIBUTES), pDeviceInfo + offset + offset2, DBG_DUMP_RECUR_LEVEL(1));
                        gnIndent -= 2;
                        break;
    #ifdef GENERIC_INPUT
                    case DEVICE_TYPE_HID:
                        {
                            ULONG64 pTLCInfo;

                            GetFieldOffset(SYM(tagDEVICEINFO), "hid", &offset);
                            Print("  HID_DEVICE_INFO @ 0x%p\n", pDeviceInfo + offset);
                            dso(SYM(tagHID_DEVICE_INFO), pDeviceInfo + offset, 0);

                            GetFieldValue(pDeviceInfo, SYM(tagDEVICEINFO), "hid.pTLCInfo", pTLCInfo);
                            Print("  HID_TLC_INFO @ 0x%p\n", pTLCInfo);
                            dso(SYM(tagHID_TLC_INFO), pTLCInfo, 0);
                        }
                        break;
    #endif
                    default:
                        Print("Unknown device type %d\n", type);
                    }

                    if ((opts & OFLAG(i))
    #ifdef GENERIC_INPUT
                        && type != DEVICE_TYPE_HID
    #endif
                        ) {
                        ULONG offset;
                        ULONG64 pData;
                        ULONG64 Information;
                        ULONG64 sizeDataItem;

                        GetFieldOffset(SYM(tagDEVICEINFO), "keyboard.Data", &offset);
                        pData = pDeviceInfo + offset;
                        GetFieldValue(pDeviceInfo, SYM(tagDEVICEINFO), "iosb.Information", Information);
                        sizeDataItem = GetTypeSize(SYM(_KEYBOARD_INPUT_DATA));

                        Print("  Input Records:");
                        if (Information == 0) {
                            Print(" NONE\n");
                        } else {
                            UINT i;

                            Print("\n");
                            gnIndent += 2;
                            for (i = 0; i < Information / sizeDataItem; ++i) {
                                dso(SYM(_KEYBOARD_INPUT_DATA), pData, 0);
                                pData += sizeDataItem;
                            }
                            gnIndent -= 2;
                        }
                    }
                    gnIndent -= 2;
                }
    #ifdef GENERIC_INPUT
                else if (type == DEVICE_TYPE_HID) {
                    ULONG64 pHidDesc;
                    USHORT UsagePage, Usage;

                    GetFieldValue(pDeviceInfo, SYM(tagDEVICEINFO), "hid.pHidDesc", pHidDesc);
                    InitTypeRead(pHidDesc, HIDDESC);
                    UsagePage = (USHORT)ReadField(hidpCaps.UsagePage);
                    Usage = (USHORT)ReadField(hidpCaps.Usage);
                    Print("  UsagePage:%04x Usage:%04x\n", UsagePage, Usage);
                }
    #endif
                Print("\n");
            }

            GetFieldValue(pDeviceInfo, SYM(tagDEVICEINFO), "pNext", pDeviceInfo);
            ++i;
        }

        // Now display input related sytem metrics
        {
            ULONG64 psi;
            ULONG offset;

            static SYSMET_ENTRY aSysMet[] = {
                SMENTRY(MOUSEPRESENT),
                SMENTRY(MOUSEWHEELPRESENT),
                SMENTRY(CMOUSEBUTTONS),
            };

            psi = GetGlobalPointer(VAR(gpsi));

            GetFieldOffset(SYM(tagSERVERINFO), "aiSysMet", &offset);

            for (i = 0; !IsCtrlCHit() && i < ARRAY_SIZE(aSysMet); ++i) {
                int metric;
                move(metric, psi + offset + aSysMet[i].iMetric * sizeof(int));
                Print("SM_%-18s = 0x%08lx = %d\n",
                      aSysMet[i].pstrMetric,
                      metric,
                      metric);
            }
        }

        moveExpValue(&dw, VAR(gnHid));
        Print("#HID = 0x%x   #Kbd = 0x%x\n", dw, nKbd);
    } except (CONTINUE) {
    }
    return TRUE;
}


BOOL I_dinp(
    DWORD opts,
    ULONG64 param1)
{
#ifdef _IA64_
    UNREFERENCED_PARAMETER(opts);
    UNREFERENCED_PARAMETER(param1);
    return FALSE;
#else
    DWORD    Time;
    NTSTATUS Status;
    PDEVICEINFO pDeviceInfo, *ppDeviceInfo;
    int i = 0;
#if 0
    char ach[100];
#endif
    DWORD nKbd;
    BOOL bVerbose = FALSE;

    DUMPSTATUS(KbdIoctlLEDSStatus);

    DUMPTIME(MouseProcessMiceInputTime);
    DUMPTIME(MouseQueueMouseEventTime);
    DUMPTIME(MouseUnqueueMouseEventTime);

    if (opts & OFLAG(v)) {
        bVerbose = TRUE;
    }


    ppDeviceInfo = (PDEVICEINFO*)EvalExp(VAR(gpDeviceInfoList));
    while (tryMove(pDeviceInfo, (ULONG64)ppDeviceInfo) && pDeviceInfo) {

        if (param1 && (param1 != (ULONG64)pDeviceInfo)) {
            ; // skip it
        } else if (pDeviceInfo != 0) {
            DEVICEINFO DeviceInfo;
            WCHAR awchBuffer[100];
            DWORD cbBuffer;

            Print("#%d: %p ", i, (ULONG64)pDeviceInfo);
            if (tryMove(DeviceInfo, (ULONG64)pDeviceInfo)) {
                if (DeviceInfo.type == DEVICE_TYPE_MOUSE) {
                    Print("MOU", i);
                } else if (DeviceInfo.type == DEVICE_TYPE_KEYBOARD) {
                    Print("KBD");
                } else {
                    Print("%2d?", DeviceInfo.type);
                }
                if (DeviceInfo.usActions) {
                    Print(" Pending action %x %s", DeviceInfo.usActions,
                            GetFlags(GF_DIAF, DeviceInfo.usActions, NULL, TRUE));
                }
                cbBuffer = min(DeviceInfo.ustrName.Length, sizeof(awchBuffer)-sizeof(WCHAR));
                if (tryMoveBlock(awchBuffer, (ULONG64)DeviceInfo.ustrName.Buffer, cbBuffer)) {
                    awchBuffer[cbBuffer / sizeof(WCHAR)] = 0;
                    Print("\n    %ws\n", awchBuffer);
                } else {
                    Print("\n");
                }
            } else {
                DeviceInfo.type = 0xFF;
            }
#if 0
            if (bVerbose || (param1 == (ULONG64)pDeviceInfo)) {
                sprintf(ach, "GENERIC_DEVICE_INFO 0x%p", pDeviceInfo);
                gnIndent += 2;
                Idso(0, ach);
                gnIndent += 2;
                sprintf(ach, "IO_STATUS_BLOCK 0x%p",
                        (PBYTE)pDeviceInfo + FIELD_OFFSET(DEVICEINFO, iosb));
                Idso(0, ach);
                gnIndent -= 2;
                if (DeviceInfo.type == DEVICE_TYPE_MOUSE) {
                    sprintf(ach, "MOUSE_DEVICE_INFO 0x%p",
                            (PBYTE)pDeviceInfo + FIELD_OFFSET(DEVICEINFO, mouse));
                    Idso(0, ach);

                    gnIndent += 2;
                    sprintf(ach, "MOUSE_ATTRIBUTES 0x%p",
                            (PBYTE)pDeviceInfo + FIELD_OFFSET(DEVICEINFO, mouse)
                                    + FIELD_OFFSET(MOUSE_DEVICE_INFO, Attr));
                    Idso(0, ach);
                    gnIndent -= 2;
                } else if (DeviceInfo.type == DEVICE_TYPE_KEYBOARD) {
                    sprintf(ach, "KEYBOARD_DEVICE_INFO 0x%p",
                            (PBYTE)pDeviceInfo + FIELD_OFFSET(DEVICEINFO, keyboard));
                    Idso(0, ach);
                    gnIndent += 2;
                    sprintf(ach, "KEYBOARD_ATTRIBUTES 0x%p",
                            (PBYTE)pDeviceInfo + FIELD_OFFSET(DEVICEINFO, keyboard)
                                    + FIELD_OFFSET(KEYBOARD_DEVICE_INFO, Attr));
                    Idso(0, ach);
                    gnIndent -= 2;
                } else {
                    Print("Unknown device type %d\n", DeviceInfo.type);
                }
                if (opts & OFLAG(i)) {
                    Print("  Input Records:");
                    if (DeviceInfo.iosb.Information == 0) {
                        Print(" NONE\n");
                    } else {
                        Print("\n");
                        gnIndent += 2;
                        sprintf(ach, "KEYBOARD_INPUT_DATA %p *%x",
                                &(pDeviceInfo->keyboard.Data[0]),
                                DeviceInfo.iosb.Information / sizeof(DeviceInfo.keyboard.Data[0]));
                        Idso(0, ach);
                        gnIndent -= 2;
                    }
                }
                gnIndent -= 2;
            }
#endif
        }
        ppDeviceInfo = FIXKP(&pDeviceInfo->pNext);
        i++;
    }

    // Now display input related sytem metrics
    {
        SERVERINFO si;
        //PSERVERINFO psi;
        ULONG64 psi;

// #define SMENTRY(sm) {SM_##sm, #sm}  (see above

        /*
         * Add mouse- and keyboard- related entries to this table
         * with the prefix removed, in whatever order you think is rational
         */
        static SYSMET_ENTRY aSysMet[] = {
            SMENTRY(MOUSEPRESENT),
            SMENTRY(MOUSEWHEELPRESENT),
            SMENTRY(CMOUSEBUTTONS),
        };

        psi = GetGlobalPointer(VAR(gpsi));
        move(si, psi);

        for (i = 0; i < ARRAY_SIZE(aSysMet); i++) {
            Print(  "SM_%-18s = 0x%08lx = %d\n",
                    aSysMet[i].pstrMetric,
                    si.aiSysMet[aSysMet[i].iMetric],
                    si.aiSysMet[aSysMet[i].iMetric]);
        }

        moveExpValue(&nKbd, VAR(gnKeyboards));
        Print("gnKeyboards = %d\n", nKbd);
        moveExpValue(&nKbd, VAR(gnMice));
        Print("gnMice = %d\n", nKbd);
        moveExpValue(&nKbd, VAR(gnHid));
        Print("ghMice = %d\n", nKbd);
    }
    return TRUE;
#endif  // _IA64_
}

#endif // KERNEL



#ifdef KERNEL
/***************************************************************************\
* hh - dump the flags in gdwHydraHint
*
* 05/20/98  MCostea       Created.
\***************************************************************************/
BOOL Ihh(
    DWORD opts,
    ULONG64 param1)
{
    DWORD dwHHint;
    ULONG64 pdwHH;
    ULONG ulSessionId;
    ULONG64 pulASessionId;
    int i, maxFlags;

    char * aHHstrings[] = {
        "HH_DRIVERENTRY            0x00000001",
        "HH_USERINITIALIZE         0x00000002",
        "HH_INITVIDEO              0x00000004",
        "HH_REMOTECONNECT          0x00000008",
        "HH_REMOTEDISCONNECT       0x00000010",
        "HH_REMOTERECONNECT        0x00000020",
        "HH_REMOTELOGOFF           0x00000040",
        "HH_DRIVERUNLOAD           0x00000080",
        "HH_GRECLEANUP             0x00000100",
        "HH_USERKCLEANUP           0x00000200",
        "HH_INITIATEWIN32KCLEANUP  0x00000400",
        "HH_ALLDTGONE              0x00000800",
        "HH_RITGONE                0x00001000",
        "HH_RITCREATED             0x00002000",
        "HH_LOADCURSORS            0x00004000",
        "HH_KBDLYOUTGLOBALCLEANUP  0x00008000",
        "HH_KBDLYOUTFREEWINSTA     0x00010000",
        "HH_CLEANUPRESOURCES       0x00020000",
        "HH_DISCONNECTDESKTOP      0x00040000",
        "HH_DTQUITPOSTED           0x00080000",
        "HH_DTQUITRECEIVED         0x00100000",
#ifdef BUG365290
        "HH_DTNONEWDESKTOP         0x00200000",
#endif //BUG365290
        "HH_DTWAITONHANDLES        0x00400000",
    };

    UNREFERENCED_PARAMETER(opts);

    if (param1) {
        dwHHint = (DWORD)((DWORD_PTR)param1);
        Print("gdwHydraHint is 0x%x:\n", dwHHint);
    } else {
        pdwHH = EvalExp(VAR(gdwHydraHint));
        if (!tryMove(dwHHint, pdwHH)) {
            Print("Can't get value of gdwHydraHint\n");
            return FALSE;
        }

        pulASessionId = EvalExp(VAR(gSessionId));
        if (!tryMove(ulSessionId, pulASessionId)) {
            Print("Can't get value of gSessionId\n");
            return FALSE;
        }

        Print("Session 0x%x \n  gdwHydraHint is 0x%x:\n", ulSessionId, dwHHint);
    }

    i = 0;
    maxFlags = ARRAY_SIZE(aHHstrings);

    while (dwHHint) {

        if (dwHHint & 0x01) {

            if (i >= maxFlags) {
                Print("\n Error: Unknown flags: userkdx.dll might be outdated\n");
                return TRUE;
            }
            Print("    %s\n", aHHstrings[i]);
        }
        i++;
        dwHHint >>= 1;
    }

    return TRUE;
}

#endif // KERNEL

/************************************************************************\
* Procedure: Idupm
*
* 04/29/98 GerardoB     Created
\************************************************************************/
#ifdef KERNEL
BOOL Idupm(
    VOID)
{
    char ach[80];
    DWORD dwMask;
    int i;
    WORD w = GF_UPM0;

    Print("UserPreferencesMask:\n");
    for (i = 0; i < SPI_BOOLMASKDWORDSIZE; i++) {
        sprintf(ach, "win32k!gpdwCPUserPreferencesMask + %#lx", i * sizeof(DWORD));
        moveExpValue(&dwMask, ach);
        w = GF_UPM0 + i;
        Print("Offset: %d - %#lx: %s\n",
              i, dwMask, GetFlags(w, dwMask, NULL, TRUE));
    }
    return TRUE;
}
#endif // KERNEL

/************************************************************************\
* Procedure: Idimc
*
* HiroYama     Created
*
\************************************************************************/

static struct /*NoName*/ {
    const char* terse;
    const char* verbose;
} gaIMCAttr[] = {
    "IN", "INPUT",
    "TC", "TARGET_CONVERTED",
    "CV", "CONVERTED",
    "TN", "TARGET_NOTCONVERTED",
    "IE", "INPUT_ERROR",
    "FC", "FIXEDCONVERTED",
};

const char* GetInxAttr(BYTE bAttr)
{
    if (bAttr < ARRAY_SIZE(gaIMCAttr)) {
        return gaIMCAttr[bAttr].terse;
    }
    return "**";
}

VOID _PrintInxAttr(
    const char* title,
    ULONG64 pCompStr,
    DWORD offset,
    DWORD len)
{
    DWORD i;
    ULONG64 pAttr = pCompStr + offset;

    if (title == NULL) {
        // Print a legend
        Print("  ");
        for (i = 0; i < ARRAY_SIZE(gaIMCAttr); ++i) {
            if (i && i % 4 == 0) {
                Print("\n");
                Print("  ");
            }
            Print("%s:%s ", gaIMCAttr[i].terse, gaIMCAttr[i].verbose);
        }
        Print("\n");
        return;
    }

    if (offset == 0 || len == 0) {
        return;
    }

    Print("  %-12s (@ 0x%p) off:0x%x len:0x%x (in byte)\n",
          title, pAttr, offset, len);
    Print("   ");
    i = 0;
    SAFEWHILE (i < len) {
        Print("|%s", GetInxAttr(GetByte(pAttr + i)));
        ++i;
    }
    Print("|\n");
}

#define PrintInxAttr(name) \
    _PrintInxAttr(#name, pCompStr, (DWORD)ReadField(dw ## name ## Offset), (DWORD)ReadField(dw ## name ## Len))

VOID _PrintInxClause(
    const char* title,
    ULONG64 pCompStr,
    DWORD offset,
    DWORD len)
{
    ULONG64 pClause = pCompStr + offset;
    DWORD i;

    if (offset == 0 || len == 0) {
        return;
    }

    Print("  %-12s (@ 0x%p) off:0x%x len:0x%x (0x%x dwords)\n",
          title, pClause, offset, len, len / sizeof(DWORD));

    Print("   ");
    len /= sizeof(DWORD);
    i = 0;
    SAFEWHILE (i < len) {
        Print("|0x%x", GetDWord(pClause + i));
        ++i;
    }
    Print("|\n");
}

#define PrintInxClause(name) \
    _PrintInxClause(#name, pCompStr, (DWORD)ReadField(dw ## name ## Offset), (DWORD)ReadField(dw ## name ## Len))

const char* GetInxStr(
    WCHAR wchar,
    BOOLEAN fUnicode)
{
    static char ach[32];

    if (wchar >= 0x20 && wchar <= 0x7e) {
        sprintf(ach, "'%c'", wchar);
    } else if (fUnicode) {
        sprintf(ach, "U+%04x", wchar);
    } else {
        sprintf(ach, "%02x", (BYTE)wchar);
    }

    return ach;
}

VOID _PrintInxStr(
    const char* title,
    ULONG64 pCompStr,
    DWORD offset,
    DWORD len,
    BOOLEAN fUnicode)
{
    DWORD i;

    if (offset == 0 || len == 0) {
        return;
    }

    Print("  %-12s (@ 0x%p) off:0x%x len:0x%x (0x%x cch)\n",
        title, pCompStr + offset, offset, len, len / (fUnicode + 1));

    Print("   ");
    i = 0;
    SAFEWHILE (i < len) {
        WCHAR wchar;
        if (fUnicode) {
            wchar = GetWord(pCompStr + offset + i * sizeof(WCHAR));
        } else {
            wchar = GetByte(pCompStr + offset + i);
        }
        Print("|%s", GetInxStr(wchar, fUnicode));
        ++i;
    }
    Print("|\n");
}

#define PrintInxStr(name) \
    _PrintInxStr(#name, pCompStr, (DWORD)ReadField(dw ## name ## Offset), (DWORD)ReadField(dw ## name ## Len), fUnicode)


#define PrintInxElementA(name) \
    do { \
        PrintInxAttr(name ## Attr); \
        PrintInxClause(name ## Clause); \
        PrintInxStr(name ## Str); \
    } while (0)

#define PrintInxElementB(name) \
    do { \
        PrintInxClause(name ## Clause); \
        PrintInxStr(name ## Str); \
    } while (0)


VOID _PrintInxFriendlyStr(
    const char* title,
    ULONG64 pCompStr,
    DWORD dwAttrOffset,
    DWORD dwAttrLen,
    DWORD dwClauseOffset,
    DWORD dwClauseLen,
    DWORD dwStrOffset,
    DWORD dwStrLen,
    BOOLEAN fUnicode)
{
    DWORD i;
    DWORD n;
    DWORD dwClause;

    Print("  %-11s", title);
    if (dwStrOffset == 0 || dwStrLen == 0) {
        Print("\n");
        return;
    }

    for (i = 0, n = 0; i < dwStrLen; ++i) {
        BYTE bAttr;
        WCHAR wchar;

        //move(dwClause, (PDWORD)(pCompStr + dwClauseOffset) + n);
        dwClause = GetDWord(pCompStr + dwClauseOffset + n * sizeof(DWORD));
        if (dwClause == i) {
            ++n;
            if (i) {
                Print("| ");
            }
        }

        if (fUnicode) {
            wchar = GetWord(pCompStr + dwStrOffset + i * sizeof(WCHAR));
            //move(wchar, (PWCHAR)((PBYTE)pCompStr + dwStrOffset) + i);
        } else {
            wchar = GetByte(pCompStr + dwStrOffset + i);
        }

        if (dwAttrOffset != ~0) {
            //move(bAttr, pCompStr + dwAttrOffset + i);
            bAttr = GetByte(pCompStr + dwAttrOffset + i);
            Print("|%s:%s", GetInxAttr(bAttr), GetInxStr(wchar, fUnicode));
        } else {
            Print("|%s", GetInxStr(wchar, fUnicode));
        }
    }
    Print("|\n");
    if (dwClauseLen / sizeof(DWORD) != (n + 1)) {
        Print("  ** dwClauseLen (0x%x) doesn't match to n (0x%x) **\n", dwClauseLen, (n + 1) * sizeof(DWORD));
    }
    if (dwAttrOffset != ~0 && dwAttrLen != dwStrLen) {
        Print("  ** dwAttrLen (0x%x) doesn't match to dwStrLen (0x%x) **\n", dwAttrLen, dwStrLen);
    }
}

#define PrintInxFriendlyStrA(name) \
    _PrintInxFriendlyStr(#name, \
                         pCompStr, \
                         (DWORD)ReadField(dw ## name ## AttrOffset), \
                         (DWORD)ReadField(dw ## name ## AttrLen), \
                         (DWORD)ReadField(dw ## name ## ClauseOffset), \
                         (DWORD)ReadField(dw ## name ## ClauseLen), \
                         (DWORD)ReadField(dw ## name ## StrOffset), \
                         (DWORD)ReadField(dw ## name ## StrLen), \
                         fUnicode)

#define PrintInxFriendlyStrB(name) \
    _PrintInxFriendlyStr(#name, \
                         pCompStr, \
                         ~0, \
                         0, \
                         (DWORD)ReadField(dw ## name ## ClauseOffset), \
                         (DWORD)ReadField(dw ## name ## ClauseLen), \
                         (DWORD)ReadField(dw ## name ## StrOffset), \
                         (DWORD)ReadField(dw ## name ## StrLen), \
                         fUnicode)


BOOL Idimc(
    DWORD opts,
    ULONG64 param1)
{
    try {
        ULONG64 pImc;           // PIMC
        ULONG64 pClientImc;     // PCLIENTIMC
        ULONG64 pInputContext;  // PINPUTCONTEXT
        ULONG64 hInputContext;
        BOOLEAN fUnicode = FALSE;
        BOOLEAN fVerbose, fDumpInputContext, fShowIMCMinInfo, fShowModeSaver, fShowCompStrRaw;

        if (param1 == 0) {
            Print("!dimc -? for help\n");
            return FALSE;
        }

        //
        // If "All" option is specified, set all bits in opts
        // except type specifiers.
        //
        if (opts & OFLAG(a)) {
            opts |= ~(OFLAG(w) | OFLAG(c) | OFLAG(i) | OFLAG(u) | OFLAG(v));
        }

        fVerbose = (opts & OFLAG(v)) != 0;
        fShowCompStrRaw = (opts & OFLAG(s)) != 0;
        fDumpInputContext = (opts & OFLAG(d)) != 0;
        fShowIMCMinInfo = (opts & OFLAG(h)) || fDumpInputContext;
        fShowModeSaver = (opts & OFLAG(r)) != 0;

        if (opts & OFLAG(w)) {
            //
            // Arg is hwnd or pwnd.
            //
            ULONG64 pwnd;

            if ((pwnd = HorPtoP(param1, TYPE_WINDOW)) == 0) {
                return FALSE;
            }
            Print("pwnd=%p\n", pwnd);
            GetFieldValue(pwnd, SYM(tagWND), "hImc", param1);
            if (param1 == 0) {
                Print("Could not read pwnd->hImc.\n");
                return FALSE;
            }
        }

        if (opts & OFLAG(c)) {
            //
            // Arg is client side IMC
            //
            pClientImc = param1;
            goto LClientImc;
        }

        if (opts & OFLAG(i)) {
            //
            // Arg is pInputContext.
            //
            pInputContext = param1;
            opts |= OFLAG(h);   // otherwise, nothing will be displayed !
            hInputContext = 0;
            if (opts & OFLAG(u)) {
                Print("Assuming Input Context is UNICODE.\n");
            } else {
                Print("Assuming Input Context is ANSI.\n");
            }
            goto LInputContext;
        }

        //
        // Otherwise, Arg is hImc.
        //
        if ((pImc = HorPtoP(param1, TYPE_INPUTCONTEXT)) == 0) {
            Print("Idimc: %p is not an input context.\n", param1);
            return FALSE;
        }

        Print("pImc=%p\n", pImc);

        InitTypeRead(pImc, win32k!IMC);
        Print("pti:%p\n", ReadField(head.pti));

#ifdef KERNEL
        // Print simple thread info.
        if (ReadField(head.pti)) {
            Idt(OFLAG(p), ReadField(head.pti));
        }
#endif

        InitTypeRead(pImc, win32k!IMC);
        //
        // Basic information
        //
        Print("pImc = %08p  pti:%08p\n", pImc, FIXKP(ReadField(head.pti)));
        Print("  handle      %08p\n", ReadField(head.h));
        Print("  dwClientImc %08p\n", ReadField(dwClientImcData));
        Print("  hImeWnd     %08p\n", ReadField(hImeWnd));

        //
        // Show client IMC
        //
        pClientImc = ReadField(dwClientImcData);
        Print("pClientImc: %p\n", pClientImc);

LClientImc:
        if (pClientImc == 0) {
            Print("pClientImc is NULL.\n");
            return TRUE;
        }
        InitTypeRead(pClientImc, user32!CLIENTIMC);

        if (fVerbose) {
            dso("user32!CLIENTIMC", pClientImc, 0);
        } else {
            Print("pClientImc @ 0x%p  cLockObj:0x%x\n", ReadField(dwClientImcData), ReadField(cLockObj));
        }
        Print("  dwFlags %s\n", GetFlags(GF_CLIENTIMC, (DWORD)ReadField(dwFlags), NULL, TRUE));
        fUnicode = !!(ReadField(dwFlags) & IMCF_UNICODE);

        //
        // Show InputContext
        //
        hInputContext = ReadField(hInputContext);
        if (hInputContext) {
            pInputContext = GetPointer(hInputContext);
        } else {
            pInputContext = 0;
        }
LInputContext:
        Print("InputContext 0x%08p (@ 0x%08p)", hInputContext, pInputContext);

        if (pInputContext == 0) {
            Print("\n");
            return TRUE;
        }

        //
        // if UNICODE specified by the option,
        // set the flag accordingly
        //
        if (opts & OFLAG(u)) {
            fUnicode = TRUE;
        }

        InitTypeRead(pInputContext, win32k!INPUTCONTEXT);
        Print("   hwnd=%p\n", ReadField(hWnd));

        if (fVerbose) {
            dso(SYM(INPUTCONTEXT), pInputContext, 0);
        }


        //
        // Decipher InputContext.
        //
        if (fShowIMCMinInfo) {
            // COMPOSITIONSTRING
            ULONG64 hCompStr = 0;
            ULONG64 pCompStr = 0;
            // CANDIDATEINFO
            ULONG64 hCandInfo = 0;
            ULONG64 pCandInfo = 0;
            // GUIDELINE
            ULONG64 hGuideLine = 0;
            ULONG64 pGuideLine = 0;
            // TRANSMSGLIST
            ULONG64 hMsgBuf = 0;
            ULONG64 pMsgBuf = 0;
            DWORD i;

            Print("  dwRefCount: 0x%x      fdwDirty: %s\n",
                  (DWORD)ReadField(dwRefCount), GetFlags(GF_IMEDIRTY, (DWORD)ReadField(fdwDirty), NULL, TRUE));
            Print("  Conversion: %s\n", GetFlags(GF_CONVERSION, (DWORD)ReadField(fdwConversion), NULL, TRUE));
            Print("  Sentence:   %s\n", GetFlags(GF_SENTENCE, (DWORD)ReadField(fdwSentence), NULL, TRUE));
            Print("  fChgMsg:    %d     uSaveVKey:   %02x %s\n",
                  (DWORD)ReadField(fChgMsg),
                  (DWORD)ReadField(uSavedVKey), GetVKeyName((UINT)ReadField(uSavedVKey)));
            Print("  StatusWnd:  (0x%x,0x%x)   SoftKbd: (0x%x,0x%x)\n",
                  (LONG)ReadField(ptStatusWndPos.x), (LONG)ReadField(ptStatusWndPos.y),
                  (LONG)ReadField(ptSoftKbdPos.x), (LONG)ReadField(ptSoftKbdPos.y));
            Print("  fdwInit:    %s\n", GetFlags(GF_IMEINIT, (DWORD)ReadField(fdwInit), NULL, TRUE));
            // Font
            {
                PINPUTCONTEXT pIC;    // dummy for sizeof
                LPCSTR fmt = "  Font:       '%s' %dpt wt:%d charset: %s\n";
                BYTE ach[max(sizeof(pIC->lfFont.A.lfFaceName), sizeof(pIC->lfFont.W.lfFaceName))];

                if (fUnicode) {
                    ULONG offset;

                    fmt = "  Font:       '%S' %dpt wt:%d charset: %s\n";
                    GetFieldOffset(SYM(INPUTCONTEXT), "lfFont.W.lfFaceName", &offset);
                    tryMoveBlock(ach, pInputContext + offset, sizeof(pIC->lfFont.W.lfFaceName));
                         // assuming WCHAR and alignment is consistent cross-platform...
                } else {
                    ULONG offset;
                    GetFieldOffset(SYM(INPUTCONTEXT), "lfFont.A.lfFaceName", &offset);
                    tryMoveBlock(ach, pInputContext + offset, sizeof(pIC->lfFont.A.lfFaceName));
                }
                Print(fmt,
                      ach,
                      ReadField(lfFont.A.lfHeight),
                      ReadField(lfFont.A.lfWeight),
                      GetMaskedEnum(EI_CHARSETTYPE, (DWORD)ReadField(lfFont.A.lfCharSet), NULL));
            }

            // COMPOSITIONFORM
            Print("  cfCompForm: %s pos:(0x%x,0x%x) rc:(0x%x,0x%x)-(0x%x,0x%x)\n",
                  GetFlags(GF_IMECOMPFORM, (DWORD)ReadField(cfCompForm.dwStyle), NULL, TRUE),
                  (DWORD)ReadField(cfCompForm.ptCurrentPos.x), (DWORD)ReadField(cfCompForm.ptCurrentPos.y),
                  (DWORD)ReadField(cfCompForm.rcArea.left), (DWORD)ReadField(cfCompForm.rcArea.top),
                  (DWORD)ReadField(cfCompForm.rcArea.right), (DWORD)ReadField(cfCompForm.rcArea.bottom));

            if (hCompStr = ReadField(hCompStr)) {
                if ((pCompStr = GetPointer(hCompStr)) == 0) {
                    Print("Could not get hCompStr=%p\n", hCompStr);
                } else if (fVerbose) {
                    dso(SYM(COMPOSITIONSTRING), pCompStr, 0);
                }
            }

            if (hCandInfo = ReadField(hCandInfo)) {
                if ((pCandInfo = GetPointer(hCandInfo)) == 0) {
                    Print("Could not get hCandInfo=%p\n", hCandInfo);
                } else if (fVerbose) {
                    dso(SYM(CANDIDATEINFO), pCandInfo, 0);
                }
            }

            if (hGuideLine = ReadField(hGuideLine)) {
                if ((pGuideLine = GetPointer(hGuideLine)) == 0) {
                    Print("Could not get hGuideLine=%p\n", hGuideLine);
                } else if (fVerbose) {
                    dso(SYM(GUIDELINE), pGuideLine, 0);
                }
            }

            if (hMsgBuf = ReadField(hMsgBuf)) {
                if ((pMsgBuf = GetPointer(hMsgBuf)) == 0) {
                    Print("Could not get hMsgBuf=%p\n", hMsgBuf);
                } else if (fVerbose) {
                    dso(SYM(TRANSMSGLIST), pMsgBuf, 0);
                }
            }

            if (!fDumpInputContext && !fVerbose) {
                Print("  CompStr @ 0x%p  CandInfo @ 0x%p  GuideL @ 0x%p  \n",
                    pCompStr, pCandInfo, pGuideLine);
                Print("  MsgBuf @ 0x%p (0x%x)\n", pMsgBuf, ReadField(dwNumMsgBuf));
            }

            if (fDumpInputContext) {
                //
                // Composition String
                //
                if (pCompStr) {

                    InitTypeRead(pCompStr, win32k!COMPOSITIONSTRING);

                    Print(" hCompositionString: %p (@ 0x%p) dwSize=0x%x\n",
                          hCompStr, pCompStr, (ULONG)ReadField(dwSize));

                    if (fShowCompStrRaw) {
                        _PrintInxAttr(NULL, /*NULL*/0, 0, 0);
                        PrintInxElementA(CompRead);
                        PrintInxElementA(Comp);
                        PrintInxElementB(ResultRead);
                        PrintInxElementB(Result);
                    }

                    Print("  CursorPos=0x%x  DeltaStart=0x%x\n",
                        ReadField(dwCursorPos), ReadField(dwDeltaStart));
                    Print("  Private: (@ 0x%p) off:0x%x len:0x%x\n",
                        (PBYTE)pCompStr + ReadField(dwPrivateOffset),
                        ReadField(dwPrivateOffset), ReadField(dwPrivateSize));

                    Print("\n");

                    PrintInxFriendlyStrA(CompRead);
                    PrintInxFriendlyStrA(Comp);
                    PrintInxFriendlyStrB(ResultRead);
                    PrintInxFriendlyStrB(Result);

                    Print("\n");
                } else {
                    Print(" pCompStr is NULL\n");
                }

                //
                // Candidate Info
                //
                if (pCandInfo) {
                    DWORD CandInfo_dwCount;

                    InitTypeRead(pCandInfo, win32k!CANDIDATEINFO);
                    CandInfo_dwCount = (DWORD)ReadField(dwCount);

                    Print(" hCandidateInfo: %p (@ 0x%p) dwSize=0x%x dwCount=0x%x PrivOffset=0x%x PrivSize=0x%x\n",
                          hCandInfo, pCandInfo, ReadField(dwSize), ReadField(dwCount),
                          ReadField(dwPrivateOffset), ReadField(dwPrivateSize));

                    for (i = 0; i < CandInfo_dwCount; ++i) {
                        ULONG64 pCandList;
                        DWORD j;
                        DWORD CandList_dwCount;

                        pCandList = pCandInfo + GetArrayElement(pCandInfo, SYM(CANDIDATEINFO), "dwOffset", i, "DWORD");
                        InitTypeRead(pCandList, win32k!CANDIDATELIST);

                        Print("   CandList[%02x] (@ 0x%p) %s count=%x sel=%x pgStart=%x pgSize=%x\n",
                              i, pCandList, GetMaskedEnum(EI_IMECANDIDATESTYLE, (DWORD)ReadField(dwStyle), NULL),
                              (DWORD)ReadField(dwCount),
                              (DWORD)ReadField(dwSelection), (DWORD)ReadField(dwPageStart), (DWORD)ReadField(dwPageSize));

                        CandList_dwCount = (DWORD)ReadField(dwCount);

                        if (ReadField(dwStyle) == IME_CAND_CODE && CandList_dwCount == 1) {
                            // Special case
                            Print("     Special case: DBCS char = %04x", (DWORD)GetArrayElement(pCandList, SYM(CANDIDATEINFO), "dwOffset", 0, "DWORD"));
                        } else if (CandList_dwCount > 1) {
                            DWORD dwSelection = (DWORD)ReadField(dwSelection);

                            for (j = 0; j < CandList_dwCount; ++j) {
                                DWORD k;
                                DWORD dwOffset;

                                dwOffset = (DWORD)GetArrayElement(pCandList, SYM(CANDIDATEINFO), "dwOffset", j, "DWORD");

                                Print("    %c%c[%02x] @ 0x%p ",
                                      j == dwSelection ? '*' : ' ',
                                      (j >= ReadField(dwPageStart) && j < ReadField(dwPageStart) + ReadField(dwPageSize) ? '+' : ' ',
                                      j, pCandList + dwOffset));
                                for (k = 0; k < 0x100; ++k) {   // limit upto 0xff cch
                                    WCHAR wchar;

                                    if (fUnicode) {
                                        wchar = GetWord(pCandList + dwOffset + k * sizeof(wchar));
                                    } else {
                                        wchar = GetByte(pCandList + dwOffset + k);
                                    }
                                    if (wchar == 0) {
                                        break;
                                    }
                                    Print("|%s", GetInxStr(wchar, fUnicode));
                                }
                                Print("|\n");
                            }
                        }
                    }
                }

                if (pGuideLine) {
                    //GUIDELINE GuideLine;
                    DWORD GuideLine_dwStrLen, GuideLine_dwStrOffset;

                    InitTypeRead(pGuideLine, user32!GUIDELINE);

                    GuideLine_dwStrLen = (DWORD)ReadField(dwStrLen);
                    GuideLine_dwStrOffset = (DWORD)ReadField(dwStrOffset);

                    Print(" hGuideLine: %p (@ 0x%p) dwSize=0x%x\n",
                        hGuideLine, pGuideLine, (DWORD)ReadField(dwSize));

                    Print("   level:%x index;%x privOffset:%x privSize:%x\n",
                          (DWORD)ReadField(dwLevel), (DWORD)ReadField(dwIndex),
                          (DWORD)ReadField(dwPrivateSize), (DWORD)ReadField(dwPrivateOffset));

                    if (GuideLine_dwStrOffset && GuideLine_dwStrLen) {
                        // String
                        Print("   str @ 0x%p  ", (PBYTE)pGuideLine + (DWORD)ReadField(dwStrOffset));
                        for (i = 0; i < GuideLine_dwStrLen; ++i) {
                            WCHAR wchar;

                            if (fUnicode) {
                                wchar = GetWord(pGuideLine + GuideLine_dwStrOffset + i * sizeof(WCHAR));
                            } else {
                                wchar = GetByte(pGuideLine + GuideLine_dwStrOffset + i);
                            }
                            Print("|%s", GetInxStr(wchar, fUnicode));
                        }
                        Print("|\n");
                    }
                }

                if (pMsgBuf) {
                    DWORD dwNumMsgBuf;

                    InitTypeRead(pInputContext, user32!INPUTCONTEXT);

                    dwNumMsgBuf = (DWORD)ReadField(dwNumMsgBuf);

                    InitTypeRead(pMsgBuf, user32!TRANSMSGLIST);

                    Print(" hMsgBuf: %p (@ 0x%p) dwNumMsgBuf=0x%x uMsgCount=0x%x\n",
                        hMsgBuf, pMsgBuf, dwNumMsgBuf,
                        ReadField(uMsgCount));

                    if (dwNumMsgBuf) {
                        ULONG offset;
                        ULONG64 pTransMsg;  // PTRANSMSG
                        ULONG size;
                        GetFieldOffset("user32!TRANSMSGLIST", "TransMsg", &offset);
                        pTransMsg = pMsgBuf + offset;
                        size = GetTypeSize("user32!TRANSMSG");

                        Print("  | ## |msg | wParam | lParam |\n");
                        Print("  +----+----+--------+--------+\n");

                        for (i = 0; i < dwNumMsgBuf; ++i, pTransMsg += size) {
                            const char* pszMsg = "";
                            DWORD j;
                            UINT message;

                            InitTypeRead(pTransMsg, user32!TRANSMSG);

                            message = (UINT)ReadField(message);

                            // Try to find a readable name of the window message
                            for (j = 0; j < ARRAY_SIZE(gaMsgs); ++j) {
                                if (gaMsgs[i].msg == message) {
                                    pszMsg = gaMsgs[j].pszMsg;
                                    break;
                                }
                            }

                            Print("   | %02x |%04x|%08x|%08x| %s\n",
                                i,
                                message, ReadField(wParam), ReadField(lParam), pszMsg);
                        }
                        Print("  +----+----+--------+--------+\n");
                    }
                }

            }
        }

        //
        // Recursively display Mode Savers.
        //
        if (fShowModeSaver) {
            ULONG64 pModeSaver;

            InitTypeRead(pInputContext, user32!INPUTCONTEXT);

            pModeSaver = ReadField(pImeModeSaver);

            //
            // Private Mode Savers.
            //
            while (pModeSaver) {
                InitTypeRead(pModeSaver, user32!IMEMODESAVER);

                Print("ImeModeSaver @ 0x%p -- LangId=%04p fOpen=%d\n",
                      pModeSaver, ReadField(langId), (int)ReadField(fOpen));
                Print("    fdwInit      %s\n", GetFlags(GF_IMEINIT, (DWORD)ReadField(fdwInit), NULL, TRUE));
                Print("    Conversion   %s\n", GetFlags(GF_CONVERSION, (DWORD)ReadField(fdwConversion), NULL, TRUE));
                Print("    Sentence     %s\n", GetFlags(GF_SENTENCE, (DWORD)ReadField(fdwSentence), NULL, TRUE));
                pModeSaver = ReadField(next);
            }
        }
    } except (CONTINUE) {
    }

    return TRUE;
}


#if OLD_FORM
//////////////////////////////////////////////////////////
// OLD_FORM, that doesn't require the user mode symbol
//////////////////////////////////////////////////////////

VOID __PrintInxAttr(
    const char* title,
    PVOID pCompStr,
    DWORD offset,
    DWORD len)
{
    DWORD i;
    PBYTE pAttr = (PBYTE)pCompStr + offset;

    if (title == NULL) {
        // Print a legend
        Print("  ");
        for (i = 0; i < ARRAY_SIZE(gaIMCAttr); ++i) {
            if (i && i % 4 == 0) {
                Print("\n");
                Print("  ");
            }
            Print("%s:%s ", gaIMCAttr[i].terse, gaIMCAttr[i].verbose);
        }
        Print("\n");
        return;
    }

    if (offset == 0 || len == 0) {
        return;
    }

    Print("  %-12s (@ 0x%p) off:0x%x len:0x%x (in byte)\n",
          title, pAttr, offset, len);
    Print("   ");
    for (i = 0; i < len; ++i) {
        BYTE bAttr;

        move(bAttr, pAttr + i);
        Print("|%s", GetInxAttr(bAttr));
    }
    Print("|\n");
}

#define _PrintInxAttr(name) \
    __PrintInxAttr(#name, pCompStr, CompStr.dw ## name ## Offset, CompStr.dw ## name ## Len)

VOID __PrintInxClause(
    const char* title,
    PVOID pCompStr,
    DWORD offset,
    DWORD len)
{
    PDWORD pClause = (PDWORD)((PBYTE)pCompStr + offset);
    DWORD i;

    if (offset == 0 || len == 0) {
        return;
    }

    Print("  %-12s (@ 0x%p) off:0x%x len:0x%x (0x%x dwords)\n",
          title, pClause, offset, len, len / sizeof(DWORD));

    Print("   ");
    len /= sizeof(DWORD);
    for (i = 0; i < len; ++i) {
        DWORD dwData;

        move(dwData,  pClause + i);
        Print("|0x%x", dwData);
    }
    Print("|\n");
}

#define _PrintInxClause(name) \
    __PrintInxClause(#name, pCompStr, CompStr.dw ## name ## Offset, CompStr.dw ## name ## Len)

#if 0
const char* GetInxStr(WCHAR wchar, BOOLEAN fUnicode)
{
    static char ach[32];

    if (wchar >= 0x20 && wchar <= 0x7e) {
        sprintf(ach, "'%c'", wchar);
    } else if (fUnicode) {
        sprintf(ach, "U+%04x", wchar);
    } else {
        sprintf(ach, "%02x", (BYTE)wchar);
    }

    return ach;
}
#endif

VOID __PrintInxStr(
    const char* title,
    PVOID pCompStr,
    DWORD offset,
    DWORD len,
    BOOLEAN fUnicode)
{
    DWORD i;

    if (offset == 0 || len == 0) {
        return;
    }

    Print("  %-12s (@ 0x%p) off:0x%x len:0x%x (0x%x cch)\n",
        title, (PBYTE)pCompStr + offset, offset, len, len / (fUnicode + 1));

    Print("   ");
    for (i = 0; i < len; ++i) {
        WCHAR wchar;
        if (fUnicode) {
            move(wchar, (PWCHAR)((PBYTE)pCompStr + offset) + i);
        }
        else {
            BYTE bchar;

            move(bchar, (PBYTE)pCompStr + offset + i);
            wchar = bchar;
        }
        Print("|%s", GetInxStr(wchar, fUnicode));
    }
    Print("|\n");
}

#define PrintInxStr(name) \
    _PrintInxStr(#name, pCompStr, CompStr.dw ## name ## Offset, CompStr.dw ## name ## Len, fUnicode)


#define _PrintInxElementA(name) \
    do { \
        __PrintInxAttr(name ## Attr); \
        __PrintInxClause(name ## Clause); \
        __PrintInxStr(name ## Str); \
    } while (0)

#define _PrintInxElementB(name) \
    do { \
        __PrintInxClause(name ## Clause); \
        __PrintInxStr(name ## Str); \
    } while (0)


VOID __PrintInxFriendlyStr(
    const char* title,
    PBYTE pCompStr,
    DWORD dwAttrOffset,
    DWORD dwAttrLen,
    DWORD dwClauseOffset,
    DWORD dwClauseLen,
    DWORD dwStrOffset,
    DWORD dwStrLen,
    BOOLEAN fUnicode)
{
    DWORD i;
    DWORD n;
    DWORD dwClause;

    Print("  %-11s", title);
    if (dwStrOffset == 0 || dwStrLen == 0) {
        Print("\n");
        return;
    }

    for (i = 0, n = 0; i < dwStrLen; ++i) {
        BYTE bAttr;
        WCHAR wchar;

        move(dwClause, (PDWORD)(pCompStr + dwClauseOffset) + n);
        if (dwClause == i) {
            ++n;
            if (i) {
                Print("| ");
            }
        }

        if (fUnicode) {
            move(wchar, (PWCHAR)((PBYTE)pCompStr + dwStrOffset) + i);
        }
        else {
            BYTE bchar;
            move(bchar, (PBYTE)pCompStr + dwStrOffset + i);
            wchar = bchar;
        }

        if (dwAttrOffset != ~0) {
            move(bAttr, pCompStr + dwAttrOffset + i);
            Print("|%s:%s", GetInxAttr(bAttr), GetInxStr(wchar, fUnicode));
        }
        else {
            Print("|%s", GetInxStr(wchar, fUnicode));
        }
    }
    Print("|\n");
    if (dwClauseLen / sizeof(DWORD) != (n + 1)) {
        Print("  ** dwClauseLen (0x%x) doesn't match to n (0x%x) **\n", dwClauseLen, (n + 1) * sizeof(DWORD));
    }
    if (dwAttrOffset != ~0 && dwAttrLen != dwStrLen) {
        Print("  ** dwAttrLen (0x%x) doesn't match to dwStrLen (0x%x) **\n", dwAttrLen, dwStrLen);
    }
}

#define __PrintInxFriendlyStrA(name) \
    __PrintInxFriendlyStr(#name, \
                         (PBYTE)pCompStr, \
                         CompStr.dw ## name ## AttrOffset, \
                         CompStr.dw ## name ## AttrLen, \
                         CompStr.dw ## name ## ClauseOffset, \
                         CompStr.dw ## name ## ClauseLen, \
                         CompStr.dw ## name ## StrOffset, \
                         CompStr.dw ## name ## StrLen, \
                         fUnicode)

#define _PrintInxFriendlyStrB(name) \
    __PrintInxFriendlyStr(#name, \
                         (PBYTE)pCompStr, \
                         ~0, \
                         0, \
                         CompStr.dw ## name ## ClauseOffset, \
                         CompStr.dw ## name ## ClauseLen, \
                         CompStr.dw ## name ## StrOffset, \
                         CompStr.dw ## name ## StrLen, \
                         fUnicode)


BOOL I_dimc(DWORD opts, ULONG64 param1)
{
    IMC imc;
    PIMC pImc;
    PCLIENTIMC pClientImc;
    CLIENTIMC ClientImc;
    PINPUTCONTEXT pInputContext;
    INPUTCONTEXT InputContext;
    HANDLE hInputContext;
    BOOLEAN fUnicode = FALSE;
    BOOLEAN fVerbose, fDumpInputContext, fShowIMCMinInfo, fShowModeSaver, fShowCompStrRaw;
    char ach[32];

    if (param1 == 0) {
        Print("!dimc -? for help\n");
        return FALSE;
    }

    //
    // If "All" option is specified, set all bits in opts
    // except type specifiers.
    //
    if (opts & OFLAG(a)) {
        opts |= ~(OFLAG(w) | OFLAG(c) | OFLAG(i) | OFLAG(u));
    }

    fVerbose = !!(opts & OFLAG(v));
    fShowCompStrRaw = (opts & OFLAG(s)) || fVerbose;
    fDumpInputContext = (opts & OFLAG(d)) || fShowCompStrRaw || fVerbose;
    fShowIMCMinInfo = (opts & OFLAG(h)) || fDumpInputContext || fVerbose;
    fShowModeSaver = (opts & OFLAG(r)) || fVerbose;

    if (opts & OFLAG(w)) {
        //
        // Arg is hwnd or pwnd.
        //
        PWND pwnd;

        if ((pwnd = HorPtoP(param1, TYPE_WINDOW)) == 0) {
            return FALSE;
        }
        Print("pwnd=%p\n", pwnd);
        if (!tryMove(param1, &pwnd->hImc)) {
            Print("Could not read pwnd->hImc.\n");
            return FALSE;
        }
    }

    if (opts & OFLAG(c)) {
        //
        // Arg is client side IMC
        //
        pClientImc = param1;
        goto LClientImc;
    }

    if (opts & OFLAG(i)) {
        //
        // Arg is pInputContext.
        //
        pInputContext = param1;
        opts |= OFLAG(h);   // otherwise, nothing will be displayed !
        hInputContext = 0;
        if (opts & OFLAG(u)) {
            Print("Assuming Input Context is UNICODE.\n");
        }
        else {
            Print("Assuming Input Context is ANSI.\n");
        }
        goto LInputContext;
    }

    //
    // Otherwise, Arg is hImc.
    //
    if ((pImc = HorPtoP(param1, TYPE_INPUTCONTEXT)) == 0) {
        Print("Idimc: %x is not an input context.\n", param1);
        return FALSE;
    }
    //move(imc, FIXKP(pImc));
    move(imc, pImc);

#ifdef KERNEL
    // Print simple thread info.
    if (imc.head.pti) {
        Idt(OFLAG(p), (ULONG64)imc.head.pti);
    }
#endif

    //
    // Basic information
    //
    Print("pImc = %08lx  pti:%08lx\n", pImc, FIXKP(imc.head.pti));
    Print("  handle      %08lx\n", imc.head.h);
    Print("  dwClientImc %08lx\n", imc.dwClientImcData);
    Print("  hImeWnd     %08lx\n", imc.hImeWnd);

    //
    // Show client IMC
    //
    pClientImc = (PVOID)imc.dwClientImcData;
LClientImc:
    if (pClientImc == NULL) {
        Print("pClientImc is NULL.\n");
        return TRUE;
    }
    move(ClientImc, pClientImc);

    if (fVerbose) {
        sprintf(ach, "CLIENTIMC %p", pClientImc);
        Idso(0, ach);
    }
    else {
        Print("pClientImc @ 0x%p  cLockObj:0x%x\n", imc.dwClientImcData, ClientImc.cLockObj);
    }
    Print("  dwFlags %s\n", GetFlags(GF_CLIENTIMC, ClientImc.dwFlags, NULL, TRUE));
    fUnicode = !!(ClientImc.dwFlags & IMCF_UNICODE);

    //
    // Show InputContext
    //
    hInputContext = ClientImc.hInputContext;
    if (hInputContext) {
        move(pInputContext, hInputContext);
    }
    else {
        pInputContext = NULL;
    }
LInputContext:
    Print("InputContext %08lx (@ 0x%p)", hInputContext, pInputContext);

    if (pInputContext == NULL) {
        Print("\n");
        return TRUE;
    }

    //
    // if UNICODE specified by the option,
    // set the flag accordingly
    //
    if (opts & OFLAG(u)) {
        fUnicode = TRUE;
    }

    move(InputContext, pInputContext);
    Print("   hwnd=%p\n", InputContext.hWnd);

    if (fVerbose) {
        sprintf(ach, "INPUTCONTEXT %p", pInputContext);
        Idso(0, ach);
    }


    //
    // Decipher InputContext.
    //
    if (fShowIMCMinInfo) {
        PCOMPOSITIONSTRING pCompStr = NULL;
        PCANDIDATEINFO pCandInfo = NULL;
        PGUIDELINE pGuideLine = NULL;
        PTRANSMSGLIST pMsgBuf = NULL;
        DWORD i;

        Print("  dwRefCount: 0x%x      fdwDirty: %s\n",
              InputContext.dwRefCount, GetFlags(GF_IMEDIRTY, InputContext.fdwDirty, NULL, TRUE));
        Print("  Conversion: %s\n", GetFlags(GF_CONVERSION, InputContext.fdwConversion, NULL, TRUE));
        Print("  Sentence:   %s\n", GetFlags(GF_SENTENCE, InputContext.fdwSentence, NULL, TRUE));
        Print("  fChgMsg:    %d     uSaveVKey:   %02x %s\n",
              InputContext.fChgMsg,
              InputContext.uSavedVKey, GetVKeyName(InputContext.uSavedVKey));
        Print("  StatusWnd:  (0x%x,0x%x)   SoftKbd: (0x%x,0x%x)\n",
              InputContext.ptStatusWndPos.x, InputContext.ptStatusWndPos.y,
              InputContext.ptSoftKbdPos.x, InputContext.ptSoftKbdPos.y);
        Print("  fdwInit:    %s\n", GetFlags(GF_IMEINIT, InputContext.fdwInit, NULL, TRUE));
        // Font
        {
            LPCSTR fmt = "  Font:       '%s' %dpt wt:%d charset: %s\n";
            if (fUnicode) {
                fmt = "  Font:       '%S' %dpt wt:%d charset: %s\n";
            }
            Print(fmt,
                  InputContext.lfFont.A.lfFaceName,
                  InputContext.lfFont.A.lfHeight,
                  InputContext.lfFont.A.lfWeight,
                  GetMaskedEnum(EI_CHARSETTYPE, InputContext.lfFont.A.lfCharSet, NULL));
        }

        // COMPOSITIONFORM
        Print("  cfCompForm: %s pos:(0x%x,0x%x) rc:(0x%x,0x%x)-(0x%x,0x%x)\n",
              GetFlags(GF_IMECOMPFORM, InputContext.cfCompForm.dwStyle, NULL, TRUE),
              InputContext.cfCompForm.ptCurrentPos.x, InputContext.cfCompForm.ptCurrentPos.y,
              InputContext.cfCompForm.rcArea.left, InputContext.cfCompForm.rcArea.top,
              InputContext.cfCompForm.rcArea.right, InputContext.cfCompForm.rcArea.bottom);

        if (InputContext.hCompStr) {
            if (!tryMove(pCompStr, InputContext.hCompStr)) {
                Print("Could not get hCompStr=%08x\n", InputContext.hCompStr);
                //return FALSE;
            }
        }
        if (pCompStr && fVerbose) {
            sprintf(ach, "COMPOSITIONSTRING %p", pCompStr);
            Idso(0, ach);
        }

        if (InputContext.hCandInfo) {
            if (!tryMove(pCandInfo, InputContext.hCandInfo)) {
                Print("Could not get hCandInfo=%08x\n", InputContext.hCandInfo);
                //return FALSE;
            }
        }
        if (pCandInfo && fVerbose) {
            sprintf(ach, "CANDIDATEINFO %p", pCandInfo);
            Idso(0, ach);
        }

        if (InputContext.hGuideLine) {
            if (!tryMove(pGuideLine, InputContext.hGuideLine)) {
                Print("Could not get hGuideLine=%08x\n", InputContext.hGuideLine);
                //return FALSE;
            }
        }
        if (pGuideLine && fVerbose) {
            sprintf(ach, "GUIDELINE %p", pGuideLine);
            Idso(0, ach);
        }

        if (InputContext.hMsgBuf) {
            if (!tryMove(pMsgBuf, InputContext.hMsgBuf)) {
                Print("Could not get hMsgBuf=%08x\n", InputContext.hMsgBuf);
                //return FALSE;
            }
        }
        if (pMsgBuf && fVerbose) {
            sprintf(ach, "TRANSMSGLIST %p", pMsgBuf);
            Idso(0, ach);
        }

        if (!fDumpInputContext && !fVerbose) {
            Print("  CompStr @ 0x%p  CandInfo @ 0x%p  GuideL @ 0x%p  \n",
                pCompStr, pCandInfo, pGuideLine);
            Print("  MsgBuf @ 0x%p (0x%x)\n", pMsgBuf, InputContext.dwNumMsgBuf);
        }

        if (fDumpInputContext) {
            //
            // Composition String
            //
            if (pCompStr) {
                COMPOSITIONSTRING CompStr;

                move(CompStr, pCompStr);
                Print(" hCompositionString: %p (@ 0x%p) dwSize=0x%x\n",
                    InputContext.hCompStr, pCompStr, CompStr.dwSize);

                if (fShowCompStrRaw) {
                    __PrintInxAttr(NULL, NULL, 0, 0);
                    _PrintInxElementA(CompRead);
                    _PrintInxElementA(Comp);
                    _PrintInxElementB(ResultRead);
                    _PrintInxElementB(Result);
                }

                Print("  CursorPos=0x%x  DeltaStart=0x%x\n",
                    CompStr.dwCursorPos, CompStr.dwDeltaStart);
                Print("  Private: (@ 0x%p) off:0x%x len:0x%x\n",
                    (PBYTE)pCompStr + CompStr.dwPrivateOffset,
                    CompStr.dwPrivateOffset, CompStr.dwPrivateSize);

                Print("\n");

                _PrintInxFriendlyStrA(CompRead);
                _PrintInxFriendlyStrA(Comp);
                _PrintInxFriendlyStrB(ResultRead);
                _PrintInxFriendlyStrB(Result);

                Print("\n");
            }
            else {
                Print(" pCompStr is NULL\n");
            }

            //
            // Candidate Info
            //
            if (pCandInfo) {
                CANDIDATEINFO CandInfo;

                move(CandInfo, pCandInfo);
                Print(" hCandidateInfo: %p (@ 0x%p) dwSize=0x%x dwCount=0x%x PrivOffset=0x%x PrivSize=0x%x\n",
                      InputContext.hCandInfo, pCandInfo, CandInfo.dwSize, CandInfo.dwCount,
                      CandInfo.dwPrivateOffset, CandInfo.dwPrivateSize);

                for (i = 0; i < CandInfo.dwCount; ++i) {
                    PCANDIDATELIST pCandList;
                    CANDIDATELIST CandList;
                    DWORD j;

                    pCandList = (PCANDIDATELIST)((PBYTE)pCandInfo + CandInfo.dwOffset[i]);
                    move(CandList, pCandList);

                    Print("   CandList[%02x] (@ 0x%p) %s count=%x sel=%x pgStart=%x pgSize=%x\n",
                          i, pCandList, GetMaskedEnum(EI_IMECANDIDATESTYLE, CandList.dwStyle, NULL),
                          CandList.dwCount,
                          CandList.dwSelection, CandList.dwPageStart, CandList.dwPageSize);

                    if (CandList.dwStyle == IME_CAND_CODE && CandList.dwCount == 1) {
                        // Special case
                        Print("     Special case: DBCS char = %04x", CandList.dwOffset[0]);
                    }
                    else if (CandList.dwCount > 1) {
                        for (j = 0; j < CandList.dwCount; ++j) {
                            DWORD k;
                            DWORD dwOffset;

                            move(dwOffset, pCandList->dwOffset + j);

                            Print("    %c%c[%02x] @ 0x%p ",
                                  j == CandList.dwSelection ? '*' : ' ',
                                  (j >= CandList.dwPageStart && j < CandList.dwPageStart + CandList.dwPageSize) ? '+' : ' ',
                                  j, (PBYTE)pCandList + dwOffset);
                            for (k = 0; k < 0x100; ++k) {   // limit upto 0xff cch
                                WCHAR wchar;

                                if (fUnicode) {
                                    move(wchar, (PWCHAR)((PBYTE)pCandList + dwOffset) + k);
                                }
                                else {
                                    BYTE bchar;
                                    move(bchar, (PBYTE)pCandList + dwOffset + k);
                                    wchar = bchar;
                                }
                                if (wchar == 0) {
                                    break;
                                }
                                Print("|%s", GetInxStr(wchar, fUnicode));
                            }
                            Print("|\n");
                        }
                    }
                }
            }

            if (pGuideLine) {
                GUIDELINE GuideLine;

                move(GuideLine, pGuideLine);
                Print(" hGuideLine: %p (@ 0x%p) dwSize=0x%x\n",
                    InputContext.hGuideLine, pGuideLine, GuideLine.dwSize);

                Print("   level:%x index;%x privOffset:%x privSize:%x\n",
                      GuideLine.dwLevel, GuideLine.dwIndex,
                      GuideLine.dwPrivateSize, GuideLine.dwPrivateOffset);

                if (GuideLine.dwStrOffset && GuideLine.dwStrLen) {
                    // String
                    Print("   str @ 0x%p  ", (PBYTE)pGuideLine + GuideLine.dwStrOffset);
                    for (i = 0; i < GuideLine.dwStrLen; ++i) {
                        WCHAR wchar;

                        if (fUnicode) {
                            move(wchar, (PWCHAR)((PBYTE)pGuideLine + GuideLine.dwStrOffset) + i);
                        } else {
                            BYTE bchar;
                            move(bchar, (PBYTE)pGuideLine + GuideLine.dwStrOffset + i);
                            wchar = bchar;
                        }
                        Print("|%s", _GetInxStr(wchar, fUnicode));
                    }
                    Print("|\n");
                }
            }

            if (pMsgBuf) {
                TRANSMSGLIST TransMsgList;

                move(TransMsgList, pMsgBuf);
                Print(" hMsgBuf: %p (@ 0x%p) dwNumMsgBuf=0x%x uMsgCount=0x%x\n",
                    InputContext.hMsgBuf, pMsgBuf, InputContext.dwNumMsgBuf,
                    TransMsgList.uMsgCount);

                if (InputContext.dwNumMsgBuf) {
                    PTRANSMSG pTransMsg = pMsgBuf->TransMsg;

                    Print("  | ## |msg | wParam | lParam |\n");
                    Print("  +----+----+--------+--------+\n");

                    for (i = 0; i < InputContext.dwNumMsgBuf; ++i, ++pTransMsg) {
                        const char* pszMsg = "";
                        TRANSMSG TransMsg;
                        DWORD j;

                        move(TransMsg, pTransMsg);

                        // Try to find a readable name of the window message
                        for (j = 0; j < ARRAY_SIZE(gaMsgs); ++j) {
                            if (gaMsgs[i].msg == TransMsg.message) {
                                pszMsg = gaMsgs[j].pszMsg;
                                break;
                            }
                        }

                        Print("   | %02x |%04x|%08x|%08x| %s\n",
                            i,
                            TransMsg.message, TransMsg.wParam, TransMsg.lParam, pszMsg);
                    }
                    Print("  +----+----+--------+--------+\n");
                }
            }

        }
    }

    //
    // Recursively display Mode Savers.
    //
    if (fShowModeSaver) {
        PIMEMODESAVER pModeSaver = InputContext.pImeModeSaver;

        //
        // Private Mode Savers.
        //
        while (pModeSaver) {
            IMEMODESAVER ImeModeSaver;

            move(ImeModeSaver, pModeSaver);
            Print("ImeModeSaver @ 0x%p -- LangId=0x%04x fOpen=0y%d\n",
                  pModeSaver, ImeModeSaver.langId, ImeModeSaver.fOpen);
            Print("    fdwInit      %s\n", GetFlags(GF_IMEINIT, ImeModeSaver.fdwInit, NULL, TRUE));
            Print("    Conversion   %s\n", GetFlags(GF_CONVERSION, ImeModeSaver.fdwConversion, NULL, TRUE));
            Print("    Sentence     %s\n", GetFlags(GF_SENTENCE, ImeModeSaver.fdwSentence, NULL, TRUE));
            move(pModeSaver, &pModeSaver->next);
        }
    }

    return TRUE;
}
#endif  // OLD_FORM

#ifdef OLD_DEBUGGER

#ifndef KERNEL
/************************************************************************\
* Procedure: Ikc
*
* Dumps keyboard cues state for the window, and pertinent info on the
* parent KC state and the system settings related to this
*
* 06/11/98 MCostea     Created
*
\************************************************************************/
BOOL Ikc(
    DWORD opts,
    ULONG64 param1)
{
    WND wnd;
    PWND pwnd, pwndParent;
    char ach[80];
    BOOL bHideFocus, bHideAccel;
    SERVERINFO si;
    PSERVERINFO psi;

    if (param1 && (pwnd = HorPtoP(param1, TYPE_WINDOW)) == 0) {
        Print("Idw: %p is not a pwnd.\n", param1);
        return FALSE;
    }
    psi = GetGlobalPointer(VAR(gpsi));
    move(si, psi);

    if (si.bKeyboardPref) {
        Print("gpsi->bKeyboardPref ON, KC mechanism is turned off\n");
    }
    if (!(si.PUSIFlags & (PUSIF_KEYBOARDCUES | PUSIF_UIEFFECTS) == PUSIF_KEYBOARDCUES | PUSIF_UIEFFECTS)) {
        Print("Either the UI effects or PUSIF_KEYBOARDCUES are off\n");
    }

    if (!param1) {
        return FALSE;
    }
    move(wnd, FIXKP(pwnd));
    /*
     * Print pwnd and title string.
     */
    DebugGetWindowTextA(pwnd, ach, ARRAY_SIZE(ach));
    Print("pwnd = %08lx  \"%s\"\n", pwnd, ach);
    bHideAccel = TestWF(pwnd, WEFPUIACCELHIDDEN);
    bHideFocus = TestWF(pwnd, WEFPUIFOCUSHIDDEN);

    switch(wnd.fnid) {
    case FNID_BUTTON :
        {
            Print("FNID_BUTTON");
        }
        goto printCues;
    case FNID_LISTBOX :
        {
            Print("FNID_LISTBOX");
        }
        goto printCues;
    case FNID_DIALOG :
        {
            Print("FNID_DIALOG");
        }
        goto printCues;
    case FNID_STATIC :
        {
            Print("FNID_STATIC");
        }
printCues:
        Print(bHideAccel ? " Hide Accel" : " Show Accel");
        Print(bHideFocus ? " Hide Focus" : " Show Focus");
        break;

    default:
        Print("Not KC interesting FNID 0x%x", wnd.fnid);
        break;
    }
    Print("\n");

    pwndParent = wnd.spwndParent;
    move(wnd, FIXKP(wnd.spwndParent));
    if (wnd.fnid == FNID_DIALOG) {
        Print("The parent is a dialog:\n");
        Ikc(opts, pwndParent);
    } else {
        Print("The parent is not a dialog\n");
    }
    return TRUE;
}
#endif  // KERNEL

#endif // OLD_DEBUGGER

#ifdef KERNEL

/************************************************************************\
* Procedure: Idimk -- dump IME Hotkeys
*
* 08/09/98 HiroYama     Created
*
\************************************************************************/

#define IHK_ITEM(x) { x, #x }

BOOL Idimk(DWORD opts, ULONG64 param1)
{
    try {
        // PIMEHOTKEYOBJ
        ULONG64 pObj;
        static const struct {
            DWORD mask;
            const char* name;
        } masks[] = {
            IHK_ITEM(MOD_IGNORE_ALL_MODIFIER),
            IHK_ITEM(MOD_ON_KEYUP),
            IHK_ITEM(MOD_RIGHT),
            IHK_ITEM(MOD_LEFT),
            IHK_ITEM(MOD_SHIFT),
            IHK_ITEM(MOD_CONTROL),
            IHK_ITEM(MOD_ALT),
        };
        int nHotKeys = 0;

        UNREFERENCED_PARAMETER(opts);

        if (param1 == 0) {
            pObj = GetGlobalPointer(VAR(gpImeHotKeyListHeader));
            if (!pObj) {
                Print("No IME HotKeys. win32k!gpImeHotKeyListHeader is NULL.\n\n");
                return TRUE;
            }
            Print("using win32k!gpImeHotKeyListHeader (@ 0x%p)\n", pObj);
        } else {
            pObj = FIXKP(param1);
        }

        SAFEWHILE (pObj) {
            int i, n;

            InitTypeRead(pObj, win32k!IMEHOTKEYOBJ);

            Print("ImeHotKeyObj @ 0x%p\n", pObj);
            Print("    pNext          0x%p\n", ReadField(pNext));
            Print("    dwHotKeyID     0x%04x    ", ReadField(hk.dwHotKeyID));

            //
            // Show hotkey ID by name
            //
            if (ReadField(hk.dwHotKeyID) >= IME_HOTKEY_DSWITCH_FIRST && ReadField(hk.dwHotKeyID) <= IME_HOTKEY_DSWITCH_LAST) {
                Print(" Direct Switch to HKL 0x%p", ReadField(hk.hKL));
            } else {
                Print(" %s", GetMaskedEnum(EI_IMEHOTKEYTYPE, (DWORD)ReadField(hk.dwHotKeyID), NULL));
            }

            //
            // Show VKey value by name
            //
            Print("\n    uVKey          0x%02x       %s\n", (UINT)ReadField(hk.uVKey), GetVKeyName((DWORD)ReadField(hk.uVKey)));

            //
            // Show bit mask by name
            //
            Print(  "    Modifiers      0x%04x     ", ReadField(hk.uModifiers));
            n = 0;
            for (i = 0; i < ARRAY_SIZE(masks); ++i) {
                if (masks[i].mask & ReadField(hk.uModifiers)) {
                    Print("%s%s", n ? " | " : "", masks[i].name);
                    ++n;
                }
            }

            //
            // Target HKL
            //
            Print("\n    hKL            0x%p\n\n", ReadField(hk.hKL));

            pObj = ReadField(pNext);

            //
            // If address is specified as an argument, just display one instance.
            //
            if (param1 != 0) {
                break;
            }

            ++nHotKeys;
        }
        if (nHotKeys) {
            Print("Number of IME HotKeys: 0x%04x\n", nHotKeys);
        }
    } except (CONTINUE) {
    }

    return TRUE;
}

#undef IHK_ITEM

#endif  // KERNEL

#ifdef KERNEL
/************************************************************************\
* Procedure: Igflags
*
* Dumps NT Global Flags
*
* 08/11/98 Hiroyama     Created
*
\************************************************************************/

#define DGF_ITEM(x) { x, #x }

BOOL Igflags(DWORD opts)
{
    static const struct {
        DWORD dwFlag;
        const char* name;
    } names[] = {
        DGF_ITEM(FLG_STOP_ON_EXCEPTION),
        DGF_ITEM(FLG_SHOW_LDR_SNAPS),
        DGF_ITEM(FLG_DEBUG_INITIAL_COMMAND),
        DGF_ITEM(FLG_STOP_ON_HUNG_GUI),
        DGF_ITEM(FLG_HEAP_ENABLE_TAIL_CHECK),
        DGF_ITEM(FLG_HEAP_ENABLE_FREE_CHECK),
        DGF_ITEM(FLG_HEAP_VALIDATE_PARAMETERS),
        DGF_ITEM(FLG_HEAP_VALIDATE_ALL),
        DGF_ITEM(FLG_POOL_ENABLE_TAGGING),
        DGF_ITEM(FLG_HEAP_ENABLE_TAGGING),
        DGF_ITEM(FLG_USER_STACK_TRACE_DB),
        DGF_ITEM(FLG_KERNEL_STACK_TRACE_DB),
        DGF_ITEM(FLG_MAINTAIN_OBJECT_TYPELIST),
        DGF_ITEM(FLG_HEAP_ENABLE_TAG_BY_DLL),
        DGF_ITEM(FLG_ENABLE_CSRDEBUG),
        DGF_ITEM(FLG_ENABLE_KDEBUG_SYMBOL_LOAD),
        DGF_ITEM(FLG_DISABLE_PAGE_KERNEL_STACKS),
        DGF_ITEM(FLG_HEAP_DISABLE_COALESCING),
        DGF_ITEM(FLG_ENABLE_CLOSE_EXCEPTIONS),
        DGF_ITEM(FLG_ENABLE_EXCEPTION_LOGGING),
        DGF_ITEM(FLG_ENABLE_HANDLE_TYPE_TAGGING),
        DGF_ITEM(FLG_HEAP_PAGE_ALLOCS),
        DGF_ITEM(FLG_DEBUG_INITIAL_COMMAND_EX),
        DGF_ITEM(FLG_DISABLE_DBGPRINT),
    };
    DWORD dwFlags;
    int i, n = 0;

    moveExpValue(&dwFlags, "NT!NtGlobalFlag");
    if (opts & OFLAG(v)) {
        Print("NT!NtGlobalFlag                         %08lx\n\n", dwFlags);
    } else {
        Print("NT!NtGlobalFlag 0x%lx\n", dwFlags);
    }

    dwFlags &= FLG_VALID_BITS;

    for (i = 0; i < ARRAY_SIZE(names); ++i) {
        BOOLEAN on = (dwFlags & names[i].dwFlag) != 0;

        if (opts & OFLAG(v)) {
            Print("  %c%-34s %c(%08x)\n", on ? '*' : ' ', names[i].name, on ? '*' : ' ', names[i].dwFlag);
        } else {
            if (n++ % 2 == 0) {
                Print("\n");
            }
            Print(" %c%-29s ", on ? '*' : ' ', names[i].name + sizeof("FLG_") - 1);
        }
    }
    if (!(opts & OFLAG(v))) {
        Print("\n");
    }

    return TRUE;
}

#undef DGF_ITEM

#endif  // KERNEL

/************************************************************************\
* Procedure: Ivkey
*
* Dumps virtual keys
*
* 08/11/98 Hiroyama     Created
*
\************************************************************************/
VOID PrintVKey(
    int i)
{
    Print("  %02x %s\n", gVKeyDef[i].dwVKey, gVKeyDef[i].name);
}

BOOL Ivkey(
    DWORD opts,
    LPSTR pszName)
{
    int i;

    if ((opts & OFLAG(a)) || (opts & OFLAG(o))) {
        //
        // List all virtual keys.
        //
        int n = 0;

        for (i = 0; i < 0x100; ++i) {
            const char* name = GetVKeyName(i);
            if (*name) {
                char buf[128];
                int len;

                sprintf(buf, " %02x %-35s", i, name);

                if (opts & OFLAG(a)) {
                    //
                    // If it exceeds the second column width, begin new line.
                    //
                    if ((len = strlen(buf)) >= 40 && n % 2 == 1) {
                        Print("\n");
                        n = 0;
                    }
                    Print(buf);
                    //
                    // If it's in the second column, begin new line.
                    //
                    if (++n % 2 == 0 || len >= 40) {
                        Print("\n");
                        n = 0;
                    }
                } else {
                    Print("%s\n", buf);
                }
            }
        }
        Print("\n");
    } else if (*pszName == 'V' || *pszName == 'v') {
        //
        // Search by VK name.
        //
        int nFound = 0;
        int len = strlen(pszName);

        if (len == 4) {
            int ch = pszName[3];

            if ((ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch <= '9')) {
                Print("  %02x %s\n", ch, pszName);
                ++nFound;
            }
        }

        for (i = 0; i < ARRAY_SIZE(gVKeyDef); ++i) {
            if (_strnicmp(gVKeyDef[i].name, pszName, len) == 0) {
                Print("  %02x %s\n", gVKeyDef[i].dwVKey, gVKeyDef[i].name);
                ++nFound;
            }
        }
        if (nFound == 0) {
            Print("Could not find it.\n");
        }
    } else {
        //
        // Search by VK value.
        //
        NTSTATUS status;
        DWORD dwVKey;
        const char* name;

        status = GetInteger(pszName, 16, &dwVKey, NULL);
        if (!NT_SUCCESS(status)) {
            return FALSE;
        }
        name = GetVKeyName(dwVKey);
        if (*name) {
            Print("  %02x %s\n", dwVKey, name);
        } else {
            Print("Could not find it.\n");
        }
    }

    return TRUE;
}

/************************************************************************\
* Procedure: Idisi
*
* Dumps event injection union
*
* 09/??/98 Hiroyama     Created
*
\************************************************************************/

BOOL I_disi(DWORD opts, ULONG64 param1)
{
    PINPUT pObj;
    INPUT input;

#ifdef _IA64_
    if (!IsPtr64()) {
        Print("not on this platform");
        return TRUE;
    }
#else
    if (IsPtr64()) {
        Print("not on this platform");
        return TRUE;
    }
#endif
    UNREFERENCED_PARAMETER(opts);

    if (param1 == 0) {
        return FALSE;
    }

    pObj = (PINPUT)FIXKP(param1);
    move(input, (ULONG64)pObj);

    Print("INPUT @ 0x%p - size: 0x%x\n", pObj, sizeof(input));

    switch (input.type) {
    case INPUT_MOUSE:
        {
            MOUSEINPUT* pmi = &input.mi;

            Print("type: Mouse Input(%x)\n", input.type);
            Print("     dx          %lx (%ld in dec.)\n", pmi->dx, pmi->dx);
            Print("     dy          %lx (%ld in dec.)\n", pmi->dx, pmi->dx);
            Print("     mouseData   %lx (%ld in dec.)\n", pmi->mouseData, pmi->mouseData);
            Print("     dwFlags     %lx (%s)\n", pmi->dwFlags, GetFlags(GF_MI, pmi->dwFlags, NULL, TRUE));
            Print("     time        %lx\n", pmi->time);
            Print("     dwExtraInfo %lx\n", pmi->dwExtraInfo);
        }
        break;

    case INPUT_KEYBOARD:
        {
            KEYBDINPUT* pki = &input.ki;
            const char* name;

            Print("type: Keyboard Input(%x)\n", input.type);
            //
            // Print Vkey
            //
            Print("     wVk         %lx", pki->wVk);
            name = GetVKeyName(pki->wVk);
            if (*name) {
                Print(" (%s)\n", name);
            } else {
                Print("\n");
            }
            //
            // Print scan code: if KEYEVENTF_UNICODE, it's UNICODE value.
            //
            if (pki->dwFlags & KEYEVENTF_UNICODE) {
                Print("     UNICODE     %lx\n", pki->wScan);
            } else {
                Print("     wScan       %lx\n", pki->wScan);
            }
            //
            // Print and decrypt dwFlags
            //
            Print("     dwFlags     %lx (%s)\n", pki->dwFlags, GetFlags(GF_KI, pki->dwFlags, NULL, TRUE));
            Print("     time        %lx\n", pki->time);
            Print("     dwExtraInfo %lx\n", pki->dwExtraInfo);
        }
        break;

    case INPUT_HARDWARE:
        Print("type: HardwareEvent(%x)\n", input.type);
        Print("         uMsg            %lx\n", input.hi.uMsg);
        Print("         wParamH:wParamL %x:%x\n", input.hi.wParamH, input.hi.wParamL);
        break;

    default:
        Print("Invalid type information(0x%lx)\n", input.type);
        break;
    }

    return TRUE;
}

/************************************************************************\
* Procedure: Iwm
*
* Decrypt window message number
*
* 09/??/98 Hiroyama     Created
*
\************************************************************************/

BOOL IwmWorker(DWORD opts, LPSTR pszName, BOOL fInternalToo)
{
    int len = strlen(pszName);

    UNREFERENCED_PARAMETER(opts);

    if (!(opts & OFLAG(a)) && *pszName == 0) {
        return FALSE;
    }

    if (len >= 3 && pszName[2] == '_' || (opts & OFLAG(a))) {
        //
        // Search by WM name.
        //
        int i;
        int nFound = 0;

        for (i = 0; i < ARRAY_SIZE(gaMsgs); ++i) {
            if (((opts & OFLAG(a)) || _strnicmp(gaMsgs[i].pszMsg, pszName, len) == 0) && (!gaMsgs[i].fInternal || fInternalToo)) {
                Print("  %04x %s\n", gaMsgs[i].msg, gaMsgs[i].pszMsg);
                ++nFound;
            }
        }
        if (nFound == 0) {
            Print("Could not find it.\n");
        }
    } else {
        //
        // Search by WM value.
        //
        DWORD value = (DWORD)EvalExp(pszName);
        int i;

        for (i = 0; i < ARRAY_SIZE(gaMsgs); ++i) {
            if (gaMsgs[i].msg == value && (!gaMsgs[i].fInternal || fInternalToo)) {
                Print("  %04x %s\n", gaMsgs[i].msg, gaMsgs[i].pszMsg);
                break;
            }
        }
    }

    return TRUE;
}

BOOL Iwm(DWORD opts, LPSTR pszName)
{
    return IwmWorker(opts, pszName, FALSE);
}

BOOL I_wm(DWORD opts, LPSTR pszName)
{
    return IwmWorker(opts, pszName, TRUE);
}

//
// Dump Dialog Template
//
//

PBYTE SkipSz(UTCHAR *lpsz, UTCHAR* lpszCopy, UINT len)
{
    UTCHAR c;
    UINT n = 0;

    lpszCopy[len - 1] = 0;

    move(c, (ULONG64)lpsz);
    if (c == 0xFF) {
        if (lpszCopy) {
            *lpszCopy = 0;
        }
        return (PBYTE)lpsz + 4;
    }

    do {
        move(c, (ULONG64)lpsz);
        ++lpsz;
        if (++n < len) {
            if (lpszCopy) {
                *lpszCopy ++ = c;
            }
        }
    } while (c != 0);

    return (PBYTE)lpsz;
}


#ifndef NextWordBoundary
#define NextWordBoundary(p)     ((PBYTE)(p) + ((ULONG_PTR)(p) & 1))
#endif
#ifndef NextDWordBoundary
#define NextDWordBoundary(p)    ((PBYTE)(p) + ((ULONG_PTR)(-(LONG_PTR)(p)) & 3))
#endif

PBYTE WordSkipSz(UTCHAR *lpsz, UTCHAR* lpszCopy, UINT len)
{
    PBYTE pb = SkipSz(lpsz, lpszCopy, len);
    return NextWordBoundary(pb);
}

PBYTE DWordSkipSz(UTCHAR *lpsz, UTCHAR* lpszCopy, UINT len)
{
    PBYTE pb = SkipSz(lpsz, lpszCopy, len);
    return NextDWordBoundary(pb);
}

LPCSTR GetCharSetName(BYTE charset)
{
    return GetMaskedEnum(EI_CHARSETTYPE, charset, NULL);
}

VOID ParseDialogFont(LPWORD* lplpstr, LPDLGTEMPLATE2 lpdt)
{
    LOGFONT     LogFont;
    short       tmp;
    int         fontheight, fheight;
    PSERVERINFO gpsi;
    BOOL fDesktopCharset = FALSE;
    WORD   dmLogPixels;

//
//  fheight = fontheight = (SHORT)(*((WORD *) *lplpstr)++);
//
    move(tmp, (ULONG64)*lplpstr);
    ++*lplpstr;
    fontheight = fheight = tmp;

    if (fontheight == 0x7FFF) {
        // a 0x7FFF height is our special code meaning use the message box font
        Print("\
    Font    System Font (Messagebox font)\n");
        return;
    }


    //
    // The dialog template contains a font description! Use it.
    //
    // Fill the LogFont with default values
    RtlZeroMemory(&LogFont, sizeof(LOGFONT));

    moveExpValue(&gpsi, VAR(gpsi));
    move(dmLogPixels, (ULONG64)&gpsi->dmLogPixels);
    LogFont.lfHeight = -MultDiv(fontheight, dmLogPixels, 72);

    if (lpdt->wDlgVer) {
        WORD w;
        BYTE b;
//
//      LogFont.lfWeight  = *((WORD FAR *) *lplpstr)++;
//
        move(w, (ULONG64)*lplpstr);
        ++*lplpstr;
        LogFont.lfWeight = w;
//
//      LogFont.lfItalic  = *((BYTE FAR *) *lplpstr)++;
//
        move(b, (ULONG64)*lplpstr);
        ++((BYTE*)*lplpstr);
        LogFont.lfItalic = b;

//
//      LogFont.lfCharSet = *((BYTE FAR *) *lplpstr)++;
//
        move(b, (ULONG64)*lplpstr);
        ++((BYTE*)*lplpstr);
        LogFont.lfCharSet = b;
    } else {
        // DIALOG statement, which only has a facename.
        // The new applications are not supposed to use DIALOG statement,
        // they should use DIALOGEX instead.
        LogFont.lfWeight  = FW_BOLD;
        LogFont.lfCharSet = 0;  //(BYTE)GET_DESKTOP_CHARSET();
        fDesktopCharset = TRUE;
    }

    *lplpstr = (WORD*)DWordSkipSz(*lplpstr, LogFont.lfFaceName, ARRAY_SIZE(LogFont.lfFaceName));

    Print("\
    Font    %dpt (%d), Weight: %d, %s Italic, %s,\n\
            \"%ls\"\n",
        fontheight, LogFont.lfHeight,
        LogFont.lfWeight,
        LogFont.lfItalic ? "" : "Not",
        fDesktopCharset ? "DESKTOP_CHARSET" : GetCharSetName(LogFont.lfCharSet),
        LogFont.lfFaceName);
}

LPCSTR GetCtrlStyle(WORD iClass, DWORD style)
{
    WORD type = GF_WS;

    switch (iClass) {
    case ICLS_DIALOG:
        type = GF_DS;
        break;
    case ICLS_STATIC:
        type = GF_SS;
        break;
    case ICLS_EDIT:
        type = GF_ES;
        break;
    case ICLS_BUTTON:
        type = GF_BS;
        break;
    case ICLS_COMBOBOX:
        type = GF_CBS;
        break;
    case ICLS_LISTBOX:
        type = GF_LBS;
        break;
    case ICLS_SCROLLBAR:
        type = GF_SBS;
        break;
    default:
        break;
    }
    return GetFlags(type, style, NULL, FALSE);
}

BOOL I_ddlgt(DWORD opts, ULONG64 param1)
{
#if !defined(_IA64_)
    UNREFERENCED_PARAMETER(opts);
    UNREFERENCED_PARAMETER(param1);
    return FALSE;
#else
    LPDLGTEMPLATE lpdt = (LPDLGTEMPLATE)FIXKP(param1);
    DLGTEMPLATE2 dt;
    LPDLGTEMPLATE2 lpdt2 = &dt;
    BOOLEAN fNewDialogTemplate = FALSE;
    UTCHAR* lpszMenu;
    UTCHAR* lpszClass;
    UTCHAR* lpszText;
    UTCHAR* lpStr;
    UTCHAR* lpCreateParams;
    LPCSTR  lpszIClassName;
    WORD w;
    DLGITEMTEMPLATE2    dit;
    LPDLGITEMTEMPLATE   lpdit;
    UTCHAR menuName[64];
    UTCHAR className[64];
    UTCHAR text[64];
    PSERVERINFO gpsi;

    UNREFERENCED_PARAMETER(opts);

    if (opts == 0 && param1 == 0) {
        return FALSE;
    }

    move(w, (ULONG64)&((LPDLGTEMPLATE2)lpdt)->wSignature);

    if (w == 0xffff) {
        move(dt, (ULONG64)lpdt);
        fNewDialogTemplate = TRUE;
    } else {
        dt.wDlgVer = 0;
        dt.wSignature = 0;
        dt.dwHelpID = 0;
        move(dt.dwExStyle, (ULONG64)&lpdt->dwExtendedStyle);
        move(dt.style, (ULONG64)&lpdt->style);
        move(dt.cDlgItems, (ULONG64)&lpdt->cdit);
        move(dt.x, (ULONG64)&lpdt->x);
        move(dt.y, (ULONG64)&lpdt->y);
        move(dt.cx, (ULONG64)&lpdt->cx);
        move(dt.cy, (ULONG64)&lpdt->cy);
    }


    Print("DlgTemplate%s @ 0x%p version 0n%d\n", dt.wDlgVer ? "2" : "", lpdt, dt.wDlgVer);

    if (!(opts & OFLAG(v))) {
        Print("\
    (%d, %d)-(%d,%d) [%d, %d](dec)\n\
    Style   %08lx   ExStyle %08lx   items 0x%x\n",
              dt.x, dt.y, dt.x + dt.cx, dt.y + dt.cy, dt.cx, dt.cy,
              dt.style, dt.dwExStyle, dt.cDlgItems);
    } else {
        Print("\
    (%d,%d)-(%d,%d) [%d,%d] (dec)  item: 0x%lx\n",
              dt.x, dt.y, dt.x + dt.cx, dt.y + dt.cy,
              dt.cx, dt.cy,
              dt.cDlgItems);
        Print("\
    Style   %08lx %s", dt.style, OFLAG(v) ? GetFlags(GF_DS, dt.style, NULL, FALSE) : "");
        if ((dt.style & DS_SHELLFONT) == DS_SHELLFONT) {
            Print(" [DS_SHELLFONT]");
        }
        Print("\n");
        Print("\
    ExStyle %08lx %s\n", dt.dwExStyle, GetFlags(GF_WSEX, dt.dwExStyle, NULL, FALSE));
    }

    // If there's a menu name string, load it.
    lpszMenu = (LPWSTR)(((PBYTE)(lpdt)) + (dt.wDlgVer ? sizeof(DLGTEMPLATE2) : sizeof(DLGTEMPLATE)));

    /*
     * If the menu id is expressed as an ordinal and not a string,
     * skip all 4 bytes to get to the class string.
     */
    move(w, (ULONG64)(WORD*)lpszMenu);

    /*
     * If there's a menu name string, load it.
     */
    if (w != 0) {
        if (w == 0xffff) {
            LPWORD lpwMenu = (LPWORD)((LPBYTE)lpszMenu + 2);
            move(w, (ULONG64)lpwMenu);
            Print("\
    menu id     %lx\n", w);
        }
    }

    if (w == 0xFFFF) {
        lpszClass = (LPWSTR)((LPBYTE)lpszMenu + 4);
    } else {
        lpszClass = (UTCHAR *)WordSkipSz(lpszMenu, menuName, ARRAY_SIZE(menuName));
        Print("\
    menu   @ 0x%p \"%ls\"\n", lpszMenu, menuName);
    }

    //
    // Class name
    //
    lpszText = (UTCHAR *)WordSkipSz(lpszClass, className, ARRAY_SIZE(className));
    Print("\
    class  @ 0x%p \"%ls\"\n", lpszClass, className);

    //
    // Window text
    //
    lpStr = (UTCHAR *)WordSkipSz(lpszText, text, ARRAY_SIZE(text));
    Print("\
    text   @ 0x%p \"%ls\"\n", lpszText, text);

    //
    // Font
    //
    if (dt.style & DS_SETFONT) {
        ParseDialogFont(&lpStr, &dt);
    }

    lpdit = (LPDLGITEMTEMPLATE)NextDWordBoundary(lpStr);


    ///////////////////////////////////////////////////
    // if "-r" option is not specified, bail out.
    ///////////////////////////////////////////////////
    if (!(opts & OFLAG(r))) {
        return TRUE;
    }

    Print("\n");

    /*
     * Loop through the dialog controls, doing a CreateWindowEx() for each of
     * them.
     */
    while (dt.cDlgItems-- != 0) {
        WORD iClass = 0;
        //
        // Retrieve basic information.
        //

        if (dt.wDlgVer) {
            move(dit, (ULONG64)lpdit);
        } else {
            dit.dwHelpID = 0;
            move(dit.dwExStyle, (ULONG64)&lpdit->dwExtendedStyle);
            move(dit.style, (ULONG64)&lpdit->style);
            move(dit.x, (ULONG64)&lpdit->x);
            move(dit.y, (ULONG64)&lpdit->y);
            move(dit.cx, (ULONG64)&lpdit->cx);
            move(dit.cy, (ULONG64)&lpdit->cy);
            move(w, (ULONG64)&lpdit->id);
            dit.dwID = w;
        }

        Print("\
#ID:0x%04x @ 0x%p HelpID:0x%04x (0n%d, 0n%d)-(0n%d, 0n%d) [0n%d, 0n%d]\n",
            dit.dwID,
            lpdit,
            dit.dwHelpID,
            dit.x, dit.y, dit.x + dit.cx, dit.y + dit.cy,
            dit.cx, dit.cy);

        //
        // Skip DLGITEMTEMPLATE or DLGITEMTEMPLATE2
        //
        lpszClass = (LPWSTR)(((PBYTE)(lpdit)) + (dt.wDlgVer ? sizeof(DLGITEMTEMPLATE2) : sizeof(DLGITEMTEMPLATE)));

        /*
         * If the first WORD is 0xFFFF the second word is the encoded class name index.
         * Use it to look up the class name string.
         */
        move(w, (ULONG64)lpszClass);
        if (w == 0xFFFF) {
            WORD wAtom;

            lpszText = lpszClass + 2;
#ifdef ORG
            lpszClass = (LPWSTR)(gpsi->atomSysClass[*(((LPWORD)lpszClass)+1) & ~CODEBIT]);
#endif
            moveExpValue(&gpsi, VAR(gpsi));
            move(iClass, (ULONG64)lpszClass + 1);
            iClass &= ~CODEBIT;
            if (*(lpszIClassName = GetMaskedEnum(EI_CLSTYPE, iClass, NULL)) == '\0') {
                lpszIClassName = NULL;
            }
            move(wAtom, (ULONG64)&gpsi->atomSysClass[iClass]);
            swprintf(className, L"#%lx", wAtom);
        } else {
            lpszText = (UTCHAR*)SkipSz(lpszClass, className, ARRAY_SIZE(className));
            lpszIClassName = NULL;
        }

        Print("\
    class  @ 0x%p \"%ls\" ", lpszClass, className);
        if (lpszIClassName) {
            Print("= %s", lpszIClassName);
        }
        Print("\n");

        lpszText = (UTCHAR*)NextWordBoundary(lpszText); // UINT align lpszText

//      Our code in InternalCreateDialog does this.
//        dit.dwExStyle |= WS_EX_NOPARENTNOTIFY;
//
        /*
         * Get pointer to additional data.  lpszText can point to an encoded
         * ordinal number for some controls (e.g.  static icon control) so
         * we check for that here.
         */

        move(w, (ULONG64)lpszText);
        if (w == 0xFFFF) {
            swprintf(text, L"#%lx", w);
            lpCreateParams = (LPWSTR)((PBYTE)lpszText + 4);
        } else {
            lpCreateParams = (LPWSTR)(PBYTE)WordSkipSz(lpszText, text, ARRAY_SIZE(text));
        }

        Print("\
    text   @ 0x%p \"%ls\"\n", lpszText, text);

        Print("\
    style   %08lx %s%s", dit.style,
                (opts & OFLAG(v)) ? GetCtrlStyle(iClass, dit.style) : "",
                (opts & OFLAG(v)) ? "\n" : "");
        Print("\
    ExStyle %08lx %s\n", dit.dwExStyle, (opts & OFLAG(v)) ? GetFlags(GF_WSEX, dit.dwExStyle, NULL, FALSE) : "");

        /*
         * Point at next item template
         */
        move(w, (ULONG64)lpCreateParams);
        lpdit = (LPDLGITEMTEMPLATE)NextDWordBoundary(
                (LPBYTE)(lpCreateParams + 1) + w);
        Print("\n");
    }


    return TRUE;
#endif  // _IA64_
}

#ifndef KERNEL
BOOL Idimedpi(DWORD opts, ULONG64 param1)
{
    ULONG64 pImeDpi; // IMEDPI

    UNREFERENCED_PARAMETER(opts);

    if (param1 == 0) {
        pImeDpi = GetGlobalPointer("imm32!gpImeDpi");
    }
    else {
        pImeDpi = FIXKP(param1);
    }

    while (pImeDpi) {
        WCHAR wsz[80];
        InitTypeRead(pImeDpi, imm32!IMEDPI);

        Print("IMEDPI @ 0x%p  hInst: 0x%p cLock: 0n%3d", pImeDpi, ReadField(hInst), (DWORD)ReadField(cLock));
        CopyUnicodeString(pImeDpi, "imm32!IMEDPI", "wszUIClass", wsz, ARRAY_SIZE(wsz));
        Print("  CodePage:%4d UI Class: \"%S\"\n", (DWORD)ReadField(dwCodePage), wsz);
        if (opts & OFLAG(i)) {
            DWORD dwOffset;
            GetFieldOffset("imm32!IMEDPI", "ImeInfo", &dwOffset);
            Print(" ImeInfo: @ 0x%p   dwPrivateDataSize: %08x\n", dwOffset,
                  (DWORD)ReadField(ImeInfo.dwPrivateDataSize));
        }

        if (opts & OFLAG(v)) {
            dso("imm32!IMEDPI", pImeDpi, 0);
        }

        Print("\n");

        pImeDpi = ReadField(pNext);
    }

    return TRUE;
}
#endif // !KERNEL

/************************************************************************\
*
* Procedure: CopyUnicodeString
*
* 06/05/00 JStall       Created (yeah, baby!)
*
\************************************************************************/
BOOL
CopyUnicodeString(
    IN  ULONG64 pData,
    IN  char * pszStructName,
    IN  char * pszFieldName,
    OUT WCHAR *pszDest,
    IN  ULONG cchMax)
{
    ULONG Length;
    ULONG64 Buffer;
    char szLengthName[256];
    char szBufferName[256];

    if (pData == 0) {
        pszDest[0] = '\0';
        return FALSE;
    }

    strcpy(szLengthName, pszFieldName);
    strcat(szLengthName, ".Length");
    strcpy(szBufferName, pszFieldName);
    strcat(szBufferName, ".Buffer");

    if (GetFieldValue(pData, pszStructName, szLengthName, Length) ||
        GetFieldValue(pData, pszStructName, szBufferName, Buffer)) {

        wcscpy(pszDest, L"<< Can't get name >>");
        return FALSE;
    }

    if (Buffer == 0) {
        wcscpy(pszDest, L"<null>");
    } else {
        ULONG cbText;
        cbText = min(cchMax, Length + sizeof(WCHAR));
        if (!(tryMoveBlock(pszDest, FIXKP(Buffer), cbText))) {
            wcscpy(pszDest, L"<< Can't get value >>");
            return FALSE;
        }
    }

    return TRUE;
}


/************************************************************************\
*
* Procedure: Idhard
*
* 06/05/00 JStall       Created (yeah, baby!)
*
\************************************************************************/
#ifdef KERNEL
BOOL Idhard(
    VOID)
{
    ULONG64 phei, pheiNext, pthread;
    WCHAR szText[256], szCaption[256];
    int cErrors = 0;
    DWORD dwClientId;

    Print("Win32k hard error list:\n");

    phei = GetGlobalPointer("winsrv!gphiList");
    while (phei != 0) {
        InitTypeRead(phei, winsrv!HARDERRORINFO);

        pheiNext = ReadField(phiNext);
        pthread = ReadField(pthread);

        CopyUnicodeString(phei, "winsrv!HARDERRORINFO", "usCaption", szCaption, ARRAY_SIZE(szCaption));
        CopyUnicodeString(phei, "winsrv!HARDERRORINFO", "usText", szText, ARRAY_SIZE(szText));

        InitTypeRead(pthread, csrsrv!CSR_THREAD);
        dwClientId = HandleToUlong((HANDLE) ReadField(ClientId.UniqueThread));

        Print("0x%p: tid:0x%x '%S'- '%S'\n", phei, dwClientId, szCaption, szText);

        phei = pheiNext;
        cErrors++;
    }

    Print("%d queued errors\n", cErrors);

    return TRUE;
}

typedef struct {
    ULONG64 thread;
    ULONG64 time;
} KERNELTIME;

ULONG CpuHogCallback(
    PFIELD_INFO NextProcess,
    PVOID Context);

BOOL Ihogs(
    DWORD dwOpts,
    ULONG64 ul64Count)
{
    KERNELTIME *pTimes;
    TIME_FIELDS Times;
    WCHAR appname[64];
    ULONG64 ProcessHead, NextProcess, Process;
    THREAD_DUMP_CONTEXT TDC;
    DWORD dwCount = (DWORD)ul64Count;
    LARGE_INTEGER RunTime;

    UNREFERENCED_PARAMETER(dwOpts);

    // Default to dumping the top 10 threads
    if (dwCount == 0) {
        dwCount = 10;
    }

    pTimes = LocalAlloc(LPTR, dwCount * sizeof(KERNELTIME));
    if (!pTimes) {
        Print("Couldn't allocate memory for KERNELTIME buffer\n");
        return TRUE;
    }

    ProcessHead = EvalExp("PsActiveProcessHead");
    if (!ProcessHead) {
        Print("Unable to get value of PsActiveProcessHead\n");
        return FALSE;
    }

    if (GetFieldValue(ProcessHead, "nt!LIST_ENTRY", "Flink", NextProcess)) {
        Print("Unable to get value of PsActiveProcessHead\n");
        return FALSE;
    }

    if (NextProcess == 0) {
        Print("PsActiveProcessHead->Flink is NULL!\n");
        return FALSE;
    }

    TDC.opts = dwCount;
    TDC.ThreadToDump = (ULONG_PTR)pTimes;
    ListType("nt!EPROCESS", NextProcess, 1, "ActiveProcessLinks.Flink", &TDC, CpuHogCallback);

    for (--dwCount; dwCount != -1; --dwCount) {
        GetFieldValue(pTimes[dwCount].thread, "nt!ETHREAD", "ThreadsProcess", Process);
        GetProcessName(Process, appname);
        RunTime.QuadPart = pTimes[dwCount].time;
        RtlTimeToElapsedTimeFields ( &RunTime, &Times);
        Print("%d: thread %#p - %ws ==> %3ld:%02ld:%02ld.%04ld\n",TDC.opts - dwCount, pTimes[dwCount].thread, appname,
                Times.Hour,
                Times.Minute,
                Times.Second,
                Times.Milliseconds);
    }

    LocalFree(pTimes);

    return TRUE;
}

VOID InsertTime(
    KERNELTIME *pTimes,
    DWORD cnt,
    ULONG64 thread,
    ULONG64 time)
{
    int i = cnt - 1;

    for (; i >= 0; --i) {
        if (time > pTimes[i].time) {
            RtlMoveMemory(&pTimes[0], &pTimes[i], cnt);
            pTimes[i].time = time;
            pTimes[i].thread = thread;
            break;
        }
    }
}

ULONG CpuHogCallback(
    PFIELD_INFO NextProcess,
    PVOID Context)
{
    THREAD_DUMP_CONTEXT *pTDC = (THREAD_DUMP_CONTEXT *)Context;
    KERNELTIME *pTimes = (KERNELTIME*)pTDC->ThreadToDump;
    DWORD dwOffset;
    ULONG64 thread, head, KernelTime;
    TIME_FIELDS Times;
    LARGE_INTEGER RunTime;
    KDDEBUGGER_DATA64 KdDebuggerData;
    static int counter = 0;
    ULONG TimeIncrement = GetUlongFromAddress((GetDebuggerData(KDBG_TAG,
                                     &KdDebuggerData, sizeof(KdDebuggerData)),
                                     KdDebuggerData.KeTimeIncrement));

    GetFieldOffset("nt!EPROCESS", "ThreadListHead", &dwOffset);
    head = NextProcess->address + dwOffset;
    ReadPointer(head, &thread);

    GetFieldOffset("nt!ETHREAD", "ThreadListEntry", &dwOffset);
    do {
        ShowProgress(counter++);
        thread -= dwOffset;
        GetFieldValue(thread, "nt!ETHREAD", "Tcb.KernelTime", KernelTime);
        RunTime.QuadPart = UInt32x32To64(KernelTime, TimeIncrement);
        RtlTimeToElapsedTimeFields ( &RunTime, &Times);
        InsertTime(pTimes, pTDC->opts, thread, RunTime.QuadPart);

        // Get next thread in the list
        ReadPointer(thread + dwOffset, &thread);
    } SAFEWHILE (thread != head);

    // Erase any symbol that might still be showing
    Print("\r");

    // Did we exit the loop because the user hit ^C?
    if (thread != head) {
       // Yes, so return TRUE to stop further callbacks
       return TRUE;
    }

    return FALSE;
}
#endif // KERNEL


#ifdef KERNEL

/************************************************************************\
* Procedure: Idhid
*
* Dumps HID (Raw Input, aka Generic Input) information
*
* ??/??/2000    Hiroyama    Created
\************************************************************************/
VOID DumpProcessHidRequest(
    ULONG64 pHidRequest)
{
    _InitTypeRead(pHidRequest, SYM(tagPROCESS_HID_REQUEST));
    Print("    (0x%x, 0x%x) @ 0x%p -> 0x%p  pwnd: 0x%p sink: 0x%x\n",
          (UINT)ReadField(usUsagePage), (UINT)ReadField(usUsage),
          pHidRequest,
          ReadField(pPORequest),
          ReadField(spwndTarget),
          (UINT)ReadField(fSinkable));
}

ULONG dhidCallback(
    ULONG64 ppi,
    PVOID param)
{
    DWORD opts = PtrToUlong(param);
    ULONG64 pHidTable;
    ULONG64 maskRawInput;
    static ULONG iSeq;

    ShowProgress(++iSeq);

    if (GetFieldValue(ppi, SYM(PROCESSINFO), "pHidTable", pHidTable)) {
        Print("Cannot get pHidTable from ppi=%p\n", ppi);
        return FALSE;
    }

    GetFieldValue(ppi, SYM(PROCESSINFO), "dwRawInputMask", maskRawInput);

    if (pHidTable || maskRawInput) {
        ULONG offset;
        ULONG64 pHidRequest;
        ULONG64 pStart;

        Print(" \nHID for ppi: %p %s\n", ppi, ProcessName(ppi));
        _InitTypeRead(pHidTable, SYM(tagPROCESS_HID_TABLE));
        Print("  PROCESS_HID_TABLE @ 0x%p (sink: 0n%d)\n", pHidTable, (int)ReadField(nSinks));
        Print("    Kbd: raw:0x%x sink:0x%x noleg:0x%x  pwnd: 0x%p nohotkey:0x%x\n",
              (DWORD)ReadField(fRawKeyboard), (DWORD)ReadField(fRawKeyboardSink), (DWORD)ReadField(fNoLegacyKeyboard),
              ReadField(spwndTargetKbd),
              (DWORD)ReadField(fNoHotKeys));
        Print("    Mou: raw:%x sink:%x noleg:%x  pwnd: %p capture:%x\n",
              (DWORD)ReadField(fRawMouse), (DWORD)ReadField(fRawMouseSink), (DWORD)ReadField(fNoLegacyMouse),
              ReadField(spwndTargetMouse), (DWORD)ReadField(fCaptureMouse));
        if (opts & OFLAG(v)) {
            dso(SYM(PROCESS_HID_TABLE), pHidTable, DBG_DUMP_RECUR_LEVEL(1));
        }

        GetFieldOffset(SYM(tagPROCESS_HID_TABLE), "InclusionList.Flink", &offset);
        pStart = pHidTable + offset;
        GetFieldValue(pHidTable, SYM(tagPROCESS_HID_TABLE), "InclusionList.Flink", pHidRequest);

        if (pHidRequest == pStart) {
            Print("  No Inclusion List\n");
        } else {
            Print("  Inclusion List:\n");
            SAFEWHILE (pHidRequest && pHidRequest != pStart) {
                DumpProcessHidRequest(pHidRequest);
                /*
                 * N.b. DumpProcessHidRequest() sets the InitTypeRead
                 */
                pHidRequest = ReadField(link.Flink);
            }
        }

        GetFieldOffset(SYM(tagPROCESS_HID_TABLE), "UsagePageList.Flink", &offset);
        pStart = pHidTable + offset;
        GetFieldValue(pHidTable, SYM(tagPROCESS_HID_TABLE), "UsagePageList.Flink", pHidRequest);
        if (pHidRequest != pStart) {
            Print("  UsagePageOnly List\n");
            SAFEWHILE (pHidRequest && pHidRequest != pStart) {
                DumpProcessHidRequest(pHidRequest);
                pHidRequest = ReadField(link.Flink);
            }
        } else {
            Print("  No UsagePageOnly List\n");
        }

        GetFieldOffset(SYM(tagPROCESS_HID_TABLE), "ExclusionList.Flink", &offset);
        pStart = pHidTable + offset;
        GetFieldValue(pHidTable, SYM(tagPROCESS_HID_TABLE), "ExclusionList.Flink", pHidRequest);
        if (pHidRequest != pStart) {
            Print("  Exclusion List\n");
            SAFEWHILE (pHidRequest && pHidRequest != pStart) {
                DumpProcessHidRequest(pHidRequest);
                if (ReadField(spwndTarget) != 0) {
                    Print("        spwndTarget is not NULL!\n");
                }
                pHidRequest = ReadField(link.Flink);
            }
        } else {
            Print("  No Exclusion List\n");
        }
    }

    return FALSE;
}

BOOL Idhid(DWORD opts, ULONG64 param1)
{
    try {
        ULONG64 pHidRequest;
        ULONG64 pStart;

        pStart = GetGlobalMemberAddress(SYM(gHidRequestTable), SYM(tagHID_REQUEST_TABLE), "TLCInfoList.Flink");
        pHidRequest = GetPointer(pStart);
        if (pHidRequest == NULL_POINTER) {
            Print("pHidRequest is NULL ???\n");
            return TRUE;
        }

        if (pHidRequest != pStart) {
            Print("HID_TLC_INFO:\n");
        }
        SAFEWHILE (pHidRequest && pHidRequest != pStart) {
            _InitTypeRead(pHidRequest, SYM(tagHID_TLC_INFO));
            Print(" (0x%x, 0x%x)  @ 0x%p\n",
                  (UINT)(USHORT)ReadField(usUsagePage), (UINT)(USHORT)ReadField(usUsage),
                  pHidRequest);
            Print("    [cDevices:0x%x] [DirectReq:0x%x] [UsagePReq:0x%x] [ExclReq:0x%x] [ExclOrphaned:0x%x]\n",
                  (UINT)ReadField(cDevices),
                  (UINT)ReadField(cDirectRequest),
                  (UINT)ReadField(cUsagePageRequest),
                  (UINT)ReadField(cExcludeRequest),
                  (UINT)ReadField(cExcludeOrphaned));
            pHidRequest = ReadField(link.Flink);
        }

        pStart = GetGlobalMemberAddress(SYM(gHidRequestTable), SYM(tagHID_REQUEST_TABLE), "UsagePageList.Flink");
        pHidRequest = GetPointer(pStart);

        if (pHidRequest != pStart) {
            Print("HID_PAGEONLY_REQUEST:\n");
        }

        SAFEWHILE (pHidRequest && pHidRequest != pStart) {
            _InitTypeRead(pHidRequest, SYM(tagHID_PAGEONLY_REQUEST));
            Print(" (0x%x, 0) @ 0x%p   cRefCount: 0x%x\n",
                  (UINT)(USHORT)ReadField(usUsagePage),
                  pHidRequest,
                  (UINT)ReadField(cRefCount));
            pHidRequest = ReadField(link.Flink);
        }

        if (opts & OFLAG(p)) {
            if (param1) {
                dhidCallback(param1, ULongToPtr(opts));
            } else {
                ForEachPpi(dhidCallback, ULongToPtr(opts));
            }
        } else {
            ULONG64 gpqForeground = GetGlobalPointer(SYM(gpqForeground));
            if (gpqForeground == NULL_POINTER) {
                Print("gpqForeground is NULL\n");
            } else {
                ULONG64 ptiMouse = NULL_POINTER;
                ULONG64 spwndMouse;
                GetFieldValue(gpqForeground, SYM(tagQ), "spwndCapture", spwndMouse);
                if (spwndMouse) {
                    GetFieldValue(spwndMouse, SYM(tagWND), "head.pti", ptiMouse);
                } else {
                    GetFieldValue(gpqForeground, SYM(tagQ), "ptiMouse", ptiMouse);
                }
                if (ptiMouse == NULL_POINTER) {
                    Print("ptiMouse is NULL.\n");
                } else {
                    ULONG64 ppi;
                    GetFieldValue(ptiMouse, SYM(tagTHREADINFO), "ppi", ppi);
                    Print("\nForeground ppi: %p\n", ppi);
                    dhidCallback(ppi, ULongToPtr(opts));
                }
            }
        }


        pStart = EvalExp(VAR(gHidCounters));
        if (pStart) {
            Print(" \nHID counter @ 0x%p\n", pStart);
            dso(SYM(tagHID_COUNTERS), pStart, 0);
        }

        if (IsChk()) {
            pStart = EvalExp(VAR(gHidAllocCounters));
            if (pStart) {
                Print(" \nDebug Allocate counter @ 0x%p\n", pStart);
                dso(SYM(HidAllocateCounter), pStart, 0);
                Print("gcAllocHidTotal: 0x%x\n", (UINT)GetGlobalPointer(VAR(gcAllocHidTotal)));
            }
        }
    } except (CONTINUE) {
        Print("AV!\n");
    }

    return TRUE;
}

#endif  // KERNEL

BOOL Ipred(DWORD opts, ULONG64 param1)
{
    UINT i = 0;

    UNREFERENCED_PARAMETER(opts);

    while (i < 64) {
        Print("%cp%-2d ", param1 & (1 << i) ? '*' : ' ', i);
        if (++i % 8 == 0) {
            Print("\n");
        }
    }

    return TRUE;
}

#ifdef KERNEL
#ifdef TRACK_PNP_NOTIFICATION

/************************************************************************\
* Procedure: Idhnr
*
* Dumps PnP notification record
*
* 09/19/2000 Hiroyama     Created
*
\************************************************************************/

/*
 * Do not call GetDeviceType twice within a sequence point!
 * This function uses a static variable for the return value.
 */
const char* GetDeviceType(ULONG64 type)
{
    static const char* devicetype[] = {
        "mouse",
        "keyboard",
        "hid",
    };

    if (type >= ARRAY_SIZE(devicetype)) {
        static char buf[32];
        sprintf(buf, "<unknown type %x>", (DWORD)type);
        return buf;
    }
    return devicetype[type];
}

BOOL Idhnr(DWORD opts, ULONG64 param1)
{
    try {
        ULONG64 p, pStart;
        ULONG64 pTarget = 0;
        ULONG64 pTargetDeviceInfo = 0;
        UCHAR szPathNameDevInfo[80] = "";
        UINT iTarget = 0;
        UINT iStartOffset = 0;
        ULONG cbSize;
        DWORD dwArraySize;
        ULONG offsetPathName;
        UINT iSeq, i;

        GetFieldOffset(SYM(PNP_NOTIFICATION_RECORD), "szPathName", &offsetPathName);
        if (offsetPathName == 0) {
            Print("can't get offset to szPathName, make sure TRACK_PNP_NOTIFICATION is turned on.\n");
            return TRUE;
        }

        if (opts & OFLAG(d)) {
            if ((pTargetDeviceInfo = param1) == 0) {
                return FALSE;
            }
        } else if (opts & OFLAG(p)) {
            p = pTarget = param1;
            if (pTarget) {
                goto PrintHeader;
            }
        } else if (param1) {
            iTarget = (UINT)param1;
            opts |= OFLAG(v) | OFLAG(n);
        }

        if ((p = pStart = GetGlobalPointer(VAR(gpPnpNotificationRecord))) == 0) {
            Print("can't get gPnpNotificationRecord\n");
            return TRUE;
        }

        if ((cbSize = GetTypeSize(SYM(PNP_NOTIFICATION_RECORD))) == 0) {
            Print("can't get sizeof(PNP_NOTIFICATION_RECORD)\n");
            return TRUE;
        }

        moveExpValue(&dwArraySize, VAR(gdwPnpNotificationRecSize));
        if (dwArraySize == 0) {
            Print("can't get gdwPnpNotificationRecSize\n");
            return TRUE;
        }

        /*
         * Firstly, find out the lowest iSeq.
         */
        iSeq = UINT_MAX;
        for (i = 0; !IsCtrlCHit() && i < dwArraySize; ++i) {
            UINT iSeqTmp;

            _InitTypeRead(p, SYM(PNP_NOTIFICATION_RECORD));
            iSeqTmp = (UINT)ReadField(iSeq);
            ShowProgress(i);

            if (iSeqTmp < iSeq && iSeqTmp != 0) {
                iSeq = iSeqTmp;
                iStartOffset = i;
            }
            /*
             * For device name search, remember the path name
             * that matches to pDeviceInfo.
             */
            if (pTargetDeviceInfo && (opts & OFLAG(m)) &&
                    szPathNameDevInfo[0] == 0 && ReadField(pDeviceInfo) == pTargetDeviceInfo) {
                move(szPathNameDevInfo, p + offsetPathName);
                Print("\r\"%s\"\n", szPathNameDevInfo);
            }
            p = p + cbSize;
        }
        Print("\r");

        /*
         * Secondly, dump the records.
         */
PrintHeader:
        Print(" seq  %-*c%-20s   %-*s %-*s code\n",
              opts & OFLAG(p) ? PtrWidth() + 2 : 1, ' ',
              "type", PtrWidth(), "pDevInfo", PtrWidth(), "thread");
        if (pTarget) {
            goto PrintOne;
        }
        for (i = 0; !IsCtrlCHit() && i < dwArraySize; ++i) {
            UINT iOffset = (i + iStartOffset) % dwArraySize;
            BOOLEAN fDump = FALSE;

            p = pStart + cbSize * iOffset;
PrintOne:
            _InitTypeRead(p, SYM(PNP_NOTIFICATION_RECORD));
            iSeq = (UINT)ReadField(iSeq);
            if (pTargetDeviceInfo) {
                if (iSeq) {
                    if (ReadField(pDeviceInfo) == pTargetDeviceInfo) {
                        fDump = TRUE;
                    } else if ((opts & OFLAG(m)) && szPathNameDevInfo[0]) {
                        /*
                         * Try to dump the deviceinfo of the same device path.
                         */
                        UCHAR szPathName[ARRAY_SIZE(szPathNameDevInfo)];

                        move(szPathName, p + offsetPathName);
                        if (strcmp(szPathName, szPathNameDevInfo) == 0) {
                            fDump = TRUE;
                        }
                    }
                }
            } else if (iTarget) {
                if (iTarget == iSeq) {
                    /*
                     * Print just one by iSeq.
                     */
                    fDump = TRUE;
                }
            } else if (pTarget) {
                /*
                 * Print just one record by address.
                 */
                fDump = TRUE;
            } else if (iSeq) {
                /*
                 * Dump all valid records.
                 */
                fDump = TRUE;
            }
            if (fDump) {
                UINT type = (UINT)ReadField(type);
                ULONG64 pDeviceInfo = ReadField(pDeviceInfo);
                UCHAR szPathName[80];
                ULONG64 NotificationCode = ReadField(NotificationCode);
                ULONG64 pThread = ReadField(pKThread);
                static const char* symbols[] = {
                    "CLASSNOTIFY",
                    "CREATEDEVICEINFO",
                    "FREEDEVICEINFO",
                    "PROCESSDEVICECHANGES",
                    "REQUESTDEVICECHANGE",
                    "DEVICENOTIFY",
                    "FREE_DEFERRED",
                    "CLOSEDEVICE",
                    "DEVNOTIFY_UNLISTED",
                    "UNREGISTER_NOTIFY",
                    "UNREG_REMOTE_CANCEL",
                };
                const char* name;

                if (type < ARRAY_SIZE(symbols)) {
                    name = symbols[type];
                } else {
                    name = "<unknown>";
                }

                if (opts & OFLAG(p)) {
                    Print("[%04x] %p %x %-20s %08p %p ", iSeq, p, type, name, pDeviceInfo, pThread);
                } else {
                    Print("[%04x] %x %-20s %08p %p ", iSeq, type, name, pDeviceInfo, pThread);
                }

                switch (type) {
                case PNP_NTF_DEVICENOTIFY:
                case PNP_NTF_REQUESTDEVICECHANGE:
                case PNP_NTF_FREEDEVICEINFO:
                case PNP_NTF_FREEDEVICEINFO_DEFERRED:
                case PNP_NTF_CLOSEDEVICE:
                case PNP_NTF_DEVICENOTIFY_UNLISTED:
                case PNP_NTF_UNREGISTER_NOTIFICATION:
                case PNP_NTF_UNREGISTER_REMOTE_CANCELLED:
                    Print("%s\n", GetFlags(GF_DIAF, (DWORD)NotificationCode, NULL, TRUE));
                    break;
                case PNP_NTF_PROCESSDEVICECHANGES:
                case PNP_NTF_CREATEDEVICEINFO:
                case PNP_NTF_CLASSNOTIFY:
                    Print("(%s)\n", GetDeviceType(NotificationCode));
                    break;
                default:
                    Print("%08p\n", NotificationCode);
                    break;
                }

                if (opts & OFLAG(n)) {
                    move(szPathName, p + offsetPathName);
                    Print("    \"%s\"\n", szPathName);
                }
                if (opts & OFLAG(v)) {
                    ULONG offset;

                    GetFieldOffset(SYM(PNP_NOTIFICATION_RECORD), "type", &offset);
                    dso(SYM(PNP_NOTIFICATION_TYPE), p + offset, 0);
                    GetFieldOffset(SYM(PNP_NOTIFICATION_RECORD), "trace", &offset);
                    PrintStackTrace(p + offset, LOCKRECORD_STACK);
                }

                /*
                 * If it is a one-shot dump, exit the loop here.
                 */
                if (iTarget || pTarget) {
                    break;
                }
            }
        }
    } except (CONTINUE) {
    }

    return TRUE;
}
#endif  // TRACK_PNP_NOTIFICATION
#endif  // KERNEL

BOOL Ichkfre(DWORD opts, ULONG64 param1)
{
    UNREFERENCED_PARAMETER(param1);

    if (opts & OFLAG(c)) {
        gfChk = 1;
    } else if (opts & OFLAG(f)) {
        gfChk = 0;
    } else if (opts & OFLAG(r)) {
        gfChk = -1;
    }

#ifdef KERNEL
    Print("Win32k IsChk: %d\n", IsChk());
#else
    Print("User32 IsChk: %d\n", IsChk());
#endif

    return TRUE;
}

#ifdef KERNEL
/************************************************************************\
* Idghost
*
* Dump ghost thread associated information
*
* 12/05/2000 Created MSadek
\************************************************************************/
BOOL Idghost(
    VOID)
{
    ULONG64 pGhost;
    ULONG64 pWnd;
    ULONG64 pWndGhost;
    ULONG64 pGhostThreadInfo;
    ULONG64 pEventScanGhosts;
    ULONG64 pCST;
    LONG SignalGhost;
    UINT i = 0;
    UINT uID;
    UINT uiThreadCount = 0;

    // Dump ghost linked list data.

    pGhost = GetGlobalPointer(SYM(gpghostFirst));
    if (0 == pGhost) {
        Print("Ghost global linked list is empty \n");
    } else {
        Print("Dumping ghost global linked list: \n");
        do {

            InitTypeRead(pGhost, tagGHOST);
            pWnd = ReadField(pwnd);
            pWndGhost = ReadField(pwndGhost);

            Print("Ghost entry #%i: \n\n", ++i);
            Print("Ghosted window: %0lx\n", pWnd);
            if (pWnd) {
                Idw(0, pWnd);
            }
            Print("Ghost window: %0lx\n", pWndGhost);
            if (pWndGhost) {
                Idw(0, pWndGhost);
            }
            GetFieldValue(pGhost, SYM(tagGHOST), "pghostNext", pGhost);
        } SAFEWHILE (pGhost);
    }

    // Dump ghost thread data.

    pGhostThreadInfo = GetGlobalPointer(SYM(gptiGhost));
    if (0 == pGhostThreadInfo) {
        Print("No Ghost thread currently active\n");
    } else {
        Print("GhostThreadInfo 0x%p\n\n", pGhostThreadInfo);
        Idti(0, pGhostThreadInfo);
    }

    // Dump the number of pending thread creation requests in CSR.

    pCST =  EvalExp(SYM(gCSTParam));
    i = 0;
    SAFEWHILE (i < CST_MAX_THREADS) {
        uID =  (UINT)GetArrayElement(pCST, SYM(CST_THREADS), "uID", i, "UINT");
        if (CST_GHOST == uID) {
            uiThreadCount++;
        }
        i++;
    }
    Print("Number of ghost threads waiting to be created in CSRSS is %i\n", uiThreadCount);

    uiThreadCount = 0;
    i = 0;
    // Dump the number of pending thread creation requests in the shell process.

    pCST =  EvalExp(SYM(gCSTRemoteParam));
    i = 0;
    SAFEWHILE (i < CST_MAX_THREADS) {
        uID =  (UINT)GetArrayElement(pCST, SYM(CST_THREADS), "uID", i, "UINT");
        if (CST_GHOST == uID) {
            uiThreadCount++;
        }
        i++;
    }
    Print("Number of ghost threads waiting to be created in the shell process is %i\n", uiThreadCount);

    // Dump the number of pending ghost windows created and freed since dirver last loaded.

    Print("Number of ghost windows created and freed since driver last loaded is %i\n", GetGlobalPointer(SYM(guGhostUnlinked)));

    // Dump signal state for gpEventScanGhosts

    pEventScanGhosts = GetGlobalPointer(SYM(gpEventScanGhosts));
    if (0 != pEventScanGhosts) {
        Print("Scan Ghost event is 0x%p\n", pEventScanGhosts);
        GetFieldValue(pEventScanGhosts, "nt!DISPATCHER_HEADER", "SignalState", SignalGhost);
        if (SignalGhost) {
            Print("Scan ghost event is signaled\n");
        } else {
            Print("Scan ghost event isn't signaled\n");
        }
    }

    return TRUE;
}


/************************************************************************\
* dce
*
* Dump information about the DCE cache.
*
*  6/15/2001    Created     JStall
\************************************************************************/
BOOL Idce(
    DWORD opts,
    ULONG64 param1)
{
    try {
        ULONG64 gpDispInfo, pdceStart, pdceCur;

        gpDispInfo = GetGlobalPointer(VAR(gpDispInfo));
        if (gpDispInfo == 0) {
            Print("ERROR: Unable to retreive win32!gpDispInfo\n");
        } else {
            InitTypeRead(gpDispInfo, DISPLAYINFO);
            pdceStart = ReadField(pdceFirst);
            if (pdceStart == 0) {
                Print("ERROR: Unable to retreive gpDispInfo->pdceFirst\n");
            } else {
                ULONG64 pData;
                DWORD dwData, cTotal, cFound;
                BOOL fDisplay, fVerbose;

                cTotal = cFound = 0;
                fVerbose = opts & OFLAG(v);

                pdceCur = pdceStart;
                while (pdceCur != 0) {
                    fDisplay = FALSE;

                    InitTypeRead(pdceCur, DCE);

                    if (param1 != 0) {
                        if (opts & OFLAG(c)) {
                            //
                            // pwndClip
                            //

                            pData = ReadField(pwndClip);
                            fDisplay = pData == param1;
                        } else if (opts & OFLAG(f)) {
                            //
                            // DCX flag filter
                            //

                            dwData = (DWORD) ReadField(DCX_flags);
                            fDisplay = (dwData & ((DWORD) param1)) != 0;
                        } else if (opts & OFLAG(h)) {
                            //
                            // HDC
                            //

                            pData = ReadField(hdc);
                            fDisplay = pData == param1;
                        } else if (opts & OFLAG(o)) {
                            //
                            // pwndOrg
                            //

                            pData = ReadField(pwndOrg);
                            fDisplay = pData == param1;
                        } else if (opts & OFLAG(r)) {
                            //
                            // hrgnClip
                            //

                            pData = ReadField(hrgnClip);
                            fDisplay = pData == param1;
                        } else if (opts & OFLAG(t)) {
                            //
                            // pti (THREADINFO)
                            //

                            pData = ReadField(ptiOwner);
                            fDisplay = pData == param1;
                        }
                    } else {
                        //
                        // No filter, so display information
                        //

                        fDisplay = TRUE;
                    }

                    if (fDisplay) {
                        if (fVerbose) {
                            ULONG64 hdc, pwndOrg, pwndClip, hrgnClip, ptiOwner;
                            DWORD nFlags;
                            LPCSTR pszFlags;
                            char szOrg[256];
                            char szClip[256];
                            WCHAR szRawApp[80];
                            PWCHAR pszApp;

                            hdc         = ReadField(hdc);
                            pwndOrg     = ReadField(pwndOrg);
                            pwndClip    = ReadField(pwndClip);
                            hrgnClip    = ReadField(hrgnClip);
                            nFlags      = (DWORD) ReadField(DCX_flags);
                            pszFlags    = GetFlags(GF_DCXFLAGS, nFlags, NULL, TRUE);
                            ptiOwner    = ReadField(ptiOwner);

                            szRawApp[0] = L'\0';
                            pszApp      = szRawApp;
                            if (ptiOwner != 0) {
                                InitTypeRead(ptiOwner, THREADINFO);
                                GetAppName(ReadField(pEThread), ptiOwner, szRawApp, sizeof(szRawApp));
                                pszApp = wcsrchr(szRawApp, L'\\');
                                if (pszApp == NULL_POINTER) {
                                    pszApp = szRawApp;
                                } else {
                                    pszApp++;
                                }
                            }

                            DebugGetWindowTextA(pwndOrg, szOrg, ARRAY_SIZE(szOrg));
                            DebugGetWindowTextA(pwndClip, szClip, ARRAY_SIZE(szClip));

                            Print(
                                    "DCE: 0x%p\n"
                                    "  HDC:         0x%p\n"
                                    "  pwndOrg:     0x%p    \"%s\"\n"
                                    "  pwndClip:    0x%p    \"%s\"\n"
                                    "  hrgnClip:    0x%p\n"
                                    "  ptiOwner:    0x%p    \"%ws\"\n"
                                    "  nFlags:      0x%x\n"
                                    "               %s\n\n",
                                    pdceCur,
                                    hdc,
                                    pwndOrg,    szOrg,
                                    pwndClip,   szClip,
                                    hrgnClip,
                                    ptiOwner,   pszApp,
                                    nFlags,
                                    pszFlags);
                        } else {
                            ULONG64 hdc, pwndOrg;
                            char szOrg[256];

                            hdc         = ReadField(hdc);
                            pwndOrg     = ReadField(pwndOrg);

                            DebugGetWindowTextA(pwndOrg, szOrg, ARRAY_SIZE(szOrg));

                            Print("DCE: 0x%p  HDC: 0x%p  pwndOrg: 0x%p  \"%s\"\n",
                                    pdceCur, hdc, pwndOrg, szOrg);
                        }

                        cFound++;
                    }


                    // Get the next DCE
                    InitTypeRead(pdceCur, DCE);
                    pdceCur = ReadField(pdceNext);
                    cTotal++;
                }

                Print("  Total 0x%x (%d) of 0x%x (%d) DCE's\n\n", cFound, cFound, cTotal, cTotal);
            }
        }
    } except (CONTINUE) {
    }

    return TRUE;
}
#endif  // KERNEL

#ifndef KERNEL
/************************************************************************\
* msft
*
* Dump Microsoft's current stock price.
*
* 12/13/2000    Created    JasonSch
\************************************************************************/
BOOL Imsft(
    VOID)
{
    BOOL bResult;
    DWORD dwBytesRead;
    SYSTEMTIME systime;
    CHAR buffer[256], *p;
    HINTERNET hUrlHandle;
    HINTERNET hInternet;

    GetLocalTime(&systime);
    if (systime.wMonth == 4 && systime.wDay == 1) {
        static int n = 0;
        if (n++ < 4) {
            /*
             * Let's pretend to be happy!
             */
            Print("MSFT: 120.5625,+80.1875,\"04/01/%d\",\"%d:%02d%s\"\n",
                  systime.wYear, systime.wHour % 12, systime.wMinute, systime.wHour >= 12 ? "PM" : "AM");
            return TRUE;
        }
    }

    hInternet = InternetOpenW(L"Jo Mama!",
                               INTERNET_OPEN_TYPE_PRECONFIG,
                               NULL,
                               NULL,
                               0);
    if (hInternet == NULL) {
        return FALSE;
    }

    hUrlHandle = InternetOpenUrlW(hInternet,
                                 L"http://quote.yahoo.com/download/quotes.csv?symbols=msft&format=sl1c1d1t1&ext=.txt",
                                 NULL,
                                 0,
                                 INTERNET_FLAG_RAW_DATA,
                                 0);

    if (!hUrlHandle) {
        return FALSE;
    }

    bResult = InternetReadFile(hUrlHandle,
                               buffer,
                               sizeof(buffer),
                               &dwBytesRead);
    if (!bResult) {
        return FALSE;
    }

    InternetCloseHandle(hUrlHandle);
    InternetCloseHandle(hInternet);

    /*
     * Buffer will now have a string that looks like:
     * "MSFT",58.375,+0.3125,"12/12/2000","4:01PM"
     */

    /*
     * NULL-terminate buffer (remove \r\n, while we're at it).
     */
    buffer[dwBytesRead - 2] = 0;
    p = &buffer[7]; // Skip '"MSFT",' part.
    Print("MSFT: %s\n", p);

    return TRUE;
}
#endif // !KERNEL

/************************************************************************\
* Idaccel
*
* Dumps accelerator tables.
*
* 04/02/2001    Created    JasonSch
\************************************************************************/
BOOL Idaccel(
    DWORD dwFlags,
    ULONG64 pAccelTable)
{
    ULONG dwOffset, dwSize;
    ULONG64 phe;
    UINT i, cnt;

    UNREFERENCED_PARAMETER(dwFlags);

    /*
     * pAccelTable could actually be a handle.
     */
    if (HtoHE(pAccelTable, &phe)) {
        GetFieldValue(phe, SYM(HANDLEENTRY), "phead", pAccelTable);
    }

    if (pAccelTable == 0) {
        return FALSE;
    }

    if (_InitTypeRead(pAccelTable, SYM(ACCELTABLE))) {
        Print("Couldn't read ACCELTABLE at %p\n", (ULONG_PTR)pAccelTable);
        return FALSE;
    }

    cnt = (UINT)ReadField(cAccel);
    GetFieldOffset(SYM(ACCELTABLE), "accel", &dwOffset);
    dwSize = GetTypeSize(SYM(ACCEL));
    pAccelTable += dwOffset;
    for (i = 0; i < cnt; ++i) {
        BYTE bVirt;
        BOOL bPrintPlus = FALSE;

        _InitTypeRead(pAccelTable, SYM(ACCEL));
        bVirt = (BYTE)ReadField(fVirt);

        Print("Flags: ");
        if (bVirt & FVIRTKEY) {
            Print("FVIRTKEY");
            bPrintPlus = TRUE;
        }
        if (bVirt & FNOINVERT) {
            if (bPrintPlus) {
                Print(" + ");
            }
            Print("FNOINVERT");
        }
        if (bVirt & FLASTKEY) {
            if (bPrintPlus) {
                Print(" + ");
            }
            Print("FLASTKEY");
        }

        Print("\nKey: ");
        if (bVirt & FALT) {
            Print("ALT + ");
        }
        if (bVirt & FCONTROL) {
            Print("CONTROL + ");
        }
        if (bVirt & FSHIFT) {
            Print("SHIFT + ");
        }
        if (isprint((int)ReadField(key))) {
            Print("'%c'\n", (char)ReadField(key));
        } else {
            Print("<unprintable> (0x%x)\n", (UINT)(WORD)ReadField(key));
        }
        Print("Cmd: 0x%x\n", (UINT)(WORD)ReadField(cmd));
        pAccelTable += dwSize;
    }

    return TRUE;
}

#ifdef KERNEL

/************************************************************************\
* Idhproc
*
* Dumps a proc with this type of kernel handle.
* Similar to !handle 0 7 <eprocess> <type>
*
* 05/14    Created    HiroYama
\************************************************************************/

#if 0
ULONG dhprocCallback(
    PFIELD_INFO NextProcess,
    PVOID Context)
{
    static int progress;

    ShowProgress(++progress);



    return FALSE;
}

BOOL Idhproc(
    DWORD dwFlags,
    PTR ul)
{
    PTR ProcessHead = EvalExp("PsActiveProcessHead");
    PTR NextProcess;
    THREAD_DUMP_CONTEXT tdc;

    if (ProcessHead == NULL_POINTER) {
        Print("Unable to get value of PsActiveProcessHead\n");
        return FALSE;
    }

    if (GetFieldValue(ProcessHead, "nt!LIST_ENTRY", "Flink", NextProcess)) {
        Print("Unable to get value of PsActiveProcessHead\n");
        return FALSE;
    }

    if (NextProcess == 0) {
        Print("PsActiveProcessHead->Flink is NULL!\n");
        return FALSE;
    }

    tdc.opts = dwFlags;
    tdc.ThreadToDump = ul;
    ListType("nt!EPROCESS", NextProcess, 1, "ActiveProcessLinks.Flink", &TDC, dhprocCallback);

    return TRUE;
}
#endif

#endif  // KERNEL


#ifdef LATER
#ifdef KERNEL
/************************************************************************\
* Procedure: Idwsl
*
* Dumps WinSta locking log
*
* 09/19/2000 Hiroyama     Created
*
\************************************************************************/
BOOL Idwsl(
    DWORD opts,
    ULONG64 param1)
{
    try {
        PTR p, pStart;
        PTR pTarget = 0;
        PTR pTargetWinSta = NULL_POINTER;
        UCHAR szWinStaName[80] = "";
        UINT iTarget = 0;
        UINT iStartOffset = 0;
        ULONG cbSize;
        DWORD dwArraySize;
        ULONG offsetWinStaName;
        ULONG offsetImageFileName;
        UINT iSeq, i;

        if (opts & OFLAG(d)) {
            if ((pTargetWinSta = param1) == NULL_POINTER) {
                return FALSE;
            }
        }
        else if (opts & OFLAG(p)) {
            p = pTarget = param1;
            if (pTarget) {
                goto PrintHeader;
            }
        }
        else if (param1) {
            iTarget = (UINT)param1;
            opts |= OFLAG(v) | OFLAG(n);
        }

        offsetWinStaName = (ULONG)-1;
        GetFieldOffset(SYM(WINSTA_RUNDOWN_RECORD), "szWinStaName", &offsetWinStaName);
        if (offsetWinStaName == (ULONG)-1) {
            Print("can't get offset to szWinStaName\n");
            return TRUE;
        }

        GetFieldOffset(SYM(WINSTA_RUNDOWN_RECORD), "szImageFileName", &offsetImageFileName);
        if (offsetImageFileName == 0) {
            Print("can't get offset to szImageFileName\n");
            return TRUE;
        }


        if ((p = pStart = EvalExp(SYM(gaWinStaRundownLog))) == NULL_POINTER) {
            Print("can't get gaWinStaRundownLog\n");
            return TRUE;
        }

        if ((cbSize = GetTypeSize(SYM(WINSTA_RUNDOWN_RECORD))) == 0) {
            Print("can't get sizeof(WINSTA_RUNDOWN_RECORD)\n");
            return TRUE;
        }

        moveExpValue(&dwArraySize, VAR(gdwWinStaRecSize));
        if (dwArraySize == 0) {
            Print("can't get gdwWinStaRecSize\n");
            return TRUE;
        }

        /*
         * Firstly, find out the lowest iSeq.
         */
        iSeq = UINT_MAX;
        for (i = 0; !IsCtrlCHit() && i < dwArraySize; ++i) {
            UINT iSeqTmp;

            _InitTypeRead(p, SYM(WINSTA_RUNDOWN_RECORD));
            iSeqTmp = (UINT)ReadField(iSeq);
            ShowProgress(i);

            if (iSeqTmp < iSeq && iSeqTmp != 0) {
                iSeq = iSeqTmp;
                iStartOffset = i;
            }
            /*
             * For device name search, remember the path name
             * that matches to pDeviceInfo.
             */
            if (pTargetWinSta && (opts & OFLAG(m)) &&
                    szWinStaName[0] == 0 && ReadField(pwinsta) == pTargetWinSta) {
                move(szWinStaName, p + offsetWinStaName);
                Print("\r\"%s\"\n", szWinStaName);
            }
            p = p + cbSize;
        }
        Print("\r");

        /*
         * Secondly, dump the records.
         */
PrintHeader:
#if 0
        Print(" seq  %-*c%-20s   %-*s %-*s code\n",
              opts & OFLAG(p) ? PtrWidth() + 2 : 1, ' ',
              "type", PtrWidth(), "pDevInfo", PtrWidth(), "thread");
#endif
        if (pTarget) {
            goto PrintOne;
        }

        for (i = 0; !IsCtrlCHit() && i < dwArraySize; ++i) {
            UINT iOffset = (i + iStartOffset) % dwArraySize;
            BOOLEAN fDump = FALSE;

            p = pStart + cbSize * iOffset;
PrintOne:
            _InitTypeRead(p, SYM(WINSTA_RUNDOWN_RECORD));
            iSeq = (UINT)ReadField(iSeq);
            if (pTargetWinSta) {
                if (iSeq) {
                    if (ReadField(pwinsta) == pTargetWinSta) {
                        fDump = TRUE;
                    }
                    else if ((opts & OFLAG(m)) && szWinStaName[0]) {
                        /*
                         * Try to dump the winsta of the same device path.
                         */
                        UCHAR szPathNameTmp[ARRAY_SIZE(szWinStaName)];

                        move(szPathNameTmp, p + offsetWinStaName);
                        if (strcmp(szWinStaName, szPathNameTmp) == 0) {
                            fDump = TRUE;
                        }
                    }
                }
            }
            else if (iTarget) {
                if (iTarget == iSeq) {
                    /*
                     * Print just one by iSeq.
                     */
                    fDump = TRUE;
                }
            }
            else if (pTarget) {
                /*
                 * Print just one record by address.
                 */
                fDump = TRUE;
            }
            else if (opts & OFLAG(z)) {
                /*
                 * Print only if the session id don't match.
                 */
                if ((DWORD)ReadField(dwSessionIdWinSta) != (DWORD)ReadField(dwCurrentSessionId)) {
                    fDump = TRUE;
                }
            }
            else if (iSeq) {
                /*
                 * Dump all valid records.
                 */
                fDump = TRUE;
            }

            if (fDump) {
                UINT fReference = (UINT)ReadField(fReference);
                ULONG64 pwinsta = ReadField(pwinsta);
                UCHAR szName[33];
                //ULONG64 NotificationCode = ReadField(NotificationCode);
                ULONG64 pThread = ReadField(pKThread);
                if (opts & OFLAG(p)) {
                    Print("[0x%04x] @ 0x%p 0x%x ws 0x%08p t 0x%p ", iSeq, p, fReference, pwinsta, pThread);
                } else {
                    Print("[0x%04x] 0x%x ws 0x%08p t 0x%p ", iSeq, fReference, pwinsta, pThread);
                }

                /*
                 * Print the windowstation name.
                 */
                move(szName, p + offsetWinStaName);
                Print(" %02x %-20s", (DWORD)ReadField(dwSessionIdWinSta), szName);
                /*
                 * Print the process name.
                 */
                move(szName, p + offsetImageFileName);
                Print(" %02x %x.%x \"%s\"\n", (DWORD)ReadField(dwCurrentSessionId), (DWORD)ReadField(pid), (DWORD)ReadField(tid), szName);

                /*
                 * If it is a one-shot dump, exit the loop here.
                 */
                if (iTarget || pTarget) {
                    break;
                }
            }
        }
    } except (CONTINUE) {
    }

    return TRUE;
}
#endif  // KERNEL
#endif  // LATER


#ifdef KERNEL
/************************************************************************\
* Iheapff
*
* Looks for a particular address in our global list of freed heap.
*
* 07/02/2001    Created    JasonSch
\************************************************************************/
BOOL Iheapff(
    DWORD dwFlags,
    ULONG64 pHeapBlock)
{
    DWORD dwHeapRecordMax, i, dwSize, dwOffset;
    ULONG64 pHeapRecords;

    UNREFERENCED_PARAMETER(pHeapBlock);
    UNREFERENCED_PARAMETER(dwFlags);

    moveExpValue(&dwHeapRecordMax, SYM(gdwFreeHeapRecordCrtIndex));
    dwSize = GetTypeSize(SYM(HEAPRECORD));
    GetFieldOffset(SYM(HEAPRECORD), "trace", &dwOffset);
    pHeapRecords = EvalExp(SYM(garrFreeHeapRecord));

    for (i = 0; i < dwHeapRecordMax; ++i, pHeapRecords += dwSize) {
        _InitTypeRead(pHeapRecords, SYM(HEAPRECORD));
        if (ReadField(p) == pHeapBlock) {
            Print("Found heap block 0x%p (Heap: 0x%p, Size: 0x%p)\n",
                  pHeapBlock,
                  ReadField(pheap),
                  ReadField(size));
            PrintStackTrace(pHeapRecords + dwOffset, 6);
        }
    }

    Print("==========================================================\n");
    moveExpValue(&dwHeapRecordMax, SYM(gdwFreeHeapRecordTotalFrees));
    Print("Total heap allocations freed thus far: 0x%x\n", dwHeapRecordMax);

    return TRUE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kdexts\ntsd\kdexts.c ===
/****************************** Module Header ******************************\
* Module Name: kdexts.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This file is included in the SOURCES= line of sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "..\kdexts.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kdexts\ntsd\makefile.inc ===
HDEPENDENCIES=..\..\exts.h $(WINDOWS_INC_PATH)\stdexts.h

GENUEDEFDEFINES=/D_$(ALT_PROJECT)_
!if !$(FREEBUILD)
GENUEDEFDEFINES=$(GENUEDEFDEFINES) /DDEBUGTAGS=1
!endif

$(O)\userexts.def: ..\..\genuedef.c $(HDEPENDENCIES)
        $(CXX_COMPILER_NAME) $(GENUEDEFDEFINES) /EP ..\..\genuedef.c >$@

#
# Dependencies for dummy targets
#
..\kdexts.c:            ..\..\kdexts.c
..\userexts.c:          ..\..\userkdx.h \
                        ..\..\userexts.c \
                        $(HDEPENDENCIES) \
                        $(WINDOWS_INC_PATH)\stdexts.c \
                        $(O)\wm.txt $(O)\vktbl.txt

..\userexts.rc:         ..\..\userexts.rc

..\..\precomp.h: ..\..\userkdx.h
..\..\userkdx.h: $(NTUSER_PATH)\client\usercli.h \
                 $(NTUSER_PATH)\inc\user.h \
                 $(NTUSER_PATH)\inc\ntuser.h \
                 $(WINDOWS_INC_PATH)\winuserp.h \
                 $(WINDOWS_INC_PATH)\immp.h \
                 $(WINCORE_PATH)\w32inc\winuserk.h


$(O)\ptagdbg.h: $(NTUSER_PATH)\kdexts\ptagdbg.bat $(NTUSER_PATH)\kernel\ptag.lst
    $(NTUSER_PATH)\kdexts\ptagdbg.bat $(NTUSER_PATH)\kernel\ptag.lst $(O)\ptagdbg.h

$(O)\wm.txt: $(PROJECT_ROOT)\Published\winuser.w $(WINDOWS_INC_PATH)\winuserp.h
    perl $(NTUSER_PATH)\kdexts\wm.pl $(PROJECT_ROOT)\Published\winuser.w > $(O)\wm.txt

VKTBL_SRCS=$(PROJECT_ROOT)\Published\winuser.w \
           $(WINDOWS_INC_PATH)\vkoem.h $(PROJECT_ROOT)\Published\ime.w

$(O)\vktbl.txt: $(VKTBL_SRCS)
    perl $(NTUSER_PATH)\kdexts\vkeytbl.pl $(VKTBL_SRCS) > $(O)\vktbl.txt
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kdexts\ntsd\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

!include $(WINCORE_PATH)\core.inc

TARGETNAME=userexts
TARGETTYPE=DYNLINK
TARGETPATH=$(_OBJ_DIR)

TARGETLIBS=$(SDK_LIB_PATH)\kernel32.lib \
           $(WINDOWS_LIB_DEST)\$(ALT_PROJECT_TARGET)\*\user32p.lib \
           $(SDK_LIB_PATH)\WinInet.lib

DELAYLOAD=user32.dll;WinInet.dll

C_DEFINES=$(C_DEFINES) $(USER_C_DEFINES) -D_USER32_ -DUNICODE

!IFNDEF MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3
!ENDIF
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

INCLUDES=..\..;                                  \
        $(NTUSER_PATH)\client;                   \
        $(NTUSER_PATH)\inc;                      \
        $(NTUSER_PATH)\inc\$(ALT_PROJECT)\$(O);  \
        $(NTUSER_PATH)\server;                   \
        $(NTGDI_PATH)\inc;                       \
        $(WINCORE_PATH)\w32inc;                  \
        $(WINCORE_PATH)\w32inc\$(O);             \
        $(NTCON_PATH)\inc;                       \
        $(BASE_INC_PATH)

USE_NTDLL=1

SOURCES=..\kdexts.c    \
        ..\userexts.c  \
        ..\userexts.rc

NTTARGETFILE0=$(O)\userexts.def $(O)\wm.txt $(O)\vktbl.txt $(O)\ptagdbg.h
DLLDEF=$(O)\userexts.def
UMTYPE=console
UMTEST=
UMLIBS=

PRECOMPILED_INCLUDE=..\..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj

SOURCES_USED=..\sources.inc $(WINCORE_PATH)\core.inc

DLOAD_ERROR_HANDLER=NONE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kdexts\ntsd\userexts.c ===
/****************************** Module Header ******************************\
* Module Name: userexts.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This file is included in the SOURCES= line of sources.inc.
*  It allows BUILD.EXE and $(NTMAKEENV)\MAKEFILE.DEF to work with source
*  files that are not stored in the current directory or the current
*  directory's parent.
*  Note also that a specific dependency line is included in makefile.inc
*   so the corresponding object is properly rebuilt when the source file
*   included below changes.
*
* History:
* Feb-14-1996 GerardoB Created
\***************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "..\userexts.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\access.h ===
/****************************** Module Header ******************************\
* Module Name: access.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Typedefs, defines, and prototypes that are used by the accessibility
* routines and the various routines that call them (input routines and
* SystemParametersInfo).
*
* History:
* 11 Feb 93 GregoryW    Created
\***************************************************************************/

#ifndef _ACCESS_
#define _ACCESS_

/*
 * Main accessibility routine entry points.
 */
typedef BOOL (* ACCESSIBILITYPROC)(PKE, ULONG, int);

BOOL FilterKeys(PKE, ULONG, int);
BOOL xxxStickyKeys(PKE, ULONG, int);
BOOL MouseKeys(PKE, ULONG, int);
BOOL ToggleKeys(PKE, ULONG, int);
BOOL HighContrastHotKey(PKE, ULONG, int);
BOOL UtilityManager(PKE, ULONG, int);

BOOL AccessProceduresStream(PKE, ULONG, int);
VOID SetAccessEnabledFlag(VOID);
VOID StopFilterKeysTimers(VOID);

/*
 * Sound support.
 */
typedef BOOL (* BEEPPROC)(void);

BOOL HighBeep(void);
BOOL LowBeep(void);
BOOL KeyClick(void);
BOOL UpSiren(void);
BOOL DownSiren(void);
BOOL DoBeep(BEEPPROC BeepProc, UINT Count);

/*
 * Macros for dwFlags support
 */
#define TEST_ACCESSFLAG(s, f)               TEST_FLAG(g##s.dwFlags, f)
#define TEST_BOOL_ACCESSFLAG(s, f)          TEST_BOOL_FLAG(g##s.dwFlags, f)
#define SET_ACCESSFLAG(s, f)                SET_FLAG(g##s.dwFlags, f)
#define CLEAR_ACCESSFLAG(s, f)              CLEAR_FLAG(g##s.dwFlags, f)
#define SET_OR_CLEAR_ACCESSFLAG(s, f, fSet) SET_OR_CLEAR_FLAG(g##s.dwFlags, f, fSet)
#define TOGGLE_ACCESSFLAG(s, f)             TOGGLE_FLAG(g##s.dwFlags, f)


#define RIGHTSHIFTBIT         0x2
#define ONLYRIGHTSHIFTDOWN(state) ((state) == RIGHTSHIFTBIT)
#define FKFIRSTWARNINGTIME    4000
#define FKACTIVATIONDELTA     4000
#define FKEMERGENCY1DELTA     4000
#define FKEMERGENCY2DELTA     4000

//
// Warning: do not change the ordering of these.
//
#define FKIDLE                   0
#define FKFIRSTWARNING           1
#define FKTOGGLE                 2
#define FKFIRSTLEVELEMERGENCY    3
#define FKSECONDLEVELEMERGENCY   4
#define FKMOUSEMOVE              8

/*
 * StickyKeys support.
 */
#define TOGGLE_STICKYKEYS_COUNT 5
#define UNION(x, y) ((x) | (y))
#define LEFTSHIFTKEY(key)  (((key) & 0xff) == VK_LSHIFT)
#define RIGHTSHIFTKEY(key) (((key) & 0xff) == VK_RSHIFT)
#define LEFTORRIGHTSHIFTKEY(key) (LEFTSHIFTKEY(key) || RIGHTSHIFTKEY(key))
BOOL xxxTwoKeysDown(int);
VOID SetGlobalCursorLevel(INT iCursorLevel);
VOID xxxUpdateModifierState(int, int);
VOID xxxTurnOffStickyKeys(VOID);
VOID xxxHardwareMouseKeyUp(DWORD);

/*
 * ToggleKeys support.
 */
#define TOGGLEKEYTOGGLETIME    5000

/*
 * MouseKeys support.
 */

//
// Parameter Constants for xxxButtonEvent()
//
#define MOUSE_BUTTON_LEFT   0x0001
#define MOUSE_BUTTON_RIGHT  0x0002

#define MOUSEKEYMODBITS     0x11
#define LRALT               0x30
#define LRCONTROL           0x0c
#define LRSHIFT             0x03
#define LRWIN               0xc0
#define VK_U                0x55

//
// Mouse cursor movement data.
//
#define MK_UP               0xFF00
#define MK_DOWN             0x0100
#define MK_RIGHT            0x0001
#define MK_LEFT             0x00FF

#define MOUSETIMERRATE      50
#define MOUSETICKS          (1000 / MOUSETIMERRATE)
/*
 * Factor for high-speed movement.
 */
#define MK_CONTROL_SPEED    4


/*
 * Valid ranges and default values.
 */
#define MAXSPEED_MIN        (10)
#define MAXSPEED_MAX        (360)
#define MAXSPEED_DEF        (40)

#define TIMETOMAXSPEED_MIN  (1000)
#define TIMETOMAXSPEED_MAX  (5000)
#define TIMETOMAXSPEED_DEF  (3000)

typedef BOOL (* MOUSEPROC)(USHORT);

VOID TurnOffMouseKeys(VOID);
BOOL xxxMKButtonClick(USHORT);
BOOL xxxMKMouseMove(USHORT);
BOOL xxxMKButtonSetState(USHORT);
BOOL MKButtonSelect(USHORT);
BOOL xxxMKButtonDoubleClick(USHORT);
BOOL xxxMKToggleMouseKeys(USHORT);
VOID MKShowMouseCursor(VOID);
VOID MKHideMouseCursor(VOID);
VOID CalculateMouseTable(VOID);

/*
 * TimeOut support.
 */
VOID AccessTimeOutReset(VOID);
VOID xxxAccessTimeOutTimer(PWND, UINT, UINT_PTR, LPARAM);

/*
 * SoundSentry support.
 */
BOOL _UserSoundSentryWorker(VOID);

#endif  // !_ACCESS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\access.c ===
/****************************** Module Header ******************************\
* Module Name: access.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains the Access Pack functions.
*
* History:
*   11 Feb 93 GregoryW   Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

CONST ACCESSIBILITYPROC aAccessibilityProc[] = {
    HighContrastHotKey,
    FilterKeys,
    xxxStickyKeys,
    MouseKeys,
    ToggleKeys
#if 0
    ,UtilityManager
#endif
};

typedef struct tagMODBITINFO {
    int BitPosition;
    BYTE ScanCode;
    USHORT Vk;
} MODBITINFO, *PMODBITINFO;

CONST MODBITINFO aModBit[] =
{
    { 0x01, SCANCODE_LSHIFT, VK_LSHIFT },
    { 0x02, SCANCODE_RSHIFT, VK_RSHIFT | KBDEXT },
    { 0x04, SCANCODE_CTRL, VK_LCONTROL },
    { 0x08, SCANCODE_CTRL, VK_RCONTROL | KBDEXT },
    { 0x10, SCANCODE_ALT, VK_LMENU },
    { 0x20, SCANCODE_ALT, VK_RMENU | KBDEXT },
    { 0x40, SCANCODE_LWIN, VK_LWIN },
    { 0x80, SCANCODE_RWIN,    VK_RWIN | KBDEXT}
};

/*
 * The ausMouseVKey array provides a translation from the virtual key
 * value to an index.  The index is used to select the appropriate
 * routine to process the virtual key, as well as to select extra
 * information that is used by this routine during its processing.
 */
CONST USHORT ausMouseVKey[] = {
                       VK_CLEAR,
                       VK_PRIOR,
                       VK_NEXT,
                       VK_END,
                       VK_HOME,
                       VK_LEFT,
                       VK_UP,
                       VK_RIGHT,
                       VK_DOWN,
                       VK_INSERT,
                       VK_DELETE,
                       VK_MULTIPLY,
                       VK_ADD,
                       VK_SUBTRACT,
                       VK_DIVIDE | KBDEXT,
                       VK_NUMLOCK | KBDEXT
                      };

CONST int cMouseVKeys = sizeof(ausMouseVKey) / sizeof(ausMouseVKey[0]);

/*
 * aMouseKeyEvent is an array of function pointers.  The routine to call
 * is selected using the index created by scanning the ausMouseVKey array.
 */
CONST MOUSEPROC aMouseKeyEvent[] = {
    xxxMKButtonClick,      // Numpad 5 (Clear)
    xxxMKMouseMove,        // Numpad 9 (PgUp)
    xxxMKMouseMove,        // Numpad 3 (PgDn)
    xxxMKMouseMove,        // Numpad 1 (End)
    xxxMKMouseMove,        // Numpad 7 (Home)
    xxxMKMouseMove,        // Numpad 4 (Left)
    xxxMKMouseMove,        // Numpad 8 (Up)
    xxxMKMouseMove,        // Numpad 6 (Right)
    xxxMKMouseMove,        // Numpad 2 (Down)
    xxxMKButtonSetState,   // Numpad 0 (Ins)
    xxxMKButtonSetState,   // Numpad . (Del)
    MKButtonSelect,        // Numpad * (Multiply)
    xxxMKButtonDoubleClick,// Numpad + (Add)
    MKButtonSelect,        // Numpad - (Subtract)
    MKButtonSelect,        // Numpad / (Divide)
    xxxMKToggleMouseKeys   // Num Lock
};

/*
 * ausMouseKeyData contains useful data for the routines that process
 * the virtual mousekeys.  This array is indexed using the index created
 * by scanning the ausMouseVKey array.
 */
CONST USHORT ausMouseKeyData[] = {
    0,                     // Numpad 5: Click active button
    MK_UP | MK_RIGHT,      // Numpad 9: Up & Right
    MK_DOWN | MK_RIGHT,    // Numpad 3: Down & Right
    MK_DOWN | MK_LEFT,     // Numpad 1: Down & Left
    MK_UP | MK_LEFT,       // Numpad 7: Up & Left
    MK_LEFT,               // Numpad 4: Left
    MK_UP,                 // Numpad 8: Up
    MK_RIGHT,              // Numpad 6: Right
    MK_DOWN,               // Numpad 2: Down
    FALSE,                 // Numpad 0: Active button down
    TRUE,                  // Numpad .: Active button up
    MOUSE_BUTTON_LEFT | MOUSE_BUTTON_RIGHT,   // Numpad *: Select both buttons
    0,                     // Numpad +: Double click active button
    MOUSE_BUTTON_RIGHT,    // Numpad -: Select right button
    MOUSE_BUTTON_LEFT,     // Numpad /: Select left button
    0
};


__inline void
PostAccessNotification(UINT accessKeyType)
{
    if (gspwndLogonNotify != NULL)
    {
        glinp.ptiLastWoken = GETPTI(gspwndLogonNotify);

        _PostMessage(gspwndLogonNotify, WM_LOGONNOTIFY,
                 LOGON_ACCESSNOTIFY, accessKeyType);
    }
}

void PostRitSound(PTERMINAL pTerm, UINT message) {
    PostEventMessage(
                    pTerm->ptiDesktop,
                    pTerm->ptiDesktop->pq,
                    QEVENT_RITSOUND,
                    NULL,
                    message, 0, 0);
    return;
}

void PostAccessibility( LPARAM lParam )
{
    PTERMINAL pTerm = grpdeskRitInput->rpwinstaParent->pTerm;

    PostEventMessage(
            pTerm->ptiDesktop,
            pTerm->ptiDesktop->pq,
            QEVENT_RITACCESSIBILITY,
            NULL,
            0, HSHELL_ACCESSIBILITYSTATE, lParam);
}

/***************************************************************************\
* AccessProceduresStream
*
* This function controls the order in which the access functions are called.
* All key events pass through this routine.  If an access function returns
* FALSE then none of the other access functions in the stream are called.
* This routine is called initially from KeyboardApcProcedure(), but then
* can be called any number of times by the access functions as they process
* the current key event or add more key events.
*
* Return value:
*   TRUE    All access functions returned TRUE, the key event can be
*           processed.
*   FALSE   An access function returned FALSE, the key event should be
*           discarded.
*
* History:
*   11 Feb 93 GregoryW   Created.
\***************************************************************************/
BOOL AccessProceduresStream(PKE pKeyEvent, ULONG ExtraInformation, int dwProcIndex)
{
    int index;

    CheckCritIn();
    for (index = dwProcIndex; index < ARRAY_SIZE(aAccessibilityProc); index++) {
        if (!aAccessibilityProc[index](pKeyEvent, ExtraInformation, index+1)) {
            return FALSE;
        }
    }

    return TRUE;
}


/***************************************************************************\
* FKActivationTimer
*
* If the hot key (right shift key) is held down this routine is called after
* 4, 8, 12 and 16 seconds.  This routine is only called at the 12 and 16
* second time points if we're in the process of enabling FilterKeys.  If at
* 8 seconds FilterKeys is disabled then this routine will not be called again
* until the hot key is released and then pressed.
*
* This routine is called with the critical section already locked.
*
* Return value:
*    0
*
* History:
*   11 Feb 93 GregoryW   Created.
\***************************************************************************/
VOID FKActivationTimer(PWND pwnd, UINT message, UINT_PTR nID, LPARAM lParam)
{
    UINT TimerDelta;
    PTERMINAL pTerm = grpdeskRitInput->rpwinstaParent->pTerm;

    CheckCritIn();

    switch (gFilterKeysState) {

    case FKFIRSTWARNING:
        //
        // The audible feedback cannot be disabled for this warning.
        //
        /*PostEventMessage(
                    pTerm->ptiDesktop,
                    pTerm->ptiDesktop->pq,
                    QEVENT_RITSOUND,
                    NULL,
                    RITSOUND_DOBEEP, RITSOUND_HIGHBEEP, 3);*/
        TimerDelta = FKACTIVATIONDELTA;
        break;

    case FKTOGGLE:
        if (TEST_ACCESSFLAG(FilterKeys, FKF_FILTERKEYSON)) {
            //
            // Disable Filter Keys
            //
            CLEAR_ACCESSFLAG(FilterKeys, FKF_FILTERKEYSON);
            if (TEST_ACCESSFLAG(FilterKeys, FKF_HOTKEYSOUND)) {
                PostRitSound(
                    pTerm,
                    RITSOUND_DOWNSIREN);
            }
            PostAccessibility( ACCESS_FILTERKEYS );
            //
            // Stop all timers that are currently running.
            //
            if (gtmridFKResponse != 0) {
                KILLRITTIMER(NULL, gtmridFKResponse);
                gtmridFKResponse = 0;
            }
            if (gtmridFKAcceptanceDelay != 0) {
                KILLRITTIMER(NULL, gtmridFKAcceptanceDelay);
                gtmridFKAcceptanceDelay = 0;
            }

            //
            // Don't reset activation timer.  Emergency levels are only
            // activated after enabling Filter Keys.
            //
            return;
        } else {
            PTERMINAL pTerm = grpdeskRitInput->rpwinstaParent->pTerm;

            if (TEST_ACCESSFLAG(FilterKeys, FKF_HOTKEYSOUND)) {
                PostRitSound(
                    pTerm,
                    RITSOUND_UPSIREN);
            }

            PostAccessNotification(ACCESS_FILTERKEYS);

        }
        TimerDelta = FKEMERGENCY1DELTA;
        break;

    case FKFIRSTLEVELEMERGENCY:
        //
        // First level emergency settings:
        //    Repeat Rate OFF
        //    SlowKeys OFF (Acceptance Delay of 0)
        //    BounceKeys Debounce Time of 1 second
        //
        if (TEST_ACCESSFLAG(FilterKeys, FKF_HOTKEYSOUND)) {
            PostEventMessage(
                    pTerm->ptiDesktop,
                    pTerm->ptiDesktop->pq,
                    QEVENT_RITSOUND,
                    NULL,
                    RITSOUND_DOBEEP, RITSOUND_UPSIREN, 2);
        }
        gFilterKeys.iRepeatMSec = 0;
        gFilterKeys.iWaitMSec = 0;
        gFilterKeys.iBounceMSec = 1000;
        TimerDelta = FKEMERGENCY2DELTA;
        break;

    case FKSECONDLEVELEMERGENCY:
        //
        // Second level emergency settings:
        //    Repeat Rate OFF
        //    SlowKeys Acceptance Delay of 2 seconds
        //    BounceKeys OFF (Debounce Time of 0)
        //
        gFilterKeys.iRepeatMSec = 0;
        gFilterKeys.iWaitMSec = 2000;
        gFilterKeys.iBounceMSec = 0;
        if (TEST_ACCESSFLAG(FilterKeys, FKF_HOTKEYSOUND)) {
            PostEventMessage(
                    pTerm->ptiDesktop,
                    pTerm->ptiDesktop->pq,
                    QEVENT_RITSOUND,
                    NULL,
                    RITSOUND_DOBEEP, RITSOUND_UPSIREN, 3);
        }
        return;
        break;

    default:
        return;
    }

    gFilterKeysState++;
    gtmridFKActivation = InternalSetTimer(
                                    NULL,
                                    nID,
                                    TimerDelta,
                                    FKActivationTimer,
                                    TMRF_RIT | TMRF_ONESHOT
                                    );
    return;

    DBG_UNREFERENCED_PARAMETER(pwnd);
    DBG_UNREFERENCED_PARAMETER(lParam);
    DBG_UNREFERENCED_PARAMETER(message);
}

/***************************************************************************\
* FKBounceKeyTimer
*
* If BounceKeys is active this routine is called after the debounce time
* has expired.  Until then, the last key released will not be accepted as
* input if it is pressed again.
*
* Return value:
*    0
*
* History:
*   11 Feb 93 GregoryW   Created.
\***************************************************************************/
VOID FKBounceKeyTimer(PWND pwnd, UINT message, UINT_PTR nID, LPARAM lParam)
{

    CheckCritIn();
    //
    // All we need to do is clear gBounceVk to allow this key as the
    // next keystroke.
    //
    gBounceVk = 0;
    return;

    DBG_UNREFERENCED_PARAMETER(pwnd);
    DBG_UNREFERENCED_PARAMETER(lParam);
    DBG_UNREFERENCED_PARAMETER(nID);
    DBG_UNREFERENCED_PARAMETER(message);

}

/***************************************************************************\
* xxxFKRepeatRateTimer
*
* If FilterKeys is active and a repeat rate is set, this routine controls
* the rate at which the last key pressed repeats.  The hardware keyboard
* typematic repeat is ignored in this case.
*
* This routine is called with the critical section already locked.
*
* Return value:
*    0
*
* History:
*   11 Feb 93 GregoryW   Created.
\***************************************************************************/
VOID xxxFKRepeatRateTimer(PWND pwnd, UINT message, UINT_PTR nID, LPARAM lParam)
{

    CheckCritIn();
    //
    // Repeat after me...
    //
    if (TEST_ACCESSFLAG(FilterKeys, FKF_CLICKON)) {
        PTERMINAL pTerm = grpdeskRitInput->rpwinstaParent->pTerm;
        PostRitSound(
                    pTerm,
                    RITSOUND_KEYCLICK);
    }

    UserAssert(gtmridFKAcceptanceDelay == 0);

    gtmridFKResponse = InternalSetTimer(
                                  NULL,
                                  nID,
                                  gFilterKeys.iRepeatMSec,
                                  xxxFKRepeatRateTimer,
                                  TMRF_RIT | TMRF_ONESHOT
                                  );
    if (AccessProceduresStream(gpFKKeyEvent, gFKExtraInformation, gFKNextProcIndex)) {
        xxxProcessKeyEvent(gpFKKeyEvent, gFKExtraInformation, FALSE);
    }
    return;


    DBG_UNREFERENCED_PARAMETER(pwnd);
    DBG_UNREFERENCED_PARAMETER(lParam);
    DBG_UNREFERENCED_PARAMETER(message);
}

/***************************************************************************\
* xxxFKAcceptanceDelayTimer
*
* If FilterKeys is active and an acceptance delay is set, this routine
* is called after the key has been held down for the acceptance delay
* period.
*
* This routine is called with the critical section already locked.
*
* Return value:
*    0
*
* History:
*   11 Feb 93 GregoryW   Created.
\***************************************************************************/
VOID xxxFKAcceptanceDelayTimer(PWND pwnd, UINT message, UINT_PTR nID, LPARAM lParam)
{

    CheckCritIn();
    //
    // The key has been held down long enough.  Send it on...
    //
    if (TEST_ACCESSFLAG(FilterKeys, FKF_CLICKON)) {
        PTERMINAL pTerm = grpdeskRitInput->rpwinstaParent->pTerm;
        PostRitSound(
                    pTerm,
                    RITSOUND_KEYCLICK);
    }

    if (AccessProceduresStream(gpFKKeyEvent, gFKExtraInformation, gFKNextProcIndex)) {
        xxxProcessKeyEvent(gpFKKeyEvent, gFKExtraInformation, FALSE);
    }
    if (!gFilterKeys.iRepeatMSec) {
        //
        // gptmrFKAcceptanceDelay needs to be released, but we can't do it while
        // in a RIT timer routine.  Set a global to indicate that the subsequent
        // break of this key should be passed on and the timer freed.
        //
        SET_ACCF(ACCF_FKMAKECODEPROCESSED);
        return;
    }
    UserAssert(gtmridFKResponse == 0);
    if (gFilterKeys.iDelayMSec) {
        gtmridFKResponse = InternalSetTimer(
                                      NULL,
                                      nID,
                                      gFilterKeys.iDelayMSec,
                                      xxxFKRepeatRateTimer,
                                      TMRF_RIT | TMRF_ONESHOT
                                      );
    } else {
        gtmridFKResponse = InternalSetTimer(
                                      NULL,
                                      nID,
                                      gFilterKeys.iRepeatMSec,
                                      xxxFKRepeatRateTimer,
                                      TMRF_RIT | TMRF_ONESHOT
                                      );
    }
    //
    // gptmrFKAcceptanceDelay timer structure was reused so set handle to NULL.
    //
    gtmridFKAcceptanceDelay = 0;

    return;

    DBG_UNREFERENCED_PARAMETER(lParam);
    DBG_UNREFERENCED_PARAMETER(message);
    DBG_UNREFERENCED_PARAMETER(pwnd);
}

/***************************************************************************\
* FilterKeys
*
* History:
*   11 Feb 93 GregoryW   Created.
\***************************************************************************/
BOOL FilterKeys(PKE pKeyEvent, ULONG ExtraInformation, int NextProcIndex)
{
    int fBreak;
    BYTE Vk;

    CheckCritIn();
    Vk = (BYTE)(pKeyEvent->usFlaggedVk & 0xff);
    fBreak = pKeyEvent->usFlaggedVk & KBDBREAK;

    //
    // Check for Filter Keys hot key (right shift key).
    //
    if (Vk == VK_RSHIFT) {
        if (fBreak) {
            if (gtmridFKActivation != 0) {
                KILLRITTIMER(NULL, gtmridFKActivation);
                gtmridFKActivation = 0;
            }
            gFilterKeysState = FKIDLE;
        } else if (ONLYRIGHTSHIFTDOWN(gPhysModifierState)) {
            //
            // Verify that activation via hotkey is allowed.
            //
            if (TEST_ACCESSFLAG(FilterKeys, FKF_HOTKEYACTIVE)) {
                if ((gtmridFKActivation == 0) && (gFilterKeysState != FKMOUSEMOVE)) {
                    gFilterKeysState = FKFIRSTWARNING;
                    gtmridFKActivation = InternalSetTimer(
                                                    NULL,
                                                    0,
                                                    FKFIRSTWARNINGTIME,
                                                    FKActivationTimer,
                                                    TMRF_RIT | TMRF_ONESHOT
                                                    );
                }
            }
        }
    }

    //
    // If another key is pressed while the hot key is down, kill
    // the timer.
    //
    if ((Vk != VK_RSHIFT) && (gtmridFKActivation != 0)) {
        gFilterKeysState = FKIDLE;
        KILLRITTIMER(NULL, gtmridFKActivation);
        gtmridFKActivation = 0;
    }
    //
    // If Filter Keys not enabled send the key event on.
    //
    if (!TEST_ACCESSFLAG(FilterKeys, FKF_FILTERKEYSON)) {
        return TRUE;
    }

    if (fBreak) {
        //
        // Kill the current timer and activate bounce key timer (if this is
        // a break of the last key down).
        //
        if (Vk == gLastVkDown) {
            KILLRITTIMER(NULL, gtmridFKResponse);
            gtmridFKResponse = 0;

            gLastVkDown = 0;
            if (gtmridFKAcceptanceDelay != 0) {
                KILLRITTIMER(NULL, gtmridFKAcceptanceDelay);
                gtmridFKAcceptanceDelay = 0;
                if (!TEST_ACCF(ACCF_FKMAKECODEPROCESSED)) {
                    //
                    // This key was released before accepted.  Don't pass on the
                    // break.
                    //
                    return FALSE;
                } else {
                    CLEAR_ACCF(ACCF_FKMAKECODEPROCESSED);
                }
            }

            if (gFilterKeys.iBounceMSec) {
                gBounceVk = Vk;
                gtmridFKResponse = InternalSetTimer(
                                              NULL,
                                              0,
                                              gFilterKeys.iBounceMSec,
                                              FKBounceKeyTimer,
                                              TMRF_RIT | TMRF_ONESHOT
                                              );
                if (TEST_ACCF(ACCF_IGNOREBREAKCODE)) {
                    return FALSE;
                }
            }
        }
    } else {
        //
        // Make key processing
        //
        // First check to see if this is a typematic repeat.  If so, we
        // can ignore this key event.  Our timer will handle any repeats.
        // LastVkDown is cleared during processing of the break.
        //
        if (Vk == gLastVkDown) {
            return FALSE;
        }
        //
        // Remember current Virtual Key down for typematic repeat check.
        //
        gLastVkDown = Vk;

        if (gBounceVk) {
            //
            // BounceKeys is active.  If this is a make of the last
            // key pressed we ignore it.  Only when the BounceKey
            // timer expires or another key is pressed will we accept
            // this key.
            //
            if (Vk == gBounceVk) {
                //
                // Ignore this make event and the subsequent break
                // code.  BounceKey timer will be reset on break.
                //
                SET_ACCF(ACCF_IGNOREBREAKCODE);
                return FALSE;
            } else {
                //
                // We have a make of a new key.  Kill the BounceKey
                // timer and clear gBounceVk.
                //
                UserAssert(gtmridFKResponse);
                if (gtmridFKResponse != 0) {
                    KILLRITTIMER(NULL, gtmridFKResponse);
                    gtmridFKResponse = 0;
                }
                gBounceVk = 0;
            }
        }
        CLEAR_ACCF(ACCF_IGNOREBREAKCODE);

        //
        // Give audible feedback that key was pressed.
        //
        if (TEST_ACCESSFLAG(FilterKeys, FKF_CLICKON)) {
            PTERMINAL pTerm = grpdeskRitInput->rpwinstaParent->pTerm;
            PostRitSound(
                    pTerm,
                    RITSOUND_KEYCLICK);
        }

        //
        // If gptmrFKAcceptanceDelay is non-NULL the previous key was
        // not held down long enough to be accepted.  Kill the current
        // timer.  A new timer will be started below for the key we're
        // processing now.
        //
        if (gtmridFKAcceptanceDelay != 0) {
            KILLRITTIMER(NULL, gtmridFKAcceptanceDelay);
            gtmridFKAcceptanceDelay = 0;
        }

        //
        // If gptmrFKResponse is non-NULL a repeat rate timer is active
        // on the previous key.  Kill the timer as we have a new make key.
        //
        if (gtmridFKResponse != 0) {
            KILLRITTIMER(NULL, gtmridFKResponse);
            gtmridFKResponse = 0;
        }

        //
        // Save the current key event for later use if we process an
        // acceptance delay or key repeat.
        //
        *gpFKKeyEvent = *pKeyEvent;
        gFKExtraInformation = ExtraInformation;
        gFKNextProcIndex = NextProcIndex;

        //
        // If there is an acceptance delay, set timer and ignore current
        // key event.  When timer expires, saved key event will be sent.
        //
        if (gFilterKeys.iWaitMSec) {
            gtmridFKAcceptanceDelay = InternalSetTimer(
                                          NULL,
                                          0,
                                          gFilterKeys.iWaitMSec,
                                          xxxFKAcceptanceDelayTimer,
                                          TMRF_RIT | TMRF_ONESHOT
                                          );
            CLEAR_ACCF(ACCF_FKMAKECODEPROCESSED);
            return FALSE;
        }
        //
        // No acceptance delay.  Before sending this key event on the
        // timer routine must be set to either the delay until repeat value
        // or the repeat rate value.  If repeat rate is 0 then ignore
        // delay until repeat.
        //
        if (!gFilterKeys.iRepeatMSec) {
            return TRUE;
        }

        UserAssert(gtmridFKResponse == 0);
        if (gFilterKeys.iDelayMSec) {
            gtmridFKResponse = InternalSetTimer(
                                          NULL,
                                          0,
                                          gFilterKeys.iDelayMSec,
                                          xxxFKRepeatRateTimer,
                                          TMRF_RIT | TMRF_ONESHOT
                                          );
        } else {
            gtmridFKResponse = InternalSetTimer(
                                          NULL,
                                          0,
                                          gFilterKeys.iRepeatMSec,
                                          xxxFKRepeatRateTimer,
                                          TMRF_RIT | TMRF_ONESHOT
                                          );
        }
    }

    return TRUE;
}

/***************************************************************************\
* StopFilterKeysTimers
*
* Called from SystemParametersInfo on SPI_SETFILTERKEYS if FKF_FILTERKEYSON
* is not set.  Timers must be stopped if user turns FilterKeys off.
*
* History:
*   18 Jul 94 GregoryW   Created.
\***************************************************************************/
VOID StopFilterKeysTimers(VOID)
{

    if (gtmridFKResponse != 0) {
        KILLRITTIMER(NULL, gtmridFKResponse);
        gtmridFKResponse = 0;
    }
    if (gtmridFKAcceptanceDelay) {
        KILLRITTIMER(NULL, gtmridFKAcceptanceDelay);
        gtmridFKAcceptanceDelay = 0;
    }
    gLastVkDown = 0;
    gBounceVk = 0;
}

/***************************************************************************\
* xxxStickyKeys
*
* History:
*   11 Feb 93 GregoryW   Created.
\***************************************************************************/
BOOL xxxStickyKeys(PKE pKeyEvent, ULONG ExtraInformation, int NextProcIndex)
{
    int fBreak;
    BYTE NewLockBits, NewLatchBits;
    int BitPositions;
    BOOL bChange;
    PTERMINAL pTerm = grpdeskRitInput->rpwinstaParent->pTerm;


    CheckCritIn();
    fBreak = pKeyEvent->usFlaggedVk & KBDBREAK;

    if (gCurrentModifierBit) {
        //
        // Process modifier key
        //

        //
        // One method of activating StickyKeys is to press either the
        // left shift key or the right shift key five times without
        // pressing any other keys.  We don't want the typematic shift
        // (make code) to enable/disable StickyKeys so we perform a
        // special test for them.
        //
        if (!fBreak) {
            if (gCurrentModifierBit & gPrevModifierState) {
                //
                // This is a typematic make of a modifier key.  Don't do
                // any further processing.  Just pass it along.
                //
                gPrevModifierState = gPhysModifierState;
                return TRUE;
            }
        }

        gPrevModifierState = gPhysModifierState;

        if (LEFTSHIFTKEY(pKeyEvent->usFlaggedVk) &&
            ((gPhysModifierState & ~gCurrentModifierBit) == 0)) {
            gStickyKeysLeftShiftCount++;
        } else {
            gStickyKeysLeftShiftCount = 0;
        }
        if (RIGHTSHIFTKEY(pKeyEvent->usFlaggedVk) &&
            ((gPhysModifierState & ~gCurrentModifierBit) == 0)) {
            gStickyKeysRightShiftCount++;
        } else {
            gStickyKeysRightShiftCount = 0;
        }

        //
        // Check to see if StickyKeys should be toggled on/off
        //
        if ((gStickyKeysLeftShiftCount == (TOGGLE_STICKYKEYS_COUNT * 2)) ||
            (gStickyKeysRightShiftCount == (TOGGLE_STICKYKEYS_COUNT * 2))) {
            if (TEST_ACCESSFLAG(StickyKeys, SKF_HOTKEYACTIVE)) {
                if (TEST_ACCESSFLAG(StickyKeys, SKF_STICKYKEYSON)) {
                    xxxTurnOffStickyKeys();
                    if (TEST_ACCESSFLAG(StickyKeys, SKF_HOTKEYSOUND)) {
                        PostRitSound(
                            pTerm,
                            RITSOUND_DOWNSIREN);
                    }
                } else {
                    if (TEST_ACCESSFLAG(StickyKeys, SKF_HOTKEYSOUND)) {
                        PostRitSound(
                            pTerm,
                            RITSOUND_UPSIREN);
                    }
                    // To make the notification window get the focus
                    // The same is done other places where WM_LOGONNOTIFY message is
                    // sent    : a-anilk
                    PostAccessNotification(ACCESS_STICKYKEYS);

                }
            }
            gStickyKeysLeftShiftCount = 0;
            gStickyKeysRightShiftCount = 0;
            return TRUE;
        }

        //
        // If StickyKeys is enabled process the modifier key, otherwise
        // just pass on the modifier key.
        //
        if (TEST_ACCESSFLAG(StickyKeys, SKF_STICKYKEYSON)) {
            if (fBreak) {
                //
                // If either locked or latched bit set for this key then
                // don't pass the break on.
                //
                if (UNION(gLatchBits, gLockBits) & gCurrentModifierBit) {
                    return FALSE;
                } else {
                    return TRUE;
                }
            } else{
                if (gPhysModifierState != gCurrentModifierBit) {
                    //
                    // More than one modifier key down at the same time.
                    // This condition may signal sticky keys to turn off.
                    // The routine xxxTwoKeysDown will return the new value
                    // of fStickyKeysOn.  If sticky keys is turned off
                    // (return value 0), the key event should be passed
                    // on without further processing here.
                    //
                    if (!xxxTwoKeysDown(NextProcIndex)) {
                        return TRUE;
                    }

                    //
                    // Modifier states were set to physical state by
                    // xxxTwoKeysDown.  The modifier keys currently in
                    // the down position will be latched by updating
                    // gLatchBits.  No more processing for this key
                    // event is needed.
                    //
                    bChange = gLockBits ||
                              (gLatchBits != gPhysModifierState);
                    gLatchBits = gPhysModifierState;
                    gLockBits = 0;
                    if (bChange) {
                        PostAccessibility( ACCESS_STICKYKEYS );
                    }

                    //
                    // Provide sound feedback, if enabled, before returning.
                    //
                    if (TEST_ACCESSFLAG(StickyKeys, SKF_AUDIBLEFEEDBACK)) {
                        PostRitSound(
                            pTerm,
                            RITSOUND_LOWBEEP);
                        PostRitSound(
                            pTerm,
                            RITSOUND_HIGHBEEP);
                    }
                    return FALSE;
                }
                //
                // Figure out which bits (Shift, Ctrl or Alt key bits) to
                // examine.  Also set up default values for NewLatchBits
                // and NewLockBits in case they're not set later.
                //
                // See the depiction of the bit pattern in KeyboardApcProcedure.
                //
                // Bit 0 -- L SHIFT
                // Bit 1 -- R SHIFT
                // Bit 2 -- L CTL
                // Bit 3 -- R CTL
                // Bit 4 -- L ALT
                // Bit 5 -- R RLT
                // Bit 6 -- L WIN
                // Bit 7 -- R WIN
                switch(pKeyEvent->usFlaggedVk) {
                case VK_LSHIFT:
                case VK_RSHIFT:
                    BitPositions = 0x3;
                    break;
                case VK_LCONTROL:
                case VK_RCONTROL:
                    BitPositions = 0xc;
                    break;
                case VK_LMENU:
                case VK_RMENU:
                    BitPositions = 0x30;
                    break;
                case VK_LWIN:
                case VK_RWIN:
                    BitPositions = 0xc0;
                    break;
                }
                NewLatchBits = gLatchBits;
                NewLockBits = gLockBits;

                //
                // If either left or right modifier is locked clear latched
                // and locked states and send appropriate break/make messages.
                //
                if (gLockBits & BitPositions) {
                    NewLockBits = gLockBits & ~BitPositions;
                    NewLatchBits = gLatchBits & ~BitPositions;
                    xxxUpdateModifierState(
                        NewLockBits | NewLatchBits | gCurrentModifierBit,
                        NextProcIndex
                        );
                } else {
                    //
                    // If specific lock bit (left or right) not
                    // previously set then toggle latch bits.
                    //
                    if (!(gLockBits & gCurrentModifierBit)) {
                        NewLatchBits = gLatchBits ^ gCurrentModifierBit;
                    }
                    //
                    // If locked mode (tri-state) enabled then if latch or lock
                    // bit previously set, toggle lock bit.
                    //
                    if (TEST_ACCESSFLAG(StickyKeys, SKF_TRISTATE)) {
                        if (UNION(gLockBits, gLatchBits) & gCurrentModifierBit) {
                            NewLockBits = gLockBits ^ gCurrentModifierBit;
                        }
                    }
                }

                //
                // Update globals
                //
                bChange = ((gLatchBits != NewLatchBits) ||
                           (gLockBits != NewLockBits));

                gLatchBits = NewLatchBits;
                gLockBits = NewLockBits;

                if (bChange) {
                    PostAccessibility( ACCESS_STICKYKEYS );
                }
                //
                // Now provide sound feedback if enabled.  For the transition
                // to LATCH mode issue a low beep then a high beep.  For the
                // transition to LOCKED mode issue a high beep.  For the
                // transition out of LOCKED mode (or LATCH mode if tri-state
                // not enabled) issue a low beep.
                //
                if (TEST_ACCESSFLAG(StickyKeys, SKF_AUDIBLEFEEDBACK)) {
                    if (!(gLockBits & gCurrentModifierBit)) {
                        PostRitSound(
                            pTerm,
                            RITSOUND_LOWBEEP);
                    }
                    if ((gLatchBits | gLockBits) & gCurrentModifierBit) {
                        PostRitSound(
                            pTerm,
                            RITSOUND_HIGHBEEP);
                    }
                }
                //
                // Pass key on if shift bit is set (e.g., if transitioning
                // from shift to lock mode don't pass on make).
                //
                if (gLatchBits & gCurrentModifierBit) {
                    return TRUE;
                } else {
                    return FALSE;
                }

            }
        }
    } else {
        //
        // Non-shift key processing here...
        //
        gStickyKeysLeftShiftCount = 0;
        gStickyKeysRightShiftCount = 0;
        if (!TEST_ACCESSFLAG(StickyKeys, SKF_STICKYKEYSON)) {
            return TRUE;
        }

        //
        // If no modifier keys are down, or this is a break, pass the key event
        // on and clear any latch states.
        //
        if (!gPhysModifierState || fBreak) {
            if (AccessProceduresStream(pKeyEvent, ExtraInformation, NextProcIndex)) {
                xxxProcessKeyEvent(pKeyEvent, ExtraInformation, FALSE);
            }
            xxxUpdateModifierState(gLockBits, NextProcIndex);

            bChange = gLatchBits != 0;
            gLatchBits = 0;
            if (bChange) {

                PostAccessibility( ACCESS_STICKYKEYS );
            }
            return FALSE;
        } else {
            //
            // This is a make of a non-modifier key and there is a modifier key
            // down.  Update the states and pass the key event on.
            //
            xxxTwoKeysDown(NextProcIndex);
            return TRUE;
        }
    }

    return TRUE;
}

/***************************************************************************\
* xxxUpdateModifierState
*
* Starting from the current modifier keys state, send the necessary key
* events (make or break) to end up with the NewModifierState passed in.
*
* Return value:
*    None.
*
* History:
*   11 Feb 93 GregoryW   Created.
\***************************************************************************/
VOID xxxUpdateModifierState(int NewModifierState, int NextProcIndex)
{
    KE ke;
    int CurrentModState;
    int CurrentModBit, NewModBit;
    int i;

    CheckCritIn();

    CurrentModState = gLockBits | gLatchBits;

    for (i = 0; i < ARRAY_SIZE(aModBit); i++) {
        CurrentModBit = CurrentModState & aModBit[i].BitPosition;
        NewModBit = NewModifierState & aModBit[i].BitPosition;
        if (CurrentModBit != NewModBit) {
            ke.bScanCode = (BYTE)aModBit[i].ScanCode;
            ke.usFlaggedVk = aModBit[i].Vk;
            if (CurrentModBit) {          // if it's currently on, send break
                ke.usFlaggedVk |= KBDBREAK;
            }
            if (AccessProceduresStream(&ke, 0L, NextProcIndex)) {
                xxxProcessKeyEvent(&ke, 0L, FALSE);
            }
        }
    }
}

/***************************************************************************\
* xxxTurnOffStickyKeys
*
* The user either pressed the appropriate key sequence or used the
* access utility to turn StickyKeys off.  Update modifier states and
* reset globals.
*
* Return value:
*   None.
*
* History:
*   11 Feb 93 GregoryW   Created.
\***************************************************************************/
VOID xxxTurnOffStickyKeys(VOID)
{
    INT index;

    CheckCritIn();

    for (index = 0; index < ARRAY_SIZE(aAccessibilityProc); index++) {
        if (aAccessibilityProc[index] == xxxStickyKeys) {

            xxxUpdateModifierState(gPhysModifierState, index+1);
            gLockBits = gLatchBits = 0;
            CLEAR_ACCESSFLAG(StickyKeys, SKF_STICKYKEYSON);

            PostAccessibility( ACCESS_STICKYKEYS );
            break;
        }
    }
}

/***************************************************************************\
* xxxUnlatchStickyKeys
*
* This routine releases any sticky keys that are latched.  This routine
* is called during mouse up event processing.
*
* Return value:
*   None.
*
* History:
*   21 Jun 93 GregoryW   Created.
\***************************************************************************/
VOID xxxUnlatchStickyKeys(VOID)
{
    INT index;
    BOOL bChange;

    if (!gLatchBits) {
        return;
    }

    for (index = 0; index < ARRAY_SIZE(aAccessibilityProc); index++) {
        if (aAccessibilityProc[index] == xxxStickyKeys) {
            xxxUpdateModifierState(gLockBits, index+1);
            bChange = gLatchBits != 0;
            gLatchBits = 0;

            if (bChange) {

                PostAccessibility( ACCESS_STICKYKEYS );
            }
            break;
        }
    }
}


/***************************************************************************\
* xxxHardwareMouseKeyUp
*
* This routine is called during a mouse button up event.  If MouseKeys is
* on and the button up event corresponds to a mouse key that's locked down,
* the mouse key must be released.
*
* If StickyKeys is on, all latched keys are released.
*
* Return value:
*   None.
*
* History:
*   17 Jun 94 GregoryW   Created.
\***************************************************************************/

VOID xxxHardwareMouseKeyUp(DWORD dwButton)
{
    CheckCritIn();

    if (TEST_ACCESSFLAG(MouseKeys, MKF_MOUSEKEYSON)) {
        gwMKButtonState &= ~dwButton;
    }

    // Not required to post a setting change
    //PostAccessibility( SPI_SETMOUSEKEYS );

    if (TEST_ACCESSFLAG(StickyKeys, SKF_STICKYKEYSON)) {
        xxxUnlatchStickyKeys();
    }
}


/***************************************************************************\
* xxxTwoKeysDown
*
* Two keys are down simultaneously.  Check to see if StickyKeys should be
* turned off.  In all cases update the modifier key state to reflect the
* physical key state and clear latched and locked modes.
*
* Return value:
*    1 if StickyKeys is enabled.
*    0 if StickyKeys is disabled.
*
* History:
*   11 Feb 93 GregoryW   Created.
\***************************************************************************/
BOOL xxxTwoKeysDown(int NextProcIndex)
{
    PTERMINAL pTerm = grpdeskRitInput->rpwinstaParent->pTerm;

    if (TEST_ACCESSFLAG(StickyKeys, SKF_TWOKEYSOFF)) {
        CLEAR_ACCESSFLAG(StickyKeys, SKF_STICKYKEYSON);
        if (TEST_ACCESSFLAG(StickyKeys, SKF_HOTKEYSOUND)) {
            PostRitSound(
                    pTerm,
                    RITSOUND_DOWNSIREN);
        }
        gStickyKeysLeftShiftCount = 0;
        gStickyKeysRightShiftCount = 0;
    }
    xxxUpdateModifierState(gPhysModifierState, NextProcIndex);
    gLockBits = gLatchBits = 0;

    PostAccessibility( ACCESS_STICKYKEYS );

    return TEST_BOOL_ACCESSFLAG(StickyKeys, SKF_STICKYKEYSON);
}

/***************************************************************************\
* SetGlobalCursorLevel
*
* Set the cursor level of all threads running on the visible
* windowstation.
*
* History:
* 04-17-95 JimA         Created.
\***************************************************************************/

VOID SetGlobalCursorLevel(
    INT iCursorLevel)
{

/*
 * LATER
 * We have other code which assumes that the
 * iCursorLevel of a queue is the sum of the iCursorLevel values for the
 * threads attached to the queue.  But this code, if you set iCursorLevel to
 * -1 (to indicate no mouse) will set the queue iCursorLevel to -1, no matter
 * how many threads are attached to the queue.  This needs to be revisited.
 * See the function AttachToQueue.
 *  FritzS
 */


    PDESKTOP pdesk;
    PTHREADINFO pti;
    PLIST_ENTRY pHead, pEntry;

    TAGMSG1(DBGTAG_PNP, "SetGlobalCursorLevel %x", iCursorLevel);

    if (grpdeskRitInput) {
        for (pdesk = grpdeskRitInput->rpwinstaParent->rpdeskList;
                pdesk != NULL; pdesk = pdesk->rpdeskNext) {

            pHead = &pdesk->PtiList;
            for (pEntry = pHead->Flink; pEntry != pHead; pEntry = pEntry->Flink) {
                pti = CONTAINING_RECORD(pEntry, THREADINFO, PtiLink);

                pti->iCursorLevel = iCursorLevel;
                pti->pq->iCursorLevel = iCursorLevel;
            }
        }
    }

    /*
     * CSRSS doesn't seem to be on the list, so fix it up now.
     */
    for (pti = PpiFromProcess(gpepCSRSS)->ptiList;
            pti != NULL; pti = pti->ptiSibling) {
        if (pti->iCursorLevel != iCursorLevel) {
            TAGMSG3(DBGTAG_PNP, "pti %#p has cursorlevel %x, should be %x",
                    pti, pti->iCursorLevel, iCursorLevel);
        }
        if (pti->pq->iCursorLevel != iCursorLevel) {
            TAGMSG4(DBGTAG_PNP, "pti->pq %#p->%#p has cursorlevel %x, should be %x",
                    pti, pti->pq, pti->pq->iCursorLevel, iCursorLevel);
        }
        pti->iCursorLevel = iCursorLevel;
        pti->pq->iCursorLevel = iCursorLevel;
    }
}

/***************************************************************************\
* MKShowMouseCursor
*
* If no hardware mouse is installed and MouseKeys is enabled, we need
* to fix up the system metrics, the oem information and the queue
* information.  The mouse cursor then gets displayed.
*
* Return value:
*    None.
*
* History:
*   11 Feb 93 GregoryW   Created.
\***************************************************************************/
VOID MKShowMouseCursor()
{
    TAGMSG1(DBGTAG_PNP, "MKShowMouseCursor (gpDeviceInfoList == %#p)", gpDeviceInfoList);

    //
    // If TEST_GTERMF(GTERMF_MOUSE) is TRUE then we either have a hardware mouse
    // or we're already pretending a mouse is installed.  In either case,
    // there's nothing to do so just return.
    //
    if (TEST_GTERMF(GTERMF_MOUSE)) {
        TAGMSG0(DBGTAG_PNP, "MKShowMouseCursor just returns");
        return;
    }

    SET_GTERMF(GTERMF_MOUSE);
    SET_ACCF(ACCF_MKVIRTUALMOUSE);
    SYSMET(MOUSEPRESENT) = TRUE;
    SYSMET(CMOUSEBUTTONS) = 2;
    /*
     * HACK: CreateQueue() uses oemInfo.fMouse to determine if a mouse is
     * present and thus whether to set the iCursorLevel field in the
     * THREADINFO structure to 0 or -1.  Unfortunately some queues have
     * already been created at this point.  Since oemInfo.fMouse is
     * initialized to FALSE, we need to go back through any queues already
     * around and set their iCursorLevel field to the correct value when
     * mousekeys is enabled.
     */
    SetGlobalCursorLevel(0);
}

/***************************************************************************\
* MKHideMouseCursor
*
* If no hardware mouse is installed and MouseKeys is disabled, we need
* to fix up the system metrics, the oem information and the queue
* information.  The mouse cursor then disappears.
*
* Return value:
*    None.
*
* History:
*   11 Feb 93 GregoryW   Created.
\***************************************************************************/
VOID MKHideMouseCursor()
{
    TAGMSG1(DBGTAG_PNP, "MKHideMouseCursor (gpDeviceInfoList == %#p)", gpDeviceInfoList);

    //
    // If a hardware mouse is present we don't need to do anything.
    //
    if (!TEST_ACCF(ACCF_MKVIRTUALMOUSE)) {
        return;
    }

    CLEAR_ACCF(ACCF_MKVIRTUALMOUSE);
    CLEAR_GTERMF(GTERMF_MOUSE);
    SYSMET(MOUSEPRESENT) = FALSE;
    SYSMET(CMOUSEBUTTONS) = 0;

    SetGlobalCursorLevel(-1);
}

/***************************************************************************\
* xxxMKToggleMouseKeys
*
* This routine is called when the NumLock key is pressed and MouseKeys is
* active.  If the left shift key and the left alt key are down then MouseKeys
* is turned off.  If just the NumLock key is pressed then we toggle between
* MouseKeys active and the state of the number pad before MouseKeys was
* activated.
*
* Return value:
*    TRUE  - key should be passed on in the input stream.
*    FALSE - key should not be passed on.
*
* History:
\***************************************************************************/
BOOL xxxMKToggleMouseKeys(USHORT NotUsed)
{
    BOOL bRetVal = TRUE;
    BOOL bNewPassThrough;
    PTERMINAL pTerm = grpdeskRitInput->rpwinstaParent->pTerm;


    //
    // If this is a typematic repeat of NumLock we just pass it on.
    //
    if (TEST_ACCF(ACCF_MKREPEATVK)) {
        return bRetVal;
    }
    //
    // This is a make of NumLock.  Check for disable sequence.
    //
    if ((gLockBits | gLatchBits | gPhysModifierState) == MOUSEKEYMODBITS) {
        if (TEST_ACCESSFLAG(MouseKeys, MKF_HOTKEYACTIVE)) {
            if (!gbMKMouseMode) {
               //
               // User wants to turn MouseKeys off.  If we're currently in
               // pass through mode then the NumLock key is in the same state
               // (on or off) as it was when the user invoked MouseKeys.  We
               // want to leave it in that state, so don't pass the NumLock
               // key on.
               //
               bRetVal = FALSE;
            }
            TurnOffMouseKeys();
        }
        return bRetVal;
    }
    /*
     * This is a NumLock with no modifiers.  Toggle current state and
     * provide audible feedback.
     *
     * Note -- this test is the reverse of other ones because it tests the
     * state of VK_NUMLOCK before the keypress flips the state of NUMLOCK.
     * So the code checks for what the state will be.
     */
    bNewPassThrough =
#ifdef FE_SB // MouseKeys()
        (TestAsyncKeyStateToggle(gNumLockVk) != 0) ^
#else  // FE_SB
        (TestAsyncKeyStateToggle(VK_NUMLOCK) != 0) ^
#endif // FE_SB
             (TEST_ACCESSFLAG(MouseKeys, MKF_REPLACENUMBERS) != 0);


    if (!bNewPassThrough) {
        gbMKMouseMode = TRUE;
        PostRitSound(
              pTerm,
              RITSOUND_HIGHBEEP);
    } else {
        WORD SaveCurrentActiveButton;
        //
        // User wants keys to be passed on.  Release all buttons currently
        // down.
        //
        gbMKMouseMode = FALSE;
        PostRitSound(
              pTerm,
              RITSOUND_LOWBEEP);
        SaveCurrentActiveButton = gwMKCurrentButton;
        gwMKCurrentButton = MOUSE_BUTTON_LEFT | MOUSE_BUTTON_RIGHT;
        xxxMKButtonSetState(TRUE);
        gwMKCurrentButton = SaveCurrentActiveButton;
    }

    PostAccessibility( ACCESS_MOUSEKEYS );

    return bRetVal;


    DBG_UNREFERENCED_PARAMETER(NotUsed);
}

/***************************************************************************\
* xxxMKButtonClick
*
* Click the active mouse button.
*
* Return value:
*    Always FALSE - key should not be passed on.
*
* History:
\***************************************************************************/
BOOL xxxMKButtonClick(USHORT NotUsed)
{
    //
    // The button click only happens on initial make of key.  If this is a
    // typematic repeat we just ignore it.
    //
    if (TEST_ACCF(ACCF_MKREPEATVK)) {
        return FALSE;
    }
    //
    // Ensure active button is UP before the click
    //
    xxxMKButtonSetState(TRUE);
    //
    // Now push the button DOWN
    //
    xxxMKButtonSetState(FALSE);
    //
    // Now release the button
    //
    xxxMKButtonSetState(TRUE);

    return FALSE;


    UNREFERENCED_PARAMETER(NotUsed);
}


/***************************************************************************\
* xxxMKMoveConstCursorTimer
*
* Timer routine that handles constant speed mouse movement.  This routine
* is called 20 times per second and uses information from
* gMouseCursor.bConstantTable[] to determine how many pixels to move the
* mouse cursor on each tick.
*
* Return value:
*    None.
*
* History:
\***************************************************************************/
VOID xxxMKMoveConstCursorTimer(PWND pwnd, UINT message, UINT_PTR nID, LPARAM lParam)
{
    LONG  MovePixels;

    CheckCritIn();

    if (TEST_ACCESSFLAG(MouseKeys, MKF_MODIFIERS)) {
        if ((gLockBits | gLatchBits | gPhysModifierState) & LRSHIFT) {
            MovePixels = 1;
            goto MoveIt;
        }
        if ((gLockBits | gLatchBits | gPhysModifierState) & LRCONTROL) {
            MovePixels = gMouseCursor.bConstantTable[0] * MK_CONTROL_SPEED;
            goto MoveIt;
        }
    }

    giMouseMoveTable %= gMouseCursor.bConstantTableLen;

    MovePixels = gMouseCursor.bConstantTable[giMouseMoveTable++];

    if (MovePixels == 0) {
        return;
    }

MoveIt:
    //
    // We're inside the critical section - leave before calling MoveEvent.
    // Set gbMouseMoved to TRUE so RawInputThread wakes up the appropriate
    // user thread (if any) to receive this event.
    //
    LeaveCrit();

    xxxMoveEvent(MovePixels * gMKDeltaX, MovePixels * gMKDeltaY, 0, 0,
#ifdef GENERIC_INPUT
                 NULL,
                 NULL,
#endif
                0, FALSE);
    QueueMouseEvent(0, 0, 0, gptCursorAsync, NtGetTickCount(),
#ifdef GENERIC_INPUT
                    /*
                     * There's no real mouse related to this mouse message.
                     */
                    NULL,
                    NULL,
#endif
                    FALSE, TRUE);
    EnterCrit();
    return;


    UNREFERENCED_PARAMETER(pwnd);
    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(nID);
    UNREFERENCED_PARAMETER(message);
}

/***************************************************************************\
* xxxMKMoveAccelCursorTimer
*
* Timer routine that handles mouse acceleration.  It gets called 20 times
* per second and uses information from gMouseCursor.bAccelTable[] to determine
* how many pixels to move the mouse cursor on each tick.
*
* Return value:
*    None.
*
* History:
\***************************************************************************/
VOID xxxMKMoveAccelCursorTimer(PWND pwnd, UINT message, UINT_PTR nID, LPARAM lParam)
{
    LONG  MovePixels;

    CheckCritIn();

    if (TEST_ACCESSFLAG(MouseKeys, MKF_MODIFIERS)) {
        if ((gLockBits | gLatchBits | gPhysModifierState) & LRSHIFT) {
            MovePixels = 1;
            goto MoveIt;
        }
        if ((gLockBits | gLatchBits | gPhysModifierState) & LRCONTROL) {
            MovePixels = gMouseCursor.bConstantTable[0] * MK_CONTROL_SPEED;
            goto MoveIt;
        }
    }

    if (giMouseMoveTable < gMouseCursor.bAccelTableLen) {
        MovePixels = gMouseCursor.bAccelTable[giMouseMoveTable++];
    } else {
        //
        // We've reached maximum cruising speed.  Switch to constant table.
        //
        MovePixels = gMouseCursor.bConstantTable[0];
        giMouseMoveTable = 1;
        gtmridMKMoveCursor = InternalSetTimer(
                                        NULL,
                                        gtmridMKMoveCursor,
                                        MOUSETIMERRATE,
                                        xxxMKMoveConstCursorTimer,
                                        TMRF_RIT
                                        );

    }
    if (MovePixels == 0) {
        return;
    }

MoveIt:
    //
    // We're inside the critical section - leave before calling xxxMoveEvent.
    // Set gbMouseMoved to TRUE so RawInputThread wakes up the appropriate
    // user thread (if any) to receive this event.
    //
    LeaveCrit();
    xxxMoveEvent(MovePixels * gMKDeltaX, MovePixels * gMKDeltaY, 0, 0,
#ifdef GENERIC_INPUT
                 NULL,
                 NULL,
#endif
                 0, FALSE);
    QueueMouseEvent(0, 0, 0, gptCursorAsync, NtGetTickCount(),
#ifdef GENERIC_INPUT
                    NULL,
                    NULL,
#endif
                    FALSE, TRUE);

    EnterCrit();

    return;

    UNREFERENCED_PARAMETER(pwnd);
    UNREFERENCED_PARAMETER(message);
    UNREFERENCED_PARAMETER(nID);
    UNREFERENCED_PARAMETER(lParam);
}

/***************************************************************************\
* xxxMKMouseMove
*
* Send a mouse move event.  A timer routine is set to handle the mouse
* cursor acceleration.  The timer will be set on the first make of a
* mouse move key if FilterKeys repeat rate is OFF.  Otherwise, the timer
* is set on the first repeat (typematic make) of the mouse move key.
* Once the timer is set the timer routine handles all mouse movement
* until the key is released or a new key is pressed.
*
* Return value:
*    Always FALSE - key should not be passed on.
*
* History:
\***************************************************************************/
BOOL xxxMKMouseMove(USHORT Data)
{


    /*
     * Let the mouse acceleration timer routine handle repeats.
     */
    if (TEST_ACCF(ACCF_MKREPEATVK) && (gtmridMKMoveCursor != 0)) {
        return FALSE;
    }


    gMKDeltaX = (LONG)((CHAR)LOBYTE(Data));   // Force sign extension
    gMKDeltaY = (LONG)((CHAR)HIBYTE(Data));   // Force sign extension

    LeaveCrit();

    if ((TEST_ACCESSFLAG(MouseKeys, MKF_MODIFIERS) && ((gLockBits | gLatchBits | gPhysModifierState) & LRCONTROL))) {
        xxxMoveEvent(gMKDeltaX * MK_CONTROL_SPEED * gMouseCursor.bConstantTable[0], gMKDeltaY * MK_CONTROL_SPEED * gMouseCursor.bConstantTable[0], 0, 0,
#ifdef GENERIC_INPUT
                     NULL,
                     NULL,
#endif
                     0, FALSE);
    } else {
        xxxMoveEvent(gMKDeltaX, gMKDeltaY, 0, 0,
#ifdef GENERIC_INPUT
                     NULL,
                     NULL,
#endif
                     0, FALSE);
    }

    QueueMouseEvent(0, 0, 0, gptCursorAsync, NtGetTickCount(),
#ifdef GENERIC_INPUT
                    NULL,
                    NULL,
#endif
                    FALSE, TRUE);

    EnterCrit();

    /*
     * If the repeat rate is zero we'll start the mouse acceleration
     * immediately.  Otherwise we wait until after the first repeat
     * of the mouse movement key.
     */
    if (!gFilterKeys.iRepeatMSec || TEST_ACCF(ACCF_MKREPEATVK)) {
        giMouseMoveTable = 0;
        gtmridMKMoveCursor = InternalSetTimer(
                                        NULL,
                                        gtmridMKMoveCursor,
                                        MOUSETIMERRATE,
                                        (gMouseCursor.bAccelTableLen) ?
                                            xxxMKMoveAccelCursorTimer :
                                            xxxMKMoveConstCursorTimer,
                                        TMRF_RIT
                                        );
    }
    return FALSE;
}

/***************************************************************************\
* xxxMKButtonSetState
*
* Set the active mouse button(s) to the state specified by fButtonUp
* (if fButtonUp is TRUE then the button is released, o.w. the button
*  is pressed).
*
* Return value:
*    Always FALSE - key should not be passed on.
*
* History:
\***************************************************************************/
BOOL xxxMKButtonSetState(USHORT fButtonUp)
{
    WORD NewButtonState;

    CheckCritIn();
    if (fButtonUp) {
        NewButtonState = gwMKButtonState & ~gwMKCurrentButton;
    } else {
        NewButtonState = gwMKButtonState | gwMKCurrentButton;
    }

    if ((NewButtonState & MOUSE_BUTTON_LEFT) != (gwMKButtonState & MOUSE_BUTTON_LEFT)) {
        xxxButtonEvent(MOUSE_BUTTON_LEFT,
                       gptCursorAsync,
                       fButtonUp,
                       NtGetTickCount(),
                       0L,
#ifdef GENERIC_INPUT
                       NULL,
                       NULL,
#endif
                       FALSE,
                       FALSE);
    }
    if ((NewButtonState & MOUSE_BUTTON_RIGHT) != (gwMKButtonState & MOUSE_BUTTON_RIGHT)) {
        xxxButtonEvent(MOUSE_BUTTON_RIGHT,
                       gptCursorAsync,
                       fButtonUp,
                       NtGetTickCount(),
                       0L,
#ifdef GENERIC_INPUT
                       NULL,
                       NULL,
#endif
                       FALSE,
                       FALSE);
    }
    gwMKButtonState = NewButtonState;

    PostAccessibility( ACCESS_MOUSEKEYS );

    return FALSE;
}

/***************************************************************************\
* MKButtonSelect
*
* Mark ThisButton as the active mouse button.  It's possible to select both
* the left and right mouse buttons as active simultaneously.
*
* Return value:
*    Always FALSE - key should not be passed on.
*
* History:
\***************************************************************************/
BOOL MKButtonSelect(WORD ThisButton)
{
    gwMKCurrentButton = ThisButton;

    PostAccessibility( ACCESS_MOUSEKEYS );
    return FALSE;
}

/***************************************************************************\
* xxxMKButtonDoubleClick
*
* Double click the active mouse button.
*
* Return value:
*    Always FALSE - key should not be passed on.
*
* History:
\***************************************************************************/
BOOL xxxMKButtonDoubleClick(USHORT NotUsed)
{
    xxxMKButtonClick(0);
    xxxMKButtonClick(0);
    return FALSE;

    UNREFERENCED_PARAMETER(NotUsed);
}

BOOL HighContrastHotKey(PKE pKeyEvent, ULONG ExtraInformation, int NotUsed) {
    int CurrentModState;
    int fBreak;
    BYTE Vk;


    CheckCritIn();

    Vk = (BYTE)(pKeyEvent->usFlaggedVk & 0xff);
    fBreak = pKeyEvent->usFlaggedVk & KBDBREAK;
    CurrentModState = gLockBits | gLatchBits | gPhysModifierState;

    if (!TEST_ACCESSFLAG(HighContrast, HCF_HIGHCONTRASTON)) {
        if (TEST_ACCESSFLAG(HighContrast, HCF_HOTKEYACTIVE) && Vk == VK_SNAPSHOT && !fBreak && CurrentModState == MOUSEKEYMODBITS) {

            if (TEST_ACCESSFLAG(HighContrast, MKF_HOTKEYSOUND)) {
                PTERMINAL pTerm = grpdeskRitInput->rpwinstaParent->pTerm;
                PostRitSound(
                    pTerm,
                    RITSOUND_UPSIREN);
            }

            PostAccessNotification(ACCESS_HIGHCONTRAST);

            return FALSE;
        }
    } else {
        if (TEST_ACCESSFLAG(HighContrast, HCF_HOTKEYACTIVE) && Vk == VK_SNAPSHOT && !fBreak && CurrentModState == MOUSEKEYMODBITS) {

            CLEAR_ACCESSFLAG(HighContrast, HCF_HIGHCONTRASTON);

                        if (TEST_ACCESSFLAG(HighContrast, MKF_HOTKEYSOUND)) {
                PTERMINAL pTerm = grpdeskRitInput->rpwinstaParent->pTerm;
                PostRitSound(
                    pTerm,
                    RITSOUND_DOWNSIREN);
            }

            if (gspwndLogonNotify != NULL) {

            _PostMessage(gspwndLogonNotify, WM_LOGONNOTIFY,
                         LOGON_ACCESSNOTIFY, ACCESS_HIGHCONTRASTOFF);
            }
        }
    }
    return TRUE;  // send key event to next accessibility routine.
    UNREFERENCED_PARAMETER(NotUsed);
    UNREFERENCED_PARAMETER(ExtraInformation);
}


/***************************************************************************\
* MouseKeys
*
* This is the strategy routine that gets called as part of the input stream
* processing.  MouseKeys enabling/disabling is handled here.  All MouseKeys
* helper routines are called from this routine.
*
* Return value:
*    TRUE  - key event should be passed on to the next access routine.
*    FALSE - key event was processed and should not be passed on.
*
* History:
\***************************************************************************/
BOOL MouseKeys(PKE pKeyEvent, ULONG ExtraInformation, int NotUsed)
{
    int CurrentModState;
    int fBreak;
    BYTE Vk;
    USHORT FlaggedVk;
    int i;

    CheckCritIn();
    Vk = (BYTE)(pKeyEvent->usFlaggedVk & 0xff);
    fBreak = pKeyEvent->usFlaggedVk & KBDBREAK;
    CurrentModState = gLockBits | gLatchBits | gPhysModifierState;

    if (!TEST_ACCESSFLAG(MouseKeys, MKF_MOUSEKEYSON)) {
        //
        // MouseKeys currently disabled.  Check for enabling sequence:
        //   left Shift + left Alt + Num Lock.
        //
#ifdef FE_SB // MouseKeys()
        if (TEST_ACCESSFLAG(MouseKeys, MKF_HOTKEYACTIVE) && Vk == gNumLockVk && !fBreak && CurrentModState == MOUSEKEYMODBITS) {
#else  // FE_SB
        if (TEST_ACCESSFLAG(MouseKeys, MKF_HOTKEYACTIVE) && Vk == VK_NUMLOCK && !fBreak && CurrentModState == MOUSEKEYMODBITS) {
#endif // FE_SB
            gMKPreviousVk = Vk;
            if (TEST_ACCESSFLAG(MouseKeys, MKF_HOTKEYSOUND)) {
                PTERMINAL pTerm = grpdeskRitInput->rpwinstaParent->pTerm;
                PostRitSound(
                    pTerm,
                    RITSOUND_UPSIREN);
            }
            PostAccessNotification(ACCESS_MOUSEKEYS);

            return FALSE;
        }
    } else {
        //
        // Is this a MouseKey key?
        //
        //
        FlaggedVk = Vk | (pKeyEvent->usFlaggedVk & KBDEXT);
        for (i = 0; i < cMouseVKeys; i++) {
#ifdef FE_SB // MouseKeys()
            if (FlaggedVk == gpusMouseVKey[i]) {
#else  // FE_SB
            if (FlaggedVk == ausMouseVKey[i]) {
#endif // FE_SB
                break;
            }
        }

        if (i == cMouseVKeys) {
            return TRUE;          // not a mousekey
        }
        //
        // Check to see if we should pass on key events until Num Lock is
        // entered.
        //

        if (!gbMKMouseMode) {
#ifdef FE_SB // MouseKeys()
            if (Vk != gNumLockVk) {
#else  // FE_SB
            if (Vk != VK_NUMLOCK) {
#endif // FE_SB
                return TRUE;
            }
        }

        //
        // Check for Ctrl-Alt-Numpad Del.  Pass key event on if sequence
        // detected.
        //
        if (Vk == VK_DELETE && CurrentModState & LRALT && CurrentModState & LRCONTROL) {
            return TRUE;
        }
        if (fBreak) {
            //
            // If this is a break of the key that we're accelerating then
            // kill the timer.
            //
            if (gMKPreviousVk == Vk) {
                if (gtmridMKMoveCursor != 0) {
                    KILLRITTIMER(NULL, gtmridMKMoveCursor);
                    gtmridMKMoveCursor = 0;
                }
                CLEAR_ACCF(ACCF_MKREPEATVK);
                gMKPreviousVk = 0;
            }
            //
            // Pass break of Numlock along.  Other mousekeys stop here.
            //
#ifdef FE_SB // MouseKeys()
            if (Vk == gNumLockVk) {
#else  // FE_SB
            if (Vk == VK_NUMLOCK) {
#endif // FE_SB
                return TRUE;
            } else {
                return FALSE;
            }
        } else {
            SET_OR_CLEAR_ACCF(ACCF_MKREPEATVK,
                              (gMKPreviousVk == Vk));
            //
            // If this is not a typematic repeat, kill the mouse acceleration
            // timer.
            //
            if ((!TEST_ACCF(ACCF_MKREPEATVK)) && (gtmridMKMoveCursor)) {
                KILLRITTIMER(NULL, gtmridMKMoveCursor);
                gtmridMKMoveCursor = 0;
            }
            gMKPreviousVk = Vk;
        }
        return aMouseKeyEvent[i](ausMouseKeyData[i]);
    }
    return TRUE;

    UNREFERENCED_PARAMETER(NotUsed);
    UNREFERENCED_PARAMETER(ExtraInformation);

}

/***************************************************************************\
* TurnOffMouseKeys
*
* Return value:
*    None.
*
* History:
*   11 Feb 93 GregoryW   Created.
\***************************************************************************/
VOID TurnOffMouseKeys(VOID)
{
    CLEAR_ACCESSFLAG(MouseKeys, MKF_MOUSEKEYSON);
//    gMKPassThrough = 0;
    CLEAR_ACCF(ACCF_MKREPEATVK);
    MKHideMouseCursor();
    if (TEST_ACCESSFLAG(MouseKeys, MKF_HOTKEYSOUND)) {
        PostRitSound(
            grpdeskRitInput->rpwinstaParent->pTerm,
            RITSOUND_DOWNSIREN);
    }
    PostAccessibility( ACCESS_MOUSEKEYS );
}


/*
 * Let's assert at the compile time if those values are
 * defined unexpectedly.
 */
#if (MAXSPEED_MIN >= MAXSPEED_MAX) || (MAXSPEED_MIN <= 0) || (TIMETOMAXSPEED_MIN >= TIMETOMAXSPEED_MAX) || (TIMETOMAXSPEED_MIN <= 0)
#error The mousekey min/max values are not as expected.
#endif

/***************************************************************************\
* CalculateMouseTable
*
* Set mouse table based on time to max speed and max speed.  This routine
* is called during user logon (after the registry entries for the access
* features are read).
*
* Return value:
*    None.
*
* History:
*    Taken from access utility.
*
****************************************************************************/

VOID CalculateMouseTable(VOID)
{
    long    Total_Distance;         /* in 1000th of pixel */

    long    Accel_Per_Tick;         /* in 1000th of pixel/tick */
    long    Current_Speed;          /* in 1000th of pixel/tick */
    long    Max_Speed;              /* in 1000th of pixel/tick */
    long    Real_Total_Distance;    /* in pixels */
    long    Real_Delta_Distance;    /* in pixels */
    int     i;
    int     Num_Constant_Table,Num_Accel_Table;

    UserAssert(gMouseKeys.iMaxSpeed >= MAXSPEED_MIN && gMouseKeys.iMaxSpeed <= MAXSPEED_MAX);
    UserAssert(gMouseKeys.iTimeToMaxSpeed >= TIMETOMAXSPEED_MIN && gMouseKeys.iTimeToMaxSpeed <= TIMETOMAXSPEED_MAX);
    UserAssert(gMouseKeys.iTimeToMaxSpeed != 0);

    Max_Speed = gMouseKeys.iMaxSpeed;
    Max_Speed *= 1000 / MOUSETICKS;

    Accel_Per_Tick = Max_Speed * 1000 / (gMouseKeys.iTimeToMaxSpeed * MOUSETICKS);
    Current_Speed = 0;
    Total_Distance = 0;
    Real_Total_Distance = 0;
    Num_Constant_Table = 0;
    Num_Accel_Table = 0;

    for(i=0; i<= 255; i++) {
        Current_Speed = Current_Speed + Accel_Per_Tick;
        if (Current_Speed > Max_Speed) {
            Current_Speed = Max_Speed;
        }
        Total_Distance += Current_Speed;

        //
        // Calculate how many pixels to move on this tick
        //
        Real_Delta_Distance = ((Total_Distance - (Real_Total_Distance * 1000)) + 500) / 1000 ;
        //
        // Calculate total distance moved up to this point
        //
        Real_Total_Distance = Real_Total_Distance + Real_Delta_Distance;

        if ((Current_Speed < Max_Speed) && (Num_Accel_Table < 128)) {
            gMouseCursor.bAccelTable[Num_Accel_Table++] = (BYTE)Real_Delta_Distance;
        }

        if ((Current_Speed == Max_Speed) && (Num_Constant_Table < 128)) {
            gMouseCursor.bConstantTable[Num_Constant_Table++] = (BYTE)Real_Delta_Distance;
        }

    }
    gMouseCursor.bAccelTableLen = (BYTE)Num_Accel_Table;
    gMouseCursor.bConstantTableLen = (BYTE)Num_Constant_Table;
}


/***************************************************************************\
* xxxToggleKeysTimer
*
* Enable ToggleKeys if it is currently disabled.  Disable ToggleKeys if it
* is currently enabled.
*
* This routine is called only when the NumLock key is held down for 5 seconds.
*
* Return value:
*    0
*
* History:
*   11 Feb 93 GregoryW   Created.
\***************************************************************************/
VOID xxxToggleKeysTimer(PWND pwnd, UINT message, UINT_PTR nID, LPARAM lParam)
{
    KE ToggleKeyEvent;
    PTERMINAL pTerm = grpdeskRitInput->rpwinstaParent->pTerm;

    CheckCritIn();
    //
    // Toggle ToggleKeys and provide audible feedback if appropriate.
    //
    if (TEST_ACCESSFLAG(ToggleKeys, TKF_TOGGLEKEYSON)) {
        CLEAR_ACCESSFLAG(ToggleKeys, TKF_TOGGLEKEYSON);
        if (TEST_ACCESSFLAG(ToggleKeys, TKF_HOTKEYSOUND)) {
            PostRitSound(
                    pTerm,
                    RITSOUND_DOWNSIREN);
        }
    } else {
        if (TEST_ACCESSFLAG(ToggleKeys, TKF_HOTKEYSOUND)) {
            PostRitSound(
                    pTerm,
                    RITSOUND_UPSIREN);
        }

        PostAccessNotification(ACCESS_TOGGLEKEYS);
    }
    //
    // Send a fake break/make combination so state of numlock key remains
    // the same as it was before user pressed it to activate/deactivate
    // ToggleKeys.
    //
    ToggleKeyEvent.bScanCode = gTKScanCode;
#ifdef FE_SB // ToggleKeysTimer()
    ToggleKeyEvent.usFlaggedVk = gNumLockVk | KBDBREAK;
#else
    ToggleKeyEvent.usFlaggedVk = VK_NUMLOCK | KBDBREAK;
#endif // FE_SB
    if (AccessProceduresStream(&ToggleKeyEvent, gTKExtraInformation, gTKNextProcIndex)) {
        xxxProcessKeyEvent(&ToggleKeyEvent, gTKExtraInformation, FALSE);
    }
#ifdef FE_SB // ToggleKeysTimer()
    ToggleKeyEvent.usFlaggedVk = gNumLockVk;
#else
    ToggleKeyEvent.usFlaggedVk = VK_NUMLOCK;
#endif // FE_SB
    if (AccessProceduresStream(&ToggleKeyEvent, gTKExtraInformation, gTKNextProcIndex)) {
        xxxProcessKeyEvent(&ToggleKeyEvent, gTKExtraInformation, FALSE);
    }
    return;

    UNREFERENCED_PARAMETER(pwnd);
    UNREFERENCED_PARAMETER(message);
    UNREFERENCED_PARAMETER(nID);
    UNREFERENCED_PARAMETER(lParam);
}


/***************************************************************************\
* ToggleKeys
*
* This is the strategy routine that gets called as part of the input stream
* processing.  Keys of interest are Num Lock, Scroll Lock and Caps Lock.
*
* Return value:
*    TRUE - key event should be passed on to the next access routine.
*    FALSE - key event was processed and should not be passed on.
*
* History:
\***************************************************************************/
BOOL ToggleKeys(PKE pKeyEvent, ULONG ExtraInformation, int NextProcIndex)
{
    int fBreak;
    BYTE Vk;

    CheckCritIn();
    Vk = (BYTE)pKeyEvent->usFlaggedVk;
    fBreak = pKeyEvent->usFlaggedVk & KBDBREAK;

    //
    // Check for Numlock key.  On the first make set the ToggleKeys timer.
    // The timer is killed on the break of the Numlock key.
    //
    switch (Vk) {
    case VK_NUMLOCK:
#ifdef FE_SB // ToggleKeys()
NumLockProc:
#endif // FE_SB
        /*
         * Don't handle NUMLOCK toggles if the user is doing MouseKey
         * toggling.
         */
        if ((gLockBits | gLatchBits | gPhysModifierState) == MOUSEKEYMODBITS &&
                TEST_ACCESSFLAG(MouseKeys, MKF_HOTKEYACTIVE)) {
            break;
        }
        if (fBreak)
        {
            //
            // Only reset gptmrToggleKeys on the break of NumLock. This
            // prevents cycling the toggle keys state by continually
            // holding down the NumLock key.
            //
            KILLRITTIMER(NULL, gtmridToggleKeys);
            gtmridToggleKeys = 0;
            gTKExtraInformation = 0;
            gTKScanCode = 0;
        }
        else
        {
            if (gtmridToggleKeys == 0 &&
                TEST_ACCESSFLAG(ToggleKeys, TKF_HOTKEYACTIVE))
            {

                //
                // Remember key information to be used by timer routine.
                //
                gTKExtraInformation = ExtraInformation;
                gTKScanCode = pKeyEvent->bScanCode;
                gTKNextProcIndex = NextProcIndex;
                gtmridToggleKeys = InternalSetTimer(
                                              NULL,
                                              0,
                                              TOGGLEKEYTOGGLETIME,
                                              xxxToggleKeysTimer,
                                              TMRF_RIT | TMRF_ONESHOT
                                              );
            }
        }
        //
        // If MouseKeys is on, audible feedback has already occurred for this
        // keystroke.  Skip the rest of the processing.
        //
        if (TEST_ACCESSFLAG(MouseKeys, MKF_MOUSEKEYSON)) {
            break;
        }
        // fall through

    case VK_SCROLL:
    case VK_CAPITAL:
#ifdef FE_SB // ToggleKeys()
CapitalProc:
#endif // FE_SB
        if (TEST_ACCESSFLAG(ToggleKeys, TKF_TOGGLEKEYSON) && !fBreak) {
            if (!TestAsyncKeyStateDown(Vk)) {
                PTERMINAL pTerm = grpdeskRitInput->rpwinstaParent->pTerm;
                if (!TestAsyncKeyStateToggle(Vk)) {
                    PostRitSound(
                        pTerm,
                        RITSOUND_HIGHBEEP);
                } else {
                    PostRitSound(
                        pTerm,
                        RITSOUND_LOWBEEP);
                }
            }
        }
        break;

    default:
#ifdef FE_SB // ToggleKeys()
        if (Vk == gNumLockVk) goto NumLockProc;
        if (Vk == gOemScrollVk) goto CapitalProc;
#endif // FE_SB
        if (gtmridToggleKeys != 0) {
            KILLRITTIMER(NULL, gtmridToggleKeys);
        }
    }

    return TRUE;
}


/***************************************************************************\
* AccessTimeOutTimer
*
* This routine is called if no keyboard activity takes place for the
* user configured amount of time.  All access related functions are
* disabled.
*
* This routine is called with the critical section already locked.
*
* Return value:
*    0
*
* History:
\***************************************************************************/
VOID xxxAccessTimeOutTimer(PWND pwnd, UINT message, UINT_PTR nID, LPARAM lParam)
{
    CheckCritIn();
    /*
     * The timeout timer will remain on (if so configured) as long as
     * TEST_ACCF(ACCF_ACCESSENABLED) is TRUE.  This means we might get timeouts when
     * only hot keys are enabled, but no features are actually on.  Don't
     * provide any audible feedback in this case.
     */
    if (    TEST_ACCESSFLAG(FilterKeys, FKF_FILTERKEYSON)   ||
            TEST_ACCESSFLAG(StickyKeys, SKF_STICKYKEYSON)   ||
            TEST_ACCESSFLAG(MouseKeys, MKF_MOUSEKEYSON)     ||
            TEST_ACCESSFLAG(ToggleKeys, TKF_TOGGLEKEYSON)   ||
            TEST_ACCESSFLAG(SoundSentry, SSF_SOUNDSENTRYON) ||
            TEST_ACCESSFLAG(HighContrast, HCF_HIGHCONTRASTON) ||
            TEST_ACCF(ACCF_SHOWSOUNDSON)) {

        PTERMINAL pTerm = grpdeskRitInput->rpwinstaParent->pTerm;
        CLEAR_ACCESSFLAG(FilterKeys, FKF_FILTERKEYSON);
        xxxTurnOffStickyKeys();
        CLEAR_ACCESSFLAG(MouseKeys, MKF_MOUSEKEYSON);
        CLEAR_ACCESSFLAG(ToggleKeys, TKF_TOGGLEKEYSON);
        CLEAR_ACCESSFLAG(SoundSentry, SSF_SOUNDSENTRYON);
        CLEAR_ACCF(ACCF_SHOWSOUNDSON);
        CLEAR_ACCESSFLAG(HighContrast, HCF_HIGHCONTRASTON);

        if (gspwndLogonNotify != NULL) {

        _PostMessage(gspwndLogonNotify, WM_LOGONNOTIFY,
                     LOGON_ACCESSNOTIFY, ACCESS_HIGHCONTRASTOFF);
        }

        if (TEST_ACCESSFLAG(AccessTimeOut, ATF_ONOFFFEEDBACK)) {
            PostRitSound(
                    pTerm,
                    RITSOUND_DOWNSIREN);
        }
        PostAccessibility( ACCESS_MOUSEKEYS );

        PostAccessibility( ACCESS_FILTERKEYS );

        PostAccessibility( ACCESS_STICKYKEYS );

    }
    SetAccessEnabledFlag();
    return;


    UNREFERENCED_PARAMETER(pwnd);
    UNREFERENCED_PARAMETER(message);
    UNREFERENCED_PARAMETER(nID);
    UNREFERENCED_PARAMETER(lParam);
}

/***************************************************************************\
* AccessTimeOutReset
*
* This routine resets the timeout timer.
*
* Return value:
*    0
*
* History:
\***************************************************************************/
VOID AccessTimeOutReset()
{

    if (gtmridAccessTimeOut != 0) {
        KILLRITTIMER(NULL, gtmridAccessTimeOut);
    }
    if (TEST_ACCESSFLAG(AccessTimeOut, ATF_TIMEOUTON)) {
        gtmridAccessTimeOut = InternalSetTimer(
                                         NULL,
                                         0,
                                         (UINT)gAccessTimeOut.iTimeOutMSec,
                                         xxxAccessTimeOutTimer,
                                         TMRF_RIT | TMRF_ONESHOT
                                         );
    }
}

/***************************************************************************\
* xxxUpdatePerUserAccessPackSettings
*
* Sets the initial access pack features according to the user's profile.
*
* 02-14-93 GregoryW        Created.
\***************************************************************************/
VOID xxxUpdatePerUserAccessPackSettings(
    PUNICODE_STRING pProfileUserName)
{
    LUID luidCaller;
    NTSTATUS Status;
    BOOL fSystem;
    BOOL fRegFilterKeysOn;
    BOOL fRegStickyKeysOn;
    BOOL fRegMouseKeysOn;
    BOOL fRegToggleKeysOn;
    BOOL fRegTimeOutOn;
    BOOL fRegKeyboardPref;
    BOOL fRegScreenReader;
    BOOL fRegHighContrastOn;
    DWORD dwDefFlags;
    WCHAR wcHighContrastScheme[MAX_SCHEME_NAME_SIZE];

    Status = GetProcessLuid(NULL, &luidCaller);
    //
    // If we're called in the system context no one is logged on.
    // We want to read the current .DEFAULT settings for the access
    // features.  Later when we're called in the user context (e.g.,
    // someone has successfully logged on) we check to see if the
    // current access state is the same as the default setting.  If
    // not, the user has enabled/disabled one or more access features
    // from the keyboard.  These changes will be propagated across
    // the logon into the user's intial state (overriding the settings
    // in the user's profile).
    //
    if (NT_SUCCESS(Status) && RtlEqualLuid(&luidCaller, &luidSystem)) {
        fSystem = TRUE;
    } else {
        fSystem = FALSE;
    }

    FastGetProfileIntW(pProfileUserName,
                       PMAP_KEYBOARDRESPONSE,
                       TEXT("Flags"),
                       0,
                       &dwDefFlags,
                       0);

    fRegFilterKeysOn = (dwDefFlags & FKF_FILTERKEYSON) != 0;

    FastGetProfileIntW(pProfileUserName,
                       PMAP_STICKYKEYS,
                       TEXT("Flags"),
                       0,
                       &dwDefFlags,
                       0);
    fRegStickyKeysOn = (dwDefFlags & SKF_STICKYKEYSON) != 0;

    FastGetProfileIntW(pProfileUserName,
                       PMAP_MOUSEKEYS,
                       TEXT("Flags"),
                       0,
                       &dwDefFlags,
                       0);
    fRegMouseKeysOn = (dwDefFlags & MKF_MOUSEKEYSON) != 0;

    FastGetProfileIntW(pProfileUserName,
                       PMAP_TOGGLEKEYS,
                       TEXT("Flags"),
                       0,
                       &dwDefFlags,
                       0);
    fRegToggleKeysOn = (dwDefFlags & TKF_TOGGLEKEYSON) != 0;

    FastGetProfileIntW(pProfileUserName,
                       PMAP_KEYBOARDPREF,
                       TEXT("On"),
                       0,
                       &dwDefFlags,
                       0);
    fRegKeyboardPref = !!dwDefFlags;

    FastGetProfileIntW(pProfileUserName,
                       PMAP_SCREENREADER,
                       TEXT("On"),
                       0,
                       &dwDefFlags,
                       0);
    fRegScreenReader = !!dwDefFlags;

    FastGetProfileIntW(pProfileUserName,
                       PMAP_TIMEOUT,
                       TEXT("Flags"),
                       0,
                       &dwDefFlags,
                       0);
    fRegTimeOutOn = (dwDefFlags & ATF_TIMEOUTON) != 0;

    FastGetProfileIntW(pProfileUserName,
                       PMAP_HIGHCONTRAST,
                       TEXT("Flags"),
                       0,
                       &dwDefFlags,
                       0);
    fRegHighContrastOn = (dwDefFlags & HCF_HIGHCONTRASTON) != 0;

    if (fSystem) {
        //
        // We're in system mode (e.g., no one is logged in).  Remember
        // the .DEFAULT state for comparison during the next user logon
        // and set the current state to the .DEFAULT state.
        //
        if (fRegFilterKeysOn) {
            SET_ACCF(ACCF_DEFAULTFILTERKEYSON);
            SET_ACCESSFLAG(FilterKeys, FKF_FILTERKEYSON);
        } else {
            CLEAR_ACCF(ACCF_DEFAULTFILTERKEYSON);
            CLEAR_ACCESSFLAG(FilterKeys, FKF_FILTERKEYSON);
        }

        //
        // If StickyKeys is currently on and we're about to turn it
        // off we need to make sure the latch keys and lock keys are
        // released.
        //
        if (TEST_ACCESSFLAG(StickyKeys, SKF_STICKYKEYSON) && (fRegFilterKeysOn == 0)) {
                xxxTurnOffStickyKeys();
        }

        if (fRegStickyKeysOn) {
            SET_ACCF(ACCF_DEFAULTSTICKYKEYSON);
            SET_ACCESSFLAG(StickyKeys, SKF_STICKYKEYSON);
        } else {
            CLEAR_ACCF(ACCF_DEFAULTSTICKYKEYSON);
            CLEAR_ACCESSFLAG(StickyKeys, SKF_STICKYKEYSON);
        }

        if (fRegMouseKeysOn) {
            SET_ACCF(ACCF_DEFAULTMOUSEKEYSON);
            SET_ACCESSFLAG(MouseKeys, MKF_MOUSEKEYSON);
        } else {
            CLEAR_ACCF(ACCF_DEFAULTMOUSEKEYSON);
            CLEAR_ACCESSFLAG(MouseKeys, MKF_MOUSEKEYSON);
        }

        if (fRegToggleKeysOn) {
            SET_ACCF(ACCF_DEFAULTTOGGLEKEYSON);
            SET_ACCESSFLAG(ToggleKeys, TKF_TOGGLEKEYSON);
        } else {
            CLEAR_ACCF(ACCF_DEFAULTTOGGLEKEYSON);
            CLEAR_ACCESSFLAG(ToggleKeys, TKF_TOGGLEKEYSON);
        }

        if (fRegTimeOutOn) {
            SET_ACCF(ACCF_DEFAULTTIMEOUTON);
            SET_ACCESSFLAG(AccessTimeOut, ATF_TIMEOUTON);
        } else {
            CLEAR_ACCF(ACCF_DEFAULTTIMEOUTON);
            CLEAR_ACCESSFLAG(AccessTimeOut, ATF_TIMEOUTON);
        }

        if (fRegKeyboardPref) {
            SET_ACCF(ACCF_DEFAULTKEYBOARDPREF);
            SET_ACCF(ACCF_KEYBOARDPREF);
            gpsi->bKeyboardPref = TRUE;
        } else {
            CLEAR_ACCF(ACCF_DEFAULTKEYBOARDPREF);
            CLEAR_ACCF(ACCF_KEYBOARDPREF);
            gpsi->bKeyboardPref = FALSE;
        }

        if (fRegScreenReader) {
            SET_ACCF(ACCF_DEFAULTSCREENREADER);
            SET_ACCF(ACCF_SCREENREADER);
        } else {
            CLEAR_ACCF(ACCF_DEFAULTSCREENREADER);
            CLEAR_ACCF(ACCF_SCREENREADER);
        }

        if (fRegHighContrastOn) {
            SET_ACCF(ACCF_DEFAULTHIGHCONTRASTON);
            SET_ACCESSFLAG(HighContrast, HCF_HIGHCONTRASTON);
        } else {
            CLEAR_ACCF(ACCF_DEFAULTHIGHCONTRASTON);
            CLEAR_ACCESSFLAG(HighContrast, HCF_HIGHCONTRASTON);
        }
    } else {
        //
        // A user has successfully logged on.  If the current state is
        // different from the default state stored earlier then we know
        // the user has modified the state via the keyboard (at the logon
        // dialog).  This state will override whatever on/off state the
        // user has set in their profile.  If the current state is the
        // same as the default state then the on/off setting from the
        // user profile is used.
        //

        if (    TEST_BOOL_ACCESSFLAG(FilterKeys, FKF_FILTERKEYSON) ==
                TEST_BOOL_ACCF(ACCF_DEFAULTFILTERKEYSON)) {
            //
            // Current state and default state are the same.  Use the
            // user's profile setting.
            //

            SET_OR_CLEAR_ACCESSFLAG(FilterKeys, FKF_FILTERKEYSON, fRegFilterKeysOn);
        }

        if (    TEST_BOOL_ACCESSFLAG(StickyKeys, SKF_STICKYKEYSON) ==
                TEST_BOOL_ACCF(ACCF_DEFAULTSTICKYKEYSON)) {
            //
            // If StickyKeys is currently on and we're about to turn it
            // off we need to make sure the latch keys and lock keys are
            // released.
            //
            if (    TEST_ACCESSFLAG(StickyKeys, SKF_STICKYKEYSON) &&
                    (fRegStickyKeysOn == 0)) {

                xxxTurnOffStickyKeys();
            }

            SET_OR_CLEAR_ACCESSFLAG(StickyKeys, SKF_STICKYKEYSON, fRegStickyKeysOn);
        }

        if (    TEST_BOOL_ACCESSFLAG(MouseKeys, MKF_MOUSEKEYSON) ==
                TEST_BOOL_ACCF(ACCF_DEFAULTMOUSEKEYSON)) {
            //
            // Current state and default state are the same.  Use the user's
            // profile setting.
            //
            SET_OR_CLEAR_ACCESSFLAG(MouseKeys, MKF_MOUSEKEYSON, fRegMouseKeysOn);
        }

        if (    TEST_BOOL_ACCESSFLAG(ToggleKeys, TKF_TOGGLEKEYSON) ==
                TEST_BOOL_ACCF(ACCF_DEFAULTTOGGLEKEYSON)) {
            //
            // Current state and default state are the same.  Use the user's
            // profile setting.
            //
            SET_OR_CLEAR_ACCESSFLAG(ToggleKeys, TKF_TOGGLEKEYSON, fRegToggleKeysOn);
        }

        if (    TEST_BOOL_ACCESSFLAG(AccessTimeOut, ATF_TIMEOUTON) ==
                TEST_BOOL_ACCF(ACCF_DEFAULTTIMEOUTON)) {
            //
            // Current state and default state are the same.  Use the user's
            // profile setting.
            //
            SET_OR_CLEAR_ACCESSFLAG(AccessTimeOut, ATF_TIMEOUTON, fRegTimeOutOn);
        }

        if (    TEST_BOOL_ACCF(ACCF_KEYBOARDPREF) ==
                TEST_BOOL_ACCF(ACCF_DEFAULTKEYBOARDPREF)) {
            //
            // Current state and default state are the same.  Use the user's
            // profile setting.
            //
            SET_OR_CLEAR_ACCF(ACCF_KEYBOARDPREF, fRegKeyboardPref);
        }

        if (    TEST_BOOL_ACCF(ACCF_SCREENREADER) ==
                TEST_BOOL_ACCF(ACCF_DEFAULTSCREENREADER)) {
            //
            // Current state and default state are the same.  Use the user's
            // profile setting.
            //
            SET_OR_CLEAR_ACCF(ACCF_SCREENREADER, fRegScreenReader);
        }

        if (    TEST_BOOL_ACCESSFLAG(HighContrast, HCF_HIGHCONTRASTON) ==
                TEST_BOOL_ACCF(ACCF_DEFAULTHIGHCONTRASTON)) {
            //
            // Current state and default state are the same.  Use the user's
            // profile setting.
            //
            SET_OR_CLEAR_ACCESSFLAG(HighContrast, HCF_HIGHCONTRASTON, fRegHighContrastOn);
        }
    }

    //
    // Get the default FilterKeys state.
    //
    // -------- flag --------------- value --------- default ------
    // #define FKF_FILTERKEYSON    0x00000001           0
    // #define FKF_AVAILABLE       0x00000002           2
    // #define FKF_HOTKEYACTIVE    0x00000004           0
    // #define FKF_CONFIRMHOTKEY   0x00000008           0
    // #define FKF_HOTKEYSOUND     0x00000010          10
    // #define FKF_INDICATOR       0x00000020           0
    // #define FKF_CLICKON         0x00000040          40
    // ----------------------------------------- total = 0x52 = 82
    //

    FastGetProfileIntW(pProfileUserName,
                       PMAP_KEYBOARDRESPONSE,
                       TEXT("Flags"),
                       82,
                       &dwDefFlags,
                       0);

    SET_OR_CLEAR_FLAG(
            dwDefFlags,
            FKF_FILTERKEYSON,
            TEST_ACCESSFLAG(FilterKeys, FKF_FILTERKEYSON));

    gFilterKeys.dwFlags = dwDefFlags;
    FastGetProfileIntW(pProfileUserName,
                       PMAP_KEYBOARDRESPONSE,
                       TEXT("DelayBeforeAcceptance"),
                       1000,
                       &gFilterKeys.iWaitMSec,
                       0);

    FastGetProfileIntW(pProfileUserName,
                       PMAP_KEYBOARDRESPONSE,
                       TEXT("AutoRepeatRate"),
                       500,
                       &gFilterKeys.iRepeatMSec,
                       0);

    FastGetProfileIntW(pProfileUserName,
                       PMAP_KEYBOARDRESPONSE,
                       TEXT("AutoRepeatDelay"),
                       1000,
                       &gFilterKeys.iDelayMSec,
                       0);

    FastGetProfileIntW(pProfileUserName,
                       PMAP_KEYBOARDRESPONSE,
                       TEXT("BounceTime"),
                       0,
                       &gFilterKeys.iBounceMSec,
                       0);

    //
    // Fill in the SoundSentry state.  This release of the
    // accessibility features only supports iWindowsEffect.
    //
    // -------- flag --------------- value --------- default ------
    // #define SSF_SOUNDSENTRYON   0x00000001           0
    // #define SSF_AVAILABLE       0x00000002           1
    // #define SSF_INDICATOR       0x00000004           0
    // ----------------------------------------- total = 0x2 = 2
    //
    FastGetProfileIntW(pProfileUserName,
                       PMAP_SOUNDSENTRY,
                       TEXT("Flags"),
                       2,
                       &gSoundSentry.dwFlags,
                       0);

    FastGetProfileIntW(pProfileUserName,
                       PMAP_SOUNDSENTRY,
                       TEXT("FSTextEffect"),
                       0,
                       &gSoundSentry.iFSTextEffect,
                       0);

    FastGetProfileIntW(pProfileUserName,
                       PMAP_SOUNDSENTRY,
                       TEXT("WindowsEffect"),
                       0,
                       &gSoundSentry.iWindowsEffect,
                       0);

    /*
     * Set ShowSounds flag.
     */
    FastGetProfileIntW(pProfileUserName,
                       PMAP_SHOWSOUNDS,
                       TEXT("On"),
                       0,
                       &dwDefFlags,
                       0);
    SET_OR_CLEAR_ACCF(ACCF_SHOWSOUNDSON, dwDefFlags);
    /*
    * Bug 17210.  Update the System Metrics Info.
    */
    SYSMET(SHOWSOUNDS) = TEST_BOOL_ACCF(ACCF_SHOWSOUNDSON);

    //
    // Get the default StickyKeys state.
    //
    // -------- flag --------------- value --------- default ------
    // #define SKF_STICKYKEYSON    0x00000001          0
    // #define SKF_AVAILABLE       0x00000002          2
    // #define SKF_HOTKEYACTIVE    0x00000004          0
    // #define SKF_CONFIRMHOTKEY   0x00000008          0
    // #define SKF_HOTKEYSOUND     0x00000010         10
    // #define SKF_INDICATOR       0x00000020          0
    // #define SKF_AUDIBLEFEEDBACK 0x00000040         40
    // #define SKF_TRISTATE        0x00000080         80
    // #define SKF_TWOKEYSOFF      0x00000100        100
    // ----------------------------------------- total = 0x1d2 = 466
    //
    FastGetProfileIntW(pProfileUserName,
                       PMAP_STICKYKEYS,
                       TEXT("Flags"),
                       466,
                       &dwDefFlags,
                       0);

    SET_OR_CLEAR_FLAG(
            dwDefFlags,
            SKF_STICKYKEYSON,
            TEST_ACCESSFLAG(StickyKeys, SKF_STICKYKEYSON));

    gStickyKeys.dwFlags = dwDefFlags;

    //
    // Get the default MouseKeys state.
    //
    // -------- flag --------------- value --------- default ------
    // #define MKF_MOUSEKEYSON     0x00000001           0
    // #define MKF_AVAILABLE       0x00000002           2
    // #define MKF_HOTKEYACTIVE    0x00000004           0
    // #define MKF_CONFIRMHOTKEY   0x00000008           0
    // #define MKF_HOTKEYSOUND     0x00000010          10
    // #define MKF_INDICATOR       0x00000020           0
    // #define MKF_MODIFIERS       0x00000040           0
    // #define MKF_REPLACENUMBERS  0x00000080           0
    // ----------------------------------------- total = 0x12 = 18
    //
    FastGetProfileIntW(pProfileUserName,
                       PMAP_MOUSEKEYS,
                       TEXT("Flags"),
                       18,
                       &dwDefFlags,
                       0);

    SET_OR_CLEAR_FLAG(
            dwDefFlags,
            MKF_MOUSEKEYSON,
            TEST_ACCESSFLAG(MouseKeys, MKF_MOUSEKEYSON));

    gMouseKeys.dwFlags = dwDefFlags;
    FastGetProfileIntW(pProfileUserName,
                       PMAP_MOUSEKEYS,
                       TEXT("MaximumSpeed"),
                       MAXSPEED_DEF,
                       &gMouseKeys.iMaxSpeed,
                       0);

    FastGetProfileIntW(pProfileUserName,
                       PMAP_MOUSEKEYS,
                       TEXT("TimeToMaximumSpeed"),
                       TIMETOMAXSPEED_DEF,
                       &gMouseKeys.iTimeToMaxSpeed,
                       0);
 
    /*
     * Avoid unexpected values, like when the migration from previous OS has set bogus values
     * or when the registry is simply broken...
     */
    if (gMouseKeys.iMaxSpeed < MAXSPEED_MIN || gMouseKeys.iMaxSpeed > MAXSPEED_MAX) {
        gMouseKeys.iMaxSpeed = MAXSPEED_DEF;
    }
    if (gMouseKeys.iTimeToMaxSpeed < TIMETOMAXSPEED_MIN || gMouseKeys.iTimeToMaxSpeed > TIMETOMAXSPEED_MAX) {
        gMouseKeys.iTimeToMaxSpeed = TIMETOMAXSPEED_DEF;
    }

    CalculateMouseTable();

    gbMKMouseMode =
#ifdef FE_SB
            (TestAsyncKeyStateToggle(gNumLockVk) != 0) ^
#else  // FE_SB
            (TestAsyncKeyStateToggle(VK_NUMLOCK) != 0) ^
#endif // FE_SB
            (TEST_ACCESSFLAG(MouseKeys, MKF_REPLACENUMBERS) != 0);

    //
    // If the system does not have a hardware mouse:
    //    If MouseKeys is enabled show the mouse cursor,
    //    o.w. hide the mouse cursor.
    //
    if (TEST_ACCESSFLAG(MouseKeys, MKF_MOUSEKEYSON)) {
        MKShowMouseCursor();
    } else {
        MKHideMouseCursor();
    }

    //
    // Get the default ToggleKeys state.
    //
    // -------- flag --------------- value --------- default ------
    // #define TKF_TOGGLEKEYSON    0x00000001           0
    // #define TKF_AVAILABLE       0x00000002           2
    // #define TKF_HOTKEYACTIVE    0x00000004           0
    // #define TKF_CONFIRMHOTKEY   0x00000008           0
    // #define TKF_HOTKEYSOUND     0x00000010          10
    // #define TKF_INDICATOR       0x00000020           0
    // ----------------------------------------- total = 0x12 = 18
    //
    FastGetProfileIntW(pProfileUserName,
                       PMAP_TOGGLEKEYS,
                       TEXT("Flags"),
                       18,
                       &dwDefFlags,
                       0);

    SET_OR_CLEAR_FLAG(
            dwDefFlags,
            TKF_TOGGLEKEYSON,
            TEST_ACCESSFLAG(ToggleKeys, TKF_TOGGLEKEYSON));

    gToggleKeys.dwFlags = dwDefFlags;

    //
    // Get the default Timeout state.
    //
    // -------- flag --------------- value --------- default ------
    // #define ATF_TIMEOUTON       0x00000001           0
    // #define ATF_ONOFFFEEDBACK   0x00000002           2
    // ----------------------------------------- total = 0x2 = 2
    //
    FastGetProfileIntW(pProfileUserName,
                       PMAP_TIMEOUT,
                       TEXT("Flags"),
                       2,
                       &dwDefFlags,
                       0);

    SET_OR_CLEAR_FLAG(
            dwDefFlags,
            ATF_TIMEOUTON,
            TEST_ACCESSFLAG(AccessTimeOut, ATF_TIMEOUTON));

    gAccessTimeOut.dwFlags = dwDefFlags;

#ifdef FE_SB //
    if (gpKbdNlsTbl) {
        //
        // Is there any alternative MouseVKey table in KBDNLSTABLE ?
        //
        if ((gpKbdNlsTbl->NumOfMouseVKey == cMouseVKeys) &&
            (gpKbdNlsTbl->pusMouseVKey   != NULL)) {
            //
            // Overwite the pointer.
            //
            gpusMouseVKey = gpKbdNlsTbl->pusMouseVKey;
        }

        //
        // Is there any remapping flag for VK_NUMLOCK/VK_SCROLL ?
        //
        if (gpKbdNlsTbl->LayoutInformation & NLSKBD_INFO_ACCESSIBILITY_KEYMAP) {
            //
            // Overwrite default.
            //
            gNumLockVk = VK_HOME;
            gOemScrollVk = VK_KANA;
        }
    }
#endif // FE_SB

    FastGetProfileIntW(pProfileUserName,
                       PMAP_TIMEOUT,
                       TEXT("TimeToWait"),
                       300000,
                       &gAccessTimeOut.iTimeOutMSec,
                       0);  // default is 5 minutes

   /*
    * Get High Contrast state
    */

    FastGetProfileIntW(pProfileUserName,
                       PMAP_HIGHCONTRAST,
                       TEXT("Flags"),
                       HCF_AVAILABLE | HCF_HOTKEYSOUND | HCF_HOTKEYAVAILABLE,
                       &dwDefFlags,
                       0);

    SET_OR_CLEAR_FLAG(
            dwDefFlags,
            HCF_HIGHCONTRASTON,
            TEST_ACCESSFLAG(HighContrast, HCF_HIGHCONTRASTON));

    gHighContrast.dwFlags = dwDefFlags;

    /*
     * Get scheme -- set up buffer
     */

    if (FastGetProfileStringW(pProfileUserName,
            PMAP_HIGHCONTRAST,
            TEXT("High Contrast Scheme"),
            NULL,
            wcHighContrastScheme,
            MAX_SCHEME_NAME_SIZE,
            0)) {

        /*
         * copy data
         */

        wcscpy(gHighContrastDefaultScheme, wcHighContrastScheme);
    }


    AccessTimeOutReset();
    SetAccessEnabledFlag();
}


/***************************************************************************\
* SetAccessEnabledFlag
*
* Sets the global flag ACCF_ACCESSENABLED to non-zero if any accessibility
* function is on or hot key activation is enabled.  When TEST_ACCF(ACCF_ACCESSENABLED)
* is zero keyboard input is processed directly.  When TEST_ACCF(ACCF_ACCESSENABLED) is
* non-zero keyboard input is filtered through AccessProceduresStream().
* See KeyboardApcProcedure in ntinput.c.
*
* History:
* 01-19-94 GregoryW         Created.
\***************************************************************************/
VOID SetAccessEnabledFlag(VOID)
{

    SET_OR_CLEAR_ACCF(ACCF_ACCESSENABLED,
                      TEST_ACCESSFLAG(FilterKeys, FKF_FILTERKEYSON)  ||
                      TEST_ACCESSFLAG(FilterKeys, FKF_HOTKEYACTIVE)  ||
                      TEST_ACCESSFLAG(StickyKeys, SKF_STICKYKEYSON)  ||
                      TEST_ACCESSFLAG(StickyKeys, SKF_HOTKEYACTIVE)  ||
                      TEST_ACCESSFLAG(HighContrast, HCF_HOTKEYACTIVE)  ||
                      TEST_ACCESSFLAG(MouseKeys, MKF_MOUSEKEYSON)    ||
                      TEST_ACCESSFLAG(MouseKeys, MKF_HOTKEYACTIVE)   ||
                      TEST_ACCESSFLAG(ToggleKeys, TKF_TOGGLEKEYSON)  ||
                      TEST_ACCESSFLAG(ToggleKeys, TKF_HOTKEYACTIVE)  ||
                      TEST_ACCESSFLAG(SoundSentry, SSF_SOUNDSENTRYON)||
                      TEST_ACCF(ACCF_SHOWSOUNDSON));
}

VOID SoundSentryTimer(PWND pwnd, UINT message, UINT_PTR idTimer, LPARAM lParam)
{
    TL tlpwndT;
    PWND pwndSoundSentry;

    if (pwndSoundSentry = RevalidateHwnd(ghwndSoundSentry)) {
        ThreadLock(pwndSoundSentry, &tlpwndT);
        xxxFlashWindow(pwndSoundSentry,
                       (TEST_BOOL_ACCF(ACCF_FIRSTTICK) ? FLASHW_ALL : FLASHW_STOP),
                       0);
        ThreadUnlock(&tlpwndT);
    }

    if (TEST_ACCF(ACCF_FIRSTTICK)) {
        gtmridSoundSentry = InternalSetTimer(
                                       NULL,
                                       idTimer,
                                       5,
                                       SoundSentryTimer,
                                       TMRF_RIT | TMRF_ONESHOT
                                       );
        CLEAR_ACCF(ACCF_FIRSTTICK);
    } else {
        ghwndSoundSentry = NULL;
        gtmridSoundSentry = 0;
        SET_ACCF(ACCF_FIRSTTICK);
    }

    return;

    UNREFERENCED_PARAMETER(pwnd);
    UNREFERENCED_PARAMETER(message);
    UNREFERENCED_PARAMETER(lParam);
}

/***************************************************************************\
* _UserSoundSentryWorker
*
* This is the worker routine that provides the visual feedback requested
* by the user.
*
* History:
* 08-02-93 GregoryW         Created.
\***************************************************************************/
BOOL
_UserSoundSentryWorker(VOID)
{
    PWND pwndActive;
    TL tlpwndT;

    CheckCritIn();
    //
    // Check to see if SoundSentry is on.
    //
    if (!TEST_ACCESSFLAG(SoundSentry, SSF_SOUNDSENTRYON)) {
        return TRUE;
    }

    if ((gpqForeground != NULL) && (gpqForeground->spwndActive != NULL)) {
        pwndActive = gpqForeground->spwndActive;
    } else {
        return TRUE;
    }

    switch (gSoundSentry.iWindowsEffect) {

    case SSWF_NONE:
        break;

    case SSWF_TITLE:
        //
        // Flash the active caption bar.
        //
        if (gtmridSoundSentry) {
            break;
        }
        ThreadLock(pwndActive, &tlpwndT);
        xxxFlashWindow(pwndActive, FLASHW_ALL, 0);
        ThreadUnlock(&tlpwndT);

        ghwndSoundSentry = HWq(pwndActive);
        gtmridSoundSentry = InternalSetTimer(
                                       NULL,
                                       0,
                                       gpsi->dtCaretBlink,
                                       SoundSentryTimer,
                                       TMRF_RIT | TMRF_ONESHOT
                                       );
        break;

    case SSWF_WINDOW:
    {
        //
        // Flash the active window.
        //
        HDC hdc;
        RECT rc;

        hdc = _GetWindowDC(pwndActive);
        _GetWindowRect(pwndActive, &rc);
        //
        // _GetWindowRect returns screen coordinates.  First adjust them
        // to window (display) coordinates and then map them to logical
        // coordinates before calling InvertRect.
        //
        OffsetRect(&rc, -rc.left, -rc.top);
        GreDPtoLP(hdc, (LPPOINT)&rc, 2);
        InvertRect(hdc, &rc);
        InvertRect(hdc, &rc);
        _ReleaseDC(hdc);
        break;
    }

    case SSWF_DISPLAY:
    {
        //
        // Flash the entire display.
        //
        HDC hdc;
        RECT rc;

        hdc = _GetDCEx(PWNDDESKTOP(pwndActive), NULL, DCX_WINDOW | DCX_CACHE);
        rc.left = rc.top = 0;
        rc.right = SYSMET(CXVIRTUALSCREEN);
        rc.bottom = SYSMET(CYVIRTUALSCREEN);
        InvertRect(hdc, &rc);
        InvertRect(hdc, &rc);
        _ReleaseDC(hdc);
        break;
    }
    }

    return TRUE;
}

/***************************************************************************\
* UtilityManager
*
* This is the strategy routine that gets called as part of the input stream
* processing.  Utility Manager launching happens here.
*
* Return value:
*    TRUE  - key event should be passed on to the next access routine.
*    FALSE - key event was processed and should not be passed on.
*
* History: 10-28-98 a-anilk created
\***************************************************************************/
BOOL UtilityManager(PKE pKeyEvent, ULONG ExtraInformation, int NotUsed)
{
    int CurrentModState;
    int fBreak;
    BYTE Vk;


    CheckCritIn();

    Vk = (BYTE)(pKeyEvent->usFlaggedVk & 0xff);
    fBreak = pKeyEvent->usFlaggedVk & KBDBREAK;
    CurrentModState = gLockBits | gLatchBits | gPhysModifierState;

    // the hot key to launch the utility manager is WinKey + U
    if ((Vk == VK_U && !fBreak && (CurrentModState & LRWIN)) )
    {
        PostAccessNotification(ACCESS_UTILITYMANAGER);

        return FALSE;
    }
    return TRUE;  // send key event to next accessibility routine.

    UNREFERENCED_PARAMETER(NotUsed);
    UNREFERENCED_PARAMETER(ExtraInformation);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\atom.c ===
/****************************** Module Header ******************************\
* Module Name: atom.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This file contains the common code to implement atom tables.
*
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#pragma alloc_text(INIT, UserRtlCreateAtomTable)

PVOID UserAtomTableHandle;

NTSTATUS
UserRtlCreateAtomTable(
    IN ULONG NumberOfBuckets
    )
{
    NTSTATUS Status;

    if (UserAtomTableHandle == NULL) {
        Status = RtlCreateAtomTable( NumberOfBuckets, &UserAtomTableHandle );
    } else {
        RIPMSG0(RIP_VERBOSE, "UserRtlCreateAtomTable: table alread exists");
        Status = STATUS_SUCCESS;
    }

    return Status;
}


ATOM UserAddAtom(
    LPCWSTR ccxlpAtom, BOOL bPin)
{
    NTSTATUS Status;
    ATOM atom;

    UserAssert(IS_PTR(ccxlpAtom) || (ccxlpAtom == NULL));

    /*
     * Rtl routines protect accesses to strings with their
     * own try/except blocks.
     */
    atom = 0;
    Status = RtlAddAtomToAtomTable( UserAtomTableHandle,
                                    (PWSTR)ccxlpAtom,
                                    &atom
                                   );
    if (!NT_SUCCESS(Status)) {
        RIPNTERR0(Status, RIP_VERBOSE, "UserAddAtom: add failed");
    }

    if (atom && bPin)
        RtlPinAtomInAtomTable(UserAtomTableHandle,atom);

    return atom;
}

ATOM UserFindAtom(
    LPCWSTR ccxlpAtom)
{
    NTSTATUS Status;
    ATOM atom;

    /*
     * Rtl routines protect accesses to strings with their
     * own try/except blocks.
     */
    atom = 0;
    Status = RtlLookupAtomInAtomTable( UserAtomTableHandle,
                                       (PWSTR)ccxlpAtom,
                                       &atom
                                     );
    if (!NT_SUCCESS(Status)) {
        RIPNTERR0(Status, RIP_VERBOSE, "UserFindAtom: lookup failed");
    }

    return atom;
}

ATOM UserDeleteAtom(
    ATOM atom)
{
    NTSTATUS Status;

    if ((atom >= gatomFirstPinned) && (atom <= gatomLastPinned))
        return 0;      // if pinned, just return

    Status = RtlDeleteAtomFromAtomTable( UserAtomTableHandle, atom );
    if (NT_SUCCESS(Status)) {
        return 0;
    } else {
        RIPNTERR0(Status, RIP_VERBOSE, "UserDeleteAtom: delete failed");
        return atom;
    }
}

UINT UserGetAtomName(
    ATOM atom,
    LPWSTR ccxlpch,
    int cchMax)
{
    NTSTATUS Status;
    ULONG AtomNameLength;

    AtomNameLength = cchMax * sizeof(WCHAR);
    Status = RtlQueryAtomInAtomTable( UserAtomTableHandle,
                                      atom,
                                      NULL,
                                      NULL,
                                      ccxlpch,
                                      &AtomNameLength
                                    );
    if (!NT_SUCCESS(Status)) {
        RIPNTERR0(Status, RIP_VERBOSE, "UserGetAtomName: query failed");
        return 0;
    } else {
        return AtomNameLength / sizeof(WCHAR);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\caption.c ===
/****************************** Module Header ******************************\
* Module Name: caption.c (aka wmcap.c)
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* History:
* 28-Oct-1990 MikeHar   Ported functions from Win 3.0 sources.
* 01-Feb-1991 MikeKe    Added Revalidation code (None)
* 03-Jan-1992 IanJa     Neutralized (ANSI/wide-character)
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


#define MIN     0x01
#define MAX     0x02
#define NOMIN   0x04
#define NOMAX   0x08
#define NOCLOSE 0x10
#define SMCAP   0x20
#define NOSIZE  (NOMIN | NOMAX)

/***************************************************************************\
* CalcCaptionButton
*
* This calculates the location of the caption button.
\***************************************************************************/

DWORD xxxCalcCaptionButton(PWND pwnd, int iButton, LPWORD pcmd, LPRECT prcBtn, LPWORD pbm)
{
    int x, y, cBorders, cxS, cyS;

    CheckLock(pwnd);

    *pcmd = 0;

    if (TestWF(pwnd, WFMINIMIZED)) {

        x = -SYSMET(CXFIXEDFRAME);
        y = -SYSMET(CYFIXEDFRAME);

    } else {

        cBorders = GetWindowBorders(pwnd->style, pwnd->ExStyle, TRUE, FALSE);
        x = -cBorders * SYSMET(CXBORDER);
        y = -cBorders * SYSMET(CYBORDER);
    }

    CopyInflateRect(prcBtn, &pwnd->rcWindow, x, y);

    x = -pwnd->rcWindow.left;
    y = -pwnd->rcWindow.top;

    /*
     * Get real caption area:  subtract final border underneath caption
     * that separates it from everything else.
     */
    if (TestWF(pwnd, WEFTOOLWINDOW)) {
        cxS = SYSMET(CXSMSIZE);
        cyS = SYSMET(CYSMSIZE);
    } else {
        cxS = SYSMET(CXSIZE);
        cyS = SYSMET(CYSIZE);
    }

    if (iButton == INDEX_TITLEBAR_CLOSEBUTTON) {

        if (xxxMNCanClose(pwnd)) {
            *pbm  = TestWF(pwnd, WEFTOOLWINDOW) ? OBI_CLOSE_PAL : OBI_CLOSE;
            *pcmd = SC_CLOSE;
        }

    } else if (iButton == INDEX_TITLEBAR_MINBUTTON) {

        /*
         * Reduce button isn't last button, so shift left by one button
         */
        if (TestWF(pwnd, WFMINBOX)) {

            prcBtn->right -= cxS * 2;
            x += SYSMET(CXEDGE);

            if (TestWF(pwnd, WFMINIMIZED)) {
                *pbm  = OBI_RESTORE;
                *pcmd = SC_RESTORE;
            } else {
                *pbm  = OBI_REDUCE;
                *pcmd = SC_MINIMIZE;
            }
        }

    } else if (iButton == INDEX_TITLEBAR_MAXBUTTON) {

        if (TestWF(pwnd, WFMAXBOX)) {

            prcBtn->right -= cxS;

            if (TestWF(pwnd, WFMAXIMIZED)) {
                *pbm  = OBI_RESTORE;
                *pcmd = SC_RESTORE;
            } else {
                *pbm  = OBI_ZOOM;
                *pcmd = SC_MAXIMIZE;
            }
        }

    } else { // iButton == INDEX_TITLEBAR_HELPBUTTON

        if (TestWF(pwnd, WEFCONTEXTHELP)) {
            prcBtn->right -= cxS;

            *pbm = OBI_HELP;
            *pcmd = SC_CONTEXTHELP;
        }
    }

    if (*pcmd) {

        prcBtn->bottom = prcBtn->top + cyS;
        prcBtn->left   = prcBtn->right - cxS;

        /*
         * Adjust 'x' and 'y' to window coordinates
         */
        x += prcBtn->left;
        y += prcBtn->top + SYSMET(CYEDGE);

        /*
         * rcBtn (screen coords hit rect) has a one-border tolerance all
         * around
         */
        InflateRect(prcBtn, SYSMET(CXBORDER), SYSMET(CYBORDER));

        /*
         * Mirror the rect because the buttons in the left hand side of the window if it mirrored.
         */
        if (TestWF(pwnd, WEFLAYOUTRTL)) {
            cxS           = prcBtn->right - prcBtn->left;
            prcBtn->right = pwnd->rcWindow.right - (prcBtn->left - pwnd->rcWindow.left);
            prcBtn->left  = prcBtn->right - cxS;
        }
    }

    return (DWORD)MAKELONG(x, y);
}

/***************************************************************************\
* xxxTrackCaptionButton
*
* Handles clicking and dragging on caption buttons.
* We draw the button depressed then track the mouse.  If the user moves
* outside of the button, undepress it.  When the mouse button is finally
* released, we return whether the mouse was inside the button or not.  I.E.,
* whether the button was clicked.
*
\***************************************************************************/

WORD xxxTrackCaptionButton(
    PWND pwnd,
    UINT hit)
{
    WORD  cmd;
    MSG   msg;
    HDC   hdc;
    WORD  bm;
    int   x;
    int   y;
    WORD  wState;
    WORD  wNewState;
    BOOL  fMouseUp = FALSE;
    RECT  rcBtn;
    DWORD dwWhere;
    int   iButton;
    WORD  wf;
    UserAssert(IsWinEventNotifyDeferredOK());

    CheckLock(pwnd);

    /*
     * Set up iButton for this and future STATECHANGE events
     */
    switch (hit) {
    case HTCLOSE:
        iButton = INDEX_TITLEBAR_CLOSEBUTTON;
        wf = WFCLOSEBUTTONDOWN;
        break;

    case HTREDUCE:
        iButton = INDEX_TITLEBAR_MINBUTTON;
        wf = WFREDUCEBUTTONDOWN;
        break;

    case HTZOOM:
        iButton = INDEX_TITLEBAR_MAXBUTTON;
        wf = WFZOOMBUTTONDOWN;
        break;

    case HTHELP:
        iButton = INDEX_TITLEBAR_HELPBUTTON;
        wf = WFHELPBUTTONDOWN;
        break;

    default:
        UserAssert(FALSE);
    }
    dwWhere = xxxCalcCaptionButton(pwnd, iButton, &cmd, &rcBtn, &bm);
    x = GET_X_LPARAM(dwWhere);
    y = GET_Y_LPARAM(dwWhere);

    if (cmd) {
        /*
         * Draw the image in its depressed state.
         */
        hdc = _GetDCEx(pwnd, NULL, DCX_WINDOW | DCX_USESTYLE);
        BitBltSysBmp(hdc, x, y, bm + DOBI_PUSHED);
        _ReleaseDC(hdc);

        wState = DOBI_PUSHED;

        /*
         * Notification of button press.
         */

        SetWF(pwnd, wf);

        xxxWindowEvent(EVENT_OBJECT_STATECHANGE, pwnd, OBJID_TITLEBAR, iButton, 0);
    } else {
        iButton = 0;
    }

    xxxSetCapture(pwnd);

    while (!fMouseUp) {

        if (xxxPeekMessage(&msg, NULL, WM_MOUSEFIRST, WM_MOUSELAST, PM_REMOVE)) {
            if (msg.message == WM_LBUTTONUP) {

                xxxReleaseCapture();
                fMouseUp = TRUE;

            } else if ((msg.message == WM_MOUSEMOVE) && cmd) {

                wNewState = PtInRect(&rcBtn, msg.pt) ? DOBI_PUSHED : DOBI_NORMAL;

                if (wState != wNewState) {
                    wState = wNewState;

                    hdc = _GetDCEx(pwnd, NULL, DCX_WINDOW | DCX_USESTYLE);
                    BitBltSysBmp(hdc, x, y, bm + wState);
                    _ReleaseDC(hdc);

                    if (wState == DOBI_PUSHED) {
                        SetWF(pwnd, wf);
                    } else {
                        ClrWF(pwnd, wf);
                    }

                    xxxWindowEvent(EVENT_OBJECT_STATECHANGE, pwnd, OBJID_TITLEBAR, iButton, 0);
                }
            }
        } else if (!xxxSleepThread(QS_MOUSE, 0, TRUE)) {
            break;
        }
        if (pwnd != PtiCurrent()->pq->spwndCapture) {
            /*
             * We lost capture. This could have happened during
             *  the WM_CAPTURECHANGED callback or later if we
             *  are/were not in the foreground queue.
             */
            break;
        }
    }

    if (!cmd)
        return 0;

    if (wState && (cmd != SC_CONTEXTHELP)) {
        hdc = _GetDCEx(pwnd, NULL, DCX_WINDOW | DCX_USESTYLE);
        BitBltSysBmp(hdc, x, y, bm);
        _ReleaseDC(hdc);

        ClrWF(pwnd, wf);

        xxxWindowEvent(EVENT_OBJECT_STATECHANGE, pwnd, OBJID_TITLEBAR, iButton, 0);
    }

    return (fMouseUp && PtInRect(&rcBtn, msg.pt)) ? cmd : 0;
}

/***************************************************************************\
* GetWindowSmIcon
*
* Gets icon to draw in caption of window
*
\***************************************************************************/

PCURSOR xxxGetWindowSmIcon(
    PWND pwnd,
    BOOL fDontSendMsg)
{
    PCURSOR pcursor = NULL;
    HICON   hico = NULL;
    PCLS    pcls = pwnd->pcls;
    DWORD   dwResult = 0;

    CheckLock(pwnd);

    /*
     * We check per-window stuff first then per-class stuff, preferring a
     * real small icon over a stretched big one.
     *
     * Per-window small icon
     * Per-window big icon stretched small
     * Per-class small icon
     * Per-class big icon stretched small
     * WM_QUERYDRAGICON big icon stretched small (for 3.x dudes)
     *
     * Try window small icon first
     * NOTE:  The WM_SETICON and WM_GETICON messags are for ISVs only.
     */
    if ((hico = (HICON)_GetProp(pwnd, MAKEINTATOM(gpsi->atomIconSmProp), PROPF_INTERNAL)) != NULL) {

        if (pcursor = (PCURSOR)HMValidateHandleNoSecure(hico, TYPE_CURSOR)) {
            return pcursor;
        } else {
            RIPMSG1(RIP_WARNING,"GetWindowSmIcon: Invalid small icon handle (0x%p)", hico);
        }
    }

    /*
     * Try class small icon next
     */
    pcursor = pcls->spicnSm;
    if (pcursor != NULL)
        return pcursor;

    if (!TestWF(pwnd, WFWIN40COMPAT) &&
        (!TestWF(pwnd, WFOLDUI)      ||
        !TestWF(pwnd, WEFMDICHILD))  &&
        !fDontSendMsg) {

        ULONG_PTR dwResult;

        /*
         * A few old apps like Corel don't set their class icon and other
         * data until long after we need it.  If we send them WM_QUERYDRAGICON,
         * they will fault because they don't check the return from GWL to
         * get their data.  WFOLDUI apps won't ever get a WM_QUERYDRAGICON,
         * sorry.  Currently the apps with this hack (not for this reason
         * necessarily)
         *      Corel Photo-Paint 5.0
         *      Myst 2.0
         *      Visual Baler 3.0
         *      Quicken
         */
        if (xxxSendMessageTimeout(pwnd,
                                  WM_QUERYDRAGICON,
                                  0,
                                  0,
                                  SMTO_NORMAL,
                                  100,
                                  &dwResult)) {

            hico = (HICON)dwResult;
        }

        if (hico) {

            hico = xxxCreateWindowSmIcon(pwnd, hico, FALSE);
            pcursor = (PCURSOR)HMValidateHandleNoSecure(hico, TYPE_CURSOR);

            if (pcursor == NULL)
                hico = NULL;
        }
    }

    if (pcursor == NULL) {
        pcursor = SYSICO(WINLOGO);
    }

    return pcursor;
}

/***************************************************************************\
* BltMe4Times
*
* This routine blts out two copies of the specified caption icon.  One
* with for an active window and one for an inactive window.
*
\***************************************************************************/

VOID BltMe4Times(
    POEMBITMAPINFO pOem,
    int            cxySlot,
    int            cxyIcon,
    HDC            hdcSrc,
    PCURSOR        pcursor,
    UINT           flags)
{
    RECT            rc;
    int             i;
    int             j;
    BOOL            fMask = TRUE;
    LONG            rop;
    HBRUSH          hBrush;

    hBrush = (flags & DC_INBUTTON) ? SYSHBR(3DHILIGHT) : SYSHBR(ACTIVECAPTION);

    for (i = 0; i < 2; i++) {

        rop = SRCAND;

        rc.left   = pOem->x;
        rc.top    = pOem->y;
        rc.right  = rc.left + pOem->cx;
        rc.bottom = rc.top + pOem->cy;
        FillRect(HDCBITS(), &rc, hBrush);

        rc.top  += (cxySlot - cxyIcon) / 2;
        rc.left += SYSMET(CXBORDER) + (cxySlot - cxyIcon) / 2;

        for (j = 0; j < 2; j++) {
                    BltIcon(
                    HDCBITS(),
                    rc.left,
                    rc.top,
                    cxyIcon,
                    cxyIcon,
                    hdcSrc,
                    pcursor,
                    fMask ? DI_MASK : DI_IMAGE,
                    rop);

            fMask = !fMask;
            rop = SRCINVERT;
        }

        pOem += DOBI_CAPOFF;
        hBrush = (flags & DC_INBUTTON) ? SYSHBR(3DFACE) : SYSHBR(INACTIVECAPTION);
    }
}

/***************************************************************************\
*
*  DrawCaptionIcon
*
*  In order to speed up the drawing of caption icons a cache is maintained.
*  Within the cache, the first entry, 0, is for the tray's depressed caption
*  look.  Items 1..CCACHEDCAPTIONS are for the actual caption's icons.
*
\***************************************************************************/

VOID DrawCaptionIcon(
    HDC     hdc,
    LPRECT  lprc,
    PCURSOR pcursor,
    HBRUSH  hbrFill,
    UINT    flags)
{
    int            i;
    int            xStart = 0;
    int            cxySlot;
    POEMBITMAPINFO pOem;
    RECT           rc;
    CAPTIONCACHE   ccTemp;

    /*
     * Check the size of the icon to see if it matches the size of the
     * cache we created.  Most of the time this will match.  Also, if
     * we are drawing with DC_INBUTTON in 16 colors, don't cache.  Also,
     * if the icon has an active alpha channel, just blit it directly
     * and don't cache!
     */
    cxySlot = lprc->bottom - lprc->top;

    if ((cxySlot != gpsi->oembmi[OBI_CAPCACHE1].cy) || 
        (hbrFill == gpsi->hbrGray) ||
        (pcursor->hbmUserAlpha != NULL)) {

        rc.left   = lprc->left;
        rc.top    = lprc->top;
        rc.right  = lprc->left + cxySlot;
        rc.bottom = lprc->top + cxySlot;

        FillRect(hdc, &rc, hbrFill);

        rc.left += SYSMET(CXBORDER) + (cxySlot - SYSMET(CXSMICON)) / 2;
        rc.top  += (cxySlot - SYSMET(CYSMICON)) / 2;

        _DrawIconEx(hdc,
                    rc.left,
                    rc.top,
                    pcursor,
                    SYSMET(CXSMICON),
                    SYSMET(CYSMICON),
                    0,
                    NULL,
                    DI_NORMAL);

        goto Done;
    }

    if (flags & DC_INBUTTON) {

        /*
         * The DC_INBUTTON icons is always slot 0.
         */
        i = ((gcachedCaptions[0].spcursor == pcursor) ? 0 : CCACHEDCAPTIONS);

    } else {

        /*
         * Search the cache to see if this cursor is currently cached.
         */
        for (i = 1; i < CCACHEDCAPTIONS; i++) {
            if (gcachedCaptions[i].spcursor == pcursor)
                break;
        }
    }

    if (i >= CCACHEDCAPTIONS) {

        /*
         * Icon wasn't cached, so try and add it to the cache
         */
        if (flags & DC_INBUTTON) {

            /*
             * The tray's special DC_INBUTTON style always goes in slot 0.
             */
            i = 0;

        } else {

            /*
             * Look for an empty slot in the cache.  If we can't find one,
             * stuff the new icon at the end of the cache.  The result will
             * be that the last item will be deleted.
             */
            for (i = 1; i < CCACHEDCAPTIONS - 1; i++) {
                if (gcachedCaptions[i].spcursor == NULL)
                    break;
            }
        }

        /*
         * Add an item to the cache by blting an active and inactive copy of
         * the icon.
         */
        BltMe4Times(gcachedCaptions[i].pOem,
                    cxySlot,
                    SYSMET(CXSMICON),
                    ghdcMem,
                    pcursor,
                    flags);

        Lock(&(gcachedCaptions[i].spcursor), pcursor);
#if DBG
        gcachedCaptions[i].hico = (HICON)PtoH(pcursor);
#endif
    }

    /*
     * We have a hit, so move that cached icon to the front of the cache.
     * This means that the least recently used icon will be the last
     * icon in the cache.  Remember, we never update index 0 because it
     * is reserved for the DC_INBUTTON icon.
     */
    for ( ; i > 1; i-- ) {

        /*
         * Move the entry toward the front
         */
        ccTemp = gcachedCaptions[i];
        gcachedCaptions[i]     = gcachedCaptions[i - 1];
        gcachedCaptions[i - 1] = ccTemp;

#if DEBUGTAGS
        /*
         * In checked builds we need to adjust the lock records for
         * the cursor so it has the correct address.
         */
        if (IsDbgTagEnabled(DBGTAG_TrackLocks)) {
            if (gcachedCaptions[i].spcursor)
                HMRelocateLockRecord(&(gcachedCaptions[i].spcursor), (int)sizeof(CAPTIONCACHE));
            if (gcachedCaptions[i - 1].spcursor)
                HMRelocateLockRecord(&(gcachedCaptions[i - 1].spcursor), -(int)sizeof(CAPTIONCACHE));
        }
#endif
    }


#if DBG
    /*
     *  Make sure the icon we want to draw is the one
     *  that we hit in the cache.
     */
    UserAssert( gcachedCaptions[i].hico == PtoH(pcursor) );
#endif

    /*
     * Determine what cached bitmap to blt.
     */
    pOem = gcachedCaptions[i].pOem;
    if (!(flags & DC_ACTIVE))
        pOem += DOBI_CAPOFF;

    GreBitBlt(hdc,
              lprc->left,
              lprc->top,
              cxySlot,
              cxySlot,
              HDCBITS(),
              pOem->x,
              pOem->y,
              SRCCOPY,
              0);

Done:
    /*
     * Adjust the given rectangle for the icon we just drew
     */
    lprc->left += cxySlot;
}

/***************************************************************************\
* FillGradient
*
* The rectangle is broken into two triangles: {0, 1, 2} and {0, 2, 3}.
* Color on {0, 3} is black, and on {1, 2) is the active caption color.
*
* 0  1
* 3  2
*
* 12/06/96      vadimg      created
\***************************************************************************/

void FillGradient(HDC hdc, LPCRECT prc, COLORREF rgbLeft, COLORREF rgbRight)
{
    TRIVERTEX avert[4];
    static GRADIENT_RECT auRect[1] = {0,1};
    #define GetCOLOR16(RGB, clr) ((COLOR16)(Get ## RGB ## Value(clr) << 8))

    avert[0].Red = GetCOLOR16(R, rgbLeft);
    avert[0].Green = GetCOLOR16(G, rgbLeft);
    avert[0].Blue = GetCOLOR16(B, rgbLeft);

    avert[1].Red = GetCOLOR16(R, rgbRight);
    avert[1].Green = GetCOLOR16(G, rgbRight);
    avert[1].Blue = GetCOLOR16(B, rgbRight);

    avert[0].x = prc->left;
    avert[0].y = prc->top;
    avert[1].x = prc->right;
    avert[1].y = prc->bottom;

    GreGradientFill(hdc, avert, 2,(PVOID)auRect, 1, GRADIENT_FILL_RECT_H);
}

void FillCaptionGradient(HDC hdc, LPCRECT prc, BOOL fActive)
{
    COLORREF rgbLeft, rgbRight;

    if (fActive) {
        rgbLeft = gpsi->argbSystem[COLOR_ACTIVECAPTION];
        rgbRight = gpsi->argbSystem[COLOR_GRADIENTACTIVECAPTION];
    } else {
        rgbLeft = gpsi->argbSystem[COLOR_INACTIVECAPTION];
        rgbRight = gpsi->argbSystem[COLOR_GRADIENTINACTIVECAPTION];
    }
    if (rgbLeft != rgbRight) {
        FillGradient(hdc, prc, rgbLeft, rgbRight);
    } else {
        FillRect(hdc, prc, fActive ? SYSHBR(ACTIVECAPTION) : SYSHBR(INACTIVECAPTION));
    }
}

/***************************************************************************\
* DrawCaptionTemp
*
\***************************************************************************/

BOOL xxxDrawCaptionTemp(
    PWND            pwnd,  // pwnd may be NULL!
    HDC             hdc,
    LPRECT          lprc,
    HFONT           hFont,
    PCURSOR         pcursor,
    PUNICODE_STRING pstrText,
    UINT            flags)
{
    int    iOldMode;
    HBRUSH hbrFill;
    LONG   clrOldText;
    LONG   clrOldBk;
    BOOL   fItFit = TRUE;
    BOOL   fGradient = FALSE;
    SIZE   size;
    UINT   oldAlign;

    CheckLock(pwnd);

    if (lprc->right <= lprc->left)
        return FALSE;

    if (pwnd != NULL) {

        if (!pcursor               &&
            _HasCaptionIcon(pwnd)  &&
            !(flags & DC_SMALLCAP) &&
            TestWF(pwnd, WFSYSMENU)) {

            /*
             * Only get the icon if we can send messages AND the window has
             * a system menu.
             */
            pcursor = xxxGetWindowSmIcon(pwnd, (flags & DC_NOSENDMSG));
        }
    }

    /*
     * Set up the colors
     */
    if (flags & DC_ACTIVE) {

        if (flags & DC_INBUTTON) {
            if (gpsi->BitCount < 8 ||
                    SYSRGB(3DHILIGHT) != SYSRGB(SCROLLBAR) ||
                    SYSRGB(3DHILIGHT) == SYSRGB(WINDOW)) {
                clrOldText = SYSRGB(3DFACE);
                clrOldBk   = SYSRGB(3DHILIGHT);
                hbrFill    = gpsi->hbrGray;
                iOldMode   = GreSetBkMode(hdc, TRANSPARENT);
            } else {
                clrOldText = SYSRGB(BTNTEXT);
                clrOldBk   = SYSRGB(3DHILIGHT);
                hbrFill    = SYSHBR(3DHILIGHT);
            }

        } else {
            clrOldText = SYSRGB(CAPTIONTEXT);
            clrOldBk   = SYSRGB(ACTIVECAPTION);
            hbrFill    = SYSHBR(ACTIVECAPTION);

            if (flags & DC_GRADIENT) {
                fGradient = TRUE;
                iOldMode = GreSetBkMode(hdc, TRANSPARENT);
            }
        }

    } else {

        if (flags & DC_INBUTTON) {
            clrOldText = SYSRGB(BTNTEXT);
            clrOldBk   = SYSRGB(3DFACE);
            hbrFill    = SYSHBR(3DFACE);
        } else {
            clrOldText = SYSRGB(INACTIVECAPTIONTEXT);
            clrOldBk   = SYSRGB(INACTIVECAPTION);
            hbrFill    = SYSHBR(INACTIVECAPTION);

            if (flags & DC_GRADIENT) {
                fGradient = TRUE;
                iOldMode = GreSetBkMode(hdc, TRANSPARENT);
            }
        }
    }


    /*
     * Set up drawing colors.
     */
    clrOldText = GreSetTextColor(hdc, clrOldText);
    clrOldBk   = GreSetBkColor(hdc, clrOldBk);

    if (pcursor && !(flags & DC_SMALLCAP)) {

        if (flags & DC_ICON) {
            /*
             * Preserve icon shape when BitBlitting it to a
             * mirrored DC. This way we don't violate copyright
             * issues on icons. [samera]
             */
            DWORD dwLayout=0L;
            if ((dwLayout=GreGetLayout(hdc)) & LAYOUT_RTL) {
                GreSetLayout(hdc, -1, dwLayout|LAYOUT_BITMAPORIENTATIONPRESERVED);
            }

            DrawCaptionIcon(hdc, lprc, pcursor, hbrFill, flags);

            /*
             * Restore the DC to its previous layout state.
             */
            if (dwLayout & LAYOUT_RTL) {
                GreSetLayout(hdc, -1, dwLayout);
            }
        } else {
            lprc->left += lprc->bottom - lprc->top;
        }
    }

    if (flags & DC_TEXT) {
        int            cch;
        HFONT          hfnOld;
        int            yCentered;
        WCHAR          szText[CCHTITLEMAX];
        UNICODE_STRING strTmp;
        PTHREADINFO ptiCurrent = PtiCurrentShared();

        /*
         * Note -- the DC_NOSENDMSG check is not in Chicago.  It needs to be,
         * since GetWindowText calls back to the window.  FritzS
         */

        /*
         *  Get the text for the caption.
         */
        if (pstrText == NULL) {

            if ((pwnd == NULL) || (flags & DC_NOSENDMSG)) {

                if (pwnd && pwnd->strName.Length) {
                    cch = TextCopy(&pwnd->strName, szText, CCHTITLEMAX - 1);
                    strTmp.Length = (USHORT)(cch * sizeof(WCHAR));
                } else {
                    szText[0] = TEXT('\0');
                    cch = strTmp.Length = 0;
                }

            } else {
                cch = xxxGetWindowText(pwnd, szText, CCHTITLEMAX - 1);
                strTmp.Length = (USHORT)(cch * sizeof(WCHAR));
            }

            /*
             *  We don't use RtlInitUnicodeString() to initialize the string
             *  because it does a wstrlen() on the string, which is a waste
             *  since we already know its length.
             */
            strTmp.Buffer = szText;
            strTmp.MaximumLength = strTmp.Length + sizeof(UNICODE_NULL);
            pstrText = &strTmp;

        } else {
            cch = pstrText->Length / sizeof(WCHAR);
            UserAssert(pstrText->Length < pstrText->MaximumLength);
            UserAssert(pstrText->Buffer[cch] == 0);
        }

        /*
         *  We need to set up font first, in case we're centering caption.
         *  Fortunately, no text at all is uncommon...
         */
        if (hFont == NULL) {

            if (flags & DC_SMALLCAP) {
                hFont = ghSmCaptionFont;
                yCentered = gcySmCaptionFontChar;
            } else {
                hFont = gpsi->hCaptionFont;
                yCentered = gcyCaptionFontChar;
            }

            yCentered = (lprc->top + lprc->bottom - yCentered) / 2;

            hfnOld = GreSelectFont(hdc, hFont);

        } else {

            TEXTMETRICW tm;

            /*
             * UNCOMMON case:  only for control panel
             */
            hfnOld = GreSelectFont(hdc, hFont);

            if (!_GetTextMetricsW(hdc, &tm)) {
                RIPMSG0(RIP_WARNING, "xxxDrawCaptionTemp: _GetTextMetricsW Failed");
                tm.tmHeight = gpsi->tmSysFont.tmHeight;
            }
            yCentered = (lprc->top + lprc->bottom - tm.tmHeight) / 2;
        }

        /*
         * Draw text
         */
        if (fGradient) {
            FillCaptionGradient(hdc, lprc, flags & DC_ACTIVE);
        } else {
            FillRect(hdc, lprc, hbrFill);
        }

        if (hbrFill == gpsi->hbrGray) {
            GreSetTextColor(hdc, SYSRGB(BTNTEXT));
            GreSetBkColor(hdc, SYSRGB(GRAYTEXT));
        }

        /*
         * GDI doesn't do callbacks to the LPK.  If an LPK is installed
         * and we're not in thread cleanup mode, call the appropriate
         * client side GDI routines.
         */
        if (CALL_LPK(ptiCurrent)) {
            xxxClientGetTextExtentPointW(hdc, pstrText->Buffer, cch, &size);
        } else {
            GreGetTextExtentW(hdc, pstrText->Buffer, cch, &size, GGTE_WIN3_EXTENT);
        }

        if (pwnd && TestWF(pwnd, WEFRTLREADING)) {
            oldAlign = GreSetTextAlign(hdc, TA_RTLREADING | GreGetTextAlign(hdc));
        }
        if (!(flags & DC_CENTER) && (!cch || (size.cx <= (lprc->right - lprc->left - SYSMET(CXEDGE))))) {
            if (pwnd && TestWF(pwnd, WEFRIGHT)) {
                if (CALL_LPK(ptiCurrent)) {
                    xxxClientExtTextOutW(hdc, lprc->right - (size.cx + SYSMET(CXEDGE)), yCentered,
                        ETO_CLIPPED, lprc, pstrText->Buffer, cch, NULL);
                }
                else {
                    GreExtTextOutW(hdc, lprc->right - (size.cx + SYSMET(CXEDGE)), yCentered,
                       ETO_CLIPPED, lprc, pstrText->Buffer, cch, NULL);
                }
            } else {
                if (CALL_LPK(ptiCurrent)) {
                    xxxClientExtTextOutW(hdc, lprc->left + SYSMET(CXEDGE), yCentered,
                        ETO_CLIPPED, lprc, pstrText->Buffer, cch, NULL);
                }
                else {
                    GreExtTextOutW(hdc, lprc->left + SYSMET(CXEDGE), yCentered,
                        ETO_CLIPPED, lprc, pstrText->Buffer, cch, NULL);
                }
            }

#ifdef LAME_BUTTON  

            if ((flags & DC_LAMEBUTTON) && pwnd != NULL && TestWF(pwnd, WEFLAMEBUTTON)) {
                
                GreSelectFont(hdc, ghLameFont);

                /*
                 * Make sure the Lame! text fits in the caption
                 */
                if (size.cx + gpsi->ncxLame + 2 * SYSMET(CXEDGE) <=
                    
                    (lprc->right - lprc->left - SYSMET(CXEDGE))) {

                    int x;
                    if (pwnd && TestWF(pwnd, WEFRIGHT)) {
                        x = lprc->left + SYSMET(CXEDGE);
                    } else {
                        x = lprc->right - SYSMET(CXEDGE) - gpsi->ncxLame;
                    }
                    if (CALL_LPK(ptiCurrent)) {
                        xxxClientExtTextOutW(hdc, x, yCentered,
                            ETO_CLIPPED, lprc, gpsi->gwszLame, wcslen(gpsi->gwszLame), NULL);
                    } else {
                        GreExtTextOutW(hdc, x, yCentered,
                            ETO_CLIPPED, lprc, gpsi->gwszLame, wcslen(gpsi->gwszLame), NULL);
                    }
                }
            }
#endif // LAME_BUTTON            
        
        } else {

            DRAWTEXTPARAMS dtp;
            UINT wSide;

            dtp.cbSize       = sizeof(DRAWTEXTPARAMS);
            dtp.iLeftMargin  = SYSMET(CXEDGE);
            dtp.iRightMargin = 0;

            wSide = (flags & DC_CENTER) ? DT_CENTER
                                        : ((pwnd && TestWF(pwnd, WEFRIGHT)) ? DT_RIGHT : 0);

            DrawTextEx(hdc,
                       pstrText->Buffer,
                       cch,
                       lprc,
                       DT_NOPREFIX | DT_END_ELLIPSIS | DT_SINGLELINE | DT_VCENTER |
                       wSide, &dtp);

            fItFit = FALSE;
        }

        if (pwnd && TestWF(pwnd, WEFRTLREADING))
            GreSetTextAlign(hdc, oldAlign);

        if (hfnOld)
            GreSelectFont(hdc, hfnOld);
    }

    /*
     * Restore colors
     */
    GreSetTextColor(hdc, clrOldText);
    GreSetBkColor(hdc, clrOldBk);

    if (hbrFill == gpsi->hbrGray)
        GreSetBkMode(hdc, iOldMode);

    return fItFit;
}

/***************************************************************************\
* xxxDrawCaptionBar
*
*
\***************************************************************************/

VOID xxxDrawCaptionBar(
    PWND pwnd,
    HDC  hdc,
    UINT wFlags)
{
    UINT   bm = OBI_CLOSE;
    RECT   rcWindow;
    HBRUSH hBrush = NULL;
    HBRUSH hCapBrush;
    int    colorBorder;
    UINT   wBtns;
    UINT   wCode;
    BOOL     fGradient = FALSE;

    CheckLock(pwnd);

    /*
     * If we're not currently showing on the screen, return.
     * NOTE
     * If you remove the IsVisible() check from DrawWindowFrame(), then
     * be careful to remove the NC_NOVISIBLE flag too.  This is a smallish
     * speed thing, so that we don't have to call IsVisible() twice on a
     * window.  DrawWindowFrame() already checks.
     */
    if (!(wFlags & DC_NOVISIBLE) && !IsVisible(pwnd))
        return;

    /*
     * Clear this flag so we know the frame has been drawn.
     */
    ClearHungFlag(pwnd, WFREDRAWFRAMEIFHUNG);

    GetRect(pwnd, &rcWindow, GRECT_WINDOW | GRECT_WINDOWCOORDS);
    /*
     * The TestALPHA() will return false in ts connections because the gbDisableAlpha 
     * flag will be set to true. So, we need to special case for TS connections. 
     * If this is a remote connection and the gradient captions flag is set, 
     * ideally, we should force it to draw gradients. However, 
     * for 8-bit color, enabling gradients looks ugly. We will fix this for Blackcomb
     * The code should be something like this
     * fGradient = IsRemoteConnection() && !8-bit color?  TestEffectUP(GRADIENTCAPTIONS) :  TestALPHA(GRADIENTCAPTIONS);
     */

    fGradient = TestALPHA(GRADIENTCAPTIONS);

    if (fGradient) {
        hCapBrush = (wFlags & DC_ACTIVE) ? SYSHBR(GRADIENTACTIVECAPTION) : SYSHBR(GRADIENTINACTIVECAPTION);
    } else {
        hCapBrush = (wFlags & DC_ACTIVE) ? SYSHBR(ACTIVECAPTION) : SYSHBR(INACTIVECAPTION);
    }

    wCode = 0;

    if (!xxxMNCanClose(pwnd))
        wCode |= NOCLOSE;

    if (!TestWF(pwnd, WFMAXBOX))
        wCode |= NOMAX;
    else if (TestWF(pwnd, WFMAXIMIZED))
        wCode |= MAX;

    if (!TestWF(pwnd, WFMINBOX))
          wCode |= NOMIN;
    else if(TestWF(pwnd, WFMINIMIZED))
          wCode |= MIN;

    if (TestWF(pwnd, WFMINIMIZED)) {

        if (wFlags & DC_FRAME) {

            /*
             * Raised outer edge + border
             */
            DrawEdge(hdc, &rcWindow, EDGE_RAISED, (BF_RECT | BF_ADJUST));
            DrawFrame(hdc, &rcWindow, 1, DF_3DFACE);
            InflateRect(&rcWindow, -SYSMET(CXBORDER), -SYSMET(CYBORDER));

        } else {
            InflateRect(&rcWindow, -SYSMET(CXFIXEDFRAME), -SYSMET(CYFIXEDFRAME));
        }

        rcWindow.bottom = rcWindow.top + SYSMET(CYSIZE);

        hBrush = GreSelectBrush(hdc, hCapBrush);

    } else {
        /*
         * BOGUS
         * What color should we draw borders in?  The check is NOT simple.
         * At create time, we set the 3D bits.  NCCREATE will also
         * set them for listboxes, edit fields,e tc.
         */
        colorBorder = (TestWF(pwnd, WEFEDGEMASK) && !TestWF(pwnd, WFOLDUI)) ? COLOR_3DFACE : COLOR_WINDOWFRAME;

        /*
         * Draw the window frame.
         */
        if (wFlags & DC_FRAME) {
            /*
             * Window edge
             */
            if (TestWF(pwnd, WEFWINDOWEDGE))
                DrawEdge(hdc, &rcWindow, EDGE_RAISED, BF_RECT | BF_ADJUST);
            else if (TestWF(pwnd, WEFSTATICEDGE))
                DrawEdge(hdc, &rcWindow, BDR_SUNKENOUTER, BF_RECT | BF_ADJUST);

            /*
             * Size border
             */
            if (TestWF(pwnd, WFSIZEBOX)) {

                DrawFrame(hdc,
                          &rcWindow,
                          gpsi->gclBorder,
                          ((wFlags & DC_ACTIVE) ? DF_ACTIVEBORDER : DF_INACTIVEBORDER));

                InflateRect(&rcWindow,
                            -gpsi->gclBorder * SYSMET(CXBORDER),
                            -gpsi->gclBorder * SYSMET(CYBORDER));
            }

            /*
             * Normal border
             */
            if (TestWF(pwnd, WFBORDERMASK) || TestWF(pwnd, WEFDLGMODALFRAME)) {
                DrawFrame(hdc, &rcWindow, 1, (colorBorder << 3));
                InflateRect(&rcWindow, -SYSMET(CXBORDER), -SYSMET(CYBORDER));
            }
        } else {

            int cBorders;

            cBorders = GetWindowBorders(pwnd->style, pwnd->ExStyle, TRUE, FALSE);

            InflateRect(&rcWindow,
                        -cBorders * SYSMET(CXBORDER),
                        -cBorders * SYSMET(CYBORDER));
        }

        /*
         * Punt if the window doesn't have a caption currently showing on screen.
         */
        if (!TestWF(pwnd, WFCPRESENT))
            return;

        if (TestWF(pwnd, WEFTOOLWINDOW)) {
            wCode |= SMCAP;
            rcWindow.bottom = rcWindow.top + SYSMET(CYSMSIZE);
            bm = OBI_CLOSE_PAL;
        } else
            rcWindow.bottom = rcWindow.top + SYSMET(CYSIZE);

#if 0
        /* Draw the border beneath the caption.
         *
         *
         * hBrush = GreSelectBrush(hdc, gpsi->ahbrSystem[colorBorder]);
         *GrePatBlt(hdc, rcWindow.left, rcWindow.bottom,
         *        rcWindow.right - rcWindow.left,
         *        SYSMET(CYBORDER), PATCOPY);
         */
#endif

        {
            POLYPATBLT PolyData;

            PolyData.x         = rcWindow.left;
            PolyData.y         = rcWindow.bottom;
            PolyData.cx        = rcWindow.right - rcWindow.left;
            PolyData.cy        = SYSMET(CYBORDER);
            PolyData.BrClr.hbr = SYSHBRUSH(colorBorder);

            GrePolyPatBlt(hdc,PATCOPY,&PolyData,1,PPB_BRUSH);
        }

        GreSelectBrush(hdc, hCapBrush);
    }

    if (!TestWF(pwnd, WFSYSMENU) && TestWF(pwnd, WFWIN40COMPAT))
        goto JustDrawIt;

    /*
     * New Rules:
     *  (1) The caption has a horz border beneath it separating it from the
     *      menu or client.
     *  (2) The caption text area has an edge of space on the left and right
     *      before the characters.
     *  (3) We account for the descent below the baseline of the caption char
     */
    wBtns = 1;

    if (!(wFlags & DC_BUTTONS)) {

        if ((!wCode) || (!(wCode & SMCAP) && ((wCode & NOSIZE) != NOSIZE))) {

            wBtns += 2;

        } else {

            rcWindow.right -= SYSMET(CXEDGE);

            if ((wCode == NOSIZE) && (wCode && TestWF(pwnd, WEFCONTEXTHELP)))
                wBtns++;
        }

        rcWindow.right -= wBtns * ((wCode & SMCAP) ? SYSMET(CXSMSIZE) : SYSMET(CXSIZE));

        goto JustDrawIt;
    }

    if (!wCode || (wCode == NOSIZE)) {
        POEMBITMAPINFO pOem = gpsi->oembmi + OBI_CAPBTNS;
        int            cx;

        cx = (wCode ? SYSMET(CXSIZE) + SYSMET(CXEDGE) : SYSMET(CXSIZE) * 3);

        if (!(wFlags & DC_ACTIVE))
            pOem += DOBI_CAPOFF;

        rcWindow.right -= cx;

        GreBitBlt(hdc,
                  rcWindow.right,
                  rcWindow.top,
                  cx,
                  pOem->cy,
                  HDCBITS(),
                  pOem->x + pOem->cx - SYSMET(CXSIZE) - cx,
                  pOem->y,
                  SRCCOPY,
                  0);

        if (wCode && TestWF(pwnd, WEFCONTEXTHELP)) {

            rcWindow.right -= SYSMET(CXSIZE) - SYSMET(CXEDGE);

            GreBitBlt(hdc,
                      rcWindow.right,
                      rcWindow.top,
                      SYSMET(CXSIZE),
                      pOem->cy,
                      HDCBITS(),
                      pOem->x + pOem->cx - SYSMET(CXSIZE),
                      pOem->y,
                      SRCCOPY,
                      0);
            /*
             * If the UI language is Hebrew we do not want to mirror the ? mark only
             * Then redraw ? with out the button frame.
             */
            if (HEBREW_UI_LANGID() && TestWF(pwnd, WEFLAYOUTRTL)) {
                GreBitBlt(hdc,
                          rcWindow.right-SYSMET(CXEDGE),
                          rcWindow.top+2,
                          SYSMET(CXSIZE)-SYSMET(CXEDGE)*2,
                          pOem->cy-4,
                          HDCBITS(),
                          pOem->x + pOem->cx - SYSMET(CXSIZE) + SYSMET(CXEDGE),
                          pOem->y + SYSMET(CXEDGE),
                          SRCCOPY|NOMIRRORBITMAP,
                          0);
            }
        }
        goto JustDrawIt;
    }

    /*
     * Draw the caption buttons
     */
    rcWindow.top    += SYSMET(CYEDGE);
    rcWindow.bottom -= SYSMET(CYEDGE);

    rcWindow.right -= SYSMET(CXEDGE);

    GrePatBlt(hdc,
              rcWindow.right,
              rcWindow.top,
              SYSMET(CXEDGE),
              rcWindow.bottom - rcWindow.top,
              PATCOPY);

    if (wCode & NOCLOSE) {
        bm += DOBI_INACTIVE;
    }

    rcWindow.right -= gpsi->oembmi[bm].cx;
    BitBltSysBmp(hdc, rcWindow.right, rcWindow.top, bm);

    if (!(wCode & SMCAP) && ((wCode & NOSIZE) != NOSIZE)) {

        rcWindow.right -= SYSMET(CXEDGE);

        GrePatBlt(hdc,
                  rcWindow.right,
                  rcWindow.top,
                  SYSMET(CXEDGE),
                  rcWindow.bottom - rcWindow.top,
                  PATCOPY);

        /*
         * Max Box
         * If window is maximized use the restore bitmap;
         * otherwise use the regular zoom bitmap
         */
        bm = (wCode & MAX) ? OBI_RESTORE : ((wCode & NOMAX) ? OBI_ZOOM_I : OBI_ZOOM);
        rcWindow.right -= gpsi->oembmi[bm].cx;
        BitBltSysBmp(hdc, rcWindow.right, rcWindow.top, bm);

        /*
         * Min Box
         */
        bm = (wCode & MIN) ? OBI_RESTORE : ((wCode & NOMIN) ? OBI_REDUCE_I : OBI_REDUCE);
        rcWindow.right -= gpsi->oembmi[bm].cx;
        BitBltSysBmp(hdc, rcWindow.right, rcWindow.top, bm);
        rcWindow.right -= SYSMET(CXEDGE);
        GrePatBlt(hdc,
                  rcWindow.right,
                  rcWindow.top,
                  SYSMET(CXEDGE),
                  rcWindow.bottom - rcWindow.top,
                  PATCOPY);

        wBtns += 2;
    }

    if ((wCode & (NOCLOSE | NOSIZE)) &&
        (!(wCode & SMCAP)) && TestWF(pwnd, WEFCONTEXTHELP)) {

        rcWindow.right -= SYSMET(CXEDGE);

        GrePatBlt(hdc,
                  rcWindow.right,
                  rcWindow.top,
                  SYSMET(CXEDGE),
                  rcWindow.bottom - rcWindow.top,
                  PATCOPY);


        bm = OBI_HELP;
        rcWindow.right -= gpsi->oembmi[bm].cx;
        BitBltSysBmp(hdc, rcWindow.right, rcWindow.top, bm);

        wBtns++;
    }

    rcWindow.top    -= SYSMET(CYEDGE);
    rcWindow.bottom += SYSMET(CYEDGE);

    wBtns *= (wCode & SMCAP) ? SYSMET(CXSMSIZE) : SYSMET(CXSIZE);

    {
        POLYPATBLT PolyData[2];

        PolyData[0].x         = rcWindow.right;
        PolyData[0].y         = rcWindow.top;
        PolyData[0].cx        = wBtns;
        PolyData[0].cy        = SYSMET(CYEDGE);
        PolyData[0].BrClr.hbr = NULL;

        PolyData[1].x         = rcWindow.right;
        PolyData[1].y         = rcWindow.bottom - SYSMET(CYEDGE);
        PolyData[1].cx        = wBtns;
        PolyData[1].cy        = SYSMET(CYEDGE);
        PolyData[1].BrClr.hbr = NULL;

        GrePolyPatBlt(hdc,PATCOPY,&PolyData[0],2,PPB_BRUSH);
    }

#if 0
    GrePatBlt(hdc, rcWindow.right, rcWindow.top, wBtns, SYSMET(CYEDGE), PATCOPY);
    GrePatBlt(hdc, rcWindow.right, rcWindow.bottom - SYSMET(CYEDGE), wBtns, SYSMET(CYEDGE), PATCOPY);
#endif

    /*
     * We're going to release this DC--we don't need to bother reselecting
     * in the old brush
     */
    if (hBrush)
        GreSelectBrush(hdc, hBrush);

JustDrawIt:

    /*
     * Call DrawCaption only if we need to draw the icon or the text
     * If the text gets truncated, set the window flag for
     * the caption tooltip
     */
    if (wFlags & (DC_TEXT | DC_ICON)) {

#ifdef LAME_BUTTON
        wFlags |= DC_LAMEBUTTON;
#endif // LAME_BUTTON
    /*
     * The TestALPHA() will return false in ts connections because the gbDisableAlpha 
     * flag will be set to true. So, we need to special case for TS connections. 
     * If this is a remote connection and the gradient captions flag is set, 
     * ideally, we should force it to draw gradients.
     * However, for 8-bit color, enabling gradients looks ugly. We will fix this for Blackcomb
     */

        if (!xxxDrawCaptionTemp(pwnd,
                               hdc,
                               &rcWindow,
                               NULL,
                               NULL,
                               NULL,
                               wFlags | ((wCode & SMCAP)  ? DC_SMALLCAP : 0) |
                               (fGradient? DC_GRADIENT : 0))) {
            SetWF(pwnd, WEFTRUNCATEDCAPTION);
        } else {
            ClrWF(pwnd, WEFTRUNCATEDCAPTION);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\acons.c ===
/****************************** Module Header ******************************\
* Module Name: acons.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains code for dealing with animated icons/cursors.
*
* History:
* 10-02-91 DarrinM      Created.
* 07-30-92 DarrinM      Unicodized.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* _SetSystemCursor (API)
*
* Replace a system (aka 'public') cursor with a user provided one.  The new
* cursor is pulled from a file (.CUR, .ICO, or .ANI) specified in WIN.INI.
*
* History:
* 12-26-91 DarrinM      Created.
* 08-04-92 DarrinM      Recreated.
* 10/14/1995 SanfordS   Win95 support.
\***************************************************************************/

BOOL zzzSetSystemCursor(
    PCURSOR pcur,
    DWORD id)
{
    int i;

    if (!CheckWinstaWriteAttributesAccess()) {
        return FALSE;
    }

    UserAssert(pcur);

    /*
     * Check if this cursor is one of the replaceable ones.
     */
    for (i = 0; i < COCR_CONFIGURABLE; i++)
        if (gasyscur[i].Id == (WORD)id)
            break;

    /*
     * Not replaceable, bail out.
     */
    if (i == COCR_CONFIGURABLE) {
        RIPMSG1(RIP_WARNING, "_SetSystemCursor: called with bad id %x.\n", id);
        return FALSE;
    }

    return zzzSetSystemImage(pcur, gasyscur[i].spcur);
}


/***********************************************************************\
* SetSystemImage
*
* Places the contents of pcur into pcurSys and destroys pcur.
*
* Returns: fSuccess
*
* 10/14/1995 Created SanfordS
\***********************************************************************/

BOOL zzzSetSystemImage(
    PCURSOR pcur,
    PCURSOR pcurSys)
{
#define CBCOPY (max(sizeof(CURSOR), sizeof(ACON)) - FIELD_OFFSET(CURSOR, CI_COPYSTART))
#define pacon ((PACON)pcur)

    char cbT[CBCOPY];
    UINT CURSORF_flags;

    UserAssert(pcurSys);

    if (pcurSys == pcur)
        return(TRUE);

    /*
     * All ssytem images being replaced should have ordinal names
     * and reference the USER module and be unowned.
     */
    UserAssert(!IS_PTR(pcurSys->strName.Buffer));
    UserAssert(pcurSys->atomModName == atomUSER32);

    /*
     * if pcur was an acon, transfer frame ownerships to pcurSys.
     */
    UserAssert(pcurSys->head.ppi == NULL);
    if (pcur->CURSORF_flags & CURSORF_ACON &&
            pcur->head.ppi != NULL) {

        int i;
        PHE phe = HMPheFromObject(pcurSys);
        PTHREADINFO ptiOwner = ((PPROCESSINFO)phe->pOwner)->ptiList;

        for (i = 0; i < pacon->cpcur; i++) {
            HMChangeOwnerProcess(pacon->aspcur[i], ptiOwner);
            pacon->aspcur[i]->head.ppi = NULL;
        }
    }

    /*
     * If this assert fails, the CURSOR and ACON structures were changed
     * incorrectly - read the comments in user.h and wingdi.w around
     * tagCURSOR, tagACON, and CURSINFO.
     */
    UserAssert(FIELD_OFFSET(CURSOR, CI_FIRST) == FIELD_OFFSET(ACON, CI_FIRST));

    /*
     * swap everything starting from CI_COPYSTART.
     */
    RtlCopyMemory(&cbT, &pcur->CI_COPYSTART, CBCOPY);
    RtlCopyMemory(&pcur->CI_COPYSTART, &pcurSys->CI_COPYSTART, CBCOPY);
    RtlCopyMemory(&pcurSys->CI_COPYSTART, &cbT, CBCOPY);
    /*
     * Swap the CURSORF_ACON flags since they go with the swapped data.
     */
    CURSORF_flags = pcur->CURSORF_flags & CURSORF_ACON;
    pcur->CURSORF_flags =
            (pcur->CURSORF_flags    & ~CURSORF_ACON) |
            (pcurSys->CURSORF_flags &  CURSORF_ACON);
    pcurSys->CURSORF_flags =
            (pcurSys->CURSORF_flags & ~CURSORF_ACON) | CURSORF_flags;

    /*
     * If we swapped acons into pcur, then we need to change the ownerhsip to
     *  make sure they can get destroyed
     */
    if (pcur->CURSORF_flags & CURSORF_ACON) {
        int i;
        PTHREADINFO ptiCurrent = PtiCurrent();
        for (i = 0; i < pacon->cpcur; i++) {
            HMChangeOwnerProcess(pacon->aspcur[i], ptiCurrent);
        }
    }

    /*
     * Use THREADCLEANUP so system cursors are not destroyed.
     */
    _DestroyCursor(pcur, CURSOR_THREADCLEANUP);


    /*
     * If the current logical current is changing the force the current physical
     * cursor to change.
     */
    if (gpcurLogCurrent == pcurSys) {
        gpcurLogCurrent = NULL;
        gpcurPhysCurrent = NULL;
        zzzUpdateCursorImage();
    }

    /*
     * Mark the cursor as a system cursor that can be shadowed by GDI.
     */
    pcurSys->CURSORF_flags |= CURSORF_SYSTEM;

    return TRUE;
#undef pacon
#undef CBCOPY
}



/***************************************************************************\
* _GetCursorFrameInfo (API)
*
* Example usage:
*
* hcur = _GetCursorFrameInfo(hacon, NULL, 4, &ccur);
* hcur = _GetCursorFrameInfo(NULL, IDC_NORMAL, 0, &ccur); // get device's arrow
*
* History:
* 08-05-92 DarrinM      Created.
\***************************************************************************/

PCURSOR _GetCursorFrameInfo(
    PCURSOR pcur,
    int     iFrame,
    PJIF    pjifRate,
    LPINT   pccur)
{
    /*
     * If this is only a single cursor (not an ACON) just return it and
     * a frame count of 1.
     */
    if (!(pcur->CURSORF_flags & CURSORF_ACON)) {
        *pccur = 1;
        *pjifRate = 0;
        return pcur;
    }

    /*
     * Return the useful cursor information for the specified frame
     * of the ACON.
     */
#define pacon ((PACON)pcur)
    if (iFrame < 0 || iFrame >= pacon->cicur)
        return NULL;

    *pccur = pacon->cicur;
    *pjifRate = pacon->ajifRate[iFrame];

    return pacon->aspcur[pacon->aicur[iFrame]];
#undef pacon
}


/***************************************************************************\
* DestroyAniIcon
*
* Free all the individual cursors that make up the frames of an animated
* icon.
*
* WARNING: DestroyAniIcon assumes that all fields that an ACON shares with
* a cursor will be freed by some cursor code (probably the cursor function
* that calls this one).
*
* History:
* 08-04-92 DarrinM      Created.
\***************************************************************************/

BOOL DestroyAniIcon(
    PACON pacon)
{
    int i;
    PCURSOR pcur;

    for (i = 0; i < pacon->cpcur; i++) {
        UserAssert(pacon->aspcur[i]->CURSORF_flags & CURSORF_ACONFRAME);
        /*
         * This should not be a public acon; if it is, unlock won't be able
         *  to destroy it. If destroy a public icon, ownership must be called
         *  before calling this function (see zzzSetSystemImage)
         */
        UserAssert(GETPPI(pacon->aspcur[i]) != NULL);
        pcur = Unlock(&pacon->aspcur[i]);
        if (pcur != NULL) {
            _DestroyCursor(pcur, CURSOR_ALWAYSDESTROY);
        }
    }

    UserFreePool(pacon->aspcur);

    return TRUE;
}


/***********************************************************************\
* LinkCursor
*
* Links unlinked cursor into the apropriate icon cache IFF its the
* type of cursor that needs to be in the cache.
*
* Note that changing ownership if cursor objects needs to keep this
* cache linking in mind.  The unlink routine in
* DestroyEmptyCursorObject() will handle public cursor objects made
* local but that is all.
*
* 10/18/1995 Created SanfordS
\***********************************************************************/

VOID LinkCursor(
    PCURSOR pcur)
{
    /*
     * Should never try to link twice!
     */
    UserAssert(!(pcur->CURSORF_flags & CURSORF_LINKED));
    /*
     * We don't cache acon frames because they all belong to the
     * root acon object.
     *
     * We don't cache process owned objects that are not LRSHARED
     * either.
     */
    if (!(pcur->CURSORF_flags & CURSORF_ACONFRAME)) {
        PPROCESSINFO ppi = pcur->head.ppi;
        if (ppi == NULL) {
            /*
             * Public cache object.
             */
            pcur->pcurNext    = gpcurFirst;
            gpcurFirst        = pcur;
            pcur->CURSORF_flags |= CURSORF_LINKED;
        } else if (pcur->CURSORF_flags & CURSORF_LRSHARED) {
            /*
             * Private cache LR_SHARED object.
             */
            pcur->pcurNext    = ppi->pCursorCache;
            ppi->pCursorCache = pcur;
            pcur->CURSORF_flags |= CURSORF_LINKED;
        }
    }
}


/***************************************************************************\
*
* Examines the source bitmap to see if it supports and uses an alpha
* channel.  If it does, a new DIB section is created that contains a
* premultiplied copy of the data from the source bitmap.
*
* If the source bitmap is not capable of supporting, or simply doesn't use,
* an alpha channel, the return value is NULL.
*
* If an error occurs, the return value is NULL.
*
* 8/10/1995 Created DwayneN
*
\***************************************************************************/
HBITMAP ProcessAlphaBitmap(HBITMAP hbmSource) {
    BITMAP bmp;
    BITMAPINFO bi;
    HBITMAP hbmAlpha;
    RGBQUAD * pAlphaBitmapBits;
    DWORD cPixels;
    DWORD i;
    RGBQUAD pixel;
    BOOL fAlphaChannel;

    /*
     * There are several code paths that end up calling us with a NULL
     * hbmSource.  This is fine, in that it simply indicates that there
     * is no alpha channel.
     */
    if (hbmSource == NULL) {
        return NULL;
    }

    if (GreExtGetObjectW(hbmSource, sizeof(BITMAP), &bmp) == 0) {
        return NULL;
    }

    /*
     * Only single plane, 32bpp bitmaps can even contain an alpha channel.
     */
    if (bmp.bmPlanes != 1 ||
        bmp.bmBitsPixel != 32) {
        return NULL;
    }

    /*
     * Allocate room to hold the source bitmap's bits for examination.
     * We actually allocate a DIB - that will be passed out if the
     * source bitmap does indeed contain an alpha channel.
     */
    RtlZeroMemory(&bi, sizeof(bi));
    bi.bmiHeader.biSize        = sizeof(BITMAPINFOHEADER);
    bi.bmiHeader.biWidth       = bmp.bmWidth;
    bi.bmiHeader.biHeight      = bmp.bmHeight;
    bi.bmiHeader.biPlanes      = 1;
    bi.bmiHeader.biBitCount    = 32;
    bi.bmiHeader.biCompression = BI_RGB;

    hbmAlpha = GreCreateDIBitmapReal(gpDispInfo->hdcScreen,
                                     0,
                                     NULL,
                                     (LPBITMAPINFO)&bi,
                                     DIB_RGB_COLORS,
                                     sizeof(bi),
                                     0,
                                     NULL,
                                     0,
                                     NULL,
                                     0,
                                     0,
                                     &pAlphaBitmapBits);

    if (NULL != hbmAlpha) {
        /*
         * Set up the header again in case it was tweaked by GreCreateDIBitmapReal.
         */
        RtlZeroMemory(&bi, sizeof(bi));
        bi.bmiHeader.biSize        = sizeof(BITMAPINFOHEADER);
        bi.bmiHeader.biWidth       = bmp.bmWidth;
        bi.bmiHeader.biHeight      = bmp.bmHeight;
        bi.bmiHeader.biPlanes      = 1;
        bi.bmiHeader.biBitCount    = 32;
        bi.bmiHeader.biCompression = BI_RGB;

        /*
         * Copy the bitmap data from the source bitmap into our alpha DIB.
         */
        if( 0 == GreGetDIBitsInternal(gpDispInfo->hdcScreen,
                                      hbmSource,
                                      0,
                                      bi.bmiHeader.biHeight,
                                      (LPBYTE) pAlphaBitmapBits,
                                      (LPBITMAPINFO)&bi,
                                      DIB_RGB_COLORS,
                                      BITMAPWIDTHSIZE(bi.bmiHeader.biWidth, bi.bmiHeader.biHeight,1,32),
                                      bi.bmiHeader.biSize) ) {
            GreDeleteObject(hbmAlpha);
            return NULL;
        }

        /*
         * We need to examine the source bitmap to see if it contains an alpha
         * channel.  This is simply a heuristic since there is no format difference
         * between 32bpp 888 RGB image and 32bpp 8888 ARGB image.  What we do is look
         * for any non-0 alpha/reserved values.  If all alpha/reserved values are 0,
         * then the image would be 100% invisible if blitted with alpha - which is
         * almost cerainly not the desired result.  So we assume such bitmaps are
         * 32bpp non-alpha.
         */
        cPixels  = bi.bmiHeader.biWidth * bi.bmiHeader.biHeight;
        fAlphaChannel = FALSE;
        for (i = 0; i < cPixels; i++) {
            if (pAlphaBitmapBits[i].rgbReserved != 0)
            {
                fAlphaChannel = TRUE;
                break;
            }
        }

        if (fAlphaChannel == FALSE) {
            GreDeleteObject(hbmAlpha);
            return NULL;
        }

        /*
         * The source bitmap appears to use an alpha channel.  Spin through our
         * copy of the bits and premultiply them.  This is a necessary step to
         * prepare an alpha bitmap for use by GDI.
         */
        for (i=0; i < cPixels; i++) {
            pixel = pAlphaBitmapBits[i];

            pAlphaBitmapBits[i].rgbRed = (pixel.rgbRed * pixel.rgbReserved) / 0xFF;
            pAlphaBitmapBits[i].rgbGreen = (pixel.rgbGreen * pixel.rgbReserved) / 0xFF;
            pAlphaBitmapBits[i].rgbBlue = (pixel.rgbBlue * pixel.rgbReserved) / 0xFF;
        }
    }

    return hbmAlpha;
}

/***************************************************************************\
*
* Initializes empty cursor/icons.  Note that the string buffers and
* pcurData are not captured.  If a fault occurs in this routine,
* all allocated memory will be freed when the cursors are destroyed.
*
* Critical side effect:  If this function fails, the bitmaps must NOT
* have been made public.  (See CreateIconIndirect()).
*
* History:
* 12-01-94 JimA         Created.
\***************************************************************************/

BOOL _SetCursorIconData(
    PCURSOR pcur,
    PUNICODE_STRING cczpstrModName,
    PUNICODE_STRING cczpstrName,
    PCURSORDATA pcurData,
    DWORD cbData)
{
#define pacon ((PACON)pcur)
    int i;
#if DBG
    BOOL fSuccess;
#endif

    pcur->CURSORF_flags |= pcurData->CURSORF_flags;
    pcur->rt = pcurData->rt;

    if (pcurData->CURSORF_flags & CURSORF_ACON) {
        UserAssert(pacon->aspcur == NULL);
        RtlCopyMemory(&pacon->cpcur,
                      &pcurData->cpcur,
                      sizeof(ACON) - FIELD_OFFSET(ACON, cpcur));
    } else {
        RtlCopyMemory(&pcur->CI_COPYSTART,
                      &pcurData->CI_COPYSTART,
                      sizeof(CURSOR) - FIELD_OFFSET(CURSOR, CI_COPYSTART));
    }

    /*
     * Save name of the cursor resource
     */
    if (cczpstrName->Length != 0){
        /*
         * AllocateUnicodeString guards access to src Buffer with
         * a try block.
         */

        if (!AllocateUnicodeString(&pcur->strName, cczpstrName))
            return FALSE;
    } else {
        pcur->strName = *cczpstrName;
    }

    /*
     * Save the module name
     */
    if (cczpstrModName->Buffer) {
        /*
         * UserAddAtom guards access to the string with a try block.
         */
        pcur->atomModName = UserAddAtom(cczpstrModName->Buffer, FALSE);
        if (pcur->atomModName == 0) {
            return FALSE;
        }
    }

    if (pcur->CURSORF_flags & CURSORF_ACON) {

        /*
         * Stash away animated icon info.
         */
        pacon = (PACON)pcur;
        pacon->aspcur = UserAllocPool(cbData, TAG_CURSOR);
        if (pacon->aspcur == NULL)
            return FALSE;

        /*
         * Copy the handle array.  Do this in a try/except so the
         * buffer will be freed if pcurData goes away.  Even though
         * cursor destruction would free the array, a fault will
         * leave the contents in an undetermined state and cause
         * problems during cursor destruction.
         */
        try {
            RtlCopyMemory(pacon->aspcur, pcurData->aspcur, cbData);
            pacon->aicur = (DWORD *)((PBYTE)pacon->aspcur + (ULONG_PTR)pcurData->aicur);
            pacon->ajifRate = (PJIF)((PBYTE)pacon->aspcur + (ULONG_PTR)pcurData->ajifRate);
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
            UserFreePool(pacon->aspcur);
            pacon->aspcur = NULL;
            return FALSE;
        }

        /*
         * Convert handles into pointers and lock them in.
         */
        for (i = 0; i < pacon->cpcur; i++) {
            PCURSOR pcurT;

            pcurT = (PCURSOR) HMValidateHandle(pacon->aspcur[i], TYPE_CURSOR);
            if (pcurT) {
                pacon->aspcur[i] = NULL;
                Lock(&pacon->aspcur[i], pcurT);
            } else {
                while (--i >= 0) {
                    Unlock(&pacon->aspcur[i]);
                }

                UserFreePool(pacon->aspcur);
                pacon->aspcur = NULL;
                RIPMSG0(RIP_WARNING, "SetCursorIconData: invalid cursor handle for animated cursor");
                return FALSE;
            }
        }
    } else {
        PW32PROCESS W32Process = W32GetCurrentProcess();

        /*
         * If the icon's color bitmap has an alpha channel, pre-process it
         * and cache it in our hbmUserAlpha field.
         */
        pcur->hbmUserAlpha = ProcessAlphaBitmap(pcur->hbmColor);

        /*
         * Make the cursor and its bitmaps public - LAST THING!
         */
        UserAssert(pcur->hbmMask);
        UserAssert(pcur->cx);
        UserAssert(pcur->cy);

        /*
         * Make the cursor public so that it can be shared across processes.
         * Charge the curson to this very process GDI quota even if it's public.
         */
#if DBG
        fSuccess =
#endif
        GreSetBitmapOwner(pcur->hbmMask, OBJECT_OWNER_PUBLIC);
        UserAssert(fSuccess);
        GreIncQuotaCount(W32Process);
        if (pcur->hbmColor) {
#if DBG
            fSuccess =
#endif
            GreSetBitmapOwner(pcur->hbmColor, OBJECT_OWNER_PUBLIC);
            UserAssert(fSuccess);
            GreIncQuotaCount(W32Process);
        }
        if (pcur->hbmUserAlpha != NULL) {
#if DBG
            fSuccess =
#endif
            GreSetBitmapOwner(pcur->hbmUserAlpha, OBJECT_OWNER_PUBLIC);
            UserAssert(fSuccess);
            GreIncQuotaCount(W32Process);
        }
    }

    LinkCursor(pcur);

    return TRUE;
#undef pacon
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\base.c ===
/****************************** Module Header ******************************\
* Module Name: base.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Contains private versions of routines that used to be in kernel32.dll
*
* History:
* 12-16-94 JimA         Created.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include <ntddbeep.h>


                          
/***************************************************************************\
* RtlLoadStringOrError
*
* NOTE: Passing a NULL value for lpch returns the string length. (WRONG!)
*
* Warning: The return count does not include the terminating NULL WCHAR;
*
* History:
* 04-05-91 ScottLu      Fixed - code is now shared between client and server
* 09-24-90 MikeKe       From Win30
* 12-09-94 JimA         Use message table.
\***************************************************************************/

int RtlLoadStringOrError(
    UINT wID,
    LPWSTR lpBuffer,            // Unicode buffer
    int cchBufferMax,           // cch in Unicode buffer
    WORD wLangId)
{
    PMESSAGE_RESOURCE_ENTRY MessageEntry;
    int cch;
    NTSTATUS Status;

    /*
     * Make sure the parms are valid.
     */
    if (!lpBuffer || (cchBufferMax-- == 0))
        return 0;

    cch = 0;

    Status = RtlFindMessage((PVOID)hModuleWin, (ULONG_PTR)RT_MESSAGETABLE,
            wLangId, wID, &MessageEntry);
    if (NT_SUCCESS(Status)) {

        /*
         * Copy out the message.  If the whole thing can be copied,
         * copy two fewer chars so the crlf in the message will be
         * stripped out.
         */
        cch = wcslen((PWCHAR)MessageEntry->Text) - 2;
        if (cch > cchBufferMax)
            cch = cchBufferMax;

        RtlCopyMemory(lpBuffer, (PWCHAR)MessageEntry->Text, cch * sizeof(WCHAR));
    }

    /*
     * Append a NULL.
     */
    lpBuffer[cch] = 0;

    return cch;
}


/***************************************************************************\
* UserSleep
*
* Kernel-mode version of Sleep() that must have a timeout value and
* is not alertable.
*
* History:
* 12-11-94 JimA         Created.
\***************************************************************************/

VOID UserSleep(
    DWORD dwMilliseconds)
{
    LARGE_INTEGER TimeOut;

    TimeOut.QuadPart = Int32x32To64( dwMilliseconds, -10000 );
    KeDelayExecutionThread(UserMode, FALSE, &TimeOut);
}


/***************************************************************************\
* UserBeep
*
* Kernel-mode version of Beep().
*
* History:
* 12-16-94 JimA         Created.
\***************************************************************************/

BOOL UserBeep(
    DWORD dwFreq,
    DWORD dwDuration)
{
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING NameString;
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatus;
    BEEP_SET_PARAMETERS BeepParameters;
    HANDLE hBeepDevice;
    LARGE_INTEGER TimeOut;

    CheckCritOut();
  
    if (IsRemoteConnection()) {
        if (gpRemoteBeepDevice == NULL)
            Status = STATUS_UNSUCCESSFUL;
        else
            Status = ObOpenObjectByPointer(
                          gpRemoteBeepDevice,
                          0,
                          NULL,
                          EVENT_ALL_ACCESS,
                          NULL,
                          KernelMode,
                          &hBeepDevice);
    } else {
        
        RtlInitUnicodeString(&NameString, DD_BEEP_DEVICE_NAME_U);
        
        InitializeObjectAttributes(&ObjectAttributes,
                                   &NameString,
                                   0,
                                   NULL,
                                   NULL);
        
        Status = ZwCreateFile(&hBeepDevice,
                              FILE_READ_DATA | FILE_WRITE_DATA,
                              &ObjectAttributes,
                              &IoStatus,
                              NULL,
                              0,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              FILE_OPEN_IF,
                              0,
                              (PVOID) NULL,
                              0L);
    }
    
    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }

    /*
     * 0,0 is a special case used to turn off a beep.  Otherwise
     * validate the dwFreq parameter to be in range.
     */
    if ((dwFreq != 0 || dwDuration != 0) &&
        (dwFreq < (ULONG)0x25 || dwFreq > (ULONG)0x7FFF)) {
        
        Status = STATUS_INVALID_PARAMETER;
    } else {
        BeepParameters.Frequency = dwFreq;
        BeepParameters.Duration = dwDuration;

        Status = ZwDeviceIoControlFile(hBeepDevice,
                                       NULL,
                                       NULL,
                                       NULL,
                                       &IoStatus,
                                       IOCTL_BEEP_SET,
                                       &BeepParameters,
                                       sizeof(BeepParameters),
                                       NULL,
                                       0);
    }

    EnterCrit();
    _UserSoundSentryWorker();
    LeaveCrit();

    if (!NT_SUCCESS(Status)) {
        ZwClose(hBeepDevice);
        return FALSE;
    }
    
    /*
     * Beep device is asynchronous, so sleep for duration
     * to allow this beep to complete.
     */
    if (dwDuration != (DWORD)-1 && (dwFreq != 0 || dwDuration != 0)) {
        TimeOut.QuadPart = Int32x32To64( dwDuration, -10000);
        
        do {
            Status = KeDelayExecutionThread(UserMode, FALSE, &TimeOut);
        }
        while (Status == STATUS_ALERTED);
    }
    ZwClose(hBeepDevice);
    return TRUE;
}

void RtlInitUnicodeStringOrId(
    PUNICODE_STRING pstrName,
    LPWSTR lpstrName)
{
    if (IS_PTR(lpstrName)) {
        RtlInitUnicodeString(pstrName, lpstrName);
    } else {
        pstrName->Length = pstrName->MaximumLength = 0;
        pstrName->Buffer = lpstrName;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\capture.c ===
/****************************** Module Header ******************************\
* Module Name: capture.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* History:
* 08-Nov-1990 DavidPe   Created.
* 01-Feb-1991 MikeKe    Added Revalidation code
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* xxxSetCapture (API)
*
* This function sets the capture window for the current queue.
*
* History:
* 08-Nov-1990 DavidPe   Created.
\***************************************************************************/

PWND xxxSetCapture(
    PWND pwnd)
{
    PQ   pq;
    PWND pwndCaptureOld;
    HWND hwndCaptureOld;
    PTHREADINFO  ptiCurrent = PtiCurrent();

    pq = (PQ)PtiCurrent()->pq;

    /*
     * If the capture is locked, bail
     */
    if (pq->QF_flags & QF_CAPTURELOCKED) {
        RIPMSG2(RIP_WARNING, "xxxSetCapture(%#p): Capture is locked. pq:%#p", pwnd, pq);
        return NULL;
    }

    /*
     * Don't allow the app to set capture to a window
     * from another queue.
     */
    if ((pwnd != NULL) && GETPTI(pwnd)->pq != pq)
        return NULL;

    /*
     * If full screen capture don't allow any other capture
     */
    if (gspwndScreenCapture)
        return NULL;

    pwndCaptureOld = pq->spwndCapture;
    hwndCaptureOld = HW(pwndCaptureOld);

    xxxCapture(ptiCurrent, pwnd, CLIENT_CAPTURE);

    if (hwndCaptureOld != NULL) {

        if (RevalidateHwnd(hwndCaptureOld))
            return pwndCaptureOld;
    }

    return NULL;
}

/***************************************************************************\
* xxxReleaseCapture (API)
*
* This function release the capture for the current queue.
*
* History:
* 08-Nov-1990 DavidPe   Created.
* 16-May-1991 MikeKe    Changed to return BOOL
\***************************************************************************/

BOOL xxxReleaseCapture(VOID)
{
    PTHREADINFO ptiCurrent = PtiCurrent();
    /*
     * If the capture is locked, bail
     */
    if (ptiCurrent->pq->QF_flags & QF_CAPTURELOCKED) {
        RIPMSG0(RIP_WARNING, "xxxReleaseCapture: Capture is locked");
        return FALSE;
    }

    /*
     * If we're releasing the capture from a window during tracking,
     * cancel tracking first.
     */
    if (ptiCurrent->pmsd != NULL) {

        /*
         * Only remove the tracking rectangle if it's
         * been made visible.
         */
        if (ptiCurrent->TIF_flags & TIF_TRACKRECTVISIBLE) {

            bSetDevDragRect(gpDispInfo->hDev, NULL, NULL);

            if (!(ptiCurrent->pmsd->fDragFullWindows))
                xxxDrawDragRect(ptiCurrent->pmsd, NULL, DDR_ENDCANCEL);

            ptiCurrent->TIF_flags &= ~(TIF_TRACKRECTVISIBLE | TIF_MOVESIZETRACKING);
        }
    }

    xxxCapture(ptiCurrent, NULL, NO_CAP_CLIENT);

    return TRUE;
}

/***************************************************************************\
* xxxCapture
*
* This is the workhorse routine of capture setting and releasing.
*
* History:
* 13-Nov-1990 DavidPe   Created.
\***************************************************************************/

VOID xxxCapture(
    PTHREADINFO pti,
    PWND        pwnd,
    UINT        code)
{
    CheckLock(pwnd);
    UserAssert(IsWinEventNotifyDeferredOK());

    if ((gspwndScreenCapture == NULL) ||
        (code == FULLSCREEN_CAPTURE) ||
        ((pwnd == NULL) && (code == NO_CAP_CLIENT) && (pti->pq != GETPTI(gspwndScreenCapture)->pq))) {

        PQ   pq;
        PWND pwndCaptureOld = NULL;

        if (code == FULLSCREEN_CAPTURE) {
            if (pwnd) {

                Lock(&gspwndScreenCapture, pwnd);

                /*
                 * We're going full screen so clear the mouse owner
                 */
                Unlock(&gspwndMouseOwner);

            } else {

                Unlock(&gspwndScreenCapture);
            }
        }

        /*
         * Internal capture works like Win 3.1 capture unlike the NT capture
         * which can be lost if the user clicks down on another application
         */
        if (code == CLIENT_CAPTURE_INTERNAL) {
            Lock(&gspwndInternalCapture, pwnd);
            code = CLIENT_CAPTURE;
        }

        /*
         * Free the internal capture if the app (thread) that did the internal
         * capture is freeing the capture.
         */
        if ((code == NO_CAP_CLIENT) &&
            gspwndInternalCapture   &&
            (pti == GETPTI(gspwndInternalCapture))) {

            Unlock(&gspwndInternalCapture);
        }

        if ((pq = pti->pq) != NULL) {
            PDESKTOP pdesk = pti->rpdesk;

#if DBG
            if (pq->QF_flags & QF_CAPTURELOCKED) {
                RIPMSG1(RIP_WARNING, "pq %p already has QF_CAPTURELOCKED", pq);
            }
#endif

            /*
             * If someone is tracking mouse events in the client area and
             *  we're setting or releasing an internal capture mode (!= CLIENT_CAPTURE),
             *  then cancel tracking -- because we're either taking or relinquishing
             *  control over the mouse.
             */
            if ((pdesk->dwDTFlags & DF_TRACKMOUSEEVENT)
                    && (pdesk->htEx == HTCLIENT)
                    && ((pdesk->spwndTrack == pwnd)
                            && (code != CLIENT_CAPTURE)
                         || ((pdesk->spwndTrack == pq->spwndCapture)
                             && (pq->codeCapture != CLIENT_CAPTURE)))) {

                BEGINATOMICCHECK();
                xxxCancelMouseMoveTracking(pdesk->dwDTFlags, pdesk->spwndTrack,
                                           pdesk->htEx, DF_TRACKMOUSEEVENT);
                ENDATOMICCHECK();

            }

            pwndCaptureOld = pq->spwndCapture;
            LockCaptureWindow(pq, pwnd);
            pq->codeCapture = code;
        } else {
            /*
             * A thread without a queue?
             */
            UserAssert(pti->pq != NULL);
        }

        /*
         * If there was a capture window and we're releasing it, post
         * a WM_MOUSEMOVE to the window we're over so they can know about
         * the current mouse position.
         * Defer WinEvent notifications to protect pwndCaptureOld
         */
        DeferWinEventNotify();
        
        if (pwnd == NULL && pwndCaptureOld != NULL) {
#ifdef REDIRECTION
            if (!IsGlobalHooked(pti, WHF_FROM_WH(WH_HITTEST)))
#endif
                zzzSetFMouseMoved();
        }
        
        if (pwndCaptureOld) {
            zzzWindowEvent(EVENT_SYSTEM_CAPTUREEND, pwndCaptureOld, OBJID_WINDOW,
                    INDEXID_CONTAINER, WEF_USEPWNDTHREAD);
        }

        if (pwnd) {
            zzzWindowEvent(EVENT_SYSTEM_CAPTURESTART, pwnd, OBJID_WINDOW,
                    INDEXID_CONTAINER, WEF_USEPWNDTHREAD);
        }

        /*
         * New for win95 - send  WM_CAPTURECHANGED.
         *
         * The FNID_DELETED_BIT is set in xxxFreeWindow which means we
         * DON'T want to send the message.
         */
        if (pwndCaptureOld                        &&
            TestWF(pwndCaptureOld, WFWIN40COMPAT) &&
            !(pwndCaptureOld->fnid & FNID_DELETED_BIT)) {

            TL tlpwnd;

            /*
             * If we are in menu mode and just set capture,
             *  don't let them take it from us during this
             *  callback.
             */
            if ((pti->pMenuState != NULL) && (pwnd != NULL)) {
                pq->QF_flags |= QF_CAPTURELOCKED;
            }

            ThreadLockAlways(pwndCaptureOld, &tlpwnd);
            zzzEndDeferWinEventNotify();
            xxxSendMessageCallback(pwndCaptureOld,
                    WM_CAPTURECHANGED,
                    FALSE,
                    (LPARAM)HW(pwnd),
                    NULL,
                    0,
                    FALSE);
            /* The thread's queue may have changed during the callback,
             * so we need to refresh the local. Bug #377795
             */
            pq = pti->pq;
            UserAssert(pq != NULL);
            ThreadUnlock(&tlpwnd);

            /*
             * Release the temporary lock, if any
             */
            pq->QF_flags &= ~QF_CAPTURELOCKED;
        } else {
            zzzEndDeferWinEventNotify();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\caret.c ===
/****************************** Module Header ******************************\
* Module Name: caret.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Caret code. Every thread has a caret in its queue structure.
*
* History:
* 11-17-90 ScottLu      Created.
* 01-Feb-1991 mikeke    Added Revalidation code (None)
* 02-12-91 JimA         Added access checks
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop




/***************************************************************************\
* UT_CaretSet
*
* Checks to see if the current queue has a caret. If pwnd != NULL, check
* to see if the caret is for pwnd.
*
* History:
* 11-17-90 ScottLu      Ported.
\***************************************************************************/

BOOL UT_CaretSet(
    PWND pwnd)
{
    PQ pq;
    PTHREADINFO ptiCurrent;

    /*
     * Current queue have a caret? If not, return FALSE.
     */
    ptiCurrent = PtiCurrent();
    pq = ptiCurrent->pq;

    if (pq->caret.spwnd == NULL) {
        RIPERR0(ERROR_ACCESS_DENIED,
                RIP_VERBOSE,
                "Access denied in UT_CaretSet to current queue's caret");

        return FALSE;
    }

    /*
     * If the current task does not own the caret, then return FALSE
     * but we let 32 bit multithreaded apps set the caret position from
     * a second thread for compatibility to our NT 3.1 BETAs
     */
    if (pq->caret.tid != TIDq(ptiCurrent)) {
        PTHREADINFO ptiCursorOwner;

        ptiCursorOwner = PtiFromThreadId(pq->caret.tid);

        if ((ptiCurrent->TIF_flags & TIF_16BIT) || ptiCursorOwner == NULL ||
                (ptiCurrent->ppi != ptiCursorOwner->ppi))  {
            RIPERR0(ERROR_ACCESS_DENIED,
                    RIP_VERBOSE,
                    "Access denied in UT_CaretSet");

            return FALSE;
        }
    }

    /*
     * If pwnd == NULL, just checking to see if current queue has caret.
     * It does, so return TRUE.
     */
    if (pwnd == NULL)
        return TRUE;

    /*
     * pwnd != NULL.  Check to see if the caret is for pwnd.  If so, return
     * TRUE.
     */
    if (pwnd == pq->caret.spwnd)
        return TRUE;

    return FALSE;
}

/***************************************************************************\
* UT_InvertCaret
*
* Invert the caret.
*
* History:
* 11-17-90 ScottLu      Ported.
\***************************************************************************/

void UT_InvertCaret()
{
    HDC hdc;
    PWND pwnd;
    PQ pq;
    HBITMAP hbmSave;
    BOOL fRestore;

    pq = PtiCurrent()->pq;
    pwnd = pq->caret.spwnd;


    if (pwnd == NULL || !IsVisible(pwnd)) {
        pq->caret.fVisible = FALSE;
        return;
    }

    /*
     * Don't have a dc.  Get one for this window and draw the caret.
     */
    hdc = _GetDC(pwnd);

    if (fRestore = (pwnd->hrgnUpdate ? TRUE : FALSE)) {
        GreSaveDC(hdc);
        if (TestWF(pwnd, WFWIN31COMPAT))
            _ExcludeUpdateRgn(hdc, pwnd);
    }

    /*
     * If the caret bitmap is NULL, the caret is a white pattern invert
     * If the caret bitmap is == 1, the caret is a gray pattern.
     * If the caret bitmap is  > 1, the caret is really a bitmap.
     */
    if ((pq->caret.hBitmap) > (HBITMAP)1) {

        /*
         * The caret is a bitmap...  SRCINVERT it onto the screen.
         */
        hbmSave = GreSelectBitmap(ghdcMem, pq->caret.hBitmap);
        GreBitBlt(hdc, pq->caret.x, pq->caret.y, pq->caret.cx,
              pq->caret.cy, ghdcMem, 0, 0, SRCINVERT, 0);

        GreSelectBitmap(ghdcMem, hbmSave);

    } else {

        POLYPATBLT PolyData;

        /*
         * The caret is a pattern (gray or white).  PATINVERT it onto the
         * screen.  Remember to unrealize the gray object so it aligns
         * to the window correctly.
         *
         * Remove call to UnrealizeObject.  GDI handles this on NT for
         * brushes.
         *
         * UnrealizeObject(hbrGray);
         */
        PolyData.x  = pq->caret.x;
        PolyData.y  = pq->caret.y;
        PolyData.cx = pq->caret.cx;
        PolyData.cy = pq->caret.cy;

        if ((pq->caret.hBitmap) == (HBITMAP)1) {
            //hbrSave = GreSelectBrush(hdc, ghbrGray);
            PolyData.BrClr.hbr = gpsi->hbrGray;
        } else {
            //hbrSave = GreSelectBrush(hdc, ghbrWhite);
            PolyData.BrClr.hbr = ghbrWhite;
        }

        GrePolyPatBlt(hdc,PATINVERT,&PolyData,1,PPB_BRUSH);

        //GrePatBlt(hdc, pq->caret.x, pq->caret.y, pq->caret.cx, pq->caret.cy,
        //        PATINVERT);
        //
        //GreSelectBrush(hdc,hbrSave);
    }

    if (fRestore)
        GreRestoreDC(hdc, -1);

    _ReleaseDC(hdc);
}


/***************************************************************************\
* zzzInternalDestroyCaret
*
* Internal routine for killing the caret for this thread.
*
* History:
* 11-17-90 ScottLu      Ported
\***************************************************************************/

void zzzInternalDestroyCaret()
{
    PQ pq;
    PTHREADINFO ptiCurrent = PtiCurrent();
    PWND pwndCaret;
    TL tlpwndCaret;

    /*
     * Hide the caret, kill the timer, and null out the caret structure.
     */
    zzzInternalHideCaret();
    pq = ptiCurrent->pq;
    _KillSystemTimer(pq->caret.spwnd, IDSYS_CARET);

    pq->caret.hTimer = 0;
    pq->caret.hBitmap = NULL;
    pq->caret.iHideLevel = 0;

    pwndCaret = pq->caret.spwnd;
    if (pwndCaret != NULL) {
        /*
         * Threadlock caret's spwnd for WinEvent notification below
         */
        ThreadLockWithPti(ptiCurrent, pwndCaret, &tlpwndCaret);
        Unlock(&pq->caret.spwnd);

        zzzWindowEvent(EVENT_OBJECT_DESTROY, pwndCaret, OBJID_CARET, INDEXID_CONTAINER, 0);

        ThreadUnlock(&tlpwndCaret);
    }
}


/***************************************************************************\
* zzzDestroyCaret
*
* External api for destroying the caret of the current thread.
*
* History:
* 11-17-90 ScottLu      Ported.
* 16-May-1991 mikeke    Changed to return BOOL
\***************************************************************************/

BOOL zzzDestroyCaret()
{
    if (UT_CaretSet(NULL)) {
        zzzInternalDestroyCaret();
        return TRUE;
    }
    return FALSE;
}


/***************************************************************************\
* xxxCreateCaret
*
* External api for creating the caret.
*
* History:
* 11-17-90 ScottLu      Ported.
* 16-May-1991 mikeke    Changed to return BOOL
\***************************************************************************/

BOOL xxxCreateCaret(
    PWND pwnd,
    HBITMAP hBitmap,
    int cx,
    int cy)
{
    PQ pq;
    BITMAP bitmap;
    PTHREADINFO  ptiCurrent = PtiCurrent();

    CheckLock(pwnd);
    UserAssert(IsWinEventNotifyDeferredOK());

    pq = ptiCurrent->pq;

    /*
     * Don't allow the app to create a caret in a window
     * from another queue.
     */
    if (GETPTI(pwnd)->pq != pq) {
        return FALSE;
    }

    /*
     * Defer WinEvent notifications to preserve pq
     */
    DeferWinEventNotify();

    if (pq->caret.spwnd != NULL)
        zzzInternalDestroyCaret();

    Lock(&pq->caret.spwnd, pwnd);
    pq->caret.iHideLevel = 1;
    pq->caret.fOn = TRUE;
    pq->caret.fVisible = FALSE;
    pq->caret.tid = TIDq(ptiCurrent);

    if (cy == 0)
        cy = SYSMET(CYBORDER);
    if (cx == 0)
        cx = SYSMET(CXBORDER);

    if ((pq->caret.hBitmap = hBitmap) > (HBITMAP)1) {
        GreExtGetObjectW(hBitmap, sizeof(BITMAP), &bitmap);
        cy = bitmap.bmHeight;
        cx = bitmap.bmWidth;
    }

    pq->caret.cy = cy;
    pq->caret.cx = cx;

    pq->caret.hTimer = _SetSystemTimer(pwnd, IDSYS_CARET, gpsi->dtCaretBlink,
            CaretBlinkProc);

    UserAssert(pwnd == pq->caret.spwnd);
    zzzEndDeferWinEventNotify();
    
    /*
     * It's best to force this routine to be an xxx routine: that way we can
     * force pwnd to be locked and force notifications from within this routine
     * and all of the callers are happy with this.
     */
    xxxWindowEvent(EVENT_OBJECT_CREATE, pwnd, OBJID_CARET, INDEXID_CONTAINER, 0);

    return TRUE;
}

/***************************************************************************\
* zzzInternalShowCaret
*
* Internal routine for showing the caret for this thread.
*
* History:
* 11-17-90 ScottLu      Ported.
\***************************************************************************/

void zzzInternalShowCaret()
{
    PQ pq;
    PTHREADINFO ptiCurrent = PtiCurrent();

    pq = ptiCurrent->pq;

    /*
     * If the caret hide level is aleady 0 (meaning it's ok to show) and the
     * caret is not physically on, try to invert now if it's turned on.
     */
    if (pq->caret.iHideLevel == 0) {
        if (!pq->caret.fVisible) {
            if ((pq->caret.fVisible = pq->caret.fOn) != 0) {
                UT_InvertCaret();
            }
        }
        return;
    }

    /*
     * Adjust the hide caret hide count.  If we hit 0, we can show the
     * caret.  Try to invert it if it's turned on.
     */

    if (--pq->caret.iHideLevel == 0) {
        if ((pq->caret.fVisible = pq->caret.fOn) != 0)
            UT_InvertCaret();

        zzzWindowEvent(EVENT_OBJECT_SHOW, pq->caret.spwnd, OBJID_CARET, INDEXID_CONTAINER, 0);
    }
}


/***************************************************************************\
* zzzInternalHideCaret
*
* Internal routine for hiding the caret.
*
* History:
* 11-17-90 ScottLu      Created.
\***************************************************************************/

void zzzInternalHideCaret()
{
    PQ pq;
    PTHREADINFO ptiCurrent = PtiCurrent();

    pq = ptiCurrent->pq;

    /*
     * If the caret is physically visible, invert it to turn off the bits.
     * Adjust the hide count upwards to remember this hide level.
     */
    if (pq->caret.fVisible)
        UT_InvertCaret();

    pq->caret.fVisible = FALSE;
    pq->caret.iHideLevel++;

    /*
     * Is the caret transitioning to being hidden?  If so, iHideLevel is
     * going from 0 to 1.
     */
    if (pq->caret.iHideLevel == 1) {
        zzzWindowEvent(EVENT_OBJECT_HIDE, pq->caret.spwnd, OBJID_CARET, INDEXID_CONTAINER, 0);
    }
}


/***************************************************************************\
* zzzShowCaret
*
* External routine for showing the caret!
*
* History:
* 11-17-90 ScottLu      Ported.
* 16-May-1991 mikeke    Changed to return BOOL
\***************************************************************************/

BOOL zzzShowCaret(
    PWND pwnd)
{
    if (UT_CaretSet(pwnd)) {
        zzzInternalShowCaret();
        return TRUE;
    }
    return FALSE;
}


/***************************************************************************\
* zzzHideCaret
*
* External api to hide the caret!
*
* History:
* 11-17-90 ScottLu      Ported.
* 16-May-1991 mikeke    Changed to return BOOL
\***************************************************************************/

BOOL zzzHideCaret(
    PWND pwnd)
{
    if (UT_CaretSet(pwnd)) {
        zzzInternalHideCaret();
        return TRUE;
    }
    return FALSE;
}

/***************************************************************************\
* CaretBlinkProc
*
* This routine gets called by DispatchMessage when it gets the WM_SYSTIMER
* message - it blinks the caret.
*
* History:
* 11-17-90 ScottLu      Ported.
\***************************************************************************/

VOID CaretBlinkProc(
    PWND pwnd,
    UINT message,
    UINT_PTR id,
    LPARAM lParam)
{
    PQ pq;

    /*
     * If this window doesn't even have a timer, just return.  TRUE is
     * returned, which gets returned from DispatchMessage().  Why? Because
     * it is compatible with Win3.
     */
    pq = PtiCurrent()->pq;
    if (pwnd != pq->caret.spwnd)
        return;

    /*
     * leave caret on, don't blink it off for remote sessions
     */

    if ((((IsRemoteConnection()) && (gpsi->dtCaretBlink >= 1200)) || (gpsi->dtCaretBlink == (UINT)-1)) &&
        pq->caret.fOn && pq->caret.fVisible) {

        /*
         * Kill the timer for performance
         */
        _KillSystemTimer(pq->caret.spwnd, IDSYS_CARET);
        return;
    }

    /*
     * Flip the logical cursor state.  If the hide level permits it, flip
     * the physical state and draw the caret.
     */
    pq->caret.fOn ^= 1;
    if (pq->caret.iHideLevel == 0) {
        pq->caret.fVisible ^= 1;
        UT_InvertCaret();
    }

    return;

    DBG_UNREFERENCED_PARAMETER(message);
    DBG_UNREFERENCED_PARAMETER(id);
    DBG_UNREFERENCED_PARAMETER(lParam);
}


/***************************************************************************\
* _SetCaretBlinkTime
*
* Sets the system caret blink time.
*
* History:
* 11-17-90 ScottLu      Created.
* 02-12-91 JimA         Added access check
* 16-May-1991 mikeke    Changed to return BOOL
\***************************************************************************/

BOOL _SetCaretBlinkTime(
    UINT cmsBlink)
{
    PQ pq;
    PTHREADINFO  ptiCurrent = PtiCurrent();

    /*
     * Blow it off if the caller doesn't have the proper access rights
     */
    if (!CheckWinstaWriteAttributesAccess()) {
        return FALSE;
    }

    /*
     * Blow it off if this value is under policy control
     */
    if (CheckDesktopPolicy(NULL, (PCWSTR)STR_BLINK)) {
        return FALSE;
    }

    gpsi->dtCaretBlink = cmsBlink;

    pq = ptiCurrent->pq;

    if (pq->caret.spwnd) {
        _KillSystemTimer(pq->caret.spwnd, IDSYS_CARET);
        pq->caret.hTimer = _SetSystemTimer(pq->caret.spwnd, IDSYS_CARET,
            gpsi->dtCaretBlink, CaretBlinkProc);
    }

    return TRUE;
}


/***************************************************************************\
* zzzSetCaretPos
*
* External routine for setting the caret pos.
*
* History:
* 11-17-90 ScottLu      Ported.
* 02-12-91 JimA         Added access check
\***************************************************************************/

BOOL zzzSetCaretPos(
    int x,
    int y)
{
    PQ pq;
    PTHREADINFO  ptiCurrent = PtiCurrent();

    /*
     * If this thread does not have the caret set, return FALSE.
     */
    if (!UT_CaretSet(NULL)) {
        RIPERR0(ERROR_ACCESS_DENIED, RIP_VERBOSE, "Access denied in zzzSetCaretPos");
        return FALSE;
    }

    /*
     * If the caret isn't changing position, do nothing (but return success).
     */
    pq = ptiCurrent->pq;
    if (pq->caret.x == x && pq->caret.y == y)
        return TRUE;

    /*
     * For windows that have private DCs, we have to store the client coordinate
     * equivelent for the logical coordinate caret positioning.
     */
    if (pq->caret.spwnd != NULL &&
        pq->caret.spwnd->pcls->style & CS_OWNDC) {
        RECT rcOwnDcCaret;
        HDC hdc;

        rcOwnDcCaret.left = x;
        rcOwnDcCaret.top = y;
        rcOwnDcCaret.right = x + pq->caret.cx;
        rcOwnDcCaret.bottom = y + pq->caret.cy;

        hdc = _GetDC(pq->caret.spwnd);
        GreLPtoDP(hdc, (LPPOINT)(&rcOwnDcCaret), 2);
        _ReleaseDC(hdc);

        pq->caret.xOwnDc = rcOwnDcCaret.left;
        pq->caret.yOwnDc = rcOwnDcCaret.top;
        pq->caret.cxOwnDc = rcOwnDcCaret.right - rcOwnDcCaret.left;
        pq->caret.cyOwnDc = rcOwnDcCaret.bottom - rcOwnDcCaret.top;
    }

    /*
     * If the caret is visible, turn it off while we move it.
     */
    if (pq->caret.fVisible)
        UT_InvertCaret();

    /*
     * Adjust to the new position.
     */
    pq->caret.x = x;
    pq->caret.y = y;

    /*
     * Set a new timer so it'll blink in the new position dtCaretBlink
     * milliseconds from now.
     */
    _KillSystemTimer(pq->caret.spwnd, IDSYS_CARET);
    pq->caret.hTimer = _SetSystemTimer(pq->caret.spwnd, IDSYS_CARET,
            gpsi->dtCaretBlink, CaretBlinkProc);

    pq->caret.fOn = TRUE;

    /*
     * Draw it immediately now if the hide level permits it.
     */
    pq->caret.fVisible = FALSE;
    if (pq->caret.iHideLevel == 0) {
        pq->caret.fVisible = TRUE;
        UT_InvertCaret();
    }

    zzzWindowEvent(EVENT_OBJECT_LOCATIONCHANGE, pq->caret.spwnd, OBJID_CARET, INDEXID_CONTAINER, 0);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\calcclrc.c ===
/****************************** Module Header ******************************\
* Module Name: calcclrc.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* History:
* 10-22-90 MikeHar      Ported functions from Win 3.0 sources.
* 01-Feb-1991 mikeke    Added Revalidation code
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop


/***************************************************************************\
* xxxCalcClientRect
*
* 10-22-90 MikeHar      Ported function from Win 3.0 sources.
\***************************************************************************/
VOID xxxCalcClientRect(
    PWND pwnd,
    LPRECT lprc,
    BOOL fHungRedraw)
{
    int cxFrame, yTopOld, cBorders;
    RECT rcTemp;
    PMENU pMenu;
    TL tlpMenu;
    BOOL fEmptyClient;
    BYTE bFramePresent;

    CheckLock(pwnd);
    UserAssert(IsWinEventNotifyDeferredOK());

    bFramePresent = TestWF(pwnd, WFFRAMEPRESENTMASK);

    /*
     * Clear all the frame bits.  NOTE: The HIBYTE of all these #defines
     * must stay the same for this line to work.
     */
    ClrWF(pwnd, WFFRAMEPRESENTMASK);

    //
    // We need to clear the client border bits also. Otherwise, when the
    // window gets really small, the client border will draw over the menu
    // and caption.
    //
    ClrWF(pwnd, WFCEPRESENT);

    /*
     * If the window is iconic, the client area is empty.
     */
    if (TestWF(pwnd, WFMINIMIZED)) {
        //  SetRectEmpty(lprc);
      // We must make it an empty rectangle.
      // But, that empty rectangle should be at the top left corner of the
      // window rect. Else, ScreenToClient() will return bad values.
        lprc->right = lprc->left;
        lprc->bottom = lprc->top;
        goto CalcClientDone;
    }

    // Save rect into rcTemp for easy local calculations.
    CopyRect(&rcTemp, lprc);

    // Save the top so we'll know how tall the caption was
    yTopOld = rcTemp.top;

    // Adjustment for the caption
    if (TestWF(pwnd, WFBORDERMASK) == LOBYTE(WFCAPTION))
    {
        SetWF(pwnd, WFCPRESENT);

        rcTemp.top += GetCaptionHeight(pwnd);
    }

    // Subtract out window borders
    cBorders = GetWindowBorders(pwnd->style, pwnd->ExStyle, TRUE, FALSE);
    cxFrame = cBorders * SYSMETFROMPROCESS(CXBORDER);
    InflateRect(&rcTemp, -cxFrame, -cBorders * SYSMETFROMPROCESS(CYBORDER));

    if (!TestwndChild(pwnd) && (pMenu = pwnd->spmenu)) {
        SetWF(pwnd, WFMPRESENT);
        if (!fHungRedraw) {
            ThreadLockMenuAlwaysNoModify(pMenu, &tlpMenu);
            rcTemp.top += xxxMenuBarCompute(pMenu, pwnd, rcTemp.top - yTopOld,
                    cxFrame, rcTemp.right - rcTemp.left);
            ThreadUnlockMenuNoModify(&tlpMenu);
        }
    }

    /*
     * We should have cleared WFMPRESENT in the else case here. Win9x doesn't do
     *  it either. Any code checking this flag will do the wrong thing...
     * It seems that it's pretty unsual for apps to remove the menu....
     * No code checking this flag can assume that pwnd->spmenu is not NULL -- we
     *  would need to clear it way earlier (at unlock time) for such assumption to hold true.
     */

    //
    // Fix for B#1425 -- Sizing window really small used to move children's
    // rects because the client calculations were wrong.  So we make the
    // bottom of the client match up with the top (the bottom of the menu
    // bar).
    //
    fEmptyClient = FALSE;

    if (rcTemp.top >= rcTemp.bottom) {
        rcTemp.bottom = rcTemp.top;
        fEmptyClient = TRUE;
    }

    //
    // BOGUS BOGUS BOGUS
    // Hack for Central Point PC Tools.
    // Possibly for M5 only.
    // B#8445
    //
    // They check for div-by-zero all over, but they jump to the wrong place
    // if a zero divisor is encountered, and end up faulting anyway.  So this
    // code path was never tested basically.  There's a period when starting
    // up where the window rect of their drives ribbon is empty.  In Win3.x,
    // the client would be shrunk to account for the border it had, and it
    // would look like it wasn't empty because the width would be negative,
    // signed!  So we version-switch this code, since other apps have
    // reported the non-emptiness as an annoying bug.
    //
    if (TestWF(pwnd, WFWIN40COMPAT) && (rcTemp.left >= rcTemp.right)) {
        rcTemp.right = rcTemp.left;
        fEmptyClient = TRUE;
    }

    if (fEmptyClient) {
        goto ClientCalcEnd;
    }

    //
    // Subtract client edge if we have space
    //
    if (    TestWF(pwnd, WEFCLIENTEDGE) &&
            (rcTemp.right - rcTemp.left >= (2 * SYSMETFROMPROCESS(CXEDGE))) &&
            (rcTemp.bottom - rcTemp.top >= (2 * SYSMETFROMPROCESS(CYEDGE))) ) {
        SetWF(pwnd, WFCEPRESENT);
        InflateRect(&rcTemp, -SYSMETFROMPROCESS(CXEDGE), -SYSMETFROMPROCESS(CYEDGE));
    }

    //
    // Subtract scrollbars
    // Note compatibility with 3.1:
    //      * You don't get a horizontal scrollbar unless you have MORE
    //  space (> ) in your client than you need for one.
    //      * You get a vertical scrollbar if you have AT LEAST ENOUGH
    //  space (>=) in your client for one.
    //
    if (TestWF(pwnd, WFHSCROLL) && (rcTemp.bottom - rcTemp.top > SYSMETFROMPROCESS(CYHSCROLL))) {
        SetWF(pwnd, WFHPRESENT);
        if (!fHungRedraw) {
            rcTemp.bottom -= SYSMETFROMPROCESS(CYHSCROLL);
        }
    }

    if (TestWF(pwnd, WFVSCROLL) && (rcTemp.right - rcTemp.left >= SYSMETFROMPROCESS(CXVSCROLL))) {
        SetWF(pwnd, WFVPRESENT);
        if (!fHungRedraw) {
            if ((!!TestWF(pwnd, WEFLEFTSCROLL)) ^ (!!TestWF(pwnd, WEFLAYOUTRTL))) {
                rcTemp.left += SYSMETFROMPROCESS(CXVSCROLL);
            } else {
                rcTemp.right -= SYSMETFROMPROCESS(CXVSCROLL);
            }
        }
    }

ClientCalcEnd:

    CopyRect(lprc, &rcTemp);

CalcClientDone:
    if (bFramePresent != TestWF(pwnd, WFFRAMEPRESENTMASK)) {
        xxxWindowEvent(EVENT_OBJECT_REORDER, pwnd, OBJID_WINDOW, 0, WEF_USEPWNDTHREAD);
    }
}

/***************************************************************************\
* UpdateClientRect()
*
* Make sure the client rect reflects the window styles correctly.
*
* 10-22-90 MikeHar      Ported function from Win 3.0 sources.
\***************************************************************************/
VOID xxxUpdateClientRect(
    PWND pwnd)
{
    RECT rc;

    CopyRect(&rc, &pwnd->rcWindow);
    xxxCalcClientRect(pwnd, &rc, FALSE);
    CopyRect(&pwnd->rcClient, &rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\class.c ===
/****************************** Module Header ******************************\
* Module Name: class.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains RegisterClass and the related window class management
* functions.
*
* History:
* 10-16-90 DarrinM      Ported functions from Win 3.0 sources.
* 02-01-91 mikeke       Added Revalidation code (None)
* 04-08-91 DarrinM      C-S-ized and removed global/public class support.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*
 * These arrays are used by Get/SetClassWord/Long.
 *
 * INDEX_OFFSET must refer to the first entry of afClassDWord[]
 */
#define INDEX_OFFSET GCLP_HICONSM
CONST BYTE afClassDWord[-INDEX_OFFSET] = {
    FIELD_SIZE(CLS, spicnSm),          // GCL_HICONSM       (-34)
    0,
    FIELD_SIZE(CLS, atomNVClassName),  // GCW_ATOM          (-32)
    0,
    0,
    0,
    0,
    0,
    FIELD_SIZE(CLS, style),            // GCL_STYLE         (-26)
    0,
    FIELD_SIZE(CLS, lpfnWndProc),      // GCL_WNDPROC       (-24)
    0,
    0,
    0,
    FIELD_SIZE(CLS, cbclsExtra),       // GCL_CBCLSEXTRA    (-20)
    0,
    FIELD_SIZE(CLS, cbwndExtra),       // GCL_CBWNDEXTRA    (-18)
    0,
    FIELD_SIZE(CLS, hModule),          // GCL_HMODULE       (-16)
    0,
    FIELD_SIZE(CLS, spicn),            // GCL_HICON         (-14)
    0,
    FIELD_SIZE(CLS, spcur),            // GCL_HCURSOR       (-12)
    0,
    FIELD_SIZE(CLS, hbrBackground),    // GCL_HBRBACKGROUND (-10)
    0,
    FIELD_SIZE(CLS, lpszMenuName),     // GCL_HMENUNAME      (-8)
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

CONST BYTE aiClassOffset[-INDEX_OFFSET] = {
    FIELD_OFFSET(CLS, spicnSm),         // GCL_HICONSM
    0,
    FIELD_OFFSET(CLS, atomNVClassName),   // GCW_ATOM
    0,
    0,
    0,
    0,
    0,
    FIELD_OFFSET(CLS, style),           // GCL_STYLE
    0,
    FIELD_OFFSET(CLS, lpfnWndProc),     // GCL_WNDPROC
    0,
    0,
    0,
    FIELD_OFFSET(CLS, cbclsExtra),      // GCL_CBCLSEXTRA
    0,
    FIELD_OFFSET(CLS, cbwndExtra),      // GCL_CBWNDEXTRA
    0,
    FIELD_OFFSET(CLS, hModule),         // GCL_HMODULE
    0,
    FIELD_OFFSET(CLS, spicn),           // GCL_HICON
    0,
    FIELD_OFFSET(CLS, spcur),           // GCL_HCURSOR
    0,
    FIELD_OFFSET(CLS, hbrBackground),   // GCL_HBRBACKGROUND
    0,
    FIELD_OFFSET(CLS, lpszMenuName),    // GCL_MENUNAME
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

/***************************************************************************\
* _RegisterClass (API)
*
* This stub calls InternalRegisterClass to do its work and then does some
* additional work to save a pointer to the client-side menu name string.
* The menu string is returned by _GetClassInfo so the client can fix up
* a valid entry for the WNDCLASS lpszMenuName field.
*
* History:
* 04-26-91 DarrinM      Created.
\***************************************************************************/

ATOM xxxRegisterClassEx(
    LPWNDCLASSVEREX cczpwc,
    PCLSMENUNAME pcmn,
    WORD fnid,
    DWORD dwFlags,
    LPDWORD pdwWOW)
{
    PCLS pcls;
    PTHREADINFO  ptiCurrent = PtiCurrent();

    /*
     * NOTE -- lpszClassName and lpszMenuName in the wndclass may be client-side
     *         pointers. Use of those fields must be protected in try blocks.
     */

    /*
     * Convert a possible CallProc Handle into a real address. They may
     * have kept the CallProc Handle from some previous mixed GetClassinfo
     * or SetWindowLong.
     */
    if (ISCPDTAG(cczpwc->lpfnWndProc)) {
        PCALLPROCDATA pCPD;
        if (pCPD = HMValidateHandleNoRip((HANDLE)cczpwc->lpfnWndProc, TYPE_CALLPROC)) {
            cczpwc->lpfnWndProc = (WNDPROC)pCPD->pfnClientPrevious;
        }
    }

    pcls = InternalRegisterClassEx(cczpwc, fnid, dwFlags | ((ptiCurrent->TIF_flags & TIF_16BIT)? CSF_WOWCLASS : 0));
    if (pcls != NULL) {

        pcls->lpszClientUnicodeMenuName = pcmn->pwszClientUnicodeMenuName;
        pcls->lpszClientAnsiMenuName = pcmn->pszClientAnsiMenuName;

        /*
         * copy 5 WOW dwords.
         */
        if (pdwWOW && (ptiCurrent->TIF_flags & TIF_16BIT)) {
            RtlCopyMemory (PWCFromPCLS(pcls), pdwWOW, sizeof(WC));
        }

        if ((ptiCurrent->TIF_flags & TIF_16BIT) && ptiCurrent->ptdb) {
            pcls->hTaskWow = ptiCurrent->ptdb->hTaskWow;
        } else {
            pcls->hTaskWow = 0;
        }

        /*
         * For some (presumably good) reason Win 3.1 changed RegisterClass
         * to return the classes classname atom.
         */
        return pcls->atomNVClassName;
    } else {
        return 0;
    }
}


/***************************************************************************\
* ClassAlloc
* ClassFree
*
* Generic allocation routines that discriminate between desktop heap
* and pool.
*
* History:
* 08-07-95 JimA         Created
\***************************************************************************/

PVOID ClassAlloc(
    PDESKTOP pdesk,
    DWORD cbAlloc)
{
    PVOID pvalloc;

    if (pdesk) {
        /*
         * NTRAID#NTBUG9-411175-2001/06/06-jasonsch.
         */
        pvalloc = DesktopAllocAlways(pdesk, cbAlloc, DTAG_CLASS);
    } else {
        pvalloc = UserAllocPoolWithQuotaZInit(cbAlloc, TAG_CLASS);
    }

    return pvalloc;
}

VOID ClassFree(
    PDESKTOP pdesk,
    PVOID pvfree)
{
    if (pdesk != NULL) {
        DesktopFree(pdesk, pvfree);
    } else {
        UserFreePool(pvfree);
    }
}

/***************************************************************************\
* ValidateAndLockCursor
*
* Win95 comaptible validation
*
* History:
* 12-19-95 GerardoB     Created
\***************************************************************************/
BOOL ValidateAndLockCursor (PCURSOR * ppcursor, BOOL fIs40Compat)
{
    PCURSOR pcur;

    if (*ppcursor == NULL) {
        return TRUE;
    }

    pcur = HMValidateHandleNoSecure(*ppcursor, TYPE_CURSOR);
    if (pcur == NULL) {
        RIPMSG1(RIP_WARNING, "ValidateAndLockCursor: Invalid Cursor or Icon:%#p", *ppcursor);
        if (fIs40Compat) {
            RIPERR0(ERROR_INVALID_PARAMETER, RIP_VERBOSE, "RegisterClass: Invalid Parameter");
            return FALSE;
        }
    }

    *ppcursor = NULL;
    Lock(ppcursor, pcur);
    return TRUE;
}

/***************************************************************************\
* InternalRegisterClass
*
* This API is called by applications or the system to register private or
* global (public) window classes. If a class with the same name already
* exists the call will fail, except in the special case where an application
* registers a private class with the same name as a global class. In this
* case the private class supercedes the global class for that application.
*
* History:
* 10-15-90 DarrinM      Ported from Win 3.0 sources.
\***************************************************************************/
PCLS InternalRegisterClassEx(
    LPWNDCLASSVEREX cczlpwndcls,
    WORD fnid,
    DWORD CSF_flags)
{
    BOOL fIs40Compat;
    ULONG_PTR dwT;
    PCLS pcls;
    LPWSTR pszT1;
    ATOM atomT;
    PTHREADINFO ptiCurrent;
    HANDLE hModule;
    PDESKTOP pdesk;
    ULONG cch;
    UNICODE_STRING UString;
    ANSI_STRING AString;

    /*
     * NOTE -- lpszClassName and lpszMenuName in the wndclass may be client-side
     *         pointers. Use of those fields must be protected in try blocks.
     */
    CheckCritIn();

    ptiCurrent = PtiCurrent();

    /*
     * Don't allow 4.0 apps to register a class using hModuleWin
     * LATER GerardoB: Our client side classes use hmodUser (USER32) while
     *  our server side classes use hWinInstance (WIN32K). We should change
     * CreateThreadInfo and LW_RegisterWindows so all classes use hModUser.
     */
    hModule = cczlpwndcls->hInstance;
     if (!(CSF_flags & (CSF_SYSTEMCLASS | CSF_SERVERSIDEPROC))
            && (hModule == hModuleWin)
            && (LOWORD(ptiCurrent->dwExpWinVer) >= VER40)) {

         RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "InternalRegisterClassEx: Invalid hInstance (Cannot use system's hInstance)");
         return NULL;
     }


    /*
     * As of NT 4.0 we no longer honor CS_BYTEALIGNCLIENT or CS_BYTEALIGNWINDOW
     */
    if (cczlpwndcls->style & (CS_BYTEALIGNCLIENT | CS_BYTEALIGNWINDOW)) {
        RIPMSG0(RIP_VERBOSE, "CS_BYTEALIGNCLIENT and CS_BYTEALIGNWINDOW styles no longer honored.");
    }

    /*
     * Does this class exist as a private class?  If so, fail.
     */
    atomT = FindClassAtom(cczlpwndcls->lpszClassNameVer);

    if (atomT != 0 && !(CSF_flags & CSF_SERVERSIDEPROC)) {
        /*
         * First check private classes. If already exists, return error.
         */
        if (_InnerGetClassPtr(atomT, &ptiCurrent->ppi->pclsPrivateList,
                hModule) != NULL) {
            RIPERR1(ERROR_CLASS_ALREADY_EXISTS, RIP_VERBOSE, "RegisterClass: Class already exists %lx", (DWORD)atomT);
            return NULL;
        }

        /*
         * Now only check public classes if CS_GLOBALCLASS is set. If it
         * isn't set, then this will allow an application to re-register
         * a private class to take precedence over a public class.
         */
        if (cczlpwndcls->style & CS_GLOBALCLASS) {
            if (_InnerGetClassPtr(atomT, &ptiCurrent->ppi->pclsPublicList, NULL) != NULL) {
                RIPERR0(ERROR_CLASS_ALREADY_EXISTS, RIP_VERBOSE, "RegisterClass: Global Class already exists");
                return NULL;
            }
        }
    }

    /*
     * Alloc space for the class.
     */
    if (ptiCurrent->TIF_flags & TIF_SYSTEMTHREAD) {
        pdesk = NULL;
    } else {
        pdesk = ptiCurrent->rpdesk;
    }
    pcls = (PCLS)ClassAlloc(pdesk, sizeof(CLS) + cczlpwndcls->cbClsExtra + (CSF_flags & CSF_WOWCLASS ? sizeof(WC):0));
    if (pcls == NULL) {
        return NULL;
    }

    LockDesktop(&pcls->rpdeskParent, pdesk, LDL_CLS_DESKPARENT1, (ULONG_PTR)pcls);
    pcls->pclsBase = pcls;

    /*
     * Copy over the shared part of the class structure.
     */
    UserAssert(FIELD_OFFSET(WNDCLASSEX, style) == FIELD_OFFSET(COMMON_WNDCLASS, style));
    RtlCopyMemory(&pcls->style, &(cczlpwndcls->style),
                  sizeof(COMMON_WNDCLASS) - FIELD_OFFSET(COMMON_WNDCLASS, style));

    /*
     * Copy CSF_SERVERSIDEPROC, CSF_ANSIPROC (etc.) flags
     */
    pcls->CSF_flags = LOWORD(CSF_flags);
    pcls->fnid = fnid;
    if (fnid) {
        CBFNID(fnid) = (WORD)(pcls->cbwndExtra + sizeof(WND));

        if (!(pcls->CSF_flags & CSF_SERVERSIDEPROC) && ptiCurrent->pClientInfo != NULL) {
            /*
             * Clear the bit so new threads in this process
             * won't bother to reregister the client-side USER classes.
             */
            ptiCurrent->pClientInfo->CI_flags &= ~CI_REGISTERCLASSES;
        }
    }

    /*
     * If this wndproc happens to be a client wndproc stub for a server
     * wndproc, then remember the server wndproc! This should be rare: why
     * would an application re-register a class that isn't "subclassed"?
     */
    if (!(pcls->CSF_flags & CSF_SERVERSIDEPROC)) {
        dwT = MapClientToServerPfn((ULONG_PTR)pcls->lpfnWndProc);
        if (dwT != 0) {
            pcls->CSF_flags |= CSF_SERVERSIDEPROC;
            pcls->CSF_flags &= ~CSF_ANSIPROC;
            pcls->lpfnWndProc = (WNDPROC_PWND)dwT;
        }
    }

    /*
     * Win95 compatible validation.
     *
     * hbrBackground was validated by GDI in the client side
     * NULL hInstances are mapped to GetModuleHandle(NULL) in the client
     * side
     */

    fIs40Compat = (CSF_flags & CSF_WIN40COMPAT) != 0;

    if (!ValidateAndLockCursor(&pcls->spcur, fIs40Compat)) {
        goto ValidateError1;
    }

    if (!ValidateAndLockCursor(&pcls->spicn, fIs40Compat)) {
        goto ValidateError2;
    }

    if (!ValidateAndLockCursor(&pcls->spicnSm, fIs40Compat)) {
        goto ValidateError3;
    }

    /*
     * Add the class name to the atom table.
     */
    if (IS_PTR(cczlpwndcls->lpszClassName)) {
        atomT = UserAddAtom(cczlpwndcls->lpszClassName, FALSE);
    } else {
        atomT = PTR_TO_ID(cczlpwndcls->lpszClassName);
    }

    if (atomT == 0) {
        goto AtomError1;
    }
    pcls->atomNVClassName = atomT;

    if (IS_PTR(cczlpwndcls->lpszClassNameVer)) {
        atomT = UserAddAtom(cczlpwndcls->lpszClassNameVer, FALSE);
    } else {
        atomT = PTR_TO_ID(cczlpwndcls->lpszClassNameVer);
    }

    if (atomT == 0) {
        goto AtomError2;
    }
    pcls->atomClassName = atomT;

    /*
     * Make an ANSI version of the class name to optimize
     * GetClassNameA for WOW.
     */
    if (IS_PTR(cczlpwndcls->lpszClassName)) {
        try {
            RtlInitUnicodeString(&UString, cczlpwndcls->lpszClassName);
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
            goto MemError2;
        }
#ifdef FE_SB // InternalRegisterClassEx()
        cch = UString.Length + 1;
#else
        cch = UString.Length / sizeof(WCHAR) + 1;
#endif // FE_SB
    } else {
        cch = 7; // 1 char for '#', 5 for '65536'.
    }

    /*
     * Allocate the ANSI name buffer and convert the unicode name
     * to ANSI.
     */
    pcls->lpszAnsiClassName = (LPSTR)ClassAlloc(pdesk, cch);
    if (pcls->lpszAnsiClassName == NULL) {
        goto MemError2;
    }

    /*
     * Form the ANSI class name.
     */
    if (IS_PTR(cczlpwndcls->lpszClassName)) {

        /*
         * Class name is a string.
         */
        AString.Length = 0;
        AString.MaximumLength = (USHORT)cch;
        AString.Buffer = pcls->lpszAnsiClassName;
        try {
            RtlUnicodeStringToAnsiString(&AString, &UString, FALSE);
        } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
            goto MemError3;
        }
    } else {

        /*
         * Class name is an integer atom.
         */
        pcls->lpszAnsiClassName[0] = L'#';
        RtlIntegerToChar(PTR_TO_ID(cczlpwndcls->lpszClassName), 10, cch - 1,
                &pcls->lpszAnsiClassName[1]);
    }

    /*
     * Make local copy of menu name.
     */
    pszT1 = pcls->lpszMenuName;

    if (pszT1 != NULL) {
        if (IS_PTR(pszT1)) {
            try {
                RtlInitUnicodeString(&UString, pszT1);
            } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
                goto MemError3;
            }
            if (UString.Length == 0) {

                /*
                 * app passed an empty string for the name
                 */
                pcls->lpszMenuName = NULL;
            } else {
                UNICODE_STRING strMenuName;

                /*
                 * Alloc space for the Menu Name.
                 */
                if (!AllocateUnicodeString(&strMenuName, &UString)) {
MemError3:
                    ClassFree(pdesk, pcls->lpszAnsiClassName);
MemError2:
                    UserDeleteAtom(pcls->atomClassName);
AtomError2:
                    UserDeleteAtom(pcls->atomNVClassName);
AtomError1:
                    Unlock(&pcls->spicnSm);
ValidateError3:
                    Unlock(&pcls->spicn);
ValidateError2:
                    Unlock(&pcls->spcur);
ValidateError1:
                    UnlockDesktop(&pcls->rpdeskParent, LDU_CLS_DESKPARENT1, (ULONG_PTR)pcls);
                    ClassFree(pdesk, pcls);
                    return NULL;
                }

                pcls->lpszMenuName = strMenuName.Buffer;
            }
        }
    }

    if ((CSF_flags & CSF_SERVERSIDEPROC) || (pcls->style & CS_GLOBALCLASS)) {
        if (pcls->CSF_flags & CSF_SYSTEMCLASS) {
            pcls->pclsNext = gpclsList;
            gpclsList = pcls;
        } else {
            pcls->pclsNext = ptiCurrent->ppi->pclsPublicList;
            ptiCurrent->ppi->pclsPublicList = pcls;
        }
    } else {
        pcls->pclsNext = ptiCurrent->ppi->pclsPrivateList;
        ptiCurrent->ppi->pclsPrivateList = pcls;
    }

    /*
     * Because Memory is allocated with ZEROINIT, the pcls->cWndReferenceCount
     * field is automatically initialised to zero.
     */

    return pcls;
}


/***************************************************************************\
* _UnregisterClass (API)
*
* This API function is used to unregister a window class previously
* registered by the Application.
*
* Returns:
*     TRUE  if successful.
*     FALSE otherwise.
*
* NOTE:
*  1. The class name must have been registered earlier by this client
*     through RegisterClass().
*  2. The class name should not be one of the predefined control classes.
*  3. All windows created with this class must be destroyed before calling
*     this function.
*
* History:
* 10-15-90 DarrinM      Ported from Win 3.0 sources.
* 03-09-94 BradG        Fixed bug when ATOM was passed in
\***************************************************************************/

BOOL _UnregisterClass(
    LPCWSTR ccxlpszClassName,
    HANDLE hModule,
    PCLSMENUNAME pcmn)
{
    ATOM atomT;
    PPCLS ppcls;
    PTHREADINFO ptiCurrent;

    CheckCritIn();

    ptiCurrent = PtiCurrent();

    /*
     * Check whether the given ClassName is already registered by the
     * Application with the given handle.
     * Return error, if either the Class does not exist or it does not
     * belong to the calling process.
     */

    /*
     * bradg (3/9/95) - Must first check to see if an ATOM has been passed
     */
    atomT = FindClassAtom(ccxlpszClassName);
    ppcls = _InnerGetClassPtr(atomT, &ptiCurrent->ppi->pclsPrivateList, hModule);
    if (ppcls == NULL) {
        /*
         * Maybe this is a public class.
         */
        ppcls = _InnerGetClassPtr(atomT, &ptiCurrent->ppi->pclsPublicList, NULL);
        if (ppcls == NULL) {
            RIPERR1(ERROR_CLASS_DOES_NOT_EXIST, RIP_WARNING, "UnregisterClass: Class does not exist; atom=%lX", (DWORD)atomT);
            return FALSE;
        }
    }

    /*
     * If any windows created with this class still exist return an error.
     */
    if ((*ppcls)->cWndReferenceCount != 0) {
        RIPERR0(ERROR_CLASS_HAS_WINDOWS, RIP_WARNING, "UnregisterClass: Class still has window");
        return FALSE;
    }

    /*
     * Return client side pointers for cleanup
     */
    pcmn->pszClientAnsiMenuName = (*ppcls)->lpszClientAnsiMenuName;
    pcmn->pwszClientUnicodeMenuName = (*ppcls)->lpszClientUnicodeMenuName;
    pcmn->pusMenuName = NULL;

    /*
     * Release the Window class and related information.
     */
    DestroyClass(ppcls);

    return TRUE;
}


PCLS _GetWOWClass(
    HANDLE hModule,
    LPCWSTR ccxlpszClassName)
{
    PCLS pcls;
    PPCLS ppcls = NULL;
    ATOM atomT;
    PTHREADINFO ptiCurrent;

    CheckCritInShared();

    ptiCurrent = PtiCurrentShared();

    /*
     * Is this class registered as a private class?
     */
    atomT = UserFindAtom(ccxlpszClassName);
    if (atomT != 0) {
        ppcls = GetClassPtr(atomT, ptiCurrent->ppi, hModule);
    }
    if (ppcls == NULL) {
        RIPERR0(ERROR_CLASS_DOES_NOT_EXIST, RIP_VERBOSE, "");
        return NULL;
    }

    pcls = *ppcls;

    if (ptiCurrent->rpdesk != pcls->rpdeskParent) {
        pcls = pcls->pclsClone;
        while (pcls != NULL) {
            if (ptiCurrent->rpdesk == pcls->rpdeskParent) {
                goto Done;
            }
            pcls = pcls->pclsNext;
        }
        RIPERR0(ERROR_CLASS_DOES_NOT_EXIST, RIP_VERBOSE, "");
        return NULL;
    }
Done:
    return pcls;
}

/***************************************************************************\
* GetClassInfo (API)
*
* This function checks if the given class name is registered already. If the
* class is not found, it returns 0;  If the class is found, then all the
* relevant information from the CLS structure is copied into the WNDCLASS
* structure pointed to by the lpWndCls argument. If successful, it returns
* the class name atom
*
* NOTE: hmod was used to distinguish between different task's public classes.
* Now that public classes are gone, hmod isn't used anymore. We just search
* the applications private class for a match and if none is found we search
* the system classes.
*
* History:
* 10-15-90 DarrinM      Ported from Win 3.0 sources.
* 04-08-91 DarrinM      Removed public classes.
* 04-26-91 DarrinM      Streamlined to work with the client-side API.
* 03-09-95 BradG        Fixed bug when ATOM was passed in.
\***************************************************************************/
ATOM _GetClassInfoEx(
    HANDLE hModule,
    LPCWSTR ccxlpszClassName,
    LPWNDCLASSEX pwc,
    LPWSTR *ppszMenuName,
    BOOL bAnsi)
{
    PCLS pcls;
    PPCLS ppcls;
    ATOM atomT;
    PTHREADINFO ptiCurrent;
    DWORD dwCPDType = 0;

    CheckCritIn();

    ptiCurrent = PtiCurrent();

    /*
     * These are done first so if we don't find the class, and therefore
     * fail, the return thank won't try to copy back these (nonexistant)
     * strings.
     */
    pwc->lpszMenuName = NULL;
    pwc->lpszClassName = NULL;

    /*
     * Must first check to see if an ATOM has been passed.
     */
    atomT = FindClassAtom(ccxlpszClassName);

    /*
     * Windows 3.1 does not perform the class search with
     * a null hModule. If an application supplies a NULL
     * hModule, they search on hModuleWin instead.
     */

    if (hModule == NULL) {
        hModule = hModClient;
    }

    ppcls = GetClassPtr(atomT, ptiCurrent->ppi, hModule);


    if (ppcls == NULL) {
        RIPERR0(ERROR_CLASS_DOES_NOT_EXIST, RIP_VERBOSE, "GetClassInfo: Class does not exist");
        return 0;
    }

    pcls = *ppcls;

    /*
     * Copy all the fields common to CLS and WNDCLASS structures except
     * the lpszMenuName and lpszClassName which will be filled in by the
     * client-side piece of GetClassInfo.
     */

     /*
      * Return public bits only.
      */
    pwc->style = pcls->style & CS_VALID;

    /*
     * Corel Depth 6.0 calls GetClassInfo (COMBOBOX) and registers a class
     * using the same name and style bits. This works OK on Win95 because
     * their "system" (combo, edit, etc) classes are not CS_GLOBALCLASS.
     * So we've got to mask this bit out for our classes.
     */

     /*
     * Bug 17998. If the app is 32bit and WinVer is less than 4.0 don't mask
     * out the CS_GLOBALCLASS bit.
     */

    if ((pcls->fnid != 0) &&
            ((LOWORD(ptiCurrent->dwExpWinVer) >= VER40) || (ptiCurrent->TIF_flags & TIF_16BIT)) ) {
        pwc->style &= ~CS_GLOBALCLASS;
    }


    pwc->cbClsExtra = pcls->cbclsExtra;
    pwc->cbWndExtra = pcls->cbwndExtra;

    /*
     * Stop 32-bit apps from inadvertantly using hModuleWin as their hInstance
     * when they register a window class.
     */
    if (LOWORD(ptiCurrent->dwExpWinVer) >= VER40) {
        /*
         * This is actually, Win95 behavior -- the USER.EXE hModule gets thunked
         * to NULL on the way out of the 16->32 bit thunk. Note -- if we ever
         * need to support 16-bit 4.0 apps (shudder), this may need to change.
         */
        if (hModule == hModClient) {
            pwc->hInstance = NULL;
        } else {
            pwc->hInstance = hModule;
        }
    } else {
        /*
         * Win NT 3.1/3.51 returned the hInstance from the class. Note that this
         * is incompatible with Win 3.1. WoW has hacks for 16-bit apps.
         */

        if ((pcls->hModule == hModuleWin) || (pcls->hModule == hModClient)) {
            pwc->hInstance = hModClient;
        } else {
            pwc->hInstance = pcls->hModule;
        }
    }

    pwc->hIcon = PtoH(pcls->spicn);
    pwc->hCursor = PtoH(pcls->spcur);
    pwc->hbrBackground = pcls->hbrBackground;

    /*
     * Need to hide the small icon if it's USER created.
     */
    if (pcls->spicnSm && (pcls->spicnSm->CURSORF_flags & CURSORF_SECRET)) {
        pwc->hIconSm = NULL;
    } else {
        pwc->hIconSm = PtoH(pcls->spicnSm);
    }

    /*
     * If its a server proc then map it to a client proc. If not we may have
     * to create a CPD.
     */
    if (pcls->CSF_flags & CSF_SERVERSIDEPROC) {
        pwc->lpfnWndProc =
                (WNDPROC)MapServerToClientPfn((ULONG_PTR)pcls->lpfnWndProc, bAnsi);
    } else {
        pwc->lpfnWndProc = (WNDPROC)MapClientNeuterToClientPfn(pcls, 0, bAnsi);

        /*
         * If the client mapping didn't change the window proc then see if
         * we need a callproc handle.
         */
        if (pwc->lpfnWndProc == (WNDPROC)pcls->lpfnWndProc) {
            /*
             * Need to return a CallProc handle if there is an Ansi/Unicode mismatch
             */
            if (bAnsi != !!(pcls->CSF_flags & CSF_ANSIPROC)) {
                dwCPDType |= bAnsi ? CPD_ANSI_TO_UNICODE : CPD_UNICODE_TO_ANSI;
            }
        }
    }

    if (dwCPDType) {
        ULONG_PTR dwCPD;

        dwCPD = GetCPD(pcls, dwCPDType | CPD_CLASS, (ULONG_PTR)pwc->lpfnWndProc);

        if (dwCPD) {
            pwc->lpfnWndProc = (WNDPROC)dwCPD;
        } else {
            RIPMSG0(RIP_WARNING, "GetClassInfo unable to alloc CPD returning handle");
        }
    }

    /*
     * Return the stashed pointer to the client-side menu name string.
     */
    if (bAnsi) {
        *ppszMenuName = (LPWSTR)pcls->lpszClientAnsiMenuName;
    } else {
        *ppszMenuName = pcls->lpszClientUnicodeMenuName;
    }
    return pcls->atomNVClassName;
}


/***************************************************************************\
* _SetClassWord (API)
*
* Set a class word. Positive index values set application class words
* while negative index values set system class words. The negative
* indices are published in WINDOWS.H.
*
* History:
* 10-16-90 darrinm      Wrote.
\***************************************************************************/
WORD _SetClassWord(
    PWND pwnd,
    int index,
    WORD value)
{
    WORD wOld;
    WORD UNALIGNED *pw;
    PCLS pcls;

    CheckCritIn();

    if (GETPTI(pwnd)->ppi != PpiCurrent()) {
        RIPERR1(ERROR_ACCESS_DENIED, RIP_WARNING, "SetClassWord: different process: index 0x%lx", index);
        return 0;
    }

    pcls = pwnd->pcls->pclsBase;
    if ((index < 0) || (index + (int)sizeof(WORD) > pcls->cbclsExtra)) {
        RIPERR1(ERROR_INVALID_INDEX,
                RIP_WARNING,
                "SetClassWord: invalid index 0x%x", index);
        return 0;
    } else {
        pw = (WORD UNALIGNED *)((BYTE *)(pcls + 1) + index);
        wOld = *pw;
        *pw = value;
        pcls = pcls->pclsClone;
        while (pcls != NULL) {
            pw = (WORD UNALIGNED *)((BYTE *)(pcls + 1) + index);
            *pw = value;
            pcls = pcls->pclsNext;
        }
        return wOld;
    }
}


/***************************************************************************\
* xxxSetClassLong (API)
*
* Set a class long. Positive index values set application class longs
* while negative index values set system class longs. The negative
* indices are published in WINDOWS.H.
*
* History:
* 10-16-90 darrinm      Wrote.
\***************************************************************************/
ULONG_PTR xxxSetClassLongPtr(
    PWND pwnd,
    int index,
    ULONG_PTR value,
    BOOL bAnsi)
{
    ULONG_PTR dwOld;
    PCLS pcls;

    CheckLock(pwnd);
    CheckCritIn();

    if (GETPTI(pwnd)->ppi != PpiCurrent()) {
        RIPERR1(ERROR_ACCESS_DENIED, RIP_WARNING, "SetClassLongPtr: different process: index 0x%lx", index);
        return 0;
    }

    if (index < 0) {
        return xxxSetClassData(pwnd, index, value, bAnsi);
    } else {
        pcls = pwnd->pcls->pclsBase;
        if (index + (int)sizeof(ULONG_PTR) > pcls->cbclsExtra) {
            RIPERR1(ERROR_INVALID_INDEX,
                    RIP_WARNING,
                    "SetClassLongPtr: invalid index 0x%x", index);
            return 0;
        } else {
            ULONG_PTR UNALIGNED *pudw;
            pudw = (ULONG_PTR UNALIGNED *)((BYTE *)(pcls + 1) + index);
            dwOld = *pudw;
            *pudw = value;
            pcls = pcls->pclsClone;
            while (pcls != NULL) {
                pudw = (ULONG_PTR UNALIGNED *)((BYTE *)(pcls + 1) + index);
                *pudw = value;
                pcls = pcls->pclsNext;
            }
            return dwOld;
        }
    }
}


#ifdef _WIN64
DWORD xxxSetClassLong(
    PWND pwnd,
    int index,
    DWORD value,
    BOOL bAnsi)
{
    DWORD dwOld;
    PCLS pcls;

    CheckLock(pwnd);
    CheckCritIn();

    if (GETPTI(pwnd)->ppi != PpiCurrent()) {
        RIPERR1(ERROR_ACCESS_DENIED, RIP_WARNING, "SetClassLong: different process: index 0x%lx", index);
        return 0;
    }

    if (index < 0) {
        if (index < INDEX_OFFSET || afClassDWord[index - INDEX_OFFSET] > sizeof(DWORD)) {
            RIPERR1(ERROR_INVALID_INDEX,
                    RIP_WARNING,
                    "SetClassLong: invalid index 0x%x", index);
            return 0;
        }
        return (DWORD)xxxSetClassData(pwnd, index, value, bAnsi);
    } else {
        pcls = pwnd->pcls->pclsBase;
        if (index + (int)sizeof(DWORD) > pcls->cbclsExtra) {
            RIPERR1(ERROR_INVALID_INDEX,
                    RIP_WARNING,
                    "SetClassLong: invalid index 0x%x", index);
            return 0;
        } else {
            DWORD UNALIGNED *pudw;
            pudw = (DWORD UNALIGNED *)((BYTE *)(pcls + 1) + index);
            dwOld = *pudw;
            *pudw = value;
            pcls = pcls->pclsClone;
            while (pcls != NULL) {
                pudw = (DWORD UNALIGNED *)((BYTE *)(pcls + 1) + index);
                *pudw = value;
                pcls = pcls->pclsNext;
            }
            return dwOld;
        }
    }
}
#endif


PPCLS _InnerGetClassPtr(
    ATOM atom,
    PPCLS ppcls,
    HANDLE hModule)
{
    if (atom == 0)
        return NULL;

    while (*ppcls != NULL) {
        if ((*ppcls)->atomClassName == atom &&
                (hModule == NULL || HIWORD((ULONG_PTR)(*ppcls)->hModule) == HIWORD((ULONG_PTR)hModule)) &&
                !((*ppcls)->CSF_flags & CSF_WOWDEFERDESTROY)) {
            return ppcls;
        }

        ppcls = (PPCLS)*ppcls;
    }

    return NULL;
}


/***************************************************************************\
* GetClassPtr
*
* Note: This returns a "pointer-to-PCLS" and not "PCLS".
*
* Scan the passed-in class list for the specified class. Return NULL if
* the class isn't in the list.
*
* History:
* 10-16-90 darrinm      Ported this puppy.
* 04-08-91 DarrinM      Rewrote to remove global classes.
* 08-14-92 FritzS     Changed check to HIWORD only to allow Wow apps to
*                     share window classes between instances of an app.
                      (For Wow apps, HiWord of hInstance is 16-bit module,
                       and LoWord is 16-bit hInstance
\***************************************************************************/

PPCLS GetClassPtr(
    ATOM atom,
    PPROCESSINFO ppi,
    HANDLE hModule)
{
    PPCLS ppcls;

    /*
     * First search public then private then usersrv registered classes
     */
    ppcls = _InnerGetClassPtr(atom, &ppi->pclsPrivateList, hModule);
    if (ppcls)
        return ppcls;

    ppcls = _InnerGetClassPtr(atom, &ppi->pclsPublicList, NULL);
    if (ppcls)
        return ppcls;

    /*
     * Next seach public and private classes and override hmodule;
     * some apps (bunny) do a GetClassInfo(dialog) and RegisterClass
     * and only change the wndproc which set the hmodule to be just
     * like usersrv created it even though it is in the app's public
     * or private class list
     */

    /*
     * Later -- since we are no longer returning hModuleWin to any app,
     * we may only need to check for hModClient. Check this out.
     *      FritzS
     */

    ppcls = _InnerGetClassPtr(atom, &ppi->pclsPrivateList, hModClient);
    if (ppcls)
        return ppcls;

    ppcls = _InnerGetClassPtr(atom, &ppi->pclsPublicList, hModClient);
    if (ppcls)
        return ppcls;

    /*
     * Search the system class list
     */
    ppcls = _InnerGetClassPtr(atom, &gpclsList, NULL);
    return ppcls;
}

/***************************************************************************\
 * UnlockAndFreeCPDs -
 *
 * Safe way to unlock and free a linked list of CPDs. Need to do it this
 * way in case the Thread's objects have already been marked for destruction.
 *
 * History 2/10/95  SanfordS    Created
\***************************************************************************/

VOID UnlockAndFreeCPDs(
PCALLPROCDATA *ppCPD)
{
    PCALLPROCDATA pCPD;

    while ((pCPD = *ppCPD) != NULL) {
        /*
         * Unlink the CPD from the list.
         */
        *ppCPD = pCPD->spcpdNext;
        pCPD->spcpdNext = NULL;

        /*
         * Mark it for destruction.
         */
        if (!HMIsMarkDestroy(pCPD)) {
            HMMarkObjectDestroy(pCPD);
        }

        /*
         * Unlock it and it will be destroyed.
         */
        Unlock(&pCPD);
    }
}

/***************************************************************************\
* DestroyClassBrush
*
* Destroy the brush of the class if it's a brush, it's not a system
* brush and no other class is using it
*
* History:
* 4-10-96 CLupu  Created
\***************************************************************************/

void DestroyClassBrush(
    PCLS pcls)
{
    PPROCESSINFO ppi = PpiCurrent();
    PCLS         pclsWalk;
    int          nInd;
    BOOL         bRet;
    /*
     * Return if it's not a real brush
     */
    if (pcls->hbrBackground <= (HBRUSH)(COLOR_MAX))
        return;

    /*
     * Don't delete the system brushes
     */
    for (nInd = 0; nInd < COLOR_MAX; nInd++) {
        if (pcls->hbrBackground == SYSHBRUSH(nInd))
            return;
    }


    /*
     * Walk the process public public list
     */
    pclsWalk = ppi->pclsPublicList;

    while (pclsWalk) {
        if (pclsWalk != pcls && pclsWalk->hbrBackground == pcls->hbrBackground)
            return;

        pclsWalk = pclsWalk->pclsNext;
    }

    /*
     * Walk the process private class list
     */
    pclsWalk = ppi->pclsPrivateList;

    while (pclsWalk) {
        if (pclsWalk != pcls && pclsWalk->hbrBackground == pcls->hbrBackground)
            return;

        pclsWalk = pclsWalk->pclsNext;
    }

    /*
     * Finaly walk the system class list
     */
    pclsWalk = gpclsList;

    while (pclsWalk) {
        if (pclsWalk != pcls && pclsWalk->hbrBackground == pcls->hbrBackground)
            return;

        pclsWalk = pclsWalk->pclsNext;
    }

    bRet = GreDeleteObject(pcls->hbrBackground);

#if DBG
    if (!bRet)
        RIPERR1(ERROR_INVALID_HANDLE, RIP_WARNING,
            "DestroyClassBrush: failed to destroy brush %#p", pcls->hbrBackground);
#endif
}

/***************************************************************************\
* DestroyClass
*
* Delete the window class. First, destroy any DCs that are attached to the
* class. Then delete classname atom. Then free the other stuff that was
* allocated when the class was registered and unlink the class from the
* master class list.
*
* History:
* 10-16-90 darrinm      Ported this puppy.
\***************************************************************************/
VOID DestroyClass(
    PPCLS ppcls)
{
    PPCLS ppclsClone;
    PCLS pcls;
    PDESKTOP rpdesk;

    pcls = *ppcls;

    UserAssert(pcls->cWndReferenceCount == 0);

    /*
     * If this is a base class, destroy all clones before deleting
     * stuff.
     */
    if (pcls == pcls->pclsBase) {
        ppclsClone = &pcls->pclsClone;
        while (*ppclsClone != NULL) {
            DestroyClass(ppclsClone);
        }

        UserDeleteAtom(pcls->atomClassName);
        UserDeleteAtom(pcls->atomNVClassName);

        /*
         * No freeing if it's an integer resource.
         */
        if (IS_PTR(pcls->lpszMenuName)) {
            UserFreePool(pcls->lpszMenuName);
        }

        /*
         * Free up the class dc if there is one.
         */
        if (pcls->pdce != NULL)
            DestroyCacheDC(NULL, pcls->pdce->hdc);

        /*
         * Delete the hBrBackground brush if nobody else is
         * using it.
         */
        DestroyClassBrush(pcls);
    }

    /*
     * If we created the small icon delete it
     */
    DestroyClassSmIcon(pcls);

    /*
     * Unlock cursor and icon
     */
    Unlock(&pcls->spicn);
    Unlock(&pcls->spicnSm);
    Unlock(&pcls->spcur);

    /*
     * Free any CallProcData objects associated with this class
     */
    if (pcls->spcpdFirst) {
        UnlockAndFreeCPDs(&pcls->spcpdFirst);
    }

    /*
     * Point the previous guy at the guy we currently point to.
     */
    *ppcls = pcls->pclsNext;

    /*
     * Lock the desktop. Do not use a thread lock because
     * this may be called during process cleanup when thread
     * locks are no longer usable.
     */
    rpdesk = NULL;
    LockDesktop(&rpdesk, pcls->rpdeskParent, LDL_FN_DESTROYCLASS, (ULONG_PTR)PtiCurrent());
    UnlockDesktop(&pcls->rpdeskParent, LDU_CLS_DESKPARENT2, (ULONG_PTR)pcls);
    ClassFree(rpdesk, pcls->lpszAnsiClassName);
    ClassFree(rpdesk, pcls);
    UnlockDesktop(&rpdesk, LDU_FN_DESTROYCLASS, (ULONG_PTR)PtiCurrent());
}

/***************************************************************************\
* GetClassIcoCur
*
* Returns the pwnd's class icon/cursor. This is called by _GetClassData
*  from the client side because PCURSORs are allocated from POOL (so the
*  client cannot do PtoH on them). NtUserCallHwndParam does the PtoH translation
*
* History:
* 11-19-90 darrinm      Wrote.
\***************************************************************************/
PCURSOR GetClassIcoCur(
    PWND pwnd,
    int index)
{
    PCLS pcls = pwnd->pcls;
    PCURSOR pcur;

    switch (index) {
        case GCLP_HICON:
            pcur = pcls->spicn;
            break;

        case GCLP_HCURSOR:
            pcur = pcls->spcur;
            break;

        case GCLP_HICONSM:
            pcur = pcls->spicnSm;
            break;

        default:
            RIPMSG2(RIP_WARNING, "GetWndIcoCur: Invalid index: 0x%x  pwnd: 0x%p",
                    index, pwnd);
            pcur = NULL;
    }

    return pcur;
}

/***************************************************************************\
* SetClassCursor
*
* History:
\***************************************************************************/
ULONG_PTR SetClassCursor(
    PWND  pwnd,
    PCLS  pcls,
    DWORD index,
    ULONG_PTR dwData)
{
    ULONG_PTR dwOld;

    CheckLock(pwnd);

    if ((HANDLE)dwData != NULL) {
        dwData = (ULONG_PTR)HMValidateHandle((HANDLE)dwData, TYPE_CURSOR);
        if ((PVOID)dwData == NULL) {
            if (index == GCLP_HICON || index == GCLP_HICONSM) {
                RIPERR0(ERROR_INVALID_ICON_HANDLE, RIP_WARNING, "SetClassData: invalid icon");
            } else {
                RIPERR0(ERROR_INVALID_CURSOR_HANDLE, RIP_WARNING, "SetClassData: invalid cursor");
            }
        }
    }

    /*
     * Handle the locking issue.
     */
    pcls = pcls->pclsBase;
    switch (index) {
    case GCLP_HICON:
    case GCLP_HICONSM:
        dwOld = (ULONG_PTR)xxxSetClassIcon(pwnd, pcls, (PCURSOR)dwData, index);
        break;

    case GCLP_HCURSOR:
        dwOld = (ULONG_PTR)Lock(&pcls->spcur, dwData);
        break;
    }

    /*
     * Now set it for each clone class.
     */
    pcls = pcls->pclsClone;
    while (pcls != NULL) {
        switch(index) {
        case GCLP_HICON:
        case GCLP_HICONSM:
            xxxSetClassIcon(pwnd, pcls, (PCURSOR)dwData, index);
            break;

        case GCLP_HCURSOR:
            Lock(&pcls->spcur, dwData);
            break;
        }
        pcls = pcls->pclsNext;
    }

    return (ULONG_PTR)PtoH((PVOID)dwOld);
}

/***************************************************************************\
* SetClassData
*
* SetClassWord and SetClassLong are now identical routines because they both
* can return DWORDs. This single routine performs the work for them both
* by using two arrays; afClassDWord to determine whether the result should be
* a WORD or a DWORD, and aiClassOffset to find the correct offset into the
* CLS structure for a given GCL_ or GCL_ index.
*
* History:
* 11-19-90 darrinm      Wrote.
\***************************************************************************/

ULONG_PTR xxxSetClassData(
    PWND pwnd,
    int index,
    ULONG_PTR dwData,
    BOOL bAnsi)
{
    PCLS pcls = pwnd->pcls;
    BYTE *pb;
    ULONG_PTR dwT;
    ULONG_PTR dwOld;
    DWORD dwCPDType = 0;
    PCLSMENUNAME pcmn;
    UNICODE_STRING strMenuName, UString;

    CheckLock(pwnd);

    switch(index) {
    case GCLP_WNDPROC:

        /*
         * If the application (client) subclasses a class that has a server -
         * side window proc we must return a client side proc stub that it
         * can call.
         */
        if (pcls->CSF_flags & CSF_SERVERSIDEPROC) {
            dwOld = MapServerToClientPfn((ULONG_PTR)pcls->lpfnWndProc, bAnsi);
            pcls->CSF_flags &= ~CSF_SERVERSIDEPROC;

            UserAssert(!(pcls->CSF_flags & CSF_ANSIPROC));
            if (bAnsi) {
                pcls->CSF_flags |= CSF_ANSIPROC;
            }
        } else {
            dwOld = MapClientNeuterToClientPfn(pcls, 0, bAnsi);

            /*
             * If the client mapping didn't change the window proc then see if
             * we need a callproc handle.
             */
            if (dwOld == (ULONG_PTR)pcls->lpfnWndProc) {
                /*
                 * Need to return a CallProc handle if there is an Ansi/Unicode mismatch
                 */
                if (bAnsi != !!(pcls->CSF_flags & CSF_ANSIPROC)) {
                    dwCPDType |= bAnsi ? CPD_ANSI_TO_UNICODE : CPD_UNICODE_TO_ANSI;
                }
            }
        }

        if (dwCPDType) {
            ULONG_PTR dwCPD;

            dwCPD = GetCPD(pcls, dwCPDType | CPD_CLASS, dwOld);

            if (dwCPD) {
                dwOld = dwCPD;
            } else {
                RIPMSG0(RIP_WARNING, "GetClassLong unable to alloc CPD returning handle");
            }
        }

        /*
         * Convert a possible CallProc Handle into a real address. They may
         * have kept the CallProc Handle from some previous mixed GetClassinfo
         * or SetWindowLong.
         */
        if (ISCPDTAG(dwData)) {
            PCALLPROCDATA pCPD;
            if (pCPD = HMValidateHandleNoRip((HANDLE)dwData, TYPE_CALLPROC)) {
                dwData = pCPD->pfnClientPrevious;
            }
        }

        /*
         * If an app 'unsubclasses' a server-side window proc we need to
         * restore everything so SendMessage and friends know that it's
         * a server-side proc again. Need to check against client side
         * stub addresses.
         */
        pcls->lpfnWndProc = (WNDPROC_PWND)dwData;
        if ((dwT = MapClientToServerPfn(dwData)) != 0) {
            pcls->lpfnWndProc = (WNDPROC_PWND)dwT;
            pcls->CSF_flags |= CSF_SERVERSIDEPROC;
            pcls->CSF_flags &= ~CSF_ANSIPROC;
        } else {
            if (bAnsi) {
                pcls->CSF_flags |= CSF_ANSIPROC;
            } else {
                pcls->CSF_flags &= ~CSF_ANSIPROC;
            }
        }
        if (pcls->CSF_flags & CSF_WOWCLASS) {
            PWC pwc = PWCFromPCLS(pcls);
            pwc->hMod16 = (pcls->CSF_flags & CSF_SERVERSIDEPROC) ? 0:xxxClientWOWGetProcModule(pcls->lpfnWndProc);
        }

        return dwOld;
        break;

    case GCLP_HICON:
    case GCLP_HICONSM:
    case GCLP_HCURSOR:
        return SetClassCursor(pwnd, pcls, index, dwData);
        break;


    case GCL_WOWMENUNAME:
        if (pcls->CSF_flags & CSF_WOWCLASS) {
            PWCFromPCLS(pcls)->vpszMenu = (DWORD)dwData;
        } else {
            UserAssert(FALSE);
        }
        break;

    case GCL_CBCLSEXTRA:
        if (pcls->CSF_flags & CSF_WOWCLASS) {
        /*
         * yes -- we can do this for WOW classes only.
         */
            if (pcls->CSF_flags & CSF_WOWEXTRA) {
                dwOld = PWCFromPCLS(pcls)->iClsExtra;
                PWCFromPCLS(pcls)->iClsExtra = LOWORD(dwData);
                return dwOld;
            } else {
                PWCFromPCLS(pcls)->iClsExtra = LOWORD(dwData);
                pcls->CSF_flags |= CSF_WOWEXTRA;
                return pcls->cbclsExtra;
            }
        }
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "Attempt to change cbClsExtra");
        break;

    case GCLP_MENUNAME:
        pcmn = (PCLSMENUNAME) dwData;

        /*
         * pcmn->pusMenuName->Buffer is a client-side address.
         */

        dwOld = (ULONG_PTR) pcls->lpszMenuName;
        /* Is it a string? */
        if (IS_PTR(pcmn->pusMenuName->Buffer)) {
            try {
                RtlInitUnicodeString(&UString, pcmn->pusMenuName->Buffer);
            } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
                break;
            }
            /* Empty String? */
            if (UString.Length == 0) {
                pcls->lpszMenuName = NULL;
            } else {
                /* Make a copy of the string */
                if (!AllocateUnicodeString(&strMenuName, &UString)) {
                    RIPMSG0(RIP_WARNING, "xxxSetClassData: GCL_MENUNAME AllocateUnicodeString failed");
                    break;
                }

                pcls->lpszMenuName = strMenuName.Buffer;
            }
        } else {
            /* Just copy the id */
            pcls->lpszMenuName = pcmn->pusMenuName->Buffer;
        }
        /* Don't return the kernel side pointer */
        pcmn->pusMenuName = NULL;

        /* Free old string, if any */
        if (IS_PTR(dwOld)) {
            UserFreePool((PVOID)dwOld);
        }

        /* Return client side pointers */
        dwOld = (ULONG_PTR) pcls->lpszClientAnsiMenuName;
        pcls->lpszClientAnsiMenuName = pcmn->pszClientAnsiMenuName;
        pcmn->pszClientAnsiMenuName = (LPSTR)dwOld;

        dwOld = (ULONG_PTR) pcls->lpszClientUnicodeMenuName;
        pcls->lpszClientUnicodeMenuName = pcmn->pwszClientUnicodeMenuName;
        pcmn->pwszClientUnicodeMenuName = (LPWSTR)dwOld;

        return (bAnsi ? (ULONG_PTR) pcmn->pszClientAnsiMenuName : (ULONG_PTR) pcmn->pwszClientUnicodeMenuName);

    default:
        /*
         * All other indexes go here...
         */
        index -= INDEX_OFFSET;

        /*
         * Only let valid indices go through; if aiClassOffset is zero
         * then we have no mapping for this negative index so it must
         * be a bogus index.
         */
        if ((index < 0) || (aiClassOffset[index] == 0)) {
            RIPERR1(ERROR_INVALID_INDEX,
                    RIP_WARNING,
                    "SetClassLong: invalid index 0x%x", index);
            return 0;
        }

        pcls = pcls->pclsBase;
        pb = ((BYTE *)pcls) + aiClassOffset[index];

        if (afClassDWord[index] == sizeof(DWORD)) {
            dwOld = *(DWORD *)pb;
            *(DWORD *)pb = (DWORD)dwData;
        } else if (afClassDWord[index] == sizeof(ULONG_PTR)) {
            dwOld = *(ULONG_PTR *)pb;
            *(ULONG_PTR *)pb = dwData;
        } else {
            dwOld = (DWORD)*(WORD *)pb;
            *(WORD *)pb = (WORD)dwData;
        }

        pcls = pcls->pclsClone;
        while (pcls != NULL) {
            pb = ((BYTE *)pcls) + aiClassOffset[index];

            if (afClassDWord[index] == sizeof(DWORD)) {
                dwOld = *(DWORD *)pb;
                *(DWORD *)pb = (DWORD)dwData;
            } else if (afClassDWord[index] == sizeof(ULONG_PTR)) {
                dwOld = *(ULONG_PTR *)pb;
                *(ULONG_PTR *)pb = dwData;
            } else {
                dwOld = (DWORD)*(WORD *)pb;
                *(WORD *)pb = (WORD)dwData;
            }
            pcls = pcls->pclsNext;
        }

        return dwOld;
    }

    return 0;
}


/***************************************************************************\
* ReferenceClass
*
* Clones the class if it is a different desktop than the new window and
* increments the class window count(s).
*
* History:
* 12-11-93 JimA         Created.
\***************************************************************************/

BOOL ReferenceClass(
    PCLS pcls,
    PWND pwnd)
{
    DWORD cbName;
    PCLS pclsClone;
    PDESKTOP pdesk;

    /*
     * If the window is on the same desktop as the base class, just
     * increment the window count.
     */
    if (pcls->rpdeskParent == pwnd->head.rpdesk) {
        pcls->cWndReferenceCount++;
        return TRUE;
    }

    /*
     * The window is not on the base desktop. Try to find a cloned
     * class.
     */
    for (pclsClone = pcls->pclsClone; pclsClone != NULL;
            pclsClone = pclsClone->pclsNext) {
        if (pclsClone->rpdeskParent == pwnd->head.rpdesk) {
            break;
        }
    }

    /*
     * If we can't find one, clone the base class.
     */
    if (pclsClone == NULL) {
        pdesk = pwnd->head.rpdesk;
        pclsClone = ClassAlloc(pdesk, sizeof(CLS) + pcls->cbclsExtra + (pcls->CSF_flags & CSF_WOWCLASS ?sizeof(WC):0));
        if (pclsClone == NULL) {
            RIPMSG0(RIP_WARNING, "ReferenceClass: Failed Clone-Class Allocation");
            return FALSE;
        }

        RtlCopyMemory(pclsClone, pcls, sizeof(CLS) + pcls->cbclsExtra + (pcls->CSF_flags & CSF_WOWCLASS?sizeof(WC):0));

        cbName = strlen(pcls->lpszAnsiClassName) + 1;
        pclsClone->lpszAnsiClassName = ClassAlloc(pdesk, cbName);
        if (pclsClone->lpszAnsiClassName == NULL) {
            ClassFree(pdesk, pclsClone);
            RIPMSG0(RIP_WARNING, "ReferenceClass: No Clone Class Name");
            return FALSE;
        }

        /*
         * Everything has been allocated, now lock everything down.
         * NULL pointers in clone to prevent Lock() from incorrectly
         * decrementing object reference count
         */
        pclsClone->rpdeskParent = NULL;
        LockDesktop(&pclsClone->rpdeskParent, pdesk,
                    LDL_CLS_DESKPARENT2, (ULONG_PTR)pclsClone);
        pclsClone->pclsNext = pcls->pclsClone;
        pclsClone->pclsClone = NULL;
        pcls->pclsClone = pclsClone;
        RtlCopyMemory(pclsClone->lpszAnsiClassName, pcls->lpszAnsiClassName, cbName);

        pclsClone->spicn = pclsClone->spicnSm = pclsClone->spcur = NULL;

        Lock(&pclsClone->spicn, pcls->spicn);
        Lock(&pclsClone->spicnSm, pcls->spicnSm);
        Lock(&pclsClone->spcur, pcls->spcur);
        pclsClone->spcpdFirst =  NULL;
        pclsClone->cWndReferenceCount = 0;
    }

    /*
     * Increment reference counts.
     */
    pcls->cWndReferenceCount++;
    pclsClone->cWndReferenceCount++;
    pwnd->pcls = pclsClone;

    return TRUE;
}


/***************************************************************************\
* DereferenceClass
*
* Decrements the class window count in the base class. If it's the
* last window of a clone class, destroy the clone.
*
* History:
* 12-11-93 JimA         Created.
\***************************************************************************/

VOID DereferenceClass(
    PWND pwnd)
{
    PCLS pcls = pwnd->pcls;
    PPCLS ppcls;

    UserAssert(pcls->cWndReferenceCount >= 1);

    pwnd->pcls = NULL;

    pcls->cWndReferenceCount--;
    if (pcls != pcls->pclsBase) {

        UserAssert(pcls->pclsBase->cWndReferenceCount >= 1);

        pcls->pclsBase->cWndReferenceCount--;

        if (pcls->cWndReferenceCount == 0) {
            ppcls = &pcls->pclsBase->pclsClone;
            while ((*ppcls) != pcls)
                ppcls = &(*ppcls)->pclsNext;
            UserAssert(ppcls);
            DestroyClass(ppcls);
        }
    }
}


/***************************************************************************\
* DestroyProcessesClasses
*
* History:
* 04-07-91 DarrinM      Created.
\***************************************************************************/

VOID DestroyProcessesClasses(
    PPROCESSINFO ppi)
{
    PPCLS ppcls;

    /*
     * Destroy the private classes first
     */
    ppcls = &(ppi->pclsPrivateList);
    while (*ppcls != NULL) {
        DestroyClass(ppcls);
    }

    /*
     * Then the cloned public classes
     */
    ppcls = &(ppi->pclsPublicList);
    while (*ppcls != NULL) {
        DestroyClass(ppcls);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\classchg.c ===
/****************************** Module Header ******************************\
* Module Name: class.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains RegisterClass and the related window class management
* functions.
*
* History:
*  12-20-94  FritzS
*
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

BOOL VisWindow(PWND,DWORD);


/***************************************************************************\
*  xxxSetClassIconEnum
*
*
\***************************************************************************/

BOOL xxxSetClassIconEnum(
    PWND   pwnd,
    LPARAM lParam)
{
    CheckLock(pwnd);

    if (pwnd->pcls == (PCLS)lParam) {
        /*
         * If the window doesn't have a small icon or it comes from
         * WM_QUERYDRAGICON, redraw the title.  In the WM_QUERYDRAGICON
         * case, get rid of the small icon so redrawing the title will
         * create it if necessary.
         */
        if (TestWF(pwnd, WFSMQUERYDRAGICON))
            DestroyWindowSmIcon(pwnd);

        if (!_GetProp(pwnd, MAKEINTATOM(gpsi->atomIconSmProp),PROPF_INTERNAL))
            xxxRedrawTitle(pwnd, DC_ICON);
    }

    return TRUE;
}

/***************************************************************************\
*  SetClassIcon
*
*  Changes the big/small icon of a class.  Called from SetClassWord().
*
\***************************************************************************/

PCURSOR xxxSetClassIcon(
    PWND    pwnd,
    PCLS    pcls,
    PCURSOR pCursor,
    int     gcw)
{
    PTHREADINFO pti = PtiCurrent();
    PCURSOR     pCursorOld;
    HCURSOR     hCursorOld;
    TL          tlpwndChild;
    BOOL        fRedraw;

    CheckLock(pwnd);

    /*
     * Save old icon
     */
    pCursorOld = ((gcw == GCLP_HICON) ? pcls->spicn : pcls->spicnSm);

    if (pCursorOld != pCursor) {

        fRedraw = TRUE;

        hCursorOld = PtoH(pCursorOld);

        /*
         * Set new icon
         */
        if (gcw == GCLP_HICON) {

            /*
             * Destroy private cached small icon first.
             */
            if (pcls->spicnSm && !DestroyClassSmIcon(pcls))
                fRedraw = FALSE;

            Lock(&(pcls->spicn), pCursor);

        } else {

            /*
             * We don't allow apps to see the small icons we create from
             * their big icons.  They can see their own.  Saves memory
             * leak problems and is easier.
             */
            if (pcls->CSF_flags & CSF_CACHEDSMICON) {
                DestroyClassSmIcon(pcls);
                hCursorOld = NULL;
            }

            Lock(&(pcls->spicnSm), pCursor);
        }

        if (pcls->spicn && !pcls->spicnSm)
            xxxCreateClassSmIcon(pcls);

        if (fRedraw) {

            if (pcls->cWndReferenceCount > 1) {
                ThreadLock(pti->rpdesk->pDeskInfo->spwnd->spwndChild, &tlpwndChild);
                xxxInternalEnumWindow(pti->rpdesk->pDeskInfo->spwnd->spwndChild,
                                      xxxSetClassIconEnum,
                                      (LPARAM)pcls,
                                      BWL_ENUMLIST);
                ThreadUnlock(&tlpwndChild);
            } else {
                xxxSetClassIconEnum(pwnd, (LPARAM)pcls);
            }
        }

        /*
         * Revalidate the old cursor
         */
        if (hCursorOld != NULL) {
            pCursorOld = HMRevalidateHandleNoRip(hCursorOld);
        } else {
            pCursorOld = NULL;
        }
    }

    return(pCursorOld);
}

/***************************************************************************\
*  DestroyClassSmIcon()
*
*  Destroys the small icon of a class if we've created a cached one.
*
\***************************************************************************/

BOOL DestroyClassSmIcon(
    PCLS pcls)
{

    /*
     * If we don't have a cached icon, then no work.
     */
    if (pcls->CSF_flags & CSF_CACHEDSMICON) {
        if (pcls->spicnSm) {
            _DestroyCursor(pcls->spicnSm, CURSOR_ALWAYSDESTROY);
            Unlock(&pcls->spicnSm);
        }
        pcls->CSF_flags &= ~CSF_CACHEDSMICON;
        return TRUE;
    }

    return FALSE;
}

/***************************************************************************\
*  xxxCreateClassSmIcon
*
*  Creates a cached class small icon from a class big icon.
*
\***************************************************************************/

VOID xxxCreateClassSmIcon(
    PCLS pcls)
{
    PCURSOR pcur;

    UserAssert(pcls->cWndReferenceCount > 0);
    UserAssert(pcls->spicn);
    UserAssert(!pcls->spicnSm);

    pcur = xxxClientCopyImage(PtoH(pcls->spicn),
            pcls->spicn->rt == PTR_TO_ID(RT_ICON) ? IMAGE_ICON : IMAGE_CURSOR,
            SYSMET(CXSMICON),
            SYSMET(CYSMICON),
            LR_DEFAULTCOLOR | LR_COPYFROMRESOURCE);

    Lock(&pcls->spicnSm, pcur);
    if (pcls->spicnSm)
        pcls->CSF_flags |= CSF_CACHEDSMICON;
}

/***************************************************************************\
*  SetWindowStyle
*
*  Changes the style bits of a window.  Called from SetWindowLong().  This
*  sends two messages, a changing and a changed.  Upon receipt of a
*  WM_STYLECHANGING message, a window can muck with the style bits for
*  validation purposes.  The WM_STYLECHANGED message is simply after the
*  fact.
*
\***************************************************************************/

LONG xxxSetWindowStyle(
    PWND  pwnd,
    int   gwl,
    DWORD styleNew)
{
    STYLESTRUCT sty;
    BOOL        fWasChild;
    BOOL        fIsChild;
    BOOL        fBefore;
    BOOL        fAfter;

    CheckLock(pwnd);
    UserAssert(IsWinEventNotifyDeferredOK());

    /*
     * HACK-O-RAMA
     * A STYLESTRUCT currently has just one field: a DWORD for the style.
     * Therefore, conveniently, we can pass a pointer into the stack for
     * LPARAM.  But, if we add stuff, we'll have to change this.
     */
    sty.styleOld = ((gwl == GWL_STYLE) ? pwnd->style : pwnd->ExStyle);
    sty.styleNew = styleNew;

    /*
     * Note that we don't do validation before _and_ after.  It is sufficient
     * to do our stuff at the end.
     */

    /*
     * We break Quicken 2.0 if we send the messages.  That's why we version
     * switch them.
     */

    /*
     * Send a WM_STYLECHANGING message to the window, so it can muck with
     * the style bits.  Like validate some stuff.
     */
    if (TestWF(pwnd, WFWIN40COMPAT)) {
        xxxSendMessage(pwnd, WM_STYLECHANGING, gwl, (LPARAM)(LPSTYLESTRUCT)&sty);
    }

    /*
     * Now do our own validation.
     */
    if (gwl == GWL_STYLE) {

        BOOL fWasVisWindow;

        /*
         * If this is an edit control that has ES_PASSWORD set and
         * the caller does not own it and is trying to reset it,
         * fail the call.
         */
        if (PpiCurrent() != GETPTI(pwnd)->ppi && IS_EDIT(pwnd) &&
            (sty.styleOld & ES_PASSWORD) && !(sty.styleNew & ES_PASSWORD)) {
            RIPERR0(ERROR_ACCESS_DENIED, RIP_WARNING, "Access denied in xxxSetWindowStyle");
            return 0;
        }

        /* Listbox ownerdraw style check was moved to the client side (client\ntstubs.c) */

        /*
         * Do proper validation on style bits
         */
        if (pwnd->spwndParent == PWNDDESKTOP(pwnd))
            sty.styleNew |= WS_CLIPSIBLINGS;

        /*
         * If the clipping-ness is changing, invalidate the dc cache.
         */
        if ((sty.styleNew & (WS_CLIPCHILDREN | WS_CLIPSIBLINGS)) !=
            (sty.styleOld & (WS_CLIPCHILDREN | WS_CLIPSIBLINGS))) {

            /*
             * No need to DeferWinEventNotify() - pwnd is locked
             */
            zzzInvalidateDCCache(pwnd, IDC_DEFAULT);
        }

        /*
         * This breaks all Paradox dialogs 1.0-5.0 that have combos.  They
         * enumerate all child windows, add on minimized, then sit in a peek
         * loop.  After that they enumerate all child windows and remove
         * WS_MINIMIZE--except the code below won't let them.
         *
         * Result is weird painting and an inability to use the dialog any
         * more short of dismissing it
         *
         * Temp fix:  Check for child window first.
         */

        /*
         * if this window is REALLY minimized (minimized bit is set and caption
         * present bit is removed), then don't allow app to remove the minimize
         * bit -- this fixes FoxBlow's attempt at being the OS -- jeffbog
         */
        if (!TestWF(pwnd, WFCHILD) &&
                TestWF(pwnd, WFMINIMIZED) &&
                !TestWF(pwnd, WFCPRESENT) &&
                !(sty.styleNew & WS_MINIMIZE)) {

            sty.styleNew |= WS_MINIMIZE;
        }

        /*
         * If we're changing the child bit, deal with spmenu appropriately.
         * If we're turning into a child, change spmenu to an id. If we're
         * turning into a top level window, turn spmenu into a menu.
         */
        fWasChild = TestwndChild(pwnd);

        pwnd->style = sty.styleNew;

        fIsChild = TestwndChild(pwnd);

        /*
         * If we turned into a top level window, change spmenu to NULL.
         * If we turned into a child from a top level window, unlock spmenu.
         */
        if (fWasChild && !fIsChild)
            pwnd->spmenu = NULL;

        if (!fWasChild && fIsChild) {
            ClrWF(pwnd, WFMPRESENT);
            UnlockWndMenu(pwnd, &pwnd->spmenu);
        }

        /*
         * If the visible, child, or minimized style is changing,
         * then update the cVisWindows count
         */
        fWasVisWindow = VisWindow(pwnd, sty.styleOld);
        if (fWasVisWindow != VisWindow(pwnd, sty.styleNew))
        {

#if DBG
            if (TestWF(pwnd, WFINDESTROY)) {
                RIPMSG1(RIP_ERROR, "xxxSetWindowStyle: window INDESTROY 0x%08X", pwnd);
            }
#endif

//            IncDecVisWindows(pwnd, !fWasVisWindow);
            if (fWasVisWindow)
                DecVisWindows(pwnd);
            else
                IncVisWindows(pwnd);
        }
    } else {
        /*
         * First, see if the app might be setting bits that it really
         * doesn't know about.  If so, replace those bits with the
         * current values.
         */
        if (GetAppCompatFlags2(VER40) & GACF2_NO50EXSTYLEBITS) {
            sty.styleNew &= WS_EX_VALID40;
        } else {
            /*
             * Don't let aplications set unused extended bits
             * Mcostea #237449
             */
#if DBG
            if (sty.styleNew & ~WS_EX_ALLVALID) {
                RIPMSG0(RIP_WARNING, "Trying to set reserved exStyle bits in SetWindowLong");
            }
#endif
            sty.styleNew &= WS_EX_ALLVALID;
        }
        /*
         * Is someone trying to toggle the WS_EX_TOPMOST style bit?
         */
        if ((sty.styleOld & WS_EX_TOPMOST) != (sty.styleNew & WS_EX_TOPMOST)) {

#if DBG
            /*
             * Rip in debug about this
             */
            RIPMSG0(RIP_WARNING, "Can't change WS_EX_TOPMOST with SetWindowLong");
#endif

            /*
             * BACKWARDS COMPATIBILITY HACK
             * If stuff is getting stored in the high word, then it must be
             * Lotus 123-W sticking a FAR pointer in this field.  So don't
             * modify it.
             */
            if (TestWF(pwnd, WFWIN40COMPAT) || !HIWORD(sty.styleNew)) {

                /*
                 * Don't let the bit be flipped
                 */
                sty.styleNew &= ~WS_EX_TOPMOST;
                sty.styleNew |= (sty.styleOld & WS_EX_TOPMOST);
            }
        }

        /*
         * Check pwnd->ExStyle directly since sty.styleOld can now be
         * different from the real state of the window, because of the
         * callbacks in this function from the time sty.styleOld was
         * remembered and up to now. We must call the layering functions
         * based on the real state of the layering bit.
         */
        fBefore = (pwnd->ExStyle & WS_EX_LAYERED);
        fAfter = (sty.styleNew & WS_EX_LAYERED);

        if (fBefore && !fAfter) {
            UnsetLayeredWindow(pwnd);
        } else if (!fBefore && fAfter) {
            if (!xxxSetLayeredWindow(pwnd, TRUE)) {
                return 0;
            }
        }

        fBefore = (pwnd->ExStyle & WS_EX_COMPOSITED);
        fAfter = (sty.styleNew & WS_EX_COMPOSITED);

        if (!fBefore && fAfter) {
            /*
             * If we are turning WS_EX_COMPOSITED on, none of our parents
             * should already have WS_EX_COMPOSITED turned on.  If any do,
             * since we were explicitely trying to turn this style on, fail
             * the call.
             */

            if (GetStyleWindow(pwnd->spwndParent, WEFCOMPOSITED) != NULL) {
                return 0;
            }
        }

        if (fBefore && !fAfter) {
            UnsetRedirectedWindow(pwnd, REDIRECT_COMPOSITED);
        } else if (!fBefore && fAfter) {
            if (!SetRedirectedWindow(pwnd, REDIRECT_COMPOSITED)) {
                return 0;
            }

            /*
             * We have successfully turned WS_EX_COMPOSITED on for ourself, so
             * need to ensure that none of our child have WS_EX_COMPOSITED also
             * turned on.
             */

            xxxTurnOffCompositing(pwnd, TRUE);
        }

#ifdef REDIRECTION
        {

            BOOL fVisrgnChange = FALSE;
            fBefore = (pwnd->ExStyle & WS_EX_EXTREDIRECTED);
            fAfter = (sty.styleNew & WS_EX_EXTREDIRECTED);

            if (fBefore && !fAfter) {
                UnsetRedirectedWindow(pwnd, REDIRECT_EXTREDIRECTED);
                fVisrgnChange = TRUE;
            } else if (!fBefore && fAfter) {
                if (!SetRedirectedWindow(pwnd, REDIRECT_EXTREDIRECTED)) {
                    return 0;
                }
                fVisrgnChange = TRUE;
            }

            if (fVisrgnChange) {
                BEGINATOMICCHECK();
                zzzInvalidateDCCache(pwnd, IDC_DEFAULT | IDC_NOMOUSE);
                ENDATOMICCHECK();
            }
        }
#endif // REDIRECTION

        /*
         * The bits we use internally should be preserved
         */
        pwnd->ExStyle = sty.styleNew | (pwnd->ExStyle & ~WS_EX_ALLVALID);
        if ((sty.styleOld ^ sty.styleNew)
            & (WS_EX_LEFTSCROLLBAR | WS_EX_RIGHT | WS_EX_RTLREADING | WS_EX_LAYOUTRTL)) {
            xxxRedrawFrame(pwnd);
        }
    }

    /*
     * See if we still need the 3D edge since the window styles changed.
     */
    if (NeedsWindowEdge(pwnd->style, pwnd->ExStyle, TestWF(pwnd, WFWIN40COMPAT)))
        SetWF(pwnd, WEFWINDOWEDGE);
    else
        ClrWF(pwnd, WEFWINDOWEDGE);

    /*
     * Send a WM_STYLECHANGED message
     */
    if (TestWF(pwnd, WFWIN40COMPAT))
        xxxSendMessage(pwnd, WM_STYLECHANGED, gwl, (LPARAM)(LPSTYLESTRUCT)&sty);

    return(sty.styleOld);
}

/***************************************************************************\
* VisWindow
*
*  Based on style, determines if this is considered to be "visible" by
*  queue foreground styles.
*
\***************************************************************************/

BOOL VisWindow(
    PWND pwnd,
    DWORD style)
{
    return(FTopLevel(pwnd) &&
            !(style & WS_MINIMIZE) &&
            (style & WS_VISIBLE));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\cursor.c ===
/****************************** Module Header ******************************\
* Module Name: cursor.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains code for dealing with cursors.
*
* History:
* 03-Dec-1990 DavidPe   Created.
* 01-Feb-1991 MikeKe    Added Revalidation code (None)
* 12-Feb-1991 JimA      Added access checks
* 21-Jan-1992 IanJa     ANSI/Unicode neutralized (null op)
* 02-Aug-1992 DarrinM   Added animated cursor code
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop
/***************************************************************************\
* zzzSetCursor (API)
*
* This API sets the cursor image for the current thread.
*
* History:
* 12-03-90 DavidPe      Created.
\***************************************************************************/

PCURSOR zzzSetCursor(
    PCURSOR pcur)
{
    PQ      pq;
    PCURSOR pcurPrev;
    PTHREADINFO  ptiCurrent = PtiCurrent();

    pq = ptiCurrent->pq;

    pcurPrev = pq->spcurCurrent;

    if (pq->spcurCurrent != pcur) {

        /*
         * Lock() returns pobjOld - if it is still valid.  Don't want to
         * return a pcurPrev that is an invalid pointer.
         */
        pcurPrev = LockQCursor(pq, pcur);

        /*
         * If no thread 'owns' the cursor, we must be in initialization
         * so go ahead and assign it to ourself.
         */
        if (gpqCursor == NULL)
            gpqCursor = pq;

        /*
         * If we're changing the local-cursor for the thread currently
         * representing the global-cursor, update the cursor image now.
         */
        if (pq == gpqCursor) {
            TL tlpcur;
            ThreadLockWithPti(ptiCurrent, pcurPrev, &tlpcur);
            zzzUpdateCursorImage();
            pcurPrev = ThreadUnlock(&tlpcur);
        }
    }

    return pcurPrev;
}

/***************************************************************************\
* zzzSetCursorPos (API)
*
* This API sets the cursor position.
*
* History:
* 03-Dec-1990 DavidPe  Created.
* 12-Feb-1991 JimA     Added access check
* 16-May-1991 mikeke   Changed to return BOOL
\***************************************************************************/

BOOL zzzSetCursorPos(
    int x,
    int y)
{
    /*
     * Blow it off if the caller doesn't have the proper access rights
     */
    if (!CheckWinstaWriteAttributesAccess()) {
        return FALSE;
    }

    zzzInternalSetCursorPos(x, y);

    /*
     * Save the absolute coordinates in the global array
     * for GetMouseMovePointsEx.
     */
    SAVEPOINT(x, y,
              SYSMET(CXVIRTUALSCREEN) - 1,
              SYSMET(CYVIRTUALSCREEN) - 1,
              NtGetTickCount(), 0);

    return TRUE;
}

/***************************************************************************\
* zzzInternalSetCursorPos
*
* This function is used whenever the server needs to set the cursor
* position, regardless of the caller's access rights.
*
* History:
* 12-Feb-1991 JimA      Created.
\***************************************************************************/
VOID zzzInternalSetCursorPos(
    int      x,
    int      y
    )
{

    gptCursorAsync.x = x;
    gptCursorAsync.y = y;

    BoundCursor(&gptCursorAsync);

    gpsi->ptCursor = gptCursorAsync;
    /*
     * Pass MP_PROCEDURAL as the last parameter so that in the
     * remote case we send an updated mouse position to the client
     */
    GreMovePointer(gpDispInfo->hDev, gpsi->ptCursor.x, gpsi->ptCursor.y,
                   MP_PROCEDURAL);

    /*
     * Cursor has changed position, so generate a mouse event so the
     * window underneath the new location knows it's there and sets the
     * shape accordingly.
     */
    zzzSetFMouseMoved();
}

/***************************************************************************\
* IncCursorLevel
* DecCursorLevel
*
* Keeps track of this thread show/hide cursor level as well as the queue
* it is associated with. Thread levels are done so that when
* AttachThreadInput() is called we can do exact level calculations in the
* new queue.
*
* 15-Jan-1993 ScottLu   Created.
\***************************************************************************/

VOID IncCursorLevel(
    PTHREADINFO pti)
{
    pti->iCursorLevel++;
    pti->pq->iCursorLevel++;
}

VOID DecCursorLevel(
    PTHREADINFO pti)
{
    pti->iCursorLevel--;
    pti->pq->iCursorLevel--;
}

/***************************************************************************\
* zzzShowCursor (API)
*
* This API allows the application to hide or show the cursor image.
*
* History:
* 03-Dec-1990 JimA      Implemented for fake cursor stuff
\***************************************************************************/

int zzzShowCursor(
    BOOL fShow)
{
    PTHREADINFO pti = PtiCurrent();
    PQ          pq;
    int         iCursorLevel;

    pq = pti->pq;
    /*
     * To preserve pq
     */
    DeferWinEventNotify();

    if (fShow) {

        IncCursorLevel(pti);

        if ((pq == gpqCursor) && (pq->iCursorLevel == 0))
            zzzUpdateCursorImage();

    } else {

        DecCursorLevel(pti);

        if ((pq == gpqCursor) && (pq->iCursorLevel == -1))
            zzzUpdateCursorImage();
    }

    iCursorLevel = pq->iCursorLevel;
    zzzEndDeferWinEventNotify();

    return iCursorLevel;
}

/***************************************************************************\
* zzzClipCursor (API)
*
* This API sets the cursor clipping rectangle which restricts where the
* cursor can go.  If prcClip is NULL, the clipping rectangle will be the
* screen.
*
* History:
* 03-Dec-1990 DavidPe   Created.
* 16-May-1991 MikeKe    Changed to return BOOL
\***************************************************************************/

BOOL zzzClipCursor(
    LPCRECT prcClip)
{
    PEPROCESS Process = PsGetCurrentProcess();

    /*
     * Don't let this happen if it doesn't have access.
     */
    if (Process != gpepCSRSS && !CheckWinstaWriteAttributesAccess()) {
        return FALSE;
    }

    /*
     * The comment from NT 3.51:
     *     Non-foreground threads can only set the clipping rectangle
     *     if it was empty, or if they are restoring it to the whole screen.
     *
     * But the code from NT 3.51 says "IsRectEmpty" instead of
     * "!IsRectEmpty", as would follow from the comment. We leave
     * the code as it was, as following the comment appears to
     * break apps.
     *
     * CONSIDER: Removing this test altogether after NT4.0 ships.
     */
    if (    PtiCurrent()->pq != gpqForeground &&
            prcClip != NULL &&
            IsRectEmpty(&grcCursorClip)) {
        RIPERR0(ERROR_ACCESS_DENIED, RIP_WARNING, "Access denied in _ClipCursor");
        return FALSE;
    }

    if (prcClip == NULL) {

        grcCursorClip = gpDispInfo->rcScreen;

    } else {

        /*
         * Never let our cursor leave the screen. Can't use IntersectRect()
         * because it doesn't allow rects with 0 width or height.
         */
        grcCursorClip.left   = max(gpDispInfo->rcScreen.left  , prcClip->left);
        grcCursorClip.right  = min(gpDispInfo->rcScreen.right , prcClip->right);
        grcCursorClip.top    = max(gpDispInfo->rcScreen.top   , prcClip->top);
        grcCursorClip.bottom = min(gpDispInfo->rcScreen.bottom, prcClip->bottom);

        /*
         * Check for invalid clip rect.
         */
        if (grcCursorClip.left > grcCursorClip.right ||
            grcCursorClip.top > grcCursorClip.bottom) {

            grcCursorClip = gpDispInfo->rcScreen;
        }
    }

    /*
     * Update the cursor position if it's currently outside the
     * cursor clip-rect.
     */
    if (!PtInRect(&grcCursorClip, gpsi->ptCursor)) {
        zzzInternalSetCursorPos(gpsi->ptCursor.x, gpsi->ptCursor.y);
    }

    return TRUE;
}

/***************************************************************************\
* BoundCursor
*
* This rountine 'clips' gptCursorAsync to be within rcCursorClip.  This
* routine treats rcCursorClip as non-inclusive so the bottom and right sides
* get bound to rcCursorClip.bottom/right - 1.
*
* Is called in OR out of the USER critical section!! IANJA
*
* History:
* 03-Dec-1990 DavidPe   Created.
\***************************************************************************/
#ifdef LOCK_MOUSE_CODE
#pragma alloc_text(MOUSE, BoundCursor)
#endif

VOID BoundCursor(
    LPPOINT lppt)
{
    if (TEST_PUDF(PUDF_VDMBOUNDSACTIVE) && gspwndFullScreen != NULL) {

        if (lppt->x < grcVDMCursorBounds.left) {
            lppt->x = grcVDMCursorBounds.left;
        } else if (lppt->x >= grcVDMCursorBounds.right) {
            lppt->x = grcVDMCursorBounds.right - 1;
        }

        if (lppt->y < grcVDMCursorBounds.top) {
            lppt->y = grcVDMCursorBounds.top;
        } else if (lppt->y >= grcVDMCursorBounds.bottom) {
            lppt->y = grcVDMCursorBounds.bottom - 1;
        }

    } else {

        if (lppt->x < grcCursorClip.left) {
            lppt->x = grcCursorClip.left;
        } else if (lppt->x >= grcCursorClip.right) {
            lppt->x = grcCursorClip.right - 1;
        }

        if (lppt->y < grcCursorClip.top) {
            lppt->y = grcCursorClip.top;
        } else if (lppt->y >= grcCursorClip.bottom) {
            lppt->y = grcCursorClip.bottom - 1;
        }
    }

    /*
     * If we have more than one monitor, then we need to clip the
     * cursor to a point on the desktop.
     */
    if (!gpDispInfo->fDesktopIsRect) {
        ClipPointToDesktop(lppt);
    }
}

/***************************************************************************\
* SetVDMCursorBounds
*
* This routine is needed so when a vdm is running, the mouse is not bounded
* by the screen. This is so the vdm can correctly virtualize the DOS mouse
* device driver. It can't deal with user always bounding to the screen,
* so it sets wide open bounds.
*
* 20-May-1993 ScottLu       Created.
\***************************************************************************/

VOID SetVDMCursorBounds(
    LPRECT lprc)
{
    if (lprc != NULL) {

        /*
         * Set grcVDMCursorBounds before TEST_PUDF(PUDF_VDMBOUNDSACTIVE), because
         * MoveEvent() calls BoundCursor() from outside the USER CritSect!
         */
        grcVDMCursorBounds = *lprc;
        SET_PUDF(PUDF_VDMBOUNDSACTIVE);

    } else {

        /*
         * Turn vdm bounds off.
         */
        CLEAR_PUDF(PUDF_VDMBOUNDSACTIVE);
    }
}

/***************************************************************************\
* zzzAnimateCursor
*
* When an animated cursor is loaded and the wait cursor is up this routine
* gets called to maintain the cursor animation.
*
* Should only be called by the cursor animation timer.
*
* History:
* 02-Oct-1991 DarrinM      Created.
* 03-Aug-1994 SanfordS     Calibrated.
\***************************************************************************/

#if defined (_M_IX86) && (_MSC_VER <= 1100)
#pragma optimize("s", off)
#endif

VOID zzzAnimateCursor(
    PWND  pwndDummy,
    UINT  message,
    UINT_PTR nID,
    LPARAM lParam)
{
    int   iicur;
    PACON pacon;
    TL    tlpacon;
    int   LostTime;
    int   tTime;

    UNREFERENCED_PARAMETER(pwndDummy);
    UNREFERENCED_PARAMETER(message);
    UNREFERENCED_PARAMETER(nID);
    UNREFERENCED_PARAMETER(lParam);

    pacon = (PACON)gpcurLogCurrent;

    if (pacon == NULL || !(pacon->CURSORF_flags & CURSORF_ACON)) {
        gdwLastAniTick = 0;
        return;
    }

    /*
     * Find out actual time loss since last update.
     */
    if (gdwLastAniTick) {

        LostTime = NtGetTickCount() - gdwLastAniTick -
                (pacon->ajifRate[pacon->iicur] * 100 / 6);

        if (LostTime < 0) {
            LostTime = 0;
        }
    } else {
        LostTime = 0;
    }

    /*
     * Increment the animation index.
     */
    iicur = pacon->iicur + 1;
    if (iicur >= pacon->cicur) {
        iicur = 0;
    }

    pacon->iicur = iicur;

    /*
     * This forces the new cursor to be drawn.
     */
    ThreadLockAlways(pacon, &tlpacon);
    zzzUpdateCursorImage();

    tTime = pacon->ajifRate[iicur] * 100 / 6;

    while (tTime < LostTime) {

        /*
         * Animation is outrunning our ability to render it - skip frames
         * to catch up.
         */
        LostTime -= tTime;

        /*
         * Increment the animation index.
         */
        iicur = pacon->iicur + 1;
        if (iicur >= pacon->cicur)
            iicur = 0;

        pacon->iicur = iicur;

        tTime = pacon->ajifRate[iicur] * 100 / 6;
    }
    ThreadUnlock(&tlpacon);

    gdwLastAniTick = NtGetTickCount() - LostTime;
    gidCursorTimer = InternalSetTimer(NULL, gidCursorTimer, tTime - LostTime, zzzAnimateCursor, TMRF_RIT | TMRF_ONESHOT);
}

/**************************************************************************\
* FCursorShadowed
*
\**************************************************************************/

__inline FCursorShadowed(PCURSINFO pci)
{
    return (TestALPHA(CURSORSHADOW) && (pci->CURSORF_flags & CURSORF_SYSTEM));
}

#if defined (_M_IX86) && (_MSC_VER <= 1100)
#pragma optimize("", on)
#endif

/**************************************************************************\
* zzzUpdateCursorImage
*
* History:
* 14-Jan-1992 DavidPe   Created.
* 09-Aug-1992 DarrinM   Added animated cursor code.
* 01-Oct-2000 JasonSch  Added autorun cursor code.
\**************************************************************************/
VOID zzzUpdateCursorImage(
    VOID)
{
    PCURSOR pcurLogNew;
    PCURSOR pcurPhysNew;
    PACON   pacon;
    PCURSOR pcurPhysOld;
    DWORD   event;

#ifdef GENERIC_INPUT
    /*
     * WindowsBug 298252
     * Even though the mouse pointer is outside
     * the GenericInput aware app, allow it to hide
     * the mouse cursor if mouse is captured.
     * i.e. use gpqForeground instead of gpqCursor.
     */
    if (gpqForeground) {
        PTHREADINFO ptiMouse = PtiMouseFromQ(gpqForeground);

        if (TestRawInputMode(ptiMouse, CaptureMouse)) {
            if (gpqForeground->iCursorLevel < 0) {
                pcurLogNew = NULL;
                goto force_setnull;
            }
        }
    }
#endif

    if (gpqCursor == NULL)
        return;

    if ((gpqCursor->iCursorLevel < 0) || (gpqCursor->spcurCurrent == NULL)) {

        pcurLogNew = NULL;

    } else {

        /*
         * Assume we're using the current cursor.
         */
        pcurLogNew = gpqCursor->spcurCurrent;

        /*
         * Check to see if we should use the "app starting" or the "autorun"
         * cursor.
         */
        if (gtimeStartCursorHide != 0
#ifdef AUTORUN_CURSOR
        || gtmridAutorunCursor != 0
#endif
        ) {

            if (gpqCursor->spcurCurrent == SYSCUR(ARROW) ||
#ifdef AUTORUN_CURSOR
                gpqCursor->spcurCurrent == SYSCUR(AUTORUN) ||
#endif
                gpqCursor->spcurCurrent == SYSCUR(APPSTARTING)) {

#ifdef AUTORUN_CURSOR
                if (gtmridAutorunCursor != 0) {
                    pcurLogNew = SYSCUR(AUTORUN);
                } else {
#endif
                    pcurLogNew = SYSCUR(APPSTARTING);
#ifdef AUTORUN_CURSOR
                }
#endif
            }
        }
    }

#ifdef GENERIC_INPUT
force_setnull:
#endif

    /*
     * If the logical cursor is changing then start/stop the cursor
     * animation timer as appropriate.
     */
    if (pcurLogNew != gpcurLogCurrent) {

        /*
         * If the old cursor was animating, shut off the animation timer.
         */
        if (gtmridAniCursor != 0) {
            /*
             * Disable animation.
             */
            KILLRITTIMER(NULL, gtmridAniCursor);
            gtmridAniCursor = 0;
        }

        /*
         * If the new cursor is animated, start the animation timer.
         */
        if ((pcurLogNew != NULL) && (pcurLogNew->CURSORF_flags & CURSORF_ACON)) {

            /*
             * Start the animation over from the beginning.
             */
            pacon = (PACON)pcurLogNew;
            pacon->iicur = 0;

            gdwLastAniTick = NtGetTickCount();

            /*
             * Use the rate table to keep the timer on track.
             * 1 Jiffy = 1/60 sec = 100/6 ms
             */
            gtmridAniCursor = InternalSetTimer(NULL, gtmridAniCursor,
                    pacon->ajifRate[0] * 100 / 6, zzzAnimateCursor, TMRF_RIT | TMRF_ONESHOT);
        }
    }

    /*
     * If this is an animated cursor, find and use the current frame
     * of the animation.  NOTE: this is done AFTER the AppStarting
     * business so the AppStarting cursor itself can be animated.
     */
    if (pcurLogNew != NULL && pcurLogNew->CURSORF_flags & CURSORF_ACON) {

        pcurPhysNew = ((PACON)pcurLogNew)->aspcur[((PACON)pcurLogNew)->
                aicur[((PACON)pcurLogNew)->iicur]];
    } else {

        pcurPhysNew = pcurLogNew;
    }

    /*
     * Remember the new logical cursor.
     */
    gpcurLogCurrent = pcurLogNew;

    /*
     * If the physical cursor is changing then update screen.
     */
    if (pcurPhysNew != gpcurPhysCurrent) {

        pcurPhysOld = gpcurPhysCurrent;

        gpcurPhysCurrent = pcurPhysNew;

        if (pcurPhysNew == NULL) {

            SetPointer(FALSE);

        } else {
            ULONG fl = 0;

            if (pcurLogNew->CURSORF_flags & CURSORF_ACON) {
                fl |= SPS_ANIMATEUPDATE;
            }
            if (FCursorShadowed(GETPCI(pcurLogNew))) {
                fl |= SPS_ALPHA;
            }
            GreSetPointer(gpDispInfo->hDev, GETPCI(pcurPhysNew), fl, GETMOUSETRAILS(), MOUSE_TRAILS_FREQ);
        }

        /*
         * Notify anyone who cares about the change
         * This can happen on the RIT, so we need to pass on the real
         * thread/process ID.  Hence we use hwndCursor.
         * This comment is from WIn'95 so it may not be true - IanJa.
         *
         * These are the events we send:
         *      hcurPhys now NULL       ->  EVENT_OBJECT_HIDE
         *      hcurPhys was NULL       ->  EVENT_OBJECT_SHOW
         *      hcurPhys changing       ->  EVENT_OBJECT_NAMECHANGE
         * Since we only go through this code if hcurPhys is actually
         * changing, these checks are simple.
         */
        if (!pcurPhysNew) {
            event = EVENT_OBJECT_HIDE;
        } else if (!pcurPhysOld) {
            event = EVENT_OBJECT_SHOW;
        } else {
            event = EVENT_OBJECT_NAMECHANGE;
        }

        zzzWindowEvent(event, NULL, OBJID_CURSOR, INDEXID_CONTAINER, WEF_USEPWNDTHREAD);
    }
}

#if DBG

/***************************************************************************\
* DbgLockQCursor
*
* Special routine to lock cursors into a queue.  Besides a pointer
* to the cursor, the handle is also saved.
* Returns the pointer to the previous current cursor for that queue.
*
* History:
* 26-Jan-1993 JimA      Created.
\***************************************************************************/

PCURSOR DbgLockQCursor(
    PQ      pq,
    PCURSOR pcur)
{
    /*
     * See if the queue is marked for destuction.  If so, we should not
     * be trying to lock a cursor.
     */
    UserAssertMsg0(!(pq->QF_flags & QF_INDESTROY),
                  "LockQCursor: Attempting to lock cursor to freed queue");

    return Lock(&pq->spcurCurrent, pcur);
}

#endif // DBG

/***************************************************************************\
* SetPointer
*
* 29-Mar-1998   vadimg      created
\***************************************************************************/

void SetPointer(BOOL fSet)
{
    if (fSet) {
#ifdef GENERIC_INPUT
        if (gpqForeground) {
            PTHREADINFO ptiMouse = PtiMouseFromQ(gpqForeground);

            if (gpqForeground->iCursorLevel < 0 && TestRawInputMode(ptiMouse, CaptureMouse)) {
                return;
            }
        }
#endif
        if (gpqCursor != NULL && gpqCursor->iCursorLevel >= 0 &&
                gpqCursor->spcurCurrent != NULL &&
                SYSMET(MOUSEPRESENT)) {

            PCURSINFO pci = GETPCI(gpqCursor->spcurCurrent);
            ULONG fl = FCursorShadowed(pci) ? SPS_ALPHA : 0;

            GreSetPointer(gpDispInfo->hDev, pci, fl, GETMOUSETRAILS(), MOUSE_TRAILS_FREQ);
        }
    } else {
        GreSetPointer(gpDispInfo->hDev, NULL, 0, 0, 0);
    }
}

/***************************************************************************\
* HideCursorNoCapture
*
* Set the cursor to NULL if the mouse is not captured.
*
* 20-May-1998   MCostea      created
\***************************************************************************/
VOID zzzHideCursorNoCapture(
    VOID)
{
    PTHREADINFO ptiCurrent = PtiCurrentShared();

    if (!ptiCurrent->pq->spwndCapture &&
            ((GetAppCompatFlags2(VER40) & GACF2_EDITNOMOUSEHIDE) == 0) &&
            TestEffectUP(MOUSEVANISH)) {
        zzzSetCursor(NULL);
    }
}

#ifdef AUTORUN_CURSOR
/***************************************************************************\
* ShowAutorunCursor
*
* Kicks off a system timer that will fire when it's time to hide the autorun
* cursor and calls zzzUpdateCursorImage to change the current cursor to the
* autorun guy.
*
* 02-Oct-2000   JasonSch      Created.
\***************************************************************************/
VOID ShowAutorunCursor(
    ULONG ulTimeout)
{
    EnterCrit();

    /*
     * Create/reset the timer. If we're already set it and it hasn't yet
     * gone off, this will reset the time to whatever we specify (which is
     * the behavior we want).
     */
    gtmridAutorunCursor = InternalSetTimer(NULL,
                                           gtmridAutorunCursor,
                                           ulTimeout,
                                           HideAutorunCursor,
                                           TMRF_RIT);
    LeaveCrit();
}

/***************************************************************************\
* HideAutorunCursor
*
* Destroys the autorun cursor timer and resets the cursor itself.
*
* 02-Oct-2000   JasonSch      Created.
\***************************************************************************/
VOID HideAutorunCursor(
    PWND pwnd,
    UINT message,
    UINT_PTR nID,
    LPARAM lParam)
{
    UINT_PTR uTimerId = gtmridAutorunCursor;

    UNREFERENCED_PARAMETER(pwnd);
    UNREFERENCED_PARAMETER(message);
    UNREFERENCED_PARAMETER(nID);
    UNREFERENCED_PARAMETER(lParam);

    CheckCritIn();

    /*
     * Calling zzzUpdateCursorImage with a NULL gtmridAutorunCursor will
     * cause the cursor to change to whatever is should be (e.g., app
     * starting, if appropriate).
     */
    gtmridAutorunCursor = 0;
    zzzUpdateCursorImage();

    KILLRITTIMER(NULL, uTimerId);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\createw.c ===
/****************************** Module Header ******************************\
* Module Name: createw.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Contains xxxCreateWindow, xxxDestroyWindow, and a few close friends.
*
* Note that during creation or deletion, the window is locked so that
* it can't be deleted recursively.
*
* History:
* 19-Oct-1990 DarrinM   Created.
* 11-Feb-1991 JimA      Added access checks.
* 19-Feb-1991 MikeKe    Added Revalidation code
* 20-Jan-1992 IanJa     ANSI/UNICODE neutralization
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

BOOL WantImeWindow(PWND pwndParent, PWND pwnd);
#if DBG
VOID VerifyWindowLink(PWND pwnd, PWND pwndParent, BOOL fLink);
#endif

/***************************************************************************\
* xxxCreateWindowEx (API)
*
* History:
* 10-18-90 darrinm      Ported from Win 3.0 sources.
* 02-07-91 DavidPe      Added Win 3.1 WH_CBT support.
* 02-11-91 JimA         Added access checks.
* 04-11-92 ChandanC     Added initialization of WOW words
\***************************************************************************/
PWND xxxCreateWindowEx(
    DWORD         dwExStyle,
    PLARGE_STRING cczpstrNVClass,
    PLARGE_STRING cczpstrClass,
    PLARGE_STRING cczpstrName,
    DWORD         style,
    int           x,
    int           y,
    int           cx,
    int           cy,
    PWND          pwndParent,
    PMENU         pMenu,
    HANDLE        hInstance,
    LPVOID        lpCreateParams,
    DWORD         dwExpWinVerAndFlags,
    PACTIVATION_CONTEXT pActCtx)
{
    /*
     * The buffers for Class and Name may be client memory, and access
     * to those buffers must be protected.
     */
    UINT           mask = 0;
    BOOL           fChild;
    BOOL           fDefPos = FALSE;
    BOOL           fStartup = FALSE;
    PCLS           pcls;
    PPCLS          ppcls;
    RECT           rc;
    int            dx, dy;
    SIZERECT       src;
    int            sw = SW_SHOW;
    PWND           pwnd;
    PWND           pwndZOrder, pwndHardError;
    CREATESTRUCTEX csex;
    PDESKTOP       pdesk;
    ATOM           atomT;
    PTHREADINFO    ptiCurrent;
    TL             tlpwnd;
    TL             tlpwndParent;
    TL             tlpwndParentT;
    BOOL           fLockParent = FALSE;
    WORD           wWFAnsiCreator = 0;
    DWORD          dw;
    DWORD          dwMinMax;
    PMONITOR       pMonitor;
    BOOL           fTiled;

    CheckLock(pwndParent);
    UserAssert(IsWinEventNotifyDeferredOK());

    /*
     * For Edit Controls (including those in comboboxes), we must know whether
     * the App used an ANSI or a Unicode CreateWindow call. This is passed in
     * with the private WS_EX_ANSICREATOR dwExStyle bit, but we MUST NOT leave
     * out this bit in the window's dwExStyle! Transfer to the internal window
     * flag WFANSICREATOR immediately.
     */
    if (dwExStyle & WS_EX_ANSICREATOR) {
        wWFAnsiCreator = WFANSICREATOR;
        dwExStyle &= ~WS_EX_ANSICREATOR;
    }


    /*
     * After grocking any bits, we should no longer be using any private bits.
     */
    UserAssert((dwExStyle & WS_EXP_PRIVATE) == 0);

    ptiCurrent = PtiCurrent();
    /*
     * If this thread has already been in xxxDestroyThreadInfo, then this window
     * is probably going to end up with a bogus pti.
     */
    UserAssert(!(ptiCurrent->TIF_flags & TIF_INCLEANUP));
    pdesk = ptiCurrent->rpdesk;

    /*
     * If a parent window is specified, make sure it's on the
     * same desktop.
     */
    if (pwndParent != NULL && pwndParent->head.rpdesk != pdesk) {
        RIPERR0(ERROR_INVALID_PARAMETER, RIP_VERBOSE, "");
        return NULL;
    }

    /*
     * Set a flag indicating whether it is a child window.
     */
    fChild = ((HIWORD(style) & MaskWF(WFTYPEMASK)) == MaskWF(WFCHILD));

    /*
     * The WS_EX_LAYOUT_RTL flag is set if,
     *
     * (1) WS_EX_LAYOUT_RTL set in dwExStyle parameter of the CreateWindow call.
     *
     * (2) If the window is created from DialogBox class, then it can't inherit
     *     from its parent and it has to specify WS_EX_LAYOUTRTL explicitly to
     *     enable mirroring on it.
     *
     * (3) If the window is an owned window then the window is left to right
     *     layout and the algorithm terminates. (An owned window is one created
     *     with an HWND passed in the hWndParent paremeter to CreateWindow(Ex),
     *     but without the WS_CHILD flag present in it's styles.
     *
     * (4) If the window is a child window, and it's parent is right to left
     *     layout, and it's parent does not have the WS_EX_NOINHERIT_LAYOUT flag
     *     set in it's extended styles, then the window is right to left layout
     *     and the algorithm terminates.
     *
     * (5) If the hWndParent parameter to Createwindow(Ex) was NULL, and the
     *     process calling CreateWindow(Ex) has called
     *     SetProcessDefaultLayout(LAYOUT_RTL), then the window is right to left
     *     layout and the algorithm terminates.
     *
     * (6) In all other cases, the layout is left to right.
     */
    if (!(dwExStyle & WS_EX_LAYOUTRTL)) {
        if (pwndParent != NULL) {
            if (fChild && TestWF(pwndParent, WEFLAYOUTRTL) && !TestWF(pwndParent, WEFNOINHERITLAYOUT)) {
                dwExStyle |= WS_EX_LAYOUTRTL;
            }
        } else if (!(!IS_PTR(cczpstrNVClass) && (PTR_TO_ID(cczpstrNVClass) == PTR_TO_ID(DIALOGCLASS)))) {
            if ((PpiCurrent()->dwLayout & LAYOUT_RTL)) {
                dwExStyle |= WS_EX_LAYOUTRTL;
            }
        }
    }

    /*
     * Ensure that we can create the window. If there is no desktop
     * yet, assume that this will be the root desktop window and allow
     * the creation.
     */
    if (ptiCurrent->hdesk) {
        RETURN_IF_ACCESS_DENIED(
                ptiCurrent->amdesk, DESKTOP_CREATEWINDOW, NULL);
    }

    if (fChild) {

        /*
         * Don't allow child windows without a parent handle.
         */
        if (pwndParent == NULL) {
            RIPERR0(ERROR_TLW_WITH_WSCHILD, RIP_VERBOSE, "");
            return NULL;
        }

        if (!ValidateParentDepth(NULL, pwndParent)) {
            RIPERR0(ERROR_INVALID_PARAMETER, RIP_WARNING, "Exceeded nested children limit");
            return NULL;
        }
    }

    /*
     * Make sure we can get the window class.
     */
    if (IS_PTR(cczpstrClass)) {
        /*
         * UserFindAtom protects access of the string.
         */
        atomT = UserFindAtom(cczpstrClass->Buffer);
    } else {
        atomT = PTR_TO_ID(cczpstrClass);
    }

    if (atomT == 0) {
CantFindClassMessageAndFail:
#if DBG
        if (IS_PTR(cczpstrNVClass)) {
            try {
                RIPMSG1(RIP_VERBOSE,
                        "Couldn't find class string %ws",
                        cczpstrNVClass->Buffer);

            } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
            }
        } else {
            RIPMSG1(RIP_VERBOSE,
                    "Couldn't find class atom %lx",
                    cczpstrNVClass);
        }
#endif

        RIPERR0(ERROR_CANNOT_FIND_WND_CLASS, RIP_VERBOSE, "");
        return NULL;
    }

    /*
     * First scan the private classes. If we don't find the class there
     * scan the public classes. If we don't find it there, fail.
     */
    ppcls = GetClassPtr(atomT, ptiCurrent->ppi, hInstance);
    if (ppcls == NULL) {
        goto CantFindClassMessageAndFail;
    }

    pcls = *ppcls;

    if (NeedsWindowEdge(style, dwExStyle, Is400Compat(dwExpWinVerAndFlags))) {
        dwExStyle |= WS_EX_WINDOWEDGE;
    } else {
        dwExStyle &= ~WS_EX_WINDOWEDGE;
    }

    /*
     * Allocate memory for regular windows.
     */
    pwnd = HMAllocObject(
            ptiCurrent, pdesk, TYPE_WINDOW, sizeof(WND) + pcls->cbwndExtra);

    if (pwnd == NULL) {
        RIPERR0(ERROR_OUTOFMEMORY,
                RIP_WARNING,
                "Out of pool in xxxCreateWindowEx");

        return NULL;
    }

    /*
     * Stuff in the pq, class pointer, and window style.
     */
    pwnd->pcls = pcls;
    pwnd->style = style & ~WS_VISIBLE;
    pwnd->ExStyle = dwExStyle & ~(WS_EX_LAYERED | WS_EX_COMPOSITED);
    pwnd->cbwndExtra = pcls->cbwndExtra;

    /*
     * Increment the window reference count in the class structure.
     * Because xxxFreeWindow() decrements the count, incrementing has
     * to be done now. In the case of error, xxxFreeWindow() will decrement it.
     */
    if (!ReferenceClass(pcls, pwnd)) {
        HMFreeObject(pwnd);
        goto CantFindClassMessageAndFail;
    }

    /*
     * Set the window active App context to be activated whenever we call
     * the user WndProc.
     */
    pwnd->pActCtx = pActCtx;

    /*
     * Button control doesn't need input context. Other windows
     * will associate with the default input context.
     * N.b. this comparison needs to be performed on the NV class
     * name.
     */
    if (pcls->atomNVClassName == gpsi->atomSysClass[ICLS_BUTTON]) {
        pwnd->hImc = NULL_HIMC;
    } else {
        pwnd->hImc = (HIMC)PtoH(ptiCurrent->spDefaultImc);
    }

    /*
     * Update the window count. Doing this now will ensure that if
     * the creation fails, xxxFreeWindow will keep the window count
     * correct.
     */
    ptiCurrent->cWindows++;

    /*
     * Get the class from the window because ReferenceClass may have
     * cloned the class.
     */
    pcls = pwnd->pcls;

    /*
     * This is a replacement for the &lpCreateParams stuff that used to
     * pass a pointer directly to the parameters on the stack. This
     * step must be done AFTER referencing the class because we
     * may use the ANSI class name.
     */
    RtlZeroMemory(&csex, sizeof(csex));
    csex.cs.dwExStyle = dwExStyle;
    csex.cs.hInstance = hInstance;

    if (!IS_PTR(cczpstrNVClass)) {
        csex.cs.lpszClass = (LPWSTR)cczpstrNVClass;
    } else {
        if (wWFAnsiCreator) {
            csex.cs.lpszClass = (LPWSTR)pcls->lpszAnsiClassName;
            if (IS_PTR(csex.cs.lpszClass)) {
                RtlInitLargeAnsiString(
                        (PLARGE_ANSI_STRING)&csex.strClass,
                        (LPSTR)csex.cs.lpszClass,
                        (UINT)-1);
            }
        } else {
            csex.cs.lpszClass = cczpstrNVClass->Buffer;
            csex.strClass = *cczpstrNVClass;
        }
    }

    if (cczpstrName != NULL) {
        csex.cs.lpszName = cczpstrName->Buffer;
        csex.strName = *cczpstrName;
    }
    csex.cs.style = style;
    csex.cs.x = x;
    csex.cs.y = y;
    csex.cs.cx = cx;
    csex.cs.cy = cy;
    csex.cs.hwndParent = HW(pwndParent);

    /*
     * If pMenu is non-NULL and the window is not a child, pMenu must
     * be a menu.
     * Child windows get their UIState bits from their parent. Top level ones
     * remain with the default cleared bits.
     *
     * The below test is equivalent to TestwndChild().
     */
    if (fChild) {
        csex.cs.hMenu = (HMENU)pMenu;

        pwnd->ExStyle |= pwndParent->ExStyle & WS_EXP_UIVALID;
#if WS_EXP_UIACCELHIDDEN  !=  0x40000000
#error Fix UISTATE bits copying if you moved the UISTATE bits from ExStyle
#endif

    } else {
        csex.cs.hMenu = PtoH(pMenu);
    }

    csex.cs.lpCreateParams = lpCreateParams;

    /*
     * ThreadLock: we are going to be doing multiple callbacks here.
     */
    ThreadLockAlwaysWithPti(ptiCurrent, pwnd, &tlpwnd);

    /*
     * set the parent to be the desktop window (if exists)
     * before any callback. This way we'll always have a
     * pointer on spwndParent
     */
    if (pwnd->head.rpdesk) {
        Lock(&(pwnd->spwndParent), PWNDMESSAGE(pwnd));
    }

    /*
     * Create the class small icon if there isn't one since we are in context
     * and we are creating a window from this class...
     */
    if (pcls->spicn && !pcls->spicnSm) {
        xxxCreateClassSmIcon(pcls);
    }

    /*
     * Store the instance handle and window proc address. We do this earlier
     * than Windows because they have a bug were a message can be sent
     * but lpfnWndProc is not set (3986 CBT WM_CREATE not allowed.)
     */
    pwnd->hModule = hInstance;

    /*
     * Get rid of EditWndProc plain.
     */
    pwnd->lpfnWndProc = (WNDPROC_PWND)MapClientNeuterToClientPfn(pcls, 0, wWFAnsiCreator);

    /*
     * If this window class has a server-side window procedure, mark
     * it as such. If the app subclasses it later with an app-side proc
     * then this mark will be removed.
     */
    if (pcls->CSF_flags & CSF_SERVERSIDEPROC) {
        SetWF(pwnd, WFSERVERSIDEPROC);
        UserAssert(!(pcls->CSF_flags & CSF_ANSIPROC));
    }

    /*
     * If this window was created with an ANSI CreateWindow*() call, mark
     * it as such so edit controls will be created correctly. (A combobox
     * will be able to pass the WFANSICREATOR bit on to its edit control)
     */
    SetWF(pwnd, wWFAnsiCreator);

    /*
     * If this window belongs to an ANSI class or it is a WFANSICREATOR
     * control, then mark it as an ANSI window
     */
    if ((pcls->CSF_flags & CSF_ANSIPROC) ||
            (wWFAnsiCreator &&
             ((atomT == gpsi->atomSysClass[ICLS_BUTTON]) ||
              (atomT == gpsi->atomSysClass[ICLS_COMBOBOX]) ||
              (atomT == gpsi->atomSysClass[ICLS_COMBOLISTBOX]) ||
              (atomT == gpsi->atomSysClass[ICLS_DIALOG]) ||
              (atomT == gpsi->atomSysClass[ICLS_EDIT]) ||
              (atomT == gpsi->atomSysClass[ICLS_LISTBOX]) ||
              (atomT == gpsi->atomSysClass[ICLS_MDICLIENT]) ||
              (atomT == gpsi->atomSysClass[ICLS_IME]) ||
              (atomT == gpsi->atomSysClass[ICLS_STATIC])))) {
        SetWF(pwnd, WFANSIPROC);
    }

    /*
     * If a 3.1-compatible application is creating the window, set this
     * bit to enable various backward-compatibility hacks.
     *
     * If it's not 3.1 compatible, see if we need to turn on the PixieHack
     * (see wmupdate.c for more info on this)
     */

    dw = GetAppCompatFlags(ptiCurrent);

    if (dw & GACF_RANDOM3XUI) {
        SetWF(pwnd, WFOLDUI);

        dwExStyle &= 0x0000003f;
        csex.cs.dwExStyle &= 0x0000003f;
    }

    pwnd->hMod16  = ((ptiCurrent->TIF_flags & TIF_16BIT) && !TestWF(pwnd, WFSERVERSIDEPROC))? xxxClientWOWGetProcModule(pwnd->lpfnWndProc):0;
    if (Is310Compat(dwExpWinVerAndFlags)) {
        SetWF(pwnd, WFWIN31COMPAT);
        if (Is400Compat(dwExpWinVerAndFlags)) {
            SetWF(pwnd, WFWIN40COMPAT);
            if (Is500Compat(dwExpWinVerAndFlags)) {
                SetWF(pwnd, WFWIN50COMPAT);
            }
        }
    } else if (dw & GACF_ALWAYSSENDNCPAINT) {
        SetWF(pwnd, WFALWAYSSENDNCPAINT);
    }

    /*
     * If we've got a registered DefWindowProc handler, make sure it's DLL
     * is loaded for this process.
     */
    if (IsInsideUserApiHook()) {
        xxxLoadUserApiHook();
    }

    /*
     * Inform the CBT hook that a window is being created. Pass it the
     * CreateParams and the window handle that the new one will be inserted
     * after. The CBT hook handler returns TRUE to prevent the window
     * from being created. It can also modify the CREATESTRUCT info, which
     * will affect the size, parent, and position of the window.
     * Defaultly position non-child windows at the top of their list.
     */

    if (IsHooked(ptiCurrent, WHF_CBT)) {
        CBT_CREATEWND cbt;

        /*
         * Use the extended createstruct so the hook thunk can
         * handle the strings correctly.
         */
        cbt.lpcs = (LPCREATESTRUCT)&csex;
        cbt.hwndInsertAfter = HWND_TOP;

        if ((BOOL)xxxCallHook(HCBT_CREATEWND, (WPARAM)HWq(pwnd),
                (LPARAM)&cbt, WH_CBT)) {

            goto MemError;
        } else {
            /*
             * The CreateHook may have modified some parameters so write them
             * out (in Windows 3.1 we used to write directly to the variables
             * on the stack).
             */

            x = csex.cs.x;
            y = csex.cs.y;
            cx = csex.cs.cx;
            cy = csex.cs.cy;
            if (!IS_PTR(cbt.hwndInsertAfter)) {
                pwndZOrder = (PWND)cbt.hwndInsertAfter;
            } else {
                pwndZOrder = RevalidateHwnd(cbt.hwndInsertAfter);
            }
        }
    } else {
        pwndZOrder = (PWND)HWND_TOP;
    }

    if (!(fTiled = TestwndTiled(pwnd))) {

        /*
         * CW_USEDEFAULT is only valid for tiled and overlapped windows.
         * Don't let it be used.
         */
        if (x == CW_USEDEFAULT || x == CW2_USEDEFAULT) {
            x = 0;
            y = 0;
        }

        if (cx == CW_USEDEFAULT || cx == CW2_USEDEFAULT) {
            cx = 0;
            cy = 0;
        }
    }

    /*
     * Make local copies of these parameters.
     */
    src.x = x;
    src.y  = y;
    src.cx = cx;
    src.cy = cy;

    /*
     *    Position Child Windows
     */
    if (fChild = (BOOL)TestwndChild(pwnd)) {

        /*
         * Child windows are offset from the parent's origin.
         */
        UserAssert(pwndParent);
        if (pwndParent != PWNDDESKTOP(pwnd)) {
            src.x += pwndParent->rcClient.left;
            src.y += pwndParent->rcClient.top;
        }

        /*
         * Defaultly position child windows at bottom of their list.
         */
        pwndZOrder = PWND_BOTTOM;
    }

    /*
     *    Position Tiled Windows
     */

    /*
     * Is this a Tiled/Overlapping window?
     */
    if (fTiled) {

        /*
         * Force the WS_CLIPSIBLINGS window style and add a caption and
         * a border.
         */
        SetWF(pwnd, WFCLIPSIBLINGS);
        mask = MaskWF(WFCAPTION) | MaskWF(WFBORDER);

        //
        // We add on a raised edge since IF the person had passed in WS_CAPTION,
        // and didn't specify any 3D borders, we would've added it on to the
        // style bits above.
        //

        if (TestWF(pwnd, WFWIN40COMPAT)) {
            SetWF(pwnd, WEFWINDOWEDGE);
        }

        /*
         * Set bit that will force size message to be sent at SHOW time.
         */
        SetWF(pwnd, WFSENDSIZEMOVE);

        /*
         * Here is how the "tiled" window initial positioning works...
         * If the app is a 1.0x app, then we use our standard "stair step"
         * default positioning scheme. Otherwise, we check the x & cx
         * parameters. If either of these == CW_USEDEFAULT then use the
         * default position/size, otherwise use the position/size they
         * specified. If not using default position, use SW_SHOW for the
         * xxxShowWindow() parameter, otherwise use the y parameter given.
         *
         * In 32-bit world, CW_USEDEFAULT is 0x80000000, but apps still
         * store word-oriented values either in dialog templates or
         * in their own structures. So CreateWindow still recognizes the
         * 16 bit equivalent, which is 0x8000, CW2_USEDEFAULT. The original
         * is changed because parameters to CreateWindow() are 32 bit
         * values, which can cause sign extention, or weird results if
         * 16 bit math assumptions are being made, etc.
         */

        /*
         * Default to passing the y parameter to xxxShowWindow().
         */
        if (x == CW_USEDEFAULT || x == CW2_USEDEFAULT) {

            /*
             * If the y value is not CW_USEDEFAULT, use it as a SW_* command.
             */
            if (src.y != CW_USEDEFAULT && src.y != CW2_USEDEFAULT) {
                sw = src.y;
            }
        }


        /*
         * Allow the shell to tell us what monitor to run this app on
         */
        pMonitor = NULL;
        if (    x == CW_USEDEFAULT ||
                x == CW2_USEDEFAULT ||
                cx == CW_USEDEFAULT ||
                cx == CW2_USEDEFAULT) {

            if (ptiCurrent->ppi->hMonitor) {
                pMonitor = ValidateHmonitor(ptiCurrent->ppi->hMonitor);
            } else if (pwndParent) {
                pMonitor = _MonitorFromWindow(pwndParent, MONITOR_DEFAULTTONEAREST);
            }
        }

        if (!pMonitor) {
            pMonitor = GetPrimaryMonitor();
        }

        SetTiledRect(pwnd, &rc, pMonitor);

        /*
         * Did the app ask for default positioning?
         */
        if (x == CW_USEDEFAULT || x == CW2_USEDEFAULT) {

            /*
             * Use default positioning.
             */
            if (ptiCurrent->ppi->usi.dwFlags & STARTF_USEPOSITION ) {
                fStartup = TRUE;
                x = src.x = ptiCurrent->ppi->usi.dwX;
                y = src.y = ptiCurrent->ppi->usi.dwY;
            } else {
                x = src.x = rc.left;
                y = src.y = rc.top;
            }
            fDefPos = TRUE;

        } else {

            /*
             * Use the apps specified positioning. Undo the "stacking"
             * effect caused by SetTiledRect().
             */
            if (pMonitor->cWndStack) {
                pMonitor->cWndStack--;
            }
        }

        /*
         * Did the app ask for default sizing?
         */
        if (src.cx == CW_USEDEFAULT || src.cx == CW2_USEDEFAULT) {

            /*
             * Use default sizing.
             */
            if (ptiCurrent->ppi->usi.dwFlags & STARTF_USESIZE) {
                fStartup = TRUE;
                src.cx = ptiCurrent->ppi->usi.dwXSize;
                src.cy = ptiCurrent->ppi->usi.dwYSize;
            } else {
                src.cx = rc.right - x;
                src.cy = rc.bottom - y;
            }
            fDefPos = TRUE;

        } else if (fDefPos) {
            /*
             * The app wants default positioning but not default sizing.
             * Make sure that it's still entirely visible by moving the
             * window.
             */
            dx = (src.x + src.cx) - pMonitor->rcMonitor.right;
            dy = (src.y + src.cy) - pMonitor->rcMonitor.bottom;
            if (dx > 0) {
                x -= dx;
                src.x = x;
                if (src.x < pMonitor->rcMonitor.left) {
                    src.x = x = pMonitor->rcMonitor.left;
                }
            }

            if (dy > 0) {
                y -= dy;
                src.y = y;
                if (src.y < pMonitor->rcMonitor.top) {
                    src.y = y = pMonitor->rcMonitor.top;
                }
            }
        }
    }

    /*
     * If we have used any startup postitions, turn off the startup
     * info so we don't use it again.
     */
    if (fStartup) {
        ptiCurrent->ppi->usi.dwFlags &=
                ~(STARTF_USESIZE | STARTF_USEPOSITION);
    }

    if (TestwndPopup(pwnd)) {
        /*
         * Force the clipsiblings/overlap style.
         */
        SetWF(pwnd, WFCLIPSIBLINGS);
    }

    /*
     * Shove in those default style bits.
     */
    *(((WORD *)&pwnd->style) + 1) |= mask;

    /*
     *    Menu/SysMenu Stuff
     */

    /*
     * If there is no menu handle given and it's not a child window but
     * there is a class menu, use the class menu.
     */
    if (pMenu == NULL && !fChild && (pcls->lpszMenuName != NULL)) {
        UNICODE_STRING strMenuName;

        RtlInitUnicodeStringOrId(&strMenuName, pcls->lpszMenuName);
        pMenu = xxxClientLoadMenu(pcls->hModule, &strMenuName);
        csex.cs.hMenu = PtoH(pMenu);

        /*
         * This load fails if the caller does not have DESKTOP_CREATEMENU
         * permission but that's ok they will just get a window without a menu
         */
    }

    /*
     * Store the menu handle.
     */
    if (TestwndChild(pwnd)) {

        /*
         * It's an id in this case.
         */
        pwnd->spmenu = pMenu;
    } else {

        /*
         * It's a real handle in this case.
         */
        LockWndMenu(pwnd, &pwnd->spmenu, pMenu);
    }

    /*
     *    Parent/Owner Stuff
     */

    /*
     * If this isn't a child window, reset the Owner/Parent info.
     */
    if (!fChild) {
        Lock(&(pwnd->spwndLastActive), pwnd);
        if ((pwndParent != NULL) &&
                (pwndParent != pwndParent->head.rpdesk->spwndMessage) &&
                (pwndParent != pwndParent->head.rpdesk->pDeskInfo->spwnd)) {

            PWND pwndOwner = GetTopLevelWindow(pwndParent);

            if (!ValidateOwnerDepth(pwnd, pwndOwner)) {
                RIPERR1(ERROR_INVALID_PARAMETER,
                        RIP_WARNING,
                        "Exceeded nested owner limit for pwnd %#p",
                        pwnd);
                goto MemError;
            }

#if DBG
            if (pwnd->pcls->atomClassName == gpsi->atomSysClass[ICLS_IME]) {
                UserAssert(!TestCF(pwndOwner, CFIME));
            }
#endif
            Lock(&(pwnd->spwndOwner), pwndOwner);
            if (pwnd->spwndOwner && TestWF(pwnd->spwndOwner, WEFTOPMOST)) {

                /*
                 * If this window's owner is a topmost window, then it has to
                 * be one also since a window must be above its owner.
                 */
                SetWF(pwnd, WEFTOPMOST);
            }

            /*
             * If this is a owner window on another thread, share input
             * state so this window gets z-ordered correctly.
             */
            if (atomT != gpsi->atomSysClass[ICLS_IME] &&
                    pwnd->spwndOwner != NULL &&
                    GETPTI(pwnd->spwndOwner) != ptiCurrent) {
                /*
                 * No need to DeferWinEventNotify() here:  pwnd and pwndParent
                 * are locked and because we called ReferenceClass(pcls, pwnd),
                 * pcls is safe until xxxFreeWindow(pwnd). (IanJa)
                 */
                zzzAttachThreadInput(ptiCurrent, GETPTI(pwnd->spwndOwner), TRUE);
            }

        } else {
            pwnd->spwndOwner = NULL;
        }

#if DBG
        if (ptiCurrent->rpdesk != NULL) {
            UserAssert(!(ptiCurrent->rpdesk->dwDTFlags & (DF_DESTROYED | DF_DESKWNDDESTROYED | DF_DYING)));
        }
#endif
        if ((pwndParent == NULL) ||
               (pwndParent != pwndParent->head.rpdesk->spwndMessage)) {
            pwndParent = _GetDesktopWindow();

            ThreadLockWithPti(ptiCurrent, pwndParent, &tlpwndParent);
            fLockParent = TRUE;
        }
    }

    /*
     * Store backpointer to parent.
     */
    if ((pwnd->spwndNext != NULL) || (pwnd->spwndPrev != NULL)) {
        RIPMSG1(RIP_WARNING, "Window %#p linked in too early (in a hook callback)", pwnd);
        UnlinkWindow(pwnd, pwnd->spwndParent);
    }
    Lock(&(pwnd->spwndParent), pwndParent);

    /*
     *    Final Window Positioning
     */

    if (!TestWF(pwnd, WFWIN31COMPAT)) {
        /*
         * BACKWARD COMPATIBILITY HACK
         *
         * In 3.0, CS_PARENTDC overrides WS_CLIPCHILDREN and WS_CLIPSIBLINGS,
         * but only if the parent is not WS_CLIPCHILDREN.
         * This behavior is required by PowerPoint and Charisma, among others.
         */
        if ((pcls->style & CS_PARENTDC) &&
                !TestWF(pwndParent, WFCLIPCHILDREN)) {
#if DBG
            if (TestWF(pwnd, WFCLIPCHILDREN))
                RIPMSG0(RIP_WARNING, "WS_CLIPCHILDREN overridden by CS_PARENTDC");
            if (TestWF(pwnd, WFCLIPSIBLINGS))
                RIPMSG0(RIP_WARNING, "WS_CLIPSIBLINGS overridden by CS_PARENTDC");
#endif
            ClrWF(pwnd, (WFCLIPCHILDREN | WFCLIPSIBLINGS));
        }
    }

    /*
     * If this is a child window being created in a parent window
     * of a different thread, but not on the desktop, attach their
     * input streams together. [windows with WS_CHILD can be created
     * on the desktop, that's why we check both the style bits
     * and the parent window.]
     */
    if (TestwndChild(pwnd) && (pwndParent != PWNDDESKTOP(pwnd)) &&
            (ptiCurrent != GETPTI(pwndParent))) {
        /*
         * No need to DeferWinEventNotify() - there is an xxx call just below
         */
        zzzAttachThreadInput(ptiCurrent, GETPTI(pwndParent), TRUE);
    }

    /*
     * Make sure the window is between the minimum and maximum sizes.
     */

    /*
     * HACK ALERT!
     * This sends WM_GETMINMAXINFO to a (tiled or sizable) window before
     * it has been created (before it is sent WM_NCCREATE).
     * Maybe some app expects this, so we mustn't reorder the messages.
     */
    xxxAdjustSize(pwnd, &src.cx, &src.cy);

    /*
     * Check for a window being created full screen.
     *
     * Note the check for a non-NULL pdeskParent -- this is important for CreateWindowStation
     */
    if (pwnd->head.rpdesk != NULL &&
        !TestWF(pwnd, WFCHILD) &&
        !TestWF(pwnd, WEFTOOLWINDOW)) {

        xxxCheckFullScreen(pwnd, &src);
    }

    if (src.cx < 0) {
        RIPMSG1(RIP_WARNING, "xxxCreateWindowEx: adjusted cx in pwnd %#p", pwnd);
        src.cx = 0;
    }

    if (src.cy < 0) {
        RIPMSG1(RIP_WARNING, "xxxCreateWindowEx: adjusted cy in pwnd %#p", pwnd);
        src.cy = 0;
    }

    /*
     * Calculate final window dimensions...
     */
    RECTFromSIZERECT(&pwnd->rcWindow, &src);

    if (TestCF2(pcls, CFOWNDC) || (TestCF2(pcls, CFCLASSDC) && pcls->pdce == NULL)) {
        if (NULL == CreateCacheDC(pwnd, DCX_OWNDC, NULL)) {

            RIPMSG1(RIP_WARNING, "xxxCreateWindowEx: pwnd %#p failed to create cached DC",
                    pwnd);

            goto MemError;
        }
    }


    /*
     * Setup Layered and Composited windows.
     *
     * NOTE: This MUST be done AFTER CreateCacheDC() has built any DC's used for
     * OWNDC windows, since the redirection functions need to convert these DC's
     * to use redirection. In Windows 2000, this was done before calling
     * CreateCacheDC(), and would Assert inside ResetOrg() when because a new
     * DC was built that was not setup for redirection.
     */
    if (dwExStyle & WS_EX_LAYERED) {
        if (!xxxSetLayeredWindow(pwnd, FALSE)) {
            RIPMSG1(RIP_WARNING, "xxxCreateWindowEx: pwnd %#p failed to setup layered window", pwnd);
            goto MemError;
        }
    }

    if (dwExStyle & WS_EX_COMPOSITED) {
        /*
         * We only want to turn WS_EX_COMPOSITED on if the parent-chain doesn't
         * already have WS_EX_COMPOSITED turned on.
         */

        if (GetStyleWindow(pwnd->spwndParent, WEFCOMPOSITED) == NULL) {
            if (!SetRedirectedWindow(pwnd, REDIRECT_COMPOSITED)) {
                RIPMSG1(RIP_WARNING, "xxxCreateWindowEx: pwnd %#p failed to setup composited window", pwnd);
                goto MemError;
            }
            SetWF(pwnd, WEFCOMPOSITED);
        }
    }

    /*
     * Update the create struct now that we've modified some passed in
     * parameters.
     */
    csex.cs.x = x;
    csex.cs.y = y;
    csex.cs.cx = cx;
    csex.cs.cy = cy;

    /*
     * Send a NCCREATE message to the window.
     */
    if (!xxxSendMessage(pwnd, WM_NCCREATE, 0L, (LPARAM)&csex)) {

MemError:

#if DBG
        if (!IS_PTR(cczpstrNVClass)) {
            RIPMSG2(RIP_WARNING,
                    (pwndParent) ?
                            "xxxCreateWindowEx failed, Class=%#.4x, ID=%d" :
                            "xxxCreateWindowEx failed, Class=%#.4x",
                    PTR_TO_ID(cczpstrNVClass),
                    (LONG_PTR) pMenu);
        } else {
            RIPMSG2(RIP_WARNING,
                    (pwndParent) ?
                            "xxxCreateWindowEx failed, Class=\"%s\", ID=%d" :
                            "xxxCreateWindowEx failed, Class=\"%s\"",
                    pcls->lpszAnsiClassName,
                    (LONG_PTR) pMenu);
        }
#endif

        if (fLockParent)
            ThreadUnlock(&tlpwndParent);

        /*
         * Set the state as destroyed so any z-ordering events will be ignored.
         * We cannot NULL out the owner field until WM_NCDESTROY is sent or
         * apps like Rumba fault (they call GetParent after every message).
         */
        SetWF(pwnd, WFDESTROYED);

        /*
         * Unset the visible flag so we don't think in xxxDestroyWindow that
         * this window is visible.
         */
        if (TestWF(pwnd, WFVISIBLE)) {
            SetVisible(pwnd, SV_UNSET);
        }

        /*
         * FreeWindow performs a ThreadUnlock.
         */
        xxxFreeWindow(pwnd, &tlpwnd);

        return NULL;
    }

    /*
     * We need to set the lame button flag before doing the CFNOCLOSE stuff
     * below or the app won't get the lame button menu item in its sysmenu.
     */
#ifdef LAME_BUTTON
    if (NeedsLameButton(pwnd, pwndParent)) {
        SetWF(pwnd, WEFLAMEBUTTON);
    }
#endif // LAME_BUTTON

    /*
     * Delete the Close menu item if directed.
     */
    if (TestCF(pwnd, CFNOCLOSE)) {
        /*
         * Do this by position since the separator does not have an ID.
         */
        pMenu = xxxGetSystemMenu(pwnd, FALSE);
        if (pMenu != NULL) {
            TL tlpMenu;

            ThreadLock(pMenu, &tlpMenu);
            xxxDeleteMenu(pMenu, 5
#ifdef LAME_BUTTON
            + !!TestWF(pwnd, WEFLAMEBUTTON)
#endif // LAME_BUTTON
            , MF_BYPOSITION);
            xxxDeleteMenu(pMenu, 5
#ifdef LAME_BUTTON
            + !!TestWF(pwnd, WEFLAMEBUTTON)
#endif // LAME_BUTTON
            , MF_BYPOSITION);
            ThreadUnlock(&tlpMenu);
        }
    }

    /*
     * WM_NCCREATE processing may have changed the window text. Change
     * the CREATESTRUCT to point to the real window text.
     *
     * MSMoney needs this because it clears the window and we need to
     * reflect the new name back into the cs structure.
     * A better thing to do would be to have a pointer to the CREATESTRUCT
     * within the window itself so that DefWindowProc can change the
     * the window name in the CREATESTRUCT to point to the real name and
     * this funky check is no longer needed.
     *
     * DefSetText converts a pointer to NULL to a NULL title so
     * we don't want to over-write cs.lpszName if it was a pointer to
     * a NULL string and pName is NULL. Approach Database for Windows creates
     * windows with a pointer to NULL and then accesses the pointer later
     * during WM_CREATE
     */
    if (TestWF(pwnd, WFTITLESET))
        if (!(csex.strName.Buffer != NULL && csex.strName.Length == 0 &&
                pwnd->strName.Buffer == NULL)) {
            csex.cs.lpszName = pwnd->strName.Buffer;
            RtlCopyMemory(&csex.strName, &pwnd->strName, sizeof(LARGE_STRING));
        }

    /*
     * The Window is now officially "created."  Change the relevant global
     * stuff.
     */


     /*
      * Create per thread default IME window.
      */
    if (IS_IME_ENABLED() && ptiCurrent->spwndDefaultIme == NULL) {
        /*
         * Avoid creating the default IME window to any of message only windows
         * or windows on no I/O desktop.
         */
        if (WantImeWindow(pwndParent, pwnd)) {
            //
            // Make sure we are not creating a window for Ole,
            // for it does not pump messages even though
            // they creates a window.
            //
            UserAssert(gaOleMainThreadWndClass != atomT);

            Lock(&(ptiCurrent->spwndDefaultIme),
                  xxxCreateDefaultImeWindow(pwnd, atomT, hInstance));


            /*
             * If keybaord layout is switched but Imm activation was skipped
             * while spwndDefaultIme was gone, do the activation now.
             */
#if _DBG
            if (ptiCurrent->spDefaultImc == NULL) {
                RIPMSG1(RIP_WARNING, "xxxCreateWindowEx: ptiCurrent(%08p)->spDefaultImc is NULL.", ptiCurrent);
            }
            ASSERT(ptiCurrent->pClientInfo);
#endif


#ifdef CUAS_ENABLE
            /*
             * Load IME and Activate TIM for CUAS.
             * We can do this after ptiCurrent->spwndDefaultIME is valid.
             */
            if (ptiCurrent->spwndDefaultIme) {
                TL tlpwndIme;

                ThreadLockAlways(ptiCurrent->spwndDefaultIme, &tlpwndIme);
                xxxSendMessage(ptiCurrent->spwndDefaultIme, WM_IME_SYSTEM, (WPARAM)IMS_LOADTHREADLAYOUT, (LPARAM)0L);
                ThreadUnlock(&tlpwndIme);
            }
#endif // CUAS_ENABLE


            if (ptiCurrent->spwndDefaultIme && (ptiCurrent->pClientInfo->CI_flags & CI_INPUTCONTEXT_REINIT)) {

                TL tlpwndIme;

                TAGMSG1(DBGTAG_IMM, "xxxCreateDefaultImeWindow: ptiCurrent(%08p)->spDefaultImc->fNeedClientImcActivate is set.", ptiCurrent);
                /*
                 * Make this client side callback to force the input context
                 * is re-initialized appropriately.
                 * (keyboard layout has been changed since this thread was taking
                 * a nap while with no window but still was GUI thread)
                 * see raid #294964
                 */
                ThreadLock(ptiCurrent->spwndDefaultIme, &tlpwndIme);
                xxxSendMessage(ptiCurrent->spwndDefaultIme, WM_IME_SYSTEM, (WPARAM)IMS_ACTIVATETHREADLAYOUT, (LPARAM)ptiCurrent->spklActive->hkl);

                // Reset the flag.
                ptiCurrent->pClientInfo->CI_flags &= ~CI_INPUTCONTEXT_REINIT;

                ThreadUnlock(&tlpwndIme);
            }
        }
        else {
            RIPMSG0(RIP_VERBOSE, "xxxCreateWindowEx: default IME window is not created.");
        }
    }


    /*
     * Update the Parent/Child linked list.
     * Also don't (re)link the window if a diffrent parent was set during
     * one of callbacks (e.g. WM_GETMINMAXINFO).
     */
    if ((pwndParent != NULL) &&
        (pwnd->spwndParent == pwndParent)) {
        /*
         * Unlink this window first, it might have been linked already by calling
         * SetParent() in any of the message that we sent till now (e.g. WM_GETMINMAXINFO).
         */
        UnlinkWindow(pwnd, pwnd->spwndParent);

        if (!fChild && (pwndParent != pwndParent->head.rpdesk->spwndMessage)) {

            /*
             * If this is a top-level window, and it's not part of the
             * topmost pile of windows, then we have to make sure it
             * doesn't go on top of any of the topmost windows.
             *
             * If he's trying to put the window on the top, or trying
             * to insert it after one of the topmost windows, insert
             * it after the last topmost window in the pile.
             */
            if (!TestWF(pwnd, WEFTOPMOST)) {
                if (pwndZOrder == PWND_TOP ||
                        TestWF(pwndZOrder, WEFTOPMOST)) {
                    pwndZOrder = CalcForegroundInsertAfter(pwnd);
                }
            } else {
                pwndHardError = GETTOPMOSTINSERTAFTER(pwnd);
                if (pwndHardError != NULL) {
                    pwndZOrder = pwndHardError;
                }
            }
        }

        LinkWindow(pwnd, pwndZOrder, pwndParent);
    }

#if DBG
    if (pwndParent != NULL) {

        VerifyWindowLink (pwnd, pwnd->spwndParent, TRUE);

        if (pwnd->spwndParent != pwndParent) {
            RIPMSG1(RIP_WARNING,
                    "Window %p re-parented during on of the CreateWindow callbacks",
                    pwnd);
        }
    }
#endif

    /*
     *    Message Sending
     */

    /*
     * Send a NCCALCSIZE message to the window and have it return the official
     * size of its client area.
     */
    if (fChild && TestWF(pwndParent, WEFLAYOUTRTL)) {
        cx = pwnd->rcWindow.right - pwnd->rcWindow.left;
        pwnd->rcWindow.right = pwndParent->rcClient.right - (pwnd->rcWindow.left - pwndParent->rcClient.left);
        pwnd->rcWindow.left  = pwnd->rcWindow.right - cx;
    }

    CopyRect(&rc, &pwnd->rcWindow);
    xxxSendMessage(pwnd, WM_NCCALCSIZE, 0L, (LPARAM)&rc);
    pwnd->rcClient = rc;

    /*
     * Send a CREATE message to the window.
     */
    if (xxxSendMessage(pwnd, WM_CREATE, 0L, (LPARAM)&csex) == -1L) {
#if DBG
        if (!IS_PTR(cczpstrNVClass)) {
            RIPMSG1(RIP_WARNING,
                    "CreateWindow() send of WM_CREATE failed, Class = 0x%x",
                    PTR_TO_ID(cczpstrNVClass));
        } else {
            RIPMSG1(RIP_WARNING,
                    "CreateWindow() send of WM_CREATE failed, Class = \"%s\"",
                    pcls->lpszAnsiClassName);
        }
#endif
        if (fLockParent)
            ThreadUnlock(&tlpwndParent);

        if (ThreadUnlock(&tlpwnd))
            xxxDestroyWindow(pwnd);

        return NULL;
    }

    SetWF(pwnd, WFISINITIALIZED); /* Flag that the window is created.
                                     WoW uses this bit to determine that
                                     an fnid of 0 really means 0. */

    /*
     * Notify anyone who is listening that the window is created. Do this
     * before we size/move/max/min/show it so that event observers can count
     * on getting notifications for those things also.
     *
     * But do this AFTER WM_CREATE is sent. The window and its data will not
     * be fully initialized until then. Since the purpose of an event is to
     * let watchers turn around and do querying, we want their queries to
     * succeed and not fault.
     */
    xxxWindowEvent(EVENT_OBJECT_CREATE, pwnd, OBJID_WINDOW, INDEXID_OBJECT, 0);

    /*
     * If this is a Tiled/Overlapped window, don't send size or move msgs yet.
     */
    if (!TestWF(pwnd, WFSENDSIZEMOVE)) {
        xxxSendSizeMessage(pwnd, SIZENORMAL);

        if (pwndParent != NULL && PWNDDESKTOP(pwnd) != pwndParent) {
            rc.left -= pwndParent->rcClient.left;
            rc.top -= pwndParent->rcClient.top;
        }

        xxxSendMessage(pwnd, WM_MOVE, 0L, MAKELONG(rc.left, rc.top));
    }

    /*
     *    Min/Max Stuff
     */

    /*
     * If app specified either min/max style, then we must call our minmax
     * code to get it all set up correctly so that when the show is done,
     * the window is displayed right.
     */
    dwMinMax = MINMAX_KEEPHIDDEN | TEST_PUDF(PUDF_ANIMATE);
    if (TestWF(pwnd, WFMINIMIZED)) {
        SetMinimize(pwnd, SMIN_CLEAR);
        xxxMinMaximize(pwnd, SW_SHOWMINNOACTIVE, dwMinMax);
    } else if (TestWF(pwnd, WFMAXIMIZED)) {
        ClrWF(pwnd, WFMAXIMIZED);
        xxxMinMaximize(pwnd, SW_SHOWMAXIMIZED, dwMinMax);
    }

    /*
     * Send notification if it's a child.
     */
    if (fChild && !TestWF(pwnd, WEFNOPARENTNOTIFY) &&
            (pwnd->spwndParent != NULL)) {
        ThreadLockAlwaysWithPti(ptiCurrent, pwnd->spwndParent, &tlpwndParentT);
        xxxSendMessage(pwnd->spwndParent, WM_PARENTNOTIFY,
                MAKELONG(WM_CREATE, PTR_TO_ID(pwnd->spmenu)), (LPARAM)HWq(pwnd));
        ThreadUnlock(&tlpwndParentT);
    }

    /*
     * Show the Window
     */
    if (style & WS_VISIBLE) {
        xxxShowWindow(pwnd, sw | TEST_PUDF(PUDF_ANIMATE));
    }

    /*
     * Try and set the application's hot key. Use the Win95 logic of
     * looking for the first tiled and/or APPWINDOW to be created by
     * this process.
     */
    if (TestwndTiled(pwnd) || TestWF(pwnd, WEFAPPWINDOW)) {
        if (ptiCurrent->ppi->dwHotkey) {
            /*
             * Ignore hot keys for WowExe the first thread of a wow process.
             */
            if (!(ptiCurrent->TIF_flags & TIF_16BIT) || (ptiCurrent->ppi->cThreads > 1)) {
#ifdef LATER
                /*
                 * Win95 sets the hot key directly, we on the other hand send
                 * a WM_SETHOTKEY message to the app. Which is right?
                 */
                DWP_SetHotKey(pwnd, ptiCurrent->ppi->dwHotkey);
#else
                xxxSendMessage(pwnd, WM_SETHOTKEY, ptiCurrent->ppi->dwHotkey, 0);
#endif
                ptiCurrent->ppi->dwHotkey = 0;
            }
        }
    }

    if (fLockParent)
        ThreadUnlock(&tlpwndParent);

    return ThreadUnlock(&tlpwnd);
}

BOOL WantImeWindow(
    PWND pwndParent,
    PWND pwnd)
{
    PDESKTOP pdesk;

    UserAssert(pwnd);

    if (PtiCurrent()->TIF_flags & TIF_DISABLEIME) {
        return FALSE;
    }

    if (TestWF(pwnd, WFSERVERSIDEPROC)) {
        return FALSE;
    }

    pdesk = pwnd->head.rpdesk;
    if (pdesk == NULL || pdesk->rpwinstaParent == NULL) {
        return FALSE;
    }

    // Check whether pwnd's desktop has I/O.
    if (pdesk->rpwinstaParent->dwWSF_Flags & WSF_NOIO) {
        return FALSE;
    }

    // Check if the owner window is message-only window.
    if (pwndParent) {
        PWND pwndT = pwndParent;

        while (pwndT && pdesk == pwndT->head.rpdesk) {
            if (pwndT == pdesk->spwndMessage) {
                return FALSE;
            }
            pwndT = pwndT->spwndParent;
        }
    }

    return TRUE;
}


/***************************************************************************\
* SetTiledRect
*
* History:
* 10-19-90 darrinm      Ported from Win 3.0 sources.
\***************************************************************************/
VOID SetTiledRect(
    PWND        pwnd,
    LPRECT      lprc,
    PMONITOR    pMonitor)
{
    POINT   pt;
    RECT    rcT;

    UserAssert(pMonitor->cWndStack >= 0);

    /*
     * Get available desktop area, minus minimized spacing area.
     */
    GetRealClientRect(PWNDDESKTOP(pwnd), &rcT, GRC_MINWNDS, pMonitor);

    /*
     * Normalized rectangle is 3/4 width, 3/4 height of desktop area. We
     * offset it based on the value of giwndStack for cascading.
     */

    /*
     * Increment the count of stacked windows.
     */
    pMonitor->cWndStack++;
    /*
     * We want the left edge of the new window to align with the
     * right edge of the old window's system menu. And we want the
     * top edge of the new window to align with the bottom edge of the
     * selected caption area (caption height - cyBorder) of the old
     * window.
     */
#define X_TILED (SYSMET(CXSIZEFRAME) + SYSMET(CXSIZE))
#define Y_TILED (SYSMET(CYSIZEFRAME) + SYSMET(CYSIZE))

    pt.x = pMonitor->cWndStack * X_TILED;
    pt.y = pMonitor->cWndStack * Y_TILED;

    /*
     * If below upper top left 1/4 of free area, reset.
     */
    if (    (pt.x > ((rcT.right-rcT.left) / 4)) ||
            (pt.y > ((rcT.bottom-rcT.top) / 4)) ) {

        pMonitor->cWndStack = 0;
        pt.x = X_TILED;
        pt.y = Y_TILED;
    }

#undef X_TILED
#undef Y_TILED
    /*
     * Get starting position
     */
    pt.x += rcT.left;
    pt.y += rcT.top;

    lprc->left      = pt.x;
    lprc->top       = pt.y;
    lprc->right     = pt.x + MultDiv(rcT.right-rcT.left, 3, 4);
    lprc->bottom    = pt.y + MultDiv(rcT.bottom-rcT.top, 3, 4);

}


/***************************************************************************\
* xxxAdjustSize
*
* Make sure that *lpcx and *lpcy are within the legal limits.
*
* History:
* 10-19-90 darrinm      Ported from Win 3.0 sources.
\***************************************************************************/

void xxxAdjustSize(
    PWND pwnd,
    LPINT lpcx,
    LPINT lpcy)
{
    POINT       ptmin,
                ptmax;
    MINMAXINFO  mmi;

    CheckLock(pwnd);

    /*
     * If this window is sizeable or if this window is tiled, check size
     */
    if (TestwndTiled(pwnd) || TestWF(pwnd, WFSIZEBOX)) {

        /*
         * Get size info from pwnd
         */
        xxxInitSendValidateMinMaxInfo(pwnd, &mmi);

        if (TestWF(pwnd, WFMINIMIZED)) {
            ptmin = mmi.ptReserved;
            ptmax = mmi.ptMaxSize;
        } else {
            ptmin = mmi.ptMinTrackSize;
            ptmax = mmi.ptMaxTrackSize;
        }

        //
        // Make sure we're less than the max, and greater than the min
        //
        *lpcx = max(ptmin.x, min(*lpcx, ptmax.x));
        *lpcy = max(ptmin.y, min(*lpcy, ptmax.y));
    }
}

#if DBG
/***************************************************************************\
* VerifyWindowLink
*
* History:
* 10/28/96 GerardoB     Added
\***************************************************************************/
VOID VerifyWindowLink(
    PWND pwnd,
    PWND pwndParent,
    BOOL fLink)
{
    BOOL fFirstFound = FALSE;
    BOOL fInFound = FALSE;
    PWND pwndNext = pwndParent->spwndChild;
    PWND pwndFirst = pwndNext;

    while (pwndNext != NULL) {
        if (pwndFirst == pwndNext) {
            if (fFirstFound) {
                RIPMSG1(RIP_ERROR, "Loop in %#p spwndNext chain", pwnd);
                return;
            } else {
                fFirstFound = TRUE;
            }
        }

        if (pwndNext == pwnd) fInFound = TRUE;
        pwndNext = pwndNext->spwndNext;
    }

    if (fLink && !fInFound) {
        RIPMSG1(RIP_ERROR, "%#p not found in spwndNext chain", pwnd);
    }
}
#endif

/***************************************************************************\
* LinkWindow
*
* History:
\***************************************************************************/
VOID LinkWindow(
    PWND pwnd,
    PWND pwndInsert,
    PWND pwndParent)
{
    if (pwndParent->spwndChild == pwnd) {
        RIPMSG0(RIP_WARNING, "Attempting to link a window to itself");
        return;
    }

    UserAssert(pwnd != pwndInsert);
    UserAssert((pwnd->spwndParent == NULL) || (pwnd->spwndParent == pwndParent));

    if (pwndInsert == PWND_TOP) {

        /*
         * We are at the top of the list.
         */
LinkTop:
#if DBG
        /*
         * If the first child is topmost, so must be pwnd, but only for
         * top-level windows.
         *
         * IME or IME related windows are the exceptions, because ImeSetTopmost
         * and its friends do most of the relinking on its own: When LinkWindow
         * is called, it's possible TOPMOST flags are left in intermediate
         * state. By the time the all window relinking finishes, TOPMOST flags
         * have been taken care of and they are just fine.
         */
        if (pwndParent == PWNDDESKTOP(pwndParent) &&
                pwndParent->spwndChild &&
                FSwpTopmost(pwndParent->spwndChild) &&
                pwndParent != PWNDMESSAGE(pwndParent) &&
                // Check if the target is IME related window
                !TestCF(pwnd, CFIME) && pwnd->pcls->atomClassName != gpsi->atomSysClass[ICLS_IME]) {

            /*
             * There are few cases that cause the z-ordering code to leave the
             * WFTOGGLETOPMOST bit set. One is when SWP_NOOWNERZORDER is used
             * when changing the topmost state of a window; in this case,
             * ZOrderByOwner2 doesn't add ownees to the psmwp list, still
             * SetTopMost sets the bit on all the ownees.
             *
             * Another case is when SetWindowPos gets re-entered on the same
             * window. It's too late to attempt to fix this ancient behavior
             * (2/24/99) so let's turn off the assert for now.
             */
            if (!FSwpTopmost(pwnd)) {
                RIPMSG1(RIP_WARNING, "LinkWindow pwnd:%p is not FSwpTopmost", pwnd);
            }
        }
#endif // DBG

        if (pwndParent->spwndChild != NULL) {
            Lock(&pwndParent->spwndChild->spwndPrev, pwnd);
            Lock(&pwnd->spwndNext, pwndParent->spwndChild);
        }
        Lock(&(pwndParent->spwndChild), pwnd);
        UserAssert(pwnd->spwndPrev == NULL);
    } else {
        if (pwndInsert == PWND_BOTTOM) {

            /*
             * Find bottom-most window.
             */
            if (((pwndInsert = pwndParent->spwndChild) == NULL) ||
                TestWF(pwndInsert, WFBOTTOMMOST))
                goto LinkTop;

            /*
             * Since we know (ahem) that there's only one bottommost window,
             * we can't possibly insert after it. Either we're inserting
             * the bottomost window, in which case it's not in the linked
             * list currently, or we're inserting some other window.
             */

            while (pwndInsert->spwndNext != NULL) {
                if (TestWF(pwndInsert->spwndNext, WFBOTTOMMOST)) {
#if DBG
                    UserAssert(pwnd != pwndInsert->spwndNext);
                    if (TestWF(pwnd, WFBOTTOMMOST))
                        UserAssert(FALSE);
#endif
                    break;
                }

                pwndInsert = pwndInsert->spwndNext;
            }
        }

        UserAssert(pwnd != pwndInsert);
        UserAssert(pwnd != pwndInsert->spwndNext);
        UserAssert(!TestWF(pwndInsert, WFDESTROYED));
        UserAssert(TestWF(pwnd, WFCHILD) || !TestWF(pwnd, WEFTOPMOST) || TestWF(pwndInsert, WEFTOPMOST) || TestWF(pwnd, WFTOGGLETOPMOST) || (pwndParent != PWNDDESKTOP(pwndInsert)));
        UserAssert(pwnd->spwndParent == pwndInsert->spwndParent);

        if (pwndInsert->spwndNext != NULL) {
            Lock(&pwndInsert->spwndNext->spwndPrev, pwnd);
            Lock(&pwnd->spwndNext, pwndInsert->spwndNext);
        }
        Lock(&pwnd->spwndPrev, pwndInsert);
        Lock(&pwndInsert->spwndNext, pwnd);
    }

    if (TestWF(pwnd, WEFLAYERED))
        TrackLayeredZorder(pwnd);

#if DBG
    VerifyWindowLink (pwnd, pwndParent, TRUE);
#endif

}


/***************************************************************************\
* xxxDestroyWindow (API)
*
* Destroy the specified window. The window passed in is not thread locked.
*
* History:
* 10-20-90 darrinm      Ported from Win 3.0 sources.
* 02-07-91 DavidPe      Added Win 3.1 WH_CBT support.
* 02-11-91 JimA         Added access checks.
\***************************************************************************/
BOOL xxxDestroyWindow(
    PWND pwnd)
{
    PMENUSTATE  pMenuState, pmnsEnd;
    PTHREADINFO pti = PtiCurrent();
    TL tlpwnd, tlpwndFocus, tlpwndParent;
    PWND pwndFocus;
    BOOL fAlreadyDestroyed;
    DWORD dwDisableHooks;

    dwDisableHooks = 0;
    ThreadLockWithPti(pti, pwnd, &tlpwnd);

    /*
     * First, if this handle has been marked for destruction, that means it
     * is possible that the current thread is not its owner! (meaning we're
     * being called from a handle unlock call). In this case, set the owner
     * to be the current thread so inter-thread send messages occur.
     */
    fAlreadyDestroyed = HMIsMarkDestroy(pwnd);
    if (fAlreadyDestroyed) {
        /*
         * UserAssert(dwInAtomicOperation > 0);
         * This Assert ensures that we are here only because of an unlock
         * on a previously destroyed window. We BEGIN/ENDATOMICHCHECK in
         * HMDestroyUnlockedObject to ensure we don't leave the crit sect
         * unexpectedly, which gives us dwInAtomicCheck > 0. We set
         * TIF_DISABLEHOOKS to prevent a callback in Unlock
         * However, it is currently possible destroy the same window handle
         * twice, since we don't (yet) fail to revalidate zombie handles:
         * GerardoB may change this, at which time we should probably restore
         * this Assert, and test #76902 (close winmsd.exe) again. (preventing
         * hooks in a second destroy of a zombie window should be OK) - IanJa
         */
        // UserAssert(dwInAtomicOperation > 0);

        if (HMPheFromObject(pwnd)->pOwner != pti) {
            UserAssert(PsGetCurrentThreadWin32Thread());
            HMChangeOwnerThread(pwnd, pti);
        }
        dwDisableHooks = pti->TIF_flags & TIF_DISABLEHOOKS;
        pti->TIF_flags |= TIF_DISABLEHOOKS;
    } else {
        /*
         * Ensure that we can destroy the window. JIMA: no other process or thread
         * should be able to destroy any other process or thread's window.
         */
        if (pti != GETPTI(pwnd)) {
            RIPERR0(ERROR_ACCESS_DENIED,
                    RIP_WARNING,
                    "Access denied in xxxDestroyWindow");

            goto FalseReturn;
        }
    }

    /*
     * First ask the CBT hook if we can destroy this window.
     * If this object has already been destroyed OR this thread is currently
     * in cleanup mode, *do not* make any callbacks via hooks to the client
     * process.
     */
    if (!fAlreadyDestroyed && !(pti->TIF_flags & TIF_INCLEANUP) &&
            IsHooked(pti, WHF_CBT)) {
        if (xxxCallHook(HCBT_DESTROYWND, (WPARAM)HWq(pwnd), 0, WH_CBT)) {
            goto FalseReturn;
        }
    }

    /*
     * If the window we are destroying is in menu mode, end the menu
     */
    pMenuState = GetpMenuState(pwnd);
    if ((pMenuState != NULL)
            && (pwnd == pMenuState->pGlobalPopupMenu->spwndNotify)) {

        MNEndMenuStateNotify(pMenuState);
        /*
         * Signal all states to end. The window(s) will be unlocked when
         *  the menu exits; we cannot unlock it now because the menu
         *  code could fault.
         */
        pmnsEnd = pMenuState;
        do {
            UserAssert(pwnd == pMenuState->pGlobalPopupMenu->spwndNotify);
            pMenuState->fInsideMenuLoop = FALSE;
            pMenuState = pMenuState->pmnsPrev;
        } while (pMenuState != NULL) ;

        /*
         * All states have been signaled to exit, so once we callback
         *  we cannot count on pmnsEnd->pmnsPrev to be valid. Thus
         *  we simply end the current menu here and let the others go
         *  on their own. No state points to pwnd anymore so that
         *  should be OK.
         */
        if (!pmnsEnd->fModelessMenu) {
            xxxEndMenu(pmnsEnd);
        }
    }

    if (ghwndSwitch == HWq(pwnd)) {
        ghwndSwitch = NULL;
    }

    if (!TestWF(pwnd, WFCHILD) && (pwnd->spwndOwner == NULL)) {
        if (TestWF(pwnd, WFHASPALETTE)) {
            xxxFlushPalette(pwnd);
        }
    }

    /*
     * Disassociate thread state if this is top level and owned by a different
     * thread. This is done to begin with so these windows z-order together.
     */
    if (pwnd->pcls->atomClassName != gpsi->atomSysClass[ICLS_IME] &&
        !TestwndChild(pwnd) && pwnd->spwndOwner != NULL &&
            GETPTI(pwnd->spwndOwner) != GETPTI(pwnd)) {
        /*
         * No need to zzzDeferWinEventNotify() - there is an xxx call just below
         */
        zzzAttachThreadInput(GETPTI(pwnd), GETPTI(pwnd->spwndOwner), FALSE);
    }

    /*
     * If we are a child window without the WS_NOPARENTNOTIFY style, send
     * the appropriate notification message.
     *
     * NOTE: Although it would appear that we are illegally cramming a
     * a WORD (WM_DESTROY) and a DWORD (pwnd->spmenu) into a single LONG
     * (wParam) this isn't really the case because we first test if this
     * is a child window. The pMenu field in a child window is really
     * the window's id and only the LOWORD is significant.
     */
    if (TestWF(pwnd, WFCHILD) && !TestWF(pwnd, WEFNOPARENTNOTIFY) &&
            pwnd->spwndParent != NULL) {

        ThreadLockAlwaysWithPti(pti, pwnd->spwndParent, &tlpwndParent);
        xxxSendMessage(pwnd->spwndParent, WM_PARENTNOTIFY,
                MAKELONG(WM_DESTROY, PTR_TO_ID(pwnd->spmenu)), (LPARAM)HWq(pwnd));
        ThreadUnlock(&tlpwndParent);
    }

    /*
     * Mark this window as beginning the destroy process. This is necessary
     * to prevent window-management calls such as ShowWindow or SetWindowPos
     * from coming in and changing the visible-state of the window
     * once we hide it. Otherwise, if the app attempts to make it
     * visible, then we can get our vis-rgns messed up once we truely
     * destroy the window.
     *
     * Don't mark the mother desktop with this bit. The xxxSetWindowPos()
     * will fail for this window, and thus possibly cause an assertion
     * in the xxxFreeWindow() call when we check for the visible-bit.
     */
    if (pwnd->spwndParent && (pwnd->spwndParent->head.rpdesk != NULL)) {
        SetWF(pwnd, WFINDESTROY);
    }

    /*
     * Hide the window.
     */
    if (TestWF(pwnd, WFVISIBLE)) {
        if (TestWF(pwnd, WFCHILD)) {
            xxxShowWindow(pwnd, SW_HIDE | TEST_PUDF(PUDF_ANIMATE));
        } else {
            /*
             * Hide this window without activating anyone else.
             */
            xxxSetWindowPos(pwnd, NULL, 0, 0, 0, 0, SWP_HIDEWINDOW |
                    SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER |
                    (fAlreadyDestroyed ? SWP_DEFERDRAWING : 0));
        }

        /*
         * Under low memory conditions, the above attempt to hide could fail.
         */
        if (TestWF(pwnd, WFVISIBLE)) {
            RIPMSG0(RIP_WARNING, "xxxDestroyWindow: normal hide failed");
            SetVisible(pwnd, SV_UNSET);

            /*
             * Invalidate windows below so they redraw properly.
             */
            xxxRedrawWindow(NULL, &pwnd->rcWindow, NULL, RDW_INVALIDATE |
                    RDW_ERASE | RDW_ALLCHILDREN);

        }
    } else if (IsTrayWindow(pwnd)) {
        PostShellHookMessages(HSHELL_WINDOWDESTROYED,
                              (LPARAM)PtoHq( pwnd ));
    }

    /*
     * Destroy any owned windows.
     * [msadek], the check for FNID_GHOST is to fix bug# 380208, 382758
     * where we recieve QEVENT_HUNGTHREAD for the owner window first.
     * since we post the event multiple times (once for each owned window)
     * We are guranteed to go through xxxDestroyWindow for owned windows too.
     */
    if (!TestWF(pwnd, WFCHILD) && (GETFNID(pwnd) != FNID_GHOST)) {
        xxxDW_DestroyOwnedWindows(pwnd);

        /*
         * And remove the window hot-key, if it has one
         */
        DWP_SetHotKey(pwnd, 0);
    }

    /*
     * If the window has already been destroyed, don't muck with
     * activation because we may already be in the middle of
     * an activation event. Changing activation now may cause us
     * to leave our critical section while holding the display lock.
     * This will result in a deadlock if another thread gets the
     * critical section before we do and attempts to lock the
     * display.
     */
    if (!fAlreadyDestroyed) {
        PWND pwndActivate = NULL;
        TL tlpwndActivate;
        UINT cmdActivate;

        /*
         * If hiding the active window, activate someone else.
         * This call is strategically located after DestroyOwnedWindows() so we
         * don't end up activating our owner window.
         *
         * If the window is a popup, try to activate his creator not the top
         * window in the Z list.
         */
        if (pwnd == pti->pq->spwndActive) {
            if (TestWF(pwnd, WFPOPUP) && pwnd->spwndOwner) {
                pwndActivate = pwnd->spwndOwner;
                cmdActivate = AW_TRY;
            } else {
                pwndActivate = pwnd;
                cmdActivate = AW_SKIP;
            }
        } else if ((pti->pq->spwndActive == NULL) && (gpqForeground == pti->pq)) {
            pwndActivate = pwnd;
            cmdActivate = AW_SKIP;
        }

        if (pwndActivate) {
            ThreadLockAlwaysWithPti(pti, pwndActivate, &tlpwndActivate);

            if (!xxxActivateWindow(pwndActivate, cmdActivate) ||
                    ((cmdActivate == AW_SKIP) && (pwnd == pti->pq->spwndActive))) {
                if ((cmdActivate == AW_SKIP) || (pwnd == pti->pq->spwndActive)) {
                    Unlock(&pti->pq->spwndActive);
                    pwndFocus = Unlock(&pti->pq->spwndFocus);
                    if (IS_IME_ENABLED() && pwndFocus != NULL) {
                        ThreadLockAlwaysWithPti(pti, pwndFocus, &tlpwndFocus);
                        xxxFocusSetInputContext(pwndFocus, FALSE, FALSE);
                        ThreadUnlock(&tlpwndFocus);
                    }
                    if (pti->pq == gpqForeground) {
                        xxxWindowEvent(EVENT_OBJECT_FOCUS, NULL, OBJID_CLIENT,
                                INDEXID_CONTAINER, 0);
                        xxxWindowEvent(EVENT_SYSTEM_FOREGROUND, NULL, OBJID_WINDOW,
                                INDEXID_CONTAINER, WEF_USEPWNDTHREAD);
                    }
                    zzzInternalDestroyCaret();
                }
            }

            ThreadUnlock(&tlpwndActivate);
        }
    }

    /*
     * fix last active popup
     */
    {
        PWND pwndOwner = pwnd->spwndOwner;

        if (pwndOwner != NULL) {
            while (pwndOwner->spwndOwner != NULL) {
                pwndOwner = pwndOwner->spwndOwner;
            }

            if (pwnd == pwndOwner->spwndLastActive) {
                Lock(&(pwndOwner->spwndLastActive), pwnd->spwndOwner);
            }
        }
    }

    if (!fAlreadyDestroyed) {
    /*
     * Note we do this BEFORE telling the app the window is dying. Note also
     * that we do NOT loop through the children generating DESTROY events.
     * DESTROY of a parent implies DESTROY of all children (see #71846 - IanJa)
     */
        if (!TestWF(pwnd, WFDESTROYED)) {
            xxxWindowEvent(EVENT_OBJECT_DESTROY, pwnd, OBJID_WINDOW, INDEXID_CONTAINER, 0);
        }

    /*
     * Send destroy messages before the WindowLockStart in case
     * he tries to destroy windows as a result.
     */
        xxxDW_SendDestroyMessages(pwnd);
    }

    /*
     * Check the owner of IME window again.
     * If thread is destroying, don't bother to check.
     */
    if (IS_IME_ENABLED() && !(pti->TIF_flags & TIF_INCLEANUP) &&
            pti->spwndDefaultIme != NULL &&
            !TestCF(pwnd, CFIME) &&
            pwnd->pcls->atomClassName != gpsi->atomSysClass[ICLS_IME]) {

        if (fAlreadyDestroyed) {
            RIPMSG2(RIP_VERBOSE, "xxxDestroyWindow: in final destruction of %#p, ime=%#p",
                    pwnd, pti->spwndDefaultIme);
        } else {
            if (!TestWF(pwnd, WFCHILD)) {
                if (ImeCanDestroyDefIME(pti->spwndDefaultIme, pwnd)) {
                    TAGMSG1(DBGTAG_IMM, "xxxDestroyWindow: destroying (1) the default IME window=%p", pti->spwndDefaultIme);
                    xxxDestroyWindow(pti->spwndDefaultIme);
                }
            }
            else if (pwnd->spwndParent != NULL) {
                if (ImeCanDestroyDefIMEforChild(pti->spwndDefaultIme, pwnd)) {
                    TAGMSG1(DBGTAG_IMM, "xxxDestroyWindow: destroying (2) the default IME window=%p", pti->spwndDefaultIme);
                    xxxDestroyWindow(pti->spwndDefaultIme);
                }
            }
        }
    }

    if ((pwnd->spwndParent != NULL) && !fAlreadyDestroyed) {

        /*
         * TestwndChild() on checks to WFCHILD bit. Make sure this
         * window wasn't SetParent()'ed to the desktop as well.
         */
        if (TestwndChild(pwnd) && (pwnd->spwndParent != PWNDDESKTOP(pwnd)) &&
                (GETPTI(pwnd) != GETPTI(pwnd->spwndParent))) {
            /*
             * pwnd is threadlocked, so no need to DeferWinEventNotify()
             */
            CheckLock(pwnd);
            zzzAttachThreadInput(GETPTI(pwnd), GETPTI(pwnd->spwndParent), FALSE);
        }

        UnlinkWindow(pwnd, pwnd->spwndParent);
    }

    /*
     * This in intended to check for a case where we destroy the window,
     * but it's still listed as the active-window in the queue. This
     * could cause problems in window-activation (see xxxActivateThisWindow)
     * where we attempt to activate another window and in the process, try
     * to deactivate this window (bad).
     */
#if DBG
    if (pwnd == pti->pq->spwndActive) {
        RIPMSG1(RIP_WARNING, "xxxDestroyWindow: pwnd == pti->pq->spwndActive (%#p)", pwnd);
    }
#endif

    /*
     * Set the state as destroyed so any z-ordering events will be ignored.
     * We cannot NULL out the owner field until WM_NCDESTROY is send or
     * apps like Rumba fault  (they call GetParent after every message)
     */
    SetWF(pwnd, WFDESTROYED);

    /*
     * FreeWindow performs a ThreadUnlock.
     */
    xxxFreeWindow(pwnd, &tlpwnd);

    if (fAlreadyDestroyed) {
        pti->TIF_flags = (pti->TIF_flags & ~TIF_DISABLEHOOKS) | dwDisableHooks;
    }
    return TRUE;

FalseReturn:
    if (fAlreadyDestroyed) {
        pti->TIF_flags = (pti->TIF_flags & ~TIF_DISABLEHOOKS) | dwDisableHooks;
    }
    ThreadUnlock(&tlpwnd);
    return FALSE;
}


/***************************************************************************\
* xxxDW_DestroyOwnedWindows
*
* History:
* 10-20-90 darrinm      Ported from Win 3.0 sources.
* 07-22-91 darrinm      Re-ported from Win 3.1 sources.
\***************************************************************************/
VOID xxxDW_DestroyOwnedWindows(
    PWND pwndParent)
{
    PWND pwnd, pwndDesktop;
    PDESKTOP pdeskParent;
    PWND pwndDefaultIme = GETPTI(pwndParent)->spwndDefaultIme;

    CheckLock(pwndParent);

    if ((pdeskParent = pwndParent->head.rpdesk) == NULL)
        return;
    pwndDesktop = pdeskParent->pDeskInfo->spwnd;

    /*
     * During shutdown, the desktop owner window will be
     * destroyed. In this case, pwndDesktop will be NULL.
     */
    if (pwndDesktop == NULL)
        return;

    pwnd = pwndDesktop->spwndChild;

    while (pwnd != NULL) {
        if (pwnd->spwndOwner == pwndParent) {
            /*
             * We don't destroy the IME window here
             * unless the thread is doing cleanup.
             */
            if (IS_IME_ENABLED() && !(GETPTI(pwndParent)->TIF_flags & TIF_INCLEANUP) &&
                    pwnd == pwndDefaultIme) {
                Unlock(&pwnd->spwndOwner);
                pwnd = pwnd->spwndNext;
                continue;
            }

            /*
             * If the window doesn't get destroyed, set its owner to NULL.
             * A good example of this is trying to destroy a window created
             * by another thread or process, but there are other cases.
             */
            if (!xxxDestroyWindow(pwnd)) {
                Unlock(&pwnd->spwndOwner);
            }

            /*
             * Start the search over from the beginning since the app could
             * have caused other windows to be created or activation/z-order
             * changes.
             */
            pwnd = pwndDesktop->spwndChild;
        } else {
            pwnd = pwnd->spwndNext;
        }
    }
}


/***************************************************************************\
* xxxDW_SendDestroyMessages
*
* History:
* 10-20-90 darrinm      Ported from Win 3.0 sources.
\***************************************************************************/

void xxxDW_SendDestroyMessages(
    PWND pwnd)
{
    PWND pwndChild;
    PWND pwndNext;
    TL tlpwndNext;
    TL tlpwndChild;
    PWINDOWSTATION pwinsta;

    CheckLock(pwnd);

    /*
     * Be sure the window gets any resulting messages before being destroyed.
     */
    xxxCheckFocus(pwnd);

    pwinsta = _GetProcessWindowStation(NULL);
    if (pwinsta != NULL && pwnd == pwinsta->spwndClipOwner) {
        /*
         * Pass along the pwnd which is the reason we are dis'ing the clipboard.
         * We want to later make sure the owner is still this window after we make callbacks
         * and clear the owner
         */
        DisownClipboard(pwnd);
    }

    /*
     * Send the WM_DESTROY message.
     */
#if _DBG
    if (pwnd == PtiCurrent()->spwndDefaultIme) {
        TAGMSG2(DBGTAG_IMM, "xxxDW_SendDestroyMessages: sending WM_DESTROY message to def IME=%p, pti=%p", pwnd, PtiCurrent());
    }
#endif
    xxxSendMessage(pwnd, WM_DESTROY, 0L, 0L);

    /*
     * Now send destroy message to all children of pwnd.
     * Enumerate down (pwnd->spwndChild) and sideways (pwnd->spwndNext).
     * We do it this way because parents often assume that child windows still
     * exist during WM_DESTROY message processing.
     */
    pwndChild = pwnd->spwndChild;

    while (pwndChild != NULL) {

        pwndNext = pwndChild->spwndNext;

        ThreadLock(pwndNext, &tlpwndNext);

        ThreadLockAlways(pwndChild, &tlpwndChild);
        xxxDW_SendDestroyMessages(pwndChild);
        ThreadUnlock(&tlpwndChild);
        pwndChild = pwndNext;

        /*
         * The unlock may nuke the next window. If so, get out.
         */
        if (!ThreadUnlock(&tlpwndNext))
            break;
    }

    xxxCheckFocus(pwnd);
}


/***************************************************************************\
* xxxFW_DestroyAllChildren
*
* History:
* 11-06-90 darrinm      Ported from Win 3.0 sources.
\***************************************************************************/

void xxxFW_DestroyAllChildren(
    PWND pwnd)
{
    PWND pwndChild;
    TL tlpwndChild;
    PTHREADINFO pti;
    PTHREADINFO ptiCurrent = PtiCurrent();

    CheckLock(pwnd);

    while (pwnd->spwndChild != NULL) {
        pwndChild = pwnd->spwndChild;

        /*
         * ThreadLock prior to the unlink in case pwndChild
         * is already marked as destroyed.
         */
        ThreadLockAlwaysWithPti(ptiCurrent, pwndChild, &tlpwndChild);

        /*
         * Propagate the VISIBLE flag. We need to do this so that
         * when a child window gets destroyed we don't try to hide it
         * if the WFVISIBLE flag is set.
         */
        if (TestWF(pwndChild, WFVISIBLE)) {
            SetVisible(pwndChild, SV_UNSET);
        }

        UnlinkWindow(pwndChild, pwnd);

        /*
         * Set the state as destroyed so any z-ordering events will be ignored.
         * We cannot NULL out the owner field until WM_NCDESTROY is send or
         * apps like Rumba fault  (they call GetParent after every message)
         */
        SetWF(pwndChild, WFDESTROYED);

        /*
         * If the window belongs to another thread, post
         * an event to let it know it should be destroyed.
         * Otherwise, free the window.
         */
        pti = GETPTI(pwndChild);
        if (pti != ptiCurrent) {
            PostEventMessage(pti, pti->pq, QEVENT_DESTROYWINDOW,
                             NULL, 0,
                             (WPARAM)HWq(pwndChild), 0);
            ThreadUnlock(&tlpwndChild);
        } else {
            /*
             * FreeWindow performs a ThreadUnlock.
             */
            xxxFreeWindow(pwndChild, &tlpwndChild);
        }
    }
}

/***************************************************************************\
* UnlockNotifyWindow
*
* Walk down a menu and unlock all notify windows.
*
* History:
* 18-May-1994 JimA      Created.
\***************************************************************************/

VOID UnlockNotifyWindow(
    PMENU pmenu)
{
    PITEM pItem;
    int   i;

    /*
     * Go down the item list and unlock submenus.
     */
    pItem = pmenu->rgItems;
    for (i = pmenu->cItems; i--; ++pItem) {

        if (pItem->spSubMenu != NULL)
            UnlockNotifyWindow(pItem->spSubMenu);
    }

    Unlock(&pmenu->spwndNotify);
}

/***************************************************************************\
* xxxFreeWindow
*
* History:
* 19-Oct-1990 DarrinM   Ported from Win 3.0 sources.
\***************************************************************************/
VOID xxxFreeWindow(
    PWND pwnd,
    PTL  ptlpwndFree)
{
    PDCE           *ppdce;
    PDCE           pdce;
    UINT           uDCERelease;
    PMENU          pmenu;
    PQMSG          pqmsg;
    PPCLS          ppcls;
    WORD           fnid;
    TL             tlpdesk;
    PWINDOWSTATION pwinsta = _GetProcessWindowStation(NULL);
    PTHREADINFO    pti  = PtiCurrent();
    PPROCESSINFO   ppi;
    PMONITOR       pMonitor;
    TL             tlpMonitor;

    UNREFERENCED_PARAMETER(ptlpwndFree);

    CheckLock(pwnd);

    /*
     * If the pwnd is any of the global shell-related windows,
     * then we need to unlock them from the deskinfo.
     */
    if (pwnd->head.rpdesk != NULL) {
        if (pwnd == pwnd->head.rpdesk->pDeskInfo->spwndShell)
            Unlock(&pwnd->head.rpdesk->pDeskInfo->spwndShell);
        if (pwnd == pwnd->head.rpdesk->pDeskInfo->spwndBkGnd)
            Unlock(&pwnd->head.rpdesk->pDeskInfo->spwndBkGnd);
        if (pwnd == pwnd->head.rpdesk->pDeskInfo->spwndTaskman)
            Unlock(&pwnd->head.rpdesk->pDeskInfo->spwndTaskman);
        if (pwnd == pwnd->head.rpdesk->pDeskInfo->spwndProgman)
            Unlock(&pwnd->head.rpdesk->pDeskInfo->spwndProgman);
        if (TestWF(pwnd,WFSHELLHOOKWND)) {
            _DeregisterShellHookWindow(pwnd);
        }

        if (TestWF(pwnd, WFMSGBOX)) {
            pwnd->head.rpdesk->pDeskInfo->cntMBox--;
            ClrWF(pwnd, WFMSGBOX);
        }
    }

    /*
     * First, if this handle has been marked for destruction, that means it
     * is possible that the current thread is not its owner! (meaning we're
     * being called from a handle unlock call). In this case, set the owner
     * to be the current thread so inter-thread send messages don't occur.
     */
    if (HMIsMarkDestroy(pwnd))
        HMChangeOwnerThread(pwnd, pti);

    /*
     * Blow away the children.
     *
     * DestroyAllChildren() will still destroy windows created by other
     * threads! This needs to be looked at more closely: the ultimate
     * "right" thing to do is not to destroy these windows but just
     * unlink them.
     */
    xxxFW_DestroyAllChildren(pwnd);
    xxxSendMessage(pwnd, WM_NCDESTROY, 0, 0L);

    pMonitor = _MonitorFromWindow(pwnd, MONITOR_DEFAULTTOPRIMARY);
    ThreadLockAlwaysWithPti(pti, pMonitor, &tlpMonitor);
    xxxRemoveFullScreen(pwnd, pMonitor);
    ThreadUnlock(&tlpMonitor);

    /*
     * If this is one of the built in controls which hasn't been cleaned
     * up yet, do it now. If it lives in the kernel, call the function
     * directly, otherwise call back to the client. Even if the control
     * is sub- or super-classed, use the window procs associated with
     * the function id.
     */
    fnid = GETFNID(pwnd);
    if ((fnid >= FNID_WNDPROCSTART) && !(pwnd->fnid & FNID_CLEANEDUP_BIT)) {

       if (fnid <= FNID_WNDPROCEND) {

           FNID(fnid)(pwnd, WM_FINALDESTROY, 0, 0, 0);

       } else if (fnid <= FNID_CONTROLEND && !(pti->TIF_flags & TIF_INCLEANUP)) {

           CallClientWorkerProc(pwnd,
                                    WM_FINALDESTROY,
                                    0,
                                    0,
                                    (PROC)FNID_TO_CLIENT_PFNWORKER(fnid));
       }

       pwnd->fnid |= FNID_CLEANEDUP_BIT;
    }

    pwnd->fnid |= FNID_DELETED_BIT;

    /*
     * Check to clear the most recently active window in owned list.
     */
    if (pwnd->spwndOwner && (pwnd->spwndOwner->spwndLastActive == pwnd)) {
        Lock(&(pwnd->spwndOwner->spwndLastActive), pwnd->spwndOwner);
    }

    /*
     * The windowstation may be NULL if we are destroying a desktop
     * or windowstation. If this is the case, this thread will not
     * be using the clipboard.
     */
    if (pwinsta != NULL) {

        if (pwnd == pwinsta->spwndClipOpen) {
            Unlock(&pwinsta->spwndClipOpen);
            pwinsta->ptiClipLock = NULL;
        }

        if (pwnd == pwinsta->spwndClipViewer) {
            Unlock(&pwinsta->spwndClipViewer);
        }
    }

    if (IS_IME_ENABLED() && pwnd == pti->spwndDefaultIme)
        Unlock(&pti->spwndDefaultIme);

    if (pwnd == pti->pq->spwndFocus)
        Unlock(&pti->pq->spwndFocus);

    if (pwnd == pti->pq->spwndActivePrev)
        Unlock(&pti->pq->spwndActivePrev);

    if (pwnd == gspwndActivate)
        Unlock(&gspwndActivate);

    if (pwnd->head.rpdesk != NULL) {

        if (pwnd == pwnd->head.rpdesk->spwndForeground)
            Unlock(&pwnd->head.rpdesk->spwndForeground);

        if (pwnd == pwnd->head.rpdesk->spwndTray)
            Unlock(&pwnd->head.rpdesk->spwndTray);

        if (pwnd == pwnd->head.rpdesk->spwndTrack) {
            /*
             * Remove tooltip, if any
             */
            if (GETPDESK(pwnd)->dwDTFlags & DF_TOOLTIPSHOWING) {
                PWND pwndTooltip = GETPDESK(pwnd)->spwndTooltip;
                TL tlpwndTooltip;

                ThreadLockAlways(pwndTooltip, &tlpwndTooltip);
                xxxResetTooltip((PTOOLTIPWND)pwndTooltip);
                ThreadUnlock(&tlpwndTooltip);
            }

            Unlock(&pwnd->head.rpdesk->spwndTrack);
            pwnd->head.rpdesk->dwDTFlags &= ~DF_MOUSEMOVETRK;
        }
    }

    if (pwnd == pti->pq->spwndCapture)
        xxxReleaseCapture();

    if (FAnyShadows()) {
        if (TestCF(pwnd, CFDROPSHADOW)) {
            xxxRemoveShadow(pwnd);
        } else if (pwnd->pcls->atomClassName == gatomShadow) {
            CleanupShadow(pwnd);
        }
    }

    /*
     * This window won't be needing any more input.
     */
    if (pwnd == gspwndMouseOwner)
        Unlock(&gspwndMouseOwner);

    /*
     * It also won't have any mouse cursors over it.
     */
    if (pwnd == gspwndCursor)
        Unlock(&gspwndCursor);

    DestroyWindowsTimers(pwnd);
    DestroyWindowsHotKeys(pwnd);

    /*
     * Make sure this window has no pending sent messages.
     */
    ClearSendMessages(pwnd);

    /*
     * Remove the associated GDI sprite.
     */
    if (TestWF(pwnd, WEFLAYERED)) {
        UnsetLayeredWindow(pwnd);
    }

    if (TestWF(pwnd, WEFCOMPOSITED)) {
        UnsetRedirectedWindow(pwnd, REDIRECT_COMPOSITED);
    }

#ifdef REDIRECTION
    if (TestWF(pwnd, WEFEXTREDIRECTED)) {
        UnsetRedirectedWindow(pwnd, REDIRECT_EXTREDIRECTED);
    }
#endif // REDIRECTION

    /*
     * Blow away any update region lying around.
     */
    if (NEEDSPAINT(pwnd)) {

        DecPaintCount(pwnd);

        DeleteMaybeSpecialRgn(pwnd->hrgnUpdate);
        pwnd->hrgnUpdate = NULL;
        ClrWF(pwnd, WFINTERNALPAINT);
    }

    /*
     * Decrememt queue's syncpaint count if necessary.
     */
    if (NEEDSSYNCPAINT(pwnd)) {
        ClrWF(pwnd, WFSENDNCPAINT);
        ClrWF(pwnd, WFSENDERASEBKGND);
    }

    /*
     * Clear both flags to ensure that the window is removed
     * from the hung redraw list.
     */
    ClearHungFlag(pwnd, WFREDRAWIFHUNG);
    ClearHungFlag(pwnd, WFREDRAWFRAMEIFHUNG);

    /*
     * If there is a WM_QUIT message in this app's message queue, call
     * PostQuitMessage() (this happens if the app posts itself a quit message.
     * WinEdit2.0 posts a quit to a window while receiving the WM_DESTROY
     * for that window - it works because we need to do a PostQuitMessage()
     * automatically for this thread.
     */
    if (pti->mlPost.pqmsgRead != NULL) {

        /*
         * try to get rid of WM_DDE_ACK too.
         */
        if ((pqmsg = FindQMsg(pti,
                              &(pti->mlPost),
                              pwnd,
                              WM_QUIT,
                              WM_QUIT, TRUE)) != NULL) {

            _PostQuitMessage((int)pqmsg->msg.wParam);
        }
    }

    if (!TestwndChild(pwnd) && pwnd->spmenu != NULL) {
        pmenu = (PMENU)pwnd->spmenu;
        if (UnlockWndMenu(pwnd, &pwnd->spmenu))
            _DestroyMenu(pmenu);
    }

    if (pwnd->spmenuSys != NULL) {
        pmenu = (PMENU)pwnd->spmenuSys;
        if (pmenu != pwnd->head.rpdesk->spmenuDialogSys) {
            if (UnlockWndMenu(pwnd, &pwnd->spmenuSys)) {
                _DestroyMenu(pmenu);
            }
        } else {
            UnlockWndMenu(pwnd, &pwnd->spmenuSys);
        }
    }

    /*
     * If it was using either of the desktop system menus, unlock it
     */
    if (pwnd->head.rpdesk != NULL) {
        if (pwnd->head.rpdesk->spmenuSys != NULL &&
                pwnd == pwnd->head.rpdesk->spmenuSys->spwndNotify) {

            UnlockNotifyWindow(pwnd->head.rpdesk->spmenuSys);
        } else if (pwnd->head.rpdesk->spmenuDialogSys != NULL &&
                pwnd == pwnd->head.rpdesk->spmenuDialogSys->spwndNotify) {

            UnlockNotifyWindow(pwnd->head.rpdesk->spmenuDialogSys);
        }

    }


    /*
     * Tell Gdi that the window is going away.
     */
    if (gcountPWO != 0) {
        PVOID pwo = InternalRemoveProp(pwnd, PROP_WNDOBJ, TRUE);
        if (pwo != NULL) {
            GreLockDisplay(gpDispInfo->hDev);
            GreDeleteWnd(pwo);
            gcountPWO--;
            GreUnlockDisplay(gpDispInfo->hDev);
        }
    }

#ifdef HUNGAPP_GHOSTING

    /*
     * RemoveGhost handles the case when pwnd is the hung window that has a
     * corresponding ghost window and the case when pwnd is the ghost itself.
     */
    RemoveGhost(pwnd);

#endif // HUNGAPP_GHOSTING

    /*
     * Scan the DC cache to find any DC's for this window. If any are there,
     * then invalidate them. We don't need to worry about calling SpbCheckDC
     * because the window has been hidden by this time.
     */
    for (ppdce = &gpDispInfo->pdceFirst; *ppdce != NULL; ) {

        pdce = *ppdce;
        if (pdce->DCX_flags & DCX_INVALID) {
            goto NextEntry;
        }

        if ((pdce->pwndOrg == pwnd) || (pdce->pwndClip == pwnd)) {

            if (!(pdce->DCX_flags & DCX_CACHE)) {

                if (TestCF(pwnd, CFCLASSDC)) {

                    GreLockDisplay(gpDispInfo->hDev);

                    if (pdce->DCX_flags & (DCX_EXCLUDERGN | DCX_INTERSECTRGN))
                        DeleteHrgnClip(pdce);

                    MarkDCEInvalid(pdce);
                    pdce->pwndOrg  = NULL;
                    pdce->pwndClip = NULL;
                    pdce->hrgnClip = NULL;

                    /*
                     * Remove the vis rgn since it is still owned - if we did
                     * not, gdi would not be able to clean up properly if the
                     * app that owns this vis rgn exist while the vis rgn is
                     * still selected.
                     */
                    GreSelectVisRgn(pdce->hdc, NULL, SVR_DELETEOLD);
                    GreUnlockDisplay(gpDispInfo->hDev);

                } else if (TestCF(pwnd, CFOWNDC)) {
                    DestroyCacheDC(ppdce, pdce->hdc);
                } else {
                    UserAssert(FALSE);
                }

            } else {

                /*
                 * If the DC is checked out, release it before
                 * we invalidate. Note, that if this process is exiting
                 * and it has a dc checked out, gdi is going to destroy that
                 * dc. We need to similarly remove that dc from the dc cache.
                 * This is not done here, but in the exiting code.
                 *
                 * The return for ReleaseDC() could fail, which would
                 * indicate a delayed-free (DCE_NUKE).
                 */
                uDCERelease = DCE_RELEASED;

                if (pdce->DCX_flags & DCX_INUSE) {
                    uDCERelease = ReleaseCacheDC(pdce->hdc, FALSE);
                } else if (!GreSetDCOwner(pdce->hdc, OBJECT_OWNER_NONE)) {
                    uDCERelease = DCE_NORELEASE;
                }

                if (uDCERelease != DCE_FREED) {

                    if (uDCERelease == DCE_NORELEASE) {

                        /*
                         * We either could not release this dc or could not set
                         * its owner. In either case it means some other thread
                         * is actively using it. Since it is not too useful if
                         * the window it is calculated for is gone, mark it as
                         * INUSE (so we don't give it out again) and as
                         * DESTROYTHIS (so we just get rid of it since it is
                         * easier to do this than to release it back into the
                         * cache). The W32PF_OWNERDCCLEANUP bit means "look for
                         * DESTROYTHIS flags and destroy that dc", and the bit
                         * gets looked at in various strategic execution paths.
                         */
                        pdce->DCX_flags = DCX_DESTROYTHIS | DCX_INUSE | DCX_CACHE;
                        pti->ppi->W32PF_Flags |= W32PF_OWNDCCLEANUP;

                    } else {

                        /*
                         * We either released the DC or changed its owner
                         * successfully. Mark the entry as invalid so it can
                         * be given out again.
                         */
                        MarkDCEInvalid(pdce);
                        pdce->hrgnClip = NULL;
                    }

                    /*
                     * We shouldn't reference this window anymore. Setting
                     * these to NULL here will make sure that even if we were
                     * not able to release the DC here, we won't return this
                     * window from one of the DC matching functions.
                     */
                    pdce->pwndOrg  = NULL;
                    pdce->pwndClip = NULL;

                    /*
                     * Remove the visrgn since it is still owned - if we did
                     * not, gdi would not be able to clean up properly if the
                     * app that owns this visrgn exist while the visrgn is
                     * still selected.
                     */
                    GreLockDisplay(gpDispInfo->hDev);
                    GreSelectVisRgn(pdce->hdc, NULL, SVR_DELETEOLD);
                    GreUnlockDisplay(gpDispInfo->hDev);
                }
            }
        }

        /*
         * Step to the next DC. If the DC was deleted, there
         * is no need to calculate address of the next entry.
         */
        if (pdce == *ppdce)
NextEntry:
            ppdce = &pdce->pdceNext;
    }

    /*
     * Clean up the spb that may still exist - like child window spb's.
     */
    if (pwnd == gspwndLockUpdate) {
        FreeSpb(FindSpb(pwnd));
        Unlock(&gspwndLockUpdate);
        gptiLockUpdate = NULL;
    }

    if (TestWF(pwnd, WFHASSPB)) {
        FreeSpb(FindSpb(pwnd));
    }

    /*
     * Blow away the window clipping region. If the window is maximized, don't
     * blow away the monitor region. If the window is the desktop, don't blow
     * away the screen region.
     */
    if (    pwnd->hrgnClip != NULL &&
            !TestWF(pwnd, WFMAXFAKEREGIONAL) &&
            GETFNID(pwnd) != FNID_DESKTOP) {

        GreDeleteObject(pwnd->hrgnClip);
        pwnd->hrgnClip = NULL;
    }

    /*
     * Clean up any memory allocated for scroll bars...
     */
    if (pwnd->pSBInfo) {
        DesktopFree(pwnd->head.rpdesk, (HANDLE)(pwnd->pSBInfo));
        pwnd->pSBInfo = NULL;
    }

    /*
     * Free any callback handles associated with this window.
     * This is done outside of DeleteProperties because of the special
     * nature of callback handles as opposed to normal memory handles
     * allocated for a thread.
     */

    /*
     * Blow away the title
     */
    if (pwnd->strName.Buffer != NULL) {
        DesktopFree(pwnd->head.rpdesk, pwnd->strName.Buffer);
        pwnd->strName.Buffer = NULL;
        pwnd->strName.Length = 0;
    }

    /*
     * Blow away any properties connected to the window.
     */
    if (pwnd->ppropList != NULL) {
        TL tlpDdeConv;
        PDDECONV pDdeConv;
        PDDEIMP pddei;

        /*
         * Get rid of any icon properties.
         */
        DestroyWindowSmIcon(pwnd);
        InternalRemoveProp(pwnd, MAKEINTATOM(gpsi->atomIconProp), PROPF_INTERNAL);

        pDdeConv = (PDDECONV)_GetProp(pwnd, PROP_DDETRACK, PROPF_INTERNAL);
        if (pDdeConv != NULL) {
            ThreadLockAlwaysWithPti(pti, pDdeConv, &tlpDdeConv);
            xxxDDETrackWindowDying(pwnd, pDdeConv);
            ThreadUnlock(&tlpDdeConv);
        }
        pddei = (PDDEIMP)InternalRemoveProp(pwnd, PROP_DDEIMP, PROPF_INTERNAL);
        if (pddei != NULL) {
            pddei->cRefInit = 0;
            if (pddei->cRefConv == 0) {
                /*
                 * If this is not 0 it is referenced by one or more DdeConv
                 * structures so DON'T free it yet!
                 */
                UserFreePool(pddei);
            }
        }
    }

    /*
     * Unlock everything that the window references.
     * After we have sent the WM_DESTROY and WM_NCDESTROY message we
     * can unlock & NULL the owner field so no other windows get z-ordered
     * relative to this window. Rhumba faults if we NULL it before the
     * destroy. (It calls GetParent after every message).
     *
     * We special-case the spwndParent window. In this case, if the
     * window being destroyed is a desktop window, unlock the parent.
     * Otherwise, we lock in the desktop-window as the parent so that
     * if we aren't freed in this function, we will ensure that we
     * won't fault when doing things like clipping-calculations. We'll
     * unlock this once we know we're truly going to free this window.
     */
    if (pwnd->head.rpdesk != NULL &&
            pwnd != pwnd->head.rpdesk->pDeskInfo->spwnd) {
        Lock(&pwnd->spwndParent, pwnd->head.rpdesk->pDeskInfo->spwnd);
    } else {
        Unlock(&pwnd->spwndParent);
    }

    Unlock(&pwnd->spwndChild);
    Unlock(&pwnd->spwndOwner);
    Unlock(&pwnd->spwndLastActive);

    /*
     * Decrement the Window Reference Count in the Class structure.
     */
    DereferenceClass(pwnd);

    /*
     * Mark the object for destruction before this final unlock. This way
     * the WM_FINALDESTROY will get sent if this is the last thread lock.
     * We're currently destroying this window, so don't allow unlock recursion
     * at this point (this is what HANDLEF_INDESTROY will do for us).
     */
    HMMarkObjectDestroy(pwnd);
    HMPheFromObject(pwnd)->bFlags |= HANDLEF_INDESTROY;

    /*
     * Unlock the window... This shouldn't return FALSE because HANDLEF_DESTROY
     * is set, but just in case... if it isn't around anymore, return because
     * pwnd is invalid.
     */
    if (!ThreadUnlock(ptlpwndFree)) {
        return;
    }

    /*
     * Try to free the object. The object won't free if it is locked - but
     * it will be marked for destruction. If the window is locked, change
     * it's wndproc to xxxDefWindowProc().
     *
     * HMMarkObjectDestroy() will clear the HANDLEF_INDESTROY flag if the
     * object isn't about to go away (so it can be destroyed again!)
     */
    if (HMMarkObjectDestroy(pwnd)) {

        /*
         * Delete the window's property list. Wait until now in case some
         * thread keeps a property pointer around across a callback.
         */
        if (pwnd->ppropList != NULL) {
            DeleteProperties(pwnd);
        }

#if DBG
        /*
         * If we find the window is visible at the time we free it, then
         * somehow the app was made visible on a callback (we hide it
         * during xxxDestroyWindow(). This screws up our vis-window
         * count for the thread, so we need to assert it.
         */
        if (TestWF(pwnd, WFINDESTROY) && TestWF(pwnd, WFVISIBLE))
            RIPMSG1(RIP_WARNING, "xxxFreeWindow: Window should not be visible (pwnd == %#p)", pwnd);
#endif

        pti->cWindows--;

        /*
         * Since we're freeing the memory for this window, we need
         * to unlock the parent (which is the desktop for zombie windows).
         */
        Unlock(&pwnd->spwndParent);

        ThreadLockDesktop(pti, pwnd->head.rpdesk, &tlpdesk, LDLT_FN_FREEWINDOW);
        HMFreeObject(pwnd);
        ThreadUnlockDesktop(pti, &tlpdesk, LDUT_FN_FREEWINDOW);
        return;
    }

    /*
     * Turn this into an object that the app won't see again - turn
     * it into an icon title window - the window is still totally
     * valid and useable by any structures that has this window locked.
     */
    pwnd->lpfnWndProc = xxxDefWindowProc;
    if (pwnd->head.rpdesk)
        ppi = pwnd->head.rpdesk->rpwinstaParent->pTerm->ptiDesktop->ppi;
    else
        ppi = PpiCurrent();
    ppcls = GetClassPtr(gpsi->atomSysClass[ICLS_ICONTITLE], ppi, hModuleWin);

    UserAssert(ppcls);
    pwnd->pcls = *ppcls;

    /*
     * Since pwnd is marked as destroyed, there should be no client-side
     * code which can validate it. So we do not need to search for a clone
     * class of the right desktop -- just use the base class and bump the
     * WndReferenceCount. This also helps if we are in a low-memory situation
     * and cannot alloc another clone.
     */

    pwnd->pcls->cWndReferenceCount++;

    SetWF(pwnd, WFSERVERSIDEPROC);

    /*
     * Clear the palette bit so that WM_PALETTECHANGED will not be sent
     * again when the window is finally destroyed.
     */
    ClrWF(pwnd, WFHASPALETTE);

    /*
     * Clear its child bits so no code assumes that if the child bit
     * is set, it has a parent. Change spmenu to NULL - it is only
     * non-zero if this was child.
     */
    ClrWF(pwnd, WFTYPEMASK);
    SetWF(pwnd, WFTILED);
    pwnd->spmenu = NULL;
}

/***************************************************************************\
* UnlinkWindow
*
* History:
* 19-Oct-1990 DarrinM   Ported from Win 3.0 sources.
\***************************************************************************/
VOID UnlinkWindow(
    PWND pwnd,
    PWND pwndParent)
{
    if (pwndParent->spwndChild == pwnd) {
        UserAssert(pwnd->spwndPrev == NULL);
        Lock(&pwndParent->spwndChild, pwnd->spwndNext);
    } else if (pwnd->spwndPrev != NULL) {
        Lock(&pwnd->spwndPrev->spwndNext, pwnd->spwndNext);
    }

    if (pwnd->spwndNext != NULL) {
        Lock(&pwnd->spwndNext->spwndPrev, pwnd->spwndPrev);
        Unlock(&pwnd->spwndNext);
    }

    Unlock(&pwnd->spwndPrev);

#if DBG
    VerifyWindowLink (pwnd, pwndParent, FALSE);
#endif
}

/***************************************************************************\
* DestroyCacheDCEntries
*
* Destroys all cache dc entries currently in use by this thread.
*
* 24-Feb-1992 ScottLu   Created.
\***************************************************************************/

VOID DestroyCacheDCEntries(
    PTHREADINFO pti)
{
    PDCE *ppdce;
    PDCE pdce;
    /*
     * Before any window destruction occurs, we need to destroy any dcs
     * in use in the dc cache. When a dc is checked out, it is marked owned,
     * which makes gdi's process cleanup code delete it when a process
     * goes away. We need to similarly destroy the cache entry of any dcs
     * in use by the exiting process.
     */
    for (ppdce = &gpDispInfo->pdceFirst; *ppdce != NULL; ) {

        /*
         * If the dc owned by this thread, remove it from the cache. Because
         * DestroyCacheEntry destroys gdi objects, it is important that
         * USER be called first in process destruction ordering.
         *
         * Only destroy this dc if it is a cache dc, because if it is either
         * an owndc or a classdc, it will be destroyed for us when we destroy
         * the window (for owndcs) or destroy the class (for classdcs).
         */
        pdce = *ppdce;
        if (pti == pdce->ptiOwner) {

            if (pdce->DCX_flags & DCX_CACHE)
                DestroyCacheDC(ppdce, pdce->hdc);
        }

        /*
         * Step to the next DC. If the DC was deleted, there
         * is no need to calculate address of the next entry.
         */
        if (pdce == *ppdce)
            ppdce = &pdce->pdceNext;
    }
}

/***************************************************************************\
* PatchThreadWindows
*
* This patches a thread's windows so that their window procs point to
* server only windowprocs. This is used for cleanup so that app aren't
* called back while the system is cleaning up after them.
*
* 24-Feb-1992 ScottLu   Created.
\***************************************************************************/
VOID PatchThreadWindows(
    PTHREADINFO pti)
{
    PHE  pheT;
    PHE  pheMax;
    PWND pwnd;

    /*
     * First do any preparation work: windows need to be "patched" so that
     * their window procs point to server only windowprocs, for example.
     */
    pheMax = &gSharedInfo.aheList[giheLast];
    for (pheT = gSharedInfo.aheList; pheT <= pheMax; pheT++) {

        /*
         * Make sure this object is a window, it hasn't been marked for
         * destruction, and that it is owned by this thread.
         */
        if (pheT->bType != TYPE_WINDOW)
            continue;

#ifdef BUG365290
        /*
         * Catch the desktop thread going away while owning windows.
         */
       if (((PTHREADINFO)pheT->pOwner == pti) && ((pti == gTermIO.ptiDesktopTemp) || (pti == gTermNOIO.ptiDesktopTemp))) {
           FRE_RIPMSG1(RIP_ERROR, "PatchThreadWindows: Patching desktop thread %p windows", pti);
       }
#endif // BUG365290    

        if (pheT->bFlags & HANDLEF_DESTROY)
            continue;

        if ((PTHREADINFO)pheT->pOwner != pti)
            continue;

        /*
         * don't patch the shared menu window
         */
        if (pti->rpdesk && (PHEAD)pti->rpdesk->spwndMenu == pheT->phead) {

            ((PTHROBJHEAD)pheT->phead)->pti = pti->rpdesk->pDeskInfo->spwnd->head.pti;
            pheT->pOwner = pti->rpdesk->pDeskInfo->spwnd->head.pti;

            continue;
        }

        /*
         * Don't patch the window based on the class it was created from -
         * because apps can sometimes sub-class a class - make a random class,
         * then call ButtonWndProc with windows of that class by using
         * the CallWindowProc() api. So patch the wndproc based on what
         * wndproc this window has been calling.
         */
        pwnd = (PWND)pheT->phead;

        if ((pwnd->fnid >= (WORD)FNID_WNDPROCSTART) &&
            (pwnd->fnid <= (WORD)FNID_WNDPROCEND)) {

            pwnd->lpfnWndProc = STOCID(pwnd->fnid);

            if (pwnd->lpfnWndProc == NULL) {
                pwnd->lpfnWndProc = xxxDefWindowProc;
            }
        } else {
            pwnd->lpfnWndProc = xxxDefWindowProc;
        }

        /*
         * This is a server side window now...
         */
        SetWF(pwnd, WFSERVERSIDEPROC);
        ClrWF(pwnd, WFANSIPROC);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\ddemlsvr.c ===
/****************************** Module Header ******************************\
* Module Name: ddemlsvr.C
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* DDE Manager main module - Contains all server side ddeml functions.
*
* 27-Aug-1991 Sanford Staab   Created
* 21-Jan-1992 IanJa           ANSI/Unicode neutralized
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

// globals

PSVR_INSTANCE_INFO psiiList;

DWORD xxxCsDdeInitialize(
PHANDLE phInst,
HWND *phwndEvent,
LPDWORD pMonitorFlags,
DWORD afCmd,
PVOID pcii)
{
    PSVR_INSTANCE_INFO psii;
    PTHREADINFO        ptiCurrent = PtiCurrent();

    CheckCritIn();

    psii = (PSVR_INSTANCE_INFO)HMAllocObject(PtiCurrent(), NULL,
            TYPE_DDEACCESS, sizeof(SVR_INSTANCE_INFO));
    if (psii == NULL) {
        return DMLERR_SYS_ERROR;
    }

    /*
     * We have to tell CreateWindow that window is not created for the same
     * module has the app, (CW_FLAGS_DIFFHMOD), so CreateWindow doesn't
     * assign a hotkey to this window.  Other window are done in the
     * client-server thunk
     */
    Lock(&(psii->spwndEvent), xxxNVCreateWindowEx(
            0,
            (PLARGE_STRING)gpsi->atomSysClass[ICLS_DDEMLEVENT],
            NULL,
            WS_POPUP | WS_CHILD,
            0, 0, 0, 0,
            (PWND)NULL,
            (PMENU)NULL,
            hModuleWin,
            NULL,
            CW_FLAGS_DIFFHMOD | VER31));

    if (psii->spwndEvent == NULL) {
        HMFreeObject((PVOID)psii);
        return DMLERR_SYS_ERROR;
    }
    /*
     * This GWL offset does NOT leave the critical section!
     */
    xxxSetWindowLongPtr(psii->spwndEvent, GWLP_PSII, (LONG_PTR)PtoH(psii), FALSE);
    psii->afCmd = 0;
    psii->pcii = pcii;
    //
    // Link into global list
    //
    psii->next = psiiList;
    psiiList = psii;

    //
    // Link into per-process list
    //
    psii->nextInThisThread = ptiCurrent->psiiList;
    ptiCurrent->psiiList = psii;

    *phInst = PtoH(psii);
    *phwndEvent = PtoH(psii->spwndEvent);
    xxxChangeMonitorFlags(psii, afCmd);        // sets psii->afCmd;
    *pMonitorFlags = MonitorFlags;
    return DMLERR_NO_ERROR;
}





DWORD _CsUpdateInstance(
HANDLE hInst,
LPDWORD pMonitorFlags,
DWORD afCmd)
{
    PSVR_INSTANCE_INFO psii;

    CheckCritIn();

    psii = (PSVR_INSTANCE_INFO)HMValidateHandleNoRip(hInst, TYPE_DDEACCESS);
    if (psii == NULL) {
        return DMLERR_INVALIDPARAMETER;
    }
    xxxChangeMonitorFlags(psii, afCmd);
    *pMonitorFlags = MonitorFlags;
    return DMLERR_NO_ERROR;
}





BOOL _CsDdeUninitialize(
HANDLE hInst)
{
    PSVR_INSTANCE_INFO psii;

    CheckCritIn();

    psii = HMValidateHandleNoRip(hInst, TYPE_DDEACCESS);
    if (psii == NULL) {
        return TRUE;
    }

    xxxDestroyThreadDDEObject(PtiCurrent(), psii);
    return TRUE;
}


VOID xxxDestroyThreadDDEObject(
PTHREADINFO pti,
PSVR_INSTANCE_INFO psii)
{
    PSVR_INSTANCE_INFO psiiT;

    CheckCritIn();

    if (HMIsMarkDestroy(psii)) {
        return;
    }

    //
    // Unlink psii from the global list.
    //
    if (psii == psiiList) {
        psiiList = psii->next;
    } else {
        for (psiiT = psiiList; psiiT->next != psii; psiiT = psiiT->next) {
            UserAssert(psiiT->next != NULL);
        }
        psiiT->next = psii->next;
    }
    // psii->next = NULL;

    //
    // Unlink psii from the per-process list.
    //
    if (psii == pti->psiiList) {
        pti->psiiList = psii->nextInThisThread;
    } else {
        for (psiiT = pti->psiiList; psiiT->nextInThisThread != psii; psiiT = psiiT->nextInThisThread) {
            UserAssert(psiiT->nextInThisThread != NULL);
        }
        psiiT->nextInThisThread = psii->nextInThisThread;
    }
    // psii->nextInThisThread = NULL;

    if (HMMarkObjectDestroy(psii)) {
        xxxDestroyWindow(psii->spwndEvent);
        Unlock(&(psii->spwndEvent));

        HMFreeObject(psii);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\clipbrd.c ===
/****************************** Module Header ******************************\
* Module Name: clipbrd.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Clipboard code.
*
* History:
* 18-Nov-1990 ScottLu   Ported from Win3.
* 18-Nov-1990 ScottLu   Added revalidation code
* 11-Feb-1991 JimA      Added access checks
* 20-Jun-1995 ChrisWil  Merged Chicago functionality.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

#undef DUMMY_TEXT_HANDLE
#define DUMMY_TEXT_HANDLE       (HANDLE)0x0001        // must be first dummy
#define DUMMY_DIB_HANDLE        (HANDLE)0x0002
#define DUMMY_METARENDER_HANDLE (HANDLE)0x0003
#define DUMMY_METACLONE_HANDLE  (HANDLE)0x0004
#define DUMMY_MAX_HANDLE        (HANDLE)0x0004        // must be last dummy

#define PRIVATEFORMAT       0
#define GDIFORMAT           1
#define HANDLEFORMAT        2
#define METAFILEFORMAT      3

#define IsTextHandle(fmt, hdata)       \
    (((hdata) != DUMMY_TEXT_HANDLE) && \
     (((fmt) == CF_TEXT) || ((fmt) == CF_OEMTEXT) || ((fmt) == CF_UNICODETEXT)))

#define IsDibHandle(fmt, hdata)      \
    (((fmt) == CF_DIB) && ((hdata) != DUMMY_DIB_HANDLE))
#define IsMetaDummyHandle(hdata)     \
    ((hdata == DUMMY_METACLONE_HANDLE) || (hdata == DUMMY_METARENDER_HANDLE))

/**************************************************************************\
* CheckClipboardAccess
*
* Perform access check on the clipboard.  Special case CSRSS threads
* so that console windows on multiple windowstations will have
* the correct access.
*
* 04-Jul-1995 JimA  Created
\**************************************************************************/

PWINDOWSTATION CheckClipboardAccess(void)
{
    NTSTATUS Status;
    PWINDOWSTATION pwinsta;
    BOOL fUseDesktop;
    PTHREADINFO pti;

    pti = PtiCurrentShared();

    /*
     * CSR process use to have NULL pwinsta. Now that it's assigned to
     * the services windowstation we have to explicitly use the desktop
     * for checking the access.
     */
    fUseDesktop = (pti->TIF_flags & TIF_CSRSSTHREAD) ? TRUE : FALSE;

    Status =  ReferenceWindowStation(PsGetCurrentThread(),
                                     NULL,
                                     WINSTA_ACCESSCLIPBOARD,
                                     &pwinsta,
                                     fUseDesktop);
    if (!NT_SUCCESS(Status)) {
        RIPNTERR0(Status, RIP_WARNING,"Access to clipboard denied.");
        return NULL;
    }

    return pwinsta;
}

/**************************************************************************\
* ConvertMemHandle
*
* Converts data to a clipboard-memory-handle.  This special handle
* contains the size-of-data in the first DWORD.  The second DWORD points
* back to the block.
*
* History:
\**************************************************************************/

HANDLE _ConvertMemHandle(
    LPBYTE ccxlpData,
    UINT   cbData)
{
    PCLIPDATA pClipData;
    UINT cbObject;

    /*
     * Round up size to account for CLIPDATA structure padding on Win64.
     */
    cbObject = max(sizeof(CLIPDATA), FIELD_OFFSET(CLIPDATA, abData) + cbData);

    pClipData = HMAllocObject(NULL,
                              NULL,
                              TYPE_CLIPDATA,
                              cbObject);

    if (pClipData == NULL)
        return NULL;

    pClipData->cbData = cbData;

    try {
        RtlCopyMemory(&pClipData->abData, ccxlpData, cbData);
    } except (W32ExceptionHandler(FALSE, RIP_WARNING)) {
        HMFreeObject(pClipData);
        return NULL;
    }

    return PtoHq(pClipData);
}

/***************************************************************************\
* _xxxOpenClipboard (API)
*
* External routine. Opens the clipboard for reading/writing, etc.
*
* History:
* 18-Nov-1990 ScottLu   Ported from Win3.
* 11-Feb-1991 JimA      Added access checks.
\***************************************************************************/

BOOL xxxOpenClipboard(
    PWND   pwnd,
    LPBOOL lpfEmptyClient)
{
    PTHREADINFO    pti;
    PWINDOWSTATION pwinsta;

    CheckLock(pwnd);

    if (lpfEmptyClient != NULL)
        *lpfEmptyClient = FALSE;

    /*
     * Blow it off if the caller does not have the proper access rights
     */
    if ((pwinsta = CheckClipboardAccess()) == NULL)
        return FALSE;

    pti = PtiCurrent();

    /*
     * If this thread already has the clipboard open, then there's no
     * need to proceed further.
     */
    if ((pwnd == pwinsta->spwndClipOpen) && (pti == pwinsta->ptiClipLock))
        return TRUE;

    if ((pwnd != pwinsta->spwndClipOpen) && (pwinsta->ptiClipLock != NULL)) {

#if DBG
        /*
         * Only rip if the current-thread doesn't have the clipboard
         * open.
         */
        if (pti != pwinsta->ptiClipLock) {

            RIPMSG0(RIP_VERBOSE,
                  "Clipboard: OpenClipboard already out by another thread");
        }
#endif
        return FALSE;
    }

    /*
     * If the window is already destroyed, then the clipboard will not
     * get disowned when the window is finally unlocked.  FritzS
     */

    UserAssert((pwnd == NULL ) || (!TestWF(pwnd, WFDESTROYED)));

    Lock(&pwinsta->spwndClipOpen, pwnd);
    pwinsta->ptiClipLock = pti;

    /*
     * The client side clipboard cache needs to be emptied if this thread
     * doesn't own the data in the clipboard.
     * Note: We only empty the 16bit clipboard if a 32bit guy owns the
     * clipboard.
     * Harvard graphics uses a handle put into the clipboard
     * by another app, and it expects that handle to still be good after the
     * clipboard has opened and closed mutilple times
     * There may be a problem here if app A puts in format foo and app B opens
     * the clipboard for format foo and then closes it and opens it again
     * format foo client side handle may not be valid.  We may need some
     * sort of uniqueness counter to tell if the client side handle is
     * in sync with the server and always call the server or put the data
     * in share memory with some semaphore.
     *
     * pwinsta->spwndClipOwner: window that last called EmptyClipboard
     * pwinsta->ptiClipLock   : thread that currently has the clipboard open
     */
    if (lpfEmptyClient != NULL) {

        if (!(pti->TIF_flags & TIF_16BIT) ||
            (pti->ppi->iClipSerialNumber != pwinsta->iClipSerialNumber)) {

            *lpfEmptyClient = (pwinsta->spwndClipOwner == NULL) ||
                    (pwinsta->ptiClipLock->ppi !=
                    GETPTI(pwinsta->spwndClipOwner)->ppi);

            pti->ppi->iClipSerialNumber = pwinsta->iClipSerialNumber;
        }
    }

    return TRUE;
}

/***************************************************************************\
* xxxDrawClipboard
*
* Tells the clipboard viewers to redraw.
*
* History:
* 18-Nov-1990 ScottLu   Ported from Win3.
\***************************************************************************/

VOID xxxDrawClipboard(
    PWINDOWSTATION pwinsta)
{
    /*
     * This is what pwinsta->fClipboardChanged is for - to tell us to
     * update the clipboard viewers.
     */
    pwinsta->fClipboardChanged = FALSE;

    if (pwinsta->ptiDrawingClipboard == NULL && pwinsta->spwndClipViewer != NULL) {

        TL tlpwndClipViewer;

        /*
         * Send the message that causes clipboard viewers to redraw.
         * Remember that we're sending this message so we don't send
         * this message twice.
         */
        pwinsta->ptiDrawingClipboard = PtiCurrent();
        ThreadLockAlways(pwinsta->spwndClipViewer, &tlpwndClipViewer);

        if (!(PtiCurrent()->TIF_flags & TIF_16BIT)) {
            /*
             * Desynchronize 32 bit apps.
             */
            xxxSendNotifyMessage(pwinsta->spwndClipViewer,
                                 WM_DRAWCLIPBOARD,
                                 (WPARAM)HW(pwinsta->spwndClipOwner),
                                 0L);
        } else {
            xxxSendMessage(pwinsta->spwndClipViewer,
                           WM_DRAWCLIPBOARD,
                           (WPARAM)HW(pwinsta->spwndClipOwner),
                           0L);
        }

        ThreadUnlock(&tlpwndClipViewer);
        pwinsta->ptiDrawingClipboard = NULL;
    }
}

/***************************************************************************\
* PasteScreenPalette
*
* Creates temp palette with all colors of screen, and sticks it on
* clipboard.
*
* 20-Jun-1995 ChrisWil  Ported from Chicago.
\***************************************************************************/

VOID PasteScreenPalette(
    PWINDOWSTATION pwinsta)
{
    int          irgb;
    int          crgbPal;
    LPLOGPALETTE lppal;
    HPALETTE     hpal = NULL;
    int          crgbFixed;

    UserAssert(TEST_PUSIF(PUSIF_PALETTEDISPLAY));

    /*
     * Use current state of screen.
     */
    crgbPal = GreGetDeviceCaps(gpDispInfo->hdcScreen, SIZEPALETTE);

    if (GreGetSystemPaletteUse(gpDispInfo->hdcScreen) == SYSPAL_STATIC) {
        crgbFixed = GreGetDeviceCaps(gpDispInfo->hdcScreen, NUMRESERVED) / 2;
    } else {
        crgbFixed = 1;
    }

    lppal = (LPLOGPALETTE)UserAllocPool(sizeof(LOGPALETTE) +
                                              (sizeof(PALETTEENTRY) * crgbPal),
                                              TAG_CLIPBOARD);

    if (lppal == NULL)
        return;

    lppal->palVersion    = 0x300;
    lppal->palNumEntries = (WORD)crgbPal;

    if (GreGetSystemPaletteEntries(gpDispInfo->hdcScreen, 0, crgbPal, lppal->palPalEntry)) {

        crgbPal -= crgbFixed;

        for (irgb = crgbFixed; irgb < crgbPal; irgb++) {

            /*
             * Any non-system palette entries need to have PC_NOCOLLAPSE
             * flag set.
             */
            lppal->palPalEntry[irgb].peFlags = PC_NOCOLLAPSE;
        }

        hpal = GreCreatePalette(lppal);
    }

    UserFreePool((HANDLE)lppal);

    if (hpal) {
        InternalSetClipboardData(pwinsta, CF_PALETTE, hpal, FALSE, TRUE);
        GreSetPaletteOwner(hpal, OBJECT_OWNER_PUBLIC);
    }
}

/***************************************************************************\
* MungeClipData
*
* When clipboard is closed, we translate data to more independent format
* and pastes dummy handles if necessary.
*
* 20-Jun-1995 ChrisWil  Ported from Chicago.
\***************************************************************************/

VOID MungeClipData(
    PWINDOWSTATION pwinsta)
{
    PCLIP  pOEM;
    PCLIP  pTXT;
    PCLIP  pUNI;
    PCLIP  pBMP;
    PCLIP  pDIB;
    PCLIP  pDV5;

    PCLIP pClip;

    /*
     * If only CF_OEMTEXT, CF_TEXT or CF_UNICODE are available, make the
     * other formats available too.
     */
    pTXT = FindClipFormat(pwinsta, CF_TEXT);
    pOEM = FindClipFormat(pwinsta, CF_OEMTEXT);
    pUNI = FindClipFormat(pwinsta, CF_UNICODETEXT);

    if (pTXT != NULL || pOEM != NULL || pUNI != NULL) {

        /*
         * Make dummy text formats.
         */
        if (!FindClipFormat(pwinsta, CF_LOCALE)) {

            /*
             * CF_LOCALE not currently stored.  Save the locale
             * information while it's still available.
             */
            PTHREADINFO ptiCurrent = PtiCurrent();
            DWORD       lcid;
            DWORD       lang;
            HANDLE      hLocale;

            /*
             * The LOCALE format is an HGLOBAL to a DWORD lcid.  The
             * spklActive->hkl actually stores more than just the locale,
             * so we need to mask the value.
             * (#99321 spklActive is NULL before winlogon loads kbd layouts)
             */
            if (ptiCurrent->spklActive) {
                lang = HandleToUlong(ptiCurrent->spklActive->hkl);

                lcid = MAKELCID(LOWORD(lang), SORT_DEFAULT);

                if (hLocale = _ConvertMemHandle((LPBYTE)&lcid, sizeof(DWORD))) {
                    if (!InternalSetClipboardData(pwinsta,
                                                  CF_LOCALE,
                                                  hLocale,
                                                  FALSE,
                                                  TRUE)) {
                        PVOID pObj;

                        pObj = HMValidateHandleNoRip(hLocale, TYPE_CLIPDATA);
                        if (pObj != NULL) {
                            HMFreeObject(pObj);
                        }
                    }
                }
            }
        }

        if (pTXT == NULL)
            InternalSetClipboardData(pwinsta,
                                     CF_TEXT,
                                     (HANDLE)DUMMY_TEXT_HANDLE,
                                     FALSE,
                                     TRUE);

        if (pOEM == NULL)
            InternalSetClipboardData(pwinsta,
                                     CF_OEMTEXT,
                                     (HANDLE)DUMMY_TEXT_HANDLE,
                                     FALSE,
                                     TRUE);

        if (pUNI == NULL)
            InternalSetClipboardData(pwinsta,
                                     CF_UNICODETEXT,
                                     (HANDLE)DUMMY_TEXT_HANDLE,
                                     FALSE,
                                     TRUE);
    }

    /*
     * For the metafile formats we also want to add its cousin if it's
     * not already present.  We pass the same data because GDI knows
     * how to convert between the two.
     */
    if (!FindClipFormat(pwinsta, CF_METAFILEPICT) &&
        (pClip = FindClipFormat(pwinsta, CF_ENHMETAFILE))) {

        InternalSetClipboardData(pwinsta,
                                CF_METAFILEPICT,
                                pClip->hData ? DUMMY_METACLONE_HANDLE :
                                    DUMMY_METARENDER_HANDLE,
                                FALSE,
                                TRUE);

    } else if (!FindClipFormat(pwinsta, CF_ENHMETAFILE) &&
               (pClip = FindClipFormat(pwinsta, CF_METAFILEPICT))) {

        InternalSetClipboardData(pwinsta,
                                 CF_ENHMETAFILE,
                                 pClip->hData ? DUMMY_METACLONE_HANDLE :
                                     DUMMY_METARENDER_HANDLE,
                                 FALSE,
                                 TRUE);
    }

    /*
     * Convert bitmap formats.
     *
     * If only CF_BITMAP, CF_DIB or CF_DIBV5 are available, make the
     * other formats available too. And check palette if screen is
     * palette managed.
     */
    pBMP = FindClipFormat(pwinsta, CF_BITMAP);
    pDIB = FindClipFormat(pwinsta, CF_DIB);
    pDV5 = FindClipFormat(pwinsta, CF_DIBV5);

    if (pBMP != NULL || pDIB != NULL || pDV5 != NULL) {

        /*
         * If there is no CF_BITMAP, set dummy.
         */
        if (pBMP == NULL) {
            InternalSetClipboardData(pwinsta,
                                     CF_BITMAP,
                                     DUMMY_DIB_HANDLE,
                                     FALSE,
                                     TRUE);
        }

        /*
         * If there is no CF_DIB, set dummy.
         */
        if (pDIB == NULL) {
            InternalSetClipboardData(pwinsta,
                                     CF_DIB,
                                     DUMMY_DIB_HANDLE,
                                     FALSE,
                                     TRUE);
        }

        /*
         * If there is no CF_DIBV5, set dummy.
         */
        if (pDV5 == NULL) {
            InternalSetClipboardData(pwinsta,
                                     CF_DIBV5,
                                     DUMMY_DIB_HANDLE,
                                     FALSE,
                                     TRUE);
        }

        if (TEST_PUSIF(PUSIF_PALETTEDISPLAY) &&
            !FindClipFormat(pwinsta, CF_PALETTE)) {

            /*
             * Displays are palettized and there is no palette data in clipboard, yet.
             */
            if (pDIB != NULL || pDV5 != NULL)
            {
                /*
                 * Store a dummy dib and palette (if one not already there).
                 */
                InternalSetClipboardData(pwinsta,
                                         CF_PALETTE,
                                         DUMMY_DIB_HANDLE,
                                         FALSE,
                                         TRUE);
            } else {
                /*
                 * if only CF_BITMAP is avalilable, perserve Screen palette.
                 */
                PasteScreenPalette(pwinsta);
            }
        }
    }

    return;
}

// #define LOG_CLIP_DATA 1
#ifdef LOG_CLIP_DATA
BOOL gfLogAll;

VOID xxxLogClipData(
    PWINDOWSTATION pwinsta)
{
    HANDLE hData;
    PCLIPDATA pClipData;
    GETCLIPBDATA gcd;
    PSTR pData;
    SIZE_T cbData;
    LARGE_INTEGER liSystemTime;
    static LARGE_INTEGER liUpdateTime;
    static CHAR szLogKey[40];
    static BOOL fLogAll;

    gfLogAll = FALSE;

    if (!(hData = xxxGetClipboardData(pwinsta, CF_TEXT, &gcd)) ||
        !(pClipData = HMValidateHandleNoRip(hData, TYPE_CLIPDATA))) {
        return;
    }

    if (gcd.uFmtRet == CF_UNICODETEXT) {
        cbData = WCSToMB((PWSTR)pClipData->abData, pClipData->cbData / sizeof(WCHAR), &pData, -1, TRUE);
    } else {
        cbData = pClipData->cbData;
        pData = pClipData->abData;
    }
    if (cbData == 0) {
        return;
    }

    KeQuerySystemTime(&liSystemTime);
    if (liSystemTime.QuadPart >= liUpdateTime.QuadPart) {
        WCHAR szLogKeyW[40];
        PSTR pszLogKey = szLogKey;
        liUpdateTime.QuadPart = liSystemTime.QuadPart + (LONGLONG)36000000000;
        FastGetProfileStringW(NULL, PMAP_WINDOWSM,
                              L"LogKey", L"coalesce",
                              szLogKeyW, ARRAY_SIZE(szLogKeyW), 0);
        WCSToMB(szLogKeyW, -1, &pszLogKey, ARRAY_SIZE(szLogKey), FALSE);
        fLogAll = FastGetProfileDwordW(NULL, PMAP_WINDOWSM, L"LogAll", 0);
    }

    if (strstr(pData, szLogKey)) {

        PSTR pszProcess;
        CHAR szHeader[160];
        SIZE_T cbHeader;
        SIZE_T cbTotal;
        LARGE_INTEGER li;
        TIME_FIELDS timeFields;
        typedef struct {
            LIST_ENTRY Link;
            SIZE_T     Size;
            CHAR       Data[1];
        } CLIPBUF;
        CLIPBUF *pClipBuf;

        gfLogAll = fLogAll;

        ExSystemTimeToLocalTime(&liSystemTime, &li);
        RtlTimeToTimeFields(&li, &timeFields);

        pszProcess = PsGetCurrentProcessImageFileName();
        if (!pszProcess) {
            pszProcess = "Unknown";
        }

        _snprintf(szHeader, ARRAY_SIZE(szHeader),
                "\n==========\nUserName: %ws\\%ws@%ws\nProcess:  %s\nTime:     %d/%d/%d %d:%02d:%02d\n",
                gszDomainName, gszUserName, gszComputerName, pszProcess,
                timeFields.Month, timeFields.Day, timeFields.Year,
                timeFields.Hour, timeFields.Minute, timeFields.Second);

        cbHeader = strlen(szHeader);
        cbData = strlen(pData) + 1;
        cbTotal = cbHeader + cbData + FIELD_OFFSET(CLIPBUF, Data);

        pClipBuf = ExAllocatePoolWithTag(NonPagedPool, cbTotal, TAG_DEBUG);
        if (pClipBuf != NULL) {

            pClipBuf->Size = cbTotal;
            RtlCopyMemory(pClipBuf->Data, szHeader, cbHeader);
            RtlCopyMemory(pClipBuf->Data + cbHeader, pData, cbData);

            li.QuadPart = 1;
            MmAddPhysicalMemory((PPHYSICAL_ADDRESS)pClipBuf, &li);
        }
    }
    if (pData != pClipData->abData) {
        UserFreePool(pData);
    }
}
#endif

/***************************************************************************\
* xxxCloseClipboard (API)
*
* External routine. Closes the clipboard.
*
* Note: we do not delete any client side handle at this point.  Many apps,
* WordPerfectWin, incorrectly use handles after they have put them in the
* clipboard.  They also put things in the clipboard without becoming the
* clipboard owner because they want to add RichTextFormat to the normal
* text that is already in the clipboard from another app.
*
* History:
* 18-Nov-1990 ScottLu   Ported from Win3.
* 22-Aug-1991 EichiM    Unicode enabling
* 20-Jun-1995 ChrisWil  Merged Chicago functionality.
\***************************************************************************/

BOOL xxxCloseClipboard(
    PWINDOWSTATION pwinsta)
{
    PTHREADINFO ptiCurrent;
    TL          tlpwinsta;

    if ((pwinsta == NULL) && ((pwinsta = CheckClipboardAccess()) == NULL)) {
        return FALSE;
    }

    /*
     * If the current thread does not have the clipboard open, return
     * FALSE.
     */
    ptiCurrent = PtiCurrent();

    if (pwinsta->ptiClipLock != ptiCurrent) {
        RIPERR0(ERROR_CLIPBOARD_NOT_OPEN, RIP_WARNING, "xxxCloseClipboard not open");
        return FALSE;
    }

    ThreadLockWinSta(ptiCurrent, pwinsta, &tlpwinsta);

    /*
     * Convert data to independent formats.
     */
    if (pwinsta->fClipboardChanged)
        MungeClipData(pwinsta);

#ifdef LOG_CLIP_DATA
    if (pwinsta->fClipboardChanged || gfLogAll) {
        xxxLogClipData(pwinsta);
    }
#endif

    /*
     * Release the clipboard explicitly after we're finished calling
     * SetClipboardData().
     */
    Unlock(&pwinsta->spwndClipOpen);
    pwinsta->ptiClipLock = NULL;

    /*
     * Notify any clipboard viewers that the clipboard contents have
     * changed.
     */
    if (pwinsta->fClipboardChanged)
        xxxDrawClipboard(pwinsta);

    ThreadUnlockWinSta(ptiCurrent, &tlpwinsta);

    return TRUE;
}

/***************************************************************************\
* _EnumClipboardFormats (API)
*
* This routine takes a clipboard format and gives the next format back to
* the application. This should only be called while the clipboard is open
* and locked so the formats don't change around.
*
* History:
* 18-Nov-1990 ScottLu   Ported from Win3.
\***************************************************************************/

UINT _EnumClipboardFormats(
    UINT fmt)
{
    PWINDOWSTATION pwinsta;
    UINT           fmtRet;

    if ((pwinsta = CheckClipboardAccess()) == NULL)
        return 0;

    /*
     * If the current thread doesn't have the clipboard open or if there
     * is no clipboard, return 0 for no formats.
     */
    if (pwinsta->ptiClipLock != PtiCurrent()) {
        RIPERR0(ERROR_CLIPBOARD_NOT_OPEN, RIP_WARNING, "EnumClipboardFormat: clipboard not open");
        return 0;
    }

    fmtRet = 0;

    if (pwinsta->pClipBase != NULL) {

        PCLIP pClip;

        /*
         * Find the next clipboard format.  If the format is 0, start from
         * the beginning.
         */
        if (fmt != 0) {

            /*
             * Find the next clipboard format.  NOTE that this routine locks
             * the clipboard handle and updates pwinsta->pClipBase with the
             * starting address of the clipboard.
             */
            if ((pClip = FindClipFormat(pwinsta, fmt)) != NULL)
                pClip++;

        } else {
            pClip = pwinsta->pClipBase;
        }

        /*
         * Find the new format before unlocking the clipboard.
         */
        if (pClip && (pClip < &pwinsta->pClipBase[pwinsta->cNumClipFormats])) {

            fmtRet = pClip->fmt;
        }
    }

    /*
     * Return the new clipboard format.
     */
    return fmtRet;
}

/***************************************************************************\
* UT_GetFormatType
*
* Given the clipboard format, return the handle type.
*
* Warning:  Private formats, eg CF_PRIVATEFIRST, return PRIVATEFORMAT
* unlike Win 3.1 which has a bug and returns HANDLEFORMAT.  And they
* would incorrectly free the handle.  Also they would NOT free GDIOBJFIRST
* objects.
*
* History:
* 18-Nov-1990 ScottLu   Ported from Win3.
\***************************************************************************/

int UT_GetFormatType(
    PCLIP pClip)
{
    switch (pClip->fmt) {

    case CF_BITMAP:
    case CF_DSPBITMAP:
    case CF_PALETTE:
        return GDIFORMAT;

    case CF_METAFILEPICT:
    case CF_DSPMETAFILEPICT:
    case CF_ENHMETAFILE:
    case CF_DSPENHMETAFILE:
        return METAFILEFORMAT;

    case CF_OWNERDISPLAY:
        return PRIVATEFORMAT;

    default:
        return HANDLEFORMAT;
    }
}

/***************************************************************************\
* UT_FreeCBFormat
*
* Free the data in the pass clipboard structure.
*
* History:
* 18-Nov-1990 ScottLu   Ported from Win3.
\***************************************************************************/

VOID UT_FreeCBFormat(
    PCLIP pClip)
{
    PVOID pObj;

    /*
     * No Data, then no point.
     */
    if (pClip->hData == NULL)
        return;

    /*
     * Free the object given the type.
     */
    switch (UT_GetFormatType(pClip)) {

    case METAFILEFORMAT:

        /*
         * GDI stores the metafile on the server side for the clipboard.
         * Notify the GDI server to free the metafile data.
         */
        if (!IsMetaDummyHandle(pClip->hData)) {
            GreDeleteServerMetaFile(pClip->hData);
        }
        break;

    case HANDLEFORMAT:

        /*
         * It's a simple global object.  Text/Dib handles can be
         * dummy handles, so check for those first.  We need to
         * perform extra-checks on the format since HANDLEFORMATS
         * are the default-type.  We only want to delete those obects
         * we can quarentee are handle-types.
         */
        if ((pClip->hData != DUMMY_TEXT_HANDLE) &&
            (pClip->hData != DUMMY_DIB_HANDLE)) {

            pObj = HMValidateHandleNoSecure(pClip->hData, TYPE_CLIPDATA);
            if (pObj) {
                HMFreeObject(pObj);
            }
        }
        break;

    case GDIFORMAT:

        /*
         * Bitmaps can be marked as dummy-handles.
         */
        if (pClip->hData != DUMMY_DIB_HANDLE) {
            GreDeleteObject(pClip->hData);
        }
        break;

    case PRIVATEFORMAT:

        /*
         * Destroy the private data here if it is a global handle: we
         * aren't destroying the client's copy here, only the server's,
         * which nobody wants (including the server!)
         */
        if (pClip->fGlobalHandle) {
            pObj = HMValidateHandleNoSecure(pClip->hData, TYPE_CLIPDATA);
            if (pObj) {
                HMFreeObject(pObj);
            }
        }
        break;
    }
}

/***************************************************************************\
* xxxSendClipboardMessage
*
* Helper routine that sends a notification message to the clipboard owner.
*
* History:
* 18-Nov-1990 ScottLu   Ported from Win3.
\***************************************************************************/

VOID xxxSendClipboardMessage(
    PWINDOWSTATION pwinsta,
    UINT           message)
{
    TL      tlpwndClipOwner;
    LONG_PTR dwResult;
    LRESULT lRet;

    if (pwinsta->spwndClipOwner != NULL) {

        PWND    pwndClipOwner = pwinsta->spwndClipOwner;

        ThreadLockAlways(pwndClipOwner, &tlpwndClipOwner);

        /*
         * We use SendNotifyMessage so the apps don't have to synchronize
         * but some 16 bit apps break because of the different message
         * ordering so we allow 16 bit apps to synchronize to other apps
         * Word 6 and Excel 5 with OLE.  Do a copy in Word and then another
         * copy in Excel and Word faults.
         */
        if ((message == WM_DESTROYCLIPBOARD) &&
            !(PtiCurrent()->TIF_flags & TIF_16BIT)) {

            /*
             * Let the app think it's the clipboard owner during
             * the processing of this message by waiting for it
             * to be processed before setting the new owner.
             */
            lRet = xxxSendMessageTimeout(
                    pwndClipOwner,
                    WM_DESTROYCLIPBOARD,
                    0,
                    0L,
                    SMTO_ABORTIFHUNG | SMTO_NORMAL,
                    5 * 1000,
                    &dwResult);

            if (lRet == 0) {

                /*
                 * The message timed out and wasn't sent, so
                 * let the app handle it when it's ready.
                 */
                RIPMSG0(RIP_WARNING, "Sending WM_DESTROYCLIPBOARD timed-out, resending via SendNotifyMessage");
                xxxSendNotifyMessage(pwndClipOwner, WM_DESTROYCLIPBOARD, 0, 0L);
            }

        } else {

            xxxSendMessage(pwndClipOwner, message, 0, 0L);
        }

        ThreadUnlock(&tlpwndClipOwner);
    }

}

/***************************************************************************\
* xxxEmptyClipboard (API)
*
* Empties the clipboard contents if the current thread has the clipboard
* open.
*
* History:
* 18-Nov-1990 ScottLu   Ported from Win3.
\***************************************************************************/

BOOL xxxEmptyClipboard(
    PWINDOWSTATION pwinsta)
{
    TL          tlpwinsta;
    PCLIP       pClip;
    int         cFmts;
    BOOL        fDying;
    PTHREADINFO ptiCurrent = (PTHREADINFO)(W32GetCurrentThread());
    BOOL bInternal = !(pwinsta == NULL);

    /*
     * Check access.
     */
    if ((pwinsta == NULL) && ((pwinsta = CheckClipboardAccess()) == NULL))
        return FALSE;

    /*
     * If the current thread doesn't have the clipboard open, it can't be
     * be emptied!
     */

    if (ptiCurrent == NULL) {
        UserAssert(bInternal);
    }

    if (!bInternal) {
        if (pwinsta->ptiClipLock != ptiCurrent) {
            RIPERR0(ERROR_CLIPBOARD_NOT_OPEN, RIP_WARNING, "xxxEmptyClipboard: clipboard not open");
            return FALSE;
        }
    }

    /*
     * Only send messages at logoff.
     */
    fDying = pwinsta->dwWSF_Flags & WSF_DYING;

    if (!fDying && ptiCurrent) {
        ThreadLockWinSta(ptiCurrent, pwinsta, &tlpwinsta);

        /*
         * Let the clipboard owner know that the clipboard is
         * being destroyed.
         */
        xxxSendClipboardMessage(pwinsta, WM_DESTROYCLIPBOARD);
    }

    if ((pClip = pwinsta->pClipBase) != NULL) {

        /*
         * Loop through all the clipboard entries and free their data
         * objects.  Only call DeleteAtom for real atoms.
         */
        for (cFmts = pwinsta->cNumClipFormats; cFmts-- != 0;) {

            if ((ATOM)pClip->fmt >= MAXINTATOM)
                UserDeleteAtom((ATOM)pClip->fmt);

            UT_FreeCBFormat(pClip++);
        }

        /*
         * Free the clipboard itself.
         */
        UserFreePool((HANDLE)pwinsta->pClipBase);
        pwinsta->pClipBase       = NULL;
        pwinsta->cNumClipFormats = 0;
    }

    /*
     * The "empty" succeeds.  The owner is now the thread that has the
     * clipboard open.  Remember the clipboard has changed; this will
     * cause the viewer to redraw at CloseClipboard time.
     */
    pwinsta->fClipboardChanged = TRUE;
    Lock(&pwinsta->spwndClipOwner, pwinsta->spwndClipOpen);

    /*
     * Change the clipboard serial number so that the client-side
     * clipboard caches of all the processes will get
     * flushed on the next OpenClipboard.
     */
    pwinsta->iClipSerialNumber++;
    pwinsta->iClipSequenceNumber++;
    pwinsta->fInDelayedRendering = FALSE;

    if (!fDying && ptiCurrent)
        ThreadUnlockWinSta(ptiCurrent, &tlpwinsta);

    return TRUE;
}

/***************************************************************************\
* _SetClipboardData
*
* This routine sets data into the clipboard. Does validation against
* DUMMY_TEXT_HANDLE only.
*
* History:
* 18-Nov-1990 ScottLu   Ported from Win3.
\***************************************************************************/

BOOL _SetClipboardData(
    UINT   fmt,
    HANDLE hData,
    BOOL   fGlobalHandle,
    BOOL   fIncSerialNumber)
{
    PWINDOWSTATION pwinsta;
    BOOL fRet;

    if ((pwinsta = CheckClipboardAccess()) == NULL)
        return FALSE;

    /*
     * Check if the Data handle is DUMMY_TEXT_HANDLE; If so, return an
     * error.  DUMMY_TEXT_HANDLE will be used as a valid clipboard handle
     * only by USER.  If any app tries to pass it as a handle, it should
     * get an error!
     */
    if ((hData >= DUMMY_TEXT_HANDLE) && (hData <= DUMMY_MAX_HANDLE)) {
        RIPMSG0(RIP_WARNING, "Clipboard: SetClipboardData called with dummy-handle");
        return FALSE;
    }

    if (fRet = InternalSetClipboardData(pwinsta, fmt, hData, fGlobalHandle, fIncSerialNumber)) {

        /*
         * The set object must remain PUBLIC, so that other processes
         * can view/manipulate the handles when requested.
         */
        switch (fmt) {
        case CF_BITMAP:
            GreSetBitmapOwner(hData, OBJECT_OWNER_PUBLIC);
            break;

        case CF_PALETTE:
            GreSetPaletteOwner(hData, OBJECT_OWNER_PUBLIC);
            break;
        }
    }

    return fRet;
}

/***************************************************************************\
* InternalSetClipboardData
*
* Internal routine to set data into the clipboard.
*
* History:
* 18-Nov-1990 ScottLu   Ported from Win3.
\***************************************************************************/

#define CCHFORMATNAME 256

BOOL InternalSetClipboardData(
    PWINDOWSTATION pwinsta,
    UINT           fmt,
    HANDLE         hData,
    BOOL           fGlobalHandle,
    BOOL           fIncSerialNumber)
{
    PCLIP pClip;
    WCHAR achFormatName[CCHFORMATNAME];

    /*
     * Just check for pwinsta->ptiClipLock being NULL instead of checking
     * against PtiCurrent because an app needs to call SetClipboardData if
     * he's rendering data while another app has the clipboard open.
     */
    if ((pwinsta->ptiClipLock == NULL) || (fmt == 0)) {
        RIPERR0(ERROR_CLIPBOARD_NOT_OPEN, RIP_WARNING, "SetClipboardData: Clipboard not open");
        return FALSE;
    }

    if ((pClip = FindClipFormat(pwinsta, fmt)) != NULL) {

        /*
         * If data already exists, free it before we replace it.
         */
        UT_FreeCBFormat(pClip);

    } else {

        if (pwinsta->pClipBase == NULL) {
            pClip = (PCLIP)UserAllocPool(sizeof(CLIP), TAG_CLIPBOARD);
        } else {
            DWORD dwSize = sizeof(CLIP) * pwinsta->cNumClipFormats;

            pClip = (PCLIP)UserReAllocPool(pwinsta->pClipBase,
                                           dwSize,
                                           dwSize + sizeof(CLIP),
                                           TAG_CLIPBOARD);
        }

        /*
         * Out of memory...  return.
         */
        if (pClip == NULL) {
            RIPMSG0(RIP_WARNING, "SetClipboardData: Out of memory");
            return FALSE;
        }

        /*
         * Just in case the data moved
         */
        pwinsta->pClipBase = pClip;

        /*
         * Increment the reference count of this atom format so that if
         * the application frees this atom we don't get stuck with a
         * bogus atom. We call DeleteAtom in the EmptyClipboard() code,
         * which decrements this count when we're done with this clipboard
         * data.
         */
        if (UserGetAtomName((ATOM)fmt, achFormatName, CCHFORMATNAME) != 0)
            UserAddAtom(achFormatName, FALSE);

        /*
         * Point to the new entry in the clipboard.
         */
        pClip += pwinsta->cNumClipFormats++;
        pClip->fmt = fmt;
    }

    /*
     * Start updating the new entry in the clipboard.
     */
    pClip->hData         = hData;
    pClip->fGlobalHandle = fGlobalHandle;

    if (fIncSerialNumber)
        pwinsta->fClipboardChanged = TRUE;

    if (fIncSerialNumber && !pwinsta->fInDelayedRendering) {
        pwinsta->iClipSequenceNumber++;
    }

    /*
     * If the thread didn't bother emptying the clipboard before
     * writing to it, change the clipboard serial number
     * so that the client-side clipboard caches of all the
     * processes will get flushed on the next OpenClipboard.
     */
    if ((pwinsta->spwndClipOwner == NULL) ||
        (GETPTI(pwinsta->spwndClipOwner) != PtiCurrent())) {

        RIPMSG0(RIP_VERBOSE, "Clipboard: SetClipboardData called without emptying clipboard");

        if (fIncSerialNumber)
            pwinsta->iClipSerialNumber++;
    }

    return TRUE;
}

/***************************************************************************\
* CreateScreenBitmap
*
*
\***************************************************************************/

HBITMAP CreateScreenBitmap(
    int  cx,
    int  cy,
    UINT bpp)
{
    if (bpp == 1)
        return GreCreateBitmap(cx, cy, 1, 1, NULL);

    return GreCreateCompatibleBitmap(gpDispInfo->hdcScreen, cx, cy);
}


/***************************************************************************\
* SizeOfDibColorTable
*
* Returns the size of the colr table of a packed-dib.
\***************************************************************************/
DWORD SizeOfDibColorTable(
    LPBITMAPINFOHEADER lpDib)
{
    DWORD dwColor;

    /*
     * Calculate size of color table.
     */
    if (lpDib->biCompression == BI_BITFIELDS) {
        if (lpDib->biBitCount == 16 || lpDib->biBitCount == 32) {
            dwColor   = (3 * sizeof(DWORD));
        } else {
            dwColor = 0;
        }
    } else if (lpDib->biCompression == BI_RGB) {
        if (lpDib->biClrUsed) {
            dwColor = lpDib->biClrUsed * sizeof(DWORD);
        } else {
            if (lpDib->biBitCount <= 8) {
                dwColor = (1 << lpDib->biBitCount) * sizeof(RGBQUAD);
            } else {
                dwColor = 0;
            }
        }
    } else if (lpDib->biCompression == BI_RLE4) {
        dwColor = 16 * sizeof(DWORD);
    } else if (lpDib->biCompression == BI_RLE8) {
        dwColor = 256 * sizeof(DWORD);
    } else {
        dwColor = 0;
    }

    return dwColor;
}

/***************************************************************************\
* SizeOfDib
*
* Returns the size of a packed-dib.
*
\***************************************************************************/

DWORD SizeOfDib(
    LPBITMAPINFOHEADER lpDib)
{
    DWORD dwColor;
    DWORD dwBits;

    /*
     * Calculate size of bitmap bits.
     */
    dwBits = WIDTHBYTES(lpDib->biWidth * lpDib->biBitCount) * abs(lpDib->biHeight);

    /*
     * Calculate size of color table.
     */
    dwColor = SizeOfDibColorTable(lpDib);

    return (lpDib->biSize + dwColor + dwBits);
}

/***************************************************************************\
* DIBtoBMP
*
* Creates a bitmap from a DIB spec.
*
\***************************************************************************/

HBITMAP DIBtoBMP(
    LPBITMAPINFOHEADER lpbih,
    HPALETTE           hpal)
{
    HDC      hdc;
    int      cx;
    int      cy;
    int      bpp;
    LPSTR    lpbits;
    HBITMAP  hbmp;

    #define lpbch ((LPBITMAPCOREHEADER)lpbih)

    /*
     * Gather the dib-info for the convert.
     */
    if (lpbih->biSize == sizeof(BITMAPINFOHEADER)) {

        cx  = (int)lpbih->biWidth;
        cy  = (int)lpbih->biHeight;
        bpp = (int)lpbih->biBitCount;

        lpbits = ((PBYTE)lpbih) + sizeof(BITMAPINFOHEADER);

        if (lpbih->biClrUsed) {
            lpbits += (lpbih->biClrUsed * sizeof(RGBQUAD));
        } else if (bpp <= 8) {
            lpbits += ((1 << bpp) * sizeof(RGBQUAD));
        } else if ((bpp == 16) || (bpp == 32)) {
            lpbits += (3 * sizeof(RGBQUAD));
        }

    } else if (lpbch->bcSize == sizeof(BITMAPCOREHEADER)) {

        cx  = (int)lpbch->bcWidth;
        cy  = (int)lpbch->bcHeight;
        bpp = (int)lpbch->bcBitCount;

        lpbits = ((PBYTE)lpbch) + sizeof(BITMAPCOREHEADER);

        if (lpbch->bcBitCount <= 8)
            lpbits += (1 << bpp);

    } else {
        return NULL;
    }

    hbmp = NULL;

    if (hdc = GreCreateCompatibleDC(gpDispInfo->hdcScreen)) {

        if (hbmp = CreateScreenBitmap(cx, cy, bpp)) {

            HBITMAP  hbmT;
            HPALETTE hpalT = NULL;

            hbmT = GreSelectBitmap(hdc, hbmp);

            if (hpal) {
                hpalT = _SelectPalette(hdc, hpal, FALSE);
                xxxRealizePalette(hdc);
            }

            GreSetDIBits(hdc,
                         hbmp,
                         0,
                         cy,
                         lpbits,
                         (LPBITMAPINFO)lpbih,
                         DIB_RGB_COLORS);

            if (hpalT) {
                _SelectPalette(hdc, hpalT, FALSE);
                xxxRealizePalette(hdc);
            }

            GreSelectBitmap(hdc, hbmT);
        }

        GreDeleteDC(hdc);
    }

    #undef lpbch

    return hbmp;
}

/***************************************************************************\
* BMPtoDIB
*
* Creates a memory block with DIB information from a physical bitmap tagged
* to a specific DC.
*
* A DIB block consists of a BITMAPINFOHEADER + RGB colors + DIB bits.
*
\***************************************************************************/

LPBITMAPINFOHEADER BMPtoDIB(
    HBITMAP  hbmp,
    HPALETTE hpal,
    DWORD*   pcbSize)
{
    BITMAP             bmp;
    BITMAPINFOHEADER   bi;
    LPBITMAPINFOHEADER lpbi;
    DWORD              cbBits;
    DWORD              cbPalette;
    DWORD              cbTotal;
    WORD               cBits;
    HDC                hdc;

    UserAssert(hbmp);

    /*
     * Get physical information
     */
    if (!GreExtGetObjectW(hbmp, sizeof(BITMAP), &bmp)) {
        UserAssert(FALSE);
        return NULL;
    }

    /*
     * Adjust the bit count since we only allow DIBS with 1,4,8,16,24 and
     * 32 bits.
     */
    cBits = ((WORD)bmp.bmPlanes * (WORD)bmp.bmBitsPixel);

    if (cBits <= 1) {

        cBits = 1;

    } else if (cBits <= 4) {

        cBits = 4;

    } else if (cBits <= 8) {

        cBits = 8;

    } else {

        /*
         * We're not going to recognize 16/32bpp formats for
         * apps that are not 4.00 or greater.  Paint-Shop has
         * a bug in it where they only recognize (1,4,8,24).  This
         * really stinks that we need to do this type of thing as
         * not to break them bad-apps.
         */
        if (LOWORD(PtiCurrent()->dwExpWinVer) >= VER40) {

            if (cBits <= 16)
                cBits = 16;
            else if (cBits <= 24)
                cBits = 24;
            else
                cBits = 32;

        } else {
            cBits = 24;
        }
    }

    /*
     * Fill in BITMAPINFOHEADER with DIB data
     */
    RtlZeroMemory(&bi, sizeof(bi));

    bi.biSize        = sizeof(bi);
    bi.biWidth       = bmp.bmWidth;
    bi.biHeight      = bmp.bmHeight;
    bi.biPlanes      = 1;
    bi.biBitCount    = cBits;
    bi.biCompression = BI_RGB;

    /*
     * DWORD align the bits-size since dibs must be so.
     */
    cbBits = (DWORD)WIDTHBYTES((WORD)bi.biWidth * cBits) * (DWORD)bi.biHeight;

    /*
     * How big is the palette color table?
     */
    cbPalette = 0;

    if (cBits <= 8) {

        cbPalette = (1 << cBits) * sizeof(RGBQUAD);

    } else if ((cBits == 16) || (cBits == 32)) {

        cbPalette = (3 * sizeof(DWORD));
        bi.biCompression = BI_BITFIELDS;
    }

    /*
     * How much space do we need for the entire DIB?
     */
    cbTotal = bi.biSize + cbPalette + cbBits;

    lpbi = (LPBITMAPINFOHEADER)UserAllocPool(cbTotal, TAG_CLIPBOARD);
    if (lpbi == NULL) {
        return NULL;
    }

    /*
     * Have the total allocated size returned in pcbSize
     */
    if (pcbSize != NULL) {
        *pcbSize = cbTotal;
    }

    /*
     * Setup DIB header
     */
    memcpy(lpbi, &bi, sizeof(bi));

    if (hdc = GreCreateCompatibleDC(gpDispInfo->hdcScreen)) {
        HPALETTE           hpalT = NULL;
        TL tlPool;

        ThreadLockPool(PtiCurrent(), lpbi, &tlPool);

        if (hpal) {
            hpalT = _SelectPalette(hdc, hpal, FALSE);
            xxxRealizePalette(hdc);
        }

        /*
         * Get old bitmap's DIB bits, using the current DC.
         */
        GreGetDIBitsInternal(hdc,
                             hbmp,
                             0,
                             (WORD)bi.biHeight,
                             (LPSTR)((LPSTR)lpbi + lpbi->biSize + cbPalette),
                             (LPBITMAPINFO)lpbi,
                             DIB_RGB_COLORS,
                             cbBits,
                             lpbi->biSize + cbPalette);


        if (hpalT) {
            _SelectPalette(hdc, hpalT, FALSE);
            xxxRealizePalette(hdc);
        }

        GreDeleteDC(hdc);

        ThreadUnlockPool(PtiCurrent(), &tlPool);
    }

    return lpbi;
}

/***************************************************************************\
* DIBtoDIBV5
*
* History:
* 18-Dec-1997 HideyukN  Created.
\***************************************************************************/

LPBITMAPV5HEADER DIBtoDIBV5(
    LPBITMAPINFOHEADER lpDib,
    DWORD              cbSize)
{
    LPBITMAPV5HEADER lpV5h;
    ULONG            cjBits;
    ULONG            cjColorV5;

    if (cbSize < sizeof(BITMAPINFOHEADER)) {
        RIPMSG2(RIP_WARNING, "DIBtoDIBV5: buffer %d too small for header %d",
                cbSize, sizeof(BITMAPINFOHEADER));
        return NULL;
    }

    /*
     * Support only convert from BITMAPINFOHEADER
     */
    if (lpDib->biSize != sizeof(BITMAPINFOHEADER)) {
        return NULL;
    }

    /*
     * Calculate size of bitmap bits.
     */
    cjBits = WIDTHBYTES(lpDib->biWidth * lpDib->biBitCount) * abs(lpDib->biHeight);

    /*
     * Calculate size of color table.
     */
    cjColorV5 = SizeOfDibColorTable(lpDib);

    if (cbSize < sizeof(BITMAPINFOHEADER) + cjColorV5 + cjBits) {
        RIPMSG5(RIP_WARNING, "DIBtoDIBV5: buffer %d too small for bitmap %d Header"
                             " %d cjColorV5 %d cjBits %d",
                cbSize,
                sizeof(BITMAPINFOHEADER) + cjColorV5 + cjBits,
                sizeof(BITMAPINFOHEADER),
                cjColorV5,
                cjBits);
        return NULL;
    }

    /*
     * Allocate memory for BITMAPV5HEADER.
     */
    lpV5h = (LPBITMAPV5HEADER)UserAllocPool(sizeof(BITMAPV5HEADER) + cjColorV5 + cjBits,
                                            TAG_CLIPBOARD);

    if (lpV5h == NULL) {
        return NULL;
    }

    /*
     * Fill allocated memory with zero.
     */
    RtlZeroMemory((PVOID)lpV5h, sizeof(BITMAPV5HEADER));

    try {
        /*
         * Copy BITMAPINFOHEADER to BITMAPV5HEADER
         */
        RtlCopyMemory((PVOID)lpV5h, (PVOID)lpDib, sizeof(BITMAPINFOHEADER));
    } except (W32ExceptionHandler(FALSE, RIP_ERROR)) {
        UserFreePool(lpV5h);
        return NULL;
    }

    /*
     * Adjust the header size to BITMAPV5HEADER.
     */
    lpV5h->bV5Size = sizeof(BITMAPV5HEADER);

    /*
     * Bitmap is in sRGB color space.
     */
    lpV5h->bV5CSType = LCS_sRGB;

    /*
     * Set rendering intent.
     */
    lpV5h->bV5Intent = LCS_GM_IMAGES;

    if ((lpDib->biCompression == BI_BITFIELDS) &&
        (lpDib->biBitCount == 16 || lpDib->biBitCount == 32)) {
        /*
         * If there is bitfields mask, copy it to BITMAPV5HEADER.
         */
        lpV5h->bV5RedMask = *(DWORD *)&(((BITMAPINFO *)lpDib)->bmiColors[0]);
        lpV5h->bV5GreenMask = *(DWORD *)&(((BITMAPINFO *)lpDib)->bmiColors[1]);
        lpV5h->bV5BlueMask = *(DWORD *)&(((BITMAPINFO *)lpDib)->bmiColors[2]);
    }

    if (cjColorV5) {
        RtlCopyMemory((BYTE *)lpV5h + sizeof(BITMAPV5HEADER),
                      (BYTE *)lpDib + sizeof(BITMAPINFOHEADER),
                      cjColorV5);
    }

    /*
     * Copy bitmap bits
     */
    RtlCopyMemory((BYTE *)lpV5h + sizeof(BITMAPV5HEADER) + cjColorV5,
                  (BYTE *)lpDib + sizeof(BITMAPINFOHEADER) + cjColorV5,
                  cjBits);

    return lpV5h;
}

/***************************************************************************\
* BMPtoDIBV5
*
* History:
* 18-Dec-1997 HideyukN  Created.
\***************************************************************************/

LPBITMAPV5HEADER BMPtoDIBV5(
    HBITMAP  hbmp,
    HPALETTE hpal)
{
    LPBITMAPV5HEADER   lpV5h;
    LPBITMAPINFOHEADER lpbih;
    DWORD              cbSize;

    /*
     * Convert bitmap handle to BITMAPINFOHEADER first.
     */
    lpbih = BMPtoDIB(hbmp, hpal, &cbSize);

    if (lpbih) {

        /*
         * Then, convert BITMAPINFOHEADER to BITMAPV5HEADER.
         */
        lpV5h = DIBtoDIBV5(lpbih, cbSize);

        /*
         * Free memory which contains BITMAPINFOHEADER temporary.
         */
        UserFreePool(lpbih);

        return (lpV5h);
    } else {

        RIPMSG0(RIP_ERROR,"Failed on BMPtoDIB(), Why ??");
        return NULL;
    }
}

/***************************************************************************\
* xxxGetDummyBitmap
*
* Returns a real-bitmap from a dummy-format.
*
* History:
* 24-Oct-1995 ChrisWil  Created.
\***************************************************************************/

HANDLE xxxGetDummyBitmap(
    PWINDOWSTATION pwinsta,
    PGETCLIPBDATA  pgcd)
{
    HANDLE             hData = NULL;
    PCLIPDATA          pData;
    HBITMAP            hBitmap;
    LPBITMAPINFOHEADER lpbih;
    ULONG              cjBitmap;
    HPALETTE           hPal = NULL;

    PCLIP              pClipT;

    /*
     * If palette display, then first attempt to get the palette
     * for this bitmap.
     */
    if (TEST_PUSIF(PUSIF_PALETTEDISPLAY)) {
        hPal = xxxGetClipboardData(pwinsta, CF_PALETTE, pgcd);
    }

    /*
     * The convertion priority is CF_DIBV5 and then CF_DIB,
     * so, check we have CF_DIBV5 first.
     */
    pClipT = FindClipFormat(pwinsta, CF_DIBV5);
    if (pClipT && (pClipT->hData != DUMMY_DIB_HANDLE)) {

        /*
         * Ok, we have *real* CF_DIBV5 data, At this moment, just
         * go back to client side, then create bitmap handle for
         * CF_BITMAP. Since color conversion only can do it on
         * user-mode.
         */
        if (hData = xxxGetClipboardData(pwinsta, CF_DIBV5, pgcd)) {

            /*
             * Return the type of the returned data.
             * Again, convertion will happen in client side.
             */
            pgcd->uFmtRet  = CF_DIBV5;
            pgcd->hPalette = hPal;

            return (hData);
        }
    }

    /*
     * If the bitmap is a dummy, then we have a problem.  We can't
     * retrieve a bitmap if we only have dummys to work with.
     */
    pClipT = FindClipFormat(pwinsta, CF_DIB);
    if (pClipT && (pClipT->hData != DUMMY_DIB_HANDLE)) {
        hData = xxxGetClipboardData(pwinsta, CF_DIB, pgcd);

    }
    if (hData == NULL)
        return NULL;

    /*
     * Since dibs (memory-handles) are stored in a special
     * format (size,base,data), we need to offet the pointer
     * to the right offset (2 uints).
     */
    if (pData = (PCLIPDATA)HMValidateHandleNoRip(hData, TYPE_CLIPDATA)) {
        lpbih = (LPBITMAPINFOHEADER)&pData->abData;
        cjBitmap = pData->cbData;
    } else {
        UserAssert(pData != NULL);
        return NULL;
    }

    /*
     * Convert the dib to a bitmap.
     */
    /*
     * The buffer size for bitmap should be larger than
     * bitmap header + color table + bitmap bits data.
     */
    if ((cjBitmap >= sizeof(BITMAPCOREHEADER)) &&
        (cjBitmap >= (GreGetBitmapSize((CONST BITMAPINFO *)lpbih,DIB_RGB_COLORS) +
                      GreGetBitmapBitsSize((CONST BITMAPINFO *)lpbih)))) {

        if (hBitmap = DIBtoBMP(lpbih, hPal)) {
            /*
             * Once, we create *real* bitmap, overwrite dummy handle.
             */

            pClipT = FindClipFormat(pwinsta, CF_BITMAP);
            if (pClipT) {
                UT_FreeCBFormat(pClipT);
                pClipT->hData = hBitmap;
                GreSetBitmapOwner(hBitmap, OBJECT_OWNER_PUBLIC);

                /*
                 * Let callee know we can obtain CF_BITMAP
                 */
                pgcd->uFmtRet = CF_BITMAP;
            } else {
                /*
                 * Bleh -- now we can't find the BITMAP entry anymore.  Bail.
                 */
                RIPMSG0(RIP_WARNING,
                      "Clipboard: CF_BITMAP format not available");
                GreDeleteObject(hBitmap);
                hBitmap = NULL;
            }
        }
        return (HANDLE)hBitmap;
    } else {
        RIPMSG0(RIP_WARNING, "GetClipboardData, bad DIB format\n");
        return NULL;
    }

}

/***************************************************************************\
* xxxGetDummyDib
*
* Returns a real-dib (in special clipboard-handle format) from a
* dummy format.
*
* History:
* 24-Oct-1995 ChrisWil  Created.
\***************************************************************************/

HANDLE xxxGetDummyDib(
    PWINDOWSTATION pwinsta,
    PGETCLIPBDATA  pgcd)
{
    HANDLE             hData = NULL;
    HBITMAP            hBitmap = NULL;
    LPBITMAPINFOHEADER lpDib;
    HANDLE             hDib;
    HPALETTE           hPal = NULL;

    PCLIP              pClipT;

    /*
     * If palette display, then first attempt to get the palette
     * for this bitmap.  For palette devices, we must have a palette.
     */
    if (TEST_PUSIF(PUSIF_PALETTEDISPLAY)) {
        hPal = xxxGetClipboardData(pwinsta, CF_PALETTE, pgcd);

        if (hPal == NULL)
            return NULL;
    }

    /*
     * The convertion priority is CF_DIBV5 and then CF_BITMAP,
     * so, check we have CF_DIBV5 first.
     */
    pClipT = FindClipFormat(pwinsta, CF_DIBV5);
    if (pClipT && (pClipT->hData != DUMMY_DIB_HANDLE)) {

        /*
         * Ok, we have *real* CF_DIBV5 data, At this moment, just
         * go back to client side, then create bitmap data for
         * CF_DIB. Since color conversion only can do it on
         * user-mode.
         */
        if (hData = xxxGetClipboardData(pwinsta, CF_DIBV5, pgcd)) {

            /*
             * Return the type of the returned data.
             * Again, convertion will happen in client side.
             */
            pgcd->uFmtRet  = CF_DIBV5;
            pgcd->hPalette = hPal;

            return (hData);
        }
    }

    /*
     * Get the real-bitmap.  We must have one in order to convert
     * to the dib.  If there's no bitmap, then we have something
     * wrong.
     */
    pClipT = FindClipFormat(pwinsta, CF_BITMAP);
    if (pClipT && (pClipT->hData != DUMMY_DIB_HANDLE)) {
        hBitmap = xxxGetClipboardData(pwinsta, CF_BITMAP, pgcd);
    }

    if (hBitmap == NULL) {
        return NULL;
    }

    /*
     * Convert the bitmap to a dib-spec.
     */
    hDib = NULL;
    if (lpDib = BMPtoDIB(hBitmap, hPal, NULL)) {

        DWORD cbData = SizeOfDib(lpDib);;

        /*
         * Convert the dib-spec to the special-clipboard
         * memory-handle (size,base,data).  This so
         * the client is able to convert properly when
         * handled a dib.
         */
        hDib = _ConvertMemHandle((LPBYTE)lpDib, cbData);
        UserFreePool(lpDib);

        if (hDib != NULL) {
            /*
             * Once, we create *real* bitmap, overwrite dummy handle.
             */

            pClipT = FindClipFormat(pwinsta, CF_DIB);
            if (pClipT) {
                UT_FreeCBFormat(pClipT);
                pClipT->hData = hDib;

                /*
                 * Let callee know we can obtain CF_DIB
                 */
                pgcd->uFmtRet = CF_DIB;
            } else {
                PVOID pObj;
                /*
                 * Bleh -- now we can't find the DIB entry anymore.  Bail.
                 */
                RIPMSG0(RIP_WARNING,
                      "Clipboard: CF_PDIB format not available");
                pObj = HMValidateHandleNoRip(hDib, TYPE_CLIPDATA);
                if (pObj) {
                    HMFreeObject(pObj);
                }
                hDib = NULL;
            }
        }
    }

    return hDib;
}

/***************************************************************************\
* xxxGetDummyDibV5
*
* Returns a real-dib (in special clipboard-handle format) from a
* dummy format.
*
* History:
* 18-Dec-1997 HideyukN  Created.
\***************************************************************************/

HANDLE xxxGetDummyDibV5(
    PWINDOWSTATION pwinsta,
    PGETCLIPBDATA  pgcd)
{
    HANDLE             hData;
    PCLIPDATA          pData;
    LPBITMAPV5HEADER   lpDibV5 = NULL;
    HANDLE             hDibV5 = NULL;

    PCLIP              pClipT;

    /*
     * The convertion priority is CF_DIB and then CF_BITMAP,
     * so, check we have CF_DIB first.
     */
    pClipT = FindClipFormat(pwinsta, CF_DIB);
    if (pClipT && (pClipT->hData != DUMMY_DIB_HANDLE)) {

        /*
         * Ok, we have *real* CF_DIB data, get it.
         */
        if (hData = xxxGetClipboardData(pwinsta, CF_DIB, pgcd)) {

            /*
             * Since dibs (memory-handles) are stored in a special
             * format (size,base,data), we need to offet the pointer
             * to the right offset (2 uints).
             */
            if (pData = (PCLIPDATA)HMValidateHandleNoRip(hData, TYPE_CLIPDATA)) {

                LPBITMAPINFOHEADER lpDib = (LPBITMAPINFOHEADER)&pData->abData;

                /*
                 * Convert the BITMAPINFOHEADER to BITMAPV5HEADER.
                 */
                lpDibV5 = DIBtoDIBV5(lpDib, pData->cbData);

            } else {
                UserAssert(pData != NULL);
            }
        }
    }

    if (lpDibV5 == NULL) {

        /*
         * Try CF_BITMAP, here
         */
        pClipT = FindClipFormat(pwinsta, CF_BITMAP);
        if ((pClipT) &&
            (pClipT->hData != DUMMY_DIB_HANDLE) &&
            (hData = xxxGetClipboardData(pwinsta, CF_BITMAP, pgcd))) {

            HPALETTE hPal = NULL;

            /*
             * If palette display, then first attempt to get the palette
             * for this bitmap.  For palette devices, we must have a palette.
             */
            if (TEST_PUSIF(PUSIF_PALETTEDISPLAY)) {

                hPal = xxxGetClipboardData(pwinsta, CF_PALETTE, pgcd);

                if (hPal == NULL)
                    return NULL;
            }

            /*
             * hData is GDI bitmap handle, Convert the bitmap to a dib-spec.
             */
            lpDibV5 = BMPtoDIBV5((HBITMAP)hData, hPal);
        }
    }

    if (lpDibV5 != NULL) {

        DWORD cbData = SizeOfDib((LPBITMAPINFOHEADER)lpDibV5);

        /*
         * Convert the dib-spec to the special-clipboard
         * memory-handle (size,base,data).  This so
         * the client is able to convert properly when
         * handled a dib.
         */
        hDibV5 = _ConvertMemHandle((LPBYTE)lpDibV5, cbData);
        UserFreePool(lpDibV5);

        if (hDibV5 != NULL) {

            /*
             * Once, we create *real* bitmap, overwrite dummy handle.
             */

            pClipT = FindClipFormat(pwinsta, CF_DIBV5);
            if (pClipT) {
                UT_FreeCBFormat(pClipT);
                pClipT->hData = hDibV5;

                /*
                 * Let callee know we can obtain CF_DIBV5
                 */
                pgcd->uFmtRet = CF_DIBV5;
            } else {
                PVOID pObj;
                /*
                 * Bleh -- now we can't find the DIB entry anymore.  Bail.
                 */
                RIPMSG0(RIP_WARNING,
                      "Clipboard: CF_DIBV5 format not available");
                pObj = HMValidateHandleNoRip(hDibV5, TYPE_CLIPDATA);
                if (pObj) {
                    HMFreeObject(pObj);
                }
                hDibV5 = NULL;
            }
        }
    }

    return hDibV5;
}

/***************************************************************************\
* CreateDIBPalette
*
* This creates a palette with PC_NOCOLLAPSE entries since we require the
* palette-entries and bitmap-indexes to map exactly.  Otherwise, we could
* end up selecting a palette where a color collapses to an index not
* where the bitmap thinks it is.  This would cause slower drawing since
* the Blt would go through color translation.
*
* History:
* 31-Jan-1992 MikeKe    From win31
\***************************************************************************/

HPALETTE CreateDIBPalette(
   LPBITMAPINFOHEADER pbmih,
   UINT               colors)
{
    HPALETTE hpal;

    if (colors != 0) {

        int         i;
        BOOL        fOldDIB = (pbmih->biSize == sizeof(BITMAPCOREHEADER));
        RGBTRIPLE   *pColorTable;
        PLOGPALETTE plp;

        /*
         * Allocate memory for palette creation.
         */
        plp = (PLOGPALETTE)UserAllocPoolWithQuota(sizeof(LOGPALETTE) +
                                                  (sizeof(PALETTEENTRY) * 256),
                                                  TAG_CLIPBOARDPALETTE);

        if (plp == NULL) {
            return NULL;
        }

        pColorTable = (RGBTRIPLE *)((LPSTR)pbmih + (WORD)pbmih->biSize);
        plp->palVersion = 0x300;

        if (fOldDIB || (pbmih->biClrUsed == 0)) {
            UserAssert(colors <= 0xFFFF);
            plp->palNumEntries = (WORD)colors;
        } else {
            UserAssert(pbmih->biClrUsed <= 0xFFFF);
            plp->palNumEntries = (WORD)pbmih->biClrUsed;
        }

        for (i = 0; i < (int)(plp->palNumEntries); i++) {

            plp->palPalEntry[i].peRed   = pColorTable->rgbtRed;
            plp->palPalEntry[i].peGreen = pColorTable->rgbtGreen;
            plp->palPalEntry[i].peBlue  = pColorTable->rgbtBlue;
            plp->palPalEntry[i].peFlags = (BYTE)PC_NOCOLLAPSE;

            if (fOldDIB) {
                pColorTable++;
            } else {
                pColorTable = (RGBTRIPLE *)((LPSTR)pColorTable+sizeof(RGBQUAD));
            }
        }

        hpal = GreCreatePalette((LPLOGPALETTE)plp);
        UserFreePool(plp);

    } else {
        hpal = GreCreateHalftonePalette(HDCBITS());
    }

    GreSetPaletteOwner(hpal, OBJECT_OWNER_PUBLIC);

    return hpal;
}

/***************************************************************************\
* xxxGetDummyPalette
*
* Returns a real-palette from a dummy-format.  Derives it from a real-dib.
*
* History:
* 24-Oct-1995 ChrisWil  Created.
\***************************************************************************/

HANDLE xxxGetDummyPalette(
    PWINDOWSTATION pwinsta,
    PGETCLIPBDATA  pgcd)
{
    HANDLE             hData;
    PCLIPDATA          pData;
    LPBITMAPINFOHEADER lpbih;
    HPALETTE           hPal;

    PCLIP              pClipT;

    /*
     * Since CF_DIBV5 has higher priority than CF_DIB, so look into
     * CF_DIBV5 first, to find DIB palette.
     */
    UINT               uFmt = CF_DIBV5;

    if ((pClipT = FindClipFormat(pwinsta, uFmt)) != NULL)
    {

        if (pClipT->hData != DUMMY_DIB_HANDLE) {

            /*
             * Ok, we have real CF_DIBV5, let extract palette from DIBV5.
             */
        } else {

            /*
             * Otherwise, try CF_DIB.
             */
            uFmt = CF_DIB;

            /*
             * If no DIB available or it's a dummy handle, bail since we
             * must have a real DIB to derive the palette.
             */
            if ((pClipT = FindClipFormat(pwinsta, uFmt)) == NULL) {
                return NULL;
            }
            if (pClipT->hData == DUMMY_DIB_HANDLE) {
                return NULL;
            }
        }
    }

    /*
     * Get the DIB by which we derive the palette.  If the DIB comes
     * back as a dummy, then there's something wrong.  Me must have
     * a real dib at this point.
     */
    hData = (HANDLE)xxxGetClipboardData(pwinsta, uFmt, pgcd);
    UserAssert(hData > DUMMY_MAX_HANDLE);

    if (hData == NULL)
        return NULL;

    /*
     * Since dibs (memory-handles) are stored in a special
     * format (size,base,data), we need to offet the pointer
     * to the right offset (2 uints).
     */
    if (pData = (PCLIPDATA)HMValidateHandle(hData, TYPE_CLIPDATA)) {
        lpbih = (LPBITMAPINFOHEADER)&pData->abData;
    } else {
        UserAssert(pData != NULL);
        return NULL;
    }

    if ((pClipT = FindClipFormat(pwinsta, CF_PALETTE)) == NULL) {
        RIPMSG0(RIP_WARNING,
              "Clipboard: CF_PALETTE format not available");
        return NULL;
    }

    /*
     * Note -- if CreateDIBPalette ever changes to leave the crit sect,
     * we will need to move the above FindClipFormat to after the create
     * call and deal with gracefully freeing hPal on failure.  pClipT
     * can change during callbacks.
     */

    hPal = CreateDIBPalette(lpbih, lpbih->biClrUsed);

    if (hPal != NULL) {
        UT_FreeCBFormat(pClipT);
        pClipT->hData = hPal;
        GreSetPaletteOwner(hPal, OBJECT_OWNER_PUBLIC);
    }

    return (HANDLE)hPal;
}

/***************************************************************************\
* xxxGetDummyText
*
* Returns a handle to text from a dummy-format.
*
* History:
* 24-Oct-1995 ChrisWil  Created.
\***************************************************************************/

HANDLE xxxGetDummyText(
    PWINDOWSTATION pwinsta,
    UINT           fmt,
    PGETCLIPBDATA  pgcd)
{
    HANDLE hText;
    PCLIP  pClipT;
    UINT   uFmtMain;
    UINT   uFmtAlt;
    BOOL  bMain = TRUE;

    /*
     * Get the handle of the other text format available.
     */
    switch (fmt) {
    case CF_TEXT:
        uFmtMain = CF_UNICODETEXT;
        uFmtAlt  = CF_OEMTEXT;
        goto GetRealText;

    case CF_OEMTEXT:
        uFmtMain = CF_UNICODETEXT;
        uFmtAlt  = CF_TEXT;
        goto GetRealText;

    case CF_UNICODETEXT:
        uFmtMain = CF_TEXT;
        uFmtAlt  = CF_OEMTEXT;

GetRealText:

        if ((pClipT = FindClipFormat(pwinsta, uFmtMain)) == NULL)
            return NULL;

        if (pClipT->hData != DUMMY_TEXT_HANDLE) {

            if (xxxGetClipboardData(pwinsta, uFmtMain, pgcd))
                break;

            return NULL;
        }

        if ((pClipT = FindClipFormat(pwinsta, uFmtAlt)) == NULL)
            return NULL;

        if (pClipT->hData != DUMMY_TEXT_HANDLE) {
            bMain = FALSE;

            if (xxxGetClipboardData(pwinsta, uFmtAlt, pgcd))
                break;
        }

        /*
         * Fall through to return a dummy handle.
         */

    default:
        return NULL;
    }

    /*
     * Since xxxGetClipboardData leaves the critsect, we need to
     * reacquire pClipT.
     */

    pClipT = FindClipFormat(pwinsta, bMain? uFmtMain:uFmtAlt);

    if (pClipT == NULL) {
        RIPMSG1(RIP_WARNING,
              "Clipboard: GetDummyText, format 0x%lX not available", bMain? uFmtMain:uFmtAlt);
        return NULL;
    }

    /*
     * Return the type of the returned data.
     */
    pgcd->uFmtRet = pClipT->fmt;
    hText         = pClipT->hData;

    /*
     * Set the locale, since the text will need to be
     * converted to another format.
     */
    if(pClipT = FindClipFormat(pwinsta, CF_LOCALE)) {
        pgcd->hLocale = pClipT->hData;
    } else {
        pgcd->hLocale = NULL;
    }

    return hText;
}

/***************************************************************************\
* xxxGetRenderData
*
* Returns a handle to delayed rendered data.  This requires a call to the
* client to supply the data.  This causes us to regenerate our pointer
* to pClip.
*
* History:
* 24-Oct-1995 ChrisWil  Created.
\***************************************************************************/

HANDLE xxxGetRenderData(
    PWINDOWSTATION pwinsta,
    UINT           fmt)
{
    BOOL   fClipboardChangedOld;
    TL     tlpwndClipOwner;
    PCLIP          pClip;

    /*
     * If the handle is NULL, the data is delay rendered.  This means
     * we send a message to the current clipboard owner and have
     * it render the data for us.
     */
    if (pwinsta->spwndClipOwner != NULL) {

        /*
         * Preserve the pwinsta->fClipboardChanged flag before SendMessage
         * and restore the flag later; Thus we ignore the changes
         * done to the pwinsta->fClipboardChanged flag by apps while
         * rendering data in the delayed rendering scheme; This
         * avoids clipboard viewers from painting twice.
         */
        fClipboardChangedOld = pwinsta->fClipboardChanged;
        pwinsta->fInDelayedRendering = TRUE;
        ThreadLockAlways(pwinsta->spwndClipOwner, &tlpwndClipOwner);
        xxxSendMessage(pwinsta->spwndClipOwner, WM_RENDERFORMAT, fmt, 0L);
        ThreadUnlock(&tlpwndClipOwner);
        pwinsta->fClipboardChanged = fClipboardChangedOld;
        pwinsta->fInDelayedRendering = FALSE;

    }

    if ((pClip = FindClipFormat(pwinsta, fmt)) == NULL) {
        RIPMSG1(RIP_WARNING,
              "Clipboard: Meta Render/Clone format 0x%lX not available", fmt);
        return NULL;
    }
    /*
     * We should have the handle now since it has been rendered.
     */
    return pClip->hData;
}

/***************************************************************************\
* xxxGetClipboardData (API)
*
* Grabs a particular data object out of the clipboard.
*
* History:
* 18-Nov-1990 ScottLu   Ported from Win3.
* 20-Aug-1991 EichiM    UNICODE enabling
\***************************************************************************/

HANDLE xxxGetClipboardData(
    PWINDOWSTATION pwinsta,
    UINT           fmt,
    PGETCLIPBDATA  pgcd)
{
    PCLIP  pClip;
    HANDLE hData;

    /*
     * Check the clipboard owner.
     */
    if (pwinsta->ptiClipLock != PtiCurrent()) {
        RIPERR0(ERROR_CLIPBOARD_NOT_OPEN, RIP_VERBOSE, "GetClipboardData: clipboard not open");
        return NULL;
    }

    /*
     * Make sure the format is available.
     */
    if ((pClip = FindClipFormat(pwinsta, fmt)) == NULL) {
        RIPMSG1(RIP_VERBOSE, "Clipboard: Requested format 0x%lX not available", fmt);
        return NULL;
    }

    /*
     * If this is a DUMMY_META*_HANDLE it means that the other
     * metafile format was set in as a delay render format and we should
     * ask for that format to get the metafile because the app has not told
     * us they know about this format.
     */
    if (IsMetaDummyHandle(pClip->hData)) {

        if (fmt == CF_ENHMETAFILE) {
            fmt = CF_METAFILEPICT;
        } else if (fmt == CF_METAFILEPICT) {
            fmt = CF_ENHMETAFILE;
        } else {
            RIPMSG0(RIP_WARNING,
                  "Clipboard: Meta Render/Clone expects a metafile type");
        }

        if ((pClip = FindClipFormat(pwinsta, fmt)) == NULL) {
            RIPMSG1(RIP_WARNING,
                  "Clipboard: Meta Render/Clone format 0x%lX not available", fmt);
            return NULL;
        }
    }

    /*
     * This is the data we're returning, unless it's a dummy or
     * render handle.
     */
    hData = pClip->hData;

    /*
     * We are dealing with non-handles.  Retrieve the real data
     * through these inline-routines.  NOTE: these make recursive
     * calls to xxxGetClipboardData().  So care must be taken to
     * assure the pClip is pointing to what we think it's pointing
     * to.
     */
    if ((hData == NULL) || (hData == DUMMY_METARENDER_HANDLE)) {

        hData = xxxGetRenderData(pwinsta, fmt);

    } else if (hData == DUMMY_DIB_HANDLE) {

        switch (fmt) {
        case CF_DIB:
            hData = xxxGetDummyDib(pwinsta, pgcd);
            break;
        case CF_DIBV5:
            hData = xxxGetDummyDibV5(pwinsta, pgcd);
            break;
        case CF_BITMAP:
            hData = xxxGetDummyBitmap(pwinsta, pgcd);
            break;
        case CF_PALETTE:
            hData = xxxGetDummyPalette(pwinsta, pgcd);
            break;
        }

    } else if (hData == DUMMY_TEXT_HANDLE) {

        hData = xxxGetDummyText(pwinsta, fmt, pgcd);
    } else {
        /*
         * This path took no callbacks, so we know pClip is OK.
         */
        if (pgcd)
            pgcd->fGlobalHandle = pClip->fGlobalHandle;

        return hData;
    }

    /*
     * The callbacks for dummy handle resolution have possibly
     * invalidated pClip -- recreate it.
     */

    if ((pClip = FindClipFormat(pwinsta, fmt)) == NULL) {
        RIPMSG1(RIP_VERBOSE, "Clipboard: Requested format 0x%lX not available", fmt);
        return NULL;
    }

    /*
     * Return if this is a global-handle.
     */
    if (pgcd)
        pgcd->fGlobalHandle = pClip->fGlobalHandle;

    return hData;
}

/***************************************************************************\
* FindClipFormat
*
* Finds a particular clipboard format in the clipboard, returns a pointer
* to it, or NULL. If a pointer is found, on return the clipboard is locked
* and pwinsta->pClipBase has been updated to point to the beginning of the
* clipboard.
*
* History:
* 18-Nov-1990 ScottLu   Ported from Win3.
\***************************************************************************/

PCLIP FindClipFormat(
    PWINDOWSTATION pwinsta,
    UINT           format)
{
    PCLIP pClip;
    int   iFmt;

    if ((format != 0) && ((pClip = pwinsta->pClipBase) != NULL)) {

        for (iFmt = pwinsta->cNumClipFormats; iFmt-- != 0;) {

            if (pClip->fmt == format)
                return pClip;

            pClip++;
        }
    }

    return NULL;
}

/***************************************************************************\
* _GetPriorityClipboardFormat (API)
*
* This api allows an application to look for any one of a range of
* clipboard formats in a predefined search order.
*
* History:
* 18-Nov-1990 ScottLu   Ported from Win3.
* 11-Feb-1991 JimA      Added access checks.
\***************************************************************************/

int _GetPriorityClipboardFormat(
    PUINT lpPriorityList,
    int   cfmts)
{
    PWINDOWSTATION pwinsta;
    PCLIP          pClip;
    int            iFmt;
    UINT           fmt;

    /*
     * Blow it off if the caller does not have the proper access rights
     */
    if ((pwinsta = CheckClipboardAccess()) == NULL)
        return 0;

    /*
     * If there is no clipboard or no objects in the clipboard, return 0.
     */
    if ((pwinsta->cNumClipFormats == 0) || (pwinsta->pClipBase == NULL))
        return 0;

    /*
     * Look through the list for any of the formats in lpPriorityList.
     */
    while (cfmts-- > 0) {

        fmt = *lpPriorityList;

        if (fmt != 0) {

            pClip = pwinsta->pClipBase;

            for (iFmt = pwinsta->cNumClipFormats; iFmt-- != 0; pClip++) {

                if (pClip->fmt == fmt)
                    return fmt;
            }
        }

        lpPriorityList++;
    }

    /*
     * There is no matching format.  Return -1.
     */
    return -1;
}

/***************************************************************************\
* xxxSetClipboardViewer (API)
*
* Sets the clipboard viewer window.
*
* History:
* 18-Nov-1990 ScottLu   Ported from Win3.
* 11-Feb-1991 JimA      Added access checks.
\***************************************************************************/

PWND xxxSetClipboardViewer(
    PWND pwndClipViewerNew)
{
    TL             tlpwinsta;
    PWINDOWSTATION pwinsta;
    HWND           hwndClipViewerOld;
    PTHREADINFO    ptiCurrent;

    CheckLock(pwndClipViewerNew);

    /*
     * Blow it off if the caller does not have the proper access rights.
     * The NULL return really doesn't indicate an error but the
     * supposed viewer will never receive any clipboard messages, so
     * it shouldn't cause any problems.
     */
    if ((pwinsta = CheckClipboardAccess()) == NULL)
        return NULL;

    ptiCurrent = PtiCurrent();

    ThreadLockWinSta(ptiCurrent, pwinsta, &tlpwinsta);

    hwndClipViewerOld = HW(pwinsta->spwndClipViewer);
    Lock(&pwinsta->spwndClipViewer, pwndClipViewerNew);

    xxxDrawClipboard(pwinsta);

    ThreadUnlockWinSta(ptiCurrent, &tlpwinsta);

    if (hwndClipViewerOld != NULL)
        return RevalidateHwnd(hwndClipViewerOld);

    return NULL;
}

/***************************************************************************\
* xxxChangeClipboardChain (API)
*
* Changes the clipboard viewer chain.
*
* History:
* 18-Nov-1990 ScottLu   Ported from Win3.
* 11-Feb-1991 JimA      Added access checks.
\***************************************************************************/

BOOL xxxChangeClipboardChain(
    PWND pwndRemove,
    PWND pwndNewNext)
{
    TL             tlpwinsta;
    PWINDOWSTATION pwinsta;
    BOOL           result;
    TL             tlpwndClipViewer;
    PTHREADINFO    ptiCurrent;

    CheckLock(pwndRemove);
    CheckLock(pwndNewNext);

    /*
     * Blow it off if the caller does not have the proper access rights.
     */
    if ((pwinsta = CheckClipboardAccess()) == NULL)
        return FALSE;

    /*
     * pwndRemove should be this thread's window, pwndNewNext will
     * either be NULL or another thread's window.
     */
    ptiCurrent = PtiCurrent();

    if (GETPTI(pwndRemove) != ptiCurrent) {
        RIPMSG0(RIP_WARNING, "Clipboard: ChangeClipboardChain will not remove cross threads");
        return FALSE;
    }

    if (pwinsta->spwndClipViewer == NULL) {
        RIPMSG0(RIP_WARNING, "Clipboard: ChangeClipboardChain has no viewer window");
        return FALSE;
    }

    ThreadLockWinSta(ptiCurrent, pwinsta, &tlpwinsta);

    if (pwndRemove == pwinsta->spwndClipViewer) {

        Lock(&pwinsta->spwndClipViewer, pwndNewNext);
        result = TRUE;

    } else {

        ThreadLockAlways(pwinsta->spwndClipViewer, &tlpwndClipViewer);
        result = (BOOL)xxxSendMessage(pwinsta->spwndClipViewer,
                                      WM_CHANGECBCHAIN,
                                      (WPARAM)HW(pwndRemove),
                                      (LPARAM)HW(pwndNewNext));
        ThreadUnlock(&tlpwndClipViewer);
    }

    ThreadUnlockWinSta(ptiCurrent, &tlpwinsta);

    return result;
}

/***************************************************************************\
* DisownClipboard
*
* Disowns the clipboard so someone else can grab it.
*
* pwndClipOwner is the pwnd that is the reason for disowning the clipboard
* when that window is deleted
*
* History:
* 18-Jun-1991 DarrinM   Ported from Win3.
\***************************************************************************/

VOID DisownClipboard(PWND pwndClipOwner)
{
    TL             tlpwinsta;
    PWINDOWSTATION pwinsta;
    int            iFmt;
    int            cFmts;
    PCLIP          pClip;
    PCLIP          pClipOut;
    BOOL           fKeepDummyHandle;
    PTHREADINFO    ptiCurrent;

    if ((pwinsta = CheckClipboardAccess()) == NULL)
        return;

    ptiCurrent = PtiCurrent();

    ThreadLockWinSta(ptiCurrent, pwinsta, &tlpwinsta);

    xxxSendClipboardMessage(pwinsta, WM_RENDERALLFORMATS);

    pClipOut = pClip = pwinsta->pClipBase;
    fKeepDummyHandle = FALSE;

    for (cFmts = 0, iFmt = pwinsta->cNumClipFormats; iFmt-- != 0;) {

        /*
         * We have to remove the Dummy handles also if the corresponding
         * valid handles are NULL; We should not remove the dummy handles if
         * the corresponding valid handles are not NULL;
         * The following code assumes that only one dummy handle is possible
         * and that can appear only after the corresponding valid handle in
         * the pClip linked list;
         * Fix for Bug #???? --SANKAR-- 10-19-89 --OPUS BUG #3252--
         */
        if (pClip->hData != NULL) {

            if ((pClip->hData != DUMMY_TEXT_HANDLE) ||
                ((pClip->hData == DUMMY_TEXT_HANDLE) && fKeepDummyHandle)) {

                cFmts++;
                *pClipOut++ = *pClip;

                if (IsTextHandle(pClip->fmt, pClip->hData)) {
                    fKeepDummyHandle  = TRUE;
                }
            }
        }

        pClip++;
    }

    /*
     * Unlock the clipboard owner if the owner is still the window we were cleaning
     * up for.
     */
    if (pwndClipOwner == pwinsta->spwndClipOwner) {
        Unlock(&pwinsta->spwndClipOwner);
    } else {
        RIPMSG2(RIP_WARNING, "DisownClipboard: pwndClipOwner changed from %#p to %#p",
                pwndClipOwner, pwinsta->spwndClipOwner);
    }

    /*
     * If number of formats changed, redraw.
     */
    if (cFmts != pwinsta->cNumClipFormats) {
        pwinsta->fClipboardChanged = TRUE;
        pwinsta->iClipSequenceNumber++;
    }

    pwinsta->cNumClipFormats = cFmts;

    /*
     * If anything changed, redraw.  And make sure the data type munging is done.  Or else we will lose
     * them when xxxDrawClipboard clears the fClipboardChanged flag
     */
    if (pwinsta->fClipboardChanged) {
        xxxDrawClipboard(pwinsta);
        MungeClipData(pwinsta);
    }

    ThreadUnlockWinSta(ptiCurrent, &tlpwinsta);
}

/***************************************************************************\
* ForceEmptyClipboard
*
* We're logging off. Force the clipboard contents to go away.
*
* 23-Jul-1992 ScottLu   Created.
\***************************************************************************/

VOID ForceEmptyClipboard(
    PWINDOWSTATION pwinsta)
{

    pwinsta->ptiClipLock =  ((PTHREADINFO)(W32GetCurrentThread())); /*
                                                                     * This will be NULL
                                                                     *   for a non-GUI thread.
                                                                     */
    Unlock(&pwinsta->spwndClipOwner);
    Unlock(&pwinsta->spwndClipViewer);
    Unlock(&pwinsta->spwndClipOpen);

    xxxEmptyClipboard(pwinsta);

    /*
     * If the windowstation is dying, don't bother closing
     * the clipboard.
     */
    if (!(pwinsta->dwWSF_Flags & WSF_DYING))
        xxxCloseClipboard(pwinsta);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\cleanup.c ===
/****************************** Module Header ******************************\
* Module Name: cleanup.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains code used to clean up after a dying thread.
*
* History:
* 02-15-91 DarrinM      Created.
* 01-16-92 IanJa        Neutralized ANSI/UNICODE (debug strings kept ANSI)
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/***************************************************************************\
* CheckForClientDeath
*
* Check to see if the client thread that is paired to the current running
* server thread has died.  If it has, we raise an exception so this thread
* can perform its cleanup duties.  NOTE: If the client has died, this
* will not be returning back to its caller.
*
* History:
* 05-23-91 DarrinM      Created.
\***************************************************************************/

/***************************************************************************\
* PseudoDestroyClassWindows
*
* Walk the window tree from hwndParent looking for windows
* of class wndClass.  If one is found, destroy it.
*
*
* WARNING windows actually destroys these windows.  We only zombie-ize them
* so this call does not have to be an xxx call.
*
* History:
* 25-Mar-1994 JohnC from win 3.1
\***************************************************************************/

VOID PseudoDestroyClassWindows(PWND pwndParent, PCLS pcls)
{
    PWND pwnd;
    PTHREADINFO pti;

    pti = PtiCurrent();

    /*
     * Recursively walk the window list and zombie any windows of this class
     */
    for (pwnd = pwndParent->spwndChild; pwnd != NULL; pwnd = pwnd->spwndNext) {

        /*
         * If this window belongs to this class then zombie it
         * if it was created by this message thread.
         */
        if (pwnd->pcls == pcls && pti == GETPTI(pwnd)) {

            /*
             * Zombie-ize the window
             *
             * Remove references to the client side window proc because that
             * WOW selector has been freed.
             */

            RIPMSG1(RIP_WARNING,
                    "USER: Wow Window not destroyed: %lX", pwnd);

            if (!TestWF(pwnd, WFSERVERSIDEPROC)) {
                pwnd->lpfnWndProc = (WNDPROC_PWND)gpsi->apfnClientA.pfnDefWindowProc;
            }
        }

        /*
         * Recurse downward to look for any children that might be
         * of this class.
         */
        if (pwnd->spwndChild != NULL)
            PseudoDestroyClassWindows(pwnd, pcls);
    }
}

/***************************************************************************\
* Go through all the windows owned by the dying queue and do the following:
*
* 1. Restore Standard window classes have their window procs restored
*    to their original value, in case they were subclassed.
*
* 2. App window classes have their window procs set to DefWindowProc
*    so that we don't execute any app code.
*
* Array of original window proc addresses,
* indexed by ICLS_* value is in globals.c now -- gpfnwp.
*
* This array is initialized in code in init.c.
\***************************************************************************/

VOID _WOWModuleUnload(HANDLE hModule) {
    PPROCESSINFO ppi = PpiCurrent();
    PHE     pheT, pheMax;
    PPCLS   ppcls;
    int     i;

    UserAssert(gpfnwp[0]);

    /*
     * PseudoDestroy windows with wndprocs from this hModule
     * If its a wow16 wndproc, check if the hMod16 is this module
     * and Nuke matches.
     */
    pheMax = &gSharedInfo.aheList[giheLast];
    for (pheT = gSharedInfo.aheList; pheT <= pheMax; pheT++) {
        PTHREADINFO ptiTest = (PTHREADINFO)pheT->pOwner;
        PWND pwnd;
        if ((pheT->bType == TYPE_WINDOW) &&
            (ptiTest->TIF_flags & TIF_16BIT) &&
            (ptiTest->ppi == ppi)) {

            pwnd = (PWND) pheT->phead;
            if (!TestWF(pwnd, WFSERVERSIDEPROC) &&
                IsWOWProc(pwnd->lpfnWndProc) &&
                (pwnd->hMod16 == (WORD)(ULONG_PTR)hModule)) {
                pwnd->lpfnWndProc = (WNDPROC_PWND)gpsi->apfnClientA.pfnDefWindowProc;
            }
        }
    }

    /*
     * Destroy private classes identified by hInstance that are not
     * referenced by any windows.  Mark in-use classes for later
     * destruction.
     */
    ppcls = &(ppi->pclsPrivateList);

    for (i = 0; i < 2; ++i) {
        while (*ppcls != NULL) {

            PWC pwc;
            PCLS pcls;

            if (HIWORD((ULONG_PTR)(*ppcls)->hModule) == (WORD)(ULONG_PTR)hModule) {
                if ((*ppcls)->cWndReferenceCount == 0) {
                    DestroyClass(ppcls);
                    /*
                     * DestroyClass does *ppcls = pcls->pclsNext;
                     * so we just want continue here
                     */
                } else {

                    /*
                     * Zap all the windows around that belong to this class.
                     */
                    PseudoDestroyClassWindows(PtiCurrent()->rpdesk->pDeskInfo->spwnd, *ppcls);

                    /*
                     * Win 3.1 does not distinguish between Dll's and Exe's
                     */
                    (*ppcls)->CSF_flags |= CSF_WOWDEFERDESTROY;
                    ppcls = &((*ppcls)->pclsNext);
                }
                continue;
            }

            pcls = *ppcls;

            if ((pcls->CSF_flags & CSF_WOWCLASS) && ((WORD)(ULONG_PTR)hModule == (pwc = PWCFromPCLS(pcls))->hMod16)) {

                ATOM atom;
                int  iSel;

                /*
                 * See if the window's class atom matches any of
                 * the system ones. If so, jam in the original window proc.
                 * Otherwise, use DefWindowProc
                 */
                atom = (*ppcls)->atomClassName;
                for (iSel = ICLS_BUTTON; iSel < ICLS_MAX; iSel++) {
                    if ((gpfnwp[iSel]) && (atom == gpsi->atomSysClass[iSel])) {
                        (*ppcls)->lpfnWndProc = (WNDPROC_PWND)gpfnwp[iSel];
                        break;
                    }
                }
                if (iSel == ICLS_MAX)
                    (*ppcls)->lpfnWndProc = (WNDPROC_PWND)gpsi->apfnClientW.pfnDefWindowProc;
            }

            ppcls = &((*ppcls)->pclsNext);
        }

        /*
         * Destroy public classes identified by hInstance that are not
         * referenced by any windows.  Mark in-use classes for later
         * destruction.
         */
        ppcls = &(ppi->pclsPublicList);
    }
    return;

}


/***************************************************************************\
* _WOWCleanup
*
* Private API to allow WOW to cleanup any process-owned resources when
* a WOW thread exits or when a DLL is unloaded.
*
* Note that at module cleanup, hInstance = the module handle and hTaskWow
* is NULL.  On task cleanup, hInstance = the hInst/hTask combined which
* matches the value passed in hModule to WowServerCreateCursorIcon and
* hTaskWow != NULL.
*
* History:
* 09-02-92 JimA         Created.
\***************************************************************************/

VOID _WOWCleanup(
    HANDLE hInstance,
    DWORD hTaskWow)
{
    PPROCESSINFO ppi = PpiCurrent();
    PPCLS   ppcls;
    PHE     pheT, pheMax;
    int     i;

    if (hInstance != NULL) {

        /*
         * Task cleanup
         */

        PWND pwnd;
        hTaskWow = (DWORD) LOWORD(hTaskWow);
        /*
         * Task exit called by wow. This loop will Pseudo-Destroy windows
         * created by this task.
         */
        pheMax = &gSharedInfo.aheList[giheLast];
        for (pheT = gSharedInfo.aheList; pheT <= pheMax; pheT++) {
            PTHREADINFO ptiTest = (PTHREADINFO)pheT->pOwner;
            if ((pheT->bType == TYPE_WINDOW) &&
                (ptiTest->TIF_flags & TIF_16BIT) &&
                (ptiTest->ptdb) &&
                (ptiTest->ptdb->hTaskWow == hTaskWow) &&
                (ptiTest->ppi == ppi)) {

                pwnd = (PWND) pheT->phead;
                if (!TestWF(pwnd, WFSERVERSIDEPROC)) {
                    pwnd->lpfnWndProc = (WNDPROC_PWND)gpsi->apfnClientA.pfnDefWindowProc;
                }
            }
        }
        return;
    }

    /*
     * If we get here, we are in thread cleanup and all of the thread's windows
     * have been destroyed or disassociated with any classes.  If a class
     * marked for destruction at this point still has windows, they must
     * belong to a dll.
     */

    /*
     * Destroy private classes marked for destruction
     */
    ppcls = &(ppi->pclsPrivateList);
    for (i = 0; i < 2; ++i) {
        while (*ppcls != NULL) {
            if ((*ppcls)->hTaskWow == hTaskWow &&
                    ((*ppcls)->CSF_flags & CSF_WOWDEFERDESTROY)) {
                if ((*ppcls)->cWndReferenceCount == 0) {
                    DestroyClass(ppcls);
                } else {
                    RIPMSG0(RIP_ERROR, "Windows remain for a WOW class marked for destruction");
                    ppcls = &((*ppcls)->pclsNext);
                }
            } else
                ppcls = &((*ppcls)->pclsNext);
        }

        /*
         * Destroy public classes marked for destruction
         */
        ppcls = &(ppi->pclsPublicList);
    }

    /*
     * Destroy menus, cursors, icons and accel tables identified by hTaskWow
     */
    pheMax = &gSharedInfo.aheList[giheLast];
    for (pheT = gSharedInfo.aheList; pheT <= pheMax; pheT++) {

        /*
         * Check against free before we look at ppi... because pq is stored
         * in the object itself, which won't be there if TYPE_FREE.
         */
        if (pheT->bType == TYPE_FREE)
            continue;

        /*
         * Destroy those objects created by this task.
         */
        if (    !(gahti[pheT->bType].bObjectCreateFlags & OCF_PROCESSOWNED) ||
                (PPROCESSINFO)pheT->pOwner != ppi ||
                (((PPROCOBJHEAD)pheT->phead)->hTaskWow != hTaskWow) ||
                (pheT->bType == TYPE_CALLPROC)  /* Do not destroy CALLPROCDATA objects.
                                                      * These should only get nuked when the
                                                      * process goes away or when the class
                                                      * is nuked.
                                                      */
                    ) {

            continue;
        }

        /*
         * Make sure this object isn't already marked to be destroyed - we'll
         * do no good if we try to destroy it now since it is locked.
         */
        if (pheT->bFlags & HANDLEF_DESTROY) {
            continue;
        }

        /*
         * Destroy this object.
         */
        HMDestroyUnlockedObject(pheT);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\dc.c ===
/****************************** Module Header ******************************\
* Module Name: dc.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains User's DC APIs and related functions.
*
* History:
* 23-Oct-1990 DarrinM   Created.
* 07-Feb-1991 MikeKe    Added Revalidation code (None).
* 17-Jul-1991 DarrinM   Recreated from Win 3.1 source.
* 21-Jan-1992 IanJa     ANSI/Unicode neutral (null op).
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*
 * DBG Related Information.
 */
#if DBG
BOOL fDisableCache;                 // TRUE to disable DC cache.
#endif

/***************************************************************************\
* DecrementFreeDCECount
*
\***************************************************************************/

__inline VOID DecrementFreeDCECount(VOID)
{
    gnDCECount--;
    UserAssert(gnDCECount >= 0);
}

/***************************************************************************\
* IncrementFreeDCECount
*
\***************************************************************************/

__inline VOID IncrementFreeDCECount(VOID)
{
    gnDCECount++;
    UserAssert(gnDCECount >= 0);
}

/***************************************************************************\
* SetMonitorRegion
*
* The region is in meta dc coordinates, so convert to monitor coords.
\***************************************************************************/

void SetMonitorRegion(PMONITOR pMonitor, HRGN hrgnDst, HRGN hrgnSrc)
{
    if (IntersectRgn(hrgnDst, hrgnSrc, pMonitor->hrgnMonitor) == ERROR) {
        GreSetRectRgn(hrgnDst, 0, 0, 0, 0);
        return;
    }

    GreOffsetRgn(hrgnDst, -pMonitor->rcMonitor.left, -pMonitor->rcMonitor.top);
}

/***************************************************************************\
* ResetOrg
*
* Resets the origin of the DC associated with *pdce, and selects
* a new visrgn.
*
* History:
* 17-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

VOID ResetOrg(
    HRGN hrgn,
    PDCE pdce,
    BOOL fSetVisRgn)
{
    RECT  rc;
    PWND  pwndLayer;

    /*
     * For compatibility purposes, make sure that the DC's for the
     * desktop windows originate at the primary monitor, i.e. (0,0).
     */
    if (GETFNID(pdce->pwndOrg) == FNID_DESKTOP) {
        rc.left = rc.top = 0;
        rc.right = SYSMET(CXVIRTUALSCREEN);
        rc.bottom = SYSMET(CYVIRTUALSCREEN);
    } else if (pdce->DCX_flags & DCX_WINDOW) {
        rc = pdce->pwndOrg->rcWindow;
    } else {
        rc = pdce->pwndOrg->rcClient;
    }

    if (pdce->pMonitor != NULL) {
        OffsetRect(&rc, -pdce->pMonitor->rcMonitor.left,
                -pdce->pMonitor->rcMonitor.top);

        if (hrgn != NULL) {
            SetMonitorRegion(pdce->pMonitor, hrgn, hrgn);
        }
    }

    if ((pwndLayer = GetStyleWindow(pdce->pwndOrg, WEFPREDIRECTED)) != NULL) {

        int x = pwndLayer->rcWindow.left;
        int y = pwndLayer->rcWindow.top;

        UserAssert(pdce->DCX_flags & DCX_REDIRECTED);

        /*
         * For layered redirection DCs, the surface origin is the
         * window origin, so offset both the rectangle and the
         * region appropriately.
         */
        OffsetRect(&rc, -x, -y);
        if (hrgn != NULL) {
            GreOffsetRgn(hrgn, -x, -y);
        }

    } else if (GetStyleWindow(pdce->pwndOrg, WEFLAYERED) != NULL) {

        /*
         * Layered windows can only draw to the screen via the redirection
         * DCs or UpdateLayeredWindow, so select an empty visrgn into this
         * screen DC.
         */
        if (hrgn != NULL) {
            GreSetRectRgn(hrgn, 0, 0, 0, 0);
        }
    }

    GreSetDCOrg(pdce->hdc, rc.left, rc.top, (PRECTL)&rc);

    if (fSetVisRgn) {
        GreSelectVisRgn(pdce->hdc, hrgn, SVR_DELETEOLD);
    }
}

/***************************************************************************\
* GetDC (API)
*
* Standard call to GetDC().
*
* History:
* 17-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

HDC _GetDC(
    PWND pwnd)
{
    /*
     * Special case for NULL: For backward compatibility we want to return
     * a window DC for the desktop that does not exclude its children.
     */
    if (pwnd == NULL) {

        PDESKTOP pdesk = PtiCurrent()->rpdesk;

        if (pdesk) {
            return _GetDCEx(pdesk->pDeskInfo->spwnd,
                            NULL,
                            DCX_WINDOW | DCX_CACHE);
        }

        /*
         * The thread has no desktop.  Fail the call.
         */
        return NULL;
    }

    return _GetDCEx(pwnd, NULL, DCX_USESTYLE);
}

/***************************************************************************\
* _ReleaseDC (API)
*
* Release the DC retrieved from GetDC().
*
* History:
* 17-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

BOOL _ReleaseDC(
    HDC hdc)
{
    CheckCritIn();

    return (ReleaseCacheDC(hdc, FALSE) == DCE_NORELEASE ? FALSE : TRUE);
}

/***************************************************************************\
* _GetWindowDC (API)
*
* Retrive a DC for the window.
*
* History:
* 17-Jul-1991 DarrinM   Ported from Win 3.1 sources.
* 25-Jan-1996 ChrisWil  Allow rgnClip so that WM_NCACTIVATE can clip.
\***************************************************************************/

HDC _GetWindowDC(
    PWND pwnd)
{

#if 0

    /*
     * For WIN31 and previous apps, we want to actually return back a
     * client DC.  Before WIN40, the window rect and client rect were the
     * same, and there was this terrible hack to grab the window dc when
     * painting because window DCs never clip anything.  Otherwise the
     * children of the minimized window would be clipped out of the fake
     * client area.  So apps would call GetWindowDC() to redraw their icons,
     * since GetDC() would clip empty if the window had a class icon.
     */
    if (TestWF(pwnd, WFMINIMIZED) && !TestWF(pwnd, WFWIN40COMPAT))
        return(_GetDCEx(pwnd, hrgnClip, DCX_INTERNAL | DCX_CACHE | DCX_USESTYLE));
#endif

    return _GetDCEx(pwnd, NULL, DCX_WINDOW | DCX_USESTYLE);
}

/***************************************************************************\
* UserSetDCVisRgn
*
* Set the visrgn for the DCE.  If the window has a (hrgnClipPublic), we use
* that instead of the (hrgnClip) since it's a public-object.  The other is
* created and owned by the user-thread and can't be used if say we're in the
* hung-app-drawing (different process).  Both regions should be equalent in
* data.
*
* History:
* 10-Nov-1992 DavidPe   Created.
* 20-Dec-1995 ChrisWil  Added (hrgnClipPublic) entry.
\***************************************************************************/

VOID UserSetDCVisRgn(
    PDCE pdce)
{
    HRGN hrgn = NULL;
    HRGN hrgnClipPublic;
    BOOL fTempPublic;
    PWND pwndLayer;

    /*
     * If the visrgn calculated is empt, set the flag DCX_PWNDORGINVISIBLE,
     * otherwise clear it (it could've been set earlier on).
     */
    if (!CalcVisRgn(&hrgn, pdce->pwndOrg, pdce->pwndClip, pdce->DCX_flags)) {
        pdce->DCX_flags |= DCX_PWNDORGINVISIBLE;
    } else {
        pdce->DCX_flags &= ~DCX_PWNDORGINVISIBLE;
    }


    /*
     * For redirected windows, hrgnClipPublic was offset to 0,0 in _GetDCEx()
     * because all coordinates in the DC being used are relative to the
     * bitmap and not the screen.  But the region we just got from CalcVisRgn()
     * is in screen coordinates.  So we need to offset hrgnClipPublic back into
     * screen coordinates so that we can properly intersect it.
     */
    if ((pdce->hrgnClipPublic > HRGN_SPECIAL_LAST) &&
        ((pwndLayer = GetStyleWindow(pdce->pwndOrg, WEFPREDIRECTED)) != NULL)) {

        hrgnClipPublic = CreateEmptyRgnPublic();
        CopyRgn(hrgnClipPublic, pdce->hrgnClipPublic);
        GreOffsetRgn(hrgnClipPublic, pwndLayer->rcWindow.left, pwndLayer->rcWindow.top);

        fTempPublic = TRUE;
    } else {
        hrgnClipPublic = pdce->hrgnClipPublic;
        fTempPublic = FALSE;
    }


    /*
     * Deal with INTERSECTRGN and EXCLUDERGN.
     */
    if (pdce->DCX_flags & DCX_INTERSECTRGN) {

        UserAssert(hrgnClipPublic != HRGN_FULL);

        if (hrgnClipPublic == NULL) {
            SetEmptyRgn(hrgn);
        } else {
            IntersectRgn(hrgn, hrgn, hrgnClipPublic);
        }

    } else if (pdce->DCX_flags & DCX_EXCLUDERGN) {

        UserAssert(hrgnClipPublic != NULL);

        if (hrgnClipPublic == HRGN_FULL) {
            SetEmptyRgn(hrgn);
        } else {
            SubtractRgn(hrgn, hrgn, hrgnClipPublic);
        }
    }

    ResetOrg(hrgn, pdce, TRUE);

    if (fTempPublic) {
        GreDeleteObject(hrgnClipPublic);
    }
}

/***************************************************************************\
* UserGetClientRgn
*
* Return a copy of the client region and rectangle for the given hwnd.
*
* The caller must enter the user critical section before calling this function.
*
* History:
* 27-Sep-1993 WendyWu   Created.
\***************************************************************************/

HRGN UserGetClientRgn(
    HWND   hwnd,
    LPRECT lprc,
    BOOL   bWindowInsteadOfClient)
{
    HRGN hrgnClient = (HRGN)NULL;
    PWND pwnd;

    /*
     * Must be in critical section.
     */
    CheckCritIn();

    if (pwnd = ValidateHwnd(hwnd)) {

        if (bWindowInsteadOfClient) {

            /*
             * Never clip children for WO_RGN_WINDOW so that NetMeeting
             * gets the unioned window area:
             */

            CalcVisRgn(&hrgnClient,
                       pwnd,
                       pwnd,
                       DCX_WINDOW |
                       (TestWF(pwnd, WFCLIPSIBLINGS) ? DCX_CLIPSIBLINGS : 0));
        } else {
            CalcVisRgn(&hrgnClient,
                       pwnd,
                       pwnd,
                       DCX_CLIPCHILDREN | DCX_CLIPSIBLINGS);
        }

        *lprc = pwnd->rcClient;
    }

    return hrgnClient;
}

/***************************************************************************\
* UserGetHwnd
*
* Return a hwnd and the associated pwo for the given display hdc.
*
* It returns FALSE if no hwnd corresponds to the hdc is found or if the
* hwnd has incorrect styles for a device format window.
*
* The caller must enter the user critical section before calling this function.
*
* History:
* 27-Sep-1993 WendyWu   Created.
\***************************************************************************/

BOOL UserGetHwnd(
    HDC   hdc,
    HWND  *phwnd,
    PVOID *ppwo,
    BOOL  bCheckStyle)
{
    PWND pwnd;
    PDCE pdce;

    /*
     * Must be in critical section.
     */
    CheckCritIn();

    /*
     * Find pdce and pwnd for this DC.
     *
     * Note: the SAMEHANDLE macro strips out the user defined bits in the
     * handle before doing the comparison.  This is important because when
     * GRE calls this function, it may have lost track of the OWNDC bit.
     */
    for (pdce = gpDispInfo->pdceFirst; pdce != NULL; pdce = pdce->pdceNext) {

        if (pdce->hdc == hdc) // this should be undone once SAMEHANDLE is fixed for kmode
            break;
    }

    /*
     * Return FALSE If it is not in the pdce list.
     */
    if ((pdce == NULL) || (pdce->pwndOrg == NULL))
        return FALSE;

    pwnd = pdce->pwndOrg;

    /*
     * The window style must be clipchildren and clipsiblings.
     * the window's class must not be parentdc
     */
    if (bCheckStyle) {

        if (    !TestWF(pwnd, WFCLIPCHILDREN) ||
                !TestWF(pwnd, WFCLIPSIBLINGS) ||
                TestCF(pwnd, CFPARENTDC)) {

            RIPMSG0(RIP_WARNING, "UserGetHwnd: Bad OpenGL window style or class");
            return FALSE;
        }
    }

    /*
     * Return the hwnd with the correct styles for a device format window.
     */
    *phwnd = HW(pwnd);
    *ppwo  = _GetProp(pwnd, PROP_WNDOBJ, TRUE);

    return TRUE;
}

/***************************************************************************\
* UserAssociateHwnd
*
* Associate a gdi WNDOBJ with hwnd.  The caller must enter the user
* critical section before calling this function.
*
* If 'pwo' is NULL, the association is removed.
*
* History:
* 13-Jan-1994 HockL     Created.
\***************************************************************************/

VOID UserAssociateHwnd(
    HWND  hwnd,
    PVOID pwo)
{
    PWND pwnd;

    /*
     * Must be in critical section.
     */
    CheckCritIn();

    if (pwnd = ValidateHwnd(hwnd)) {

        if (pwo != NULL) {
            if (InternalSetProp(pwnd, PROP_WNDOBJ, pwo, PROPF_INTERNAL | PROPF_NOPOOL))
                gcountPWO++;
        } else {
            if (InternalRemoveProp(pwnd, PROP_WNDOBJ, TRUE))
                gcountPWO--;
        }
    }
}

/***************************************************************************\
* UserReleaseDC
*
* Enter's the critical section and calls _ReleaseDC.
*
* History:
* 25-Jan-1996 ChrisWil  Created comment block.
\***************************************************************************/

BOOL UserReleaseDC(
    HDC hdc)
{
    BOOL b;

    EnterCrit();
    b = _ReleaseDC(hdc);
    LeaveCrit();

    return b;
}

/***************************************************************************\
* InvalidateDce
*
* If the DCE is not in use, removes all information and marks it invalid.
* Otherwise, it resets the DCE flags based on the window styles and
* recalculates the vis rgn.
*
* History:
* 17-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

VOID InvalidateDce(
    PDCE pdce)
{
    GreLockDisplay(gpDispInfo->hDev);

    if (!(pdce->DCX_flags & DCX_INUSE)) {

        /*
         * Accumulate any bounds for this CE
         * since we're about to mark it invalid.
         */
        SpbCheckDce(pdce);

        MarkDCEInvalid(pdce);

        pdce->pwndOrg        = NULL;
        pdce->pwndClip       = NULL;
        pdce->hrgnClip       = NULL;
        pdce->hrgnClipPublic = NULL;

        /*
         * Remove the vis rgn since it is still owned - if we did not,
         * gdi would not be able to clean up properly if the app that
         * owns this vis rgn exist while the vis rgn is still selected.
         */
        GreSelectVisRgn(pdce->hdc, NULL, SVR_DELETEOLD);

    } else {

        PWND pwndOrg  = pdce->pwndOrg;
        PWND pwndClip = pdce->pwndClip;

        /*
         * In case the window's clipping style bits changed,
         * reset the DCE flags from the window style bits.
         * Note that minimized windows never exclude their children.
         */
        pdce->DCX_flags &= ~(DCX_CLIPCHILDREN | DCX_CLIPSIBLINGS);

        /*
         * Chicago stuff...
         */
        if (TestCF(pwndOrg, CFPARENTDC) &&
            (TestWF(pwndOrg, WFWIN31COMPAT) || !TestWF(pwndClip, WFCLIPCHILDREN)) &&
            (TestWF(pwndOrg, WFVISIBLE) == TestWF(pwndClip, WFVISIBLE))) {

            if (TestWF(pwndClip, WFCLIPSIBLINGS))
                pdce->DCX_flags |= DCX_CLIPSIBLINGS;

        } else {

            if (TestWF(pwndOrg, WFCLIPCHILDREN) && !TestWF(pwndOrg, WFMINIMIZED))
                pdce->DCX_flags |= DCX_CLIPCHILDREN;

            if (TestWF(pwndOrg, WFCLIPSIBLINGS))
                pdce->DCX_flags |= DCX_CLIPSIBLINGS;
        }

        /*
         * Mark that any saved visrgn needs to be recomputed.
         */
        pdce->DCX_flags |= DCX_SAVEDRGNINVALID;

        UserSetDCVisRgn(pdce);
    }

    GreUnlockDisplay(gpDispInfo->hDev);
}

/***************************************************************************\
* DeleteHrgnClip
*
* Deletes the clipping regions in the DCE, restores the saved visrgn,
* and invalidates the DCE if saved visrgn is invalid.
*
* History:
* 17-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

VOID DeleteHrgnClip(
    PDCE pdce)
{
    /*
     * Clear these flags first in case we get a DCHook() callback...
     */
    pdce->DCX_flags &= ~(DCX_EXCLUDERGN | DCX_INTERSECTRGN);

    /*
     * Blow away pdce->hrgnClip and clear the associated flags.
     * Do not delete hrgnClip if DCX_NODELETERGN is set!
     */
    if (!(pdce->DCX_flags & DCX_NODELETERGN)) {
        DeleteMaybeSpecialRgn(pdce->hrgnClip);
    } else {
        pdce->DCX_flags &= ~DCX_NODELETERGN;
    }

    DeleteMaybeSpecialRgn(pdce->hrgnClipPublic);

    pdce->hrgnClip       = NULL;
    pdce->hrgnClipPublic = NULL;

    /*
     * If the saved visrgn was invalidated by an InvalidateDce()
     * while we had it checked out, then invalidate the entry now.
     */
    if (pdce->DCX_flags & DCX_SAVEDRGNINVALID) {
        InvalidateDce(pdce);

        /*
         * We've just gone through InvalidateDce, so the visrgn in the
         * DC has been properly reset. Simply nuke the old saved visrgn.
         */
        if (pdce->hrgnSavedVis != NULL) {
            GreDeleteObject(pdce->hrgnSavedVis);
            pdce->hrgnSavedVis = NULL;
        }
    } else {
        /*
         * The saved visrgn is still valid, select it back into the
         * DC so the entry may be re-used without recomputing.
         */
        if (pdce->hrgnSavedVis != NULL) {
            GreSelectVisRgn(pdce->hdc, pdce->hrgnSavedVis, SVR_DELETEOLD);
            pdce->hrgnSavedVis = NULL;
        }
    }
}

/***************************************************************************\
* GetDCEx (API)
*
*
* History:
* 17-Jul-1991 DarrinM   Ported from Win 3.1 sources.
* 20-Dec-1995 ChrisWil  Added (hrgnClipPublic) entry.
\***************************************************************************/

HDC _GetDCEx(
    PWND  pwnd,
    HRGN  hrgnClip,
    DWORD DCX_flags)
{
    HRGN  hrgn;
    HDC   hdcMatch;
    PWND  pwndClip;
    PWND  pwndOrg;
    PDCE  pdce;
    PDCE  *ppdce;
    PDCE  *ppdceNotInUse;
    DWORD DCX_flagsMatch;
    BOOL  bpwndOrgVisible;
    PWND  pwndLayer;
    HBITMAP hbmLayer;
    BOOL  fVisRgnError = FALSE;

    /*
     * Lock the device while we're playing with visrgns.
     */
    GreLockDisplay(gpDispInfo->hDev);

    if (pwnd == NULL)
        pwnd = PtiCurrent()->rpdesk->pDeskInfo->spwnd;

    hdcMatch = NULL;
    pwndOrg  = pwndClip = pwnd;

    bpwndOrgVisible = IsVisible(pwndOrg);

    if (PpiCurrent()->W32PF_Flags & W32PF_OWNDCCLEANUP) {
        DelayedDestroyCacheDC();
    }

    /*
     * If necessary, compute DCX flags from window style.
     */
    if (DCX_flags & DCX_USESTYLE) {

        DCX_flags &= ~(DCX_CLIPSIBLINGS | DCX_CLIPCHILDREN | DCX_PARENTCLIP);

        if (!(DCX_flags & DCX_WINDOW)) {

            if (TestCF(pwndOrg, CFPARENTDC))
                DCX_flags |= DCX_PARENTCLIP;

            /*
             * If the DCX_CACHE flag is present, override OWNDC/CLASSDC.
             * Otherwise, calculate from appropriate style bits.
             */
            if (!(DCX_flags & DCX_CACHE) && !TestCF(pwndOrg, CFOWNDC)) {
                if (TestCF(pwndOrg, CFCLASSDC)) {
                    /*
                     * Look for a non-cache entry that matches hdc...
                     */
                    if (pwndOrg->pcls->pdce != NULL) {
                        hdcMatch = pwndOrg->pcls->pdce->hdc;
                    }
                } else {
                    DCX_flags |= DCX_CACHE;
                }
            }

            if (TestWF(pwndOrg, WFCLIPCHILDREN))
                DCX_flags |= DCX_CLIPCHILDREN;

            if (TestWF(pwndOrg, WFCLIPSIBLINGS))
                DCX_flags |= DCX_CLIPSIBLINGS;

            /*
             * Minimized windows never exclude their children.
             */
            if (TestWF(pwndOrg, WFMINIMIZED)) {
                DCX_flags &= ~DCX_CLIPCHILDREN;

                if (pwndOrg->pcls->spicn)
                    DCX_flags |= DCX_CACHE;
            }

        } else {
            if (TestWF(pwndClip, WFCLIPSIBLINGS))
                DCX_flags |= DCX_CLIPSIBLINGS;

            DCX_flags |= DCX_CACHE;

            /*
             * Window DCs never exclude children.
             */
        }
    }

    /*
     * Deal with all the Win 3.0-compatible clipping rules:
     *
     * DCX_NOCLIPCHILDREN overrides:
     *      DCX_PARENTCLIP/CS_OWNDC/CS_CLASSDC
     * DCX_PARENTCLIP overrides:
     *      DCX_CLIPSIBLINGS/DCX_CLIPCHILDREN/CS_OWNDC/CS_CLASSDC
     */
    if (DCX_flags & DCX_NOCLIPCHILDREN) {
        DCX_flags &= ~(DCX_PARENTCLIP | DCX_CLIPCHILDREN);
        DCX_flags |= DCX_CACHE;
    }

    /*
     * Deal with layered windows.
     */
    if ((pwndLayer = GetStyleWindow(pwndOrg, WEFPREDIRECTED)) != NULL &&
            (hbmLayer = GetRedirectionBitmap(pwndLayer)) != NULL) {

        /*
         * Get a layered redirection DC.
         */
        DCX_flags |= DCX_REDIRECTED;

        /*
         * When the window we're getting the DC for is the layered and
         * redirected window, don't allow to clip to its parent, since
         * clipping must not exceed the size of the backing bitmap.
         */
        if (pwndOrg == pwndLayer) {
            DCX_flags &= ~DCX_PARENTCLIP;
        }

        /*
         * Convert hrgnClip from screen to the redirection DC coordinates.
         */
        if (hrgnClip > HRGN_SPECIAL_LAST) {

            if (DCX_flags & DCX_NODELETERGN) {

                HRGN hrgnClipSave = hrgnClip;
                hrgnClip = CreateEmptyRgnPublic();
                CopyRgn(hrgnClip, hrgnClipSave);
                DCX_flags &= ~DCX_NODELETERGN;
            }

            GreOffsetRgn(hrgnClip, -pwndLayer->rcWindow.left,
                    -pwndLayer->rcWindow.top);
        }
    } else {
        pwndLayer = NULL;
        hbmLayer = NULL;
    }

    if (DCX_flags & DCX_PARENTCLIP) {

        PWND pwndParent;

        /*
         * If this window has no parent.  This can occur if the app is
         * calling GetDC in response to a CBT_CREATEWND callback.  In this
         * case, the parent is not yet setup.
         */
        if (pwndOrg->spwndParent == NULL)
            pwndParent = PtiCurrent()->rpdesk->pDeskInfo->spwnd;
        else
            pwndParent = pwndOrg->spwndParent;

        /*
         * Always get the DC from the cache.
         */
        DCX_flags |= DCX_CACHE;

        /*
         * We can't use a shared DC if the visibility of the
         * child does not match the parent's, or if a
         * CLIPSIBLINGS or CLIPCHILDREN DC is requested.
         *
         * In 3.1, we pay attention to the CLIPSIBLINGS and CLIPCHILDREN
         * bits of CS_PARENTDC windows, by overriding CS_PARENTDC if
         * either of these flags are requested.
         *
         * BACKWARD COMPATIBILITY HACK
         *
         * If parent is CLIPCHILDREN, get a cache DC, but don't
         * use parent's DC.  Windows PowerPoint depends on this
         * behavior in order to draw the little gray rect between
         * its scroll bars correctly.
         */
        if (!(DCX_flags & (DCX_CLIPSIBLINGS | DCX_CLIPCHILDREN)) &&
                (TestWF(pwndOrg, WFWIN31COMPAT) || !TestWF(pwndParent, WFCLIPCHILDREN)) &&
                TestWF(pwndParent, WFVISIBLE) == TestWF(pwndOrg, WFVISIBLE)) {

            pwndClip = pwndParent;

#if DBG
            if (DCX_flags & DCX_CLIPCHILDREN)
                RIPMSG0(RIP_WARNING, "WS_CLIPCHILDREN overridden by CS_PARENTDC");
            if (DCX_flags & DCX_CLIPSIBLINGS)
                RIPMSG0(RIP_WARNING, "WS_CLIPSIBLINGS overridden by CS_PARENTDC");
#endif
            /*
             * Make sure flags reflect hwndClip rather than hwndOrg.
             * But, we must never clip the children (since that's who
             * wants to do the drawing!)
             */
            DCX_flags &= ~(DCX_CLIPCHILDREN | DCX_CLIPSIBLINGS);
            if (TestWF(pwndClip, WFCLIPSIBLINGS))
                DCX_flags |= DCX_CLIPSIBLINGS;
        }
    }

    /*
     * Make sure we don't return an OWNDC if the calling thread didn't
     * create this window - need to returned cached always in this case.
     *
     * Win95 does not contain this code.  Why?
     */
    if (!(DCX_flags & DCX_CACHE)) {
        if (pwndOrg == NULL || GETPTI(pwndOrg) != PtiCurrent())
            DCX_flags |= DCX_CACHE;
    }

    DCX_flagsMatch = DCX_flags & DCX_MATCHMASK;

    if (!(DCX_flags & DCX_CACHE)) {

        /*
         * Handle CS_OWNDC and CS_CLASSDC cases specially.  Based on the
         * supplied match information, we need to find the appropriate DCE.
         */
        for (ppdce = &gpDispInfo->pdceFirst; (pdce = *ppdce); ppdce = &pdce->pdceNext) {

            if (pdce->DCX_flags & DCX_CACHE)
                continue;

            /*
             * Look for the entry that matches hdcMatch or pwndOrg...
             */
            if (!(pdce->pwndOrg == pwndOrg || pdce->hdc == hdcMatch))
                continue;

            /*
             * NOTE: The "Multiple-BeginPaint()-of-OWNDC-Window" Conundrum
             *
             * There is a situation having to do with OWNDC or CLASSDC window
             * DCs that can theoretically arise that is handled specially
             * here and in ReleaseCacheDC().  These DCs are identified with
             * the DCX_CACHE bit CLEAR.
             *
             * In the case where BeginPaint() (or a similar operation) is
             * called more than once without an intervening EndPaint(), the
             * DCX_INTERSECTRGN (or DCX_EXCLUDERGN) bit may already be set
             * when we get here.
             *
             * Theoretically, the correct thing to do is to save the current
             * hrgnClip, and set up the new one here.  In ReleaseCacheDC, the
             * saved hrgnClip is restored and the visrgn recomputed.
             *
             * All of this is only necessary if BOTH calls involve an
             * hrgnClip that causes the visrgn to be changed (i.e., the
             * simple hrgnClip test clears the INTERSECTRGN or EXCLUDERGN bit
             * fails), which is not at all likely.
             *
             * When this code encounters this multiple-BeginPaint case it
             * punts by honoring the new EXCLUDE/INTERSECTRGN bits, but it
             * first restores the DC to a wide-open visrgn before doing so.
             * This means that the first EndPaint() will restore the visrgn
             * to a wide-open DC, rather than clipped to the first
             * BeginPaint()'s update rgn.  This is a good punt, because worst
             * case an app does a bit more drawing than it should.
             */
            if ((pdce->DCX_flags & (DCX_EXCLUDERGN | DCX_INTERSECTRGN)) &&
                    (DCX_flags & (DCX_EXCLUDERGN | DCX_INTERSECTRGN))) {

                RIPMSG0(RIP_WARNING, "Nested BeginPaint() calls, please fix Your app!");
                DeleteHrgnClip(pdce);
            }

            if (pdce->DCX_flags & DCX_REDIRECTED) {
                /*
                 * We're giving out the same DC again. Since it may not have
                 * been released, transfer any accumulated bits if needed.
                 */
                UpdateRedirectedDC(pdce);

                /*
                 * As this point, the DC may get converted back to a screen
                 * DC, so we must select the screen surface back into the DC.
                 */
                UserVerify(GreSelectRedirectionBitmap(pdce->hdc, NULL));
            }

            /*
             * If we matched exactly, no recomputation necessary
             * (we found a CS_OWNDC or a CS_CLASSDC that is already set up)
             * Otherwise, we have a CS_CLASSDC that needs recomputation.
             */
            if (    pdce->pwndOrg == pwndOrg &&
                    bpwndOrgVisible &&
                    (pdce->DCX_flags & DCX_REDIRECTED) == (DCX_flags & DCX_REDIRECTED) &&
                    !(pdce->DCX_flags & DCX_PWNDORGINVISIBLE)) {

                goto HaveComputedEntry;
            }

            goto RecomputeEntry;
        }

        RIPMSG1(RIP_WARNING, "Couldn't find DC for %p - bad code path", pwndOrg);

NullExit:

        GreUnlockDisplay(gpDispInfo->hDev);
        return NULL;

    } else {

        /*
         * Make a quick pass through the cache, looking for an
         * exact match.
         */
SearchAgain:

#if DBG
        if (fDisableCache)
            goto SearchFailed;
#endif

        /*
         * CONSIDER (adams): Put this check into the loop above so we don't
         * touch all these pages twice?
         */
        for (ppdce = &gpDispInfo->pdceFirst; (pdce = *ppdce); ppdce = &pdce->pdceNext) {

            /*
             * If we find an entry that is not in use and whose clip flags
             * and clip window match, we can use it.
             *
             * NOTE: DCX_INTERSECT/EXCLUDERGN cache entries always have
             * DCX_INUSE set, so we'll never erroneously match one here.
             */
            UserAssert(!(pdce->DCX_flags & (DCX_INTERSECTRGN | DCX_EXCLUDERGN)) ||
                       (pdce->DCX_flags & DCX_INUSE));

            if ((pdce->pwndClip == pwndClip) &&
                pdce->pMonitor == NULL &&
                (DCX_flagsMatch == (pdce->DCX_flags & (DCX_MATCHMASK | DCX_INUSE | DCX_INVALID)))) {

                /*
                 * Special case for icon - bug 9103 (win31)
                 */
                if (TestWF(pwndClip, WFMINIMIZED) &&
                    (pdce->pwndOrg != pdce->pwndClip)) {
                    continue;
                }

                /*
                 * If the pwndOrg of the DC we found is not visible and
                 * the pwndOrg we're looking for is visble, then
                 * the visrgn is no good, we can't reuse it so keep
                 * looking.
                 */
                if (bpwndOrgVisible && pdce->DCX_flags & DCX_PWNDORGINVISIBLE) {
                    continue;
                }

                /*
                 * Set INUSE before performing any GDI operations, just
                 * in case DCHook() has a mind to recalculate the visrgn...
                 */
                pdce->DCX_flags |= DCX_INUSE;

                /*
                 * We found an entry with the proper visrgn.
                 * If the origin doesn't match, update the CE and reset it.
                 */
                if (pwndOrg != pdce->pwndOrg) {
                    /*
                     * Need to flush any dirty rectangle stuff now.
                     */
                    SpbCheckDce(pdce);

                    pdce->pwndOrg = pwndOrg;
                    ResetOrg(NULL, pdce, FALSE);
                }

                goto HaveComputedEntry;
            }
        }

#if DBG
SearchFailed:
#endif

        /*
         * Couldn't find an exact match.  Find some invalid or non-inuse
         * entry we can reuse.
         */
        ppdceNotInUse = NULL;
        for (ppdce = &gpDispInfo->pdceFirst; (pdce = *ppdce); ppdce = &pdce->pdceNext) {

            /*
             * Skip non-cache entries
             */
            if (!(pdce->DCX_flags & DCX_CACHE))
                continue;

            /*
             * Skip monitor-specific entires
             */
            if (pdce->pMonitor != NULL)
                continue;

            if (pdce->DCX_flags & DCX_INVALID) {
                break;
            } else if (!(pdce->DCX_flags & DCX_INUSE)) {

                /*
                 * Remember the non-inuse one, but keep looking for an invalid.
                 */
                ppdceNotInUse = ppdce;
            }
        }

        /*
         * If we broke out of the loop, we found an invalid entry to reuse.
         * Otherwise see if we found a non-inuse entry to reuse.
         */
        if (pdce == NULL && ((ppdce = ppdceNotInUse) == NULL)) {

            /*
             * Create another DCE if we need it.
             */
            if (!CreateCacheDC(pwndOrg,
                               DCX_INVALID | DCX_CACHE |
                               (DCX_flags & DCX_REDIRECTED),
                               NULL)) {
                goto NullExit;
            }

            goto SearchAgain;
        }

        /*
         * We've chosen an entry to reuse: now fill it in and recompute it.
         */
        pdce = *ppdce;

RecomputeEntry:

        /*
         * Any non-invalid entries that we reuse might still have some bounds
         * that need to be used to invalidate SPBs.  Apply them here.
         */
        if (!(pdce->DCX_flags & DCX_INVALID))
            SpbCheckDce(pdce);

        /*
         * We want to compute only the matchable visrgn at first,
         * so we don't set up hrgnClip, or set the EXCLUDERGN or INTERSECTRGN
         * bits yet -- we'll deal with those later.
         */
        pdce->DCX_flags = DCX_flagsMatch | DCX_INUSE;

#if DBG
        /*
         * We're about to select the visrgn into the DC, even though it's
         * not yet completely setup. Turn off the visrgn validation for now.
         * It will be turned on before this function returns.
         */
        GreValidateVisrgn(pdce->hdc, FALSE);
#endif

        /*
         * Now recompute the visrgn (minus any hrgnClip shenanigans)
         */
        if (TestWF(pwndOrg, WEFPREDIRECTED)) {
            DCX_flagsMatch |= DCX_REDIRECTEDBITMAP;
        }


        hrgn = NULL;
        if (CalcVisRgn(&hrgn, pwndOrg, pwndClip, DCX_flagsMatch) == FALSE) {
            pdce->DCX_flags |= DCX_PWNDORGINVISIBLE;
        }

        pdce->pwndOrg        = pwndOrg;
        pdce->pwndClip       = pwndClip;
        pdce->hrgnClip       = NULL;      // Just in case...
        pdce->hrgnClipPublic = NULL;

        ResetOrg(hrgn, pdce, TRUE);

        if (hrgn == NULL) {
            fVisRgnError = TRUE;
        }

        /*
         * When we arrive here, pdce (and *ppdce) point to
         * a cache entry whose visrgn and origin are set up.
         * All that remains to be done is to deal with EXCLUDE/INTERSECTRGN
         */
HaveComputedEntry:

        /*
         * If the window clipping flags have changed in the window
         * since the last time this dc was invalidated, then recompute
         * this dc entry.
         */
        if ((pdce->DCX_flags & DCX_MATCHMASK) != (DCX_flags & DCX_MATCHMASK))
            goto RecomputeEntry;

        /*
         * Let's check these assertions just in case...
         */
        UserAssert(pdce);
        UserAssert(*ppdce == pdce);
        UserAssert(pdce->DCX_flags & DCX_INUSE);
        UserAssert(!(pdce->DCX_flags & DCX_INVALID));
        UserAssert((pdce->DCX_flags & DCX_MATCHMASK) == (DCX_flags & DCX_MATCHMASK));

        /*
         * Move the dce to the head of the list so it's easy to find later.
         */
        if (pdce != gpDispInfo->pdceFirst) {
            *ppdce = pdce->pdceNext;
            pdce->pdceNext = gpDispInfo->pdceFirst;
            gpDispInfo->pdceFirst = pdce;
        }

#if DBG
        /*
         * We're about to mess with the visrgn in this DC, even though it's
         * not yet completely setup. Turn off the visrgn validation for now.
         * It will be turned on before this function returns.
         */
        GreValidateVisrgn(pdce->hdc, FALSE);
#endif

        /*
         * Time to deal with DCX_INTERSECTRGN or DCX_EXCLUDERGN.
         *
         * We handle these two bits specially, because cache entries
         * with these bits set cannot be reused with the bits set.  This
         * is because the area described in hrgnClip would have to be
         * compared along with the bit, which is a pain, especially since
         * they'd never match very often anyhow.
         *
         * What we do instead is to save the visrgn of the window before
         * applying either of these two flags, which is then restored
         * at ReleaseCacheDC() time, along with the clearing of these bits.
         * This effectively converts a cache entry with either of these
         * bits set into a "normal" cache entry that can be matched.
         */
        if (DCX_flags & DCX_INTERSECTRGN) {

            if (hrgnClip != HRGN_FULL) {

                SetEmptyRgn(ghrgnGDC);

                /*
                 * Save the visrgn for reuse on ReleaseDC().
                 * (do this BEFORE we set hrgnClip & pdce->flag bit,
                 * so that if a DCHook() callback occurs it recalculates
                 * without hrgnClip)
                 */
                UserAssertMsg0(!pdce->hrgnSavedVis,
                               "Nested SaveVisRgn attempt in _GetDCEx");

                /*
                 * get the current vis region into hrgnSavedVis.  Temporarily
                 * store a dummy one in the DC.
                 */

                pdce->hrgnSavedVis = CreateEmptyRgn();

                GreSelectVisRgn(pdce->hdc,pdce->hrgnSavedVis, SVR_SWAP);

                pdce->hrgnClip = hrgnClip;

                if (DCX_flags & DCX_NODELETERGN)
                    pdce->DCX_flags |= DCX_NODELETERGN;

                pdce->DCX_flags |= DCX_INTERSECTRGN;

                if (hrgnClip == NULL) {

                    pdce->hrgnClipPublic = NULL;

                } else {

                    IntersectRgn(ghrgnGDC, pdce->hrgnSavedVis, hrgnClip);

                    /*
                     * Make a copy of the hrgnClip and make it public
                     * so that we can use it in calculations in HungDraw.
                     */
                    pdce->hrgnClipPublic = CreateEmptyRgnPublic();
                    CopyRgn(pdce->hrgnClipPublic, hrgnClip);
                }

                /*
                 * Clear the SAVEDRGNINVALID bit, since we're just
                 * about to set it properly now.  If the dce later
                 * gets invalidated, it'll set this bit so we know
                 * to recompute it when we restore the visrgn.
                 */
                pdce->DCX_flags &= ~DCX_SAVEDRGNINVALID;

                /*
                 * Select in the new region.  we use the SWAP_REGION mode
                 * so that ghrgnGDC always has a valid rgn
                 */

                GreSelectVisRgn(pdce->hdc, ghrgnGDC, SVR_SWAP);
            }
        } else if (DCX_flags & DCX_EXCLUDERGN) {

            if (hrgnClip != NULL) {

                SetEmptyRgn(ghrgnGDC);

                /*
                 * Save the visrgn for reuse on ReleaseDC().
                 * (do this BEFORE we set hrgnClip & pdce->flag bit,
                 * so that if a DCHook() callback occurs it recalculates
                 * without hrgnClip)
                 */
                UserAssertMsg0(!pdce->hrgnSavedVis,
                               "Nested SaveVisRgn attempt in _GetDCEx");

                /*
                 * get the current vis region into hrgnSavedVis.  Temporarily
                 * store a dummy one in the DC.
                 */
                pdce->hrgnSavedVis = CreateEmptyRgn();

                GreSelectVisRgn(pdce->hdc,pdce->hrgnSavedVis, SVR_SWAP);

                pdce->hrgnClip = hrgnClip;

                if (DCX_flags & DCX_NODELETERGN)
                    pdce->DCX_flags |= DCX_NODELETERGN;

                pdce->DCX_flags |= DCX_EXCLUDERGN;

                if (hrgnClip == HRGN_FULL) {

                    pdce->hrgnClipPublic = HRGN_FULL;

                } else {

                    SubtractRgn(ghrgnGDC, pdce->hrgnSavedVis, hrgnClip);

                    /*
                     * Make a copy of the hrgnClip and make it public
                     * so that we can use it in calculations in HungDraw.
                     */
                    pdce->hrgnClipPublic = CreateEmptyRgnPublic();
                    CopyRgn(pdce->hrgnClipPublic, hrgnClip);
                }

                /*
                 * Clear the SAVEDRGNINVALID bit, since we're just
                 * about to set it properly now.  If the dce later
                 * gets invalidated, it'll set this bit so we know
                 * to recompute it when we restore the visrgn.
                 */
                pdce->DCX_flags &= ~DCX_SAVEDRGNINVALID;

                /*
                 * Select in the new region.  we use the SWAP_REGION mode
                 * so that ghrgnGDC always has a valid rgn
                 */

                GreSelectVisRgn(pdce->hdc, ghrgnGDC, SVR_SWAP);
            }
        }
    }

    if (pdce->DCX_flags & DCX_REDIRECTED) {
        UserAssert(pwndLayer != NULL);
        UserAssert(hbmLayer != NULL);

        UserVerify(GreSelectRedirectionBitmap(pdce->hdc, hbmLayer));

        /*
         * Enable bounds accumulation, so we know if there was any drawing
         * done into that DC and the actual rect we need to update when
         * this DC is released.
         */
        GreGetBounds(pdce->hdc, NULL, GGB_ENABLE_WINMGR);

        /*
         * In case the visrgn couldn't be allocated, clear it in the
         * dc again, since we just selected a new surface.
         */
        if (fVisRgnError) {
            GreSelectVisRgn(pdce->hdc, NULL, SVR_DELETEOLD);
        }
    }

    /*
     * Whew! Set ownership and return the bloody DC.
     * Only set ownership for cache dcs.  Own dcs have already been owned.
     * The reason why we don't want to set the ownership over again is
     * because the console sets its owndcs to PUBLIC so gdisrv can use
     * them without asserting.  We don't want to set the ownership back
     * again.
     */
    if (pdce->DCX_flags & DCX_CACHE) {

        if (!GreSetDCOwner(pdce->hdc, OBJECT_OWNER_CURRENT)) {
            RIPMSG1(RIP_WARNING, "GetDCEx: SetDCOwner Failed %lX", pdce->hdc);
        }

        /*
         * Decrement the Free DCE Count.  This should always be >= 0,
         * since we'll create a new dce if the cache is all in use.
         */
        DecrementFreeDCECount();

        pdce->ptiOwner = PtiCurrent();
    }

    if (TestWF(pwnd, WEFLAYOUTRTL) && !(DCX_flags & DCX_NOMIRROR)) {
        GreSetLayout(pdce->hdc, -1, LAYOUT_RTL);
    }

#if DBG
    GreValidateVisrgn(pdce->hdc, TRUE);
#endif

    GreUnlockDisplay(gpDispInfo->hDev);

    return pdce->hdc;
}

/***************************************************************************\
* ReleaseCacheDC
*
* Releases a DC from the cache.
*
* History:
* 17-Jul-1991 DarrinM   Ported from Win 3.1 sources.
* 20-Dec-1995 ChrisWil  Added (hrgnClipPublic) entry.
\***************************************************************************/

UINT ReleaseCacheDC(
    HDC  hdc,
    BOOL fEndPaint)
{
    PDCE pdce;
    PDCE *ppdce;

    for (ppdce = &gpDispInfo->pdceFirst; (pdce = *ppdce); ppdce = &pdce->pdceNext) {

        if (pdce->hdc == hdc) {

            /*
             * Check for redundant releases or release of an invalid entry
             */
            if ((pdce->DCX_flags & (DCX_DESTROYTHIS | DCX_INVALID | DCX_INUSE)) != DCX_INUSE)
                return DCE_NORELEASE;

            /*
             * Lock the display since we may be playing with visrgns.
             */
            GreLockDisplay(gpDispInfo->hDev);

            if (pdce->DCX_flags & DCX_REDIRECTED) {
                UpdateRedirectedDC(pdce);
            }

            /*
             * If this is a permanent DC, then don't reset its state.
             */
            if (pdce->DCX_flags & DCX_CACHE) {
                /*
                 * Restore the DC state and mark the entry as not in use.
                 * Set owner back to server as well, since it's going back
                 * into the cache.
                 */
                if (!(pdce->DCX_flags & DCX_NORESETATTRS)) {
                    /*
                     * If bSetupDC() failed, the DC is busy (ie. in-use
                     * by another thread), so don't release it.
                     */
                    if ( (!(GreCleanDC(hdc))) ||
                         (!(GreSetDCOwner(hdc, OBJECT_OWNER_NONE))) ) {

                        GreUnlockDisplay(gpDispInfo->hDev);
                        return DCE_NORELEASE;
                    }

                } else if (!GreSetDCOwner(pdce->hdc, OBJECT_OWNER_NONE)) {

                    GreUnlockDisplay(gpDispInfo->hDev);
                    return DCE_NORELEASE;
                }

                pdce->ptiOwner  = NULL;
                pdce->DCX_flags    &= ~DCX_INUSE;

#if DBG
                /*
                 * Turn off checked only surface validation for now, since
                 * we may select a different surface (screen) in this DC that
                 * may not correspond to the visrgn currently in the DC. When
                 * the DC is given out again, it will be revalidated.
                 */
                GreValidateVisrgn(pdce->hdc, FALSE);
#endif

                /*
                 * The DC is no longer in use, so unselect the redirection
                 * bitmap from it.
                 */
                if (pdce->DCX_flags & DCX_REDIRECTED) {
                    UserVerify(GreSelectRedirectionBitmap(pdce->hdc, NULL));
                }

                /*
                 * Increment the Free DCE count.  This holds the count
                 * of available DCEs.  Check the threshold, and destroy
                 * the dce if it's above the mark.
                 */
                IncrementFreeDCECount();

                if (gnDCECount > DCE_SIZE_CACHETHRESHOLD) {
                    if (DestroyCacheDC(ppdce, pdce->hdc)) {
                        GreUnlockDisplay(gpDispInfo->hDev);
                        return DCE_FREED;
                    }
                }
            }

            /*
             * If we have an EXCLUDERGN or INTERSECTRGN cache entry,
             * convert it back to a "normal" cache entry by restoring
             * the visrgn and blowing away hrgnClip.
             *
             * Note that for non-DCX_CACHE DCs, we only do this if
             * we're being called from EndPaint().
             */
            if ((pdce->DCX_flags & (DCX_EXCLUDERGN | DCX_INTERSECTRGN)) &&
                    ((pdce->DCX_flags & DCX_CACHE) || fEndPaint)) {
                DeleteHrgnClip(pdce);
            }

            GreUnlockDisplay(gpDispInfo->hDev);
            return DCE_RELEASED;
        }
    }

    /*
     * Yell if DC couldn't be found...
     */
    RIPERR1(ERROR_DC_NOT_FOUND, RIP_WARNING,
            "Invalid device context (DC) handle passed to ReleaseCacheDC (0x%08lx)", hdc);

    return DCE_NORELEASE;
}

/***************************************************************************\
* CreateCacheDC
*
* Creates a DCE and adds it to the cache.
*
* History:
* 17-Jul-1991 DarrinM   Ported from Win 3.1 sources.
* 20-Dec-1995 ChrisWil  Added (hrgnClipPublic) entry.
\***************************************************************************/

HDC CreateCacheDC(
        PWND  pwndOrg,
        DWORD DCX_flags,
        PMONITOR pMonitor
        )
{
    PDCE pdce;
    HDC  hdc;
    HANDLE hDev;

    if ((pdce = (PDCE)UserAllocPool(sizeof(DCE), TAG_DCE)) == NULL)
        return NULL;

    if (pMonitor == NULL) {
        hDev = gpDispInfo->hDev;
    } else {
        hDev = pMonitor->hDev;
    }

    if ((hdc = GreCreateDisplayDC(hDev, DCTYPE_DIRECT, FALSE)) == NULL) {
        UserFreePool(pdce);
        return NULL;
    }

    /*
     * Link this entry into the cache entry list.
     */
    pdce->pdceNext      = gpDispInfo->pdceFirst;
    gpDispInfo->pdceFirst = pdce;

    pdce->hdc            = hdc;
    pdce->DCX_flags      = DCX_flags;
    pdce->pwndOrg        = pwndOrg;
    pdce->pwndClip       = pwndOrg;
    pdce->hrgnClip       = NULL;
    pdce->hrgnClipPublic = NULL;
    pdce->hrgnSavedVis   = NULL;
    pdce->pMonitor       = pMonitor;

    /*
     * Mark it as undeleteable so no application can delete it out of our
     * cache!
     */
    GreMarkUndeletableDC(hdc);

    if (DCX_flags & DCX_OWNDC) {

        /*
         * Set the ownership of owndcs immediately: that way console can set
         * the owernship to PUBLIC when it calls GetDC so that both the input
         * thread and the service threads can use the same owndc.
         */
        GreSetDCOwner(hdc, OBJECT_OWNER_CURRENT);
        pdce->ptiOwner = PtiCurrent();

    } else {

        /*
         * Otherwise it is a cache dc...  set its owner to none - nothing
         * is using it - equivalent of "being in the cache" but unaccessible
         * to other processes.
         */
        GreSetDCOwner(hdc, OBJECT_OWNER_NONE);
        pdce->ptiOwner = NULL;

        /*
         * Increment the available-cacheDC count.  Once this hits our
         * threshold, then we can free-up some of the entries.
         */
        IncrementFreeDCECount();
    }

    /*
     * If we're creating a permanent DC, then compute it now.
     */
    if (!(DCX_flags & DCX_CACHE)) {

        /*
         * Set up the class DC now...
         */
        if (TestCF(pwndOrg, CFCLASSDC))
            pwndOrg->pcls->pdce = pdce;

        /*
         * Finish setting up DCE and force eventual visrgn calculation.
         */
        UserAssert(!(DCX_flags & DCX_WINDOW));

        pdce->DCX_flags |= DCX_INUSE;

        InvalidateDce(pdce);
    }

    /*
     * If there are any spb's around then enable bounds accumulation.
     */
    if (AnySpbs())
        GreGetBounds(pdce->hdc, NULL, DCB_ENABLE | DCB_SET | DCB_WINDOWMGR);

    return pdce->hdc;
}

/***************************************************************************\
* WindowFromCacheDC
*
* Returns the window associated with a DC.
*
* History:
* 17-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

PWND WindowFromCacheDC(
    HDC hdc)
{
    PDCE pdce;
    for (pdce = gpDispInfo->pdceFirst; pdce; pdce = pdce->pdceNext) {

        if (pdce->hdc == hdc)
            return (pdce->DCX_flags & DCX_DESTROYTHIS) ? NULL : pdce->pwndOrg;
    }

    return NULL;
}

/***************************************************************************\
* DelayedDestroyCacheDC
*
* Destroys DCE's which have been partially destroyed.
*
* History:
* 16-Jun-1992 DavidPe   Created.
\***************************************************************************/

VOID DelayedDestroyCacheDC(VOID)
{
    PDCE *ppdce;
    PDCE pdce;


    /*
     * Zip through the cache looking for a DCX_DESTROYTHIS hdc.
     */
    for (ppdce = &gpDispInfo->pdceFirst; *ppdce != NULL; ) {

        /*
         * If we found a DCE on this thread that we tried to destroy
         * earlier, try and destroy it again.
         */
        pdce = *ppdce;

        if (pdce->DCX_flags & DCX_DESTROYTHIS)
            DestroyCacheDC(ppdce, pdce->hdc);

        /*
         * Step to the next DC.  If the DC was deleted, there
         * is no need to calculate address of the next entry.
         */
        if (pdce == *ppdce)
            ppdce = &pdce->pdceNext;
    }

    PpiCurrent()->W32PF_Flags &= ~W32PF_OWNDCCLEANUP;
}

/***************************************************************************\
* DestroyCacheDC
*
* Removes a DC from the cache, freeing all resources associated
* with it.
*
* History:
* 17-Jul-1991 DarrinM   Ported from Win 3.1 sources.
* 20-Dec-1995 ChrisWil  Added (hrgnClipPublic) entry.
\***************************************************************************/

BOOL DestroyCacheDC(
    PDCE *ppdce,
    HDC  hdc)
{
    PDCE pdce;

    /*
     * Zip through the cache looking for hdc.
     */
    if (ppdce == NULL) {
        for (ppdce = &gpDispInfo->pdceFirst; (pdce = *ppdce); ppdce = &pdce->pdceNext) {
            if (pdce->hdc == hdc)
                break;
        }
    }

    if (ppdce == NULL)
        return FALSE;

    /*
     * Set this here so we know this DCE is supposed to be deleted.
     */
    pdce = *ppdce;
    pdce->DCX_flags |= DCX_DESTROYTHIS;

    /*
     * Free up the dce object and contents.
     */

    if (!(pdce->DCX_flags & DCX_NODELETERGN)) {
        DeleteMaybeSpecialRgn(pdce->hrgnClip);
        pdce->hrgnClip = NULL;
    }

    if (pdce->hrgnClipPublic != NULL) {
        GreDeleteObject(pdce->hrgnClipPublic);
        pdce->hrgnClipPublic = NULL;
    }

    if (pdce->hrgnSavedVis != NULL) {
        GreDeleteObject(pdce->hrgnSavedVis);
        pdce->hrgnSavedVis = NULL;
    }

    /*
     * If GreSetDCOwner() or GreDeleteDC() fail, the
     * DC is in-use by another thread.  Set
     * W32PF_OWNDCCLEANUP so we know to scan for and
     * delete this DCE later.
     */
    if (!GreSetDCOwner(hdc, OBJECT_OWNER_PUBLIC)) {
        PpiCurrent()->W32PF_Flags |= W32PF_OWNDCCLEANUP;
        return FALSE;
    }

    /*
     * Set the don't rip flag so our routine RipIfCacheDC() doesn't
     * rip (called back from gdi).
     */
#if DBG
    pdce->DCX_flags |= DCX_DONTRIPONDESTROY;
    GreMarkDeletableDC(hdc);    // So GRE doesn't RIP.
#endif

    if (!GreDeleteDC(hdc)) {

#if DBG
        GreMarkUndeletableDC(hdc);
        pdce->DCX_flags &= ~DCX_DONTRIPONDESTROY;
#endif
        PpiCurrent()->W32PF_Flags |= W32PF_OWNDCCLEANUP;
        return FALSE;
    }

    /*
     * Decrement this dc-entry from the free-list count.
     */
    if (pdce->DCX_flags & DCX_CACHE) {

        if (!(pdce->DCX_flags & DCX_INUSE)) {
            DecrementFreeDCECount();
        }
    }

#if DBG
    pdce->pwndOrg  = NULL;
    pdce->pwndClip = NULL;
#endif

    /*
     * Unlink the DCE from the list.
     */
    *ppdce = pdce->pdceNext;

    UserFreePool(pdce);

    return TRUE;
}


/***************************************************************************\
* InvalidateGDIWindows
*
* Recalculates the visrgn of all descendents of pwnd on behalf of GRE.
*
* History:
\***************************************************************************/

VOID InvalidateGDIWindows(
    PWND pwnd)
{
    PVOID pwo;

    if (pwnd != NULL) {

        if ((pwo = _GetProp(pwnd, PROP_WNDOBJ, TRUE)) != NULL) {

            HRGN hrgnClient = NULL;

            if (GreWindowInsteadOfClient(pwo)) {

                /*
                 * Never clip children for WO_RGN_WINDOW so that NetMeeting
                 * gets the unioned window area:
                 */

                CalcVisRgn(&hrgnClient,
                           pwnd,
                           pwnd,
                           DCX_WINDOW |
                           (TestWF(pwnd, WFCLIPSIBLINGS) ? DCX_CLIPSIBLINGS : 0));
            } else {
                CalcVisRgn(&hrgnClient,
                           pwnd,
                           pwnd,
                           DCX_CLIPCHILDREN | DCX_CLIPSIBLINGS);
            }

            GreSetClientRgn(pwo, hrgnClient, &(pwnd->rcClient));
        }

        pwnd = pwnd->spwndChild;
        while (pwnd != NULL) {
            InvalidateGDIWindows(pwnd);
            pwnd = pwnd->spwndNext;
        }
    }
}

/***************************************************************************\
* zzzInvalidateDCCache
*
* This function is called when the visrgn of a window is changing for
* some reason.  It is responsible for ensuring that all of the cached
* visrgns in the DC cache that are affected by the visrgn change are
* invalidated.
*
* Operations that affect the visrgn of a window (i.e., things that better
* call this routine one way or another:)
*
*   Hiding or showing self or parent
*   Moving, sizing, or Z-order change of self or parent
*   Minimizing or unminimizing self or parent
*   Screen or paint locking of self or parent
*   LockWindowUpdate of self or parent
*
* Invalidates any cache entries associated with pwnd and/or any children of
* pwnd by either recalcing them on the fly if they're in use, or causing
* them to be recalced later.
*
* History:
* 17-Jul-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

BOOL zzzInvalidateDCCache(
    PWND  pwndInvalid,
    DWORD flags)
{
    PWND        pwnd;
    PDCE        pdce;
    PTHREADINFO ptiCurrent = PtiCurrent();
    TL          tlpwndInvalid;
    FLONG       fl;

    /*
     * Invalidation implies screen real estate is changing so we must
     * jiggle the mouse, because a different window may be underneath
     * the mouse, which needs to get a mouse move in order to change the
     * mouse pointer.
     *
     * The check for the tracking is added for full-drag-windows.  In doing
     * full-drag, zzzBltValidBits() is called from setting the window-pos.
     * This resulted in an extra-mousemove being queued from this routine.
     * So, when we're tracking, don't queue a mousemove.  This pointer is
     * null when tracking is off, so it won't effect the normal case.
     */
    ThreadLockAlwaysWithPti(ptiCurrent, pwndInvalid, &tlpwndInvalid);

    if (!(ptiCurrent->TIF_flags & TIF_MOVESIZETRACKING) &&
            !(flags & IDC_NOMOUSE)) {

#ifdef REDIRECTION
        if (!IsGlobalHooked(ptiCurrent, WHF_FROM_WH(WH_HITTEST)))
#endif // REDIRECTION

            zzzSetFMouseMoved();
    }

    /*
     * The visrgn of pwnd is changing.  First see if a change to this
     * visrgn will also affect other window's visrgns:
     *
     * 1) if parent is clipchildren, we need to invalidate parent
     * 2) if clipsiblings, we need to invalidate our sibling's visrgns.
     *
     * We don't optimize the case where we're NOT clipsiblings, and our
     * parent is clipchildren: very rare case.
     * We also don't optimize the fact that a clipsiblings window visrgn
     * change only affects the visrgns of windows BELOW it.
     */
    if (flags & IDC_DEFAULT) {

        flags = 0;

        if ((pwndInvalid->spwndParent != NULL) &&
            (pwndInvalid != PWNDDESKTOP(pwndInvalid))) {

            /*
             * If the parent is a clip-children window, then
             * a change to our visrgn will affect his visrgn, and
             * possibly those of our siblings.  So, invalidate starting
             * from our parent.  Note that we don't need to invalidate
             * any window DCs associated with our parent.
             */
            if (TestWF(pwndInvalid->spwndParent, WFCLIPCHILDREN)) {

                flags = IDC_CLIENTONLY;
                pwndInvalid = pwndInvalid->spwndParent;

            } else if (TestWF(pwndInvalid, WFCLIPSIBLINGS)) {

                /*
                 * If we are clip-siblings, chances are that our siblings are
                 * too.  A change to our visrgn might affect our siblings,
                 * so invalidate all of our siblings.
                 *
                 * NOTE! This code assumes that if pwndInvalid is NOT
                 * CLIPSIBLINGs, that either it does not overlap other
                 * CLIPSIBLINGs windows, or that none of the siblings are
                 * CLIPSIBLINGs.  This is a reasonable assumption, because
                 * mixing CLIPSIBLINGs and non CLIPSIBLINGs windows that
                 * overlap is generally unpredictable anyhow.
                 */
                flags = IDC_CHILDRENONLY;
                pwndInvalid = pwndInvalid->spwndParent;
            }
        }
    }

    /*
     * Go through the list of DCE's, looking for any that need to be
     * invalidated or recalculated.  Basically, any DCE that contains
     * a window handle that is equal to pwndInvalid or a child of pwndInvalid
     * needs to be invalidated.
     */
    for (pdce = gpDispInfo->pdceFirst; pdce; pdce = pdce->pdceNext) {

        if (pdce->DCX_flags & (DCX_INVALID | DCX_DESTROYTHIS))
            continue;

        /*
         * HACK ALERT
         *
         * A minimized client DC must never exclude its children, even if
         * its WS_CLIPCHILDREN bit is set.  For CS_OWNDC windows we must
         * update the flags of the DCE to reflect the change in window state
         * when the visrgn is eventually recomputed.
         */
        if (!(pdce->DCX_flags & (DCX_CACHE | DCX_WINDOW))) {

            if (TestWF(pdce->pwndOrg, WFCLIPCHILDREN))
                pdce->DCX_flags |= DCX_CLIPCHILDREN;

            if (TestWF(pdce->pwndOrg, WFMINIMIZED))
                pdce->DCX_flags &= ~DCX_CLIPCHILDREN;
        }

        /*
         * This code assumes that if pdce->pwndClip != pdce->pwndOrg,
         * that pdce->pwndClip == pdce->pwndOrg->spwndParent.  To ensure
         * that both windows are visited, we start the walk upwards from
         * the lower of the two, or pwndOrg.
         *
         * This can happen if someone gets a DCX_PARENTCLIP dc and then
         * changes the parent.
         */
#if DBG
        if ((pdce->pwndClip != pdce->pwndOrg) &&
                (pdce->pwndClip != pdce->pwndOrg->spwndParent)) {
            RIPMSG1(RIP_WARNING, "HDC %lX clipped to wrong parent", pdce->hdc);
        }
#endif
        /*
         * Walk upwards from pdce->pwndOrg, to see if we encounter
         * pwndInvalid.
         */
        for (pwnd = pdce->pwndOrg; pwnd; pwnd = pwnd->spwndParent) {

            if (pwnd == pwndInvalid) {

                if (pwndInvalid == pdce->pwndOrg) {

                    /*
                     * Ignore DCEs for pwndInvalid if IDC_CHILDRENONLY.
                     */
                    if (flags & IDC_CHILDRENONLY)
                        break;

                    /*
                     * Ignore window DCEs for pwndInvalid if IDC_CLIENTONLY
                     */
                    if ((flags & IDC_CLIENTONLY) && (pdce->DCX_flags & DCX_WINDOW))
                        break;
                }

                InvalidateDce(pdce);
                break;
            }
        }
    }

    /*
     * Update WNDOBJs in gdi if they exist.
     */
    GreLockDisplay(gpDispInfo->hDev);

    fl = (flags & IDC_MOVEBLT) ? GCR_DELAYFINALUPDATE : 0;

    if (gcountPWO != 0) {
        InvalidateGDIWindows(pwndInvalid);
        fl |= GCR_WNDOBJEXISTS;
    }

    GreClientRgnUpdated(fl);

    GreUpdateSpriteVisRgn(gpDispInfo->hDev);

    GreUnlockDisplay(gpDispInfo->hDev);

    ThreadUnlock(&tlpwndInvalid);

    return TRUE;
}

/***************************************************************************\
* _WindowFromDC (API)
*
* Takes a dc, returns the window associated with it.
*
* History:
* 23-Jun-1991 ScottLu   Created.
\***************************************************************************/

PWND _WindowFromDC(
    HDC hdc)
{
    PDCE pdce;

    for (pdce = gpDispInfo->pdceFirst; pdce; pdce = pdce->pdceNext) {

        if (!(pdce->DCX_flags & DCX_INUSE) || (pdce->DCX_flags & DCX_CREATEDC))
            continue;

        if (pdce->hdc == hdc)
            return pdce->pwndOrg;
    }

    return NULL;
}

/***************************************************************************\
* FastWindowFromDC
*
* Returns the window associated with a DC, and puts it at the
* front of the list.
*
* History:
* 23-Jun-1991 ScottLu   Created.
\***************************************************************************/

PWND FastWindowFromDC(
    HDC hdc)
{
    PDCE *ppdce;
    PDCE pdceT;

    if ((gpDispInfo->pdceFirst->hdc == hdc) &&
        (gpDispInfo->pdceFirst->DCX_flags & DCX_INUSE)) {

        return gpDispInfo->pdceFirst->pwndOrg;
    }

    for (ppdce = &gpDispInfo->pdceFirst; *ppdce; ppdce = &(*ppdce)->pdceNext) {

        if (((*ppdce)->hdc == hdc) && ((*ppdce)->DCX_flags & DCX_INUSE)) {

            /*
             * Unlink/link to make it first.
             */
            pdceT                 = *ppdce;
            *ppdce                = pdceT->pdceNext;
            pdceT->pdceNext       = gpDispInfo->pdceFirst;
            gpDispInfo->pdceFirst = pdceT;

            return pdceT->pwndOrg;
        }
    }

    return NULL;
}

/***************************************************************************\
* GetDCOrgOnScreen
*
* This function gets the DC origin of a window in screen coordinates. The
* DC origin is always in the surface coordinates. For screen DCs the
* surface is the screen, so their origin is already in the screen
* coordinates. For redirected DCs, GreGetDCOrg will return the origin
* of the DC in the redirected surface coordinates to which we will add
* the origin of the redirected window that the surface is backing.
*
* 11/25/1998        vadimg      created
\***************************************************************************/

BOOL GetDCOrgOnScreen(HDC hdc, LPPOINT ppt)
{
    if (GreGetDCOrg(hdc, ppt)) {
        POINT ptScreen;

        /*
         * Get the origin of the redirected window in screen coordinates.
         */
        if (UserGetRedirectedWindowOrigin(hdc, &ptScreen)) {
            ppt->x += ptScreen.x;
            ppt->y += ptScreen.y;
            return TRUE;
        }
    }
    return FALSE;
}

/***************************************************************************\
* UserGetRedirectedWindowOrigin
*
* The DC origin is in the surface coordinates. For screen DCs, the surface
* is the screen and so their origin is in the screen coordinates. But for
* redirected DCs, the backing surface origin is the same as the window
* being redirected. This function retrieves the screen origin of a redirected
* window corresponding to a redirection DC. It returns FALSE if this isn't
* a valid DC or it's not a redirected DC.
*
* 11/18/1998        vadimg      created
\***************************************************************************/

BOOL UserGetRedirectedWindowOrigin(HDC hdc, LPPOINT ppt)
{
    PWND pwnd;
    PDCE pdce;

    if ((pdce = LookupDC(hdc)) == NULL)
        return FALSE;

    if (!(pdce->DCX_flags & DCX_REDIRECTED))
        return FALSE;

    pwnd = GetStyleWindow(pdce->pwndOrg, WEFPREDIRECTED);

    ppt->x = pwnd->rcWindow.left;
    ppt->y = pwnd->rcWindow.top;

    return TRUE;
}

/***************************************************************************\
* LookupDC
*
* Validate a DC by returning a correspnding pdce.
*
* 11/12/1997   vadimg          created
\***************************************************************************/

PDCE LookupDC(HDC hdc)
{
    PDCE pdce;

    for (pdce = gpDispInfo->pdceFirst; pdce != NULL; pdce = pdce->pdceNext) {

        if (pdce->DCX_flags & (DCX_INVALID | DCX_DESTROYTHIS))
            continue;

        if (pdce->hdc == hdc && pdce->pMonitor == NULL &&
                (pdce->DCX_flags & DCX_INUSE)) {
            return pdce;
        }
    }
    return NULL;
}

/***************************************************************************\
* GetMonitorDC
*
* 11/06/97      vadimg      ported from Memphis
\***************************************************************************/

#define DCX_LEAVEBITS (DCX_WINDOW | DCX_CLIPCHILDREN | DCX_CLIPSIBLINGS | \
        DCX_PARENTCLIP | DCX_LOCKWINDOWUPDATE | DCX_NOCLIPCHILDREN | \
        DCX_USESTYLE | DCX_EXCLUDEUPDATE | DCX_INTERSECTUPDATE | \
        DCX_EXCLUDERGN | DCX_INTERSECTRGN)

HDC GetMonitorDC(PDCE pdceOrig, PMONITOR pMonitor)
{
    PDCE pdce;
    POINT pt;
    RECT rc;

TryAgain:
    for (pdce = gpDispInfo->pdceFirst; pdce != NULL; pdce = pdce->pdceNext) {
        /*
         * Find an available DC for this monitor.
         */
        if (pdce->DCX_flags & (DCX_INUSE | DCX_DESTROYTHIS))
            continue;

        if (pdce->pMonitor != pMonitor)
            continue;

        if (!(pdce->DCX_flags & DCX_INVALID))
            SpbCheckDce(pdce);

        /*
         * Copy DC properties and style bits.
         */
        GreSetDCOwner(pdce->hdc, OBJECT_OWNER_CURRENT);
        pdce->pwndOrg = pdceOrig->pwndOrg;
        pdce->pwndClip = pdceOrig->pwndClip;
        pdce->ptiOwner = pdceOrig->ptiOwner;
        pdce->DCX_flags = (DCX_INUSE | DCX_CACHE) |
                (pdceOrig->DCX_flags & DCX_LEAVEBITS);

        if (pdceOrig->hrgnClip > HRGN_FULL) {
            UserAssert(pdce->hrgnClip == NULL);
            UserAssert(pdceOrig->DCX_flags & (DCX_INTERSECTRGN | DCX_EXCLUDERGN));

            pdce->hrgnClip = CreateEmptyRgn();
            SetMonitorRegion(pMonitor, pdce->hrgnClip, pdceOrig->hrgnClip);
        } else {
            pdce->hrgnClip = pdceOrig->hrgnClip;
        }

        /*
         * Setup the visrgn clipped to this monitor.
         */
        GreCopyVisRgn(pdceOrig->hdc, ghrgnGDC);
        SetMonitorRegion(pMonitor, ghrgnGDC, ghrgnGDC);
        GreSelectVisRgn(pdce->hdc, ghrgnGDC, SVR_COPYNEW);

        GreGetDCOrgEx(pdceOrig->hdc, &pt, &rc);
        OffsetRect(&rc, -pMonitor->rcMonitor.left, -pMonitor->rcMonitor.top);
        GreSetDCOrg(pdce->hdc, rc.left, rc.top, (PRECTL)&rc);

        /*
         * Decrement the Free DCE Count.  This should always be >= 0,
         * since we'll create a new dce if the cache is all in use.
         */
        DecrementFreeDCECount();

        return pdce->hdc;
    }

    /*
     * If this call succeeds a new DC will be available in the cache,
     * so the loop will find it and properly set it up.
     */
    if (CreateCacheDC(NULL, DCX_INVALID | DCX_CACHE, pMonitor) == NULL)
        return NULL;

    goto TryAgain;
}

/***************************************************************************\
* RipIfCacheDC
*
* This is called on debug systems by gdi when it is destroying a dc
* to make sure it isn't in the cache.
*
* History:
\***************************************************************************/

#if DBG
VOID RipIfCacheDC(
    HDC hdc)
{
    PDCE pdce;

    /*
     * This is called on debug systems by gdi when it is destroying a dc
     * to make sure it isn't in the cache.
     */
    EnterCrit();

    for (pdce = gpDispInfo->pdceFirst; pdce; pdce = pdce->pdceNext) {

        if (pdce->hdc == hdc && !(pdce->DCX_flags & DCX_DONTRIPONDESTROY)) {

            RIPMSG1(RIP_ERROR,
                  "Deleting DC in DC cache - contact JohnC. hdc == %08lx\n",
                  pdce->hdc);
        }
    }

    LeaveCrit();
}
#endif

/***************************************************************************\
* OrderRects
*
* Order the rectangles, so that they flow from left to right. This is needed
* when combining a mirrored region (see MirrorRegion)
*
*
* History:
\***************************************************************************/
void OrderRects(LPRECT lpR, int nRects)
{
    RECT R;
    int i,j;

    //
    // Sort Left to right
    //
    for (i=0; i<nRects; i++){
        for (j=i+1; (j<nRects) && ((lpR+j)->top == (lpR+i)->top); j++){
            if (((lpR+j)->left < (lpR+i)->left)) {
                R = *(lpR+i);
                *(lpR+i) = *(lpR+j);
                *(lpR+j) = R;
            }
        }
    }

}

/***************************************************************************\
* MirrorRegion
*
* Mirror a region in a window. This is done by mirroring the rects
* that constitute the region. 'bUseClient' param controls whether
* the region is a client one or not.
*
* History:
\***************************************************************************/
BOOL MirrorRegion(PWND pwnd, HRGN hrgn, BOOL bUseClient)
{
    int        nRects, i, nDataSize, Saveleft, cx;
    HRGN       hrgn2 = NULL;
    RECT       *lpR;
    RGNDATA    *lpRgnData;
    BOOL       bRet = FALSE;

    if (TestWF(pwnd, WEFLAYOUTRTL) && hrgn > HRGN_SPECIAL_LAST) {
        nDataSize = GreGetRegionData(hrgn, 0, NULL);
        if (nDataSize && (lpRgnData = (RGNDATA *)UserAllocPool(nDataSize, TAG_MIRROR))) {
            if (GreGetRegionData(hrgn, nDataSize, lpRgnData)) {
                nRects       = lpRgnData->rdh.nCount;
                lpR          = (RECT *)lpRgnData->Buffer;

                if (bUseClient) {
                    cx = pwnd->rcClient.right - pwnd->rcClient.left;
                } else {
                    cx = pwnd->rcWindow.right - pwnd->rcWindow.left;
                }

                Saveleft                     = lpRgnData->rdh.rcBound.left;
                lpRgnData->rdh.rcBound.left  = cx - lpRgnData->rdh.rcBound.right;
                lpRgnData->rdh.rcBound.right = cx - Saveleft;


                for (i=0; i<nRects; i++){
                    Saveleft   = lpR->left;
                    lpR->left  = cx - lpR->right;
                    lpR->right = cx - Saveleft;

                    lpR++;
                }

                OrderRects((RECT *)lpRgnData->Buffer, nRects);
                hrgn2 = GreExtCreateRegion(NULL, nDataSize, lpRgnData);
                if (hrgn2) {
                    GreCombineRgn(hrgn, hrgn2, NULL, RGN_COPY);
                    GreDeleteObject((HGDIOBJ)hrgn2);
                    bRet = TRUE;
                }
            }

            //Free mem.
            UserFreePool(lpRgnData);
        }
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\ddetrack.c ===
/****************************** Module Header *******************************
* Module Name: ddetrack.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module handles tracking of DDE conversations for use in emulating
* DDE shared memory.
*
* History:
* 9-3-91      sanfords  Created
* 21-Jan-1992 IanJa     ANSI/Unicode netralized (null op)
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

PPUBOBJ gpPublicObjectList;

#define TRACE_DDE(str)          TAGMSG0(DBGTAG_DDE, str)
#define TRACE_DDE1(s, a)        TAGMSG1(DBGTAG_DDE, (s), (a))
#define TRACE_DDE2(s, a, b)     TAGMSG2(DBGTAG_DDE, (s), (a), (b))
#define TRACE_DDE3(s, a, b, c)  TAGMSG3(DBGTAG_DDE, (s), (a), (b), (c))

BOOL NewConversation(PDDECONV *ppdcNewClient, PDDECONV *ppdcNewServer,
        PWND pwndClient, PWND pwndServer);
PDDECONV FindDdeConv(PWND pwndProp, PWND pwndPartner);
BOOL AddConvProp(PWND pwndUs, PWND pwndThem, DWORD flags, PDDECONV pdcNew,
        PDDECONV pdcPartner);
FNDDERESPONSE xxxUnexpectedServerPost;
FNDDERESPONSE xxxUnexpectedClientPost;
FNDDERESPONSE xxxAdvise;
FNDDERESPONSE xxxAdviseAck;
FNDDERESPONSE xxxAdviseData;
FNDDERESPONSE xxxAdviseDataAck;
DWORD Unadvise(PDDECONV pDdeConv);
FNDDERESPONSE xxxUnadviseAck;
DWORD Request(PDDECONV pDdeConv);
FNDDERESPONSE xxxRequestAck;
FNDDERESPONSE xxxPoke;
FNDDERESPONSE xxxPokeAck;
FNDDERESPONSE xxxExecute;
FNDDERESPONSE xxxExecuteAck;
DWORD SpontaneousTerminate(PDWORD pmessage, PDDECONV pDdeConv);
FNDDERESPONSE DupConvTerminate;

HANDLE AnticipatePost(PDDECONV pDdeConv, FNDDERESPONSE fnResponse,
        HANDLE hClient, HANDLE hServer, PINTDDEINFO pIntDdeInfo, DWORD flags);
PXSTATE Createpxs(FNDDERESPONSE fnResponse, HANDLE hClient, HANDLE hServer,
        PINTDDEINFO pIntDdeInfo, DWORD flags);
DWORD AbnormalDDEPost(PDDECONV pDdeConv, DWORD message);
DWORD xxxCopyDdeIn(HANDLE hSrc, PDWORD pflags, PHANDLE phDirect, PINTDDEINFO *ppi);
DWORD xxxCopyAckIn(PDWORD pmessage, LPARAM *plParam, PDDECONV pDdeConv, PINTDDEINFO *ppIntDdeInfo);
HANDLE xxxCopyDDEOut(PINTDDEINFO pIntDdeInfo, PHANDLE phDirect);
BOOL FreeListAdd(PDDECONV pDdeConv, HANDLE hClient, DWORD flags);
VOID xxxFreeListFree(PFREELIST pfl);
VOID PopState(PDDECONV pDdeConv);
PDDECONV UnlinkConv(PDDECONV pDdeConv);

VOID FreeDDEHandle(PDDECONV pDdeConv, HANDLE hClient, DWORD flags);
DWORD ClientFreeDDEHandle(HANDLE hClient, DWORD flags);
DWORD ClientGetDDEFlags(HANDLE hClient, DWORD flags);
DWORD xxxClientCopyDDEIn1(HANDLE hClient, DWORD flags, PINTDDEINFO *ppi);
HANDLE xxxClientCopyDDEOut1(PINTDDEINFO pIntDdeInfo);
DWORD xxxClientCopyDDEOut2(PINTDDEINFO pIntDdeInfo);

PPUBOBJ IsObjectPublic(HANDLE hObj);
BOOL AddPublicObject(UINT format, HANDLE hObj, W32PID pid);
BOOL RemovePublicObject(UINT format, HANDLE hObj);
BOOL GiveObject(UINT format, HANDLE hObj, W32PID pid);

/*
 *  The Big Picture:
 *
 *  When a WM_DDE_ACK message is SENT, it implies the begining of a DDE
 *    Conversation.  The tracking layer creates DDECONV structure for each
 *    window in volved in the conversation and cross links the structures.
 *    Thus a unique window pair identifies a conversation.  Each window has
 *    its DDECONV structure attached to it via a private property.
 *
 *  As DDE messages are posted, the tracking layer copies data into the
 *    CSR server side of USER into a INTDDEINFO structure.  This structure
 *    contains flags which direct how the data is to be freed when the
 *    time comes.  This info is placed within an XSTATE structure along
 *    with context infomation.  A pointer to the XSTATE structure is
 *    placed in the lParam of the message and the MSB of message is set
 *    for special processing when the message is recieved on the other side.
 *
 *  If the message posted requires a responding message to follow the DDE
 *    protocol, a XSTATE structure is created and attached to DDECONV
 *    structure associated with the window that is expected to post the message.
 *    The XSTATE structure directs the tracking layer so that it knows the
 *    context of the message when it is posted and also includes any
 *    information needed for proper freeing of extra DDE data.
 *
 *  When the message is extracted from the queue either by a hook, peek,
 *    or by GetMessage, the id is checked to see if it lies in the special
 *    range.  If so, the XSTATE structure pointed to by the lParam is
 *    operated on.  This causes the data to be copied from the CSR server
 *    side of USER to the target process context.  Once this is done, the
 *    XSTATE structure may or may not be freed depending on flags and
 *    the message is restored to a proper DDE message form ready to be
 *    used by the target process.  Since the message id is changed back,
 *    subsequent peeks or hooks to the message will not result in duplicated
 *    processing of the message.
 *
 *  During the course of come transactions it becomes evident that an object
 *    on the opposite side process needs to be freed.  This is done
 *    asynchronously by inserting the object that needs freeing along with
 *    associated flags into a freeing list which is tied to the DDECONV
 *    structure associated with the window on the opposite side.  Whenever
 *    a DDE messages is posted, this freeing list is checked and processed.
 *
 *  When a WM_DDE_TERMINATE message is finally recieved, flags are set
 *    in the DDECONV structure indicating that the conversation is terminating.
 *    This alters the way the mapping layer handles DDE messages posted.
 *    When the responding side posts a WM_DDE_TERMINATE, the DDECONV structures
 *    and all associated information is freed and unlinked from the windows
 *    concerned.
 *
 *  Should a DDE window get destroyed before proper termination, the
 *    xxxDDETrackWindowDying function is called to make sure proper termination
 *    is done prior to the window being destroyed.
 */


/************************************************************************
* xxxDDETrackSendHook
*
* Called when a DDE message is passed to SendMessage().
*
* Returns fSendOk.
*
* History:
* 9-3-91    sanfords    Created
\***********************************************************************/
BOOL xxxDDETrackSendHook(
PWND pwndTo,
DWORD message,
WPARAM wParam,
LPARAM lParam)
{
    PWND pwndServer;
    PDDECONV pdcNewClient, pdcNewServer;

    if (MonitorFlags & MF_SENDMSGS) {
        DDEML_MSG_HOOK_DATA dmhd;

        dmhd.cbData = 0;    // Initiate and Ack sent messages have no data.
        dmhd.uiLo = LOWORD(lParam);     // they arn't packed either.
        dmhd.uiHi = HIWORD(lParam);
        xxxMessageEvent(pwndTo, message, wParam, lParam, MF_SENDMSGS, &dmhd);
    }

    if (PtiCurrent()->ppi == GETPWNDPPI(pwndTo)) {
        /*
         * Skip monitoring of all intra-process conversations.
         */
        return TRUE;
    }

    if (message != WM_DDE_ACK) {
        if (message == WM_DDE_INITIATE) {
            return TRUE;     // this is cool
        }
        return FALSE;
    }

    pwndServer = ValidateHwnd((HWND)wParam);
    if (pwndServer == NULL) {
        return FALSE;
    }

    pdcNewServer = FindDdeConv(pwndServer, pwndTo);
    if (pdcNewServer != NULL) {
        RIPMSG2(RIP_WARNING,
                "DDE protocol violation - non-unique window pair (%#p:%#p)",
                PtoH(pwndTo), PtoH(pwndServer));
        /*
         * Duplicate Conversation case:
         *  Don't allow the ACK to pass, post a terminate to the server
         *  to shut down the duplicate on his end.
         */
        AnticipatePost(pdcNewServer, DupConvTerminate, NULL, NULL, NULL, 0);
        _PostMessage(pwndServer, WM_DDE_TERMINATE, (WPARAM)PtoH(pwndTo), 0);
        return FALSE;
    }

    if (!NewConversation(&pdcNewClient, &pdcNewServer, pwndTo, pwndServer)) {
        return FALSE;
    }

    TRACE_DDE2("%#p->%#p DDE Conversation started", PtoH(pwndTo), wParam);
    return TRUE;
}


/************************************************************************
* AddConvProp
*
* Helper for xxxDDETrackSendHook - associates a new DDECONV struct with
* a window and initializes it.
*
* History:
* 9-3-91    sanfords    Created
\***********************************************************************/
BOOL AddConvProp(
PWND pwndUs,
PWND pwndThem,
DWORD flags,
PDDECONV pdcNew,
PDDECONV pdcPartner)
{
    PDDECONV pDdeConv;
    PDDEIMP pddei;

    pDdeConv = (PDDECONV)_GetProp(pwndUs, PROP_DDETRACK, PROPF_INTERNAL);
    Lock(&(pdcNew->snext), pDdeConv);
    Lock(&(pdcNew->spwnd), pwndUs);
    Lock(&(pdcNew->spwndPartner), pwndThem);

    /*
     * Assert to catch stress bug.
     */
    UserAssert(pdcPartner != (PDDECONV)(-1));

    Lock(&(pdcNew->spartnerConv), pdcPartner);
    pdcNew->spxsIn = NULL;
    pdcNew->spxsOut = NULL;
    pdcNew->flags = flags;
    pddei = (PDDEIMP)_GetProp((flags & CXF_IS_SERVER) ?
            pwndThem : pwndUs, PROP_DDEIMP, PROPF_INTERNAL);
    if (pddei != NULL) {    // This can be NULL if a bad WOW app has been
        pddei->cRefConv++;  // allowed through for compatability.
    }
    pdcNew->pddei = pddei;

    HMLockObject(pdcNew);         // lock for property
    InternalSetProp(pwndUs, PROP_DDETRACK, pdcNew, PROPF_INTERNAL);
    return TRUE;
}


/************************************************************************
* UnlinkConv
*
* Unlinks a DDECONV structure from the property list it is associated with.
*
* returns pDdeConv->snext
*
* History:
* 9-3-91    sanfords    Created
\***********************************************************************/
PDDECONV UnlinkConv(
PDDECONV pDdeConv)
{
    PDDECONV pdcPrev, pdcT, pDdeConvNext;

    /*
     * Already unlinked
     */
    if (pDdeConv->spwnd == NULL) {
        return NULL;
    }
    TRACE_DDE1("UnlinkConv(%#p)", pDdeConv);

    pdcT = (PDDECONV)_GetProp(pDdeConv->spwnd,
            PROP_DDETRACK, PROPF_INTERNAL);
    if (pdcT == NULL) {
        return NULL;             // already unlinked
    }

    pdcPrev = NULL;
    while (pdcT != pDdeConv) {
        pdcPrev = pdcT;
        pdcT = pdcT->snext;
        if (pdcT == NULL) {
            return NULL;        // already unlinked
        }
    }

    if (pdcPrev == NULL) {
        if (pDdeConv->snext == NULL) {
            // last one out removes the property
            InternalRemoveProp(pDdeConv->spwnd, PROP_DDETRACK, PROPF_INTERNAL);
        } else {
            // head conv unlinked - update prop
            InternalSetProp(pDdeConv->spwnd, PROP_DDETRACK, pDdeConv->snext,
                    PROPF_INTERNAL);
        }
    } else {
        Lock(&(pdcPrev->snext), pDdeConv->snext);
    }
    pDdeConvNext = Unlock(&(pDdeConv->snext));
    HMUnlockObject(pDdeConv);      // unlock for property detachment
    return pDdeConvNext;
}


/************************************************************************
* xxxDDETrackPostHook
*
* Hook function for handling posted DDE messages.
*
* returns post action code - DO_POST, FAKE_POST, FAIL_POST.
*
* History:
* 9-3-91    sanfords    Created
\***********************************************************************/
DWORD xxxDDETrackPostHook(
PUINT pmessage,
PWND pwndTo,
WPARAM wParam,
LPARAM *plParam,
BOOL fSent)
{
    PWND pwndFrom;
    PDDECONV pDdeConv = NULL;
    DWORD dwRet;
    TL tlpDdeConv;
    PFREELIST pfl, *ppfl;
    DWORD MFlag;

    CheckLock(pwndTo);

    MFlag = fSent ? MF_SENDMSGS : MF_POSTMSGS;
    if (MonitorFlags & MFlag) {
        DDEML_MSG_HOOK_DATA dmhd;

        switch (*pmessage ) {
        case WM_DDE_DATA:
        case WM_DDE_POKE:
        case WM_DDE_ADVISE:
        case WM_DDE_EXECUTE:
        case WM_DDE_ACK:
            ClientGetDDEHookData(*pmessage, *plParam, &dmhd);
            break;

        default:
            // WM_DDE_REQUEST
            // WM_DDE_TERMINATE
            // WM_DDE_UNADVISE
            dmhd.cbData = 0;
            dmhd.uiLo = LOWORD(*plParam);
            dmhd.uiHi = HIWORD(*plParam);
        }
        xxxMessageEvent(pwndTo, *pmessage, wParam, *plParam, MFlag,
                &dmhd);
    }

    if (PtiCurrent()->ppi == GETPWNDPPI(pwndTo)) {
        /*
         * skip all intra-process conversation tracking.
         */
        dwRet = DO_POST;
        goto Exit;
    }

    if (*pmessage == WM_DDE_INITIATE) {
        RIPMSG2(RIP_WARNING,
                "DDE Post failed (%#p:%#p) - WM_DDE_INITIATE posted",
                wParam, PtoH(pwndTo));
        dwRet = FAIL_POST;
        goto Exit;
    }

    pwndFrom = ValidateHwnd((HWND)wParam);
    if (pwndFrom == NULL) {
        /*
         * This is a post AFTER a window has been destroyed.  This is not
         * expected except in the case where xxxDdeTrackWindowDying()
         * is posting a cleanup terminate.
         */
        dwRet = *pmessage == WM_DDE_TERMINATE ? DO_POST : FAKE_POST;
        goto Exit;
    }

    /*
     * locate conversation info.
     */
    pDdeConv = FindDdeConv(pwndFrom, pwndTo);
    if (pDdeConv == NULL) {
        if (*pmessage != WM_DDE_TERMINATE &&
                (GETPTI(pwndFrom)->TIF_flags & TIF_16BIT) &&
                (pwndTo->head.rpdesk == pwndFrom->head.rpdesk)) {
            /*
             * If a WOW app bypasses initiates and posts directly to
             * a window on the same desktop, let it sneak by here.
             *
             * This allows some evil apps such as OpenEngine and CA-Cricket
             * to get away with murder.
             *
             * TERMINATES out of the blue however may be due to an app
             * posting its WM_DDE_TERMINATE after it has destroyed its
             * window.  Since window destruction would have generated the
             * TERMINATE already, don't let it through here.
             */
            NewConversation(&pDdeConv, NULL, pwndFrom, pwndTo);
        }
        if (pDdeConv == NULL) {
            RIPMSG2(RIP_VERBOSE, "Can't find DDE conversation for (%#p:%#p).",
                    wParam, PtoH(pwndTo));
            dwRet = *pmessage == WM_DDE_TERMINATE ? FAKE_POST : FAIL_POST;
            goto Exit;
        }
    }

    if (fSent && pDdeConv->spartnerConv->spxsOut != NULL &&
        !(GETPTI(pwndFrom)->dwCompatFlags2 & GACF2_DDENOSYNC) ) {
        /*
         * Sent DDE messages will not work if any posted DDE messages are
         * in the queue because this will violate the message ordering rule.
         */
        RIPMSG0(RIP_VERBOSE,
                "Sent DDE message failed - queue contains a previous post.");
        dwRet = FAIL_POST;
        goto Exit;
    }

    /*
     * The tracking layer never did allow multiple threads to handle
     * the same DDE conversation but win95 shipped and some apps
     * got out there that did just this.  We will let it slide for
     * 4.0 apps only so that when they rev their app, they will see
     * that they were wrong.
     */
    if (PtiCurrent() != GETPTI(pDdeConv) &&
            LOWORD(PtiCurrent()->dwExpWinVer) != VER40) {
        RIPERR0(ERROR_WINDOW_OF_OTHER_THREAD,
                RIP_ERROR,
                "Posting DDE message from wrong thread!");

        dwRet = FAIL_POST;
        goto Exit;
    }

    ThreadLockAlways(pDdeConv, &tlpDdeConv);

    /*
     * If the handle we're using is in the free list, remove it
     */
    ppfl = &pDdeConv->pfl;
    while (*ppfl != NULL) {
        if ((*ppfl)->h == (HANDLE)*plParam) {
            /* Let's stop to check this out */
            UserAssert((*ppfl)->h == (HANDLE)*plParam);
            *ppfl = (*ppfl)->next;
        } else {
            ppfl = &(*ppfl)->next;
        }
    }
    pfl = pDdeConv->pfl;
    pDdeConv->pfl = NULL;
    xxxFreeListFree(pfl);

    if (*pmessage != WM_DDE_TERMINATE &&
            (pDdeConv->flags & (CXF_TERMINATE_POSTED | CXF_PARTNER_WINDOW_DIED))) {
        dwRet = FAKE_POST;
        goto UnlockExit;
    }

    if (pDdeConv->spxsOut == NULL) {
        if (pDdeConv->flags & CXF_IS_SERVER) {
            dwRet = xxxUnexpectedServerPost((PDWORD)pmessage, plParam, pDdeConv);
        } else {
            dwRet = xxxUnexpectedClientPost((PDWORD)pmessage, plParam, pDdeConv);
        }
    } else {
        dwRet = (pDdeConv->spxsOut->fnResponse)(pmessage, plParam, pDdeConv);
    }

UnlockExit:

    ThreadUnlock(&tlpDdeConv);

Exit:

    if (dwRet == FAKE_POST && !((PtiCurrent())->TIF_flags & TIF_INCLEANUP)) {
        /*
         * We faked the post so do a client side cleanup here so that we
         * don't make it appear there is a leak in the client app.
         */
        DWORD flags = XS_DUMPMSG;
        /*
         * The XS_DUMPMSG tells FreeDDEHandle to also free the atoms
         * associated with the data - since a faked post would make the app
         * think that the receiver was going to cleanup the atoms.
         * It also tells FreeDDEHandle to pay attention to the
         * fRelease bit when freeing the data - this way, loaned data
         * won't be destroyed.
         */

        switch (*pmessage & 0xFFFF) {
        case WM_DDE_UNADVISE:
        case WM_DDE_REQUEST:
            goto DumpMsg;

        case WM_DDE_ACK:
            flags |= XS_PACKED;
            goto DumpMsg;

        case WM_DDE_ADVISE:
            flags |= XS_PACKED | XS_HIHANDLE;
            goto DumpMsg;

        case WM_DDE_DATA:
        case WM_DDE_POKE:
            flags |= XS_DATA | XS_LOHANDLE | XS_PACKED;
            goto DumpMsg;

        case WM_DDE_EXECUTE:
            flags |= XS_EXECUTE;
            // fall through
DumpMsg:
            if (pDdeConv != NULL) {
                TRACE_DDE("xxxDdeTrackPostHook: dumping message...");
                FreeDDEHandle(pDdeConv, (HANDLE)*plParam, flags);
                dwRet = FAILNOFREE_POST;
            }
        }
    }
#if DBG
    if (fSent) {
        TraceDdeMsg(*pmessage, (HWND)wParam, PtoH(pwndTo), MSG_SENT);
    } else {
        TraceDdeMsg(*pmessage, (HWND)wParam, PtoH(pwndTo), MSG_POST);
    }
    if (dwRet == FAKE_POST) {
        TRACE_DDE("...FAKED!");
    } else if (dwRet == FAIL_POST) {
        TRACE_DDE("...FAILED!");
    } else if (dwRet == FAILNOFREE_POST) {
        TRACE_DDE("...FAILED, DATA FREED!");
    }
#endif // DBG
    return dwRet;
}

VOID xxxCleanupDdeConv(
    PWND pwndProp)
{
    PDDECONV pDdeConv;

Restart:

    CheckCritIn();

    pDdeConv = (PDDECONV)_GetProp(pwndProp, PROP_DDETRACK, PROPF_INTERNAL);
    
    while (pDdeConv != NULL) {
        if ((pDdeConv->flags & (CXF_IS_SERVER | CXF_TERMINATE_POSTED | CXF_PARTNER_WINDOW_DIED))
                == (CXF_IS_SERVER | CXF_TERMINATE_POSTED | CXF_PARTNER_WINDOW_DIED) &&
            
            (pDdeConv->spartnerConv->flags & CXF_TERMINATE_POSTED)) {
            
            /*
             * clean up client side objects on this side
             */
            BOOL fUnlockDdeConv;
            TL tlpDdeConv;

            RIPMSG1(RIP_VERBOSE, "xxxCleanupDdeConv %p", pDdeConv);

            fUnlockDdeConv = (pDdeConv->pfl != NULL);
            if (fUnlockDdeConv) {
                PFREELIST pfl;

                ThreadLockAlways(pDdeConv, &tlpDdeConv);

                pfl = pDdeConv->pfl;
                pDdeConv->pfl = NULL;
                xxxFreeListFree(pfl);
            }

            FreeDdeConv(pDdeConv->spartnerConv);
            FreeDdeConv(pDdeConv);

            if (fUnlockDdeConv) {
                ThreadUnlock(&tlpDdeConv);
            }
            
            /*
             * Take it back from the top. The list might have changed
             * if we left the critical section
             */
            goto Restart;
        }
        
        pDdeConv = pDdeConv->snext;
    }
}


/************************************************************************
* xxxDDETrackGetMessageHook
*
* This routine is used to complete an inter-process copy from the
* CSRServer context to the target context.  pmsg->lParam is a
* pxs that is used to obtain the pIntDdeInfo needed to
* complete the copy.  The pxs is either filled with the target side
* direct handle or is freed depending on the message and its context.
*
* The XS_FREEPXS bit of the flags field of the pxs tells this function
* to free the pxs when done.
*
* History:
* 9-3-91    sanfords    Created
\***********************************************************************/
VOID xxxDDETrackGetMessageHook(
    PMSG pmsg)
{
    PXSTATE pxs;
    HANDLE hDirect;
    DWORD flags;
    BOOL fUnlockDdeConv;
    TL tlpDdeConv, tlpxs;

    TraceDdeMsg(pmsg->message, (HWND)pmsg->wParam, pmsg->hwnd, MSG_RECV);

    if (pmsg->message == WM_DDE_TERMINATE) {
        PWND pwndFrom, pwndTo;
        PDDECONV pDdeConv;

        pwndTo = ValidateHwnd(pmsg->hwnd);
        
        /*
         * We should get the pwnd even if the partner is destroyed in order
         * to clean up the DDE objects now.  Exiting now would work, but would
         * leave the conversation objects locked and present until the To window
         * gets destroyed, which seems excessive.
         */
        pwndFrom = RevalidateCatHwnd((HWND)pmsg->wParam);
        
        if (pwndTo == NULL) {
            TRACE_DDE("TERMINATE ignored, invalid window(s).");
            return;
        } else if (pwndFrom == NULL) {
            
CleanupAndExit:            
            /*
             * Do this only for appcompat
             */
            if (GetAppCompatFlags2(VERMAX) & GACF2_DDE) {
                xxxCleanupDdeConv(pwndTo);
            } else {
                TRACE_DDE("TERMINATE ignored, invalid window(s).");
            }
            return;
        }
        
        /*
         * locate conversation info.
         */
        pDdeConv = FindDdeConv(pwndTo, pwndFrom);
        if (pDdeConv == NULL) {
            /*
             * Must be a harmless extra terminate.
             */
            TRACE_DDE("TERMINATE ignored, conversation not found.");
            return;
        }

        if (pDdeConv->flags & CXF_TERMINATE_POSTED &&
                pDdeConv->spartnerConv->flags & CXF_TERMINATE_POSTED) {

            /*
             * clean up client side objects on this side
             */
            fUnlockDdeConv = FALSE;
            if (pDdeConv->pfl != NULL) {
                PFREELIST pfl;

                fUnlockDdeConv = TRUE;
                ThreadLockAlways(pDdeConv, &tlpDdeConv);
                pfl = pDdeConv->pfl;
                pDdeConv->pfl = NULL;
                xxxFreeListFree(pfl);
            }

            TRACE_DDE2("DDE conversation (%#p:%#p) closed",
                    (pDdeConv->flags & CXF_IS_SERVER) ? pmsg->wParam : (ULONG_PTR)pmsg->hwnd,
                    (pDdeConv->flags & CXF_IS_SERVER) ? (ULONG_PTR)pmsg->hwnd : pmsg->wParam);

            FreeDdeConv(pDdeConv->spartnerConv);
            FreeDdeConv(pDdeConv);

            if (fUnlockDdeConv) {
                ThreadUnlock(&tlpDdeConv);
            }
        }

        goto CleanupAndExit;
    }

    pxs = (PXSTATE)HMValidateHandleNoRip((HANDLE)pmsg->lParam, TYPE_DDEXACT);
    if (pxs == NULL) {
        /*
         * The posting window has died and the pxs was freed so this
         * message shouldn't be bothered with...map to WM_NULL.
         */
        pmsg->lParam = 0;
        pmsg->message = WM_NULL;
        return;
    }
    flags = pxs->flags;

    ThreadLockAlways(pxs, &tlpxs);
    pmsg->lParam = (LPARAM)xxxCopyDDEOut(pxs->pIntDdeInfo, &hDirect);
    if (pmsg->lParam == (LPARAM)NULL) {
        /*
         * Turn this message into a terminate - we failed to copy the
         * message data out which implies we are too low on memory
         * to continue the conversation.  Shut it down now before
         * other problems pop up that this failure will cause.
         */
        pmsg->message = WM_DDE_TERMINATE;
        RIPMSG0(RIP_WARNING, "DDETrack: couldn't copy data out, terminate faked.");
    }
    if (ThreadUnlock(&tlpxs) == NULL) {
        return;
    }

    if (flags & XS_FREEPXS) {
        FreeDdeXact(pxs);
        return;
    }

    /*
     * The only reason XS_FREEPXS isn't set is because we don't know which
     * side frees the data till an ACK comes back, thus one of the client
     * handles in pxs is already set via xxxDDETrackPostHook().  The one thats
     * not yet set gets set here.
     */

    if (pxs->hClient == NULL) {
        TRACE_DDE1("Saving %#p into hClient", hDirect);
        pxs->hClient = hDirect;
    } else {
        TRACE_DDE1("Saving %#p into hServer.", hDirect);
        pxs->hServer = hDirect;
    }
}



/************************************************************************
* xxxDDETrackWindowDying
*
* Called when a window with PROP_DDETRACK is destroyed.
*
* This posts a terminate to the partner window and sets up for proper
* terminate post fake from other end.
*
* History:
* 9-3-91    sanfords    Created
\***********************************************************************/
VOID xxxDDETrackWindowDying(
PWND pwnd,
PDDECONV pDdeConv)
{
    TL tlpDdeConv, tlpDdeConvNext;

    UNREFERENCED_PARAMETER(pwnd);

    CheckLock(pwnd);
    CheckLock(pDdeConv);

    TRACE_DDE2("xxxDDETrackWindowDying(%#p, %#p)", PtoH(pwnd), pDdeConv);

    while (pDdeConv != NULL) {

        PFREELIST pfl;

        /*
         * If there are any active conversations for this window
         * start termination if not already started.
         */
        if (!(pDdeConv->flags & CXF_TERMINATE_POSTED)) {
            /*
             * Win9x doesn't do any tracking. This breaks some apps that
             *  destroy the window first and then post the terminate. The
             *  other side gets two terminates.
             */
            if (!(GACF2_NODDETRKDYING & GetAppCompatFlags2(VER40))
                || (pDdeConv->spwndPartner == NULL)
                || !(GACF2_NODDETRKDYING
                        & GetAppCompatFlags2ForPti(GETPTI(pDdeConv->spwndPartner), VER40))) {

                /*
                 * CXF_TERMINATE_POSTED would have been set if the window had died.
                 */
                _PostMessage(pDdeConv->spwndPartner, WM_DDE_TERMINATE,
                        (WPARAM)PtoH(pDdeConv->spwnd), 0);
                // pDdeConv->flags |= CXF_TERMINATE_POSTED;  set by PostHookProc
            } else {
                RIPMSG2(RIP_WARNING, "xxxDDETrackWindowDying(GACF2_NODDETRKDYING) not posting terminate from %#p to %#p\r\n",
                        pwnd, pDdeConv->spwndPartner);
            }
        }

        /*
         * now fake that the other side already posted a terminate since
         * we will be gone.
         */
        pDdeConv->spartnerConv->flags |=
                CXF_TERMINATE_POSTED | CXF_PARTNER_WINDOW_DIED;

        ThreadLock(pDdeConv->snext, &tlpDdeConvNext);
        ThreadLockAlways(pDdeConv, &tlpDdeConv);

        pfl = pDdeConv->pfl;
        pDdeConv->pfl = NULL;

        if (pDdeConv->flags & CXF_PARTNER_WINDOW_DIED) {

            ThreadUnlock(&tlpDdeConv);
            /*
             * he's already gone, free up conversation tracking data
             */
            FreeDdeConv(pDdeConv->spartnerConv);
            FreeDdeConv(pDdeConv);
        } else {
            UnlinkConv(pDdeConv);
            ThreadUnlock(&tlpDdeConv);
        }
        xxxFreeListFree(pfl);

        pDdeConv = ThreadUnlock(&tlpDdeConvNext);
    }
}



/************************************************************************
* xxxUnexpectedServerPost
*
* Handles Server DDE messages not anticipated. (ie spontaneous or abnormal)
*
* History:
* 9-3-91    sanfords    Created
\***********************************************************************/
DWORD xxxUnexpectedServerPost(
PDWORD pmessage,
LPARAM *plParam,
PDDECONV pDdeConv)
{
    switch (*pmessage) {
    case WM_DDE_TERMINATE:
        return SpontaneousTerminate(pmessage, pDdeConv);

    case WM_DDE_DATA:
        return xxxAdviseData(pmessage, plParam, pDdeConv);

    case WM_DDE_ACK:

        /*
         * Could be an extra NACK due to timeout problems, just fake it.
         */
        TRACE_DDE("xxxUnexpectedServerPost: dumping ACK data...");
        FreeDDEHandle(pDdeConv, (HANDLE)*plParam, XS_PACKED);
        return FAILNOFREE_POST;

    case WM_DDE_ADVISE:
    case WM_DDE_UNADVISE:
    case WM_DDE_REQUEST:
    case WM_DDE_POKE:
    case WM_DDE_EXECUTE:
        return AbnormalDDEPost(pDdeConv, *pmessage);
    }
    return 0;
}



/************************************************************************
* xxxUnexpectedClientPost
*
*
* Handles Client DDE messages not anticipated. (ie spontaneous or abnormal)
*
* History:
* 9-3-91    sanfords    Created
\***********************************************************************/
DWORD xxxUnexpectedClientPost(
PDWORD pmessage,
LPARAM *plParam,
PDDECONV pDdeConv)
{
    switch (*pmessage) {
    case WM_DDE_TERMINATE:
        return SpontaneousTerminate(pmessage, pDdeConv);

    case WM_DDE_ACK:

        /*
         * Could be an extra NACK due to timeout problems, just fake it.
         */
        TRACE_DDE("xxxUnexpectedClientPost: dumping ACK data...");
        FreeDDEHandle(pDdeConv, (HANDLE)*plParam, XS_PACKED);
        return FAILNOFREE_POST;

    case WM_DDE_DATA:
        return AbnormalDDEPost(pDdeConv, *pmessage);

    case WM_DDE_ADVISE:
        return xxxAdvise(pmessage, plParam, pDdeConv);

    case WM_DDE_UNADVISE:
        return Unadvise(pDdeConv);

    case WM_DDE_REQUEST:
        return Request(pDdeConv);

    case WM_DDE_POKE:
        return xxxPoke(pmessage, plParam, pDdeConv);

    case WM_DDE_EXECUTE:
        return xxxExecute(pmessage, plParam, pDdeConv);
    }
    return 0;
}



/************************************************************************
*                   ADVISE TRANSACTION PROCESSING                       *
\***********************************************************************/



DWORD xxxAdvise(            // Spontaneous Client transaction = WM_DDE_ADVISE
PDWORD pmessage,
LPARAM *plParam,
PDDECONV pDdeConv)
{
    PINTDDEINFO pIntDdeInfo;
    HANDLE hDirect;
    DWORD flags, dwRet;

    CheckLock(pDdeConv);

    TRACE_DDE("xxxAdvise");
    flags = XS_PACKED | XS_LOHANDLE;
    dwRet = xxxCopyDdeIn((HANDLE)*plParam, &flags, &hDirect, &pIntDdeInfo);
    if (dwRet == DO_POST) {
        UserAssert(pIntDdeInfo != NULL);
        *pmessage |= MSGFLAG_DDE_MID_THUNK;
        *plParam = (LPARAM)AnticipatePost(pDdeConv->spartnerConv, xxxAdviseAck,
             hDirect, NULL, pIntDdeInfo, flags);
        if (*plParam == 0) {
            dwRet = FAILNOFREE_POST;
        }
    }
    return dwRet;
}

/*
 * If its inter-process:
 *
 * xxxDDETrackGetMessageHook() fills in hServer from pIntDdeInfo when WM_DDE_ADVISE
 * is received. pIntDdeInfo is then freed. The hServer handle is saved into the
 * pxs structure pointed to by lParam is a direct data structure since
 * packed DDE messages are always assumed to have the packing handle freed.
 */


DWORD xxxAdviseAck(         // Server response to advise - WM_DDE_ACK expected
PDWORD pmessage,
LPARAM *plParam,
PDDECONV pDdeConv)
{
    PXSTATE pxsFree;
    PINTDDEINFO pIntDdeInfo;
    DWORD dwRet;

    CheckLock(pDdeConv);

    if (*pmessage != WM_DDE_ACK) {
        return xxxUnexpectedServerPost(pmessage, plParam, pDdeConv);
    }

    TRACE_DDE("xxxAdviseAck");

    dwRet = xxxCopyAckIn(pmessage, plParam, pDdeConv, &pIntDdeInfo);
    if (dwRet != DO_POST) {
        return dwRet;
    }
    UserAssert(pIntDdeInfo != NULL);

    pxsFree = pDdeConv->spxsOut;
    if (pIntDdeInfo->DdePack.uiLo & DDE_FACK) {

        /*
         * positive ack implies server accepted the hOptions data - free from
         * client at postmessage time.
         */
        TRACE_DDE("xxxAdviseAck: +ACK delayed freeing data from client");
        FreeListAdd(pDdeConv->spartnerConv, pxsFree->hClient, pxsFree->flags & ~XS_PACKED);
    } else {
        // Shouldn't this be freed directly?
        TRACE_DDE("xxxAdviseAck: -ACK delayed freeing data from server");
        FreeListAdd(pDdeConv, pxsFree->hServer, pxsFree->flags & ~XS_PACKED);
    }

    PopState(pDdeConv);
    return DO_POST;
}



/************************************************************************
*                  ADVISE DATA TRANSACTION PROCESSING                   *
\***********************************************************************/



DWORD xxxAdviseData(        // spontaneous from server - WM_DDE_DATA
PDWORD pmessage,
LPARAM *plParam,
PDDECONV pDdeConv)
{
    DWORD flags, dwRet;
    PINTDDEINFO pIntDdeInfo;
    HANDLE hDirect;
    PXSTATE pxs;

    CheckLock(pDdeConv);

    TRACE_DDE("xxxAdviseData");

    flags = XS_PACKED | XS_LOHANDLE | XS_DATA;

    dwRet = xxxCopyDdeIn((HANDLE)*plParam, &flags, &hDirect, &pIntDdeInfo);
    if (dwRet == DO_POST) {
        UserAssert(pIntDdeInfo != NULL);
        TRACE_DDE1("xxxAdviseData: wStatus = %x",
                ((PDDE_DATA)(pIntDdeInfo + 1))->wStatus);
        if (!(((PDDE_DATA)(pIntDdeInfo + 1))->wStatus & (DDE_FACK | DDE_FRELEASE))) {
            RIPMSG0(RIP_ERROR, "DDE protocol violation - no RELEASE or ACK bit set - setting RELEASE.");
            ((PDDE_DATA)(pIntDdeInfo + 1))->wStatus |= DDE_FRELEASE;
        }
        if (((PDDE_DATA)(pIntDdeInfo + 1))->wStatus & DDE_FRELEASE) {
            /*
             * giving it away
             */
            if (IsObjectPublic(pIntDdeInfo->hIndirect) != NULL) {
                RIPMSG0(RIP_ERROR, "DDE Protocol violation - giving away a public GDI object.");
                UserFreePool(pIntDdeInfo);
                return FAILNOFREE_POST;
            }
            if (GiveObject(((PDDE_DATA)(pIntDdeInfo + 1))->wFmt,
                    pIntDdeInfo->hIndirect,
                    (W32PID)(GETPTI(pDdeConv->spwndPartner)->ppi->W32Pid))) {
                flags |= XS_GIVEBACKONNACK;
            }
            flags |= XS_FRELEASE;
        } else {
            /*
             * on loan
             */
            if (AddPublicObject(((PDDE_DATA)(pIntDdeInfo + 1))->wFmt,
                        pIntDdeInfo->hIndirect,
                        (W32PID)(GETPTI(pDdeConv->spwnd)->ppi->W32Pid))) {
                flags |= XS_PUBLICOBJ;
            }
        }

        *pmessage |= MSGFLAG_DDE_MID_THUNK;
        if (((PDDE_DATA)(pIntDdeInfo + 1))->wStatus & DDE_FACK) {
            *plParam = (LPARAM)AnticipatePost(pDdeConv->spartnerConv,
                xxxAdviseDataAck, NULL, hDirect, pIntDdeInfo, flags);
        } else {
            TRACE_DDE("xxxAdviseData: dumping non Ackable data...");
            UserAssert(hDirect != (HANDLE)*plParam);
            FreeDDEHandle(pDdeConv, hDirect, flags & ~XS_PACKED);
            pxs = Createpxs(NULL, NULL, NULL, pIntDdeInfo, flags | XS_FREEPXS);
            if (pxs != NULL) {
                pxs->head.pti = GETPTI(pDdeConv->spwndPartner);
            }
            *plParam = (LPARAM)PtoH(pxs);
        }
        if (*plParam == 0) {
            dwRet = FAILNOFREE_POST;
        }
    }
    return dwRet;
}


/*
 * If its inter-process:
 *
 * xxxDDETrackGetMessageHook() completes the copy from pIntDdeInfo when WM_DDE_DATA
 * is received. pIntDdeInfo is then freed. The hServer handle saved into the
 * pxs structure pointed to by lParam is a directdata structure since
 * packed DDE messages are always assumed to have the packing handle freed
 * by the receiving app.
 * For the !fAckReq case, the pxs is freed due to the XS_FREEPXS flag.
 */


DWORD xxxAdviseDataAck(     // Client response to advise data - WM_DDE_ACK expected
PDWORD pmessage,
LPARAM *plParam,
PDDECONV pDdeConv)
{
    PXSTATE pxsFree;
    PINTDDEINFO pIntDdeInfo;
    DWORD dwRet;

    CheckLock(pDdeConv);

    /*
     * This is also used for request data ack processing.
     */
    if (*pmessage != WM_DDE_ACK) {
        return xxxUnexpectedClientPost(pmessage, plParam, pDdeConv);
    }

    TRACE_DDE("xxxAdviseDataAck");

    dwRet = xxxCopyAckIn(pmessage, plParam, pDdeConv, &pIntDdeInfo);
    if (dwRet != DO_POST) {
        return dwRet;
    }
    UserAssert(pIntDdeInfo != NULL);

    pxsFree = pDdeConv->spxsOut;
    TRACE_DDE3("xxxAdviseDataAck:pxs.hClient(%#p), hServer(%#p), wStatus(%x)",
            pxsFree->hClient, pxsFree->hServer, pIntDdeInfo->DdePack.uiLo);
    if (pIntDdeInfo->DdePack.uiLo & DDE_FACK) {

        /*
         * positive ack implies client accepted the data - free from
         * server at postmessage time iff FRELEASE was set in data msg.
         */
        if (pxsFree->flags & XS_FRELEASE) {
            TRACE_DDE("xxxAdviseDataAck: +ACK delayed server data free");
            FreeListAdd(pDdeConv->spartnerConv, pxsFree->hServer,
                    pxsFree->flags & ~XS_PACKED);
        } else {
            /*
             * Ack w/out fRelease bit means client is done with data.
             */
            TRACE_DDE1("xxxAdviseDataAck: Freeing %#p. (+ACK)",
                    pxsFree->hClient);
            UserAssert(pxsFree->hClient != (HANDLE)*plParam);
            FreeDDEHandle(pDdeConv, pxsFree->hClient, pxsFree->flags & ~XS_PACKED);
        }

    } else {
        TRACE_DDE1("xxxAdviseDataAck: Freeing %#p. (-ACK)",
                pxsFree->hClient);
        FreeDDEHandle(pDdeConv, pxsFree->hClient, pxsFree->flags & ~XS_PACKED);
        UserAssert(pxsFree->hClient != (HANDLE)*plParam);
    }
    PopState(pDdeConv);
    return DO_POST;
}



/************************************************************************
*                   UNADVISE TRANSACTION PROCESSING                     *
\***********************************************************************/



DWORD Unadvise(          // Spontaneous client transaction = WM_DDE_UNADVISE
PDDECONV pDdeConv)
{
    TRACE_DDE("Unadvise");
    if (AnticipatePost(pDdeConv->spartnerConv, xxxUnadviseAck, NULL, NULL, NULL, 0)) {
        return DO_POST;
    } else {
        return FAIL_POST;
    }
}



DWORD xxxUnadviseAck(      // Server response to unadvise - WM_DDE_ACK expected
PDWORD pmessage,
LPARAM *plParam,
PDDECONV pDdeConv)
{
    DWORD dwRet;
    PINTDDEINFO pIntDdeInfo;
    CheckLock(pDdeConv);

    if (*pmessage != WM_DDE_ACK) {
        return xxxUnexpectedServerPost(pmessage, plParam, pDdeConv);
    }
    TRACE_DDE("xxxUnadviseAck");
    dwRet = xxxCopyAckIn(pmessage, plParam, pDdeConv, &pIntDdeInfo);
    if (dwRet != DO_POST) {
        return dwRet;
    }
    UserAssert(pIntDdeInfo != NULL);
    PopState(pDdeConv);
    return DO_POST;
}



/************************************************************************
*                   REQUEST TRANSACTION PROCESSING                      *
\***********************************************************************/

DWORD Request(       // Spontaneous Client transaction - WM_DDE_REQUEST
PDDECONV pDdeConv)
{
    TRACE_DDE("Request");
    if (AnticipatePost(pDdeConv->spartnerConv, xxxRequestAck, NULL, NULL, NULL, 0)) {
        return DO_POST;
    } else {
        return FAIL_POST;
    }
}



DWORD xxxRequestAck(    // Server response - WM_DDE_ACK or WM_DDE_DATA expected
PDWORD pmessage,
LPARAM *plParam,
PDDECONV pDdeConv)
{
    PXSTATE pxsFree;
    DWORD flags;
    PINTDDEINFO pIntDdeInfo;
    HANDLE hDirect;
    DWORD dwStatus, dwRet;

    CheckLock(pDdeConv);

    TRACE_DDE("xxxRequestAck or xxxAdviseData");
    switch (*pmessage) {
    case WM_DDE_DATA:

        /*
         * This is very close to advise data handling - the only catch
         * is that if the fRequest bit is clear this IS advise data.
         */
        flags = XS_PACKED | XS_LOHANDLE | XS_DATA;

        dwStatus = ClientGetDDEFlags((HANDLE)*plParam, flags);

        if (!(dwStatus & DDE_FREQUESTED)) {

            /*
             * Its NOT a request Ack - it must be advise data
             */
            return xxxAdviseData(pmessage, plParam, pDdeConv);
        }

        pxsFree = pDdeConv->spxsOut;
        dwRet = xxxCopyDdeIn((HANDLE)*plParam, &flags, &hDirect, &pIntDdeInfo);
        if (dwRet == DO_POST) {
            UserAssert(pIntDdeInfo != NULL);
            if (!(((PDDE_DATA)(pIntDdeInfo + 1))->wStatus & (DDE_FACK | DDE_FRELEASE))) {
                RIPMSG0(RIP_ERROR, "DDE protocol violation - no RELEASE or ACK bit set - setting RELEASE.");
                ((PDDE_DATA)(pIntDdeInfo + 1))->wStatus |= DDE_FRELEASE;
            }
            if (dwStatus & DDE_FRELEASE) {
                /*
                 * giving it away
                 */
                if (IsObjectPublic(pIntDdeInfo->hIndirect) != NULL) {
                    RIPMSG0(RIP_ERROR, "DDE Protocol violation - giving away a public GDI object.");
                    UserFreePool(pIntDdeInfo);
                    return FAILNOFREE_POST;
                }
                if (GiveObject(((PDDE_DATA)(pIntDdeInfo + 1))->wFmt,
                        pIntDdeInfo->hIndirect,
                        (W32PID)GETPTI(pDdeConv->spwndPartner)->ppi->W32Pid)) {
                    flags |= XS_GIVEBACKONNACK;
                }
                flags |= XS_FRELEASE;
            } else {
                /*
                 * on loan
                 */
                if (AddPublicObject(((PDDE_DATA)(pIntDdeInfo + 1))->wFmt,
                            pIntDdeInfo->hIndirect,
                            (W32PID)GETPTI(pDdeConv->spwnd)->ppi->W32Pid)) {
                    flags |= XS_PUBLICOBJ;
                }
            }
            *pmessage |= MSGFLAG_DDE_MID_THUNK;
            if (dwStatus & DDE_FACK) {
                *plParam = (LPARAM)AnticipatePost(pDdeConv->spartnerConv,
                    xxxAdviseDataAck, NULL, hDirect, pIntDdeInfo, flags);
            } else {
                TRACE_DDE("xxxRequestAck: Delayed freeing non-ackable request data");
                FreeListAdd(pDdeConv, hDirect, flags & ~XS_PACKED);
                pxsFree = Createpxs(NULL, NULL, NULL, pIntDdeInfo, flags | XS_FREEPXS);
                if (pxsFree != NULL) {
                    pxsFree->head.pti = GETPTI(pDdeConv->spwndPartner);
                }
                *plParam = (LPARAM)PtoH(pxsFree);
            }

            if (*plParam != 0) {
                PopState(pDdeConv);
            } else {
                dwRet = FAILNOFREE_POST;
            }
        }
        return dwRet;

    case WM_DDE_ACK:        // server NACKs request
        dwRet = xxxCopyAckIn(pmessage, plParam, pDdeConv, &pIntDdeInfo);
        if (dwRet != DO_POST) {
            return dwRet;
        }
        UserAssert(pIntDdeInfo != NULL);
        PopState(pDdeConv);
        return DO_POST;

    default:
        return xxxUnexpectedServerPost(pmessage, plParam, pDdeConv);
    }
}



/************************************************************************
*                     POKE TRANSACTION PROCESSING                       *
\***********************************************************************/



DWORD xxxPoke(          // spontaneous client transaction - WM_DDE_POKE
PDWORD pmessage,
LPARAM *plParam,
PDDECONV pDdeConv)
{
    DWORD flags, dwRet;
    PINTDDEINFO pIntDdeInfo;
    HANDLE hDirect;

    CheckLock(pDdeConv);

    TRACE_DDE("xxxPoke");
    flags = XS_PACKED | XS_LOHANDLE | XS_DATA;
    dwRet = xxxCopyDdeIn((HANDLE)*plParam, &flags, &hDirect, &pIntDdeInfo);
    if (dwRet == DO_POST) {
        UserAssert(pIntDdeInfo != NULL);
        if (((PDDE_DATA)(pIntDdeInfo + 1))->wStatus & DDE_FRELEASE) {
            /*
             * giving it away
             */
            if (IsObjectPublic(pIntDdeInfo->hIndirect) != NULL) {
                RIPMSG0(RIP_ERROR, "DDE Protocol violation - giving away a public GDI object.");
                UserFreePool(pIntDdeInfo);
                return FAILNOFREE_POST;
            }
            if (GiveObject(((PDDE_DATA)(pIntDdeInfo + 1))->wFmt,
                    pIntDdeInfo->hIndirect,
                    (W32PID)GETPTI(pDdeConv->spwndPartner)->ppi->W32Pid)) {
                flags |= XS_GIVEBACKONNACK;
            }
            flags |= XS_FRELEASE;
        } else {
            /*
             * on loan
             */
            /*
             * fAck bit is ignored and assumed on.
             */
            if (AddPublicObject(((PDDE_DATA)(pIntDdeInfo + 1))->wFmt,
                        pIntDdeInfo->hIndirect,
                        (W32PID)GETPTI(pDdeConv->spwnd)->ppi->W32Pid)) {
                flags |= XS_PUBLICOBJ;
            }
        }
        *pmessage |= MSGFLAG_DDE_MID_THUNK;
        *plParam = (LPARAM)AnticipatePost(pDdeConv->spartnerConv, xxxPokeAck,
             hDirect, NULL, pIntDdeInfo, flags);
        if (*plParam == 0) {
            dwRet = FAILNOFREE_POST;
        }
    }
    return dwRet;
}


/*
 * If its inter-process:
 *
 * xxxDDETrackGetMessageHook() fills in hServer from pIntDdeInfo when WM_DDE_ADVISE
 * is received.  pIntDdeInfo is then freed.  The hServer handle saved into the
 * pxs structure pointer to by lParam is a directdata structure since
 * packed DDE messages are always assumed to have the packing handle freed
 * by the receiving app.
 * For the !fAckReq case, the pxs is also freed due to the XS_FREEPXS flag.
 */


DWORD xxxPokeAck(       // Server response to poke data - WM_DDE_ACK expected
PDWORD pmessage,
LPARAM *plParam,
PDDECONV pDdeConv)
{
    PXSTATE pxsFree;
    PINTDDEINFO pIntDdeInfo;
    DWORD dwRet;

    CheckLock(pDdeConv);

    if (*pmessage != WM_DDE_ACK) {
        return xxxUnexpectedServerPost(pmessage, plParam, pDdeConv);
    }

    TRACE_DDE("xxxPokeAck");

    dwRet = xxxCopyAckIn(pmessage, plParam, pDdeConv, &pIntDdeInfo);
    if (dwRet != DO_POST) {
        return dwRet;
    }
    UserAssert(pIntDdeInfo != NULL);

    pxsFree = pDdeConv->spxsOut;
    if (pIntDdeInfo->DdePack.uiLo & DDE_FACK) {
        // positive ack implies server accepted the data - free from
        // client at postmessage time iff fRelease was set in poke message.
        if (pxsFree->flags & XS_FRELEASE) {
            TRACE_DDE("xxxPokeAck: delayed freeing client data");
            FreeListAdd(pDdeConv->spartnerConv, pxsFree->hClient,
                    pxsFree->flags & ~XS_PACKED);
        }
    } else {
        // Nack means that sender is responsible for freeing it.
        // We must free it in the receiver's context for him.
        TRACE_DDE("xxxPokeAck: freeing Nacked data");
        UserAssert(pxsFree->hServer != (HANDLE)*plParam);
        FreeDDEHandle(pDdeConv, pxsFree->hServer, pxsFree->flags & ~XS_PACKED);
    }
    PopState(pDdeConv);
    return DO_POST;
}



/************************************************************************
*                   EXECUTE TRANSACTION PROCESSING                      *
\***********************************************************************/

DWORD xxxExecute(       // spontaneous client transaction - WM_DDE_EXECUTE
PDWORD pmessage,
LPARAM *plParam,
PDDECONV pDdeConv)
{
    DWORD flags, dwRet;
    PINTDDEINFO pIntDdeInfo;
    HANDLE hDirect;

    CheckLock(pDdeConv);

    TRACE_DDE("xxxExecute");

    flags = XS_EXECUTE;
    if (!TestWF(pDdeConv->spwnd, WFANSIPROC) &&
            !TestWF(pDdeConv->spwndPartner, WFANSIPROC)) {
        flags |= XS_UNICODE;
    }
    dwRet = xxxCopyDdeIn((HANDLE)*plParam, &flags, &hDirect, &pIntDdeInfo);
    if (dwRet == DO_POST) {
        UserAssert(pIntDdeInfo != NULL);
        *pmessage |= MSGFLAG_DDE_MID_THUNK;
        *plParam = (LPARAM)AnticipatePost(pDdeConv->spartnerConv, xxxExecuteAck,
                hDirect, NULL, pIntDdeInfo, flags);
        /*
         * Check for != 0 to make sure the AnticipatePost() succeeded.
         */
        if (*plParam != 0) {

            /*
             * In the execute case it is likely that the postee will want to activate
             * itself and come on top (OLE 1.0 is an example). In this case, allow
             * both the postee and the poster to foreground activate for the next
             * activate (poster because it will want to activate itself again
             * probably, once the postee is done.)
             */
            GETPTI(pDdeConv->spwnd)->TIF_flags |= TIF_ALLOWFOREGROUNDACTIVATE;
            TAGMSG1(DBGTAG_FOREGROUND, "xxxExecute set TIF %#p", GETPTI(pDdeConv->spwnd));
            GETPTI(pDdeConv->spwndPartner)->TIF_flags |= TIF_ALLOWFOREGROUNDACTIVATE;
            TAGMSG1(DBGTAG_FOREGROUND, "xxxExecute set TIF %#p", GETPTI(pDdeConv->spwndPartner));
        } else {
            dwRet = FAILNOFREE_POST;
        }

    }
    return dwRet;
}


/*
 * xxxDDETrackGetMessageHook() fills in hServer from pIntDdeInfo when WM_DDE_EXECUTE
 * is received.  pIntDdeInfo is then freed.
 */


DWORD xxxExecuteAck(       // Server response to execute data - WM_DDE_ACK expected
PDWORD pmessage,
LPARAM *plParam,
PDDECONV pDdeConv)
{
    PXSTATE pxsFree;
    PINTDDEINFO pi;
    DWORD flags = XS_PACKED | XS_FREESRC | XS_EXECUTE;
    DWORD dwRet;

    CheckLock(pDdeConv);

    if (*pmessage != WM_DDE_ACK) {
        return xxxUnexpectedServerPost(pmessage, plParam, pDdeConv);
    }

    TRACE_DDE("xxxExecuteAck");
    dwRet = xxxCopyDdeIn((HANDLE)*plParam, &flags, NULL, &pi);
    if (dwRet == DO_POST) {
        UserAssert(pi != NULL);
        /*
         * the server must respond to the execute with an ack containing the
         * same handle it was given.
         */
        pi->DdePack.uiHi = (ULONG_PTR)pDdeConv->spxsOut->hClient;
        pi->hDirect = NULL;
        pi->cbDirect = 0;
        *pmessage |= MSGFLAG_DDE_MID_THUNK;
        pxsFree = Createpxs(NULL, NULL, NULL, pi, XS_PACKED | XS_FREEPXS);
        if (pxsFree != NULL) {
            pxsFree->head.pti = GETPTI(pDdeConv->spwndPartner);
        }
        *plParam = (LPARAM)PtoH(pxsFree);
        if (*plParam != 0) {
            PopState(pDdeConv);
        } else {
            dwRet = FAILNOFREE_POST;
        }
    }
    return dwRet;
}



/************************************************************************
*                  TERMINATE TRANSACTION PROCESSING                     *
\***********************************************************************/



DWORD SpontaneousTerminate(
PDWORD pmessage,
PDDECONV pDdeConv)
{
    TRACE_DDE("SpontaneousTerminate");
    if (pDdeConv->flags & CXF_TERMINATE_POSTED) {
        return FAKE_POST;
    } else {
        pDdeConv->flags |= CXF_TERMINATE_POSTED;
        *pmessage |= MSGFLAG_DDE_MID_THUNK;
        return DO_POST;
    }
}

/*
 * The xxxDDETrackGetMessageHook() function restores the *pmessage value.
 * Unless a spontaneous terminate from the other app has already
 * arrived, it will note that CXF_TERMINATE_POSTED is NOT set on
 * both sides so no action is taken.
 */


/************************************************************************
*               DUPLICATE CONVERSATION TERMINATION                      *
\***********************************************************************/

/*
 * This routine is called when a DDE server window sent a WM_DDE_ACK
 * message to a client window which is already engaged in a conversation
 * with that server window.  We swallow the ACK and post a terminate to
 * the server window to shut this conversation down.  When the server
 * posts the terminate, this function is called to basically fake
 * a sucessful post.  Thus the client is never bothered while the
 * errant server thinks the conversation was connected and then
 * imediately terminated.
 */
DWORD DupConvTerminate(       // WM_DDE_TERMINATE expected
PDWORD pmessage,
LPARAM *plParam,
PDDECONV pDdeConv)
{
    CheckLock(pDdeConv);

    TRACE_DDE("DupConvTerminate");

    if (*pmessage != WM_DDE_TERMINATE) {
        return xxxUnexpectedServerPost(pmessage, plParam, pDdeConv);
    }

    PopState(pDdeConv);
    return FAKE_POST;
}



/************************************************************************
*               HELPER ROUTINES FOR TRANSACTION TRACKING                *
\***********************************************************************/



/************************************************************************
* AnticipatePost
*
* Allocates, fills and links XSTATE structures.
*
* History:
* 9-3-91    sanfords    Created
\***********************************************************************/
HANDLE AnticipatePost(
PDDECONV pDdeConv,
FNDDERESPONSE fnResponse,
HANDLE hClient,
HANDLE hServer,
PINTDDEINFO pIntDdeInfo,
DWORD flags)
{
    PXSTATE pxs;

    pxs = Createpxs(fnResponse, hClient, hServer, pIntDdeInfo, flags);
    if (pxs != NULL) {
        pxs->head.pti = pDdeConv->head.pti;
        if (pDdeConv->spxsOut == NULL) {
            UserAssert(pDdeConv->spxsIn == NULL);
            Lock(&(pDdeConv->spxsOut), pxs);
            Lock(&(pDdeConv->spxsIn), pxs);
        } else {
            UserAssert(pDdeConv->spxsIn != NULL);
            Lock(&(pDdeConv->spxsIn->snext), pxs);
            Lock(&(pDdeConv->spxsIn), pxs);
        }
#if 0
        {
            int i;
            HANDLEENTRY *phe;

            for (i = 0, phe = gSharedInfo.aheList;
                i <= (int)giheLast;
                    i++) {
                if (phe[i].bType == TYPE_DDEXACT) {
                    UserAssert(((PXSTATE)(phe[i].phead))->snext != pDdeConv->spxsOut);
                }
                if (phe[i].bType == TYPE_DDECONV &&
                        (PDDECONV)phe[i].phead != pDdeConv) {
                    UserAssert(((PDDECONV)(phe[i].phead))->spxsOut != pDdeConv->spxsOut);
                    UserAssert(((PDDECONV)(phe[i].phead))->spxsIn != pDdeConv->spxsOut);
                }
            }
        }
#endif
    }
    return PtoH(pxs);
}



/************************************************************************
* Createpxs
*
* Allocates and fills XSTATE structures.
*
* History:
* 9-3-91    sanfords    Created
\***********************************************************************/
PXSTATE Createpxs(
FNDDERESPONSE fnResponse,
HANDLE hClient,
HANDLE hServer,
PINTDDEINFO pIntDdeInfo,
DWORD flags)
{
    PXSTATE pxs;

    pxs = HMAllocObject(PtiCurrent(), NULL, TYPE_DDEXACT, sizeof(XSTATE));
    if (pxs == NULL) {
#if DBG
        RIPMSG0(RIP_WARNING, "Unable to alloc DDEXACT");
#endif
        return NULL;
    }
    pxs->snext = NULL;
    pxs->fnResponse = fnResponse;
    pxs->hClient = hClient;
    pxs->hServer = hServer;
    pxs->pIntDdeInfo = pIntDdeInfo;
    pxs->flags = flags;
    ValidatePublicObjectList();
    UserAssert(pxs->head.cLockObj == 0);
    return pxs;
}




/************************************************************************
* AbnormalDDEPost
*
* This is the catch-all routine for wierd cases
*
* returns post action code - DO_POST, FAKE_POST, FAIL_POST.
*
* History:
* 9-3-91    sanfords    Created
\***********************************************************************/
DWORD AbnormalDDEPost(
PDDECONV pDdeConv,
DWORD message)
{

#if DBG
    if (message != WM_DDE_TERMINATE) {
        RIPMSG2(RIP_WARNING,
                "DDE Post failed (%#p:%#p) - protocol violation.",
                PtoH(pDdeConv->spwnd), PtoH(pDdeConv->spwndPartner));
    }
#endif // DBG

    // shutdown this conversation by posting a terminate on
    // behalf of this guy, then fail all future posts but
    // fake a successful terminate.

    if (!(pDdeConv->flags & CXF_TERMINATE_POSTED)) {
        _PostMessage(pDdeConv->spwndPartner, WM_DDE_TERMINATE,
                (WPARAM)PtoH(pDdeConv->spwnd), 0);
        // pDdeConv->flags |= CXF_TERMINATE_POSTED; Set by post hook proc
    }
    return message == WM_DDE_TERMINATE ? FAKE_POST : FAIL_POST;
}



/************************************************************************
* NewConversation
*
* Worker function used to create a saimese pair of DDECONV structures.
*
* Returns fCreateOk
*
* History:
* 11-5-92    sanfords    Created
\***********************************************************************/
BOOL NewConversation(
PDDECONV *ppdcNewClient,
PDDECONV *ppdcNewServer,
PWND pwndClient,
PWND pwndServer)
{
    PDDECONV pdcNewClient;
    PDDECONV pdcNewServer;

    pdcNewClient = HMAllocObject(GETPTI(pwndClient), NULL,
            TYPE_DDECONV, sizeof(DDECONV));
    if (pdcNewClient == NULL) {
        return FALSE;
    }

    pdcNewServer = HMAllocObject(GETPTI(pwndServer), NULL,
            TYPE_DDECONV, sizeof(DDECONV));
    if (pdcNewServer == NULL) {
        HMFreeObject(pdcNewClient);     // we know it's not locked.
        return FALSE;
    }

    AddConvProp(pwndClient, pwndServer, 0, pdcNewClient, pdcNewServer);
    AddConvProp(pwndServer, pwndClient, CXF_IS_SERVER, pdcNewServer,
            pdcNewClient);

    if (ppdcNewClient != NULL) {
        *ppdcNewClient = pdcNewClient;
    }
    if (ppdcNewServer != NULL) {
        *ppdcNewServer = pdcNewServer;
    }
    return TRUE;
}


/************************************************************************
* FindDdeConv
*
* Locates the pDdeConv associated with pwndProp, and pwndPartner.
* Only searches pwndProp's property list.
*
* History:
* 3-31-91   sanfords    Created
\***********************************************************************/
PDDECONV FindDdeConv(
PWND pwndProp,
PWND pwndPartner)
{
    PDDECONV pDdeConv;

    pDdeConv = (PDDECONV)_GetProp(pwndProp, PROP_DDETRACK, PROPF_INTERNAL);
    while (pDdeConv != NULL && pDdeConv->spwndPartner != pwndPartner) {
        pDdeConv = pDdeConv->snext;
    }

    return pDdeConv;
}



/************************************************************************
* xxxCopyAckIn
*
* A common occurance helper function
*
* History:
* 9-3-91    sanfords    Created
\***********************************************************************/
DWORD xxxCopyAckIn(
LPDWORD pmessage,
LPARAM *plParam,
PDDECONV pDdeConv,
PINTDDEINFO * ppIntDdeInfo)
{
    PINTDDEINFO pIntDdeInfo;
    DWORD flags, dwRet;
    PXSTATE pxs;

    CheckLock(pDdeConv);

    flags = XS_PACKED | XS_FREESRC;
    dwRet = xxxCopyDdeIn((HANDLE)*plParam, &flags, NULL, ppIntDdeInfo);
    if (dwRet == DO_POST) {
        UserAssert(*ppIntDdeInfo != NULL);
        pIntDdeInfo = *ppIntDdeInfo;
        if (pDdeConv->spxsOut->flags & XS_GIVEBACKONNACK &&
                !(((PDDE_DATA)(pIntDdeInfo + 1))->wStatus & DDE_FACK)) {
            GiveObject(((PDDE_DATA)(pDdeConv->spxsOut->pIntDdeInfo + 1))->wFmt,
                    pDdeConv->spxsOut->pIntDdeInfo->hIndirect,
                    (W32PID)GETPTI(pDdeConv->spwndPartner)->ppi->W32Pid);
        }
        if (pDdeConv->spxsOut->flags & XS_PUBLICOBJ) {
            RemovePublicObject(((PDDE_DATA)(pDdeConv->spxsOut->pIntDdeInfo + 1))->wFmt,
                    pDdeConv->spxsOut->pIntDdeInfo->hIndirect);
            pDdeConv->spxsOut->flags &= ~XS_PUBLICOBJ;
        }
        pxs = Createpxs(NULL, NULL, NULL, pIntDdeInfo, flags | XS_FREEPXS);
        if (pxs != NULL) {
            pxs->head.pti = GETPTI(pDdeConv->spwndPartner);
        }
        *plParam = (LPARAM)PtoH(pxs);
        if (*plParam == 0) {
            return FAILNOFREE_POST;
        }
        *pmessage |= MSGFLAG_DDE_MID_THUNK;
    }
    return dwRet;
}



/************************************************************************
* FreeListAdd
*
* Adds a CSR Client handle to the free list associated with pDdeConv.
* This allows us to make sure stuff is freed that isn't in a context
* we have access at the time we know it must be freed.
*
* returns fSuccess
*
* History:
* 9-3-91    sanfords    Created
\***********************************************************************/
BOOL FreeListAdd(
PDDECONV pDdeConv,
HANDLE hClient,
DWORD flags)
{
    PFREELIST pfl;

    pfl = (PFREELIST)UserAllocPool(sizeof(FREELIST), TAG_DDE1);
    if (!pfl) {
        return FALSE;
    }
    TRACE_DDE2("FreeListAdd: %x for thread %x.", hClient,
            GETPTIID(pDdeConv->head.pti));
    pfl->h = hClient;
    pfl->flags = flags;
    pfl->next = pDdeConv->pfl;
    pDdeConv->pfl = pfl;
    return TRUE;
}


/************************************************************************
* FreeDDEHandle
*
* Frees contents DDE client side handle - delayed free if a WOW process.
*
* History:
* 7-28-94    sanfords    Created
\***********************************************************************/
VOID FreeDDEHandle(
PDDECONV pDdeConv,
HANDLE hClient,
DWORD flags)
{
    if (PtiCurrent()->TIF_flags & TIF_16BIT) {
        TRACE_DDE1("FreeDDEHandle: (WOW hack) delayed Freeing %#p.", hClient);
        FreeListAdd(pDdeConv, hClient, flags);
    } else {
        TRACE_DDE1("FreeDDEHandle: Freeing %#p.", hClient);
        ClientFreeDDEHandle(hClient, flags);
    }
}



/************************************************************************
* xxxFreeListFree
*
* Frees contents of the free list associated with pDdeConv.
*
* History:
* 9-3-91    sanfords    Created
\***********************************************************************/
VOID FreeListFree(
    PFREELIST pfl)
{
    PFREELIST pflPrev;

    CheckCritIn();

    UserAssert(pfl != NULL);

    while (pfl != NULL) {
        pflPrev = pfl;
        pfl = pfl->next;
        UserFreePool(pflPrev);
    }
}


VOID xxxFreeListFree(
PFREELIST pfl)
{
    PFREELIST pflPrev;
    BOOL      fInCleanup;
    TL        tlPool;

    CheckCritIn();

    if (pfl == NULL) {
        return;
    }

    fInCleanup = (PtiCurrent())->TIF_flags & TIF_INCLEANUP;

    while (pfl != NULL) {

        ThreadLockPoolCleanup(PtiCurrent(), pfl, &tlPool, FreeListFree);

        if (!fInCleanup) {
            TRACE_DDE1("Freeing %#p from free list.\n", pfl->h);
            ClientFreeDDEHandle(pfl->h, pfl->flags);
        }

        ThreadUnlockPoolCleanup(PtiCurrent(), &tlPool);

        pflPrev = pfl;
        pfl = pfl->next;
        UserFreePool(pflPrev);
    }
}


/************************************************************************
* PopState
*
* Frees spxsOut from pDdeConv and handles empty queue case.
*
* History:
* 9-3-91    sanfords    Created
\***********************************************************************/
VOID PopState(
PDDECONV pDdeConv)
{
    PXSTATE pxsNext, pxsFree;
    TL tlpxs;

    UserAssert(pDdeConv->spxsOut != NULL);
#if 0
    {
        int i;
        HANDLEENTRY *phe;

        for (i = 0, phe = gSharedInfo.aheList;
            i <= giheLast;
                i++) {
            if (phe[i].bType == TYPE_DDEXACT) {
                UserAssert(((PXSTATE)(phe[i].phead))->snext != pDdeConv->spxsOut);
            }
        }
    }
#endif
    UserAssert(!(pDdeConv->spxsOut->flags & XS_FREEPXS));
    UserAssert(pDdeConv->spxsIn != NULL);
    UserAssert(pDdeConv->spxsIn->snext == NULL);

    ThreadLockAlways(pDdeConv->spxsOut, &tlpxs);              // hold it fast
    pxsNext = pDdeConv->spxsOut->snext;
    pxsFree = Lock(&(pDdeConv->spxsOut), pxsNext);      // lock next into head
    if (pxsNext == NULL) {
        UserAssert(pDdeConv->spxsIn == pxsFree);
        Unlock(&(pDdeConv->spxsIn));                // queue is empty.
    } else {
        Unlock(&(pxsFree->snext));                  // clear next ptr
    }
    pxsFree = ThreadUnlock(&tlpxs);                     // undo our lock
    if (pxsFree != NULL) {
        FreeDdeXact(pxsFree);                           // cleanup.
    }
}


VOID FreeDdeConv(
PDDECONV pDdeConv)
{

    TRACE_DDE1("FreeDdeConv(%#p)", pDdeConv);

    if (!(pDdeConv->flags & CXF_TERMINATE_POSTED) &&
            !HMIsMarkDestroy(pDdeConv->spwndPartner)) {
        _PostMessage(pDdeConv->spwndPartner, WM_DDE_TERMINATE,
                (WPARAM)PtoH(pDdeConv->spwnd), 0);
        // pDdeConv->flags |= CXF_TERMINATE_POSTED; set by PostHookProc
    }

    if (pDdeConv->spartnerConv != NULL &&
            GETPTI(pDdeConv)->TIF_flags & TIF_INCLEANUP) {
        /*
         * Fake that the other side already posted a terminate.
         * This prevents vestigal dde structures from hanging
         * around after thread cleanup if the conversation structure
         * is destroyed before the associated window.
         */
        pDdeConv->spartnerConv->flags |= CXF_TERMINATE_POSTED;
    }

    UnlinkConv(pDdeConv);

    if (pDdeConv->pddei != NULL) {
        pDdeConv->pddei->cRefConv--;
        if (pDdeConv->pddei->cRefConv == 0 && pDdeConv->pddei->cRefInit == 0) {
            SeDeleteClientSecurity(&pDdeConv->pddei->ClientContext);
            UserFreePool(pDdeConv->pddei);
        }
        pDdeConv->pddei = NULL;
    }

    Unlock(&(pDdeConv->spartnerConv));
    Unlock(&(pDdeConv->spwndPartner));
    Unlock(&(pDdeConv->spwnd));

    if (!HMMarkObjectDestroy((PHEAD)pDdeConv))
        return;

    while (pDdeConv->spxsOut) {
        PopState(pDdeConv);
    }

    HMFreeObject(pDdeConv);
}



/***************************************************************************\
* xxxCopyDdeIn
*
* Description:
*   Copies DDE data from the CSR client to the CSR server side.
*   Crosses the CSR barrier as many times as is needed to get all the data
*   through the CSR window.
*
* History:
* 11-1-91   sanfords    Created.
\***************************************************************************/
DWORD xxxCopyDdeIn(
HANDLE hSrc,
PDWORD pflags,
PHANDLE phDirect,
PINTDDEINFO *ppi)
{
    DWORD dwRet;
    PINTDDEINFO pi;

    dwRet = xxxClientCopyDDEIn1(hSrc, *pflags, ppi);
    pi = *ppi;
    TRACE_DDE2(*pflags & XS_FREESRC ?
            "Copying in and freeing %#p(%#p)" :
            "Copying in %#p(%#p)",
            hSrc, pi ? pi->hDirect : 0);

    if (dwRet == DO_POST) {
        UserAssert(*ppi != NULL);
        *pflags = pi->flags;
        TRACE_DDE3("xxxCopyDdeIn: uiLo=%x, uiHi=%x, hDirect=%#p",
                pi->DdePack.uiLo, pi->DdePack.uiHi, pi->hDirect);
        if (phDirect != NULL) {
            *phDirect = pi->hDirect;
        }
    }
#if DBG
      else {
        RIPMSG0(RIP_WARNING, "Unable to alloc DDE INTDDEINFO");
    }
#endif

    return dwRet;
}



/***********************************************************************\
* xxxCopyDDEOut
*
* Returns: the apropriate client side handle for lParam or NULL on
* failure. (Since only TERMINATES should have 0 here)
*
* 11/7/1995 Created SanfordS
\***********************************************************************/

HANDLE xxxCopyDDEOut(
PINTDDEINFO pi,
PHANDLE phDirect)   // receives the target client side GMEM handle.
{
    HANDLE hDst;

    TRACE_DDE3("xxxCopyDDEOut: cbDirect=%x, cbIndirect=%x, flags=%x",
            pi->cbDirect, pi->cbIndirect, pi->flags);
    hDst = xxxClientCopyDDEOut1(pi);
    TRACE_DDE3("xxxCopyDDEOut: uiLo=%x, uiHi=%x, hResult=%#p",
            pi->DdePack.uiLo, pi->DdePack.uiHi, hDst);
    if (hDst != NULL) {
        if (phDirect != NULL) {
            TRACE_DDE1("xxxCopyDDEOut: *phDirect=%#p", pi->hDirect);
            *phDirect = pi->hDirect;
        }
    }
    return hDst;
}



/*
 * This API is used to set the QOS associated with a potential DDE client window.
 * It should be called prior to sending a WM_DDE_INITIATE message and the qos set
 * will hold until the WM_DDE_INITIATE send or broadcast returns.
 */
BOOL _DdeSetQualityOfService(
PWND pwndClient,
CONST PSECURITY_QUALITY_OF_SERVICE pqosNew,
PSECURITY_QUALITY_OF_SERVICE pqosOld)
{
    PSECURITY_QUALITY_OF_SERVICE pqosUser;
    PSECURITY_QUALITY_OF_SERVICE pqosAlloc = NULL;
    BOOL fRet;

    /*
     * ASSUME: calling process is owner of pwndClient - ensured in thunk.
     */
    pqosUser = (PSECURITY_QUALITY_OF_SERVICE)InternalRemoveProp(pwndClient,
            PROP_QOS, PROPF_INTERNAL);
    if (pqosUser == NULL) {
        if (RtlEqualMemory(pqosNew, &gqosDefault, sizeof(SECURITY_QUALITY_OF_SERVICE))) {
            return TRUE;           // no PROP_QOS property implies default QOS
        }
        pqosAlloc = (PSECURITY_QUALITY_OF_SERVICE)UserAllocPoolZInit(
                sizeof(SECURITY_QUALITY_OF_SERVICE), TAG_DDE2);
        if (pqosAlloc == NULL) {
            return FALSE;          // memory allocation failure - can't change from default
        }
        pqosUser = pqosAlloc;
    }
    *pqosOld = *pqosUser;
    *pqosUser = *pqosNew;

    fRet = InternalSetProp(pwndClient, PROP_QOS, pqosUser, PROPF_INTERNAL);
    if ((fRet == FALSE) && (pqosAlloc != NULL)) {
        UserFreePool(pqosAlloc);
    }

    return fRet;
}


/*
 * This is a private API for NetDDE's use.  It extracts the QOS associated with an
 * active DDE conversation.  Intra-process conversations always are set to the default
 * QOS.
 */
BOOL _DdeGetQualityOfService(
PWND pwndClient,
PWND pwndServer,
PSECURITY_QUALITY_OF_SERVICE pqos)
{
    PDDECONV pDdeConv;
    PSECURITY_QUALITY_OF_SERVICE pqosClient;

    if (pwndServer == NULL) {
        /*
         * Special case to support DDEML-RAW conversations that need to get
         * the QOS prior to initiation completion.
         */
        pqosClient = _GetProp(pwndClient, PROP_QOS, PROPF_INTERNAL);
        if (pqosClient == NULL) {
            *pqos = gqosDefault;
        } else {
            *pqos = *pqosClient;
        }
        return TRUE;
    }
    if (GETPWNDPPI(pwndClient) == GETPWNDPPI(pwndServer)) {
        *pqos = gqosDefault;
        return TRUE;
    }
    pDdeConv = FindDdeConv(pwndClient, pwndServer);
    if (pDdeConv == NULL) {
        return FALSE;
    }
    if (pDdeConv->pddei == NULL) {
        return FALSE;
    }
    *pqos = pDdeConv->pddei->qos;
    return TRUE;
}



BOOL _ImpersonateDdeClientWindow(
    PWND pwndClient,
    PWND pwndServer)
{
    PDDECONV pDdeConv;
    NTSTATUS Status;

    /*
     * Locate token used in the conversation
     */
    pDdeConv = FindDdeConv(pwndClient, pwndServer);
    if (pDdeConv == NULL || pDdeConv->pddei == NULL)
        return FALSE;

    /*
     * Stick the token into the dde server thread
     */
    Status = SeImpersonateClientEx(&pDdeConv->pddei->ClientContext,
            PsGetCurrentThread());
    if (!NT_SUCCESS(Status)) {
        RIPNTERR0(Status, RIP_VERBOSE, "");
        return FALSE;
    }
    return TRUE;
}


VOID FreeDdeXact(
    PXSTATE pxs)
{
    if (!HMMarkObjectDestroy(pxs)) {
        return;
    }

#if 0
    {
        int i;
        HANDLEENTRY *phe;

        for (i = 0, phe = gSharedInfo.aheList; i <= giheLast; i++) {
            if (phe[i].bType == TYPE_DDEXACT) {
                UserAssert(((PXSTATE)(phe[i].phead))->snext != pxs);
            } else if (phe[i].bType == TYPE_DDECONV) {
                UserAssert(((PDDECONV)(phe[i].phead))->spxsOut != pxs);
                UserAssert(((PDDECONV)(phe[i].phead))->spxsIn != pxs);
            }
        }
    }
    UserAssert(pxs->head.cLockObj == 0);
    UserAssert(pxs->snext == NULL);
#endif

    if (pxs->pIntDdeInfo != NULL) {
        /*
         * free any server-side GDI objects
         */
        if (pxs->pIntDdeInfo->flags & (XS_METAFILEPICT | XS_ENHMETAFILE)) {
            GreDeleteServerMetaFile(pxs->pIntDdeInfo->hIndirect);
        }
        if (pxs->flags & XS_PUBLICOBJ) {
            RemovePublicObject(((PDDE_DATA)(pxs->pIntDdeInfo + 1))->wFmt,
                    pxs->pIntDdeInfo->hIndirect);
            pxs->flags &= ~XS_PUBLICOBJ;
        }
        UserFreePool(pxs->pIntDdeInfo);
    }

    HMFreeObject(pxs);
    ValidatePublicObjectList();
}



PPUBOBJ IsObjectPublic(
HANDLE hObj)
{
    PPUBOBJ ppo;

    for (ppo = gpPublicObjectList; ppo != NULL; ppo = ppo->next) {
        if (ppo->hObj == hObj) {
            break;
        }
    }
    return ppo;
}



BOOL AddPublicObject(
UINT format,
HANDLE hObj,
W32PID pid)
{
    PPUBOBJ ppo;

    switch (format) {
    case CF_BITMAP:
    case CF_DSPBITMAP:
    case CF_PALETTE:
        break;

    default:
        return FALSE;
    }

    ppo = IsObjectPublic(hObj);
    if (ppo == NULL) {
        ppo = UserAllocPool(sizeof(PUBOBJ), TAG_DDE4);
        if (ppo == NULL) {
            return FALSE;
        }
        ppo->count = 1;
        ppo->hObj = hObj;
        ppo->pid = pid;
        ppo->next = gpPublicObjectList;
        gpPublicObjectList = ppo;
        GiveObject(format, hObj, OBJECT_OWNER_PUBLIC);
    } else {
        ppo->count++;
    }
    return TRUE;
}



BOOL RemovePublicObject(
UINT format,
HANDLE hObj)
{
    PPUBOBJ ppo, ppoPrev;

    switch (format) {
    case CF_BITMAP:
    case CF_DSPBITMAP:
    case CF_PALETTE:
        break;

    default:
        return FALSE;
    }

    for (ppoPrev = NULL, ppo = gpPublicObjectList;
            ppo != NULL;
                ppoPrev = ppo, ppo = ppo->next) {
        if (ppo->hObj == hObj) {
            break;
        }
    }
    if (ppo == NULL) {
        UserAssert(FALSE);
        return FALSE;
    }
    ppo->count--;
    if (ppo->count == 0) {
        GiveObject(format, hObj, ppo->pid);
        if (ppoPrev != NULL) {
            ppoPrev->next = ppo->next;
        } else {
            gpPublicObjectList = ppo->next;
        }
        UserFreePool(ppo);
    }
    return TRUE;
}


BOOL
GiveObject(
    UINT format,
    HANDLE hObj,
    W32PID pid)
{
    switch (format) {
    case CF_BITMAP:
    case CF_DSPBITMAP:
        GreSetBitmapOwner(hObj, pid);
        return TRUE;

    case CF_PALETTE:
        GreSetPaletteOwner(hObj, pid);
        return TRUE;

    default:
        return FALSE;
    }
}

#if DBG
VOID ValidatePublicObjectList()
{
    PPUBOBJ ppo;
    int i, count;
    HANDLEENTRY *phe;

    for (count = 0, ppo = gpPublicObjectList;
            ppo != NULL;
                ppo = ppo->next) {
        count += ppo->count;
    }
    for (i = 0, phe = gSharedInfo.aheList;
        i <= (int)giheLast;
            i++) {
        if (phe[i].bType == TYPE_DDEXACT) {
            if (((PXSTATE)(phe[i].phead))->flags & XS_PUBLICOBJ) {
                UserAssert(((PXSTATE)(phe[i].phead))->pIntDdeInfo != NULL);
                UserAssert(IsObjectPublic(((PXSTATE)
                        (phe[i].phead))->pIntDdeInfo->hIndirect) != NULL);
                count--;
            }
        }
    }
    UserAssert(count == 0);
}


VOID TraceDdeMsg(
UINT msg,
HWND hwndFrom,
HWND hwndTo,
UINT code)
{
    LPSTR szMsg, szType;

    msg = msg & 0xFFFF;

    switch (msg) {
    case WM_DDE_INITIATE:
        szMsg = "INITIATE";
        break;

    case WM_DDE_TERMINATE:
        szMsg = "TERMINATE";
        break;

    case WM_DDE_ADVISE:
        szMsg = "ADVISE";
        break;

    case WM_DDE_UNADVISE:
        szMsg = "UNADVISE";
        break;

    case WM_DDE_ACK:
        szMsg = "ACK";
        break;

    case WM_DDE_DATA:
        szMsg = "DATA";
        break;

    case WM_DDE_REQUEST:
        szMsg = "REQUEST";
        break;

    case WM_DDE_POKE:
        szMsg = "POKE";
        break;

    case WM_DDE_EXECUTE:
        szMsg = "EXECUTE";
        break;

    default:
        szMsg = "BOGUS";
        UserAssert(msg >= WM_DDE_FIRST && msg <= WM_DDE_LAST);
        break;
    }

    switch (code) {
    case MSG_SENT:
        szType = "[sent]";
        break;

    case MSG_POST:
        szType = "[posted]";
        break;

    case MSG_RECV:
        szType = "[received]";
        break;

    case MSG_PEEK:
        szType = "[peeked]";
        break;

    default:
        szType = "[bogus]";
        UserAssert(FALSE);
        break;
    }

    RIPMSG4(RIP_VERBOSE,
            "%#p->%#p WM_DDE_%s %s",
            hwndFrom, hwndTo, szMsg, szType);
}
#endif //DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\ddemlsvr.h ===
/****************************** Module Header ******************************\
* Module Name: ddemlsvr.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Typedefs, defines, and prototypes that are used exclusively by the DDEML
* server-side.
*
* History:
* 12-6-91     sanfords   Created.
* 21-Jan-1992 IanJa      ANSI/Unicode neutralized (null op)
\***************************************************************************/

#define     MF_INTERNAL                  0x80000000L

// globals

extern PSVR_INSTANCE_INFO psiiList;
extern DWORD MonitorFlags;

// event.c

VOID xxxChangeMonitorFlags(PSVR_INSTANCE_INFO psii, DWORD afCmdNew);
DWORD xxxCsEvent(PEVENT_PACKET pep, WORD cbEventData);
LRESULT xxxEventWndProc(PWND pwnd, UINT message, WPARAM wParam, LPARAM lParam);
VOID xxxProcessDDEMLEvent(PSVR_INSTANCE_INFO psii, PEVENT_PACKET pep);
VOID xxxMessageEvent(PWND pwndTo, UINT message, WPARAM wParam, LPARAM lParam,
    DWORD flag, PDDEML_MSG_HOOK_DATA pdmhd);

// ddemlsvr.c

DWORD xxxCsDdeInitialize(PHANDLE phInst, HWND *phwndEvent, LPDWORD pMonitorFlags,
    DWORD afCmd, PVOID pcii);
DWORD _CsUpdateInstance(HANDLE hInst, LPDWORD pMonitorFlags, DWORD afCmd);
BOOL _CsDdeUninitialize(HANDLE hInst);
VOID xxxDestroyThreadDDEObject(PTHREADINFO pti, PSVR_INSTANCE_INFO psii);
PVOID _CsValidateInstance(HANDLE hInst);

// CSR callbacks

DWORD ClientEventCallback(PVOID pcii, PEVENT_PACKET pep);
DWORD ClientGetDDEHookData(UINT message, LPARAM lParam, PDDEML_MSG_HOOK_DATA pdmhd);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\debug.c ===
/****************************** Module Header ******************************\
* Module Name: debug.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains random debugging related functions.
*
* History:
* 17-May-1991 DarrinM   Created.
* 22-Jan-1992 IanJa     ANSI/Unicode neutral (all debug output is ANSI)
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*
 * Include stuff necessary to send a datagram to winsrv.
 */
#include "ntcsrmsg.h"
#include "csrmsg.h"

/**************************************************************************\
* ActivateDebugger
*
* Force an exception on the active application's context so it will break
* into the debugger.
*
* History:
* 05-10-91 DarrinM      Created.
\***************************************************************************/

BOOL xxxActivateDebugger(
    UINT fsModifiers)
{
    ULONG ArgLength;
    USER_API_MSG m;
    PACTIVATEDEBUGGERMSG a = &m.u.ActivateDebugger;
    PEPROCESS Process;
    HANDLE hDebugPort;
    NTSTATUS Status;
    if (fsModifiers & MOD_CONTROL) {
#if DBG
        if (RipOutput(0, RIP_WARNING, "User debugger", 0, "Debug prompt", NULL)) {
            DbgBreakPoint();
        }
#endif
        return FALSE;
    } else if (fsModifiers & MOD_SHIFT) {

        /*
         * Bail out if the process is not being debugged.
         */
        if (PsGetProcessDebugPort(gpepCSRSS) == NULL)
            return FALSE;

        a->ClientId.UniqueProcess = PsGetProcessId(gpepCSRSS);
    } else {

        if ((gpqForeground == NULL) || (gpqForeground->ptiKeyboard == NULL))
            return FALSE;

        a->ClientId.UniqueProcess = PsGetThreadProcessId(gpqForeground->ptiKeyboard->pEThread);
        a->ClientId.UniqueThread = PsGetThreadId(gpqForeground->ptiKeyboard->pEThread);

        LeaveCrit();
        Status = LockProcessByClientId(a->ClientId.UniqueProcess, &Process);
        EnterCrit();

        /*
         * Bail out if the process is not being debugged or the process id
         * is invalid.
         */
        if (!NT_SUCCESS(Status))
            return FALSE;
        
        hDebugPort = PsGetProcessDebugPort(Process);
        UnlockProcess(Process);

        if (hDebugPort == NULL)
            return FALSE;
    }

    /*
     * Send the datagram to CSR
     */
    if (CsrApiPort != NULL) {
        ArgLength = sizeof(*a);
        ArgLength |= (ArgLength << 16);
        ArgLength +=     ((sizeof( CSR_API_MSG ) - sizeof( m.u )) << 16) |
                        (FIELD_OFFSET( CSR_API_MSG, u ) - sizeof( m.h ));
        m.h.u1.Length = ArgLength;
        m.h.u2.ZeroInit = 0;
        m.CaptureBuffer = NULL;
        m.ApiNumber = CSR_MAKE_API_NUMBER( USERSRV_SERVERDLL_INDEX,
                                           UserpActivateDebugger);
        LeaveCrit();
        Status = LpcRequestPort(CsrApiPort, (PPORT_MESSAGE)&m);
        EnterCrit();
        UserAssert(NT_SUCCESS(Status));
    }

    /*
     * Don't eat this event unless we are breaking into CSR! Since we have
     * choosen an arbitrary hot key like F12 for the debug key, we need to
     * pass on the key to the application, or apps that want this key would
     * never see it. If we had an api for installing a debug hot key
     * (export or MOD_DEBUG flag to RegisterHotKey()), then it would be ok
     * to eat because the user selected the hot key. But it is not ok to
     * eat it as long as we've picked an arbitrary hot key. scottlu.
     */
    if (fsModifiers & MOD_SHIFT)
        return TRUE;
    else
        return FALSE;
}

DWORD GetRipComponent(VOID) { return RIP_USERKRNL; }

DWORD GetDbgTagFlags(int tag)
{
#if DEBUGTAGS
    return (gpsi != NULL ? gpsi->adwDBGTAGFlags[tag] : 0);
#else
    return 0;
    UNREFERENCED_PARAMETER(tag);
#endif // DEBUGTAGS
}

DWORD GetRipPID(VOID) { return (gpsi != NULL ? gpsi->wRIPPID : 0); }
DWORD GetRipFlags(VOID) { return (gpsi != NULL ? gpsi->wRIPFlags : RIPF_DEFAULT); }

VOID SetRipFlags(DWORD dwRipFlags, DWORD dwRipPID)
{
    _SetRipFlags(dwRipFlags, dwRipPID);
}

VOID SetDbgTag(int tag, DWORD dwBitFlags)
{
    _SetDbgTag(tag, dwBitFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntuser\kernel\desktop.c ===
/***************************** Module Header ******************************\
* Module Name: desktop.c
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* This module contains everything related to the desktop support.
*
* History:
* 23-Oct-1990 DarrinM   Created.
* 01-Feb-1991 JimA      Added new API stubs.
* 11-Feb-1991 JimA      Added access checks.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

typedef struct _DESKTOP_CONTEXT {
    PUNICODE_STRING pstrDevice;
    LPDEVMODE       lpDevMode;
    DWORD           dwFlags;
} DESKTOP_CONTEXT, *PDESKTOP_CONTEXT;

extern BOOL fGdiEnabled;

/*
 * We use these to protect a handle we're currently using from being closed.
 */
PEPROCESS gProcessInUse;
HANDLE gHandleInUse;

/*
 * Debug Related Info.
 */
#if DBG
DWORD gDesktopsBusy;     // diagnostic
#endif

#ifdef DEBUG_DESK
VOID ValidateDesktop(PDESKTOP pdesk);
#endif // DEBUG_DESK
VOID DbgCheckForThreadsOnDesktop(PPROCESSINFO ppi, PDESKTOP pdesk);

VOID FreeView(
    PEPROCESS Process,
    PDESKTOP pdesk);


NTSTATUS
SetDisconnectDesktopSecurity(
    IN HDESK hdeskDisconnect);

#ifdef POOL_INSTR
    extern FAST_MUTEX* gpAllocFastMutex;   // mutex to syncronize pool allocations
#endif // POOL_INSTR


PVOID DesktopAlloc(
    PDESKTOP pdesk,
    UINT     uSize,
    DWORD    tag)
{
    if (pdesk->dwDTFlags & DF_DESTROYED) {
        RIPMSG2(RIP_ERROR,
                "DesktopAlloc: tag %d pdesk %#p is destroyed",
                tag,
                pdesk);
        return NULL;
    }

    return Win32HeapAlloc(pdesk->pheapDesktop, uSize, tag, 0);
}

#if DBG

WCHAR s_strName[100];
WCHAR s_strNameNull[] = L"null";

/***************************************************************************\
* GetDesktopName
*
* This is for debug purposes.
*
* Dec-10-1997 CLUPU     Created.
\***************************************************************************/
PWCHAR GetDesktopName(
    PDESKTOP pdesk)
{
    POBJECT_NAME_INFORMATION DesktopObjectName = (POBJECT_NAME_INFORMATION) s_strName;
    ULONG DesktopObjectNameLength = sizeof(s_strName) - sizeof(WCHAR);
    NTSTATUS Status;

    if (pdesk == NULL) {
        return s_strNameNull;
    }

    Status = ObQueryNameString( pdesk,
                                DesktopObjectName,
                                DesktopObjectNameLength,
                                &DesktopObjectNameLength );

    if (!NT_SUCCESS( Status )) {
        return s_strNameNull;
    }

    UserAssert(DesktopObjectNameLength + sizeof(WCHAR) < sizeof(s_strName));

    DesktopObjectName->Name.Buffer[DesktopObjectName->Name.Length / sizeof(WCHAR)] = 0;

    return DesktopObjectName->Name.Buffer;
}

#endif // DBG

typedef struct _CST_THREADS {
    PVOID pParam;
    HANDLE UniqueProcessId;
    UINT  uID;
} CST_THREADS, *PCST_THREADS;

CST_THREADS gCSTParam[CST_MAX_THREADS];

CST_THREADS gCSTRemoteParam[CST_MAX_THREADS];

/***************************************************************************\
* CSTPop
*
* Pops the first available pointer and ID in gCSTParam or gCSTRemoteParam.
*
* History:
* 31-Mar-00 MHamid      Created.
\***************************************************************************/
BOOL CSTPop(PUINT pThreadID, PVOID *pParam, PHANDLE pUniqueProcessId, BOOL bRemoteThreadStack)
{
    UINT i = 0;
    PCST_THREADS pCSTParam = bRemoteThreadStack ? gCSTRemoteParam : gCSTParam;
    CheckCritIn();


    while (i < CST_MAX_THREADS) {
        if (pCSTParam[i].pParam) {
            *pParam = pCSTParam[i].pParam;
            if(NULL != pUniqueProcessId) {
                *pUniqueProcessId =  pCSTParam[i].UniqueProcessId;
            }
            *pThreadID = pCSTParam[i].uID;

            pCSTParam[i].pParam = NULL;
            pCSTParam[i].uID = 0;
            return TRUE;
        }
        i++;
    }
    return FALSE;
}

/***************************************************************************\
* CSTPush
*
* Push pointer (pParam) and ID  in the first empty spot in gCSTParam or gCSTRemoteParam.
*
* History:
* 31-Mar-00 MHamid      Created.
\***************************************************************************/
BOOL CSTPush(UINT uThreadID, PVOID pParam, HANDLE UniqueProcessId, BOOL bRemoteThreadStack)
{
    UINT i=0;
    PCST_THREADS pCSTParam = bRemoteThreadStack ? gCSTRemoteParam : gCSTParam;

    CheckCritIn();

    while (i < CST_MAX_THREADS) {
        if (!pCSTParam[i].pParam) {
            pCSTParam[i].pParam = pParam;
            pCSTParam[i].UniqueProcessId = UniqueProcessId;
            pCSTParam[i].uID = uThreadID;
            return TRUE;
        }
        i++;
    }
    return FALSE;
}

/***************************************************************************\
* CSTCleanupStack
*
* Clean up any items left on gCSTParam or gCSTRemoteParam.
*
* History:
* 20-Aug-00 MSadek      Created.
\***************************************************************************/
void CSTCleanupStack(BOOL bRemoteThreadStack)
{
    UINT uThreadID;
    PVOID pvoid;

    while(CSTPop(&uThreadID, &pvoid, NULL, bRemoteThreadStack)) {
        switch(uThreadID) {
            case CST_RIT:
                    if(((PRIT_INIT)(pvoid))->pRitReadyEvent) {
                    FreeKernelEvent(&((PRIT_INIT)(pvoid))->pRitReadyEvent);
                }
                break;
            case CST_POWER:
                if(((PPOWER_INIT)(pvoid))->pPowerReadyEvent) {
                    FreeKernelEvent(&((PPOWER_INIT)(pvoid))->pPowerReadyEvent);
                }
                break;
        }

    }

}

/***************************************************************************\
* GetRemoteProcessId
*
* Return handle to a remote process where a system thread would
* be created (currently, only for ghost thread).
*
* History:
* 20-Aug-00 MSadek      Created.
\***************************************************************************/
HANDLE GetRemoteProcessId(void)
{
    UINT uThreadID;
    PVOID pInitData;
    HANDLE UniqueProcessId;

    if (!CSTPop(&uThreadID, &pInitData, &UniqueProcessId, TRUE)) {
        return NULL;
    }
    /*
     * We should be here only for ghost thread
     */
    UserAssert(uThreadID == CST_GHOST);

    CSTPush(uThreadID, pInitData, UniqueProcessId, TRUE);

    return UniqueProcessId;
 }

/***************************************************************************\
* HandleSystemThreadCreationFailure
*
* Handles the System thread creation failure
*
* History:
* 1-Oct-00 MSadek      Created.
\***************************************************************************/

void HandleSystemThreadCreationFailure(BOOL bRemoteThread)
{
    UINT uThreadID;
    PVOID pvoid;

    if (!CSTPop(&uThreadID, &pvoid, NULL, bRemoteThread)) {
        return;
    }
    if(uThreadID == CST_POWER) {
        if(((PPOWER_INIT)(pvoid))->pPowerReadyEvent) {
            KeSetEvent(((PPOWER_INIT)(pvoid))->pPowerReadyEvent, EVENT_INCREMENT, FALSE);
        }
    }
}

/***************************************************************************\
* xxxCreateSystemThreads
*
* Call the right thread routine (depending on uThreadID),
* which will wait for its own desired messages.
*
* History:
* 15-Mar-00 MHamid      Created.
\***************************************************************************/
void xxxCreateSystemThreads(BOOL bRemoteThread)
{
    UINT uThreadID;
    PVOID pvoid;

    /*
     * Do not allow any process other than CSRSS to call this function.
     * The only exception is Ghost thread case since now we allow it to launch
     * in the context of the shell process
     */
    if (!bRemoteThread && !ISCSRSS()) {
        RIPMSG0(RIP_WARNING, "xxxCreateSystemThreads get called from a Process other than CSRSS");
        return;
    }

    if (!CSTPop(&uThreadID, &pvoid, NULL, bRemoteThread)) {
        return;
    }

    LeaveCrit();
    switch (uThreadID) {
        case CST_DESKTOP:
            xxxDesktopThread((PTERMINAL)pvoid);
            break;
        case CST_RIT:
            RawInputThread(pvoid);
            break;
        case CST_GHOST:
            GhostThread((PDESKTOP)pvoid);
            break;
       case CST_POWER:
            VideoPortCalloutThread(pvoid);
            break;
    }
    EnterCrit();
}

/***************************************************************************\
* xxxDesktopThread
*
* This thread owns all desktops windows on a windowstation.
* While waiting for messages, it moves the mouse cursor without entering the
* USER critical section.  The RIT does the rest of the mouse input processing.
*
* History:
* 03-Dec-1993 JimA      Created.
\***************************************************************************/

#ifdef LOCK_MOUSE_CODE
#pragma alloc_text(MOUSE, xxxDesktopThread)
#endif

#define OBJECTS_COUNT 3

VOID xxxDesktopThread(
    PTERMINAL pTerm)
{
    KPRIORITY       Priority;
    PTHREADINFO     ptiCurrent;
    PQ              pqOriginal;
    UNICODE_STRING  strThreadName;
    PKEVENT         *apRITEvents;
    PKEVENT         pEvent;
    MSGWAITCALLBACK pfnHidChangeRoutine = NULL;
    DWORD           nEvents = 0;
    UINT            idMouseInput;
    UINT            idDesktopDestroy;
    UINT            idPumpMessages;

    UserAssert(pTerm != NULL);

    /*
     * Set the desktop thread's priority to low realtime.
     */
#ifdef W2K_COMPAT_PRIORITY
    Priority = LOW_REALTIME_PRIORITY;
#else
    Priority = LOW_REALTIME_PRIORITY - 4;
#endif
    ZwSetInformationThread(NtCurrentThread(),
                           ThreadPriority,
                           &Priority,
                           sizeof(KPRIORITY));

    /*
     * There are just two TERMINAL structures. One is for the
     * interactive windowstation and the other is for all the
     * non-interactive windowstations.
     */
    if (pTerm->dwTERMF_Flags & TERMF_NOIO) {
        RtlInitUnicodeString(&strThreadName, L"NOIO_DT");
    } else {
        RtlInitUnicodeString(&strThreadName, L"IO_DT");
    }

    if (!NT_SUCCESS(InitSystemThread(&strThreadName))) {
        pTerm->dwTERMF_Flags |= TERMF_DTINITFAILED;
        KeSetEvent(pTerm->pEventTermInit, EVENT_INCREMENT, FALSE);
        RIPMSG0(RIP_ERROR, "Fail to create the desktop thread");
        return;
    }

    ptiCurrent = PtiCurrentShared();

    pTerm->ptiDesktop = ptiCurrent;
    pTerm->pqDesktop  = pqOriginal = ptiCurrent->pq;

    (pqOriginal->cLockCount)++;
    ptiCurrent->pDeskInfo = &diStatic;

    /*
     * Set the winsta to NULL. It will be set to the right
     * windowstation in xxxCreateDesktop before pEventInputReady
     * is set.
     */
    ptiCurrent->pwinsta = NULL;

    /*
     * Allocate non-paged array.  Include an extra entry for
     * the thread's input event.
     */
    apRITEvents = UserAllocPoolNonPagedNS((OBJECTS_COUNT * sizeof(PKEVENT)),
                                        TAG_SYSTEM);

    if (apRITEvents == NULL) {
        pTerm->dwTERMF_Flags |= TERMF_DTINITFAILED;
        KeSetEvent(pTerm->pEventTermInit, EVENT_INCREMENT, FALSE);
        return;
    }

    idMouseInput     = 0xFFFF;
    idDesktopDestroy = 0xFFFF;

    /*
     * Reference the mouse input event.  The system terminal doesn't
     * wait for any mouse input.
     */
    if (!(pTerm->dwTERMF_Flags & TERMF_NOIO)) {
        pfnHidChangeRoutine = (MSGWAITCALLBACK)ProcessDeviceChanges;
        idMouseInput  = nEvents++;
        UserAssert(aDeviceTemplate[DEVICE_TYPE_MOUSE].pkeHidChange);
        apRITEvents[idMouseInput] = aDeviceTemplate[DEVICE_TYPE_MOUSE].pkeHidChange;
    }

    /*
     * Create the desktop destruction event.
     */
    idDesktopDestroy = nEvents++;
    apRITEvents[idDesktopDestroy] = CreateKernelEvent(SynchronizationEvent, FALSE);
    if (apRITEvents[idDesktopDestroy] == NULL) {
        pTerm->dwTERMF_Flags |= TERMF_DTINITFAILED;
        KeSetEvent(pTerm->pEventTermInit, EVENT_INCREMENT, FALSE);
        UserFreePool(apRITEvents);
        return;
    }
    pTerm->pEventDestroyDesktop = apRITEvents[idDesktopDestroy];

    EnterCrit();
    UserAssert(IsWinEventNotifyDeferredOK());

    /*
     * Set the event that tells the initialization of desktop
     * thread is done.
     */
    pTerm->dwTERMF_Flags |= TERMF_DTINITSUCCESS;
    KeSetEvent(pTerm->pEventTermInit, EVENT_INCREMENT, FALSE);

    /*
     * Prepare to wait on input ready event.
     */
    pEvent = pTerm->pEventInputReady;
    ObReferenceObjectByPointer(pEvent,
                               EVENT_ALL_ACCESS,
                               *ExEventObjectType,
                               KernelMode);

    LeaveCrit();

    KeWaitForSingleObject(pEvent, WrUserRequest, KernelMode, FALSE, NULL);
    ObDereferenceObject(pEvent);

    EnterCrit();

    /*
     * Adjust the event ids
     */
    idMouseInput     += WAIT_OBJECT_0;
    idDesktopDestroy += WAIT_OBJECT_0;
    idPumpMessages    = WAIT_OBJECT_0 + nEvents;

    /*
     * message loop lasts until we get a WM_QUIT message
     * upon which we shall return from the function
     */
    while (TRUE) {
        DWORD result;

        /*
         * Wait for any message sent or posted to this queue, while calling
         * ProcessDeviceChanges whenever the mouse change event (pkeHidChange)
         * is set.
         */
        result = xxxMsgWaitForMultipleObjects(nEvents,
                                              apRITEvents,
                                              pfnHidChangeRoutine,
                                              NULL);

#if DBG
        gDesktopsBusy++; // diagnostic
        if (gDesktopsBusy >= 2) {
            RIPMSG0(RIP_WARNING, "2 or more desktop threads busy");
        }
#endif

        /*
         * result tells us the type of event we have:
         * a message or a signalled handle
         *
         * if there are one or more messages in the queue ...
         */
        if (result == (DWORD)idPumpMessages) {

            /*
             * block-local variable
             */
            MSG msg ;

            CheckCritIn();

            /*
             * read all of the messages in this next loop
             * removing each message as we read it
             */
            while (xxxPeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {

                /*
                 * Instrumentation to catch WindowsBug: 210358
                 * Hydra stress: TRACKING: xxxDesktopThread loops receiving STATUS_USER_APC on xxxMsgWaitForMultipleObject
                 */
                if (msg.message == WM_QUIT && ptiCurrent->cWindows > 1) {
                    FRE_RIPMSG2(RIP_ERROR, "xxxDesktopThread: WM_QUIT received when %d windows around for pti=%p",
                                ptiCurrent->cWindows, ptiCurrent);
                }
                /*
                 * if it's a quit message we're out of here
                 */
                if (msg.message == WM_QUIT && ptiCurrent->cWindows <= 1) {

                    TRACE_DESKTOP(("WM_QUIT: Destroying the desktop thread. cWindows %d\n",
                                   ptiCurrent->cWindows));

                    HYDRA_HINT(HH_DTQUITRECEIVED);

                    /*
                     * The window station is gone, so
                     *
                     *      DON'T USE PWINSTA ANYMORE
                     */

                    /*
                     * We could have received a mouse message in between the
                     * desktop destroy event and the WM_QUIT message in which
                     * case we may need to clear spwndTrack again to make sure
                     * that a window (gotta be the desktop) isn't locked in.
                     */
                    Unlock(&ptiCurrent->rpdesk->spwndTrack);

#ifdef BUG365290
                    if (ptiCurrent->rpdesk != NULL) {
                        ULONG ResultLength = 0;
                        grpdeskTerminate = ptiCurrent->rpdesk;
                        ObQueryNameString(ptiCurrent->rpdesk, (POBJECT_NAME_INFORMATION)gTerminateDesktopName, sizeof(gTerminateDesktopName), &ResultLength);
                    }
#endif // BUG365290
                    /*
                     * If we're running on the last interactive desktop,
                     *  then we never unlocked pdesk->pDeskInfo->spwnd.
                     * However, it seems to me that the system stops
                     *  running before we make it here; otherwise, (or
                     *  for a Hydra-like thing) we need to unlock that
                     *  window here.....
                     */
                    UserAssert(ptiCurrent->rpdesk != NULL &&
                               ptiCurrent->rpdesk->pDeskInfo != NULL);
                    if (ptiCurrent->rpdesk->pDeskInfo->spwnd != NULL) {
                        Unlock(&ptiCurrent->rpdesk->pDeskInfo->spwnd);
#ifdef BUG365290
                        ptiCurrent->rpdesk->dwDTFlags |= DF_QUITUNLOCK;
#endif // BUG365290
                    }

                    /*
                     * Because there is no desktop, we need to fake a
                     * desktop info structure so that the IsHooked()
                     * macro can test a "valid" fsHooks value.
                     */
                    ptiCurrent->pDeskInfo = &diStatic;

                    /*
                     * The desktop window is all that's left, so
                     * let's exit.  The thread cleanup code will
                     * handle destruction of the window.
                     */

                    /*
                     * If the thread is not using the original queue,
                     * destroy it.
                     */
                    UserAssert(pqOriginal->cLockCount);
                    (pqOriginal->cLockCount)--;
                    if (ptiCurrent->pq != pqOriginal) {
                        zzzDestroyQueue(pqOriginal, ptiCurrent); // DeferWinEventNotify() ?? IANJA ??
                    }

#if DBG
                    gDesktopsBusy--; // diagnostic
#endif

                    LeaveCrit();

                    /*
                     * Deref the events now that we're done with them.
                     * Also free the wait array.
                     */
                    FreeKernelEvent(&apRITEvents[idDesktopDestroy]);
                    UserFreePool(apRITEvents);
#ifdef BUG365290
                    pTerm->ptiDesktopTemp = pTerm->ptiDesktop;
#endif // BUG365290

                    pTerm->ptiDesktop = NULL;
                    pTerm->pqDesktop  = NULL;

                    pTerm->dwTERMF_Flags |= TERMF_DTDESTROYED;

                    /*
                     * Terminate the thread by just return. Since we are
                     * now a user thread.
                     */
                    return;
                } else if(msg.message == WM_DESKTOPNOTIFY) {
                    switch(msg.wParam)
                    {
                    case DESKTOP_RELOADWALLPAPER:
                        {
                            TL tlName;
                            PUNICODE_STRING pProfileUserName = CreateProfileUserName(&tlName);
                            xxxSetDeskWallpaper(pProfileUserName, SETWALLPAPER_METRICS);
                            FreeProfileUserName(pProfileUserName, &tlName);
                        }
                        break;

                    default:
                        RIPMSG1(RIP_WARNING, "WM_DESKTOPNOTIFY received with unrecognized wParam:%x\n", msg.wParam);
                        break;
                    }
                    continue;
                }

                UserAssert(msg.message != WM_QUIT);

                /*
                 * otherwise dispatch it
                 */
                xxxDispatchMessage(&msg);

            } // end of PeekMessage while loop

        } else if (result == idDesktopDestroy) {

            PDESKTOP        *ppdesk;
            PDESKTOP        pdesk;
            PWND            pwnd;
            PMENU           pmenu;
            TL              tlpwinsta;
            PWINDOWSTATION  pwinsta;
            TL              tlpdesk;
            TL              tlpwnd;
            PDESKTOP        pdeskTemp;
            HDESK           hdeskTemp;
            TL              tlpdeskTemp;

            /*
             * Destroy desktops on the destruction list.
             */
            for (ppdesk = &pTerm->rpdeskDestroy; *ppdesk != NULL; ) {
                /*
                 * Unlink from the list.
                 */
                pdesk = *ppdesk;

                TRACE_DESKTOP(("Destroying desktop '%ws' %#p ...\n",
                       GetDesktopName(pdesk), pdesk));

                UserAssert(!(pdesk->dwDTFlags & DF_DYING));

                ThreadLockDesktop(ptiCurrent, pdesk, &tlpdesk, LDLT_FN_DESKTOPTHREAD_DESK);
                pwinsta = pdesk->rpwinstaParent;
                ThreadLockWinSta(ptiCurrent, pdesk->rpwinstaParent, &tlpwinsta);

                LockDesktop(ppdesk, pdesk->rpdeskNext, LDL_TERM_DESKDESTROY1, (ULONG_PTR)pTerm);
                UnlockDesktop(&pdesk->rpdeskNext, LDU_DESK_DESKNEXT, 0);

                /*
                 * !!! If this is the current desktop, switch to another one.
                 */
                if (pdesk == grpdeskRitInput) {
                    PDESKTOP pdeskNew;

                    TRACE_DESKTOP(("Destroying the current active desktop\n"));
#ifdef BUG365290
                        pdesk->dwDTFlags |= DF_ACTIVEONDESTROY;
#endif // BUG365290

                    if (pwinsta->dwWSF_Flags & WSF_SWITCHLOCK) {

                        TRACE_DESKTOP(("The windowstation is locked\n"));

                        /*
                         * this should be the interactive windowstation
                         */
#ifdef BUG365290
                        if (pwinsta->dwWSF_Flags & WSF_NOIO) {
                            FRE_RIPMSG1(RIP_ERROR, "xxxDesktopThread: grpdeskRitInput on non-IO windowstation = %p", grpdeskRitInput);
                        }
#else // !BUG365290
                        UserAssert(!(pwinsta->dwWSF_Flags & WSF_NOIO));
#endif // BUG365290
                        /*
                         * Switch to the disconnected desktop if the logon desktop
                         * is being destroyed, or there is no logon desktop, or
                         * if the logon desktop has already been destroyed.
                         */
                        if (gspdeskDisconnect &&
                             (pdesk == grpdeskLogon ||
                              grpdeskLogon == NULL  ||
                              (grpdeskLogon->dwDTFlags & DF_DESKWNDDESTROYED))) {
                            TRACE_DESKTOP(("disable the screen and switch to the disconnect desktop\n"));
#ifdef BUG365290
                            pdesk->dwDTFlags |= DF_SKIPSWITCHDESKTOP;
#endif // BUG365290
                            RemoteDisableScreen();
                            goto skip;

                        } else {
                            TRACE_DESKTOP(("Switch to the logon desktop '%ws' %#p ...\n",
                                   GetDesktopName(grpdeskLogon), grpdeskLogon));

                            pdeskNew = grpdeskLogon;
                        }
                    } else {
                        pdeskNew = pwinsta->rpdeskList;
                        if (pdeskNew == pdesk)
                            pdeskNew = pdesk->rpdeskNext;

                        /*
                         * You can hit this if you exit winlogon before
                         * logging in.  I.E. all desktop's close so there is
                         * no "next" one to switch to.  I'm assuming that there
                         * is a check for a NULL desktop in xxxSwitchDesktop().
                         *
                         * You can't switch to a NULL desktop.  But this means
                         * there isn't any input desktop so clear it manually.
                         */
                        if (pdeskNew == NULL) {

                            TRACE_DESKTOP(("NO INPUT FOR DT FROM THIS POINT ON ...\n"));

                            ClearWakeBit(ptiCurrent, QS_INPUT | QS_EVENT | QS_MOUSEMOVE, FALSE);

#ifdef BUG365290
                            pdesk->dwDTFlags |= DF_DTNONEWDESKTOP;
#endif // BUG365290
                        }
                    }

                    TRACE_DESKTOP(("Switch to desktop '%ws' %#p\n",
                           GetDesktopName(pdeskNew), pdeskNew));

                    xxxSwitchDesktop(pwinsta, pdeskNew, 0);
                }
skip:

                /*
                 * Close the display if this desktop did not use
                 * the global display.
                 */
                if ((pdesk->pDispInfo->hDev != NULL) &&
                    (pdesk->pDispInfo->hDev != gpDispInfo->hDev)) {

                    TRACE_DESKTOP(("Destroy MDEV\n"));

                    DrvDestroyMDEV(pdesk->pDispInfo->pmdev);
                    GreFreePool(pdesk->pDispInfo->pmdev);
                    pdesk->pDispInfo->pmdev = NULL;
                }

                if (pdesk->pDispInfo != gpDispInfo) {
                    UserAssert(pdesk->pDispInfo->pMonitorFirst == NULL);
                    UserFreePool(pdesk->pDispInfo);
                    pdesk->pDispInfo = NULL;
                }


#ifdef BUG365290
                /*
                 * Makes sure the IO desktop thread is running on the active destkop.
                */
                if (!(pTerm->dwTERMF_Flags & TERMF_NOIO) && (ptiCurrent->rpdesk != grpdeskRitInput)) {
                    FRE_RIPMSG0(RIP_ERROR, "xxxDesktopThread: desktop thread not originally on grpdeskRitInput");
                }
#endif // BUG365290

                pdeskTemp = ptiCurrent->rpdesk;            // save current desktop
                hdeskTemp = ptiCurrent->hdesk;
                ThreadLockDesktop(ptiCurrent, pdeskTemp, &tlpdeskTemp, LDLT_FN_DESKTOPTHREAD_DESKTEMP);
                xxxSetThreadDesktop(NULL, pdesk);
                Unlock(&pdesk->spwndForeground);
                Unlock(&pdesk->spwndTray);

                /*
                 * Destroy desktop and menu windows.
                 */
                Unlock(&pdesk->spwndTrack);
                pdesk->dwDTFlags &= ~DF_MOUSEMOVETRK;

                if (pdesk->spmenuSys != NULL) {
                    pmenu = pdesk->spmenuSys;
                    if (UnlockDesktopSysMenu(&pdesk->spmenuSys))
                        _DestroyMenu(pmenu);
                }

                if (pdesk->spmenuDialogSys != NULL) {
                    pmenu = pdesk->spmenuDialogSys;
                    if (UnlockDesktopSysMenu(&pdesk->spmenuDialogSys))
                        _DestroyMenu(pmenu);
                }

                if (pdesk->spmenuHScroll != NULL) {
                    pmenu = pdesk->spmenuHScroll;
                    if (UnlockDesktopMenu(&pdesk->spmenuHScroll))
                        _DestroyMenu(pmenu);
                }

                if (pdesk->spmenuVScroll != NULL) {
                    pmenu = pdesk->spmenuVScroll;
                    if (UnlockDesktopMenu(&pdesk->spmenuVScroll))
                        _DestroyMenu(pmenu);
                }

                /*
                 * If this desktop doesn't have a pDeskInfo, then
                 * something is wrong.  All desktops should have
                 * this until the object is freed.
                 */
                if (pdesk->pDeskInfo == NULL) {
                    RIPMSG0(RIP_ERROR,
                          "xxxDesktopThread: There is no pDeskInfo for this desktop");
                }

                if (pdesk->pDeskInfo) {
                    if (pdesk->pDeskInfo->spwnd == gspwndFullScreen)
                        Unlock(&gspwndFullScreen);

                    if (pdesk->pDeskInfo->spwndShell)
                        Unlock(&pdesk->pDeskInfo->spwndShell);

                    if (pdesk->pDeskInfo->spwndBkGnd)
                        Unlock(&pdesk->pDeskInfo->spwndBkGnd);

                    if (pdesk->pDeskInfo->spwndTaskman)
                        Unlock(&pdesk->pDeskInfo->spwndTaskman);

                    if (pdesk->pDeskInfo->spwndProgman)
                        Unlock(&pdesk->pDeskInfo->spwndProgman);
                }

                UserAssert(!(pdesk->dwDTFlags & DF_DYING));

                if (pdesk->spwndMenu != NULL) {

                    pwnd = pdesk->spwndMenu;

                    /*
                     * Hide this window without activating anyone else.
                     */
                    if (TestWF(pwnd, WFVISIBLE)) {
                        ThreadLockAlwaysWithPti(ptiCurrent, pwnd, &tlpwnd);
                        xxxSetWindowPos(pwnd,
                                        NULL,
                                        0,
                                        0,
                                        0,
                                        0,
                                        SWP_HIDEWINDOW | SWP_NOACTIVATE |
                                            SWP_NOMOVE | SWP_NOSIZE |
                                            SWP_NOZORDER | SWP_NOREDRAW |
                                            SWP_NOSENDCHANGING);

                        ThreadUnlock(&tlpwnd);
                    }

                    /*
                     * Reset the flag in the popupmenu structure that tells this
                     * popup menu belongs to the pdesk->spwndMenu so it can go away.
                     */
                    ((PMENUWND)pwnd)->ppopupmenu->fDesktopMenu = FALSE;
                    ((PMENUWND)pwnd)->ppopupmenu->fDelayedFree = FALSE;
                    #if DBG
                        /* We used to zero out this popup when closing the menu.
                         * now we zero it out when about to re-use it.
                         * So make ValidatepPopupMenu happy by clearing the
                         * leftover ppopupmenuRoot, if any.
                         */
                        ((PMENUWND)pwnd)->ppopupmenu->ppopupmenuRoot = NULL;
                    #endif

                    if (Unlock(&pdesk->spwndMenu)) {
                        xxxDestroyWindow(pwnd);
                    }
                }

                if (pdesk->spwndMessage != NULL) {

                    pwnd = pdesk->spwndMessage;

                    if (Unlock(&pdesk->spwndMessage)) {
                        xxxDestroyWindow(pwnd);
                    }
                }

                if (pdesk->spwndTooltip != NULL) {

                    pwnd = pdesk->spwndTooltip;

                    if (Unlock(&pdesk->spwndTooltip)) {
                        xxxDestroyWindow(pwnd);
                    }
                    UserAssert(!(pdesk->dwDTFlags & DF_TOOLTIPSHOWING));
                }

                UserAssert(!(pdesk->dwDTFlags & DF_DYING));

                /*
                 * If the dying desktop is the owner of the desktop
                 * owner window, reassign it to the first available
                 * desktop.  This is needed to ensure that
                 * xxxSetWindowPos will work on desktop windows.
                 */
                if (pTerm->spwndDesktopOwner != NULL &&
                    pTerm->spwndDesktopOwner->head.rpdesk == pdesk) {

                    PDESKTOP pdeskR;

                    /*
                     * Find out to what desktop the mother desktop window
                     * should go. Careful with the NOIO case where there
                     * might be several windowstations using the same
                     * mother desktop window
                     */
                    if (pTerm->dwTERMF_Flags & TERMF_NOIO) {

                        PWINDOWSTATION pwinstaW;

                        pdeskR = NULL;

                        CheckCritIn();

                        if (grpWinStaList) {

                            pwinstaW = grpWinStaList->rpwinstaNext;

                            while (pwinstaW != NULL) {
                                if (pwinstaW->rpdeskList != NULL) {
                                    pdeskR = pwinstaW->rpdeskList;
                                    break;
                                }
                                pwinstaW = pwinstaW->rpwinstaNext;
                            }
                        }

                    } else {
                        pdeskR = pwinsta->rpdeskList;
                    }

                    if (pdeskR == NULL) {

                        PWND pwnd;

                        TRACE_DESKTOP(("DESTROYING THE MOTHER DESKTOP WINDOW %#p\n",
                                pTerm->spwndDesktopOwner));

                        pwnd = pTerm->spwndDesktopOwner;

                        /*
                         * Hide it first
                         */
                        SetVisible(pwnd, SV_UNSET);

                        Unlock(&(pTerm->spwndDesktopOwner));

                        xxxDestroyWindow(pwnd);

                    } else {
                        TRACE_DESKTOP(("MOVING THE MOTHER DESKTOP WINDOW %#p to pdesk %#p '%ws'\n",
                                pTerm->spwndDesktopOwner, pdeskR, GetDesktopName(pdeskR)));

                        LockDesktop(&(pTerm->spwndDesktopOwner->head.rpdesk),
                                    pdeskR, LDL_MOTHERDESK_DESK1, (ULONG_PTR)(pTerm->spwndDesktopOwner));
                    }
                }

                if (pdesk->pDeskInfo && (pdesk->pDeskInfo->spwnd != NULL)) {

                    UserAssert(!(pdesk->dwDTFlags & DF_DESKWNDDESTROYED));

                    pwnd = pdesk->pDeskInfo->spwnd;

                    /*
                     * Hide this window without activating anyone else.
                     */
                    if (TestWF(pwnd, WFVISIBLE)) {
                        ThreadLockAlwaysWithPti(ptiCurrent, pwnd, &tlpwnd);
                        xxxSetWindowPos(pwnd,
                                        NULL,
                                        0,
                                        0,
                                        0,
                                        0,
                                        SWP_HIDEWINDOW | SWP_NOACTIVATE |
                                            SWP_NOMOVE | SWP_NOSIZE |
                                            SWP_NOZORDER | SWP_NOREDRAW |
                                            SWP_NOSENDCHANGING);

                        ThreadUnlock(&tlpwnd);
                    }

                    /*
                     * A lot of pwnd related code assumes that we
                     *  always have a valid desktop window. So we call
                     *  xxxDestroyWindow first to clean up and then
                     *  we unlock it to free it (now or eventually).
                     * However, if we're destroying the last destkop, then
                     *  we don't unlock the window since we're are forced
                     *  to continue running on that desktop.
                     */

                    TRACE_DESKTOP(("Destroying the desktop window\n"));

                    xxxDestroyWindow(pdesk->pDeskInfo->spwnd);
                    if (pdesk != grpdeskRitInput) {
                        Unlock(&pdesk->pDeskInfo->spwnd);
#ifdef BUG365290
                        pdesk->dwDTFlags |= DF_NOTRITUNLOCK;
#endif // BUG365290

                    } else {
#ifdef BUG365290
                        pdesk->dwDTFlags |= DF_ZOMBIE;
#endif // BUG365290

                        /*
                         * unlock the gspwndShouldBeForeground window
                         */
                        if (ISTS() && gspwndShouldBeForeground != NULL) {
                            Unlock(&gspwndShouldBeForeground);
                        }

                        /*
                         * This is hit in HYDRA when the last desktop does away
                         */
                        RIPMSG1(RIP_WARNING, "xxxDesktopThread: Running on zombie desk:%#p", pdesk);
                    }
                    pdesk->dwDTFlags |= DF_DESKWNDDESTROYED;
                }

                /*
                 * Restore the previous desktop.
                 *
                 * In NOIO sessions, if pdeskTemp is destroyed, don't bother switching
                 * back to it since it'll fail (and assert) latter in zzzSetDesktop
                 */
                if (!(pTerm->dwTERMF_Flags & TERMF_NOIO) ||
                    !(pdeskTemp->dwDTFlags & (DF_DESKWNDDESTROYED | DF_DYING))) {

                    xxxSetThreadDesktop(hdeskTemp, pdeskTemp);
                }

#ifdef BUG365290
                /*
                 * Makes sure the IO desktop thread is running on the active destkop.
                */
                if (!(pTerm->dwTERMF_Flags & TERMF_NOIO) && (ptiCurrent->rpdesk != grpdeskRitInput)) {
                    FRE_RIPMSG0(RIP_ERROR, "xxxDesktopThread: desktop thread not back on grpdeskRitInput");
                }
#endif // BUG365290

                ThreadUnlockDesktop(ptiCurrent, &tlpdeskTemp, LDUT_FN_DESKTOPTHREAD_DESKTEMP);
                ThreadUnlockWinSta(ptiCurrent, &tlpwinsta);
                ThreadUnlockDesktop(ptiCurrent, &tlpdesk, LDUT_FN_DESKTOPTHREAD_DESK);
            }

            /*
             * Wakeup ntinput thread for exit processing
             */
            TRACE_DESKTOP(("Wakeup ntinput thread for exit processing\n"));

            UserAssert(gpevtDesktopDestroyed != NULL);

            KeSetEvent(gpevtDesktopDestroyed, EVENT_INCREMENT, FALSE);

        } else if ((NTSTATUS)result == STATUS_USER_APC) {
            /*
             * Instrumentation to catch WindowsBug: 210358
             * Hydra stress: TRACKING: xxxDesktopThread loops receiving STATUS_USER_APC on xxxMsgWaitForMultipleObject
             */
            FRE_RIPMSG1(RIP_ERROR, "xxxDesktopThread: received STATUS_USER_APC for pti=%p", ptiCurrent);
            /*
             * Perhaps we should repost WM_QUIT to myself?
             */
        } else {
            RIPMSG1(RIP_ERROR, "Desktop woke up for what? status=%08x", result);
        }

#if DBG
        gDesktopsBusy--; // diagnostic
#endif
    }
}

/***************************************************************************\
* xxxRealizeDesktop
*
* 4/28/97   vadimg      created
\***************************************************************************/

VOID xxxRealizeDesktop(PWND pwnd)
{
    CheckLock(pwnd);
    UserAssert(GETFNID(pwnd) == FNID_DESKTOP);

    if (ghpalWallpaper) {
        HDC hdc = _GetDC(pwnd);
        xxxInternalPaintDesktop(pwnd, hdc, FALSE);
        _ReleaseDC(hdc);
    }
}

/***************************************************************************\
* xxxDesktopWndProc
*
* History:
* 23-Oct-1990 DarrinM   Ported from Win 3.0 sources.
* 08-Aug-1996 jparsons  51725 - added fix to prevent crash on WM_SETICON
\***************************************************************************/

LRESULT xxxDesktopWndProc(
    PWND   pwnd,
    UINT   message,
    WPARAM wParam,
    LPARAM lParam)
{
    PTHREADINFO ptiCurrent = PtiCurrent();
    HDC         hdcT;
    PAINTSTRUCT ps;
    PWINDOWPOS  pwp;


    CheckLock(pwnd);
    UserAssert(IsWinEventNotifyDeferredOK());

    VALIDATECLASSANDSIZE(pwnd, message, wParam, lParam, FNID_DESKTOP, WM_CREATE);


    if (pwnd->spwndParent == NULL) {
        switch (message) {

            case WM_SETICON:
                /*
                 * cannot allow this as it will cause a callback to user mode from the
                 * desktop system thread.
                 */
                RIPMSG0(RIP_WARNING, "WM_ICON sent to desktop window was discarded.\n") ;
                return 0L ;

            default:
                break;
        } /* switch */

        return xxxDefWindowProc(pwnd, message, wParam, lParam);
    }

    switch (message) {

    case WM_WINDOWPOSCHANGING:

        /*
         * We receive this when switch desktop is called.  Just
         * to be consistent, set the rit desktop as this
         * thread's desktop.
         */
        pwp = (PWINDOWPOS)lParam;
        if (!(pwp->flags & SWP_NOZORDER) && pwp->hwndInsertAfter == HWND_TOP) {

            xxxSetThreadDesktop(NULL, grpdeskRitInput);

            /*
             * If some app has taken over the system-palette, we should make
             * sure the system is restored.  Otherwise, if this is the logon
             * desktop, we might not be able to view the dialog correctly.
             */
            if (GreGetSystemPaletteUse(gpDispInfo->hdcScreen) != SYSPAL_STATIC)
                GreRealizeDefaultPalette(gpDispInfo->hdcScreen, TRUE);

            /*
             * Let everyone know if the palette has changed
             */
            if (grpdeskRitInput->dwDTFlags & DTF_NEEDSPALETTECHANGED) {
                xxxSendNotifyMessage(PWND_BROADCAST,
                                     WM_PALETTECHANGED,
                                     (WPARAM)HWq(pwnd),
                                     0);
                grpdeskRitInput->dwDTFlags &= ~DTF_NEEDSPALETTECHANGED;
            }
        }
        break;

    case WM_FULLSCREEN: {
            TL tlpwndT;

            ThreadLockWithPti(ptiCurrent, grpdeskRitInput->pDeskInfo->spwnd, &tlpwndT);
            xxxMakeWindowForegroundWithState(
                    grpdeskRitInput->pDeskInfo->spwnd, GDIFULLSCREEN);
            ThreadUnlock(&tlpwndT);

            /*
             * We have to tell the switch window to repaint if we switched
             * modes
             */
            if (gspwndAltTab != NULL) {
                ThreadLockAlwaysWithPti(ptiCurrent, gspwndAltTab, &tlpwndT);
                xxxSendMessage(gspwndAltTab, WM_FULLSCREEN, 0, 0);
                ThreadUnlock(&tlpwndT);
            }

            break;
        }

    case WM_CLOSE:

        /*
         * Make sure nobody sends this window a WM_CLOSE and causes it to
         * destroy itself.
         */
        break;

    case WM_SETICON:
        /*
         * cannot allow this as it will cause a callback to user mode from the
         * desktop system thread.
         */
        RIPMSG0(RIP_WARNING, "WM_ICON sent to desktop window was discarded.\n") ;
        break;

    case WM_CREATE: {
        TL tlName;
        PUNICODE_STRING pProfileUserName = CreateProfileUserName(&tlName);
        /*
         * Is there a desktop pattern, or bitmap name in WIN.INI?
         */
        xxxSetDeskPattern(pProfileUserName, (LPWSTR)-1, TRUE);

        FreeProfileUserName(pProfileUserName, &tlName);
        /*
         * Initialize the system colors before we show the desktop window.
         */
        xxxSendNotifyMessage(pwnd, WM_SYSCOLORCHANGE, 0, 0L);

        hdcT = _GetDC(pwnd);
        xxxInternalPaintDesktop(pwnd, hdcT, FALSE); // use "normal" HDC so SelectPalette() will work
        _ReleaseDC(hdcT);

        /*
         * Save process and thread ids.
         */
        xxxSetWindowLong(pwnd,
                         0,
                         HandleToUlong(PsGetCurrentProcessId()),
                         FALSE);

        xxxSetWindowLong(pwnd,
                         4,
                         HandleToUlong(PsGetCurrentThreadId()),
                         FALSE);
        break;
    }
    case WM_PALETTECHANGED:
        if (HWq(pwnd) == (HWND)wParam)
            break;

        // FALL THROUGH

    case WM_QUERYNEWPALETTE:
        xxxRealizeDesktop(pwnd);
        break;

    case WM_SYSCOLORCHANGE:

        /*
         * We do the redrawing if someone has changed the sys-colors from
         * another desktop and we need to redraw.  This is appearent with
         * the MATROX card which requires OGL applications to take over
         * the entire sys-colors for drawing.  When switching desktops, we
         * never broadcast the WM_SYSCOLORCHANGE event to tell us to redraw
         * This is only a DAYTONA related fix, and should be removed once
         * we move the SYSMETS to a per-desktop state.
         *
         * 05-03-95 : ChrisWil.
         */
        xxxRedrawWindow(pwnd,
                        NULL,
                        NULL,
                        RDW_INVALIDATE | RDW_ALLCHILDREN | RDW_ERASE);
        break;

    case WM_ERASEBKGND:
        hdcT = (HDC)wParam;
        xxxInternalPaintDesktop(pwnd, hdcT, TRUE);
        return TRUE;

    case WM_PAINT:
        xxxBeginPaint(pwnd, (LPPAINTSTRUCT)&ps);
        xxxEndPaint(pwnd, (LPPAINTSTRUCT)&ps);
        break;

#ifdef HUNGAPP_GHOSTING
    case WM_HUNGTHREAD:
        {
            PWND pwnd = RevalidateHwnd((HWND)lParam);

            if (pwnd != NULL && FHungApp(GETPTI(pwnd), CMSHUNGAPPTIMEOUT)) {
                TL tlpwnd;

                pwnd = GetTopLevelWindow(pwnd);

                ThreadLockAlways(pwnd, &tlpwnd);
                xxxCreateGhost(pwnd);
                ThreadUnlock(&tlpwnd);
            }
            break;
        }

    case WM_SCANGHOST:
        if(gpEventScanGhosts) {
            KeSetEvent(gpEventScanGhosts, EVENT_INCREMENT, FALSE);
        }
        break;

#endif // HUNGAPP_GHOSTING
    case WM_CREATETRAILTIMER:
        if (GETMOUSETRAILS() && !gtmridMouseTrails) {

            gtmridMouseTrails = InternalSetTimer(NULL, gtmridMouseTrails, 1000 / MOUSE_TRAILS_FREQ, HideMouseTrails, TMRF_RIT);
        }
        break;

    case WM_LBUTTONDBLCLK:
        message = WM_SYSCOMMAND;
        wParam = SC_TASKLIST;

        /*
         *** FALL THRU **
         */

    default:
        return xxxDefWindowProc(pwnd, message, wParam, lParam);
    }

    return 0L;
}

/***************************************************************************\
* SetDeskPattern
*
* NOTE: the lpszPattern parameter is new for Win 3.1.
*
* History:
* 23-Oct-1990 DarrinM   Created stub.
* 22-Apr-1991 DarrinM   Ported code from Win 3.1 sources.
\***************************************************************************/

BOOL xxxSetDeskPattern(PUNICODE_STRING pProfileUserName,
    LPWSTR   lpszPattern,
    BOOL     fCreation)
{
    LPWSTR p;
    int    i;
    UINT   val;
    WCHAR  wszNone[20];
    WCHAR  wchValue[MAX_PATH];
    WORD   rgBits[CXYDESKPATTERN];
    HBRUSH hBrushTemp;

    CheckCritIn();

    /*
     * Get rid of the old bitmap (if any).
     */
    if (ghbmDesktop != NULL) {
        GreDeleteObject(ghbmDesktop);
        ghbmDesktop = NULL;
    }

    /*
     * Check if a pattern is passed via lpszPattern.
     */
    if (lpszPattern != (LPWSTR)LongToPtr( (LONG)-1 )) {

        /*
         * Yes! Then use that pattern;
         */
        p = lpszPattern;
        goto GotThePattern;
    }

    /*
     * Else, pickup the pattern selected in WIN.INI.
     * Get the "DeskPattern" string from WIN.INI's [Desktop] section.
     */
    if (!FastGetProfileStringFromIDW(pProfileUserName,
                                     PMAP_DESKTOP,
                                     STR_DESKPATTERN,
                                     TEXT(""),
                                     wchValue,
                                     sizeof(wchValue)/sizeof(WCHAR),
                                     0
                                     )) {
        return FALSE;
    }

    ServerLoadString(hModuleWin,
                     STR_NONE,
                     wszNone,
                     sizeof(wszNone)/sizeof(WCHAR));

    p = wchValue;

GotThePattern:

    /*
     * Was a Desk Pattern selected?
     */
    if (*p == TEXT('\0') || _wcsicmp(p, wszNone) == 0) {
        hBrushTemp = GreCreateSolidBrush(SYSRGB(DESKTOP));
        if (hBrushTemp != NULL) {
            if (SYSHBR(DESKTOP)) {
                GreMarkDeletableBrush(SYSHBR(DESKTOP));
                GreDeleteObject(SYSHBR(DESKTOP));
            }
            GreMarkUndeletableBrush(hBrushTemp);
            SYSHBR(DESKTOP) = hBrushTemp;
        }
        GreSetBrushOwnerPublic(hBrushTemp);
        goto SDPExit;
    }

    /*
     * Get eight groups of numbers seprated by non-numeric characters.
     */
    for (i = 0; i < CXYDESKPATTERN; i++) {
        val = 0;

        /*
         * Skip over any non-numeric characters, check for null EVERY time.
         */
        while (*p && !(*p >= TEXT('0') && *p <= TEXT('9')))
            p++;

        /*
         * Get the next series of digits.
         */
        while (*p >= TEXT('0') && *p <= TEXT('9'))
            val = val * (UINT)10 + (UINT)(*p++ - TEXT('0'));

        rgBits[i] = (WORD)val;
    }

    ghbmDesktop = GreCreateBitmap(CXYDESKPATTERN,
                                  CXYDESKPATTERN,
                                  1,
                                  1,
                                  (LPBYTE)rgBits);

    if (ghbmDesktop == NULL)
        return FALSE;

    GreSetBitmapOwner(ghbmDesktop, OBJECT_OWNER_PUBLIC);

    RecolorDeskPattern();

SDPExit:
    if (!fCreation) {

        /*
         * Notify everyone that the colors have changed.
         */
        xxxSendNotifyMessage(PWND_BROADCAST, WM_SYSCOLORCHANGE, 0, 0L);

        /*
         * Update the entire screen.  If this is creation, don't update: the
         * screen hasn't drawn, and also there are some things that aren't
         * initialized yet.
         */
        xxxRedrawScreen();
    }

    return TRUE;
}

/***************************************************************************\
* RecolorDeskPattern
*
* Remakes the desktop pattern (if it exists) so that it uses the new
* system colors.
*
* History:
* 22-Apr-1991 DarrinM   Ported from Win 3.1 sources.
\***************************************************************************/

VOID RecolorDeskPattern(VOID)
{
    HBITMAP hbmOldDesk;
    HBITMAP hbmOldMem;
    HBITMAP hbmMem;
    HBRUSH  hBrushTemp;
    if (ghbmDesktop == NULL)
        return;

    /*
     * Redo the desktop pattern in the new colors.
     */

    if (hbmOldDesk = GreSelectBitmap(ghdcMem, ghbmDesktop)) {

        if (!SYSMET(SAMEDISPLAYFORMAT)) {

            BYTE bmi[sizeof(BITMAPINFOHEADER)+sizeof(RGBQUAD)*2];
            PBITMAPINFO pbmi = (PBITMAPINFO) &bmi;

            pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
            pbmi->bmiHeader.biWidth = CXYDESKPATTERN;
            pbmi->bmiHeader.biHeight = CXYDESKPATTERN;
            pbmi->bmiHeader.biPlanes = 1;
            pbmi->bmiHeader.biBitCount = 1;
            pbmi->bmiHeader.biCompression = BI_RGB;
            pbmi->bmiHeader.biSizeImage = 0;
            pbmi->bmiHeader.biXPelsPerMeter = 0;
            pbmi->bmiHeader.biYPelsPerMeter = 0;
            pbmi->bmiHeader.biClrUsed = 2;
            pbmi->bmiHeader.biClrImportant = 2;

            pbmi->bmiColors[0].rgbBlue  = (BYTE)((SYSRGB(DESKTOP) >> 16) & 0xff);
            pbmi->bmiColors[0].rgbGreen = (BYTE)((SYSRGB(DESKTOP) >>  8) & 0xff);
            pbmi->bmiColors[0].rgbRed   = (BYTE)((SYSRGB(DESKTOP)      ) & 0xff);

            pbmi->bmiColors[1].rgbBlue  = (BYTE)((SYSRGB(WINDOWTEXT) >> 16) & 0xff);
            pbmi->bmiColors[1].rgbGreen = (BYTE)((SYSRGB(WINDOWTEXT) >>  8) & 0xff);
            pbmi->bmiColors[1].rgbRed   = (BYTE)((SYSRGB(WINDOWTEXT)      ) & 0xff);

            hbmMem = GreCreateDIBitmapReal(
               HDCBITS(), 0, NULL,
               pbmi,DIB_RGB_COLORS,sizeof(bmi),0,
               NULL,0,NULL,0,0, NULL);

        } else {

            hbmMem = GreCreateCompatibleBitmap(
               HDCBITS(), CXYDESKPATTERN, CXYDESKPATTERN);
        }

        if (hbmMem) {

            if (hbmOldMem = GreSelectBitmap(ghdcMem2, hbmMem)) {

                GreSetTextColor(ghdcMem2, SYSRGB(DESKTOP));
                GreSetBkColor(ghdcMem2, SYSRGB(WINDOWTEXT));

                GreBitBlt(ghdcMem2,
                          0,
                          0,
                          CXYDESKPATTERN,
                          CXYDESKPATTERN,
                          ghdcMem,
                          0,
                          0,
                          SRCCOPY,
                          0);

                if (hBrushTemp = GreCreatePatternBrush(hbmMem)) {

                    if (SYSHBR(DESKTOP) != NULL) {
                        GreMarkDeletableBrush(SYSHBR(DESKTOP));
                        GreDeleteObject(SYSHBR(DESKTOP));
                    }

                    GreMarkUndeletableBrush(hBrushTemp);
                    SYSHBR(DESKTOP) = hBrushTemp;
                }

                GreSetBrushOwnerPublic(hBrushTemp);
                GreSelectBitmap(ghdcMem2, hbmOldMem);
            }

            GreDeleteObject(hbmMem);
        }

        GreSelectBitmap(ghdcMem, hbmOldDesk);
    }
}

/***************************************************************************\
* xxxCreateDesktop (API)
*
* Create a new desktop object
*
* History:
* 16-Jan-1991 JimA      Created scaffold code.
* 11-Feb-1991 JimA      Added access checks.
\***************************************************************************/

NTSTATUS xxxCreateDesktop2(
    PWINDOWSTATION   pwinsta,
    PACCESS_STATE    pAccessState,
    KPROCESSOR_MODE  AccessMode,
    PUNICODE_STRING  pstrName,
    PDESKTOP_CONTEXT Context,
    PVOID            *pObject)
{
    LUID              luidCaller;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PEPROCESS         Process;
    PDESKTOP          pdesk;
    PDESKTOPINFO      pdi;
    ULONG             ulHeapSize;
    NTSTATUS          Status;
    BOOLEAN MemoryAllocated;
    PSECURITY_DESCRIPTOR SecurityDescriptor;


    CheckCritIn();

    /*
     * If this is a desktop creation, make sure
     * that the windowstation grants create access.
     */
    if (!ObCheckCreateObjectAccess(
            pwinsta,
            WINSTA_CREATEDESKTOP,
            pAccessState,
            pstrName,
            TRUE,
            AccessMode,
            &Status)) {

        return Status;
    }
    /*
     * Fail if the windowstation is locked
     */
    Process = PsGetCurrentProcess();

    if (pwinsta->dwWSF_Flags & WSF_OPENLOCK &&
            PsGetProcessId(Process) != gpidLogon) {

        /*
         * If logoff is occuring and the caller does not
         * belong to the session that is ending, allow the
         * open to proceed.
         */
        Status = GetProcessLuid(NULL, &luidCaller);

        if (!NT_SUCCESS(Status) ||
                !(pwinsta->dwWSF_Flags & WSF_SHUTDOWN) ||
                RtlEqualLuid(&luidCaller, &pwinsta->luidEndSession)) {
            return STATUS_DEVICE_BUSY;
        }
    }

    /*
     * If a devmode has been specified, we also must be able
     * to switch desktops.
     */
    if (Context->lpDevMode != NULL && (pwinsta->dwWSF_Flags & WSF_OPENLOCK) &&
            PsGetProcessId(Process) != gpidLogon) {
        return STATUS_DEVICE_BUSY;
    }

    /*
     * Allocate the new object
     */
    InitializeObjectAttributes(&ObjectAttributes, pstrName, 0, NULL, NULL);
    Status = ObCreateObject(
            KernelMode,
            *ExDesktopObjectType,
            &ObjectAttributes,
            UserMode,
            NULL,
            sizeof(DESKTOP),
            0,
            0,
            &pdesk);
    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "xxxCreateDesktop2: ObCreateObject failed with Status 0x%x",
                Status);
        return Status;
    }

    RtlZeroMemory(pdesk, sizeof(DESKTOP));

    /*
     * Store the session id of the session who created the desktop
     */
    pdesk->dwSessionId = gSessionId;

    /*
     * Fetch the parents security descriptor
     */
    Status = ObGetObjectSecurity(pwinsta,
                                 &SecurityDescriptor,
                                 &MemoryAllocated);

    if (!NT_SUCCESS(Status))
        goto Error;

    /*
     * Create security descriptor
     */
    Status = ObAssignSecurity(
            pAccessState,
            SecurityDescriptor,
            pdesk,
            *ExDesktopObjectType);

    ObReleaseObjectSecurity (SecurityDescriptor,
                             MemoryAllocated);

    if (!NT_SUCCESS(Status))
        goto Error;

    /*
     * Set up desktop heap.  The first desktop (logon desktop) uses a
     * small heap (128).
     */
    if (!(pwinsta->dwWSF_Flags & WSF_NOIO) && (pwinsta->rpdeskList == NULL)) {
        ulHeapSize = 128;
#ifdef _WIN64
        /*
         * Increase heap size 50% for Win64 to allow for larger structures.
         */
        ulHeapSize = (ulHeapSize * 3) / 2;
#endif
    } else {
        if (pwinsta->dwWSF_Flags & WSF_NOIO) {
            ulHeapSize = gdwNOIOSectionSize;
        } else {

            /*
             * The disconnected desktop should be small also.
             */
            if (gspdeskDisconnect == NULL) {
                ulHeapSize = 64;
#ifdef _WIN64
                /*
                 * Increase heap size 50% for Win64 to allow for larger structures.
                 */
                 ulHeapSize = (ulHeapSize * 3) / 2;
#endif
            } else {
                ulHeapSize = gdwDesktopSectionSize;
            }
        }
    }

    ulHeapSize *= 1024;
    /*
     * Create the desktop heap.
     */
    pdesk->hsectionDesktop = CreateDesktopHeap(&pdesk->pheapDesktop, ulHeapSize);
    if (pdesk->hsectionDesktop == NULL) {
        RIPMSG1(RIP_WARNING, "xxxCreateDesktop: CreateDesktopHeap failed for pdesk %#p",
                pdesk);
        goto ErrorOutOfMemory;
    }

    if (pwinsta->rpdeskList == NULL || (pwinsta->dwWSF_Flags & WSF_NOIO)) {

        /*
         * The first desktop or invisible desktops must also
         * use the default settings.  This is because specifying
         * the devmode causes a desktop switch, which must be
         * avoided in this case.
         */
        Context->lpDevMode = NULL;
    }

    /*
     * Allocate desktopinfo
     */
    pdi = (PDESKTOPINFO)DesktopAlloc(pdesk, sizeof(DESKTOPINFO), DTAG_DESKTOPINFO);
    if (pdi == NULL) {
        RIPMSG0(RIP_WARNING, "xxxCreateDesktop: failed DeskInfo Alloc");
        goto ErrorOutOfMemory;
    }

    /*
     * Initialize everything.
     */
    pdesk->pDeskInfo = pdi;
    InitializeListHead(&pdesk->PtiList);

    /*
     * If a DEVMODE or another device name is passed in, then use that
     * information.
     * Otherwise use the default information (gpDispInfo).
     */

    if (Context->lpDevMode) {

        BOOL  bDisabled = FALSE;
        PMDEV pmdev = NULL;
        LONG  ChangeStat = GRE_DISP_CHANGE_FAILED;

        /*
         * Allocate a display-info for this device.
         */
        pdesk->pDispInfo = (PDISPLAYINFO)UserAllocPoolZInit(
                sizeof(DISPLAYINFO), TAG_DISPLAYINFO);

        if (!pdesk->pDispInfo) {
            RIPMSG1(RIP_WARNING, "xxxCreateDesktop: failed to allocate pDispInfo for pdesk %#p",
                    pdesk);
            goto ErrorOutOfMemory;
        }

        if ((bDisabled = SafeDisableMDEV()) == TRUE) {
            ChangeStat = DrvChangeDisplaySettings(Context->pstrDevice,
                                                  NULL,
                                                  Context->lpDevMode,
                                                  LongToPtr( gdwDesktopId ),
                                                  UserMode,
                                                  FALSE,
                                                  TRUE,
                                                  NULL,
                                                  &pmdev,
                                                  GRE_DEFAULT,
                                                  FALSE);
        }

        if (ChangeStat != GRE_DISP_CHANGE_SUCCESSFUL) {

            if (bDisabled) {
                SafeEnableMDEV();
            }

            //
            // If there is a failure, then repaint the whole screen.
            //

            RIPMSG1(RIP_WARNING, "xxxCreateDesktop2 callback for pdesk %#p !",
                    pdesk);

            xxxUserResetDisplayDevice();

            Status = STATUS_UNSUCCESSFUL;
            goto Error;
        }

        pdesk->pDispInfo->hDev  = pmdev->hdevParent;
        pdesk->pDispInfo->pmdev = pmdev;
        pdesk->dwDesktopId      = gdwDesktopId++;

        CopyRect(&pdesk->pDispInfo->rcScreen, &gpDispInfo->rcScreen);
        pdesk->pDispInfo->dmLogPixels = gpDispInfo->dmLogPixels;

        pdesk->pDispInfo->pMonitorFirst = NULL;
        pdesk->pDispInfo->pMonitorPrimary = NULL;

    } else {

        pdesk->pDispInfo   = gpDispInfo;
        pdesk->dwDesktopId = GW_DESKTOP_ID;

    }

    /*
     * Heap is HEAP_ZERO_MEMORY, so we should be zero-initialized already.
     */
    UserAssert(pdi->pvwplShellHook == NULL);

    pdi->pvDesktopBase  = Win32HeapGetHandle(pdesk->pheapDesktop);
    pdi->pvDesktopLimit = (PBYTE)pdi->pvDesktopBase + ulHeapSize;

    /*
     * Reference the parent windowstation
     */
    LockWinSta(&(pdesk->rpwinstaParent), pwinsta);

    /*
     * Link the desktop into the windowstation list
     */
    if (pwinsta->rpdeskList == NULL) {

        if (!(pwinsta->dwWSF_Flags & WSF_NOIO))
            LockDesktop(&grpdeskLogon, pdesk, LDL_DESKLOGON, 0);
        /*
         * Make the first desktop the "owner" of the top
         * desktop window.  This is needed to ensure that
         * xxxSetWindowPos will work on desktop windows.
         */
        LockDesktop(&(pwinsta->pTerm->spwndDesktopOwner->head.rpdesk),
                    pdesk, LDL_MOTHERDESK_DESK2, (ULONG_PTR)(pwinsta->pTerm->spwndDesktopOwner));
    }


    LockDesktop(&pdesk->rpdeskNext, pwinsta->rpdeskList, LDL_DESK_DESKNEXT1, (ULONG_PTR)pwinsta);
    LockDesktop(&pwinsta->rpdeskList, pdesk, LDL_WINSTA_DESKLIST1, (ULONG_PTR)pwinsta);

    /*
     * Mask off invalid access bits
     */
    if (pAccessState->RemainingDesiredAccess & MAXIMUM_ALLOWED) {
        pAccessState->RemainingDesiredAccess &= ~MAXIMUM_ALLOWED;
        pAccessState->RemainingDesiredAccess |= GENERIC_ALL;
    }

    RtlMapGenericMask( &pAccessState->RemainingDesiredAccess, (PGENERIC_MAPPING)&DesktopMapping);
    pAccessState->RemainingDesiredAccess &=
            (DesktopMapping.GenericAll | ACCESS_SYSTEM_SECURITY);

    *pObject = pdesk;

    /*
     * Add the desktop to the global list of desktops in this win32k.
     * This is HYDRA only
     */
    DbgTrackAddDesktop(pdesk);

    return STATUS_SUCCESS;

ErrorOutOfMemory:
    Status = STATUS_NO_MEMORY;
    // fall-through

Error:
    LogDesktop(pdesk, LD_DEREF_FN_2CREATEDESKTOP, FALSE, 0);
    ObDereferenceObject(pdesk);

    UserAssert(!NT_SUCCESS(Status));

    return Status;
}

BOOL xxxCreateDisconnectDesktop(
    HWINSTA        hwinsta,
    PWINDOWSTATION pwinsta)
{
    UNICODE_STRING      strDesktop;
    OBJECT_ATTRIBUTES   oa;
    HDESK               hdeskDisconnect;
    HRGN                hrgn;
    NTSTATUS            Status;

    /*
     * Create the empty clipping region for the disconnect desktop.
     */

    if ((hrgn = CreateEmptyRgnPublic()) == NULL) {
       RIPMSG0(RIP_WARNING, "Creation of empty region for Disconnect Desktop failed ");
       return FALSE;
    }

    /*
     * If not created yet, then create the Disconnected desktop
     * (used when WinStation is disconnected), and lock the desktop
     * and desktop window to ensure they never get deleted.
     */
    RtlInitUnicodeString(&strDesktop, TEXT("Disconnect"));
    InitializeObjectAttributes(&oa, &strDesktop,
            OBJ_OPENIF | OBJ_CASE_INSENSITIVE, hwinsta, NULL);

    hdeskDisconnect = xxxCreateDesktop(&oa, KernelMode,
            NULL, NULL, 0, MAXIMUM_ALLOWED);

    if (hdeskDisconnect == NULL) {
        RIPMSG0(RIP_WARNING, "Could not create Disconnect desktop");
        GreDeleteObject(hrgn);
        return FALSE;
    }

    /*
     * Set the disconnect desktop security.
     * Keep around an extra reference to the disconnect desktop from
     * the CSR so it will stay around even if winlogon exits.
     */

    Status = SetDisconnectDesktopSecurity(hdeskDisconnect);

    if (NT_SUCCESS(Status)) {
        Status = ObReferenceObjectByHandle(hdeskDisconnect,
                                           0,
                                           NULL,
                                           KernelMode,
                                           &gspdeskDisconnect,
                                           NULL);
    }
    if (!NT_SUCCESS(Status)) {

        RIPMSG1(RIP_WARNING, "Disconnect Desktop reference failed 0x%x", Status);

        GreDeleteObject(hrgn);
        xxxCloseDesktop(hdeskDisconnect, KernelMode);
        gspdeskDisconnect = NULL;
        return FALSE;
    }

    LogDesktop(gspdeskDisconnect, LDL_DESKDISCONNECT, TRUE, 0);

    /*
     * Set the region of the desktop window to be (0, 0, 0, 0) so
     * that there is no hittesting going on the 'disconnect' desktop
     * But prior to session the null region, we need to null the pointer
     * to the existing shared region so that it doesn't get deleted.
     */

    UserAssert(gspdeskDisconnect->pDeskInfo != NULL);

    gspdeskDisconnect->pDeskInfo->spwnd->hrgnClip = hrgn;


    KeAttachProcess(PsGetProcessPcb(gpepCSRSS));

    Status = ObOpenObjectByPointer(
                 gspdeskDisconnect,
                 0,
                 NULL,
                 EVENT_ALL_ACCESS,
                 NULL,
                 KernelMode,
                 &ghDisconnectDesk);

    if (NT_SUCCESS(Status)) {

        Status = ObOpenObjectByPointer(
                     pwinsta,
                     0,
                     NULL,
                     EVENT_ALL_ACCESS,
                     NULL,
                     KernelMode,
                     &ghDisconnectWinSta);
    }

    KeDetachProcess();

    if (!NT_SUCCESS(Status)) {

        RIPMSG0(RIP_WARNING, "Could not create Disconnect desktop");

        GreDeleteObject(hrgn);
        gspdeskDisconnect->pDeskInfo->spwnd->hrgnClip = NULL;

        if (ghDisconnectDesk != NULL) {
            CloseProtectedHandle(ghDisconnectDesk);
            ghDisconnectDesk = NULL;
        }

        xxxCloseDesktop(hdeskDisconnect, KernelMode);
        return FALSE;
    }

    /*
     * Don't want to do alot of paints if we disconnected before this.
     */
    if (!gbConnected) {
        RIPMSG0(RIP_WARNING,
            "RemoteDisconnect was issued during CreateDesktop(\"Winlogon\"...");
    }

    return TRUE;
}

VOID CleanupDirtyDesktops(
    VOID)
{
    PWINDOWSTATION pwinsta;
    PDESKTOP*      ppdesk;

    CheckCritIn();

    for (pwinsta = grpWinStaList; pwinsta != NULL; pwinsta = pwinsta->rpwinstaNext) {

        ppdesk = &pwinsta->rpdeskList;

        while (*ppdesk != NULL) {

            if (!((*ppdesk)->dwDTFlags & DF_DESKCREATED)) {
                RIPMSG1(RIP_WARNING, "Desktop %#p in a dirty state", *ppdesk);

                if (grpdeskLogon == *ppdesk) {
                    UnlockDesktop(&grpdeskLogon, LDU_DESKLOGON, 0);
                }

                if (pwinsta->pTerm->spwndDesktopOwner &&
                    pwinsta->pTerm->spwndDesktopOwner->head.rpdesk == *ppdesk) {

                    UnlockDesktop(&(pwinsta->pTerm->spwndDesktopOwner->head.rpdesk),
                                  LDU_MOTHERDESK_DESK, (ULONG_PTR)(pwinsta->pTerm->spwndDesktopOwner));
                }

                LockDesktop(ppdesk, (*ppdesk)->rpdeskNext, LDL_WINSTA_DESKLIST1, (ULONG_PTR)pwinsta);
            } else {
                ppdesk = &(*ppdesk)->rpdeskNext;
            }
        }
    }
}

HDESK xxxCreateDesktop(
    POBJECT_ATTRIBUTES ccxObjectAttributes,
    KPROCESSOR_MODE    ProbeMode,
    PUNICODE_STRING    ccxpstrDevice,
    LPDEVMODE          ccxlpdevmode,
    DWORD              dwFlags,
    DWORD              dwDesiredAccess)
{
    HWINSTA         hwinsta;
    HDESK           hdesk;
    DESKTOP_CONTEXT Context;
    PDESKTOP        pdesk;
    PDESKTOPINFO    pdi;
    PWINDOWSTATION  pwinsta;
    PDESKTOP        pdeskTemp;
    HDESK           hdeskTemp;
    PWND            pwndDesktop = NULL;
    PWND            pwndMessage = NULL;
    PWND            pwndTooltip = NULL;
    PWND            pwndMenu = NULL;
    TL              tlpwnd;
    PTHREADINFO     ptiCurrent = PtiCurrent();
    BOOL            fWasNull;
    BOOL            bSuccess;
    PPROCESSINFO    ppi;
    PPROCESSINFO    ppiSave;
    PTERMINAL       pTerm;
    NTSTATUS        Status;
    DWORD           dwDisableHooks;

#if DBG
    /*
     * Too many jumps in this function to use BEGIN/ENDATOMICHCECK
     */
    DWORD dwCritSecUseSave = gdwCritSecUseCount;
#endif

    CheckCritIn();

    UserAssert(IsWinEventNotifyDeferredOK());

    /*
     * Capture directory handle and check for create access.
     */
    try {
        hwinsta = ccxObjectAttributes->RootDirectory;
    } except (W32ExceptionHandler(TRUE, RIP_WARNING)) {
        return NULL;
    }
    if (hwinsta != NULL) {
        Status = ObReferenceObjectByHandle(
                hwinsta,
                WINSTA_CREATEDESKTOP,
                *ExWindowStationObjectType,
                ProbeMode,
                &pwinsta,
                NULL);
        if (NT_SUCCESS(Status)) {
            ObDereferenceObject(pwinsta);
        } else {
            RIPNTERR0(Status, RIP_VERBOSE, "ObReferenceObjectByHandle Failed");
            return NULL;
        }
    }

    /*
     * Set up creation context
     */
    Context.lpDevMode  = ccxlpdevmode;
    Context.pstrDevice = ccxpstrDevice;
    Context.dwFlags    = dwFlags;

    /*
     * Create the desktop -- the object manager uses try blocks
     */
    Status = ObOpenObjectByName(
            ccxObjectAttributes,
            *ExDesktopObjectType,
            ProbeMode,
            NULL,
            dwDesiredAccess,
            &Context,
            &hdesk);

    if (!NT_SUCCESS(Status)) {

        RIPNTERR1(Status,
                  RIP_WARNING,
                  "xxxCreateDesktop: ObOpenObjectByName failed with Status 0x%x",
                  Status);

        /*
         * Cleanup desktop objects that were created in xxxCreateDesktop2
         * but later on the Ob manager failed the creation for other
         * reasons (ex: no quota)
         */
        CleanupDirtyDesktops();

        return NULL;
    }

    /*
     * If the desktop already exists, we're done.  This will only happen
     * if OBJ_OPENIF was specified.
     */
    if (Status == STATUS_OBJECT_NAME_EXISTS) {
        SetHandleFlag(hdesk, HF_PROTECTED, TRUE);
        RIPMSG0(RIP_WARNING, "xxxCreateDesktop: Object name exists");
        return hdesk;
    }

    /*
     * Reference the desktop to finish initialization
     */
    Status = ObReferenceObjectByHandle(
            hdesk,
            0,
            *ExDesktopObjectType,
            KernelMode,
            &pdesk,
            NULL);
    if (!NT_SUCCESS(Status)) {
        RIPNTERR0(Status, RIP_VERBOSE, "");
        CloseProtectedHandle(hdesk);
        return NULL;
    }

    /*
     * We're going to mark the desktop menu as being in use here. That way,
     * we'll *never* try to use it. This is because the code has problems, and
     * this approach (circumventing the code) is deemed safer than simply
     * removing it. Windows Bug #314157.
     */
    pdesk->dwDTFlags |= DF_DESKCREATED | DF_MENUINUSE;

    LogDesktop(pdesk, LD_REF_FN_CREATEDESKTOP, TRUE, (ULONG_PTR)PtiCurrent());

    pwinsta = pdesk->rpwinstaParent;
    pTerm   = pwinsta->pTerm;
    pdi = pdesk->pDeskInfo;

    pdi->ppiShellProcess = NULL;

    /*
     * If the desktop was not mapped in as a result of the open,
     * fail.
     */
    ppi = PpiCurrent();
    if (GetDesktopView(ppi, pdesk) == NULL) {

        /*
         * Desktop mapping failed.
         */
        CloseProtectedHandle(hdesk);

        LogDesktop(pdesk, LD_DEREF_FN_CREATEDESKTOP1, FALSE, (ULONG_PTR)PtiCurrent());

        ObDereferenceObject(pdesk);
        RIPNTERR0(STATUS_ACCESS_DENIED, RIP_WARNING, "Desktop mapping failed");
        return NULL;
    }

    if (gpepCSRSS != NULL) {
        /*
         * Map the desktop into CSRSS to ensure that the
         * hard error handler can get access.
         */
        {
            WIN32_OPENMETHOD_PARAMETERS OpenParams;

            OpenParams.OpenReason = ObOpenHandle;
            OpenParams.Process = gpepCSRSS;
            OpenParams.Object = pdesk;
            OpenParams.GrantedAccess = 0;
            OpenParams.HandleCount = 1;

            if (!NT_SUCCESS(MapDesktop(&OpenParams))) {
                /*
                 * Desktop mapping failed.
                 */
                CloseProtectedHandle(hdesk);

                LogDesktop(pdesk, LD_DEREF_FN_CREATEDESKTOP2, FALSE, (ULONG_PTR)PtiCurrent());

                ObDereferenceObject(pdesk);
                RIPNTERR0(STATUS_ACCESS_DENIED, RIP_WARNING, "Desktop mapping failed (2)");
                return NULL;
            }
        }

        UserAssert(GetDesktopView(PpiFromProcess(gpepCSRSS), pdesk) != NULL);
    }

    /*
     * Set hook flags
     */
    SetHandleFlag(hdesk, HF_DESKTOPHOOK, dwFlags & DF_ALLOWOTHERACCOUNTHOOK);

    /*
     * Set up to create the desktop window.
     */
    fWasNull = (ptiCurrent->ppi->rpdeskStartup == NULL);
    pdeskTemp = ptiCurrent->rpdesk;            // save current desktop
    hdeskTemp = ptiCurrent->hdesk;

    /*
     * Switch ppi values so window will be created using the
     * system's desktop window class.
     */
    ppiSave  = ptiCurrent->ppi;
    ptiCurrent->ppi = pTerm->ptiDesktop->ppi;

    DeferWinEventNotify();
    BeginAtomicCheck();

    zzzSetDesktop(ptiCurrent, pdesk, hdesk);

    /*
     * Create the desktop window
     */
    /*
     * HACK HACK HACK!!! (adams) In order to create the desktop window
     * with the correct desktop, we set the desktop of the current thread
     * to the new desktop. But in so doing we allow hooks on the current
     * thread to also hook this new desktop. This is bad, because we don't
     * want the desktop window to be hooked while it is created. So we
     * temporarily disable hooks of the current thread and its desktop,
     * and reenable them after switching back to the original desktop.
     */

    dwDisableHooks = ptiCurrent->TIF_flags & TIF_DISABLEHOOKS;
    ptiCurrent->TIF_flags |= TIF_DISABLEHOOKS;

    pwndDesktop = xxxNVCreateWindowEx(
            (DWORD)0,
            (PLARGE_STRING)DESKTOPCLASS,
            NULL,
            (WS_POPUP | WS_CLIPCHILDREN),
            pdesk->pDispInfo->rcScreen.left,
            pdesk->pDispInfo->rcScreen.top,
            pdesk->pDispInfo->rcScreen.right - pdesk->pDispInfo->rcScreen.left,
            pdesk->pDispInfo->rcScreen.bottom - pdesk->pDispInfo->rcScreen.top,
            NULL,
            NULL,
            hModuleWin,
            NULL,
            VER31);

    if (pwndDesktop == NULL) {
        RIPMSG1(RIP_WARNING,
                "xxxCreateDesktop: Failed to create the desktop window for pdesk %#p",
                pdesk);
        goto Error;
    }

    /*
     * NOTE: In order for the message window to be created without
     * the desktop as it's owner, it needs to be created before
     * setting pdi->spwnd to the desktop window. This is a complete
     * hack and should be fixed.
     */
    pwndMessage = xxxNVCreateWindowEx(
            (DWORD)0,
            (PLARGE_STRING)gatomMessage,
            NULL,
            (WS_POPUP | WS_CLIPCHILDREN),
            0,
            0,
            100,
            100,
            NULL,
            NULL,
            hModuleWin,
            NULL,
            VER31);

    if (pwndMessage == NULL) {
        RIPMSG0(RIP_WARNING, "xxxCreateDesktop: Failed to create the message window");
        goto Error;
    }
    /*
     * NOTE: Remember what window class this window belongs to.
     * Since the message window does not have its own window proc
     * (they use xxxDefWindowProc) we have to do it here.
     */
    pwndMessage->fnid = FNID_MESSAGEWND;

    UserAssert(pdi->spwnd == NULL);

    Lock(&(pdi->spwnd), pwndDesktop);

    SetFullScreen(pwndDesktop, GDIFULLSCREEN);

    /*
     * set this windows to the fullscreen window if we don't have one yet
     */

    /*
     * Don't set gspwndFullScreen if fGdiEnabled has been cleared
     * (we may be in the middle of a disconnect).
     */
    UserAssert(fGdiEnabled == TRUE);

    if (gspwndFullScreen == NULL && !(pwinsta->dwWSF_Flags & WSF_NOIO)) {
        Lock(&(gspwndFullScreen), pwndDesktop);
    }

    /*
     * NT Bug 388747: Link the message window to the mother desktop window
     * so that it properly has a parent.  We will do this before we link the
     * desktop window just so the initial message window appears after the
     * initial desktop window (a minor optimization, but not necessary).
     */
    Lock(&pwndMessage->spwndParent, pTerm->spwndDesktopOwner);
    LinkWindow(pwndMessage, NULL, pTerm->spwndDesktopOwner);
    Lock(&pdesk->spwndMessage, pwndMessage);
    Unlock(&pwndMessage->spwndOwner);

    /*
     * Link it as a child but don't use WS_CHILD style
     */
    LinkWindow(pwndDesktop, NULL, pTerm->spwndDesktopOwner);
    Lock(&pwndDesktop->spwndParent, pTerm->spwndDesktopOwner);
    Unlock(&pwndDesktop->spwndOwner);

    /*
     * Make it regional if it's display configuration is regional.
     */
    if (!pdesk->pDispInfo->fDesktopIsRect) {
        pwndDesktop->hrgnClip = pdesk->pDispInfo->hrgnScreen;
    }

    /*
     * Create shared menu window and tooltip window
     */
    ThreadLock(pdesk->spwndMessage, &tlpwnd);

    /*
     * Create the tooltip window only for desktops in
     * interactive windowstations.
     */
    if (!(pwinsta->dwWSF_Flags & WSF_NOIO)) {
        pwndTooltip = xxxNVCreateWindowEx(
                WS_EX_TOOLWINDOW | WS_EX_TOPMOST,
                (PLARGE_STRING)TOOLTIPCLASS,
                NULL,
                WS_POPUP | WS_BORDER,
                0,
                0,
                100,
                100,
                pdesk->spwndMessage,
                NULL,
                hModuleWin,
                NULL,
                VER31);


        if (pwndTooltip == NULL) {
            ThreadUnlock(&tlpwnd);
            RIPMSG0(RIP_WARNING, "xxxCreateDesktop: Failed to create the tooltip window");
            goto Error;
        }

        Lock(&pdesk->spwndTooltip, pwndTooltip);
    }

    pwndMenu = xxxNVCreateWindowEx(
            WS_EX_TOOLWINDOW | WS_EX_DLGMODALFRAME | WS_EX_WINDOWEDGE,
            (PLARGE_STRING)MENUCLASS,
            NULL,
            WS_POPUP | WS_BORDER,
            0,
            0,
            100,
            100,
            pdesk->spwndMessage,
            NULL,
            hModuleWin,
            NULL,
            WINVER);

    ThreadUnlock(&tlpwnd);

    if (pwndMenu == NULL) {
        RIPMSG0(RIP_WARNING, "xxxCreateDesktop: Failed to create the menu window");
        goto Error;
    }

    Lock(&(pdesk->spwndMenu), pwndMenu);

    /*
     * Set the flag in the popupmenu structure that tells this
     * popup menu belongs to the pdesk->spwndMenu
     */
    ((PMENUWND)pdesk->spwndMenu)->ppopupmenu->fDesktopMenu = TRUE;
    /*
     * Unlock spwndPopupMenu since the menu is not in use but mainly
     *  so we won't have to special case this later when the menu is used.
     */
    Unlock(&((PMENUWND)pdesk->spwndMenu)->ppopupmenu->spwndPopupMenu);

    HMChangeOwnerThread(pdi->spwnd, pTerm->ptiDesktop);
    HMChangeOwnerThread(pwndMessage, pTerm->ptiDesktop);
    HMChangeOwnerThread(pdesk->spwndMenu, pTerm->ptiDesktop);

    if (!(pwinsta->dwWSF_Flags & WSF_NOIO)) {
        HMChangeOwnerThread(pwndTooltip, pTerm->ptiDesktop);
    }

    /*
     * Restore caller's ppi
     */
    PtiCurrent()->ppi = ppiSave;

    /*
     * HACK HACK HACK (adams): Renable hooks.
     */
    UserAssert(ptiCurrent->TIF_flags & TIF_DISABLEHOOKS);
    ptiCurrent->TIF_flags = (ptiCurrent->TIF_flags & ~TIF_DISABLEHOOKS) | dwDisableHooks;

    /*
     * Restore the previous desktop
     */
    zzzSetDesktop(ptiCurrent, pdeskTemp, hdeskTemp);

    EndAtomicCheck();
    UserAssert(dwCritSecUseSave == gdwCritSecUseCount);
    zzzEndDeferWinEventNotify();

    /*
     * If this is the first desktop, let the worker threads run now
     * that there is someplace to send input to.  Reassign the event
     * to handle desktop destruction.
     */
    if (pTerm->pEventInputReady != NULL) {

        /*
         * Set the windowstation for RIT and desktop thread
         * so when EventInputReady is signaled the RIT and the desktop
         * will have a windowstation.
         */
        if (!(pTerm->dwTERMF_Flags & TERMF_NOIO)) {
            gptiRit->pwinsta = pwinsta;
        } else {
            /*
             * let the desktop thread of the system terminal have
             * a rpdesk.
             */
            zzzSetDesktop(pTerm->ptiDesktop, pdesk, NULL);
        }

        pTerm->ptiDesktop->pwinsta = pwinsta;

        KeSetEvent(pTerm->pEventInputReady, EVENT_INCREMENT, FALSE);

        if (!(pTerm->dwTERMF_Flags & TERMF_NOIO)) {

            LeaveCrit();
            while (grpdeskRitInput == NULL) {
                UserSleep(20);
                RIPMSG0(RIP_WARNING, "Waiting for grpdeskRitInput to be set ...");
            }
            EnterCrit();
        }

        ObDereferenceObject(pTerm->pEventInputReady);
        pTerm->pEventInputReady = NULL;
    }


    /*
     * HACK HACK:
     * LATER
     *
     * If we have a devmode passed in, then switch desktops ...
     */

    if (ccxlpdevmode) {

        TRACE_INIT(("xxxCreateDesktop: about to call switch desktop\n"));

        bSuccess = xxxSwitchDesktop(pwinsta, pdesk, SDF_CREATENEW);
        UserAssertMsg1(bSuccess,
                       "Failed to switch desktop 0x%p on create", pdesk);
    } else if (pTerm == &gTermIO){
        UserAssert(grpdeskRitInput != NULL);

        /*
         * Force the window to the bottom of the z-order if there
         * is an active desktop so any drawing done on the desktop
         * window will not be seen.  This will also allow
         * IsWindowVisible to work for apps on invisible
         * desktops.
         */
        ThreadLockWithPti(ptiCurrent, pwndDesktop, &tlpwnd);
        xxxSetWindowPos(pwndDesktop, PWND_BOTTOM, 0, 0, 0, 0,
                    SWP_SHOWWINDOW | SWP_NOACTIVATE | SWP_NOMOVE |
                    SWP_NOREDRAW | SWP_NOSIZE | SWP_NOSENDCHANGING);
        ThreadUnlock(&tlpwnd);
    }

    /*
     * If it was null when we came in, make it null going out, or else
     * we'll have the wrong desktop selected into this.
     */
    if (fWasNull)
        UnlockDesktop(&ptiCurrent->ppi->rpdeskStartup,
                      LDU_PPI_DESKSTARTUP1, (ULONG_PTR)(ptiCurrent->ppi));

    /*
     * Create the disconnect desktop for the console session too.
     */

    if (gspdeskDisconnect == NULL && pdesk == grpdeskLogon) {
        UserAssert(hdesk != NULL);

        /*
         * Create the 'disconnect' desktop
         */
        if (!xxxCreateDisconnectDesktop(hwinsta, pwinsta)) {
            RIPMSG0(RIP_WARNING, "Failed to create the 'disconnect' desktop");

            LogDesktop(pdesk, LD_DEREF_FN_CREATEDESKTOP3, FALSE, (ULONG_PTR)PtiCurrent());
            ObDereferenceObject(pdesk);

            xxxCloseDesktop(hdesk, KernelMode);

            return NULL;
        }

        /*
         * Signal that the disconnect desktop got created.
         */
        KeSetEvent(gpEventDiconnectDesktop, EVENT_INCREMENT, FALSE);

        HYDRA_HINT(HH_DISCONNECTDESKTOP);
    }

Cleanup:

    LogDesktop(pdesk, LD_DEREF_FN_CREATEDESKTOP3, FALSE, (ULONG_PTR)PtiCurrent());
    ObDereferenceObject(pdesk);

    TRACE_INIT(("xxxCreateDesktop: Leaving\n"));

    if (hdesk != NULL) {
        SetHandleFlag(hdesk, HF_PROTECTED, TRUE);
    }
    return hdesk;

Error:

    EndAtomicCheck();
    UserAssert(dwCritSecUseSave == gdwCritSecUseCount);

    UserAssert(pwndMenu == NULL);

    if (pwndTooltip != NULL) {
        xxxDestroyWindow(pwndTooltip);
        Unlock(&pdesk->spwndTooltip);
    }
    if (pwndMessage != NULL) {
        xxxDestroyWindow(pwndMessage);
        Unlock(&pdesk->spwndMessage);
    }
    if (pwndDesktop != NULL) {
        xxxDestroyWindow(pwndDesktop);
        Unlock(&pdi->spwnd);
        Unlock(&gspwndFullScreen);
    }
    /*
     * Restore caller's ppi
     */
    PtiCurrent()->ppi = ppiSave;

    UserAssert(ptiCurrent->TIF_flags & TIF_DISABLEHOOKS);
    ptiCurrent->TIF_flags = (ptiCurrent->TIF_flags & ~TIF_DISABLEHOOKS) | dwDisableHooks;
    zzzSetDesktop(ptiCurrent, pdeskTemp, hdeskTemp);

    CloseProtectedHandle(hdesk);
    hdesk = NULL;

    zzzEndDeferWinEventNotify();

    /*
     * If it was null when we came in, make it null going out, or else
     * we'll have the wrong desktop selected into this.
     */
    if (fWasNull)
        UnlockDesktop(&ptiCurrent->ppi->rpdeskStartup,
                      LDU_PPI_DESKSTARTUP1, (ULONG_PTR)(ptiCurrent->ppi));

    goto Cleanup;

}

/***************************************************************************\
* ParseDesktop
*
* Parse a desktop path.
*
* History:
* 14-Jun-1995 JimA      Created.
\***************************************************************************/
NTSTATUS ParseDesktop(
    PVOID                        pContainerObject,
    POBJECT_TYPE                 pObjectType,
    PACCESS_STATE                pAccessState,
    KPROCESSOR_MODE              AccessMode,
    ULONG                        Attributes,
    PUNICODE_STRING              pstrCompleteName,
    PUNICODE_STRING              pstrRemainingName,
    PVOID                        Context,
    PSECURITY_QUALITY_OF_SERVICE pqos,
    PVOID                        *pObject)
{
    PWINDOWSTATION  pwinsta = pContainerObject;
    PDESKTOP        pdesk;
    PUNICODE_STRING pstrName;
    NTSTATUS        Status = STATUS_OBJECT_NAME_NOT_FOUND;

    *pObject = NULL;

    BEGIN_REENTERCRIT();

    UserAssert(OBJECT_TO_OBJECT_HEADER(pContainerObject)->Type == *ExWindowStationObjectType);
    UserAssert(pObjectType == *ExDesktopObjectType);

    /*
     * See if the desktop exists
     */
    for (pdesk = pwinsta->rpdeskList; pdesk != NULL; pdesk = pdesk->rpdeskNext) {
        pstrName = POBJECT_NAME(pdesk);
        if (pstrName && RtlEqualUnicodeString(pstrRemainingName, pstrName,
                (BOOLEAN)((Attributes & OBJ_CASE_INSENSITIVE) != 0))) {
            if (Context != NULL) {
                if (!(Attributes & OBJ_OPENIF)) {

                    /*
                     * We are attempting to create a desktop and one
                     * already exists.
                     */
                    Status = STATUS_OBJECT_NAME_COLLISION;
                    goto Exit;

                } else {
                    Status = STATUS_OBJECT_NAME_EXISTS;
                }
            } else {
                Status = STATUS_SUCCESS;
            }

            ObReferenceObject(pdesk);

            *pObject = pdesk;
            goto Exit;
        }
    }

    /*
     * Handle creation request
     */
    if (Context != NULL) {
        Status = xxxCreateDesktop2(pContainerObject,
                                   pAccessState,
                                   AccessMode,
                                   pstrRemainingName,
                                   Context,
                                   pObject);
    }

Exit:
    END_REENTERCRIT();

    return Status;

    UNREFERENCED_PARAMETER(pObjectType);
    UNREFERENCED_PARAMETER(pstrCompleteName);
    UNREFERENCED_PARAMETER(pqos);
}

/***************************************************************************\
* DestroyDesktop
*
* Called upon last close of a desktop to remove the desktop from the
* desktop list and free all desktop resources.
*
* History:
* 08-Dec-1993 JimA      Created.
\***************************************************************************/

BOOL DestroyDesktop(
    PDESKTOP pdesk)
{
    PWINDOWSTATION pwinsta = pdesk->rpwinstaParent;
    PTERMINAL      pTerm;
    PDESKTOP       *ppdesk;

    if (pdesk->dwDTFlags & DF_DESTROYED) {
        RIPMSG1(RIP_WARNING, "DestroyDesktop: Already destroyed:%#p", pdesk);
        return FALSE;
    }

    /*
     * Unlink the desktop, if it has not yet been unlinked.
     */
    if (pwinsta != NULL) {

        ppdesk = &pwinsta->rpdeskList;
        while (*ppdesk != NULL && *ppdesk != pdesk) {
            ppdesk = &((*ppdesk)->rpdeskNext);
        }

        if (*ppdesk != NULL) {

            /*
             * remove desktop from the list
             */
            LockDesktop(ppdesk, pdesk->rpdeskNext, LDL_WINSTA_DESKLIST2, (ULONG_PTR)pwinsta);
            UnlockDesktop(&pdesk->rpdeskNext, LDU_DESK_DESKNEXT, (ULONG_PTR)pwinsta);
        }
    }

    /*
     * Link it into the destruction list and signal the desktop thread.
     */
    pTerm = pwinsta->pTerm;

    LockDesktop(&pdesk->rpdeskNext, pTerm->rpdeskDestroy, LDL_DESK_DESKNEXT2, 0);
    LockDesktop(&pTerm->rpdeskDestroy, pdesk, LDL_TERM_DESKDESTROY2, (ULONG_PTR)pTerm);
    KeSetEvent(pTerm->pEventDestroyDesktop, EVENT_INCREMENT, FALSE);

    pdesk->dwDTFlags |= DF_DESTROYED;

    TRACE_DESKTOP(("pdesk %#p '%ws' marked as destroyed\n", pdesk, GetDesktopName(pdesk)));

    return TRUE;
}


/***************************************************************************\
* FreeDesktop
*
* Called to free desktop object and section when last lock is released.
*
* History:
* 08-Dec-1993 JimA      Created.
\***************************************************************************/

NTSTATUS FreeDesktop(
    PKWIN32_DELETEMETHOD_PARAMETERS pDeleteParams )
{
    PDESKTOP pdesk = (PDESKTOP)pDeleteParams->Object;
    NTSTATUS Status = STATUS_SUCCESS; // Caller ignores return value

    BEGIN_REENTERCRIT();

    UserAssert(OBJECT_TO_OBJECT_HEADER(pDeleteParams->Object)->Type == *ExDesktopObjectType);

#ifdef LOGDESKTOPLOCKS

    if (pdesk->pLog != NULL) {

        /*
         * By the time we get here the lock count for lock/unlock
         * tracking code should be 0
         */
        if (pdesk->nLockCount != 0) {
            RIPMSG3(RIP_WARNING,
                    "FreeDesktop pdesk %#p, pLog %#p, nLockCount %d should be 0",
                    pdesk, pdesk->pLog, pdesk->nLockCount);
        }
        UserFreePool(pdesk->pLog);
        pdesk->pLog = NULL;
    }
#endif // LOGDESKTOPLOCKS

#if DBG
    if (pdesk->pDeskInfo && (pdesk->pDeskInfo->spwnd != NULL)) {

        /*
         * assert if the desktop has a desktop window but the flag
         * that says the window is destroyed is not set
         */
        UserAssert(pdesk->dwDTFlags & DF_DESKWNDDESTROYED);
    }
#endif // DBG

    /*
     * Mark the desktop as dying.  Make sure we aren't recursing.
     */
    UserAssert(!(pdesk->dwDTFlags & DF_DYING));
    pdesk->dwDTFlags |= DF_DYING;

#ifdef DEBUG_DESK
    ValidateDesktop(pdesk);
#endif

    /*
     * If the desktop is mapped into CSR, unmap it.  Note the
     * handle count values passed in will cause the desktop
     * to be unmapped and skip the desktop destruction tests.
     */
    FreeView(gpepCSRSS, pdesk);

    if (pdesk->pheapDesktop != NULL) {

        PVOID hheap = Win32HeapGetHandle(pdesk->pheapDesktop);

        Win32HeapDestroy(pdesk->pheapDesktop);

        Status = Win32UnmapViewInSessionSpace(hheap);

        UserAssert(NT_SUCCESS(Status));
        Win32DestroySection(pdesk->hsectionDesktop);
    }

    UnlockWinSta(&pdesk->rpwinstaParent);

    DbgTrackRemoveDesktop(pdesk);

    END_REENTERCRIT();

    return Status;
}

/***************************************************************************\
* CreateDesktopHeap
*
* Create a new desktop heap
*
* History:
* 27-Jul-1992 JimA      Created.
\***************************************************************************/

HANDLE CreateDesktopHeap(
    PWIN32HEAP* ppheapRet,
    ULONG       ulHeapSize)
{
    HANDLE        hsection;
    LARGE_INTEGER SectionSize;
    SIZE_T        ulViewSize;
    NTSTATUS      Status;
    PWIN32HEAP    pheap;
    PVOID         pHeapBase;

    /*
     * Create desktop heap section and map it into the kernel
     */
    SectionSize.QuadPart = ulHeapSize;

    Status = Win32CreateSection(&hsection,
                                SECTION_ALL_ACCESS,
                                (POBJECT_ATTRIBUTES)NULL,
                                &SectionSize,
                                PAGE_EXECUTE_READWRITE,
                                SEC_RESERVE,
                                (HANDLE)NULL,
                                NULL,
                                TAG_SECTION_DESKTOP);

    if (!NT_SUCCESS( Status )) {
        RIPNTERR0(Status, RIP_WARNING, "Can't create section for desktop heap.");
        return NULL;
    }

    ulViewSize = ulHeapSize;
    pHeapBase = NULL;

    Status = Win32MapViewInSessionSpace(hsection, &pHeapBase, &ulViewSize);

    if (!NT_SUCCESS(Status)) {
        RIPNTERR0(Status,
                  RIP_WARNING,
                  "Can't map section for desktop heap into system space.");
        goto Error;
    }

    /*
     * Create desktop heap.
     */
    if ((pheap = UserCreateHeap(
            hsection,
            0,
            pHeapBase,
            ulHeapSize,
            UserCommitDesktopMemory)) == NULL) {

        RIPERR0(ERROR_NOT_ENOUGH_MEMORY, RIP_WARNING, "Can't create Desktop heap.");

        Win32UnmapViewInSessionSpace(pHeapBase);
Error:
        Win32DestroySection(hsection);
        *ppheapRet = NULL;
        return NULL;
    }

    UserAssert(Win32HeapGetHandle(pheap) == pHeapBase);
    *ppheapRet = pheap;

    return hsection;
}

/***************************************************************************\
* GetDesktopView
*
* Determines if a desktop has already been mapped into a process.
*
* History:
* 10-Apr-1995 JimA      Created.
\***************************************************************************/
PDESKTOPVIEW GetDesktopView(
    PPROCESSINFO ppi,
    PDESKTOP     pdesk)
{
    PDESKTOPVIEW pdv;

    if (ppi->Process != gpepCSRSS && pdesk == NULL) {
        RIPMSG1(RIP_WARNING, "Process 0x%p isn't CSRSS but pdesk is NULL in GetDesktopView", ppi);
    }

    for (pdv = ppi->pdvList; pdv != NULL; pdv = pdv->pdvNext) {
        if (pdv->pdesk == pdesk) {
            break;
        }
    }

    return pdv;
}

/***************************************************************************\
* _MapDesktopObject
*
* Maps a desktop object into the client's address space
*
* History:
* 11-Apr-1995 JimA      Created.
\***************************************************************************/

PVOID _MapDesktopObject(
    HANDLE h)
{
    PDESKOBJHEAD pobj;
    PDESKTOPVIEW pdv;

    /*
     * Validate the handle
     */
    pobj = HMValidateHandle(h, TYPE_GENERIC);
    if (pobj == NULL) {
        return NULL;
    }

    UserAssert(HMObjectFlags(pobj) & OCF_DESKTOPHEAP);

    /*
     * Locate the client's view of the desktop. Realistically, this should
     * never fail for valid objects.
     */
    pdv = GetDesktopView(PpiCurrent(), pobj->rpdesk);
    if (pdv == NULL) {
        RIPMSG1(RIP_WARNING, "MapDesktopObject: cannot map handle 0x%p", h);
        return NULL;
    }

    UserAssert(pdv->ulClientDelta != 0);
    return (PVOID)((PBYTE)pobj - pdv->ulClientDelta);
}


/***************************************************************************\
* MapDesktop
*
* Attempts to map a desktop heap into a process.
*
* History:
* 20-Oct-1994 JimA      Created.
\***************************************************************************/
NTSTATUS DesktopOpenProcedure(
    PKWIN32_OPENMETHOD_PARAMETERS pOpenParams)
{
    PDESKTOP      pdesk = (PDESKTOP)pOpenParams->Object;
    /*
     * Make sure we're not opening a handle for a destroy desktop. If this happens,
     * we probably want to fail it.
     */
    if (pdesk->dwDTFlags & DF_DESTROYED) {
        RIPMSG0(RIP_WARNING, "DesktopOpenProcedure: Opening a handle to a destroy desktop");
    }

    return MapDesktop(pOpenParams);

}

NTSTATUS MapDesktop(
    PKWIN32_OPENMETHOD_PARAMETERS pOpenParams)
{
    PPROCESSINFO  ppi;
    PDESKTOP      pdesk = (PDESKTOP)pOpenParams->Object;
    SIZE_T        ulViewSize;
    LARGE_INTEGER liOffset;
    PDESKTOPVIEW  pdvNew;
    PBYTE         pheap;
    HANDLE        hsectionDesktop;
    PBYTE         pClientBase;
    BOOL          bAttached = FALSE;
    KAPC_STATE    ApcState;
    NTSTATUS      Status = STATUS_SUCCESS;

    UserAssert(OBJECT_TO_OBJECT_HEADER(pOpenParams->Object)->Type == *ExDesktopObjectType);

    TAGMSG2(DBGTAG_Callout,
            "Mapping desktop 0x%p into process 0x%p",
            pdesk,
            pOpenParams->Process);

    BEGIN_REENTERCRIT();


    /*
     * If we shuting down the session fail any new desktop open to speed up
     * shutdown, since InitiateWIn32kCleanup is now waiting for all desktop
     * reference to go away.
     */
    if (gbFailDeskopOpen) {
        Status = STATUS_NO_MEMORY;
        goto Exit;
    }

    /*
     * Ignore handle inheritance because MmMapViewOfSection cannot be called
     * during process creation.
     */
    if (pOpenParams->OpenReason == ObInheritHandle) {
        goto Exit;
    }

    /*
     * Do this here, before we (potentially) attach to the process, so
     * we know we're in the right context.
     */
    pheap = Win32HeapGetHandle(pdesk->pheapDesktop);
    hsectionDesktop = pdesk->hsectionDesktop;

    /*
     * If there is no ppi, we can't map the desktop.
     */
    ppi = PpiFromProcess(pOpenParams->Process);
    if (ppi == NULL) {
        goto Exit;
    }

    /*
     * If this process is in a session different than that of the object
     * in question, we must attach to it in order to reference its ppi.
     */
    if (PsGetProcessSessionId(pOpenParams->Process) != pdesk->dwSessionId) {
        KeStackAttachProcess(PsGetProcessPcb(pOpenParams->Process), &ApcState);
        bAttached = TRUE;
    }

    /*
     * If the desktop has already been mapped we're done.
     */
    if (GetDesktopView(ppi, pdesk) != NULL) {
        goto Exit;
    }


    /*
     * Allocate a view of the desktop.
     */
    pdvNew = UserAllocPoolWithQuota(sizeof(*pdvNew), TAG_PROCESSINFO);
    if (pdvNew == NULL) {
        Status = STATUS_NO_MEMORY;
        goto Exit;
    }

    /*
     * Read/write access has been granted. Map the desktop memory into
     * the client process.
     */
    ulViewSize = 0;
    liOffset.QuadPart = 0;
    pClientBase = NULL;

    Status = MmMapViewOfSection(hsectionDesktop,
                                pOpenParams->Process,
                                &pClientBase,
                                0,
                                0,
                                &liOffset,
                                &ulViewSize,
                                ViewUnmap,
                                SEC_NO_CHANGE,
                                PAGE_EXECUTE_READ);
    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING,
                "MapDesktop - failed to map to client process (Status == 0x%x).",
                Status);

        RIPNTERR0(Status, RIP_VERBOSE, "");
        UserFreePool(pdvNew);
        Status = STATUS_NO_MEMORY;
        goto Exit;
    }

    /*
     * Link the view into the ppi.
     */
    pdvNew->pdesk         = pdesk;
    pdvNew->ulClientDelta = (ULONG_PTR)(pheap - pClientBase);
    pdvNew->pdvNext       = ppi->pdvList;
    ppi->pdvList          = pdvNew;

Exit:

    if (bAttached) {
        KeUnstackDetachProcess(&ApcState);
    }

    END_REENTERCRIT();

    return Status;
}


VOID FreeView(
    PEPROCESS Process,
    PDESKTOP pdesk)
{
    PPROCESSINFO ppi;
    NTSTATUS     Status;
    PDESKTOPVIEW pdv, *ppdv;

    /*
     * Bug 277291: gpepCSRSS can be NULL when FreeView is
     * called from FreeDesktop.
     */
    if (Process == NULL) {
        return;
    }

    /*
     * If there is no ppi, then the process is gone and nothing
     * needs to be unmapped.
     */
    ppi = PpiFromProcess(Process);
    if (ppi != NULL) {
        KAPC_STATE ApcState;
        BOOL       bAttached;

        if (PsGetProcessSessionId(Process) != pdesk->dwSessionId) {
            TAGMSG2(DBGTAG_Callout,
                    "FreeView across sessions: process=%p, desktop=%p",
                    Process,
                    pdesk);
            KeStackAttachProcess(PsGetProcessPcb(Process), &ApcState);
            bAttached = TRUE;
        } else {
            bAttached = FALSE;
        }

        pdv = GetDesktopView(ppi, pdesk);

        /*
         * Because mapping cannot be done when a handle is
         * inherited, there may not be a view of the desktop.
         * Only unmap if there is a view.
         */
        if (pdv != NULL) {
            Status = MmUnmapViewOfSection(Process,
                    (PBYTE)Win32HeapGetHandle(pdesk->pheapDesktop) - pdv->ulClientDelta);
            UserAssert(NT_SUCCESS(Status) || Status == STATUS_PROCESS_IS_TERMINATING);
            if (!NT_SUCCESS(Status)) {
                RIPMSG1(RIP_WARNING, "FreeView unmap status = 0x%x", Status);
            }

            /*
             * Unlink and delete the view.
             */
            for (ppdv = &ppi->pdvList; *ppdv && *ppdv != pdv;
                    ppdv = &(*ppdv)->pdvNext) {
                /* do nothing */;
            }
            UserAssert(*ppdv);
            *ppdv = pdv->pdvNext;
            UserFreePool(pdv);
        }

        /*
         * No thread in this process should be on this desktop.
         */
        DbgCheckForThreadsOnDesktop(ppi, pdesk);

        if (bAttached) {
            KeUnstackDetachProcess(&ApcState);
        }
    }
}


NTSTATUS UnmapDesktop(
    PKWIN32_CLOSEMETHOD_PARAMETERS pCloseParams)
{
    PDESKTOP pdesk = (PDESKTOP)pCloseParams->Object;

    BEGIN_REENTERCRIT();

    UserAssert(OBJECT_TO_OBJECT_HEADER(pCloseParams->Object)->Type == *ExDesktopObjectType);

    TAGMSG4(DBGTAG_Callout,
            "Unmapping desktop 0x%p from process 0x%p (0x%x <-> 0x%x)",
            pdesk,
            pCloseParams->Process,
            PsGetProcessSessionId(pCloseParams->Process),
            pdesk->dwSessionId);

    /*
     * Update cSystemHandles with the correct information.
     */
    pCloseParams->SystemHandleCount = OBJECT_TO_OBJECT_HEADER(pCloseParams->Object)->HandleCount + 1;

    /*
     * Only unmap the desktop if this is the last process handle and
     * the process is not CSR.
     */
    if (pCloseParams->ProcessHandleCount == 1 && pCloseParams->Process != gpepCSRSS) {
        FreeView(pCloseParams->Process, pdesk);
    }

    if (pCloseParams->SystemHandleCount > 2) {
        goto Exit;
    }

    if (pCloseParams->SystemHandleCount == 2 && pdesk->dwConsoleThreadId != 0) {

        /*
         * If a console thread exists and we're down to two handles, it means
         * that the last application handle to the desktop is being closed.
         * Terminate the console thread so the desktop can be freed.
         */
        TerminateConsole(pdesk);
    } else if (pCloseParams->SystemHandleCount == 1) {
        /*
         * If this is the last handle to this desktop in the system,
         * destroy the desktop.
         */

        /*
         * No pti should be linked to this desktop.
         */
        if ((&pdesk->PtiList != pdesk->PtiList.Flink)
                || (&pdesk->PtiList != pdesk->PtiList.Blink)) {

            RIPMSG1(RIP_WARNING, "UnmapDesktop: PtiList not Empty. pdesk:%#p", pdesk);
        }

        DestroyDesktop(pdesk);
    }

Exit:
    END_REENTERCRIT();
    return STATUS_SUCCESS;
}


/***************************************************************************\
* OkayToCloseDesktop
*
* We can only close desktop handles if they're not in use.
*
* History:
* 08-Feb-1999 JerrySh   Created.
\***************************************************************************/
NTSTATUS OkayToCloseDesktop(
    PKWIN32_OKAYTOCLOSEMETHOD_PARAMETERS pOkCloseParams )
{
    PDESKTOP pdesk = (PDESKTOP)pOkCloseParams->Object;

    UserAssert(OBJECT_TO_OBJECT_HEADER(pOkCloseParams->Object)->Type == *ExDesktopObjectType);

    /*
     * Kernel mode code can close anything.
     */
    if (pOkCloseParams->PreviousMode == KernelMode) {
        return STATUS_SUCCESS;
    }

    /*
     * We can't close the desktop if we're still initializing it.
     */
    if (!(pdesk->dwDTFlags & DF_DESKCREATED)) {
        RIPMSG1(RIP_WARNING, "Trying to close desktop %#p during initialization", pdesk);
        return STATUS_UNSUCCESSFUL;
    }

    /*
     * We can't close a desktop that's being used.
     */
    if (CheckHandleInUse(pOkCloseParams->Handle) || CheckHandleFlag(pOkCloseParams->Process, pdesk->dwSessionId, pOkCloseParams->Handle, HF_PROTECTED)) {
        RIPMSG1(RIP_WARNING, "Trying to close desktop %#p while still in use", pdesk);
        return STATUS_UNSUCCESSFUL;
    }

    return STATUS_SUCCESS;
}

/***************************************************************************\
* xxxUserResetDisplayDevice
*
* Called to reset the display device after a switch to another device.
* Used when opening a new device, or when switching back to an old desktop
*
* History:
* 31-May-1994 AndreVa   Created.
\***************************************************************************/
VOID xxxUserResetDisplayDevice(
    VOID)
{
    TL tlpwnd;
    TRACE_INIT(("xxxUserResetDisplayDevice: about to reset the device\n"));

    /*
     * Handle early system initialization gracefully.
     */
    if (grpdeskRitInput != NULL) {
        ThreadLock(grpdeskRitInput->pDeskInfo->spwnd, &tlpwnd);
#if 0
        // what should we do here to notify the display applet ?
        // AndreVa

        /*
         * Broadcast that the display has changed resolution.  We are going
         * to specify the desktop for the changing-desktop.  That way we
         * don't get confused as to what desktop to broadcast to.
         */
        xxxBroadcastMessage(grpdeskRitInput->pDeskInfo->spwnd,
                            WM_DISPLAYCHANGE,
                            gpsi->BitCount,
                            MAKELONG(SYSMET(CXSCREEN), SYSMET(CYSCREEN)),
                            BMSG_SENDNOTIFYMSG,
                            NULL);
#endif
        xxxRedrawWindow(grpdeskRitInput->pDeskInfo->spwnd,
                        NULL,
                        NULL,
                        RDW_INVALIDATE | RDW_ERASE | RDW_ERASENOW |
                            RDW_ALLCHILDREN);
        gpqCursor = NULL;

        /*
         * No need to DeferWinEventNotify() - we just made an xxx call above
         */
        zzzInternalSetCursorPos(gpsi->ptCursor.x, gpsi->ptCursor.y);

        SetPointer(TRUE);

        ThreadUnlock(&tlpwnd);
    }

    TRACE_INIT(("xxxUserResetDisplayDevice: complete\n"));

}

/***************************************************************************\
* OpenDesktopCompletion
*
* Verifies that a given desktop has successfully opened.
*
* History:
* 03-Oct-1995 JimA      Created.
\***************************************************************************/

BOOL OpenDesktopCompletion(
    PDESKTOP pdesk,
    HDESK    hdesk,
    DWORD    dwFlags,
    BOOL*    pbShutDown)
{
    PPROCESSINFO   ppi = PpiCurrent();
    PWINDOWSTATION pwinsta;

    /*
     * If the desktop was not mapped in as a result of the open,
     * fail.
     */
    if (GetDesktopView(ppi, pdesk) == NULL) {
        RIPMSG0(RIP_WARNING,
                "OpenDesktopCompletion failed as the desktop is not mapped");

        /*
         * Desktop mapping failed. Status is set by MapDesktop.
         */
        return FALSE;
    } else {
        /*
         * Fail if the windowstation is locked
         */
        pwinsta = pdesk->rpwinstaParent;
        if (pwinsta->dwWSF_Flags & WSF_OPENLOCK &&
                PsGetProcessId(ppi->Process) != gpidLogon) {
            LUID luidCaller;
            NTSTATUS Status;

            /*
             * If logoff is occuring and the caller does not
             * belong to the session that is ending, allow the
             * open to proceed.
             */
            Status = GetProcessLuid(NULL, &luidCaller);

            if (!NT_SUCCESS(Status) ||
                    (pwinsta->dwWSF_Flags & WSF_REALSHUTDOWN) ||
                    RtlEqualLuid(&luidCaller, &pwinsta->luidEndSession)) {

                RIPERR0(ERROR_BUSY, RIP_WARNING, "OpenDesktopCompletion failed");

                /*
                 * Set the shut down flag
                 */
                *pbShutDown = TRUE;
                return FALSE;
            }
        }
    }

    SetHandleFlag(hdesk, HF_DESKTOPHOOK, dwFlags & DF_ALLOWOTHERACCOUNTHOOK);

    return TRUE;
}

/***************************************************************************\
* _OpenDesktop (API)
*
* Open a desktop object.
*
* History:
* 16-Jan-1991 JimA      Created scaffold code.
* 20-Apr-2001 Mohamed   Removed xxx prefix since the function doesn't leave
*                       the Critical Section.
\***************************************************************************/

HDESK _OpenDesktop(
    POBJECT_ATTRIBUTES ccxObjA,
    KPROCESSOR_MODE    AccessMode,
    DWORD              dwFlags,
    DWORD              dwDesiredAccess,
    BOOL*              pbShutDown)
{
    HDESK    hdesk;
    PDESKTOP pdesk;
    NTSTATUS Status;

    /*
     * Require read/write access
     */
    dwDesiredAccess |= DESKTOP_READOBJECTS | DESKTOP_WRITEOBJECTS;

    /*
     * Open the desktop -- Ob routines capture Obj attributes.
     */
    Status = ObOpenObjectByName(
            ccxObjA,
            *ExDesktopObjectType,
            AccessMode,
            NULL,
            dwDesiredAccess,
            NULL,
            &hdesk);
    if (!NT_SUCCESS(Status)) {
        RIPNTERR0(Status, RIP_VERBOSE, "");
        return NULL;
    }

    /*
     * Reference the desktop
     */
    ObReferenceObjectByHandle(
            hdesk,
            0,
            *ExDesktopObjectType,
            KernelMode,
            &pdesk,
            NULL);
    if (!NT_SUCCESS(Status)) {
        RIPNTERR0(Status, RIP_VERBOSE, "");

Error:
        CloseProtectedHandle(hdesk);
        return NULL;
    }

    if (pdesk->dwSessionId != gSessionId) {
        RIPNTERR1(STATUS_INVALID_HANDLE, RIP_WARNING,
                  "_OpenDesktop pdesk %#p belongs to a different session",
                  pdesk);
        ObDereferenceObject(pdesk);
        goto Error;
    }

    LogDesktop(pdesk, LD_REF_FN_OPENDESKTOP, TRUE, (ULONG_PTR)PtiCurrent());

    /*
     * Complete the desktop open
     */
    if (!OpenDesktopCompletion(pdesk, hdesk, dwFlags, pbShutDown)) {
        CloseProtectedHandle(hdesk);
        hdesk = NULL;
    }

    TRACE_INIT(("_OpenDesktop: Leaving\n"));

    LogDesktop(pdesk, LD_DEREF_FN_OPENDESKTOP, FALSE, (ULONG_PTR)PtiCurrent());
    ObDereferenceObject(pdesk);

    if (hdesk != NULL) {
        SetHandleFlag(hdesk, HF_PROTECTED, TRUE);
    }

    return hdesk;
}

/***************************************************************************\
* xxxSwitchDesktop (API)
*
* Switch input focus to another desktop and bring it to the top of the
* desktops
*
* dwFlags:
*   SDF_CREATENEW is set when a new desktop has been created on the device, and
*   when we do not want to send another enable\disable
*
*   SDF_SLOVERRIDE is set when we want to ignore WSF_SWITCHLOCK being set on
*   the desktop's winsta.
*
* History:
* 16-Jan-1991 JimA      Created scaffold code.
* 11-Oct-2000 JasonSch  Added SDF_SLOVERRIDE flag.
\***************************************************************************/

BOOL xxxSwitchDesktop(
    PWINDOWSTATION pwinsta,
    PDESKTOP       pdesk,
    DWORD          dwFlags)
{
    PETHREAD    Thread;
    PWND        pwndSetForeground;
    TL          tlpwndChild;
    TL          tlpwnd;
    TL          tlhdesk;
    PQ          pq;
    BOOL        bUpdateCursor = FALSE;
    PLIST_ENTRY pHead, pEntry;
    PTHREADINFO pti;
    PTHREADINFO ptiCurrent = PtiCurrent();
    PTERMINAL   pTerm;
    NTSTATUS    Status;
    HDESK       hdesk;

    CheckCritIn();

    UserAssert(IsWinEventNotifyDeferredOK());

    if (pdesk == NULL) {
        return FALSE;
    }

    if (pdesk == grpdeskRitInp