                  &OptionDataLength,
                            &dwUnused);

                if ( Error != ERROR_SUCCESS ) {
                    LeaseDuration = INFINIT_LEASE;
                } else {
                    DhcpAssert( OptionDataLength == sizeof(LeaseDuration) );
                    LeaseDuration = *(DWORD *)OptionData;
                    // DhcpGetParameter returns values in Network Byte Order.
                    LeaseDuration = ntohl( LeaseDuration );
                    DhcpFreeMemory( OptionData );
                }

                Lease = DhcpCalculateTime(LeaseDuration);
                NetworkIpAddress = htonl(IpAddress);

                // we don't know what's the Hardware address, so we fake it to the binary encoding
                // of the string representation of the IpAddress
                strcpy(HardwareAddressBuffer, inet_ntoa(*(struct in_addr *)&NetworkIpAddress));
                nClientHardwareAddress = strlen(HardwareAddressBuffer) + sizeof(CHAR);
            }

            // next, write down the database record based on the info obtained above
            if (Subnet->fSubnet) {
                //
                // create a dummy entry with subnet/global lease time, so
                // that this bad entry will be recovered after the lease
                // expires.
                //
                Error = CreateClientDBEntry(
                    IpAddress,
                    Subnet->Mask,
                    HardwareAddressBuffer,
                    nClientHardwareAddress,
                    Lease,
                    MachineName,
                    NULL,
                    INADDR_LOOPBACK,
                    ADDRESS_STATE_ACTIVE,
                    CLIENT_TYPE_BOTH );
            } else {
                Error = MadcapCreateClientEntry(
                    (LPBYTE)&IpAddress,
                    sizeof(IpAddress),
                    Subnet->MScopeId,
                    HardwareAddressBuffer,
                    nClientHardwareAddress,
                    NULL,
                    DhcpGetDateTime(),
                    Lease,
                    INADDR_LOOPBACK,
                    ADDRESS_STATE_ACTIVE,
                    0,
                    FALSE
                );
            }

            DhcpAssert( Error == ERROR_SUCCESS );

            if( Error != ERROR_SUCCESS ) {
                ReturnError = Error;
            }
        }
        else {

            //
            // neither the registry nor the database fix.
            //

            DhcpAssert( FALSE );
        }
    }

//    if (RegistryModified) {
//          old code updated here the registry as well
//    }

//Cleanup:

    if( NewBitMapList != NULL ) {
        DhcpFreeMemory( NewBitMapList );
    }

    if( HardwareAddressBuffer != NULL) {
        DhcpFreeMemory( HardwareAddressBuffer );
    }

    return( ReturnError );
}

DWORD
GetReservedList(
    IN PM_SUBNET Subnet,
    OUT DHCP_IP_ADDRESS **ReservedList,
    OUT ULONG* ReserveListCount
    )
{
    ULONG Error, Count;
    ARRAY_LOCATION Loc;
    DHCP_IP_ADDRESS *List;

    (*ReservedList) = NULL;
    (*ReserveListCount) = MemArraySize(&Subnet->Reservations);
    if( 0 == (*ReserveListCount) ) {
        return ERROR_SUCCESS;
    }

    (*ReservedList) = DhcpAllocateMemory(
        sizeof(DHCP_IP_ADDRESS)*(*ReserveListCount)
        );
    if( NULL == (*ReservedList) ) {
        (*ReserveListCount) = 0;
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    List = *ReservedList;
    for(
        Error = MemArrayInitLoc(&Subnet->Reservations, &Loc);
        ERROR_SUCCESS == Error;
        Error = MemArrayNextLoc(&Subnet->Reservations, &Loc)
        ) {
        PM_RESERVATION ThisElt;

        MemArrayGetElement(&Subnet->Reservations, &Loc, &ThisElt);
        *List ++ = ThisElt->Address;
    }

    return ERROR_SUCCESS;
}

DWORD
ScanDatabase(
    PM_SUBNET Subnet,
    DWORD FixFlag,
    LPDHCP_SCAN_LIST *ScanList
    )
/*++

Routine Description:

    Worker function for R_DhcpScanDatabase.

Arguments:

    SubnetAddress : Address of the subnet scope to verify.

    FixFlag : If this flag is TRUE, this api will fix the bad entries.

    ScanList : List of bad entries returned. The caller should free up
        this memory after it has been used.


Return Value:

    WINDOWS errors.
--*/
{
    DWORD Error;
    LPDHCP_IP_ADDRESS DatabaseList = NULL;
    DWORD DatabaseListCount = 0;
    LPBITMAP_ENTRY BitMapList = NULL;
    DWORD BitMapListCount = 0;
    DHCP_IP_ADDRESS *ReservedList;
    ULONG ReserveListCount;

    DhcpAssert( *ScanList == NULL );

    //
    // lock both registry and database locks here to avoid dead lock.
    //

    LOCK_DATABASE();

    //
    // read registry bit-map.
    //

    Error = GetRegistryBitMap(
        Subnet,
        &BitMapList,
        &BitMapListCount
    );


    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    // now make list of database records of the specified subnet.
    if (Subnet->fSubnet) {
        Error = GetDatabaseList(
            Subnet->Address,
            &DatabaseList,
            &DatabaseListCount
        );
    } else {
        Error = GetMCastDatabaseList(
            Subnet->MScopeId,
            &DatabaseList,
            &DatabaseListCount
        );
    }

    if( Error != ERROR_SUCCESS ) {
        goto Cleanup;
    }

    GetReservedList(
        Subnet,
        &ReservedList,
        &ReserveListCount
        );

    //
    // now time to check both lists.
    //

    Error = VerifyLists(
        Subnet,
        DatabaseList,
        DatabaseListCount,
        BitMapList,
        BitMapListCount,
        ReservedList,
        ReserveListCount,
        ScanList
    );

    if( ReservedList ) DhcpFreeMemory(ReservedList);

    if( Error != ERROR_SUCCESS ) {
        DhcpAssert( *ScanList == NULL );
        goto Cleanup;
    }

    DhcpAssert( *ScanList != NULL );

    if( FixFlag ) {

        //
        // fix bad entries.
        //

        Error = FixBadEntries(
            Subnet,
            BitMapList,
            BitMapListCount,
            *ScanList
        );
    }

Cleanup:

    if( DatabaseList != NULL ) {
        DhcpFreeMemory( DatabaseList );
    }

    if( BitMapList != NULL) {
        DhcpFreeMemory( BitMapList );
    }

    UNLOCK_DATABASE();

    return(Error);
}

DWORD
R_DhcpScanDatabase2(
    LPWSTR ServerIpAddress,
    LPWSTR  pMScopeName,
    DWORD FixFlag,
    LPDHCP_SCAN_LIST *ScanList
    )
/*++

Routine Description:

    This function scans the database entries and registry bit-map for
    specified subnet scope and veryfies to see they match. If they
    don't match, this api will return the list of inconsistent entries.
    Optionally FixFlag can be used to fix the bad entries.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : Address of the subnet scope to verify.

    FixFlag : If this flag is TRUE, this api will fix the bad entries.

    ScanList : List of bad entries returned. The caller should free up
        this memory after it has been used.


Return Value:

    WINDOWS errors.
--*/
{
    DWORD Error;
    PM_SUBNET   Subnet;

    DhcpPrint(( DEBUG_APIS, "DhcpScanDatabase is called.\n"));

    if (!pMScopeName ) {
        return ERROR_INVALID_PARAMETER;
    }

    Error = DhcpApiAccessCheck( DHCP_ADMIN_ACCESS );

    if ( Error != ERROR_SUCCESS ) {
        return( Error );
    }


    DhcpAcquireWriteLock();

    Error = DhcpFlushBitmaps();
    DhcpAssert(ERROR_SUCCESS == Error);

    Error = DhcpServerFindMScope(
        DhcpGetCurrentServer(),
        0,
        pMScopeName,
        &Subnet
    );

    if( ERROR_SUCCESS == Error ) {
        Error = ScanDatabase(
            Subnet,
            FixFlag,
            ScanList
        );
    }

    DhcpReleaseWriteLock();
    DhcpScheduleRogueAuthCheck();

    if( Error != ERROR_SUCCESS ) {
        DhcpPrint(( DEBUG_APIS, "DhcpScanDatabase  failed, %ld.\n",
                        Error ));
    }

    return(Error);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\rpcapi.h ===
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================

LPWSTR
CloneLPWSTR(                                      // allocate and copy a LPWSTR type
    IN      LPWSTR                 Str
);

LPBYTE                                            // defined in rpcapi1.c
CloneLPBYTE(
    IN      LPBYTE                 Bytes,
    IN      DWORD                  nBytes
);

DWORD
DhcpAddSubnetElement(
    IN      PM_SUBNET              Subnet,
    IN      LPDHCP_SUBNET_ELEMENT_DATA_V4 ElementInfo,
    IN      BOOL                   fIsV5Call
);

DWORD
DhcpEnumSubnetElements(
    IN      PM_SUBNET              Subnet,
    IN      DHCP_SUBNET_ELEMENT_TYPE EnumElementType,
    IN OUT  DWORD                 *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    IN      BOOL                   fIsV5Call,
    IN OUT  LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 LocalEnumInfo,
    OUT     DWORD                 *nRead,
    OUT     DWORD                 *nTotal
);

DWORD
DhcpRemoveSubnetElement(
    IN      PM_SUBNET              Subnet,
    IN      LPDHCP_SUBNET_ELEMENT_DATA_V4 RemoveElementInfo,
    IN      BOOL                   fIsV5Call,
    IN      DHCP_FORCE_FLAG        ForceFlag
);

DWORD
ScanDatabase(
    PM_SUBNET Subnet,
    DWORD FixFlag,
    LPDHCP_SCAN_LIST *ScanList
);

DWORD
SubnetInUse(
    IN      HKEY                   SubnetKeyHandle,
    IN      DHCP_IP_ADDRESS        SubnetAddress
);

DWORD       _inline
ConvertOptIdToMemValue(
    IN      DWORD                  OptId,
    IN      BOOL                   IsVendor
)
{
    if( IsVendor ) return OptId + 256;
    return OptId;
}


DWORD                                             // ERROR_MORE_DATA with DataSize as reqd size if buffer insufficient
DhcpParseRegistryOption(                          // parse the options to fill into this buffer
    IN      LPBYTE                 Value,         // input option buffer
    IN      DWORD                  Length,        // size of input buffer
    OUT     LPBYTE                 DataBuffer,    // output buffer
    OUT     DWORD                 *DataSize,      // given buffer space on input, filled buffer space on output
    IN      BOOL                   fUtf8
) ;


DWORD                                             // ERROR_DHCP_OPTION_EXITS if option is already there
R_DhcpCreateOptionV5(                             // create a new option (must not exist)
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,      // must be between 0-255 or 256-511 (for vendor stuff)
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION          OptionInfo
) ;


DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT if option does not exist
R_DhcpSetOptionInfoV5(                            // Modify existing option's fields
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION          OptionInfo
) ;


DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT
R_DhcpGetOptionInfoV5(                            // retrieve the information from off the mem structures
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    OUT     LPDHCP_OPTION         *OptionInfo     // allocate memory using MIDL functions
) ;


DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT if option does not exist
R_DhcpEnumOptionsV5(                              // enumerate the options defined
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN OUT  DHCP_RESUME_HANDLE    *ResumeHandle,  // must be zero intially and then never touched
    IN      DWORD                  PreferredMaximum, // max # of bytes of info to pass along
    OUT     LPDHCP_OPTION_ARRAY   *Options,       // fill this option array
    OUT     DWORD                 *OptionsRead,   // fill in the # of options read
    OUT     DWORD                 *OptionsTotal   // fill in the total # here
) ;


DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT if option not existent
R_DhcpRemoveOptionV5(                             // remove the option definition from the registry
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName
) ;


DWORD                                             // OPTION_NOT_PRESENT if option is not defined
R_DhcpSetOptionValueV5(                           // replace or add a new option value
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionId,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    IN      LPDHCP_OPTION_DATA     OptionValue
) ;


DWORD                                             // not atomic!!!!
R_DhcpSetOptionValuesV5(                          // set a bunch of options
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO  ScopeInfo,
    IN      LPDHCP_OPTION_VALUE_ARRAY OptionValues
) ;


DWORD
R_DhcpGetOptionValueV5(                           // fetch the required option at required level
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    OUT     LPDHCP_OPTION_VALUE   *OptionValue    // allocate memory using MIDL_user_allocate
) ;


DWORD
R_DhcpEnumOptionValuesV5(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DWORD                  Flags,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    IN      DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_OPTION_VALUE_ARRAY *OptionValues,
    OUT     DWORD                 *OptionsRead,
    OUT     DWORD                 *OptionsTotal
) ;


DWORD
R_DhcpRemoveOptionValueV5(
    IN      LPWSTR                 ServerIpAddress,
    IN      DWORD                  Flags,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPWSTR                 ClassName,
    IN      LPWSTR                 VendorName,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo
) ;


DWORD
R_DhcpCreateClass(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN      LPDHCP_CLASS_INFO      ClassInfo
) ;


DWORD
R_DhcpModifyClass(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN      LPDHCP_CLASS_INFO      ClassInfo
) ;


DWORD
R_DhcpDeleteClass(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN      LPWSTR                 ClassName
) ;


DWORD
R_DhcpGetClassInfo(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN      LPDHCP_CLASS_INFO      PartialClassInfo,
    OUT     LPDHCP_CLASS_INFO     *FilledClassInfo
) ;


DWORD
R_DhcpEnumClasses(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DWORD                  ReservedMustBeZero,
    IN OUT  DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_CLASS_INFO_ARRAY *ClassInfoArray,
    OUT     DWORD                 *nRead,
    OUT     DWORD                 *nTotal
) ;


DWORD
R_DhcpGetAllOptionValues(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DWORD                  Flags,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    OUT     LPDHCP_ALL_OPTION_VALUES *Values
) ;


DWORD
R_DhcpGetAllOptions(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DWORD                  Flags,
    OUT     LPDHCP_ALL_OPTIONS    *Options
) ;


DWORD                                             // ERROR_DHCP_OPTION_EXITS if option is already there
R_DhcpCreateOption(                               // create a new option (must not exist)
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionId,      // must be between 0-255 or 256-511 (for vendor stuff)
    IN      LPDHCP_OPTION          OptionInfo
) ;


DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT if option does not exist
R_DhcpSetOptionInfo(                              // Modify existing option's fields
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPDHCP_OPTION          OptionInfo
) ;


DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT
R_DhcpGetOptionInfo(                              // retrieve the information from off the mem structures
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionID,
    OUT     LPDHCP_OPTION         *OptionInfo     // allocate memory using MIDL functions
) ;


DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT if option does not exist
R_DhcpEnumOptions(                                // enumerate the options defined
    IN      LPWSTR                 ServerIpAddress,
    IN OUT  DHCP_RESUME_HANDLE    *ResumeHandle,  // must be zero intially and then never touched
    IN      DWORD                  PreferredMaximum, // max # of bytes of info to pass along
    OUT     LPDHCP_OPTION_ARRAY   *Options,       // fill this option array
    OUT     DWORD                 *OptionsRead,   // fill in the # of options read
    OUT     DWORD                 *OptionsTotal   // fill in the total # here
) ;


DWORD                                             // ERROR_DHCP_OPTION_NOT_PRESENT if option not existent
R_DhcpRemoveOption(                               // remove the option definition from the registry
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionID
) ;


DWORD                                             // OPTION_NOT_PRESENT if option is not defined
R_DhcpSetOptionValue(                             // replace or add a new option value
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    IN      LPDHCP_OPTION_DATA     OptionValue
) ;


DWORD                                             // not atomic!!!!
R_DhcpSetOptionValues(                            // set a bunch of options
    IN      LPWSTR                 ServerIpAddress,
    IN      LPDHCP_OPTION_SCOPE_INFO  ScopeInfo,
    IN      LPDHCP_OPTION_VALUE_ARRAY OptionValues
) ;


DWORD
R_DhcpGetOptionValue(                             // fetch the required option at required level
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    OUT     LPDHCP_OPTION_VALUE   *OptionValue    // allocate memory using MIDL_user_allocate
) ;


DWORD
R_DhcpEnumOptionValues(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo,
    IN      DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_OPTION_VALUE_ARRAY *OptionValues,
    OUT     DWORD                 *OptionsRead,
    OUT     DWORD                 *OptionsTotal
) ;


DWORD
R_DhcpRemoveOptionValue(
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_OPTION_ID         OptionID,
    IN      LPDHCP_OPTION_SCOPE_INFO ScopeInfo
) ;

//========================================================================
//  end of file 
//========================================================================
//========================================================================
//  Copyright (C) 1997 Microsoft Corporation                              
//  Author: RameshV                                                       
//  Description: This file has been generated. Pl look at the .c file     
//========================================================================

DWORD
DhcpUpdateReservationInfo(                        // this is used in cltapi.c to update a reservation info
    IN      DWORD                  Address,
    IN      LPBYTE                 ClientUID,
    IN      DWORD                  ClientUIDLength
) ;


DWORD
R_DhcpSetSuperScopeV4(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPWSTR                 SuperScopeName,
    IN      BOOL                   ChangeExisting
) ;


DWORD
R_DhcpDeleteSuperScopeV4(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      LPWSTR                 SuperScopeName
) ;


DWORD
R_DhcpGetSuperScopeInfoV4(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    OUT     LPDHCP_SUPER_SCOPE_TABLE *SuperScopeTable
) ;


DWORD
R_DhcpCreateSubnet(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPDHCP_SUBNET_INFO     SubnetInfo
) ;


DWORD
R_DhcpSetSubnetInfo(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPDHCP_SUBNET_INFO     SubnetInfo
) ;


DWORD
R_DhcpGetSubnetInfo(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    OUT     LPDHCP_SUBNET_INFO    *SubnetInfo
) ;


DWORD
R_DhcpEnumSubnets(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    IN      LPDHCP_IP_ARRAY       *EnumInfo,
    IN      DWORD                 *ElementsRead,
    IN      DWORD                 *ElementsTotal
) ;


DWORD
R_DhcpDeleteSubnet(
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      DHCP_FORCE_FLAG        ForceFlag      // if TRUE delete all turds from memory/registry/database
) ;


DWORD
R_DhcpAddSubnetElementV4(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPDHCP_SUBNET_ELEMENT_DATA_V4  AddElementInfo
) ;


DWORD
R_DhcpEnumSubnetElementsV4(
    IN      DHCP_SRV_HANDLE        ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      DHCP_SUBNET_ELEMENT_TYPE EnumElementType,
    IN OUT  DHCP_RESUME_HANDLE    *ResumeHandle,
    IN      DWORD                  PreferredMaximum,
    OUT     LPDHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 *EnumElementInfo,
    OUT     DWORD                 *ElementsRead,
    OUT     DWORD                 *ElementsTotal
) ;


DWORD
R_DhcpRemoveSubnetElementV4(
    IN      LPWSTR                 ServerIpAddress,
    IN      DHCP_IP_ADDRESS        SubnetAddress,
    IN      LPDHCP_SUBNET_ELEMENT_DATA_V4 RemoveElementInfo,
    IN      DHCP_FORCE_FLAG        ForceFlag
) ;

//========================================================================
//  end of file 
//========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\secretk.c ===
/*++

Copyright (C) 1998 Microsoft Corporation

Module Name:

   SecretK.C

Abstract:

   This module implements reading and writing secret keys using
   LSA secrets API.  Two APIs are provided to retrieve the values
   and set the values respectively.

   This is preliminary version for use by the DHCP server to store
   persistent information on whether Rogue detection ever succeeded
   and if so, when.

Author:

   Ramesh V (RameshV) 29-July-1998

--*/

#include <dhcppch.h>
#include <ntlsa.h>

#define  DHCP_SECRET_KEY            L"DhcpServer Secret Key For Rogue Detection"
#define  DHCP_SECRET_UNAME_KEY      L"DhcpServer Uname Key"
#define  DHCP_SECRET_DOMAIN_KEY     L"DhcpServer Domain Key"
#define  DHCP_SECRET_DNS_PASSWD_KEY L"DhcpServer Passwd Key"

#define  FTIME_TO_SEC_FACTOR       10000000
#define  DHCP_SERVER_AUTHORIZATION_VALIDITY_PERIOD (2*24*60*60)
#define  MAX_STRING_SIZE           260
#define  AUTH_FLAG_JUST_UPGRADED   0x01
#define  AUTH_FLAG_UNAUTHORIZED    0x02
#ifndef  DHCP_ENCODE_SEED
#define  DHCP_ENCODE_SEED          ((UCHAR)0xA5)
#endif

typedef struct {
    ULONG Flags;
    FILETIME TimeStamp;
    //
    // This is followed directly by WCHAR string
    // for the domain that the server was authorized/unauthorized
    // in the last time.
} AUTH_CACHE_INFO, *PAUTH_CACHE_INFO;

static
LSA_HANDLE GlobalPolicyHandle;

static
ULONG Initialized = 0;

DWORD _inline
OpenPolicy(
    OUT LSA_HANDLE *PolicyHandle
)
{
    LSA_HANDLE hPolicy;
    DWORD status;
    OBJECT_ATTRIBUTES objectAttributes;

    (*PolicyHandle) = NULL;

    InitializeObjectAttributes(
        &objectAttributes,
        NULL,
        0L,
        NULL,
        NULL
    );

    status = LsaOpenPolicy(
        NULL,
        &objectAttributes,
        POLICY_WRITE | POLICY_READ |
        POLICY_CREATE_ACCOUNT | POLICY_LOOKUP_NAMES,
        &hPolicy
    );

    if (status != STATUS_SUCCESS) {
        return LsaNtStatusToWinError(status);
    }

    (*PolicyHandle) = hPolicy;

    return ERROR_SUCCESS;
}

DWORD _fastcall
SetSecretValue(
    IN LPCWSTR KeyName,
    IN PVOID Buffer,
    IN LONG BufSize
)
/*++

Routine Description

    Set the secret value associated with the keyname using local
    system security policy.

Arguments

    KeyName - key name to use to set secret value

    Buffer - the secret value to set ..

    BufSize - the size of the buffer in bytes.  If this is zero
        the value would be deleted.

Return Value

    Win32 errors

--*/
{
    UNICODE_STRING LKey, Value;
    DWORD status;

    RtlInitUnicodeString(&LKey, KeyName);
    Value.Length = Value.MaximumLength = (USHORT)BufSize;
    Value.Buffer = Buffer;

    status = LsaStorePrivateData( GlobalPolicyHandle, &LKey, &Value);

    return LsaNtStatusToWinError(status);

}

DWORD _inline
GetSecretValue(
    IN LPCWSTR KeyName,
    OUT PVOID Buffer,
    IN OUT PLONG BufSize
)
/*++

Routine Description

    Retrive the secret value with keyname as provided using local
    system security policy.

    If the return value requires more space than the buffer provided
    (BufSize initially has the space provided via Buffer) then return
    the space required in bytes in the BufSize parameter and return
    ERROR_INSUFFICIENT_BUFFER.

Arguments

    KeyName - provide the name of the key of interest.

    Buffer - provide the buffer that needs to be filled in with secret value.

    BufSize - on input this will the size of Buffer in bytes provided.
        In case of successful return, this will hold the actual number of
        bytes used.  If the routine returns ERROR_INSUFFICIENT_BUFFER then
        this will hold the size required.

Return Value

    ERROR_SUCCESS -- successfully copied the value.  If no value exists,
        (*BufSize) would be zero on return and function would return success.

    ERROR_INSUFFICIENT_BUFFER -- The size as provided by BufSize is not
        sufficient to do the full copy of the value.  On return BufSize will
        hold the actual size required.

    Other Win32 errors.

--*/
{
    UNICODE_STRING LKey, *pValue = NULL;
    DWORD status;

    RtlInitUnicodeString(&LKey, KeyName);

    status = LsaRetrievePrivateData( GlobalPolicyHandle, &LKey, &pValue);

    if( STATUS_SUCCESS != status ) {
        return LsaNtStatusToWinError(status);
    }

    if( *BufSize >= pValue->Length ) {
        RtlCopyMemory( Buffer, pValue->Buffer, pValue->Length );
    } else {
        status = ERROR_INSUFFICIENT_BUFFER;
    }

    *BufSize = pValue->Length;
    LsaFreeMemory(pValue);

    return status;
}

BOOL
DhcpGetAuthStatus(
    IN LPWSTR DomainName,
    OUT BOOL *fUpgraded,
    OUT BOOL *fAuthorized
)
/*++

Routine Description:
    This routine checks to see if there is a registry cache entry for the
    given domain name.  If there isn't one for the given domain name, it
    returns FALSE. (In this case, the value for *fAuthorized is FALSE).

    If there is a registry cache entry for the given domain name, then the
    fAuthorized flag contains information on whether it is authorized or
    unauthorized.

    If the machine was just upgraded, then fAuthorized is fUpgraded is set
    to TRUE (This is independent of the return value of the function).

Arguments:
    DomainName -- name of domain to check authorization information
    fUpgraded -- was the machine just upgraded to NT5 ?
    fAuthorized -- is it authorized or unauthorized ?

Return Value:
    TRUE indicates a cache entry for the given domain was found (and the
    flag fAuthorized can be checked to see authorization status). 

--*/
{
    ULONG Error, AuthInfoSize;
    PAUTH_CACHE_INFO AuthInfo;
    BOOL fResult;
    LPWSTR CachedDomainName;
    FILETIME Diff, CurrentTime;

    (*fUpgraded) = (*fAuthorized) = FALSE;

    AuthInfo = NULL; AuthInfoSize = 0;
    Error = GetSecretValue(
        DHCP_SECRET_KEY,
        AuthInfo,
        &AuthInfoSize
        );
    if( ERROR_INSUFFICIENT_BUFFER != Error ) return FALSE;
    if( AuthInfoSize < sizeof(*AuthInfo)) return FALSE;
    
    AuthInfo = LocalAlloc( LPTR, AuthInfoSize );
    if( NULL == AuthInfo ) return FALSE;

    fResult = FALSE;
    do {
        Error = GetSecretValue(
            DHCP_SECRET_KEY,
            AuthInfo,
            &AuthInfoSize
            );
        if( ERROR_SUCCESS != Error ) break;
        if( AuthInfoSize < sizeof(*AuthInfo) ) break;
        
        (*fUpgraded) = ( AuthInfo->Flags & AUTH_FLAG_JUST_UPGRADED );
        CachedDomainName = (LPWSTR)(sizeof(*AuthInfo) + (LPBYTE)AuthInfo);

        if( NULL == DomainName ) break;

        if( (1 + wcslen(DomainName)) *sizeof(WCHAR) 
            != AuthInfoSize - sizeof(*AuthInfo) ) {
            break;
        }

        if( 0 != _wcsicmp( 
            DomainName, 
            CachedDomainName
            ) ) {
            break;
        }

        *(ULONGLONG *)&Diff = DHCP_SERVER_AUTHORIZATION_VALIDITY_PERIOD;
        *(ULONGLONG *)&Diff *= FTIME_TO_SEC_FACTOR;
        
        GetSystemTimeAsFileTime(&CurrentTime);
        (*(ULONGLONG *)&CurrentTime) += *(ULONGLONG *)&Diff;

        if( CompareFileTime( &AuthInfo->TimeStamp, &CurrentTime ) < 0 ) {
            //
            // We've gone past the cache life
            //
            break;
        }

        (*fAuthorized) = (0 == ( AuthInfo->Flags & AUTH_FLAG_UNAUTHORIZED ));
        fResult = TRUE;

    } while ( 0 );
    LocalFree( AuthInfo );
    return fResult ;
}


DWORD
DhcpSetAuthStatus(
    IN LPWSTR DomainName OPTIONAL,
    IN BOOL fUpgraded,
    IN BOOL fAuthorized
)
/*++

Routine Description:
    This routine sets the registry cache information for authorization.  

Arguments:
    DomainName -- name of domain to set in the authorization info
    fUpgraded -- was this just upgraded to NT5?
    fAuthorized -- was this authorized or unauthorized ?

Return Value:
    Status

--*/
{
    AUTH_CACHE_INFO AuthInfoTmp;
    PAUTH_CACHE_INFO AuthInfo;
    ULONG Error;
    ULONG StringSize;
    
    StringSize = DomainName? (sizeof(WCHAR)*(1+wcslen(DomainName))):0;
    if( 0 == StringSize ) {
        AuthInfo = &AuthInfoTmp;
    } else {
        AuthInfo = LocalAlloc( LPTR, sizeof(*AuthInfo) + StringSize );
    }
    if( NULL == AuthInfo ) return ERROR_NOT_ENOUGH_MEMORY;

    AuthInfo->Flags = 0;
    if( fUpgraded ) AuthInfo -> Flags |= AUTH_FLAG_JUST_UPGRADED;
    if( !fAuthorized ) AuthInfo ->Flags |= AUTH_FLAG_UNAUTHORIZED;

    GetSystemTimeAsFileTime( &AuthInfo->TimeStamp );

    RtlCopyMemory( 
        sizeof(AuthInfo) + (LPBYTE)AuthInfo, 
        DomainName,
        StringSize 
        );

    Error = SetSecretValue(
        DHCP_SECRET_KEY,
        AuthInfo,
        StringSize + sizeof(*AuthInfo)
        );
    if( AuthInfo != &AuthInfoTmp ) {
        LocalFree(AuthInfo);
    }
    return Error;
}

VOID
DhcpSetAuthStatusUpgradedFlag(
    IN BOOL fUpgraded
)
/*++

Routine Description:
   This routine does not alter any cache information other
   than the just upgraded flag.

--*/
{
    ULONG Error, AuthInfoSize;
    PAUTH_CACHE_INFO AuthInfo;
    BOOL fResult;

    AuthInfo = NULL; AuthInfoSize = 0;
    Error = GetSecretValue(
        DHCP_SECRET_KEY,
        AuthInfo,
        &AuthInfoSize
        );
    if( ERROR_INSUFFICIENT_BUFFER != Error ||
        AuthInfoSize < sizeof( *AuthInfo ) ) {
        DhcpSetAuthStatus( NULL, fUpgraded, FALSE );
        return;
    }
    AuthInfo = LocalAlloc( LPTR, AuthInfoSize );
    if( NULL == AuthInfo ) {
        DhcpSetAuthStatus( NULL, fUpgraded, FALSE );
        return;
    }

    fResult = FALSE;
    do{
        Error = GetSecretValue(
            DHCP_SECRET_KEY,
            AuthInfo,
            &AuthInfoSize
            );
        if( ERROR_SUCCESS != Error ) break;
        if( AuthInfoSize < sizeof(*AuthInfo) ) break;
        if( fUpgraded ) {
            AuthInfo->Flags |= AUTH_FLAG_JUST_UPGRADED;
        } else {
            AuthInfo->Flags &= ~AUTH_FLAG_JUST_UPGRADED;
        }

        SetSecretValue(
            DHCP_SECRET_KEY,
            AuthInfo,
            AuthInfoSize
            );
        fResult = TRUE;
    } while ( 0 );

    if( FALSE == fResult ) {
        DhcpSetAuthStatus( NULL, fUpgraded, FALSE );
    }
    LocalFree( AuthInfo );
}

VOID
WINAPI
DhcpMarkUpgrade(
    VOID
)
/*++

Routine Description:
   This routine is to be called by the UPGRADE setup path when the machine
   has been upgraded to NT5 (and dhcp server is installed etc).
   It MUST NOT BE CALLED within DHCP.
   It automatically initializes this module and cleans up.

--*/
{
    ULONG Error;

    Error = DhcpInitSecrets();
    if( ERROR_SUCCESS == Error ) {
        Error = DhcpSetAuthStatus( NULL, TRUE, TRUE );
        ASSERT( ERROR_SUCCESS == Error );
        DhcpCleanupSecrets();
    }
}


DWORD
DhcpQuerySecretUname(
    IN OUT LPWSTR Uname,
    IN ULONG UnameSize, // size in BYTES not WCHARS
    IN OUT LPWSTR DomainName,
    IN ULONG DomainNameSize,
    IN OUT LPWSTR Passwd,
    IN ULONG PasswdSize
    )
{
    DWORD Error;

    ZeroMemory( Uname, UnameSize );
    ZeroMemory( DomainName, DomainNameSize );
    ZeroMemory( Passwd, PasswdSize );

    if( UnameSize <= sizeof(WCHAR) ) return ERROR_INSUFFICIENT_BUFFER;
    if( DomainNameSize <= sizeof(WCHAR) ) return ERROR_INSUFFICIENT_BUFFER;
     
    Error = GetSecretValue(
        DHCP_SECRET_UNAME_KEY, Uname, &UnameSize );
    if( ERROR_FILE_NOT_FOUND == Error ) {
        Uname[0] = L'\0';
        DomainName[0] = L'\0';
        return NO_ERROR;
    }

    if(NO_ERROR != Error ) return Error;

    Error = GetSecretValue(
        DHCP_SECRET_DOMAIN_KEY, DomainName, &DomainNameSize );
    if( ERROR_FILE_NOT_FOUND == Error ) {
        DomainName[0] = L'\0';
        return NO_ERROR;
    }
 
    if ( NO_ERROR != Error ) return Error;

    Error = GetSecretValue( 
        DHCP_SECRET_DNS_PASSWD_KEY, Passwd, &PasswdSize );
    if ( ERROR_FILE_NOT_FOUND == Error ) {
        Passwd[ 0 ] = L'\0';
        return NO_ERROR;
    }

    return Error;    
}

DWORD
GetAccountSid(
    IN LPWSTR AccountName,
    IN OUT PSID *pSid
    )
{
    BOOL fSuccess;
    DWORD Error, Size, DomSize;
    SID_NAME_USE unused;
    WCHAR DomainName[512];
    
    Size = 0;
    DomSize = sizeof(DomainName)/sizeof(DomainName[0]);
    fSuccess = LookupAccountName(
        NULL, AccountName, (*pSid), &Size, DomainName, &DomSize,
        &unused );
    
    Error = NO_ERROR;
    if( FALSE == fSuccess ) Error = GetLastError();

    if( ERROR_INSUFFICIENT_BUFFER != Error ) return Error;

    (*pSid ) = LocalAlloc( LPTR, Size );
    if( NULL == (*pSid )) return GetLastError();

    fSuccess = LookupAccountName(
        NULL, AccountName, (*pSid), &Size, DomainName, &DomSize,
        &unused );

    Error = NO_ERROR;
    if( FALSE == fSuccess ) Error = GetLastError();
    if( NO_ERROR != Error ) {
        LocalFree(*pSid);
        (*pSid) = NULL;
    }

    return Error;
}

DWORD
SetPrivilegeOnAccount(
    IN PSID pSid,
    IN LPWSTR Privilege
    )
{
    BOOL fEnable = TRUE;
    DWORD Error;
    LSA_UNICODE_STRING Str;

    Str.Buffer = Privilege;
    Str.Length = (USHORT)(lstrlenW(Privilege)*sizeof(WCHAR));
    Str.MaximumLength = Str.Length + sizeof(WCHAR);

    Error = LsaAddAccountRights(
        GlobalPolicyHandle, pSid, &Str, 1 );

    return LsaNtStatusToWinError( Error );
}

DWORD
VerifyAccount(
    IN LPWSTR Uname,
    IN LPWSTR DomainName,
    IN LPWSTR Passwd
    )
{
    DWORD Error;
    WCHAR AccountName[512];
    PSID pSid = NULL;
    HANDLE hToken;

    wcscpy(AccountName, DomainName );
    wcscat(AccountName, L"\\");
    wcscat(AccountName, Uname );

    //
    // Check if lookup succeeds
    //
    

    Error = GetAccountSid( AccountName, &pSid );
    if( NO_ERROR != Error ) return Error;

    Error = SetPrivilegeOnAccount(pSid, L"SeServiceLogonRight"); 
    if( NO_ERROR != Error ) {
        if( NULL != pSid ) LocalFree( pSid );
        return Error;
    }

    Error = LogonUser(
        Uname, DomainName, Passwd, LOGON32_LOGON_SERVICE,
        LOGON32_PROVIDER_WINNT50, &hToken );
    if( FALSE == Error ) {
        Error = GetLastError();
    } else {
        Error = NO_ERROR;
    }

    if( NULL != pSid ) LocalFree( pSid );
    CloseHandle( hToken );
    return Error;
}

DWORD
DhcpSetSecretUnamePasswd(
    IN LPWSTR Uname,
    IN LPWSTR DomainName,
    IN LPWSTR Passwd
    )
{
    DWORD Error, Size;
    UNICODE_STRING Str;
    WCHAR LocalDomainName[300];
    
    if( NULL == Uname || Uname[0] == L'\0' ) {
        Error = SetSecretValue(
            DHCP_SECRET_UNAME_KEY, NULL, 0 );
        if( NO_ERROR != Error ) return Error;

        Error = SetSecretValue(
            DHCP_SECRET_DOMAIN_KEY, NULL, 0 );
        if( NO_ERROR != Error ) return Error;

        Error = SetSecretValue(
            DHCP_SECRET_DNS_PASSWD_KEY, NULL, 0 );
        return Error;
    }

    if( NULL == Passwd ) Passwd = L"";

    if( NULL == DomainName || DomainName[0] == L'\0' ) {
        //
        // Empty domain is local domain.
        //

        Size = sizeof(LocalDomainName)/sizeof(WCHAR);
        Error = GetComputerNameEx(
            ComputerNameDnsHostname, LocalDomainName, &Size );
        if( FALSE == Error ) return GetLastError();

        DomainName = (LPWSTR)LocalDomainName;
    }
        
    Str.Length = (USHORT)(wcslen(Passwd)*sizeof(WCHAR));
    Str.MaximumLength = Str.Length;
    Str.Buffer = (PVOID)Passwd;
    
    RtlRunDecodeUnicodeString( DHCP_ENCODE_SEED, &Str );

    Error =  VerifyAccount(Uname, DomainName, Passwd );
    if( NO_ERROR != Error ) goto Cleanup;
        
    Size = sizeof(WCHAR)*(1+wcslen(Uname));

    Error = SetSecretValue(
        DHCP_SECRET_UNAME_KEY, Uname, Size );
    if( NO_ERROR != Error ) goto Cleanup;

    Size = sizeof(WCHAR)*(1+wcslen(DomainName));

    Error = SetSecretValue(
        DHCP_SECRET_DOMAIN_KEY, DomainName, Size );
    if( NO_ERROR != Error ) goto Cleanup;

    Size = sizeof(WCHAR)*(wcslen(Passwd));

    Error = SetSecretValue(
        DHCP_SECRET_DNS_PASSWD_KEY, Passwd, Size );

 Cleanup:

    ZeroMemory( Passwd, wcslen(Passwd)*sizeof(WCHAR));
    
    return Error;
}


DWORD
DhcpInitSecrets(
    VOID
)
/*++

Routine description

    Initialize this module, take care of multiple initializations..
    NOT Thread safe (if multiple people intialize won't work well).

Return Value

    Win32 error codes

--*/
{
    DWORD                          Error;

    if( Initialized ) return ERROR_SUCCESS;

    Error = OpenPolicy(&GlobalPolicyHandle);

    if( ERROR_SUCCESS == Error ) Initialized ++;
    return Error;
}

VOID
DhcpCleanupSecrets(
    VOID
)
/*++


Routine description

    Undo the effect of DhcpInitSecrets -- keep track of # of calls to init & cleanup.
    NOT Thread safe

Return Value

    Win32 error code

--*/
{
    if( 0 == Initialized ) return;

    Initialized --;
    if( 0 == Initialized ) {
        LsaClose(GlobalPolicyHandle);
        GlobalPolicyHandle = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\servtest.c ===
/*++

Copyright (C) 1998 Microsoft Corporation

--*/

#include <dhcppch.h>

// Dont update status from this module.. Should not do it now..
#define UpdateStatus()

BOOL
LoadStrings(); // main.c

DWORD
InitializeData(); // main.c

DWORD
DhcpTestInitialize(                                       // global data struct init..
    VOID
) {
    DWORD                          threadId;
    DWORD                          Error;
    WSADATA                        wsaData;
    DWORD                          i;
    DWORD                          DsThreadId;
    HANDLE                         DsThreadHandle;

    DhcpGlobalUseNoDns = 1;

    //
    // prepare to use the debug heap
    //

    INIT_DEBUG_HEAP( HEAPX_NORMAL );

    //
    // Initialize globals
    //

    // set to TRUE after rogue detection part decides it's ok to service
    DhcpGlobalOkToService = FALSE;
    DhcpGlobalDSDomainAnsi = NULL;

    DhcpLeaseExtension = 0;

    DhcpGlobalRegRoot = NULL;
    DhcpGlobalRegConfig = NULL;
    DhcpGlobalRegSubnets = NULL;
    DhcpGlobalRegMScopes = NULL;
    DhcpGlobalRegOptionInfo = NULL;
    DhcpGlobalRegGlobalOptions = NULL;
    DhcpGlobalRegSuperScope = NULL;    // added by t-cheny: superscope
    DhcpGlobalRegParam = NULL;

    DhcpGlobalTotalNumSubnets = 0;     // added by t-cheny: superscope
    DhcpGlobalNumberOfNetsActive = 0;

    DhcpGlobalSubnetsListModified = TRUE;
    DhcpGlobalSubnetsListEmpty = FALSE;

    DhcpGlobalJetServerSession = 0;
    DhcpGlobalDatabaseHandle = 0;
    DhcpGlobalClientTableHandle = 0;
    DhcpGlobalClientTable = NULL;


    DhcpGlobalProcessTerminationEvent = NULL;
    DhcpGlobalScavengerTimeout = 0;
    DhcpGlobalProcessorHandle = NULL;
    DhcpGlobalMessageHandle = NULL;
    DhcpGlobalRecomputeTimerEvent = NULL;

    DhcpGlobalRpcStarted = FALSE;

    DhcpGlobalOemDatabasePath = NULL;
    DhcpGlobalOemBackupPath = NULL;
    DhcpGlobalOemJetBackupPath = NULL;
    DhcpGlobalOemDatabaseName = NULL;
    DhcpGlobalBackupConfigFileName = NULL;

    DhcpGlobalBackupInterval = DEFAULT_BACKUP_INTERVAL;
    DhcpGlobalDatabaseLoggingFlag = DEFAULT_LOGGING_FLAG;
    DhcpGlobalRestoreFlag = DEFAULT_RESTORE_FLAG;

    DhcpGlobalAuditLogFlag = DEFAULT_AUDIT_LOG_FLAG;
    g_hAuditLog = NULL;
    DhcpGlobalDetectConflictRetries = DEFAULT_DETECT_CONFLICT_RETRIES;

    DhcpGlobalCleanupInterval = DHCP_DATABASE_CLEANUP_INTERVAL;

    DhcpGlobalRpcProtocols = 0;

    DhcpGlobalScavengeIpAddressInterval = DHCP_SCAVENGE_IP_ADDRESS;
    DhcpGlobalScavengeIpAddress = FALSE;

    DhcpGlobalSystemShuttingDown = FALSE;
    DhcpGlobalServiceStopping = FALSE;

    InitializeCriticalSection(&DhcpGlobalJetDatabaseCritSect);
    InitializeCriticalSection(&DhcpGlobalRegCritSect);
    InitializeCriticalSection(&DhcpGlobalInProgressCritSect);
    InitializeCriticalSection(&DhcpGlobalMemoryCritSect);
    InitializeCriticalSection(&g_ProcessMessageCritSect );

    DhcpGlobalMessageQueueLength = DHCP_RECV_QUEUE_LENGTH;
    InitializeListHead(&DhcpGlobalFreeRecvList);
    InitializeListHead(&DhcpGlobalActiveRecvList);
    InitializeCriticalSection(&DhcpGlobalRecvListCritSect);
    DhcpGlobalRecvEvent = NULL;


#if DBG
    DhcpGlobalDebugFlag = 0xFFFF | DEBUG_LOG_IN_FILE | DEBUG_ALLOC;

    Error = DhcpMemInit();
    if( ERROR_SUCCESS != Error ) return Error;


    InitializeCriticalSection(&DhcpGlobalDebugFileCritSect);
    DhcpGlobalDebugFileHandle = NULL;

    DhcpGlobalDebugFileMaxSize = DEFAULT_MAXIMUM_DEBUGFILE_SIZE;
    DhcpGlobalDebugSharePath = NULL;

    //
    // Open debug log file.
    //

    DhcpOpenDebugFile( FALSE );  // not a reopen.

#endif

    DhcpInitDnsMemory();

    DhcpGlobalServerStartTime.dwLowDateTime = 0;
    DhcpGlobalServerStartTime.dwHighDateTime = 0;

    DhcpGlobalSecurityDescriptor = NULL;
    DhcpGlobalWellKnownSIDsMade = FALSE;

    //
    // Initialize all the status fields so that subsequent calls to
    // SetServiceStatus need to only update fields that changed.
    //

    DhcpGlobalServiceStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    DhcpGlobalServiceStatus.dwCurrentState = SERVICE_START_PENDING;
    DhcpGlobalServiceStatus.dwControlsAccepted = 0;
    DhcpGlobalServiceStatus.dwCheckPoint = 1;
    DhcpGlobalServiceStatus.dwWaitHint = 60000; // 60 secs.
    DhcpGlobalServiceStatus.dwWin32ExitCode = ERROR_SUCCESS;
    DhcpGlobalServiceStatus.dwServiceSpecificExitCode = 0;

    //
    // Tell Service Controller that we are start pending.
    //

    UpdateStatus();

    //
    // Create the process termination event.
    //

    DhcpGlobalProcessTerminationEvent =
        CreateEvent(
            NULL,      // no security descriptor
            TRUE,      // MANUAL reset
            FALSE,     // initial state: not signalled
            NULL);     // no name

    if ( DhcpGlobalProcessTerminationEvent == NULL ) {
        Error = GetLastError();
        DhcpPrint((DEBUG_INIT, "Can't create ProcessTerminationEvent, "
                    "%ld.\n", Error));
        return(Error);
    }


    //
    // create the ProcessMessage termination event
    //

    g_hevtProcessMessageComplete = CreateEvent(
        NULL,
        FALSE,
        FALSE,
        NULL
    );

    if ( !g_hevtProcessMessageComplete ) {
        Error = GetLastError();

        DhcpPrint( (DEBUG_INIT,
                    "Initialize(...) CreateEvent returned error %x\n",
                    Error )
                );

        return Error;
    }

    DhcpPrint(( DEBUG_INIT, "Initializing .. \n", 0 ));


    //
    // load localized messages from the string table
    //

    if ( !LoadStrings() )
    {
        DhcpPrint(( DEBUG_INIT, "Unable to load string table.\n" ));

        DhcpServerEventLog(
                EVENT_SERVER_INIT_DATA_FAILED,
                EVENTLOG_ERROR_TYPE,
                ERROR_NOT_ENOUGH_MEMORY );

        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // start up winsock
    //
    //

    Error = WSAStartup( WS_VERSION_REQUIRED, &wsaData);
    if ( Error != ERROR_SUCCESS ) {
        DhcpPrint(( DEBUG_INIT, "WSAStartup failed, %ld.\n", Error ));

        DhcpServerEventLog(
            EVENT_SERVER_INIT_WINSOCK_FAILED,
            EVENTLOG_ERROR_TYPE,
            Error );

        return(Error);
    }

    Error = InitializeData();
    if ( Error != ERROR_SUCCESS ) {
        DhcpPrint(( DEBUG_INIT, "Data initialization failed, %ld.\n",
                        Error ));

        DhcpServerEventLog(
            EVENT_SERVER_INIT_DATA_FAILED,
            EVENTLOG_ERROR_TYPE,
            Error );

        return(Error);
    }

    DhcpPrint(( DEBUG_INIT, "Data initialization succeeded.\n", 0 ));

    //
    // send heart beat to the service controller.
    //
    //

    DhcpGlobalServiceStatus.dwCheckPoint++;
    UpdateStatus();


    Error = PerfInit();
    if( ERROR_SUCCESS != Error ) {
        return Error;
    }

    Error = DhcpConfigInit();                   // do the main reg. init. here.
    if( ERROR_SUCCESS != Error ) {                // could not get critical info
        DhcpPrint(( DEBUG_ERRORS, "Error reading registry : %ld\n", Error));
        DhcpServerEventLog(
            EVENT_SERVER_INIT_REGISTRY_FAILED,
            EVENTLOG_ERROR_TYPE,
            Error
        );

        return Error;
    }

    Error = DhcpInitializeRegistry();             // older init proc. appendage, will go sometime.
    if ( Error != ERROR_SUCCESS ) {
        DhcpPrint(( DEBUG_ERRORS, "New Registry initialization failed, %ld.\n", Error ));
        DhcpServerEventLog(
            EVENT_SERVER_INIT_REGISTRY_FAILED,
            EVENTLOG_ERROR_TYPE,
            Error
        );
        return Error;
    }


#if DBG
    //
    // break in the debugger if we are asked to do so.
    //

    if(DhcpGlobalDebugFlag & DEBUG_STARTUP_BRK) {
        // Here comes the kludge... NTSD will not be able to
        // get this because we wont know the pid of tcpsvcs.exe
        // to catch this.... So, we print messages and sleep
        // for about a minute to enable others to catch it.
        // To avoid problems, we sleep 10 seconds at a time,
        // and print messages, and do this 6 times. (Updating
        // SC with hearbeats....)
        DWORD i;

        for( i = 0 ; i < 6 && (DhcpGlobalDebugFlag & DEBUG_STARTUP_BRK) ; i ++ ) {
            DhcpPrint((DEBUG_MISC, "Going to break into debugger soon\n"));
            Sleep(5000);
            UpdateStatus();
        }

        DebugBreak();
    }

#endif

    DhcpPrint(( DEBUG_INIT, "Registry initialization succeeded.\n", 0));

    Error = DhcpAuditLogInit();
    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_INIT, "AuditLog failed 0x%lx\n", Error));
        return Error;
    }


    //
    // send heart beat to the service controller.
    //
    //

    DhcpGlobalServiceStatus.dwCheckPoint++;
    UpdateStatus();

    //
    // restore the database and registry configurations if we are asked
    // to do so.
    //

    if( DhcpGlobalRestoreFlag ) {

        Error = DhcpRestoreConfiguration( DhcpGlobalBackupConfigFileName );

        if ( Error != ERROR_SUCCESS ) {
            DhcpPrint(( DEBUG_ERRORS,
                "DhcpRestoreConfiguration failed, %ld.\n", Error ));

            DhcpServerEventLog(
                EVENT_SERVER_CONFIG_RESTORE_FAILED,
                EVENTLOG_ERROR_TYPE,
                Error );

            return(Error);
        }

        Error = DhcpRestoreDatabase( DhcpGlobalOemJetBackupPath );

        if ( Error != ERROR_SUCCESS ) {
            DhcpPrint(( DEBUG_ERRORS,
                "DhcpRestoreDatabase failed, %ld.\n", Error ));

            DhcpServerEventLog(
                EVENT_SERVER_DATABASE_RESTORE_FAILED,
                EVENTLOG_ERROR_TYPE,
                Error );

            return(Error);
        }

        //
        // reset restore flag in registry, so that we don't do the
        // restore again in the next reboot.
        //

        DhcpGlobalRestoreFlag = FALSE;
        Error = RegSetValueEx(
                    DhcpGlobalRegParam,
                    DHCP_RESTORE_FLAG_VALUE,
                    0,
                    DHCP_RESTORE_FLAG_VALUE_TYPE,
                    (LPBYTE)&DhcpGlobalRestoreFlag,
                    sizeof(DhcpGlobalRestoreFlag)
                    );

        DhcpAssert( Error == ERROR_SUCCESS );
    }

    Error = DhcpInitializeDatabase();
    if ( Error != ERROR_SUCCESS ) {
        DhcpPrint(( DEBUG_ERRORS, "Database init failed, %ld.\n", Error ));

        DhcpServerEventLog(
            EVENT_SERVER_INIT_DATABASE_FAILED,
            EVENTLOG_ERROR_TYPE,
            Error );

        //
        // the database/logfile may be corrupt, try to restore the
        // database from backup and retry database initialization once
        // again
        //

        Error = DhcpRestoreDatabase( DhcpGlobalOemJetBackupPath );

        if ( Error != ERROR_SUCCESS ) {
            DhcpPrint(( DEBUG_ERRORS,
                "DhcpRestoreDatabase failed, %ld.\n", Error ));

            DhcpServerEventLog(
                EVENT_SERVER_DATABASE_RESTORE_FAILED,
                EVENTLOG_ERROR_TYPE,
                Error );

            return(Error);
        }

        Error = DhcpInitializeDatabase();

        if ( Error != ERROR_SUCCESS ) {
            DhcpPrint(( DEBUG_ERRORS,
                "Database init failed again, %ld.\n", Error ));

            DhcpServerEventLog(
                EVENT_SERVER_INIT_DATABASE_FAILED,
                EVENTLOG_ERROR_TYPE,
                Error );

            return(Error);
        }
    }

    DhcpPrint(( DEBUG_INIT, "Database initialization succeeded.\n", 0));

    CalloutInit();

    return ERROR_SUCCESS;
}


VOID
MainLoop( VOID ) {
    DHCP_IP_ADDRESS IpAddress = inet_addr( "157.55.55.157" );
    BYTE            HwAddr[1000] = "HwAddr" ;
    DWORD           HwAddrLen = sizeof(HwAddr);
    DWORD           TimeSec   = 1000;
    DATE_TIME       LeaseTime;
    WCHAR           MachineName[1000];
    WCHAR           ClientComment[1000];
    BYTE            ClientType  = 0;
    DHCP_IP_ADDRESS ServAddress = inet_addr("255.255.255.255");
    BYTE            AddressState = ADDRESS_STATE_ACTIVE;
    BOOL            OpenExisting = FALSE;
    DATE_TIME           TimeNow;
    DWORD           Error = ERROR_SUCCESS, Count = 0;
    DWORD
        CleanupDatabase(                                       // tidies up the database by removing expired leases
            IN      DATE_TIME*             TimeNow,            // current time standard
            IN      BOOL                   DeleteExpiredLeases // expired leases be deleted right away? or just set state="doomed"
            );
    
#if !defined(DBG) || !DBG
    return; // should not do anything in retail builds.
#endif

    Error = DhcpTestInitialize();
    if( ERROR_SUCCESS != Error ) {
        fprintf(stderr, "Error: %ld\n", Error);
        exit(1);
    }


    for( Count = 0 ; Count < 100; Count ++ ) {

        Error = DhcpCreateClientEntry(Count, (LPBYTE)&Count, sizeof(Count), DhcpCalculateTime(0), NULL, NULL, 0, 0,
                    ADDRESS_STATE_DECLINED, FALSE);

        printf("CreateClientEntry: %ld (0x%lx)\n", Error, Error);
        Count ++;
    }

    while( 1 ) {

        Count ++;
        TimeNow = DhcpCalculateTime(0);

        Error = DhcpCreateClientEntry(
            Count,
            (LPBYTE)&Count,
            sizeof(Count),
            DhcpCalculateTime(0), NULL, NULL,
            0, 0,
            ADDRESS_STATE_DECLINED,
            FALSE);
        printf("CreateClientEntry: %ld (0x%lx)\n", Error, Error);
        
        {
            void AuditLogStop(void), AuditLogStart(void);
            extern DWORD CurrentDay;

            CurrentDay++;
            CurrentDay = ( CurrentDay % 7 );
            AuditLogStop();
            AuditLogStart();
        }
        
        Error = CleanupDatabase(&TimeNow, FALSE);
        printf("Cleanup: %ld (0x%lx)\n", Error, Error);
        
        //Error = DhcpBackupDatabase(DhcpGlobalOemJetBackupPath, TRUE);
        //printf("Backup: %ld (0x%lx)\n", Error, Error);

        Count ++;

        Error = DhcpCreateClientEntry(
            Count,
            (LPBYTE)&Count,
            sizeof(Count),
            DhcpCalculateTime(0), NULL, NULL,
            0, 0,
            ADDRESS_STATE_DECLINED,
            FALSE);
        printf("CreateClientEntry: %ld (0x%lx)\n", Error, Error);

        Error = DhcpBackupDatabase(NULL, TRUE);
        printf("DhcpBackupDatabase: %ld (0x%lx)\n", Error, Error);
    }


    while(1) {
        DWORD  xClientType, xAddressState, xOpenExisting;
        BYTE   ipaddr_buf[500], servaddr_buf[500];

        xOpenExisting = 696;
        // Read from input a bunch of lines, each one for each record.
        // Then go ahead and add it up into the database..
        printf("NextInput:");
        Error = scanf("%s %s %d %d %ws %ws %d %s %d %d",
              ipaddr_buf, HwAddr, &HwAddrLen, &TimeSec, MachineName, ClientComment,
              &xClientType, servaddr_buf, &xAddressState, &xOpenExisting);

        //if( Error < 0 || 696 == xOpenExisting ) break;

        IpAddress = inet_addr(ipaddr_buf);
        LeaseTime = DhcpCalculateTime(TimeSec);
        ClientType = (BYTE)xClientType;
        ServAddress = inet_addr(servaddr_buf);
        AddressState = (BYTE)xAddressState;
        OpenExisting = (BYTE)xOpenExisting;

        printf("IP=%s Hw=%s HwLen=%d Expires=%d Machine=%ws (%ws) Type=%d Server=%s State=%d Exists=%s\n",
               inet_ntoa(*(struct in_addr *) &IpAddress),
               HwAddr, HwAddrLen, TimeSec, MachineName, ClientComment, ClientType,
               inet_ntoa(*(struct in_addr *) &ServAddress),
               AddressState, OpenExisting?"TRUE":"FALSE");
        IpAddress = htonl(IpAddress);
        Error = DhcpCreateClientEntry(IpAddress, HwAddr, HwAddrLen, LeaseTime, MachineName,
                                      ClientComment, ClientType, ServAddress, AddressState, OpenExisting);

        fprintf(stderr, "DhcpCreateClientEntry: %ld %x\n", Error, Error);
        OpenExisting = TRUE;

        Error = DhcpCreateClientEntry(IpAddress, HwAddr, HwAddrLen, LeaseTime, MachineName,
                                      ClientComment, ClientType, ServAddress, AddressState, OpenExisting);

        fprintf(stderr, "DhcpCreateClientEntry: %ld, %x\n", Error, Error);
    }

    printf("Good bye\n");
    DhcpCleanupDatabase(0);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\scavengr.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    scavengr.c

Abstract:

    This is the scavenger thread for the DHCP server.

Author:

    Madan Appiah (madana)  10-Sep-1993

Environment:

    User Mode - Win32

Revision History:

--*/

#include "dhcppch.h"
#include "mdhcpsrv.h"

//
// For every few records, release and take the lock.
//
DWORD DhcpGlobalLockedRecordsCount = 50;
//
// Stop scavenging if it takes over limit.
//
DWORD DhcpGlobalMaxScavengeTime = 3*60*1000;

DWORD DhcpGlobalScavengeStartAddress = 0;

DWORD
QueryMibInfo(
    LPDHCP_MIB_INFO *MibInfo
);

DWORD
QueryMCastMibInfo(
    LPDHCP_MCAST_MIB_INFO *MibInfo
);

DWORD
NextEventTime(
    LPDHCP_TIMER Timers,
    DWORD NumTimers,
    LPDWORD TimeOut
    )
/*++

Routine Description:

    This function walks through the timer array and returns the next
    timer to fire and the time in msecs to go.

Arguments:

    Timers - Timer Array.

    NumTimers - number of timer blocks in the above array.

    TimeOut - timeout in secs, returned.

Return Value:

    Next Timer ID to fire.

--*/
{
    DATE_TIME LocalTimeOut;
    DATE_TIME TimeNow;
    ULONGLONG NextFire = ~0;
    DWORD EventID, i;

    for ( i = EventID = 0 ; i < NumTimers ; i++ ) {
        ULONGLONG CurrentNextFire;

        //
        // findout time when need to fire this timer.
        //

        CurrentNextFire = ( *(ULONGLONG UNALIGNED *)&Timers[i].LastFiredTime
                            + *Timers[i].Period * (ULONGLONG)10000 );

        //
        // Find least value
        //

        if( CurrentNextFire < NextFire ) {
            NextFire = CurrentNextFire;
            EventID = i;
        }
    }


    TimeNow = DhcpGetDateTime();
    LocalTimeOut.dwLowDateTime = 0;
    LocalTimeOut.dwHighDateTime = 0;


    //
    // if the timer has already fired then we don't have to sleep
    // any further, so return timeout zero.
    //


    *TimeOut = 0 ;

    if ( CompareFileTime(
        (FILETIME *)&NextFire,
        (FILETIME *)&TimeNow ) > 0 ) {

        //
        // findout time in msecs to go still.
        //

        *(ULONGLONG UNALIGNED *)&LocalTimeOut = (
            ( *(ULONGLONG UNALIGNED *)&NextFire - *(ULONGLONG UNALIGNED *)&TimeNow ) / 10000
        ) ;

        DhcpAssert( LocalTimeOut.dwHighDateTime == 0 );
        *TimeOut = LocalTimeOut.dwLowDateTime;
    }

    DhcpPrint(( DEBUG_SCAVENGER,"Next Timer Event: %ld, Time: %ld (msecs)\n",
                EventID, *TimeOut ));

    return EventID;
}

DWORD
CleanupClientRequests(                                 // removes all pending client requests
    IN      DATE_TIME*             TimeNow,            // remove iff client's expiration time < TimeNow
    IN      BOOL                   CleanupAll
)
{
    DWORD                          Error;
    DATE_TIME                      ZeroTime = {0, 0};

    LOCK_INPROGRESS_LIST();
    Error = DhcpDeleteExpiredCtxt(CleanupAll ? ZeroTime : *TimeNow);
    UNLOCK_INPROGRESS_LIST();

    return Error;
}

VOID
DynBootpCallback(
    IN      ULONG                  IpAddress,
    IN      LPBYTE                 HwAddr,
    IN      ULONG                  HwLen,
    IN      BOOL                   Reachable
)
{
    ULONG                          Error;
    ULONG                          HwLen1 = 0, SubnetAddr;
    LPBYTE                         HwAddr1 = NULL;
    ULONG                          HwType;
    
    if( Reachable ) {
        //
        // This machine is still around, do not delete it
        //
        DhcpPrint((DEBUG_PING, "DynBootpCallback for 0x%08lx -- machine is reachable\n", IpAddress));
        return;
    }

    LOCK_DATABASE();
    do {
        Error = DhcpJetOpenKey(
            DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,
            (PVOID)&IpAddress,
            sizeof(IpAddress)
            );
        if( ERROR_SUCCESS != Error ) {
            DhcpPrint((DEBUG_ERRORS, "DynBootpCallback for 0x%08lx erred 0x%lx\n", IpAddress, Error ));
            break;
        }

        Error = DhcpJetGetValue(
            DhcpGlobalClientTable[HARDWARE_ADDRESS_INDEX].ColHandle,
            &HwAddr1,
            &HwLen1
            );
        if( ERROR_SUCCESS != Error ) {
            DhcpPrint((DEBUG_ERRORS, "DynBootpCallback for 0x%08lx erred in hw check 0x%lx\n", IpAddress, Error ));
            break;
        }

        if( HwLen1 != HwLen && 0 != memcmp( HwAddr1, HwAddr, HwLen1) ) {
            DhcpPrint((DEBUG_ERRORS, "DynBootpCallback for 0x%08lx mismatched hw addr\n", IpAddress));
            break;
        }

        Error = DhcpReleaseBootpAddress(IpAddress);
        if( ERROR_SUCCESS != Error ) {
            DhcpPrint((DEBUG_ERRORS,"DynBootpCallback for 0x%08lx failed releasebootaddress: %lx\n",
                       IpAddress, Error));
            break;
        }

        Error = DhcpJetBeginTransaction();
        if( ERROR_SUCCESS != Error ) {
            DhcpAssert(FALSE);
            break;
        }

        //
        // Give DynDNS a chance but ignore any possible errors
        //

        Error = DhcpDoDynDnsCheckDelete(IpAddress);
        Error = ERROR_SUCCESS;

        Error = DhcpJetDeleteCurrentRecord();

        if( ERROR_SUCCESS != Error ) {
            Error = DhcpJetRollBack();
            DhcpAssert(ERROR_SUCCESS == Error);
            break;
        } else {
            Error = DhcpJetCommitTransaction();
        }
        DhcpAssert(ERROR_SUCCESS == Error);

        DhcpUpdateAuditLog(
            DHCP_IP_BOOTP_LOG_DELETED,
            GETSTRING(DHCP_IP_BOOTP_LOG_DELETED_NAME),
            IpAddress,
            HwAddr,
            HwLen,
            NULL
            );
        SubnetAddr = (
            DhcpGetSubnetMaskForAddress(IpAddress) & IpAddress
            );
        if( HwLen > sizeof(SubnetAddr) &&
            0 == memcmp((PVOID)&SubnetAddr, HwAddr, sizeof(SubnetAddr) ) ) {
            //
            // Hardware address has a prefix of subnet-address.. remove it..
            //
            HwAddr += sizeof(SubnetAddr);
            HwLen -= sizeof(SubnetAddr);
        }
        
        if( HwLen ) {
            HwLen --;
            HwType = *HwAddr ++;
        } else {
            HwAddr = NULL;
            HwLen = 0;
            HwType = 0;
        }

        CALLOUT_DELETED(IpAddress, HwAddr, HwLen, HwType);

    } while ( 0 );

    UNLOCK_DATABASE();
    if( HwAddr1 ) MIDL_user_free(HwAddr1);
}

DWORD
DoIcmpRequestForDynBootp(
    IN      ULONG                  IpAddress,
    IN      LPBYTE                 HwAddr,
    IN      ULONG                  HwLen,
    IN      VOID                   (*Callback) ( ULONG IpAddress, LPBYTE HwAddr, ULONG HwLen, BOOL Reachable)
);

DWORD
CheckDynamicBootpClient(
    IN      DHCP_IP_ADDRESS        IpAddress
)
{
    DWORD                          Error;
    LPBYTE                         HwAddr = NULL;
    ULONG                          HwLen = 0;

    //
    // First read the hw-address for later use
    //

    Error = DhcpJetGetValue(
        DhcpGlobalClientTable[HARDWARE_ADDRESS_INDEX].ColHandle,
        &HwAddr,
        &HwLen
        );
    if( ERROR_SUCCESS != Error ) return Error;

    //
    // Now make the Asycn Ping call and wait till ping succeeds..
    //
    Error = DoIcmpRequestForDynBootp(
        IpAddress,
        HwAddr,
        HwLen,
        DynBootpCallback
        );

    if( HwAddr ) MIDL_user_free( HwAddr );
    return Error;
}

DWORD
CleanupIpDatabase(
    IN      DATE_TIME*             TimeNow,            // current time standard
    IN      DATE_TIME*             DoomTime,           // Time when the records become 'doom'
    IN      BOOL                   DeleteExpiredLeases,// expired leases be deleted right away? or just set state="doomed"
    OUT     ULONG*                 nExpiredLeases,
    OUT     ULONG*                 nDeletedLeases
)
{
    JET_ERR                        JetError;
    DWORD                          Error;
    FILETIME                       leaseExpires;
    DWORD                          dataSize;
    LPBYTE                         HwAddr = NULL, HwAddr2;
    ULONG                          HwLen = 0;
    DHCP_IP_ADDRESS                ipAddress, SubnetAddr;
    DHCP_IP_ADDRESS                NextIpAddress;
    BYTE                           AddressState;
    BOOL                           DatabaseLocked = FALSE;
    BOOL                           RegistryLocked = FALSE;
    DWORD                          i;
    BYTE                            bAllowedClientTypes;
    DWORD                          ReturnError = ERROR_SUCCESS;
    ULONG                          LockedCount = 0;
    ULONG_PTR                      ScavengeEndTime = 0;

    DhcpPrint(( DEBUG_MISC, "Cleaning up IP database table.\n"));
    //
    // Get the first user record's IpAddress.
    //

    (*nDeletedLeases) = (*nExpiredLeases) = 0;

    LockedCount = DhcpGlobalLockedRecordsCount;
    ScavengeEndTime = time(NULL) + DhcpGlobalMaxScavengeTime;
   
    LOCK_DATABASE();
    DatabaseLocked = TRUE;
    Error = DhcpJetPrepareSearch(
        DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,
        TRUE,   // Search from start
        NULL,
        0
    );
    if( Error != ERROR_SUCCESS ) goto Cleanup;

    dataSize = sizeof( NextIpAddress );
    Error = DhcpJetGetValue(
        DhcpGlobalClientTable[IPADDRESS_INDEX].ColHandle,
        &NextIpAddress,
        &dataSize
    );
    if( Error != ERROR_SUCCESS ) goto Cleanup;
    DhcpAssert( dataSize == sizeof( NextIpAddress )) ;


    //
    // Start from where we left off ..
    //
    if( DeleteExpiredLeases ) {
        DhcpGlobalScavengeStartAddress = 0;
    } else if( 0 != DhcpGlobalScavengeStartAddress ) {
        NextIpAddress = DhcpGlobalScavengeStartAddress;
        DhcpGlobalScavengeStartAddress ++;
    }
        
    //
    // Walk through the entire database looking for expired leases to
    // free up.
    //
    //

    for ( ;; ) {

        //
        // return to caller when the service is shutting down.
        //

        if ( DhcpGlobalServiceStopping ) {
            Error = ERROR_SUCCESS;
            goto Cleanup;
        }

        //
        // lock both registry and database locks here to avoid dead lock.
        //

        if( !DatabaseLocked ) {
            LOCK_DATABASE();
            DatabaseLocked = TRUE;
        }

        //
        // Seek to the next record.
        //

        JetError = JetSetCurrentIndex(
            DhcpGlobalJetServerSession,
            DhcpGlobalClientTableHandle,
            DhcpGlobalClientTable[IPADDRESS_INDEX].ColName
        );

        Error = DhcpMapJetError( JetError, "Cleanup:SetCurrentIndex" );
        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        JetError = JetMakeKey(
            DhcpGlobalJetServerSession,
            DhcpGlobalClientTableHandle,
            &NextIpAddress,
            sizeof( NextIpAddress ),
            JET_bitNewKey
        );

        Error = DhcpMapJetError( JetError, "Cleanup:MakeKey" );
        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        // Seek to the next record or greater to process. When we
        // processed last record we noted down the next record to
        // process, however the next record may have been deleted when
        // we unlocked the database lock. So moving to the next or
        // greater record will make us to move forward.

        JetError = JetSeek(
            DhcpGlobalJetServerSession,
            DhcpGlobalClientTableHandle,
            JET_bitSeekGE
        );

        // #if0 when JET_errNoCurrentRecord removed (see scavengr.c@v25);
        // that code tried to go back to start of file when scanned everything.

        Error = DhcpMapJetError( JetError, "Cleanup:Seek" );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        //
        // read the IP address of current record.
        //

        dataSize = sizeof( ipAddress );
        Error = DhcpJetGetValue(
            DhcpGlobalClientTable[IPADDRESS_INDEX].ColHandle,
            &ipAddress,
            &dataSize
        );
        if( Error != ERROR_SUCCESS ) {
            goto ContinueError;
        }

        if( FALSE == DeleteExpiredLeases ) {
            DhcpGlobalScavengeStartAddress = ipAddress;
        }
        
        DhcpAssert( dataSize == sizeof( ipAddress )) ;

        //
        // if this is reserved entry don't delete.
        //

        if( DhcpServerIsAddressReserved(DhcpGetCurrentServer(), ipAddress) ) {
            Error = ERROR_SUCCESS;
            goto ContinueError;
        }

        dataSize = sizeof( leaseExpires );
        Error = DhcpJetGetValue(
            DhcpGlobalClientTable[LEASE_TERMINATE_INDEX].ColHandle,
            &leaseExpires,
            &dataSize
        );

        if( Error != ERROR_SUCCESS ) {
            goto ContinueError;
        }

        DhcpAssert(dataSize == sizeof( leaseExpires ) );

        // Now get the address state, and if we need to do a DhcpDnsAsync call,
        // do it now.
        if( !USE_NO_DNS ) {
            dataSize = sizeof(AddressState);
            Error = DhcpJetGetValue(
                DhcpGlobalClientTable[STATE_INDEX].ColHandle,
                &AddressState,
                &dataSize
            );
            if(ERROR_SUCCESS != Error) {
                DhcpPrint((DEBUG_ERRORS, "Could not get address state!: Jet:%ld\n",Error));
                DhcpAssert(FALSE);
            } else {
                Error = DhcpJetBeginTransaction();

                if( ERROR_SUCCESS == Error ) {
                    if(IsAddressDeleted(AddressState)) {
                        if( DhcpDoDynDnsCheckDelete(ipAddress) ) {
                            Error = DhcpJetDeleteCurrentRecord();

                            if( ERROR_SUCCESS == Error ) {
                                Error = DhcpJetCommitTransaction();
                            } else {
                                Error = DhcpJetRollBack();
                            }

                            if( ERROR_SUCCESS != Error ) {
                                DhcpPrint((DEBUG_ERRORS, "JetCommitTransaction/RollBack: %ld\n", Error));
                            } else {
                                (*nDeletedLeases) ++;
                                DhcpUpdateAuditLog(
                                    DHCP_IP_LOG_DELETED,
                                    GETSTRING( DHCP_IP_LOG_DELETED_NAME),
                                    ipAddress,
                                    NULL,
                                    0,
                                    NULL
                                );
                            }
                            goto ContinueError;
                        }
                    } else if(IsAddressUnRegistered(AddressState)) {
                        DhcpDoDynDnsRefresh(ipAddress);
                    }

                    Error = DhcpJetCommitTransaction();

                    if( ERROR_SUCCESS != Error ) {
                        DhcpPrint((DEBUG_ERRORS, "JetCommit: %ld\n", Error));
                    }
                }
            }
        }

        // if the LeaseExpired value is not zero and the lease has
        // expired then delete the entry.

        if( CompareFileTime( &leaseExpires, (FILETIME *)TimeNow ) < 0 ) {
            BOOL Deleted;

            //
            // This lease has expired.  Clear the record.
            //

            //
            // Delete this lease if
            //
            //  1. we are asked to delete all expired leases. or
            //
            //  2. the record passed doom time.
            //

            if( DeleteExpiredLeases ||
                    CompareFileTime(
                        &leaseExpires, (FILETIME *)DoomTime ) < 0 ) {
                BYTE ClientType;

                DhcpPrint(( DEBUG_SCAVENGER, "Deleting Client Record %s.\n",
                    DhcpIpAddressToDottedString(ipAddress) ));

                dataSize = sizeof(ClientType);
                Error = DhcpJetGetValue(
                    DhcpGlobalClientTable[CLIENT_TYPE_INDEX].ColHandle,
                    &ClientType,
                    &dataSize
                    );
                if( ERROR_SUCCESS != Error ) {
                    //
                    //
                    //
                    DhcpAssert(FALSE);
                    ClientType = CLIENT_TYPE_DHCP;
                }

                if( CLIENT_TYPE_BOOTP == ClientType ) {
                    //
                    // This is a dynamic BOOTP record... Do not delete it yet!
                    //
                    Error = CheckDynamicBootpClient(ipAddress);
                    goto ContinueError;
                }

                Error = DhcpReleaseAddress( ipAddress );

                if( Error != ERROR_SUCCESS ) {
                    //
                    // Release address can fail if we have already released
                    // address, but dyndns is pending, for instance..
                    // But give one shot by trying to release it as a
                    // BOOTP address..
                    // goto ContinueError;
                    (void)DhcpReleaseBootpAddress( ipAddress );
                    Error = ERROR_SUCCESS;
                }

                HwLen = 0; HwAddr = NULL;
                JetError = DhcpJetGetValue(
                    DhcpGlobalClientTable[HARDWARE_ADDRESS_INDEX].ColHandle,
                    &HwAddr,
                    &HwLen
                );
                if( ERROR_SUCCESS != JetError ) goto ContinueError;

                Error = DhcpJetBeginTransaction();

                if( Error != ERROR_SUCCESS ) {
                    goto Cleanup;
                }
                
                // see if it is okay to delete from DynDns point of view..
                
                if(Deleted = DhcpDoDynDnsCheckDelete(ipAddress)) {
                    Error = DhcpJetDeleteCurrentRecord();
                }

                if( Error != ERROR_SUCCESS ) {

                    Error = DhcpJetRollBack();
                    if( Error != ERROR_SUCCESS ) {
                        goto Cleanup;
                    }

                    goto ContinueError;
                }

                Error = DhcpJetCommitTransaction();

                if( Error != ERROR_SUCCESS ) {
                    goto Cleanup;
                }

                if( Deleted ) (*nDeletedLeases ) ++;
                else (*nExpiredLeases) ++;
                
                DhcpUpdateAuditLog(
                    DHCP_IP_LOG_DELETED,
                    GETSTRING( DHCP_IP_LOG_DELETED_NAME),
                    ipAddress,
                    NULL,
                    0,
                    NULL
                );

                SubnetAddr = (
                    DhcpGetSubnetMaskForAddress(ipAddress) & ipAddress
                    );
                if( HwLen > sizeof(SubnetAddr) &&
                    0 == memcmp((PVOID)&SubnetAddr, HwAddr, sizeof(SubnetAddr) )) {
                    HwAddr2 = HwAddr + sizeof(SubnetAddr);
                    HwLen -= sizeof(SubnetAddr);
                } else {
                    HwAddr2 = HwAddr;
                }
                
                CALLOUT_DELETED(ipAddress, HwAddr2, HwLen, 0);
                if( HwAddr ) DhcpFreeMemory(HwAddr);
                HwAddr = NULL;
                HwLen = 0;
            }
            else {

                //
                // read address State.
                //

                dataSize = sizeof( AddressState );
                Error = DhcpJetGetValue(
                            DhcpGlobalClientTable[STATE_INDEX].ColHandle,
                            &AddressState,
                            &dataSize );

                if( Error != ERROR_SUCCESS ) {
                    goto ContinueError;
                }

                DhcpAssert( dataSize == sizeof( AddressState )) ;

                if( ! IS_ADDRESS_STATE_DOOMED(AddressState) ) {
                    JET_ERR JetError;

                    //
                    // set state to DOOM.
                    //

                    Error = DhcpJetBeginTransaction();

                    if( Error != ERROR_SUCCESS ) {
                        goto Cleanup;
                    }

                    JetError = JetPrepareUpdate(
                                    DhcpGlobalJetServerSession,
                                    DhcpGlobalClientTableHandle,
                                    JET_prepReplace );

                    Error = DhcpMapJetError( JetError, "Cleanup:PrepareUpdate" );

                    if( Error == ERROR_SUCCESS ) {

                        SetAddressStateDoomed(AddressState);
                        Error = DhcpJetSetValue(
                                    DhcpGlobalClientTable[STATE_INDEX].ColHandle,
                                    &AddressState,
                                    sizeof(AddressState) );

                        if( Error == ERROR_SUCCESS ) {
                            Error = DhcpJetCommitUpdate();
                        }
                    }

                    if( Error != ERROR_SUCCESS ) {

                        Error = DhcpJetRollBack();
                        if( Error != ERROR_SUCCESS ) {
                            goto Cleanup;
                        }

                        goto ContinueError;
                    }

                    Error = DhcpJetCommitTransaction();

                    if( Error != ERROR_SUCCESS ) {
                        goto Cleanup;
                    }

                    DhcpUpdateAuditLog(
                        DHCP_IP_LOG_EXPIRED,
                        GETSTRING( DHCP_IP_LOG_EXPIRED_NAME),
                        ipAddress,
                        NULL,
                        0,
                        NULL
                    );
                }
            }
        }

ContinueError:

        if( NULL != HwAddr ) {
            DhcpFreeMemory(HwAddr);
            HwAddr = NULL; HwLen = 0;
        }

        if( Error != ERROR_SUCCESS ) {

            DhcpPrint(( DEBUG_ERRORS,
                "Cleanup current database record failed, %ld.\n",
                    Error ));

            ReturnError = Error;
        }

        Error = DhcpJetNextRecord();

        if( Error == ERROR_NO_MORE_ITEMS ) {
            if( FALSE == DeleteExpiredLeases ) {
                DhcpGlobalScavengeStartAddress = 0;
            }
            Error = ERROR_SUCCESS;
            break;
        }

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        //
        // get next record Ip Address.
        //

        dataSize = sizeof( NextIpAddress );
        Error = DhcpJetGetValue(
                    DhcpGlobalClientTable[IPADDRESS_INDEX].ColHandle,
                    &NextIpAddress,
                    &dataSize );

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        } 

        if( FALSE == DeleteExpiredLeases ) {
            DhcpGlobalScavengeStartAddress = NextIpAddress;
        }

        DhcpAssert( dataSize == sizeof( NextIpAddress )) ;

        //
        // unlock the registry and database locks after each user record
        // processed, so that other threads will get chance to look into
        // the registry and/or database.
        //
        // Since we have noted down the next user record to process,
        // when we resume to process again we know where to start.
        //

        //
        // Unlocking/locking for every record is expensive.  Do this once
        // in a while.  Also, make sure we don't spend too much time scavenging.
        //
        
        if( DatabaseLocked ) {
            LockedCount --;
            if( 0 == LockedCount ) {
                UNLOCK_DATABASE();
                DatabaseLocked = FALSE;
                LockedCount = DhcpGlobalLockedRecordsCount;
            }
            if( FALSE == DeleteExpiredLeases ) {
                if( (ULONG_PTR)time(NULL) >= ScavengeEndTime ) {
                    //
                    // No more scavenging..
                    //
                    goto Cleanup;
                }
            }
        }
    }

    DhcpAssert( Error == ERROR_SUCCESS );

Cleanup:

    if( NULL != HwAddr ) {
        DhcpFreeMemory(HwAddr);
        HwAddr = NULL; HwLen = 0;
    }

    if( DatabaseLocked ) {
        UNLOCK_DATABASE();
    }

    return ReturnError;
}

DWORD
AuditIPAddressUsage()
{
    DWORD                           Error;
    LPDHCP_MIB_INFO                 MibInfo;
    LPSCOPE_MIB_INFO                ScopeInfo;
    DWORD                           i;

    MibInfo = NULL;

    Error = QueryMibInfo( &MibInfo );
    if ( Error != ERROR_SUCCESS ) {
        return Error;
    }

    for ( i = 0, ScopeInfo = MibInfo->ScopeInfo;
          i < MibInfo->Scopes;
          i++, ScopeInfo++ ) {

        IN_ADDR addr;
        DWORD percentage;

        //
        // be careful about divide-by-zero errors.
        //

        if ( ScopeInfo->NumAddressesInuse == 0 &&
                 ScopeInfo->NumAddressesFree == 0 ) {
            continue;
        }

        addr.s_addr = htonl(ScopeInfo->Subnet);

        percentage =
            ( 100 * ScopeInfo->NumAddressesInuse ) /
                (ScopeInfo->NumAddressesInuse + ScopeInfo->NumAddressesFree);

        if ( percentage > DhcpGlobalAlertPercentage &&
                ScopeInfo->NumAddressesFree < DhcpGlobalAlertCount ) {

            LPSTR Strings[3];
            BYTE percentageString[8];
            BYTE remainingString[8];

            _ltoa( percentage, percentageString, 10 );
            _ltoa( ScopeInfo->NumAddressesFree, remainingString, 10 );

            Strings[0] = inet_ntoa( addr );
            Strings[1] = percentageString;
            Strings[2] = remainingString;

            DhcpReportEventA(
                DHCP_EVENT_SERVER,
                EVENT_SERVER_LOW_ADDRESS_WARNING,
                EVENTLOG_WARNING_TYPE,
                3,
                0,
                Strings,
                NULL
                );
        }
    }

    if( MibInfo->ScopeInfo ) MIDL_user_free( MibInfo->ScopeInfo );
    MIDL_user_free( MibInfo );

    return Error;
}

DWORD
AuditMCastAddressUsage()
{
    DWORD                               Error;
    LPDHCP_MCAST_MIB_INFO                MCastMibInfo;
    LPMSCOPE_MIB_INFO                   ScopeInfo;
    DWORD                           i;

    MCastMibInfo = NULL;

    Error = QueryMCastMibInfo( &MCastMibInfo );
    if ( Error != ERROR_SUCCESS ) {
        return Error;
    }

    for ( i = 0, ScopeInfo = MCastMibInfo->ScopeInfo;
          i < MCastMibInfo->Scopes;
          i++, ScopeInfo++ ) {

        IN_ADDR addr;
        DWORD percentage;

        //
        // be careful about divide-by-zero errors.
        //

        if ( ScopeInfo->NumAddressesInuse == 0 &&
                 ScopeInfo->NumAddressesFree == 0 ) {
            continue;
        }

        percentage =
            ( 100 * ScopeInfo->NumAddressesInuse ) /
                (ScopeInfo->NumAddressesInuse + ScopeInfo->NumAddressesFree);

        if ( percentage > DhcpGlobalAlertPercentage &&
                ScopeInfo->NumAddressesFree < DhcpGlobalAlertCount ) {

            LPSTR Strings[3];
            BYTE percentageString[8];
            BYTE remainingString[8];
            CHAR MScopeNameOem[256];

            _ltoa( percentage, percentageString, 10 );
            _ltoa( ScopeInfo->NumAddressesFree, remainingString, 10 );
            Strings[0] = DhcpUnicodeToOem( ScopeInfo->MScopeName, MScopeNameOem  );
            Strings[1] = percentageString;
            Strings[2] = remainingString;

            DhcpReportEventA(
                DHCP_EVENT_SERVER,
                EVENT_SERVER_LOW_ADDRESS_WARNING,
                EVENTLOG_WARNING_TYPE,
                3,
                0,
                Strings,
                NULL
                );
        }
    }

    if(MCastMibInfo->ScopeInfo) MIDL_user_free( MCastMibInfo->ScopeInfo );
    MIDL_user_free( MCastMibInfo );

    return ERROR_SUCCESS;
}

VOID
LogScavengeStats(
    IN ULONG EventId,
    IN ULONG nExpiredLeases,
    IN ULONG nDeletedLeases
    )
{
    DWORD Error;
    LPSTR Strings[2];
    CHAR OemString0[sizeof(DWORD)*4 + 1];
    CHAR OemString1[sizeof(DWORD)*4 + 1];

    Strings[0] = OemString0;
    Strings[1] = OemString1;

    _ultoa( nExpiredLeases, OemString0, 10 );
    _ultoa( nDeletedLeases, OemString1, 10 );

    Error = DhcpReportEventA(
        DHCP_EVENT_SERVER,
        EventId,
        EVENTLOG_INFORMATION_TYPE,
        2,
        0,
        Strings,
        NULL
        );

    if( Error != ERROR_SUCCESS ) {
        DhcpPrint(( DEBUG_ERRORS,
                    "DhcpReportEventW failed, %ld.\n", Error ));
    }

    return;    
} // LogScavengeStats()

DWORD
CleanupDatabase(                                       // tidies up the database by removing expired leases
    IN      DATE_TIME*             TimeNow,            // current time standard
    IN      BOOL                   DeleteExpiredLeases // expired leases be deleted right away? or just set state="doomed"
)
{
    DWORD                          Error;
    HANDLE                         ThreadHandle;
    BOOL                           BoolError;
    DWORD                          ReturnError = ERROR_SUCCESS;
    DATE_TIME                      DoomTime;
    ULONG                          ExpiredLeases, DeletedLeases;
    
    DhcpPrint(( DEBUG_MISC, "Database Cleanup started.\n"));

    //
    // reduce the priority of this thread when we perform the database
    // cleanup. So that we wouldn't hog the CPU when we do the cleanup
    // of big database. Also let the message processing thread work
    // faster.
    //

    ThreadHandle = GetCurrentThread();
    BoolError = SetThreadPriority(
        ThreadHandle,
        THREAD_PRIORITY_BELOW_NORMAL
    );
    DhcpAssert( BoolError );

    *(ULONGLONG UNALIGNED *)&DoomTime =
            *(ULONGLONG UNALIGNED *)TimeNow -
                DhcpLeaseExtension * (ULONGLONG)10000000;

    DhcpServerEventLog(
        EVENT_SERVER_CLEANUP_STARTED,
        EVENTLOG_INFORMATION_TYPE,
        0
        );
    
    Error = CleanupIpDatabase(
        TimeNow,&DoomTime,DeleteExpiredLeases,
        &ExpiredLeases, &DeletedLeases
        );

    LogScavengeStats(
        EVENT_SERVER_IPCLEANUP_FINISHED,
        ExpiredLeases, DeletedLeases
        );
                
    if( Error != ERROR_SUCCESS ) ReturnError = Error;
    DhcpAssert(ERROR_SUCCESS == Error);

    Error = CleanupMCastDatabase(
        TimeNow,&DoomTime,DeleteExpiredLeases,
        &ExpiredLeases, &DeletedLeases
        );
    if( Error != ERROR_SUCCESS ) ReturnError = Error;
    DhcpAssert(ERROR_SUCCESS == Error);

    LogScavengeStats(
        EVENT_SERVER_MCASTCLEANUP_FINISHED,
        ExpiredLeases, DeletedLeases
        );
    
    // database is successfully cleanup, backup the database and the
    // registry now.
    // backup the registry now.
    Error = DhcpBackupConfiguration( DhcpGlobalBackupConfigFileName );

    if( Error != ERROR_SUCCESS ) {
        DhcpServerEventLog(
            EVENT_SERVER_CONFIG_BACKUP,
            EVENTLOG_ERROR_TYPE,
            Error );
        DhcpPrint(( DEBUG_ERRORS,"DhcpBackupConfiguration failed, %ld.\n", Error ));
        ReturnError = Error;
    }

    //
    // perform full database backup now.
    //

    Error = DhcpBackupDatabase(
                 DhcpGlobalOemJetBackupPath,
                 TRUE );

    if( Error != ERROR_SUCCESS ) {

        DhcpServerEventLog(
            EVENT_SERVER_DATABASE_BACKUP,
            EVENTLOG_ERROR_TYPE,
            Error );

        DhcpPrint(( DEBUG_ERRORS,
            "DhcpBackupDatabase failed, %ld.\n", Error ));

        ReturnError = Error;
    }

    // now perform the ipaddress usage and warn the admin if neccessary.
    AuditIPAddressUsage();
    AuditMCastAddressUsage();


Cleanup:


    //
    // Reset the thread priority.
    //

    BoolError = SetThreadPriority(
                    ThreadHandle,
                    THREAD_PRIORITY_NORMAL );

    DhcpAssert( BoolError );

    if( Error == ERROR_SUCCESS ) {
        Error = ReturnError;
    }

    if( (Error != ERROR_SUCCESS) && (Error != ERROR_NO_MORE_ITEMS) ) {

        DhcpServerEventLog(
            EVENT_SERVER_DATABASE_CLEANUP,
            EVENTLOG_ERROR_TYPE,
            Error );

        DhcpPrint(( DEBUG_ERRORS, "Database Cleanup failed, %ld.\n", Error ));

    }
    else  {
        DhcpPrint(( DEBUG_MISC,
            "Database Cleanup finished successfully.\n" ));
    }

    return( ReturnError );
}

DWORD
Scavenger(
    VOID
    )
/*++

Routine Description:

    This function runs as an independant thread.  It periodically wakes
    up to free expired leases.

Arguments:

    None.

Return Value:

    None.

--*/
{

#define CORE_SCAVENGER      0
#define DATABASE_BACKUP     1
#define DATABASE_CLEANUP    2
#define SCAVENGE_IP_ADDRESS 3

#define TIMERS_COUNT        4

    DWORD Error;
    DWORD result;
    DATE_TIME TimeNow;
    BOOL MidNightCleanup = TRUE;
    BOOL ScavengedOutOfTurn = FALSE;
    BOOL fDidNullBackup = FALSE;
    DHCP_TIMER Timers[TIMERS_COUNT];
    ULONG NextFireForRogue, Now;

    SYSTEMTIME LocalTime;

    DWORD DisableRogueDetection = 0;

#define TERMINATE_EVENT             0
#define ROGUE_DETECT_EVENT          1
#define TIMER_RECOMPUTE_EVENT       2

#define EVENT_COUNT                 3

    HANDLE WaitHandle[EVENT_COUNT];

    //
    // Initialize timers.
    //

    TimeNow = DhcpGetDateTime();
    Timers[CORE_SCAVENGER].Period = &DhcpGlobalScavengerTimeout;
    Timers[CORE_SCAVENGER].LastFiredTime = TimeNow;

    Timers[DATABASE_BACKUP].Period = &DhcpGlobalBackupInterval;
    Timers[DATABASE_BACKUP].LastFiredTime = TimeNow;

    Timers[DATABASE_CLEANUP].Period = &DhcpGlobalCleanupInterval;
    Timers[DATABASE_CLEANUP].LastFiredTime = TimeNow;

    Timers[SCAVENGE_IP_ADDRESS].Period = &DhcpGlobalScavengeIpAddressInterval;
    Timers[SCAVENGE_IP_ADDRESS].LastFiredTime = TimeNow;

    DhcpAssert( DhcpGlobalRecomputeTimerEvent != NULL );
    WaitHandle[TIMER_RECOMPUTE_EVENT] = DhcpGlobalRecomputeTimerEvent;
    WaitHandle[TERMINATE_EVENT] = DhcpGlobalProcessTerminationEvent;
    WaitHandle[ROGUE_DETECT_EVENT] = DhcpGlobalRogueWaitEvent;

    // Check to see if rogue detection is needed    
    Error = DhcpRegGetValue( DhcpGlobalRegParam,
			     DHCP_DISABLE_ROGUE_DETECTION,
			     DHCP_DISABLE_ROGUE_DETECTION_TYPE,
			     ( LPBYTE ) &DisableRogueDetection
			     );
    if (( ERROR_SUCCESS == Error ) &&
	( 0 != DisableRogueDetection )) {
	DisableRogueDetection = 1;
    } // if 


    NextFireForRogue = RogueDetectStateMachine(NULL);
    if( INFINITE != NextFireForRogue ) NextFireForRogue += (ULONG) time(NULL);

    while (1) {

        DWORD TimeOut;
        DWORD EventID;

        EventID = NextEventTime( Timers, TIMERS_COUNT, &TimeOut );


	do {
		
	    //
	    // If wait forever for rogue stuff, don't alter timeout
	    //
		
	    if( INFINITE == NextFireForRogue ) break;
		
	    //
	    // If the rogue state should have changed already, re-schedule
	    //
		
	    if( (Now = (ULONG)time(NULL)) >= NextFireForRogue ) {
		NextFireForRogue = RogueDetectStateMachine(NULL);		
		if( INFINITE != NextFireForRogue ) {
		    NextFireForRogue += (Now = (ULONG)time(NULL));
		} else {
		    //
		    // INFINITE sleep?  timeout won't change
		    //
		    break;
		} // else
	    } // if
		
	    //
	    // Wakeup at the earliest of rogue-state-change or normal timeout
	    //

	    if( (NextFireForRogue - Now)*1000 < TimeOut ) {
		TimeOut = (NextFireForRogue - Now)*1000;
	    }

	} while ( 0 );

	DhcpPrint( ( DEBUG_SCAVENGER,
		     "Waiting for %d seconds.\n",
		     TimeOut / 1000 )
		   );

	if( INFINITE == NextFireForRogue ) {
	    //
	    // INFINITE wait is used to indicate network is not ready.
	    // Wait on NetworkReady event rather than RogueWait event.
	    //
	    WaitHandle[ROGUE_DETECT_EVENT] = DhcpGlobalEndpointReadyEvent;
	} else {
	    WaitHandle[ROGUE_DETECT_EVENT] = DhcpGlobalRogueWaitEvent;
	}

	if ( DisableRogueDetection ) {
	    WaitHandle[ ROGUE_DETECT_EVENT ] = DhcpGlobalRogueWaitEvent;
	}

        DhcpDnsHandleCallbacks();
        
        result = WaitForMultipleObjectsEx(
                    EVENT_COUNT,            // num. of handles.
                    WaitHandle,             // handle array.
                    FALSE,                  // wait for any.
                    TimeOut,                // timeout in msecs.
                    TRUE );                 // alertable

        switch( result ) {
        case WAIT_IO_COMPLETION:
            // IoCompletion routine is called ( for the winsock pnp notifications )
            break;

        case TERMINATE_EVENT:
            //
            // the service is asked to stop, return to main.
            //

            return( ERROR_SUCCESS );

        case TIMER_RECOMPUTE_EVENT:

            break;

        case ROGUE_DETECT_EVENT:
	    
	    //
	    // Fire another step in state machine.
	    //
	    NextFireForRogue = RogueDetectStateMachine(NULL);
	    if( INFINITE != NextFireForRogue ) {
		NextFireForRogue += (ULONG) time(NULL);
	    }
		ResetEvent(DhcpGlobalRogueWaitEvent);
            break;

        case WAIT_TIMEOUT:


	    if( INFINITE != NextFireForRogue && (ULONG)time(NULL) >= NextFireForRogue ) {
		//
		// GO To top of WHILE loop -- need to fire another step in state machine.
		//
		continue;
	    }


            TimeNow = DhcpGetDateTime();
            switch (EventID ) {

            case CORE_SCAVENGER :

                //
                // Cleanup client requests that are never committed.
                //

                Error = CleanupClientRequests( &TimeNow, FALSE );

                //
                // Expire multicast scopes
                //

                DeleteExpiredMcastScopes(&TimeNow);
                
                
                //
                // is it time to do mid-night database cleanup ?
                //

                GetLocalTime( &LocalTime );
                if ( LocalTime.wHour == 0 ) {

                    //
                    // change audit logs if required...
                    //

                    DhcpChangeAuditLogs();

                    //
                    // did we do this cleanup before ?
                    //

                    if( MidNightCleanup == TRUE ) {

                        Error = CleanupDatabase( &TimeNow, FALSE );
                        MidNightCleanup = FALSE;
                    }
                }
                else {

                    //
                    // set the mid-night flag again.
                    //

                    MidNightCleanup = TRUE;
                }

                if( ! DhcpGlobalScavengeIpAddress ) {
                    //
                    // don't need to scavenge Ip address away..
                    //
                    break;
                }

                if( ScavengedOutOfTurn ) {
                    // already done once out of turn.. don't do anymore..
                    break;
                }

                ScavengedOutOfTurn = TRUE;

                // FALL THROUGH AND SCAVENGE IF NEEDED

            case SCAVENGE_IP_ADDRESS:

                if( DhcpGlobalScavengeIpAddress ) {

                    //
                    // cleanup all expired leases too.
                    //

                    Error = CleanupDatabase( &TimeNow, TRUE );
                    DhcpGlobalScavengeIpAddress = FALSE;
                }

                if( SCAVENGE_IP_ADDRESS == EventID ) {
                    ScavengedOutOfTurn = FALSE;
                }

                break;

            case DATABASE_CLEANUP:

                Error = CleanupDatabase( &TimeNow, FALSE );
                break;

            case DATABASE_BACKUP : {

                Error = DhcpBackupConfiguration( DhcpGlobalBackupConfigFileName );

                if( Error != ERROR_SUCCESS ) {

                    DhcpServerEventLog(
                        EVENT_SERVER_CONFIG_BACKUP,
                        EVENTLOG_ERROR_TYPE,
                        Error );

                    DhcpPrint(( DEBUG_ERRORS,
                        "DhcpBackupConfiguration failed, %ld.\n", Error ));
                }

                //
                // Do a NULL backup every alternate time..
                //
                if( fDidNullBackup ) {
                    Error = DhcpBackupDatabase(
                        DhcpGlobalOemJetBackupPath,
                        FALSE );
                } else {
                    Error = DhcpBackupDatabase(
                        NULL,
                        TRUE
                    );
                }
                fDidNullBackup = ! fDidNullBackup;

                if( Error != ERROR_SUCCESS ) {

                    DhcpServerEventLog(
                        EVENT_SERVER_DATABASE_BACKUP,
                        EVENTLOG_ERROR_TYPE,
                        Error );

                    DhcpPrint(( DEBUG_ERRORS,
                        "DhcpBackupDatabase failed, %ld.\n", Error ));
                }


                break;
            }

            default:
                DhcpAssert(FALSE);
                break;
            } // switch (EventID)

            Timers[EventID].LastFiredTime = DhcpGetDateTime();
            break;

        default :

            DhcpPrint(( DEBUG_ERRORS,
                "WaitForMultipleObjects returned invalid result, %ld.\n",
                    result ));
            break;

        } // switch()
    } // while (1) 

    return( ERROR_SUCCESS );
} // Scavenger()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\auditlog\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\subntapi.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    dhcpapi.c

Abstract:

    This module contains the implementation for the APIs that update
    the list of IP addresses that the server can distribute.

Author:

    Madan Appiah (madana)  13-Sep-1993

Environment:

    User Mode - Win32

Revision History:

    Cheng Yang (t-cheny)  30-May-1996  superscope
    Cheng Yang (t-cheny)  27-Jun-1996  audit log

--*/

#include "dhcppch.h"

DWORD
SubnetInUse(
    HKEY SubnetKeyHandle,
    DHCP_IP_ADDRESS SubnetAddress
    )
/*++

Routine Description:

    This function determains whether a subnet is under use or not.
    Currently it returns error if any of the subnet address is still
    distributed to client.

Arguments:

    SubnetKeyHandle : handle to the subnet key.

    SubnetAddress : address of the subnet to test.

Return Value:

    DHCP_SUBNET_CANT_REMOVE - if the subnet is in use.

    Other registry errors.

--*/
{
    DWORD Error;
    DWORD Resumehandle = 0;
    LPDHCP_CLIENT_INFO_ARRAY_V4 ClientInfo = NULL;
    DWORD ClientsRead;
    DWORD ClientsTotal;

    //
    // enumurate clients that belong to the given subnet.
    //
    // We can specify big enough buffer to hold one or two clients
    // info, all we want to know is, is there atleast a client belong
    // to this subnet.
    //

    Error = R_DhcpEnumSubnetClientsV4(
                NULL,
                SubnetAddress,
                &Resumehandle,
                1024,  // 1K buffer.
                &ClientInfo,
                &ClientsRead,
                &ClientsTotal );

    if( Error == ERROR_NO_MORE_ITEMS ) {
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    if( (Error == ERROR_SUCCESS) || (Error == ERROR_MORE_DATA) ) {

        if( ClientsRead != 0 ) {
            Error = ERROR_DHCP_ELEMENT_CANT_REMOVE;
        }
        else {
            Error = ERROR_SUCCESS;
        }
    }

Cleanup:

    if( ClientInfo != NULL ) {
        _fgs__DHCP_CLIENT_INFO_ARRAY( ClientInfo );
        MIDL_user_free( ClientInfo );
    }

    return( Error );
}


//
// Subnet APIs
//


DWORD
R_DhcpAddSubnetElement(
    DHCP_SRV_HANDLE ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    LPDHCP_SUBNET_ELEMENT_DATA AddElementInfo
    )
/*++

Routine Description:

    This function adds an enumerable type of subnet elements to the
    specified subnet. The new elements that are added to the subnet will
    come into effect immediately.

    This function emulates the RPC interface used by NT 4.0 DHCP Server.
    It is provided for backward compatibilty with older version of the
    DHCP Administrator application.

    NOTE: It is not clear now how do we handle the new secondary hosts.

Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : IP Address of the subnet.

    AddElementInfo : Pointer to an element information structure
        containing new element that is added to the subnet.
        DhcpIPClusters element type is invalid to specify.

Return Value:

    ERROR_DHCP_SUBNET_NOT_PRESENT - if the subnet is not managed by the server.

    ERROR_INVALID_PARAMETER - if the information structure contains invalid
        data.

    Other WINDOWS errors.
--*/


{
    DHCP_SUBNET_ELEMENT_DATA_V4 *pAddElementInfoV4;
    DWORD                        dwResult;

    if( NULL == AddElementInfo ||
        (DhcpIpRanges == AddElementInfo->ElementType &&
         NULL == AddElementInfo->Element.IpRange ) ) {

        //
        // Bug# 158321
        //
        
        return ERROR_INVALID_PARAMETER;
    }
    
    pAddElementInfoV4 = CopySubnetElementDataToV4( AddElementInfo );
    if ( pAddElementInfoV4 )
    {

        if ( DhcpReservedIps == pAddElementInfoV4->ElementType )
        {
            pAddElementInfoV4->Element.ReservedIp->bAllowedClientTypes =
                CLIENT_TYPE_BOTH;
        }

        dwResult = R_DhcpAddSubnetElementV4(
                        ServerIpAddress,
                        SubnetAddress,
                        pAddElementInfoV4 );

        _fgs__DHCP_SUBNET_ELEMENT_DATA( pAddElementInfoV4 );

        MIDL_user_free( pAddElementInfoV4 );
    }
    else
        dwResult = ERROR_NOT_ENOUGH_MEMORY;

    return dwResult;
}


DWORD
R_DhcpEnumSubnetElements(
    DHCP_SRV_HANDLE ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    DHCP_SUBNET_ELEMENT_TYPE EnumElementType,
    DHCP_RESUME_HANDLE *ResumeHandle,
    DWORD PreferredMaximum,
    LPDHCP_SUBNET_ELEMENT_INFO_ARRAY *EnumElementInfo,
    DWORD *ElementsRead,
    DWORD *ElementsTotal
    )
{
    DHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 *pEnumElementInfoV4 = NULL;
    DWORD                              dwResult;

    dwResult = R_DhcpEnumSubnetElementsV4(
                        ServerIpAddress,
                        SubnetAddress,
                        EnumElementType,
                        ResumeHandle,
                        PreferredMaximum,
                        &pEnumElementInfoV4,
                        ElementsRead,
                        ElementsTotal
                        );
    if ( ERROR_SUCCESS == dwResult || ERROR_MORE_DATA == dwResult )
    {
        DWORD dw;


        // since the only difference between DHCP_SUBNET_ELEMENT_INFO_ARRAY_V4 and
        // DHCP_SUBNET_ELEMENT_INFO_ARRAY are a couple of fields at the end of the
        // embedded DHCP_IP_RESERVATION_V4 struct, it is safe to simply return the
        // V4 struct.

        *EnumElementInfo = ( DHCP_SUBNET_ELEMENT_INFO_ARRAY *) pEnumElementInfoV4;
    }
    else
    {
        DhcpAssert( !pEnumElementInfoV4 );
    }

    return dwResult;
}



DWORD
R_DhcpRemoveSubnetElement(
    LPWSTR  ServerIpAddress,
    DHCP_IP_ADDRESS SubnetAddress,
    LPDHCP_SUBNET_ELEMENT_DATA RemoveElementInfo,
    DHCP_FORCE_FLAG ForceFlag
    )
/*++

Routine Description:

    This function removes a subnet element from managing. If the subnet
    element is in use (for example, if the IpRange is in use) then it
    returns error according to the ForceFlag specified.

    This function emulates the RPC interface used by NT 4.0 DHCP Server.
    It is provided for backward compatibilty with older version of the
    DHCP Administrator application.


Arguments:

    ServerIpAddress : IP address string of the DHCP server.

    SubnetAddress : IP Address of the subnet.

    RemoveElementInfo : Pointer to an element information structure
        containing element that should be removed from the subnet.
        DhcpIPClusters element type is invalid to specify.

    ForceFlag - Indicates how forcefully this element is removed.

Return Value:

    ERROR_DHCP_SUBNET_NOT_PRESENT - if the subnet is not managed by the server.

    ERROR_INVALID_PARAMETER - if the information structure contains invalid
        data.

    ERROR_DHCP_ELEMENT_CANT_REMOVE - if the element can't be removed for the
        reason it is has been used.

    Other WINDOWS errors.
--*/


{
    DWORD dwResult;
    DHCP_SUBNET_ELEMENT_DATA_V4 *pRemoveElementInfoV4;

    pRemoveElementInfoV4 = CopySubnetElementDataToV4( RemoveElementInfo );
    if ( pRemoveElementInfoV4 )
    {
        if ( DhcpReservedIps == pRemoveElementInfoV4->ElementType )
        {
            pRemoveElementInfoV4->Element.ReservedIp->bAllowedClientTypes = CLIENT_TYPE_DHCP;
        }

        dwResult = R_DhcpRemoveSubnetElementV4(
                        ServerIpAddress,
                        SubnetAddress,
                        pRemoveElementInfoV4,
                        ForceFlag );

        _fgs__DHCP_SUBNET_ELEMENT_DATA( pRemoveElementInfoV4 );
        MIDL_user_free( pRemoveElementInfoV4 );
    }
    else
        dwResult = ERROR_NOT_ENOUGH_MEMORY;

    return dwResult;
}


//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\thread.c ===
//--------------------------------------------------------------------------------
//  Copyright (C) Microsoft Corporation 1997
//  Author: RameshV
//  Title: Threading Model
//  Description: the new, neat threading model
//  Date: 24-Jul-97 09:22
//--------------------------------------------------------------------------------
#include <dhcppch.h>                    //  global header file
#include <thread.h>                     //  types and exposed functions
#include <ping.h>                       //  handling the ping calls

typedef PLIST_ENTRY      PACKET_Q;      //  PACKET_Q is just a list

#define Q_INIT_SIZE      50             //  Initial amount of allocated buffers
#define Q_MAX_SIZE       100            //  Maximum size of the queue
#define MAX_MSG_IN_Q_TIME 30            //  30 seconds
#define DHCP_S_MSG_SIZE  2000           //  should work on lan at full udp size?

#define ThreadTrace(str)                DhcpPrint((DEBUG_THREAD, "%s", str ))
#define ThreadTrace2(X,Y)               DhcpPrint((DEBUG_THREAD, X, Y ))
#define ThreadTrace3(X,Y,Z)             DhcpPrint((DEBUG_THREAD, X, Y, Z));
#define ThreadAlert(X)                  DhcpPrint((DEBUG_ERRORS, "ALERT: %s", X))

//================================================================================
//  IMPORTED functions  (non Win32 API stuff only)
//================================================================================
// DhcpPrint
// ASSERT
// DhcpAssert
// DhcpAllocateMemory
// DhcpFreeMemory
//
// DhcpWaitForMessage
//
// DhcpCreateClientEntry
//
//
// DoIcmpRequest
//
//
//================================================================================
//  IMPORTED global variables
//================================================================================
// No global variable is used directly in this file
//

//================================================================================
//  Function prototypes: forward declarations
//================================================================================
DWORD
NotifyProcessingLoop(
    VOID
);

DWORD
DhcpNotifiedAboutMessage(
    OUT     BOOL        *Terminate
);

BOOL
DhcpTerminated(
    VOID
);

DWORD
DhcpMessageWait(
    IN      LPPACKET     Packet
);

BOOL
ExactMatch(
    IN      LPPACKET     Packet1,
    IN      LPPACKET     Packet2
);

VOID
ProcessPacket(
    IN      LPPACKET     Packet
);

VOID
HandlePingAbort(
    IN      DWORD        IpAddress,
    IN      BOOL         DestReachable
);

//================================================================================
//  Here is the hash queue..
//================================================================================
#define     HASH_Q_SIZE  1024           //  Size of the hash queue
LIST_ENTRY  HashQ[HASH_Q_SIZE];         //  Each list is one bucket

//================================================================================
//  Hash q functions
//================================================================================
DWORD                                   //  Hash value == 0 .. HASH_Q_SIZE
HashPacket(                             //  Hash the packet into the reqd queue
    IN      PPACKET      P              //  The input packet to hash.
) {
    DWORD   PrefixLen, HashVal, Tmp;
    LPBYTE  HashBytes;                  //  The start of the hashing bytes

    PrefixLen = HASH_PREFIX;            //  packet prefix is this big.
    HashBytes = (LPBYTE)&P->Xid;        //  Start the hashing from Xid
    HashVal = 0;

    while( PrefixLen > sizeof(DWORD) ) {
        memcpy((LPBYTE)&Tmp, HashBytes, sizeof(DWORD));
        HashBytes += sizeof(DWORD);
        PrefixLen -= sizeof(DWORD);
        HashVal += Tmp;
    }

    if( PrefixLen ) {                   //  If prefixlen is not a multiple of DWORD size
        Tmp = 0;                        //  Then, copy as much as is left
        memcpy((LPBYTE)&Tmp, HashBytes, PrefixLen);
        HashVal += Tmp;
    }

    DhcpAssert( 4 == sizeof(DWORD) );   //  We need to get down to 2 bytes, so assert this

    HashVal = (HashVal >> 16 ) + (HashVal & 0xFFFF);
    return HashVal % HASH_Q_SIZE;       //  add hashval higher word to lower word and mod size
}

DWORD                                   //  Win32 errors
InitHashQ(                              //  Initialize the hash q
    VOID                                //  No parameters
) {
    DWORD   i;

    for( i = 0; i < HASH_Q_SIZE ; i ++ )
        InitializeListHead(&HashQ[i]);

    return ERROR_SUCCESS;
}

VOID
CleanupHashQ(                           //  Cleanup all memory associated with hash q
) {
    DWORD   i;

    for( i = 0; i < HASH_Q_SIZE ; i ++ )
        InitializeListHead(&HashQ[i]);
}

DWORD                                   //  Win32 errors
InsertHashQ(                            //  Insert the given packet into the HashQ
    IN      PPACKET      P              //  input packet to insert
) {
    DWORD   HashVal;

    DhcpAssert(P && P->HashValue < HASH_Q_SIZE );

    DhcpAssert(P->HashList.Flink == &(P->HashList) );
    InsertHeadList(&HashQ[P->HashValue], &P->HashList);
    return  ERROR_SUCCESS;
}

DWORD                                   //  Win32 errors
DeleteHashQ(                            //  Delete this from the hash q
    IN      PPACKET      P              //  The packet to delete
) {
    DhcpAssert(P->HashList.Flink != &(P->HashList) );
    RemoveEntryList(&P->HashList);
    InitializeListHead(&P->HashList);   //  Further removes wont hurt
    return  ERROR_SUCCESS;
}

DWORD                                   //  Win32 errors
SearchHashQ(                            //  Search the hash Q
    IN      PPACKET      P,             //  Input packet to search for
    OUT     PPACKET     *OutP           //  Output packet if found
) {
    PLIST_ENTRY          List,NextEntry;
    PPACKET              RetVal;

    DhcpAssert(OutP && P && P->HashValue < HASH_Q_SIZE );

    *OutP = NULL;
    List = &HashQ[P->HashValue];
    NextEntry = List->Flink;
    while( List != NextEntry ) {        //  While not end of list
        RetVal = CONTAINING_RECORD(NextEntry, PACKET, HashList);

        if(ExactMatch(P, RetVal) ) {    //  It is in the same bucket, but is it same?
            *OutP = RetVal;
            break;
        }

        NextEntry = NextEntry->Flink;
    }

    if( *OutP ) return ERROR_SUCCESS;
    return ERROR_FILE_NOT_FOUND;
}


//================================================================================
//  Functions, helpers, real, initialization,cleanup etc.
//================================================================================

LPPACKET  STATIC                        //  Return a deleted elt or NULL if empty
DeleteOldestElement(                    //  Delete the first inserted elt from the Q
    IN      PACKET_Q     Pq             //  The Q to delete from
) {
    PLIST_ENTRY          Head;

    if( IsListEmpty(Pq) ) return NULL;  //  No element here

    Head = RemoveTailList(Pq);
    return CONTAINING_RECORD(Head, PACKET, List);
}

BOOL  STATIC                            //  TRUE on success, FALSE if no memory
InsertElement(                          //  Insert an element into the array
    IN      PACKET_Q     Pq,            //  Insert into this Q
    IN      LPPACKET     packet         //  This is the packet to insert
) {
    InsertHeadList(Pq, &packet->List);  //  Just insert this guy
    return TRUE;
}

//================================================================================
//  Local Data
//================================================================================
CRITICAL_SECTION         PacketCritSection;
#define QLOCK()          EnterCriticalSection(&PacketCritSection)
#define QUNLOCK()        LeaveCriticalSection(&PacketCritSection)

LIST_ENTRY               FreeQ;
PACKET_Q                 ActiveQ, PingRetryQ, PingRetriedQ;

struct /* anonymous */ { //  holds the statistics for this file
    DWORD     NServiced;
    DWORD     NActiveDropped;
    DWORD     NRetryDropped;
    DWORD     NRetriedDropped;
    DWORD     NActiveMatched;
    DWORD     NRetryMatched;
    DWORD     NRetriedMatched;
    DWORD     NPacketsAllocated;
    DWORD     NPacketsInFreePool;
} Stats;

//================================================================================
//  Module functions
//================================================================================

LPPACKET  STATIC                        //  Packet* or NULL if no mem
AllocateFreePacket(                     //  Allocate a packet
    VOID
) {
    DWORD   HeaderSize, PacketSize, MessageSize;
    LPBYTE  Memory;
    PPACKET RetVal;

    HeaderSize = sizeof(LIST_ENTRY);
    HeaderSize = ROUND_UP_COUNT(HeaderSize, ALIGN_WORST);
    PacketSize = sizeof(PACKET);
    PacketSize = ROUND_UP_COUNT(PacketSize, ALIGN_WORST);
    MessageSize = DHCP_S_MSG_SIZE;

    Memory = DhcpAllocateMemory(HeaderSize+PacketSize+MessageSize);
    if( NULL == Memory ) return NULL;   //  Cannot do anything if no mem.
    RetVal = (LPPACKET)(Memory+HeaderSize);

    RetVal->ReqContext.ReceiveBuffer = (LPBYTE)(Memory+HeaderSize+PacketSize);
    RetVal->ReqContext.ReceiveBufferSize = MessageSize;

    Stats.NPacketsAllocated ++;
    return RetVal;
}

VOID  STATIC
FreeFreePacket(                         //  Free the packet and associated strucs
    IN      LPPACKET     Packet         //  The packet to free
) {
    DWORD   HeaderSize;
    LPBYTE  Memory;

    HeaderSize = sizeof(LIST_ENTRY);
    HeaderSize = ROUND_UP_COUNT(HeaderSize, ALIGN_WORST);

    Memory = (LPBYTE)Packet ;
    DhcpFreeMemory( Memory - HeaderSize );
    Stats.NPacketsAllocated --;
}

VOID  STATIC
InsertFreePacket(                       //  Insert a free packet into pool
    IN      PLIST_ENTRY  List,          //  The list to insert into
    IN      LPPACKET     Packet         //  The packet to insert
) {
    DWORD                HeaderSize;
    LPBYTE               Memory;

    if( Stats.NPacketsInFreePool > Q_INIT_SIZE ) {
        FreeFreePacket(Packet);
        return;
    }

    Stats.NPacketsInFreePool ++;
    HeaderSize = sizeof(LIST_ENTRY);
    HeaderSize = ROUND_UP_COUNT(HeaderSize, ALIGN_WORST);
    //  Note that the packet has a "hidden" header the used start address.
    //  Things will work correctly only IF THE PACKET WAS ALLOCATED by the
    //  AllocatePacket function

    Memory = (LPBYTE)Packet;
    InsertHeadList( List, ((PLIST_ENTRY)(Memory - HeaderSize)));
}

LPPACKET   STATIC _inline               //  Return NULL or a packet
DeleteFreePacketEx(                     //  Try to see if a free packet exists
    IN     PLIST_ENTRY   List,          //  Input list
    IN     BOOL          Alloc          //  Allocate if list empty?
) {
    PLIST_ENTRY          Head;
    LPBYTE               Memory;
    DWORD                HeaderSize;

    HeaderSize = sizeof(LIST_ENTRY);
    HeaderSize = ROUND_UP_COUNT(HeaderSize, ALIGN_WORST);

    if( IsListEmpty(List) ) {
        if( Alloc && Stats.NPacketsAllocated < Q_MAX_SIZE )
            return AllocateFreePacket();
        return NULL;
    }

    DhcpAssert(Stats.NPacketsInFreePool);
    Stats.NPacketsInFreePool --;
    Head = RemoveHeadList(List);        //  Remove the first elt in the list
    Memory = (LPBYTE)Head;
    return (LPPACKET) (Memory + HeaderSize );
}

LPPACKET  STATIC                        //  A packet* if one exists, NULL else
DeleteFreePacket(                       //  Delete a free packet
    IN      PLIST_ENTRY  List           //  The list to delete from
) {
    LPPACKET             RetVal;

    RetVal = DeleteFreePacketEx(List, TRUE );
    if( RetVal ) {
        InitializeListHead(&RetVal->List);
        InitializeListHead(&RetVal->HashList);
    }
    return RetVal;
}

static                                  //  The space for these three pointers..
LIST_ENTRY ActiveQSpace, PingRetryQSpace, PingRetriedQSpace;

DWORD  STATIC                           //  Win32 errors
InitQData(                              //  Initialize DataStrucs for this file
    VOID
) {
    int   i;
    DWORD Error = ERROR_SUCCESS;

    ActiveQ = &ActiveQSpace;            //  should we do alloc or use
    PingRetryQ = &PingRetryQSpace;      //  static variables like this?
    PingRetriedQ = &PingRetriedQSpace;

    InitializeListHead( &FreeQ );
    InitializeListHead( ActiveQ);
    InitializeListHead( PingRetryQ );
    InitializeListHead( PingRetriedQ );
    InitHashQ();
    try {
        InitializeCriticalSection(&PacketCritSection);
    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        //
        // shouldnt happen, but one never knows..
        //

        Error = GetLastError( );
        return Error;
    }

    for( i = 0; i < Q_INIT_SIZE ; i ++ ) {
        LPPACKET     Packet;

        Packet = AllocateFreePacket();
        if( NULL == Packet )
            return ERROR_NOT_ENOUGH_MEMORY;

        InsertFreePacket( &FreeQ, Packet );
    }

    return ERROR_SUCCESS;
}

VOID  STATIC
CleanupQData(                           //  Cleanup the memory used in this file
    VOID
) {
    LPPACKET   Packet;

    QLOCK();                            //  Must be able to lock -- Else problem!
    while( Packet = DeleteFreePacketEx( &FreeQ , FALSE) )
        FreeFreePacket( Packet );       //  Free memory..
    while( Packet = DeleteOldestElement( ActiveQ ) )
        FreeFreePacket( Packet );
    while( Packet = DeleteOldestElement( PingRetryQ ) ) {
        HandlePingAbort(Packet->PingAddress, Packet->DestReachable);
        FreeFreePacket( Packet );
    }
    while( Packet = DeleteOldestElement( PingRetriedQ ) ) {
        HandlePingAbort(Packet->PingAddress, Packet->DestReachable);
        FreeFreePacket( Packet );
    }

    DeleteCriticalSection(&PacketCritSection);
    CleanupHashQ();
}

VOID  STATIC                            //  Only one threads must call this
MessageLoop(                            //  Handle the sockets side, queueing messages
    VOID                                //  No parameters
) {
    LPPACKET  P, P2, MatchedP;
    DWORD     Error;
    BOOL      ProcessIt;

    ThreadTrace("Starting message loop\n");
    QLOCK();
    P = DeleteFreePacket( &FreeQ );
    QUNLOCK();
    DhcpAssert(P);
    if( NULL == P ) return;             //  Cannot happen, but handle this anyways.

    while(1) {
        if( NULL == P ) {
            DhcpPrint((DEBUG_ERRORS, "Did not expect to lose packet altogether\n"));
            DhcpAssert(FALSE);
            return;                     //  Error!
        }

        P->PingAddress = 0;         //  This ensures that this is treated as a new packet
        P->DestReachable = 0;       //  No harm clearing one more field

        while(1) {
            P->ReqContext.ReceiveBuffer = ROUND_UP_COUNT(sizeof(PACKET), ALIGN_WORST) + (LPBYTE)P;
            Error = DhcpMessageWait(P);
            P->ReqContext.TimeArrived = GetCurrentTime();
            if( ERROR_SUCCESS == Error ) {
                InterlockedIncrement( &(DhcpGlobalNumPacketsReceived  ) );
                ProcessIt = TRUE;
                P->CalloutContext = NULL;
                CALLOUT_NEWPKT(P, &ProcessIt);
                if( FALSE == ProcessIt ) {        // asked by callout to NOT process this pkt
                    // signal the callout that this packet is dropped (on demand :o)
                    CALLOUT_DROPPED(P, DHCP_DROP_PROCESSED);
                    ThreadTrace("Callout dropped pkt for us..\n");
                    continue;
                }
                P->HashValue = HashPacket(P);
            } else {
                P->HashValue = 0;
            }

            if( DhcpTerminated() ) {    //  Quit the loop if asked to quit
                // the MessageLoop exits
                // if there was a CALLOUT_NEWPKT, signal CALLOUT_DROPPED
                if (ERROR_SUCCESS == Error)
                    CALLOUT_DROPPED(P, DHCP_DROP_PROCESSED);
                P->PacketType = PACKET_ACTIVE;
                QLOCK();
                InsertFreePacket( &FreeQ, P );
                QUNLOCK();
                ThreadTrace("MessageLoop quitting\n");
                return;                 //  Insert P back so it will get freed
            }

            if( ERROR_SUCCESS == Error )
                break;

            if( ERROR_SEM_TIMEOUT == Error ) {
                ThreadTrace("Sockets timeout -- No messages\n");
            }

            if( ERROR_DEV_NOT_EXIST == Error ) {
                ThreadTrace("Socket vanished underneath (PnP). Ignored\n");
            }

            if( ERROR_SUCCESS != Error ) {
                ThreadTrace2("Waiting for message, Error: %ld\n", Error);
            }
        }
        QLOCK();

        if( ERROR_SUCCESS == SearchHashQ(P, &MatchedP) ) {
            //  Found this packet in the hash queue.. drop incoming packet
            InterlockedIncrement( &DhcpGlobalNumPacketsDuplicate );
            DhcpAssert(MatchedP);
            Stats.NActiveDropped ++;
            QUNLOCK();
            CALLOUT_DROPPED(P, DHCP_DROP_DUPLICATE);
            // also notify that this packet was processed
            CALLOUT_DROPPED(P, DHCP_DROP_PROCESSED);
            continue;
        }

        P2 = DeleteFreePacket( &FreeQ);
        if( NULL == P2 ) {
            DhcpPrint((DEBUG_ERRORS, "Do not have enough packets to go by..\n"));
            QUNLOCK();
            CALLOUT_DROPPED(P, DHCP_DROP_NOMEM);
            // also notify that this packet was processed
            CALLOUT_DROPPED(P, DHCP_DROP_PROCESSED);
            continue;
        }

        Error = InsertHashQ(P);
        DhcpAssert(ERROR_SUCCESS == Error);

        Stats.NServiced ++;             //  Not a retry packet, don't drop it
        P->PacketType = PACKET_ACTIVE;  //  Set the correct type
        if( !InsertElement(ActiveQ, P)){//  Insert into this queue
            DhcpAssert(FALSE);
            Error = DeleteHashQ(P);
            InsertFreePacket( &FreeQ, P);
            DhcpAssert(ERROR_SUCCESS == Error);
            ThreadTrace("Dropped active packet as activeQ too long\n");
            CALLOUT_DROPPED(P, DHCP_DROP_INTERNAL_ERROR);
            // also notify that this packet was processed
            CALLOUT_DROPPED(P, DHCP_DROP_PROCESSED);
        }

        InterlockedIncrement( &DhcpGlobalNumPacketsInActiveQueue );
        NotifyProcessingLoop();         //  Ask the processing loop to wakeup
        P = P2;                         //  Use this packet for the next iteration
        QUNLOCK();
    }
}

VOID  STATIC                            //  Multithreaded main loop for handling messages
ProcessingLoop(                         //  Pickout requests and dispatch them
    VOID                                //  No parameters
) {
    LPBYTE              SendBuffer;     //  Need a buffer to send messages
    DWORD               SendBufferSize; //  The size of above buffer in bytes
    LPPACKET            P;              //  The current packet being looked at
    BOOL                Terminate;
    DWORD               Error;

    SendBufferSize = DHCP_S_MSG_SIZE;
    SendBuffer = DhcpAllocateMemory( SendBufferSize );

    if( NULL == SendBuffer ) {          //  Need this buffer to be able to send stuff out
        ThreadAlert("Could not allocate send buffer\n");
        return ;                        //  ERROR_NOT_ENOUGH_MEMORY
    }

    ThreadTrace("Starting processing loop\n");
    while( TRUE ) {                     //  Main loop
        Terminate = FALSE;
        Error = DhcpNotifiedAboutMessage(&Terminate);

        if( ERROR_SUCCESS != Error ) {  //  Nothing much to do if this fails
            ThreadTrace2("Notification failed : %ld\n", Error );
            continue;
        }
        if( Terminate ) {               //  If asked to quit, make sure we put packet back in
            DhcpFreeMemory(SendBuffer); //  Free our local buffers..
            break;
        }


        while( TRUE ) {
            QLOCK();                    //  Q's are del'ed in rev order compared to MsgLoop
            P = DeleteOldestElement( PingRetriedQ);
            if( NULL != P ) {
                InterlockedDecrement( &DhcpGlobalNumPacketsInPingQueue );
            } else {
                P = DeleteOldestElement( ActiveQ);
                if( NULL != P ) InterlockedDecrement( &DhcpGlobalNumPacketsInActiveQueue);
            }

            QUNLOCK();

            if( NULL == P ) break;      //  We finished all elements

            P->ReqContext.SendBuffer = SendBuffer;
            P->ReqContext.SendMessageSize = SendBufferSize;

            if( PACKET_ACTIVE == P->PacketType )
                ThreadTrace("Processing active packet\n");
            else ThreadTrace("Processing ping packet\n");
            ProcessPacket(P);           //  This automatically re-inserts the packet into Q's
            ThreadTrace("Processed packet\n");
        }
    }

    ThreadTrace("ProcessingLoop quitting\n");
}

VOID
HandlePingAbort(                        //  Aborted address... Release address or mark bad
    IN      DWORD        IpAddress,     //  We did a ping against this address
    IN      BOOL         DestReachable  //  And this tells if this address was reachable
) {
    DWORD   Error, Status;
    PACKET  pkt, *P = &pkt;

    if( 0 == IpAddress ) return;        //  Nope we did not really do a ping

    ThreadTrace3(
        "Ping abort: %s, %s\n",
        inet_ntoa(*(struct in_addr *)&IpAddress),
        DestReachable? "TRUE" : "FALSE"
    );
    if( !DestReachable ) {              //  A sensible address
        Error = DhcpReleaseAddress(IpAddress);
        if( ERROR_SUCCESS != Error ) {
            //
            // Don't know if we are checking for BOOP or DHCP..
            //
            Error = DhcpReleaseBootpAddress( IpAddress );
        }
        DhcpAssert(ERROR_SUCCESS == Error);
        return;
    }

    P->PingAddress = IpAddress;         //  Mark this addresss bad by creating a dummy packet
    P->DestReachable = DestReachable;   //  structure and calling CreateClientEntry
    Error = DhcpCreateClientEntry(
        IpAddress,                      //  Ip address to mark bad
        (LPBYTE)&IpAddress,             //  Munged hw address, No hw address
        sizeof(IpAddress),              //  size is size of ip address
        DhcpCalculateTime(INFINIT_LEASE),//  Does not really matter
        GETSTRING(DHCP_BAD_ADDRESS_NAME),//  Machine name & info dont matter
        GETSTRING(DHCP_BAD_ADDRESS_INFO),//  ditto
        CLIENT_TYPE_DHCP,               //  Dont care about client type
        (-1),                           //  Server address?
        ADDRESS_STATE_DECLINED,         //  Address state?
        TRUE                            //  Open existing? D
    );

    DhcpAssert( ERROR_SUCCESS == Error);
}

DWORD
DoIcmpRequestForDynBootp(
    IN      ULONG                  IpAddress,
    IN      LPBYTE                 HwAddr,
    IN      ULONG                  HwLen,
    IN      VOID                   (*Callback)(ULONG IpAddres, LPBYTE HwAddr, ULONG HwLen, BOOL Reachable)
)
{
    ULONG                          Error;
    LPPACKET                       P;

    P = DhcpAllocateMemory( sizeof(PACKET) + HwLen);
    if( NULL == P ) return ERROR_NOT_ENOUGH_MEMORY;

    memset(P, 0, sizeof(PACKET));
    P->PingAddress = htonl(IpAddress);
    P->PacketType = PACKET_DYNBOOT;
    P->ClientIdSize = (BYTE)HwLen;
    P->Callback = Callback;
    memcpy((LPBYTE)&P[1], HwAddr, HwLen);

    Error = DoIcmpRequestEx(P->PingAddress, P, 3);
    if( ERROR_SUCCESS != Error ) {
        DhcpFreeMemory(P);
    }
    return Error;
}

VOID                                    //  No return values
HandleIcmpResult(                       //  After a ping is finished, it comes here
    IN      DWORD        PingAddressIn, //  The Address that was pinged
    IN      BOOL         DestReachable, //  Was the Destination reachable?
    IN      LPPACKET     P              //  This is the packet that we were dealing with
)
{
    LPPACKET             P2;
    DWORD                PingAddress, Error;

    if( P->PacketType == PACKET_DYNBOOT ) {
        //
        // Handle dynamic bootp result..
        //
        P->Callback(
            ntohl(P->PingAddress), (LPBYTE)&P[1], P->ClientIdSize, DestReachable
            );
        DhcpFreeMemory(P);
        return ;
    }

    PingAddress = htonl(PingAddressIn);

    ThreadTrace("StartIcmpResult\n");
    QLOCK();
    if( P->PingAddress != PingAddress || P->PacketType != PACKET_PING ) {
        ThreadTrace("Ping reply too late\n");
        InterlockedDecrement(&DhcpGlobalNumPacketsInPingQueue);
        HandlePingAbort(PingAddress, DestReachable);
        goto EndFunc;                   //  We already killed this packet
    }

    Error = SearchHashQ(P, &P2);
    if( ERROR_SUCCESS != Error ) {      //  This packet was dropped and re-used
        DhcpAssert(FALSE);              //  Cannot happen.
        ThreadTrace("Ping reply too late!\n");
        InterlockedDecrement( &DhcpGlobalNumPacketsInPingQueue );
        HandlePingAbort(PingAddress, DestReachable);
        goto EndFunc;
    }
    DhcpAssert( P2 == P );              //  Must get this exact packet!

    RemoveEntryList(&P->List);          //  Remove this element from the PingRetryQ
    InitializeListHead(&P->List);       //  Fit in this list correctly

    P->PacketType = PACKET_PINGED;      //  Completed ping request
    P->DestReachable = DestReachable;   //  Was the destination actually reachable?

    ThreadTrace3("%s %s reachable\n",
                 inet_ntoa(*(struct in_addr *)&PingAddressIn),
                 DestReachable? "is" : "is not"
                 );
    if(!InsertElement(PingRetriedQ, P)){//  Will be handled by the ProcessingLoop
        DhcpAssert(FALSE);
        HandlePingAbort(PingAddress, DestReachable);
        Error = DeleteHashQ(P);
        InsertFreePacket( &FreeQ, P);
        DhcpAssert(ERROR_SUCCESS == Error);
        ThreadTrace("Dropped ping retried packet as Q too long\n");
    }

EndFunc:

    QUNLOCK();
    ThreadTrace("EndIcmpResult\n");
    NotifyProcessingLoop();             //  Notify the ProcessingLoop of new arrival
}

//================================================================================
//  Functions needed for IO Completion ports
//================================================================================
static
HANDLE      IoPort       = NULL;        //  The IO Completion Port that threads queue
static
LONG        nPendingReq  = 0;           //  The # of Pending IO Compl Port Requests
static
DWORD       nMaxWorkerThreads;          //  The maximum # of worker threads to run
static
DWORD       nActiveWorkerThreads;       //  Of these the # of threads that are active

// TEST 
static
LONG        postQueued = 0;
static      
LONG        getQueued  = 0;
// TEST


DWORD  STATIC                           //  Win32 errors
InitCompletionPort(                     //  Initialize completion ports
    IN      DWORD        nMaxThreads,   //  max # of threads
    IN      DWORD        nActiveThreads,//  max # of active threads
    IN      DWORD        QueueSize      //  The size of the message queue -- UNUSED
) {
    DWORD        i, Error, nProcessors;
    SYSTEM_INFO  SysInfo;

    GetSystemInfo(&SysInfo);            //  Get the # of processors on this machine
    nProcessors = SysInfo.dwNumberOfProcessors;
    DhcpAssert(nProcessors);

    if( 0xFFFFFFFF == nMaxThreads )     //  Unspecified # of total threads
        nMaxThreads = 1;                //  Assume it is 1 more than # processors
    if( 0xFFFFFFFF == nActiveThreads )  //  Unspecified # of active threads
        nActiveThreads = 0;             //  Assume as many as there are processors

    nMaxThreads += nProcessors;         //  Increment by # of processors
    nActiveThreads += nProcessors;

    if( nActiveThreads > nMaxThreads )
        return ERROR_NOT_ENOUGH_MEMORY;

    nMaxWorkerThreads = nMaxThreads;    //  Copy stuff into local variables
    nActiveWorkerThreads = nActiveThreads;

    ThreadTrace2("Created %ld completion ports\n", nActiveWorkerThreads);

    IoPort = CreateIoCompletionPort(    //  Create the completion ports
        INVALID_HANDLE_VALUE,           //  Overlap file handle
        NULL,                           //  Existing completion port
        0,                              //  Key
        nActiveWorkerThreads            //  # of concurrent active threads
    );

    if( NULL == IoPort ) {
        Error = GetLastError();
        DhcpPrint((DEBUG_ERRORS, "Could not create io port: %ld\n", Error));
        return Error;
    }

    return ERROR_SUCCESS;
}

VOID  STATIC
CleanupCompletionPort(                  //  Cleanup last function
    VOID
) {
    if( NULL != IoPort) {
        CloseHandle(IoPort);
        IoPort = NULL;
    }
}


DWORD  STATIC                           //  Win32 errors
NotifyProcessingLoop(                   //  Post an IO Completion request about msg
    VOID
) {
    DhcpAssert(IoPort);                 //  Must have initialized IoPort

    if( InterlockedIncrement(&nPendingReq) > (LONG)nMaxWorkerThreads+1 ) {
        //
        // Too many requests done already.  Don't POST anything now..
        //

        InterlockedDecrement(&nPendingReq);

	DhcpPrint((DEBUG_ERRORS, "Too many pending requests : %ld\n", nPendingReq));
	// This return value is not used by anyone
	return 0;
    }

    // TEST
    // Update the postQueued count
    InterlockedIncrement(&postQueued);

    //TEST

    if(!PostQueuedCompletionStatus(IoPort, 0, 0, NULL)) {
        DWORD  Error = GetLastError();  //  This should not happen
        DhcpPrint((DEBUG_ERRORS, "Could not post to io port: %ld\n", Error));
        return Error;
    }
    return ERROR_SUCCESS;
}

DWORD                                   //  Win32 errors
DhcpNotifyWorkerThreadsQuit(            //  Post io comp request asking threads to quit
    VOID
) {
    if( !IoPort ) return ERROR_INVALID_PARAMETER;

    if(!PostQueuedCompletionStatus(IoPort, 0, 1, NULL)) {
        DWORD  Error = GetLastError();  //  Should not really happen
        DhcpPrint((DEBUG_ERRORS, "Could not post to io port: %ld\n", Error));
        return Error;
    }
    return ERROR_SUCCESS;
}

DWORD  STATIC                           //  Win32 errors
DhcpNotifiedAboutMessage(               //  Check if there is a message waiting
    OUT     BOOL        *Terminate      //  Has a terminate been issued?
) {
    DWORD Error, n;
    ULONG_PTR key;
    LPOVERLAPPED olap;

    DhcpAssert(IoPort);                 //  Expect to have initialized port
    if( !IoPort ) {                     //  If for some reason, something went wrong
        *Terminate = TRUE;              //  got to terminate!
        return ERROR_INVALID_PARAMETER;
    }

    (*Terminate) = FALSE;

    if( DhcpTerminated() ) {            //  Quit, when the terminate signal is up
        (*Terminate) = TRUE;            //  This is one way to signal termination
        DhcpNotifyWorkerThreadsQuit();  //  Pass this notificatioin to all other threads
        return ERROR_SUCCESS;
    }

    // TEST
    // update getQueued count

    InterlockedIncrement(&getQueued);
    // TEST

    if(!GetQueuedCompletionStatus(IoPort, &n, &key, &olap, INFINITE)) {
        Error = GetLastError();         //  Could not get notification?
        DhcpPrint((DEBUG_ERRORS, "GetQueuedStatus = %ld\n", Error));
        return Error;
    }

    InterlockedDecrement(&nPendingReq);
    DhcpAssert(key == 0 || key == 1);   //  key:0 => normal message, 1 => Termination
    if(key == 1) {                      //  Asked to terminate
        (*Terminate) = TRUE;
        (void)DhcpNotifyWorkerThreadsQuit();
    }

    return ERROR_SUCCESS;
} // DhcpNotifiedAboutMessage()

//================================================================================
//  Some helper functions
//================================================================================
BOOL  STATIC                            //  TRUE==>Terminated
DhcpTerminated(                         //  Has termination been signaled?
    VOID
) {                                     //  no error cases handled ?
    //
    // We can look at the terminate event here.. but then, this var is also equally
    // good .. so lets opt for the faster solution.
    //

    return DhcpGlobalServiceStopping;
}

DWORD  STATIC                           //  Win32 errors
DhcpMessageWait(                        //  Wait until something happens on some socket
    IN      LPPACKET     Packet         //  This is where the incoming packet will be stored
) {                                     //  For more info on this fn, see ExtractOptions
    DWORD                Error, RecvMessageSize, Hwlen;
    LPBYTE               Start,EndOfMessage,MagicCookie;

    Error = DhcpWaitForMessage( &Packet->ReqContext);

    if( ERROR_SUCCESS != Error ) {
        return Error;
    }

    if (FALSE == Packet->ReqContext.fMadcap) {

        LPDHCP_MESSAGE       RecvMessage;   //  DataBuffer to the message received
        LPBYTE               currentOption, nextOption;
        RecvMessage = (LPDHCP_MESSAGE)Packet->ReqContext.ReceiveBuffer;
        RecvMessageSize = Packet->ReqContext.ReceiveMessageSize;

        Packet->Xid = RecvMessage->TransactionID;
        Packet->HWAddrType = RecvMessage->HardwareAddressType;
        Hwlen = RecvMessage->HardwareAddressLength;
        if( Hwlen > sizeof(Packet->Chaddr) ) {
            //
            // Insufficient space for hardware address...
            // HWLEN is invalid!
            //
            return ERROR_DHCP_INVALID_DHCP_MESSAGE;
        }

        memcpy(Packet->Chaddr, RecvMessage->HardwareAddress, Hwlen);
        memset(Packet->Chaddr+ Hwlen, 0, sizeof(Packet->Chaddr) - Hwlen);
        Packet->ClientId = "" ;             //  dont use NULL, because we cant do strncmp
        Packet->ClientIdSize = 0;           //  but this empty string, we can do strncmp

        // Now do a minimal parse to get the ClientId of this client
        Start = (LPBYTE) RecvMessage;
        EndOfMessage = Start + RecvMessageSize -1;
        currentOption = (LPBYTE)&RecvMessage->Option;

        if( Start + RecvMessageSize <= currentOption ) {
            return ERROR_DHCP_INVALID_DHCP_MESSAGE ;
        }

        if ( Start + RecvMessageSize == currentOption ) {
            // this is to take care of the bootp clients which can send
            // requests without vendor field filled in.

            return ERROR_SUCCESS;
        }

        MagicCookie = currentOption;

        if( (*MagicCookie != (BYTE)DHCP_MAGIC_COOKIE_BYTE1) ||
            (*(MagicCookie+1) != (BYTE)DHCP_MAGIC_COOKIE_BYTE2) ||
            (*(MagicCookie+2) != (BYTE)DHCP_MAGIC_COOKIE_BYTE3) ||
            (*(MagicCookie+3) != (BYTE)DHCP_MAGIC_COOKIE_BYTE4))
        {
            // this is a vendor specific magic cookie.

            return ERROR_SUCCESS;
        }

        currentOption = MagicCookie + 4;
        while ( (currentOption <= EndOfMessage) &&
                currentOption[0] != OPTION_END &&
                (currentOption+1 <= EndOfMessage) ) {

            if ( OPTION_PAD == currentOption[0] )
                nextOption = currentOption +1;
            else  nextOption = currentOption + currentOption[1] + 2;

            if ( nextOption  > EndOfMessage+1 ) {
                return ERROR_SUCCESS;
            }

            if( OPTION_CLIENT_ID == currentOption[0] ) {
                DWORD   len;
                if ( currentOption[1] > 1 ) {
                    Packet->HWAddrType = currentOption[2];
                }

                if ( currentOption[1] > 2 ) {
                    Packet->ClientIdSize = currentOption[1] - sizeof(BYTE);
                    Packet->ClientId = currentOption + 2 + sizeof(BYTE);
                }

                if( Packet->ClientIdSize < sizeof(Packet->Chaddr))
                    len = Packet->ClientIdSize;
                else len = sizeof(Packet->Chaddr);

                // if we find a client-id, copy it to hw addr (erase what was there)
                memcpy(Packet->Chaddr, Packet->ClientId, len);
                memset(&Packet->Chaddr[len], 0, sizeof(Packet->Chaddr)-len);

                break;
            }
            currentOption = nextOption;
        }

    } else {
        WIDE_OPTION UNALIGNED*         NextOpt;
        BYTE        UNALIGNED*         EndOpt;
        DWORD                          Size;
        DWORD                          OptionType;
        LPMADCAP_MESSAGE               RecvMessage;   //  DataBuffer to the message received


        RecvMessage = (LPMADCAP_MESSAGE)Packet->ReqContext.ReceiveBuffer;
        RecvMessageSize = Packet->ReqContext.ReceiveMessageSize;

        // MBUG : Duplicating option parsing code is really ugly here
        Packet->Xid = RecvMessage->TransactionID;
        Packet->HWAddrType = 0;


        EndOpt = (LPBYTE) RecvMessage + RecvMessageSize;              // all options should be < EndOpt;
        NextOpt = (WIDE_OPTION UNALIGNED*)&RecvMessage->Option;
        //
        // Check sizes to see if the fixed size header part exists or not.

        if( RecvMessageSize < MADCAP_MESSAGE_FIXED_PART_SIZE ) {
            return( ERROR_DHCP_INVALID_DHCP_MESSAGE );
        }

        while( NextOpt->OptionValue <= EndOpt &&
               MADCAP_OPTION_END != (OptionType = ntohs(NextOpt->OptionType)) ) {

            Size = ntohs(NextOpt->OptionLength);
            if ((NextOpt->OptionValue + Size) > EndOpt) {
                return ERROR_DHCP_INVALID_DHCP_MESSAGE;
            }

            // Now do a minimal parse to get the ClientId of this client
            if( MADCAP_OPTION_LEASE_ID == OptionType ) {
                DWORD   len;

                Packet->ClientIdSize = (BYTE)Size;
                Packet->ClientId = (LPBYTE)NextOpt->OptionValue;

                if( Packet->ClientIdSize < sizeof(Packet->Chaddr))
                    len = Packet->ClientIdSize;
                else len = sizeof(Packet->Chaddr);

                // if we find a client-id, copy it to hw addr (erase what was there)
                memcpy(Packet->Chaddr, Packet->ClientId, len);
                memset(&Packet->Chaddr[len], 0, sizeof(Packet->Chaddr)-len);

                break;
            }
            NextOpt = (WIDE_OPTION UNALIGNED*)(NextOpt->OptionValue + Size);
        }

    }

    return ERROR_SUCCESS;
}

BOOL  STATIC                            //  TRUE==>Same src both packets
ExactMatch(                             //  Are these two pckts from same source?
    IN      LPPACKET     Packet1,       //  First packet
    IN      LPPACKET     Packet2        //  second packet
)
{
    LPBYTE  B1, B2;
    BOOL Check;
    PDHCP_MESSAGE M1, M2;
    PDHCP_REQUEST_CONTEXT Req1, Req2;

    // First make sure we are not mixing MADCAP  and DHCP
    if (Packet1->ReqContext.fMadcap != Packet2->ReqContext.fMadcap ) {
        return FALSE;
    }
    B1 = (LPBYTE) &Packet1->Xid;
    B2 = (LPBYTE) &Packet2->Xid;

    if( 0 != memcmp(B1, B2, HASH_PREFIX ) )
        return FALSE;                   //  Mismatch in basic check

    Check = ( Packet1->ClientIdSize == Packet2->ClientIdSize &&
             0 == memcmp(Packet1->ClientId, Packet2->ClientId, Packet1->ClientIdSize)
    );
    if( FALSE == Check ) return FALSE;
    // If this is MADCAP Packet that is all we need to compare.
    else if (Packet1->ReqContext.fMadcap ) return TRUE;
    //
    // Now check subnets of origin as well as GIADDRs.
    //
    M1 = (PDHCP_MESSAGE) Packet1->ReqContext.ReceiveBuffer;
    M2 = (PDHCP_MESSAGE) Packet2->ReqContext.ReceiveBuffer;

    if( M1->RelayAgentIpAddress != M2->RelayAgentIpAddress ) {
        return FALSE;
    }

    Req1 = &Packet1->ReqContext;
    Req2 = &Packet2->ReqContext;

    return ( ( Req1->EndPointMask & Req1->EndPointIpAddress )
             ==
             ( Req2->EndPointMask & Req1->EndPointIpAddress )
             );
}

VOID  STATIC
ProcessPacket(                          //  Handle a packet, and call the right function
    IN      LPPACKET     Packet         //  The input packet to process
) {
    DWORD   Error, Status;
    BOOL    TimedOuT;
    ULONG ProcessingTime;

    Error = Status = ERROR_SUCCESS;
    if( 0 == Packet->PingAddress &&     //  Fresh packet, can be thrown depending on timeout
        GetCurrentTime() >= Packet->ReqContext.TimeArrived + 1000* MAX_MSG_IN_Q_TIME) {
        // If a Ping had been done, then the address would have been marked.  So,
        // handle this case.
        HandlePingAbort(Packet->PingAddress, Packet->DestReachable);
        CALLOUT_DROPPED(Packet, DHCP_DROP_TIMEOUT);
        InterlockedIncrement( &DhcpGlobalNumPacketsExpired );
        DhcpPrint((DEBUG_ERRORS, "A packet has been dropped (timed out)\n"));
    } else if( !DhcpGlobalOkToService ) {
        DhcpPrint((DEBUG_ERRORS, "Dropping packets as not authorized to process\n"));
        CALLOUT_DROPPED(Packet, DHCP_DROP_UNAUTH);
        HandlePingAbort(Packet->PingAddress, Packet->DestReachable);
    } else {
        DhcpAcquireReadLock();
        Packet->ReqContext.Server = DhcpGetCurrentServer();
        Packet->ReqContext.Subnet = NULL;
        Packet->ReqContext.Range = NULL;
        Packet->ReqContext.Excl = NULL;
        Packet->ReqContext.Reservation = NULL;
        if (Packet->ReqContext.fMadcap) {
            Error = ProcessMadcapMessage( &Packet->ReqContext, Packet, &Status);
        } else {
            Error = ProcessMessage( &Packet->ReqContext, Packet, &Status);
        }
        (void)DhcpRegFlushServerIfNeeded();
        DhcpReleaseReadLock();
    }

    ProcessingTime = GetCurrentTime() - Packet->ReqContext.TimeArrived;
    QLOCK();
    switch(Status) {
    case ERROR_SUCCESS:                 //  Everything went well, plug it back into freeQ
        CALLOUT_DROPPED(Packet, DHCP_DROP_PROCESSED);
        DeleteHashQ(Packet);
        InsertFreePacket( &FreeQ, Packet);
        break;
    case ERROR_IO_PENDING:              //  Need to ping something!
        Packet->PacketType = PACKET_PING;
        if(!InsertElement( PingRetryQ, Packet)) {
            CALLOUT_DROPPED(Packet, DHCP_DROP_PROCESSED);
            DhcpAssert(FALSE);
            DeleteHashQ(Packet);
            InsertFreePacket( &FreeQ, Packet);
            ThreadTrace("Could not process ping retry packet as Q too long\n");
        }
        InterlockedIncrement( &DhcpGlobalNumPacketsInPingQueue );
        break;
    default:
        ASSERT(FALSE);                  //  Should not happen
    }
    QUNLOCK();

    if( ERROR_IO_PENDING == Status ) {  //  Ok do the ping out side the lock as this can block
        DoIcmpRequest(ntohl(Packet->PingAddress), Packet);
    } else {
        InterlockedExchangeAdd( &DhcpGlobalNumMilliSecondsProcessed, ProcessingTime );
        InterlockedIncrement( &DhcpGlobalNumPacketsProcessed );
    }

    return;
}

//================================================================================
//  Module Initialization and cleanup
//================================================================================
static
DWORD       InitLevel = 0;              //  How much of init. has been completed

DWORD                                   //  Win32 errors
ThreadsDataInit(                        //  Initialize everything in this file
    IN      DWORD        nMaxThreads,   //  Max # of processing threads to start
    IN      DWORD        nActiveThreads //  Of this how many can run at a time
) {
    DWORD   Error;

    Error = InitCompletionPort(         //  First Initialize completion ports
        nMaxThreads,
        nActiveThreads,
        0                               //  This parameter is no longer in use
    );
    InitLevel++;

    if( ERROR_SUCCESS != Error )
        return Error;

    Error = InitQData();                //  Now initialize the lists and arrays
    InitLevel++;

    return Error;
}

VOID
ThreadsDataCleanup(                     //  Cleanup everything done in this file
    VOID
) {
    if( !InitLevel ) return;            //  Did not initialize anything beyond this
    InitLevel--;

    CleanupCompletionPort();            //  Cleanup completion ports
    if( !InitLevel ) return;            //  Did not initialize anything beyond this
    InitLevel--;

    CleanupQData();                     //  Cleanup Q structures

    DhcpAssert(0 == InitLevel);         //  Since there is no known cleanup
}

static
HANDLE      ThreadHandles[MAX_THREADS]; //  The handles of the threads created
static
DWORD       nThreadsCreated = 0;        //  # of threads created

//================================================================================
//  This call must be preceded by ThreadsDataInit, PingStartup, and by
//  Database Initialization -- preferably in that order.
//================================================================================
DWORD                                   //  Win32 errors
ThreadsStartup(                         //  Start the requisite # of threads
    VOID
) {
    DWORD   i, count, ThreadId, Error;
    HANDLE  ThreadHandle;

    if( nMaxWorkerThreads >= MAX_THREADS )
        nMaxWorkerThreads = MAX_THREADS -1;

    for( i = 0 ; i < nMaxWorkerThreads; i ++ ) {
        ThreadHandle = CreateThread(    //  Create Each of the threads
            NULL,                       //  No security attributes
            0,                          //  Same size as primary thread of process
            (LPTHREAD_START_ROUTINE)ProcessingLoop,
            NULL,                       //  No parameters to this function
            0,                          //  Run immediately
            &ThreadId                   //  We dont really care about this
        );

        if( NULL == ThreadHandle ) {    //  Function Failed
            Error = GetLastError();     //  Print the error and return it
            DhcpPrint((DEBUG_ERRORS, "CreateThread(processingloop): %ld\n", Error));
            return Error;
        }
        ThreadHandles[nThreadsCreated++] = ThreadHandle;
    }

    ThreadHandle = CreateThread(        //  Create thread for message loop
        NULL,                           //  No security
        0,                              //  same stack size as primary thread
        (LPTHREAD_START_ROUTINE) MessageLoop,
        NULL,                           //  No parameter
        0,                              //  Run rightaway
        &ThreadId                       //  We dont really care about this
    );

    if( NULL == ThreadHandle ) {        //  Could not create thread
        Error = GetLastError();         //  Print the error and return it
        DhcpPrint((DEBUG_ERRORS, "CreateThread(MessageLoop): %ld\n", Error));
        return Error;
    }

    ThreadHandles[nThreadsCreated++] = ThreadHandle;

    return ERROR_SUCCESS;               //  Everything went fine
}

//================================================================================
//  This function must be called before calling PingStop and ThreadsDataCleanup.
//================================================================================
VOID
ThreadsStop(                            //  Stop all the threads
    VOID
) {
    DWORD   i, Error;
    DhcpNotifyWorkerThreadsQuit();      //  Ask all worker threads to quit

    ThreadTrace("Notified worker threads.. should quit soon\n");
    for( i = 0; i < nThreadsCreated; i ++ ) {
        if (ThreadHandles[i] != NULL) {
            ThreadTrace2("Waiting for thread %ld to be done\n", i);
            if( WAIT_OBJECT_0 != WaitForSingleObject(ThreadHandles[i], INFINITE )) {
                Error = GetLastError();
                DhcpPrint((DEBUG_ERRORS, "Error (threadwait to die): %ld\n", Error));

                //
                // error occurred.
                // removed reference to terminate thread, BINL may be 
                // affected. Exit anyway.
                //

            }
            CloseHandle(ThreadHandles[i]);
            ThreadHandles[i] = NULL;
        }
    }
    nThreadsCreated = 0;
    nPendingReq  = 0;
    ThreadTrace("ThreadStop done\n");
}


//================================================================================
//  End of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\stoc.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    stoc.c

Abstract:

    This module contains the code to deal with most of the protocol parts
    of the DHCP server (like processing for each type of packet -- discover,
    request, inform, bootp etc).

    THIS FILE IS BEST VIEWED IN 100 COLUMNS

Author:

    Madan Appiah (madana)  10-Sep-1993
    Manny Weiser (mannyw)  24-Aug-1992

Environment:

    User Mode - Win32

Revision History:

    Cheng Yang (t-cheny)  30-May-1996  superscope
    Cheng Yang (t-cheny)  27-Jun-1996  audit log
    Ramesh V K (rameshv)  06-Jun-1998  severe reformat + accumulated changes

--*/

#include "dhcppch.h"
#include <thread.h>
#include <ping.h>
#include <mdhcpsrv.h>
#include <iptbl.h>
#include <endpoint.h>


//
// Default Bootp Options
//

BYTE  pbOptionList[] = {
    3,   // router list
    6,   // dns
    2,   // time offset
    12,  // host name
    15,  // domain name
    44,  // nbt config
    45,  // ""
    46,  // ""
    47,  // ""
    48,  // X term server
    49,  // X term server
    69,  // smtp server
    70,  // pop3 server
    9,   // lpr server
    17,  // root path
    42,  // ntp
    4,   // time server
    144, //HP Jet Direct
    7,   // Log Servers
    18   // Extensions Path
};


VOID
PrintHWAddress(
    IN      LPBYTE                 HWAddress,
    IN      LONG                   HWAddressLength
)
{
    LONG                           i;

    DhcpPrint(( DEBUG_STOC, "Client UID = " ));

    if( (HWAddress == NULL) || (HWAddressLength == 0) ) {
        DhcpPrint(( DEBUG_STOC, "(NULL).\n" ));
        return;
    }

    for( i = 0; i < (HWAddressLength-1); i++ ) {
        DhcpPrint(( DEBUG_STOC, "%.2lx-", (DWORD)HWAddress[i] ));
    }

    DhcpPrint(( DEBUG_STOC, "%.2lx.\n", (DWORD)HWAddress[i] ));
    return;
}

#ifndef     DBG
#define     PrintHWAddress(X,Y)    // dont print anything on retail builds
#endif      DBG

DWORD
DhcpMakeClientUID(
    IN      LPBYTE                 ClientHardwareAddress,
    IN      ULONG                  ClientHardwareAddressLength,
    IN      BYTE                   ClientHardwareAddressType,
    IN      DHCP_IP_ADDRESS        ClientSubnetAddress,
    OUT     LPBYTE                *ClientUID,
    OUT     DWORD                 *ClientUIDLength
    )

/*++

Routine Description:

    This function computes the unique identifier for a client by concatenating
    4-byte subnet address of the client, the client hardware address type and
    the actual hardware address.  But we hardcode the client hardware type as
    HARDWARE_TYPE_10MB_ETHERNET currently  (as there is no way to specify the
    hardware type in the UI for reservations).

    Also this format is used in DhcpValidateClient (cltapi.c?) -- careful about
    changing this code!

    THIS FUNCTION IS DUPLICATED IN RPCAPI2.C IN DHCPDS\ DIRECTORY!  DO NOT
    MODIFY THIS WITHOUT MAKING CORRESPONDING CHANGES THERE!

Arguments:

    ClientHardwareAddress - The actual hardware address (MAC) of the client.

    ClientHardwareAddressLength - The actual number of bytes of hardware address.

    ClientHardwareAddressType - The hardware type of the client. Currently ignored.

    ClientSubnetAddress - The subnet address that the client belongs to. This
        must be in network order, I think (RameshV).

    ClientUID - On return this will hold a buffer allocated via DhcpAllocateMemory,
        that will be filled with the newly formed Client UID.

    ClientUIDLength - This will be filled in to hold the # of bytes of the buffer
        that the ClientUID variable contains.

Return Value:

    ERROR_SUCCESS is returned if everything went fine.
    ERROR_NOT_ENOUGH_MEMORY is returned if not enough memory could be allocated.
    ERROR_DHCP_INVALID_DHCP_CLIENT is returned if the MAC address specified is
        not valid.

--*/

{
    LPBYTE                         Buffer;
    LPBYTE                         ClientUIDBuffer;
    DWORD                          ClientUIDBufferLength;

    DhcpAssert( *ClientUID == NULL );

    if( ClientHardwareAddressLength == 0 ) {
        return ERROR_DHCP_INVALID_DHCP_CLIENT;
    }

    ClientHardwareAddressType = HARDWARE_TYPE_10MB_EITHERNET;

    ClientUIDBufferLength  =  sizeof(ClientSubnetAddress);
    ClientUIDBufferLength +=  sizeof(ClientHardwareAddressType);
    ClientUIDBufferLength +=  (BYTE)ClientHardwareAddressLength;

    ClientUIDBuffer = DhcpAllocateMemory( ClientUIDBufferLength );

    if( ClientUIDBuffer == NULL ) {
        *ClientUIDLength = 0;
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Buffer = ClientUIDBuffer;
    RtlCopyMemory(Buffer,&ClientSubnetAddress,sizeof(ClientSubnetAddress));

    Buffer += sizeof(ClientSubnetAddress);
    RtlCopyMemory(Buffer,&ClientHardwareAddressType,sizeof(ClientHardwareAddressType) );

    Buffer += sizeof(ClientHardwareAddressType);
    RtlCopyMemory(Buffer,ClientHardwareAddress,ClientHardwareAddressLength );

    *ClientUID = ClientUIDBuffer;
    *ClientUIDLength = ClientUIDBufferLength;

    return ERROR_SUCCESS;
}


VOID
GetLeaseInfo(
    IN      DHCP_IP_ADDRESS        IpAddress,
    IN      PDHCP_REQUEST_CONTEXT  ClientCtxt,
    OUT     LPDWORD                LeaseDurationPtr,
    OUT     LPDWORD                T1Ptr               OPTIONAL,
    OUT     LPDWORD                T2Ptr               OPTIONAL,
    IN      DWORD UNALIGNED       *RequestLeaseTime    OPTIONAL
)
/*++

Routine Description:

    This routine gets the specified lease information for the DHCP client
    identified by the IP Address "IpAddress".   This is done by walking the
    configuration for the IP address (first reservations, then scopes, then global)
    via the function DhcpGetParameter.  (Note that any class specific information
    would still be used -- this is passed via the ClientCtxt structure pointer.

Arguments:

    IpAddress - This is the IP address of the client for which lease info is needed.

    ClientCtxt - The client ctxt structure for the client to be used to figure out
        the client class and other information.

    LeaseDurationPtr - This DWORD will be filled with the # of seconds the lease is
        to be given out to the client.

    T1Ptr, T2Ptr - These two DWORDs (OPTIONAL) will be filled with the # of seconds
        until T1 and T2 time respectively.

    RequestedLeaseTime -- If specified, and if this lease duration is lesser than
        the duration as specified in the configuration, then, this is the duration
        that the client would be returned in LeaseDurationPtr.

Return Value:

    None.

--*/
{
    LPBYTE                         OptionData = NULL;
    DWORD                          Error;
    DWORD                          LocalLeaseDuration;
    DWORD                          LocalT1;
    DWORD                          LocalT2;
    DWORD                          OptionDataLength = 0;
    DWORD                          dwUnused;
    DWORD                          LocalRequestedLeaseTime;

    Error = DhcpGetParameter(
        IpAddress,
        ClientCtxt,
        OPTION_LEASE_TIME,
        &OptionData,
        &OptionDataLength,
        NULL /* dont care if this is reservation option, subnet option etc */
    );

    if ( Error != ERROR_SUCCESS ) {
        DhcpPrint((DEBUG_ERRORS, "Unable to read lease value from registry, %ld.\n", Error));
        LocalLeaseDuration = DHCP_MINIMUM_LEASE_DURATION;
    } else {
        DhcpAssert( OptionDataLength == sizeof(LocalLeaseDuration) );
        LocalLeaseDuration = *(DWORD *)OptionData;
        LocalLeaseDuration = ntohl( LocalLeaseDuration );

        DhcpFreeMemory( OptionData );
        OptionData = NULL;
        OptionDataLength = 0;
    }

    //
    // If client requests a shorter lease than what we usually give, shorten it!
    //

    if ( CFLAG_GIVE_REQUESTED_LEASE && ARGUMENT_PRESENT(RequestLeaseTime) ) {
        LocalRequestedLeaseTime =  ntohl( *RequestLeaseTime );
        if ( LocalLeaseDuration > LocalRequestedLeaseTime ) {
            LocalLeaseDuration = LocalRequestedLeaseTime;
        }
    }

    *LeaseDurationPtr = LocalLeaseDuration;

    //
    // If T1 and T2 are requested, then do as before for T1 & T2.  If we don't
    // find any information about T1 or T2 in registry, calculate T1 as half LeaseTime
    // and T2 as 87.5 seconds.
    //

    if ( ARGUMENT_PRESENT(T1Ptr) || ARGUMENT_PRESENT(T2Ptr) ) {
        Error = DhcpGetParameter(
            IpAddress,
            ClientCtxt,
            OPTION_RENEWAL_TIME,
            &OptionData,
            &OptionDataLength,
            NULL
        );

        if ( Error != ERROR_SUCCESS ) {
            DhcpPrint(( DEBUG_ERRORS,"Unable to read T1 value from registry, %ld.\n", Error));
            LocalT1 = (LocalLeaseDuration) / 2 ;
        } else {
            DhcpAssert( OptionDataLength == sizeof(LocalT1) );
            LocalT1 = *(DWORD *)OptionData;
            LocalT1 = ntohl( LocalT1 );

            DhcpFreeMemory( OptionData );
            OptionData = NULL;
            OptionDataLength = 0;
        }

        Error = DhcpGetParameter(
            IpAddress,
            ClientCtxt,
            OPTION_REBIND_TIME,
            &OptionData,
            &OptionDataLength,
            NULL
        );

        if ( Error != ERROR_SUCCESS ) {
            DhcpPrint(( DEBUG_ERRORS, "Unable to read T2 value from registry, %ld.\n", Error));
            LocalT2 = (LocalLeaseDuration) * 7 / 8 ;
        } else {
            DhcpAssert( OptionDataLength == sizeof(LocalT2) );
            LocalT2 = *(DWORD *)OptionData;

            LocalT2 = ntohl( LocalT2 );

            DhcpFreeMemory( OptionData );
            OptionData = NULL;
            OptionDataLength = 0;
        }

        if( (LocalT2 == 0) || (LocalT2 > LocalLeaseDuration) ) {
            LocalT2 = LocalLeaseDuration * 7 / 8;
        }

        if( (LocalT1 == 0) || (LocalT1 > LocalT2) ) {
            LocalT1 = LocalLeaseDuration / 2;
            if( LocalT1 > LocalT2 ) {
                LocalT1 = LocalT2 - 1; // 1 sec less.
            }
        }

        if( ARGUMENT_PRESENT(T1Ptr) ) *T1Ptr = LocalT1;
        if( ARGUMENT_PRESENT(T2Ptr) ) *T2Ptr = LocalT2;
    }

    return;
}

DWORD
ExtractOptions(
    IN      LPDHCP_MESSAGE         DhcpReceiveMessage,
    OUT     LPDHCP_SERVER_OPTIONS  DhcpOptions,
    IN      ULONG                  ReceiveMessageSize
)

/*++

Routine Description:

    This routine parses the options (non-fixed) part of the DHCP message, making
    sure the packet is correctly formatted and fills in the DhcpOptions structure
    pointer with all the correct pointers.

    A couple of points here -- the input message is kept intact and unmodified.
    If any of the standard options have unacceptable size or value,  an  error
    (ERROR_DHCP_INVALID_DHCP_MESSAGE) is returned.

    Even if there is no OPTION_DYNDNS_BOTH present in the wire, the value of
    DhcpOptions->DNSFlags is non-zero (DYNDNS_DOWNLEVEL_CLIENT which happens
    to be 3).  This is because a value of ZERO means the option with value ZERO
    was sent by the DHCP client.

Arguments:

    DhcpReceiveMessage - This is the actual message sent by the DHCP client.

    DhcpOptions - A pointer to the structure that holds all the important optiosn
        needed by the dhcp server.  This structure must be zeroed -- if an option
        is not received, then the fields won't be modified (except for the
        DNS* fields and DSDomain* fields)

    ReceiveMessageSize - The size of the buffer DhcpReceiveMessage in bytes.

Return Value:

    ERROR_SUCCESS is returned if everything is OK with the message and all optiosn
    were parsed fine.

    ERROR_DHCP_INVALID_DHCP_MESSAGE is returned otherwise.

--*/

{
    LPOPTION                       Option;
    LPOPTION                       MsftOption;
    LPBYTE                         start;
    LPBYTE                         EndOfMessage;
    POPTION                        nextOption;
    LPBYTE                         MagicCookie;

    //
    // Note the HACK with DhcpOptions->DnsFlags below. See routine description.
    // N.B DYNDNS_DOWNLEVEL_CLIENT != ZERO !!
    //

    DhcpOptions->DNSFlags = DYNDNS_DOWNLEVEL_CLIENT;
    DhcpOptions->DNSName = NULL;
    DhcpOptions->DNSNameLength = 0;

    DhcpOptions->DSDomainName = NULL;
    DhcpOptions->DSDomainNameLen = 0;
    DhcpOptions->DSDomainNameRequested = FALSE;

    start = (LPBYTE) DhcpReceiveMessage;
    EndOfMessage = start + ReceiveMessageSize -1;
    Option = &DhcpReceiveMessage->Option;

    //
    // Check sizes to see if the fixed size header part exists or not.
    // If there are no options, it may be just a BOOTP client.
    //

    if( (LONG)ReceiveMessageSize <= ((LPBYTE)Option - start) ) {
        return( ERROR_DHCP_INVALID_DHCP_MESSAGE );
    } else if ( (LONG)ReceiveMessageSize == ((LPBYTE)Option - start) ){
        return ERROR_SUCCESS;
    }

    //
    // If the MAGIC cookie doesn't match, don't parse options!
    // Shouldn't we just drop the packet in this case?
    //

    MagicCookie = (LPBYTE) Option;
    if( (*MagicCookie != (BYTE)DHCP_MAGIC_COOKIE_BYTE1) ||
        (*(MagicCookie+1) != (BYTE)DHCP_MAGIC_COOKIE_BYTE2) ||
        (*(MagicCookie+2) != (BYTE)DHCP_MAGIC_COOKIE_BYTE3) ||
        (*(MagicCookie+3) != (BYTE)DHCP_MAGIC_COOKIE_BYTE4)) {
        return ERROR_SUCCESS;
    }


    //
    // Carefully, walk the options - [BYTE opcode BYTE len BYTES value]*
    // Make sure we don't look outside of packet size in case of bugs Len values
    // or missing OPTION_END option.  Also note that OPTION_PAD and OPTION_END
    // are just one byte each with no len/value parts to them.
    //

    Option = (LPOPTION) (MagicCookie + 4);
    while ( ((LPBYTE)Option <= EndOfMessage) && Option->OptionType != OPTION_END
            && ((LPBYTE)Option+1 <= EndOfMessage)) {

        if ( Option->OptionType == OPTION_PAD ){
            nextOption = (LPOPTION)( (LPBYTE)(Option) + 1);
        } else {
            nextOption = (LPOPTION)( (LPBYTE)(Option) + Option->OptionLength + 2);
        }

        if ((LPBYTE)nextOption  > EndOfMessage+1 ) {
            if ( !DhcpOptions->MessageType ) {

                //
                // We ignore these errors for BOOTP clients as some seem have such problems.
                // This is LEGACY code.
                //

                return ERROR_SUCCESS;
            } else  {
                return ERROR_DHCP_INVALID_DHCP_MESSAGE;
            }
        }

        //
        // giant UGLY switch for each option of interest.  Wish we could do better.
        //

        switch ( Option->OptionType ) {

        case OPTION_PAD:
            break;

        case OPTION_SERVER_IDENTIFIER:
            DhcpOptions->Server = (LPDHCP_IP_ADDRESS)&Option->OptionValue;
            if( sizeof(DWORD) != Option->OptionLength ) {
                return ERROR_DHCP_INVALID_DHCP_MESSAGE;
            }
            break;

        case OPTION_SUBNET_MASK:
            DhcpOptions->SubnetMask = (LPDHCP_IP_ADDRESS)&Option->OptionValue;
            if( sizeof(DWORD) != Option->OptionLength ) {
                return ERROR_DHCP_INVALID_DHCP_MESSAGE;
            }
            break;

        case OPTION_ROUTER_ADDRESS:
            DhcpOptions->RouterAddress = (LPDHCP_IP_ADDRESS)&Option->OptionValue;
            if( sizeof(DWORD) != Option->OptionLength ) {
                return ERROR_DHCP_INVALID_DHCP_MESSAGE;
            }
            break;

        case OPTION_REQUESTED_ADDRESS:
            DhcpOptions->RequestedAddress = (LPDHCP_IP_ADDRESS)&Option->OptionValue;
            if( sizeof(DWORD) != Option->OptionLength ) {
                return ERROR_DHCP_INVALID_DHCP_MESSAGE;
            }
            break;

        case OPTION_LEASE_TIME:
            DhcpOptions->RequestLeaseTime = (LPDWORD)&Option->OptionValue;
            if( sizeof(DWORD) != Option->OptionLength ) {
                return ERROR_DHCP_INVALID_DHCP_MESSAGE;
            }
            break;

        case OPTION_OK_TO_OVERLAY:
            DhcpOptions->OverlayFields = (LPBYTE)&Option->OptionValue;
            break;

        case OPTION_PARAMETER_REQUEST_LIST:
            DhcpOptions->ParameterRequestList = (LPBYTE)&Option->OptionValue;
            DhcpOptions->ParameterRequestListLength =
                (DWORD)Option->OptionLength;
            break;

        case OPTION_MESSAGE_TYPE:
            DhcpOptions->MessageType = (LPBYTE)&Option->OptionValue;
            break;

        case OPTION_HOST_NAME:
            DhcpOptions->MachineNameLength = Option->OptionLength;
            DhcpOptions->MachineName = Option->OptionValue;

            break;

        case OPTION_CLIENT_CLASS_INFO:
            DhcpOptions->VendorClassLength = Option->OptionLength;
            DhcpOptions->VendorClass = Option->OptionValue;

            break;

        case OPTION_USER_CLASS:
            DhcpOptions->ClassIdentifierLength = Option->OptionLength;
            DhcpOptions->ClassIdentifier = Option->OptionValue;

            break;

        case OPTION_CLIENT_ID:

            if ( Option->OptionLength >= 1 ) {
                DhcpOptions->ClientHardwareAddressType =
                    (BYTE)Option->OptionValue[0];
            }

            if ( Option->OptionLength >= 2 ) {
                DhcpOptions->ClientHardwareAddressLength =
                    Option->OptionLength - sizeof(BYTE);
                DhcpOptions->ClientHardwareAddress =
                    (LPBYTE)Option->OptionValue + sizeof(BYTE);
            }

            break;

        case OPTION_DYNDNS_BOTH:

            //
            // DHCP_DNS Draft says length >= 4! but subtract 1 byte for len
            // 3 bytes = flags+rcode1+rcode2
            // Get the Flags and domain name if it exists.. else mark null.
            //

            if( Option->OptionLength < 3) break;

            DhcpOptions->DNSFlags = *(LPBYTE)( Option->OptionValue);
            DhcpOptions->DNSNameLength = Option->OptionLength - 3 ;
            DhcpOptions->DNSName = ((LPBYTE)Option->OptionValue)+3;

            break;

        case OPTION_VENDOR_SPEC_INFO:

            if( Option->OptionLength < 2 ) {
                //
                // Don;t have interested option ignore it.
                //
                break;
            }

            MsftOption = (LPOPTION)&Option->OptionValue[0];

            //
            // has the client requested our domain name?
            //

            if (MsftOption->OptionType == OPTION_MSFT_DSDOMAINNAME_REQ) {
                DhcpOptions->DSDomainNameRequested = TRUE;

                MsftOption = (LPOPTION) (
                    (&MsftOption->OptionValue[0] + MsftOption->OptionLength)
                    );
            }


            //
            // have we reached the end of the MsftOption list?
            //

            if (((LPBYTE)MsftOption)+1 >= (LPBYTE)nextOption) {
                break;
            }

            //
            // has the client supplied its domain name?
            //

            if (MsftOption->OptionType == OPTION_MSFT_DSDOMAINNAME_RESP) {

                DhcpOptions->DSDomainNameLen = (DWORD)(MsftOption->OptionLength);

                DhcpOptions->DSDomainName = &MsftOption->OptionValue[0];

                MsftOption = (LPOPTION) (
                    (&MsftOption->OptionValue[0] + MsftOption->OptionLength)
                    );
            }

            if( MsftOption > nextOption ) {
                //
                // Went out of bounds.  Ignore DSDomainName etc..
                //
                DhcpOptions->DSDomainNameLen = 0;
                DhcpOptions->DSDomainName = NULL;
            }

            break;

        //
        //  these next three are for BINL
        //

        case OPTION_SYSTEM_ARCHITECTURE:
            if (Option->OptionLength == 2) {
                DhcpOptions->SystemArchitectureLength = Option->OptionLength;
//                  DhcpOptions->SystemArchitecture = ntohs(*(PUSHORT)Option->OptionValue);
		// use unaligned dereference. Otherwise, it may cause exceptions in ia64.
		DhcpOptions->SystemArchitecture = ntohs(*(USHORT UNALIGNED *)Option->OptionValue);
            } else {
                return (ERROR_DHCP_INVALID_DHCP_MESSAGE);
            }
            break;

        case OPTION_NETWORK_INTERFACE_TYPE:
            DhcpOptions->NetworkInterfaceTypeLength = Option->OptionLength;
            DhcpOptions->NetworkInterfaceType = Option->OptionValue;
            break;

        case OPTION_CLIENT_GUID:
            DhcpOptions->GuidLength = Option->OptionLength;
            DhcpOptions->Guid = Option->OptionValue;
            break;

        default: {
#if DBG
                DWORD i;

            DhcpPrint(( DEBUG_STOC,
                        "Received an unknown option, ID =%ld, Len = %ld, Data = ",
                        (DWORD)Option->OptionType,
                        (DWORD)Option->OptionLength ));

            for( i = 0; i < Option->OptionLength; i++ ) {
                DhcpPrint(( DEBUG_STOC, "%ld ",
                            (DWORD)Option->OptionValue[i] ));

            }
#endif

            break;
            }

        }

        Option = nextOption;
    }

    return( ERROR_SUCCESS) ;

}

DWORD
ExtractMadcapOptions(
    IN      LPMADCAP_MESSAGE         MadcapReceiveMessage,
    OUT     LPMADCAP_SERVER_OPTIONS  MadcapOptions,
    IN      ULONG                  ReceiveMessageSize
)

/*++

Routine Description:

    This routine parses the options (non-fixed) part of the DHCP message, making
    sure the packet is correctly formatted and fills in the MadcapOptions structure
    pointer with all the correct pointers.

    A couple of points here -- the input message is kept intact and unmodified.
    If any of the standard options have unacceptable size or value,  an  error
    (ERROR_DHCP_INVALID_DHCP_MESSAGE) is returned.

    Even if there is no OPTION_DYNDNS_BOTH present in the wire, the value of
    MadcapOptions->DNSFlags is non-zero (DYNDNS_DOWNLEVEL_CLIENT which happens
    to be 3).  This is because a value of ZERO means the option with value ZERO
    was sent by the DHCP client.

Arguments:

    DhcpReceiveMessage - This is the actual message sent by the DHCP client.

    MadcapOptions - A pointer to the structure that holds all the important optiosn
        needed by the dhcp server.  This structure must be zeroed -- if an option
        is not received, then the fields won't be modified (except for the
        DNS* fields and DSDomain* fields)

    ReceiveMessageSize - The size of the buffer DhcpReceiveMessage in bytes.

Return Value:

    ERROR_SUCCESS is returned if everything is OK with the message and all optiosn
    were parsed fine.

    ERROR_DHCP_INVALID_DHCP_MESSAGE is returned otherwise.

--*/

{
    WIDE_OPTION UNALIGNED*         NextOpt;
    BYTE        UNALIGNED*         EndOpt;
    WORD                           Size;          // Option Size
    WORD                           ExpSize;       // Expected option size
    DWORD                          OptionType;
    WORD                           AddrFamily;

    // all options should be < EndOpt;
    EndOpt = (LPBYTE) MadcapReceiveMessage + ReceiveMessageSize;

    NextOpt = (WIDE_OPTION UNALIGNED*)&MadcapReceiveMessage->Option;

    //
    // Check sizes to see if the fixed size header part exists or not.
    //
    if( ReceiveMessageSize < MADCAP_MESSAGE_FIXED_PART_SIZE ) {
        return( ERROR_DHCP_INVALID_DHCP_MESSAGE );
    }

    while( NextOpt->OptionValue <= EndOpt) {

        OptionType = ntohs(NextOpt->OptionType);

	// Check for duplicate options in the known range. Others are ignored
	if (OptionType < MADCAP_OPTION_TOTAL) {

	    // cannot include same option twice
	    if (MadcapOptions->OptPresent[OptionType]) {
		return( ERROR_DHCP_INVALID_DHCP_MESSAGE );
	    }
	    
	    MadcapOptions->OptPresent[OptionType] = TRUE;
	    if ( MADCAP_OPTION_END == OptionType){
		break;
	    }

	} // if 

	// Check for boundary condition
        Size = ntohs(NextOpt->OptionLength);
        if ((NextOpt->OptionValue + Size) > EndOpt) {
            return ERROR_DHCP_INVALID_DHCP_MESSAGE;
        }

	ExpSize = Size;

        switch ( OptionType ) {
        case MADCAP_OPTION_LEASE_TIME:
	    ExpSize = 4;
            MadcapOptions->RequestLeaseTime = (DWORD UNALIGNED *)NextOpt->OptionValue;
            break;
        case MADCAP_OPTION_SERVER_ID:
	    ExpSize = 6;
            AddrFamily = ntohs(*(WORD UNALIGNED *)NextOpt->OptionValue);
            if ( MADCAP_ADDR_FAMILY_V4 != AddrFamily ) return ERROR_DHCP_INVALID_DHCP_MESSAGE;
            MadcapOptions->Server = (DHCP_IP_ADDRESS UNALIGNED *)(NextOpt->OptionValue+2);
            break;
        case MADCAP_OPTION_LEASE_ID:
            MadcapOptions->GuidLength = Size;
            MadcapOptions->Guid = (LPBYTE)NextOpt->OptionValue;
            break;
        case MADCAP_OPTION_MCAST_SCOPE:
            ExpSize = 4;
            MadcapOptions->ScopeId = (DHCP_IP_ADDRESS UNALIGNED *)NextOpt->OptionValue;
            break;
        case MADCAP_OPTION_REQUEST_LIST:
            MadcapOptions->RequestList = (LPBYTE)NextOpt->OptionValue;
            MadcapOptions->RequestListLength = Size;
            break;
        case MADCAP_OPTION_START_TIME:
	    ExpSize = 4;
            MadcapOptions->LeaseStartTime = (DWORD UNALIGNED *)NextOpt->OptionValue;
            break;
        case MADCAP_OPTION_ADDR_COUNT:
	    ExpSize = 4;
            MadcapOptions->MinAddrCount = (WORD UNALIGNED *)NextOpt->OptionValue;
            MadcapOptions->AddrCount = (WORD UNALIGNED *)(NextOpt->OptionValue+2);
            break;
        case MADCAP_OPTION_REQUESTED_LANG:
            MadcapOptions->RequestLang = (LPBYTE)NextOpt->OptionValue;
            MadcapOptions->RequestLangLength = Size;
            break;
        case MADCAP_OPTION_MCAST_SCOPE_LIST:
	    ExpSize = 0;
	    // Nothing here?
            break;
        case MADCAP_OPTION_ADDR_LIST:
            ExpSize = Size - (Size % 6);
            MadcapOptions->AddrRangeList = NextOpt->OptionValue;
            MadcapOptions->AddrRangeListSize = Size;
            break;
        case MADCAP_OPTION_TIME:
	    ExpSize = 4;
            MadcapOptions->Time = (DWORD UNALIGNED *)NextOpt->OptionValue;
            break;

	    /*
	     * Feature list option lists the optional MADCAP features supported, requested or
	     * required by the sender.
	     *
	     *    The code for this option is 12 and the minimum length is 6.
	     *
	     *            Code        Len      Supported   Requested   Required
	     *    +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+
	     *    |    12     |     n     |    FL1    |    FL2    |    FL3    |
	     *    +-----+-----+-----+-----+-----+-----+-----+-----+-----+-----+
	     *
	     *    where each of the Feature Lists is of the following format:
	     *
	     *           Feature     Feature           Feature
	     *            Count      Code 1            Code m
	     *        +-----+-----+-----+-----+-...-+-----+-----+
	     *        |     m     | FC1       |     |    FCm    |
	     *        +-----+-----+-----+-----+-...-+-----+-----+
	     *
	     */
        case MADCAP_OPTION_FEATURE_LIST:

	    // 9/27/00 : (rterala)
	    // The following code is written incorrectly and does not make
	    // any sense to me. It needs a complete rewrite. Do it when a
	    // customer requests this option.

            if ((Size < 6) || (Size % 2)) {
                ExpSize = 6;
            } else {
                WORD        TempSize;
                WORD        Count,i;
                PBYTE       NextValue;

                TempSize = Size;
                Count = 0;
                NextValue = NextOpt->OptionValue;
                for (i = 0; i < 3; i ++) {
                    if (NextValue <= EndOpt &&
                        (Count = ntohs(*(WORD UNALIGNED *)NextValue)) &&
                        TempSize >= (Count*2 + 2)) {
                        TempSize -= (Count*2 + 2);
                        NextValue += 2;
                        MadcapOptions->Features[i] = (WORD UNALIGNED *)NextValue;
                        MadcapOptions->FeatureCount[i] = Count;
                    } else {
                        ExpSize = Size+1;   // just to fail it
                    }
                }
                if (i < 3 ) {
                    ExpSize = Size+1;   // just to fail it
                } else {
//                      DhcpAssert (0 == TempSize);
                }
            }
            break;
        case MADCAP_OPTION_RETRY_TIME:
	    ExpSize = 4;
	    MadcapOptions->RetryTime = (DWORD UNALIGNED *)NextOpt->OptionValue;
            break;
        case MADCAP_OPTION_MIN_LEASE_TIME:
	    ExpSize = 4;
            MadcapOptions->MinLeaseTime = (DWORD UNALIGNED *)NextOpt->OptionValue;
            break;
        case MADCAP_OPTION_MAX_START_TIME:
	    ExpSize = 4;
            MadcapOptions->MaxStartTime = (DWORD UNALIGNED *)NextOpt->OptionValue;
            break;
        case MADCAP_OPTION_ERROR:
	    ExpSize = 0;
            break;
        default: {
            DWORD i;
            DhcpPrint(( DEBUG_STOC,"Received an unknown option, ID =%ld, Len = %ld, Data = ",
                        (DWORD)OptionType,(DWORD)Size ));
            for( i = 0; i < Size; i++ ) {
                DhcpPrint(( DEBUG_STOC, "%2.2x", NextOpt->OptionValue[i] ));
            }
            break;
            }

        }
        if( ExpSize != Size ) {
            return ERROR_DHCP_INVALID_DHCP_MESSAGE;
        }
        NextOpt = (WIDE_OPTION UNALIGNED*)(NextOpt->OptionValue + Size);
    }

    return( ERROR_SUCCESS) ;

}


LPOPTION
ConsiderAppendingOption(                               // conditionally append option to message (if the option is valid)
    IN      DHCP_IP_ADDRESS        IpAddress,          // client ip address
    IN      PDHCP_REQUEST_CONTEXT  ClientCtxt,         // ctxt of the client
    OUT     LPOPTION               Option,             // where to start adding the options
    IN      ULONG                  OptionType,         // what option is this?
    IN      LPBYTE                 OptionEnd,          // cutoff upto which we can fill options
    IN      BOOL                   fSwitchedSubnet     // is this client in a switched subnet environment?
    )
/*++

Routine Description:

   This routine tries to verify if it is OK to append the option requested and
   if it is not one of the options manually added by the DHCP server, then it is
   appended at the point given by "Option" (assuming it would fit in without outrunning
   "OptionEnd" ).   The format in which it is appended is as per the wire protocol.

   When an option has been decided to be appended, first the value is obtained from
   the registry (using the ClientCtxt for class-specific options) in case of
   most options.  (Some are obtained through other means).

   If OPTION_CLIENT_CLASS_INFO is the option requested and this is a NetPC requesting
   the option (via BOOTPROM -- the vendor class is set to a specific string) -- then
   the returned value for this option is just the same as one sent in by the client.
   This is a special case for NetPC's..

Arguments:

   IpAddress - The IP Address of the client for which the options are being added.

   ClientCtxt - This is the bunch of parameters like client class, vendor class etc.

   Option - The location where to start appending the option

   OptionType - The actual OPTION ID to retrieve the value of and append.

   OptionEnd - The end marker for this buffer (the option is not appended if we
       would have to overrun this marker while trying to append)

   fSwitchedSubnet - Is the subnet switched? If so, the router address is given
       out as the IP address instead of trying to retrieve it from the config.
       If this variable is true, then OptionType of ROUTER_ADDRESS is NOT appended
       (as in this case, this would have been done elsewhere).

Return Value:

   The location in memory AFTER the option has been appended (in case the option was
   not appended, this would be the same as "Option" ).

--*/

{
    LPBYTE                         optionValue = NULL;
    DWORD                          optionSize;
    DWORD                          status;
    DWORD                          dwUnused;
    BOOL                           doDefault;

    doDefault = FALSE;

    switch ( OptionType ) {
    case OPTION_USER_CLASS:
        Option = (LPOPTION) DhcpAppendClassList(
            (LPBYTE)Option,
            (LPBYTE)OptionEnd
        );
        break;

    //
    //  NetPC Option
    //

    case OPTION_CLIENT_CLASS_INFO:

        if( BinlRunning() ) {
            if( ClientCtxt->BinlClassIdentifierLength ) {
                Option = DhcpAppendOption(
                    Option,
                    OPTION_CLIENT_CLASS_INFO,
                    (PVOID)ClientCtxt->BinlClassIdentifier,
                    (BYTE)ClientCtxt->BinlClassIdentifierLength,
                    OptionEnd
                    );
            }
        } else {
            doDefault = TRUE;
        }

        break;
    //
    // Options already handled.
    //

    case OPTION_SUBNET_MASK:
    case OPTION_REQUESTED_ADDRESS:
    case OPTION_LEASE_TIME:
    case OPTION_OK_TO_OVERLAY:
    case OPTION_MESSAGE_TYPE:
    case OPTION_RENEWAL_TIME:
    case OPTION_REBIND_TIME:
    case OPTION_DYNDNS_BOTH:
        break;


    //
    // Options it is illegal to ask for.
    //

    case OPTION_PAD:
    case OPTION_PARAMETER_REQUEST_LIST:
    case OPTION_END:

        DhcpPrint((DEBUG_ERRORS,"Request for invalid option %d\n", OptionType));
        break;

    case OPTION_ROUTER_ADDRESS:

        if( !fSwitchedSubnet ) {
            doDefault = TRUE;
        }
        break;

    default:

        doDefault = TRUE;
        break;

    }

    if( doDefault ) {
        status = DhcpGetParameter(
            IpAddress,
            ClientCtxt,
            OptionType,
            &optionValue,
            &optionSize,
            NULL
        );

        if ( status == ERROR_SUCCESS ) {
            Option = DhcpAppendOption(
                Option,
                (BYTE)OptionType,
                (PVOID)optionValue,
		optionSize,
                OptionEnd
            );

            DhcpFreeMemory( optionValue );

        } else {
            DhcpPrint((
                DEBUG_ERRORS,"Requested option is "
                "unavilable in registry, %d\n",OptionType
                ));
        }
    }

    return Option;
}


LPOPTION
AppendClientRequestedParameters(                       // if the client requested parameters, add those to the message
    IN      DHCP_IP_ADDRESS        IpAddress,          // client ip address
    IN      PDHCP_REQUEST_CONTEXT  ClientCtxt,         // clients context
    IN      LPBYTE                 RequestedList,      // list of options requested by client
    IN      DWORD                  ListLength,         // how long is the list
    OUT     LPOPTION               Option,             // this is where to start adding the options
    IN      LPBYTE                 OptionEnd,          // cutoff pt in the buffer up to which options can be filled
    IN      BOOL                   fSwitchedSubnet,    // is this client in a switched subnet environment?
    IN      BOOL                   fAppendVendorSpec   // append vendor spec info?
)
{
    while ( ListLength > 0) {

        if( FALSE == fAppendVendorSpec
            && OPTION_VENDOR_SPEC_INFO == *RequestedList ) {
            ListLength -- ; RequestedList ++;
            continue;
        }

        Option = ConsiderAppendingOption(
            IpAddress,
            ClientCtxt,
            Option,
            *RequestedList,
            OptionEnd,
            fSwitchedSubnet
        );
        ListLength--;
        RequestedList++;
    }

    return Option;
}

LPOPTION
FormatDhcpAck(
    IN      LPDHCP_REQUEST_CONTEXT Ctxt,
    IN      LPDHCP_MESSAGE         Request,
    OUT     LPDHCP_MESSAGE         Response,
    IN      DHCP_IP_ADDRESS        IpAddress,
    IN      DWORD                  LeaseDuration,
    IN      DWORD                  T1,
    IN      DWORD                  T2,
    IN      DHCP_IP_ADDRESS        ServerAddress
)
/*++

Routine Description:

    This function formats a DHCP Ack response packet.  The END option
    is not appended to the message and must be appended by the caller.

Arguments:

    Ctxt - DHCP client request context.

    Response - A pointer to the Received message data buffer.

    Response - A pointer to a preallocated Response buffer.  The buffer
        currently contains the initial request.

    IpAddress - IpAddress offered (in network order).

    LeaseDuration - The lease duration (in network order).

    T1 - renewal time.

    T2 - rebind time.

    ServerAddress - Server IP address (in network order).

Return Value:

    pointer to the next option in the send buffer.

--*/
{
    LPOPTION                       Option;
    LPBYTE                         OptionEnd;
    BYTE                           messageType;
    BYTE                           szBootFileName[BOOT_FILE_SIZE];
    DWORD                          BootpServerIpAddress;

    RtlZeroMemory( Response, DHCP_SEND_MESSAGE_SIZE );

    Response->Operation = BOOT_REPLY;
    Response->TransactionID = Request->TransactionID;
    Response->YourIpAddress = IpAddress;
    Response->Reserved = Request->Reserved;

    Response->HardwareAddressType = Request->HardwareAddressType;
    Response->HardwareAddressLength = Request->HardwareAddressLength;
    RtlCopyMemory(Response->HardwareAddress,
                    Request->HardwareAddress,
                    Request->HardwareAddressLength );

    Response->BootstrapServerAddress = Request->BootstrapServerAddress;
    Response->RelayAgentIpAddress = Request->RelayAgentIpAddress;

    if (IpAddress != 0 && !CLASSD_NET_ADDR(IpAddress) ) {

        DhcpGetBootpInfo(
            Ctxt,
            ntohl(IpAddress),
            DhcpGetSubnetMaskForAddress(ntohl(IpAddress)),
            Request->BootFileName,
            szBootFileName,
            &BootpServerIpAddress
        );

        Response->BootstrapServerAddress = BootpServerIpAddress;
        strncpy(Response->BootFileName, szBootFileName, BOOT_FILE_SIZE);
    }

    Option = &Response->Option;
    OptionEnd = (LPBYTE)Response + DHCP_SEND_MESSAGE_SIZE;

    Option = (LPOPTION) DhcpAppendMagicCookie(
        (LPBYTE) Option,
        OptionEnd );

    messageType = DHCP_ACK_MESSAGE;
    Option = DhcpAppendOption(
        Option,
        OPTION_MESSAGE_TYPE,
        &messageType,
        sizeof( messageType ),
        OptionEnd );

    if (T1) {
        Option = DhcpAppendOption(
            Option,
            OPTION_RENEWAL_TIME,
            &T1,
            sizeof(T1),
            OptionEnd );
    }

    if (T2) {
        Option = DhcpAppendOption(
            Option,
            OPTION_REBIND_TIME,
            &T2,
            sizeof(T2),
            OptionEnd );
    }

    Option = DhcpAppendOption(
        Option,
        OPTION_LEASE_TIME,
        &LeaseDuration,
        sizeof( LeaseDuration ),
        OptionEnd );

    Option = DhcpAppendOption(
        Option,
        OPTION_SERVER_IDENTIFIER,
        &ServerAddress,
        sizeof(ServerAddress),
        OptionEnd );

    DhcpAssert( (char *)Option - (char *)Response <= DHCP_SEND_MESSAGE_SIZE );

    InterlockedIncrement(&DhcpGlobalNumAcks);     // increment ack counter.

    return( Option );
}

LPOPTION
FormatDhcpInformAck(
    IN      LPDHCP_MESSAGE         Request,
    OUT     LPDHCP_MESSAGE         Response,
    IN      DHCP_IP_ADDRESS        IpAddress,
    IN      DHCP_IP_ADDRESS        ServerAddress
)
/*++

Routine Description:

This function formats a DHCP Ack response packet.  The END option
is not appended to the message and must be appended by the caller.

This is to be used only for Inform Packets!
Arguments:

    Response - A pointer to the Received message data buffer.

    Response - A pointer to a preallocated Response buffer.  The buffer
        currently contains the initial request.

    IpAddress - IpAddress offered (in network order).
    -- This is actually the ip address of the client to send this message to!

    ServerAddress - Server IP address (in network order).

Return Value:

    pointer to the next option in the send buffer.

--*/
{
    LPOPTION                       Option;
    LPBYTE                         OptionEnd;
    BYTE                           messageType;

    RtlZeroMemory( Response, DHCP_SEND_MESSAGE_SIZE );

    Response->Operation = BOOT_REPLY;
    Response->TransactionID = Request->TransactionID;
    // Response->YourIpAddress = IpAddress;
    Response->YourIpAddress = 0; // According to the Draft, we should zero this.
    Response->Reserved = Request->Reserved;
    Response->ClientIpAddress = IpAddress;


    Response->HardwareAddressType = Request->HardwareAddressType;
    Response->HardwareAddressLength = Request->HardwareAddressLength;
    RtlCopyMemory(Response->HardwareAddress,
                    Request->HardwareAddress,
                    Request->HardwareAddressLength );

    Response->BootstrapServerAddress = Request->BootstrapServerAddress;
    Response->RelayAgentIpAddress = Request->RelayAgentIpAddress;

    Option = &Response->Option;
    OptionEnd = (LPBYTE)Response + DHCP_SEND_MESSAGE_SIZE;

    Option = (LPOPTION) DhcpAppendMagicCookie(
                            (LPBYTE) Option,
                            OptionEnd );

    messageType = DHCP_ACK_MESSAGE;
    Option = DhcpAppendOption(
        Option,
        OPTION_MESSAGE_TYPE,
        &messageType,
        sizeof( messageType ),
        OptionEnd );

    // Some code here in FormatDhcpAck has been removed..

    Option = DhcpAppendOption(
        Option,
        OPTION_SERVER_IDENTIFIER,
        &ServerAddress,
        sizeof(ServerAddress),
        OptionEnd );

    DhcpAssert( (char *)Option - (char *)Response <= DHCP_SEND_MESSAGE_SIZE );

    if (IpAddress) {
        //
        //  binl calls into us with an IP address of 0, only update the counter
        //  iff we're called from within dhcpssvc.  Within dhcp server, this
        //  routine isn't called with a zero IP address, but if it is, it's
        //  certainly not fatal if we don't increment the counter.
        //
        InterlockedIncrement(&DhcpGlobalNumAcks);     // increment ack counter.
    }

    return( Option );
}


DWORD
FormatDhcpNak(
    IN      LPDHCP_MESSAGE         Request,
    IN      LPDHCP_MESSAGE         Response,
    IN      DHCP_IP_ADDRESS        ServerAddress
)
/*++

Routine Description:

    This function formats a DHCP Nak response packet.

Arguments:

    Response - A pointer to the Received message data buffer.

    Response - A pointer to a preallocated Response buffer.  The buffer
        currently contains the initial request.

    ServerAddress - The address of this server.

Return Value:

    Message size in bytes.

--*/
{
    LPOPTION Option;
    LPBYTE OptionEnd;

    BYTE messageType;
    DWORD messageSize;

    RtlZeroMemory( Response, DHCP_SEND_MESSAGE_SIZE );

    Response->Operation = BOOT_REPLY;
    Response->TransactionID = Request->TransactionID;


    Response->Reserved = Request->Reserved;
    // set the broadcast bit always here. Because the client may be
    // using invalid Unicast address.
    Response->Reserved |= htons(DHCP_BROADCAST);

    Response->HardwareAddressType = Request->HardwareAddressType;
    Response->HardwareAddressLength = Request->HardwareAddressLength;
    RtlCopyMemory(Response->HardwareAddress,
                    Request->HardwareAddress,
                    Request->HardwareAddressLength );

    Response->BootstrapServerAddress = Request->BootstrapServerAddress;
    Response->RelayAgentIpAddress = Request->RelayAgentIpAddress;

    Option = &Response->Option;
    OptionEnd = (LPBYTE)Response + DHCP_SEND_MESSAGE_SIZE;

    Option = (LPOPTION) DhcpAppendMagicCookie( (LPBYTE) Option, OptionEnd );

    messageType = DHCP_NACK_MESSAGE;
    Option = DhcpAppendOption(
        Option,
        OPTION_MESSAGE_TYPE,
        &messageType,
        sizeof( messageType ),
        OptionEnd
    );

    Option = DhcpAppendOption(
        Option,
        OPTION_SERVER_IDENTIFIER,
        &ServerAddress,
        sizeof(ServerAddress),
        OptionEnd );

    Option = DhcpAppendOption(
        Option,
        OPTION_END,
        NULL,
        0,
        OptionEnd
    );

    messageSize = (DWORD)((char *)Option - (char *)Response);
    DhcpAssert( messageSize <= DHCP_SEND_MESSAGE_SIZE );

    InterlockedIncrement(&DhcpGlobalNumNaks);     // increment nak counter.
    return( messageSize );

}

//--------------------------------------------------------------------------------
// This function decides the additional flags to the state for this client.
// The following are possible flags:
//     ADDRESS_BIT_CLEANUP     : This implies when this record is deleted,
//                               it must be de-registered.
//     ADDRESS_BIT_DOTH_REC    : Treat this client as a down level client
//     ADDRESS_BIT_UNREGISTERED: Do DNS registration for this client
// If the flags value is zero, then no DNS stuff has to be done for this client.
//--------------------------------------------------------------------------------
VOID _inline
DhcpDnsDecideOptionsForClient(
    IN      DHCP_IP_ADDRESS        IpAddress,
    IN      PDHCP_REQUEST_CONTEXT  RequestContext,
    IN      DHCP_SERVER_OPTIONS   *DhcpOptions,
    OUT     LPDWORD                pFlags
)
{
    DWORD                          status;
    DWORD                          DnsFlag;
    DWORD                          OptionSize = 0;
    LPBYTE                         OptionValue = NULL;

    (*pFlags)  = 0;
    if( USE_NO_DNS ) return;

    if( DhcpOptions->ClientHardwareAddressLength >= strlen(DHCP_RAS_PREPEND) &&
        0 == memcmp(
            DhcpOptions->ClientHardwareAddress,
            DHCP_RAS_PREPEND,
            strlen(DHCP_RAS_PREPEND)
        )
    ) {
        //
        // This is actually a RAS server getting the address from us.
        // Don't do anything for this case..
        //
        return;
    }

    if( DhcpOptions->DNSNameLength == 1 &&
        L'\0' == *(DhcpOptions->DNSName) ) {
        //
        // Do not register anything for bad DNS option..
        //
        return;
    }

    status = DhcpGetParameter(
        IpAddress,
        RequestContext,
        OPTION_DYNDNS_BOTH,
        &OptionValue,
        &OptionSize,
        NULL
    );

    if( ERROR_SUCCESS == status && OptionSize == sizeof(DWORD)) {
        memcpy(&DnsFlag, OptionValue, sizeof(DWORD));

        DnsFlag = ntohl(DnsFlag);
    } else {
        DnsFlag = DNS_FLAG_ENABLED | DNS_FLAG_CLEANUP_EXPIRED ;
    }

    if( OptionValue ) DhcpFreeMemory(OptionValue);

    if( !(DNS_FLAG_ENABLED & DnsFlag ) ) {
        DnsFlag = 0;
    } else if( !(DNS_FLAG_UPDATE_BOTH_ALWAYS & DnsFlag ) ) {
        // Do as requested by client.

        if( IS_CLIENT_DOING_A_AND_PTR(DhcpOptions->DNSFlags) ) {
            // Client wants to handle both A and Ptr records.. Let it do it.
            DnsFlag &= ~DNS_FLAG_UPDATE_DOWNLEVEL;
        } else if( DYNDNS_DOWNLEVEL_CLIENT ==
                   DhcpOptions->DNSFlags ) {

            // DOWN level client... Check if it is enabled ?
            if( !( DNS_FLAG_UPDATE_DOWNLEVEL & DnsFlag ) )
                DnsFlag = 0;
        }
	else {
	    DnsFlag |= DNS_FLAG_UPDATE_DOWNLEVEL;
	}
    } else {
        if( DYNDNS_DOWNLEVEL_CLIENT == DhcpOptions->DNSFlags ) {
            // DOWN level client... Check if it is enabled ?
            if( !( DNS_FLAG_UPDATE_DOWNLEVEL & DnsFlag ) )
                DnsFlag = 0;
        } else {
            // We are going to update BOTH always
            DnsFlag |= DNS_FLAG_UPDATE_DOWNLEVEL;
        }
    }

    if( DNS_FLAG_ENABLED & DnsFlag ) {
        (*pFlags) = AddressUnRegistered(*pFlags);    // Do DNS for this client

        if( DNS_FLAG_UPDATE_DOWNLEVEL & DnsFlag )
            (*pFlags) = AddressUpdateAPTR(*pFlags);  // update both records for client

        if( DNS_FLAG_CLEANUP_EXPIRED & DnsFlag )
            (*pFlags) = AddressCleanupRequired(*pFlags); // cleanup on expiry
    } else {                                    // No DNS stuff enabled here
        (*pFlags ) = 0;
    }

    DhcpPrint((DEBUG_DNS, "DNS State for <%s> is: %s, %s (%02x)\n",
               (*pFlags)? "DNS Enabled " : "DnsDisabled ",
               ((*pFlags) & ADDRESS_BIT_BOTH_REC)? "DownLevel " : "Not DownLevel ",
               ((*pFlags) & ADDRESS_BIT_CLEANUP) ? "CleanupOnExpiry" : "No CleanupOnExpiry",
               (*pFlags)
    ));

    return;
}

//--------------------------------------------------------------------------------
//  $DhcpAppendDnsRelatedOptions will append the OPTION_DYNDNS_BOTH with flags
//  either 3 or 0 depending on whether the client was down level or not respectively.
//  It fills in the other two RCODE's with 255.
//--------------------------------------------------------------------------------
POPTION _inline
DhcpAppendDnsRelatedOptions(
    OUT     PVOID                  Option,             // Option to append at the end of.
    IN      DHCP_SERVER_OPTIONS   *DhcpOptions,        // reqd for client name etc. info
    IN      PVOID                  OptionEnd,          // make sure opt doesnt go beyond this.
    IN      BOOL                   DownLevelClient     // client requires dns fwd/rev updates?
) {
    DWORD memSize;

    struct /* anonymous */ {
        BYTE flags;
        BYTE rcode1;
        BYTE rcode2;
    } value;

    if( USE_NO_DNS ) return Option;
    if( NULL == DhcpOptions->DNSName ) {               // if the client never event sent a DNS option..
        DhcpAssert(DownLevelClient == TRUE);           // this had better be a down level client
        return Option;
    }

    ASSERT(sizeof(value) == 3);

    // these flags of 0xff imply we are unaware of DynDNS return values.
    value.rcode1 = value.rcode2 = 0xff;

    // if we did DNS fwd&rev then flags=0x03, not 0x00
    value.flags = (DownLevelClient? (DYNDNS_S_BIT|DYNDNS_O_BIT) : 0);
    value.flags |= (DhcpOptions->DNSFlags & DYNDNS_E_BIT );
    
    // if we are not doing both fwd/rev dns, dont give return code for 2.
    if( DownLevelClient ) value.rcode2 = 0;

    // Now just append this stuff.
    Option = DhcpAppendOption(
        Option,
        OPTION_DYNDNS_BOTH,
        (PVOID)&value,
        (BYTE)sizeof(value),
        OptionEnd
    );

    return Option;
}

DWORD
DhcpDetermineInfoFromMessage(                          // find standard info from message
    IN      LPDHCP_REQUEST_CONTEXT RequestContext,
    IN      LPDHCP_SERVER_OPTIONS  DhcpOptions,
    OUT     LPBYTE                *OptionHardwareAddress,
    OUT     DWORD                 *OptionHardwareAddressLength,
    OUT     DHCP_IP_ADDRESS       *ClientSubnetAddress
) {
    LPDHCP_MESSAGE                 dhcpReceiveMessage;
    DHCP_IP_ADDRESS                RelayAgentAddress;
    DHCP_IP_ADDRESS                RelayAgentSubnetMask;


    dhcpReceiveMessage = (LPDHCP_MESSAGE)RequestContext->ReceiveBuffer;

    if( DhcpOptions->ClientHardwareAddress != NULL ) { // if specified in options use that
        *OptionHardwareAddress = DhcpOptions->ClientHardwareAddress;
        *OptionHardwareAddressLength = DhcpOptions->ClientHardwareAddressLength;
    } else {                                           // else use the one in the static field
        *OptionHardwareAddress = dhcpReceiveMessage->HardwareAddress;
        *OptionHardwareAddressLength = dhcpReceiveMessage->HardwareAddressLength;
        if( 0 == dhcpReceiveMessage->HardwareAddressLength ) {
            return ERROR_DHCP_INVALID_DHCP_MESSAGE;
        }
    }

    //
    // This function is relied on by ProcessDhcpRelease where it will pass
    // a NULL. In case of ProcessDhcpDiscover, it will pass a NON NULL
    // parameter.
    // NULL checking added for whistler bug 291164
    //

    if ( ClientSubnetAddress == NULL )
    {
        return ERROR_SUCCESS;
    }

    if( 0 == dhcpReceiveMessage->RelayAgentIpAddress ) {
        *ClientSubnetAddress = ntohl( RequestContext->EndPointIpAddress );
        (*ClientSubnetAddress) &= DhcpGetSubnetMaskForAddress(*ClientSubnetAddress);
        if( 0 == (*ClientSubnetAddress) ) {
            return ERROR_FILE_NOT_FOUND;
        }

    } else {
        RelayAgentAddress = ntohl( dhcpReceiveMessage->RelayAgentIpAddress );
        RelayAgentSubnetMask = DhcpGetSubnetMaskForAddress( RelayAgentAddress );

        if( RelayAgentSubnetMask == 0 ) {              // dont know about this subnet
            return ERROR_FILE_NOT_FOUND;               // avoid a NAK..
        }

        *ClientSubnetAddress = (RelayAgentAddress & RelayAgentSubnetMask);
    }

    return ERROR_SUCCESS;
}

BOOL
ConvertOemToUtf8(
    IN LPSTR OemName,
    IN OUT LPSTR Utf8Name,
    IN ULONG BufSize
    )
{
    WCHAR Buf[300];
    DWORD Count;
    
    if( BufSize < sizeof(Buf)/sizeof(Buf[0]) ) {
        ASSERT(FALSE);
        return FALSE;
    }

    Count = MultiByteToWideChar(
        CP_OEMCP, MB_ERR_INVALID_CHARS, OemName, -1,
        (LPWSTR)Buf, sizeof(Buf)/sizeof(Buf[0]));
    if( 0 == Count ) return FALSE;

    Count = WideCharToMultiByte(
        CP_UTF8, 0, Buf, -1, Utf8Name, BufSize, NULL, NULL );

    //
    // N.B. Looks like there is no such thing as a default
    // character for UTF8 - so we have to assume this
    // succeeded.. 
    // if any default characters were used, then it can't be
    // converted actually.. so don't allow this
    //
    
    return (Count != 0);
}

VOID
DhcpDetermineHostName(                                 // find and null terminate the host name
    IN      PDHCP_REQUEST_CONTEXT  ClientCtxt,         // client context (for reservation info)
    IN      DHCP_IP_ADDRESS        IpAddress,          // ip address being offered to client
    IN      LPDHCP_SERVER_OPTIONS  DhcpOptions,        // to get the MachineName etc.
    OUT     LPWSTR                *HostName,           // fill this with the required pointer
    IN      LPWSTR                 Buffer,             // use this as buffer
    IN      DWORD                  BufSize             // how many WCHARs can the Buffer take?
) {
    WCHAR                          Tmp[2*OPTION_END+2];
    BYTE                           Buf[2*OPTION_END+2];// host name cannot be bigger than this
    BYTE                           Buf2[2*OPTION_END+2];// host name cannot be bigger than this
    LPBYTE                         AsciiName;
    LPBYTE                         FirstChoiceName;
    LPBYTE                         SecondChoiceName;
    DWORD                          FirstChoiceSize;
    DWORD                          SecondChoiceSize;
    DWORD                          Error;
    DWORD                          Size;
    DWORD                          HostNameSize;
    BOOL                           fUtf8;
    
    *HostName = NULL;
    AsciiName = NULL;
    fUtf8 = ((DhcpOptions->DNSFlags & DYNDNS_E_BIT) != 0 );
    
    if( CFLAG_FOLLOW_DNSDRAFT_EXACTLY ) {              // follow everything per DRAFT exactly
        FirstChoiceName = DhcpOptions->DNSName;
        FirstChoiceSize = DhcpOptions->DNSNameLength;
        SecondChoiceName = DhcpOptions->MachineName;
        SecondChoiceSize = DhcpOptions->MachineNameLength;
    } else {                                           // better solution -- use MachineName..
        FirstChoiceName = DhcpOptions->MachineName;
        FirstChoiceSize = DhcpOptions->MachineNameLength;
        SecondChoiceName = DhcpOptions->DNSName;
        SecondChoiceSize = DhcpOptions->DNSNameLength;
    }

    if( NULL != FirstChoiceName && 0 != FirstChoiceSize 
        && '\0' != *FirstChoiceName ) {
        if( '\0' == FirstChoiceName[FirstChoiceSize-1] )
            AsciiName = FirstChoiceName;               // cool already nul terminated!
        else {                                         // nope, have to nul terminate it
            AsciiName = Buf;
            memcpy(AsciiName, FirstChoiceName, FirstChoiceSize);
            AsciiName[FirstChoiceSize] = '\0';
        }
        if( FirstChoiceName != DhcpOptions->DNSName ) {
            fUtf8 = FALSE;
        }
    } else if( NULL != SecondChoiceName && 0 != SecondChoiceSize ) {
        if( '\0' == SecondChoiceName[SecondChoiceSize-1] )
            AsciiName = SecondChoiceName;              // already null terminated
        else {                                         // nope, we have to null terminate this
            AsciiName = Buf;
            memcpy(AsciiName, SecondChoiceName, SecondChoiceSize);
            AsciiName[SecondChoiceSize] = '\0';
        }
        if( SecondChoiceName != DhcpOptions->DNSName ) {
            fUtf8 = FALSE;
        }
    } else if( NULL != ClientCtxt->Reservation ) {     // nah! got to get this from configured options now
        Size = sizeof(Buf)-1;
        Error = DhcpGetAndCopyOption(              // get the option for host name
            0,                                         // zero address -- no client would have this, but dont matter
            ClientCtxt,
            OPTION_HOST_NAME,
            Buf,
            &Size,
            NULL,                                      // dont care about which level this option is obtained
            TRUE /* use UTF8 */
            );
        if( ERROR_SUCCESS != Error || 0 == Size ) return;
        Buf[Size] = '\0';
        AsciiName = Buf;
        fUtf8 = TRUE;
    }

    if( !AsciiName || !*AsciiName ) return ;           // no name or empty name?

    //
    // Data is not in UTF8 format. Convert it to UTF8 format..
    //
    
    if( !fUtf8 ) {
        if(!ConvertOemToUtf8(AsciiName, Buf2, sizeof(Buf2))) return;
        AsciiName = Buf2;
    }
    
    if( NULL == strchr(AsciiName, '.') ) {             // does not already have a domain name? (not FQDN)
        HostNameSize = strlen(AsciiName);
        if( HostNameSize <= OPTION_END -1 ) {          // enough space for a '.' and domain name..
            if( Buf != AsciiName ) {                   // make sure we have the data in buf so that ..
                strcpy(Buf, AsciiName);                // .. we can pad it in with the domain name..
                AsciiName = Buf;
            }
            Buf[HostNameSize] = '.' ;                  // connector '.'
            Size = sizeof(Buf)-1-HostNameSize-1;       // remove space occupied by '.' ..
            Error = DhcpGetAndCopyOption(              // get the option for domain name...
                IpAddress,                             // client ip address
                ClientCtxt,
                OPTION_DOMAIN_NAME,
                &Buf[HostNameSize+1],
                &Size,
                NULL,                                  // dont care abt level..
                TRUE /* use utf8 */
                );
            if( ERROR_SUCCESS != Error || 0 == Size ) {// couldnt copy domain name..
                Buf[HostNameSize] = '\0';              // forget this domain name business..
            } else {                                   // did copy domain name.. nul terminate it..
                Buf[HostNameSize+Size+1] = '\0';
            }
        }
    }

    if( BufSize <= strlen(AsciiName) ) {               // not enough space!
        return ;
    }

    if( 0 != ConvertUTF8ToUnicode(
        AsciiName, -1, (LPWSTR)Tmp, sizeof(Tmp)/sizeof(WCHAR))) {
        *HostName = DhcpAllocateMemory(
            sizeof(WCHAR)*(1+wcslen(Tmp)));
        if( NULL != *HostName ) {
            wcscpy(*HostName, Tmp);
        }
    }
}

DWORD
ProcessBootpRequest(                                   // process a bootp request
    IN OUT  LPDHCP_REQUEST_CONTEXT RequestContext,     // info on this particular client, including message
    IN      LPDHCP_SERVER_OPTIONS  DhcpOptions,        // parsed options
    IN OUT  LPPACKET               AdditionalContext,  // asynchronous ping information
    IN OUT  LPDWORD                AdditionalStatus    // is it asynchronous? if so this is set to ERROR_IO_PENDING
) {
    WCHAR                          ServerName[MAX_COMPUTERNAME_LENGTH + 10];
    DWORD                          Length;
    DWORD                          Error;
    LPDHCP_MESSAGE                 dhcpReceiveMessage;
    LPDHCP_MESSAGE                 dhcpSendMessage;
    CHAR                           szBootFileName[ BOOT_FILE_SIZE];
    CHAR                           szBootServerName[ BOOT_SERVER_SIZE ];
    LPOPTION                       Option;
    LPBYTE                         OptionEnd;

    DHCP_IP_ADDRESS                desiredIpAddress = NO_DHCP_IP_ADDRESS;
    DHCP_IP_ADDRESS                ClientSubnetAddress = 0;
    DHCP_IP_ADDRESS                ClientSubnetMask = 0;
    DHCP_IP_ADDRESS                networkOrderSubnetMask;
    DHCP_IP_ADDRESS                networkOrderIpAddress;
    DHCP_IP_ADDRESS                BootpServerIpAddress = 0;
    DHCP_IP_ADDRESS                desiredSubnetMask;

    DWORD                          StateFlags = 0;

    BYTE                          *HardwareAddress = NULL;
    DWORD                          HardwareAddressLength;
    BYTE                           bAllowedClientType;

    BYTE                          *OptionHardwareAddress;
    DWORD                          OptionHardwareAddressLength;
    BOOL                           DatabaseLocked = FALSE;
    BOOL                           fSwitchedSubnet;

    WCHAR                          LocalBufferForMachineNameUnicodeString[OPTION_END+2];
    LPWSTR                         NewMachineName;
    LPBYTE                         OptionMachineName;  // Did we send out the mc name as option?

    Length = MAX_COMPUTERNAME_LENGTH + 10;         // get the server name
    if( !GetComputerName( ServerName, &Length ) ) {
        Error = GetLastError();
        DhcpPrint(( DEBUG_ERRORS, "Can't get computer name, %ld.\n", Error ));

        return Error ;
    }

    DhcpAssert( Length <= MAX_COMPUTERNAME_LENGTH );
    ServerName[Length] = L'\0';

    NewMachineName = NULL;
    OptionMachineName = NULL;

    DhcpPrint((DEBUG_STOC, "Bootp Request arrived.\n"));

    dhcpReceiveMessage = (LPDHCP_MESSAGE) RequestContext->ReceiveBuffer;

    if( AdditionalStatus ) *AdditionalStatus = ERROR_SUCCESS;

    if( DhcpOptions->Server || DhcpOptions->RequestedAddress ) {
        return ERROR_DHCP_INVALID_DHCP_MESSAGE;        // BOOTP clients cannot use Server Id option..
    }

    // make sure the host name and server name fields are null-terminated

    dhcpReceiveMessage->HostName[ BOOT_SERVER_SIZE - 1] = '\0';
    dhcpReceiveMessage->BootFileName[ BOOT_FILE_SIZE - 1 ] = '\0';

    if ( dhcpReceiveMessage->HostName[0] ) {           // if a server-name is mentioned, it should be us
        WCHAR szHostName[ BOOT_SERVER_SIZE ];

        if ( !DhcpOemToUnicode( dhcpReceiveMessage->HostName, szHostName ) ) {
            return ERROR_DHCP_INVALID_DHCP_MESSAGE;    // can this be handled any better?
        }

        if ( _wcsicmp( szHostName, ServerName ) ) {
            return ERROR_DHCP_INVALID_DHCP_MESSAGE;    // maybe destined for some other bootp/dhcp server
        }
    }

    Error = DhcpDetermineInfoFromMessage(              // find h/w address and subnet address of client
        RequestContext,
        DhcpOptions,
        &OptionHardwareAddress,
        &OptionHardwareAddressLength,
        &ClientSubnetAddress
    );
    if( ERROR_SUCCESS != Error ) return Error;

    Error = DhcpLookupReservationByHardwareAddress(    // search for a reservation with this hardware address
        ClientSubnetAddress,                           // filter off to include only subnets in superscope with this
        OptionHardwareAddress,
        OptionHardwareAddressLength,
        RequestContext                                 // fill in the reservation details into the context
    );
    if( ERROR_SUCCESS != Error ) {                     // did not find this hardware address?
        DhcpAssert( ERROR_FILE_NOT_FOUND == Error);    // there should be no other problem, really

        return ERROR_DHCP_INVALID_DHCP_CLIENT;         // no reservation for this client
    }

    DhcpReservationGetAddressAndType(
        RequestContext->Reservation,
        &desiredIpAddress,
        &bAllowedClientType
    );
    DhcpSubnetGetSubnetAddressAndMask(
        RequestContext->Subnet,
        &ClientSubnetAddress,
        &desiredSubnetMask
    );
    ClientSubnetMask = desiredSubnetMask;

    if( dhcpReceiveMessage->ClientIpAddress ) {        // client is requesting specific address
        if( desiredIpAddress != ntohl(dhcpReceiveMessage->ClientIpAddress) )
            return ERROR_DHCP_INVALID_DHCP_CLIENT;     // reservation exists for some other address
    }

    if( !(bAllowedClientType & CLIENT_TYPE_BOOTP )) {  // does this reservation allow bootp clients?
        return ERROR_DHCP_INVALID_DHCP_CLIENT;
    }

    if( DhcpSubnetIsDisabled(RequestContext->Subnet, TRUE)) {
        return ERROR_DHCP_INVALID_DHCP_CLIENT;         // sorry, this subnet is currently in disabled mode
    }

    DhcpGetBootpInfo(                                  // get boot file name and tftp server
        RequestContext,
        desiredIpAddress,
        desiredSubnetMask,
        dhcpReceiveMessage->BootFileName,
        szBootFileName,
        &BootpServerIpAddress
    );

    if( INADDR_NONE == BootpServerIpAddress ) {        // admin specified wrong Boopt server for phase 2
        return ERROR_DHCP_INVALID_DHCP_CLIENT;         // dont respond.
    }

    DhcpDetermineHostName(                             // calculate the client host name
        RequestContext,
        desiredIpAddress,
        DhcpOptions,
        &NewMachineName,
        LocalBufferForMachineNameUnicodeString,        // give a buffer to return the name, and limit the max size also
        sizeof(LocalBufferForMachineNameUnicodeString)/sizeof(WCHAR)
    );

    HardwareAddress = NULL;
    Error = DhcpMakeClientUID(                         // ok, make extended UID for the database
        OptionHardwareAddress,
        OptionHardwareAddressLength,
        dhcpReceiveMessage->HardwareAddressType,
        ClientSubnetAddress,
        &HardwareAddress,                              // allocate hardware address bits
        &HardwareAddressLength
    );
    if ( ERROR_SUCCESS != Error ) return Error;
    DhcpAssert(HardwareAddress);

    PrintHWAddress( HardwareAddress, (BYTE)HardwareAddressLength );

    LOCK_DATABASE();
    DhcpDnsDecideOptionsForClient(                     // check out and see if the client needs DNS (de)registrations..
        desiredIpAddress,
        RequestContext,
        DhcpOptions,                                   // need to look at the client specified options
        &StateFlags                                    // OUT tell if the client is a down level client or not.
    );

    Error = DhcpCreateClientEntry(                     // now actually try to create a Database record
        desiredIpAddress,
        HardwareAddress,
        HardwareAddressLength,
        DhcpCalculateTime(INFINIT_LEASE),
        NewMachineName,
        NULL,
        CLIENT_TYPE_BOOTP,
        ntohl(RequestContext->EndPointIpAddress),
        (CHAR)(StateFlags | ADDRESS_STATE_ACTIVE),
        TRUE                                           // Existing
    );
    UNLOCK_DATABASE();
    DhcpFreeMemory(HardwareAddress);
    HardwareAddress = NULL;
    HardwareAddressLength = 0;

    if( Error != ERROR_SUCCESS ) {                     // could not create the entry?
        DhcpAssert( Error != ERROR_DHCP_RANGE_FULL );  // BOOTP clients cannot have this problem?
        CALLOUT_DROPPED(AdditionalContext, DHCP_DROP_NOADDRESS);
        return Error;
    }

    CALLOUT_RENEW_BOOTP(AdditionalContext, desiredIpAddress, INFINIT_LEASE);

    DhcpUpdateAuditLog(                                // log this event onto the audit logging facility
        DHCP_IP_LOG_BOOTP,
        GETSTRING( DHCP_IP_LOG_BOOTP_NAME ),
        desiredIpAddress,
        OptionHardwareAddress,
        OptionHardwareAddressLength,
        NewMachineName
    );

    DhcpAssert( desiredIpAddress != NO_DHCP_IP_ADDRESS );
    DhcpAssert( desiredIpAddress != 0 );
    DhcpAssert( desiredIpAddress != ClientSubnetAddress );
    DhcpAssert( ClientSubnetMask != 0 );

    //
    // Now generate and send a reply.
    //

    dhcpReceiveMessage->Reserved |= DHCP_BROADCAST;    // force server to broadcast response

    dhcpSendMessage = (LPDHCP_MESSAGE) RequestContext->SendBuffer;
    RtlZeroMemory( RequestContext->SendBuffer, BOOTP_MESSAGE_SIZE );

    dhcpSendMessage->Operation = BOOT_REPLY;
    dhcpSendMessage->TransactionID = dhcpReceiveMessage->TransactionID;
    dhcpSendMessage->YourIpAddress = htonl( desiredIpAddress );

    if ( BootpServerIpAddress )
        dhcpSendMessage->BootstrapServerAddress = BootpServerIpAddress;
    else
        dhcpSendMessage->BootstrapServerAddress = RequestContext->EndPointIpAddress;

    dhcpSendMessage->Reserved = dhcpReceiveMessage->Reserved;

    dhcpSendMessage->HardwareAddressType =
        dhcpReceiveMessage->HardwareAddressType;
    dhcpSendMessage->HardwareAddressLength =
        dhcpReceiveMessage->HardwareAddressLength;
    RtlCopyMemory(
        dhcpSendMessage->HardwareAddress,
        dhcpReceiveMessage->HardwareAddress,
        dhcpReceiveMessage->HardwareAddressLength
    );

    dhcpSendMessage->RelayAgentIpAddress = dhcpReceiveMessage->RelayAgentIpAddress;

    strncpy( dhcpSendMessage->BootFileName, szBootFileName, BOOT_FILE_SIZE);
    RtlZeroMemory( dhcpSendMessage->HostName, BOOT_SERVER_SIZE );

    Option = &dhcpSendMessage->Option;
    OptionEnd = (LPBYTE)dhcpSendMessage + BOOTP_MESSAGE_SIZE;

    Option = (LPOPTION) DhcpAppendMagicCookie( (LPBYTE) Option, OptionEnd );

    fSwitchedSubnet = DhcpSubnetIsSwitched( RequestContext->Subnet );

    if ( fSwitchedSubnet ) {                           // see dhcpsrv.doc on switched subnets..
        networkOrderIpAddress =  htonl( desiredIpAddress );
        Option = DhcpAppendOption(                     // set router address as self ==> all subnets are on the same wire
            Option,
            OPTION_ROUTER_ADDRESS,
            &networkOrderIpAddress,
            sizeof( networkOrderIpAddress ),
            OptionEnd
        );
    }

    networkOrderSubnetMask = htonl( ClientSubnetMask );

    Option = DhcpAppendOption(
        Option,
        OPTION_SUBNET_MASK,
        &networkOrderSubnetMask,
        sizeof(networkOrderSubnetMask),
        OptionEnd
    );

    if( 0 != StateFlags ) {                            // Append DYNDNS related options
        Option = DhcpAppendDnsRelatedOptions(
            Option,
            DhcpOptions,
            OptionEnd,
            IS_DOWN_LEVEL(StateFlags)
        );
    }

    // BUG:BUG we should have a set of mandatory options being sent irrespective and in addition to
    // whatever the client requests...

    if ( !DhcpOptions->ParameterRequestList ) {        // add any parameters requested by the client
        // fake a default set of requests..
        DhcpOptions->ParameterRequestList       = pbOptionList;
        DhcpOptions->ParameterRequestListLength = sizeof( pbOptionList ) / sizeof( *pbOptionList );
    }

    Option = AppendClientRequestedParameters(
        desiredIpAddress,
        RequestContext,
        DhcpOptions->ParameterRequestList,
        DhcpOptions->ParameterRequestListLength,
        Option,
        OptionEnd,
        fSwitchedSubnet,
        TRUE
    );

    Option = DhcpAppendOption(
        Option,
        OPTION_END,
        NULL,
        0,
        OptionEnd
    );

    RequestContext->SendMessageSize = (DWORD)((LPBYTE)Option - (LPBYTE)dhcpSendMessage);
    DhcpAssert( RequestContext->SendMessageSize <= BOOTP_MESSAGE_SIZE );

    DhcpPrint((DEBUG_STOC, "Bootp Request leased, %s.\n", DhcpIpAddressToDottedString(desiredIpAddress)));

    return ERROR_SUCCESS;
}

DWORD                                                  // must be called with pending list lock taken
DhcpDiscoverValidateRequestedAddress(                  // check if everything is ok with the address being requested by client
    IN      PDHCP_REQUEST_CONTEXT  RequestContext,     // input request context
    IN      DHCP_IP_ADDRESS UNALIGNED *RequestedAddress, // client may be requesting something
    IN      LPBYTE                 HardwareAddress,
    IN      DWORD                  HardwareAddressLength,
    IN      BOOL                   fBootp,
    OUT     DHCP_IP_ADDRESS       *IpAddress           // this is the ip address chosen
)
{
    DHCP_IP_ADDRESS                desiredIpAddress;
    DHCP_IP_ADDRESS                SubnetAddress;
    DWORD                          Mask;
    DWORD                          Error;
    LPDHCP_PENDING_CTXT            PendingCtxt;

    DhcpSubnetGetSubnetAddressAndMask(
        RequestContext->Subnet,
        &SubnetAddress,
        &Mask
    );

    if( NULL == RequestedAddress ) {                   // no requests from the client
        *IpAddress = SubnetAddress;                    // choose some address from a subnet later
        return ERROR_SUCCESS;
    }

    desiredIpAddress = ntohl(*RequestedAddress);

    if( ! DhcpInSameSuperScope(desiredIpAddress, SubnetAddress) ) {
        *IpAddress = SubnetAddress;
        return ERROR_SUCCESS;
    }

    Error = DhcpFindPendingCtxt(
        NULL,
        0,
        desiredIpAddress,
        &PendingCtxt
    );
    if( ERROR_SUCCESS == Error ) {                     // found someone else waiting on this address...
        *IpAddress = SubnetAddress;
        return ERROR_SUCCESS;
    }

    Error = DhcpGetSubnetForAddress(
        desiredIpAddress,
        RequestContext
    );
    if( ERROR_SUCCESS != Error ) {
        Error = DhcpGetSubnetForAddress(
            SubnetAddress,
            RequestContext
        );
        DhcpAssert(ERROR_SUCCESS == Error);
        *IpAddress = SubnetAddress;
        return ERROR_SUCCESS;
    }

    if( DhcpSubnetIsDisabled(RequestContext->Subnet, fBootp ) ) {
        DhcpPrint((DEBUG_ERRORS, "Client request is on a disabled subnet..\n"));
        Error = ERROR_FILE_NOT_FOUND;
    } else if( DhcpAddressIsOutOfRange(desiredIpAddress, RequestContext, fBootp ) ||
               DhcpAddressIsExcluded(desiredIpAddress, RequestContext ) ) {
        DhcpPrint((DEBUG_ERRORS, "Client requested out of range or exlcluded address\n"));
        Error = ERROR_FILE_NOT_FOUND;
    } else {
        if( DhcpRequestSpecificAddress(RequestContext, desiredIpAddress) ) {
            Error = ERROR_IO_PENDING;                  // we just retrieved this addres.. we need to do conflict detection
            *IpAddress = desiredIpAddress;
        } else {
            BOOL fUnused;
            if( DhcpIsClientValid(
                desiredIpAddress, "ImpossibleHwAddress",
                sizeof("ImpossibleHwAddress"), &fUnused) ) {
                Error = ERROR_IO_PENDING;              // client is requesting an address that we is not available in registry
                *IpAddress = desiredIpAddress;         // but looks like database is ok with it... so give it to him..
            } else {
                Error = ERROR_FILE_NOT_FOUND;
            }
        }
    }

    if( ERROR_SUCCESS != Error && ERROR_IO_PENDING != Error ) {
        *IpAddress = SubnetAddress;
        Error = DhcpGetSubnetForAddress(
            SubnetAddress,
            RequestContext
        );
        DhcpAssert(ERROR_SUCCESS == Error);
    }

    if( ERROR_FILE_NOT_FOUND == Error ) return ERROR_SUCCESS;
    return Error;
}

DWORD
DhcpRespondToDiscover(                                 // respond to the DISCOVER message
    IN      LPDHCP_REQUEST_CONTEXT RequestContext,
    IN      LPPACKET               AdditionalContext,
    IN      LPDHCP_SERVER_OPTIONS  DhcpOptions,
    IN      LPBYTE                 OptionHardwareAddress,
    IN      DWORD                  OptionHardwareAddressLength,
    IN      DHCP_IP_ADDRESS        desiredIpAddress,
    IN      DWORD                  leaseDuration,
    IN      DWORD                  T1,
    IN      DWORD                  T2
    )
//
//  If desiredIpAddress is 0, then this client already has an IP address and
//  we're just passing back BINL's response.
//
{
    LPDHCP_MESSAGE                 dhcpReceiveMessage;
    LPDHCP_MESSAGE                 dhcpSendMessage;
    DHCP_IP_ADDRESS                desiredSubnetMask;
    DHCP_IP_ADDRESS                ClientSubnetAddress;
    DHCP_IP_ADDRESS                ClientSubnetMask;
    DHCP_IP_ADDRESS                networkOrderIpAddress;
    DHCP_IP_ADDRESS                networkOrderSubnetMask;
    DWORD                          Error;
    BYTE                           messageType;
    CHAR                           szBootFileName[ BOOT_FILE_SIZE ];
    CHAR                           szBootServerName[ BOOT_SERVER_SIZE ];
    LPOPTION                       Option;
    LPBYTE                         OptionEnd;
    BOOL                           fSwitchedSubnet, fBootp;
    DWORD                          BootpServerIpAddress;
    LPWSTR                         NewMachineName;
    WCHAR                          LocalBufferForMachineNameUnicodeString[256];
    ULONG                          StateFlags =0;

    fBootp = (NULL == DhcpOptions->MessageType );
    dhcpReceiveMessage = (LPDHCP_MESSAGE) RequestContext->ReceiveBuffer;

    DhcpAssert( desiredIpAddress != NO_DHCP_IP_ADDRESS );

    if ( desiredIpAddress != 0 ) {

        DhcpSubnetGetSubnetAddressAndMask(
            RequestContext->Subnet,
            &ClientSubnetAddress,
            &desiredSubnetMask
        );
        ClientSubnetMask = desiredSubnetMask;

        DhcpGetBootpInfo(
            RequestContext,
            desiredIpAddress,
            ClientSubnetMask,
            dhcpReceiveMessage->BootFileName,
            szBootFileName,
            &BootpServerIpAddress
        );
    }

    dhcpReceiveMessage->BootFileName[ BOOT_FILE_SIZE - 1 ] = '\0';

    if( fBootp ) {
        DhcpAssert( desiredIpAddress != 0 );
        if( NULL != RequestContext->Reservation ) {
            //
            // For BOOTP reservations, we use INFINITE_LEASE...
            //
            leaseDuration = INFINIT_LEASE;
        }
    }

    if( fBootp && (desiredIpAddress != 0) ) {
        LPBYTE HardwareAddress = NULL;
        ULONG HardwareAddressLength;

        if( INADDR_NONE == BootpServerIpAddress ) {
            //
            // Illegal bootp server specified by admin
            //
            return ERROR_DHCP_INVALID_DHCP_CLIENT;
        }

        DhcpDetermineHostName(
            RequestContext,
            desiredIpAddress,
            DhcpOptions,
            &NewMachineName,
            LocalBufferForMachineNameUnicodeString,
            sizeof(LocalBufferForMachineNameUnicodeString)/sizeof(WCHAR)
            );

        Error = DhcpMakeClientUID(
            OptionHardwareAddress,
            OptionHardwareAddressLength,
            dhcpReceiveMessage->HardwareAddressType,
            ClientSubnetAddress,
            &HardwareAddress,
            &HardwareAddressLength
            );
        if( ERROR_SUCCESS != Error ) return Error;

        PrintHWAddress( HardwareAddress, (BYTE)HardwareAddressLength );

        LOCK_DATABASE();
        DhcpDnsDecideOptionsForClient(
            desiredIpAddress,
            RequestContext,
            DhcpOptions,
            &StateFlags
            );

        Error = DhcpJetOpenKey(
            DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,
            (PVOID)&desiredIpAddress,
            sizeof(desiredIpAddress)
            );
        Error = DhcpCreateClientEntry(
            desiredIpAddress,
            HardwareAddress,
            HardwareAddressLength,
            DhcpCalculateTime(leaseDuration),
            NewMachineName,
            NULL,
            CLIENT_TYPE_BOOTP,
            ntohl(RequestContext->EndPointIpAddress),
            (CHAR)(StateFlags | ADDRESS_STATE_ACTIVE ),
            ERROR_SUCCESS == Error
            );

        UNLOCK_DATABASE();
        DhcpFreeMemory(HardwareAddress);

        if( ERROR_SUCCESS != Error ) {
            CALLOUT_DROPPED(AdditionalContext, DHCP_DROP_NOADDRESS);
            return Error;
        }

        CALLOUT_RENEW_BOOTP(AdditionalContext, desiredIpAddress, leaseDuration );
        DhcpUpdateAuditLog(
            RequestContext->Reservation ? DHCP_IP_LOG_BOOTP : DHCP_IP_LOG_DYNBOOTP,
            GETSTRING( (RequestContext->Reservation ?
                        DHCP_IP_LOG_BOOTP_NAME : DHCP_IP_LOG_DYNBOOTP_NAME
                )),
            desiredIpAddress,
            OptionHardwareAddress,
            OptionHardwareAddressLength,
            NewMachineName
            );
    }

    dhcpSendMessage = (LPDHCP_MESSAGE) RequestContext->SendBuffer;
    RtlZeroMemory( RequestContext->SendBuffer, DHCP_SEND_MESSAGE_SIZE );

    dhcpSendMessage->Operation = BOOT_REPLY;
    dhcpSendMessage->TransactionID = dhcpReceiveMessage->TransactionID;
    dhcpSendMessage->YourIpAddress = htonl( desiredIpAddress );
    if( FALSE == fBootp ) {
        dhcpSendMessage->Reserved = dhcpReceiveMessage->Reserved;
    } else {
        dhcpSendMessage->Reserved = dhcpReceiveMessage->Reserved | DHCP_BROADCAST;
    }

    dhcpSendMessage->HardwareAddressType = dhcpReceiveMessage->HardwareAddressType;
    dhcpSendMessage->HardwareAddressLength = dhcpReceiveMessage->HardwareAddressLength;
    RtlCopyMemory(
        dhcpSendMessage->HardwareAddress,
        dhcpReceiveMessage->HardwareAddress,
        dhcpReceiveMessage->HardwareAddressLength
    );

    if( BootpServerIpAddress && (fBootp || desiredIpAddress != 0) ) {
        dhcpSendMessage->BootstrapServerAddress = BootpServerIpAddress;
    } else {
        dhcpSendMessage->BootstrapServerAddress = RequestContext->EndPointIpAddress;
    }

    dhcpSendMessage->RelayAgentIpAddress =  dhcpReceiveMessage->RelayAgentIpAddress;

    RtlZeroMemory( dhcpSendMessage->HostName, BOOT_SERVER_SIZE );

    if ( fBootp || desiredIpAddress != 0 ) {
        strncpy( dhcpSendMessage->BootFileName, szBootFileName, BOOT_FILE_SIZE );
    }

    Option = &dhcpSendMessage->Option;
    if( fBootp ) {
        OptionEnd = (LPBYTE)dhcpSendMessage + BOOTP_MESSAGE_SIZE;
    } else {
        OptionEnd = (LPBYTE)dhcpSendMessage + DHCP_SEND_MESSAGE_SIZE;
    }

    Option = (LPOPTION) DhcpAppendMagicCookie( (LPBYTE) Option, OptionEnd );

    if( FALSE == fBootp ) {
        messageType = DHCP_OFFER_MESSAGE;
        Option = DhcpAppendOption(
            Option,
            OPTION_MESSAGE_TYPE,
            &messageType,
            1,
            OptionEnd
            );
    }

    fSwitchedSubnet = DhcpSubnetIsSwitched(RequestContext->Subnet);

    if ( fSwitchedSubnet ) {                           // see dhcpsrv.doc for details on switched subnets
        networkOrderIpAddress = htonl( desiredIpAddress );
        Option = DhcpAppendOption(                     // set router to self ==> all subnets are on the same wire
            Option,
            OPTION_ROUTER_ADDRESS,
            &networkOrderIpAddress,
            sizeof( networkOrderIpAddress ),
            OptionEnd
        );
    }

    if ( fBootp || desiredIpAddress != 0 ) {

        ClientSubnetMask = DhcpGetSubnetMaskForAddress(desiredIpAddress);
        networkOrderSubnetMask = htonl( ClientSubnetMask );
        Option = DhcpAppendOption(
            Option,
            OPTION_SUBNET_MASK,
            &networkOrderSubnetMask,
            sizeof(networkOrderSubnetMask),
            OptionEnd
        );
    }

    if( FALSE == fBootp && desiredIpAddress != 0 ) {
        T1 = htonl( T1 );
        Option = DhcpAppendOption(
            Option,
            OPTION_RENEWAL_TIME,
            &T1,
            sizeof(T1),
            OptionEnd
            );

        T2 = htonl( T2 );
        Option = DhcpAppendOption(
            Option,
            OPTION_REBIND_TIME,
            &T2,
            sizeof(T2),
            OptionEnd
            );

        leaseDuration = htonl( leaseDuration );
        Option = DhcpAppendOption(
            Option,
            OPTION_LEASE_TIME,
            &leaseDuration,
            sizeof(leaseDuration),
            OptionEnd
            );
    }

    if( FALSE == fBootp ) {

        Option = DhcpAppendOption(
            Option,
            OPTION_SERVER_IDENTIFIER,
            &RequestContext->EndPointIpAddress,
            sizeof(RequestContext->EndPointIpAddress),
            OptionEnd
            );

    }

    if( fBootp && 0 != StateFlags ) {
        Option = DhcpAppendDnsRelatedOptions(
            Option,
            DhcpOptions,
            OptionEnd,
            IS_DOWN_LEVEL(StateFlags)
            );
    }

    if( FALSE == fBootp ) {
        //
        //  If requested & appropriate inform client of BINL service
        //

        //
        //Option = BinlProcessRequest(RequestContext, DhcpOptions, Option, OptionEnd);
        //
        BinlProcessDiscover(RequestContext, DhcpOptions );
    }

    if( fBootp && NULL == DhcpOptions->ParameterRequestList ) {
        //
        // Fake request list for bootp clients
        //
        DhcpOptions->ParameterRequestList = pbOptionList;
        DhcpOptions->ParameterRequestListLength = sizeof(pbOptionList);
    }

    if ( DhcpOptions->ParameterRequestList != NULL ) { // if client requested for parameters add 'em
        Option = AppendClientRequestedParameters(
            desiredIpAddress,
            RequestContext,
            DhcpOptions->ParameterRequestList,
            DhcpOptions->ParameterRequestListLength,
            Option,
            OptionEnd,
            fSwitchedSubnet,
            FALSE
        );
    }

    if( fBootp && DhcpOptions->ParameterRequestList == pbOptionList ) {
        DhcpOptions->ParameterRequestList = NULL;
        DhcpOptions->ParameterRequestListLength = 0;
    }

    if( fBootp || desiredIpAddress != 0 ) {
        Option = ConsiderAppendingOption(
            desiredIpAddress,
            RequestContext,
            Option,
            OPTION_VENDOR_SPEC_INFO,
            OptionEnd,
            fSwitchedSubnet
            );
    }

    Option = DhcpAppendOption(                         // done it
        Option,
        OPTION_END,
        NULL,
        0,
        OptionEnd
    );

    RequestContext->SendMessageSize = (DWORD)((LPBYTE)Option - (LPBYTE)dhcpSendMessage);
    DhcpAssert( RequestContext->SendMessageSize <= DHCP_SEND_MESSAGE_SIZE );

    DhcpPrint((DEBUG_STOC, "DhcpDiscover leased address %s.\n", DhcpIpAddressToDottedString(desiredIpAddress)));

    InterlockedIncrement(&DhcpGlobalNumOffers);        // successful offers.
    return ERROR_SUCCESS;
}

DWORD
DhcpProcessDiscoverForValidatedAddress(                // add to pending list and send a validated address
    IN      DWORD                  desiredIpAddress,   // validated address
    IN OUT  PDHCP_REQUEST_CONTEXT  RequestContext,
    IN      LPPACKET               AdditionalContext,
    IN      LPDHCP_SERVER_OPTIONS  DhcpOptions,
    IN      LPBYTE                 OptionHardwareAddress,
    IN      DWORD                  OptionHardwareAddressLength,
    IN      BOOL                   AddToPendingList    // use this if dont wish to add to pending list
)
{
    DWORD                          Error, Error2;
    LPDHCP_MESSAGE                 dhcpReceiveMessage;
    LPDHCP_MESSAGE                 dhcpSendMessage;

    DHCP_IP_ADDRESS                ClientSubnetAddress = 0;
    DHCP_IP_ADDRESS                ClientSubnetMask = 0;
    DHCP_IP_ADDRESS                desiredSubnetMask;

    DWORD                          leaseDuration;
    DWORD                          T1;
    DWORD                          T2;
    BOOL                           fBootp;

    fBootp = (NULL == DhcpOptions->MessageType);
    DhcpSubnetGetSubnetAddressAndMask(
        RequestContext->Subnet,
        &ClientSubnetAddress,
        &ClientSubnetMask
    );
    desiredSubnetMask = ClientSubnetMask;
    dhcpReceiveMessage = (LPDHCP_MESSAGE) RequestContext->ReceiveBuffer;
    DhcpAssert((desiredIpAddress & desiredSubnetMask) == ClientSubnetAddress);
    DhcpAssert(desiredIpAddress != ClientSubnetAddress);

    if( NULL == RequestContext->Reservation ) {
        if( DhcpSubnetIsAddressExcluded(
            RequestContext->Subnet , desiredIpAddress
            ) ||
            DhcpSubnetIsAddressOutOfRange(
                RequestContext->Subnet, desiredIpAddress, fBootp
                )
            ) {
            DhcpPrint((DEBUG_STOC, "Request for excluded"
                       " or out of range address tossed out\n"));
            return ERROR_DHCP_INVALID_DHCP_CLIENT;
        }
    }

    GetLeaseInfo(                                      // determine lease time and other details
        desiredIpAddress,
        RequestContext,
        &leaseDuration,
        &T1,
        &T2,
        DhcpOptions->RequestLeaseTime
    );

    if( NULL == DhcpOptions->MessageType ) {
        //
        // No pending list for BOOTP
        //
        AddToPendingList = FALSE;
    }

    if( AddToPendingList ) {                           // add to pending list only if asked to
        LOCK_INPROGRESS_LIST();                        // locks unnecessary as must have already been taken? bug bug
        Error = DhcpAddPendingCtxt(
            OptionHardwareAddress,
            OptionHardwareAddressLength,
            desiredIpAddress,
            leaseDuration,
            T1,
            T2,
            0,
            DhcpCalculateTime( DHCP_CLIENT_REQUESTS_EXPIRE ),
            FALSE                                      // this record has been processed, nothing more to do
        );
        UNLOCK_INPROGRESS_LIST();
        DhcpAssert(ERROR_SUCCESS == Error);            // expect everything to go well here
    }

    return DhcpRespondToDiscover(
        RequestContext,
        AdditionalContext,
        DhcpOptions,
        OptionHardwareAddress,
        OptionHardwareAddressLength,
        desiredIpAddress,
        leaseDuration,
        T1,
        T2
    );
}

DWORD
ProcessDhcpDiscover(                                   // forward declaration
    IN OUT  LPDHCP_REQUEST_CONTEXT RequestContext,
    IN      LPDHCP_SERVER_OPTIONS  DhcpOptions,
    OUT     LPPACKET               AdditionalContext,
    OUT     LPDWORD                AdditionalStatus
);

DWORD
HandlePingCallback(                                    // asynchronous ping returns..
    IN      PDHCP_REQUEST_CONTEXT  RequestContext,     // the context with which we return
    IN      LPPACKET               AdditionalContext,
    IN      LPDHCP_SERVER_OPTIONS  DhcpOptions,        // parsed options
    IN      LPPACKET               Packet,             // ping context
    IN      DWORD                 *Status,             // status? useless really
    IN      LPBYTE                 OptionHardwareAddress,
    IN      DWORD                  OptionHardwareAddressLength
)
{
    LPDHCP_PENDING_CTXT            PendingCtxt;
    DWORD                          leaseDuration;
    DWORD                          T1, T2;
    DWORD                          Error;
    DWORD                          IpAddress;

    DhcpAssert(0 != Packet->PingAddress );
    LOCK_INPROGRESS_LIST();
    Error = DhcpFindPendingCtxt(
        OptionHardwareAddress,
        OptionHardwareAddressLength,
        0,
        &PendingCtxt                                   // find the pending context if one exists for above hw address
    );
    if( ERROR_SUCCESS != Error ) {                     // oops, could not find a corresponding packet?
        UNLOCK_INPROGRESS_LIST();
        return Error;                                  // whoever deleted the context would also have released the address
    }

    if( PendingCtxt->Address != Packet->PingAddress ||
        FALSE == PendingCtxt->Processing ) {
        DhcpPrint((DEBUG_STOC, "Pending ctxt for ping diff..\n"));
        UNLOCK_INPROGRESS_LIST();
        return ERROR_DHCP_INVALID_DHCP_CLIENT;
    }

    PendingCtxt->Processing = FALSE;                   // just finished processing

    if(  Packet->DestReachable ) {                     // ok to make offer?
        Error = DhcpRemovePendingCtxt(
            PendingCtxt
        );
        UNLOCK_INPROGRESS_LIST();
        DhcpAssert(ERROR_SUCCESS == Error);
        CALLOUT_CONFLICT(Packet);
        GetLeaseInfo(
            Packet->PingAddress,
            RequestContext,
            &leaseDuration,
            &T1,
            &T2,
            NULL
        );
        LOCK_DATABASE();
        IpAddress = Packet->PingAddress;
        Error = DhcpCreateClientEntry(
            (Packet->PingAddress),
            (LPBYTE)&(Packet->PingAddress),
            sizeof(Packet->PingAddress),
            DhcpCalculateTime(leaseDuration),
            GETSTRING( DHCP_BAD_ADDRESS_NAME ),
            GETSTRING( DHCP_BAD_ADDRESS_INFO ),
            (BYTE)((NULL == DhcpOptions->MessageType) ? CLIENT_TYPE_BOOTP : CLIENT_TYPE_DHCP),
            ntohl(RequestContext->EndPointIpAddress),
            ADDRESS_STATE_DECLINED,
            ERROR_SUCCESS == DhcpJetOpenKey(
                DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,&IpAddress,sizeof(IpAddress)
                )
            //TRUE                                     // Existing client? actually dont know, but dont matter
        );
        UNLOCK_DATABASE();

        DhcpFreeMemory(PendingCtxt);                   // dont use DhcpDeletePendingCtxt as that free's address
        Packet->PingAddress = 0;                       // zero it to indicate fresh call..
        Packet->DestReachable = FALSE;                 // initialize this ..
        DhcpOptions->RequestedAddress = NULL;          // ignore any requested address now..
        return ProcessDhcpDiscover(                    // start all over again and try to find an address
            RequestContext,
            DhcpOptions,
            Packet,
            Status
        );
    }

    // valid lease being offered
    UNLOCK_INPROGRESS_LIST();

    Error = DhcpGetSubnetForAddress(
        Packet->PingAddress,
        RequestContext
    );
    if( ERROR_SUCCESS != Error ) return Error;         // if this subnet no longer exists.. sorry buddy we got shoved

    return DhcpProcessDiscoverForValidatedAddress(
        Packet->PingAddress,
        RequestContext,
        AdditionalContext,
        DhcpOptions,
        OptionHardwareAddress,
        OptionHardwareAddressLength,
        FALSE                                          // no need to add to pending list, already there
    );
}

DWORD
ProcessDhcpDiscover(                                   // process discover packets
    IN OUT  LPDHCP_REQUEST_CONTEXT RequestContext,     // ptr to current request context
    IN      LPDHCP_SERVER_OPTIONS  DhcpOptions,        // parsed options from the message
    OUT     LPPACKET               AdditionalContext,  // asynchronous conflict detection context
    OUT     LPDWORD                AdditionalStatus    // asynchronous conflict detection status
)
{
    WCHAR                          ServerName[MAX_COMPUTERNAME_LENGTH + 10];
    DWORD                          Length;
    DWORD                          Error, Error2;
    LPDHCP_MESSAGE                 dhcpReceiveMessage;
    LPDHCP_MESSAGE                 dhcpSendMessage;

    BYTE                           bAllowedClientType;
    BYTE                          *OptionHardwareAddress;
    DWORD                          OptionHardwareAddressLength;

    DHCP_IP_ADDRESS                desiredIpAddress = NO_DHCP_IP_ADDRESS;
    DHCP_IP_ADDRESS                ClientSubnetAddress = 0;
    DHCP_IP_ADDRESS                ClientSubnetMask = 0;
    DHCP_IP_ADDRESS                desiredSubnetMask;

    LPDHCP_PENDING_CTXT            PendingContext;

    DWORD                          leaseDuration;
    DWORD                          T1;
    DWORD                          T2;
    DATE_TIME                      ZeroDateTime = {0, 0};
    BOOL                           fBootp;

    DhcpPrint(( DEBUG_STOC, "DhcpDiscover arrived.\n" ));

    if(AdditionalStatus) *AdditionalStatus = ERROR_SUCCESS;

    if( NULL == AdditionalContext || 0 == AdditionalContext->PingAddress ) {
        // This is a valid packet not a re-run because of ping-retry
        InterlockedIncrement(&DhcpGlobalNumDiscovers); // increment discovery counter.
    }

    fBootp = (NULL == DhcpOptions->MessageType ) ;

    dhcpReceiveMessage = (LPDHCP_MESSAGE) RequestContext->ReceiveBuffer;
    dhcpReceiveMessage->HostName[ BOOT_SERVER_SIZE - 1] = '\0';
    dhcpReceiveMessage->BootFileName[ BOOT_FILE_SIZE - 1 ] = '\0';

    if( fBootp ) {
        //
        // Bootp Clients -- verify if the server name is us (if present)
        //
        if( dhcpReceiveMessage->HostName[0] ) {
            WCHAR szHostName[ BOOT_SERVER_SIZE ];

            if( !DhcpOemToUnicode( dhcpReceiveMessage->HostName, szHostName ) ) {
                return ERROR_DHCP_INVALID_DHCP_MESSAGE;
            }


            Length = MAX_COMPUTERNAME_LENGTH + 10;         // get the server name
            if( !GetComputerName( ServerName, &Length ) ) {
                Error = GetLastError();                   // need to use gethostname..
                DhcpPrint(( DEBUG_ERRORS, "Can't get computer name, %ld.\n", Error ));
                
                return Error ;
            }
            
            DhcpAssert( Length <= MAX_COMPUTERNAME_LENGTH );
            ServerName[Length] = L'\0';
            
            if( _wcsicmp( szHostName, ServerName ) ) {
                return ERROR_DHCP_INVALID_DHCP_MESSAGE;
            }
        }
    }

    if ( DhcpOptions->Server != NULL ) {               // if client specified a server in its message
        if ( *DhcpOptions->Server != RequestContext->EndPointIpAddress ) {
            return ERROR_DHCP_INVALID_DHCP_CLIENT;     // we are not the server the client wants
        }
    }

    Error = DhcpDetermineInfoFromMessage(              // find h/w address and subnet address of client
        RequestContext,
        DhcpOptions,
        &OptionHardwareAddress,
        &OptionHardwareAddressLength,
        &ClientSubnetAddress
    );
    if( ERROR_SUCCESS != Error ) return Error;

    //
    //  if binl is running and this client already has an IP address and
    //  the client specified PXECLIENT as an option, then we just pass this
    //  discover on to BINL
    //

    if (CheckForBinlOnlyRequest( RequestContext, DhcpOptions )) {

        return DhcpRespondToDiscover(
            RequestContext,
            AdditionalContext,
            DhcpOptions,
            OptionHardwareAddress,
            OptionHardwareAddressLength,
            0,              // desiredIpAddress
            0,              // leaseDuration
            0,              // T1
            0               // T2
            );
    }

    if( NULL != AdditionalContext && 0 != AdditionalContext->PingAddress ) {
        return HandlePingCallback(
            RequestContext,
            AdditionalContext,
            DhcpOptions,
            AdditionalContext,
            AdditionalStatus,
            OptionHardwareAddress,
            OptionHardwareAddressLength
        );
    }

    LOCK_INPROGRESS_LIST();
    Error = DhcpFindPendingCtxt(
        OptionHardwareAddress,
        OptionHardwareAddressLength,
        0,
        &PendingContext                                // find the pending context if one exists for above hw address
    );
    if( NULL != PendingContext ) {                     // if we found a matching pending context
        if( PendingContext->Processing ) {             // if a ping is pending on this context
            UNLOCK_INPROGRESS_LIST();
            CALLOUT_DROPPED(AdditionalContext, DHCP_DROP_DUPLICATE);
            return ERROR_IO_PENDING;                   // return SOME error -- note that *AdditionalStatus is not set..
        }

        desiredIpAddress = PendingContext->Address;

        UNLOCK_INPROGRESS_LIST();

        Error = DhcpGetSubnetForAddress(               // get the subnet for this request
            desiredIpAddress,
            RequestContext
        );

	GetLeaseInfo(desiredIpAddress, RequestContext,
		     &leaseDuration, &T1, &T2, NULL);

//  	T1 = PendingContext->T1;
//  	T2 = PendingContext->T2;
//  	leaseDuration = PendingContext->LeaseDuration;


        if( ERROR_SUCCESS == Error ) {

            if( DhcpSubnetIsAddressOutOfRange(
                RequestContext->Subnet, desiredIpAddress, fBootp
                ) ) {
                return ERROR_DHCP_INVALID_DHCP_CLIENT;
            }

            Error = DhcpRespondToDiscover(
                RequestContext,
                AdditionalContext,
                DhcpOptions,
                OptionHardwareAddress,
                OptionHardwareAddressLength,
                desiredIpAddress,
                leaseDuration,
                T1,
                T2
            );
        }
        return Error;
    }

    desiredIpAddress = 0;

    Error = DhcpLookupReservationByHardwareAddress(    // first check if this is a reservation
        ClientSubnetAddress,
        OptionHardwareAddress,
        OptionHardwareAddressLength,
        RequestContext
    );

    if( ERROR_SUCCESS == Error ) {                     // found the reservation
        UNLOCK_INPROGRESS_LIST();
        DhcpReservationGetAddressAndType(
            RequestContext->Reservation,
            &desiredIpAddress,
            &bAllowedClientType
        );
        if( FALSE == fBootp ) {
            if( !(bAllowedClientType & CLIENT_TYPE_DHCP ) )
                return ERROR_DHCP_INVALID_DHCP_CLIENT;
        } else {
            if( !(bAllowedClientType & CLIENT_TYPE_BOOTP ) )
                return ERROR_DHCP_INVALID_DHCP_CLIENT;
        }

        //
        // For Reservations, we allow things to go through even if the
        // address pool allows only DHCP or only BOOTP etc so long as it
        // is NOT disabled..
        //

        if( DhcpIsSubnetStateDisabled(RequestContext->Subnet->State) ) {
            return ERROR_DHCP_INVALID_DHCP_CLIENT;
        }

        return DhcpProcessDiscoverForValidatedAddress(
            desiredIpAddress,
            RequestContext,
            AdditionalContext,
            DhcpOptions,
            OptionHardwareAddress,
            OptionHardwareAddressLength,
            FALSE                                      // dont really need to keep in pending list for this case
        );
    }
    DhcpAssert(ERROR_FILE_NOT_FOUND == Error);         // dont expect any other kind of errors

    // Nothing for this client on the pending list, and no reservations either

    Error = DhcpGetSubnetForAddress(                   // find which subnet this client belongs to
        ClientSubnetAddress,
        RequestContext
    );
    if( ERROR_SUCCESS != Error ) {
        UNLOCK_INPROGRESS_LIST();
        return ERROR_DHCP_INVALID_DHCP_CLIENT;         // uknown subnet
    }

    LOCK_DATABASE();
    Error = DhcpLookupDatabaseByHardwareAddress(       // see if this client has any address in the database
        RequestContext,
        OptionHardwareAddress,
        OptionHardwareAddressLength,
        &desiredIpAddress                              // and this is the desired address
    );
    UNLOCK_DATABASE();

    if( ERROR_SUCCESS == Error ) {
        if( DhcpSubnetIsDisabled(RequestContext->Subnet, fBootp ) ) {
            Error = DhcpRemoveClientEntry(desiredIpAddress, NULL, 0, TRUE, FALSE);
            DhcpAssert(ERROR_SUCCESS == Error);        // should be able to get rid of old request of this client..
            Error = ERROR_FILE_NOT_FOUND;              // finding in disabled subnet -- as good as not finding..
        } else {
            Error = DhcpProcessDiscoverForValidatedAddress(
                desiredIpAddress,
                RequestContext,
                AdditionalContext,
                DhcpOptions,
                OptionHardwareAddress,
                OptionHardwareAddressLength,
                TRUE                                   // yes, add this to pending list
            );
            if( ERROR_DHCP_INVALID_DHCP_CLIENT != Error ) {
                UNLOCK_INPROGRESS_LIST();
                return Error;
            }
            //
            // OOPS! We have a record for the client in the DB
            // But it isn't acceptable for some reason (excluded, out of range?)
            //
            Error = DhcpRemoveClientEntry(desiredIpAddress, NULL, 0, TRUE, FALSE);
            DhcpAssert(ERROR_SUCCESS == Error);
            Error = ERROR_FILE_NOT_FOUND;
        }
    }

    DhcpAssert(ERROR_FILE_NOT_FOUND == Error);         // this better be the only reason for failure

    Error = DhcpDiscoverValidateRequestedAddress(
        RequestContext,
        DhcpOptions->RequestedAddress,
        OptionHardwareAddress,
        OptionHardwareAddressLength,
        fBootp,
        &desiredIpAddress                              // this is the ip address to offer
    );
    if( ERROR_SUCCESS != Error ) {
        if( ERROR_IO_PENDING != Error ) {              // could be an indication that a ping may need to be scheduled
            UNLOCK_INPROGRESS_LIST();
            DhcpAssert(FALSE);                         // should not happen really
            return Error;
        }
        if( DhcpGlobalDetectConflictRetries ) {        // ok need to schedule a ping
            Error = DhcpAddPendingCtxt(
                OptionHardwareAddress,
                OptionHardwareAddressLength,
                desiredIpAddress,
                0,
                0,
                0,
                0,
                DhcpCalculateTime( DHCP_CLIENT_REQUESTS_EXPIRE ),
                TRUE                                   // yes, ping is scheduled on this
            );
            if( ERROR_SUCCESS == Error ) {
                AdditionalContext->PingAddress = desiredIpAddress;
                AdditionalContext->DestReachable = FALSE;
                *AdditionalStatus = ERROR_IO_PENDING;
            }
            UNLOCK_INPROGRESS_LIST();
            return Error;
        }
    }

    DhcpSubnetGetSubnetAddressAndMask(
        RequestContext->Subnet,
        &ClientSubnetAddress,
        &desiredSubnetMask
        );

    if( desiredIpAddress != ClientSubnetAddress ) {    // gotcha! got an address to send ..
        Error = DhcpProcessDiscoverForValidatedAddress(
            desiredIpAddress,
            RequestContext,
            AdditionalContext,
            DhcpOptions,
            OptionHardwareAddress,
            OptionHardwareAddressLength,
            TRUE
        );
        if( ERROR_DHCP_INVALID_DHCP_CLIENT != Error ) {
            UNLOCK_INPROGRESS_LIST();
            return Error;
        }
    }

    desiredIpAddress = ClientSubnetAddress;
    Error = DhcpRequestSomeAddress(                    // try to get some address..
        RequestContext,
        &desiredIpAddress,
        fBootp
    );
    if( Error == ERROR_DHCP_RANGE_FULL ) {             // failed because of lack of addresses
        DhcpGlobalScavengeIpAddress = TRUE;            // flag scanvenger to scavenge ip addresses
    }

    if( ERROR_SUCCESS == Error ) {
        if( DhcpGlobalDetectConflictRetries ) {        // cause a ping to be scheduled
            Error = DhcpAddPendingCtxt(
                OptionHardwareAddress,
                OptionHardwareAddressLength,
                desiredIpAddress,
                0,
                0,
                0,
                0,
                DhcpCalculateTime( DHCP_CLIENT_REQUESTS_EXPIRE ),
                TRUE                                   // yes, ping is scheduled on this
            );
            if( ERROR_SUCCESS == Error ) {
                AdditionalContext->PingAddress = desiredIpAddress;
                AdditionalContext->DestReachable = FALSE;
                *AdditionalStatus = ERROR_IO_PENDING;
            }
        } else {
            Error = DhcpProcessDiscoverForValidatedAddress(
                desiredIpAddress,
                RequestContext,
                AdditionalContext,
                DhcpOptions,
                OptionHardwareAddress,
                OptionHardwareAddressLength,
                TRUE
            );
        }
    }
    UNLOCK_INPROGRESS_LIST();
    return Error;
}

DWORD
DhcpDetermineClientRequestedAddress(                   // find which address is requested by the client
    IN      DHCP_MESSAGE          *pRequestMessage,    // input message
    IN      DHCP_SERVER_OPTIONS   *pOptions,           // parsed options
    IN      DHCP_REQUEST_CONTEXT  *pContext,           // the client context
    OUT     DHCP_IP_ADDRESS       *pIPAddress          // fill this in with the ip address requested by the client
)
{
    if( pRequestMessage->ClientIpAddress != 0 ) {      // if the "ciaddr" field has been filled in, use it
        // the client must be either in the RENEWING or REBINDING state.
       *pIPAddress = ntohl( pRequestMessage->ClientIpAddress );
    } else if ( pOptions->RequestedAddress != NULL ) { // try the option 50 "Requested Ip address"
        // the client's IP address was specified via option 50,
        // 'requested IP address'.  the client must be in SELECTING or INIT_REBOOT STATE
       *pIPAddress  = ntohl( *pOptions->RequestedAddress );
    } else {
        // the client did not request an IP address.  According to section 4.3.2
        // of the DHCP draft, the client must specify the requested IP address
        // in either 'ciaddr' or option 50, depending on the client's state:
        //
        // State        'ciaddr'            Option 50
        //
        // SELECTING    must not specify    must specify
        // INIT-REBOOT  must not specify    must specify
        // RENEWING     must specify        must not specify
        // REBINDING    must specify        must not specify
        //
        // if the client didn't request an address, this points to a bug in the
        // clients DHCP implementation.  If we simply ignore the problem, the client
        // will never receive an address.  So, we send a Nack which will cause the
        // client to return to the INIT state and send a DHCPDISCOVER.
        // set IpAddress to 0 so a garbage address won't appear in the log.
       *pIPAddress = 0;
        return ERROR_DHCP_INVALID_DHCP_CLIENT;
    }

    return ERROR_SUCCESS;
}

DWORD
DhcpValidIpAddressRequested (
    IN      DHCP_MESSAGE          *pRequestMessage,
    IN      DHCP_SERVER_OPTIONS   *pOptions,
    IN      DHCP_REQUEST_CONTEXT  *pContext,
    IN      DHCP_IP_ADDRESS        IPAddress
)
{
    DHCP_IP_ADDRESS                LocalAddress;

    if( ! pRequestMessage->RelayAgentIpAddress) {      // either this is unicast or not across a relay
        LocalAddress = ntohl( pContext->EndPointIpAddress);
        if( !pOptions->Server && pRequestMessage->ClientIpAddress )
            return ERROR_SUCCESS;                      // Client in RENEW state according to the draft
    } else {                                           // client is across a relay.
        LocalAddress  = ntohl( pRequestMessage->RelayAgentIpAddress );
    }

    // At this point: LocalAddress is either the relay agent's or local interface's address
    // And IpAddress is the ip address requested by the client

    if ( !DhcpInSameSuperScope( IPAddress, LocalAddress ))
        return ERROR_DHCP_INVALID_DHCP_CLIENT;         // nope they are not in the same superscope, NACK

    return ERROR_SUCCESS;                              // more validation in ProcessDhcpRequest
}

DWORD
DhcpRetractOffer(                                      // remove pending list and database entries
    IN      PDHCP_REQUEST_CONTEXT  RequestContext,
    IN      LPDHCP_SERVER_OPTIONS  DhcpOptions,
    IN      LPBYTE                 HardwareAddress,
    IN      DWORD                  HardwareAddressLength
)
{
    DWORD                          Error;
    DHCP_IP_ADDRESS                desiredIpAddress;
    LPDHCP_PENDING_CTXT            PendingCtxt;

    DhcpPrint((DEBUG_STOC, "Retracting offer (clnt accepted from %s)\n",
               DhcpIpAddressToDottedString(DhcpOptions->Server?*(DhcpOptions->Server):-1)));

    LOCK_INPROGRESS_LIST();
    Error = DhcpFindPendingCtxt(                       // try to see if we have this pending
        HardwareAddress,
        HardwareAddressLength,
        0,
        &PendingCtxt
    );
    if( ERROR_SUCCESS == Error ) {
        desiredIpAddress = PendingCtxt->Address;
        Error = DhcpRemovePendingCtxt(PendingCtxt);
        DhcpAssert(ERROR_SUCCESS == Error);
        Error = DhcpDeletePendingCtxt(PendingCtxt);
        DhcpAssert(ERROR_SUCCESS == Error);
    }
    UNLOCK_INPROGRESS_LIST();

    if( NULL == RequestContext->Subnet ) {             // what can we do when we dont even know who this is?
        return ERROR_DHCP_INVALID_DHCP_CLIENT;
    }

    LOCK_DATABASE();
    if( ERROR_SUCCESS != Error) {
        DhcpPrint((DEBUG_MISC, "Retract offer: client has no records\n" ));
        Error = DhcpLookupDatabaseByHardwareAddress(
            RequestContext,
            HardwareAddress,
            HardwareAddressLength,
            &desiredIpAddress
        );
        if( ERROR_SUCCESS != Error ) {                 // did not really have any record in the database
            UNLOCK_DATABASE();
            return ERROR_DHCP_INVALID_DHCP_CLIENT;
        }
    } else {
        DhcpPrint((DEBUG_MISC, "Deleting pending client entry, %s.\n",
                   DhcpIpAddressToDottedString(desiredIpAddress)
        ));
    }

    // bug #65666
    //
    // it's necessary to delete client entries in the ADDRESS_STATE_ACTIVE
    // state as well as ADDRESS_STATE_OFFERED.  see the comments in
    // DhcpCreateClientEntry for details.

    Error = DhcpRemoveClientEntry(
        desiredIpAddress,
        HardwareAddress,
        HardwareAddressLength,
        TRUE,                                          // release address from bit map.
        FALSE                                          // ignore record state.
    );
    UNLOCK_DATABASE();

    if( Error != ERROR_SUCCESS ) {
        DhcpPrint(( DEBUG_ERRORS, "[RetractOffer] RemoveClientEntry(%s): %ld [0x%lx]\n",
                    DhcpIpAddressToDottedString(desiredIpAddress), Error, Error ));
    }

    return ERROR_DHCP_INVALID_DHCP_CLIENT;
}

DWORD  _inline
DhcpDetermineRequestedAddressInfo(
    IN OUT  LPDHCP_REQUEST_CONTEXT RequestContext,
    IN      LPDHCP_SERVER_OPTIONS  DhcpOptions,
    IN      LPDHCP_MESSAGE         dhcpReceiveMessage,
    IN      BOOL                   fDirectedAtUs,
    OUT     DHCP_IP_ADDRESS       *RequestedIpAddress,
    OUT     BOOL                  *fSendNack
)
/*++

Routine Description:

    This function looks at the packet and determines the Requested Address
    for this client and validates that it is OK for the client to request this
    Address -- by verifying the client's subnet address matches the requested
    address (same superscope).

    The client's subnet address is the relay-agent's address if present or the
    interface's address through which this client's packet was received.

    0.  If SIADDR is some other server, just retrieve ip address..
        and return ERROR_SUCCESS.

    1.  If there is no CIADDR or RequestedAddrOption, we NACK if SIADDR is
        not set to any valid IP address or set to this server's IP address.

    2.  If the packet comes through a Relay Agent (giaddr set) and the
        RelayAgent is not in any configured scope:
           If the SIADDR was set to OUR IpAddress we NACK it else we DROP it.

    3.  If the requested subnet doesn't exist, but we the interface we received
        the message was not configured either, we DONT send a NACK unless the
        message had SIADDR set to our IP address.

    4.  If the requested Subnet doesn't exist (with interface configured),
        we NACK it if SIADDR is set to our IP address or if SIADDR is not valid.

    5.  If client is SELECTING or INIT-REBOOTING (CIADDR = 0), and if the
        interface on which we received it has an IP address for which no
        scope is configured, we NACK it (if SIADDR is invalid or points to us,
        otherwise, we DROP it).
        This check should also be done for REBIND but there is no way to tell
        a REBIND from a RENEW in case of no relay agent, so we don't do that.

Arguments:

    RequestContext                 context for incoming request -- in case of success
                                   the correct subnet will be configured here..

    DhcpOptions                    the parsed options received from the client

    dhcpReceoveMessage             the incoming message

    fDirectedAtUs                  FALSE ==> pointedly directed at some other server
                                   TRUE ==> SIADDR = self or invalid SIADDR

    RequestedIpAddress             This is the IP address that the client wants to use

    fSendNack                      Should we send a NACK?

Returns:

    Returns either ERROR_SUCCESS or ERROR_DHCP_INVALID_DHCP_CLIENT or
                   ERROR_DHCP_UNSUPPORTED_CLIENT.

    Note that ERROR_SUCCESS could be returned directly if fDirectedAtus is false.

    In any case, fSendNack is set to TRUE if a Nack needs to be sent.
    If the return value is not success, the packet has to be dropped.

--*/
{
    ULONG                          Error;
    DHCP_IP_ADDRESS                ClientAddress, ClientSubnetAddress, ClientMask;
    DHCP_IP_ADDRESS                InterfaceSubnetAddress, InterfaceMask;
    BOOL                           fRenewOrRebind;
    BOOL                           fBootp;

    fBootp = (NULL == DhcpOptions->MessageType );

    //
    // Generally, don't send a NACK if the packet wasn't directed at us..
    //

    *fSendNack = fDirectedAtUs;
    fRenewOrRebind = FALSE;
    *RequestedIpAddress = 0;

    //
    // Determine client's IP address from ci-addr first then requested address..
    // According to RFC2131, CIADDR must be specified only in RENEW or REBIND
    //

    if( 0 != dhcpReceiveMessage->ClientIpAddress ) {

        ClientAddress = ntohl( dhcpReceiveMessage->ClientIpAddress );
        fRenewOrRebind = TRUE;

    } else if( NULL != DhcpOptions->RequestedAddress ) {

        ClientAddress = ntohl( *DhcpOptions->RequestedAddress );

    } else {

        DhcpPrint((DEBUG_ERRORS, "Invalid client -- no CIADDR or Requested Address option\n"));
        return ERROR_DHCP_INVALID_DHCP_CLIENT;
    }

    *RequestedIpAddress = ClientAddress;

    DhcpPrint((DEBUG_STOC, "REQUEST for address %s\n", inet_ntoa(*(struct in_addr *)&ClientAddress)));

    if( !fDirectedAtUs ) {
        Error = DhcpGetSubnetForAddress(
            ClientAddress,
            RequestContext
        );

        DhcpPrint((DEBUG_STOC, "Ignoring SELECTING request for another server: %ld\n", Error));
        return Error;
    }

    //
    // Verify relay agent sanity. If it is an unknown relay agent, drop the packet
    // unless the message was directed explicity at us.
    //

    if( 0 != dhcpReceiveMessage->RelayAgentIpAddress ) {

        InterfaceSubnetAddress = ntohl(dhcpReceiveMessage->RelayAgentIpAddress);
        InterfaceMask = DhcpGetSubnetMaskForAddress( InterfaceSubnetAddress );

        DhcpPrint((DEBUG_STOC, "REQUEST from relay agent: %s\n",
                   inet_ntoa(*(struct in_addr *)&InterfaceSubnetAddress )));

        if( 0 == InterfaceMask ) {

            if( DhcpOptions->Server &&
                *DhcpOptions->Server == RequestContext->EndPointIpAddress ) {

                DhcpPrint((DEBUG_ERRORS, "Directed request from unsupported GIADDR\n"));
                return ERROR_DHCP_INVALID_DHCP_CLIENT;
            }

            DhcpPrint((DEBUG_ERRORS, "Undirected request from unsupported GIADDR ignored\n"));
            *fSendNack = FALSE;
            return ERROR_DHCP_UNSUPPORTED_CLIENT;
        }
    } else {

        InterfaceSubnetAddress = ntohl(RequestContext->EndPointIpAddress);
        // We Don't have interface mask yet.  We do that later on.

        InterfaceMask = 0;
    }

    //
    // retrieve subnet of client's requested address -- if we don't have one or scope
    // is disabled, got to NACK it..
    //

    Error = DhcpGetSubnetForAddress(
        ClientAddress,
        RequestContext
    );

    if( ERROR_SUCCESS != Error ) {
        //
        //  We don't know about the requested address.  Do we know about the interface
        //  it came on? If we don't know about the interface then we DONT NACK it.
        //

        if( 0 == InterfaceMask ) {
            InterfaceMask = DhcpGetSubnetMaskForAddress( InterfaceSubnetAddress );
        }

        if( 0 == InterfaceMask ) {
            if( DhcpOptions->Server &&
                *DhcpOptions->Server == RequestContext->EndPointIpAddress ) {

                DhcpPrint((DEBUG_ERRORS, "Directed request from unsupported INTERFACE\n"));
                return ERROR_DHCP_INVALID_DHCP_CLIENT;
            }

            DhcpPrint((DEBUG_ERRORS, "Undirected request from unsupported INTERFACE ignored\n"));
            *fSendNack = FALSE;
            return ERROR_DHCP_UNSUPPORTED_CLIENT;
        }

        return ERROR_DHCP_INVALID_DHCP_CLIENT;
    }

    if( ERROR_SUCCESS != Error || DhcpSubnetIsDisabled( RequestContext->Subnet, fBootp ) ) {

        if( ERROR_SUCCESS == Error ) {
            DhcpPrint((DEBUG_ERRORS, "REQUEST on a disabled subnet, ignored\n"));
            *fSendNack = FALSE;
            return ERROR_SUCCESS;
        } else {
            DhcpPrint((DEBUG_ERRORS, "INVALID requested address\n"));
        }

        return ERROR_DHCP_INVALID_DHCP_CLIENT;
    }

    //
    // We need to do more checks for REBIND, but since we can't detect a REBIND
    // from the RENEW, we leave it at that and go ahead...  Note that if we do have a
    // relay agent IP address, then it can't be RENEW as RENEW has to be a UNICAST.
    // So, we figure that out and proceed with the checks in case of REBIND from across
    // a relay agent.
    //

    if( fRenewOrRebind && 0 == dhcpReceiveMessage->RelayAgentIpAddress ) {
        DhcpPrint((DEBUG_STOC, "Possibly RENEW (REBIND) request -- allowed\n"));
        *fSendNack = FALSE;
        return ERROR_SUCCESS;
    }

    //
    // More checks for SELECTING or INIT_REBOOTING or REBIND-from-across-relay state..
    //

    if( 0 == dhcpReceiveMessage->RelayAgentIpAddress ) {
        InterfaceMask = DhcpGetSubnetMaskForAddress( InterfaceSubnetAddress );
        if( 0 == InterfaceMask ) {
            DhcpPrint((DEBUG_ERRORS, "REQUEST came over wrong interface!\n"));

            return ERROR_DHCP_INVALID_DHCP_CLIENT;
        }

        InterfaceSubnetAddress &= InterfaceMask;
    }

    DhcpAssert( InterfaceMask );
    DhcpAssert( InterfaceSubnetAddress );

    DhcpPrint((DEBUG_STOC, "Interface subnet = %s\n", inet_ntoa(*(struct in_addr*)&InterfaceSubnetAddress)));

    if( !DhcpSubnetInSameSuperScope( RequestContext->Subnet, InterfaceSubnetAddress) ) {

        DhcpPrint((DEBUG_ERRORS, "Superscope check failed \n"));
        return ERROR_DHCP_INVALID_DHCP_CLIENT;
    }

    *fSendNack = FALSE;
    return ERROR_SUCCESS;
}

DWORD
ProcessDhcpRequest(                                    // process a client REQUEST packet..
    IN OUT  LPDHCP_REQUEST_CONTEXT RequestContext,     // current client request structure
    IN      LPDHCP_SERVER_OPTIONS  DhcpOptions,       // parsed options from the message
    OUT     LPPACKET               AdditionalContext, // used to store info in case or asynchronous ping
    OUT     LPDWORD                AdditionalStatus   // used to return status in case of asynchronous ping
)
{
    DWORD                          Error, Error2;
    DWORD                          LeaseDuration;
    DWORD                          T1, T2;
    DWORD                          dwcb;

    BOOL                           fDirectedAtUs;
    BOOL                           fSwitchedSubnet;
    BOOL                           fJustCreatedEntry = FALSE;
    BOOL                           existingClient;
    BOOL                           fSendNack;

    BYTE                          *HardwareAddress = NULL;
    BYTE                          *OptionHardwareAddress;
    DWORD                          HardwareAddressLength = 0;
    DWORD                          OptionHardwareAddressLength;

    BOOL                           fValidated, fReserved, fReconciled;
    DWORD                          StateFlags = 0;
    BYTE                           bAddressState;
    BYTE                          *OptionEnd;
    OPTION                        *Option;

    WCHAR                          LocalBufferForMachineNameUnicodeString[OPTION_END+2];
    LPWSTR                         NewMachineName = NULL;

    LPDHCP_MESSAGE                 dhcpReceiveMessage;
    LPDHCP_MESSAGE                 dhcpSendMessage;

    LPDHCP_PENDING_CTXT            PendingCtxt;

    DHCP_IP_ADDRESS                ClientSubnetAddress = 0;
    DHCP_IP_ADDRESS                networkOrderIpAddress;
    DHCP_IP_ADDRESS                NetworkOrderSubnetMask;
    DHCP_IP_ADDRESS                ClientSubnetMask = 0;
    DHCP_IP_ADDRESS                IpAddress;
    DHCP_IP_ADDRESS                realIpAddress;

    DhcpPrint(( DEBUG_STOC, "Processing DHCPREQUEST.\n" ));

    dhcpReceiveMessage  = (LPDHCP_MESSAGE)RequestContext->ReceiveBuffer;
    dhcpSendMessage     = (LPDHCP_MESSAGE)RequestContext->SendBuffer;

    InterlockedIncrement(&DhcpGlobalNumRequests);

    if( AdditionalStatus ) {
        *AdditionalStatus   = ERROR_SUCCESS;
    }

    //
    //  Figure out some basic stuff -- is the packet looking good ? right interface etc..
    //

    if( DhcpOptions->Server && *DhcpOptions->Server != RequestContext->EndPointIpAddress ) {
        fDirectedAtUs = FALSE;                         // this is not sent to us specifically
    } else {
        fDirectedAtUs = TRUE;                          // this IS intended for this  server
    }

    OptionHardwareAddress = NULL; OptionHardwareAddressLength = 0;
    if( DhcpOptions->ClientHardwareAddress ) {
        OptionHardwareAddress = DhcpOptions->ClientHardwareAddress;
        OptionHardwareAddressLength = DhcpOptions->ClientHardwareAddressLength;
    } else {
        OptionHardwareAddress = dhcpReceiveMessage->HardwareAddress;
        OptionHardwareAddressLength = dhcpReceiveMessage->HardwareAddressLength;
    }

    //
    //  if binl is running and this client already has an IP address and
    //  the client specified PXECLIENT as an option, then we just pass this
    //  discover on to BINL
    //

    if (CheckForBinlOnlyRequest( RequestContext, DhcpOptions )) {

        Option = FormatDhcpAck(
            RequestContext,
            dhcpReceiveMessage,
            dhcpSendMessage,
            0,                  // ip address
            0,                  // lease duration
            0,                  // T1
            0,                  // T2
            RequestContext->EndPointIpAddress
        );

        OptionEnd = (LPBYTE)dhcpSendMessage + DHCP_SEND_MESSAGE_SIZE;

        fSwitchedSubnet = DhcpSubnetIsSwitched(RequestContext->Subnet);

        if ( fSwitchedSubnet ) {
            IpAddress = ((struct sockaddr_in *)(&RequestContext->SourceName))->sin_addr.s_addr ;
            DhcpAssert(0 != IpAddress );
            networkOrderIpAddress = htonl( IpAddress );
            Option = DhcpAppendOption(
                Option,
                OPTION_ROUTER_ADDRESS,
                &networkOrderIpAddress,
                sizeof( networkOrderIpAddress ),
                OptionEnd
            );
        }

        //  If requested & appropriate inform client of BINL service
        Option = BinlProcessRequest(RequestContext, DhcpOptions, Option, OptionEnd );

        if ( DhcpOptions->ParameterRequestList != NULL ) { // add any client requested parameters
            Option = AppendClientRequestedParameters(
                IpAddress,
                RequestContext,
                DhcpOptions->ParameterRequestList,
                DhcpOptions->ParameterRequestListLength,
                Option,
                OptionEnd,
                fSwitchedSubnet,
                TRUE
            );
        }

        Option = DhcpAppendOption(
            Option,
            OPTION_END,
            NULL,
            0,
            OptionEnd
        );

        RequestContext->SendMessageSize = (DWORD)((LPBYTE)Option - (LPBYTE)dhcpSendMessage);

        DhcpPrint(( DEBUG_STOC, "DhcpRequest bypassed, binl only request for (%ws).\n",
                    NewMachineName? NewMachineName : L"<no-name>"
        ));

        return ERROR_SUCCESS;
    }

    fSendNack = FALSE;                                 // do we need to NACK?
    Error = DhcpDetermineRequestedAddressInfo(
        RequestContext,
        DhcpOptions,
        dhcpReceiveMessage,
        fDirectedAtUs,
        &IpAddress,
        &fSendNack
    );

    DhcpDetermineHostName(                             // find the client machine name
        RequestContext,
        IpAddress,
        DhcpOptions,
        &NewMachineName,
        LocalBufferForMachineNameUnicodeString,
        sizeof(LocalBufferForMachineNameUnicodeString)/sizeof(WCHAR)
    );

    if( fSendNack ) goto Nack;                         // NACK
    if( ERROR_SUCCESS != Error ) return Error;         // DROP

    if( !fDirectedAtUs ) {
        return DhcpRetractOffer(                       // RETRACT & DROP
            RequestContext,
            DhcpOptions,
            OptionHardwareAddress,
            OptionHardwareAddressLength
        );
    }

    DhcpAssert(IpAddress && RequestContext->Subnet);   // got to have these by now..

    DhcpSubnetGetSubnetAddressAndMask(
        RequestContext->Subnet,
        &ClientSubnetAddress,
        &ClientSubnetMask
    );

    DhcpAssert( ClientSubnetMask );
    DhcpAssert( ClientSubnetAddress );

    Error = DhcpMakeClientUID(
        OptionHardwareAddress,
        OptionHardwareAddressLength,
        dhcpReceiveMessage->HardwareAddressType,
        ClientSubnetAddress,
        &HardwareAddress,
        &HardwareAddressLength
        );
    if( ERROR_SUCCESS != Error ) return Error;     // should not really happen

    //
    // Check if this is a reservation etc.
    //

    fValidated = DhcpValidateClient(
        IpAddress, HardwareAddress, HardwareAddressLength
        );
    if( fValidated ) {
        fReserved = DhcpServerIsAddressReserved(DhcpGetCurrentServer(), IpAddress);
    } else {
        fReserved = FALSE;
    }

    //
    // This is a renewal request.  Verify if it is correctly in range etc..
    //
    if( DhcpIsSubnetStateDisabled(RequestContext->Subnet->State) ||
        DhcpSubnetIsAddressOutOfRange(
            RequestContext->Subnet, IpAddress, FALSE
            ) ||
        DhcpSubnetIsAddressExcluded(RequestContext->Subnet, IpAddress) ) {

        Error = ERROR_DHCP_INVALID_DHCP_CLIENT ;
        DhcpPrint((DEBUG_STOC, "ProcessDhcpRequest: OutOfRange/Excluded ipaddress\n"));

        if( fReserved
            && !DhcpIsSubnetStateDisabled(RequestContext->Subnet->State) ) {
            //
            // For reserved clients, if subnet is not disabled,
            // we send ACK even if the client is out of range  etc.
            //
            DhcpPrint((DEBUG_STOC, "Allowing reserved out of range client.\n"));
            Error = ERROR_SUCCESS;
        } else if( DhcpOptions->Server || fValidated ) {
            //
            // Either client is in SELECTING state -- in which case we have to
            // NACK.
            // Or, we have this client's record -- Delete the record as well as
            // send him a NACK.  Next time through, we would just ignore this...
            //

            DhcpRemoveClientEntry(
                IpAddress, HardwareAddress, HardwareAddressLength,
                TRUE, FALSE /* release address from bitmap, delete all records.. */
                );

            goto Nack;
        } else {
            //
            // Client wasn't validated.. it wasn't in selecting state either.
            // So, we just ignore this out of range request..
            //

            DhcpPrint((DEBUG_STOC, "Unknown client, out of range IP, ignored.\n"));
            if( HardwareAddress ) DhcpFreeMemory( HardwareAddress );
            HardwareAddress = NULL;
            return ERROR_DHCP_INVALID_DHCP_CLIENT;
        }
    }

    //
    // At this point, the IP address is in a valid range that we serve. Also,
    // the request is not directed at some other server -- so if anything is invalid
    // we can safely NACK
    //

    GetLeaseInfo(
        IpAddress,
        RequestContext,
        &LeaseDuration,
        &T1,
        &T2,
        DhcpOptions->RequestLeaseTime
    );

    LOCK_INPROGRESS_LIST();
    Error = DhcpFindPendingCtxt(
        NULL,
        0,
        IpAddress,
        &PendingCtxt
    );
    if( ERROR_SUCCESS == Error ) {                     // there is some pending ctxt with this address
        if( OptionHardwareAddressLength != PendingCtxt->nBytes ||
            0 != memcmp(OptionHardwareAddress, PendingCtxt->RawHwAddr, PendingCtxt->nBytes) ) {
            UNLOCK_INPROGRESS_LIST();
            Error = ERROR_DHCP_INVALID_DHCP_CLIENT;    // some one else is expected to take up this address
            goto Nack;
        }
        if( PendingCtxt->Processing ) {                // async ping is in progres.. drop its
            UNLOCK_INPROGRESS_LIST();
            return ERROR_DHCP_INVALID_DHCP_CLIENT;     // dont NACK.. just ignore it
        }

        Error = DhcpRemovePendingCtxt(PendingCtxt);    // remove & free pending context and proceed..
        DhcpAssert(ERROR_SUCCESS == Error);
        DhcpFreeMemory(PendingCtxt);
    } else {                                           // if not pending, need to request the particular address and "block" it
        //
        // Need to check if the same client obtained a different
        // hardware address..
        //
        Error = DhcpFindPendingCtxt(
            OptionHardwareAddress,
            OptionHardwareAddressLength,
            0,
            &PendingCtxt
            );
        if( ERROR_SUCCESS == Error
            && PendingCtxt->Address != IpAddress ) {
            //
            // Hmm.. we offered client diff address, now he's
            // asking for diff..
            //
            UNLOCK_INPROGRESS_LIST();
            DhcpPrint((DEBUG_STOC, "Client w/ ip address 0x%lx"
                       " asking for 0x%lx\n", PendingCtxt->Address,
                       IpAddress
                ));
            goto Nack;
        }

        LOCK_DATABASE();
        Error = DhcpLookupDatabaseByHardwareAddress(
           RequestContext,
           OptionHardwareAddress,
           OptionHardwareAddressLength,
           &realIpAddress
        );
        UNLOCK_DATABASE();
        if( ERROR_SUCCESS == Error) {
            if( IpAddress != realIpAddress ) {
                UNLOCK_INPROGRESS_LIST();
                DhcpPrint((DEBUG_STOC, "Client with ip address 0x%lx asking 0x%lx\n", realIpAddress, IpAddress));
                Error = ERROR_DHCP_INVALID_DHCP_CLIENT;
                goto Nack;
            }
        }

        Error = DhcpRequestSpecificAddress(RequestContext, IpAddress);
        if( ERROR_SUCCESS != Error ) {
            DhcpPrint((DEBUG_STOC, "Requested new address 0x%lx (failed %ld [0x%lx])\n", IpAddress, Error,Error));
            // DhcpAssert(FALSE);                      // this can happen if this address is given to someone else
        }
    }
    UNLOCK_INPROGRESS_LIST();

    PrintHWAddress( HardwareAddress, (BYTE)HardwareAddressLength );

    fReconciled = FALSE;
    LOCK_DATABASE();
    if( !DhcpIsClientValid(
        IpAddress, OptionHardwareAddress,
        OptionHardwareAddressLength, &fReconciled) ) { 
        // nope, this record is definitiely taken by some OTHER client
        UNLOCK_DATABASE();

        Error = ERROR_DHCP_INVALID_DHCP_CLIENT;
        goto Nack;
    }

    // Before we do this, we need to check out and see if this client needs to be
    // register both forward and backward..
    Error = DhcpJetOpenKey(
        DhcpGlobalClientTable[IPADDRESS_INDEX].ColName,
        &IpAddress,
        sizeof(IpAddress)
    );
    if( ERROR_SUCCESS  == Error ) {
        dwcb = sizeof(BYTE);
        Error = DhcpJetGetValue(
            DhcpGlobalClientTable[STATE_INDEX].ColHandle,
            &bAddressState,
            &dwcb
        );
        existingClient = TRUE;
    } else {
        existingClient = FALSE;
    }

    if( ERROR_SUCCESS != Error ) {
        bAddressState = ADDRESS_STATE_OFFERED;
    }

    DhcpDnsDecideOptionsForClient(
        IpAddress,                                     // The ip address to do the calcualations for
        RequestContext,                                // The subnet the client belongs to.
        DhcpOptions,                                   // need to look at the client specified options
        &StateFlags                                    // Additional flags to mark state
    );

    Error = DhcpCreateClientEntry(
        IpAddress,
        HardwareAddress,
        HardwareAddressLength,
        DhcpCalculateTime( LeaseDuration ),
        NewMachineName,
        fReconciled ? L"" : NULL, // if reconciled, clear the comment away
        CLIENT_TYPE_DHCP,
        ntohl(RequestContext->EndPointIpAddress),
        (CHAR)(StateFlags | ADDRESS_STATE_ACTIVE),
        existingClient
    );
    UNLOCK_DATABASE();
    DhcpFreeMemory(HardwareAddress);
    HardwareAddress = NULL; HardwareAddressLength =0;

    if( Error != ERROR_SUCCESS ) {
        if( !existingClient ) {
            DhcpPrint((DEBUG_STOC, "Releasing attempted address: 0x%lx\n", IpAddress));
            Error2 = DhcpReleaseAddress(IpAddress);
            DhcpAssert(ERROR_SUCCESS == Error2);
        }
        return Error;
    }

    CALLOUT_RENEW_DHCP(AdditionalContext, IpAddress, LeaseDuration, existingClient);
    if( IS_ADDRESS_STATE_ACTIVE(bAddressState) ) {
        DhcpUpdateAuditLog(
            DHCP_IP_LOG_RENEW,
            GETSTRING( DHCP_IP_LOG_RENEW_NAME ),
            IpAddress,
            OptionHardwareAddress,
            OptionHardwareAddressLength,
            NewMachineName
        );
    } else {
        DhcpUpdateAuditLog(
            DHCP_IP_LOG_ASSIGN,
            GETSTRING( DHCP_IP_LOG_ASSIGN_NAME ),
            IpAddress,
            OptionHardwareAddress,
            OptionHardwareAddressLength,
            NewMachineName
        );
    }

    Option = FormatDhcpAck(
        RequestContext,
        dhcpReceiveMessage,
        dhcpSendMessage,
        htonl(IpAddress),
        htonl(LeaseDuration),
        htonl(T1),
        htonl(T2),
        RequestContext->EndPointIpAddress
    );

    OptionEnd = (LPBYTE)dhcpSendMessage + DHCP_SEND_MESSAGE_SIZE;

    fSwitchedSubnet = DhcpSubnetIsSwitched(RequestContext->Subnet);

    if ( fSwitchedSubnet ) {
        networkOrderIpAddress = htonl( IpAddress );
        Option = DhcpAppendOption(
            Option,
            OPTION_ROUTER_ADDRESS,
            &networkOrderIpAddress,
            sizeof( networkOrderIpAddress ),
            OptionEnd
        );
    }

    NetworkOrderSubnetMask = htonl( ClientSubnetMask );
    Option = DhcpAppendOption(
        Option,
        OPTION_SUBNET_MASK,
        &NetworkOrderSubnetMask,
        sizeof( NetworkOrderSubnetMask ),
        OptionEnd
    );

    //  If requested & appropriate inform client of BINL service
    Option = BinlProcessRequest(RequestContext, DhcpOptions, Option, OptionEnd );

    if( 0 != StateFlags ) {                            // if required, append dyndns related stuff
        Option = DhcpAppendDnsRelatedOptions(
            Option,
            DhcpOptions,
            OptionEnd,
            IS_DOWN_LEVEL(StateFlags)
        );
    }

    if ( DhcpOptions->ParameterRequestList != NULL ) { // add any client requested parameters
        Option = AppendClientRequestedParameters(
            IpAddress,
            RequestContext,
            DhcpOptions->ParameterRequestList,
            DhcpOptions->ParameterRequestListLength,
            Option,
            OptionEnd,
            fSwitchedSubnet,
            FALSE
        );
    }

    Option = ConsiderAppendingOption(
        IpAddress,
        RequestContext,
        Option,
        OPTION_VENDOR_SPEC_INFO,
        OptionEnd,
        fSwitchedSubnet
    );

    Option = DhcpAppendOption(
        Option,
        OPTION_END,
        NULL,
        0,
        OptionEnd
    );

    RequestContext->SendMessageSize = (DWORD)((LPBYTE)Option - (LPBYTE)dhcpSendMessage);

    DhcpPrint(( DEBUG_STOC, "DhcpRequest committed, address %s (%ws).\n",
                DhcpIpAddressToDottedString(IpAddress),
                NewMachineName? NewMachineName : L"<no-name>"
    ));

    if( HardwareAddress ) {
        DhcpFreeMemory(HardwareAddress);
        HardwareAddress = NULL;
    }

    return ERROR_SUCCESS;

Nack:
    if( HardwareAddress ) {
        DhcpFreeMemory(HardwareAddress);
        HardwareAddress = NULL;
    }

    DhcpPrint(( DEBUG_STOC, "Invalid DHCPREQUEST for %s Nack'd.\n", DhcpIpAddressToDottedString ( IpAddress ) ));
    CALLOUT_NACK_DHCP(AdditionalContext, IpAddress);

/*------------- ft 06/30
 *  out as per Munil and Karoly suggestions for bug #172529
 *  post Beta 2 might get back in with a filtering on different levels of systemLog.
 *-------------

    DhcpServerEventLogSTOC(
        EVENT_SERVER_LEASE_NACK,
        EVENTLOG_WARNING_TYPE,
        IpAddress,
        OptionHardwareAddress,
        OptionHardwareAddressLength
    );

---------------*/

    DhcpUpdateAuditLog(
        DHCP_IP_LOG_NACK,
        GETSTRING( DHCP_IP_LOG_NACK_NAME ),
        IpAddress,
        OptionHardwareAddress,
        OptionHardwareAddressLength,
        NewMachineName
    );

    RequestContext->SendMessageSize =
        FormatDhcpNak(
            dhcpReceiveMessage,
            dhcpSendMessage,
            RequestContext->EndPointIpAddress
        );
    
    // Free the memory created for NewMachineName
    if (NewMachineName != NULL) {
	DhcpFreeMemory(NewMachineName);
	NewMachineName = NULL;
    } // 

    return ERROR_SUCCESS;
} // ProcessDhcpRequest()

DWORD
ProcessDhcpInform(
    IN      LPDHCP_REQUEST_CONTEXT RequestContext,
    IN      LPDHCP_SERVER_OPTIONS  DhcpOptions,
    IN      LPPACKET               AdditionalContext
)
{
    DWORD                          Error;
    DWORD                          dwcb;
    DWORD                          HardwareAddressLength;
    DWORD                          OptionHardwareAddressLength;
    LPBYTE                         HardwareAddress = NULL;
    LPBYTE                         OptionHardwareAddress;
    BYTE                           bAddressState;
    BOOL                           DatabaseLocked = FALSE;
    BOOL                           fSwitchedSubnet;

    LPBYTE                         OptionEnd;
    OPTION                        *Option;

    WCHAR                          LocalBufferForMachineNameUnicodeString[OPTION_END+2];
    LPWSTR                         NewMachineName = NULL;

    LPDHCP_MESSAGE                 dhcpReceiveMessage;
    LPDHCP_MESSAGE                 dhcpSendMessage;

    LPDHCP_PENDING_CTXT            PendingCtxt;

    DHCP_IP_ADDRESS                ClientSubnetAddress = 0;
    DHCP_IP_ADDRESS                NetworkOrderSubnetMask;
    DHCP_IP_ADDRESS                ClientSubnetMask    = 0;
    DHCP_IP_ADDRESS                IpAddress;

    DhcpDumpMessage(
        DEBUG_MESSAGE,
        (LPDHCP_MESSAGE)RequestContext->ReceiveBuffer,
        DHCP_MESSAGE_SIZE
        );

    InterlockedIncrement(&DhcpGlobalNumInforms);

    DhcpPrint((DEBUG_STOC, "Processing DHCPINFORM\n"));
    dhcpReceiveMessage  = (LPDHCP_MESSAGE)RequestContext->ReceiveBuffer;
    dhcpSendMessage     = (LPDHCP_MESSAGE)RequestContext->SendBuffer;


    OptionHardwareAddress = NULL; OptionHardwareAddressLength = 0;
    Error = DhcpDetermineInfoFromMessage(
        RequestContext,
        DhcpOptions,
        &OptionHardwareAddress,
        &OptionHardwareAddressLength,
        &ClientSubnetAddress
    );
    DhcpAssert(NULL != OptionHardwareAddress);

    // if( ERROR_SUCCESS != Error ) return Error;      // ignore errors here..

    if( DhcpOptions->DSDomainNameRequested ) {         // if another server is asking for DS domain name..
        Error = DhcpDetermineClientRequestedAddress(   // this may fail but ignore that..
            dhcpReceiveMessage,
            DhcpOptions,
            RequestContext,
            &IpAddress
        );
        ClientSubnetMask = ClientSubnetAddress =0;
    } else {
        Error = DhcpDetermineClientRequestedAddress(
            dhcpReceiveMessage,
            DhcpOptions,
            RequestContext,
            &IpAddress
        );
        if( ERROR_SUCCESS != Error ) return Error;     // unknown subnet

        Error = DhcpGetSubnetForAddress(
            IpAddress,
            RequestContext
        );
        if( ERROR_SUCCESS != Error ) return Error;     // unknown subnet

        DhcpSubnetGetSubnetAddressAndMask(
            RequestContext->Subnet,
            &ClientSubnetAddress,
            &ClientSubnetMask
        );

        DhcpAssert( IpAddress );
    }

    Option = FormatDhcpInformAck(                      // Here come the actual formatting of the ack!
        dhcpReceiveMessage,
        dhcpSendMessage,
        htonl(IpAddress),
        RequestContext->EndPointIpAddress
    );
    OptionEnd = (LPBYTE)dhcpSendMessage + DHCP_SEND_MESSAGE_SIZE;

    fSwitchedSubnet = DhcpSubnetIsSwitched(RequestContext->Subnet);

    if ( fSwitchedSubnet ) {
        DHCP_IP_ADDRESS networkOrderIpAddress = htonl( IpAddress );

        Option = DhcpAppendOption(
            Option,
            OPTION_ROUTER_ADDRESS,
            &networkOrderIpAddress,
            sizeof( networkOrderIpAddress ),
            OptionEnd
        );
    }

    NetworkOrderSubnetMask = htonl( ClientSubnetMask );
    Option = DhcpAppendOption(
        Option,
        OPTION_SUBNET_MASK,
        &NetworkOrderSubnetMask,
        sizeof( NetworkOrderSubnetMask ),
        OptionEnd
    );

    if (DhcpOptions->DSDomainNameRequested) {          // if our enterprise name was requested, append it
        PUCHAR  pIp = (PUCHAR)(&IpAddress);

        DhcpPrint((DEBUG_ERRORS,"%d.%d.%d.%d is trying to come up as a DHCP server\n",
            *(pIp+3),*(pIp+2),*(pIp+1),*pIp));

        Option = DhcpAppendEnterpriseName(
            Option,
            DhcpGlobalDSDomainAnsi,
            OptionEnd
        );

        // also, make the server send out a broadcast: if someone is using a bad
        // ipaddr, we should make sure we reach him

        dhcpReceiveMessage->Reserved = htons(DHCP_BROADCAST);
    }

    if ( NULL != RequestContext->Subnet && DhcpOptions->ParameterRequestList != NULL ) {
        Option = AppendClientRequestedParameters(      // finally add anything requested by the client
            IpAddress,
            RequestContext,
            DhcpOptions->ParameterRequestList,
            DhcpOptions->ParameterRequestListLength,
            Option,
            OptionEnd,
            fSwitchedSubnet,
            TRUE
        );
    }

    Option = DhcpAppendOption(
        Option,
        OPTION_END,
        NULL,
        0,
        OptionEnd
    );

    RequestContext->SendMessageSize = (DWORD)((LPBYTE)Option - (LPBYTE)dhcpSendMessage);

    DhcpPrint(( DEBUG_STOC,"DhcpInform Ack'ed, address %s.\n",
                DhcpIpAddressToDottedString(IpAddress)
    ));
    return ERROR_SUCCESS;
}


DWORD
ProcessDhcpDecline(                                    // process a decline packet from the client
    IN OUT  LPDHCP_REQUEST_CONTEXT RequestContext,     // context block for this client
    IN      LPDHCP_SERVER_OPTIONS  DhcpOptions,        // parsed options
    IN      LPPACKET               AdditionalContext   // additional context information
)
{
    DWORD                          Error;
    DWORD                          LeaseDuration;
    DWORD                          T1, T2, dwcb;
    DHCP_IP_ADDRESS                ipAddress;
    LPDHCP_MESSAGE                 dhcpReceiveMessage;
    LPDHCP_PENDING_CTXT            PendingCtxt;

    LPBYTE                         HardwareAddress = NULL;
    DWORD                          HardwareAddressLength;

    LPBYTE                         OptionHardwareAddress;
    DWORD                          OptionHardwareAddressLength;

    DHCP_IP_ADDRESS                ClientSubnetAddress = 0;
    DHCP_IP_ADDRESS                ClientSubnetMask = 0;
    BOOL                           DatabaseLocked = FALSE;

    //
    // If this client validates, then mark this address bad.
    //

    DhcpPrint(( DEBUG_STOC, "DhcpDecline arrived.\n" ));
    InterlockedIncrement(&DhcpGlobalNumDeclines);       // increment decline counter.

    dhcpReceiveMessage = (LPDHCP_MESSAGE)RequestContext->ReceiveBuffer;

    //
    // If requested options is present, use that.. else if ciaddr is present use that.
    //

    if( DhcpOptions->RequestedAddress ) {
        ipAddress = ntohl( *(DhcpOptions->RequestedAddress));
    } else {
        ipAddress = ntohl( dhcpReceiveMessage->ClientIpAddress );
    }

    if( 0 == ipAddress || ~0 == ipAddress ) {
        return ERROR_DHCP_INVALID_DHCP_CLIENT;
    }

    if( 0 == (ClientSubnetMask = DhcpGetSubnetMaskForAddress(ipAddress)) ) {
        return ERROR_DHCP_INVALID_DHCP_CLIENT;
    }

    ClientSubnetAddress = ( ipAddress & ClientSubnetMask );

    if( DhcpOptions->ClientHardwareAddress ) {
        OptionHardwareAddress = DhcpOptions->ClientHardwareAddress;
        OptionHardwareAddressLength = DhcpOptions->ClientHardwareAddressLength;
    } else {
        OptionHardwareAddress = dhcpReceiveMessage->HardwareAddress;
        OptionHardwareAddressLength = dhcpReceiveMessage->HardwareAddressLength;
    }

    HardwareAddress = NULL;
    Error = DhcpMakeClientUID(
        OptionHardwareAddress,
        OptionHardwareAddressLength,
        dhcpReceiveMessage->HardwareAddressType,
        ClientSubnetAddress,
        &HardwareAddress,
        &HardwareAddressLength
    );
    if( Error != ERROR_SUCCESS ) return Error;

    DhcpAssert( (HardwareAddress != NULL) && (HardwareAddressLength != 0) );

    PrintHWAddress( HardwareAddress, (BYTE)HardwareAddressLength );

    LOCK_DATABASE();
    DatabaseLocked = TRUE;

    if ( DhcpValidateClient(ipAddress,HardwareAddress,HardwareAddressLength ) ) {
        BYTE                       BadHWAddress[sizeof(DHCP_IP_ADDRESS) + sizeof("BAD")-1];
        DWORD                      BadHWAddressLength;
        DWORD                      BadHWAddressOffset = 0;

        //
        // Create a database entry for this bad IP address.
        // The client ID for this entry is of the following form
        // "ipaddress""BAD"
        //
        // we postfix BAD so DHCP admn can display this entry
        // separately.
        //
        // we prefix ipaddress so that if the same client declines
        // more than one address, we dont run into DuplicateKey problem
        //

        BadHWAddressLength = sizeof(DHCP_IP_ADDRESS) + sizeof("BAD") -1;
        memcpy( BadHWAddress, &ipAddress, sizeof(DHCP_IP_ADDRESS) );
        BadHWAddressOffset = sizeof(DHCP_IP_ADDRESS);
        memcpy( BadHWAddress + BadHWAddressOffset, "BAD", sizeof("BAD")-1);

        CALLOUT_DECLINED(AdditionalContext, ipAddress);
        GetLeaseInfo(
            ipAddress,
            RequestContext,
            &LeaseDuration,
            &T1,
            &T2,
            NULL
        );


        Error = DhcpCreateClientEntry(
            ipAddress,
            BadHWAddress,
            BadHWAddressLength,
            DhcpCalculateTime(LeaseDuration),          //DhcpCalculateTime(INFINIT_LEASE),
            GETSTRING( DHCP_BAD_ADDRESS_NAME ),
            GETSTRING( DHCP_BAD_ADDRESS_INFO ),
            CLIENT_TYPE_DHCP,
            ntohl(RequestContext->EndPointIpAddress),
            ADDRESS_STATE_DECLINED,
            TRUE                                       // Existing
        );

/*------------- ft 07/01
 *  out as per Thiru suggestion for bug #172529
 *  post Beta 2 might get back in with a filtering on different levels of systemLog.
 *-------------
        DhcpServerEventLogSTOC(
            EVENT_SERVER_LEASE_DECLINED,
            EVENTLOG_ERROR_TYPE,
            ipAddress,
            HardwareAddress,
            HardwareAddressLength
        );
---------------*/

        if( Error != ERROR_SUCCESS ) {
            goto Cleanup;
        }

        //
        // finally if there is any pending request with this ipaddress,
        // remove it now.
        //

        UNLOCK_DATABASE();
        DatabaseLocked = FALSE;
        LOCK_INPROGRESS_LIST();
        Error = DhcpFindPendingCtxt(
            NULL,
            0,
            ipAddress,
            &PendingCtxt
        );
        if( PendingCtxt ) {
            DhcpRemovePendingCtxt(PendingCtxt);
            DhcpFreeMemory(PendingCtxt);
        }
        UNLOCK_INPROGRESS_LIST();
    }

    DhcpPrint(( DEBUG_STOC, "DhcpDecline address %s.\n",
                    DhcpIpAddressToDottedString(ipAddress) ));

    Error = ERROR_SUCCESS;

Cleanup:

    if( DatabaseLocked ) {
        UNLOCK_DATABASE();
    }

    if( HardwareAddress != NULL ) {
        DhcpFreeMemory( HardwareAddress );
    }

    if( Error != ERROR_SUCCESS ) {
        DhcpPrint(( DEBUG_STOC, "DhcpDecline failed, %ld.\n", Error ));
    }

    return( Error );
}

DWORD
ProcessDhcpRelease(                                    // process the DHCP Release packet from a client
    IN OUT  LPDHCP_REQUEST_CONTEXT RequestContext,     // client context
    IN      LPDHCP_SERVER_OPTIONS  DhcpOptions,        // parsed options
    IN      LPPACKET               AdditionalContext   // additional ctxt info
)
{
    DWORD                          Error;
    DWORD                          Error2;
    DHCP_IP_ADDRESS                ClientIpAddress;
    DHCP_IP_ADDRESS                addressToRemove = 0;
    LPDHCP_MESSAGE                 dhcpReceiveMessage;
    LPDHCP_PENDING_CTXT            PendingCtxt;

    LPBYTE                         HardwareAddress = NULL;
    DWORD                          HardwareAddressLength;

    LPBYTE                         OptionHardwareAddress;
    DWORD                          OptionHardwareAddressLength;

    DHCP_IP_ADDRESS                ClientSubnetAddress = 0;
    DHCP_IP_ADDRESS                ClientSubnetMask = 0;
    BOOL                           DatabaseLocked = FALSE;

    WCHAR                         *pwszName;
    DWORD                          dwcb;

    DhcpPrint(( DEBUG_STOC, "DhcpRelease arrived.\n" ));
    InterlockedIncrement(&DhcpGlobalNumReleases);      // increment Release counter.

    dhcpReceiveMessage = (LPDHCP_MESSAGE)RequestContext->ReceiveBuffer;

    Error = DhcpDetermineInfoFromMessage(
        RequestContext,
        DhcpOptions,
        &OptionHardwareAddress,
        &OptionHardwareAddressLength,
        NULL
    );
    if( ERROR_SUCCESS != Error) return Error;          // invalid subnet of origin

    LOCK_INPROGRESS_LIST();
    Error2 = DhcpFindPendingCtxt(                      // remove any pending offers we have for this guy..
        OptionHardwareAddress,
        OptionHardwareAddressLength,
        0,
        &PendingCtxt
    );
    if( ERROR_SUCCESS == Error2 ) {
        // weird scenario, more likely a bug?
        Error2 = DhcpRemovePendingCtxt(
            PendingCtxt
        );
        DhcpAssert( ERROR_SUCCESS == Error2);
    } else PendingCtxt = NULL;

    if( PendingCtxt ) {                                // actually free up the address in bitmap..
        Error2 = DhcpDeletePendingCtxt(
            PendingCtxt
        );
        DhcpAssert(ERROR_SUCCESS == Error);
    }
    UNLOCK_INPROGRESS_LIST();


    //
    // to fix whistler bug 291164.
    // the ClientSubnetAddress could be something other than the relay ip
    // when the request comes from a relay ip. ( superscope case )
    // finding ClientSubnetAddress below for relay and non relay
    // based on ClientIpAddress
    //

    if( 0 != dhcpReceiveMessage->ClientIpAddress ) {
        DHCP_IP_ADDRESS            ClientIpAddress;

        ClientIpAddress = ntohl(dhcpReceiveMessage->ClientIpAddress);
        ClientSubnetMask = DhcpGetSubnetMaskForAddress( ClientIpAddress );
        if( ClientSubnetMask == 0 ) {                  // unsupported subnet
            return ERROR_DHCP_INVALID_DHCP_CLIENT;
        }
        ClientSubnetAddress = ClientSubnetMask & ClientIpAddress;
    }

    HardwareAddress = NULL;
    Error = DhcpMakeClientUID(
        OptionHardwareAddress,
        OptionHardwareAddressLength,
        dhcpReceiveMessage->HardwareAddressType,
        ClientSubnetAddress,
        &HardwareAddress,
        &HardwareAddressLength
    );

    if( Error != ERROR_SUCCESS ) return Error;

    DhcpAssert( (HardwareAddress != NULL) && (HardwareAddressLength != 0) );

    PrintHWAddress( HardwareAddress, (BYTE)HardwareAddressLength );

    LOCK_DATABASE();
    DatabaseLocked = TRUE;

    if( dhcpReceiveMessage->ClientIpAddress != 0 ) {   // client informed us of his ip address
        ClientIpAddress = ntohl( dhcpReceiveMessage->ClientIpAddress );

        if ( DhcpValidateClient(ClientIpAddress,HardwareAddress,HardwareAddressLength ) ) {
            addressToRemove = ClientIpAddress;         // ok, address matches with what we got in out db
        }
    } else {                                           // look up ip info from db, as client didnt say
        if(!DhcpGetIpAddressFromHwAddress(HardwareAddress,(BYTE)HardwareAddressLength,&addressToRemove)) {
            addressToRemove = 0;
        }
    }

    if( 0 == addressToRemove ) {                       // could not find the required address..
        Error = ERROR_FILE_NOT_FOUND;
        goto Cleanup;
    }

    // MISSING DhcpJetOpenKey(addressToRemove) --> DhcpValidateClient or DhcpGetIpAddressFromHwAddress

    dwcb = 0;
    Error = DhcpJetGetValue(                           // try to get client's name..
        DhcpGlobalClientTable[MACHINE_NAME_INDEX].ColHandle,
        &pwszName,
        &dwcb
    );
    if ( ERROR_SUCCESS != Error ) pwszName = NULL;


    DhcpPrint((DEBUG_STOC, "DhcpRelease address, %s.\n",
               DhcpIpAddressToDottedString(addressToRemove) ));

    if ( addressToRemove == 0 ) {
        Error = ERROR_SUCCESS;
    } else {
        Error = DhcpRemoveClientEntry(
            addressToRemove,
            HardwareAddress,
            HardwareAddressLength,
            TRUE,       // release address from bit map.
            FALSE       // delete non-pending record
        );

        // if this reserved client, keep his database entry, he would be using this address again.

        if( Error == ERROR_DHCP_RESERVED_CLIENT ) {
            Error = ERROR_SUCCESS;
        }

        if (Error == ERROR_SUCCESS) {

            CALLOUT_RELEASE(AdditionalContext, addressToRemove);
            //
            // log the activity   -- added by t-cheny
            //

            DhcpUpdateAuditLog(
                DHCP_IP_LOG_RELEASE,
                GETSTRING( DHCP_IP_LOG_RELEASE_NAME ),
                addressToRemove,
                OptionHardwareAddress,
                OptionHardwareAddressLength,
                pwszName
            );

            if( pwszName ) MIDL_user_free( pwszName );
        }
    }

Cleanup:

    if( DatabaseLocked ) {
        UNLOCK_DATABASE();
    }

    if( HardwareAddress != NULL ) {
        DhcpFreeMemory( HardwareAddress );
    }

    if( Error != ERROR_SUCCESS ) {
        DhcpPrint(( DEBUG_STOC, "DhcpRelease failed, %ld.\n", Error ));
    }

    //
    // Do not send a response.
    //

    return( Error );
}

VOID
SetMicrosoftVendorClassInformation(
    IN OUT LPDHCP_REQUEST_CONTEXT Ctxt,
    IN LPBYTE VendorClass,
    IN ULONG VendorClassLength
    )
/*++

Routine Description:
    This routine sets additional information on whether
    the current client is a MSFT client or not based on
    the vendor class information.

--*/
{
    BOOL fMicrosoftClient = FALSE;

    if( VendorClassLength > DHCP_MSFT_VENDOR_CLASS_PREFIX_SIZE ) {
        ULONG RetVal;

        RetVal = memcmp(
            VendorClass,
            DHCP_MSFT_VENDOR_CLASS_PREFIX,
            DHCP_MSFT_VENDOR_CLASS_PREFIX_SIZE
            );
        if( 0 == RetVal ) fMicrosoftClient = TRUE;
    }

    if( fMicrosoftClient ) {
        DhcpPrint((DEBUG_STOC, "Processing MSFT client\n"));
    } else {
        DhcpPrint((DEBUG_STOC, "Processing non MSFT client\n"));
    }

    Ctxt->fMSFTClient = fMicrosoftClient;
}


//================================================================================
// Must be called with READ_LOCK taken on memory, and ServerObject filled in RequestContext
//================================================================================
DWORD
ProcessMessage(                                        // Dispatch call to correct handler based on message type
    IN OUT  LPDHCP_REQUEST_CONTEXT RequestContext,
    IN OUT  LPPACKET               AdditionalContext,
    IN OUT  LPDWORD                AdditionalStatus
)
{
    DWORD                          Error;
    BOOL                           fSendResponse;
    DHCP_SERVER_OPTIONS            dhcpOptions;
    LPDHCP_MESSAGE                 dhcpReceiveMessage;
    BOOLEAN                        fInOurEnterprise=TRUE;

    DhcpPrint(( DEBUG_STOC, "ProcessMessage entered\n" ));

    if( SERVICE_PAUSED == DhcpGlobalServiceStatus.dwCurrentState ) {
        CALLOUT_DROPPED(AdditionalContext, DHCP_DROP_PAUSED);
        return ERROR_DHCP_SERVICE_PAUSED;
    }
    dhcpReceiveMessage = (LPDHCP_MESSAGE)RequestContext->ReceiveBuffer;
    if( 0 == DhcpServerGetSubnetCount(RequestContext->Server)) {
        CALLOUT_DROPPED(AdditionalContext, DHCP_DROP_NO_SUBNETS);
        return ERROR_DHCP_SUBNET_NOT_PRESENT;          // discard as no subnets configured
    }

    RtlZeroMemory( &dhcpOptions, sizeof( dhcpOptions ) );

    if( BOOT_REQUEST != dhcpReceiveMessage->Operation ) {
        CALLOUT_DROPPED(AdditionalContext, DHCP_DROP_INVALID);
        return ERROR_DHCP_INVALID_DHCP_MESSAGE;        // discard non-bootp packets
    }

    Error = ExtractOptions(
        dhcpReceiveMessage,
        &dhcpOptions,
        RequestContext->ReceiveMessageSize
    );
    if( Error != ERROR_SUCCESS ) {                     // discard malformed packets
        CALLOUT_DROPPED(AdditionalContext, DHCP_DROP_INVALID);
        return Error;
    }
    CALLOUT_MARK_OPTIONS(AdditionalContext, &dhcpOptions);

    RequestContext->ClassId = DhcpServerGetClassId(
        RequestContext->Server,
        dhcpOptions.ClassIdentifier,
        dhcpOptions.ClassIdentifierLength
    );

    RequestContext->VendorId = DhcpServerGetVendorId(
        RequestContext->Server,
        dhcpOptions.VendorClass,
        dhcpOptions.VendorClassLength
    );

    SetMicrosoftVendorClassInformation(
        RequestContext,
        dhcpOptions.VendorClass,
        dhcpOptions.VendorClassLength
        );

    RequestContext->BinlClassIdentifier = dhcpOptions.VendorClass;
    RequestContext->BinlClassIdentifierLength = dhcpOptions.VendorClassLength;

    fSendResponse = TRUE;
    if ( dhcpOptions.MessageType == NULL ) {           // no msg type ==> BOOTP message
        RequestContext->MessageType = 0;               // no msg type ==> mark it as some invalid type..

        if( FALSE == DhcpGlobalDynamicBOOTPEnabled ) {
            Error = ProcessBootpRequest(
                RequestContext,
                &dhcpOptions,
                AdditionalContext,
                AdditionalStatus
                );
        } else {
            if( RequestContext->ClassId == 0 ) {
                //
                // No class-Id specified for BOOTP clients?
                // Then lets give one to it!
                //
                RequestContext->ClassId = DhcpServerGetClassId(
                    RequestContext->Server,
                    DEFAULT_BOOTP_CLASSID,
                    DEFAULT_BOOTP_CLASSID_LENGTH
                    );
            }

            Error = ProcessDhcpDiscover(
                RequestContext,
                &dhcpOptions,
                AdditionalContext,
                AdditionalStatus
                );
        }

        if( ERROR_SUCCESS == Error && ERROR_SUCCESS != *AdditionalStatus )
            fSendResponse = FALSE;                     //  We have scheduled a ping, Send response later
    } else {
        if (dhcpOptions.DSDomainName && dhcpOptions.DSDomainName[0] != '\0')  {
            fInOurEnterprise = DhcpRogueAcceptEnterprise(
                dhcpOptions.DSDomainName,              // if client specified enterprise, make sure we respond
                dhcpOptions.DSDomainNameLen            // only if the enterprise is same as our own
            );

            if (!fInOurEnterprise) {                   // discard if client is not in our enterprise
                CALLOUT_DROPPED(AdditionalContext, DHCP_DROP_WRONG_SERVER);
                return ERROR_DHCP_ROGUE_NOT_OUR_ENTERPRISE;
            }
        }

        RequestContext->MessageType = *dhcpOptions.MessageType ;

#if DBG
        if( TRUE == fDhcpGlobalProcessInformsOnlyFlag ) {
            if( DHCP_INFORM_MESSAGE != *dhcpOptions.MessageType ) {
                *dhcpOptions.MessageType = 0;          // some invalid type, will get dropped
            }
        }
#endif

        switch( *dhcpOptions.MessageType ) {           // dispatch based on message type
        case DHCP_DISCOVER_MESSAGE:
            Error = ProcessDhcpDiscover(               // may need to schedule a ping (check AdditionalStatus)
                RequestContext,                        // if so, schedule it, and dont send response now
                &dhcpOptions,                          // note that in all other cases, we still send response,
                AdditionalContext,                     // in particular, even if Error is not ERROR_SUCESS
                AdditionalStatus
            );
            fSendResponse = (ERROR_SUCCESS == *AdditionalStatus);
            break;
        case DHCP_REQUEST_MESSAGE:
            Error = ProcessDhcpRequest(                 // see comments for ProcessDhcpDiscover case above -- same.
                RequestContext,
                &dhcpOptions,
                AdditionalContext,
                AdditionalStatus
            );
            fSendResponse = (ERROR_SUCCESS == *AdditionalStatus);
            break;
        case DHCP_DECLINE_MESSAGE:
            Error = ProcessDhcpDecline(
                RequestContext,
                &dhcpOptions,
                AdditionalContext
            );
            fSendResponse = FALSE;
            break;
        case DHCP_RELEASE_MESSAGE:
            Error = ProcessDhcpRelease(
                RequestContext,
                &dhcpOptions,
                AdditionalContext
            );
            fSendResponse = FALSE;
            break;
        case DHCP_INFORM_MESSAGE:
            Error = ProcessDhcpInform(
                RequestContext,
                &dhcpOptions,
                AdditionalContext
            );
            fSendResponse = TRUE;
            break;
        default:
            DhcpPrint((DEBUG_STOC,"Received a invalid message type, %ld.\n",*dhcpOptions.MessageType ));
            Error = ERROR_DHCP_INVALID_DHCP_MESSAGE;
            break;
        }
    }

    if ( ERROR_SUCCESS == Error && fSendResponse ) {
        DhcpDumpMessage(
            DEBUG_MESSAGE,
            (LPDHCP_MESSAGE)RequestContext->SendBuffer,
            DHCP_MESSAGE_SIZE
            );
        CALLOUT_SENDPKT( AdditionalContext );
        DhcpSendMessage( RequestContext );
    }

    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_STOC, "ProcessMessage: returning 0x%lx, [decimal %ld]\n", Error, Error));
    }

    if( ERROR_DHCP_INVALID_DHCP_MESSAGE == Error ||
        ERROR_DHCP_INVALID_DHCP_CLIENT == Error ) {
        CALLOUT_DROPPED(AdditionalContext, DHCP_DROP_INVALID);
    } else if( ERROR_SUCCESS == Error && ERROR_IO_PENDING == *AdditionalStatus ) {
        CALLOUT_PINGING(AdditionalContext);
    } else if( ERROR_SUCCESS != Error ) {
        CALLOUT_DROPPED(AdditionalContext, DHCP_DROP_GEN_FAILURE);
    }

    return Error;
}

//================================================================================
// Must be called with READ_LOCK taken on memory, and ServerObject filled in RequestContext
//================================================================================
DWORD
ProcessMadcapMessage(                                        // Dispatch call to correct handler based on message type
    IN OUT  LPDHCP_REQUEST_CONTEXT RequestContext,
    IN OUT  LPPACKET               AdditionalContext,
    IN OUT  LPDWORD                AdditionalStatus
) {
    DWORD                          Error;
    BOOL                           fSendResponse;
    MADCAP_SERVER_OPTIONS            MadcapOptions;
    LPMADCAP_MESSAGE                 dhcpReceiveMessage;
    BOOLEAN                        fInOurEnterprise=TRUE;

    DhcpPrint(( DEBUG_STOC, "ProcessMadcapMessage entered\n" ));

    if( SERVICE_PAUSED == DhcpGlobalServiceStatus.dwCurrentState ) {
        CALLOUT_DROPPED(AdditionalContext, DHCP_DROP_PAUSED);
        return ERROR_DHCP_SERVICE_PAUSED;
    }
    dhcpReceiveMessage = (PMADCAP_MESSAGE)RequestContext->ReceiveBuffer;
    if( 0 == DhcpServerGetMScopeCount(RequestContext->Server)) {
        CALLOUT_DROPPED(AdditionalContext, DHCP_DROP_NO_SUBNETS);
        return ERROR_DHCP_SUBNET_NOT_PRESENT;          // discard as no subnets configured
    }

    RtlZeroMemory( &MadcapOptions, sizeof( MadcapOptions ) );

    if( MADCAP_VERSION < dhcpReceiveMessage->Version ||
        MADCAP_ADDR_FAMILY_V4 != ntohs(dhcpReceiveMessage->AddressFamily)) {
        CALLOUT_DROPPED(AdditionalContext, DHCP_DROP_INVALID);
        return ERROR_DHCP_INVALID_DHCP_MESSAGE;
    }

    Error = ExtractMadcapOptions(
        dhcpReceiveMessage,
        &MadcapOptions,
        RequestContext->ReceiveMessageSize
    );
    if( Error != ERROR_SUCCESS ) {                     // discard malformed packets
        CALLOUT_DROPPED(AdditionalContext, DHCP_DROP_INVALID);
        return Error;
    }

    fSendResponse = FALSE;


    switch( dhcpReceiveMessage->MessageType ) {           // dispatch based on message type
    case MADCAP_DISCOVER_MESSAGE:
    case MADCAP_REQUEST_MESSAGE:
        Error = ProcessMadcapDiscoverAndRequest(
            RequestContext,
            &MadcapOptions,
            dhcpReceiveMessage->MessageType,
            &fSendResponse
        );
        break;
    case MADCAP_RENEW_MESSAGE:
        Error = ProcessMadcapRenew(
            RequestContext,
            &MadcapOptions,
            &fSendResponse
        );
        break;

    case MADCAP_RELEASE_MESSAGE:
        Error = ProcessMadcapRelease(
            RequestContext,
            &MadcapOptions,
            &fSendResponse
        );
        break;
    case MADCAP_INFORM_MESSAGE:
        Error = ProcessMadcapInform(
            RequestContext,
            &MadcapOptions,
            &fSendResponse
        );
        break;
    default:
        DhcpPrint((DEBUG_STOC,"Received a invalid message type, %ld.\n",dhcpReceiveMessage->MessageType ));
        Error = ERROR_DHCP_INVALID_DHCP_MESSAGE;
        break;
    }

    if ( fSendResponse ) {
        MadcapDumpMessage(
            DEBUG_MESSAGE,
            (PMADCAP_MESSAGE)RequestContext->SendBuffer,
            DHCP_MESSAGE_SIZE
            );
        CALLOUT_SENDPKT( AdditionalContext );
        MadcapSendMessage( RequestContext );
    }

    if( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_STOC, "ProcessMadcapMessage: returning 0x%lx, [decimal %ld]\n", Error, Error));
    }

    if( ERROR_DHCP_INVALID_DHCP_MESSAGE == Error ||
        ERROR_DHCP_INVALID_DHCP_CLIENT == Error ) {
        CALLOUT_DROPPED(AdditionalContext, DHCP_DROP_INVALID);
    } else if( ERROR_SUCCESS != Error ) {
        CALLOUT_DROPPED(AdditionalContext, DHCP_DROP_GEN_FAILURE);
    }

    return Error;
}

DWORD
DhcpInitializeClientToServer(
    VOID
    )
/*++

Routine Description:

    This function initializes client to server communications.  It
    initializes the DhcpRequestContext block, and then creates and initializes
    a socket for each address the server uses.

    It also initializes the receive buffers and receive buffer queue.

Arguments:

    DhcpRequest - Pointer to a location where the request context pointer
        is returned.

Return Value:

    Error Code.

--*/
{
    DWORD                 Error,
                          LastError,
                          i,
                          cInitializedEndpoints;


    DHCP_REQUEST_CONTEXT    *pRequestContext;

    LPSOCKET_ADDRESS_LIST  interfaceList;


    // initialize locks that the threads take on processing packets
    Error = DhcpReadWriteInit();
    if( ERROR_SUCCESS != Error ) return Error;

    // create an event to indicate endpoint status.
    DhcpGlobalEndpointReadyEvent =
        CreateEvent( NULL, TRUE, FALSE, NULL );

    if( NULL == DhcpGlobalEndpointReadyEvent ) {
        return GetLastError();
    }

    Error = InitializeEndPoints();
    if ( ERROR_SUCCESS != Error ) {
        DhcpPrint((DEBUG_ERRORS, "InitailizeEndPoints: 0x%lx\n", Error));
    }

    //
    //  Initialize vars in thread.c, start the ping thread, start
    //  message and processing threads in thread.c
    //

    Error = ThreadsDataInit(
        g_cMaxProcessingThreads,
        g_cMaxActiveThreads
    );

    if( ERROR_SUCCESS != Error )
        return Error;

    Error = PingInit();

    if( ERROR_SUCCESS != Error )
        return Error;

    Error = ThreadsStartup();

    if( ERROR_SUCCESS != Error )
        return Error;

    return ERROR_SUCCESS;
}

VOID
DhcpCleanupClientToServer(
    VOID
    )
/*++

Routine Description:

    This function frees up all resources that are allocated for the client
    to server protocol.

Arguments:

    DhcpRequest - Pointer to request context.

Return Value:

    None.

--*/
{

    CleanupEndPoints();

    ThreadsStop();
    PingCleanup();
    ThreadsDataCleanup();
    DhcpReadWriteCleanup();
}

//================================================================================
// end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\auditlog\log.c ===
//================================================================================
//  Copyright (C) 1998 Microsoft Corporation
//  Author: RameshV
//  Description:
//    This file implements the actually logging that takes place... there is
//    only one function used in reality...
//================================================================================


//================================================================================
//  required headers
//================================================================================

#include <windows.h>
#define  LPDHCP_SERVER_OPTIONS     LPVOID         // we dont use this field actually..
#include <dhcpssdk.h>                             // include this for all required prototypes

//================================================================================
//  the three functions defined in this module
//================================================================================
static      BOOL                   Initialized = FALSE;

VOID
DhcpLogInit(
    VOID
)
{
}

VOID
DhcpLogCleanup(
    VOID
)
{
}

VOID
DhcpLogEvent(                                     // log the event ...
    IN      DWORD                  ControlCode,   // foll args depend on control code
    ...
)
{
    if( FALSE == Initialized ) return;            // ugh? something went wrong!

    // DHCP_CONTROL_ START,STOP,PAUSE,CONTINUE dont have any other params
    // DHCP_DROP_NOADDRESS [IpAddress] where we recd this packet from
    // DHCP_PROB_ CONFLIC, DECLINE, RELEASE, NACKED [IpAddress, AddrInQuestion]
    // DHCP_GIVE_ADDRESS_ NEW/OLD, [IpAddress] [AddressBeingGiven] DHCP_CLIENT_ BOOTP/DHCP LeaseTime
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\thread.h ===
//================================================================================
//  Copyright (C) Microsoft Corporation 1997
//  Author: RameshV
//  Title: Threading Model
//  Description: the new, neat threading model
//  Date: 24-Jul-97 09:22
//--------------------------------------------------------------------------------

#ifndef THREAD_H_INCLUDED
#define THREAD_H_INCLUDED
//================================================================================
//  EXPOSED strucures and types
//================================================================================

typedef struct st_PACKET {              //  Packet information for quick lookups
    LIST_ENTRY           List;          //  This is one of Active/PingRetry/PingRetried
    LIST_ENTRY           HashList;      //  This is the list for each bucket in the hash
    DWORD                HashValue;     //  The hash value for this packet
    // Do not separate the following three fields: Check HashPacket for reason.
    DWORD                Xid;           //  The transaction id of the process
    BYTE                 HWAddrType;    //  The hardware address type
    BYTE                 Chaddr[16];    //  Client hw address
    LPBYTE               ClientId;      //  Client Identifier
    BYTE                 ClientIdSize;  //  The length of above ptr
    BYTE                 PacketType;    //  What is the type of the packet?
    DHCP_IP_ADDRESS      PingAddress;   //  Address attempted ping for
    BOOL                 DestReachable; //  Is the destination reachable?
    DHCP_REQUEST_CONTEXT ReqContext;    //  The actual request context
    union {
        LPVOID           CalloutContext;//  used to pass context to dhcp server callouts
        VOID             (*Callback)(ULONG IpAddress, LPBYTE HwAddr, ULONG HwLen, BOOL Reachable);
    };
} PACKET, *LPPACKET, *PPACKET;


#define PACKET_ACTIVE    0x01           //  A new packet just came in
#define PACKET_PING      0x02           //  This packet is waiting for trying out ping
#define PACKET_PINGED    0x03           //  A ping has happened
#define PACKET_DYNBOOT   0x04           //  Packet for dynamic bootp

#define PACKET_OFFSET(X) ((DWORD)(ULONG_PTR)&(((LPPACKET)0)->X))
#define HASH_PREFIX      (PACKET_OFFSET(ClientId) - PACKET_OFFSET(Xid))

//================================================================================
//  EXPOSED functions
//================================================================================
DWORD                                   //  Win32 errors
ThreadsDataInit(                        //  Initialize everything in this file
    IN      DWORD        nMaxThreads,   //  Max # of processing threads to start
    IN      DWORD        nActiveThreads //  Of this how many can run at a time
);

VOID
ThreadsDataCleanup(                     //  Cleanup everything done in this file
    VOID
);

DWORD                                   //  Win32 errors
ThreadsStartup(                         //  Start the requisite # of threads
    VOID
);

VOID
ThreadsStop(                            //  Stop all the threads
    VOID
);

VOID                                    //  No return values
HandleIcmpResult(                       //  After a ping is finished, it comes here
    IN      DWORD        PingAddressIn, //  The Address that was pinged
    IN      BOOL         DestReachable, //  Was the Destination reachable?
    IN      LPPACKET     P              //  This is the packet that we were dealing with
);

DWORD                                   //  Win32 errors
DhcpNotifyWorkerThreadsQuit(            //  Post io comp request asking threads to quit
    VOID
);

//================================================================================
//  End of file
//================================================================================
#endif THREAD_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\auditlog\log.h ===
//================================================================================
//  Copyright (C) 1998 Microsoft Corporation
//  Author: RameshV
//  Description:
//    The actual logging facility is implemented as part of this module.
//    This header file gives required functions.. see C file for documentation.
//================================================================================

VOID
DhcpLogInit(
    VOID
);

VOID
DhcpLogCleanup(
    VOID
);

VOID
DhcpLogEvent(                                     // log the event ...
    IN      DWORD                  ControlCode,   // foll args depend on control code
    ...
);

//================================================================================
//  end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\util.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    util.c

Abstract:

    This module contains miscellaneous utility routines used by the
    DHCP server service.

Author:

    Madan Appiah (madana) 10-Sep-1993
    Manny Weiser (mannyw) 12-Aug-1992

Revision History:

--*/
#include <dhcppch.h>
#include "dhcp_srv.h"

#define  MESSAGE_BOX_WIDTH_IN_CHARS  65

LPSTR
ConvertDhcpSpeficErrors(
    IN ULONG ErrorCode
    )
{
    HMODULE hDhcpModule;
    LPSTR pMsg;
    ULONG nBytes;
                    
    if( ErrorCode < ERROR_FIRST_DHCP_SERVER_ERROR ||
        ErrorCode > ERROR_LAST_DHCP_SERVER_ERROR
        ) {
        return NULL;
    }

    //
    // Attempt to format the error correctly.
    //
    hDhcpModule = LoadLibrary(DHCP_SERVER_MODULE_NAME);
    
    nBytes = FormatMessageA(
        FORMAT_MESSAGE_ALLOCATE_BUFFER |
        FORMAT_MESSAGE_FROM_HMODULE |
        FORMAT_MESSAGE_IGNORE_INSERTS ,
        (LPVOID)hDhcpModule,
        ErrorCode,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // default country id
        (LPSTR)&pMsg,
        0,
        NULL
        );

    FreeLibrary(hDhcpModule);
    
    if( 0 == nBytes ) return NULL;

    DhcpAssert(NULL != pMsg);
    return pMsg;
}

VOID
DhcpServerEventLog(
    DWORD EventID,
    DWORD EventType,
    DWORD ErrorCode
    )
/*++

Routine Description:

    Logs an event in EventLog.

Arguments:

    EventID - The specific event identifier. This identifies the
                message that goes with this event.

    EventType - Specifies the type of event being logged. This
                parameter can have one of the following

                values:

                    Value                       Meaning

                    EVENTLOG_ERROR_TYPE         Error event
                    EVENTLOG_WARNING_TYPE       Warning event
                    EVENTLOG_INFORMATION_TYPE   Information event


    ErrorCode - Error Code to be Logged.

Return Value:

    None.

--*/

{
    DWORD Error;
    LPSTR Strings[1];
    CHAR ErrorCodeOemString[32 + 1];

    strcpy( ErrorCodeOemString, "%%" );
    _ultoa( ErrorCode, ErrorCodeOemString + 2, 10 );

    Strings[0] = ConvertDhcpSpeficErrors(ErrorCode);
    if( NULL == Strings[0] ) {
        Strings[0] = ErrorCodeOemString;
    }
    
    Error = DhcpReportEventA(
                DHCP_EVENT_SERVER,
                EventID,
                EventType,
                1,
                sizeof(ErrorCode),
                Strings,
                &ErrorCode );

    if( Error != ERROR_SUCCESS ) {
        DhcpPrint(( DEBUG_ERRORS,
            "DhcpReportEventW failed, %ld.\n", Error ));
    }

    if( Strings[0] != ErrorCodeOemString ) {
        LocalFree(Strings[0]);
    }
    
    return;
}

VOID
DhcpServerJetEventLog(
    DWORD EventID,
    DWORD EventType,
    DWORD ErrorCode,
    LPSTR CallerInfo OPTIONAL
    )
/*++

Routine Description:

    Logs an event in EventLog.

Arguments:

    EventID - The specific event identifier. This identifies the
                message that goes with this event.

    EventType - Specifies the type of event being logged. This
                parameter can have one of the following

                values:

                    Value                       Meaning

                    EVENTLOG_ERROR_TYPE         Error event
                    EVENTLOG_WARNING_TYPE       Warning event
                    EVENTLOG_INFORMATION_TYPE   Information event


    ErrorCode - JET error code to be Logged.

    CallerInfo - info to locate where the call failed.

Return Value:

    None.

--*/

{
    DWORD Error;
    LPSTR Strings[2];
    CHAR ErrorCodeOemString[32 + 1];

    _ltoa( ErrorCode, ErrorCodeOemString, 10 );
    Strings[0] = ErrorCodeOemString;
    Strings[1] = CallerInfo? CallerInfo : "";

    Error = DhcpReportEventA(
                DHCP_EVENT_SERVER,
                EventID,
                EventType,
                2,
                sizeof(ErrorCode),
                Strings,
                &ErrorCode );

    if( Error != ERROR_SUCCESS ) {
        DhcpPrint(( DEBUG_ERRORS,
            "DhcpReportEventW failed, %ld.\n", Error ));
    }

    return;
}

VOID
DhcpServerEventLogSTOC(
    DWORD EventID,
    DWORD EventType,
    DHCP_IP_ADDRESS IPAddress,
    LPBYTE HardwareAddress,
    DWORD HardwareAddressLength
    )

/*++

Routine Description:

    Logs an event in EventLog.

Arguments:

    EventID - The specific event identifier. This identifies the
                message that goes with this event.

    EventType - Specifies the type of event being logged. This
                parameter can have one of the following

                values:

                    Value                       Meaning

                    EVENTLOG_ERROR_TYPE         Error event
                    EVENTLOG_WARNING_TYPE       Warning event
                    EVENTLOG_INFORMATION_TYPE   Information event


    IPAddress - IP address to LOG.

    HardwareAddress - Hardware Address to log.

    HardwareAddressLength - Length of Hardware Address.

Return Value:

    None.

--*/
{
    DWORD Error;
    LPWSTR Strings[2];
    WCHAR IpAddressString[DOT_IP_ADDR_SIZE];
    LPWSTR HWAddressString = NULL;

    Strings[0] = DhcpOemToUnicode(
                    DhcpIpAddressToDottedString(IPAddress),
                    IpAddressString );

    //
    // allocate memory for the hardware address hex string.
    // Each byte in HW address is converted into two characters
    // in hex buffer. 255 -> "FF"
    //

    HWAddressString = DhcpAllocateMemory(
                        (2 * HardwareAddressLength + 1) *
                        sizeof(WCHAR) );

    if( HWAddressString == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    DhcpHexToString( HWAddressString, HardwareAddress, HardwareAddressLength );

    //
    // terminate Hex address string buffer.
    //

    HWAddressString[ 2 * HardwareAddressLength ] = L'\0';

    Strings[1] = HWAddressString;

    Error = DhcpReportEventW(
                DHCP_EVENT_SERVER,
                EventID,
                EventType,
                2,
                HardwareAddressLength,
                Strings,
                HardwareAddress );

Cleanup:

    if( HWAddressString != NULL ) {
        DhcpFreeMemory( HWAddressString );
    }

    if( Error != ERROR_SUCCESS ) {
        DhcpPrint(( DEBUG_ERRORS,
            "DhcpReportEventW failed, %ld.\n", Error ));
    }

    return;
}




DWORD
DisplayUserMessage(
    DWORD MessageId,
    ...
    )
/*++

Routine Description:

    This function starts a new thread to display a message box.

Arguments:

    MessageId - The ID of the message to display.
        On NT, messages are attached to the TCPIP service DLL.

Return Value:

    None.

--*/
{
    unsigned msglen;
    va_list arglist;
    LPVOID  pMsg;
    HINSTANCE hModule;
    DWORD   Error;


    hModule = LoadLibrary(DHCP_SERVER_MODULE_NAME);
    if ( hModule == NULL ) {
        Error = GetLastError();

        DhcpPrint((
            DEBUG_ERRORS,"DisplayUserMessage: FormatMessage failed with error = (%d)\n",
            Error ));
        return Error;

    }
    va_start(arglist, MessageId);
    if (!(msglen = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
          FORMAT_MESSAGE_FROM_HMODULE | MESSAGE_BOX_WIDTH_IN_CHARS ,
          hModule,
          MessageId,
          0L,       // Default country ID.
          (LPTSTR)&pMsg,
          0,
          &arglist)))
    {
        Error = GetLastError();

        DhcpPrint((
            DEBUG_ERRORS,"DisplayUserMessage: FormatMessage failed with error = (%d)\n",
            Error ));
    }
    else
    {

      if(MessageBoxEx(
            NULL, pMsg, DHCP_SERVER_FULL_NAME, 
            MB_SYSTEMMODAL | MB_OK | MB_SETFOREGROUND | MB_SERVICE_NOTIFICATION | MB_ICONSTOP, 
            MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL)) == 0)
      {
          Error = GetLastError();
          DhcpPrint((
              DEBUG_ERRORS,"DisplayUserMessage: MessageBoxEx failed with error = (%d)\n",
              Error ));


      }
      LocalFree(pMsg);

      Error = ERROR_SUCCESS;
    }

    FreeLibrary(hModule);

    return Error;
}


BOOL
CreateDirectoryPathW(
    IN LPWSTR StringPath,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    )
/*++

Routine Description:
    This routine creates the database path specified.
    (If a path a\b..x\y\z is specified, all the directories
    a,b,c.. etc are created if they do not exist.

Arguments:
    StringPath -- UNICIDE string for path to create
    pSecurityDescriptor -- security descriptor to use

Return Values:
    TRUE -- succeeded.
    FALSE -- failed, use GetLastError for error.
    
--*/
{
    BOOL fRetVal;
    ULONG Error;
    LPWSTR Next;
    SECURITY_ATTRIBUTES Attr = {
        sizeof(SECURITY_ATTRIBUTES), pSecurityDescriptor, FALSE
    };
    
    if( StringPath == NULL || L'\0' == *StringPath ) {
        SetLastError(ERROR_BAD_PATHNAME);
        return FALSE;
    }
    
    //
    // First simply try to create the directory specified.
    // If not possible we go about and do the long solution.
    // 
    // If the directory already exists, then we mask that
    // error and return success.
    //

    DhcpPrint(( DEBUG_MISC, "CreateDirectoryPathW() : Creating %ws\n",
		StringPath ));
//      fRetVal = CreateDirectory( StringPath, &Attr );
    fRetVal = CreateDirectory( StringPath, NULL );

    DhcpPrint(( DEBUG_MISC, "CreateDirectory : Error = %ld, %ld\n",
		fRetVal, GetLastError() ));
    if( FALSE != fRetVal ) return fRetVal;

    Error = GetLastError();
    if( ERROR_ALREADY_EXISTS == Error ) {
	return TRUE;
    }

    //
    // Aargh.  Nope, directory doesn't exist?
    //
    DhcpPrint((DEBUG_ERRORS, "CreateDirectory(%ws): 0x%lx\n",
               StringPath,Error));

    //
    // While trying to create directory, if the error is something
    // other than that the path doesn't exist, we don't bother creatin
    // parent directories..
    //
    
    if( ERROR_PATH_NOT_FOUND != Error ) return FALSE;

    //
    // Now loop until the required directory could be created.
    //

    Next = wcsrchr(StringPath, L'\\');
    if( NULL == Next ) {
        SetLastError(ERROR_BAD_PATHNAME);
        return FALSE;
    }

    (*Next) = L'\0';

    fRetVal = CreateDirectoryPathW(
        StringPath, pSecurityDescriptor
        );

    (*Next) = L'\\';

    //
    // If we couldn't create the parent directory, return error..
    //
    if( FALSE == fRetVal ) return fRetVal;

    //
    // Now attempt to create the child direcotry..
    //
//      fRetVal = CreateDirectory( StringPath, &Attr );
    fRetVal = CreateDirectory( StringPath, NULL );

    if( FALSE != fRetVal ) return fRetVal;

    DhcpPrint((DEBUG_ERRORS, "CreateDirectory(%ws): 0xlx\n",
               StringPath, GetLastError()));

    return fRetVal;
}

BOOL
CreateDirectoryPathOem(
    IN LPCSTR OemStringPath,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
    )
/*++

Routine Description:
    This routine creates the database path specified.
    (If a path a\b..x\y\z is specified, all the directories
    a,b,c.. etc are created if they do not exist.

Arguments:
    OemStringPath -- OEM string for path to create
    pSecurityDescriptor -- security descriptor to use

Return Values:
    TRUE -- succeeded.
    FALSE -- failed, use GetLastError for error.
    
--*/
{
    LPWSTR UnicodeString;
    BOOL fRetVal;
    ULONG Error = 0;

    UnicodeString = DhcpOemToUnicode(
        (LPSTR)OemStringPath, NULL
        );
    if( NULL == UnicodeString ) {
        SetLastError(ERROR_CAN_NOT_COMPLETE);
        return FALSE;
    }

    fRetVal = CreateDirectoryPathW(
        UnicodeString, pSecurityDescriptor
        );

    if( FALSE == fRetVal ) {
        Error = GetLastError();
    }

    DhcpFreeMemory(UnicodeString);

    if( FALSE == fRetVal ) {
        SetLastError(Error);
    }

    return fRetVal;
}

ULONG
GetUserAndDomainNames(
    IN OUT WCHAR *UnameBuf,
    IN OUT PULONG UnameBufLen,
    IN OUT WCHAR *DomainBuf,
    IN OUT PULONG DomainBufLen
    )
/*++

Routine Description:
    This routine finds the user and domain
    name for the caller.  If the caller is
    impersonated, the user and domain name
    are the impersonated callers user and domain names.

Arguments:
    UnameBuf - buffer to hold user name.
    UnameBufLen - length of above buffer in wchars
    DomainBuf -- buffer to hold domain name.
    DomainBufLen -- length of above buffer in whcars

Return Values:
    Win32 errors.

    N.B The user name domain name buffers are passed to
    LookupAccountSid which can fail with ERROR_MORE_DATA or
    other errors if the buffers are of insufficient size.
    LookupAccountSid won't fail for lack of space if 
    both buffers are atleast 256 WCHARs long.

--*/
{
    HANDLE Token;
    TOKEN_USER *pTokenUser;
    ULONG Error, Len;
    PSID pSid;
    SID_NAME_USE eUse;
    BOOL fImpersonated = FALSE;

    if( RPC_S_OK == RpcImpersonateClient(NULL)) {
        fImpersonated = TRUE;
    }
    
    //
    // Get process token.
    //

    Error = NO_ERROR;
    if(!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, FALSE, &Token)) {
        Error = GetLastError();
    }

    if( ERROR_ACCESS_DENIED == Error ) {
        Error = NO_ERROR;
        if(!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &Token)) {
            Error = GetLastError();
        }
    }

    if( NO_ERROR != Error ) {
        if( fImpersonated ) 
        {
            Error = RpcRevertToSelf();
        }
        return Error;
    }

    //
    // Query for user info.
    //

    do {
        Len = 0;
        GetTokenInformation(Token, TokenUser, NULL, 0, &Len);
        if( 0 == Len ) {
            Error = GetLastError();
            break;
        }
        
        pTokenUser = LocalAlloc(LPTR, Len);
        if( NULL == pTokenUser ) {
            Error = GetLastError();
            break;
        }

        if(!GetTokenInformation(
            Token, TokenUser, pTokenUser, Len, &Len
            )){
            Error = GetLastError();
            break;
        }

        pSid = pTokenUser->User.Sid;
        
        Error = NO_ERROR;
        if(!LookupAccountSid(
            NULL, pSid, UnameBuf, UnameBufLen, DomainBuf, DomainBufLen, &eUse
            )) {
            Error = GetLastError();
        }
        
        LocalFree(pTokenUser);
    } while ( 0 );

    CloseHandle(Token);

    if( fImpersonated )
    {
        Error = RpcRevertToSelf();
    }

    return Error;
}

ULONG
GetUserAndDomainName(
    IN WCHAR Buf[]
    )
/*++

Routine Description:
    This routine finds the caller's user and domain, and if
    the caller is impersonated a client, this gives the
    client's user and domain name.

    If the domain exists, the format is domain\username
    Otherwise it is just "username".

Return Values:
    Win32 errors..

--*/
{
    WCHAR UName[UNLEN+1];
    WCHAR DName[DNLEN+1];
    ULONG USize = UNLEN+1, DSize = DNLEN+1;
    ULONG Error;

    Buf[0] = L'\0';
    Error = GetUserAndDomainNames(UName, &USize, DName, &DSize);
    if( ERROR_SUCCESS != Error ) return Error;

    wcscpy(Buf, DName);
    if( DSize ) Buf[DSize++] = L'\\';
    wcscpy(&Buf[DSize], UName);
    return NO_ERROR;
}

//
// abstract: Initialize dynamic dns. Impersonate secret user to do so. 
// If secret user is not configured default attempt initializing dnsapi
// when not running on a DC.
// input : None
// output: ERROR_SUCCESS always.
// side-effect: DhcpGlobalUseNoDns is set not to do DNS updates when
// not appropriate.
//

DWORD
DynamicDnsInit(
    VOID 
)
{

    DWORD Error  = ERROR_SUCCESS;
    DWORD Error1 = ERROR_SUCCESS;
    DWORD RunningOnDc = 0;
    WCHAR Uname[256], Domain[256], Passwd[256];
    DNS_CREDENTIALS   DnsDhcpCreds;

    Uname[ 0 ]  = L'\0';
    Domain[ 0 ] = L'\0';
    Passwd[ 0 ] = L'\0';


    //
    // figure out if running on DC.
    //

    RunningOnDc = IsRunningOnDc( );


    Error = DhcpQuerySecretUname(
        (LPWSTR)Uname, sizeof(Uname), (LPWSTR)Domain,
        sizeof(Domain), (LPWSTR)Passwd, sizeof(Passwd) );

    //
    // Now try to call DNS API for impersonation of a valid user
    //

    
    if ( ( Error == NO_ERROR ) && ( Uname[ 0 ] != L'\0' ) )
    {
        DnsDhcpCreds.pUserName = &Uname[ 0 ];
        DnsDhcpCreds.pDomain   = &Domain[ 0 ];
        DnsDhcpCreds.pPassword = &Passwd[ 0 ];

        Error1 = DnsDhcpSrvRegisterInitialize( &DnsDhcpCreds );

        if ( Error1 != ERROR_SUCCESS )
        {
            if ( ( Error1 == ERROR_CANNOT_IMPERSONATE ) )
            {


                if ( RunningOnDc )
                {
                    //
                    // warn the admin that dns updates wont happen
                    //

                    DhcpServerEventLog(
                         DHCP_EVENT_NO_DNSCREDENTIALS_ON_DC,
                         EVENTLOG_WARNING_TYPE,
                         0 );

                    DhcpGlobalUseNoDns = TRUE;

                    //
                    // Terminate the thread opened for impersonation in DNSAPI.
                    //

                    DnsDhcpSrvRegisterTerm( );
                }

            }
            else
            {

                //
                // if the error code is something other than CANT_IMPERSONATE
                // something is messed up. Disable Dynamic DNS updates.
                //

                DhcpGlobalUseNoDns = TRUE;
            }

        }

    }

    if ( ( NO_ERROR != Error ) || ( Error1 == ERROR_CANNOT_IMPERSONATE ) || ( Uname[ 0 ] == L'\0' ) )
    {

        if ( !RunningOnDc )
        {

            //
            // some error occurred while getting username/passwd
            // or impersonation failed because of invalud username/passwd
            // domain. if not running on a dc, it is safe to call this 
            // function to enable dynamic dns updates.
            //

            Error1 = DnsDhcpSrvRegisterInitialize( NULL );

            if ( Error1 != ERROR_SUCCESS )
            {

                //
                // we cant do dynamic dns updates.
                //

                DhcpGlobalUseNoDns = TRUE;
            }

        }
        else
        {

            //
            // log a warning event if running on DC that no credential
            // is configured. 
            //

            if ( Uname[ 0 ] == L'\0' )
            {
                DhcpServerEventLog(
                     DHCP_EVENT_NO_DNSCREDENTIALS_ON_DC,
                     EVENTLOG_WARNING_TYPE,
                     0 );
            }

        }
    }
    
    //
    // dont shut down the service if dynamic dns initialization fails.
    //

    return ( ERROR_SUCCESS );
        
} // DynamicDnsInit()


DWORD
ImpersonateSecretUser(
    VOID
    )
{
    DWORD Error;
    WCHAR Uname[256], Domain[256], Passwd[256];
    HANDLE hToken, hOldToken;
    SECURITY_ATTRIBUTES Attr = {
        sizeof(SECURITY_ATTRIBUTES), NULL, TRUE };
    
    
    Error = DhcpQuerySecretUname(
        (LPWSTR)Uname, sizeof(Uname), (LPWSTR)Domain,
        sizeof(Domain), (LPWSTR)Passwd, sizeof(Passwd) );

    if( NO_ERROR != Error ) return Error;

    if( Uname[0] == L'\0' ) return ERROR_FILE_NOT_FOUND;
    
    Error = LogonUser(
        (LPWSTR)Uname, (LPWSTR)Domain,
        (LPWSTR)Passwd,
        LOGON32_LOGON_SERVICE, LOGON32_PROVIDER_WINNT50,
        &hToken );

    if( FALSE == Error ) return GetLastError();

    hOldToken = hToken;
    Error = DuplicateTokenEx(
        hToken, MAXIMUM_ALLOWED, &Attr, SecurityDelegation,
        TokenPrimary, &hToken );
    if( FALSE == Error ) {
        Error = GetLastError();
        CloseHandle( hOldToken );

        DhcpPrint((DEBUG_ERRORS, "DuplicateTokenEx: %ld\n", Error));
        return Error;
    }

    CloseHandle( hOldToken );
    
    if( !ImpersonateLoggedOnUser( hToken ) ) {
        Error = GetLastError();
    } else {
        Error = NO_ERROR;
    }
    
    CloseHandle( hToken );
    return Error;
}
    
DWORD
RevertFromSecretUser(
    IN VOID
    )
{
    if( FALSE == RevertToSelf() ) return GetLastError();
    return NO_ERROR;
}

BOOL
IsThisTheComputerName(
    IN LPWSTR Name
    )
{
    WCHAR ComputerName[300];
    DWORD Error, Size;

    DhcpPrint((DEBUG_MISC, "DC Name = %ws\n", Name ));
    
    if( NULL == Name || Name[0] == L'\0' ) return FALSE;
    if( Name[0] == L'\\' && Name[1] == L'\\' ) {
        Name += 2;
    }
    
    Size = sizeof(ComputerName)/sizeof(WCHAR);
    Error = GetComputerNameEx(
        ComputerNameDnsHostname, ComputerName, &Size );
    if( FALSE == Error ) {

        //
        // If this fails, there is probably no domain name at all
        //
        
        Error = GetLastError();
        DhcpPrint((DEBUG_ERRORS, "GetComputerNameEx(Host): %ld\n", Error));
        return FALSE;
    }

    if( 0 == _wcsicmp(Name, ComputerName) ) return TRUE;

    Size = sizeof(ComputerName)/sizeof(WCHAR);
    Error = GetComputerNameEx(
        ComputerNameDnsFullyQualified, ComputerName, &Size );
    if( FALSE == Error ) {

        //
        // If this fails, there is probably no domain name at all
        //
        
        Error = GetLastError();
        DhcpPrint((DEBUG_ERRORS, "GetComputerNameEx(Fqdn): %ld\n", Error));
        return FALSE;
    }

    if( 0 == _wcsicmp(Name, ComputerName) ) return TRUE;
    return FALSE;
}

BOOL
IsRunningOnDc(
    VOID
    )
{
    DWORD Error, Size;
    WCHAR DomainName[300];
    PDOMAIN_CONTROLLER_INFO pDcInfo = NULL;
    
    Size = sizeof(DomainName)/sizeof(WCHAR);
    Error = GetComputerNameEx(
        ComputerNameDnsDomain, DomainName, &Size );
    if( FALSE == Error ) {

        //
        // If this fails, there is probably no domain name at all
        //
        
        Error = GetLastError();
        DhcpPrint((DEBUG_ERRORS, "GetComputerNameEx2: %ld\n", Error));
        return FALSE;
    }

    Error = DsGetDcName(
        NULL, DomainName, NULL, NULL,
        DS_DIRECTORY_SERVICE_REQUIRED | 
        DS_IS_DNS_NAME | DS_RETURN_DNS_NAME, &pDcInfo );

    if( NO_ERROR != Error ) {
        DhcpPrint((DEBUG_ERRORS, "DsGetDcName: %ld\n", Error));
    } else {

        if( pDcInfo != NULL ) {
            Error = IsThisTheComputerName(pDcInfo->DomainControllerName);
            NetApiBufferFree(pDcInfo);
            if( Error == TRUE ) return TRUE;
        }
    }

    return FALSE;    
}

DWORD
DhcpBeginWriteApi(
    IN LPSTR ApiName
    )
{
    DWORD Error;

    DhcpPrint((DEBUG_APIS, "%s called\n", ApiName));
    Error = DhcpApiAccessCheck( DHCP_ADMIN_ACCESS );
    if( NO_ERROR != Error ) return Error;
    
    DhcpAcquireWriteLock();
    LOCK_DATABASE();


#if 0
    //
    // The following code has problems because of the size of the
    // database update that can be done within a BeginWriteApi
    // and EndWriteApi.  So, the proposal is to just do the
    // transaction recovery in the EndWriteApi.DhcpConfigSave routine.
    //
    Error = DhcpJetBeginTransaction();
    if( NO_ERROR != Error ) {
        UNLOCK_DATABASE();
        DhcpReleaseWriteLock();
    }
#endif
    
    return Error;
}

DWORD
DhcpEndWriteApiEx(
    IN LPSTR ApiName,
    IN ULONG Error,
    IN BOOL fClassChanged,
    IN BOOL fOptionsChanged,
    IN DHCP_IP_ADDRESS Subnet OPTIONAL,
    IN DWORD Mscope OPTIONAL,
    IN DHCP_IP_ADDRESS Reservation OPTIONAL
    )
{
    if( NO_ERROR == Error ) {
        Error = DhcpConfigSave(
            fClassChanged, fOptionsChanged, Subnet, Mscope,
            Reservation );
        if( NO_ERROR != Error ) {
            DhcpPrint((DEBUG_ERRORS, "DhcpConfigSave: 0x%lx\n", Error));
        }
    }

    DhcpPrint((DEBUG_APIS, "%s returned %ld\n", ApiName, Error));
        
#if 0
    //
    // See comments in DhcpBeginWriteApi
    //
    
    if( NO_ERROR == Error ) {
        Error = DhcpJetCommitTransaction();
    } else {
        Error = DhcpJetRollBack();
    }

    DhcpAssert( NO_ERROR == Error );
#endif

    UNLOCK_DATABASE();
    DhcpReleaseWriteLock();

    if( NO_ERROR == Error ) {
        DhcpScheduleRogueAuthCheck();
    }

    return Error;
}


DWORD
DhcpEndWriteApi(
    IN LPSTR ApiName,
    IN ULONG Error
    )
{
    return DhcpEndWriteApiEx(
        ApiName, Error, FALSE, FALSE, 0, 0, 0 );
}

DWORD
DhcpBeginReadApi(
    IN LPSTR ApiName
    )
{
    DWORD Error;

    DhcpPrint((DEBUG_APIS, "%s called\n", ApiName));
    Error = DhcpApiAccessCheck( DHCP_VIEW_ACCESS );

    if( NO_ERROR != Error ) return Error;

    DhcpAcquireReadLock();

    return NO_ERROR;
}

VOID
DhcpEndReadApi(
    IN LPSTR ApiName,
    IN ULONG Error
    )
{
    DhcpPrint((DEBUG_APIS, "%s returned %ld\n", ApiName, Error));
    DhcpReleaseReadLock();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\upgrade\postupg.c ===
/*++

Copyright (C) 1999 Microsoft Corporation

Module Name:

    postupg.c

Abstract:

    test program to test post upgrade phase

--*/

#include <upgrade.h>

void _cdecl main(void)
{
    DWORD Error = DhcpUpgConvertTempToDhcpDb(NULL);
    if( NO_ERROR != Error ) {
        printf("ConvertTextToDhcpDatabase: %ld\n", Error);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\upgrade\upg.c ===
/*++

Copyright (C) 1999 Microsoft Corporation

Module Name:

    upg.c

Abstract:

    test program to test upgrade phase

--*/

#include <upgrade.h>

void _cdecl main(void)
{
    DWORD Error;
    Error = DhcpUpgConvertDhcpDbToTemp();
    if( NO_ERROR != Error ) {
        printf("ConvertDhcpDatabaseToText: %ld\n", Error);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\server\auditlog\stubs.c ===
//================================================================================
//  Copyright (C) 1998 Microsoft Corporation
//  Author: RameshV
//  Description:
//    This file is part of the audit-logging DLL that is written using the
//    DHCP Server Callouts, and is explanatory of how CALLOUTS work.
//    This file contains the stubs and other stuff related to the callouts,
//    with the actual logging code itself localized to log.c
//================================================================================

//================================================================================
//  required headers
//================================================================================

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <dhcpssdk.h>                            // include this for all required prototypes
#include <log.h>

//================================================================================
//  Helper functions..
//================================================================================
VOID
LogDhcpCalloutDllProblem(
    IN      DWORD                  ErrCode
)
{
    HANDLE                         Handle;
    DWORD                          Error;
    LPSTR                          Strings[1];
    CHAR                           ErrorCodeOemString[32 + 1 + 7];

    strcpy( ErrorCodeOemString, "Error: %%" );
    _ultoa( ErrCode, ErrorCodeOemString + 2+7, 10 );

    Strings[0] = ErrorCodeOemString;

    Handle = RegisterEventSourceW(NULL, (LPWSTR)L"DhcpSLog");
    if( NULL == Handle ) return;

    ReportEventA(
        Handle,
        (WORD) EVENTLOG_ERROR_TYPE,
        0,
        0 /* Event ID */,
        NULL,
        1,
        sizeof(ErrCode),
        Strings,
        &ErrCode
    );

    DeregisterEventSource(Handle);
}

#define LOG_IT                     LogDhcpCalloutDllProblem(Err = GetExceptionCode())
#define BEGIN_PROTECT              try {
#define END_PROTECT                } except (EXCEPTION_EXECUTE_HANDLER) { LOG_IT; }

//================================================================================
//  forward declaration of callout functions we support.
//  (these functions are those defined as fields in DHCP_CALLOUT_TABLE struct.
//  usage and meaning of these functions are documented at definition point.
//================================================================================
DWORD
Control(
    IN      DWORD                  dwControlCode,
    IN      LPVOID                 lpReserved
);

DWORD
NewPkt(
    IN      LPBYTE                 Packet,
    IN      DWORD                  PacketSize,
    IN      DWORD                  IpAddress,
    IN      LPVOID                 Reserved,
    IN OUT  LPVOID                *PacketContext,
    OUT     LPBOOL                 ProcessIt
);

DWORD
SendPkt(
    IN      LPBYTE                 Packet,
    IN      DWORD                  PacketSize,
    IN      DWORD                  ControlCode,
    IN      DWORD                  IpAddress,
    IN      LPVOID                 Reserved,
    IN      LPVOID                 PacketContext
);

DWORD
DropPkt(
    IN      LPBYTE                 Packet,
    IN      DWORD                  PacketSize,
    IN      DWORD                  ControlCode,
    IN      DWORD                  IpAddress,
    IN      LPVOID                 Reserved,
    IN      LPVOID                 PacketContext
);

DWORD
LoseAddress(
    IN      LPBYTE                 Packet,
    IN      DWORD                  PacketSize,
    IN      DWORD                  ControlCode,
    IN      DWORD                  IpAddress,
    IN      DWORD                  AltAddress,
    IN      LPVOID                 Reserved,
    IN      LPVOID                 PacketContext
);

DWORD
GiveAddress(
    IN      LPBYTE                 Packet,
    IN      DWORD                  PacketSize,
    IN      DWORD                  ControlCode,
    IN      DWORD                  IpAddress,
    IN      DWORD                  AltAddress,
    IN      DWORD                  AddrType,
    IN      DWORD                  LeaseTime,
    IN      LPVOID                 Reserved,
    IN      LPVOID                 PacketContext
);

DWORD
HandleOptions(
    IN      LPBYTE                 Packet,
    IN      DWORD                  PacketSize,
    IN      LPVOID                 Reserved,
    IN      LPVOID                 PacketContext,
    IN      LPDHCP_SERVER_OPTIONS  ServerOptions
);

//================================================================================
//  required data structure
//================================================================================

DHCP_CALLOUT_TABLE
ExportCalloutTbl = {                              // fill it with functions we support
    Control,                                      // we actually support all of these,
    NewPkt,                                       // though we dont use all of these..
    DropPkt,
    SendPkt,
    LoseAddress,
    GiveAddress,
    HandleOptions,
    NULL,
    NULL
};

static
DWORD                              Initialized = FALSE;
DHCP_CALLOUT_TABLE                 CalloutTbl;   // globals are init'ed to NULL
HMODULE                            CalloutDll = NULL;

//================================================================================
//  the only required export function -- DhcpServerCalloutEntry
//================================================================================

//  Before this function, let use declare helper routines..
DWORD
LoadDll(
    IN      LPWSTR                 DllName,
    OUT     HMODULE               *Dll,
    OUT     LPDHCP_ENTRY_POINT_FUNC *EntryPoint
);

DWORD
GetTable(
    IN      HMODULE                Dll,
    IN      LPWSTR                 DllList,
    IN      LPDHCP_ENTRY_POINT_FUNC EntryPoint,
    IN      DWORD                  CalloutVersion
);

//  The following entry point would be called by DHCP server as the first thing
//  it does with this callout DLL (after doing a LoadLibrary).
//  If this functions call fails to return ERROR_SUCCESS, it is assume that the
//  call failed (the "ExpCalloutTbl" should be unmodified in this case) and this
//  callout DLL is assumed to have failed to initialize -- it is then immediately
//  dropped.  If it succeeds then the server uses the values in the ExpCalloutTbl
//  field for its callouts.

//  ChainDlls represent the remaining DLL names (excluding this DLL) that have to
//  be chained up and that should be treated as callout DLLs exactly the same way
//  the server treats this DLL.  (Even when this DLL has "hooked" onto a DLL callout
//  routine, the rest of the DLLs MUST be also called...)
//  The code below does this..

//  Note that if CalloutVersion is not supported, this function should return
//  ERROR_NOT_SUPPORTED and proceed no further.
//  ALSO, this function should fill in the callout routines that it wants to "trap"
//  into the callout table.

DWORD                                             // error_code or ERROR_SUCCESS
DhcpServerCalloutEntry(                           // entry point for this callout DLL
    IN      LPWSTR                 ChainDlls,     // other dll's in chain.
    IN      DWORD                  CalloutVersion,// server callout version
    IN OUT  LPDHCP_CALLOUT_TABLE   ExpCalloutTbl  // need to fill this table up
)
{
    DWORD                          Err;
    LPWSTR                         AllocedMem;    // need to keep track of mem
    LPDHCP_ENTRY_POINT_FUNC        EntryPoint;    // the entry point in 1st dll
    HMODULE                        Dll;           // dll module handle

    if( FALSE != Initialized ) {                  // make sure this DLL is loaded only once
        return ERROR_ALREADY_INITIALIZED;
    }

    if( CalloutVersion != 0 ) {                   // we dont support this version...
        return ERROR_NOT_SUPPORTED;
    }

    // DO ANY LOCAL START-UP HERE..

    for(                                          // try to startup rest of the DLLs in chain..
        ;  0 != wcslen(ChainDlls) ;               // so long as got dll to try
        ChainDlls += 1 + wcslen(ChainDlls)        // skip to next dll
    ) {
        Dll = NULL;
        Err = LoadDll(                            // try to load this DLL, and get entrypoint
            ChainDlls,
            &Dll,
            &EntryPoint
        );
        if( ERROR_SUCCESS != Err ) {              // could not load dll or get entrypoint
            continue;                             // try the next -- ignore errors
        }

        Err = GetTable(                           // try to get the tbl into CalloutTbl
            Dll,
            ChainDlls,
            EntryPoint,
            CalloutVersion
        );
        if( ERROR_SUCCESS != Err ) {              // could not do so?
            FreeLibrary(Dll);
        } else {                                  // loaded a table? cool!
            Initialized = TRUE;
            break;                                // vogay, get on w life
        }
    }

    if( !Initialized ) {                          // did not initialize any other DLL yet..
        memset(&CalloutTbl,0, sizeof(CalloutTbl));// zero this so we dont trip on random values here
    }

    // Now do this for EVERY field in the CalloutTbl --> chain to any succeeding DLL

    if( NULL == ExportCalloutTbl.DhcpControlHook ) {
        ExportCalloutTbl.DhcpControlHook = CalloutTbl.DhcpControlHook;
    }
    if( NULL == ExportCalloutTbl.DhcpNewPktHook ) {
        ExportCalloutTbl.DhcpNewPktHook = CalloutTbl.DhcpNewPktHook;
    }
    if( NULL == ExportCalloutTbl.DhcpPktDropHook ) {
        ExportCalloutTbl.DhcpPktDropHook = CalloutTbl.DhcpPktDropHook;
    }
    if( NULL == ExportCalloutTbl.DhcpPktSendHook ) {
        ExportCalloutTbl.DhcpPktSendHook = CalloutTbl.DhcpPktSendHook;
    }
    if( NULL == ExportCalloutTbl.DhcpAddressDelHook) {
        ExportCalloutTbl.DhcpAddressDelHook = CalloutTbl.DhcpAddressDelHook;
    }
    if( NULL == ExportCalloutTbl.DhcpAddressOfferHook ) {
        ExportCalloutTbl.DhcpAddressOfferHook = CalloutTbl.DhcpAddressOfferHook;
    }
    if( NULL == ExportCalloutTbl.DhcpHandleOptionsHook ) {
        ExportCalloutTbl.DhcpHandleOptionsHook = CalloutTbl.DhcpHandleOptionsHook;
    }
    if( NULL ==  ExportCalloutTbl.DhcpExtensionHook ) {
        ExportCalloutTbl.DhcpExtensionHook = CalloutTbl.DhcpExtensionHook;
    }
    if( NULL == ExportCalloutTbl.DhcpReservedHook ) {
        ExportCalloutTbl.DhcpReservedHook = CalloutTbl.DhcpReservedHook;
    }

    *ExpCalloutTbl = ExportCalloutTbl;            // now copy the tbl over..
    Initialized = TRUE;                           // ok everything went fine..

    // If you wish to make this DLL work when loaded multiple times, then
    // you have to probably make ExportCalloutTbl into a linked list...
    // It will not work well as it is now..

    return ERROR_SUCCESS;                         // did fine?
}

//================================================================================
//  now come the support functions that are needed to implement the function
//  call ABOVE..
//================================================================================

DWORD                                             // error code or ERROR_SUCCESS
LoadDll(                                          // try to load dll+entry point
    IN      LPWSTR                 DllName,       // the dll to try to load
    OUT     HMODULE               *Dll,           // fill in this with handle
    OUT     LPDHCP_ENTRY_POINT_FUNC *EntryPoint   // fill in this function pointer
)
{
    DWORD                          Err;

    try {
        *Dll = NULL;
        *EntryPoint = NULL;                       // fill in defaults..

        *Dll = LoadLibrary(DllName);              // try to load dll
        if( NULL == *Dll ) return GetLastError(); // oops.. could not load dll
        *EntryPoint = (LPDHCP_ENTRY_POINT_FUNC)GetProcAddress(*Dll, DHCP_CALLOUT_ENTRY_POINT);
        if( NULL == *EntryPoint ) {               // oops.. couldnt load entyr pt
            Err = GetLastError();                 // find error and return it
            FreeLibrary(*Dll);                    // make sure dont dll is out
            *Dll = NULL;
            return Err;
        }
    } except( EXCEPTION_EXECUTE_HANDLER ) {       // if there is an offending DLL ...
        LogDhcpCalloutDllProblem(Err = GetExceptionCode());
        return Err;
    }

    return ERROR_SUCCESS;                         // everything went fine
}

// NOTE that this function affects the global variable CalloutTbl and sets it to
// contain the Tbl as returned by the first DLL in the chain (and which by definition
// stands for the whole chain).

DWORD
GetTable(                                         // try to retrieve callout tbl
    IN      HMODULE                Dll,           // this is the dll that is going to be used..
    IN      LPWSTR                 DllList,       // current dll list
    IN      LPDHCP_ENTRY_POINT_FUNC EntryPoint,   // entry pt func to call
    IN      DWORD                  Version        // version of server..
)
{
    DWORD                          Err;

    try {
        DllList += wcslen(DllList) + 1;           // skip the module "Dll"
        Err = EntryPoint(                         // just chase the entry point to get tbl..
            DllList,
            Version,
            &CalloutTbl
        );
        if( ERROR_SUCCESS == Err ) {              // cool everything went fine..
            CalloutDll = Dll;                     // save this module handle -- got to free it sometime
            return ERROR_SUCCESS;                 // alrighty, got table, lets proceed clean.
        }

        memset(&CalloutTbl,0,sizeof(CalloutTbl)); // clear up table...
        CalloutDll = NULL;                        // not really necessary - must be NULL anyways..
    } except (EXCEPTION_EXECUTE_HANDLER ) {       // the entry point actually av'ed!!
        Err = GetExceptionCode();
        memset(&CalloutTbl,0,sizeof(CalloutTbl)); // clear up table...
        CalloutDll = NULL;                        // not really necessary - must be NULL anyways..
        return Err;
    }
    return Err;                                   // return failure code
}

VOID
FreeTable(                                        // free table and module..
    VOID
)
{
    if( FALSE == Initialized ) {                  // never initialize anyways?
        return;
    }

    memset(&CalloutTbl,0,sizeof(CalloutTbl));
    CalloutDll = NULL;

    if( NULL != CalloutDll ) {
        FreeLibrary(CalloutDll);
    }
}

//================================================================================
//  here comes the various callouts themselves.. pretty straightforward
//  stuff here.. None of the return status here is being used.
//  It is hoped that the callout will return informational return values that may
//  be used in future..
//================================================================================

//  lpReserved should not be looked at yet..
//  dwControlCode is one of DHCP_CONTROL_??? where ??? is START, STOP, PAUSE, CONTINUE
//  this reflects the state of the DHCP Server service.
//  this function is required to call the Control function with same parameters for
//  any chained DLLs.

DWORD
Control(
    IN      DWORD                  dwControlCode,
    IN      LPVOID                 lpReserved
)
{
    DWORD                          Err;

    switch( dwControlCode ) {                     // what are the possible control codes?
    case DHCP_CONTROL_START :                     // the DHCP server service is started
        DhcpLogInit();                            // init that module..
        break;
    case DHCP_CONTROL_STOP:                       // the DHCP server service is being stopped
        break;
    case DHCP_CONTROL_PAUSE:                      // the DHCP server service is being paused
        break;
    case DHCP_CONTROL_CONTINUE:                   // the DHCP server service is being continued after pause
        break;
    default:                                      // as yet undefined error code
    }

    DhcpLogEvent(dwControlCode);
    if( NULL == CalloutTbl.DhcpControlHook ) {    // no chaining needed.
        return ERROR_SUCCESS;
    }

    BEGIN_PROTECT

    Err = CalloutTbl.DhcpControlHook(             // chain.
        dwControlCode,
        lpReserved
    );

    END_PROTECT

    if( DHCP_CONTROL_STOP == dwControlCode ) {    // stopping.. unload the tbl
        FreeTable();                              // free up resources..
        DhcpLogCleanup();
        Initialized = FALSE;
    }

    return Err;
}

//  NewPkt is invoked whenever a new packet comes into the network.
//  Packet refers to the actual bytes of iformation for the packet
//  IpAddress is the IpAddress of the socket this packet was received on
//  Reserved is explained elsewhere
//  ProcessIt is an OUT parameter that needs to set to TRUE if it should
//  be processed by the server or dropped..

DWORD
NewPkt(
    IN      LPBYTE                 Packet,
    IN      DWORD                  PacketSize,
    IN      DWORD                  IpAddress,
    IN      LPVOID                 Reserved,
    IN OUT  LPVOID                *PacketContext,
    OUT     LPBOOL                 ProcessIt
)
{
    DWORD                          Err;

    // NewPkt is not used..
    // Do any local processing here
    // Also, if you wish to return your PacketContext for further reference
    // (all future PacketContext variables will be same for this packet),
    // then, you have to make sure taht you also maintain the context for the
    // next in the chain.  That is, your PacketContext structure should
    // have a field for the packet context as returned by the next DLL in the
    // chain.

    // Also, You should do the same with the ProcessIt flag.

    // Another important aspect is that you should pass the right PacketContext
    // to the SendPkt or the other miscellaneous functions that pass the PacketContext
    // (i.e. when you call the other chained DLLs, you will have to pass the right
    // PacketContext that they return here).

    if( NULL == CalloutTbl.DhcpNewPktHook ) {     // no chaining reqd
        *ProcessIt = TRUE;                        // dont drop the pkt
        return ERROR_SUCCESS;
    }

    BEGIN_PROTECT
    Err = CalloutTbl.DhcpNewPktHook(              // chain this
        Packet,
        PacketSize,
        IpAddress,
        Reserved,
        PacketContext,                            // we dont use it, so ok; else we have to pass our own ctxt..
        ProcessIt
    );
    END_PROTECT
}

//  This callout is called whenever a packet is ready to be sent on the wire
//  by the dhcp server.
//  Packet refers to the actual bytes of information for the packet to be sent out
//  IpAddress is the IpAddress of the socket this packet was received on
//  Reserved is explained elsewhere
//  ControlCode is currently just DHCP_SEND_PACKET.. (if not the DLL should not
//  process the callout, but just chain it).

DWORD
SendPkt(
    IN      LPBYTE                 Packet,
    IN      DWORD                  PacketSize,
    IN      DWORD                  ControlCode,
    IN      DWORD                  IpAddress,
    IN      LPVOID                 Reserved,
    IN      LPVOID                 PacketContext
)
{
    DWORD                          Err;

    // SendPkt is not used.. just chain it?

    switch(ControlCode) {
    case DHCP_SEND_PACKET:                        // packet is being sent on wire
        break;
    default:                                      // undefined control code
    }

    if( NULL == CalloutTbl.DhcpPktSendHook ) {    // no chaining reqd
        return ERROR_SUCCESS;
    }

    BEGIN_PROTECT
    // Remember to pass the right PacketContext
    Err = CalloutTbl.DhcpPktSendHook(             // chain this
        Packet,
        PacketSize,
        ControlCode,
        IpAddress,
        Reserved,
        PacketContext
    );
    END_PROTECT
}

//  If the server has to drop a packet (and not send a response), it calls this routine.
//  Packet refers to the actual bytes of information for the packet to be sent out
//  IpAddress is the IpAddress of the socket this packet was received on
//  Reserved is explained elsewhere
//  PacketContext is the value returned as out parameter by NewPkt function.
//  ControlCode is currently  DHCP_DROP_??? where ??? is one of
//  DUPLICATE (this packet looks like a duplicate of another, so dropped)
//  NOMEM (not enought memory to queue this packet)
//  INTERNAL_ERROR (duh!)
//  TIMEOUT (was in the queue too long to be processed)
//  UNAUTH (server is not authorized to process packet)
//  NO_SUBNETS (no subnets are configured for the server to run this..)
//  INVALID (either the packet is invalid, or server not configured for this client)
//  WRONG_SERVER (client contacting wrong server)
//  NOADDRESS (dont have any address to offer client)
//  GEN_FAILURE (duh! duh!)
//  PROCESSED (actually is not a drop.. the packet was just completely processed)

DWORD
DropPkt(
    IN      LPBYTE                 Packet,
    IN      DWORD                  PacketSize,
    IN      DWORD                  ControlCode,
    IN      DWORD                  IpAddress,
    IN      LPVOID                 Reserved,
    IN      LPVOID                 PacketContext
)
{
    DWORD                          Err;

    switch(ControlCode) {
    case DHCP_DROP_DUPLICATE:                     // dropped as this packet is a duplicate
        break;
    case DHCP_DROP_NOMEM:                         // dropped as server does not have memory
        break;
    case DHCP_DROP_INTERNAL_ERROR:                // dropped as server had some internal problem
        break;
    case DHCP_DROP_TIMEOUT:                       // dropped as packet is too old
        break;
    case DHCP_DROP_UNAUTH:                        // dropped as server is not authorized to process
        break;
    case DHCP_DROP_PAUSED:                        // dropped as server is paused
        break;
    case DHCP_DROP_NO_SUBNETS:                    // dropped as no subnets are configured
        break;
    case DHCP_DROP_INVALID:                       // dropped as packet is invalid or client is invalid
        break;
    case DHCP_DROP_WRONG_SERVER:                  // dropped as the client is in different DS enterprise
        break;
    case DHCP_DROP_NOADDRESS:                     // dropped as we got no address to offer
        DhcpLogEvent(DHCP_DROP_NOADDRESS, IpAddress);
        break;
    case DHCP_DROP_PROCESSED:                     // dropped as packet has been processed and nothing to do
        break;
    case DHCP_DROP_GEN_FAILURE:                   // unspecified error
        break;
    default:                                      // unknown control code
        break;
    }

    if( NULL == CalloutTbl.DhcpPktDropHook ) {    // no chaining reqd
        return ERROR_SUCCESS;
    }

    BEGIN_PROTECT

    // Careful about PacketContext

    Err = CalloutTbl.DhcpPktDropHook(             // chain this
        Packet,
        PacketSize,
        ControlCode,
        IpAddress,
        Reserved,
        PacketContext
    );
    END_PROTECT
}

//  if the client loses/declines an address or the server detects that the address
//  is being in use in the network when it tries to give it to this client... this
//  callout is called.
//  Packet refers to the actual bytes of information for the packet to be sent out
//  IpAddress is the IpAddress of the socket this packet was received on
//  Reserved is explained elsewhere
//  AltAddress refers to the address that is released by a client/ declined or in
//    conflict.
//  ControlCode is currently  DHCP_PROB_??? where ??? is one of
//  CONFLICT -- server was about to offer this address, but detected it was in use
//  DECLINE -- client declined this address
//  RELEASE -- this address was released by client
//  NACKED -- server just NACKED client's request for "AltAddress"

DWORD
LoseAddress(
    IN      LPBYTE                 Packet,
    IN      DWORD                  PacketSize,
    IN      DWORD                  ControlCode,
    IN      DWORD                  IpAddress,
    IN      DWORD                  AltAddress,
    IN      LPVOID                 Reserved,
    IN      LPVOID                 PacketContext
)
{
    DWORD                          Err;

    switch(ControlCode) {
    case DHCP_PROB_CONFLICT:                      // the address is in conflict
        break;
    case DHCP_PROB_DECLINE:                       // client has declined address
        break;
    case DHCP_PROB_RELEASE:                       // client is releasing address
        break;
    case DHCP_PROB_NACKED:                        // DHCP server is NACKing Client
        break;
    default:                                      // unknown control code
        break;
    }

    DhcpLogEvent(ControlCode, IpAddress, AltAddress);

    if( NULL == CalloutTbl.DhcpAddressDelHook ) { // no chaining reqd
        return ERROR_SUCCESS;
    }

    BEGIN_PROTECT

    // Careful with Packet Context

    Err = CalloutTbl.DhcpAddressDelHook(         // chain this
        Packet,
        PacketSize,
        ControlCode,
        IpAddress,
        AltAddress,
        Reserved,
        PacketContext
    );
    END_PROTECT

    return Err;
}

//  When the server decides to give the address to a client (RENEW the address
//  not OFFER), this callout is called.
//  Packet refers to the actual bytes of information for the packet to be sent out
//  IpAddress is the IpAddress of the socket this packet was received on
//  Reserved is explained elsewhere
//  AltAddress refers to the address being given out.
//  AddrType is either DHCP_CLIENT_BOOTP or DHCP_CLIENT_DHCP
//  LeaseTime is time in seconds that is going to be offered as lease to client.
//  ControlCode is currently DHCP_GIVE_ADDRESS_NEW (meaning the client did not already
//   have a lease on this address before) or DHCP_GIVE_ADDRESS_OLD (meaning, the client just
//   renewed its lease).

DWORD
GiveAddress(
    IN      LPBYTE                 Packet,
    IN      DWORD                  PacketSize,
    IN      DWORD                  ControlCode,
    IN      DWORD                  IpAddress,
    IN      DWORD                  AltAddress,
    IN      DWORD                  AddrType,
    IN      DWORD                  LeaseTime,
    IN      LPVOID                 Reserved,
    IN      LPVOID                 PacketContext
)
{
    DWORD                          Err;

    switch(ControlCode) {
    case DHCP_GIVE_ADDRESS_NEW:                  // this address wasn't given to this client before
        break;
    case DHCP_GIVE_ADDRESS_OLD:                  // this client already got this address before
        break;
    default:                                     // undefined
    }

    switch(AddrType) {
    case DHCP_CLIENT_DHCP:                       // client is a DHCP client
        break;
    case DHCP_CLIENT_BOOTP:                      // client is a BOOTP client
        break;
    default:                                     // undefined client type
    }

    DhcpLogEvent(ControlCode, IpAddress, AltAddress, AddrType, LeaseTime);

    if( NULL == CalloutTbl.DhcpAddressOfferHook) {// no chaining required
        return ERROR_SUCCESS;
    }

    BEGIN_PROTECT

    // Careful with the PacketContext now.

    Err = CalloutTbl.DhcpAddressOfferHook(
        Packet,
        PacketSize,
        ControlCode,
        IpAddress,
        AltAddress,
        AddrType,
        LeaseTime,
        Reserved,
        PacketContext
    );
    END_PROTECT

    return Err;
}

//  Each packet, when it arrives, goes to a NewPkt and ends in a DROP_* where * is atleast
//  PROCESSED.. (it is possible that it may get multiple DROP_ but only the first one
//  should be considered).
//  Before making any PROB_ or GIVE_ callouts, the foll callout is made, which makes
//  available, the parsed options structure... (the structure will be published shortly).
//  Also, until the final DROP_* callout, the "Reserved" parameter to all the callouts are
//  the same, and the pointer "ServerOptions" passed as parameter here is valid.. (but not
//  after the first DROP_ for this packet).
//  This is like an "application" context to figure out what is happening to which packet?
//  Note that "Packet" itself is not guaranteed to be the same "ptr" even a single packet..
//  This is obscure code.. not sure we need to expose this?
DWORD
HandleOptions(
    IN      LPBYTE                 Packet,
    IN      DWORD                  PacketSize,
    IN      LPVOID                 Reserved,
    IN      LPVOID                 PacketContext,
    IN      LPDHCP_SERVER_OPTIONS  ServerOptions
)
{
    DWORD                          Err;

    if( NULL == CalloutTbl.DhcpHandleOptionsHook ) {// no chaining
        return ERROR_SUCCESS;
    }

    BEGIN_PROTECT
    Err = CalloutTbl.DhcpHandleOptionsHook(        // chain
        Packet,
        PacketSize,
        Reserved,
        PacketContext,
        ServerOptions
    );
    END_PROTECT

    return Err;
}


//================================================================================
//  end of file
//================================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\upgrade\db.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    db.c

Abstract:

    Upgrade databases from NT3.51, NT4.0 and NT5.0 to Whistler.

    N.B: Most of this is taken from dhcp\server\server\database.c
    
--*/

#include <upgrade.h>

//
// Debugging and logging
//
typedef enum {
    Winnt32LogSevereError,
    Winnt32LogError,
    Winnt32LogWarning,
    Winnt32LogInformation,
    Winnt32LogDetailedInformation,
    Winnt32LogMax
} Winnt32DebugLevel;

HANDLE hInst;
HANDLE hDebugLog;
Winnt32DebugLevel DebugLevel;
typedef DWORD (WINAPI *GetClusterStateFn)( LPCWSTR, DWORD*);

ULONG
ByteSwap(
    IN ULONG Source
    )
{
    ULONG swapped;

    swapped = ((Source)              << (8 * 3)) |
              ((Source & 0x0000FF00) << (8 * 1)) |
              ((Source & 0x00FF0000) >> (8 * 1)) |
              ((Source)              >> (8 * 3));

    return swapped;
}

LPSTR
IpAddressToString(
    IN ULONG Address
    )
{
    static CHAR Buffer[30];
    PUCHAR pAddress;

    pAddress = (PUCHAR)&Address;
    sprintf(Buffer, "%d.%d.%d.%d", pAddress[0], pAddress[1],
            pAddress[2], pAddress[3] );
    return Buffer;
}

VOID
ConcatenatePaths(
    IN OUT PTSTR   Path1,
    IN     LPCTSTR Path2,
    IN     DWORD   BufferSizeChars
    )

/*++

Routine Description:

    Concatenate two path strings together, supplying a path separator
    character (\) if necessary between the 2 parts.

Arguments:

    Path1 - supplies prefix part of path. Path2 is concatenated to Path1.

    Path2 - supplies the suffix part of path. If Path1 does not end with a
        path separator and Path2 does not start with one, then a path sep
        is appended to Path1 before appending Path2.

    BufferSizeChars - supplies the size in chars (Unicode version) or
        bytes (Ansi version) of the buffer pointed to by Path1. The string
        will be truncated as necessary to not overflow that size.

Return Value:

    None.

--*/

{
    BOOL NeedBackslash = TRUE;
    DWORD l;
     
    if(!Path1)
        return;

    l = lstrlen(Path1);

    if(BufferSizeChars >= sizeof(TCHAR)) {
        //
        // Leave room for terminating nul.
        //
        BufferSizeChars -= sizeof(TCHAR);
    }

    //
    // Determine whether we need to stick a backslash
    // between the components.
    //
    if(l && (Path1[l-1] == TEXT('\\'))) {

        NeedBackslash = FALSE;
    }

    if(Path2 && *Path2 == TEXT('\\')) {

        if(NeedBackslash) {
            NeedBackslash = FALSE;
        } else {
            //
            // Not only do we not need a backslash, but we
            // need to eliminate one before concatenating.
            //
            Path2++;
        }
    }

    //
    // Append backslash if necessary and if it fits.
    //
    if(NeedBackslash && (l < BufferSizeChars)) {
        lstrcat(Path1,TEXT("\\"));
    }

    //
    // Append second part of string to first part if it fits.
    //
    if(Path2 && ((l+lstrlen(Path2)) < BufferSizeChars)) {
        lstrcat(Path1,Path2);
    }
}


LPTSTR
DupString(
    IN LPCTSTR String
    )

/*++

Routine Description:

    Make a duplicate of a nul-terminated string.

Arguments:

    String - supplies pointer to nul-terminated string to copy.

Return Value:

    Copy of string or NULL if OOM. Caller can free with FREE().

--*/

{
    LPTSTR p;

    if(p = LocalAlloc(LPTR, (lstrlen(String)+1)*sizeof(TCHAR))) {
        lstrcpy(p,String);
    }

    return(p);
}


/***
*void Parse_Cmdline(cmdstart, argv, lpstr, numargs, numbytes)
*
*Purpose:
*       Parses the command line and sets up the Unicode argv[] array.
*       On entry, cmdstart should point to the command line,
*       argv should point to memory for the argv array, lpstr
*       points to memory to place the text of the arguments.
*       If these are NULL, then no storing (only counting)
*       is done.  On exit, *numargs has the number of
*       arguments (plus one for a final NULL argument),
*       and *numbytes has the number of bytes used in the buffer
*       pointed to by args.
*
*Entry:
*       LPWSTR cmdstart - pointer to command line of the form
*           <progname><nul><args><nul>
*       TCHAR **argv - where to build argv array; NULL means don't
*                      build array
*       LPWSTR lpstr - where to place argument text; NULL means don't
*                      store text
*
*Exit:
*       no return value
*       INT *numargs - returns number of argv entries created
*       INT *numbytes - number of bytes used in args buffer
*
*Exceptions:
*
*******************************************************************************/

void Parse_Cmdline (
    LPTSTR cmdstart,
    LPTSTR*argv,
    LPTSTR lpstr,
    INT *numargs,
    INT *numbytes
    )
{
    LPTSTR p;
    TCHAR c;
    INT inquote;                    /* 1 = inside quotes */
    INT copychar;                   /* 1 = copy char to *args */
    WORD numslash;                  /* num of backslashes seen */

    *numbytes = 0;
    *numargs = 1;                   /* the program name at least */

    /* first scan the program name, copy it, and count the bytes */
    p = cmdstart;
    if (argv)
        *argv++ = lpstr;

    /* A quoted program name is handled here. The handling is much
       simpler than for other arguments. Basically, whatever lies
       between the leading double-quote and next one, or a terminal null
       character is simply accepted. Fancier handling is not required
       because the program name must be a legal NTFS/HPFS file name.
       Note that the double-quote characters are not copied, nor do they
       contribute to numbytes. */
    if (*p == TEXT('\"'))
    {
        /* scan from just past the first double-quote through the next
           double-quote, or up to a null, whichever comes first */
        while ((*(++p) != TEXT('\"')) && (*p != TEXT('\0')))
        {
            *numbytes += sizeof(WCHAR);
            if (lpstr)
                *lpstr++ = *p;
        }
        /* append the terminating null */
        *numbytes += sizeof(WCHAR);
        if (lpstr)
            *lpstr++ = TEXT('\0');

        /* if we stopped on a double-quote (usual case), skip over it */
        if (*p == TEXT('\"'))
            p++;
    }
    else
    {
        /* Not a quoted program name */
        do {
            *numbytes += sizeof(WCHAR);
            if (lpstr)
                *lpstr++ = *p;

            c = *p++;

        } while (c > TEXT(' '));

        if (c == TEXT('\0'))
        {
            p--;
        }
        else
        {
            if (lpstr)
                *(lpstr - 1) = TEXT('\0');
        }
    }

    inquote = 0;

    /* loop on each argument */
    for ( ; ; )
    {
        if (*p)
        {
            while (*p == TEXT(' ') || *p == TEXT('\t'))
                ++p;
        }

        if (*p == TEXT('\0'))
            break;                  /* end of args */

        /* scan an argument */
        if (argv)
            *argv++ = lpstr;         /* store ptr to arg */
        ++*numargs;

        /* loop through scanning one argument */
        for ( ; ; )
        {
            copychar = 1;
            /* Rules: 2N backslashes + " ==> N backslashes and begin/end quote
                      2N+1 backslashes + " ==> N backslashes + literal "
                      N backslashes ==> N backslashes */
            numslash = 0;
            while (*p == TEXT('\\'))
            {
                /* count number of backslashes for use below */
                ++p;
                ++numslash;
            }
            if (*p == TEXT('\"'))
            {
                /* if 2N backslashes before, start/end quote, otherwise
                   copy literally */
                if (numslash % 2 == 0)
                {
                    if (inquote)
                        if (p[1] == TEXT('\"'))
                            p++;    /* Double quote inside quoted string */
                        else        /* skip first quote char and copy second */
                            copychar = 0;
                    else
                        copychar = 0;       /* don't copy quote */

                    inquote = !inquote;
                }
                numslash /= 2;          /* divide numslash by two */
            }

            /* copy slashes */
            while (numslash--)
            {
                if (lpstr)
                    *lpstr++ = TEXT('\\');
                *numbytes += sizeof(WCHAR);
            }

            /* if at end of arg, break loop */
            if (*p == TEXT('\0') || (!inquote && (*p == TEXT(' ') || *p == TEXT('\t'))))
                break;

            /* copy character into argument */
            if (copychar)
            {
                if (lpstr)
                        *lpstr++ = *p;
                *numbytes += sizeof(WCHAR);
            }
            ++p;
        }

        /* null-terminate the argument */

        if (lpstr)
            *lpstr++ = TEXT('\0');         /* terminate string */
        *numbytes += sizeof(WCHAR);
    }

}


LPTSTR *
CommandLineToArgv(
    OUT int *NumArgs
    )
{
    LPTSTR CommandLine;
    TCHAR  ModuleName[MAX_PATH];
    LPTSTR Start;
    INT    Size;
    LPTSTR *Args;

    CommandLine = GetCommandLine();
    GetModuleFileName(NULL,ModuleName,MAX_PATH);

    //
    // If there's no command line at all (won't happen from cmd.exe, but
    // possibly another program), then we use pgmname as the command line
    // to parse, so that argv[0] is initialized to the program name
    //
    Start = *CommandLine ? CommandLine : ModuleName;

    //
    // Find out how much space is needed to store args,
    // allocate space for argv[] vector and strings,
    // and store args and argv ptrs in block we allocate
    //

    Parse_Cmdline(Start,NULL,NULL,NumArgs,&Size);

    Args = (LPTSTR *)LocalAlloc(LMEM_ZEROINIT,((*NumArgs+1) * sizeof(LPTSTR)) + Size);
    if(!Args) {
        return(NULL);
    }

    Parse_Cmdline(Start,Args,(LPTSTR)(Args + *NumArgs),NumArgs,&Size);

    return(Args);
}

BOOL
StartDebugLog(
    IN LPCTSTR DebugFileLog,
    IN Winnt32DebugLevel Level
    )
{
    if( hDebugLog ) return TRUE;

    hInst = LoadLibrary(TEXT("DHCPUPG.DLL"));
    
    if(Level >= Winnt32LogMax) Level = Winnt32LogMax-1;
    DebugLevel = Level;

    hDebugLog = CreateFile(
        DebugFileLog, GENERIC_WRITE,
        FILE_SHARE_READ, NULL, OPEN_ALWAYS,
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
        NULL );

    if( hDebugLog == INVALID_HANDLE_VALUE) {
        hDebugLog = NULL;
        return FALSE;
    }

    if(GetLastError() == ERROR_ALREADY_EXISTS) {
        //
        // Appending to existing file
        //

        SetFilePointer(hDebugLog,0,NULL,FILE_END);
    }

    return(TRUE);
}

VOID
CloseDebugLog(
    VOID
    )
{
    if( hDebugLog ) {
        CloseHandle( hDebugLog );
        hDebugLog = NULL;
    }
}

VOID
StartDebug(
    VOID
    )
/*++

Routine Description:

    Parse arguments passed to the program.  Perform syntactic validation
    and fill in defaults where necessary.

    Valid arguments:

    /debug[level][:filename]    maintain debug log at level, defaults to warning level 2
                                and file c:\winnt32.log

    /tempdrive:letter           manually specify drive for local source

Arguments:

    None. Arguments are retreived via GetCommandLine().

Return Value:

    None.

--*/

{
    LPTSTR Arg;
    LPTSTR BadParam = NULL;
    LPTSTR Colon;
    LPTSTR p;
    BOOL Valid;
    LPCTSTR DebugFileLog;
    LONG DebugLevel;
    BOOL b;
    unsigned u;
    int argc;
    LPTSTR *argv;
    BOOL Downloaded = FALSE;

    argv = CommandLineToArgv(&argc);

    //
    // Skip program name. We should always get back argc as at least 1,
    // but be robust anyway.
    //
    if(argc) {
        argc--;
        argv++;
    }

    DebugFileLog = NULL;
    DebugLevel = 0;
    Valid = FALSE;

    while(argc--) {
        Arg = *argv++;
        if((*Arg == TEXT('/')) || (*Arg == TEXT('-'))) {

            switch(_totupper(Arg[1])) {

            case TEXT('D'):

                if(DebugFileLog || _tcsnicmp(Arg+1,TEXT("debug"),5)) {
                    break;
                }

                DebugLevel = _tcstol(Arg+6,&Colon,10);
                if((DebugLevel == -1) || (*Colon && (*Colon != TEXT(':')))) {
                    break;
                }

                if(Colon == Arg+6) {
                    //
                    // No debug level specified, use default
                    //
                    DebugLevel = Winnt32LogWarning;
                }

                if(*Colon) {
                    //
                    // Log file name was specified.
                    //
                    Colon++;
                    if(*Colon) {
                        // Hardcode debug file to
                        // %windir%\dhcpupg.log for now
                        // DebugFileLog = Colon;
                    } 
                }
                break;

            }
        }
    }

    if( DebugLevel == 0 || DebugLevel == -1 ) {
        DebugLevel = Winnt32LogInformation;
    }
    if( DebugFileLog == NULL ) {
        TCHAR   Buffer[MAX_PATH];
        if( 0 == GetWindowsDirectory( Buffer, MAX_PATH )) {
            ZeroMemory(Buffer, sizeof(Buffer));
        }
        ConcatenatePaths( Buffer, TEXT("DHCPUPG.LOG"), MAX_PATH );
        DebugFileLog = DupString( Buffer );
    }

    if( DebugFileLog ) Valid = StartDebugLog(DebugFileLog,DebugLevel);
    if( !Valid ) {
        DbgPrint( "DHCPUPG: Logging not done.\n" );
    } 
}

struct _MSG_MAP {
    DWORD MessageId;
    LPWSTR MessageStr;
} MessageMap[] = {
    MSGERR_STARTLOG,L"DHCPUPG: **************  Starting conversion to text.\n",
    MSGERR_STARTLOG2,L"DHCPUPG: **************  Starting conversion from text.\n",
    MSGERR_VALUE,L"DHCPUPG: Error reading registry value %1!s! : %2!d!.\n",
    MSGERR_EXPAND,L"DHCPUPG: Error expanding environment variables in string %1!s!.\n",
    MSGERR_OPENPARAMSKEY,L"DHCPUPG: Error opening the Parameters key: %1!d!.\n",
    MSGERR_GETDBPARAMS,L"DHCPUPG: Successfully read DHCP registry parameters.\n",
    MSGERR_LOAD,L"DHCPUPG: %2!s! failed to load: %1!d!.\n",
    MSGERR_GETPROCADDR,L"DHCPUPG: Error linking to routine %2!s!: %1!d!.\n",
    MSGERR_SETDBPARAM,L"DHCPUPG: Error attempting to set database param %2!d!: %1!d!.\n",
    MSGERR_JETINIT,L"DHCPUPG: Error initializing Jet database: %1!d!.\n",
    MSGERR_JETBEGINSESSION,L"DHCPUPG: Error initializing Jet session: %1!d!.\n",
    MSGERR_JETDETACHDB,L"DHCPUPG: Error detaching Jet database: %1!d!.\n",
    MSGERR_JETATTACHDB,L"DHCPUPG: Error attaching Jet database: %1!d!.\n",
    MSGERR_JETOPENDB,L"DHCPUPG: Error opening Jet database: %1!d!.\n",
    MSGERR_JETOPENTABLE,L"DHCPUPG: Error opening Jet database table: %1!d!.\n",
    MSGERR_JETGETCOL,L"DHCPUPG: Error opening Jet table column: %1!d!.\n",
    MSGERR_JETOPENMTABLE,L"DHCPUPG: Error opening Jet database mcast table: %1!d!.\n",
    MSGERR_JETGETMCOL,L"DHCPUPG: Error opening Jet mcast table column: %1!d!.\n",
    MSGERR_INITDB,L"DHCPUPG: Attempting to intialize jet database (version %1!d!).\n",
    MSGERR_REGISTRY,L"DHCPUPG: Error reading parameters from registry: %1!d!.\n",
    MSGERR_LOADESE,L"DHCPUPG: Error failed to initialize ESE database: %1!d!.\n",
    MSGERR_LOAD500,L"DHCPUPG: Error failed to initialize Jet500 database: %1!d!.\n",
    MSGERR_LOAD200,L"DHCPUPG: Error failed to initialize Jet200 database: %1!d!.\n",
    MSGERR_GETCOL,L"DHCPUPG: Error retrieving column %2!d!: %1!d!.\n",
    MSGERR_GETMCOL,L"DHCPUPG: Error retrieving mcast column %2!d!: %1!d!.\n",
    MSGERR_SETINDEX,L"DHCPUPG: Error attempting to set the index for the database: %1!d!.\n",
    MSGERR_INVALIDIP,L"DHCPUPG: Invalid record -- IP address value is not of the right size.\n",
    MSGERR_INVALIDMASK,L"DHCPUPG: Invalid record -- Subnet Mask value is not of the right size.\n",
    MSGERR_INVALIDNAME,L"DHCPUPG: Invalid record -- Name value is not of the right size.\n",
    MSGERR_INVALIDINFO,L"DHCPUPG: Invalid record -- Machine Info value is not of the right size.\n",
    MSGERR_INVALIDEXPIRATION,L"DHCPUPG: Invalid record -- Lease value is not of the right size.\n",
    MSGERR_SCANCOUNT,L"DHCPUPG: Scanned %1!d! records.\n",
    MSGERR_SETMINDEX,L"DHCPUPG: Error attempting to set the index for the mcast table: %1!d!.\n",
    MSGERR_INVALIDMIP,L"DHCPUPG: Invalid mcast record -- IP address value is not of the right size.\n",
    MSGERR_INVALIDSCOPEID,L"DHCPUPG: Invalid mcast record -- ScopeId value is not of the right size.\n",
    MSGERR_INVALIDMEXPIRATION,L"DHCPUPG: Invalid mcast record -- Lease value is not of the right size.\n",
    MSGERR_INVALIDMSTART,L"DHCPUPG: Invalid mcast record -- LeaseStart value is not of the right size.\n",
    MSGERR_SCANMCOUNT,L"DHCPUPG: Scanned %1!d! mcast records.\n",
    MSGERR_CONVERT_FAILED,L"DHCPUPG: Failed to convert DHCP database to temporary format.\n",
    MSGERR_CONVERT_SUCCEEDED,L"DHCPUPG: Successfully converted DHCP database to temporary format.\n",
    MSGERR_CREATE_FILE_FAILED,L"DHCPUPG: Cannot create the destination temporary file: %1!d!.\n",
    MSGERR_OPENSCM,L"DHCPUPG: Unable to open the services control manager: %1!d!.\n",
    MSGERR_OPENSVC,L"DHCPUPG: Unable to open the DHCPServer service: %1!d!.\n",
    MSGERR_SVCQUERY,L"DHCPUPG: Unable to query the status of DHCPServer service: %1!d!.\n",
    MSGERR_SVCWAIT,L"DHCPUPG: DHCPServer service is in %1!d! state -- waiting for it to stop.\n",
    MSGERR_SVCCTRL,L"DHCPUPG: DHCPServer failed to stop: %1!d!.\n",
    MSGERR_SVCSTOP_SUCCESS,L"DHCPUPG: DHCPServer service has stopped successfully.\n",
    MSGERR_CREATE_MAP,L"DHCPUPG: Failed to create a mapping object for file: %1!d!.\n",
    MSGERR_CREATE_VIEW,L"DHCPUPG: Failed to create memory view for file: %1!d!.\n",
    MSGERR_SETVALUE,L"DHCPUPG: Failed to set the \"Version\" registry value: %1!d!.\n",
    MSGERR_DELETEFILE,L"DHCPUPG: Failed to delete the temporary file: %1!d!.\n",
    MSGERR_CHANGEPERMS,L"DHCPUPG: Failed to convert permissions on database: %1!d!.\n",
    0xFFFFFFFF, 0
};

BOOL
DebugLog(
    IN Winnt32DebugLevel Level,
    IN UINT MessageId,
    ...
    )
{
    CHAR MessageA[5000];
    va_list arglist;
    DWORD Size, Written, i;
    LPWSTR Message;
    BOOL b;

    if( !hDebugLog ) return FALSE;
    if( Level > DebugLevel ) return TRUE;

    va_start(arglist,MessageId);

    Size = FormatMessageW(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE,
        hInst, MessageId, 0, (LPWSTR)&Message, 0, &arglist );

    if( Size == 0 ) {
        for( i = 0; MessageMap[i].MessageId != 0xFFFFFFFF ; i ++ ) {
            if( MessageMap[i].MessageId == MessageId ) break;
        }
        if( MessageMap[i].MessageId == MessageId ) {
            Size = FormatMessageW(
                FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                MessageMap[i].MessageStr, MessageId, 0,
                (LPWSTR)&Message, 0, &arglist ); 
        }
    }
    
    va_end(arglist);

    b = FALSE;
    if(Size) {
        Size = WideCharToMultiByte(
            CP_ACP, 0, Message, -1, MessageA, sizeof(MessageA),
            NULL, NULL );

        if( Size ) b = WriteFile(
            hDebugLog, MessageA, Size-1, &Written, NULL );
        
        LocalFree((HLOCAL)Message);
    } 

    return b;
}

//
// reading the database
//

enum {
    LoadJet200,
    LoadJet500,
    LoadJet97,
};

enum {
    RecordTypeDbEntry,
    RecordTypeMcastDbEntry,
};

//
// database table and field names.
//

#define IPADDRESS_INDEX                                0
#define HARDWARE_ADDRESS_INDEX                         1
#define STATE_INDEX                                    2
#define MACHINE_INFO_INDEX                             3
#define MACHINE_NAME_INDEX                             4
#define LEASE_TERMINATE_INDEX                          5
#define SUBNET_MASK_INDEX                              6
#define SERVER_IP_ADDRESS_INDEX                        7
#define SERVER_NAME_INDEX                              8
#define CLIENT_TYPE_INDEX                              9
#define MAX_INDEX                                      10


#define LogErr printf
#define LogInf printf
#define LogError(A,B) if(Error)LogErr("DHCP: %s:%s:0x%lx\n",#A,#B,Error)
#define LogErrorEx(A,B,C) if(Error)LogErr("DHCP: %s:%s:%s:0x%lx\n",#A,#B,#C,Error)
#define LogInfo(A,B,C) LogInf("DHCP: " #A B, C)

#define SAVE_BUF_SIZE (1004096L)
#define SAVE_THRESHOLD (1000000L)

//
// Globals
//

DWORD LastError;
DWORD JetVersion;
CHAR DatabaseName[1024], DatabasePath[1024];
HMODULE hJet;
JET_INSTANCE JetInstance;
JET_SESID JetSession;
JET_DBID JetDb;
JET_TABLEID JetTbl;
PUCHAR SaveBuf;
ULONG SaveBufSize;
HANDLE hTextFile, hMapping;
PVOID FileView;
DWORD LoSize, HiSize;
WCHAR Winnt32Path[MAX_PATH*2];
CHAR System32Path[MAX_PATH*2];

JET_ERR (JET_API *pJetSetCurrentIndex)(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	const char		*szIndexName
    );
JET_ERR (JET_API *pJetRetrieveColumn)(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	JET_COLUMNID	columnid,
	void			*pvData,
	unsigned long	cbData,
	unsigned long	*pcbActual,
	JET_GRBIT		grbit,
	JET_RETINFO		*pretinfo );

JET_ERR (JET_API *pJetMove)(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	long			cRow,
	JET_GRBIT		grbit );

JET_ERR (JET_API *pJetSetSystemParameter)(
	JET_INSTANCE	*pinstance,
	JET_SESID		sesid,
	unsigned long	paramid,
	ULONG_PTR		lParam,
	const char		*sz );

JET_ERR (JET_API *pJetTerm)( JET_INSTANCE instance );

JET_ERR (JET_API *pJetTerm2)( JET_INSTANCE instance, JET_GRBIT grbit );

JET_ERR (JET_API *pJetEndSession)( JET_SESID sesid, JET_GRBIT grbit );

JET_ERR (JET_API *pJetBeginSession)(
	JET_INSTANCE	instance,
	JET_SESID		*psesid,
	const char		*szUserName,
	const char		*szPassword );

JET_ERR (JET_API *pJetInit)( JET_INSTANCE *pinstance);

JET_ERR (JET_API *pJetDetachDatabase)(
	JET_SESID		sesid,
	const char		*szFilename );

JET_ERR (JET_API *pJetAttachDatabase)(
	JET_SESID		sesid,
	const char		*szFilename,
	JET_GRBIT		grbit );

JET_ERR (JET_API *pJetOpenDatabase)(
	JET_SESID		sesid,
	const char		*szFilename,
	const char		*szConnect,
	JET_DBID		*pdbid,
	JET_GRBIT		grbit );

JET_ERR (JET_API *pJetCloseDatabase)(
	JET_SESID		sesid,
	JET_DBID		dbid,
	JET_GRBIT		grbit );

JET_ERR (JET_API *pJetOpenTable)(
	JET_SESID		sesid,
	JET_DBID		dbid,
	const char		*szTableName,
	const void		*pvParameters,
	unsigned long	cbParameters,
	JET_GRBIT		grbit,
	JET_TABLEID		*ptableid );

JET_ERR (JET_API *pJetCloseTable)( JET_SESID sesid, JET_TABLEID tableid );

JET_ERR (JET_API *pJetGetTableColumnInfo)(
	JET_SESID		sesid,
	JET_TABLEID		tableid,
	const char		*szColumnName,
	void			*pvResult,
	unsigned long	cbMax,
	unsigned long	InfoLevel );

JET_ERR (JET_API *pJetGetIndexInfo)(
        JET_SESID               sesid,
        JET_DBID                dbid,
        const char              *szTableName,
        const char              *szIndexName,
        void                    *pvResult,
        unsigned long   cbResult,
        unsigned long   InfoLevel );

#define DB_FUNC(F,I,S) \
{#F, TEXT(#F), #F "@" #S, I, (FARPROC *)& p ## F }

typedef struct _DB_FUNC_ENTRY {
    LPSTR FuncName;
    LPWSTR FuncNameW;
    LPSTR AltName;
    DWORD Index;
    FARPROC *FuncPtr;
} DB_FUNC_ENTRY;

DB_FUNC_ENTRY FuncTable[] = {
    DB_FUNC(JetSetCurrentIndex, 164, 12),
    DB_FUNC(JetRetrieveColumn, 157, 32),
    DB_FUNC(JetMove, 147, 16),
    DB_FUNC(JetSetSystemParameter, 165, 20),
    DB_FUNC(JetTerm, 167, 4),
    DB_FUNC(JetTerm2, 0, 8),
    DB_FUNC(JetEndSession, 124, 8),
    DB_FUNC(JetBeginSession, 104, 16),
    DB_FUNC(JetInit, 145, 4),
    DB_FUNC(JetDetachDatabase, 121, 8),
    DB_FUNC(JetAttachDatabase, 102, 12),
    DB_FUNC(JetOpenDatabase, 148, 20),
    DB_FUNC(JetOpenTable, 149, 28),
    DB_FUNC(JetGetTableColumnInfo, 137, 24),
    DB_FUNC(JetCloseTable,108, 8),
    DB_FUNC(JetCloseDatabase, 107, 12),
    DB_FUNC(JetGetIndexInfo, 131, 28),
};

#define JetSetCurrentIndex pJetSetCurrentIndex
#define JetRetrieveColumn pJetRetrieveColumn
#define JetMove pJetMove
#define JetSetSystemParameter pJetSetSystemParameter
#define JetTerm pJetTerm
#define JetTerm2 pJetTerm2
#define JetEndSession pJetEndSession
#define JetBeginSession pJetBeginSession
#define JetInit pJetInit
#define JetDetachDatabase pJetDetachDatabase
#define JetAttachDatabase pJetAttachDatabase
#define JetOpenDatabase pJetOpenDatabase
#define JetOpenTable pJetOpenTable
#define JetGetTableColumnInfo pJetGetTableColumnInfo
#define JetCloseTable pJetCloseTable
#define JetCloseDatabase pJetCloseDatabase
#define JetGetIndexInfo pJetGetIndexInfo

typedef struct _TABLE_INFO {
    CHAR *ColName;
    JET_COLUMNID ColHandle;
    BOOL fPresent;
    JET_COLTYP ColType;
} TABLE_INFO, *LPTABLE_INFO;

#define IPADDRESS_STRING        "IpAddress"
#define HARDWARE_ADDRESS_STRING "HardwareAddress"
#define STATE_STRING            "State"
#define MACHINE_INFO_STRING     "MachineInformation"
#define MACHINE_NAME_STRING     "MachineName"
#define LEASE_TERMINATE_STRING  "LeaseTerminates"
#define SUBNET_MASK_STRING      "SubnetMask"
#define SERVER_IP_ADDRESS_STRING "ServerIpAddress"
#define SERVER_NAME_STRING      "ServerName"
#define CLIENT_TYPE             "ClientType"

static TABLE_INFO ClientTable[] = {
    { IPADDRESS_STRING        , 0, 1, JET_coltypLong },
    { HARDWARE_ADDRESS_STRING , 0, 1, JET_coltypBinary },
    { STATE_STRING            , 0, 1, JET_coltypUnsignedByte },
    { MACHINE_INFO_STRING     , 0, 1, JET_coltypBinary }, // must modify MACHINE_INFO_SIZE if this changes
    { MACHINE_NAME_STRING     , 0, 1, JET_coltypBinary },
    { LEASE_TERMINATE_STRING  , 0, 1, JET_coltypCurrency },
    { SUBNET_MASK_STRING      , 0, 1, JET_coltypLong },
    { SERVER_IP_ADDRESS_STRING, 0, 1, JET_coltypLong },
    { SERVER_NAME_STRING      , 0, 1, JET_coltypBinary },
    { CLIENT_TYPE             , 0, 1, JET_coltypUnsignedByte }
};

#define MCAST_CLIENT_TABLE_NAME       "MCastClientTableVer3"

#define MCAST_TBL_IPADDRESS_STR "MCastIpAddr"
#define MCAST_TBL_CLIENT_ID_STR "MCastClientID"
#define MCAST_TBL_CLIENT_INFO_STR "MCastClientInfo"
#define MCAST_TBL_STATE_STR     "MCastState"
#define MCAST_TBL_FLAGS_STR     "MCastFlags"
#define MCAST_TBL_SCOPE_ID_STR     "ScopeId"
#define MCAST_TBL_LEASE_START_STR   "MCastLeaseStart"
#define MCAST_TBL_LEASE_END_STR     "MCastLeaseEnd"
#define MCAST_TBL_SERVER_IP_ADDRESS_STR "MCastServerIp"
#define MCAST_TBL_SERVER_NAME_STR "MCastServerName"

enum {
    MCAST_TBL_IPADDRESS,
    MCAST_TBL_CLIENT_ID,
    MCAST_TBL_CLIENT_INFO,
    MCAST_TBL_STATE,
    MCAST_TBL_FLAGS,
    MCAST_TBL_SCOPE_ID,
    MCAST_TBL_LEASE_START,
    MCAST_TBL_LEASE_END,
    MCAST_TBL_SERVER_IP_ADDRESS,
    MCAST_TBL_SERVER_NAME,
    MCAST_MAX_COLUMN
};

TABLE_INFO MadcapClientTable[] = {
    { MCAST_TBL_IPADDRESS_STR        , 0, JET_coltypLongBinary },
    { MCAST_TBL_CLIENT_ID_STR        , 0, JET_coltypBinary },
    { MCAST_TBL_CLIENT_INFO_STR      , 0, JET_coltypLongBinary },
    { MCAST_TBL_STATE_STR            , 0, JET_coltypUnsignedByte },
    { MCAST_TBL_FLAGS_STR            , 0, JET_coltypLong },
    { MCAST_TBL_SCOPE_ID_STR         , 0, JET_coltypBinary },
    { MCAST_TBL_LEASE_START_STR      , 0, JET_coltypCurrency },
    { MCAST_TBL_LEASE_END_STR  ,       0, JET_coltypCurrency },
    { MCAST_TBL_SERVER_IP_ADDRESS_STR, 0, JET_coltypLongBinary },
    { MCAST_TBL_SERVER_NAME_STR,    0, JET_coltypBinary },
};

JET_TABLEID MadcapTbl;

VOID static
CleanupDatabase(
    VOID
    )
{
    if( JetTbl != 0 ) {
        JetCloseTable( JetSession, JetTbl );
        JetTbl = 0;
    }

    if( MadcapTbl != 0 ) {
        JetCloseTable( JetSession, MadcapTbl );
        MadcapTbl = 0;
    }
    
    if( JetSession != 0 ) {
        JetEndSession( JetSession, 0 );
        JetSession = 0;
    }

    if( NULL != hJet ) {
        if( NULL != JetTerm2 ) {
            JetTerm2( JetInstance, JET_bitTermComplete );
        } else {
            JetTerm( JetInstance );
        }
    
        FreeLibrary( hJet ); hJet = NULL;
    }

    JetInstance = 0;
}

DWORD
ReadString(
    IN HKEY hKey,
    IN LPSTR KeyName,
    IN LPSTR Buffer,
    IN ULONG BufSize
    )
{
    DWORD Error, Size, Type;
    CHAR Str[1024];
    
    Size = sizeof(Str);
    Error = RegQueryValueExA(
        hKey, KeyName, NULL, &Type, (LPSTR)Str, &Size );
    if( NO_ERROR == Error ) {
        if( 0 == Size || 1 == Size ) Error = ERROR_NOT_FOUND;
        if( Type != REG_SZ && Type != REG_EXPAND_SZ && Type !=
            REG_MULTI_SZ ) Error = ERROR_BAD_FORMAT;
    }

    if( NO_ERROR != Error ) return Error;

    Size = ExpandEnvironmentStringsA( (LPSTR)Str, Buffer, BufSize );
    if( Size == 0 || Size > BufSize ) {
        Error = ERROR_META_EXPANSION_TOO_LONG;
    }

    if(Error) DebugLog(Winnt32LogError,MSGERR_EXPAND,KeyName);
    return Error;
}

DWORD
ReadRegistry(
    VOID
    )
{
    HKEY hKey;
    DWORD Error, Size;
    CHAR Str[1024];
    
    //
    // Open dhcp server parameters key
    //
    
    Error = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        TEXT("SYSTEM\\CurrentControlSet\\Services\\DHCPServer\\Parameters"),
        0, KEY_READ, &hKey );

    if(Error)DebugLog(Winnt32LogError, MSGERR_OPENPARAMSKEY, Error );
    if( NO_ERROR != Error ) return Error;

    //
    // Read database details
    //
    
    do {
        Error = ReadString(
            hKey, "DatabasePath", (LPSTR)DatabasePath,
            sizeof(DatabasePath) ); 

        if(Error)DebugLog(Winnt32LogError,MSGERR_VALUE, L"DatabasePath", Error);
        if( NO_ERROR != Error ) break;

        Error = ReadString(
            hKey, "DatabaseName", (LPSTR)DatabaseName,
            sizeof(DatabaseName) );

        if(Error)DebugLog(Winnt32LogError,MSGERR_VALUE, L"DatabaseName", Error);
        if( NO_ERROR != Error ) break;

        Error = NO_ERROR;

        DebugLog(Winnt32LogInformation, MSGERR_GETDBPARAMS );
    } while( 0 );

    RegCloseKey( hKey );
    return Error;
}

DWORD
LoadAndLinkRoutines(
    IN DWORD JetVersion
    )
{
    DWORD Error, i;
    LPTSTR Module;
    LPSTR FuncName;
    
    Module = NULL;
    switch( JetVersion ) {
    case LoadJet97 : Module = TEXT("esent.dll"); break;
    case LoadJet500 : Module = TEXT("jet500.dll"); break;
    case LoadJet200 : Module = TEXT("jet.dll"); break;
    default: Module = TEXT("esent.dll"); break;
    }

    hJet = LoadLibrary( Module );
    if( NULL == hJet ) {
        Error = GetLastError();
    } else {
        Error = NO_ERROR;
    }

    if(Error)DebugLog(Winnt32LogInformation, MSGERR_LOAD, Error, Module );
    if( NO_ERROR != Error ) return Error;

    for( i = 0; i < sizeof(FuncTable)/sizeof(FuncTable[0]); i ++ ) {
        (*FuncTable[i].FuncPtr) = NULL;
    }
    
    for( i = 0; i < sizeof(FuncTable)/sizeof(FuncTable[0]); i ++ ) {
        if( LoadJet200 != JetVersion ) {
            FuncName = FuncTable[i].FuncName;
        } else {
            if( 0 == FuncTable[i].Index ) {
                (*FuncTable[i].FuncPtr) = NULL;
                continue;
            }

            FuncName = (LPSTR)ULongToPtr(FuncTable[i].Index);
        }

        Error = NO_ERROR;
        
        (*FuncTable[i].FuncPtr) = GetProcAddress(hJet, FuncName);
        
        if( NULL == FuncTable[i].FuncPtr ) {
            Error = GetLastError();

            if( LoadJet97 == JetVersion ) {
                (*FuncTable[i].FuncPtr) = GetProcAddress(
                    hJet, FuncTable[i].AltName );
                if( NULL != FuncTable[i].FuncPtr ) continue;

                Error = GetLastError();
            }
        }

        if(Error) DebugLog(Winnt32LogError, MSGERR_GETPROCADDR, Error, FuncTable[i].FuncNameW );
        if( NO_ERROR != Error ) break;
    }

    //
    // if erred out, cleanup
    //

    if( NO_ERROR != Error ) {
        FreeLibrary( hJet );
        hJet = NULL;
    }

    return Error;
}

DWORD
SetJetParams(
    IN DWORD JetVersion,
    IN LPSTR DbName,
    IN LPSTR DbPath
    )
{
    DWORD Error, JetParam;
    CHAR Temp[2048];
    LPSTR DbSysFile = "\\system.mdb";
    LPSTR DbBaseName = "j50";

    Temp[ 0 ] = '\0';
    JetInstance = 0;

    if ( strlen( DbPath ) < 2048 )
        strcpy(Temp, DbPath);

    if( LoadJet200 == JetVersion ) {
        strcat(Temp, DbSysFile);
        JetParam = JET_paramSysDbPath_OLD;
    } else {
        strcat(Temp, "\\");
        if( LoadJet97 != JetVersion ) {
            JetParam = JET_paramSystemPath_OLD;
        } else {
            JetParam = JET_paramSystemPath;
        }
    }

    Error = JetSetSystemParameter(
        &JetInstance, (JET_SESID)0, JetParam, 0, Temp );

    if(Error)DebugLog(Winnt32LogError, MSGERR_SETDBPARAM, Error, JetParam );
    if( NO_ERROR != Error ) return Error;

    if( LoadJet200 != JetVersion ) {
        if( LoadJet97 != JetVersion ) {
            JetParam = JET_paramBaseName_OLD;
        } else {
            JetParam = JET_paramBaseName;
        }
        
        Error = JetSetSystemParameter(
            &JetInstance, (JET_SESID)0, JetParam, 0, DbBaseName  );

        if(Error)DebugLog(Winnt32LogError, MSGERR_SETDBPARAM, Error, JetParam );
        if( NO_ERROR != Error ) return Error;
    }

    if( LoadJet200 != JetVersion ) {
        if( LoadJet97 == JetVersion ) {
            JetParam = JET_paramLogFileSize;
        } else {
            JetParam = JET_paramLogFileSize_OLD;
        }
        
        Error = JetSetSystemParameter(
            &JetInstance, (JET_SESID)0, JetParam, 1000, NULL );
        if(Error) DebugLog(Winnt32LogError, MSGERR_SETDBPARAM, Error,
                           JetParam );
        if( NO_ERROR != Error ) return Error;
    }
    
    if( LoadJet200 != JetVersion ) {
        Error = JetSetSystemParameter(
            &JetInstance, (JET_SESID)0,
            JET_paramCheckFormatWhenOpenFail, 1, NULL );
        LogError(SetJetParams, OpenFail );

        JetParam = JET_paramCheckFormatWhenOpenFail;
        if(Error)DebugLog(Winnt32LogError, MSGERR_SETDBPARAM, Error, JetParam );
        if( NO_ERROR != Error ) return Error;
    }

    if( LoadJet200 != JetVersion ) {
        if( LoadJet97 != JetVersion ) {
            JetParam = JET_paramRecovery_OLD;
        } else {
            JetParam = JET_paramRecovery;
        }
        
        Error = JetSetSystemParameter(
            &JetInstance, (JET_SESID)0, JetParam, 0, "on");
        
        if(Error)DebugLog(Winnt32LogError, MSGERR_SETDBPARAM, Error, JetParam );
        if( NO_ERROR != Error ) return Error;
    }
    
    //
    // Note: Ideally, the log files should never exist.  Even
    // if the database is opened in readonly mode, they seem to
    // exist.  Not sure what else can be done
    //
        
    if( LoadJet97 == JetVersion ) {
        JetParam = JET_paramLogFilePath;
    } else {
        JetParam = JET_paramLogFilePath_OLD;
    }        
    
    strcpy(Temp, DbPath); strcat( Temp, "\\");
    
    Error = JetSetSystemParameter(
        &JetInstance, (JET_SESID)0, JetParam, 0, Temp );
    if(Error)DebugLog(Winnt32LogError, MSGERR_SETDBPARAM, Error, JetParam );

    return Error;
}

DWORD
OpenDatabase(
    IN DWORD JetVersion,
    IN LPSTR DbName,
    IN LPSTR DbPath
    )
{
    LONG Error;
    DWORD i;
    CHAR FilePath[2048];
    JET_INDEXLIST TmpIdxList;
    
    JetSession = 0;
    JetDb = 0;
    JetTbl = 0;
    MadcapTbl = 0;
    
    FilePath[ 0 ] = '\0';

    Error = JetInit( &JetInstance );

    if(Error) DebugLog(Winnt32LogError, MSGERR_JETINIT, Error );
    if( NO_ERROR != Error ) return Error;

    Error = JetBeginSession(
        JetInstance, &JetSession, "admin", "" );

    if(Error) DebugLog(Winnt32LogError, MSGERR_JETBEGINSESSION, Error );
    if( Error < 0 ) return Error;

    if ( ( strlen( DbPath ) + strlen( DbName ) + 2 ) < 2048 )
    {
        strcpy(FilePath, DbPath );
        strcat(FilePath, "\\" );
        strcat(FilePath, DbName );
    }

    Error = JetDetachDatabase( JetSession, NULL );
    
    if(Error) DebugLog(Winnt32LogError, MSGERR_JETDETACHDB, Error );
    if( Error < 0 ) return Error;

    Error = JetAttachDatabase( JetSession, FilePath, JET_bitDbRecoveryOff );

    if(Error) DebugLog(Winnt32LogError, MSGERR_JETATTACHDB, Error );
    if( Error < 0 ) return Error;

    Error = JetOpenDatabase(
        JetSession, FilePath, NULL, &JetDb,
        JET_bitDbSingleExclusive | JET_bitDbReadOnly );
    
    if(Error) DebugLog(Winnt32LogError, MSGERR_JETOPENDB, Error );
    if( Error < 0 ) return Error;

    Error = JetOpenTable(
        JetSession, JetDb, (LPSTR)"ClientTable",
        NULL, 0, JET_bitTableReadOnly,&JetTbl );  

    if(Error) DebugLog(Winnt32LogError, MSGERR_JETOPENTABLE, Error );
    if( Error < 0 ) return Error;

    for( i = 0; i < sizeof(ClientTable)/sizeof(ClientTable[0]); i ++ ) {
        JET_COLUMNDEF ColDef;
        
        Error = JetGetTableColumnInfo(
            JetSession, JetTbl, ClientTable[i].ColName, &ColDef,
            sizeof(ColDef), 0 );

        if(Error && JET_errColumnNotFound != Error ) {
            DebugLog(Winnt32LogError, MSGERR_JETGETCOL, Error );
        }
        
        if( Error < 0 ) {
            if( JET_errColumnNotFound == Error ) {
                ClientTable[i].fPresent = FALSE;
                continue;
            } else {
                return Error;
            }
        }

        if( ColDef.coltyp != ClientTable[i].ColType ) {
            ASSERT( FALSE );
            Error = ERROR_BAD_FORMAT;
            return Error;
        }

        ClientTable[i].ColHandle = ColDef.columnid;
    }

    Error = JetOpenTable(
        JetSession, JetDb, (LPSTR)"MCastClientTableVer3",
        NULL, 0, JET_bitTableReadOnly, &MadcapTbl );
    if( JET_errObjectNotFound == Error ) {
        Error = NO_ERROR;
    } else {
        if(Error) DebugLog(Winnt32LogError, MSGERR_JETOPENMTABLE, Error );
        if( Error < 0 ) return Error;
        
        for( i = 0; i < sizeof(MadcapClientTable)/sizeof(MadcapClientTable[0]); i ++ ) {
            JET_COLUMNDEF ColDef;
            
            Error = JetGetTableColumnInfo(
                JetSession, MadcapTbl, ClientTable[i].ColName, &ColDef,
                sizeof(ColDef), 0 );

            if(Error && Error != JET_errColumnNotFound) {
                DebugLog(Winnt32LogError, MSGERR_JETGETMCOL, Error );
            }
            
            if( Error < 0 ) {
                if( JET_errColumnNotFound == Error ) {
                    MadcapClientTable[i].fPresent = FALSE;
                    continue;
                } else {
                    return Error;
                }
            }
            
            if( ColDef.coltyp != MadcapClientTable[i].ColType ) {
                ASSERT( FALSE );
                Error = ERROR_BAD_FORMAT;
                return Error;
            }
        
            MadcapClientTable[i].ColHandle = ColDef.columnid;
        }
    }
    
    return NO_ERROR;
}

DWORD
LoadAndInitializeDatabase(
    IN DWORD JetVersion,
    IN LPSTR DbName,
    IN LPSTR DbPath
    )
{
    DWORD Error;

    //
    // Attempt to load DLL and retrieve function pointers
    //

    DebugLog(Winnt32LogInformation, MSGERR_INITDB, JetVersion );
    
    Error = LoadAndLinkRoutines( JetVersion );
    if( NO_ERROR != Error ) return Error;

    //
    // set standard jet params
    //
    
    Error = SetJetParams( JetVersion, DbName, DbPath );
    if( NO_ERROR != Error ) {
        FreeLibrary( hJet ); hJet = NULL;
        return Error;
    }

    //
    // Attempt to open database
    //

    Error = OpenDatabase( JetVersion, DbName, DbPath );
    if( NO_ERROR != Error ) {
        CleanupDatabase();
        return Error;
    }
    
    return NO_ERROR;
}

DWORD
LoadAndLinkSecurityRoutines(
    OUT FARPROC *pGetInfo,
    OUT FARPROC *pSetInfo
    )
{
    HMODULE hAdvapi32;

    hAdvapi32 = GetModuleHandle(TEXT("ADVAPI32.DLL"));
    if( NULL == hAdvapi32 ) return GetLastError();

    (*pGetInfo) = GetProcAddress(hAdvapi32, "GetNamedSecurityInfoA");
    if( NULL == *pGetInfo ) return GetLastError();

    (*pSetInfo) = GetProcAddress(hAdvapi32, "SetNamedSecurityInfoA");
    if( NULL == *pSetInfo ) return GetLastError();

    return NO_ERROR;
}

DWORD
ConvertPermissionsOnDbFiles(
    VOID
    )
{
    DWORD Error, dwVersion = GetVersion();
    PSECURITY_DESCRIPTOR pSec;
    PACL pAcl;
    HANDLE hSearch = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATAA FileData;
    CHAR FileName[1024];
    FARPROC pGetInfo, pSetInfo;
    CHAR DriversDirPath[MAX_PATH *2 +1];
    DWORD PathLen = sizeof(DriversDirPath)-1;
        
    //
    // Check if version is atleast NT5.
    //
    
    dwVersion =  (DWORD)(LOBYTE(LOWORD(dwVersion)));
    if( dwVersion < 5 ) return NO_ERROR;
    
    //
    // First get the requried function pointers..
    //

    Error = LoadAndLinkSecurityRoutines(
        &pGetInfo, &pSetInfo );
    if( NO_ERROR != Error ) return Error;

    ZeroMemory(DriversDirPath, PathLen+1);
    PathLen = ExpandEnvironmentStringsA(
        "%SystemRoot%\\system32\\drivers", DriversDirPath, PathLen );
    if( PathLen == 0 ) {
        Error = GetLastError();
        return Error;
    }    

    pSec = NULL;
    pAcl = NULL;
    Error = (DWORD)pGetInfo(
        "MACHINE\\SYSTEM\\CurrentControlSet\\Services\\DHCPServer",
        SE_REGISTRY_KEY, DACL_SECURITY_INFORMATION, NULL, NULL,
        &pAcl, NULL, &pSec );

    if( NO_ERROR != Error ) return Error;

    Error = (DWORD)pSetInfo(
        DatabasePath, SE_FILE_OBJECT, DACL_SECURITY_INFORMATION,
        NULL, NULL, pAcl, NULL );
    if( NO_ERROR != Error ) return Error;

    strcpy(FileName, DatabasePath);
    if( FileName[strlen(FileName)-1] != '\\' ) {
        strcat(FileName, "\\");
    }
    strcat(FileName, DatabaseName);

    Error = (DWORD)pSetInfo(
        FileName, SE_FILE_OBJECT, DACL_SECURITY_INFORMATION,
        NULL, NULL, pAcl, NULL );
    if( NO_ERROR != Error ) goto Cleanup;

    //
    // Now for all files matching "*.log", repeat above operation
    //

    strcpy(FileName, DatabasePath);
    if( FileName[strlen(FileName)-1] != '\\' ) {
        strcat(FileName, "\\");
    }
    strcat(FileName, "*.*");
    
    hSearch = FindFirstFileA( FileName, &FileData );
    if( INVALID_HANDLE_VALUE == hSearch ) {
        Error = GetLastError();
        goto Cleanup;
    }

    do {

        if( 0 != strcmp(FileData.cFileName, ".") &&
            0 != strcmp(FileData.cFileName, "..") ) {
            strcpy(FileName, DatabasePath);
            if( FileName[strlen(FileName)-1] != '\\' ) {
                strcat(FileName, "\\");
            }
            strcat(FileName, FileData.cFileName);
            
            Error = (DWORD)pSetInfo(
                FileName, SE_FILE_OBJECT,
                DACL_SECURITY_INFORMATION, NULL, NULL, pAcl, NULL );
            if( NO_ERROR != Error ) break;
        }

        Error = FindNextFileA( hSearch, &FileData );
        if( FALSE != Error ) Error = NO_ERROR;
        else Error = GetLastError();

    } while( NO_ERROR == Error );

    FindClose( hSearch );
    
 Cleanup:

    LocalFree( pSec );

    if( ERROR_FILE_NOT_FOUND == Error ) return NO_ERROR;
    if( ERROR_NO_MORE_FILES == Error ) return NO_ERROR;
    return Error;
}

DWORD
InitializeDatabase(
    VOID
    )
{
    DWORD Error;

    Error = ReadRegistry();
    if(Error) DebugLog(Winnt32LogError, MSGERR_REGISTRY, Error );
    if( NO_ERROR != Error ) return Error;

    // Do not set the ACLs on %SystemRoot%\\system32\\dhcp
//      Error = ConvertPermissionsOnDbFiles();
//      if(Error) DebugLog(Winnt32LogError, MSGERR_CHANGEPERMS, Error );

    // ignore error and try best effort

    if( FALSE == SetCurrentDirectoryA(DatabasePath) ) {
        Error = GetLastError();
        if( ERROR_FILE_NOT_FOUND == Error ||
            ERROR_PATH_NOT_FOUND == Error ) {
            return ERROR_SERVICE_DOES_NOT_EXIST;
        }
        
        return Error;
    }
    
    Error = LoadAndInitializeDatabase(
        LoadJet97, (LPSTR)DatabaseName, (LPSTR)DatabasePath );

    if(Error) DebugLog( Winnt32LogInformation, MSGERR_LOADESE, Error );
    if( NO_ERROR == Error ) return NO_ERROR;

    Error = LoadAndInitializeDatabase(
        LoadJet500, (LPSTR)DatabaseName, (LPSTR)DatabasePath );
    
    if(Error) DebugLog( Winnt32LogInformation, MSGERR_LOAD500, Error );
    if( NO_ERROR == Error ) return NO_ERROR;

    Error = LoadAndInitializeDatabase(
        LoadJet200, (LPSTR)DatabaseName, (LPSTR)DatabasePath );
    
    if(Error) DebugLog( Winnt32LogInformation, MSGERR_LOAD200, Error );
    return Error;
}

DWORD
GetColumnValue(
    IN DWORD Index,
    IN LPSTR Buffer,
    IN OUT ULONG *BufSize
    )
{
    JET_ERR Error = NO_ERROR;
    DWORD Size;

    if( ClientTable[Index].fPresent == FALSE ) {
        (*BufSize) = 0;
        return NO_ERROR;
    }
    
    Error = JetRetrieveColumn(
        JetSession, JetTbl, ClientTable[Index].ColHandle, Buffer,
        *BufSize, &Size, 0, NULL );

    if( JET_errColumnNotFound == Error ) {
        Error = NO_ERROR;
        Size = 0;
    }

    if(Error) DebugLog( Winnt32LogWarning, MSGERR_GETCOL, Error, Index);
    if( Error < 0 ) return Error;

    (*BufSize) = Size;
    return NO_ERROR;
}

DWORD
GetMadcapColumnValue(
    IN DWORD Index,
    IN LPSTR Buffer,
    IN OUT ULONG *BufSize
    )
{
    JET_ERR Error = NO_ERROR;
    DWORD Size;

    if( ClientTable[Index].fPresent == FALSE ) {
        (*BufSize) = 0;
        return NO_ERROR;
    }
    
    Error = JetRetrieveColumn(
        JetSession, MadcapTbl,
        MadcapClientTable[Index].ColHandle, Buffer, 
        *BufSize, &Size, 0, NULL );

    if( JET_errColumnNotFound == Error ) {
        Error = NO_ERROR;
        Size = 0;
    }
    
    if(Error) DebugLog( Winnt32LogWarning, MSGERR_GETMCOL, Error, Index);
    if( Error < 0 ) return Error;

    (*BufSize) = Size;
    return NO_ERROR;
}

#define CLIENT_TYPE_UNSPECIFIED     0x0 // for backward compatibility
#define CLIENT_TYPE_DHCP            0x1
#define CLIENT_TYPE_BOOTP           0x2
#define CLIENT_TYPE_BOTH    ( CLIENT_TYPE_DHCP | CLIENT_TYPE_BOOTP )

#define ADDRESS_STATE_OFFERED 0
#define ADDRESS_STATE_ACTIVE 1
#define ADDRESS_STATE_DECLINED 2
#define ADDRESS_STATE_DOOM 3
#define ADDRESS_BIT_DELETED  0x80
#define ADDRESS_BIT_UNREGISTERED 0x40
#define ADDRESS_BIT_BOTH_REC 0x20
#define ADDRESS_BIT_CLEANUP 0x10
#define ADDRESS_BITS_MASK 0xF0

DWORD
AddRecord(
    IN LPSTR Buffer,
    IN ULONG BufSize
    );

DWORD
AddScannedClient(
    IN DWORD IpAddressNetOrder,
    IN DWORD SubnetMaskNetOrder,
    IN LPBYTE HwAddr,
    IN ULONG HwLen,
    IN LPWSTR MachineName,
    IN LPWSTR MachineInfo,
    IN ULONGLONG ExpirationFileTime,
    IN BYTE State,
    IN BYTE ClientType
    )
{
    DWORD i;
    CHAR Buffer[1024];
    ULONG Length, Size;

    Length = 0;
    Buffer[Length++] = (BYTE)RecordTypeDbEntry;
    
    CopyMemory(
        &Buffer[Length], (PVOID)&IpAddressNetOrder, sizeof(DWORD) );
    Length += sizeof(DWORD);
    
    CopyMemory(
        &Buffer[Length], (PVOID)&SubnetMaskNetOrder, sizeof(DWORD) );
    Length += sizeof(DWORD);

    Buffer[Length++] = (BYTE)HwLen;
    CopyMemory(&Buffer[Length], HwAddr, HwLen );
    Length += HwLen;
    
    if( NULL == MachineName || 0 == *MachineName ) Size = 0;
    else Size = sizeof(WCHAR)*(1+wcslen(MachineName));

    CopyMemory(&Buffer[Length], (PVOID)&Size, sizeof(DWORD));
    Length += sizeof(DWORD);
    CopyMemory(&Buffer[Length], (PVOID)MachineName, Size );
    Length += Size;
    
    if( NULL == MachineInfo || 0 == *MachineInfo ) Size = 0;
    else Size = sizeof(WCHAR)*(1+wcslen(MachineInfo));

    CopyMemory(&Buffer[Length], (PVOID)&Size, sizeof(DWORD));
    Length += sizeof(DWORD);
    CopyMemory(&Buffer[Length], (PVOID)MachineInfo, Size );
    Length += Size;

    CopyMemory(&Buffer[Length], (PVOID)&ExpirationFileTime, sizeof(ULONGLONG));
    Length += sizeof(ULONGLONG);
    Buffer[Length++] = State;
    Buffer[Length++] = ClientType;

    return AddRecord( Buffer, Length );
}

DWORD
AddScannedMadcapClient(
    IN DWORD IpAddressNetOrder,
    IN DWORD ScopeIdNetOrder,
    IN LPBYTE ClientId,
    IN ULONG HwLen,
    IN LPWSTR MachineInfo,
    IN ULONGLONG ExpirationFileTime,
    IN ULONGLONG StartFileTime,
    IN BYTE State
    )
{
    DWORD i;
    CHAR Buffer[1024];
    ULONG Length, Size;

    Length = 0;
    Buffer[Length++] = (BYTE)RecordTypeMcastDbEntry;
    
    CopyMemory(
        &Buffer[Length], (PVOID)&IpAddressNetOrder, sizeof(DWORD) );
    Length += sizeof(DWORD);
    
    CopyMemory(
        &Buffer[Length], (PVOID)&ScopeIdNetOrder, sizeof(DWORD) );
    Length += sizeof(DWORD);

    Buffer[Length++] = (BYTE)HwLen;
    CopyMemory(&Buffer[Length], ClientId, (BYTE)HwLen );
    Length += (BYTE)HwLen;

    if( NULL == MachineInfo || 0 == *MachineInfo ) Size = 0;
    else Size = sizeof(WCHAR)*(1+wcslen(MachineInfo));

    CopyMemory(&Buffer[Length], (PVOID)&Size, sizeof(DWORD));
    Length += sizeof(DWORD);
    CopyMemory(&Buffer[Length], (PVOID)MachineInfo, Size );
    Length += Size;
    
    CopyMemory(&Buffer[Length], (PVOID)&ExpirationFileTime, sizeof(ULONGLONG));
    Length += sizeof(ULONGLONG);

    CopyMemory(&Buffer[Length], (PVOID)&StartFileTime, sizeof(ULONGLONG));
    Length += sizeof(ULONGLONG);
    
    Buffer[Length++] = State;

    return AddRecord( Buffer, Length );
}


DWORD static
ScanDatabase(
    VOID
    )
{
    LONG Error;
    DWORD Count;
    
    Error = JetSetCurrentIndex(
        JetSession, JetTbl, NULL );

    if( Error ) DebugLog(Winnt32LogError, MSGERR_SETINDEX, Error );
    if( Error < 0 ) return Error;

    Error = JetMove( JetSession, JetTbl, JET_MoveFirst, 0 );

    for( Count = 0 ; Error >= 0 ; Count ++,
         Error = JetMove(JetSession, JetTbl, JET_MoveNext, 0) ) {
        
        DWORD IpAddress, SubnetMask, Size, HwLen;
        FILETIME Expiration;
        CHAR HwAddress[256];
        WCHAR MachineName[300], MachineInfo[300];
        BYTE Type, State;
        
        //
        // Get current client's info.
        //

        Size = sizeof(IpAddress);
        Error = GetColumnValue(
            IPADDRESS_INDEX, (PVOID)&IpAddress, &Size );

        if( NO_ERROR != Error ) break;
        if( Size != sizeof(IpAddress) ) {
            DebugLog(Winnt32LogError, MSGERR_INVALIDIP );
            continue;
        }
        
        Size = sizeof(SubnetMask);
        Error = GetColumnValue(
            SUBNET_MASK_INDEX, (PVOID)&SubnetMask, &Size );

        if( NO_ERROR != Error ) break;
        if( Size != sizeof(SubnetMask) ) {
            DebugLog(Winnt32LogError, MSGERR_INVALIDMASK );
            continue;
        }

        HwLen = sizeof(HwAddress);
        Error = GetColumnValue(
            HARDWARE_ADDRESS_INDEX, (PVOID)HwAddress, &HwLen );
        if( NO_ERROR != Error ) break;

        Size = sizeof(MachineName);
        Error = GetColumnValue(
            MACHINE_NAME_INDEX, (PVOID)MachineName, &Size );
        if( NO_ERROR != Error ) break;

        if( (Size % 2) != 0 ) {
            DebugLog(Winnt32LogError, MSGERR_INVALIDNAME );
            continue;
        }

        MachineName[Size/2] = L'\0';

        Size = sizeof(MachineInfo);
        Error = GetColumnValue(
            MACHINE_INFO_INDEX, (PVOID)MachineInfo, &Size );
        if( NO_ERROR != Error ) break;

        if( (Size % 2) != 0 ) {
            DebugLog(Winnt32LogError, MSGERR_INVALIDINFO );
            continue;
        }

        MachineInfo[Size/2] = L'\0';

        Size = sizeof(Expiration);
        Error = GetColumnValue(
            LEASE_TERMINATE_INDEX, (PVOID)&Expiration, &Size );
        if( NO_ERROR != Error ) break;

        if( Size != sizeof(Expiration) ) {
            DebugLog(Winnt32LogError, MSGERR_INVALIDEXPIRATION );
            Error = ERROR_INVALID_DATA;
            break;
        }

        Size = sizeof(Type);
        Error = GetColumnValue(
            CLIENT_TYPE_INDEX, (PVOID)&Type, &Size );

        if( NO_ERROR != Error || 0 == Size ) {
            Type = CLIENT_TYPE_DHCP;
        }

        Size = sizeof(State);
        Error = GetColumnValue(
            STATE_INDEX, (PVOID)&State, &Size );

        if( NO_ERROR != Error || 0 == Size ) {
            State = ADDRESS_STATE_ACTIVE;
        }

        if( ADDRESS_STATE_OFFERED == State ) {
            continue;
        }
        
        //
        // Try to add the client
        //

        Error = AddScannedClient(
            ByteSwap(IpAddress), ByteSwap(SubnetMask), HwAddress, HwLen,
            MachineName, MachineInfo, *(PULONGLONG)&Expiration,
            State, Type ); 
        
        if( NO_ERROR != Error ) break;
    }

    DebugLog( Winnt32LogInformation, MSGERR_SCANCOUNT, Count );
    
    if( JET_errNoCurrentRecord == Error ) return NO_ERROR;
    if( Error < 0 ) return Error;
    return NO_ERROR;
}

DWORD
ScanMadcapDatabase(
    VOID
    )
{
    LONG Error;
    DWORD Count;

    if( 0 == MadcapTbl ) return NO_ERROR;
    
    Error = JetSetCurrentIndex(
        JetSession, MadcapTbl, NULL );

    if( Error ) DebugLog(Winnt32LogError, MSGERR_SETMINDEX, Error );
    if( Error < 0 ) return Error;

    Error = JetMove( JetSession, MadcapTbl, JET_MoveFirst, 0 );

    for( Count = 0 ; Error >= 0 ; Count ++,
         Error = JetMove(JetSession, MadcapTbl, JET_MoveNext, 0) ) {

        DWORD IpAddress, ScopeId, Size, HwLen;
        FILETIME Expiration, Start;
        CHAR ClientId[300];
        WCHAR ClientInfo[300], MachineInfo[300];
        BYTE State;
        
        //
        // Get current client's info.
        //

        Size = sizeof(IpAddress);
        Error = GetMadcapColumnValue(
            MCAST_TBL_IPADDRESS, (PVOID)&IpAddress, &Size );

        if( NO_ERROR != Error ) break;
        if( Size != sizeof(IpAddress) ) {
            DebugLog(Winnt32LogError, MSGERR_INVALIDMIP );
            continue;
        }
        
        Size = sizeof(ScopeId);
        Error = GetMadcapColumnValue(
            MCAST_TBL_SCOPE_ID, (PVOID)&ScopeId, &Size );

        if( NO_ERROR != Error ) break;
        if( Size != sizeof( ScopeId ) ) {
            DebugLog(Winnt32LogError, MSGERR_INVALIDSCOPEID);
            continue;
        }

        HwLen = sizeof(ClientId);
        Error = GetMadcapColumnValue(
            MCAST_TBL_CLIENT_ID, (PVOID)ClientId, &HwLen );
        if( NO_ERROR != Error ) break;


        Size = sizeof(MachineInfo);
        Error = GetMadcapColumnValue(
            MCAST_TBL_CLIENT_INFO, (PVOID)MachineInfo, &Size );
        if( NO_ERROR != Error ) break;

        if( (Size % 2) != 0 ) {
            DebugLog(Winnt32LogError, MSGERR_INVALIDINFO );
            continue;
        }

        MachineInfo[Size/2] = L'\0';
        Size = sizeof(Expiration);
        Error = GetMadcapColumnValue(
            MCAST_TBL_LEASE_END, (PVOID)&Expiration, &Size );
        if( NO_ERROR != Error ) break;

        if( Size != sizeof(Expiration) ) {
            DebugLog(Winnt32LogError, MSGERR_INVALIDMEXPIRATION );
            Error = ERROR_INVALID_DATA;
            break;
        }


        Size = sizeof(Start);
        Error = GetMadcapColumnValue(
            MCAST_TBL_LEASE_START, (PVOID)&Start, &Size );
        LogError( ScanMadcapDatabase, GetLeaseExpiration );
        if( NO_ERROR != Error ) break;

        if( Size != sizeof(Start) ) {
            DebugLog(Winnt32LogError, MSGERR_INVALIDMSTART );
            Error = ERROR_INVALID_DATA;
            break;
        }
        
        
        Size = sizeof(State);
        Error = GetMadcapColumnValue(
            MCAST_TBL_STATE, (PVOID)&State, &Size );
        if( NO_ERROR != Error ) break;
        
        //
        // Try to add the client
        //

        Error = AddScannedMadcapClient(
            ByteSwap(IpAddress), ByteSwap(ScopeId), ClientId, HwLen,
            MachineInfo, *(PULONGLONG)&Expiration,
            *(PULONGLONG)&Start, State ); 
        if( NO_ERROR != Error ) break;
    }

    DebugLog( Winnt32LogInformation, MSGERR_SCANMCOUNT, Count );

    if( JET_errNoCurrentRecord == Error ) return NO_ERROR;
    if( Error < 0 ) return Error;
    return NO_ERROR;
}

DWORD
DumpData(
    IN LPSTR Buffer,
    IN ULONG BufSize
    )
{
    return NO_ERROR;
}

DWORD
AddRecord(
    IN LPSTR Buffer,
    IN ULONG BufSize
    )
{
    DWORD Written, Error = NO_ERROR;

    if( NULL != Buffer ) {
        CopyMemory(&SaveBuf[SaveBufSize], (PVOID)&BufSize, sizeof(DWORD));
        CopyMemory(&SaveBuf[SaveBufSize+sizeof(DWORD)], Buffer, BufSize );
    } else {
        if( 0 == SaveBufSize ) return NO_ERROR;
        if( FALSE == WriteFile(
            hTextFile, SaveBuf, SaveBufSize, &Written, NULL ) ) {
            return GetLastError();
        }

        if( Written != SaveBufSize ) {
            ASSERT(FALSE);
            return ERROR_CAN_NOT_COMPLETE;
        }

        return NO_ERROR;
    }
    
    if( SaveBufSize <= SAVE_THRESHOLD ) {
        SaveBufSize += BufSize + sizeof(DWORD);
    } else {
        if( FALSE == WriteFile(
            hTextFile, SaveBuf, SaveBufSize + BufSize + sizeof(DWORD),
            &Written, NULL )) {
            return GetLastError();
        }

        if( Written != SaveBufSize + BufSize + sizeof(DWORD) ) {
            ASSERT(FALSE);
            return ERROR_CAN_NOT_COMPLETE;
        }
        
        SaveBufSize = 0;
    }

    return Error;
}

DWORD
OpenTextFile(
    BOOL fRead
    )
{
    CHAR FileName[4096];
    DWORD Error, Flags;
    
    strcpy(FileName, DatabasePath);
    if( DatabasePath[strlen(DatabasePath)-1] != '\\' ) {
        strcat(FileName, "\\dhcpdb.txt" );
    } else {
        strcat(FileName, "dhcpdb.txt");
    }

    Flags = FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN;

    hTextFile = CreateFileA(
        FileName, GENERIC_READ | GENERIC_WRITE | DELETE,
        FILE_SHARE_READ, NULL,
        fRead ? OPEN_EXISTING : CREATE_ALWAYS,
        Flags, NULL );

    if( hTextFile == INVALID_HANDLE_VALUE ) {
        hTextFile = NULL;
        Error = GetLastError();
        if( !fRead || ERROR_FILE_NOT_FOUND != Error ) { 
            DebugLog( Winnt32LogError, MSGERR_CREATE_FILE_FAILED, Error);
        }
        return Error;
    }

    if( !fRead ) return NO_ERROR;

    LoSize = GetFileSize( hTextFile, &HiSize );
    if( -1 == LoSize && NO_ERROR != GetLastError() ) {
        return GetLastError();
    }

    if( LoSize == 0 && HiSize == 0 ) return NO_ERROR;
    
    hMapping = CreateFileMapping(
        hTextFile, NULL, PAGE_READONLY | SEC_COMMIT, HiSize, LoSize,
        NULL );
    if( NULL == hMapping ) {
        Error = GetLastError();
        DebugLog( Winnt32LogError, MSGERR_CREATE_MAP, Error );
        return Error;
    }

    FileView = MapViewOfFile(
        hMapping, FILE_MAP_READ, 0, 0, 0 );

    if( NULL == FileView ) {
        Error = GetLastError();
        DebugLog( Winnt32LogError, MSGERR_CREATE_VIEW, Error );
        return Error;
    }
    
    return NO_ERROR;
}

DWORD
StopDhcpService(
    VOID
    )
{
    SC_HANDLE hSc, hSvc;
    DWORD Error;

    Error = NO_ERROR;
    hSc = NULL;
    hSvc = NULL;
    
    do {
        hSc = OpenSCManager(
            NULL, NULL, SC_MANAGER_CONNECT | GENERIC_WRITE | GENERIC_WRITE );
        if( NULL == hSc ) {
            Error = GetLastError();

            DebugLog( Winnt32LogError, MSGERR_OPENSCM, Error );
            break;
        }

        hSvc = OpenService(
            hSc, TEXT("DHCPServer"), SERVICE_STOP| SERVICE_QUERY_STATUS );
        if( NULL == hSvc ) {
            Error = GetLastError();

            DebugLog( Winnt32LogError, MSGERR_OPENSVC, Error );
            break;
        }

        while( NO_ERROR == Error ) {
            SERVICE_STATUS Status;

            if( FALSE == QueryServiceStatus( hSvc, &Status ) ) {
                Error = GetLastError();
                DebugLog( Winnt32LogError, MSGERR_SVCQUERY, Error );
                break;
            }

            if( Status.dwCurrentState == SERVICE_STOPPED ) break;
            if( Status.dwCurrentState != SERVICE_RUNNING &&
                Status.dwCurrentState != SERVICE_PAUSED ) {
                DebugLog( Winnt32LogInformation, MSGERR_SVCWAIT,
                          Status.dwCurrentState );

                if( Status.dwWaitHint < 1000 ) {
                    Status.dwWaitHint = 1000;
                }
                
                Sleep(Status.dwWaitHint);
            } else {
                Error = ControlService(
                    hSvc, SERVICE_CONTROL_STOP, &Status );
                if( FALSE != Error ) Error = NO_ERROR;
                else {
                    Error = GetLastError();
                    DebugLog( Winnt32LogError, MSGERR_SVCCTRL, Error );
                    break;
                }
            }
        }
    } while( 0 );

    if( NO_ERROR == Error ) {
        DebugLog( Winnt32LogInformation, MSGERR_SVCSTOP_SUCCESS );
    } 
    
    if( NULL != hSvc ) CloseServiceHandle( hSvc );
    if( NULL != hSc ) CloseServiceHandle( hSc );
    
    return Error;
}

BOOL
UpgradeNotNeeded(
    VOID
    )
{
    HKEY hKey;
    DWORD Error, Type, Value, Size;

    
    Error = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        TEXT("SYSTEM\\CurrentControlSet\\Services\\DHCPServer\\Parameters"),
        0, KEY_READ, &hKey );

    if( NO_ERROR != Error ) return FALSE;

    Type = REG_DWORD; Value = 0; Size = sizeof(Value);
    Error = RegQueryValueEx(
        hKey, TEXT("Version"), NULL, &Type, (PVOID)&Value, &Size );

    RegCloseKey( hKey );

    //
    // if this value is not present, then upgrade is needed
    //
    
    return (Error == NO_ERROR );
}

DWORD __stdcall
DhcpUpgConvertDhcpDbToTemp(
    VOID
    )
{
    DWORD Error;
    DWORD clusState;
    DWORD Error1 = ERROR_SUCCESS;
    GetClusterStateFn pGetClusterStateFn = NULL;
    HINSTANCE hLib;

    LastError = NO_ERROR;
    if( UpgradeNotNeeded() ) return NO_ERROR;

    Error = GetCurrentDirectoryW(
        sizeof(Winnt32Path)/sizeof(WCHAR), Winnt32Path );
    if( 0 != Error ) {
        Error = NO_ERROR;
    } else {
        Error = GetLastError();
        return Error;
    }
    
    SaveBuf = LocalAlloc(LPTR, SAVE_BUF_SIZE);
    if( NULL == SaveBuf ) {
        return GetLastError();
    }

    SaveBufSize = 0;
    Error = NO_ERROR;
    
    StartDebug();
    DebugLog( Winnt32LogInformation, MSGERR_STARTLOG );
    
    do {
        Error = StopDhcpService();
        if( NO_ERROR != Error ) break;
        
        Error = InitializeDatabase();
        if( NO_ERROR != Error ) break;

        Error = OpenTextFile(FALSE);
        if( NO_ERROR != Error ) break;
        
        Error = ScanDatabase();
        if( NO_ERROR != Error ) break;

        Error = ScanMadcapDatabase();
        if( NO_ERROR != Error ) break;

        Error = AddRecord( NULL, 0 );
        
    } while( 0 );

    if( NULL != SaveBuf ) {
        LocalFree( SaveBuf );
        SaveBuf = 0;
    }

    CleanupDatabase();

    if( NULL != hTextFile ) CloseHandle( hTextFile );
    hTextFile = NULL;


    //
    // if the error code is ERROR_BUSY, it could be a cluster node
    // that doesnt have access to the db. Check if this is the case.
    //

    if ( ERROR_BUSY == Error )
    {
        
        hLib = LoadLibrary( L"clusapi.dll" );

        if ( hLib != NULL )
        {
            pGetClusterStateFn = (GetClusterStateFn)GetProcAddress( hLib, "GetNodeClusterState" );

        }

        if ( pGetClusterStateFn != NULL )
        {
            Error1 = pGetClusterStateFn( NULL, &clusState );

            if ( Error1 == ERROR_SUCCESS )
            {
                 if ( ( clusState & ClusterStateNotRunning ) ||
                      ( clusState & ClusterStateRunning ) )
                {

                    //
                    // the error code remains the same if the above 
                    // condition is not met.
                    //

                    Error = ERROR_SUCCESS;
                }
            }
         }

        if ( hLib != NULL )
        {
            FreeLibrary( hLib );
        }        

    }

    //
    // If the service never existed, not much to do
    //
    
    if( ERROR_SERVICE_DOES_NOT_EXIST == Error ) Error = NO_ERROR;
    
    if( NO_ERROR != Error ) {
        DebugLog( Winnt32LogError, MSGERR_CONVERT_FAILED, Error );
    } else {
        DebugLog( Winnt32LogInformation, MSGERR_CONVERT_SUCCEEDED );
    }

    CloseDebugLog();

    if( FALSE == SetCurrentDirectoryW(Winnt32Path) ) {
        if( NO_ERROR == Error ) Error = GetLastError();
    }
    
    LastError = Error;
    return NO_ERROR;
}


VOID
DeleteDatabaseTempFile(
    VOID
    )
{
    CHAR FileName[4096];
    DWORD Error;

    //
    // Attempt to delete the temporary database stuff
    //

    
    strcpy(FileName, DatabasePath);
    if( DatabasePath[strlen(DatabasePath)-1] != '\\' ) {
        strcat(FileName, "\\dhcpdb.txt" );
    } else {
        strcat(FileName, "dhcpdb.txt");
    }

    if( FALSE == DeleteFileA( FileName ) ) {
        Error = GetLastError();

        DebugLog(
            Winnt32LogError, MSGERR_DELETEFILE, Error );
    }
}

VOID
FixRegistryAndDeleteFiles(
    VOID
    )
{
    DWORD Error;
    HKEY hKey;
    
    //
    // Attempt to write the version key
    //
    
    Error = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        TEXT("SYSTEM\\CurrentControlSet\\Services\\DHCPServer\\Parameters"),
        0, KEY_WRITE, &hKey );

    if( NO_ERROR != Error ) {
        DebugLog(
            Winnt32LogError, MSGERR_OPENPARAMSKEY, Error );
    } else {
        DWORD Version = 0, Size = sizeof(Version);

        Error = RegSetValueEx(
            hKey, TEXT("Version"), 0, REG_DWORD, (PVOID)&Version,
            Size );
        if( NO_ERROR != Error ) {
            DebugLog(
                Winnt32LogError, MSGERR_SETVALUE, Error );
        }

        RegCloseKey( hKey );
    }

    DeleteDatabaseTempFile();
}

DWORD __stdcall PrintRecord(
    IN PDHCP_RECORD Recx
    )
{
    DWORD i;
    DHCP_RECORD Rec = *Recx;
    
    if( Rec.fMcast ) {
        printf("Mcast Record\n" );
        printf("Address: %s\n", IpAddressToString(
            Rec.Info.Mcast.Address ));
        printf("ScopeId: %s\n", IpAddressToString(
            Rec.Info.Mcast.ScopeId ));

        printf("ClientId:");
        for( i = 0 ; i < (DWORD)Rec.Info.Mcast.HwLen; i ++ ) {
            printf(" %02X", Rec.Info.Mcast.ClientId[i]);
        }
        printf("\nState = %02X\n", Rec.Info.Mcast.State);
        
    } else {
        printf("DHCP Record\n" );
        printf("Address: %s\n", IpAddressToString(
            Rec.Info.Dhcp.Address ));
        printf("Mask: %s\n", IpAddressToString(
            Rec.Info.Dhcp.Mask ));

        printf("ClientId:");
        for( i = 0 ; i < (DWORD)Rec.Info.Dhcp.HwLen; i ++ ) {
            printf(" %02X", Rec.Info.Dhcp.HwAddr[i]);
        }
        printf("\nState = %02X\n", Rec.Info.Dhcp.State);
        printf("\nType = %02X\n", Rec.Info.Dhcp.Type);
        if( Rec.Info.Dhcp.Name ) {
            printf("Name = %ws\n", Rec.Info.Dhcp.Name );
        }

        if( Rec.Info.Dhcp.Info ) {
            printf("Comment = %ws\n", Rec.Info.Dhcp.Info );
        }
    }

    return NO_ERROR;
}
        
DWORD
ProcessDbEntries(
    IN LPSTR Buffer,
    IN ULONG BufSize,
    IN DHCP_ADD_RECORD_ROUTINE AddRec
    )
{
    DWORD Size, ThisSize, DbEntry;
    LPSTR Buf;
    DWORD Address, i, Error;
    FILETIME Time;
    DHCP_RECORD Rec;

    Error = NO_ERROR;
    
    while( BufSize > sizeof(DWORD) ) {
        CopyMemory(&ThisSize, Buffer, sizeof(DWORD));
        Buffer += sizeof(DWORD);
        BufSize -= sizeof(DWORD);

        if( ThisSize > BufSize ) return ERROR_INVALID_DATA;
        if( ThisSize == 0 ) continue;
        DbEntry = *Buffer;
        Buf = Buffer+1;
        Buffer += ThisSize;
        BufSize -= ThisSize;

        ZeroMemory( &Rec, sizeof(Rec));

        switch(DbEntry) {
        default :
            return ERROR_INVALID_DATA;
            
        case RecordTypeDbEntry :
            Rec.fMcast = FALSE;
            CopyMemory( &Rec.Info.Dhcp.Address, Buf, sizeof(DWORD));
            Buf += sizeof(DWORD);

            CopyMemory( &Rec.Info.Dhcp.Mask, Buf, sizeof(DWORD));
            Buf += sizeof(DWORD);

            Size = Rec.Info.Dhcp.HwLen = *Buf++;
            Rec.Info.Dhcp.HwAddr = Buf;
            Buf += Size;

            CopyMemory(&Size, Buf, sizeof(DWORD));
            Buf += sizeof(DWORD);
            if( Size ) {
                Rec.Info.Dhcp.Name = (PVOID)Buf;
                Buf += Size;
            }

            CopyMemory(&Size, Buf, sizeof(DWORD));
            Buf += sizeof(DWORD);
            if( Size ) {
                Rec.Info.Dhcp.Info = (PVOID)Buf;
                Buf += Size;
            }

            CopyMemory(&Rec.Info.Dhcp.ExpTime, Buf, sizeof(FILETIME));
            Buf += sizeof(FILETIME);

            Rec.Info.Dhcp.State = Buf[0];
            Rec.Info.Dhcp.Type = Buf[1];

            Error = AddRec( &Rec );
            
            break;
        case RecordTypeMcastDbEntry :
            Rec.fMcast = TRUE;
            
            CopyMemory( &Rec.Info.Mcast.Address, Buf, sizeof(DWORD));
            Buf += sizeof(DWORD);

            CopyMemory( &Rec.Info.Mcast.ScopeId, Buf, sizeof(DWORD));
            Buf += sizeof(DWORD);

            Size = Rec.Info.Mcast.HwLen = *Buf++;
            Rec.Info.Mcast.ClientId = Buf;
            Buf += Size;

            CopyMemory(&Size, Buf, sizeof(DWORD));
            Buf += sizeof(DWORD);
            if( Size ) {
                Rec.Info.Mcast.Info = (PVOID)Buf;
                Buf += Size;
            }

            CopyMemory(&Rec.Info.Mcast.End, Buf, sizeof(FILETIME));
            Buf += sizeof(FILETIME);

            CopyMemory(&Rec.Info.Mcast.Start, Buf, sizeof(FILETIME));
            Buf += sizeof(FILETIME);

            Rec.Info.Mcast.State = Buf[0];

            Error = AddRec( &Rec );
            break;
        }

        if( NO_ERROR != Error ) return Error;
    }

    return NO_ERROR;
}


DWORD __stdcall
DhcpUpgConvertTempToDhcpDb(
    IN DHCP_ADD_RECORD_ROUTINE AddRec
    )
{
    DWORD Error;

    if( UpgradeNotNeeded() ) return NO_ERROR;

    if( NULL == AddRec ) {
        //
        // If caller didn't specify, then the intention is to
        // just get us to dump.. so just print the stuff out.
        //

        AddRec = PrintRecord;
    }
    
    Error = NO_ERROR;
    
    StartDebug();
    DebugLog( Winnt32LogInformation, MSGERR_STARTLOG2 );
    
    do {
        Error = ReadRegistry();
        if( NO_ERROR != Error ) break;
        
        Error = OpenTextFile(TRUE);
        if( NO_ERROR != Error ) {
            if( ERROR_FILE_NOT_FOUND == Error ) {
                Error = NO_ERROR;
            }
            
            break;
        }

        //
        // Walk through the database-text and parse the fields out
        //

        Error = ProcessDbEntries(
            FileView, LoSize, AddRec
            );
        
    } while( 0 );

    if( NULL != FileView ) UnmapViewOfFile( FileView );
    FileView = NULL;

    if( NULL != hMapping ) CloseHandle( hMapping );
    hMapping = NULL;
    
    if( NULL != hTextFile ) CloseHandle( hTextFile );
    hTextFile = NULL;
    
    if( NO_ERROR != Error ) {
        DebugLog( Winnt32LogError, MSGERR_CONVERT_FAILED, Error );
    } else {
        //
        // Whack the registry keys
        //

        FixRegistryAndDeleteFiles();
        DebugLog( Winnt32LogInformation, MSGERR_CONVERT_SUCCEEDED );
    }

    CloseDebugLog();
    
    return Error;
}
    
DWORD __stdcall
DhcpUpgGetLastError(
    VOID
    )
{
    return LastError;
}

DWORD __stdcall
DhcpUpgCleanupDhcpTempFiles(
    VOID
    )
{
    DWORD Error;
    
    //
    // This routine is supposed to delete the special dhcp
    // database file because the operation was cancelled.
    //

    if( UpgradeNotNeeded() ) return NO_ERROR;
    StartDebug();

    Error = ReadRegistry();
    if( NO_ERROR == Error ) {
        
        DeleteDatabaseTempFile();
    }

    CloseDebugLog();

    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dhcp\server\upgrade\upgrade.h ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    upgrade.h

Abstract:

    precompiled header.
    
--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntseapi.h>
#include <windows.h>
#include <time.h>
#include <esent.h>
#include <stdio.h>
#include <winsock.h>
#include <shellapi.h>
#include <tchar.h>
#include <winsvc.h>
#include <setupapi.h>
#include <oemupgex.h>
#include <accctrl.h>
#include <msgs.h>
#include <dhcpupg.h>
#include <clusapi.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\bindings.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      bindings.c
//
//  Abstract:
//
//      Queries into network drivers
//
//  Author:
//
//      Anilth  - 4-20-1998
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//--
#include "precomp.h"

#undef IsEqualGUID
#include "bindings.h"


HRESULT
BindingsTest(NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
//++
// Description:
// This Test uses the INetCfg COM interface to get the bingings.
// COM Interface is accessed using C, not C++.
//
// Arguments:
// None.
//
// Author:
// Rajkumar .P ( 07/17/98 )
//
//--
{
    INetCfg* pINetCfg = NULL;
    INetCfgClass *pINetCfgClass = NULL;
    IEnumNetCfgComponent *pIEnumNetCfgComponent = NULL;
    INetCfgComponent *pINetCfgComponent = NULL;
    INetCfgComponentBindings *pINetCfgComponentBindings = NULL;
    IEnumNetCfgBindingPath *pEnumNetCfgBindingPath = NULL;
    INetCfgBindingPath *pINetCfgBindingPath = NULL;
    IEnumNetCfgBindingInterface *pIEnumNetCfgBindingInterface = NULL;
    INetCfgBindingInterface *pINetBindingInterface = NULL;
    INetCfgComponent *pUpperComponent = NULL;
    INetCfgComponent *pLowerComponent = NULL;
    INetCfgComponent *pOwner = NULL;


    HRESULT hr;
    wchar_t *pszwDisplayName;
    wchar_t *pszwBindName;
    wchar_t *pszwDescription;
    wchar_t *pszwInterfaceName;
    wchar_t *pszwUpperComponent;
    wchar_t *pszwLowerComponent;
    wchar_t *pszwOwner;

    TCHAR szBuffer[512];

    DWORD dwPathId;
    int i;

    PrintStatusMessage( pParams, 4, IDS_BINDINGS_STATUS_MSG );

    InitializeListHead( &pResults->Bindings.lmsgOutput );

    // Only do this test if in really verbose mode
    if (!pParams->fReallyVerbose)
        return S_OK;

    //  Initialize the COM library
    CoInitialize(NULL);

    hr = CoCreateInstance(&CLSID_NetCfg,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          &IID_INetCfg,
                          (void**)&pINetCfg) ;


    if(FAILED(hr))
    {
        DebugMessage("CreateInstance for IID_INetCfg failed\n");
        goto end_BindingsTest;
    }

    hr = pINetCfg->lpVtbl->Initialize(pINetCfg, NULL);

    if(FAILED(hr))
    {
        DebugMessage("pINetCfg->Initialize failed.\n");
        goto end_BindingsTest;
    }



    for ( i = 0; i < MAX_CLASS_GUID ; i++ )
    {

        hr = pINetCfg->lpVtbl->QueryNetCfgClass(pINetCfg,
                                          c_pNetClassGuid[i].pGuid,
                                          &IID_INetCfgClass, // This arg is undocumented
                                          &pINetCfgClass
                                         );

        if(FAILED(hr))
        {
            DebugMessage("QueryNetCfgClass failed\n");
            goto end_BindingsTest;
        }

        hr = pINetCfgClass->lpVtbl->EnumComponents(pINetCfgClass,
                                            &pIEnumNetCfgComponent);

        pINetCfgClass->lpVtbl->Release(pINetCfgClass);
        pINetCfgClass = NULL;

        if(FAILED(hr))
        {
            DebugMessage("EnumComponents failed\n");
            goto end_BindingsTest;
        }

        // pIEnumNetCfgComponent is a standard COM enumerator

        while (S_OK == pIEnumNetCfgComponent->lpVtbl->Next(pIEnumNetCfgComponent,1,&pINetCfgComponent,NULL))
        {
            HRESULT hrTmp;

            hrTmp = pINetCfgComponent->lpVtbl->GetDisplayName(pINetCfgComponent,
                                          (LPWSTR *)&pszwDisplayName
                                          );


            if (hrTmp == S_OK)
            {
                WideCharToMultiByte(CP_ACP, 0, pszwDisplayName, -1, szBuffer, sizeof(szBuffer), NULL, NULL);
                //IDS_BINDINGS_14801                  "Component Name : %s\n"
                AddMessageToList(&pResults->Bindings.lmsgOutput, Nd_ReallyVerbose, IDS_BINDINGS_14801, szBuffer);
                CoTaskMemFree(pszwDisplayName);
            }

            hrTmp = pINetCfgComponent->lpVtbl->GetBindName(pINetCfgComponent,
                                               (LPWSTR *)&pszwBindName);

            if ( SUCCEEDED(hrTmp) )
            {
                WideCharToMultiByte(CP_ACP, 0, pszwBindName, -1, szBuffer, sizeof(szBuffer), NULL, NULL);
                //IDS_BINDINGS_14802                  "Bind Name: %s\n"
                AddMessageToList(&pResults->Bindings.lmsgOutput, Nd_ReallyVerbose, IDS_BINDINGS_14802, szBuffer);
//$REVIEW nsun: maybe we should use SysFreeString to free the buffer
                CoTaskMemFree(pszwBindName);
            }

//
//  This function though found in doc , is not yet available
//

/*
                        hrTmp = pINetCfgComponent->lpVtbl->GetDescriptionText(pINetCfgComponent,
                                                              (LPWSTR *)&pszwDescription);

                        if (hrTmp == S_OK) {
                            WideCharToMultiByte(CP_ACP, 0, pszwBindName, -1, szBuffer, sizeof(szBuffer), NULL, NULL);
//IDS_BINDINGS_14804                  "Description: %s\n"
                            wsPrintMessage(&pResults->Bindings.lmsgOutput, IDS_BINDINGS_14804,pszwDescription);
                            CoTaskMemFree(pszwDescription);
                        }
*/

            AddMessageToListSz(&pResults->Bindings.lmsgOutput, Nd_ReallyVerbose, _T("    Binding Paths:\n"));
            hrTmp = pINetCfgComponent->lpVtbl->QueryInterface(pINetCfgComponent,
                                                  &IID_INetCfgComponentBindings,
                                                  &pINetCfgComponentBindings);

            pINetCfgComponent->lpVtbl->Release(pINetCfgComponent);
            pINetCfgComponent = NULL;

            if (FAILED(hrTmp)) 
                continue;

            hrTmp = pINetCfgComponentBindings->lpVtbl->EnumBindingPaths(pINetCfgComponentBindings,EBP_BELOW,&pEnumNetCfgBindingPath);

            pINetCfgComponentBindings->lpVtbl->Release(pINetCfgComponentBindings);
            pINetCfgComponentBindings = NULL;

            if (FAILED(hrTmp)) 
                continue;

            while ( S_OK == pEnumNetCfgBindingPath->lpVtbl->Next(pEnumNetCfgBindingPath, 1,&pINetCfgBindingPath,NULL))
            {
//
// Got some problems using these two calls - need to take this up with sumitc
//

                hrTmp = pINetCfgBindingPath->lpVtbl->GetOwner(pINetCfgBindingPath,
                                                   &pOwner);

                if ( SUCCEEDED(hrTmp) )
                {
                   hrTmp = pOwner->lpVtbl->GetDisplayName(pOwner,
                                                       &pszwOwner);

                   if (hrTmp == S_OK) {
                       WideCharToMultiByte(CP_ACP, 0, pszwOwner, -1, szBuffer, sizeof(szBuffer), NULL, NULL);
                       //IDS_BINDINGS_14805                  "Owner of the binding path : %s\n"
                       AddMessageToList(&pResults->Bindings.lmsgOutput, Nd_ReallyVerbose, IDS_BINDINGS_14805, szBuffer);
                       CoTaskMemFree(pszwOwner);
                   }
                }

                pOwner->lpVtbl->Release(pOwner);
                pOwner = NULL;

                hrTmp = pINetCfgBindingPath->lpVtbl->IsEnabled(pINetCfgBindingPath);

                if (hrTmp == S_OK)
                    //IDS_BINDINGS_14806                  "Binding Enabled: Yes\n"
                    AddMessageToListId(&pResults->Bindings.lmsgOutput, Nd_ReallyVerbose, IDS_BINDINGS_14806);
                else
                if (hrTmp == S_FALSE)
                    //IDS_BINDINGS_14807                  "Binding Enabled: No\n"
                    AddMessageToListId(&pResults->Bindings.lmsgOutput, Nd_ReallyVerbose, IDS_BINDINGS_14807);
                else
                if (hrTmp == NETCFG_E_NOT_INITIALIZED)
                    //IDS_BINDINGS_14808                  "Binding Enabled: Binding has not yet been intialized\n"
                    AddMessageToListId(&pResults->Bindings.lmsgOutput, Nd_ReallyVerbose, IDS_BINDINGS_14808);

                AddMessageToListSz(&pResults->Bindings.lmsgOutput, Nd_ReallyVerbose, _T("    Interfaces of the binding path: \n"));
                hrTmp = pINetCfgBindingPath->lpVtbl->EnumBindingInterfaces(
                                                   pINetCfgBindingPath,
                                                  &pIEnumNetCfgBindingInterface);

                pINetCfgBindingPath->lpVtbl->Release(pINetCfgBindingPath);
                pINetCfgBindingPath = NULL;

                if( FAILED(hrTmp) )
                {
                    DebugMessage("EnumBindingInterfaces failed\n" );
                    continue;
                }

                while ( S_OK == pIEnumNetCfgBindingInterface->lpVtbl->Next(pIEnumNetCfgBindingInterface,1,&pINetBindingInterface,NULL))
                {

                    hrTmp = pINetBindingInterface->lpVtbl->GetName(pINetBindingInterface,
                                                     &pszwInterfaceName);

                    if (hrTmp == S_OK)
                    {
                        WideCharToMultiByte(CP_ACP, 0, pszwInterfaceName, -1, szBuffer, sizeof(szBuffer), NULL, NULL);
                        //IDS_BINDINGS_14810                  "Interface Name: %s\n"
                        AddMessageToList(&pResults->Bindings.lmsgOutput, Nd_ReallyVerbose, IDS_BINDINGS_14810, szBuffer);
                        CoTaskMemFree(pszwInterfaceName);
                    }

                    hrTmp = pINetBindingInterface->lpVtbl->GetUpperComponent(
                                                   pINetBindingInterface,
                                                   &pUpperComponent);

                    if (hrTmp == S_OK)
                    {
                        pszwUpperComponent = NULL;

                        hrTmp = pUpperComponent->lpVtbl->GetDisplayName(
                                                pUpperComponent,
                                                &pszwUpperComponent);
                        
                        pUpperComponent->lpVtbl->Release(pUpperComponent);
                        pUpperComponent = NULL;

                        if (hrTmp == S_OK)
                        {
                            assert(pszwUpperComponent);
                            WideCharToMultiByte(CP_ACP, 0, pszwUpperComponent, -1, szBuffer, sizeof(szBuffer), NULL, NULL);
                            //IDS_BINDINGS_14811                  "Upper Component: %s\n"
                            AddMessageToList(&pResults->Bindings.lmsgOutput, Nd_ReallyVerbose, IDS_BINDINGS_14811, szBuffer);
                            CoTaskMemFree(pszwUpperComponent);
                        }

                    }

                    hrTmp = pINetBindingInterface->lpVtbl->GetLowerComponent(
                                                     pINetBindingInterface,
                                                     &pLowerComponent);

                    pINetBindingInterface->lpVtbl->Release(pINetBindingInterface);
                    pINetBindingInterface = NULL;

                    if (hrTmp == S_OK )
                    {
                        pszwLowerComponent = NULL;
                        hrTmp = pLowerComponent->lpVtbl->GetDisplayName(
                                                  pLowerComponent,
                                                  &pszwLowerComponent);

                        pLowerComponent->lpVtbl->Release(pLowerComponent);
                        pLowerComponent = NULL;

                        if (hrTmp == S_OK )
                        {
                            assert(pszwLowerComponent);
                            WideCharToMultiByte(CP_ACP, 0, pszwLowerComponent, -1, szBuffer, sizeof(szBuffer), NULL, NULL);
                            //IDS_BINDINGS_14812                  "Lower Component: %s\n"
                            AddMessageToList(&pResults->Bindings.lmsgOutput, Nd_ReallyVerbose, IDS_BINDINGS_14812, szBuffer);
                            CoTaskMemFree(pszwLowerComponent);
                        }
                    }
                }

                pIEnumNetCfgBindingInterface->lpVtbl->Release(pIEnumNetCfgBindingInterface);
                pIEnumNetCfgBindingInterface = NULL;

                AddMessageToList(&pResults->Bindings.lmsgOutput, Nd_ReallyVerbose, IDS_GLOBAL_EmptyLine);
            }

            AddMessageToList(&pResults->Bindings.lmsgOutput, Nd_ReallyVerbose, IDS_GLOBAL_EmptyLine);
            pEnumNetCfgBindingPath->lpVtbl->Release(pEnumNetCfgBindingPath);
            pEnumNetCfgBindingPath = NULL;
        }
        pIEnumNetCfgComponent->lpVtbl->Release(pIEnumNetCfgComponent);
        pIEnumNetCfgComponent = NULL;
     }
     pINetCfg->lpVtbl->Uninitialize(pINetCfg);
     pINetCfg->lpVtbl->Release(pINetCfg);


end_BindingsTest:

    // Unitialize COM Library
    CoUninitialize();
    pResults->Bindings.hrTestResult = hr;
    return hr;
}


void BindingsGlobalPrint(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults)
{
    if (pParams->fVerbose || !FHrOK(pResults->Bindings.hrTestResult))
    {
        PrintNewLine(pParams, 2);
        PrintTestTitleResult(pParams,
                             IDS_BINDINGS_LONG,
                             IDS_BINDINGS_SHORT,
                             TRUE,
                             pResults->Bindings.hrTestResult,
                             0);
    }

    PrintMessageList(pParams, &pResults->Bindings.lmsgOutput);
}


void BindingsPerInterfacePrint(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults, INTERFACE_RESULT *pInterfaceResults)
{
    //no pre interface print
}

void BindingsCleanup(IN NETDIAG_PARAMS *pParams,
                     IN OUT NETDIAG_RESULT *pResults)
{
    MessageListCleanUp(&pResults->Bindings.lmsgOutput);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\autonet.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      autonet.c
//
//  Abstract:
//
//      Queries into network drivers
//
//  Author:
//
//      Anilth  - 4-20-1998 
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//--
#include "precomp.h"
#include "dhcptest.h"


//$Review (nsun) Now we just print "Autonet address is in use" if autonet. 
// we don't send Dhcp broadcast.
// Maybe later we should send the Dhcp broadcast to see if the Dhcp server works or not
// for all DHCP enabled card
//-------------------------------------------------------------------------//
//######  A u t o n e t T e s t ()  #######################################//
//-------------------------------------------------------------------------//
HRESULT
AutonetTest(NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
//++
//
//  Routine Description:
//
//      Checks if we have autonet addresses on all adapters. If we do than 
//      the workstation couldn't reach a DHCP server on any adapters.
//      Potential HW or NDIS issue.
//    
//  Arguments:
//
//      None.
//
//  Return Value:
//
//      S_FALSE :   Test failed, all adapters are autoconfigure.
//      S_OK    :   Test succeeded, we found at least one non-autoconfigure.
//      other   :   error codes
//
//--
{
    PIP_ADAPTER_INFO pIpAdapterInfo;
    HRESULT         hr = S_FALSE;    // Assume that this will fail

    int i;

    PrintStatusMessage(pParams, 4, IDS_AUTONET_STATUS_MSG);

    //
    //  scan all adapters for a non-autonet address
    //

    for( i = 0; i < pResults->cNumInterfaces; i++)
    {
        pIpAdapterInfo = pResults->pArrayInterface[i].IpConfig.pAdapterInfo;
        //if this is not an active connection, skip it.
        
        if (!pResults->pArrayInterface[i].IpConfig.fActive ||
            NETCARD_DISCONNECTED == pResults->pArrayInterface[i].dwNetCardStatus)
            continue;

        if ( !pResults->pArrayInterface[i].IpConfig.fAutoconfigActive ) 
        {
            //$REVIEW (nsun) maybe we need to DhcpBroadcast(pIpAdapterInfo) here instead
            // of for the AutoNet adapters
            pResults->pArrayInterface[i].AutoNet.fAutoNet = FALSE;
            hr = S_OK;
            continue;
        }
        // Skip WAN Cards
        if ( ! strstr(pIpAdapterInfo->AdapterName,"NdisWan") ) 
            pResults->pArrayInterface[i].AutoNet.fAutoNet = TRUE;
    }

    if ( FHrOK(hr) )
    {
        PrintStatusMessage(pParams, 0, IDS_GLOBAL_PASS_NL);
        pResults->AutoNet.fAllAutoConfig = FALSE;
    }
    else
    {
        PrintStatusMessage(pParams, 0, IDS_GLOBAL_FAIL_NL);
        pResults->AutoNet.fAllAutoConfig = TRUE;
    }
    
    return hr;
} /* END OF AutonetTest() */




void AutonetGlobalPrint(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults)
{
    if (pParams->fVerbose || pResults->AutoNet.fAllAutoConfig)
    {
        PrintNewLine(pParams, 2);
        PrintTestTitleResult(pParams,
                             IDS_AUTONET_LONG,
                             IDS_AUTONET_SHORT,
                             TRUE,
                             pResults->AutoNet.fAllAutoConfig ?
                             S_FALSE : S_OK, 0);
    }

    if(pResults->AutoNet.fAllAutoConfig)
    {
        //IDS_AUTONET_11601                  "    [FATAL] All adapters are autoconfigured!\n" 
        PrintMessage(pParams,  IDS_AUTONET_11601 );
        //IDS_AUTONET_11602                  "    The DHCP servers are unreachable. Please check cables, hubs, and taps!\n\n" 
        PrintMessage(pParams,  IDS_AUTONET_11602 );
    }
    else
    {
        if (pParams->fReallyVerbose)
            //IDS_AUTONET_11603                  "    PASS - you have at least one non-autoconfigured IP address\n" 
            PrintMessage(pParams,  IDS_AUTONET_11603 );
    }
}


void AutonetPerInterfacePrint(NETDIAG_PARAMS *pParams, 
                              NETDIAG_RESULT *pResults, 
                              INTERFACE_RESULT *pInterfaceResults)
{
    if (!pInterfaceResults->IpConfig.fActive || 
        NETCARD_DISCONNECTED == pInterfaceResults->dwNetCardStatus)
        return;

    if (pParams->fVerbose)
    {
        //IDS_AUTONET_11604                  "        Autonet results : " 
        PrintMessage(pParams, IDS_AUTONET_11604);
        if(pInterfaceResults->AutoNet.fAutoNet)
        {
            PrintMessage(pParams, IDS_GLOBAL_FAIL_NL);
            //IDS_AUTONET_11605                  "            [WARNING] AutoNet is in use. DHCP not available!\n" 
            PrintMessage(pParams, IDS_AUTONET_11605);
        }
        else
        {
            PrintMessage(pParams, IDS_GLOBAL_PASS_NL);
            if(pParams->fReallyVerbose)
                //IDS_AUTONET_11606                  "            AutoNet is not in use. \n" 
                PrintMessage(pParams, IDS_AUTONET_11606);
        }
    }
}

void AutonetCleanup(IN NETDIAG_PARAMS *pParams, IN OUT NETDIAG_RESULT *pResults)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\brnames.h ===
/*++

Copyright (c) 1991 Microsoft Corporation

Module Name:

    wsnames.h

Abstract:

    Private header file which defines the Workstation names.

Author:

    Rita Wong (ritaw) 06-May-1991

Revision History:

--*/

#define BROWSER_INTERFACE_NAME    TEXT("browser")

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\bindings.h ===
/*--
Copyright (C) Microsoft Corporation, 1999 - 1999 

Module Name:
       
     bindings.h

Abstract:

     This file contains the includes, definitions , data structures and function prototypes
     needed for the bindings test.

Author:

     4-Aug-1998 (t-rajkup).

Revision History:

     None.
--*/

#ifndef HEADER_BINDINGS
#define HEADER_BINDINGS

#define CINTERFACE
#include <devguid.h>
#include <netcfgx.h>

//This is the CLSID used to CoCreate the object implementing INetCfg
EXTERN_C const CLSID CLSID_NetCfg = {0x5B035261,0x40F9,0x11D1,{0xAA,0xEC,0x00,0x80,0x5F,0xC1,0x27,0x0E}};

typedef struct _devclass {
  const GUID *pGuid;
} devclass;

#define MAX_CLASS_GUID       4
const devclass c_pNetClassGuid[] =
{
 &GUID_DEVCLASS_NETTRANS,
 &GUID_DEVCLASS_NETCLIENT,
 &GUID_DEVCLASS_NETSERVICE,
 &GUID_DEVCLASS_NET
};

//
// These IIDs are not publicly available yet. Sumitc will put it out for public
// after which we need to use the publicly available IIDs.
//

EXTERN_C const IID IID_INetCfg = {0xC0E8AE93,0x306E,0x11D1,{0xAA,0xCF,0x00,0x80,0x5F,0xC1,0x27,0x0E}};     
EXTERN_C const IID IID_INetCfgClass = {0xC0E8AE97,0x306E,0x11D1,{0xAA,0xCF,0x00,0x80,0x5F,0xC1,0x27,0x0E}};
EXTERN_C const IID IID_INetCfgComponent = { 0xC0E8AE99,0x306E,0x11D1,{0xAA,0xCF,0x00,0x80,0x5F,0xC1,0x27,0x0E}}; 
EXTERN_C const IID IID_INetCfgComponentBindings = { 0xC0E8AE9E,0x306E,0x11D1,{0xAA,0xCF,0x00,0x80,0x5F,0xC1,0x27,0x0E }};
EXTERN_C const IID IID_IEnumNetCfgComponent = { 0xC0E8AE92,0x306E,0x11D1,{0xAA,0xCF,0x00,0x80,0x5F,0xC1,0x27,0x0E} };

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\bowser.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Tue May 02 14:36:51 2000
 */
/* Compiler settings for .\bowser.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext, oldnames, robust
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__


#ifndef __bowser_h__
#define __bowser_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

/* header files for imported files */
#include "imports.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __browser_INTERFACE_DEFINED__
#define __browser_INTERFACE_DEFINED__

/* interface browser */
/* [implicit_handle][unique][ms_union][version][uuid] */ 

#pragma once

typedef /* [handle] */ wchar_t __RPC_FAR *BROWSER_IMPERSONATE_HANDLE;

typedef /* [handle] */ wchar_t __RPC_FAR *BROWSER_IDENTIFY_HANDLE;

typedef struct  _SERVER_INFO_100_CONTAINER
    {
    DWORD EntriesRead;
    /* [size_is] */ LPSERVER_INFO_100 Buffer;
    }	SERVER_INFO_100_CONTAINER;

typedef struct _SERVER_INFO_100_CONTAINER __RPC_FAR *PSERVER_INFO_100_CONTAINER;

typedef struct _SERVER_INFO_100_CONTAINER __RPC_FAR *LPSERVER_INFO_100_CONTAINER;

typedef struct  _SERVER_INFO_101_CONTAINER
    {
    DWORD EntriesRead;
    /* [size_is] */ LPSERVER_INFO_101 Buffer;
    }	SERVER_INFO_101_CONTAINER;

typedef struct _SERVER_INFO_101_CONTAINER __RPC_FAR *PSERVER_INFO_101_CONTAINER;

typedef struct _SERVER_INFO_101_CONTAINER __RPC_FAR *LPSERVER_INFO_101_CONTAINER;

typedef struct  _BROWSER_STATISTICS_100_CONTAINER
    {
    DWORD EntriesRead;
    /* [size_is] */ PBROWSER_STATISTICS_100 Buffer;
    }	BROWSER_STATISTICS_100_CONTAINER;

typedef struct _BROWSER_STATISTICS_100_CONTAINER __RPC_FAR *PBROWSER_STATISTICS_100_CONTAINER;

typedef struct  _BROWSER_STATISTICS_101_CONTAINER
    {
    DWORD EntriesRead;
    /* [size_is] */ PBROWSER_STATISTICS_101 Buffer;
    }	BROWSER_STATISTICS_101_CONTAINER;

typedef struct _BROWSER_STATISTICS_101_CONTAINER __RPC_FAR *PBROWSER_STATISTICS_101_CONTAINER;

typedef struct  _BROWSER_EMULATED_DOMAIN_CONTAINER
    {
    DWORD EntriesRead;
    /* [size_is] */ PBROWSER_EMULATED_DOMAIN Buffer;
    }	BROWSER_EMULATED_DOMAIN_CONTAINER;

typedef struct _BROWSER_EMULATED_DOMAIN_CONTAINER __RPC_FAR *PBROWSER_EMULATED_DOMAIN_CONTAINER;

typedef struct  _SERVER_ENUM_STRUCT
    {
    DWORD Level;
    /* [switch_is] */ /* [switch_type] */ union _SERVER_ENUM_UNION
        {
        /* [case()] */ LPSERVER_INFO_100_CONTAINER Level100;
        /* [case()] */ LPSERVER_INFO_101_CONTAINER Level101;
        /* [default] */  /* Empty union arm */ 
        }	ServerInfo;
    }	SERVER_ENUM_STRUCT;

typedef struct _SERVER_ENUM_STRUCT __RPC_FAR *PSERVER_ENUM_STRUCT;

typedef struct _SERVER_ENUM_STRUCT __RPC_FAR *LPSERVER_ENUM_STRUCT;

typedef struct  _BROWSER_STATISTICS_STRUCT
    {
    DWORD Level;
    /* [switch_is] */ /* [switch_type] */ union _BROWSER_STATISTICS_UNION
        {
        /* [case()] */ PBROWSER_STATISTICS_100_CONTAINER Level100;
        /* [case()] */ PBROWSER_STATISTICS_101_CONTAINER Level101;
        /* [default] */  /* Empty union arm */ 
        }	Statistics;
    }	BROWSER_STATISTICS_STRUCT;

typedef struct _BROWSER_STATISTICS_STRUCT __RPC_FAR *PBROWSER_STATISTICS_STRUCT;

typedef struct _BROWSER_STATISTICS_STRUCT __RPC_FAR *LPBROWSER_STATISTICS_STRUCT;

DWORD I_BrowserrServerEnum( 
    /* [unique][string][in] */ BROWSER_IDENTIFY_HANDLE ServerName,
    /* [unique][string][in] */ wchar_t __RPC_FAR *TransportName,
    /* [unique][string][in] */ wchar_t __RPC_FAR *ClientName,
    /* [out][in] */ LPSERVER_ENUM_STRUCT InfoStruct,
    /* [in] */ DWORD PreferedMaximumLength,
    /* [out] */ LPDWORD TotalEntries,
    /* [in] */ DWORD ServerType,
    /* [unique][string][in] */ wchar_t __RPC_FAR *Domain,
    /* [unique][out][in] */ LPDWORD ResumeHandle);

DWORD I_BrowserrDebugCall( 
    /* [unique][string][in] */ BROWSER_IDENTIFY_HANDLE ServerName,
    /* [in] */ DWORD DebugFunction,
    /* [in] */ DWORD OptionalValue);

DWORD I_BrowserrQueryOtherDomains( 
    /* [unique][string][in] */ BROWSER_IDENTIFY_HANDLE ServerName,
    /* [out][in] */ LPSERVER_ENUM_STRUCT InfoStruct,
    /* [out] */ LPDWORD TotalEntries);

DWORD I_BrowserrResetNetlogonState( 
    /* [unique][string][in] */ BROWSER_IDENTIFY_HANDLE ServerName);

DWORD I_BrowserrDebugTrace( 
    /* [unique][string][in] */ BROWSER_IDENTIFY_HANDLE ServerName,
    /* [string][in] */ LPSTR TraceString);

DWORD I_BrowserrQueryStatistics( 
    /* [unique][string][in] */ BROWSER_IDENTIFY_HANDLE servername,
    /* [out] */ LPBROWSER_STATISTICS __RPC_FAR *statistics);

DWORD I_BrowserrResetStatistics( 
    /* [unique][string][in] */ BROWSER_IDENTIFY_HANDLE servername);

DWORD NetrBrowserStatisticsClear( 
    /* [unique][string][in] */ BROWSER_IDENTIFY_HANDLE servername);

DWORD NetrBrowserStatisticsGet( 
    /* [unique][string][in] */ BROWSER_IDENTIFY_HANDLE servername,
    /* [in] */ DWORD Level,
    /* [out][in] */ LPBROWSER_STATISTICS_STRUCT StatisticsStruct);

DWORD I_BrowserrSetNetlogonState( 
    /* [unique][string][in] */ BROWSER_IDENTIFY_HANDLE ServerName,
    /* [string][in] */ wchar_t __RPC_FAR *DomainName,
    /* [unique][string][in] */ wchar_t __RPC_FAR *EmulatedComputerName,
    /* [in] */ DWORD Role);

DWORD I_BrowserrQueryEmulatedDomains( 
    /* [unique][string][in] */ BROWSER_IDENTIFY_HANDLE ServerName,
    /* [out][in] */ PBROWSER_EMULATED_DOMAIN_CONTAINER EmulatedDomains);

DWORD I_BrowserrServerEnumEx( 
    /* [unique][string][in] */ BROWSER_IDENTIFY_HANDLE ServerName,
    /* [unique][string][in] */ wchar_t __RPC_FAR *TransportName,
    /* [unique][string][in] */ wchar_t __RPC_FAR *ClientName,
    /* [out][in] */ LPSERVER_ENUM_STRUCT InfoStruct,
    /* [in] */ DWORD PreferedMaximumLength,
    /* [out] */ LPDWORD TotalEntries,
    /* [in] */ DWORD ServerType,
    /* [unique][string][in] */ wchar_t __RPC_FAR *Domain,
    /* [unique][string][in] */ wchar_t __RPC_FAR *FirstNameToReturn);


extern handle_t browser_bhandle;


extern RPC_IF_HANDLE browser_ClientIfHandle;
extern RPC_IF_HANDLE browser_ServerIfHandle;
#endif /* __browser_INTERFACE_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

handle_t __RPC_USER BROWSER_IDENTIFY_HANDLE_bind  ( BROWSER_IDENTIFY_HANDLE );
void     __RPC_USER BROWSER_IDENTIFY_HANDLE_unbind( BROWSER_IDENTIFY_HANDLE, handle_t );

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\bowser.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      browser.c
//
//  Abstract:
//
//      Queries into network drivers
//
//  Author:
//
//      Anilth  - 4-20-1998
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//--

#include "precomp.h"
#include "malloc.h"
#include "nbtutil.h"

NET_API_STATUS GetBrowserTransportList(OUT PLMDR_TRANSPORT_LIST *TransportList);
//$review (nsun) there is a recursive calling of this function
NTSTATUS
NettestBrowserSendDatagram(
    IN PLIST_ENTRY listNetbtTransports,
    IN PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pPrimaryDomainInfo,
    IN PVOID ContextDomainInfo,
    IN ULONG IpAddress,
    IN LPWSTR UnicodeDestinationName,
    IN DGRECEIVER_NAME_TYPE NameType,
    IN LPWSTR pswzTransportName,
    IN LPSTR OemMailslotName,
    IN PVOID Buffer,
    IN ULONG BufferSize
    );
BOOL MailslotTest(NETDIAG_PARAMS* pParams,
                  IN LPWSTR DestinationName,
                  NETDIAG_RESULT* pResults);




BOOL
BrowserTest(
      NETDIAG_PARAMS*  pParams,
      NETDIAG_RESULT*  pResults
    )
/*++

Routine Description:

    Determine the machines role and membership.

Arguments:

    None.

Return Value:

    TRUE: Test suceeded.
    FALSE: Test failed

--*/
{
    NET_API_STATUS NetStatus;
    HRESULT hrRetVal = S_OK;

    BOOL BrowserIsUp = TRUE;
    BOOL RedirIsUp = TRUE;
    PLMDR_TRANSPORT_LIST TransportList = NULL;
    PLMDR_TRANSPORT_LIST TransportEntry;
    LONG NetbtTransportCount;
    LONG RealNetbtTransportCount;
    PNETBT_TRANSPORT NetbtTransport;
    BOOL PrintIt;
    PWKSTA_TRANSPORT_INFO_0 pWti0 = NULL;
    DWORD EntriesRead;
    DWORD TotalEntries;
    DWORD i;
    WCHAR DestinationName[MAX_PATH+1];
    BOOL MailslotTested = FALSE;
    PTESTED_DOMAIN TestedDomain;
    PLIST_ENTRY ListEntry;

    USES_CONVERSION;

    PrintStatusMessage( pParams, 4, IDS_BROWSER_STATUS_MSG );
	pResults->Browser.fPerformed = TRUE;

    InitializeListHead( &pResults->Browser.lmsgOutput );

    //
    // Ensure the workstation service is running.
    //

    NetStatus = IsServiceStarted( _T("LanmanWorkstation") );

    if ( NetStatus != NO_ERROR )
    {
        //IDS_BROWSER_13001                  "    [FATAL] Workstation service is not running. [%s]\n"
        AddMessageToList( &pResults->Browser.lmsgOutput, Nd_Quiet,
                            IDS_BROWSER_13001, NetStatusToString(NetStatus) );
        hrRetVal = S_OK;
        goto Cleanup;
    }

	if (!pResults->Global.fHasNbtEnabledInterface)
	{
		AddMessageToList( &pResults->Browser.lmsgOutput, Nd_Verbose,
						  IDS_BROWSER_NETBT_DISABLED);
		pResults->Browser.fPerformed = FALSE;
		hrRetVal = S_OK;
		goto Cleanup;
	}

    //
    //  Get the transports bound to the Redir
    //

    if ( pParams->fReallyVerbose )
    {
        //IDS_BROWSER_13002                  "    List of transports currently bound to the Redir\n"
        AddMessageToListId( &pResults->Browser.lmsgOutput, Nd_ReallyVerbose, IDS_BROWSER_13002 );
    }
    else if ( pParams->fVerbose )
    {
        //IDS_BROWSER_13003                  "    List of NetBt transports currently bound to the Redir\n"
        AddMessageToListId( &pResults->Browser.lmsgOutput, Nd_Verbose, IDS_BROWSER_13003 );
    }


   NetStatus = NetWkstaTransportEnum(
                   NULL,
                   0,
                   (LPBYTE *)&pWti0,
                   0xFFFFFFFF,      // MaxPreferredLength
                   &EntriesRead,
                   &TotalEntries,
                   NULL );          // Optional resume handle

    if (NetStatus != NERR_Success)
    {
        //IDS_BROWSER_13004                  "    [FATAL] Unable to retrieve transport list from Redir. [%s]\n"
        AddMessageToList( &pResults->Browser.lmsgOutput, Nd_Quiet, IDS_BROWSER_13004, NetStatusToString(NetStatus) );
        hrRetVal = S_FALSE;
        RedirIsUp = FALSE;
    }
    else
    {
        NetbtTransportCount = 0;
        RealNetbtTransportCount = 0;
        for ( i = 0; i < EntriesRead; i++ )
        {
            UNICODE_STRING ustrTransportName;
            LPTSTR  pszTransportName;

            RtlInitUnicodeString( &ustrTransportName, (LPWSTR)pWti0[i].wkti0_transport_name );

            // Strip off the "\Device\" off of the beginning of
            // the string
            pszTransportName = W2T(MapGuidToServiceNameW(ustrTransportName.Buffer + 8));


            PrintIt = FALSE;

            if ( ustrTransportName.Length >= sizeof(NETBT_DEVICE_PREFIX) &&
                _wcsnicmp( ustrTransportName.Buffer, NETBT_DEVICE_PREFIX, (sizeof(NETBT_DEVICE_PREFIX)/sizeof(WCHAR)-1)) == 0 )
            {

                //
                // Determine if this Netbt transport really exists.
                //

                NetbtTransport = FindNetbtTransport( pResults, ustrTransportName.Buffer );

                if ( NetbtTransport == NULL )
                {
                    //IDS_BROWSER_13005                  "    [FATAL] Transport %s is bound to the redir but is not a configured NetbtTransport."
                    AddMessageToList( &pResults->Browser.lmsgOutput, Nd_Quiet, IDS_BROWSER_13005, pszTransportName );
                    hrRetVal = S_FALSE;
                }
                else
                {
                    if ( NetbtTransport->Flags & BOUND_TO_REDIR )
                    {
                        //IDS_BROWSER_13006                  "    [WARNING] Transport %s is bound to redir more than once."
                        AddMessageToList( &pResults->Browser.lmsgOutput, Nd_Verbose, IDS_BROWSER_13006, pszTransportName );
                    }
                    else
                    {
                        NetbtTransport->Flags |= BOUND_TO_REDIR;
                        RealNetbtTransportCount ++;
                    }
                }

                //
                // Count the found transports.
                //
                NetbtTransportCount ++;
                if ( pParams->fVerbose ) {
                    PrintIt = TRUE;
                }
            }

            //IDS_BROWSER_13007                  "        %s\n"
            AddMessageToList( &pResults->Browser.lmsgOutput, PrintIt ? Nd_Verbose : Nd_ReallyVerbose, IDS_BROWSER_13007, pszTransportName);//&ustrTransportName );
        }

        //
        // Ensure the redir is bound to some Netbt transports.
        //
        if ( NetbtTransportCount == 0 )
        {
            //IDS_BROWSER_13008                  "    [FATAL] The redir isn't bound to any NetBt transports."
            AddMessageToListId( &pResults->Browser.lmsgOutput, Nd_Quiet, IDS_BROWSER_13008);
            hrRetVal = S_FALSE;
            RedirIsUp = FALSE;
        }
        else
        {
                //IDS_BROWSER_13009                  "    The redir is bound to %ld NetBt transport%s.\n"
                AddMessageToList( &pResults->Browser.lmsgOutput, Nd_Verbose,
                       IDS_BROWSER_13009,
                       NetbtTransportCount,
                       NetbtTransportCount > 1 ? "s" : "" );
        }

        //
        // Ensure the redir is bound to all of the Netbt transports.
        //

        if ( RealNetbtTransportCount != pResults->NetBt.cTransportCount )
        {
            //IDS_BROWSER_13010                  "    [FATAL] The redir is only bound to %ld of the %ld NetBt transports."
            AddMessageToList( &pResults->Browser.lmsgOutput, Nd_Quiet,
                   IDS_BROWSER_13010,
                   RealNetbtTransportCount,
                   pResults->NetBt.cTransportCount );
            hrRetVal = S_FALSE;
        }
    }


    //
    //  Get the transports bound to the browser.
    //

    //IDS_BROWSER_13011                  "\n"
    AddMessageToListId( &pResults->Browser.lmsgOutput, Nd_Verbose, IDS_BROWSER_13011);

    if ( pParams->fReallyVerbose )
        //IDS_BROWSER_13012                  "    List of transports currently bound to the browser\n"
        AddMessageToListId( &pResults->Browser.lmsgOutput, Nd_ReallyVerbose, IDS_BROWSER_13012 );
    else if ( pParams->fVerbose )
        //IDS_BROWSER_13013                  "    List of NetBt transports currently bound to the browser\n"
        AddMessageToListId( &pResults->Browser.lmsgOutput, Nd_Verbose, IDS_BROWSER_13013 );


    NetStatus = GetBrowserTransportList(&TransportList);

    if (NetStatus != NERR_Success)
    {
        //IDS_BROWSER_13014                  "    [FATAL] Unable to retrieve transport list from browser. [%s]\n"
        AddMessageToList( &pResults->Browser.lmsgOutput, Nd_Quiet, IDS_BROWSER_13014, NetStatusToString(NetStatus) );
        hrRetVal = S_FALSE;
        BrowserIsUp = FALSE;
    }
    else
    {
        TransportEntry = TransportList;

        NetbtTransportCount = 0;
        RealNetbtTransportCount = 0;
        while (TransportEntry != NULL)
        {
            UNICODE_STRING ustrTransportName;
            LPTSTR  pszTransportName;

            ustrTransportName.Buffer = TransportEntry->TransportName;
            ustrTransportName.Length = (USHORT)TransportEntry->TransportNameLength;
            ustrTransportName.MaximumLength = (USHORT)TransportEntry->TransportNameLength;

            pszTransportName = W2T(MapGuidToServiceNameW(ustrTransportName.Buffer + 8));

            PrintIt = FALSE;
            if ( ustrTransportName.Length >= sizeof(NETBT_DEVICE_PREFIX) &&
                _wcsnicmp( ustrTransportName.Buffer, NETBT_DEVICE_PREFIX, (sizeof(NETBT_DEVICE_PREFIX)/sizeof(WCHAR)-1)) == 0 )
            {

                //
                // Determine if this Netbt transport really exists.
                //

                NetbtTransport = FindNetbtTransport( pResults, ustrTransportName.Buffer );

                if ( NetbtTransport == NULL )
                {
                    //IDS_BROWSER_13015                  "    [FATAL] Transport %s is bound to the browser but is not a configured NetbtTransport."
                    AddMessageToList( &pResults->Browser.lmsgOutput, Nd_Quiet, IDS_BROWSER_13015, pszTransportName );
                    hrRetVal = S_FALSE;
                }
                else
                {
                    if ( NetbtTransport->Flags & BOUND_TO_BOWSER )
                    {
                        //IDS_BROWSER_13016                  "    [FATAL] Transport %s is bound to browser more than once."
                        AddMessageToList( &pResults->Browser.lmsgOutput, Nd_Quiet, IDS_BROWSER_13016, pszTransportName );
                        hrRetVal = S_FALSE;
                    }
                    else
                    {
                        NetbtTransport->Flags |= BOUND_TO_BOWSER;
                        RealNetbtTransportCount ++;
                    }

                }

                //
                // Count the found transports.
                //
                NetbtTransportCount ++;
                if ( pParams->fVerbose )
                    PrintIt = TRUE;
            }

            //IDS_BROWSER_13017                  "        %s\n"
            AddMessageToList( &pResults->Browser.lmsgOutput,
                                PrintIt ? Nd_Verbose : Nd_ReallyVerbose,
                                IDS_BROWSER_13017, pszTransportName );


            if (TransportEntry->NextEntryOffset == 0)
            {
                TransportEntry = NULL;
            }
            else
            {
                TransportEntry = (PLMDR_TRANSPORT_LIST)((PCHAR)TransportEntry+TransportEntry->NextEntryOffset);
            }
        }

        if ( NetbtTransportCount == 0 )
        {
            //IDS_BROWSER_13018                  "    [FATAL] The browser isn't bound to any NetBt transports"
            AddMessageToListId( &pResults->Browser.lmsgOutput, Nd_Quiet,
                                IDS_BROWSER_13018 );
            hrRetVal = S_FALSE;
            BrowserIsUp = FALSE;
        }
        else
        {
            //IDS_BROWSER_13019                  "    The browser is bound to %ld NetBt transport%s.\n"
            AddMessageToList( &pResults->Browser.lmsgOutput, Nd_Verbose,
                       IDS_BROWSER_13019,
                       NetbtTransportCount,
                       NetbtTransportCount > 1 ? "s" : "" );
        }

        //
        // Ensure the browser is bound to all of the Netbt transports.
        //

        if ( RealNetbtTransportCount != pResults->NetBt.cTransportCount )
        {
            //IDS_BROWSER_13020                  "    [FATAL] The browser is only bound to %ld of the %ld NetBt transports."
            AddMessageToList( &pResults->Browser.lmsgOutput, Nd_Quiet,
                   IDS_BROWSER_13020,
                   RealNetbtTransportCount,
                   pResults->NetBt.cTransportCount );
            hrRetVal = FALSE;
        }
    }

    //
    // Ensure we can send mailslot messages.  (DsGetDcName uses them.)
    //
    // Try sending to each of the tested domains.
    //

    for ( ListEntry = pResults->Global.listTestedDomains.Flink ;
          ListEntry != &pResults->Global.listTestedDomains ;
          ListEntry = ListEntry->Flink )
    {

        //
        // Only test this domain if it is has a Netbios domain name
        //

        TestedDomain = CONTAINING_RECORD( ListEntry, TESTED_DOMAIN, Next );

        if ( TestedDomain->NetbiosDomainName != NULL )
        {
            //
            // Send the message to the <DomainName>[1C] name
            //
            wcscpy( DestinationName, TestedDomain->NetbiosDomainName );
            wcscat( DestinationName, L"*" );
            if ( !MailslotTest( pParams, DestinationName, pResults ) ) {
                hrRetVal = S_FALSE;
            }
            else
            {
                USES_CONVERSION;
                //IDS_BROWSER_13021                  "Mailslot test for %s passed.\n"
                AddMessageToList( &pResults->Browser.lmsgOutput, Nd_ReallyVerbose, IDS_BROWSER_13021, W2CT(DestinationName));
            }
            MailslotTested = TRUE;
        }
    }


    //
    // If we still haven't tested mailslots,
    //  test them by sending the message to our own computername.
    //

//#ifdef notdef   // crashes build 1728
    if ( !MailslotTested ) {
        wcscpy( DestinationName, pResults->Global.swzNetBiosName );
        if ( !MailslotTest( pParams, DestinationName, pResults ) ) {
            hrRetVal = S_FALSE;
        }
        MailslotTested = TRUE;
    }
//#endif // notdef   // crashes build 1728


Cleanup:
    if ( pWti0 )
    {
        NetApiBufferFree( pWti0 );
    }

    if ( TransportList != NULL )
    {
        NetApiBufferFree(TransportList);
    }

    if ( FHrOK(hrRetVal) )
    {
        PrintStatusMessage(pParams, 0, IDS_GLOBAL_PASS_NL);
    }
    else
    {
        PrintStatusMessage(pParams, 0, IDS_GLOBAL_FAIL_NL);
    }


    pResults->Browser.hrTestResult = hrRetVal;

    return hrRetVal;
}




NET_API_STATUS
GetBrowserTransportList(
    OUT PLMDR_TRANSPORT_LIST *TransportList
    )

/*++

Routine Description:

    This routine returns the list of transports bound into the browser.

Arguments:

    OUT PLMDR_TRANSPORT_LIST *TransportList - Transport list to return.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/

{

    NET_API_STATUS NetStatus;
    HANDLE BrowserHandle;
    LMDR_REQUEST_PACKET RequestPacket;

    NetStatus = OpenBrowser(&BrowserHandle);

    if (NetStatus != NERR_Success) {
        DebugMessage2("    [FATAL] Unable to open browser driver. [%s]\n",  NetStatusToString(NetStatus) );
        return NetStatus;
    }

    RequestPacket.Version = LMDR_REQUEST_PACKET_VERSION_DOM;

    RequestPacket.Type = EnumerateXports;

    RtlInitUnicodeString(&RequestPacket.TransportName, NULL);
    RtlInitUnicodeString(&RequestPacket.EmulatedDomainName, NULL);

    NetStatus = DeviceControlGetInfo(
                BrowserHandle,
                IOCTL_LMDR_ENUMERATE_TRANSPORTS,
                &RequestPacket,
                sizeof(RequestPacket),
                (PVOID *)TransportList,
                0xffffffff,
                4096,
                NULL);

    NtClose(BrowserHandle);

    return NetStatus;
}





BOOL
MailslotTest(
    NETDIAG_PARAMS* pParams,
    IN LPWSTR DestinationName,
    NETDIAG_RESULT* pResults
    )
/*++

Routine Description:

    Ensure we can send mailslot messages.

    Test both via redir and browser.

    Don't test responses (since that really tests if the DC is up).

Arguments:

    DestinationName - Name to send the message to
        Name ends in * if destination is the [1c] name.

Return Value:

    TRUE: Test suceeded.
    FALSE: Test failed

--*/
{
    BOOL RetVal = TRUE;

    NET_API_STATUS NetStatus;
    NTSTATUS Status;
    HANDLE ResponseMailslotHandle = NULL;
    TCHAR ResponseMailslotName[MAX_PATH+1];
    WCHAR NetlogonMailslotName[MAX_PATH+1];

    WCHAR BrowserDestinationName[MAX_PATH+1];
    DWORD BrowserDestinationNameLen;
    DGRECEIVER_NAME_TYPE NameType;

    PVOID PingMessage = NULL;
    ULONG PingMessageSize = 0;

    //
    // Open a mailslot to get ping responses on.
    //
    //

    NetStatus = NetpLogonCreateRandomMailslot( ResponseMailslotName,
                                               &ResponseMailslotHandle );

    if (NetStatus != NO_ERROR ) {
        //IDS_BROWSER_13022                  "    [FATAL] Cannot create temp mailslot. [%s]\n"
        AddMessageToList( &pResults->Browser.lmsgOutput, Nd_Quiet, IDS_BROWSER_13022,   NetStatusToString(NetStatus)  );
        RetVal = FALSE;
        goto Cleanup;
    }

    //
    // Allocate a mailslot message to send
    //

    NetStatus = NetpDcBuildPing (
        FALSE,  // Not only PDC
        0,      // Retry count
        pResults->Global.swzNetBiosName, //replace GlobalNetbiosComputerName,
        NULL,   // No Account name
        ResponseMailslotName,
        0,      // no AllowableAccountControlBits,
        NULL,   // No Domain SID
        0,      // Not NT Version 5
        &PingMessage,
        &PingMessageSize );

    if ( NetStatus != NO_ERROR ) {
        //IDS_BROWSER_13023                  "    [FATAL] Cannot allocate mailslot message. [%s]\n"
        AddMessageToList( &pResults->Browser.lmsgOutput, Nd_Quiet, IDS_BROWSER_13023,
                            NetStatusToString(NetStatus) );
        RetVal = FALSE;
        goto Cleanup;
    }

    //
    // Build the destination mailslot name.
    //

    NetlogonMailslotName[0] = '\\';
    NetlogonMailslotName[1] = '\\';
    wcscpy(NetlogonMailslotName + 2, DestinationName );
    wcscat( NetlogonMailslotName, NETLOGON_LM_MAILSLOT_W );

    //
    // Send the mailslot via the redir.
    //
    NetStatus = NetpLogonWriteMailslot(
                        NetlogonMailslotName,
                        (PCHAR)PingMessage,
                        PingMessageSize );

    if ( NetStatus != NO_ERROR ) {
        //IDS_BROWSER_13024                  "    [FATAL] Cannot send mailslot message to '%ws' via redir. [%s]\n"
        AddMessageToList( &pResults->Browser.lmsgOutput, Nd_Quiet, IDS_BROWSER_13024,
                            NetlogonMailslotName,  NetStatusToString(NetStatus)  );
        RetVal = FALSE;
        goto Cleanup;
    }


    //
    // Send the mailslot via the browser
    //
    // Avoid this test if this build has an old value for the IOCTL function
    //  code to the browser.
    //

    if ( _ttoi(pResults->Global.pszCurrentBuildNumber) < NTBUILD_BOWSER )
    {
        if ( pParams->fReallyVerbose ) {
            //IDS_BROWSER_13025                  "    Cannot sending mailslot messages via the browser since this machine is running build %ld. [Test skipped.]\n"
            AddMessageToList( &pResults->Browser.lmsgOutput, Nd_Quiet, IDS_BROWSER_13025, pResults->Global.pszCurrentBuildNumber  );
        }
    }
    else
    {
        wcscpy( BrowserDestinationName, DestinationName );
        BrowserDestinationNameLen = wcslen(BrowserDestinationName);

        if ( BrowserDestinationName[BrowserDestinationNameLen-1] == L'*' )
        {
            BrowserDestinationName[BrowserDestinationNameLen-1] = L'\0';
            NameType = DomainName;  // [1c] name
        }
        else
        {
            NameType = PrimaryDomain; // [00] name
        }

        Status = NettestBrowserSendDatagram(
                    &pResults->NetBt.Transports,
                    pResults->Global.pPrimaryDomainInfo,
                    NULL,
                    ALL_IP_TRANSPORTS,
                    BrowserDestinationName,
                    NameType,
                    NULL,       // All transports
                    NETLOGON_LM_MAILSLOT_A,
                    PingMessage,
                    PingMessageSize );

        if ( !NT_SUCCESS(Status) )
        {
            NetStatus = NetpNtStatusToApiStatus(Status);
            //IDS_BROWSER_13026                  "    [FATAL] Cannot send mailslot message to '%ws' via browser. [%s]\n"
            AddMessageToList( &pResults->Browser.lmsgOutput, Nd_Quiet, IDS_BROWSER_13026,
                              DestinationName,  NetStatusToString(NetStatus) );
            RetVal = FALSE;
            goto Cleanup;
        }
    }

Cleanup:
    if ( PingMessage != NULL ) {
        NetpMemoryFree( PingMessage );
    }
    if ( ResponseMailslotHandle != NULL ) {
        CloseHandle(ResponseMailslotHandle);
    }
    return RetVal;
}




NTSTATUS
NettestBrowserSendDatagram(
    IN PLIST_ENTRY plistNetbtTransports,
    IN PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pPrimaryDomainInfo,
    IN PVOID ContextDomainInfo,
    IN ULONG IpAddress,
    IN LPWSTR UnicodeDestinationName,
    IN DGRECEIVER_NAME_TYPE NameType,
    IN LPWSTR TransportName,
    IN LPSTR OemMailslotName,
    IN PVOID Buffer,
    IN ULONG BufferSize
    )
/*++

Routine Description:

    Send the specified mailslot message to the specified mailslot on the
    specified server on the specified transport..

Arguments:

    DomainInfo - Hosted domain sending the datagram

    IpAddress - IpAddress of the machine to send the message to.
        If zero, UnicodeDestinationName must be specified.
        If ALL_IP_TRANSPORTS, UnicodeDestination must be specified but the datagram
            will only be sent on IP transports.

    UnicodeDestinationName -- Name of the server to send to.

    NameType -- Type of name represented by UnicodeDestinationName.

    TransportName -- Name of the transport to send on.
        Use NULL to send on all transports.

    OemMailslotName -- Name of the mailslot to send to.

    Buffer -- Specifies a pointer to the mailslot message to send.

    BufferSize -- Size in bytes of the mailslot message

Return Value:

    Status of the operation.

    STATUS_NETWORK_UNREACHABLE: Cannot write to network.

--*/
{
    PLMDR_REQUEST_PACKET RequestPacket = NULL;
    NET_API_STATUS NetStatus;

    DWORD OemMailslotNameSize;
    DWORD TransportNameSize;
    DWORD DestinationNameSize;
    WCHAR IpAddressString[NL_IP_ADDRESS_LENGTH+1];
    ULONG Information;
    HANDLE BrowserHandle = NULL;

    NTSTATUS Status;
    LPBYTE Where;
    LONG    test;

    //
    // If the transport isn't specified,
    //  send on all transports.
    //

    if ( TransportName == NULL ) {
        ULONG i;
        PLIST_ENTRY ListEntry;
        NTSTATUS SavedStatus = STATUS_NETWORK_UNREACHABLE;

        //
        // Loop through the list of netbt transports finding this one.
        //

        for ( ListEntry = plistNetbtTransports->Flink ;
              ListEntry != plistNetbtTransports ;
              ListEntry = ListEntry->Flink ) {

            PNETBT_TRANSPORT NetbtTransport;

            //
            // If the transport names match,
            //  return the entry
            //

            NetbtTransport = CONTAINING_RECORD( ListEntry, NETBT_TRANSPORT, Next );

            //
            // Skip deleted transports.
            //
            if ( (NetbtTransport->Flags & BOUND_TO_BOWSER) == 0 ) {
                continue;
            }

            Status = NettestBrowserSendDatagram(
                              plistNetbtTransports,
                              pPrimaryDomainInfo,
                              ContextDomainInfo,
                              IpAddress,
                              UnicodeDestinationName,
                              NameType,
                              NetbtTransport->pswzTransportName,
                              OemMailslotName,
                              Buffer,
                              BufferSize );

            if ( NT_SUCCESS(Status) ) {
                // If any transport works, we've been successful
                SavedStatus = STATUS_SUCCESS;
            } else {
                // Remember the real reason for the failure instead of the default failure status
                // Remember only the first failure.
                if ( SavedStatus == STATUS_NETWORK_UNREACHABLE ) {
                    SavedStatus = Status;
                }
            }

        }
        return SavedStatus;
    }



    //
    // Open a handle to the browser.
    //

    NetStatus = OpenBrowser(&BrowserHandle);

    if (NetStatus != NERR_Success) {
        DebugMessage2("    [FATAL] Unable to open browser driver. [%s]\n", NetStatusToString(NetStatus));
        Status = NetpApiStatusToNtStatus( NetStatus );
        goto Cleanup;
    }



    //
    // Allocate a request packet.
    //

    OemMailslotNameSize = strlen(OemMailslotName) + 1;
    TransportNameSize = (wcslen(TransportName) + 1) * sizeof(WCHAR);

    if ( UnicodeDestinationName == NULL ) {
        return STATUS_INTERNAL_ERROR;
    }

    DestinationNameSize = wcslen(UnicodeDestinationName) * sizeof(WCHAR);

    RequestPacket = NetpMemoryAllocate(
                                  sizeof(LMDR_REQUEST_PACKET) +
                                  TransportNameSize +
                                  OemMailslotNameSize +
                                  DestinationNameSize + sizeof(WCHAR) +
                                  (wcslen( pPrimaryDomainInfo->DomainNameFlat ) + 1) * sizeof(WCHAR) +
                                  sizeof(WCHAR)) ; // For alignment


    if (RequestPacket == NULL) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }



    //
    // Fill in the Request Packet.
    //

    RequestPacket->Type = Datagram;
    RequestPacket->Parameters.SendDatagram.DestinationNameType = NameType;


    //
    // Fill in the name of the machine to send the mailslot message to.
    //

    RequestPacket->Parameters.SendDatagram.NameLength = DestinationNameSize;

    Where = (LPBYTE) RequestPacket->Parameters.SendDatagram.Name;
    RtlCopyMemory( Where, UnicodeDestinationName, DestinationNameSize );
    Where += DestinationNameSize;


    //
    // Fill in the name of the mailslot to send to.
    //

    RequestPacket->Parameters.SendDatagram.MailslotNameLength =
        OemMailslotNameSize;
    strcpy( Where, OemMailslotName);
    Where += OemMailslotNameSize;
    Where = ROUND_UP_POINTER( Where, ALIGN_WCHAR );


    //
    // Fill in the TransportName
    //

    wcscpy( (LPWSTR) Where, TransportName);
    RtlInitUnicodeString( &RequestPacket->TransportName, (LPWSTR) Where );
    Where += TransportNameSize;


    //
    // Copy the hosted domain name to the request packet.
    //
	//If the machine doesn't belong to a domain, we shouldn't get to here
	assert(pPrimaryDomainInfo->DomainNameFlat);
	if (pPrimaryDomainInfo->DomainNameFlat)  
	{
		wcscpy( (LPWSTR)Where,
				pPrimaryDomainInfo->DomainNameFlat );
		RtlInitUnicodeString( &RequestPacket->EmulatedDomainName,
							  (LPWSTR)Where );
		Where += (wcslen( pPrimaryDomainInfo->DomainNameFlat ) + 1) * sizeof(WCHAR);
	}


    //
    // Send the request to the browser.
    //

    NetStatus = BrDgReceiverIoControl(
                   BrowserHandle,
                   IOCTL_LMDR_WRITE_MAILSLOT,
                   RequestPacket,
                   (ULONG)(Where - (LPBYTE)RequestPacket),
                   Buffer,
                   BufferSize,
                   &Information );


    if ( NetStatus != NO_ERROR ) {
        Status = NetpApiStatusToNtStatus( NetStatus );
    }

    //
    // Free locally used resources.
    //
Cleanup:
    if ( BrowserHandle != NULL ) {
        NtClose(BrowserHandle);
    }

    if ( RequestPacket != NULL ) {
        NetpMemoryFree( RequestPacket );
    }

    return Status;
}


void BrowserGlobalPrint(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults)
{
    if (pParams->fVerbose || !FHrOK(pResults->Browser.hrTestResult))
    {
        PrintNewLine(pParams, 2);
        PrintTestTitleResult(pParams,
                             IDS_BROWSER_LONG,
                             IDS_BROWSER_SHORT,
                             pResults->Browser.fPerformed,
                             pResults->Browser.hrTestResult,
                             0);
    }
    PrintMessageList(pParams, &pResults->Browser.lmsgOutput);

}

void BrowserPerInterfacePrint(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults, INTERFACE_RESULT *pInterfaceResults)
{
    //no per interface results
}

void BrowserCleanup(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults)
{
    MessageListCleanUp(&pResults->Browser.lmsgOutput);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\dclist.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      dclist.c
//
//  Abstract:
//
//      Queries into network drivers
//
//  Author:
//
//      Anilth  - 4-20-1998 
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//--

#include "precomp.h"

BOOL
GetDcListFromDs(
    IN NETDIAG_PARAMS*      pParams,
    IN OUT NETDIAG_RESULT*  pResults,
    IN PTESTED_DOMAIN       TestedDomain
    );

BOOL
GetDcListFromSam(
    IN NETDIAG_PARAMS*  pParams,
    IN OUT  NETDIAG_RESULT*  pResults,
    IN PTESTED_DOMAIN   TestedDomain
    );

NET_API_STATUS
GetBrowserServerList(
    IN PUNICODE_STRING TransportName,
    IN LPCWSTR Domain,
    OUT LPWSTR *BrowserList[],
    OUT PULONG BrowserListLength,
    IN BOOLEAN ForceRescan
    );

NET_API_STATUS
EnumServersForTransport(
    IN PUNICODE_STRING TransportName,
    IN LPCWSTR DomainName OPTIONAL,
    IN ULONG level,
    IN ULONG prefmaxlen,
    IN ULONG servertype,
    IN LPWSTR CurrentComputerName,
    OUT PINTERIM_SERVER_LIST InterimServerList,
    OUT PULONG TotalEntriesOnThisTransport,
    IN LPCWSTR FirstNameToReturn,
    IN BOOLEAN WannishTransport,
    IN BOOLEAN RasTransport,
    IN BOOLEAN IpxTransport
    );
NET_API_STATUS NET_API_FUNCTION
LocalNetServerEnumEx(
    IN  LPCWSTR     servername OPTIONAL,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN  DWORD       servertype,
    IN  LPCWSTR     domain OPTIONAL,
    IN  LPCWSTR     FirstNameToReturnArg OPTIONAL,
    IN  NETDIAG_PARAMS *pParams,
    IN OUT NETDIAG_RESULT *pResults
    );
BOOL GetDcListFromDc(IN NETDIAG_PARAMS *pParams,
                     IN OUT NETDIAG_RESULT *pResults,
                     IN PTESTED_DOMAIN TestedDomain);


HRESULT
DcListTest(NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
/*++

Routine Description:

    This test builds a list of all the DCs in the tested domains.

Arguments:

    None.

Return Value:

    TRUE: Test suceeded.
    FALSE: Test failed

--*/
{
    HRESULT hrRetVal = S_OK;
    PTESTED_DOMAIN pTestedDomain = (PTESTED_DOMAIN) pParams->pDomain;
    NET_API_STATUS NetStatus;

    PSERVER_INFO_101 ServerInfo101 = NULL;
    DWORD EntriesRead;
    DWORD TotalEntries;
    PTESTED_DC TestedDc = NULL;
    PLIST_ENTRY ListEntry;

    ULONG i;

    PrintStatusMessage(pParams, 0, IDS_DCLIST_STATUS_MSG, pTestedDomain->PrintableDomainName);

    //if the machine is a member machine or DC, DcListTest will get called. 
    //Otherwise, DcList test will be skipped
    pResults->DcList.fPerformed = TRUE;

    //the Dclist test will be called for every domain, but we only want to initialize
    //the message list once.
    if(pResults->DcList.lmsgOutput.Flink == NULL)       
        InitializeListHead( &pResults->DcList.lmsgOutput );

    //
    // First try getting the list of DCs from the DS
    //

    if ( !GetDcListFromDs( pParams, pResults, pTestedDomain ) ) {
        pResults->DcList.hr = S_FALSE;
        hrRetVal = S_FALSE;
    }

    //
    // If that failed,
    //  then try using the browser.
    //

    if( FHrOK(pResults->DcList.hr) )
    {
        if ( pTestedDomain->NetbiosDomainName ) 
        {
            NetStatus = LocalNetServerEnumEx(
                            NULL,
                            101,
                            (LPBYTE *)&ServerInfo101,
                            MAX_PREFERRED_LENGTH,
                            &EntriesRead,
                            &TotalEntries,
                            SV_TYPE_DOMAIN_CTRL | SV_TYPE_DOMAIN_BAKCTRL,
                            pTestedDomain->NetbiosDomainName,
                            NULL,       // Resume handle
                            pParams,
                            pResults);

            if ( NetStatus != NERR_Success && NetStatus != ERROR_MORE_DATA )
            {
                // "NetServerEnum failed. [%s]\n"
                SetMessage(&pResults->DcList.msgErr, Nd_Quiet,
                           IDS_DCLIST_NETSERVERENUM_FAILED, NetStatusToString(NetStatus));
                pResults->DcList.hr = HResultFromWin32(NetStatus);
                hrRetVal = S_FALSE;
                goto LERROR;
            }

            for ( i=0; i<EntriesRead; i++ )
            {
                //
                // Skip non-NT entries
                //

                if ( (ServerInfo101[i].sv101_type & SV_TYPE_NT) == 0 ) {
                    continue;
                }

                AddTestedDc( pParams,
                             pResults,
                             pTestedDomain,
                             ServerInfo101[i].sv101_name,
                             ServerInfo101[i].sv101_version_major >= 5 ?
                             DC_IS_NT5 :
                             DC_IS_NT4 );
            }
        }
        else
        {
            if ( pParams->fDebugVerbose )
            {
                // "'%ws' is not a Netbios domain name.  Cannot use NetServerEnum to find DCs\n"
                PrintMessage(pParams, IDS_DCLIST_NOT_A_NETBIOS_DOMAIN,
                             pTestedDomain->PrintableDomainName);
            }
        }
    }

    //
    // If we're really interested,
    //  get a list from SAM on the discovered DC.
    //  (But it's really slow)
    //

    if ( pParams->fDcAccountEnum ) {
        if ( !GetDcListFromSam( pParams, pResults, pTestedDomain ) ) {
            pResults->DcList.hr = S_FALSE;
            hrRetVal = S_FALSE;
        }
    }

LERROR:

    return hrRetVal;
}



NET_API_STATUS
GetBrowserServerList(
    IN PUNICODE_STRING TransportName,
    IN LPCWSTR Domain,
    OUT LPWSTR *BrowserList[],
    OUT PULONG BrowserListLength,
    IN BOOLEAN ForceRescan
    )
/*++

Routine Description:

    This function will return a list of browser servers.

Arguments:

    IN PUNICODE_STRING TransportName - Transport to return list.


Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{


    NET_API_STATUS Status;
    HANDLE BrowserHandle;
    PLMDR_REQUEST_PACKET RequestPacket = NULL;

//    DbgPrint("Getting browser server list for transport %wZ\n", TransportName);

    Status = OpenBrowser(&BrowserHandle);

    if (Status != NERR_Success) {
        return Status;
    }

    RequestPacket = Malloc( sizeof(LMDR_REQUEST_PACKET)+(DNLEN*sizeof(WCHAR))+TransportName->MaximumLength);
    if (RequestPacket == NULL) {
        NtClose(BrowserHandle);
        return(GetLastError());
    }

    ZeroMemory( RequestPacket, sizeof(LMDR_REQUEST_PACKET)+(DNLEN*sizeof(WCHAR))+TransportName->MaximumLength );

    RequestPacket->Version = LMDR_REQUEST_PACKET_VERSION_DOM;

    RequestPacket->Level = 0;

    RequestPacket->Parameters.GetBrowserServerList.ForceRescan = ForceRescan;

    if (Domain != NULL)
    {
        wcscpy(RequestPacket->Parameters.GetBrowserServerList.DomainName, Domain);

        RequestPacket->Parameters.GetBrowserServerList.DomainNameLength = (USHORT)wcslen(Domain) * sizeof(WCHAR);
    }
    else
    {
        RequestPacket->Parameters.GetBrowserServerList.DomainNameLength = 0;
        RequestPacket->Parameters.GetBrowserServerList.DomainName[0] = L'\0';

    }

    RequestPacket->TransportName.Buffer = (PWSTR)((PCHAR)RequestPacket+sizeof(LMDR_REQUEST_PACKET)+DNLEN*sizeof(WCHAR));
    RequestPacket->TransportName.MaximumLength = TransportName->MaximumLength;

    RtlCopyUnicodeString(&RequestPacket->TransportName, TransportName);
    RtlInitUnicodeString( &RequestPacket->EmulatedDomainName, NULL );

    RequestPacket->Parameters.GetBrowserServerList.ResumeHandle = 0;

    Status = DeviceControlGetInfo(
                BrowserHandle,
                IOCTL_LMDR_GET_BROWSER_SERVER_LIST,
                RequestPacket,
                sizeof(LMDR_REQUEST_PACKET)+
                    (DNLEN*sizeof(WCHAR))+TransportName->MaximumLength,
                (PVOID *)BrowserList,
                0xffffffff,
                4096,
                NULL);

    if (Status == NERR_Success)
    {
        *BrowserListLength = RequestPacket->Parameters.GetBrowserServerList.EntriesRead;
    }

    NtClose(BrowserHandle);
    Free(RequestPacket);

    return Status;
}




#define API_SUCCESS(x)  ((x) == NERR_Success || (x) == ERROR_MORE_DATA)
NET_API_STATUS
EnumServersForTransport(
    IN PUNICODE_STRING TransportName,
    IN LPCWSTR DomainName OPTIONAL,
    IN ULONG level,
    IN ULONG prefmaxlen,
    IN ULONG servertype,
    IN LPWSTR CurrentComputerName,
    OUT PINTERIM_SERVER_LIST InterimServerList,
    OUT PULONG TotalEntriesOnThisTransport,
    IN LPCWSTR FirstNameToReturn,
    IN BOOLEAN WannishTransport,
    IN BOOLEAN RasTransport,
    IN BOOLEAN IpxTransport
    )
{
    PWSTR *BrowserList = NULL;
    ULONG BrowserListLength = 0;
    NET_API_STATUS Status;
    PVOID ServerList = NULL;
    ULONG EntriesInList = 0;
    ULONG ServerIndex = 0;

    //
    //  Skip over IPX transports - we can't contact machines over them anyway.
    //

    *TotalEntriesOnThisTransport = 0;

    if (IpxTransport) {
        return NERR_Success;
    }

    //
    //  Retrieve a new browser list.  Do not force a revalidation.
    //

    Status = GetBrowserServerList(TransportName,
                                    DomainName,
                                    &BrowserList,
                                    &BrowserListLength,
                                    FALSE);

    //
    //  If a domain name was specified and we were unable to find the browse
    //  master for the domain and we are running on a wannish transport,
    //  invoke the "double hop" code and allow a local browser server
    //  remote the API to the browse master for that domain (we assume that
    //  this means that the workgroup is on a different subnet of a WAN).
    //

    if (!API_SUCCESS(Status) &&
        DomainName != NULL) {

        Status = GetBrowserServerList(TransportName,
                                    NULL,
                                    &BrowserList,
                                    &BrowserListLength,
                                    FALSE);


    }


    //
    //  If we were able to retrieve the list, remote the API.  Otherwise
    //  return.
    //

    if (API_SUCCESS(Status)) {

        do {
            LPWSTR Transport;
            LPWSTR ServerName;
            BOOL AlreadyInTree;

            //
            // Remote the API to that server.
            //

            Transport = TransportName->Buffer;
            ServerName = BrowserList[0];
            *TotalEntriesOnThisTransport = 0;

                Status = RxNetServerEnum(
                             ServerName,
                             Transport,
                             level,
                             (LPBYTE *)&ServerList,
                             prefmaxlen,
                             &EntriesInList,
                             TotalEntriesOnThisTransport,
                             servertype,
                             DomainName,
                             FirstNameToReturn );



            if ( !API_SUCCESS(Status)) {
                NET_API_STATUS GetBListStatus;

                //
                //  If we failed to remote the API for some reason,
                //  we want to regenerate the bowsers list of browser
                //  servers.
                //

                if (BrowserList != NULL) {

                    LocalFree(BrowserList);

                    BrowserList = NULL;
                }


                GetBListStatus = GetBrowserServerList(TransportName,
                                                            DomainName,
                                                            &BrowserList,
                                                            &BrowserListLength,
                                                            TRUE);
                if (GetBListStatus != NERR_Success) {

                    //
                    //  If we were unable to reload the list,
                    //  try the next transport.
                    //

                    break;
                }

                ServerIndex += 1;

                //
                //  If we've looped more times than we got servers
                //  in the list, we're done.
                //

                if ( ServerIndex > BrowserListLength ) {
                    break;
                }

            } else {

                NET_API_STATUS TempStatus;
                TempStatus = MergeServerList(
                                        InterimServerList,
                                        level,
                                        ServerList,
                                        EntriesInList,
                                        *TotalEntriesOnThisTransport );

                if ( TempStatus != NERR_Success ) {
                    Status = TempStatus;
                }

                //
                //  The remote API succeeded.
                //
                //  Now free up the remaining parts of the list.
                //

                if (ServerList != NULL) {
                    NetApiBufferFree(ServerList);
                    ServerList = NULL;
                }

                // We're done regardless of the success or failure of MergeServerList.
                break;

            }

        } while ( !API_SUCCESS(Status) );

    }

    //
    //  Free up the browser list.
    //

    if (BrowserList != NULL) {
        LocalFree(BrowserList);
        BrowserList = NULL;
    }

    return Status;
}


NET_API_STATUS NET_API_FUNCTION
LocalNetServerEnumEx(
    IN  LPCWSTR     servername OPTIONAL,
    IN  DWORD       level,
    OUT LPBYTE      *bufptr,
    IN  DWORD       prefmaxlen,
    OUT LPDWORD     entriesread,
    OUT LPDWORD     totalentries,
    IN  DWORD       servertype,
    IN  LPCWSTR     domain OPTIONAL,
    IN  LPCWSTR     FirstNameToReturnArg OPTIONAL,
    IN  NETDIAG_PARAMS *pParams,
    IN OUT NETDIAG_RESULT *pResults
    )
/*++

Routine Description:

    This is identical to the real NetServerEnumEx except it only uses the
    Netbt transport that the nettest utility has found.

Arguments:

    servername - Supplies the name of server to execute this function

    level - Supplies the requested level of information.

    bufptr - Returns a pointer to a buffer which contains the
        requested transport information.

    prefmaxlen - Supplies the number of bytes of information
        to return in the buffer.  If this value is MAXULONG, we will try
        to return all available information if there is enough memory
        resource.

    entriesread - Returns the number of entries read into the buffer.  This
        value is returned only if the return code is NERR_Success or
        ERROR_MORE_DATA.

    totalentries - Returns the total number of entries available.  This value
        is returned only if the return code is NERR_Success or ERROR_MORE_DATA.

    servertype - Supplies the type of server to enumerate.

    domain - Supplies the name of one of the active domains to enumerate the
        servers from.  If NULL, servers from the primary domain, logon domain
        and other domains are enumerated.

    FirstNameToReturnArg - Supplies the name of the first domain or server entry to return.
        The caller can use this parameter to implement a resume handle of sorts by passing
        the name of the last entry returned on a previous call.  (Notice that the specified
        entry will, also, be returned on this call unless it has since been deleted.)
        Pass NULL (or a zero length string) to start with the first entry available.


Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

    ERROR_MORE_DATA - More servers are available to be enumerated.

        It is possible to return ERROR_MORE_DATA and zero entries in the case
        where the browser server used doesn't support enumerating all the entries
        it has. (e.g., an NT 3.5x Domain Master Browser that downloaded a domain
        list from WINS and the WINS list is more than 64Kb long.) The caller
        should simply ignore the additional data.

        It is possible to fail to return ERROR_MORE_DATA and return a truncated
        list.  (e.g., an NT 3.5x Backup browser or WIN 95 backup browser in the
        above mentioned domain.  Such a backup browser replicates only 64kb
        of data from the DMB (PDC) then represents that list as the entire list.)
        The caller should ignore this problem.  The site should upgrade its
        browser servers.

--*/
{
    INTERIM_SERVER_LIST InterimServerList;
    NET_API_STATUS Status;
    DWORD DomainNameSize = 0;
    WCHAR DomainName[DNLEN + 1];
    WCHAR FirstNameToReturn[DNLEN+1];
    DWORD LocalTotalEntries;
    BOOLEAN AnyTransportHasMoreData = FALSE;


    //
    // Canonicalize the input parameters to make later comparisons easier.
    //

    if (ARGUMENT_PRESENT(domain)) {

        if ( I_NetNameCanonicalize(
                          NULL,
                          (LPWSTR) domain,
                          DomainName,
                          (DNLEN + 1) * sizeof(WCHAR),
                          NAMETYPE_WORKGROUP,
                          LM2X_COMPATIBLE
                          ) != NERR_Success) {
            return ERROR_INVALID_PARAMETER;
        }

        DomainNameSize = wcslen(DomainName) * sizeof(WCHAR);

        domain = DomainName;
    }

    if (ARGUMENT_PRESENT(FirstNameToReturnArg)  && *FirstNameToReturnArg != L'\0') {

        if ( I_NetNameCanonicalize(
                          NULL,
                          (LPWSTR) FirstNameToReturnArg,
                          FirstNameToReturn,
                          sizeof(FirstNameToReturn),
                          NAMETYPE_WORKGROUP,
                          LM2X_COMPATIBLE
                          ) != NERR_Success) {
            return ERROR_INVALID_PARAMETER;
        }

    } else {
        FirstNameToReturn[0] = L'\0';
    }

    if ((servername != NULL) &&
        ( *servername != L'\0')) {

        //
        // Call downlevel version of the API
        //

        Status = RxNetServerEnum(
                     servername,
                     NULL,
                     level,
                     bufptr,
                     prefmaxlen,
                     entriesread,
                     totalentries,
                     servertype,
                     domain,
                     FirstNameToReturn );

        return Status;
    }

    //
    // Only levels 100 and 101 are valid
    //

    if ((level != 100) && (level != 101)) {
        return ERROR_INVALID_LEVEL;
    }

    if (servertype != SV_TYPE_ALL) {
        if (servertype & SV_TYPE_DOMAIN_ENUM) {
            if (servertype != SV_TYPE_DOMAIN_ENUM) {
                return ERROR_INVALID_FUNCTION;
            }
        }
    }

    //
    //  Initialize the buffer to a known value.
    //

    *bufptr = NULL;

    *entriesread = 0;

    *totalentries = 0;


    Status = InitializeInterimServerList(&InterimServerList, NULL, NULL, NULL, NULL);

    try {
        BOOL AnyEnumServersSucceeded = FALSE;
        LPWSTR MyComputerName = NULL;
        PLIST_ENTRY ListEntry;
        PNETBT_TRANSPORT NetbtTransport;

        Status = NetpGetComputerName( &MyComputerName);

        if ( Status != NERR_Success ) {
            goto try_exit;
        }

        //
        // Loop through the list of netbt transports browsing on each one
        //

        for ( ListEntry = pResults->NetBt.Transports.Flink ;
              ListEntry != &pResults->NetBt.Transports ;
              ListEntry = ListEntry->Flink ) {

            UNICODE_STRING TransportName;

            //
            // If the transport names match,
            //  return the entry
            //

            NetbtTransport = CONTAINING_RECORD( ListEntry, NETBT_TRANSPORT, Next );

            if ( (NetbtTransport->Flags & BOUND_TO_BOWSER) == 0 ) {
                continue;
            }

            RtlInitUnicodeString( &TransportName, NetbtTransport->pswzTransportName );

            Status = EnumServersForTransport(&TransportName,
                                             domain,
                                             level,
                                             prefmaxlen,
                                             servertype,
                                             MyComputerName,
                                             &InterimServerList,
                                             &LocalTotalEntries,
                                             FirstNameToReturn,
                                             FALSE,
                                             FALSE,
                                             FALSE );

            if (API_SUCCESS(Status)) {
                if ( Status == ERROR_MORE_DATA ) {
                    AnyTransportHasMoreData = TRUE;
                }
                AnyEnumServersSucceeded = TRUE;
                if ( LocalTotalEntries > *totalentries ) {
                    *totalentries = LocalTotalEntries;
                }
            }

        }

        if ( MyComputerName != NULL ) {
            (void) NetApiBufferFree( MyComputerName );
        }

        if (AnyEnumServersSucceeded) {

            //
            //  Pack the interim server list into its final form.
            //

            Status = PackServerList(&InterimServerList,
                            level,
                            servertype,
                            prefmaxlen,
                            (PVOID *)bufptr,
                            entriesread,
                            &LocalTotalEntries,  // Pack thinks it has ALL the entries
                            NULL ); // The server has already returned us the right entries

            if ( API_SUCCESS( Status ) ) {
                if ( LocalTotalEntries > *totalentries ) {
                    *totalentries = LocalTotalEntries;
                }
            }
        }

try_exit:NOTHING;
    } finally {
        UninitializeInterimServerList(&InterimServerList);
    }

    if ( API_SUCCESS( Status )) {

        //
        // At this point,
        //  *totalentries is the largest of:
        //      The TotalEntries returned from any transport.
        //      The actual number of entries read.
        //
        // Adjust TotalEntries returned for reality.
        //

        if ( Status == NERR_Success ) {
            *totalentries = *entriesread;
        } else {
            if ( *totalentries <= *entriesread ) {
                *totalentries = *entriesread + 1;
            }
        }

        //
        // Ensure we return ERROR_MORE_DATA if any transport has more data.
        //

        if ( AnyTransportHasMoreData ) {
            Status = ERROR_MORE_DATA;
        }
    }

    return Status;
}



BOOL
GetDcListFromDs(
    IN NETDIAG_PARAMS*      pParams,
    IN OUT NETDIAG_RESULT*  pResults,
    IN PTESTED_DOMAIN       TestedDomain
    )
/*++

Routine Description:

    Get a list of DCs in this domain from the DS on an up DC.

Arguments:

    TestedDomain - Domain to get the DC list for

Return Value:

    TRUE: Test suceeded.
    FALSE: Test failed

--*/
{
    NET_API_STATUS NetStatus;
    PDS_DOMAIN_CONTROLLER_INFO_1W DcInfo = NULL;
    HANDLE DsHandle = NULL;
    DWORD DcCount;
    BOOL RetVal = TRUE;
    ULONG i;
    const WCHAR c_szDcPrefix[] = L"\\\\";
    LPWSTR pwszDcName;
	LPTSTR pszDcType;

    PTESTED_DC TestedDc;

    //
    // Get a DC to seed the algorithm with
    //

    if ( TestedDomain->DcInfo == NULL ) {

        if ( TestedDomain->fTriedToFindDcInfo ) {
            //"    '%ws': Cannot find DC to get DC list from.\n" 
            AddMessageToList(&pResults->DcList.lmsgOutput, Nd_Quiet, IDS_DCLIST_NO_DC, 
                         TestedDomain->PrintableDomainName );
            RetVal = FALSE;
            goto Cleanup;
        }

		pszDcType = LoadAndAllocString(IDS_DCTYPE_DC);

        NetStatus = DoDsGetDcName( pParams,
                                   pResults,
                                   &pResults->DcList.lmsgOutput,
                                   TestedDomain,
                                   DS_DIRECTORY_SERVICE_PREFERRED,
                                   pszDcType,
                                   FALSE,
                                   &TestedDomain->DcInfo );

		Free(pszDcType);

        TestedDomain->fTriedToFindDcInfo = TRUE;

        if ( NetStatus != NO_ERROR ) {
             //"    '%ws': Cannot find DC to get DC list from.\n" 
             AddMessageToList(&pResults->DcList.lmsgOutput, Nd_Quiet, IDS_DCLIST_NO_DC);
             AddIMessageToList(&pResults->DcList.lmsgOutput, Nd_Quiet, 4, 
                                  IDS_GLOBAL_STATUS, NetStatusToString(NetStatus) );
            RetVal = FALSE;
            goto Cleanup;
        }
    }

    // if the DC doesn't support DS, we should not try to call DsBindW()
    if (!(TestedDomain->DcInfo->Flags & DS_DS_FLAG))
        goto Cleanup;

    //
    // Get a DC that's UP.
    //

    TestedDc = GetUpTestedDc( TestedDomain );

    if ( TestedDc == NULL ) {
        //IDS_DCLIST_NO_DC_UP   "    '%ws': No DCs are up.\n"
        AddMessageToList(&pResults->DcList.lmsgOutput, Nd_Quiet, IDS_DCLIST_NO_DC_UP,
               TestedDomain->PrintableDomainName );
        PrintGuruMessage2("    '%ws': No DCs are up.\n", TestedDomain->PrintableDomainName );
        PrintGuru( 0, DSGETDC_GURU );
        RetVal = FALSE;
        goto Cleanup;
    }

    //
    // Bind to the target DC
    //

    pwszDcName = Malloc((wcslen(TestedDc->ComputerName) + wcslen(c_szDcPrefix) + 1) * sizeof(WCHAR));
    if (pwszDcName == NULL)
    {
        DebugMessage("Out of Memory!");
        RetVal = FALSE;
        goto Cleanup;
    }
    wcscpy(pwszDcName, c_szDcPrefix);

	assert(TestedDc->ComputerName);

	if (TestedDc->ComputerName)
	{
		wcscat(pwszDcName, TestedDc->ComputerName);	
	}
    
    NetStatus = DsBindW( pwszDcName,
                         NULL,
                         &DsHandle );

    Free(pwszDcName);

    if ( NetStatus != NO_ERROR ) {

        //
        // Only warn if we don't have access
        //

        if ( NetStatus == ERROR_ACCESS_DENIED ) {
            //IDS_DCLIST_NO_ACCESS_DSBIND   "        You don't have access to DsBind to %ws (%ws) (Trying NetServerEnum). [%s]\n"
            AddMessageToList(&pResults->DcList.lmsgOutput, Nd_ReallyVerbose, IDS_DCLIST_NO_ACCESS_DSBIND,
                   TestedDc->NetbiosDcName,
                   TestedDc->DcIpAddress,
                   NetStatusToString(NetStatus));
        } else {
            //IDS_DCLIST_ERR_DSBIND     "    [WARNING] Cannot call DsBind to %ws (%ws). [%s]\n"
            AddMessageToList(&pResults->DcList.lmsgOutput, Nd_Quiet, IDS_DCLIST_ERR_DSBIND,
                   TestedDc->ComputerName,
                   TestedDc->DcIpAddress,
                   NetStatusToString(NetStatus));
            PrintGuruMessage3("    [WARNING] Cannot call DsBind to %ws (%ws).\n",
                   TestedDc->NetbiosDcName,
                   TestedDc->DcIpAddress );
            PrintGuru( NetStatus, DS_GURU );
        }
        RetVal = FALSE;
        goto Cleanup;
    }

    //
    // Get the list of DCs from the target DC.
    //
    NetStatus = DsGetDomainControllerInfoW(
                    DsHandle,
                    TestedDomain->DnsDomainName != NULL ?
                        TestedDomain->DnsDomainName :
                        TestedDomain->NetbiosDomainName,
                    1,      // Info level
                    &DcCount,
                    &DcInfo );

    if ( NetStatus != NO_ERROR ) {
        //IDS_DCLIST_ERR_GETDCINFO      "    [WARNING] Cannot call DsGetDomainControllerInfoW to %ws (%ws). [%s]\n"
        AddMessageToList( &pResults->DcList.lmsgOutput, Nd_Quiet, IDS_DCLIST_ERR_GETDCINFO,
               TestedDc->NetbiosDcName,
               TestedDc->DcIpAddress, NetStatusToString(NetStatus) );
        PrintGuruMessage3("    [WARNING] Cannot call DsGetDomainControllerInfoW to %ws (%ws).",
               TestedDc->NetbiosDcName,
               TestedDc->DcIpAddress );
        PrintGuru( NetStatus, DS_GURU );
        RetVal = FALSE;
        goto Cleanup;
    }

    //
    // Loop though the list of DCs.
    //

    if(pParams->fDebugVerbose)
    {
        // IDS_DCLIST_DCS   "   DC list for domain %ws:\n"
        PrintMessage(pParams, IDS_DCLIST_DCS, TestedDomain->PrintableDomainName);
    }

    for ( i=0; i<DcCount; i++ ) 
    {
        if ( pParams->fDebugVerbose ) 
        {

            //IDS_DCLIST_13421                  "        %ws" 
            PrintMessage(pParams, IDS_DCLIST_13421,
                   DcInfo[i].DnsHostName != NULL ?
                        DcInfo[i].DnsHostName :
                        DcInfo[i].NetbiosName );
            if ( DcInfo[i].fIsPdc ) {
                //IDS_DCLIST_13422                  " [PDC emulator]" 
				//if is NT4 DC, just say PDC
                PrintMessage(pParams, DcInfo[i].fDsEnabled ? IDS_DCLIST_13422 : IDS_DCLIST_NT4_PDC);
            }
            if ( DcInfo[i].fDsEnabled ) {
                //IDS_DCLIST_13423                  " [DS]" 
                PrintMessage(pParams, IDS_DCLIST_13423);
            }
            if ( DcInfo[i].SiteName != NULL ) {
                //IDS_DCLIST_13424                  " Site: %ws" 
                PrintMessage(pParams, IDS_DCLIST_13424, DcInfo[i].SiteName );
            }
            //IDS_DCLIST_13425                  "\n" 
            PrintMessage(pParams, IDS_DCLIST_13425);
        }

        //
        // Add this DC to the list of DCs to test.
        //
        AddTestedDc( pParams,
                     pResults,
                     TestedDomain,
                     DcInfo[i].DnsHostName != NULL ?
                         DcInfo[i].DnsHostName :
                         DcInfo[i].NetbiosName,
                     DcInfo[i].fDsEnabled ?
                            DC_IS_NT5 :
                            DC_IS_NT4 );
    }


    //
    // Cleanup locally used resources
    //
Cleanup:
    if ( DcInfo != NULL ) {
        DsFreeDomainControllerInfoW( 1, DcCount, DcInfo );
    }

    if ( DsHandle != NULL ) {
        DsUnBindW( &DsHandle );
    }
    return RetVal;
}


BOOL
GetDcListFromSam(
    IN NETDIAG_PARAMS*  pParams,
    IN OUT  NETDIAG_RESULT*  pResults,
    IN PTESTED_DOMAIN   TestedDomain
    )
/*++

Routine Description:

    Get a list of DCs in this domain from SAM on the current DC.

Arguments:

    TestedDomain - Domain to get the DC list for

Return Value:

    TRUE: Test suceeded.
    FALSE: Test failed

--*/
{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;
    BOOL RetVal = TRUE;

    SAM_HANDLE LocalSamHandle = NULL;
    SAM_HANDLE DomainHandle = NULL;

    LSA_HANDLE  LSAPolicyHandle = NULL;
    OBJECT_ATTRIBUTES LSAObjectAttributes;
    PPOLICY_ACCOUNT_DOMAIN_INFO AccountDomainInfo = NULL;

    PDOMAIN_DISPLAY_MACHINE MachineInformation = NULL;
    NTSTATUS SamStatus;
    ULONG SamIndex;
	LPTSTR pszDcType;

    //
    // Get a DC to seed the algorithm with
    //

    if ( TestedDomain->DcInfo == NULL ) {

        if ( TestedDomain->fTriedToFindDcInfo ) {
            if(pParams->fDebugVerbose)
            {
                //IDS_DCLIST_13426                  "        Cannot find DC to get DC list from (Test skipped).\n" 
                PrintMessage(pParams, IDS_DCLIST_13426 );
            }
            goto Cleanup;
        }

		pszDcType = LoadAndAllocString(IDS_DCTYPE_DC);
        NetStatus = DoDsGetDcName( pParams,
                                   pResults,
                                   &pResults->DcList.lmsgOutput,
                                   TestedDomain,
                                   DS_DIRECTORY_SERVICE_PREFERRED,
                                   pszDcType,
                                   FALSE,
                                   &TestedDomain->DcInfo );
		Free(pszDcType);

        TestedDomain->fTriedToFindDcInfo = TRUE;

        if ( NetStatus != NO_ERROR ) {
            if(pParams->fDebugVerbose)
            {
                //IDS_DCLIST_13427                  "    Cannot find DC to get DC list from (Test skipped). [%s]\n" 
                PrintMessage(pParams, IDS_DCLIST_13427, NetStatusToString(NetStatus) );
                PrintMessage(pParams, IDS_GLOBAL_STATUS, NetStatusToString( NetStatus ));
            }
            goto Cleanup;
        }
    }

    if ( pParams->fReallyVerbose ) {
//IDS_DCLIST_13428                  "    Get list of DC accounts from SAM in domain '%ws'.\n" 
        PrintMessage(pParams, IDS_DCLIST_13428, TestedDomain->PrintableDomainName);
    }


    //
    // Connect to the SAM server
    //

    Status = NettestSamConnect( pParams,
                TestedDomain->DcInfo->DomainControllerName,
                &LocalSamHandle );

    if ( !NT_SUCCESS(Status)) {
        if ( Status == STATUS_ACCESS_DENIED ) {
            RetVal = FALSE;
        }
        goto Cleanup;
    }

    //
    // If we don't have a domain sid,
    //  find out what it is.
    //

    if ( TestedDomain->DomainSid == NULL ) {
        UNICODE_STRING ServerNameString;


        //
        // Open LSA to read account domain info.
        //

        InitializeObjectAttributes( &LSAObjectAttributes,
                                      NULL,             // Name
                                      0,                // Attributes
                                      NULL,             // Root
                                      NULL );           // Security Descriptor

        RtlInitUnicodeString( &ServerNameString, TestedDomain->DcInfo->DomainControllerName );

        Status = LsaOpenPolicy( &ServerNameString,
                                &LSAObjectAttributes,
                                POLICY_VIEW_LOCAL_INFORMATION,
                                &LSAPolicyHandle );

        if( !NT_SUCCESS(Status) ) {
            if(pParams->fDebugVerbose)
            {
                //IDS_DCLIST_13429                  "    [FATAL] Cannot LsaOpenPolicy to LSA on '%ws'." 
                PrintMessage(pParams, IDS_DCLIST_13429, TestedDomain->DcInfo->DomainControllerName );
            }
            PrintGuruMessage2("    [FATAL] Cannot LsaOpenPolicy to LSA on '%ws'." , TestedDomain->DcInfo->DomainControllerName );
            PrintGuru( NetpNtStatusToApiStatus( Status ), LSA_GURU );
            RetVal = FALSE;
            goto Cleanup;
        }


        //
        // Now read account domain info from LSA.
        //

        Status = LsaQueryInformationPolicy(
                        LSAPolicyHandle,
                        PolicyAccountDomainInformation,
                        (PVOID *) &AccountDomainInfo );

        if( !NT_SUCCESS(Status) ) {
            AccountDomainInfo = NULL;
            if(pParams->fDebugVerbose)
            {
                //IDS_DCLIST_13430                  "    [FATAL] Cannot LsaQueryInformationPolicy (AccountDomainInfor) to LSA on '%ws'." 
                PrintMessage(pParams, IDS_DCLIST_13430, TestedDomain->DcInfo->DomainControllerName );
            }
            PrintGuruMessage2("    [FATAL] Cannot LsaQueryInformationPolicy (AccountDomainInfor) to LSA on '%ws'.", TestedDomain->DcInfo->DomainControllerName );
            PrintGuru( NetpNtStatusToApiStatus( Status ), LSA_GURU );
            RetVal = FALSE;
            goto Cleanup;
        }

        //
        // Save the domain sid for other tests
        //

        pResults->Global.pMemberDomain->DomainSid =
            Malloc( RtlLengthSid( AccountDomainInfo->DomainSid ) );

        if ( pResults->Global.pMemberDomain->DomainSid == NULL ) {
            //IDS_DCLIST_13431                  "Out of memory\n" 
            PrintMessage(pParams, IDS_DCLIST_13431);
            RetVal = FALSE;
            goto Cleanup;
        }

        RtlCopyMemory( pResults->Global.pMemberDomain->DomainSid,
                       AccountDomainInfo->DomainSid,
                       RtlLengthSid( AccountDomainInfo->DomainSid ) );

        if ( pParams->fReallyVerbose ) {
            //IDS_DCLIST_13432                  "    Domain Sid:          " 
            PrintMessage(pParams, IDS_DCLIST_13432);
            PrintSid( pParams, pResults->Global.pMemberDomain->DomainSid );
        }
    }

    //
    // Open the domain.
    //

    Status = SamOpenDomain( LocalSamHandle,
                            DOMAIN_LIST_ACCOUNTS |
                                DOMAIN_LOOKUP,
                            pResults->Global.pMemberDomain->DomainSid,
                            &DomainHandle );

    if ( !NT_SUCCESS( Status ) ) {
        if(pParams->fDebugVerbose)
        {
            //IDS_DCLIST_13433                  "    [FATAL] Cannot SamOpenDomain on '%ws'." 
            PrintMessage(pParams, IDS_DCLIST_13433, TestedDomain->DcInfo->DomainControllerName );
        }
        PrintGuruMessage2("    [FATAL] Cannot SamOpenDomain on '%ws'.", TestedDomain->DcInfo->DomainControllerName );
        PrintGuru( NetpNtStatusToApiStatus( Status ), SAM_GURU );
        RetVal = FALSE;
        goto Cleanup;
    }



    //
    // Loop building a list of DC names from SAM.
    //
    // On each iteration of the loop,
    //  get the next several machine accounts from SAM.
    //  determine which of those names are DC names.
    //  Merge the DC names into the list we're currently building of all DCs.
    //

    SamIndex = 0;
    do {
        //
        // Arguments to SamQueryDisplayInformation
        //
        ULONG TotalBytesAvailable;
        ULONG BytesReturned;
        ULONG EntriesRead;

        DWORD i;

        //
        // Get the list of machine accounts from SAM
        //

        SamStatus = SamQueryDisplayInformation (
                        DomainHandle,
                        DomainDisplayMachine,
                        SamIndex,
                        4096,   // Machines per pass
                        0xFFFFFFFF, // PrefMaxLen
                        &TotalBytesAvailable,
                        &BytesReturned,
                        &EntriesRead,
                        &MachineInformation );

        if ( !NT_SUCCESS(SamStatus) ) {
            Status = SamStatus;
            if(pParams->fDebugVerbose)
            {
                //IDS_DCLIST_13434                  "    [FATAL] Cannot SamQueryDisplayInformation on '%ws'." 
                PrintMessage(pParams, IDS_DCLIST_13434, TestedDomain->DcInfo->DomainControllerName );
            }
            PrintGuruMessage2("    [FATAL] Cannot SamQueryDisplayInformation on '%ws'.", TestedDomain->DcInfo->DomainControllerName );
            PrintGuru( NetpNtStatusToApiStatus( Status ), SAM_GURU );
            RetVal = FALSE;
            goto Cleanup;
        }

        //
        // Set up for the next call to Sam.
        //

        if ( SamStatus == STATUS_MORE_ENTRIES ) {
            SamIndex = MachineInformation[EntriesRead-1].Index;
        }


        //
        // Loop though the list of machine accounts finding the Server accounts.
        //

        for ( i=0; i<EntriesRead; i++ ) {

            //
            // Ensure the machine account is a server account.
            //

            if ( MachineInformation[i].AccountControl &
                    USER_SERVER_TRUST_ACCOUNT ) {
                WCHAR LocalComputerName[CNLEN+1];
                ULONG LocalComputerNameLength;


                //
                // Insert the server session.
                //
                if(pParams->fDebugVerbose)
                {
                    //IDS_DCLIST_13435                  "%wZ %ld\n" 
                    PrintMessage(pParams,  IDS_DCLIST_13435, &MachineInformation[i].Machine, MachineInformation[i].Rid );
                }

                LocalComputerNameLength =
                        min( MachineInformation[i].Machine.Length/sizeof(WCHAR) - 1,
                             CNLEN );
                RtlCopyMemory( LocalComputerName,
                               MachineInformation[i].Machine.Buffer,
                               LocalComputerNameLength * sizeof(WCHAR) );
                LocalComputerName[LocalComputerNameLength] = '\0';

                AddTestedDc( pParams,
                             pResults,
                             TestedDomain, LocalComputerName, 0 );

            }
        }

        //
        // Free the buffer returned from SAM.
        //

        if ( MachineInformation != NULL ) {
            SamFreeMemory( MachineInformation );
            MachineInformation = NULL;
        }

    } while ( SamStatus == STATUS_MORE_ENTRIES );


    //
    // Cleanup locally used resources
    //
Cleanup:
    if ( DomainHandle != NULL ) {
        (VOID) SamCloseHandle( DomainHandle );
    }
    if ( AccountDomainInfo != NULL ) {
        LsaFreeMemory( AccountDomainInfo );
        AccountDomainInfo = NULL;
    }

    if ( LocalSamHandle != NULL ) {
        (VOID) SamCloseHandle( LocalSamHandle );
    }

    if( LSAPolicyHandle != NULL ) {
        LsaClose( LSAPolicyHandle );
    }

    return RetVal;
}


//(nsun) _delete
/*
BOOL
GetDcListFromDc(
                IN NETDIAG_PARAMS *pParams,
                IN OUT NETDIAG_RESULT *pResults,
                IN PTESTED_DOMAIN pTestedDomain
    )
*++

Routine Description:

    Get a list of DCs in this domain from the current DC.

Arguments:

    pTestedDomain - Domain to get the DC list for

Return Value:

    TRUE: Test suceeded.
    FALSE: Test failed

--*
{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;
    BOOL RetVal = TRUE;

    SAM_HANDLE LocalSamHandle = NULL;
    SAM_HANDLE DomainHandle = NULL;

    LSA_HANDLE  LSAPolicyHandle = NULL;
    OBJECT_ATTRIBUTES LSAObjectAttributes;
    PPOLICY_ACCOUNT_DOMAIN_INFO AccountDomainInfo = NULL;
    
    PDOMAIN_DISPLAY_MACHINE MachineInformation = NULL;
    NTSTATUS SamStatus;
    ULONG SamIndex;
    
    LPWSTR LocalShareName = NULL;
    PTESTED_DC  pTestedDC;

    //
    // Get a DC to seed the algorithm with
    //

    if ( pTestedDomain->DcInfo == NULL )
    {

        NetStatus = GetADc( pParams,
                            pResults,
                            DsGetDcNameW,
                            pTestedDomain,
                            DS_DIRECTORY_SERVICE_PREFERRED,
                            &pTestedDomain->DcInfo );

        if ( NetStatus != NO_ERROR )
        {
//IDS_DCLIST_13436                  "    [FATAL] Cannot find DC to get DC list from." 
//            PrintMessage(pParams, IDS_DCLIST_13436 );
            RetVal = FALSE;
            goto Cleanup;
        }
    }

//    if ( pParams->fVerbose )
//  {
//IDS_DCLIST_13437                  "    Get list of DC account in domain '%ws'.\n" 
//        PrintMessage(pParams, IDS_DCLIST_13437, pTestedDomain->DomainName);
//    }


    //
    // Connect to the SAM server
    //

    Status = NettestSamConnect(
                               pParams,
                               pTestedDomain->DcInfo->DomainControllerName,
                               &LocalSamHandle,
                               &LocalShareName );

    if ( !NT_SUCCESS(Status)) {
        RetVal = FALSE;
        goto Cleanup;
    }

    //
    // If we don't have a domain sid,
    //  find out what it is.
    //

    if ( pTestedDomain->DomainSid == NULL ) {
        UNICODE_STRING ServerNameString;


        //
        // Open LSA to read account domain info.
        //

        InitializeObjectAttributes( &LSAObjectAttributes,
                                      NULL,             // Name
                                      0,                // Attributes
                                      NULL,             // Root
                                      NULL );           // Security Descriptor

        RtlInitUnicodeString( &ServerNameString, pTestedDomain->DcInfo->DomainControllerName );

        Status = LsaOpenPolicy( &ServerNameString,
                                &LSAObjectAttributes,
                                POLICY_VIEW_LOCAL_INFORMATION,
                                &LSAPolicyHandle );

        if( !NT_SUCCESS(Status) )
        {
            // "    [FATAL] Cannot LsaOpenPolicy to LSA on '%ws'.", 
            if (pParams->fDebugVerbose)
                PrintMessage(pParams, IDS_DCLIST_LSAOPENPOLICY,
                             pTestedDomain->DcInfo->DomainControllerName );
            RetVal = FALSE;
            goto Cleanup;
        }


        //
        // Now read account domain info from LSA.
        //

        Status = LsaQueryInformationPolicy(
                        LSAPolicyHandle,
                        PolicyAccountDomainInformation,
                        (PVOID *) &AccountDomainInfo );

        if( !NT_SUCCESS(Status) )
        {
            AccountDomainInfo = NULL;

            // "    [FATAL] Cannot LsaQueryInformationPolicy (AccountDomainInfor) to LSA on '%ws'."
            if (pParams->fDebugVerbose)
                PrintMessage(pParams, IDS_DCLIST_LSAQUERYINFO,
                             pTestedDomain->DcInfo->DomainControllerName);
                
            RetVal = FALSE;
            goto Cleanup;
        }

        //
        // Save the domain sid for other tests
        //

        pResults->Global.pMemberDomain->DomainSid =
            Malloc( RtlLengthSid( AccountDomainInfo->DomainSid ) );

        if ( pResults->Global.pMemberDomain->DomainSid == NULL )
        {
            RetVal = FALSE;
            goto Cleanup;
        }

        // We have the domain SID
        pResults->Global.pMemberDomain->fDomainSid = TRUE;
        RtlCopyMemory( pResults->Global.pMemberDomain->DomainSid,
                       AccountDomainInfo->DomainSid,
                       RtlLengthSid( AccountDomainInfo->DomainSid ) );

//        if ( pParams->fVerbose ) {
//IDS_DCLIST_13438                  "    Domain Sid:          " 
//            PrintMessage(pParams, IDS_DCLIST_13438);
//            NlpDumpSid( pResults->Global.pMemberDomain->DomainSid );
//        }
    }

    //
    // Open the domain.
    //

    Status = SamOpenDomain( LocalSamHandle,
                            DOMAIN_LIST_ACCOUNTS |
                                DOMAIN_LOOKUP,
                            pResults->Global.pMemberDomain->DomainSid,
                            &DomainHandle );

    if ( !NT_SUCCESS( Status ) )
    {
        // "    [FATAL] Cannot SamOpenDomain on '%ws'."
        if (pParams->fDebugVerbose)
            PrintMessage(pParams, IDS_DCLIST_SAMOPENDOMAIN,
                         pTestedDomain->DcInfo->DomainControllerName);
        RetVal = FALSE;
        goto Cleanup;
    }



    //
    // Loop building a list of DC names from SAM.
    //
    // On each iteration of the loop,
    //  get the next several machine accounts from SAM.
    //  determine which of those names are DC names.
    //  Merge the DC names into the list we're currently building of all DCs.
    //

    SamIndex = 0;
    do {
        //
        // Arguments to SamQueryDisplayInformation
        //
        ULONG TotalBytesAvailable;
        ULONG BytesReturned;
        ULONG EntriesRead;

        DWORD i;

        //
        // Get the list of machine accounts from SAM
        //

        SamStatus = SamQueryDisplayInformation (
                        DomainHandle,
                        DomainDisplayMachine,
                        SamIndex,
                        4096,   // Machines per pass
                        0xFFFFFFFF, // PrefMaxLen
                        &TotalBytesAvailable,
                        &BytesReturned,
                        &EntriesRead,
                        &MachineInformation );

        if ( !NT_SUCCESS(SamStatus) )
        {
            Status = SamStatus;

            if (pParams->fDebugVerbose)
            {
                // "    [FATAL] Cannot SamQueryDisplayInformation on '%ws'."
                PrintMessage(pParams, IDS_DCLIST_SAMQUERYDISPLAYINFO,
                             pTestedDomain->DcInfo->DomainControllerName);
            }

            RetVal = FALSE;
            goto Cleanup;
        }

        //
        // Set up for the next call to Sam.
        //

        if ( SamStatus == STATUS_MORE_ENTRIES ) {
            SamIndex = MachineInformation[EntriesRead-1].Index;
        }


        //
        // Loop though the list of machine accounts finding the Server accounts.
        //

        for ( i=0; i<EntriesRead; i++ ) {

            //
            // Ensure the machine account is a server account.
            //

            if ( MachineInformation[i].AccountControl &
                    USER_SERVER_TRUST_ACCOUNT ) {
                WCHAR LocalComputerName[CNLEN+1];
                ULONG LocalComputerNameLength;


                //
                // Insert the server session.
                //
//IDS_DCLIST_13439                  "%wZ %ld\n" 
                //  PrintMessage(pParams,  IDS_DCLIST_13439, &MachineInformation[i].Machine, MachineInformation[i].Rid );

                LocalComputerNameLength =
                        min( MachineInformation[1].Machine.Length/sizeof(WCHAR) - 1,
                             CNLEN );
                RtlCopyMemory( LocalComputerName,
                               MachineInformation[1].Machine.Buffer,
                               LocalComputerNameLength * sizeof(WCHAR) );
                LocalComputerName[LocalComputerNameLength] = '\0';

                pTestedDC = AddTestedDc( pParams,
                                         pResults,
                                         pTestedDomain,
                                         LocalComputerName,
                                         0 );
                pTestedDC->Rid = MachineInformation[i].Rid;

            }
        }

        //
        // Free the buffer returned from SAM.
        //

        if ( MachineInformation != NULL ) {
            SamFreeMemory( MachineInformation );
            MachineInformation = NULL;
        }

    } while ( SamStatus == STATUS_MORE_ENTRIES );


    //
    // Cleanup locally used resources
    //
Cleanup:
    if ( DomainHandle != NULL ) {
        (VOID) SamCloseHandle( DomainHandle );
    }
    if ( AccountDomainInfo != NULL ) {
        LsaFreeMemory( AccountDomainInfo );
        AccountDomainInfo = NULL;
    }

    if ( LocalSamHandle != NULL ) {
        (VOID) SamCloseHandle( LocalSamHandle );
    }

    if( LSAPolicyHandle != NULL ) {
        LsaClose( LSAPolicyHandle );
    }

    if ( LocalShareName != NULL )
    {

        NET_API_STATUS TempStatus;

        TempStatus = NetUseDel( NULL, LocalShareName, FALSE );

        if ( (TempStatus != NERR_Success) && (pParams->fDebugVerbose) )
        {
            // "     [WARNING] Cannot NetUseDel '%ws' NULL session."
            PrintMessage(pParams, IDS_DCLIST_NETUSEDEL, LocalShareName );
        }

        NetpMemoryFree( LocalShareName );
    }

    return RetVal;
}
*/



/*!--------------------------------------------------------------------------
    DcListGlobalPrint
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void DcListGlobalPrint( NETDIAG_PARAMS* pParams,
                          NETDIAG_RESULT*  pResults)
{
    LIST_ENTRY *            pListEntry;
    LIST_ENTRY *            pListEntryDC;
    TESTED_DOMAIN *         pDomain;
    TESTED_DC *             pTestedDC;
    int                     i;
    
    if (!pResults->IpConfig.fEnabled)
    {
        return;
    }
    
    if (pParams->fVerbose || !FHrOK(pResults->DcList.hr))
    {
        PrintNewLine(pParams, 2);
        PrintTestTitleResult(pParams, IDS_DCLIST_LONG, IDS_DCLIST_SHORT,
                             pResults->DcList.fPerformed, 
                             pResults->DcList.hr, 0);
        PrintNdMessage(pParams, &pResults->DcList.msgErr);

        //The message list contains the error info
        PrintMessageList(pParams, &pResults->DcList.lmsgOutput);

        if (pParams->fReallyVerbose)
        {
            // Iterate through the list of tested domain
            // Iterate through each domain
            for (pListEntry = pResults->Global.listTestedDomains.Flink;
                 pListEntry != &pResults->Global.listTestedDomains;
                 pListEntry = pListEntry->Flink)
            {
                pDomain = CONTAINING_RECORD(pListEntry, TESTED_DOMAIN, Next);
                
                //  "    List of DCs in Domain '%ws':\n"                
                PrintMessage(pParams, IDS_DCLIST_DOMAIN_HEADER,
                             pDomain->PrintableDomainName);

                if (pDomain->fDomainSid)
                {
                    // print out the sid for the domain
                    PrintMessage(pParams, IDS_DCLIST_DOMAIN_SID);
                    PrintSid( pParams, pResults->Global.pMemberDomain->DomainSid );
                }

                for (pListEntryDC = pDomain->TestedDcs.Flink;
                     pListEntryDC != &pDomain->TestedDcs;
                     pListEntryDC = pListEntryDC->Flink)
                {
                    pTestedDC = CONTAINING_RECORD(pListEntryDC,
                        TESTED_DC, Next);
                    
                    PrintMessage(pParams, IDS_DCLIST_DC_INFO,
                                 pTestedDC->ComputerName);

                    if (pTestedDC->Rid)
                    {
                        PrintMessage(pParams, IDS_DCLIST_RID,
                                     pTestedDC->Rid);
                    }

                    if (pTestedDC->Flags & DC_IS_DOWN)
                    {
                        PrintMessage(pParams, IDS_DCLIST_DC_IS_DOWN);
                        
                        if (pTestedDC->Flags & DC_FAILED_PING)
                        {
                            PrintNewLine(pParams, 1);
                            PrintMessage(pParams, IDS_DCLIST_DC_FAILED_PING,
                                        pTestedDC->ComputerName);
                        }
                    }
                    PrintNewLine(pParams, 1);
                }
                
            }
            
        }
    }
}

/*!--------------------------------------------------------------------------
    DcListPerInterfacePrint
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void DcListPerInterfacePrint( NETDIAG_PARAMS* pParams,
                                NETDIAG_RESULT*  pResults,
                                INTERFACE_RESULT *pInterfaceResults)
{
    // no per-interface results
}


/*!--------------------------------------------------------------------------
    DcListCleanup
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void DcListCleanup( NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
{
    int     i;
    
    ClearMessage(&pResults->DcList.msgErr);
    MessageListCleanUp(&pResults->DcList.lmsgOutput);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\dcutil.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       dcutil.h
//
//--------------------------------------------------------------------------

#ifndef HEADER_DCUTIL
#define HEADER_DCUTIL

PTESTED_DC
AddTestedDc(IN NETDIAG_PARAMS *pParams,
			IN OUT NETDIAG_RESULT *pResults,
			IN PTESTED_DOMAIN TestedDomain,
			IN LPWSTR ComputerName,
			IN ULONG Flags
		   );

PTESTED_DC
FindTestedDc(IN OUT NETDIAG_RESULT *pResults,
			 IN LPWSTR ComputerName
			);

NET_API_STATUS
GetADc(IN NETDIAG_PARAMS *pParams,
	   IN OUT NETDIAG_RESULT *pResults,
       OUT PLIST_ENTRY plmsgOutput,
	   IN DSGETDCNAMEW *DsGetDcRoutine,
	   IN PTESTED_DOMAIN TestedDomain,
	   IN DWORD Flags,
	   OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
	  );

PTESTED_DC
GetUpTestedDc(
    IN PTESTED_DOMAIN TestedDomain
    );

BOOL
GetIpAddressForDc(PTESTED_DC TestedDc);

NET_API_STATUS
DoDsGetDcName(IN NETDIAG_PARAMS *pParams,
			  IN OUT NETDIAG_RESULT *pResults,
              OUT PLIST_ENTRY   plmsgOutput,
			  IN PTESTED_DOMAIN pTestedDomain,
			  IN DWORD Flags,
			  IN LPTSTR pszDcType,
			  IN BOOLEAN IsFatal,
			  OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
			 );

VOID
NetpIpAddressToStr(
    ULONG IpAddress,
    CHAR IpAddressString[NL_IP_ADDRESS_LENGTH+1]
    );

VOID
NetpIpAddressToWStr(
    ULONG IpAddress,
    WCHAR IpAddressString[NL_IP_ADDRESS_LENGTH+1]
    );

NET_API_STATUS
NetpDcBuildPing(
    IN BOOL PdcOnly,
    IN ULONG RequestCount,
    IN LPCWSTR UnicodeComputerName,
    IN LPCWSTR UnicodeUserName OPTIONAL,
    IN LPCSTR ResponseMailslotName,
    IN ULONG AllowableAccountControlBits,
    IN PSID RequestedDomainSid OPTIONAL,
    IN ULONG NtVersion,
    OUT PVOID *Message,
    OUT PULONG MessageSize
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\browser1.c ===
#include <precomp.h>
#include <nt.h>                  // DbgPrint prototype
#include <ntrtl.h>                  // DbgPrint
#include <nturtl.h>                 // Needed by winbase.h

#include <windef.h>                 // DWORD
#include <winbase.h>                // LocalFree

#include <rpcutil.h>                // GENERIC_ENUM_STRUCT

#include <lmcons.h>                 // NET_API_STATUS
#include <lmerr.h>                  // NetError codes
#include <lmremutl.h>               // SUPPORTS_RPC

#include <brnames.h>                // Service and interface names

#include <netlib.h>
#include <netdebug.h>

#include <winsvc.h>

#include <lmserver.h>
#include <tstr.h>

#include <ntddbrow.h>
#include <brcommon.h>               // Routines common between client & server

VOID
UpdateInterimServerListElement(
    IN PINTERIM_SERVER_LIST ServerList,
    IN PINTERIM_ELEMENT Element,
    IN ULONG Level,
    IN BOOLEAN NewElement
    );

PINTERIM_ELEMENT
AllocateInterimServerListEntry(
    IN PSERVER_INFO_101 ServerInfo,
    IN ULONG Level
    );

NET_API_STATUS
MergeServerList(
    IN OUT PINTERIM_SERVER_LIST InterimServerList,
    IN ULONG Level,
    IN PVOID NewServerList,
    IN ULONG NewEntriesRead,
    IN ULONG NewTotalEntries
    )
/*++

Routine Description:

    This function will merge two server lists.  It will reallocate the buffer
    for the old list if appropriate.

Arguments:

    IN OUT PINTERIM_SERVER_LIST InterimServerList - Supplies an interim server list to merge into.

    IN ULONG Level - Supplies the level of the list (100 or 101).  Special
        level 1010 is really level 101 with the special semantic that no
        fields from this the NewServerList override existing fields in the
        InterimServerList.

    IN ULONG NewServerList - Supplies the list to merge into the interim list

    IN ULONG NewEntriesRead - Supplies the entries read in the list.

    IN ULONG NewTotalEntries - Supplies the total entries available in the list.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    ULONG i;
    ULONG ServerElementSize;
    PSERVER_INFO_101 ServerInfo = NewServerList;
    PINTERIM_ELEMENT InterimEntry = NULL;
    PLIST_ENTRY InterimList;
    PINTERIM_ELEMENT NewElement = NULL;


    if (Level == 100) {
        ServerElementSize = sizeof(SERVER_INFO_100);
    } else if ( Level == 101 || Level == 1010 ) {
        ServerElementSize = sizeof(SERVER_INFO_101);
    } else {
        return(ERROR_INVALID_LEVEL);
    }

    //
    //  Early out if no entries in list.
    //

    if (NewEntriesRead == 0) {
        return NERR_Success;
    }

    PrepareServerListForMerge(NewServerList, Level, NewEntriesRead);

    InterimList = InterimServerList->ServerList.Flink;

    //
    //  Walk the existing structure, packing it into an interim element, and
    //  sticking the element into the interim table.
    //

    for (i = 0; i < NewEntriesRead; i ++) {
        BOOLEAN EntryInserted = FALSE;

        //
        //  Walk forward in the interim element and find the appropriate place
        //  to insert this element.
        //

        while (InterimList != &InterimServerList->ServerList) {

            LONG CompareResult;

            InterimEntry = CONTAINING_RECORD(InterimList, INTERIM_ELEMENT, NextElement);

//            KdPrint(("MergeServerList: Compare %ws and %ws\n", NewElement->Name, InterimEntry->Name));

#if DBG
            //
            //  Make sure that this entry is lexically less than the next
            //  entry.
            //

            {
                PLIST_ENTRY NextList = InterimList->Flink;
                PINTERIM_ELEMENT NextEntry = CONTAINING_RECORD(NextList, INTERIM_ELEMENT, NextElement);

                if (NextList != &InterimServerList->ServerList) {
                    ASSERT (wcscmp(InterimEntry->Name, NextEntry->Name) < 0);
                }

                //
                //  Now make sure that the input buffer also doesn't contain
                //  duplicate entries.
                //

                if (i < (NewEntriesRead-1)) {
                    PSERVER_INFO_101 NextServerInfo = (PSERVER_INFO_101)((PCHAR)ServerInfo+ServerElementSize);

                    ASSERT (wcscmp(ServerInfo->sv101_name, NextServerInfo->sv101_name) <= 0);
                }

            }
#endif

            CompareResult = wcscmp(ServerInfo->sv101_name, InterimEntry->Name);

            if (CompareResult == 0) {

//                KdPrint(("MergeServerList: Elements equal - update\n"));

                //
                // If the new information should override the old information,
                //  copy it on top of the new info.
                //
                if ( Level != 1010 ) {
                    InterimEntry->PlatformId = ServerInfo->sv101_platform_id;

                    if (Level >= 101) {
                        InterimEntry->MajorVersionNumber = ServerInfo->sv101_version_major;

                        InterimEntry->MinorVersionNumber = ServerInfo->sv101_version_minor;

                        InterimEntry->Type = ServerInfo->sv101_type;

                        InterimServerList->TotalBytesNeeded -= wcslen(InterimEntry->Comment) * sizeof(WCHAR) + sizeof(WCHAR);

                        wcscpy(InterimEntry->Comment, ServerInfo->sv101_comment);

                        InterimServerList->TotalBytesNeeded += wcslen(InterimEntry->Comment) * sizeof(WCHAR) + sizeof(WCHAR);

                    }
                }

                UpdateInterimServerListElement(InterimServerList, InterimEntry, Level, FALSE);

                EntryInserted = TRUE;

                break;

            } else if (CompareResult > 0) {

//                KdPrint(("MergeServerList: Elements greater.  Skip element\n"));

                InterimList = InterimList->Flink;

            } else {

                NewElement = AllocateInterimServerListEntry(ServerInfo, Level);

                if (NewElement == NULL) {
                    return ERROR_NOT_ENOUGH_MEMORY;
                }
//                KdPrint(("MergeServerList: Elements less.  Insert at end\n"));

                //
                //  The new entry is < than the previous entry.  Insert it
                //  before this entry.
                //

                InsertTailList(&InterimEntry->NextElement, &NewElement->NextElement);

                //
                //  Skip to the next element in the list.
                //

                InterimList = &NewElement->NextElement;

                UpdateInterimServerListElement(InterimServerList, NewElement, Level, TRUE);

                EntryInserted = TRUE;

                break;
            }
        }

        if (!EntryInserted &&
            (InterimList == &InterimServerList->ServerList)) {

            NewElement = AllocateInterimServerListEntry(ServerInfo, Level);

            if (NewElement == NULL) {
                return ERROR_NOT_ENOUGH_MEMORY;
            }
//            KdPrint(("MergeServerList: Insert %ws at end of list\n", NewElement->Name));

            InsertTailList(&InterimServerList->ServerList, &NewElement->NextElement);

            InterimList = &NewElement->NextElement;

            UpdateInterimServerListElement(InterimServerList, NewElement, Level, TRUE);

        }

        ServerInfo = (PSERVER_INFO_101)((PCHAR)ServerInfo+ServerElementSize);
    }

#if 0
    {
        PLIST_ENTRY InterimList;
        ULONG TotalNeededForList = 0;

        for (InterimList = InterimServerList->ServerList.Flink ;
             InterimList != &InterimServerList->ServerList ;
             InterimList = InterimList->Flink ) {
             ULONG ServerElementSize;

             InterimEntry = CONTAINING_RECORD(InterimList, INTERIM_ELEMENT, NextElement);

             if (Level == 100) {
                 ServerElementSize = sizeof(SERVER_INFO_100);
             } else {
                 ServerElementSize = sizeof(SERVER_INFO_101);
             }

             ServerElementSize += wcslen(InterimEntry->Name)*sizeof(WCHAR)+sizeof(WCHAR);

             ServerElementSize += wcslen(InterimEntry->Comment)*sizeof(WCHAR)+sizeof(WCHAR);

//             KdPrint(("MergeInterimServerList: %ws.  %ld needed\n", InterimEntry->Name, ServerElementSize));

             TotalNeededForList += ServerElementSize;
         }

         if (TotalNeededForList != InterimServerList->TotalBytesNeeded) {
             KdPrint(("UpdateInterimServerList:  Wrong number of bytes (%ld) for interim server list.  %ld needed\n", InterimServerList->TotalBytesNeeded, TotalNeededForList));
         }
     }

#endif
//    KdPrint(("%lx bytes needed to hold server list\n", InterimServerList->TotalBytesNeeded));

    //
    //  Also, we had better have the whole table locally.
    //

    ASSERT (InterimServerList->EntriesRead == InterimServerList->TotalEntries);

    return(NERR_Success);
}

ULONG
__cdecl
CompareServerInfo(
    const void * Param1,
    const void * Param2
    )
{
    const SERVER_INFO_100 * ServerInfo1 = Param1;
    const SERVER_INFO_100 * ServerInfo2 = Param2;

    return wcscmp(ServerInfo1->sv100_name, ServerInfo2->sv100_name);
}

VOID
PrepareServerListForMerge(
    IN PVOID ServerInfoList,
    IN ULONG Level,
    IN ULONG EntriesInList
    )
/*++

Routine Description:

    MergeServerList requires that the inputs to the list be in a strictly
    sorted order.  This routine guarantees that this list will be of
    an "appropriate" form to be merged.

Arguments:

    IN PVOID ServerInfoList - Supplies the list to munge.

    IN ULONG Level - Supplies the level of the list (100 or 101).
        (Or level 1010 which is identical to level 101.)

    IN ULONG EntriesInList - Supplies the number of entries in the list.

Return Value:

    None.

Note:
    In 99% of the cases, the list passed in will already be sorted.  We want to
    take the input list and first check to see if it is sorted.  If it is,
    we can return immediately.  If it is not, we need to sort the list.

    We don't just unilaterally sort the list, because the input is mostly
    sorted anyway, and there are no good sorting algorithms that handle mostly
    sorted inputs.  Since we will see unsorted input only rarely (basically,
    we will only see it from WfW machines), we just take the penalty of a worst
    case quicksort if the input is unsorted.

--*/

{
    LONG i;
    ULONG ServerElementSize;
    PSERVER_INFO_101 ServerInfo = ServerInfoList;
    BOOLEAN MisOrderedList = FALSE;

    ASSERT (Level == 100 || Level == 101 || Level == 1010);

    //
    //  Figure out the size of each element.
    //

    if (Level == 100) {
        ServerElementSize = sizeof(SERVER_INFO_100);
    } else {
        ServerElementSize = sizeof(SERVER_INFO_101);
    }

    //
    //  Next check to see if the input list is sorted.
    //

    for (i = 0 ; i < ((LONG)EntriesInList - 1) ; i += 1 ) {
        PSERVER_INFO_101 NextServerInfo = (PSERVER_INFO_101)((PCHAR)ServerInfo+ServerElementSize);

        if (wcscmp(ServerInfo->sv101_name, NextServerInfo->sv101_name) >= 0) {
            MisOrderedList = TRUE;
            break;
        }

        ServerInfo = NextServerInfo;
    }

    //
    //  This list is sorted.  Return right away, it's fine.
    //

    if (!MisOrderedList) {
        return;
    }

    //
    //  This list isn't sorted.  We need to sort it.
    //

    qsort(ServerInfoList, EntriesInList, ServerElementSize, CompareServerInfo);


}

PINTERIM_ELEMENT
AllocateInterimServerListEntry(
    IN PSERVER_INFO_101 ServerInfo,
    IN ULONG Level
    )
{
    PINTERIM_ELEMENT NewElement;

    NewElement = MIDL_user_allocate(sizeof(INTERIM_ELEMENT));

    if (NewElement == NULL) {
        return NULL;
    }

    //
    //  Initialize TimeLastSeen and Periodicity.
    //

    NewElement->TimeLastSeen = 0;

    NewElement->Periodicity = 0;

    NewElement->PlatformId = ServerInfo->sv101_platform_id;

    ASSERT (wcslen(ServerInfo->sv101_name) <= CNLEN);

    wcscpy(NewElement->Name, ServerInfo->sv101_name);

    if (Level == 100) {
        NewElement->MajorVersionNumber = 0;
        NewElement->MinorVersionNumber = 0;
        *NewElement->Comment = L'\0';
        NewElement->Type = SV_TYPE_ALL;
    } else {
        NewElement->MajorVersionNumber = ServerInfo->sv101_version_major;

        NewElement->MinorVersionNumber = ServerInfo->sv101_version_minor;

        NewElement->Type = ServerInfo->sv101_type;

        ASSERT (wcslen(ServerInfo->sv101_comment) <= LM20_MAXCOMMENTSZ);

        wcscpy(NewElement->Comment, ServerInfo->sv101_comment);

    }

    return NewElement;
}


VOID
UpdateInterimServerListElement(
    IN PINTERIM_SERVER_LIST InterimServerList,
    IN PINTERIM_ELEMENT InterimElement,
    IN ULONG Level,
    IN BOOLEAN NewElement
    )
{
#if 0
    PINTERIM_ELEMENT InterimEntry;
    ULONG TotalNeededForList = 0;
#endif

    //
    //  If this is a new element, update the size of the table to match.
    //

    if (NewElement) {
        ULONG ServerElementSize;

        if (Level == 100) {
            ServerElementSize = sizeof(SERVER_INFO_100);
        } else {
            ServerElementSize = sizeof(SERVER_INFO_101);
        }

        InterimServerList->EntriesRead += 1;

        ServerElementSize += wcslen(InterimElement->Name)*sizeof(WCHAR)+sizeof(WCHAR);

        if (Level == 100) {
            ServerElementSize += sizeof(WCHAR);
        } else {
            ServerElementSize += wcslen(InterimElement->Comment)*sizeof(WCHAR)+sizeof(WCHAR);
        }

        InterimServerList->TotalBytesNeeded += ServerElementSize;

        InterimServerList->TotalEntries += 1;

        if (InterimServerList->NewElementCallback != NULL) {
            InterimServerList->NewElementCallback(InterimServerList,
                                                            InterimElement);
        } else {
            InterimElement->Periodicity = 0xffffffff;
            InterimElement->TimeLastSeen = 0xffffffff;
        }


    } else {
        if (InterimServerList->ExistingElementCallback != NULL) {
            InterimServerList->ExistingElementCallback(InterimServerList,
                                                       InterimElement);
        } else {
            InterimElement->Periodicity = 0xffffffff;
            InterimElement->TimeLastSeen = 0xffffffff;
        }

    }

#if 0
    {
        PLIST_ENTRY InterimList;
        ULONG TotalNeededForList = 0;

        for (InterimList = InterimServerList->ServerList.Flink ;
             InterimList != &InterimServerList->ServerList ;
             InterimList = InterimList->Flink ) {
             ULONG ServerElementSize;

             InterimEntry = CONTAINING_RECORD(InterimList, INTERIM_ELEMENT, NextElement);

             if (Level == 100) {
                 ServerElementSize = sizeof(SERVER_INFO_100);
             } else {
                 ServerElementSize = sizeof(SERVER_INFO_101);
             }

             ServerElementSize += wcslen(InterimEntry->Name)*sizeof(WCHAR)+sizeof(WCHAR);

             ServerElementSize += wcslen(InterimEntry->Comment)*sizeof(WCHAR)+sizeof(WCHAR);

             TotalNeededForList += ServerElementSize;
         }

         if (TotalNeededForList != InterimServerList->TotalBytesNeeded) {
             KdPrint(("UpdateInterimServerList:  Wrong number of bytes (%ld) for interim server list.  %ld needed\n", InterimServerList->TotalBytesNeeded, TotalNeededForList));
         }
     }

#endif

    return;

}

NET_API_STATUS
PackServerList(
    IN PINTERIM_SERVER_LIST InterimServerList,
    IN ULONG Level,
    IN ULONG ServerType,
    IN ULONG PreferedMaximumLength,
    OUT PVOID *ServerList,
    OUT PULONG EntriesRead,
    OUT PULONG TotalEntries,
    IN LPCWSTR FirstNameToReturn
    )
/*++

Routine Description:

    This function will take an interim server list and "pack" it into an array
    of server_info_xxx structures.

Arguments:

    IN PINTERIM_SERVER_LIST InterimServerList - Supplies an interim server list to merge into.

    IN ULONG Level - Supplies the level of the list (100 or 101).

    IN ULONG ServerType - Supplies the type to filter on the list.

    IN ULONG PreferedMaximumLength - Supplies the prefered size of the list.

    OUT PVOID *ServerList - Where to put the destination list.

    OUT PULONG EntriesEntries - Receives the entries packed in the list.

    OUT PULONG TotalEntries - Receives the total entries available in the list.

    FirstNameToReturn - Supplies the name of the first domain or server entry to return.
        The caller can use this parameter to implement a resume handle of sorts by passing
        the name of the last entry returned on a previous call.  (Notice that the specified
        entry will, also, be returned on this call unless it has since been deleted.)
        Pass NULL to start with the first entry available.

        Passed name must be the canonical form of the name.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    ULONG EntriesPacked = 0;
    PLIST_ENTRY InterimList;
    PSERVER_INFO_101 ServerEntry;
    ULONG EntrySize = 0;
    LPWSTR BufferEnd;
    BOOLEAN ReturnWholeList = FALSE;
    BOOLEAN TrimmingNames;
    BOOLEAN BufferFull = FALSE;

    if (Level == 100) {
        EntrySize = sizeof(SERVER_INFO_100);
    } else if (Level == 101) {
        EntrySize = sizeof(SERVER_INFO_101);
    } else {
        return(ERROR_INVALID_LEVEL);
    }

    //
    //  Set the entries read based on the information we collected before.
    //

    *TotalEntries = 0;

    if (PreferedMaximumLength == 0xffffffff) {
        *ServerList = MIDL_user_allocate(InterimServerList->TotalBytesNeeded);

        BufferEnd = (LPWSTR)((ULONG_PTR)(*ServerList)+InterimServerList->TotalBytesNeeded);

    } else {
        *ServerList = MIDL_user_allocate(PreferedMaximumLength);

        BufferEnd = (LPWSTR)((ULONG_PTR)(*ServerList)+PreferedMaximumLength);
    }

    if (ServerType == SV_TYPE_ALL || ServerType == SV_TYPE_DOMAIN_ENUM) {
        ReturnWholeList = TRUE;
    }

    if ( *ServerList == NULL ) {
        return(ERROR_NOT_ENOUGH_MEMORY);

    }

    TrimmingNames = (FirstNameToReturn != NULL && *FirstNameToReturn != L'\0');
    ServerEntry = *ServerList;

    for (InterimList = InterimServerList->ServerList.Flink ;
         InterimList != &InterimServerList->ServerList ;
         InterimList = InterimList->Flink ) {

        PINTERIM_ELEMENT InterimEntry = CONTAINING_RECORD(InterimList, INTERIM_ELEMENT, NextElement);

#if DBG
        //
        //  Make sure that this entry is lexically less than the next
        //  entry.
        //

        {
            PLIST_ENTRY NextList = InterimList->Flink;
            PINTERIM_ELEMENT NextEntry = CONTAINING_RECORD(NextList, INTERIM_ELEMENT, NextElement);

            if (NextList != &InterimServerList->ServerList) {
                ASSERT (wcscmp(InterimEntry->Name, NextEntry->Name) < 0);
            }

        }
#endif

        //
        // Trim the first several names from the list.
        //

        if ( TrimmingNames ) {
            if ( wcscmp( InterimEntry->Name, FirstNameToReturn ) < 0 ) {
                continue;
            }
            TrimmingNames = FALSE;
        }

        //
        //  If the server's type matches the type filter, pack it into the buffer.
        //

        if (InterimEntry->Type & ServerType) {

            (*TotalEntries) += 1;

            //
            //  If this entry will fit into the buffer, pack it in.
            //
            //  Please note that we only count an entry if the entire entry
            //  (server and comment) fits in the buffer.  This is NOT
            //  strictly Lan Manager compatible.
            //

            if ( !BufferFull &&
                 ((ULONG_PTR)ServerEntry+EntrySize <= (ULONG_PTR)BufferEnd)) {

                ServerEntry->sv101_platform_id = InterimEntry->PlatformId;

                ServerEntry->sv101_name = InterimEntry->Name;

                if (NetpPackString(&ServerEntry->sv101_name,
                                    (LPBYTE)((PCHAR)ServerEntry)+EntrySize,
                                    &BufferEnd)) {

                    if (Level == 101) {

                        ServerEntry->sv101_version_major = InterimEntry->MajorVersionNumber;;

                        ServerEntry->sv101_version_minor = InterimEntry->MinorVersionNumber;;

                        ServerEntry->sv101_type = InterimEntry->Type;

                        ServerEntry->sv101_comment = InterimEntry->Comment;

                        if (NetpPackString(&ServerEntry->sv101_comment,
                                    (LPBYTE)((PCHAR)ServerEntry)+EntrySize,
                                    &BufferEnd)) {
                            EntriesPacked += 1;
                        } else {
                            BufferFull = TRUE;
                        }
                    } else {
                        EntriesPacked += 1;
                    }
#if DBG
                    {
                        PSERVER_INFO_101 PreviousServerInfo = (PSERVER_INFO_101)((PCHAR)ServerEntry-EntrySize);
                        if (PreviousServerInfo >= (PSERVER_INFO_101)*ServerList) {
                            ASSERT (wcscmp(ServerEntry->sv101_name, PreviousServerInfo->sv101_name) > 0);
                        }

                    }
#endif
                } else {
                    BufferFull = TRUE;
                }

            } else {

                //
                //  If we're returning the entire list and we have exceeded
                //  the amount that fits in the list, we can early out
                //  now.
                //

                if (ReturnWholeList) {

                    *TotalEntries = InterimServerList->TotalEntries;

                    break;
                }

                BufferFull = TRUE;
            }

            //
            //  Step to the next server entry.
            //

            ServerEntry = (PSERVER_INFO_101)((PCHAR)ServerEntry+EntrySize);
        }
    }

    ASSERT (InterimServerList->EntriesRead >= EntriesPacked);

    *EntriesRead = EntriesPacked;

    if (EntriesPacked != *TotalEntries) {
        return ERROR_MORE_DATA;
    } else {
        return NERR_Success;
    }

}


NET_API_STATUS
InitializeInterimServerList(
    IN PINTERIM_SERVER_LIST InterimServerList,
    IN PINTERIM_NEW_CALLBACK NewCallback,
    IN PINTERIM_EXISTING_CALLBACK ExistingCallback,
    IN PINTERIM_DELETE_CALLBACK DeleteElementCallback,
    IN PINTERIM_AGE_CALLBACK AgeElementCallback
    )
{

    InitializeListHead(&InterimServerList->ServerList);

    InterimServerList->TotalBytesNeeded = 0;
    InterimServerList->TotalEntries = 0;
    InterimServerList->EntriesRead = 0;

    InterimServerList->NewElementCallback = NewCallback;
    InterimServerList->ExistingElementCallback = ExistingCallback;
    InterimServerList->DeleteElementCallback = DeleteElementCallback;
    InterimServerList->AgeElementCallback = AgeElementCallback;
    return(NERR_Success);
}

NET_API_STATUS
UninitializeInterimServerList(
    IN PINTERIM_SERVER_LIST InterimServerList
    )
{
    PINTERIM_ELEMENT InterimElement;


//    KdPrint(("BROWSER: Uninitialize Interim Server List %lx\n", InterimServerList));

    //
    //  Enumerate the elements in the table, deleting them as we go.
    //

    while (!IsListEmpty(&InterimServerList->ServerList)) {
        PLIST_ENTRY Entry;

        Entry = RemoveHeadList(&InterimServerList->ServerList);

        InterimElement = CONTAINING_RECORD(Entry, INTERIM_ELEMENT, NextElement);

        if (InterimServerList->DeleteElementCallback != NULL) {
            InterimServerList->DeleteElementCallback(InterimServerList, InterimElement);
        }

        //
        //  There is one less element in the list.
        //

        InterimServerList->EntriesRead -= 1;

        InterimServerList->TotalEntries -= 1;

        MIDL_user_free(InterimElement);
    }

    ASSERT (InterimServerList->EntriesRead == 0);

    return(NERR_Success);
}

ULONG
NumberInterimServerListElements(
    IN PINTERIM_SERVER_LIST InterimServerList
    )
{
    PLIST_ENTRY InterimList;
    ULONG NumberOfEntries = 0;

    for (InterimList = InterimServerList->ServerList.Flink ;
         InterimList != &InterimServerList->ServerList ;
         InterimList = InterimList->Flink ) {
        NumberOfEntries += 1;

    }

    return NumberOfEntries;
}

NET_API_STATUS
AgeInterimServerList(
    IN PINTERIM_SERVER_LIST InterimServerList
    )
{
    PLIST_ENTRY InterimList, NextElement;
    PINTERIM_ELEMENT InterimElement;

    if (InterimServerList->AgeElementCallback != NULL) {

        //
        //  Enumerate the elements in the table, aging them as we go.
        //


        for (InterimList = InterimServerList->ServerList.Flink ;
             InterimList != &InterimServerList->ServerList ;
             InterimList = NextElement) {
            InterimElement = CONTAINING_RECORD(InterimList, INTERIM_ELEMENT, NextElement);

            //
            //  Call into the aging routine and if this entry is too old,
            //  remove it from the interim list.
            //

            if (InterimServerList->AgeElementCallback(InterimServerList, InterimElement)) {
                ULONG ElementSize = sizeof(SERVER_INFO_101) + ((wcslen(InterimElement->Comment) + 1) * sizeof(WCHAR)) + ((wcslen(InterimElement->Name) + 1) * sizeof(WCHAR));

                ASSERT (ElementSize <= InterimServerList->TotalBytesNeeded);

                NextElement = InterimList->Flink;

                //
                //  Remove this entry from the list.
                //

                RemoveEntryList(&InterimElement->NextElement);

                if (InterimServerList->DeleteElementCallback != NULL) {
                    InterimServerList->DeleteElementCallback(InterimServerList, InterimElement);
                }

                //
                //  There is one less element in the list.
                //

                InterimServerList->EntriesRead -= 1;

                InterimServerList->TotalEntries -= 1;

                //
                //  Since this element isn't in the table any more, we don't
                //  need to allocate memory for it.
                //

                InterimServerList->TotalBytesNeeded -= ElementSize;

                MIDL_user_free(InterimElement);

            } else {
                NextElement = InterimList->Flink;
            }
        }
#if 0
    {
        PINTERIM_ELEMENT InterimEntry;
        ULONG TotalNeededForList = 0;

        for (InterimList = InterimServerList->ServerList.Flink ;
             InterimList != &InterimServerList->ServerList ;
             InterimList = InterimList->Flink ) {
             ULONG ServerElementSize;

             InterimEntry = CONTAINING_RECORD(InterimList, INTERIM_ELEMENT, NextElement);

             ServerElementSize = sizeof(SERVER_INFO_101);

             ServerElementSize += wcslen(InterimEntry->Name)*sizeof(WCHAR)+sizeof(WCHAR);

             ServerElementSize += wcslen(InterimEntry->Comment)*sizeof(WCHAR)+sizeof(WCHAR);

             TotalNeededForList += ServerElementSize;
         }

         if (TotalNeededForList != InterimServerList->TotalBytesNeeded) {
             KdPrint(("AgeInterimServerList:  Too few bytes (%ld) for interim server list.  %ld needed\n", InterimServerList->TotalBytesNeeded, TotalNeededForList));
         }
     }
#endif

    }

    return(NERR_Success);
}

PINTERIM_ELEMENT
LookupInterimServerList(
    IN PINTERIM_SERVER_LIST InterimServerList,
    IN LPWSTR ServerNameToLookUp
    )
{
    PLIST_ENTRY InterimList;

    for (InterimList = InterimServerList->ServerList.Flink ;
         InterimList != &InterimServerList->ServerList ;
         InterimList = InterimList->Flink ) {

        PINTERIM_ELEMENT InterimEntry = CONTAINING_RECORD(InterimList, INTERIM_ELEMENT, NextElement);
        LONG CompareResult;

        if ((CompareResult = _wcsicmp(InterimEntry->Name, ServerNameToLookUp) == 0)) {
            return InterimEntry;
        }

        //
        //  If we went past this guy, return an error.
        //

        if (CompareResult > 0) {
            return NULL;
        }

    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\dcutil.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      dcutil.c
//
//  Abstract:
//
//    Test to ensure that a workstation has network (IP) connectivity to
//      the outside.
//
//  Author:
//
//     15-Dec-1997 (cliffv)
//      Anilth  - 4-20-1998
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//    1-June-1998 (denisemi) add DnsServerHasDCRecords to check DC dns records
//                           registration
//
//    26-June-1998 (t-rajkup) add general tcp/ip , dhcp and routing,
//                            winsock, ipx, wins and netbt information.
//--

//
// Common include files.
//
#include "precomp.h"
#include <iphlpint.h>
#include "dcutil.h"
#include "ipcfgtest.h"

DWORD CheckDomainConfig(IN PWSTR pwzDomainName, OUT PLIST_ENTRY plmsgOutput);
DWORD CheckAdapterDnsConfig( OUT PLIST_ENTRY plmsgOutput);
DWORD DnsDcSrvCheck(PWSTR pwzDnsDomain, OUT PLIST_ENTRY plmsgOutput);
DWORD ValidateDnsDomainName(PWSTR pwzDnsDomain,  OUT PLIST_ENTRY plmsgOutput);
PWSTR ConcatonateStrings(PWSTR pwzFirst, PWSTR pwzSecond);
BOOL AddToList(PWSTR * ppwzList, PWSTR pwz);
BOOL BuildDomainList(PWSTR * ppwzDomainList, PWSTR pwzDnsDomain);
PWSTR AllocString(PWSTR pwz);
DWORD GetInterfacesStr( PWSTR *ppwIfStr);

const PWSTR g_pwzSrvRecordPrefix = L"_ldap._tcp.dc._msdcs.";

//(nsun) DC related routines

PTESTED_DC
GetUpTestedDc(
    IN PTESTED_DOMAIN TestedDomain
    )
/*++

Routine Description:

    Returns a DC that's currently up and running.

Arguments:

    TestedDomain - Domain the DC is in

Return Value:

    Returns pointer to structure describing the DC

    NULL: There are no 'up' DCs

--*/
{
    PLIST_ENTRY ListEntry;
    PTESTED_DC TestedDc;


    //
    // Find a DC that's up to run the test
    //

    for ( ListEntry = TestedDomain->TestedDcs.Flink ;
          ListEntry != &TestedDomain->TestedDcs ;
          ListEntry = ListEntry->Flink ) {


        //
        // Loop through the list of DCs in this domain
        //

        TestedDc = CONTAINING_RECORD( ListEntry, TESTED_DC, Next );

        if ( (TestedDc->Flags & DC_IS_DOWN) == 0) {
            return TestedDc;
        }
    }

    return NULL;
}



PTESTED_DC
AddTestedDc(
            IN NETDIAG_PARAMS *pParams,
            IN OUT NETDIAG_RESULT *pResults,
            IN PTESTED_DOMAIN TestedDomain,
            IN LPWSTR ComputerName,
            IN ULONG Flags
           )
/*++

Routine Description:

    Add a DC to the list of DCs to test in a particular domain

Arguments:

    TestedDomain - Domain the DC is in

    ComputerName - Netbios or DNS computer name of the DC
        Without the leading \\

    Flags - Flags to set on the DC

Return Value:

    Returns pointer to structure describing the DC

    NULL: Memory allocation failure.

--*/
{
    PTESTED_DC TestedDc = NULL;
    PLIST_ENTRY ListEntry;
    LPWSTR Period;



    //
    // Check if the domain is already defined.
    //

    TestedDc = FindTestedDc( pResults, ComputerName );

    //
    // Ensure the DC is for the right domain
    //

    if ( TestedDc != NULL )
    {
        if ( TestedDc->TestedDomain != TestedDomain )
        {
            return NULL;
        }
    }


    //
    // Allocate a structure to describe the domain.
    //

    if ( TestedDc == NULL )
    {
        TestedDc = Malloc( sizeof(TESTED_DC) );

        if ( TestedDc == NULL )
        {
            DebugMessage(" AddTestedDc(): Out of Memory!\n");
            return NULL;
        }

        ZeroMemory( TestedDc, sizeof(TESTED_DC) );

        TestedDc->ComputerName = NetpAllocWStrFromWStr( ComputerName );

        if ( TestedDc->ComputerName == NULL )
        {
            Free(TestedDc);
            return NULL;
        }

        //
        // Convert the computername to netbios (Use the API when in becomes available.
        //

        if ((Period = wcschr( ComputerName, L'.' )) == NULL )
        {
            wcsncpy( TestedDc->NetbiosDcName, ComputerName, CNLEN );
            TestedDc->NetbiosDcName[CNLEN] = L'\0';
        }
        else
        {
            ULONG CharsToCopy = (ULONG) min( CNLEN, Period-ComputerName);

            wcsncpy( TestedDc->NetbiosDcName, ComputerName, CharsToCopy );
            TestedDc->NetbiosDcName[CharsToCopy] = '\0';
        }

        TestedDc->TestedDomain = TestedDomain;

        InsertTailList( &TestedDomain->TestedDcs, &TestedDc->Next );
    }

    //
    // Set the flags requested by the caller.
    //

//    if ( Flags & DC_IS_NT5 ) {
//        if ( TestedDc->Flags & DC_IS_NT4 ) {
//            printf("        [WARNING] '%ws' is both an NT 5 and NT 4 DC.\n", ComputerName );
//        }
//    }
//    if ( Flags & DC_IS_NT4 ) {
//        if ( TestedDc->Flags & DC_IS_NT5 ) {
//            printf("        [WARNING] '%ws' is both an NT 4 and NT 5 DC.\n", ComputerName );
//        }
//    }
    TestedDc->Flags |= Flags;

    //
    // Ensure we have the IpAddress of this DC.
    //

    (VOID) GetIpAddressForDc( TestedDc );


    //
    // Ping the DC
    //

    if ( (TestedDc->Flags & DC_PINGED) == 0  && (TestedDc->Flags & DC_IS_DOWN) == 0)
    {
        if ( !IsIcmpResponseW( TestedDc->DcIpAddress ) ) {
            DebugMessage2("    [WARNING] Cannot ping '%ws' (it must be down).\n", TestedDc->ComputerName );
            TestedDc->Flags |= DC_IS_DOWN;
            TestedDc->Flags |= DC_FAILED_PING;
        }
        TestedDc->Flags |= DC_PINGED;
    }

    //try to query DC info to check if the DC is really up
    if( (TestedDc->Flags & DC_IS_DOWN) == 0 )
    {
        PSERVER_INFO_100  pServerInfo100 = NULL;
        NET_API_STATUS  NetStatus;
        NetStatus = NetServerGetInfo( TestedDc->ComputerName,
                          100,
                          (LPBYTE *)&pServerInfo100 );
        if(NetStatus != NO_ERROR && NetStatus != ERROR_ACCESS_DENIED)
        {
            TestedDc->Flags |= DC_IS_DOWN;

            // IDS_GLOBAL_DC_DOWN   "Cannot get information for DC %ws. [%s] Assume it is down.\n"
            PrintDebug(pParams, 4, IDS_GLOBAL_DC_DOWN, TestedDc->ComputerName,
                            NetStatusToString(NetStatus));
        }
        else
            NetApiBufferFree( pServerInfo100 );

    }

    return TestedDc;
}



PTESTED_DC
FindTestedDc(
             IN OUT NETDIAG_RESULT *pResults,
             IN LPWSTR ComputerName
            )
/*++

Routine Description:

    Find the tested DC structure for the named DC

Arguments:

    ComputerName - Netbios or DNS computer name of the DC
        Without the leading \\

Return Value:

    Returns pointer to structure describing the DC

    NULL: No Such DC is currently defined

--*/
{
    PTESTED_DC TestedDc = NULL;
    PTESTED_DOMAIN TestedDomain = NULL;
    PLIST_ENTRY ListEntry;
    PLIST_ENTRY ListEntry2;
    WCHAR NetbiosDcName[CNLEN+1];
    LPWSTR Period;

    //
    // Convert the computername to netbios (Use the API when in becomes available.
    //

    if ((Period = wcschr( ComputerName, L'.' )) == NULL )
    {
        wcsncpy( NetbiosDcName, ComputerName, CNLEN );
        NetbiosDcName[CNLEN] = L'\0';
    }
    else
    {
        ULONG CharsToCopy = (ULONG) min( CNLEN, Period-ComputerName);

        wcsncpy( NetbiosDcName, ComputerName, CharsToCopy );
        NetbiosDcName[CharsToCopy] = '\0';
    }


    //
    //  Loop through the list of domains
    //

    for ( ListEntry = pResults->Global.listTestedDomains.Flink ;
          ListEntry != &pResults->Global.listTestedDomains ;
          ListEntry = ListEntry->Flink ) {


        //
        // Loop through the list of DCs in this domain
        //

        TestedDomain = CONTAINING_RECORD( ListEntry, TESTED_DOMAIN, Next );

        for ( ListEntry2 = TestedDomain->TestedDcs.Flink ;
              ListEntry2 != &TestedDomain->TestedDcs ;
              ListEntry2 = ListEntry2->Flink ) {


            //
            // Loop through the list of DCs in this domain
            //

            TestedDc = CONTAINING_RECORD( ListEntry2, TESTED_DC, Next );


            //
            // If the Netbios computer names match,
            //  we found it.
            //

            if ( _wcsicmp( TestedDc->NetbiosDcName, NetbiosDcName ) == 0 ) {
                return TestedDc;
            }
        }

    }

    return NULL;
}




NET_API_STATUS
GetADc(IN NETDIAG_PARAMS *pParams,
       IN OUT NETDIAG_RESULT *pResults,
       OUT PLIST_ENTRY plmsgOutput,
       IN DSGETDCNAMEW *DsGetDcRoutine,
       IN PTESTED_DOMAIN TestedDomain,
       IN DWORD Flags,
       OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
    )
/*++

Routine Description:

    Does a DsGetDcName

Arguments:

    DsGetDcRoutine - Routine to call to find a DC

    TestedDomain - Domain to test

    Flags - Flags to pass to DsGetDcName

    DomainControllerInfo - Return Domain Controller information

Return Value:

    Status of the operation.

--*/
{
    NET_API_STATUS NetStatus;
    PDOMAIN_CONTROLLER_INFOW LocalDomainControllerInfo = NULL;
    PDOMAIN_CONTROLLER_INFOW LocalDomainControllerInfo2;
    static BOOL s_fDcNameInitialized = FALSE;

    //
    // Initialize internal version of DsGetDcName
    //
	if( !s_fDcNameInitialized )
    {

// Commented out to port to Source Depot - smanda
#ifdef SLM_TREE
	    NetStatus = DCNameInitialize();

	    if ( NetStatus != NO_ERROR )
	    {
		    DebugMessage2("    [FATAL] Cannot initialize DsGetDcName. [%s]\n",
                         NetStatusToString(NetStatus));
            PrintGuru( NetStatus, DSGETDC_GURU );
		    goto Cleanup;
	    }
#endif

        //$REVIEW (nsun 10/05/98) make sure we just init once
        s_fDcNameInitialized = TRUE;
    }



    //
    // Try it first not asking for IP.
    //
    // Though technically wrong, specify DS_DIRECTORY_SERVICE_PREFERRED here
    // or I won't be able to tell that this is an NT 5 domain below.
    //

    NetStatus = (*DsGetDcRoutine)( NULL,
                              TestedDomain->QueryableDomainName,
                              NULL,
                              NULL,
                              DS_FORCE_REDISCOVERY |
                                DS_DIRECTORY_SERVICE_PREFERRED |
                                Flags,
                              &LocalDomainControllerInfo );

    // If DsGetDcName return ERROR_NO_SUCH_DOMAIN then try to findout the exact reason for the error
    // Based on DoctorDNS specs for join command
    if ( NetStatus == ERROR_NO_SUCH_DOMAIN && TestedDomain->QueryableDomainName != NULL && plmsgOutput != NULL ) {
        CheckDomainConfig(TestedDomain->QueryableDomainName, plmsgOutput);
    }

    if ( NetStatus != NO_ERROR ) {
        DebugMessage2( "    DsGetDcRoutine failed. [%s]\n", NetStatusToString(NetStatus));
        goto Cleanup;
    }

    //
    // Add this DC to the list of DCs in the domain
    //

    (VOID) AddTestedDc( pParams,
                        pResults,
                        TestedDomain,
                        LocalDomainControllerInfo->DomainControllerName+2,
                        (LocalDomainControllerInfo->Flags & DS_DS_FLAG ) ?
                            DC_IS_NT5 :
                            DC_IS_NT4 );

    //
    // If this DC wasn't discovered using IP,
    //  and it is an NT 5 DC,
    //  try again requiring IP.
    //
    // (I can't require IP in the first place since NT 4.0 DCs can't return
    // their IP address.)
    //

    if ( LocalDomainControllerInfo->DomainControllerAddressType != DS_INET_ADDRESS &&
         (LocalDomainControllerInfo->Flags & DS_DS_FLAG) != 0 ) {

        NetStatus = (*DsGetDcRoutine)( NULL,
                                  TestedDomain->QueryableDomainName,
                                  NULL,
                                  NULL,
                                  DS_FORCE_REDISCOVERY |
                                    DS_IP_REQUIRED |
                                    Flags,
                                  &LocalDomainControllerInfo2 );

        if ( NetStatus == NO_ERROR ) {
            NetApiBufferFree( LocalDomainControllerInfo );
            LocalDomainControllerInfo = LocalDomainControllerInfo2;

            //
            // Add this DC to the list of DCs in the domain
            //

            (VOID) AddTestedDc( pParams,
                                pResults,
                                TestedDomain,
                                LocalDomainControllerInfo->DomainControllerName+2,
                                (LocalDomainControllerInfo->Flags & DS_DS_FLAG ) ?
                                    DC_IS_NT5 :
                                    DC_IS_NT4 );
        }

    }

    //
    // Check to ensure KDC consistency
    //

    // This is also checked in DoDsGetDcName()
    if ( (LocalDomainControllerInfo->Flags & (DS_DS_FLAG|DS_KDC_FLAG)) == DS_DS_FLAG ) {
        DebugMessage3("    [WARNING] KDC is not running on NT 5 DC '%ws' in domain '%ws'.",
               LocalDomainControllerInfo->DomainControllerName,
               TestedDomain->PrintableDomainName );
    }

    //
    // Return the info to the caller
    //

    *DomainControllerInfo = LocalDomainControllerInfo;
    LocalDomainControllerInfo = NULL;
    NetStatus = NO_ERROR;

Cleanup:
    if ( LocalDomainControllerInfo != NULL ) {
        NetApiBufferFree( LocalDomainControllerInfo );
        LocalDomainControllerInfo = NULL;
    }

    return NetStatus;
}



//used in DCList and LDAP tests
BOOL
GetIpAddressForDc( PTESTED_DC TestedDc )
/*++

Routine Description:

    Get the IP address for the tested DC

Arguments:

    TestedDc - DC to get the IP address for.
    None.

Return Value:

    TRUE: Test suceeded.
    FALSE: Test failed

--*/
{
    BOOL RetVal = TRUE;
    NET_API_STATUS NetStatus;
    HOSTENT *HostEnt;
    LPSTR AnsiComputerName;

     if ( TestedDc->DcIpAddress == NULL ) {

         AnsiComputerName = NetpAllocStrFromWStr( TestedDc->ComputerName );

         if ( AnsiComputerName == NULL ) {
             DebugMessage( "Out of memory!\n" );
             RetVal = FALSE;
             TestedDc->Flags |= DC_IS_DOWN;
         } else {

             HostEnt = gethostbyname( AnsiComputerName );

             NetApiBufferFree( AnsiComputerName );

             if ( HostEnt == NULL )
             {
                 NetStatus = WSAGetLastError();
                 DebugMessage3("    [WARNING] Cannot gethostbyname for '%ws'. [%s]\n",
                                TestedDc->ComputerName, NetStatusToString(NetStatus) );
                 TestedDc->Flags |= DC_IS_DOWN;
             }
             else
             {
                 WCHAR LocalIpAddressString[NL_IP_ADDRESS_LENGTH+1];
                 NetpIpAddressToWStr( *(PULONG)HostEnt->h_addr_list[0], LocalIpAddressString );
                 TestedDc->DcIpAddress = NetpAllocWStrFromWStr( LocalIpAddressString );
                 if (TestedDc->DcIpAddress == NULL )
                 {
                     RetVal = FALSE;
                     TestedDc->Flags |= DC_IS_DOWN;
                 }
             }
         }

     }

     return RetVal;
}


DWORD CheckDomainConfig(IN PWSTR pwzDomainName, OUT PLIST_ENTRY plmsgOutput)
{
    DNS_STATUS status;
    status = ValidateDnsDomainName(pwzDomainName, plmsgOutput);
    if (status == ERROR_SUCCESS)
    {
        status = CheckAdapterDnsConfig(plmsgOutput);
        if (status == ERROR_SUCCESS)
        {
            status = DnsDcSrvCheck(pwzDomainName, plmsgOutput);
        }
        else
        {
            AddMessageToList(plmsgOutput, Nd_Quiet, IDS_DSGETDC_13242);
        }
    }
    return ERROR_SUCCESS;
}

//+----------------------------------------------------------------------------
//
// Function:   CheckAdapterDnsConfig
//
// Synopsis:   Check whether at least one enabled adapter/connection is
//             configured with a DNS server.
//
//-----------------------------------------------------------------------------
DWORD
CheckAdapterDnsConfig( OUT PLIST_ENTRY plmsgOutput )
{
   // IpConfig reads the registry and I can't find a good alternative way to do
   // this remotely. For now using DnsQueryConfig which is not remoteable nor
   // does it return per-adapter listings.
   //
   PIP_ARRAY pipArray;
   DNS_STATUS status;
   DWORD i, dwBufSize = sizeof(IP_ARRAY);

   status = DnsQueryConfig(DnsConfigDnsServerList, DNS_CONFIG_FLAG_ALLOC, NULL,
                           NULL, &pipArray, &dwBufSize);

   if (ERROR_SUCCESS != status || !pipArray)
   {
      DebugMessage2(L"Attempt to obtain DNS name server info failed with error %d\n", status);
      return status;
   }

   return (pipArray->AddrCount) ? ERROR_SUCCESS : DNS_INFO_NO_RECORDS;
}


//+----------------------------------------------------------------------------
//
// Function:   DnsDcSrvCheck
//
// Synopsis:   Check whether the SRV DNS record for
//             _ldap._tcp.dc._msdcs.<DNS name of Active Directory Domain>
//             is in place.
//
//-----------------------------------------------------------------------------
DWORD
DnsDcSrvCheck(PWSTR pwzDnsDomain, OUT PLIST_ENTRY plmsgOutput)
{
   PDNS_RECORD rgDnsRecs, pDnsRec;
   DNS_STATUS status;
   BOOL fSuccess;
   PWSTR pwzFullSrvRecord, pwzSrvList = NULL;

   pwzFullSrvRecord = ConcatonateStrings(g_pwzSrvRecordPrefix, pwzDnsDomain);

   if (!pwzFullSrvRecord)
   {
      return ERROR_NOT_ENOUGH_MEMORY;
   }

   // First query for the SRV records for this 
   status = DnsQuery_W(pwzFullSrvRecord, DNS_TYPE_SRV, DNS_QUERY_BYPASS_CACHE,
                       NULL, &rgDnsRecs, NULL);

   pDnsRec = rgDnsRecs;

   if (ERROR_SUCCESS == status)
   {
      if (!pDnsRec)
      {
         //  PrintMsg(SEV_ALWAYS, DCDIAG_REPLICA_ERR_NO_SRV, pwzDnsDomain);
      }
      else
      {
         PDNS_RECORD rgARecs;
         fSuccess = FALSE;

         while (pDnsRec)
         {
            if (DNS_TYPE_SRV == pDnsRec->wType)
            {
               WCHAR UnicodeDCName[MAX_PATH+1];
               NetpCopyStrToWStr( UnicodeDCName, pDnsRec->Data.Srv.pNameTarget);
               status = DnsQuery_W(UnicodeDCName, DNS_TYPE_A,
                                   DNS_QUERY_BYPASS_CACHE,
                                   NULL, &rgARecs, NULL);

               if (ERROR_SUCCESS != status || !rgARecs)
               {
                  // failure.
                  if (!AddToList(&pwzSrvList, UnicodeDCName))
                  {
                     return ERROR_NOT_ENOUGH_MEMORY;
                  }
               }
               else
               {
                  fSuccess = TRUE;
                  DebugMessage2(L"SRV name: %s\n",
                              pDnsRec->Data.Srv.nameTarget);
                  DnsRecordListFree(rgARecs, TRUE);
               }
            }
            pDnsRec = pDnsRec->pNext;
         }

         DnsRecordListFree(rgDnsRecs, TRUE);

         if (fSuccess)
         {
            // Success message
         }
         else
         {
            AddMessageToList(plmsgOutput, Nd_Quiet, IDS_DSGETDC_13243, 
                    pwzDnsDomain,  pwzSrvList);
            LocalFree(pwzSrvList);
         }
      }
   }
   else
   {
      PWSTR pwzDomainList;

      switch (status)
      {
      case DNS_ERROR_RCODE_FORMAT_ERROR:
      case DNS_ERROR_RCODE_NOT_IMPLEMENTED:
         AddMessageToList(plmsgOutput, Nd_Quiet, IDS_DSGETDC_13244, 
                         pwzDnsDomain );
         break;

      case DNS_ERROR_RCODE_SERVER_FAILURE:
         if (!BuildDomainList(&pwzDomainList, pwzDnsDomain))
         {
            return ERROR_NOT_ENOUGH_MEMORY;
         }
         AddMessageToList(plmsgOutput, Nd_Quiet, IDS_DSGETDC_13245, 
                         pwzDnsDomain, pwzFullSrvRecord, pwzDomainList );
         LocalFree(pwzDomainList);
         break;

      case DNS_ERROR_RCODE_NAME_ERROR:
         if (!BuildDomainList(&pwzDomainList, pwzDnsDomain))
         {
            return ERROR_NOT_ENOUGH_MEMORY;
         }
         AddMessageToList(plmsgOutput, Nd_Quiet, IDS_DSGETDC_13246, 
                         pwzDnsDomain, pwzDnsDomain, pwzFullSrvRecord, pwzDomainList );
         LocalFree(pwzDomainList);
         break;

      case DNS_ERROR_RCODE_REFUSED:
         if (!BuildDomainList(&pwzDomainList, pwzDnsDomain))
         {
            return ERROR_NOT_ENOUGH_MEMORY;
         }
         AddMessageToList(plmsgOutput, Nd_Quiet, IDS_DSGETDC_13247, 
                         pwzDnsDomain, pwzDomainList );
         LocalFree(pwzDomainList);
         break;

      case DNS_INFO_NO_RECORDS:
         AddMessageToList(plmsgOutput, Nd_Quiet, IDS_DSGETDC_13248, 
                         pwzDnsDomain, pwzDnsDomain, pwzDnsDomain );
         break;

      case ERROR_TIMEOUT:
         AddMessageToList(plmsgOutput, Nd_Quiet, IDS_DSGETDC_13249);
         break;

      default:
         AddMessageToList(plmsgOutput, Nd_Quiet, IDS_DSGETDC_13250, 
                         status );
         break;
      }
   }

   LocalFree(pwzFullSrvRecord);

   return status;
}



//+----------------------------------------------------------------------------
//
// Function:   ValidateDnsDomainName
//
// Synopsis:   Validate the DNS domain name.
//
//-----------------------------------------------------------------------------
DWORD
ValidateDnsDomainName(PWSTR pwzDnsDomain,  OUT PLIST_ENTRY plmsgOutput)
{
   DNS_STATUS status;

   status = DnsValidateName_W(pwzDnsDomain, DnsNameDomain);

   switch (status)
   {
   case ERROR_INVALID_NAME:
   case DNS_ERROR_INVALID_NAME_CHAR:
   case DNS_ERROR_NUMERIC_NAME:
       AddMessageToList(plmsgOutput, Nd_Quiet, IDS_DSGETDC_13240, 
                       pwzDnsDomain, DNS_MAX_LABEL_LENGTH );
       return status;

   case DNS_ERROR_NON_RFC_NAME:
       //
       // Not an error, print warning message.
       //
       AddMessageToList(plmsgOutput, Nd_Quiet, IDS_DSGETDC_13241, 
                       pwzDnsDomain );
       break;

   case ERROR_SUCCESS:
       break;
   }

   return status;
}

PWSTR ConcatonateStrings(PWSTR pwzFirst, PWSTR pwzSecond)
{
   PWSTR pwz;

   pwz = (PWSTR)LocalAlloc(LMEM_FIXED,
                           ((int)wcslen(pwzFirst) + (int)wcslen(pwzSecond) + 1) * sizeof(WCHAR));

   if (!pwz)
   {
      return NULL;
   }

   wcscpy(pwz, pwzFirst);
   wcscat(pwz, pwzSecond);

   return pwz;
}

BOOL AddToList(PWSTR * ppwzList, PWSTR pwz)
{
   PWSTR pwzTmp;

   if (*ppwzList)
   {
      pwzTmp = (PWSTR)LocalAlloc(LMEM_FIXED,
                                 ((int)wcslen(*ppwzList) + (int)wcslen(pwz) + 3) * sizeof(WCHAR));
      if (!pwzTmp)
      {
         return FALSE;
      }

      wcscpy(pwzTmp, *ppwzList);
      wcscat(pwzTmp, L", ");
      wcscat(pwzTmp, pwz);

      LocalFree(*ppwzList);

      *ppwzList = pwzTmp;
   }
   else
   {
      pwzTmp = AllocString(pwz);

      if (!pwzTmp)
      {
         return FALSE;
      }

      *ppwzList = pwzTmp;
   }
   return TRUE;
}

BOOL BuildDomainList(PWSTR * ppwzDomainList, PWSTR pwzDnsDomain)
{
   PWSTR pwzDot, pwzTmp;

   pwzTmp = AllocString(pwzDnsDomain);

   if (!pwzTmp)
   {
      return FALSE;
   }

   pwzDot = pwzDnsDomain;

   while (pwzDot = wcschr(pwzDot, L'.'))
   {
      pwzDot++;
      if (!pwzDot)
      {
         break;
      }

      if (!AddToList(&pwzTmp, pwzDot))
      {
         return FALSE;
      }
   }

   *ppwzDomainList = pwzTmp;

   return TRUE;
}

// string helpers.

PWSTR AllocString(PWSTR pwz)
{
   PWSTR pwzTmp;

   pwzTmp = (PWSTR)LocalAlloc(LMEM_FIXED, ((int)wcslen(pwz) + 1) * sizeof(WCHAR));

   if (!pwzTmp)
   {
      return NULL;
   }

   wcscpy(pwzTmp, pwz);

   return pwzTmp;
}


VOID
NetpIpAddressToStr(
    ULONG IpAddress,
    CHAR IpAddressString[NL_IP_ADDRESS_LENGTH+1]
    )
/*++

Routine Description:

    Convert an IP address to a string.

Arguments:

    IpAddress - IP Address to convert

    IpAddressString - resultant string.

Return Value:

    None.

--*/
{
    struct in_addr InetAddr;
    char * InetAddrString;

    //
    // Convert the address to ascii
    //
    InetAddr.s_addr = IpAddress;
    InetAddrString = inet_ntoa( InetAddr );

    //
    // Copy the string our to the caller.
    //

    if ( InetAddrString == NULL || strlen(InetAddrString) > NL_IP_ADDRESS_LENGTH ) {
        *IpAddressString = L'\0';
    } else {
        strcpy( IpAddressString, InetAddrString );
    }

    return;
}

VOID
NetpIpAddressToWStr(
    ULONG IpAddress,
    WCHAR IpAddressString[NL_IP_ADDRESS_LENGTH+1]
    )
/*++

Routine Description:

    Convert an IP address to a string.

Arguments:

    IpAddress - IP Address to convert

    IpAddressString - resultant string.

Return Value:

    None.

--*/
{
    CHAR IpAddressStr[NL_IP_ADDRESS_LENGTH+1];
    NetpIpAddressToStr( IpAddress, IpAddressStr );
    NetpCopyStrToWStr( IpAddressString, IpAddressStr );
}


NET_API_STATUS
NetpDcBuildPing(
    IN BOOL PdcOnly,
    IN ULONG RequestCount,
    IN LPCWSTR UnicodeComputerName,
    IN LPCWSTR UnicodeUserName OPTIONAL,
    IN LPCSTR ResponseMailslotName,
    IN ULONG AllowableAccountControlBits,
    IN PSID RequestedDomainSid OPTIONAL,
    IN ULONG NtVersion,
    OUT PVOID *Message,
    OUT PULONG MessageSize
    )

/*++

Routine Description:

    Build the message to ping a DC to see if it exists.
    Copied from net\svcdlls\logonsv\netpdc.c

Arguments:

    PdcOnly - True if only the PDC should respond.

    RequestCount - Retry count of this operation.

    UnicodeComputerName - Netbios computer name of the machine to respond to.

    UnicodeUserName - Account name of the user being pinged.
        If NULL, DC will always respond affirmatively.

    ResponseMailslotName - Name of the mailslot DC is to respond to.

    AllowableAccountControlBits - Mask of allowable account types for UnicodeUserName.

    RequestedDomainSid - Sid of the domain the message is destined to.

    NtVersion - Version of the message.
        0: For backward compatibility.
        NETLOGON_NT_VERSION_5: for NT 5.0 message.
        NETLOGON_NT_VERSION_5EX: for extended NT 5.0 message

    Message - Returns the message to be sent to the DC in question.
        Buffer must be free using NetpMemoryFree().

    MessageSize - Returns the size (in bytes) of the returned message


Return Value:

    NO_ERROR - Operation completed successfully;

    ERROR_NOT_ENOUGH_MEMORY - The message could not be allocated.

--*/
{
    NET_API_STATUS NetStatus;
    LPSTR Where;
    PNETLOGON_SAM_LOGON_REQUEST SamLogonRequest = NULL;
    LPSTR OemComputerName = NULL;

    //
    // If only the PDC should respond,
    //  build a primary query packet.
    //

    if ( PdcOnly ) {
        PNETLOGON_LOGON_QUERY LogonQuery;

        //
        // Allocate memory for the primary query message.
        //

        SamLogonRequest = NetpMemoryAllocate( sizeof(NETLOGON_LOGON_QUERY) );

        if( SamLogonRequest == NULL ) {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        LogonQuery = (PNETLOGON_LOGON_QUERY)SamLogonRequest;



        //
        // Translate to get an Oem computer name.
        //

#ifndef WIN32_CHICAGO
        OemComputerName = NetpLogonUnicodeToOem( (LPWSTR)UnicodeComputerName );
#else
        OemComputerName = MyNetpLogonUnicodeToOem( (LPWSTR)UnicodeComputerName );
#endif

        if ( OemComputerName == NULL ) {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        //
        // Build the query message.
        //

        LogonQuery->Opcode = LOGON_PRIMARY_QUERY;

        Where = LogonQuery->ComputerName;

        NetpLogonPutOemString(
                    OemComputerName,
                    sizeof(LogonQuery->ComputerName),
                    &Where );

        NetpLogonPutOemString(
                    (LPSTR) ResponseMailslotName,
                    sizeof(LogonQuery->MailslotName),
                    &Where );

        NetpLogonPutUnicodeString(
                    (LPWSTR) UnicodeComputerName,
                    sizeof( LogonQuery->UnicodeComputerName ),
                    &Where );

        // Join common code to add NT 5 specific data.


    //
    // If any DC can respond,
    //  build a logon query packet.
    //

    } else {
        ULONG DomainSidSize;

        //
        // Allocate memory for the logon request message.
        //

#ifndef WIN32_CHICAGO
        if ( RequestedDomainSid != NULL ) {
            DomainSidSize = RtlLengthSid( RequestedDomainSid );
        } else {
            DomainSidSize = 0;
        }
#else // WIN32_CHICAGO
        DomainSidSize = 0;
#endif // WIN32_CHICAGO

        SamLogonRequest = NetpMemoryAllocate(
                        sizeof(NETLOGON_SAM_LOGON_REQUEST) +
                        DomainSidSize +
                        sizeof(DWORD) // for SID alignment on 4 byte boundary
                        );

        if( SamLogonRequest == NULL ) {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }


        //
        // Build the query message.
        //

        SamLogonRequest->Opcode = LOGON_SAM_LOGON_REQUEST;
        SamLogonRequest->RequestCount = (WORD) RequestCount;

        Where = (PCHAR) &SamLogonRequest->UnicodeComputerName;

        NetpLogonPutUnicodeString(
                (LPWSTR) UnicodeComputerName,
                sizeof(SamLogonRequest->UnicodeComputerName),
                &Where );

        NetpLogonPutUnicodeString(
                (LPWSTR) UnicodeUserName,
                sizeof(SamLogonRequest->UnicodeUserName),
                &Where );

        NetpLogonPutOemString(
                (LPSTR) ResponseMailslotName,
                sizeof(SamLogonRequest->MailslotName),
                &Where );

        NetpLogonPutBytes(
                &AllowableAccountControlBits,
                sizeof(SamLogonRequest->AllowableAccountControlBits),
                &Where );

        //
        // Place domain SID in the message.
        //

        NetpLogonPutBytes( &DomainSidSize, sizeof(DomainSidSize), &Where );
        NetpLogonPutDomainSID( RequestedDomainSid, DomainSidSize, &Where );

    }

    NetpLogonPutNtToken( &Where, NtVersion );

    //
    // Return the message to the caller.
    //

    *Message = SamLogonRequest;
    *MessageSize = (ULONG)(Where - (PCHAR)SamLogonRequest);
    SamLogonRequest = NULL;

    NetStatus = NO_ERROR;


    //
    // Free locally used resources.
    //
Cleanup:

    if ( OemComputerName != NULL ) {
        NetpMemoryFree( OemComputerName );
    }

    if ( SamLogonRequest != NULL ) {
        NetpMemoryFree( SamLogonRequest );
    }
    return NetStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\defgw.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      defgw.c
//
//  Abstract:
//
//      Queries into network drivers
//
//  Author:
//
//      Anilth  - 4-20-1998 
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//      NSun       08/30/98
//
//--

#include "precomp.h"


//-------------------------------------------------------------------------//
//######  D e f G w T e s t ()  ###########################################//
//-------------------------------------------------------------------------//
HRESULT
DefGwTest(NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
//++
//
//  Routine Description:
//
//      Tests that the default gateway can be pinged. This doesn't really 
//      confirms forwarding on that IP address but it's a start.
//    
//  Arguments:
//
//      None.
//
//  Return Value:
//
//      TRUE:  Test suceeded.
//      FALSE: Test failed
//
//--
{
    DWORD   nReplyCnt;
    IPAddr  GwAddress;
    int     nGwsReachable = 0;
    int     i;

    PIP_ADAPTER_INFO  pIpAdapterInfo;
    IP_ADDR_STRING Gateway;

    PrintStatusMessage(pParams, 4, IDS_DEFGW_STATUS_MSG);

    //
    //  try to ping all gateways on all adapters
    //
    for( i = 0; i < pResults->cNumInterfaces; i++)
    {
        pIpAdapterInfo = pResults->pArrayInterface[i].IpConfig.pAdapterInfo;

        InitializeListHead( &pResults->pArrayInterface[i].DefGw.lmsgOutput );
        
        if (!pResults->pArrayInterface[i].IpConfig.fActive ||
            NETCARD_DISCONNECTED == pResults->pArrayInterface[i].dwNetCardStatus)
            continue;
        
        pResults->pArrayInterface[i].DefGw.dwNumReachable = 0;


        Gateway = pIpAdapterInfo->GatewayList;
        if ( Gateway.IpAddress.String[0] == 0 ) 
        {
            //No default gateway configured
            pResults->pArrayInterface[i].DefGw.dwNumReachable = -1;
            continue;
        }
        while ( TRUE ) {
            AddMessageToList(&pResults->pArrayInterface[i].DefGw.lmsgOutput, Nd_ReallyVerbose, IDS_DEFGW_12003, Gateway.IpAddress.String );
            //IDS_DEFGW_12003                  "       Pinging gateway %s "
            
            if ( IsIcmpResponseA(Gateway.IpAddress.String) )
            {
                AddMessageToListId(&pResults->pArrayInterface[i].DefGw.lmsgOutput, Nd_ReallyVerbose, IDS_DEFGW_12004 );
                //IDS_DEFGW_12004                  "- reachable\n" 
                nGwsReachable++;
                pResults->pArrayInterface[i].DefGw.dwNumReachable ++;
            }
            else {
                AddMessageToListId(&pResults->pArrayInterface[i].DefGw.lmsgOutput, Nd_ReallyVerbose, IDS_DEFGW_12005 );
                //IDS_DEFGW_12005                  "- not reachable\n" 
            }
            if ( Gateway.Next == NULL ) { break; }
            Gateway = *(Gateway.Next);
        }
    }

    // 
    //  No gateway is reachable - fatal.
    //
    if ( nGwsReachable == 0 )
    {
        PrintStatusMessage(pParams, 0, IDS_GLOBAL_FAIL_NL);
        pResults->DefGw.hrReachable = S_FALSE;
    }
    else
    {
        PrintStatusMessage(pParams, 0, IDS_GLOBAL_PASS_NL);
        pResults->DefGw.hrReachable = S_OK;
    }

    return pResults->DefGw.hrReachable;
} /* END OF DefGwTest() */


//----------------------------------------------------------------
//
// DefGwGlobalPrint
//
// Author   NSun
//
//------------------------------------------------------------------

void DefGwGlobalPrint(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults)
{
    if (!pResults->IpConfig.fEnabled)
    {
        return;
    }
    
    if (pParams->fVerbose || !FHrOK(pResults->DefGw.hrReachable))
    {
        PrintNewLine(pParams, 2);
        PrintTestTitleResult(pParams,
                             IDS_DEFGW_LONG,
							 IDS_DEFGW_SHORT,
                             TRUE,
                             pResults->DefGw.hrReachable,
                             0);
    }

    if(FHrOK(pResults->DefGw.hrReachable))
    {
        if (pParams->fReallyVerbose)
            PrintMessage(pParams,  IDS_DEFGW_12011 );
        //IDS_DEFGW_12011  "\n    PASS - you have at least one reachable gateway.\n"
    }
    else
    {
        //IDS_DEFGW_12006                  "\n" 
        PrintMessage(pParams,  IDS_DEFGW_12006 );
        //IDS_DEFGW_12007                  "    [FATAL] NO GATEWAYS ARE REACHABLE.\n" 
        PrintMessage(pParams,  IDS_DEFGW_12007 );
        //IDS_DEFGW_12008                  "    You have no connectivity to other network segments.\n" 
        PrintMessage(pParams,  IDS_DEFGW_12008 );
        //IDS_DEFGW_12009                  "    If you configured the IP protocol manually then\n" 
        PrintMessage(pParams,  IDS_DEFGW_12009 );
        //IDS_DEFGW_12010                  "    you need to add at least one valid gateway.\n" 
        PrintMessage(pParams,  IDS_DEFGW_12010 );
    }

}


//----------------------------------------------------------------
//
// DefGwPerInterfacePrint
//
// Author   NSun
//
//------------------------------------------------------------------
void DefGwPerInterfacePrint(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults, INTERFACE_RESULT *pInterfaceResults)
{
    if (!pInterfaceResults->fActive || 
        !pInterfaceResults->IpConfig.fActive ||
        NETCARD_DISCONNECTED == pInterfaceResults->dwNetCardStatus)
        return;
    
    if (pParams->fVerbose)
    {
        PrintNewLine(pParams, 1);
        if(-1 == pInterfaceResults->DefGw.dwNumReachable) //test skipped on this interface
            PrintTestTitleResult(pParams, IDS_DEFGW_LONG, IDS_DEFGW_SHORT, FALSE, S_FALSE, 8);
        else if(pInterfaceResults->DefGw.dwNumReachable == 0)
            PrintTestTitleResult(pParams, IDS_DEFGW_LONG, IDS_DEFGW_SHORT, TRUE, S_FALSE, 8);
        else
            PrintTestTitleResult(pParams, IDS_DEFGW_LONG, IDS_DEFGW_SHORT, TRUE, S_OK, 8);
    }

    PrintMessageList(pParams, &pInterfaceResults->DefGw.lmsgOutput);
    if(pParams->fVerbose)
    {
        if(-1 == pInterfaceResults->DefGw.dwNumReachable)
            PrintMessage(pParams, IDS_DEFGW_12002 );
            //IDS_DEFGW_12002                  "    There is no gateway defined for this adapter.\n" 
        else if( 0 == pInterfaceResults->DefGw.dwNumReachable)
            PrintMessage(pParams, IDS_DEFGW_12001);
            //IDS_DEFGW_12001                  "    No gateway reachable for this adapter. \n"
        else if (pParams->fReallyVerbose)
            PrintMessage(pParams, IDS_DEFGW_12012);
            //IDS_DEFGW_12012                   "   At least one gateway for this adapter is reachable. \n"

        PrintNewLine(pParams, 1);
    }
}



//----------------------------------------------------------------
//
// DefGwCleanup
//
// Author   NSun
//
//------------------------------------------------------------------
void DefGwCleanup(IN NETDIAG_PARAMS *pParams,
                     IN OUT NETDIAG_RESULT *pResults)
{
    int i;
    for(i = 0; i < pResults->cNumInterfaces; i++)
    {
        MessageListCleanUp(&pResults->pArrayInterface[i].DefGw.lmsgOutput);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\dnstest.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      dnstest.c
//
//  Abstract:
//
//      Queries into network drivers
//
//  Author:
//
//      Anilth  - 4-20-1998
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//      ElenaAp - 10-22-1998
//
//--

#include "precomp.h"
#include "dnscmn.h"



BOOL DnsServerUp(LPSTR IpAddressString,
                 NETDIAG_PARAMS *pParams,
                 NETDIAG_RESULT *pResults,
                 INTERFACE_RESULT *pIfResults);

BOOL DnsServerHasRecords(LPSTR IpAddressString,
                         NETDIAG_PARAMS *pParams,
                         NETDIAG_RESULT *pResults,
                         INTERFACE_RESULT *pIfResults);

BOOL DnsServerHasDCRecords (NETDIAG_PARAMS *pParams,
                            NETDIAG_RESULT *pResults,
                            LPSTR   IpAddressString);

BOOL ReadStringToDnsRecord(IN LPSTR lpstrString, OUT PDNS_RECORD pDNSRecord);

VOID PrintDNSError(IN NETDIAG_PARAMS *pParams,
                   IN NETDIAG_RESULT *pResults,
                   IN DWORD status,
                                   IN NdVerbose ndv);

VOID PrintARecord (IN NETDIAG_PARAMS *pParams, IN  PDNS_RECORD pDnsRecord );
VOID PrintSRVRecord (IN NETDIAG_PARAMS *pParams, IN  PDNS_RECORD pDnsRecord );
VOID PrintCNAMERecord (IN NETDIAG_PARAMS *pParams, IN  PDNS_RECORD pDnsRecord );
VOID PrintRecord (IN NETDIAG_PARAMS *pParams,
                  IN NETDIAG_RESULT *pResults,
                  IN  PDNS_RECORD pDnsRecord,
                                  IN NdVerbose ndv);




HRESULT
DnsTest(NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
/*++

Routine Description:

    Ensure that DNS is up and running

Arguments:

    None.

Return Value:

    TRUE: Test suceeded.
    FALSE: Test failed

--*/
{
    NET_API_STATUS  NetStatus;
    PIP_ADDR_STRING DnsServer;
    ULONG           WorkingDnsServerCount = 0;
    ULONG           ConfiguredDnsServerCount = 0;
    BOOL            fRecordsRegistered = FALSE;
    BOOL            fDSRecordsRegistered = FALSE;
    BOOL            fFixOnce = FALSE;
    BOOL            fBogusDnsRecord = FALSE;
    INTERFACE_RESULT *  pVariableInfo;
    PIP_ADAPTER_INFO pIpVariableInfo;
    IP_ADDR_STRING  LocalDnsServerList;
    PIP_ADDR_STRING DnsServerList;
    BOOL            fUseOldDnsServerList = FALSE;
    HRESULT         hr = hrOK, hrTemp = hrOK;
    WCHAR           wszBuffer[DNS_MAX_NAME_BUFFER_LENGTH];
    DWORD           dwSize = DNS_MAX_NAME_BUFFER_LENGTH;
    int             i, ids;
        PDNS_NETINFO            pNetworkInfo = NULL;
    DNS_STATUS                  dwStatus = NO_ERROR;
    LPTSTR              pError = NULL;
    BOOL                bDnscacheRunning = TRUE;
    BOOL                bGetComputerName = TRUE;
    PIP_ARRAY           pDnsServers = NULL;
    DWORD               idx, dwError;


    InitializeListHead(&pResults->Dns.lmsgOutput);

    for ( i=0; i<pResults->cNumInterfaces; i++)
        InitializeListHead( &pResults->pArrayInterface[i].Dns.lmsgOutput );

    PrintStatusMessage(pParams, 4, IDS_DNS_STATUS_MSG);

    //
    // Ensure the DNS cache resolver is running.
    //
    NetStatus = IsServiceStarted( _T("DnsCache") );
    if ( NetStatus != NO_ERROR )
    {
        PrintStatusMessage(pParams, 0, IDS_DNS_RESOLVER_CACHE_IS_OFF, NetStatusToString(NetStatus));

        pResults->Dns.fOutput = TRUE;
        AddMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet,
                         IDS_DNS_RESOLVER_CACHE_IS_OFF, NetStatusToString(NetStatus));
        bDnscacheRunning = FALSE;
    }


    //
    // For validation we must use the UNICODE DNS name, not the ANSI name
    //
    if (!GetComputerNameExW( ComputerNameDnsFullyQualified, wszBuffer, &dwSize ))
    {
        dwError = GetLastError();
        // "[WARNING] GetComputerNameExW() failed with error %d\n"
        PrintStatusMessage(pParams, 0,  IDS_DNS_12948, dwError);
        pResults->Dns.fOutput = TRUE;
        AddIMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, 4,
                              IDS_DNS_12948, dwError);
    }
    else
    {
        NetStatus = DnsValidateDnsName_W( wszBuffer );

        if ( NetStatus != NO_ERROR )
        {
            if ( NetStatus == DNS_ERROR_NON_RFC_NAME )
            {
                // "[WARNING] DnsHostName '%S' valid only on NT 5.0 DNS servers. [%s]\n"
                ids = IDS_DNS_NAME_VALID_NT5_ONLY;
            }
            else
            {
                // "[FATAL] DnsHostName '%S' is not valid. [%s]\n",
                ids = IDS_DNS_NAME_INVALID;
                hr = S_FALSE;
            }

            PrintStatusMessage(pParams, 0,  ids, wszBuffer, NetStatusToString(NetStatus));
            pResults->Dns.fOutput = TRUE;
            AddIMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, 4,
                              ids, wszBuffer, NetStatusToString(NetStatus));
        }
    }

    //
    // Get the DNS Network Information
    // Force rediscovery
    //
    pNetworkInfo = DnsQueryConfigAlloc(
                        DnsConfigNetInfo,
                        NULL );
    if (!pNetworkInfo)
    {
        dwStatus = GetLastError(); pError = NetStatusToString(dwStatus);
        // [FATAL] Cannot get the DNS Adapter Information from registry, error 0x%x %s\n
        PrintStatusMessage(pParams, 0, IDS_DNS_12877, dwStatus, pError);

        pResults->Dns.fOutput = TRUE;
        AddMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet,
                         IDS_DNS_12877, dwStatus, pError);
        hr = S_FALSE;
        goto Error;
    }

    //
    // See if we have at least one DNS server
    // If there are no DNS servers at all,
    // That's fatal.
    //
    dwStatus = GetAllDnsServersFromRegistry(pNetworkInfo, &pDnsServers);
    if (dwStatus)
    {
        if (dwStatus == DNS_ERROR_INVALID_DATA)
        {
            // IDS_DNS_12872 "[FATAL] No DNS servers are configured.\n"
            PrintStatusMessage(pParams, 8,  IDS_DNS_12872);

            pResults->Dns.fOutput = TRUE;
            AddIMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, 4,
                                IDS_DNS_12872);
        }
        else
        {
            // IDS_DNS_12885 "[FATAL] Cannot get the DNS server list, error %d %s\n"
            PrintStatusMessage(pParams, 8,  IDS_DNS_12885, dwStatus, NetStatusToString(dwStatus));

            pResults->Dns.fOutput = TRUE;
            AddIMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, 4,
                                IDS_DNS_12885, dwStatus, NetStatusToString(dwStatus));
        }

        hr = S_FALSE;
        goto Error;

    }

    // check the DNS registration
    hrTemp = CheckDnsRegistration(pNetworkInfo, pParams, pResults);
    hr = ((hr == S_FALSE) ? hr : hrTemp);

    //
    //if this is a DC, check if all the dns entries in
    //netlogon.dns are registered on DNS servers
    //
    if ( (pResults->Global.pPrimaryDomainInfo->MachineRole == DsRole_RoleBackupDomainController) ||
          (pResults->Global.pPrimaryDomainInfo->MachineRole == DsRole_RolePrimaryDomainController) )
    {
        //
        // go through list of DNS servers and check DC registration
        //
        for (idx = 0; idx < pDnsServers->AddrCount; idx++)
        {
            //
            //(nsun) we need just fix the DC records on one DNS server and that DNS server will replicate the
            //      the fix on other DNS servers
            //
            if ( !fFixOnce )
            {
                if (DnsServerHasDCRecords( pParams,
                                           pResults,
                                           IP_STRING(pDnsServers->AddrArray[idx])))
                     fDSRecordsRegistered = TRUE;
            }

            if ( pParams->fFixProblems )
                fFixOnce = TRUE;
        }

        if( !fDSRecordsRegistered )
        {
            PrintStatusMessage(pParams, 8, IDS_DNS_DC_FAILURE);
            //IDS_DNS_DC_FAILURE "[FATAL] No DNS servers have our DNS records for this DC registered.\n"
            AddIMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, 4,
                                IDS_DNS_DC_FAILURE);
            hr = S_FALSE;
        }
    }

/*
    //
    // If we're running a build that's older than ipconfig can handle,
    //  build our own list of DNS servers directly from the registry.
    //
    if ( _ttoi(pResults->Global.pszCurrentBuildNumber) < NTBUILD_DNSSERVERLIST)
    {
        HKEY TcpipParametersKey;
        HKEY TransientKey;
        LPSTR Name;
        BOOLEAN ok;
        BOOL   ReadRegistryIpAddrString(HKEY, LPSTR, PIP_ADDR_STRING);

        RtlZeroMemory( &LocalDnsServerList, sizeof(LocalDnsServerList));

        Name = "SYSTEM\\CurrentControlSet\\Services\\TcpIp\\Parameters";
        NetStatus = RegOpenKey( HKEY_LOCAL_MACHINE, Name, &TcpipParametersKey );

        if ( NetStatus != NO_ERROR )
        {
            PrintDebugSz(pParams, 0, _T("        [FATAL] Cannot open key '%s'. [%s]\n"),
                          Name, NetStatusToString(NetStatus) );
            hr = S_FALSE;
            goto Error;
        }
        //
        // NameServer: 1st try Transient key then NameServer (override) in
        // Parameters key, and finally DhcpNameServer in parameters key
        //

        if (RegOpenKey(TcpipParametersKey, "Transient", &TransientKey) == ERROR_SUCCESS) {
            ok = ReadRegistryIpAddrString(TransientKey,
                                          "NameServer",
                                          &LocalDnsServerList
                                          );
            RegCloseKey(TransientKey);
        } else {
            ok = FALSE;
        }

        if (!ok) {
            ok = ReadRegistryIpAddrString(TcpipParametersKey,
                                          "NameServer",
                                          &LocalDnsServerList
                                          );
        }

        if (!ok) {
            ok = ReadRegistryIpAddrString(TcpipParametersKey,
                                          "DhcpNameServer",
                                          &LocalDnsServerList
                                          );
        }

        RegCloseKey(TcpipParametersKey);

        fUseOldDnsServerList = TRUE;
    }


    //
    // Test the DNS servers for each adapter
    //
    for ( i=0; i<pResults->cNumInterfaces; i++)
    {
        pVariableInfo = pResults->pArrayInterface + i;
        pIpVariableInfo = pVariableInfo->IpConfig.pAdapterInfo;

        if (!pVariableInfo->IpConfig.fActive)
            continue;

        //
        // Use the old Dns server list or the per adapter one depending on
        //  what build we're running.
        //

        if ( fUseOldDnsServerList )
        {
            DnsServerList = &LocalDnsServerList;
        }
        else
        {
            DnsServerList = &pVariableInfo->IpConfig.DnsServerList;

            PrintStatusMessage(pParams, 8, IDS_DNS_CHECKING_DNS_SERVERS,
                               pVariableInfo->pszFriendlyName);

            AddMessageToListSz(&pVariableInfo->Dns.lmsgOutput, Nd_ReallyVerbose,
                               _T("            "));
            AddMessageToList(&pVariableInfo->Dns.lmsgOutput, Nd_ReallyVerbose,
                             IDS_DNS_CHECKING_DNS_SERVERS,
                             pVariableInfo->pszFriendlyName);
        }

        //
        // Make sure all of the DNS servers are up.
        //

        for ( DnsServer = DnsServerList;
              DnsServer;
              DnsServer = DnsServer->Next)
        {
            if ( DnsServer->IpAddress.String[0] == '\0' )
            {
                fBogusDnsRecord = TRUE;
                continue;
            }

            ConfiguredDnsServerCount++;

            if ( DnsServerUp( DnsServer->IpAddress.String,
                              pParams,
                              pResults,
                              pVariableInfo) )
            {
                if ( pParams->fReallyVerbose)
                {
                    // IDS_DNS_SERVER_IS_UP "DNS server at %s is up.\n"
                    AddMessageToList(&pVariableInfo->Dns.lmsgOutput,
                                     Nd_ReallyVerbose,
                                     IDS_DNS_SERVER_IS_UP,
                                     DnsServer->IpAddress.String );
                }
                WorkingDnsServerCount ++;


                //
                // Since the server is up,
                //  check to see that it has all of the right records registered.
                //

                if ( DnsServerHasRecords( DnsServer->IpAddress.String, pParams, pResults, pVariableInfo) ) {
                    fRecordsRegistered = TRUE;
                }

    if ((hr == hrOK))
    {
                // check DC dns entry here
                //
                //if this is a DC, we check if all the dns entries in
                //netlogon.dns are registered on DNS server
                //
                if ( pResults->Global.pPrimaryDomainInfo->MachineRole ==
                        DsRole_RoleBackupDomainController ||
                     pResults->Global.pPrimaryDomainInfo->MachineRole ==
                        DsRole_RolePrimaryDomainController )
                {
                    //(nsun) we need just fix the DC records on one DNS server and that DNS server will replicate the
                    //      the fix on other DNS servers
                     if ( !fFixOnce )
                     {
                        if (DnsServerHasDCRecords( pParams,
                                                   pResults,
                                                   DnsServer->IpAddress.String))
                            fDSRecordsRegistered = TRUE;
                     }

                     if ( pParams->fFixProblems )
                         fFixOnce = TRUE;
                }
                // if it is not a DC, we don't check it later.
                else
                   fDSRecordsRegistered = TRUE;
    }
            }
        }

        //
        // There isn't one old list per adapter
        //
        if ( fUseOldDnsServerList ) {
            break;
        }

    }

    //
    // If there are no DNS servers at all,
    //  That's fatal.
    //

    if ( ConfiguredDnsServerCount == 0 )
    {
        if ( !fBogusDnsRecord )
        {
            // IDS_DNS_12872 "[FATAL] No DNS servers are configured.\n"
            PrintStatusMessage(pParams, 8,  IDS_DNS_12872);

            pResults->Dns.fOutput = TRUE;
            AddIMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, 4,
                                IDS_DNS_12872);


            hr = S_FALSE;
        }

        //
        // If there are no working DNS servers,
        //  That's fatal.
        //

    }
    else if ( WorkingDnsServerCount == 0 )
    {
        // IDS_DNS_12873  "[FATAL] No DNS servers are working.\n"
        PrintStatusMessage(pParams, 8, IDS_DNS_12873);

        pResults->Dns.fOutput = TRUE;
        AddIMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, 4,
                          IDS_DNS_12873);
        hr = S_FALSE;

    }
    else
    {
        if ( !fRecordsRegistered )
        {
            //
            // Warn if no DNS servers have our addresses registered.
            //  (But still not fatal).
            //
            // IDS_DNS_12874 "[WARNING] No DNS servers have our records registered.\n"
            PrintStatusMessage(pParams, 8, IDS_DNS_12874);

            pResults->Dns.fOutput = TRUE;
            AddIMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, 4,
                               IDS_DNS_12874);
        }
*/

    DnsFreeConfigStructure(
        pNetworkInfo,
        DnsConfigNetInfo );

    if (pDnsServers) LocalFree (pDnsServers);
    pResults->Dns.hr = hr;
    return hr;

Error:
    if (pDnsServers) LocalFree (pDnsServers);
    pResults->Dns.hr = hr;
    return hr;
}





BOOL
DnsServerUp(
            LPSTR IpAddressString,
            NETDIAG_PARAMS *pParams,
            NETDIAG_RESULT *pResults,
            INTERFACE_RESULT *pIfResults
    )
/*++

Routine Description:

    Determine if the DNS server at the specified address is up and running.

Arguments:

    IpAddressString - Ip Address of a DNS server

Return Value:

    TRUE: Dns server is up.
    FALSE: Dns server is not up

--*/
{
    NET_API_STATUS NetStatus;
    BOOL RetVal = TRUE;
    CHAR SoaNameBuffer[DNS_MAX_NAME_LENGTH+1];
    PCHAR SoaName;
    PCHAR OldSoaName;
    PDNS_RECORD DnsRecord = NULL;
    SOCKADDR_IN SockAddr;
    ULONG SockAddrSize;

    IP_ARRAY DnsServer;

    //
    // Ping the DNS server.
    //

    if ( !IsIcmpResponseA( IpAddressString) )
    {
        PrintStatusMessage(pParams, 12, IDS_DNS_CANNOT_PING, IpAddressString);

        pIfResults->Dns.fOutput = TRUE;
        AddIMessageToList(&pIfResults->Dns.lmsgOutput, Nd_Quiet, 16,
                          IDS_DNS_CANNOT_PING, IpAddressString);
        RetVal = FALSE;
        goto Cleanup;
    }

    //
    // Compute the name of an SOA record.
    //

    if (pResults->Global.pszDnsDomainName == NULL)
    {
//IDS_DNS_12821                  "    [FATAL] Cannot test DNS server at %s since no DnsDomainName\n."
        AddMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, IDS_DNS_12821, IpAddressString );
        RetVal = FALSE;
        goto Cleanup;
    }

    strcpy( SoaNameBuffer, pResults->Global.pszDnsDomainName );
    SoaName = SoaNameBuffer;

    //
    // Tell DNS which Dns Server to use
    //

    DnsServer.AddrCount = 1;
    SockAddrSize = sizeof(SockAddr);
    NetStatus = WSAStringToAddress( IpAddressString,
                                    AF_INET,
                                    NULL,
                                    (LPSOCKADDR) &SockAddr,
                                    &SockAddrSize );

    if ( NetStatus != NO_ERROR ) {
        NetStatus = WSAGetLastError();
//IDS_DNS_12822                  "    [FATAL] Cannot convert DNS server address %s to SockAddr. [%s]\n"
        AddMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, IDS_DNS_12822, IpAddressString, NetStatusToString(NetStatus));
        RetVal = FALSE;
        goto Cleanup;
    }

    DnsServer.AddrArray[0] = SockAddr.sin_addr.S_un.S_addr;

    //
    // Loop until the real SOA record is found
    //

    for (;;) {

        //
        // Query this DNS server for the SOA record.
        //

        NetStatus = DnsQuery( SoaName,
                              DNS_TYPE_SOA,
                              DNS_QUERY_BYPASS_CACHE |
                                DNS_QUERY_NO_RECURSION,
                              &DnsServer,
                              &DnsRecord,
                              NULL );

        if ( NetStatus == NO_ERROR ) {
            if ( DnsRecord != NULL ) {
                DnsRecordListFree ( DnsRecord, TRUE );
            }
            DnsRecord = NULL;
            break;
        }

        switch ( NetStatus ) {
        case ERROR_TIMEOUT:     // DNS server isn't available
        case DNS_ERROR_RCODE_SERVER_FAILURE:  // Server failed
            // IDS_DNS_12823  "    [WARNING] DNS server at %s is down for SOA record '%s'. [%s]\n"
            AddMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, IDS_DNS_12823, IpAddressString, SoaName, NetStatusToString(NetStatus) );
            //IDS_DNS_12825                  "\n"
            AddMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, IDS_DNS_12825);
            RetVal = FALSE;
            goto Cleanup;

        case DNS_ERROR_NO_TCPIP:    // TCP/IP not configured
            // IDS_DNS_12826 "    [FATAL] DNS (%s) thinks IP is not configured for SOA record '%s'. [%s]\n"
            AddMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, IDS_DNS_12826, IpAddressString, SoaName, NetStatusToString(NetStatus) );
            RetVal = FALSE;
            goto Cleanup;

        case DNS_ERROR_NO_DNS_SERVERS:  // DNS not configured
            // IDS_DNS_12827 "    [FATAL] DNS (%s) thinks DNS is not configured for SOA record '%s'. [%s]\n"
            AddMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, IDS_DNS_12827, IpAddressString, SoaName, NetStatusToString(NetStatus) );
            RetVal = FALSE;
            goto Cleanup;

        case DNS_ERROR_RCODE_NAME_ERROR:    // no RR's by this name
        case DNS_INFO_NO_RECORDS:           // RR's by this name but not of the requested type:
            break;
        default:
            // IDS_DNS_12828 "    [FATAL] Cannot query DNS server at %s for SOA record '%s'. [%s]\n"
            AddMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, IDS_DNS_12828, IpAddressString, SoaName, NetStatusToString(NetStatus) );
            RetVal = FALSE;
            goto Cleanup;
        }

        //
        // Remove the next label from the potential SOA name and use it.
        //

        SoaName = strchr( SoaName, '.' );

        if ( SoaName == NULL )
        {
            // IDS_DNS_12829  "    [FATAL] DNS server at %s could not find an SOA record for '%s'.\n"
            AddMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, IDS_DNS_12829, IpAddressString, pResults->Global.pszDnsDomainName );
            RetVal = FALSE;
            goto Cleanup;
        }

        SoaName ++;
    }

Cleanup:
    if ( DnsRecord != NULL ) {
        DnsRecordListFree ( DnsRecord, TRUE );
    }
    return RetVal;
}





BOOL
DnsServerHasRecords(LPSTR IpAddressString,
                    NETDIAG_PARAMS *pParams,
                    NETDIAG_RESULT *pResults,
                    INTERFACE_RESULT *pIfResults
    )
/*++

Routine Description:

    Determine if the DNS server at the specified address has all of records
    registered that that machine is supposed to have registered.

Arguments:

    IpAddressString - Ip Address of a DNS server

Return Value:

    TRUE: Dns server is up.
    FALSE: Dns server is not up

--*/
{
    NET_API_STATUS NetStatus;
    BOOL RetVal = TRUE;
    CHAR LocalIpAddressString[NL_IP_ADDRESS_LENGTH+1];
    PDNS_RECORD DnsRecord = NULL;
    PDNS_RECORD CurrentDnsRecord;
    SOCKADDR_IN SockAddr;
    ULONG SockAddrSize;

    PLIST_ENTRY ListEntry;
    PNETBT_TRANSPORT NetbtTransport;

    IP_ARRAY DnsServer;

    //
    // Avoid this test if this build is incompatible with the current
    //  Dynamic DNS servers.
    //

    if ( _ttoi(pResults->Global.pszCurrentBuildNumber) < NTBUILD_DYNAMIC_DNS)
    {
            // IDS_DNS_CANNO_TEST_DNS "Cannot test Dynamic DNS to %s since this machine is running build %ld. [Test skipped.]\n",
        AddMessageToList(&pIfResults->Dns.lmsgOutput,
                             Nd_ReallyVerbose,
                             IDS_DNS_CANNOT_TEST_DNS,
                             IpAddressString, pResults->Global.pszCurrentBuildNumber );
        return TRUE;
    }

    //
    // Tell DNS which Dns Server to use
    //

    DnsServer.AddrCount = 1;
    SockAddrSize = sizeof(SockAddr);
    NetStatus = WSAStringToAddress( IpAddressString,
                                    AF_INET,
                                    NULL,
                                    (LPSOCKADDR) &SockAddr,
                                    &SockAddrSize );

    if ( NetStatus != NO_ERROR )
    {
        NetStatus = WSAGetLastError();

        PrintDebugSz(pParams, 0, _T("    [FATAL] Cannot convert DNS server address %s to SockAddr. [%s]\n"),
                        IpAddressString, NetStatusToString(NetStatus));

        AddMessageToList(&pIfResults->Dns.lmsgOutput,
                         Nd_ReallyVerbose,
                         IDS_DNS_CANNOT_CONVERT_DNS_ADDRESS,
                         IpAddressString, NetStatusToString(NetStatus));

        RetVal = FALSE;
        goto Cleanup;
    }

    DnsServer.AddrArray[0] = SockAddr.sin_addr.S_un.S_addr;


    //
    // Query this DNS server for A record for this hostname
    //

    NetStatus = DnsQuery( pResults->Global.szDnsHostName,
                          DNS_TYPE_A,
                          DNS_QUERY_BYPASS_CACHE,
                          &DnsServer,
                          &DnsRecord,
                          NULL );

    switch ( NetStatus )
    {
        case NO_ERROR:
            break;
        case ERROR_TIMEOUT:     // DNS server isn't available
        case DNS_ERROR_RCODE_SERVER_FAILURE:  // Server failed
            // IDS_DNS_SERVER_IS_DOWN "    [WARNING] DNS server at %s is down. [%s]\n"
            PrintStatusMessage(pParams, 12, IDS_DNS_SERVER_IS_DOWN, IpAddressString, NetStatusToString(NetStatus));
            AddIMessageToList(&pIfResults->Dns.lmsgOutput,
                              Nd_ReallyVerbose,
                              16,
                              IDS_DNS_SERVER_IS_DOWN,
                              IpAddressString, NetStatusToString(NetStatus));
            RetVal = FALSE;
            goto Cleanup;
        case DNS_ERROR_NO_TCPIP:    // TCP/IP not configured
            //IDS_DNS_THINKS_IP_IS_UNCONFIGURED "    [FATAL] DNS (%s) thinks IP is not configured. [%s]\n"
            AddMessageToList(&pIfResults->Dns.lmsgOutput,
                             Nd_ReallyVerbose,
                             IDS_DNS_THINKS_IP_IS_UNCONFIGURED,
                             IpAddressString, NetStatusToString(NetStatus));
            RetVal = FALSE;
            goto Cleanup;
        case DNS_ERROR_NO_DNS_SERVERS:  // DNS not configured
            // IDS_DNS_IS_UNCONFIGURED "    [FATAL] DNS (%s) thinks DNS is not configured. [%s]\n"
            AddMessageToList(&pIfResults->Dns.lmsgOutput,
                             Nd_ReallyVerbose,
                             IDS_DNS_IS_UNCONFIGURED,
                             IpAddressString, NetStatusToString(NetStatus));
            RetVal = FALSE;
            goto Cleanup;
        case DNS_ERROR_RCODE_NAME_ERROR:    // no RR's by this name
        case DNS_INFO_NO_RECORDS:           // RR's by this name but not of the requested type:
            // IDS_DNS_HAS_NO_RECORD "    [WARNING] DNS server at %s has no A record for '%s'. [%s]\n"
            AddMessageToList(&pIfResults->Dns.lmsgOutput,
                             Nd_ReallyVerbose,
                             IDS_DNS_HAS_NO_RECORD,
                             IpAddressString,
                             pResults->Global.szDnsHostName,
                             NetStatusToString(NetStatus) );
            RetVal = FALSE;
            goto Cleanup;
        default:
            // IDS_DNS_CANNOT_QUERY "    [FATAL] Cannot query DNS server at %s. [%s]\n"
            AddMessageToList(&pIfResults->Dns.lmsgOutput,
                             Nd_ReallyVerbose,
                             IDS_DNS_CANNOT_QUERY,
                             IpAddressString, pResults->Global.szDnsHostName,
                             NetStatusToString(NetStatus) );
            RetVal = FALSE;
            goto Cleanup;
    }

    //
    // We have an A record for ourselves.
    //
#ifdef notdef
//IDS_DNS_12830                  "    DNS server at %s has an A record for '%s'.\n"
        AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12830, IpAddressString, pResults->Global.szDnsHostName );
        if ( pParams->fDebugVerbose ) {
                        PrintMessage(pParams, IDS_DNS_12830, IpAddressString, pResults->Global.szDnsHostName );
//IDS_DNS_12831                  "    A"
            DnsPrint_RecordSet( &PrintMessage(pParams,  IDS_DNS_12831, DnsRecord );
        }
#endif // notdef

    //
    // Match the IP address on the A records with the IP address of this machine
    //
    // Mark each transport that its IP address hasn't yet been found.
    //

    for ( ListEntry = pResults->NetBt.Transports.Flink ;
          ListEntry != &pResults->NetBt.Transports ;
          ListEntry = ListEntry->Flink ) {

        NetbtTransport = CONTAINING_RECORD( ListEntry, NETBT_TRANSPORT, Next );

        NetbtTransport->Flags &= ~IP_ADDRESS_IN_DNS;

    }

    //
    // Loop through the A records
    //
    for ( CurrentDnsRecord = DnsRecord;
          CurrentDnsRecord;
          CurrentDnsRecord = CurrentDnsRecord->pNext )
    {

        //
        // Ignore everything but A records.
        //

        if ( CurrentDnsRecord->wType == DNS_TYPE_A )
        {
            BOOLEAN FoundIt = FALSE;

            //
            // Loop through the list of netbt transports finding one with this IP address.
            //

            for ( ListEntry = pResults->NetBt.Transports.Flink ;
                  ListEntry != &pResults->NetBt.Transports ;
                  ListEntry = ListEntry->Flink )
            {

                NetbtTransport = CONTAINING_RECORD( ListEntry, NETBT_TRANSPORT, Next );

                if ( NetbtTransport->IpAddress == CurrentDnsRecord->Data.A.IpAddress )
                {
                    FoundIt = TRUE;
                    NetbtTransport->Flags |= IP_ADDRESS_IN_DNS;
                }

            }


            if ( !FoundIt )
            {
                NetpIpAddressToStr( CurrentDnsRecord->Data.A.IpAddress, LocalIpAddressString );

                // IDS_DNS_HAS_A_RECORD "    [WARNING] DNS server at %s has an A record for '%s' with wrong IP address: %s", IpAddressString, pResults->Global.szDnsHostName, LocalIpAddressString );

                AddMessageToList(&pIfResults->Dns.lmsgOutput,
                                 Nd_ReallyVerbose,
                                 IDS_DNS_HAS_A_RECORD,
                                 IpAddressString,
                                 pResults->Global.szDnsHostName,
                                 LocalIpAddressString );

                RetVal = FALSE;
            }

        }
    }

    //
    // If all of the addresses of this machine aren't registered,
    //  complain.
    //

    for ( ListEntry = pResults->NetBt.Transports.Flink ;
          ListEntry != &pResults->NetBt.Transports ;
          ListEntry = ListEntry->Flink )
    {
        NetbtTransport = CONTAINING_RECORD( ListEntry, NETBT_TRANSPORT, Next );

        if ( (NetbtTransport->Flags & IP_ADDRESS_IN_DNS) == 0 )
        {
            NetpIpAddressToStr( NetbtTransport->IpAddress, LocalIpAddressString );
            // IDS_DNS_HAS_NO_A_RECORD "    [WARNING] DNS server at %s does not have an A record for '%s' with IP address: %s (%ws)", IpAddressString, pResults->Global.szDnsHostName, LocalIpAddressString, NetbtTransport->pswzTransportName );
            AddMessageToList(&pIfResults->Dns.lmsgOutput,
                             Nd_ReallyVerbose,
                             IDS_DNS_HAS_NO_A_RECORD,
                             IpAddressString,
                             pResults->Global.szDnsHostName,
                             LocalIpAddressString,
                             NetbtTransport->pswzTransportName );


            RetVal = FALSE;
        }

    }


Cleanup:
    if ( DnsRecord != NULL ) {
        DnsRecordListFree ( DnsRecord, TRUE );
    }
    return RetVal;
}


BOOL
DnsServerHasDCRecords ( NETDIAG_PARAMS *pParams,
                        NETDIAG_RESULT *pResults,
                        LPSTR   IpAddressString)

/*++

Routine Description:
   On a DC machine, Open file (%systemroot%\system32\config\netlogon.dns) and read the dns entry from it.
   Query the specified dns server for the entry and confirm it is correct.
   Reupdate these entry if /fix option is on.

Arguments:  IpAddressString - DNS server IP address

Return Value:

    TRUE: Query succeed.
    FALSE: failed.

--*/

{
    char pchDnsDataFileName[MAX_PATH] = "\\config\\netlogon.dns";
    char pchDnsDataFileExpandName[MAX_PATH];
    FILE    *fDnsFile;
    PIP_ARRAY pIpArray = NULL;
    CHAR    achTempLine[ NL_MAX_DNS_LENGTH*3+1 ];
    INT   iMaxLineLength;
    DWORD       status, dwOptions = DNS_QUERY_BYPASS_CACHE;
    PDNS_RECORD     pDNSRecord = NULL;
    PDNS_RECORD     pDNSTempRecord = NULL;
    PDNS_RECORD     pDiff1=NULL, pDiff2=NULL;
    PDNS_RECORD pNotUsedSet = NULL;
    BOOL    bReRegister, bReadData = FALSE, bFixFail = FALSE;
    BOOL    fRetVal = TRUE;

    enum _Results               // Declare enum type
    {
        enumSuccess,
        enumRegistered,
        enumProblem,
        enumTimeout
    } Results;

    Results = enumSuccess;

    pIpArray = (PIP_ARRAY) LocalAlloc( LPTR,
                    ( sizeof(IP_ADDRESS) + sizeof(DWORD) ));

    // "Check the DNS registration for DCs entries on DNS server %s\n"
    AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12944, IpAddressString);

    if ( ! pIpArray ) {
      DebugMessage("   [FATAL] No enough memory to create IpArray.");
      return ( FALSE );
    }
    pIpArray->AddrCount = 1;
    pIpArray->AddrArray[0] = inet_addr( IpAddressString );

    if ( pIpArray->AddrArray[0] == INADDR_NONE) {
         //IDS_DNS_IPADDR_ERR   "   [FATAL] Cannot convert DNS server address %s, failed in inet_addr().\n"
        PrintStatusMessage(pParams, 0,  IDS_DNS_IPADDR_ERR, IpAddressString);
        pResults->Dns.fOutput = TRUE;
        AddMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, IDS_DNS_IPADDR_ERR, IpAddressString);
         return( FALSE );
    }

    //
    //open file
    //
    if ( ! GetSystemDirectory ( pchDnsDataFileExpandName, MAX_PATH)) {
        // IDS_DNS_12832                  "    [FATAL] Could not GetSystemDir %s for reading."
            PrintStatusMessage(pParams, 0,  IDS_DNS_12832,  pchDnsDataFileExpandName);
            pResults->Dns.fOutput = TRUE;
            AddMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet,
                    IDS_DNS_12832,
                    pchDnsDataFileExpandName);
            return FALSE;
        }
    strcat( pchDnsDataFileExpandName, pchDnsDataFileName);
    if (( fDnsFile = fopen (pchDnsDataFileExpandName, "rt")) == NULL) {
        //IDS_DNS_12833                  "   [FATAL] Could not open file %s for reading."
            PrintStatusMessage(pParams, 0,  IDS_DNS_12833,  pchDnsDataFileExpandName);
            pResults->Dns.fOutput = TRUE;
            AddMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet,
                    IDS_DNS_12833,
                    pchDnsDataFileExpandName);
            return FALSE ;
        }

    //
    //allocate memory for pDNSRecord
    //

    pDNSRecord = (PDNS_RECORD) Malloc( sizeof( DNS_RECORD ) );

    if ( !pDNSRecord )
    {
        // IDS_DNS_12834 "Out of Memory: LocalAlloc(sizeof(DNS_RECORD)) call failed.\n"
        PrintStatusMessage(pParams, 0,  IDS_DNS_12834);
        pResults->Dns.fOutput = TRUE;
        AddMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, IDS_DNS_12834 );
        return( FALSE );
    }

    ZeroMemory( pDNSRecord, sizeof( DNS_RECORD ) );

    //read each line
    //do query one by one
    //print out msg
    //do reupdate
    //check the result

    //
    // Parse the file line by line
    //
    iMaxLineLength = NL_MAX_DNS_LENGTH*3+1 ;
    while( fgets( achTempLine, iMaxLineLength, fDnsFile ) != NULL)
    {
        //
        // Read the data into pDNSRecord
        //
        if (ReadStringToDnsRecord(achTempLine, pDNSRecord))
        {

            bReadData = TRUE ;

            if ( pParams->fDebugVerbose )
            {
//IDS_DNS_12835                  "\n********** * ********** * ********** * ********** * ********** *\n"
                 AddMessageToList(&pResults->Dns.lmsgOutput, Nd_DebugVerbose, IDS_DNS_12835);
//IDS_DNS_12836                  "* CHECK NAME %s on DNS server %s\n"
                 AddMessageToList(&pResults->Dns.lmsgOutput, Nd_DebugVerbose, IDS_DNS_12836,
UTF8ToAnsi(pDNSRecord->pName), IpAddressString);
//IDS_DNS_12837                  "********** * ********** * ********** * ********** * ********** *\n\n"
                 AddMessageToList(&pResults->Dns.lmsgOutput, Nd_DebugVerbose, IDS_DNS_12837);
            }

            bReRegister = FALSE;
            //
            // make the query
            //
            status = DnsQuery_UTF8(
                        pDNSRecord->pName,
                        pDNSRecord->wType,
                        dwOptions,
                        pIpArray,
                        &pDNSTempRecord,
                        NULL );

            if ( status )
            {

//IDS_DNS_12838                  "Query for DC DNS entry %s on DNS server %s failed.\n"
                AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12838,
UTF8ToAnsi(pDNSRecord->pName), IpAddressString);
                PrintDNSError( pParams, pResults, status, Nd_ReallyVerbose );
                bReRegister = TRUE;
                Results = enumProblem;

                //
                // if result was TIMEOUT do not continue querying this server
                //
                if ( status == ERROR_TIMEOUT )
                {
                    Results = enumTimeout;
                    break;
                }
            }
            else
            {
                //
                // Sometimes when DnsQuery is called, the returned record set
                // contains additional records of different types than what
                // was queried for. Need to strip off the additional records
                // from the query results.
                //
                pNotUsedSet = DnsRecordSetDetach( pDNSTempRecord );

                if ( pNotUsedSet )  {
                    DnsRecordListFree( pNotUsedSet, TRUE );
                    pNotUsedSet = NULL;
                    }

                if ( DnsRecordSetCompare(
                            pDNSRecord,
                            pDNSTempRecord,
                            &pDiff1,
                            &pDiff2 ))
                {
                    //
                    // The response from dns server is the same as the data in the file
                    //
                    //PrintDebugSz(pParams, 0, _T("The Record is correct on dns server %s!\n\n"), IpAddressString);
                    AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12941, IpAddressString);
                }
                else
                {
                    //
                    // The RR on dns server is different, we check if it is one of the RR on dns server
                    //
                    // PrintDebugSz(pParams, 0, _T("The Record is different on dns server %s.\n"), IpAddressString);
                    AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12942,  IpAddressString);
                    if (pDiff1 == NULL)
                    {
                        //"DNS server has more than one entries for this name, usually this means there are multiple DCs for this domain.\nYour DC entry is one of them on DNS server %s, no need to re-register.\n"
                        AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12943, IpAddressString);
                        if ( Results ==  enumSuccess )
                            Results = enumRegistered;
                    }
                    else
                    {
                        Results = enumProblem;
                        bReRegister = TRUE;
                    }

//IDS_DNS_12839                  "\n+------------------------------------------------------+\n"
                     AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12839);
//IDS_DNS_12840                  "The record on your DC is: \n"
                     AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12840);
                     PrintRecord(pParams, pResults, pDNSRecord, Nd_ReallyVerbose );
//IDS_DNS_12841                  "\nThe record on DNS server %s is:\n"
                     AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12841, IpAddressString);
                     PrintRecord(pParams, pResults, pDNSTempRecord, Nd_ReallyVerbose );
//IDS_DNS_12842                  "+------------------------------------------------------+\n\n"
                     AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12842);

                }
            }
            if ( bReRegister && pParams->fFixProblems)
            {
                //
                // Send to  register again
                //
                // IDS_DNS_12843  "  [Fix] Try to re-register the record on DNS server %s...\n"
                AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12843, IpAddressString);

                status = DnsModifyRecordsInSet(
                                pDNSRecord,         // add records
                                NULL,               // no delete records
                                0,                  // no options
                                NULL,               // default security context
                                pIpArray,           // DNS servers
                                NULL
                                );

                if ( status != ERROR_SUCCESS )
                {
                    // IDS_DNS_12844 "    [FATAL] Failed to fix: DC DNS entry %s re-registeration on DNS server %s failed. \n"
                    AddMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, IDS_DNS_12844, pDNSRecord->pName, IpAddressString);
                    PrintDNSError( pParams, pResults, status, Nd_Quiet );
                    bFixFail = TRUE;
                }
                else
                {
//IDS_DNS_12845                  "  [FIX] re-register DC DNS entry %s on DNS server %s succeed.\n"
                    AddMessageToList(&pResults->Dns.lmsgOutput, Nd_Verbose, IDS_DNS_12845, UTF8ToAnsi(pDNSRecord->pName), IpAddressString );
                }
            }



            //
            // free the memory after process each line
            //
            if ( pDNSTempRecord )
                DnsRecordListFree( pDNSTempRecord, TRUE );
            if ( pDiff1 ){
                DnsRecordListFree( pDiff1, TRUE );
                pDiff1 = NULL;
            }
            if ( pDiff2 ) {
                DnsRecordListFree( pDiff2, TRUE );
                pDiff2 = NULL;
            }
        }
        else {
            bReadData = FALSE ;
        }

    }
    // "\n ** ** Check DC DNS NAME FINAL RESULT ** ** \n"
    if ( pParams->fDebugVerbose )
    {
        AddMessageToList(&pResults->Dns.lmsgOutput, Nd_DebugVerbose, IDS_DNS_12945);
    }

    if (bReadData == FALSE)
    {
        // PrintDebugSz(pParams, 0, _T("   [FATAL] File %s contains invalid dns entries. Send the file to DnsDev"), pchDnsDataFileName);
        PrintStatusMessage(pParams, 0,  IDS_DNS_12946, pchDnsDataFileName);
        pResults->Dns.fOutput = TRUE;
        AddIMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, 4,
                                IDS_DNS_12946, pchDnsDataFileName);
        fRetVal = FALSE;
    }
    else
    {
        switch (Results)
        {
        case enumSuccess:
            // IDS_DNS_12846 "    PASS - All the DNS entries for DC are registered on DNS server %s.\n"
            PrintStatusMessage(pParams, 0,  IDS_DNS_12846, IpAddressString);
            pResults->Dns.fOutput = TRUE;
            AddMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, IDS_DNS_12846, IpAddressString);
            fRetVal = TRUE;
            break;
        case enumRegistered:
            // IDS_DNS_12847 "    PASS - All the DNS entries for DC are registered on DNS server %s and other DCs also have some of the names registered.\n"
            PrintStatusMessage(pParams, 0,  IDS_DNS_12847, IpAddressString);
            pResults->Dns.fOutput = TRUE;
            AddMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, IDS_DNS_12847, IpAddressString);
            fRetVal = TRUE;
            break;
        case enumTimeout:
            // IDS_DNS_12850  "       [WARNING] The DNS entries for this DC cannot be verified right now on DNS server %s, ERROR_TIMEOUT. \n"
            PrintStatusMessage(pParams, 0,  IDS_DNS_12949, IpAddressString);
            pResults->Dns.fOutput = TRUE;
            AddMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, IDS_DNS_12949, IpAddressString);
            fRetVal = FALSE;
            break;
        case enumProblem:
        default:
            if (pParams->fFixProblems)
            {
                if (bFixFail == FALSE )
                {
                    // IDS_DNS_12848 "   FIX PASS - nettest re-registered missing DNS entries for this DC successfully on DNS server %s.\n"
                    PrintStatusMessage(pParams, 0,  IDS_DNS_12848, IpAddressString);
                    pResults->Dns.fOutput = TRUE;
                    AddMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, IDS_DNS_12848, IpAddressString);
                }
                else
                {
                    // IDS_DNS_12849  "   [FATAL] Fix Failed: nettest failed to re-register missing DNS entries for this DC on DNS server %s.\n"
                    PrintStatusMessage(pParams, 0,  IDS_DNS_12849, IpAddressString);
                    pResults->Dns.fOutput = TRUE;
                    AddMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, IDS_DNS_12849, IpAddressString);
                }
            }
            else
            {
                // IDS_DNS_12850  "       [WARNING] The DNS entries for this DC are not registered correctly on DNS server %s. Please wait for 30 minutes for DNS server replication.\n"
                PrintStatusMessage(pParams, 0,  IDS_DNS_12850, IpAddressString);
                pResults->Dns.fOutput = TRUE;
                AddMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, IDS_DNS_12850, IpAddressString);
            }
            fRetVal = FALSE;
        }
    }

    Free(pDNSRecord);
    return fRetVal;
}

//
// The following are for dns DC entry check
//
BOOL ReadStringToDnsRecord(
              IN LPSTR lpstrString,
              OUT PDNS_RECORD pDNSRecord)

/*++

Routine Description:

   Parse a string and put the data into DNS record

Arguments:

  lpstrString - The input string, the format is:
                DnsName IN Type Data
  pDNSRecord - The result DNS record

Return Value:

  TRUE: if succeed. False otherwise

--*/
{
    BOOL bComments;
    LPSTR lpstrType,lpstrTemp;
    PCHAR  pchEnd;
    DWORD  dwTemp;
    LPCTSTR pszWhite = _T(" \t\n");

    // skip white spaces and comments lines
    // comments start with ;

    //
    // Initialize pDNSRecord
    //
    pDNSRecord->pNext = NULL;
// Commented out to port to Source Depot - smanda
#ifdef SLM_TREE
    pDNSRecord->Flags.S.Unicode = FALSE;
#endif
    pDNSRecord->dwTtl = 0;
    // name
    pDNSRecord->pName = strtok(lpstrString, pszWhite);
    if(!pDNSRecord->pName || pDNSRecord->pName[0] == _T(';'))
    {
        return ( FALSE );
    }

    // ttl: this is added since build 1631
    // we need to check which format the netlogon.dns is using

    lpstrTemp = strtok(NULL,pszWhite);
    if (lpstrTemp)
    {
       dwTemp = strtoul( lpstrTemp, &pchEnd, 10 );
       if ( (lpstrTemp != pchEnd) && (*pchEnd == '\0') )
       {
           pDNSRecord->dwTtl = dwTemp ;
           // skip the class IN
           strtok(NULL, pszWhite);
       }
    }

    // type
    lpstrType = strtok(NULL,pszWhite);

    if (lpstrType)
    {
       if (_stricmp(lpstrType,_T("A")) == 0)
       {
           pDNSRecord->wType = DNS_TYPE_A;
           pDNSRecord->wDataLength = sizeof( DNS_A_DATA );

           // IP address
           lpstrTemp = strtok(NULL,pszWhite);
           if (lpstrTemp)
              pDNSRecord->Data.A.IpAddress = inet_addr ( lpstrTemp );
       }
       else if (_stricmp(lpstrType,_T("SRV")) == 0)
       {

           pDNSRecord->wType = DNS_TYPE_SRV;
           pDNSRecord->wDataLength = sizeof( DNS_SRV_DATA );

           // wPriority
           lpstrTemp = strtok(NULL,pszWhite);
           if (lpstrTemp)
              pDNSRecord->Data.SRV.wPriority = (WORD) atoi ( lpstrTemp );
           // wWeight
           lpstrTemp = strtok(NULL,pszWhite);
           if (lpstrTemp)
              pDNSRecord->Data.SRV.wWeight = (WORD) atoi ( lpstrTemp );
           // wPort
           lpstrTemp = strtok(NULL,pszWhite);
           if (lpstrTemp)
              pDNSRecord->Data.SRV.wPort = (WORD) atoi ( lpstrTemp );
           // pNameTarget
           pDNSRecord->Data.SRV.pNameTarget = strtok(NULL,pszWhite);
       }
       else if (_stricmp(lpstrType,_T("CNAME")) == 0)
       {
           pDNSRecord->wType = DNS_TYPE_CNAME;
           pDNSRecord->wDataLength = sizeof( DNS_PTR_DATA );
           // name host
           pDNSRecord->Data.CNAME.pNameHost = strtok(NULL,pszWhite);
       }
    }

    return ( TRUE );
}

VOID PrintDNSError(
                   NETDIAG_PARAMS *pParams,
                   NETDIAG_RESULT *pResults,
                   IN DWORD status,
                                   NdVerbose ndv)
/*++

Routine Description:

   Print out error message

Arguments:

  status - error code

Return Value:

  none

--*/
{
    // IDS_DNS_12851                  "DNS Error code: "
    AddMessageToList(&pResults->Dns.lmsgOutput, ndv, IDS_DNS_12851);
    switch ( status ) {

    case ERROR_SUCCESS:
        // IDS_DNS_12852                  "ERROR_SUCCESS\n"
        AddMessageToList(&pResults->Dns.lmsgOutput, ndv, IDS_DNS_12852);
        break;
    case DNS_ERROR_RCODE_FORMAT_ERROR :
        // IDS_DNS_12853                  "DNS_ERROR_RCODE_FORMAT_ERROR\n"
        AddMessageToList(&pResults->Dns.lmsgOutput, ndv, IDS_DNS_12853);
        break;
    case DNS_ERROR_RCODE_SERVER_FAILURE :
        // IDS_DNS_12854                  "DNS_ERROR_RCODE_SERVER_FAILURE\n"
        AddMessageToList(&pResults->Dns.lmsgOutput, ndv, IDS_DNS_12854);
        break;
    case DNS_ERROR_RCODE_NAME_ERROR :
        // IDS_DNS_12855                  "DNS_ERROR_RCODE_NAME_ERROR (Name does not exist on DNS server)\n"
        AddMessageToList(&pResults->Dns.lmsgOutput, ndv, IDS_DNS_12855);
        break;
    case DNS_ERROR_RCODE_NOT_IMPLEMENTED :
        // IDS_DNS_12856                  "DNS_ERROR_RCODE_NOT_IMPLEMENTED\n"
        AddMessageToList(&pResults->Dns.lmsgOutput, ndv, IDS_DNS_12856);
        break;
    case DNS_ERROR_RCODE_REFUSED :
        // IDS_DNS_12857                  "DNS_ERROR_RCODE_REFUSED\n"
        AddMessageToList(&pResults->Dns.lmsgOutput, ndv, IDS_DNS_12857);
        break;
    case DNS_ERROR_RCODE_NOTAUTH :
        // IDS_DNS_12858                  "DNS_ERROR_RCODE_NOTAUTH\n"
        AddMessageToList(&pResults->Dns.lmsgOutput, ndv, IDS_DNS_12858);
        break;
    case DNS_ERROR_TRY_AGAIN_LATER :
        // IDS_DNS_12859                  "DNS_ERROR_TRY_AGAIN_LATER\n"
        AddMessageToList(&pResults->Dns.lmsgOutput, ndv, IDS_DNS_12859);
        break;
    case 0xcc000055 :
        // IDS_DNS_12860                  "DNS_ERROR_NOT_UNIQUE\n"
        AddMessageToList(&pResults->Dns.lmsgOutput, ndv, IDS_DNS_12860);
        break;
    case 0x5b4:
        // IDS_DNS_12861                  "ERROR_TIMEOUT (Dns server may be down!)\n"
        AddMessageToList(&pResults->Dns.lmsgOutput, ndv, IDS_DNS_12861);
        break;
    case 0x4c000030:
        // IDS_DNS_12862                  "DNS_INFO_NO_RECORDS\n"
        AddMessageToList(&pResults->Dns.lmsgOutput, ndv, IDS_DNS_12862 );
        break;
    default:
        // IDS_DNS_12863                  "0x%.8X\n"
        AddMessageToList(&pResults->Dns.lmsgOutput, ndv, IDS_DNS_12863,status);
    }
}


/*
VOID
PrintARecord (
              IN NETDIAG_PARAMS *pParams,
              IN  PDNS_RECORD pDnsRecord )
{
//IDS_DNS_12864                  "            A  %d.%d.%d.%d\n"
    PrintMessage(pParams,  IDS_DNS_12864,
            ((BYTE *) &pDnsRecord->Data.A.IpAddress)[0],
            ((BYTE *) &pDnsRecord->Data.A.IpAddress)[1],
            ((BYTE *) &pDnsRecord->Data.A.IpAddress)[2],
            ((BYTE *) &pDnsRecord->Data.A.IpAddress)[3] );
}

VOID
PrintSRVRecord (
                IN NETDIAG_PARAMS *pParams,
                IN  PDNS_RECORD pDnsRecord )
{
//IDS_DNS_12865                  "            SRV "
    PrintMessage(pParams,  IDS_DNS_12865 );

//IDS_DNS_12866                  "%d %d %d %s \n"
    PrintMessage(pParams,  IDS_DNS_12866,
            pDnsRecord->Data.SRV.wPriority,
            pDnsRecord->Data.SRV.wWeight,
            pDnsRecord->Data.SRV.wPort,
            pDnsRecord->Data.SRV.pNameTarget );
}

VOID
PrintCNAMERecord (
                  IN NETDIAG_PARAMS *pParams,
                  IN  PDNS_RECORD pDnsRecord )
{
//IDS_DNS_12867                  "            CNAME %s \n"
    PrintMessage(pParams,  IDS_DNS_12867,
            pDnsRecord->Data.CNAME.pNameHost);
}
*/

VOID
PrintRecord (
             IN NETDIAG_PARAMS *pParams,
             IN NETDIAG_RESULT *pResults,
             IN  PDNS_RECORD pDnsRecord,
                         IN NdVerbose ndv)
{
    PDNS_RECORD pCur;

    if (pDnsRecord==NULL)
        return;
    //IDS_DNS_12868                  "DNS NAME = %s\n"
    AddMessageToList(&pResults->Dns.lmsgOutput, ndv, IDS_DNS_12868, UTF8ToAnsi(pDnsRecord->pName));
    //IDS_DNS_12869                  "DNS DATA = \n"
    AddMessageToList(&pResults->Dns.lmsgOutput, ndv, IDS_DNS_12869);
    pCur = pDnsRecord;
    while ( pCur )
    {
        switch( pCur->wType ){
        case DNS_TYPE_A :
            //IDS_DNS_12864                  "            A  %d.%d.%d.%d\n"
            AddMessageToList(&pResults->Dns.lmsgOutput, ndv, IDS_DNS_12864,
                ((BYTE *) &pDnsRecord->Data.A.IpAddress)[0],
                ((BYTE *) &pCur->Data.A.IpAddress)[1],
                ((BYTE *) &pCur->Data.A.IpAddress)[2],
                ((BYTE *) &pCur->Data.A.IpAddress)[3] );
            break;
         case DNS_TYPE_SRV :
            //IDS_DNS_12865                  "            SRV "
            AddMessageToList(&pResults->Dns.lmsgOutput, ndv, IDS_DNS_12865 );

            //IDS_DNS_12866                  "%d %d %d %s \n"
            AddMessageToList(&pResults->Dns.lmsgOutput, ndv, IDS_DNS_12866,
                    pCur->Data.SRV.wPriority,
                    pCur->Data.SRV.wWeight,
                    pCur->Data.SRV.wPort,
                    pCur->Data.SRV.pNameTarget );
            break;
         case DNS_TYPE_CNAME :
            //IDS_DNS_12867                  "            CNAME %s \n"
            AddMessageToList(&pResults->Dns.lmsgOutput, ndv, IDS_DNS_12867,
                    UTF8ToAnsi(pCur->Data.CNAME.pNameHost));
            break;
         default :
             // IDS_DNS_12870  "Don't know how to print record type %d\n"
            AddMessageToList(&pResults->Dns.lmsgOutput, ndv, IDS_DNS_12870,
                    pCur->wType);
        }
        pCur = pCur->pNext;
    }
}


/*!--------------------------------------------------------------------------
    DnsGlobalPrint
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void DnsGlobalPrint( NETDIAG_PARAMS* pParams,
                          NETDIAG_RESULT*  pResults)
{
    if (!pResults->IpConfig.fEnabled)
        return;

    if (pParams->fVerbose || !FHrOK(pResults->Dns.hr) || pResults->Dns.fOutput)
    {
        PrintNewLine(pParams, 2);
        PrintTestTitleResult(pParams, IDS_DNS_LONG, IDS_DNS_SHORT, TRUE, pResults->Dns.hr, 0);
        PrintMessageList(pParams, &pResults->Dns.lmsgOutput);
    }
}

/*!--------------------------------------------------------------------------
    DnsPerInterfacePrint
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void DnsPerInterfacePrint( NETDIAG_PARAMS* pParams,
                                NETDIAG_RESULT*  pResults,
                                INTERFACE_RESULT *pInterfaceResults)
{
/*    BOOL    fVerboseT;
    BOOL    fReallyVerboseT;

    if (!pResults->IpConfig.fEnabled)
        return;

    if (!pInterfaceResults->IpConfig.fActive)
        return;

    if (pParams->fVerbose || pInterfaceResults->Dns.fOutput)
    {
        fVerboseT = pParams->fVerbose;
        fReallyVerboseT = pParams->fReallyVerbose;
        pParams->fReallyVerbose = TRUE;

        PrintNewLine(pParams, 1);
//IDS_DNS_12871                  "        DNS test results :\n"
        PrintMessage(pParams, IDS_DNS_12871);
        PrintMessageList(pParams, &pInterfaceResults->Dns.lmsgOutput);

        pParams->fReallyVerbose = fReallyVerboseT;
        pParams->fVerbose = fVerboseT;
    }
    */
    return;
}


/*!--------------------------------------------------------------------------
    DnsCleanup
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void DnsCleanup( NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
{
    int     i;

    MessageListCleanUp(&pResults->Dns.lmsgOutput);

    for ( i=0; i<pResults->cNumInterfaces; i++)
    {
        MessageListCleanUp(&pResults->pArrayInterface[i].Dns.lmsgOutput);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\dnscmn.c ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    dnscmn.c

Abstract:

    Domain Name System (DNS) Client
    Routines used to verify the DNS registration for a client

Author:

    Elena Apreutesei (elenaap) 10/22/98

Revision History:

--*/


#include "precomp.h"
#include "dnscmn.h"
#include <malloc.h>


LPSTR
UTF8ToAnsi(
    LPSTR szuStr
    )
{
    WCHAR wszBuff[2048];
    static char aszBuff[2048];
    strcpy(aszBuff, "");

    if (NULL == szuStr)
            return aszBuff;

    if ( MultiByteToWideChar(
                CP_UTF8,
                0L,
                szuStr,
                -1,
                wszBuff,
                DimensionOf(wszBuff)
                ))
    {
            WideCharToMultiByte(
                    CP_ACP,
                    0L,
                    wszBuff,
                    -1,
                    aszBuff,
                    DimensionOf(aszBuff),
                    NULL,
                    NULL);
    }
    
    return aszBuff;
}


HRESULT
CheckDnsRegistration(
    PDNS_NETINFO        pNetworkInfo,
    NETDIAG_PARAMS*     pParams,
    NETDIAG_RESULT*     pResults
    )
{
    LPSTR       pszHostName = NULL;
    LPSTR       pszPrimaryDomain = NULL;
    LPSTR       pszDomain = NULL;
    DWORD       dwServerIP, dwIP;
    int         idx, idx1, idx2;
    BOOL        RegDnOk, RegPdnOk, RegDnAll, RegPdnAll;
    char        szName[DNS_MAX_NAME_BUFFER_LENGTH];
    char        szIP[1500];
    DNS_RECORD  recordA[MAX_ADDRS];
    DNS_RECORD  recordPTR;
    DNS_STATUS  dwStatus;
    PREGISTRATION_INFO pExpectedRegistration = NULL;
    HRESULT     hResult = hrOK;

    // print out DNS settings
    pszHostName = (PSTR) DnsQueryConfigAlloc(
                            DnsConfigHostName_UTF8,
                            NULL );
    if (NULL == pszHostName)
    {
        //IDS_DNS_NO_HOSTNAME              "    [FATAL] Cannot find DNS host name."
        AddMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, IDS_DNS_NO_HOSTNAME);
        hResult = S_FALSE;
        goto L_ERROR;
    }

    pszPrimaryDomain = (PSTR) DnsQueryConfigAlloc(
                                DnsConfigPrimaryDomainName_UTF8,
                                NULL );
    
    // compute the expected DNS registration
    dwStatus = ComputeExpectedRegistration(
                    pszHostName,
                    pszPrimaryDomain,
                    pNetworkInfo,
                    &pExpectedRegistration,
                    pParams, 
                    pResults);

    // verifies the DNS registration
    if (pExpectedRegistration)
        hResult = VerifyDnsRegistration(
                    pszHostName, 
                    pExpectedRegistration, 
                    pParams, 
                    pResults);

L_ERROR:
    return hResult;
}


DNS_STATUS
ComputeExpectedRegistration(
    LPSTR               pszHostName,
    LPSTR               pszPrimaryDomain,
    PDNS_NETINFO        pNetworkInfo,
    PREGISTRATION_INFO  *ppExpectedRegistration,
    NETDIAG_PARAMS*     pParams, 
    NETDIAG_RESULT*     pResults
    )
{
    DWORD           idx;
    DWORD           idx1;
    DNS_STATUS      dwStatus;
    char            szName[DNS_MAX_NAME_BUFFER_LENGTH];
    PDNS_NETINFO    pFazResult = NULL;
    LPSTR           pszDomain;
    DWORD           dwIP;
    PIP_ARRAY       pDnsServers = NULL;
    PIP_ARRAY       pNameServers = NULL;
    PIP_ARRAY       pNS = NULL;
    IP_ARRAY        PrimaryDNS; 
    LPWSTR          pwAdapterGuidName = NULL;
    BOOL            bRegEnabled = FALSE;
    BOOL            bAdapterRegEnabled = FALSE;


    *ppExpectedRegistration = NULL;

    for (idx = 0; idx < pNetworkInfo->cAdapterCount; idx++)
    {
//IDS_DNS_12878                  "      Interface %s\n" 
        AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12878, (pNetworkInfo->AdapterArray[idx])->pszAdapterGuidName);
        pszDomain = (pNetworkInfo->AdapterArray[idx])->pszAdapterDomain;
//IDS_DNS_12879                  "        DNS Domain: %s\n" 
        AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12879, UTF8ToAnsi(pszDomain));
//IDS_DNS_12880                  "        DNS Servers: " 
        AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12880);
        for (idx1 = 0; idx1 < (pNetworkInfo->AdapterArray[idx])->cServerCount; idx1++)
        {
            dwIP = (pNetworkInfo->AdapterArray[idx])->ServerArray[idx1].IpAddress;
//IDS_DNS_12881                  "%s " 
            AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12881, IP_STRING(dwIP));
        }
//IDS_DNS_12882                  "\n        IP Address: " 
        AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12882);
        for(idx1 = 0; idx1 < (pNetworkInfo->AdapterArray[idx])->pAdapterIPAddresses->AddrCount; idx1++)
        {
            dwIP = (pNetworkInfo->AdapterArray[idx])->pAdapterIPAddresses->AddrArray[idx1];
//IDS_DNS_12883                  "%s " 
            AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12883, IP_STRING(dwIP));
        }
//IDS_DNS_12884                  "\n" 
       AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12884);

        pDnsServers = ServerInfoToIpArray(
                                (pNetworkInfo->AdapterArray[idx])->cServerCount,
                                (pNetworkInfo->AdapterArray[idx])->ServerArray
                                );

        //
        // Verify if DNS registration is enabled for interface and for adapter's DNS domain name
        //
        bRegEnabled = bAdapterRegEnabled = FALSE;
        pwAdapterGuidName = LocalAlloc(LPTR, sizeof(WCHAR)*(1+strlen((pNetworkInfo->AdapterArray[idx])->pszAdapterGuidName)));
        if (pwAdapterGuidName)
        {
                    MultiByteToWideChar(
                          CP_ACP,
                          0L,  
                          (pNetworkInfo->AdapterArray[idx])->pszAdapterGuidName,  
                          -1,         
                          pwAdapterGuidName, 
                          sizeof(WCHAR)*(1+strlen((pNetworkInfo->AdapterArray[idx])->pszAdapterGuidName)) 
                          );
                    bRegEnabled = (BOOL) DnsQueryConfigDword(
                                            DnsConfigRegistrationEnabled,
                                            pwAdapterGuidName );

                    bAdapterRegEnabled = (BOOL) DnsQueryConfigDword(
                                            DnsConfigAdapterHostNameRegistrationEnabled,
                                            pwAdapterGuidName );
                    LocalFree(pwAdapterGuidName);
        }
        if(bRegEnabled)
        {
            if(pDnsServers)
            {
                // compute expected registration with PDN
                if (pszPrimaryDomain && strlen(pszPrimaryDomain))
                {
                    sprintf(szName, "%s.%s.", pszHostName, pszPrimaryDomain);
    //IDS_DNS_12886                  "        Expected registration with PDN (primary DNS domain name):\n           Hostname: %s\n" 
                    AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12886, UTF8ToAnsi(szName));
                    pFazResult = NULL;
                    pNameServers = NULL;
                    dwStatus = DnsFindAllPrimariesAndSecondaries(
                                szName,
                                DNS_QUERY_BYPASS_CACHE,
                                pDnsServers,
                                &pFazResult,
                                &pNameServers,
                                NULL);

                    if (pFazResult)
                    {
    //IDS_DNS_12887                  "          Authoritative zone: %s\n" 
                        AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12887,
UTF8ToAnsi(pFazResult->pSearchList->pszDomainOrZoneName));
    //IDS_DNS_12888                  "          Primary DNS server: %s %s\n" 
                        AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12888, UTF8ToAnsi(pFazResult->AdapterArray[0]->pszAdapterDomain),
                                        IP_STRING(pFazResult->AdapterArray[0]->ServerArray[0].IpAddress));
                        if (pNameServers)
                        {
    //IDS_DNS_12889                  "          Authoritative NS:" 
                            AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12889);
                            for(idx1=0; idx1 < pNameServers->AddrCount; idx1++)
    //IDS_DNS_12890              "%s " 
                                AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12890,
IP_STRING(pNameServers->AddrArray[idx1]));
    //IDS_DNS_12891              "\n" 
                            AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12891);
                            pNS = pNameServers;                
                        }
                        else
                        {
    //IDS_DNS_12892                  "          NS query failed with %d %s\n" 
                            AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12892, dwStatus, DnsStatusString(dwStatus));
                            PrimaryDNS.AddrCount = 1;
                            PrimaryDNS.AddrArray[0] = pFazResult->AdapterArray[0]->ServerArray[0].IpAddress;
                            pNS = &PrimaryDNS;
                        }
                        dwStatus = DnsUpdateAllowedTest_UTF8(
                                    NULL,
                                    szName,
                                    pFazResult->pSearchList->pszDomainOrZoneName,
                                    pNS);
                        if ((dwStatus == NO_ERROR) || (dwStatus == ERROR_TIMEOUT))
                            AddToExpectedRegistration(
                                pszPrimaryDomain,
                                (pNetworkInfo->AdapterArray[idx]),
                                pFazResult, 
                                pNS,
                                ppExpectedRegistration);
                        else
    //IDS_DNS_12893                  "          Update is not allowed in zone %s.\n" 
                            AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12893, UTF8ToAnsi(pFazResult->pSearchList->pszDomainOrZoneName));
                    }
                    else
                    {
    //IDS_DNS_12894                  "          [WARNING] Cannot find the authoritative server for the DNS name '%s'. [%s]\n                    The name '%s' may not be registered properly on the DNS servers.\n"
                        AddMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, IDS_DNS_12894, UTF8ToAnsi(szName), DnsStatusString(dwStatus), UTF8ToAnsi(szName));
                    }
                }

                // compute expected registration with DN for this adapter
                if (pszDomain && strlen(pszDomain) && 
                   (!pszPrimaryDomain || !strlen(pszPrimaryDomain) || 
                   (pszPrimaryDomain && pszDomain && _stricmp(pszDomain, pszPrimaryDomain))))
                { 
                    sprintf(szName, "%s.%s." , pszHostName, pszDomain);
        //IDS_DNS_12896                  "        Expected registration with adapter's DNS Domain Name:\n             Hostname: %s\n" 
                    AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12896, UTF8ToAnsi(szName));
                
                    if (bAdapterRegEnabled)
                    {
                        
                        pFazResult = NULL;
                        pNameServers = NULL;
                        dwStatus = DnsFindAllPrimariesAndSecondaries(
                                    szName,
                                    DNS_QUERY_BYPASS_CACHE,
                                    pDnsServers,
                                    &pFazResult,
                                    &pNameServers,
                                    NULL);
                        if (pFazResult)
                        {
        //IDS_DNS_12897                  "          Authoritative zone: %s\n" 
                            AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12897, UTF8ToAnsi(pFazResult->pSearchList->pszDomainOrZoneName));
        //IDS_DNS_12898                  "          Primary DNS server: %s %s\n" 
                            AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12898, UTF8ToAnsi(pFazResult->AdapterArray[0]->pszAdapterDomain),
                                            IP_STRING(pFazResult->AdapterArray[0]->ServerArray[0].IpAddress));
                            if (pNameServers)
                            {
        //IDS_DNS_12899                  "          Authoritative NS:" 
                                AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12899);
                                for(idx1=0; idx1 < pNameServers->AddrCount; idx1++)
        //IDS_DNS_12900                  "%s " 
                                    AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12900,
IP_STRING(pNameServers->AddrArray[idx1]));
        //IDS_DNS_12901                  "\n" 
                                AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12901);
                                pNS = pNameServers;                
                            }
                            else
                            {
        //IDS_DNS_12902                  "          NS query failed with %d %s\n" 
                                AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12902, dwStatus, DnsStatusString(dwStatus));
                                PrimaryDNS.AddrCount = 1;
                                PrimaryDNS.AddrArray[0] = pFazResult->AdapterArray[0]->ServerArray[0].IpAddress;
                                pNS = &PrimaryDNS;
                            }

                            dwStatus = DnsUpdateAllowedTest_UTF8(
                                        NULL,
                                        szName,
                                        pFazResult->pSearchList->pszDomainOrZoneName,
                                        pNS);
                            if ((dwStatus == NO_ERROR) || (dwStatus == ERROR_TIMEOUT))
                                AddToExpectedRegistration(
                                    pszDomain,
                                    (pNetworkInfo->AdapterArray[idx]),
                                    pFazResult, 
                                    pNS,
                                    ppExpectedRegistration);
                            else
        //IDS_DNS_12903                  "          Update is not allowed in zone %s\n" 
                                AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12903, UTF8ToAnsi(pFazResult->pSearchList->pszDomainOrZoneName));
                        }
                        else
                        {
        //IDS_DNS_12894                  "          [WARNING] Cannot find the authoritative server for the DNS name '%s'. [%s]\n                    The name '%s' may not be registered properly on the DNS servers.\n"
                            AddMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, IDS_DNS_12894, UTF8ToAnsi(szName), DnsStatusString(dwStatus), UTF8ToAnsi(szName));
                        }

                    }
                    else
                    {
                        AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12939);
                    }
                }

                LocalFree(pDnsServers);
            }
        }
        else // if(bRegEnabled)
        {
            AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12947);
        }
    }
    return NO_ERROR;
}

void
AddToExpectedRegistration(
    LPSTR               pszDomain,
    PDNS_ADAPTER        pAdapterInfo,
    PDNS_NETINFO        pFazResult, 
    PIP_ARRAY           pNS,
    PREGISTRATION_INFO *ppExpectedRegistration)
{
    PREGISTRATION_INFO pCurrent = *ppExpectedRegistration, pNew = NULL, pLast = NULL;
    BOOL        done = FALSE, found = FALSE;
    DWORD       i,j;
    IP_ARRAY    ipArray;
    DWORD       dwAddrToRegister;
    DWORD       dwMaxAddrToRegister;

    USES_CONVERSION;

    dwMaxAddrToRegister = DnsQueryConfigDword(
                                DnsConfigAddressRegistrationMaxCount,
                                A2W(pAdapterInfo->pszAdapterGuidName ));

    dwAddrToRegister = (pAdapterInfo->pAdapterIPAddresses->AddrCount < dwMaxAddrToRegister) ?
                               pAdapterInfo->pAdapterIPAddresses->AddrCount : dwMaxAddrToRegister;

    while(pCurrent)
    {
        if(!done &&
           !_stricmp(pCurrent->szDomainName, pszDomain) && 
           !_stricmp(pCurrent->szAuthoritativeZone, pFazResult->pSearchList->pszDomainOrZoneName) &&
           SameAuthoritativeServers(pCurrent, pNS))
        {
           // found a node under the same domain name / authoritative server list
           done = TRUE;
           if(pCurrent->dwIPCount + pAdapterInfo->pAdapterIPAddresses->AddrCount > MAX_ADDRS)
           {
//IDS_DNS_12905                  "   WARNING - more than %d IP addresses\n" 
//               AddMessageToList(&pResults->Dns.lmsgOutput, Nd_Verbose, IDS_DNS_12905, MAX_ADDRS);
               return;
           }

           // add the new IPs
           for(i=0; i < dwAddrToRegister; i++)
           {
                pCurrent->IPAddresses[pCurrent->dwIPCount + i] = pAdapterInfo->pAdapterIPAddresses->AddrArray[i];
           }
           pCurrent->dwIPCount += dwAddrToRegister;
           
           // for each NS check if it's already in the list, if not add it
           for(i=0; i < pNS->AddrCount; i++)
           {
                found = FALSE;
                for(j=0; !found && (j < pCurrent->dwAuthNSCount); j++)
                    if(pNS->AddrArray[i] == pCurrent->AuthoritativeNS[j])
                        found = TRUE;
                if (!found && pCurrent->dwAuthNSCount < MAX_NAME_SERVER_COUNT)
                    pCurrent->AuthoritativeNS[pCurrent->dwAuthNSCount++] = pNS->AddrArray[i];
           }

           // check if DNS servers allow updates
           if (pCurrent->AllowUpdates == ERROR_TIMEOUT)
           {
               ipArray.AddrCount = 1;
               ipArray.AddrArray[0] = pFazResult->AdapterArray[0]->ServerArray[0].IpAddress;
               pCurrent->AllowUpdates = DnsUpdateTest_UTF8(
                                            NULL,       // Context handle
                                            pCurrent->szAuthoritativeZone, 
                                            0,          //DNS_UPDATE_TEST_USE_LOCAL_SYS_ACCT,
                                            &ipArray);  // use the DNS server returned from FAZ
           }
        }
        pLast = pCurrent;
        pCurrent = pCurrent->pNext;
    }

    if (!done)
    {
        // need to allocate new entry
        pNew = LocalAlloc(LMEM_FIXED, sizeof(REGISTRATION_INFO));
        if( !pNew)
            return;
        pNew->pNext = NULL;
        strcpy(pNew->szDomainName, pszDomain);
        strcpy(pNew->szAuthoritativeZone, pFazResult->pSearchList->pszDomainOrZoneName);
        pNew->dwIPCount = 0;
        for(i=0; i < dwAddrToRegister; i++)
        {
           if(pNew->dwIPCount < MAX_ADDRS)
               pNew->IPAddresses[pNew->dwIPCount++] = pAdapterInfo->pAdapterIPAddresses->AddrArray[i];
           else
           {
//IDS_DNS_12905                  "   WARNING - more than %d IP addresses\n" 
//               AddMessageToList(&pResults->Dns.lmsgOutput, Nd_Verbose, IDS_DNS_12905, MAX_ADDRS);
               break;
           }
        }

        pNew->dwAuthNSCount = 0;
        for(i=0; i < pNS->AddrCount; i++)
        {
           if (pNew->dwAuthNSCount < MAX_NAME_SERVER_COUNT)
               pNew->AuthoritativeNS[pNew->dwAuthNSCount++] = pNS->AddrArray[i];
           else
               break;
        }
        
        // check if DNS servers allow updates
        ipArray.AddrCount = 1;
        ipArray.AddrArray[0] = pFazResult->AdapterArray[0]->ServerArray[0].IpAddress;
        pNew->AllowUpdates = DnsUpdateTest_UTF8(
                                          NULL,    // Context handle
                                          pNew->szAuthoritativeZone, 
                                          0, //DNS_UPDATE_TEST_USE_LOCAL_SYS_ACCT,
                                          &ipArray);  // use the DNS server returned from FAZ

        if(pLast)
            pLast->pNext = (LPVOID)pNew;
        else
            *ppExpectedRegistration = pNew;
    }
}

BOOL
SameAuthoritativeServers(PREGISTRATION_INFO pCurrent, PIP_ARRAY pNS)
{
    BOOL same = FALSE, found = FALSE;
    DWORD i, j;

    for (i=0; i<pCurrent->dwAuthNSCount; i++)
    {
        found = FALSE;
        for (j=0; j<pNS->AddrCount; j++)
            if(pNS->AddrArray[j] == pCurrent->AuthoritativeNS[i])
                found = TRUE;
        if (found)
            same = TRUE;
    }

    return same;
}

HRESULT VerifyDnsRegistration(LPSTR pszHostName, PREGISTRATION_INFO pExpectedRegistration,NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults )
{
    PREGISTRATION_INFO pCurrent = pExpectedRegistration;
    BOOL regOne, regAll, partialMatch;
    DWORD i,j, numOfMissingAddr;
    DNS_STATUS dwStatus;
    PDNS_RECORD pExpected=NULL, pResult=NULL, pDiff1=NULL, pDiff2=NULL, pThis = NULL;
    char szFqdn[DNS_MAX_NAME_BUFFER_LENGTH];
    IP_ARRAY DnsServer;
    HRESULT         hr = hrOK;


//IDS_DNS_12906                  "      Verify DNS registration:\n" 
    AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12906);
    DnsServer.AddrCount = 1;
    while(pCurrent)
    {
        regOne = FALSE; regAll = TRUE;
        partialMatch = FALSE;
        numOfMissingAddr = 0;
        sprintf(szFqdn, "%s.%s" , pszHostName, pCurrent->szDomainName);
//IDS_DNS_12908                  "        Name: %s\n" 
        AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12908, UTF8ToAnsi(szFqdn));
        
        // build the expected RRset
        pExpected = LocalAlloc(LMEM_FIXED, pCurrent->dwIPCount * sizeof(DNS_RECORD));
        if(!pExpected)
        {
//IDS_DNS_12909                  "        LocalAlloc() failed, exit verify\n" 
            AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12909);
            return S_FALSE;
        }
        memset(pExpected, 0, pCurrent->dwIPCount * sizeof(DNS_RECORD));
//IDS_DNS_12910                  "        Expected IP: " 
        AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12910);
        for (j=0; j<pCurrent->dwIPCount; j++)
        {
            pExpected[j].pName = szFqdn;
            pExpected[j].wType = DNS_TYPE_A;
            pExpected[j].wDataLength = sizeof(DNS_A_DATA);
            pExpected[j].Data.A.IpAddress = pCurrent->IPAddresses[j];
            pExpected[j].pNext = (j < (pCurrent->dwIPCount - 1))?(&pExpected[j+1]):NULL;
            pExpected[j].Flags.S.Section = DNSREC_ANSWER;
//IDS_DNS_12911                  "%s " 
            AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12911, IP_STRING(pCurrent->IPAddresses[j]));
        }
//IDS_DNS_12912                  "\n" 
        AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12912);

        // verify on each server
        for (i=0; i < pCurrent->dwAuthNSCount; i++)
        {
            DnsServer.AddrArray[0] = pCurrent->AuthoritativeNS[i];
/*
            //
            // Ping the DNS server.
            //
            IpAddressString = inet_ntoa(inetDnsServer.AddrArray[0]);
            if ( IpAddressString )
                if (!IsIcmpResponseA( IpAddressString )
                {
                    PrintStatusMessage(pParams, 12, IDS_DNS_CANNOT_PING, IpAddressString);

                    pIfResults->Dns.fOutput = TRUE;
                    AddIMessageToList(&pIfResults->Dns.lmsgOutput, Nd_Quiet, 16,
                                      IDS_DNS_CANNOT_PING, IpAddressString);
                    RetVal = FALSE;
                    goto Cleanup;
                }
*/
            pDiff1 = pDiff2 = NULL;
            dwStatus = DnsQueryAndCompare(
                            szFqdn,
                            DNS_TYPE_A,
                            DNS_QUERY_DATABASE,
                            &DnsServer,
                            &pResult,
                            NULL,   // don't want the full DNS message
                            pExpected,
                            FALSE,
                            FALSE,
                            &pDiff1,
                            &pDiff2
                            );
            if(dwStatus != NO_ERROR)
            {
                if (dwStatus == ERROR_NO_MATCH)
                {
//IDS_DNS_12913                  "          Server %s: ERROR_NO_MATCH\n" 
                    AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12913,
IP_STRING(DnsServer.AddrArray[0]));
                    if(pDiff2)
                    {
//IDS_DNS_12914                  "            Missing IP from DNS: " 
                            AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12914);
                            for (pThis = pDiff2; pThis; pThis = pThis->pNext, numOfMissingAddr++)
//IDS_DNS_12915                  "%s " 
                                AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12915, IP_STRING (pThis->Data.A.IpAddress));
//IDS_DNS_12916                  "\n" 
                            AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12916);
                            if (numOfMissingAddr != pCurrent->dwIPCount)
                               partialMatch = TRUE;
                    }
                    if(pDiff1)
                    {
//IDS_DNS_12917                  "            Wrong IP in DNS: " 
                            AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12917);
                            for (pThis = pDiff1; pThis; pThis = pThis->pNext)
//IDS_DNS_12918                  "%s " 
                                AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12918, IP_STRING (pThis->Data.A.IpAddress));
//IDS_DNS_12919                  "\n" 
                            AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12919);
                    }
                }
                else
//IDS_DNS_12920                  "          Server %s: Error %d %s\n" 
                    AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12920,
IP_STRING(DnsServer.AddrArray[0]), dwStatus, DnsStatusToErrorString_A(dwStatus));
                if ( dwStatus != ERROR_TIMEOUT )
                    regAll = FALSE;
            }
            else
            {
//IDS_DNS_12921                  "          Server %s: NO_ERROR\n" 
                AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12921,
IP_STRING(DnsServer.AddrArray[0]));
                regOne = TRUE;
            }
        }
        if (regOne && !regAll)
//IDS_DNS_12922                  "          WARNING: The DNS registration is correct only on some DNS servers, pls. wait 15 min for replication and try this test again\n" 
        {
            PrintStatusMessage(pParams, 0,  IDS_DNS_12922, UTF8ToAnsi(szFqdn));
            pResults->Dns.fOutput = TRUE;
            AddIMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, 4,
                                IDS_DNS_12922, UTF8ToAnsi(szFqdn));


        }
        if (!regOne && !regAll && !partialMatch)
//IDS_DNS_12923                  "          FATAL: The DNS registration is incorrect on all DNS servers.\n" 
        {
            PrintStatusMessage(pParams, 0,  IDS_DNS_12923, UTF8ToAnsi(szFqdn));
            pResults->Dns.fOutput = TRUE;
            AddIMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, 4,
                                IDS_DNS_12923, UTF8ToAnsi(szFqdn));
            hr = S_FALSE;
        }

        if (!regOne && !regAll && partialMatch)
//IDS_DNS_12951                  "       [WARNING] Not all DNS registrations for %s is correct on all DNS Servers.  Please run netdiag /v /test:dns for more detail. \n"
        {
            PrintStatusMessage(pParams, 0,  IDS_DNS_12951, UTF8ToAnsi(szFqdn));
            pResults->Dns.fOutput = TRUE;
            AddIMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, 4,
                                IDS_DNS_12951, UTF8ToAnsi(szFqdn));
            hr = S_FALSE;
        }

        if (!regOne && regAll)
//IDS_DNS_12924                  "          FATAL: All DNS servers are currently down.\n" 
        {
            PrintStatusMessage(pParams, 0,  IDS_DNS_12924, UTF8ToAnsi(szFqdn));
            pResults->Dns.fOutput = TRUE;
            AddIMessageToList(&pResults->Dns.lmsgOutput, Nd_Quiet, 4,
                                IDS_DNS_12924, UTF8ToAnsi(szFqdn));


            hr = S_FALSE;
        }

        if (regOne && regAll)
        {
            PrintStatusMessage(pParams, 6,  IDS_DNS_12940, UTF8ToAnsi(szFqdn));
            AddIMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, 0,
                                IDS_DNS_12940, UTF8ToAnsi(szFqdn));


        }

        pCurrent = pCurrent->pNext;
    }
    return hr;
}


PIP_ARRAY
ServerInfoToIpArray(
    DWORD               cServerCount,
    PDNS_SERVER_INFO    ServerArray
    )
{
    PIP_ARRAY   pipDnsServers = NULL;
    DWORD       i;

    pipDnsServers = LocalAlloc(LMEM_FIXED, IP_ARRAY_SIZE(cServerCount));
    if (!pipDnsServers)
        return NULL;
    
    pipDnsServers->AddrCount = cServerCount;
    for(i=0; i < cServerCount; i++)
        pipDnsServers->AddrArray[i] = ServerArray[i].IpAddress;
    
    return pipDnsServers;
}


DNS_STATUS
DnsFindAllPrimariesAndSecondaries(
    IN      LPSTR           pszName,
    IN      DWORD           dwFlags,
    IN      PIP_ARRAY       aipQueryServers,
    OUT     PDNS_NETINFO *  ppNetworkInfo,
    OUT     PIP_ARRAY *     ppNameServers,
    OUT     PIP_ARRAY *     ppPrimaries
    )
{
    DNS_STATUS          dwStatus;
    PDNS_RECORD         pDnsRecord = NULL;
    PIP_ARRAY           pDnsServers = NULL;
    DWORD               i;

    //
    // check arguments
    //
    if (!pszName || !ppNetworkInfo || !ppNameServers)
        return ERROR_INVALID_PARAMETER;

    *ppNameServers = NULL;
    *ppNetworkInfo = NULL;

    //
    // FAZ First
    //
    dwStatus = DnsFindAuthoritativeZone(
                pszName,
                dwFlags,
                aipQueryServers,
                ppNetworkInfo);

    //
    // Check error cases
    //
    if (dwStatus != NO_ERROR)
        return dwStatus;

    if ( !Dns_IsUpdateNetworkInfo(*ppNetworkInfo))
    {
        if ( *ppNetworkInfo )
        {
            DnsFreeConfigStructure(
                *ppNetworkInfo,
                DnsConfigNetInfo );
        }
        *ppNetworkInfo = NULL;
        return DNS_ERROR_RCODE_SERVER_FAILURE;
    }
    
    //
    // Get all NS records for the Authoritative Domain Name
    //

    pDnsServers = ServerInfoToIpArray(
                                ((*ppNetworkInfo)->AdapterArray[0])->cServerCount,
                                ((*ppNetworkInfo)->AdapterArray[0])->ServerArray
                                );
    dwStatus = DnsQuery_UTF8(
                    (*ppNetworkInfo)->pSearchList->pszDomainOrZoneName, 
                    DNS_TYPE_NS,
                    DNS_QUERY_BYPASS_CACHE,
                    aipQueryServers,
                    &pDnsRecord,
                    NULL);

    if (dwStatus != NO_ERROR)
        return dwStatus;

    *ppNameServers = GrabNameServersIp(pDnsRecord);

    //
    // select primaries
    //
    if (ppPrimaries)
    {
        *ppPrimaries = NULL;
        if (*ppNameServers)
        {
            *ppPrimaries = LocalAlloc(LPTR, IP_ARRAY_SIZE((*ppNameServers)->AddrCount));
            if(*ppPrimaries)
            {
                (*ppPrimaries)->AddrCount = 0;
                for (i=0; i<(*ppNameServers)->AddrCount; i++)
                    if(NO_ERROR == IsDnsServerPrimaryForZone_UTF8(
                                        (*ppNameServers)->AddrArray[i], 
                                        pszName))
                    {
                        (*ppPrimaries)->AddrArray[(*ppPrimaries)->AddrCount] = (*ppNameServers)->AddrArray[i];
                        ((*ppPrimaries)->AddrCount)++;
                    }
            }
        }
    }

    return dwStatus;
    
}

/*
void
CompareCachedAndRegistryNetworkInfo(PDNS_NETINFO      pNetworkInfo)
{
    DNS_STATUS              dwStatus1, dwStatus2;
    PDNS_RPC_ADAPTER_INFO   pRpcAdapterInfo = NULL, pCurrentCache;
    PDNS_RPC_SERVER_INFO    pRpcServer = NULL;
    PDNS_ADAPTER            pCurrentRegistry;
    PDNS_IP_ADDR_LIST       pIpList = NULL;
    BOOL                    cacheOk = TRUE, sameServers = TRUE, serverFound = FALSE;
    DWORD                   iCurrentAdapter, iServer, count = 0;

    dwStatus1 = GetCachedAdapterInfo( &pRpcAdapterInfo );
    dwStatus2 = GetCachedIpAddressList( &pIpList );

//IDS_DNS_12925                  "\nCheck DNS cached network info: \n" 
    AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12925);
    if(dwStatus1)
    {
//IDS_DNS_12926                  "  ERROR: CRrGetAdapterInfo() failed with error %d %s\n" 
        AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12926, dwStatus1, DnsStatusToErrorString_A(dwStatus1) );
        return;
    }
    if (!pRpcAdapterInfo)
    {
//IDS_DNS_12927                  "  ERROR: CRrGetAdapterInfo() returned NO_ERROR but empty Adapter Info\n" 
        AddMessageToList(&pResults->Dns.lmsgOutput, Nd_ReallyVerbose, IDS_DNS_12927);
        return;
    }

    // check adapter count
    count = 0;
    for(pCurrentCache = pRpcAdapterInfo; pCurrentCache; pCurrentCache = pCurrentCache->pNext)
        count++;
    if(count != pNetworkInfo->cAdapterCount)
    {
//IDS_DNS_12928                  "  ERROR: mismatch between adapter count from cache and registry\n" 
        PrintMessage(pParams, IDS_DNS_12928);
        PrintCacheAdapterInfo(pRpcAdapterInfo);
        PrintRegistryAdapterInfo(pNetworkInfo);
        return;
    }

    pCurrentCache = pRpcAdapterInfo;
    iCurrentAdapter = 0;
    while(pCurrentCache && (iCurrentAdapter < pNetworkInfo->cAdapterCount))
    {
        // check DNS domain name
        pCurrentRegistry = pNetworkInfo->AdapterArray[iCurrentAdapter];
        if((pCurrentCache->pszAdapterDomainName && !pCurrentRegistry->pszAdapterDomain) ||
           (!pCurrentCache->pszAdapterDomainName && pCurrentRegistry->pszAdapterDomain) ||
           (pCurrentCache->pszAdapterDomainName && pCurrentRegistry->pszAdapterDomain &&
            _stricmp(pCurrentCache->pszAdapterDomainName, pCurrentRegistry->pszAdapterDomain)))
        {
            cacheOk = FALSE;
//IDS_DNS_12929                  "  ERROR: mismatch between cache and registry info on adapter %s\n" 
            PrintMessage(pParams, IDS_DNS_12929, pCurrentRegistry->pszAdapterGuidName);
//IDS_DNS_12930                  "    DNS Domain Name in cache: %s\n" 
            PrintMessage(pParams, IDS_DNS_12930, pCurrentCache->pszAdapterDomainName);
//IDS_DNS_12931                  "    DNS Domain Name in registry: %s\n" 
            PrintMessage(pParams, IDS_DNS_12931, pCurrentRegistry->pszAdapterDomain);
        }

        // check DNS server list
        sameServers = TRUE;
        pRpcServer = pCurrentCache->pServerInfo;
        count = 0;
        while(pRpcServer)
        {
            count++;
            serverFound = FALSE;
            for (iServer = 0; iServer < pCurrentRegistry->cServerCount; iServer++)
                if(pRpcServer->ipAddress == (pCurrentRegistry->aipServers[iServer]).ipAddress)
                    serverFound = TRUE;
            if(!serverFound)
                sameServers = FALSE;
            pRpcServer = pRpcServer->pNext;
        }
        if (count != pCurrentRegistry->cServerCount)
            sameServers = FALSE;
        if(!sameServers)
        {
            cacheOk = FALSE;
//IDS_DNS_12932                  "  ERROR: mismatch between cache and registry info on adapter %s\n" 
            PrintMessage(pParams, IDS_DNS_12932, pCurrentRegistry->pszAdapterGuidName);
//IDS_DNS_12933                  "    DNS server list in cache: " 
            PrintMessage(pParams, IDS_DNS_12933);
            for( pRpcServer = pCurrentCache->pServerInfo; pRpcServer; pRpcServer = pRpcServer->pNext)
//IDS_DNS_12934                  "%s " 
                PrintMessage(pParams, IDS_DNS_12934, IP_STRING(pRpcServer->ipAddress));
//IDS_DNS_12935                  "\n    DNS server list in registry: " 
            PrintMessage(pParams, IDS_DNS_12935);
            for (iServer = 0; iServer < pCurrentRegistry->cServerCount; iServer++)
//IDS_DNS_12936                  "%s " 
                PrintMessage(pParams, IDS_DNS_12936, IP_STRING((pCurrentRegistry->aipServers[iServer]).ipAddress));
//IDS_DNS_12937                  "\n" 
            PrintMessage(pParams, IDS_DNS_12937);
        }
        
        pCurrentCache = pCurrentCache->pNext;
        iCurrentAdapter++;
    }
    if (cacheOk)
//IDS_DNS_12938                  "  NO_ERROR\n" 
        PrintMessage(pParams, IDS_DNS_12938);
}
*/

DNS_STATUS
DnsUpdateAllowedTest_A(
    IN  HANDLE      hContextHandle OPTIONAL,
    LPSTR           pszName,
    LPSTR           pszAuthZone,
    PIP_ARRAY       pAuthDnsServers
    )
{
    LPWSTR  pwName = NULL, pwZone = NULL;
    int     count = 0;

    //
    // check arguments
    //
    if (!pszName || !pszAuthZone || !pAuthDnsServers || !pAuthDnsServers->AddrCount)
        return ERROR_INVALID_PARAMETER;

    pwName = LocalAlloc(LPTR, (strlen(pszName)+1) * sizeof(WCHAR));
    if(!pwName)
        return GetLastError();

    count = MultiByteToWideChar(
              CP_ACP,
              0L,  
              pszName,  
              -1,         
              pwName, 
              (strlen(pszName) + 1) * sizeof(WCHAR) 
              );

    if (!count)
    {
        LocalFree(pwName);
        return GetLastError();
    }
    
    pwZone = LocalAlloc(LPTR, (strlen(pszAuthZone)+1) * sizeof(WCHAR));
    if(!pwZone)
    {
        LocalFree(pwName);
        return GetLastError();
    }

    count = MultiByteToWideChar(
              CP_ACP,
              0L,  
              pszAuthZone,  
              -1,         
              pwZone, 
              (strlen(pszAuthZone) + 1) * sizeof(WCHAR) 
              );

    if (!count)
    {
        LocalFree(pwName);
        LocalFree(pwZone);
        return GetLastError();
    }    

    return DnsUpdateAllowedTest_W(
                hContextHandle,
                pwName,
                pwZone,
                pAuthDnsServers);
}

DNS_STATUS
DnsQueryAndCompare(
    IN      LPSTR           lpstrName,
    IN      WORD            wType,
    IN      DWORD           fOptions,
    IN      PIP_ARRAY       aipServers              OPTIONAL,
    IN OUT  PDNS_RECORD *   ppQueryResultsSet       OPTIONAL,
    IN OUT  PVOID *         pResponseMsg            OPTIONAL,
    IN      PDNS_RECORD     pExpected               OPTIONAL, 
    IN      BOOL            bInclusionOk,
    IN      BOOL            bUnicode,
    IN OUT  PDNS_RECORD *   ppDiff1                 OPTIONAL,
    IN OUT  PDNS_RECORD *   ppDiff2                 OPTIONAL
    )
{
    BOOL bCompare = FALSE;
    DNS_STATUS  stat;
    DNS_RRSET   rrset;
    PDNS_RECORD pDnsRecord = NULL, pAnswers = NULL, pAdditional = NULL, pLastAnswer = NULL;
    BOOL bIsLocal = FALSE;

    //
    // Run the query and get the result 
    //
    if(fOptions | DNS_QUERY_DATABASE)
        if (!aipServers || !aipServers->AddrCount)
            return ERROR_INVALID_PARAMETER;
        else
            stat = QueryDnsServerDatabase(lpstrName, wType, aipServers->AddrArray[0], ppQueryResultsSet, bUnicode, &bIsLocal);
    else
        if(!bUnicode)
        {
            stat = DnsQuery_UTF8(lpstrName, wType, fOptions, aipServers, ppQueryResultsSet, pResponseMsg);
        }
        else            // Unicode call
        {
            stat = DnsQuery_W((LPWSTR)lpstrName, wType, fOptions, aipServers, ppQueryResultsSet, pResponseMsg);
        }
    
    if (pExpected && !stat)  //succeed, compare the result
    {
        // no need to compare if wanted reponse from database and result is from outside
        if ((fOptions | DNS_QUERY_DATABASE) && !bIsLocal)
            return DNS_INFO_NO_RECORDS;

        pDnsRecord = *ppQueryResultsSet;

        //
        //  Truncate temporary the record set to answers only 
        //
        
        if ((pDnsRecord == NULL) || (pDnsRecord->Flags.S.Section > DNSREC_ANSWER))
        {
            pAnswers = NULL;
            pAdditional = pDnsRecord;
        }
        else
        {
            pAnswers = pDnsRecord;
            pAdditional = pDnsRecord;
            while (pAdditional->pNext && pAdditional->pNext->Flags.S.Section == DNSREC_ANSWER)
                pAdditional = pAdditional->pNext;
            if(pAdditional->pNext)
            {
                pLastAnswer = pAdditional;
                pAdditional = pAdditional->pNext;
                pLastAnswer->pNext = NULL;
            }
            else
                pAdditional = NULL;
        }

        //
        //  Compare the answer with what's expected
        //
        stat = DnsRecordSetCompare( pAnswers, 
                                     pExpected, 
                                     ppDiff1,
                                     ppDiff2);
        //
        //  Restore the list
        //
        if (pAnswers && pAdditional)
            pLastAnswer->pNext = pAdditional;

        // 
        // check if inclusion acceptable 
        //
        if (stat == TRUE)
            stat = NO_ERROR;
        else
            if (bInclusionOk && (ppDiff2 == NULL))
                stat = NO_ERROR;
            else
                stat = ERROR_NO_MATCH;
    }

  return( stat );
}

DNS_STATUS
QueryDnsServerDatabase( LPSTR szName, WORD type, IP_ADDRESS serverIp, PDNS_RECORD *ppDnsRecord, BOOL bUnicode, BOOL *pIsLocal)
{
    PDNS_RECORD     pDnsRecord1 = NULL, pDnsRecord2 = NULL;
    PDNS_RECORD     pdiff1 = NULL, pdiff2 = NULL;
    DNS_STATUS      status1, status2, ret = NO_ERROR;
    PIP_ARRAY       pipServer = NULL;
    BOOL            bMatch = FALSE;
    DWORD           dwTtl1, dwTtl2;

    *pIsLocal = FALSE;
    *ppDnsRecord = NULL;

    if ( serverIp == INADDR_NONE )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    pipServer = Dns_CreateIpArray( 1 );
    if ( ! pipServer )
    {
        return ERROR_OUTOFMEMORY;
    }

    pipServer->AddrArray[0] = serverIp;

    status1 = DnsQuery_UTF8(
                                szName, 
                                type, 
                                DNS_QUERY_BYPASS_CACHE, 
                                pipServer, 
                                &pDnsRecord1, 
                                NULL
                                );
    
    if (status1 != NO_ERROR)
        status2 = status1;
    else
    {
        Sleep(1500);
        status2 = DnsQuery_UTF8(
                                szName, 
                                type, 
                                DNS_QUERY_BYPASS_CACHE, 
                                pipServer, 
                                &pDnsRecord2, 
                                NULL
                                );
    }

    if ((status1 == ERROR_TIMEOUT) || (status2 == ERROR_TIMEOUT))
    {
        ret = ERROR_TIMEOUT;
        goto Cleanup;
    }

    if ((status1 != NO_ERROR) || (status2 != NO_ERROR))
    {
        ret = (status1 != NO_ERROR)?status1:status2;
        goto Cleanup;
    }

    bMatch = DnsRecordSetCompare(
                            pDnsRecord1,
                            pDnsRecord2,
                            &pdiff1,
                            &pdiff2
                            );

    if (!bMatch)
    {
        ret = DNS_ERROR_TRY_AGAIN_LATER;
        goto Cleanup;
    }
    
    if (GetAnswerTtl( pDnsRecord1, &dwTtl1 ) && GetAnswerTtl( pDnsRecord2, &dwTtl2 ))
        if ( dwTtl1 != dwTtl2 )
        {
            ret = NO_ERROR;
            *pIsLocal = FALSE;
        }
        else 
        {
            ret = NO_ERROR;
            *pIsLocal = TRUE;
        }
    else
        ret = DNS_INFO_NO_RECORDS;

Cleanup:

    Dns_Free( pipServer );

    if (pdiff1)
        DnsRecordListFree( pdiff1, TRUE );
    if (pdiff2)
      DnsRecordListFree( pdiff2, TRUE );
    if (pDnsRecord1)
        DnsRecordListFree( pDnsRecord1, TRUE );
    if (pDnsRecord2 && (ret != NO_ERROR))
        DnsRecordListFree( pDnsRecord2, TRUE );
    if (ret == NO_ERROR)
        *ppDnsRecord = pDnsRecord2;
    else 
        *ppDnsRecord = NULL;
    return ret;
}

BOOL GetAnswerTtl( PDNS_RECORD pRec, PDWORD pTtl )
{

    PDNS_RECORD     pDnsRecord = NULL;
    BOOL            bGotAnswer = FALSE;

    *pTtl = 0;

    //
    //  Look for answer section
    //
        
    for (pDnsRecord = pRec; !bGotAnswer && pDnsRecord; pDnsRecord = pDnsRecord->pNext)
    {
        if (pDnsRecord->Flags.S.Section == DNSREC_ANSWER)
        {
            bGotAnswer = TRUE;
            *pTtl = pDnsRecord->dwTtl;
        }
    }
    
    return bGotAnswer;
}

// Get A records from additional section and build a PIP_ARRAY
PIP_ARRAY
GrabNameServersIp(
                  PDNS_RECORD pDnsRecord
                  )
{
    DWORD       i = 0;
    PDNS_RECORD pCurrent = pDnsRecord;
    PIP_ARRAY   pIpArray = NULL;
    
    // count records
    while (pCurrent)
    {
        if((pCurrent->wType == DNS_TYPE_A) &&
           (pCurrent->Flags.S.Section == DNSREC_ADDITIONAL))
           i++;
        pCurrent = pCurrent->pNext;
    }

    if (!i)
        return NULL;

    // allocate PIP_ARRAY
    pIpArray = LocalAlloc(LMEM_FIXED, IP_ARRAY_SIZE(i));
    if (!pIpArray)
        return NULL;

    // fill PIP_ARRAY
    pIpArray->AddrCount = i;
    pCurrent = pDnsRecord;
    i=0;
    while (pCurrent)
    {
        if((pCurrent->wType == DNS_TYPE_A) && (pCurrent->Flags.S.Section == DNSREC_ADDITIONAL))
            (pIpArray->AddrArray)[i++] = pCurrent->Data.A.IpAddress;
        pCurrent = pCurrent->pNext;
    }
    return pIpArray;
}

DNS_STATUS
DnsUpdateAllowedTest_W(
    IN  HANDLE      hContextHandle OPTIONAL,
    LPWSTR          pwszName,
    LPWSTR          pwszAuthZone,
    PIP_ARRAY       pAuthDnsServers
    )
{
    PDNS_RECORD     pResult = NULL;
    DNS_STATUS      dwStatus = 0, status = 0;
    BOOL            bAnyAllowed = FALSE;
    BOOL            bAllTimeout = TRUE;
    DWORD           i;

    // 
    // Check arguments
    //
    if (!pwszName || !pwszAuthZone || !pAuthDnsServers || !pAuthDnsServers->AddrCount)
        return ERROR_INVALID_PARAMETER;

    // 
    // go through server list 
    //
    for(i=0; i<pAuthDnsServers->AddrCount; i++)
    {
        //
        // verify if server is a primary
        //
        status = IsDnsServerPrimaryForZone_W(
                    pAuthDnsServers->AddrArray[i],
                    pwszAuthZone);
        switch(status)
        {
        case ERROR_TIMEOUT:
        case DNS_ERROR_RCODE:
            //
            // it's ok to go check the next server; this one timeouted or it's a secondary
            //
            break; 
        case NO_ERROR:  // server is a primary
            //
            // Check if update allowed
            //
            status = DnsUpdateTest_W(
                hContextHandle,
                pwszName,
                0,
                pAuthDnsServers);
            switch(status)
            {
            case ERROR_TIMEOUT:
                break;
            case NO_ERROR:
            case DNS_ERROR_RCODE_YXDOMAIN:
                return NO_ERROR;
                break;
            case DNS_ERROR_RCODE_REFUSED:
            default:
                return status;
                break;
            }
            break;
        default:
            return status;
            break;
        }
    }
    return ERROR_TIMEOUT;
}

DNS_STATUS
DnsUpdateAllowedTest_UTF8(
    IN  HANDLE      hContextHandle OPTIONAL,
    LPSTR           pszName,
    LPSTR           pszAuthZone,
    PIP_ARRAY       pAuthDnsServers
    )
{
    PDNS_RECORD     pResult = NULL;
    DNS_STATUS      dwStatus = 0, status = 0;
    BOOL            bAnyAllowed = FALSE;
    BOOL            bAllTimeout = TRUE;
    DWORD           i;

    // 
    // Check arguments
    //
    if (!pszName || !pszAuthZone || !pAuthDnsServers || !pAuthDnsServers->AddrCount)
        return ERROR_INVALID_PARAMETER;

    // 
    // go through server list 
    //
    for(i=0; i<pAuthDnsServers->AddrCount; i++)
    {
        //
        // verify if server is a primary
        //
        status = IsDnsServerPrimaryForZone_UTF8(
                    pAuthDnsServers->AddrArray[i],
                    pszAuthZone);
        switch(status)
        {
        case ERROR_TIMEOUT:
        case DNS_ERROR_RCODE:
            //
            // it's ok to go check the next server; this one timeouted or it's a secondary
            //
            break; 
        case NO_ERROR:  // server is a primary
            //
            // Check if update allowed
            //
            status = DnsUpdateTest_UTF8(
                hContextHandle,
                pszName,
                0,
                pAuthDnsServers);
            switch(status)
            {
            case ERROR_TIMEOUT:
                break;
            case NO_ERROR:
            case DNS_ERROR_RCODE_YXDOMAIN:
                return NO_ERROR;
                break;
            case DNS_ERROR_RCODE_REFUSED:
            default:
                return status;
                break;
            }
            break;
        default:
            return status;
            break;
        }
    }
    return ERROR_TIMEOUT;
}

DNS_STATUS
IsDnsServerPrimaryForZone_UTF8(
                          IP_ADDRESS    ip,
                          LPSTR         zone
                          )
{
    PDNS_RECORD     pDnsRecord = NULL;
    DNS_STATUS      status;
    IP_ARRAY        ipArray;
    PIP_ARRAY       pResult = NULL;
    BOOL            bFound = FALSE;
    DWORD           i;

    //
    // query for SOA
    //
    ipArray.AddrCount = 1;
    ipArray.AddrArray[0] = ip;
    status = DnsQuery_UTF8(
                zone,
                DNS_TYPE_SOA,
                DNS_QUERY_BYPASS_CACHE,
                &ipArray,
                &pDnsRecord,
                NULL);

    if(status == NO_ERROR)
    {
        pResult = GrabNameServersIp(pDnsRecord);
        if (pResult)
        {
            bFound = FALSE;
            for (i=0; i<pResult->AddrCount; i++)
                if(pResult->AddrArray[i] == ip)
                    bFound = TRUE;
            LocalFree(pResult);
            if(bFound)
                return NO_ERROR;
            else
                return DNS_ERROR_RCODE;
        }
        else
            return DNS_ERROR_ZONE_CONFIGURATION_ERROR;
    }
    else
        return status;
}

DNS_STATUS
IsDnsServerPrimaryForZone_W(
                          IP_ADDRESS    ip,
                          LPWSTR         zone
                          )
{
    PDNS_RECORD     pDnsRecord = NULL;
    DNS_STATUS      status;
    IP_ARRAY        ipArray;
    PIP_ARRAY       pResult = NULL;
    BOOL            bFound = FALSE;
    DWORD           i;

    //
    // query for SOA
    //
    ipArray.AddrCount = 1;
    ipArray.AddrArray[0] = ip;
    status = DnsQuery_W(
                zone,
                DNS_TYPE_SOA,
                DNS_QUERY_BYPASS_CACHE,
                &ipArray,
                &pDnsRecord,
                NULL);

    if(status == NO_ERROR)
    {
        pResult = GrabNameServersIp(pDnsRecord);
        if (pResult)
        {
            bFound = FALSE;
            for (i=0; i<pResult->AddrCount; i++)
                if(pResult->AddrArray[i] == ip)
                    bFound = TRUE;
            LocalFree(pResult);
            if(bFound)
                return NO_ERROR;
            else
                return DNS_ERROR_RCODE;
        }
        else
            return DNS_ERROR_ZONE_CONFIGURATION_ERROR;
    }
    else
        return status;
}


DNS_STATUS
GetAllDnsServersFromRegistry(
    PDNS_NETINFO        pNetworkInfo,
    PIP_ARRAY *         pIpArray
    )
{
    DNS_STATUS          dwStatus = NO_ERROR;
    DWORD               i, j, idx, idx1, count = 0, dwIP;
    BOOL                bFound = FALSE;


    *pIpArray = NULL;

    if (!pNetworkInfo)
    {
        //
        // Get the DNS Network Information
        // Force rediscovery
        //

        pNetworkInfo = DnsQueryConfigAlloc(
                            DnsConfigNetInfo,
                            NULL );
        if (!pNetworkInfo)
        {
            dwStatus = GetLastError(); 
            return dwStatus;
        }
    }

    for (idx = 0; idx < pNetworkInfo->cAdapterCount; idx++)
        count += (pNetworkInfo->AdapterArray[idx])->cServerCount;
    if(count == 0)
        return DNS_ERROR_INVALID_DATA;

    *pIpArray = LocalAlloc(LPTR, sizeof(DWORD) + count*sizeof(IP_ADDRESS));
    if(*pIpArray == NULL)
        return GetLastError();
    
    i = 0;
    for (idx = 0; idx < pNetworkInfo->cAdapterCount; idx++)
    {
        for (idx1 = 0; idx1 < (pNetworkInfo->AdapterArray[idx])->cServerCount; idx1++)
        {
            dwIP = (pNetworkInfo->AdapterArray[idx])->ServerArray[idx1].IpAddress;
            bFound = FALSE;
            if(i>0)
                for (j = 0; j < i; j++)
                    if(dwIP == (*pIpArray)->AddrArray[j])
                        bFound = TRUE;
            if (!bFound)
                (*pIpArray)->AddrArray[i++] = dwIP;
        }
    }
    (*pIpArray)->AddrCount = i;
    return DNS_ERROR_RCODE_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\dhcptest.h ===
/*--

Copyright (C) Microsoft Corporation, 1999 - 1999 

Module Name:

      dhcptest.h

Abstract:

      Contains function prototypes, defines and data structures used in dhcp test as part of
      autonet test.

Author:
       
      4-Aug-1998 (t-rajkup)

Environment:

      User mode only.

Revision History:

      None.

--*/
#ifndef HEADER_DHCPTEST
#define HEADER_DHCPTEST

#define OPTION_MSFT_CONTINUED           250
#define OPTION_USER_CLASS               77

#define MAX_DISCOVER_RETRIES            4

//
// The format of Adapter Status responses
//

typedef struct
{
    ADAPTER_STATUS AdapterInfo;
    NAME_BUFFER    Names[32];
} tADAPTERSTATUS;

UCHAR nameToQry[NETBIOS_NAME_SIZE + 1];


/*
VOID
ExtractDhcpResponse(
   IN PDHCP_MESSAGE pDhcpMessage
  );
*/


/*=======================< Dhcp related function prototypes >================*/


/*
DWORD
DhcpCalculateWaitTime(
    IN      DWORD                  RoundNum,
    OUT     DWORD                 *WaitMilliSecs
  );
 

BOOL
GetSpecifiedDhcpMessage(
          IN SOCKET sock,
          IN PIP_ADAPTER_INFO pAdapterInfo,
          OUT PDHCP_MESSAGE pDhcpMessage,
          IN DWORD Xid,
          IN DWORD TimeToWait
);

VOID
SendDhcpMessage(
 IN SOCKET sock,
 IN PDHCP_MESSAGE pDhcpMessage,
 IN DWORD MessageLength,
 IN DWORD TransactionId,
 IN PIP_ADAPTER_INFO pAdapterInfo
 );

LPBYTE
DhcpAppendMagicCookie(
    OUT LPBYTE Option,
    IN LPBYTE OptionEnd
    );

LPOPTION
DhcpAppendClassIdOption(
    IN OUT     PDHCP_CONTEXT          DhcpContext,
    OUT     LPBYTE                 BufStart,
    IN      LPBYTE                 BufEnd
);

LPOPTION
DhcpAppendClientIDOption(
    OUT LPOPTION Option,
    IN BYTE ClientHWType,
    IN LPBYTE ClientHWAddr,
    IN BYTE ClientHWAddrLength,
    IN LPBYTE OptionEnd
    );

DWORD
OpenDriver(
    OUT HANDLE *Handle,
    IN LPWSTR DriverName
);


LPOPTION
DhcpAppendOption(
    OUT LPOPTION Option,
    IN  BYTE OptionType,
    IN  PVOID OptionValue,
    IN  ULONG OptionLength,
    IN  LPBYTE OptionEnd
);
*/
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\dnscmn.h ===
/*++

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:
    dnscmn.h

Abstract:
    Domain Name System (DNS) Client
    Routines used to verify the DNS registration for a client

Author:
    Elena Apreutesei (elenaap) 10/22/98

Revision History:

--*/

#ifndef _DNSCOMMON_H_
#define _DNSCOMMON_H_

#include <dnslib.h>

#define     MAX_NAME_SERVER_COUNT   (20)
#define     MAX_ADDRS               (35)    
#define     DNS_QUERY_DATABASE      (0x200)
#define     IP_ARRAY_SIZE(a)        (sizeof(DWORD) + (a)*sizeof(IP_ADDRESS))

//  Use dnslib memory routines
#define ALLOCATE_HEAP(iSize)            Dns_Alloc(iSize)
#define ALLOCATE_HEAP_ZERO(iSize)       Dns_AllocZero(iSize)
#define REALLOCATE_HEAP(pMem,iSize)     Dns_Realloc((pMem),(iSize))
#define FREE_HEAP(pMem)                 Dns_Free(pMem)

typedef struct
{
    PVOID       pNext;
    char        szDomainName[DNS_MAX_NAME_BUFFER_LENGTH];
    char        szAuthoritativeZone[DNS_MAX_NAME_BUFFER_LENGTH];
    DWORD       dwAuthNSCount;
    IP_ADDRESS  AuthoritativeNS[MAX_NAME_SERVER_COUNT];
    DWORD       dwIPCount;
    IP_ADDRESS  IPAddresses[MAX_ADDRS];
    DNS_STATUS  AllowUpdates;
}
REGISTRATION_INFO, *PREGISTRATION_INFO;


BOOL
SameAuthoritativeServers(
    PREGISTRATION_INFO pCurrent,
    PIP_ARRAY pNS
    );

DNS_STATUS
ComputeExpectedRegistration(
    LPSTR               pszHostName,
    LPSTR               pszPrimaryDomain,
    PDNS_NETINFO        pNetworkInfo,
    PREGISTRATION_INFO  *ppExpectedRegistration,
    NETDIAG_PARAMS*     pParams, 
    NETDIAG_RESULT*     pResults
    );

void
AddToExpectedRegistration(
    LPSTR               pszDomain,
    PDNS_ADAPTER        pAdapterInfo,
    PDNS_NETINFO        pFazResult, 
    PIP_ARRAY           pNS,
    PREGISTRATION_INFO *ppExpectedRegistration
    );

HRESULT
VerifyDnsRegistration(
    LPSTR               pszHostName,
    PREGISTRATION_INFO  pExpectedRegistration,
    NETDIAG_PARAMS*     pParams,  
    NETDIAG_RESULT*     pResults
    );

HRESULT
CheckDnsRegistration(
    PDNS_NETINFO        pNetworkInfo,
    NETDIAG_PARAMS*     pParams, 
    NETDIAG_RESULT*     pResults
    );

void
CompareCachedAndRegistryNetworkInfo(
    PDNS_NETINFO        pNetworkInfo
    );

PIP_ARRAY
ServerInfoToIpArray(
    DWORD               cServerCount,
    DNS_SERVER_INFO *   ServerArray
    );

DNS_STATUS
DnsFindAuthoritativeZone(
    IN      LPCSTR          pszName,
    IN      DWORD           dwFlags,
    IN      PIP_ARRAY       aipQueryServers,
    OUT     PDNS_NETINFO *  ppNetworkInfo
    );

DNS_STATUS
DnsFindAllPrimariesAndSecondaries(
    IN      LPSTR           pszName,
    IN      DWORD           dwFlags,
    IN      PIP_ARRAY       aipQueryServers,
    OUT     PDNS_NETINFO *  ppNetworkInfo,
    OUT     PIP_ARRAY *     ppNameServers,
    OUT     PIP_ARRAY *     ppPrimaries //optional
    );

PIP_ARRAY
GrabNameServersIp(
    PDNS_RECORD     pDnsRecord
    );

DNS_STATUS
IsDnsServerPrimaryForZone_UTF8(
    IP_ADDRESS      ip,
    LPSTR           zone
    );

DNS_STATUS
IsDnsServerPrimaryForZone_W(
    IP_ADDRESS      ip,
    LPWSTR          zone
    );

DNS_STATUS
DnsUpdateAllowedTest_A(
    IN  HANDLE      hContextHandle OPTIONAL,
    LPSTR           pszName,
    LPSTR           pszAuthZone,
    PIP_ARRAY       pAuthDnsServers
    );

DNS_STATUS
DnsUpdateAllowedTest_UTF8(
    IN  HANDLE      hContextHandle OPTIONAL,
    LPSTR           pszName,
    LPSTR           pszAuthZone,
    PIP_ARRAY       pAuthDnsServers
    );

DNS_STATUS
DnsUpdateAllowedTest_W(
    IN  HANDLE      hContextHandle OPTIONAL,
    LPWSTR          pwszName,
    LPWSTR          pwszAuthZone,
    PIP_ARRAY       pDnsServers
    );

DNS_STATUS
DnsQueryAndCompare(
    IN      LPSTR           lpstrName,
    IN      WORD            wType,
    IN      DWORD           fOptions,
    IN      PIP_ARRAY       aipServers          OPTIONAL,
    IN OUT  PDNS_RECORD *   ppQueryResultsSet   OPTIONAL,
    IN OUT  PVOID *         pReserved           OPTIONAL,
    IN      PDNS_RECORD     pExpected           OPTIONAL, 
    IN      BOOL            bInclusionOk,
    IN      BOOL            bUnicode,
    IN OUT  PDNS_RECORD *   ppDiff1             OPTIONAL,
    IN OUT  PDNS_RECORD *   ppDiff2             OPTIONAL
    );

BOOLEAN
DnsCompareRRSet_W (
    IN  PDNS_RECORD   pRRSet1,
    IN  PDNS_RECORD   pRRSet2,
    OUT PDNS_RECORD * ppDiff1,
    OUT PDNS_RECORD * ppDiff2
    );

DNS_STATUS
QueryDnsServerDatabase( 
    LPSTR szName, 
    WORD type, 
    IP_ADDRESS serverIp, 
    PDNS_RECORD *ppDnsRecord, 
    BOOL bUnicode,
    BOOL *pIsLocal
    );

BOOL
GetAnswerTtl(
    PDNS_RECORD pRec,
    PDWORD pTtl
    );

DNS_STATUS
GetAllDnsServersFromRegistry(
    PDNS_NETINFO      pNetworkInfo, 
    PIP_ARRAY *pIpArray
    );

LPSTR
UTF8ToAnsi(
    LPSTR szuStr
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\domutil.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       domutil.h
//
//--------------------------------------------------------------------------

#ifndef HEADER_DOMUTIL
#define HEADER_DOMUTIL

PTESTED_DOMAIN
AddTestedDomain(
                IN NETDIAG_PARAMS *pParams,
                IN NETDIAG_RESULT *pResults,
                IN LPWSTR pswzNetbiosDomainName,
                IN LPWSTR pswzDnsDomainName,
                IN BOOL bPrimaryDomain
    );

BOOL
NetpIsDomainNameValid(
    IN LPWSTR DomainName
    );

BOOL
NetpDcValidDnsDomain(
    IN LPCWSTR DnsDomainName
    );

BOOL
NlEqualDnsName(
    IN LPCWSTR Name1,
    IN LPCWSTR Name2
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\domutil.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      domutil.c
//
//  Abstract:
//
//    Test to ensure that a workstation has network (IP) connectivity to
//      the outside.
//
//  Author:
//
//     15-Dec-1997 (cliffv)
//      Anilth  - 4-20-1998 
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//    1-June-1998 (denisemi) add DnsServerHasDCRecords to check DC dns records
//                           registration
//
//    26-June-1998 (t-rajkup) add general tcp/ip , dhcp and routing,
//                            winsock, ipx, wins and netbt information. 
//--

//
// Common include files.
//
#include "precomp.h"
#include "domutil.h"

#include "ipcfgtest.h"


/*!--------------------------------------------------------------------------
    AddTestedDomain
        Add a domain to the list of domains to test.
        
        Arguments:

            pswzNetbiosDomainName - Name of the domain.
                If pswzDnsDomainName is NULL, this can be either a netbios or dns domain name.
                If pswzDnsDomainName is not NULL, this must be the netbios name of the domain.

            pwszDnsDomainName - Another name of the domain.
                If specified, this must be the DNS name of the domain.

    
            PrimaryDomain - True if this is the primary domain
        
        Return Value:
        
            Returns pointer to structure describing the domain
            NULL: Memory allocation failure.
    Author: KennT
 ---------------------------------------------------------------------------*/
PTESTED_DOMAIN
AddTestedDomain(
                IN NETDIAG_PARAMS *pParams,
                IN NETDIAG_RESULT *pResults,
                IN LPWSTR pswzNetbiosDomainName,
                IN LPWSTR pswzDnsDomainName,
                IN BOOL bPrimaryDomain
    )
{
    PTESTED_DOMAIN pTestedDomain = NULL;
    PLIST_ENTRY pListEntry;
    BOOL fIsNetbios;
    BOOL fIsDns;

    //
    // Determine if the passed in parameters are Netbios or DNS names
    //

    if ( pswzDnsDomainName == NULL ) {
        fIsDns = NetpDcValidDnsDomain( pswzNetbiosDomainName );
        fIsNetbios = NetpIsDomainNameValid( pswzNetbiosDomainName );
        // Don't allow a single name to be both netbios and dns.
        if ( fIsDns && fIsNetbios ) {
            //
            // If there is a period in the name,
            //  it is a DNS name, otherwise
            //  it is a Netbios Name
            //
            if ( wcschr( pswzNetbiosDomainName, L'.' ) != NULL ) {
                fIsNetbios = FALSE;
            } else {
                fIsDns = FALSE;
            }
        }

        if ( !fIsNetbios && !fIsDns ) {
            DebugMessage2("'%ws' is not a valid domain name\n\n", pswzNetbiosDomainName );
            return NULL;
        }

        if ( fIsDns ) {
            pswzDnsDomainName = pswzNetbiosDomainName;
        }

        if ( !fIsNetbios ) {
            pswzNetbiosDomainName = NULL;
        }

    } else {

        fIsNetbios = NetpIsDomainNameValid( pswzNetbiosDomainName );

        if ( !fIsNetbios ) {
            DebugMessage2("'%ws' is not a valid Netbios domain name\n\n", pswzNetbiosDomainName );
            return NULL;
        }

        fIsDns = NetpDcValidDnsDomain( pswzDnsDomainName );

        if ( !fIsDns ) {
            DebugMessage2("'%ws' is not a valid DNS domain name\n\n", pswzDnsDomainName );
            return NULL;
        }
    }

    //
    // Check if the domain is already defined.
    //

    for ( pListEntry = pResults->Global.listTestedDomains.Flink ;
          pListEntry != &pResults->Global.listTestedDomains ;
          pListEntry = pListEntry->Flink )
    {
        //
        // If the entry is found,
        //  use it.
        //

        pTestedDomain = CONTAINING_RECORD( pListEntry, TESTED_DOMAIN, Next );

        if ( pswzNetbiosDomainName != NULL &&
             pTestedDomain->NetbiosDomainName != NULL &&
             _wcsicmp( pTestedDomain->NetbiosDomainName, pswzNetbiosDomainName ) == 0 ) {

            //
            // The netbios domain name matched.
            //  So the DNS name must match if it exists.
            //

            if ( pswzDnsDomainName != NULL &&
                 pTestedDomain->DnsDomainName != NULL ) {

                if ( !NlEqualDnsName( pTestedDomain->DnsDomainName, pswzDnsDomainName ) ) {
                    DebugMessage3("'%ws' and '%ws' DNS domain names different\n\n", pTestedDomain->DnsDomainName, pswzDnsDomainName );
                    return NULL;
                }
            }

            break;
        }

        if ( pswzDnsDomainName != NULL &&
             pTestedDomain->DnsDomainName != NULL &&
             NlEqualDnsName( pTestedDomain->DnsDomainName, pswzDnsDomainName ) ) {
            break;
        }

        pTestedDomain = NULL;
    }

    //
    // Allocate a structure to describe the domain.
    //

    if ( pTestedDomain == NULL )
    {
        pTestedDomain = Malloc( sizeof(TESTED_DOMAIN) );
        if ( pTestedDomain == NULL )
        {
            PrintMessage(pParams, IDS_GLOBAL_OutOfMemory);
            return NULL;
        }
        
        ZeroMemory( pTestedDomain, sizeof(TESTED_DOMAIN) );

        InitializeListHead( &pTestedDomain->TestedDcs );

        InsertTailList( &pResults->Global.listTestedDomains, &pTestedDomain->Next );
    }

    //
    // Update the domain name.
    //

    if ( pTestedDomain->DnsDomainName == NULL && pswzDnsDomainName != NULL ) {
        pTestedDomain->DnsDomainName = NetpAllocWStrFromWStr( pswzDnsDomainName );

        if ( pTestedDomain->DnsDomainName == NULL ) {
            PrintMessage( pParams, IDS_GLOBAL_OutOfMemory);
            return NULL;
        }
    }

    if ( pTestedDomain->NetbiosDomainName == NULL && pswzNetbiosDomainName != NULL ) {
        pTestedDomain->NetbiosDomainName = NetpAllocWStrFromWStr( pswzNetbiosDomainName );

        if ( pTestedDomain->NetbiosDomainName == NULL ) {
            PrintMessage( pParams, IDS_GLOBAL_OutOfMemory);
            return NULL;
        }
    }


    //
    // Fill in other fields.
    //

    if ( bPrimaryDomain ) {
        pTestedDomain->fPrimaryDomain = TRUE;
    }

    if ( pTestedDomain->fPrimaryDomain ) {
        pTestedDomain->QueryableDomainName = NULL;
    } else {
        //
        // The queryable domain name is the DNS domain name (if known)
        if ( pTestedDomain->DnsDomainName != NULL ) {
            pTestedDomain->QueryableDomainName = pTestedDomain->DnsDomainName;
        } else {
            pTestedDomain->QueryableDomainName = pTestedDomain->NetbiosDomainName;
        }
    }

    // The printable domain name is the Netbios domain name (if known)
    if (pTestedDomain->NetbiosDomainName != NULL ) {
        pTestedDomain->PrintableDomainName = pTestedDomain->NetbiosDomainName;
    } else {
        pTestedDomain->PrintableDomainName = pTestedDomain->DnsDomainName;
    }


    return pTestedDomain;
}

BOOL
NetpDcValidDnsDomain(
    IN LPCWSTR DnsDomainName
)
/*++

Routine Description:

    Returns whether the specified string is a valid DNS Domain name.

Arguments:


    DnsDomainName - DNS domain name to validate.

Return Value:

    TRUE - The specified name is syntactically a DNS Domain name.

    FALSE - The specified name in not syntactically a DNS Domain name.

--*/
{
    DNS_STATUS DnsStatus;
    DnsStatus = DnsValidateDnsName_W( DnsDomainName );

    if ( DnsStatus == ERROR_SUCCESS ||
         DnsStatus == DNS_ERROR_NON_RFC_NAME ) {
        return TRUE;
    }

    return FALSE;

}


BOOL
NlEqualDnsName(
    IN LPCWSTR Name1,
    IN LPCWSTR Name2
    )
/*++

Routine Description:

    This routine compares two DNS names for equality.

    Case is ignored.  A single trailing . is ignored.
    Null is compared equal to a zero length string.

Arguments:

    Name1 - First DNS name to compare

    Name2 - Second DNS name to compare

Return Value:

    TRUE: DNS names are equal.

--*/
{
    if ( Name1 == NULL ) {
        return (Name2 == NULL);
    } else if ( Name2 == NULL ) {
        return FALSE;
    }

    return DnsNameCompare_W( (LPWSTR) Name1, (LPWSTR) Name2 );
}


// from net\netlib\names.c
BOOL
NetpIsDomainNameValid(
    IN LPWSTR DomainName
    )

/*++

Routine Description:
    NetpIsDomainNameValid checks for "domain" format.
    The name is only checked syntactically; no attempt is made to determine
    whether or not a domain with that name actually exists.

Arguments:

    DomainName - Supplies an alleged Domain name.

Return Value:

    BOOL - TRUE if name is syntactically valid, FALSE otherwise.

--*/
{
    NET_API_STATUS ApiStatus = NO_ERROR;
    WCHAR CanonBuf[DNLEN+1];

    if (DomainName == (LPWSTR) NULL) {
        return (FALSE);
    }
    if ( (*DomainName) == (TCHAR)'\0' ) {
        return (FALSE);
    }

    ApiStatus = NetpNameCanonicalize(
            NULL,                       // no server name
            DomainName,                 // name to validate
            CanonBuf,                   // output buffer
            (DNLEN+1) * sizeof(WCHAR), // output buffer size
            NAMETYPE_DOMAIN,           // type
            0 );                       // flags: none

    return (ApiStatus == NO_ERROR);

} // NetpIsDomainNameValid
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\dsgetdc.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      dsgetdc.c
//
//  Abstract:
//
//      Queries into network drivers
//
//  Author:
//
//      Anilth	- 4-20-1998
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//--

#include "precomp.h"
#include "objbase.h"

VOID PrintDsGetDcName(IN NETDIAG_RESULT *pResults,
                      IN OUT PLIST_ENTRY plmsgOutput,
					  IN PDOMAIN_CONTROLLER_INFOW DomainControllerInfo);

NET_API_STATUS SetPrimaryGuid(IN GUID *GuidToSet);


HRESULT
DsGetDcTest(NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
/*++

Routine Description:

    Ensure that we can find domain controllers

Arguments:

    None.

Return Value:

    TRUE: Test suceeded.
    FALSE: Test failed

--*/
{
	NET_API_STATUS NetStatus;
	NET_API_STATUS LocalNetStatus;
	BOOL RetVal = TRUE;
	HRESULT		hr = hrOK;
	LPTSTR	pszDcType;
	
	PTESTED_DOMAIN pTestedDomain = (PTESTED_DOMAIN) pParams->pDomain;
	PDOMAIN_CONTROLLER_INFOW LocalDomainControllerInfo = NULL;

	//if the machine is a member machine or DC, DsGetDc Test will get called. 
	//Otherwise, this test will be skipped
	pResults->DsGetDc.fPerformed = TRUE;

	//the DsGetDc test will be called for every domain, but we only want to initialize
	//the message list once.
	if(pResults->DsGetDc.lmsgOutput.Flink == NULL)		
		InitializeListHead(&pResults->DsGetDc.lmsgOutput);
	
	PrintStatusMessage(pParams, 4, IDS_DSGETDC_STATUS_MSG);
	

	//
	// Find a generic DC
	//

	PrintStatusMessage(pParams, 4, IDS_DSGETDC_STATUS_DC);

	pszDcType = LoadAndAllocString(IDS_DCTYPE_DC);
	NetStatus = DoDsGetDcName( pParams,
							   pResults,
                               &pResults->DsGetDc.lmsgOutput,
							   pTestedDomain,
							   DS_DIRECTORY_SERVICE_PREFERRED,
							   pszDcType, //_T("DC"),
							   TRUE,
							   &pTestedDomain->DcInfo );
	Free(pszDcType);
	
    pTestedDomain->fTriedToFindDcInfo = TRUE;

	if ( NetStatus != NO_ERROR ) {
        hr = S_FALSE;
        goto Error;
	}
	
	//
	// Find a PDC
	//  (Failure isn't fatal.)
	//
	PrintStatusMessage(pParams, 4, IDS_DSGETDC_STATUS_PDC);

	pszDcType = LoadAndAllocString(IDS_DCTYPE_PDC);
	LocalNetStatus = DoDsGetDcName(pParams,
								   pResults,
                                   &pResults->DsGetDc.lmsgOutput,
								   pTestedDomain,
								   DS_PDC_REQUIRED,
								   pszDcType, //_T("PDC"),
								   FALSE,
								   &LocalDomainControllerInfo );
	Free(pszDcType);
	
	if ( LocalNetStatus == NO_ERROR )
	{
		if ( LocalDomainControllerInfo != NULL )
		{
			NetApiBufferFree( LocalDomainControllerInfo );
			LocalDomainControllerInfo = NULL;
		}
	}
	
	//
	// Find an NT 5 DC
	//  (Failure isn't fatal.)
	//
	PrintStatusMessage(pParams, 4, IDS_DSGETDC_STATUS_NT5DC);
	
	pszDcType = LoadAndAllocString(IDS_DCTYPE_W2K_DC);	
	LocalNetStatus = DoDsGetDcName(pParams,
								   pResults,
                                   &pResults->DsGetDc.lmsgOutput,
								   pTestedDomain,
								   DS_DIRECTORY_SERVICE_REQUIRED,
								   pszDcType, //_T("Windows 2000 DC"),
								   FALSE,
								   &LocalDomainControllerInfo );
	Free(pszDcType);
	
	if ( LocalNetStatus == NO_ERROR )
	{
		if ( LocalDomainControllerInfo != NULL )
		{
			NetApiBufferFree( LocalDomainControllerInfo );
			LocalDomainControllerInfo = NULL;
		}
	}
	
	
	//
	// Ensure the returned domain GUID is the domain GUID stored in the LSA
	//
	if ( pTestedDomain == pResults->Global.pMemberDomain )
	{
		
		if ( !IsEqualGUID( &pResults->Global.pPrimaryDomainInfo->DomainGuid, &NlDcZeroGuid ) &&
			 !IsEqualGUID( &pTestedDomain->DcInfo->DomainGuid, &NlDcZeroGuid )  &&
			 !IsEqualGUID( &pResults->Global.pPrimaryDomainInfo->DomainGuid,
						   &pTestedDomain->DcInfo->DomainGuid ) )
		{
			// Need to convert the two GUIDS
			WCHAR	swzGuid1[64];
			WCHAR	swzGuid2[64];

			StringFromGUID2(&pResults->Global.pPrimaryDomainInfo->DomainGuid,
							swzGuid1,
							DimensionOf(swzGuid1));
			StringFromGUID2(&pTestedDomain->DcInfo->DomainGuid,
							swzGuid2,
							DimensionOf(swzGuid2));

			// "    [FATAL] Your machine thinks the domain GUID of domain '%ws' is\n        '"
			// "' but \n        '%ws' thinks it is\n        '"
			AddMessageToList(&pResults->DsGetDc.lmsgOutput,
							 Nd_Quiet,
							 IDS_DSGETDC_FATAL_GUID,
							 pResults->Global.pPrimaryDomainInfo->DomainNameFlat,
							 swzGuid1,
							 pTestedDomain->DcInfo->DomainControllerName,
							 swzGuid2);
							

			hr = S_FALSE;
			
			//
			// Attempt to fix the problem.
			//
			
			if ( !pParams->fFixProblems )
			{
				// "\nConsider running 'nettest /fix' to try to fix this problem\n"
				AddMessageToList( &pResults->DsGetDc.lmsgOutput, Nd_Quiet, IDS_DSGETDC_13206 );
			}
			else
			{
				NetStatus = SetPrimaryGuid( &pTestedDomain->DcInfo->DomainGuid );
				
				if ( NetStatus != NO_ERROR )
				{
					if ( NetStatus == ERROR_ACCESS_DENIED )
					{
						// "\nCannot fix domain GUID since you are not an administrator.  Leave then rejoin the domain.\n"
						AddMessageToList( &pResults->DsGetDc.lmsgOutput, Nd_Quiet, IDS_DSGETDC_13207 );
					}
					else
					{
						// "    [FATAL] Failed to fix Domain Guid. [%s]\n"
						AddMessageToList( &pResults->DsGetDc.lmsgOutput, Nd_Quiet,
                                           IDS_DSGETDC_13208, NetStatusToString(NetStatus) );
					}
				}
				else
				{
					// "\nFixed domain GUID.  Reboot then run 'nettest' again to ensure everything is working.\n"
					AddMessageToList( &pResults->DsGetDc.lmsgOutput, Nd_Quiet, IDS_DSGETDC_13209 );
				}
			}
			
		}
	}
	
Error:
    //$REVIEW (nsun 10/05/98) CliffV deleted DCNameClose()
    //DCNameClose();
    pResults->DsGetDc.hr = hr;
    return hr;
}



VOID
PrintDsGetDcName(
				 IN NETDIAG_RESULT *pResults,
                 IN OUT PLIST_ENTRY plmsgOutput,
				 IN PDOMAIN_CONTROLLER_INFOW DomainControllerInfo
    )
/*++

Routine Description:

    Prints the information returned from DsGetDcName

Arguments:

    DomainControllerInfo - Information to print

Return Value:

    None.

--*/
{
	// "                   DC: %ws\n"
    AddMessageToList( plmsgOutput,
					  Nd_Quiet,
					  IDS_DSGETDC_13210,
					  DomainControllerInfo->DomainControllerName );
	
	// "              Address: %ws\n"
    AddMessageToList( plmsgOutput,
					  Nd_Quiet,
					  IDS_DSGETDC_13211,
					  DomainControllerInfo->DomainControllerAddress );

    if ( !IsEqualGUID( &DomainControllerInfo->DomainGuid, &NlDcZeroGuid) )
	{
		WCHAR	swzGuid[64];
		StringFromGUID2(&DomainControllerInfo->DomainGuid,
						swzGuid,
						DimensionOf(swzGuid));
		
		// "        Domain Guid . . . . . . : %ws\n"
        AddMessageToList( plmsgOutput,
						  Nd_Quiet,
						  IDS_DSGETDC_13212,
						  swzGuid);
    }

    if ( DomainControllerInfo->DomainName != NULL )
	{
		// "             Dom Name: %ws\n"
        AddMessageToList( plmsgOutput,
						  Nd_Quiet,
						  IDS_DSGETDC_13214,
						  DomainControllerInfo->DomainName );
    }
	
    if ( DomainControllerInfo->DnsForestName != NULL )
	{
		// "          Forest Name: %ws\n"
		AddMessageToList( plmsgOutput,
						  Nd_Quiet,
						  IDS_DSGETDC_13215,
						  DomainControllerInfo->DnsForestName );
    }
	
    if ( DomainControllerInfo->DcSiteName != NULL )
	{
		// "         Dc Site Name: %ws\n"
        AddMessageToList( plmsgOutput,
						  Nd_Quiet,
						  IDS_DSGETDC_13216,
						  DomainControllerInfo->DcSiteName );
    }
	
    if ( DomainControllerInfo->ClientSiteName != NULL )
	{
		// "        Our Site Name: %ws\n"
        AddMessageToList( plmsgOutput,
						  Nd_Quiet,
						  IDS_DSGETDC_13217,
						  DomainControllerInfo->ClientSiteName );
    }
	
    if ( DomainControllerInfo->Flags )
	{
        ULONG LocalFlags = DomainControllerInfo->Flags;
		
		//  "                Flags:"
        AddMessageToList( plmsgOutput,
						  Nd_Quiet,
						  IDS_DSGETDC_13218 );
		
        if ( LocalFlags & DS_PDC_FLAG )
		{
			// " PDC"
            AddMessageToList( plmsgOutput,
							  Nd_Quiet,
							  (LocalFlags & DS_DS_FLAG) ? IDS_DSGETDC_13219 : IDS_DSGETDC_NT4_PDC);
            LocalFlags &= ~DS_PDC_FLAG;
        }
		
        if ( LocalFlags & DS_GC_FLAG ) {
//IDS_DSGETDC_13220                  " GC"
            AddMessageToList( plmsgOutput,
							  Nd_Quiet,
							  IDS_DSGETDC_13220);
            LocalFlags &= ~DS_GC_FLAG;
        }
        if ( LocalFlags & DS_DS_FLAG ) {
//IDS_DSGETDC_13221                  " DS"
            AddMessageToList( plmsgOutput,
							  Nd_Quiet,
							  IDS_DSGETDC_13221);
            LocalFlags &= ~DS_DS_FLAG;
        }
        if ( LocalFlags & DS_KDC_FLAG ) {
//IDS_DSGETDC_13222                  " KDC"
            AddMessageToList( plmsgOutput,
							  Nd_Quiet,
							  IDS_DSGETDC_13222);
            LocalFlags &= ~DS_KDC_FLAG;
        }
        if ( LocalFlags & DS_TIMESERV_FLAG ) {
//IDS_DSGETDC_13223                  " TIMESERV"
            AddMessageToList( plmsgOutput,
							  Nd_Quiet,
							  IDS_DSGETDC_13223);
            LocalFlags &= ~DS_TIMESERV_FLAG;
        }
        if ( LocalFlags & DS_GOOD_TIMESERV_FLAG ) {
//IDS_DSGETDC_13224                  " GTIMESERV"
            AddMessageToList( plmsgOutput,
							  Nd_Quiet,
							  IDS_DSGETDC_13224);
            LocalFlags &= ~DS_GOOD_TIMESERV_FLAG;
        }
        if ( LocalFlags & DS_WRITABLE_FLAG ) {
//IDS_DSGETDC_13225                  " WRITABLE"
            AddMessageToList( plmsgOutput,
							  Nd_Quiet,
							  IDS_DSGETDC_13225);
            LocalFlags &= ~DS_WRITABLE_FLAG;
        }
        if ( LocalFlags & DS_DNS_CONTROLLER_FLAG ) {
//IDS_DSGETDC_13226                  " DNS_DC"
            AddMessageToList( plmsgOutput,
							  Nd_Quiet,
							  IDS_DSGETDC_13226);
            LocalFlags &= ~DS_DNS_CONTROLLER_FLAG;
        }
        if ( LocalFlags & DS_DNS_DOMAIN_FLAG ) {
//IDS_DSGETDC_13227                  " DNS_DOMAIN"
            AddMessageToList( plmsgOutput,
							  Nd_Quiet,
							  IDS_DSGETDC_13227);
            LocalFlags &= ~DS_DNS_DOMAIN_FLAG;
        }
        if ( LocalFlags & DS_DNS_FOREST_FLAG ) {
//IDS_DSGETDC_13228                  " DNS_FOREST"
            AddMessageToList( plmsgOutput,
							  Nd_Quiet,
							  IDS_DSGETDC_13228);
            LocalFlags &= ~DS_DNS_FOREST_FLAG;
        }
        if ( LocalFlags & DS_CLOSEST_FLAG ) {
//IDS_DSGETDC_13229                  " CLOSE_SITE"
            AddMessageToList( plmsgOutput,
							  Nd_Quiet,
							  IDS_DSGETDC_13229);
            LocalFlags &= ~DS_CLOSEST_FLAG;
        }
        if ( LocalFlags != 0 ) {
//IDS_DSGETDC_13230                  " 0x%lX"
            AddMessageToList( plmsgOutput,
							  Nd_Quiet,
							  IDS_DSGETDC_13230,
							  LocalFlags);
        }
//IDS_DSGETDC_13231                  "\n"
        AddMessageToList( plmsgOutput,
							  Nd_Quiet,
						  IDS_DSGETDC_13231);
    }
}



NET_API_STATUS
DoDsGetDcName(IN NETDIAG_PARAMS *pParams,
			  IN OUT NETDIAG_RESULT *pResults,
              OUT PLIST_ENTRY   plmsgOutput,
			  IN PTESTED_DOMAIN pTestedDomain,
			  IN DWORD Flags,
			  IN LPTSTR pszDcType,
			  IN BOOLEAN IsFatal,
			  OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
			 )
/*++

Routine Description:

    Does a DsGetDcName

Arguments:

    plmsgOutput  -  The message list to dump output
    pTestedDomain - Domain to test

    Flags - Flags to pass to DsGetDcName

    pszDcType - English description of Flags

    IsFatal - True if failure is fatal

    DomainControllerInfo - Return Domain Controller information

Return Value:

    Status of the operation.

--*/
{
    NET_API_STATUS NetStatus;
    PDOMAIN_CONTROLLER_INFOW LocalDomainControllerInfo = NULL;
    LPSTR Severity;


    //
    // Initialization
    //

    if ( IsFatal ) {
        Severity = "[FATAL]";
    } else {
        Severity = "[WARNING]";
    }
	if ( pParams->fReallyVerbose )
	{
		//   "\n    Find %s in domain '%ws':\n"
        AddMessageToList( plmsgOutput, Nd_ReallyVerbose, IDS_DSGETDC_13232, pszDcType, pTestedDomain->PrintableDomainName );
    }

    //
    // Find a DC in the domain.
    //  Use the DsGetDcName built into nettest.
    //

    NetStatus = GetADc( pParams,
						pResults,
                        plmsgOutput,
// Commented out to port to Source Depot - smanda
#ifdef SLM_TREE
						NettestDsGetDcNameW,
#else
                        DsGetDcNameW,
#endif
                        pTestedDomain,
                        Flags,
                        DomainControllerInfo );

    if ( NetStatus != NO_ERROR )
	{
		//  "    %s Cannot find %s in domain '%ws'. [%s]\n"
        AddMessageToList( plmsgOutput,
						  Nd_Quiet,
						  IDS_DSGETDC_13233,
						  Severity,
						  pszDcType,
						  pTestedDomain->PrintableDomainName,
                          NetStatusToString(NetStatus));
		
        if ( NetStatus == ERROR_NO_SUCH_DOMAIN ) {
            if ( Flags & DS_DIRECTORY_SERVICE_REQUIRED )
		    {
			    // "\n        This isn't a problem if domain '%ws' does not have any NT 5.0 DCs.\n"
                AddMessageToList( plmsgOutput,
							      Nd_Quiet,
							      IDS_DSGETDC_13234,
							      pTestedDomain->PrintableDomainName );
            }
            else if ( Flags & DS_PDC_REQUIRED )
            {
                PrintGuruMessage2("        If the PDC for domain '%ws' is up, ", TestedDomain->PrintableDomainName );
                PrintGuru( 0, DSGETDC_GURU );
            } else
            {
                PrintGuruMessage3("        If any %s for domain '%ws' is up, ", DcType, TestedDomain->PrintableDomainName );
                PrintGuru( 0, DSGETDC_GURU );
            }
        }
        else
        {
            PrintGuru( NetStatus, DSGETDC_GURU );
        }

    //
    // If that worked,
    //  try again through netlogon this time.
    //
    }
	else
	{

        if (pParams->fReallyVerbose )
		{
			// "    Found this %s in domain '%ws':\n"
            AddMessageToList( plmsgOutput,
							  Nd_ReallyVerbose,
							  IDS_DSGETDC_13235,
							  pszDcType,
							  pTestedDomain->PrintableDomainName );
            PrintDsGetDcName( pResults, plmsgOutput, *DomainControllerInfo );
        }
		else if ( pParams->fVerbose )
		{
			// "    Found %s '%ws' in domain '%ws'.\n"
            AddMessageToList( plmsgOutput,
							  Nd_Verbose,
							  IDS_DSGETDC_13236,
							  pszDcType,
							  (*DomainControllerInfo)->DomainControllerName,
							  pTestedDomain->PrintableDomainName );
        }

        if ( ((*DomainControllerInfo)->Flags & (DS_DS_FLAG|DS_KDC_FLAG)) == DS_DS_FLAG )
		{
			// "    %s: KDC is not running on NT 5 DC '%ws' in domain '%ws'."
            AddMessageToList( plmsgOutput,
							  Nd_Quiet,
							  IDS_DSGETDC_13237,
							  Severity,
							  (*DomainControllerInfo)->DomainControllerName,
							  pTestedDomain->PrintableDomainName );
        }


        //
        // If netlogon is running,
        //  try it again using the netlogon service.
        //

        if ( pResults->Global.fNetlogonIsRunning )
		{

            NetStatus = GetADc( pParams,
								pResults,
                                plmsgOutput,
								DsGetDcNameW,
                                pTestedDomain,
                                Flags,
                                &LocalDomainControllerInfo );

            if ( NetStatus != NO_ERROR )
			{
				// "    %s: Netlogon cannot find %s in domain '%ws'. [%s]\n"
                AddMessageToList( plmsgOutput,
								  Nd_Quiet,
								  IDS_DSGETDC_13238,
								  Severity,
								  pszDcType,
								  pTestedDomain->PrintableDomainName,
                                  NetStatusToString(NetStatus));

            //
            // If that worked,
            //  sanity check the returned DC.
            //

            }
			else
			{

                if ( (LocalDomainControllerInfo->Flags & (DS_DS_FLAG|DS_KDC_FLAG)) == DS_DS_FLAG )
				{
					// "    %s: KDC is not running on NT 5 DC '%ws' in domain '%ws'."
                    AddMessageToList( plmsgOutput,
									  Nd_Quiet,
									  IDS_DSGETDC_13239,
									  Severity,
									  LocalDomainControllerInfo->DomainControllerName,
									  pTestedDomain->PrintableDomainName );
                }
            }
        }
    }

    if ( LocalDomainControllerInfo != NULL ) {
        NetApiBufferFree( LocalDomainControllerInfo );
        LocalDomainControllerInfo = NULL;
    }

    return NetStatus;
}





NET_API_STATUS
SetPrimaryGuid(
    IN GUID *GuidToSet
    )
/*++

Routine Description:

    Set the primary GUID to the specified value.

Arguments:

    GuidToSet - Guid to set as the primary GUID

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/

{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;
    LSA_HANDLE PolicyHandle = NULL;
    PPOLICY_DNS_DOMAIN_INFO PrimaryDomainInfo = NULL;
    OBJECT_ATTRIBUTES ObjAttributes;


    //
    // Open a handle to the LSA.
    //

    InitializeObjectAttributes(
        &ObjAttributes,
        NULL,
        0L,
        NULL,
        NULL
        );

    Status = LsaOpenPolicy(
                   NULL,
                   &ObjAttributes,
                   POLICY_VIEW_LOCAL_INFORMATION |
                    POLICY_TRUST_ADMIN,
                   &PolicyHandle
                   );

    if (! NT_SUCCESS(Status)) {
        NetStatus = NetpNtStatusToApiStatus(Status);
        goto Cleanup;
    }

    //
    // Get the name of the primary domain from LSA
    //

    Status = LsaQueryInformationPolicy(
                   PolicyHandle,
                   PolicyDnsDomainInformation,
                   (PVOID *) &PrimaryDomainInfo
                   );

    if (! NT_SUCCESS(Status)) {
        NetStatus = NetpNtStatusToApiStatus(Status);
        goto Cleanup;
    }

    //
    // Set the new GUID of the primary domain into the LSA
    //

    PrimaryDomainInfo->DomainGuid = *GuidToSet;

    Status = LsaSetInformationPolicy(
                   PolicyHandle,
                   PolicyDnsDomainInformation,
                   (PVOID) PrimaryDomainInfo
                   );

    if (! NT_SUCCESS(Status)) {
        NetStatus = NetpNtStatusToApiStatus(Status);
        goto Cleanup;
    }


    NetStatus = NO_ERROR;

Cleanup:
    if ( PrimaryDomainInfo != NULL ) {
        (void) LsaFreeMemory((PVOID) PrimaryDomainInfo);
    }
    if ( PolicyHandle != NULL ) {
        (void) LsaClose(PolicyHandle);
    }

    return NetStatus;

}



/*!--------------------------------------------------------------------------
	DsGetDcGlobalPrint
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void DsGetDcGlobalPrint( NETDIAG_PARAMS* pParams,
						  NETDIAG_RESULT*  pResults)
{
	if (pParams->fVerbose || !FHrOK(pResults->DsGetDc.hr))
	{
		PrintNewLine(pParams, 2);
		PrintTestTitleResult(pParams, IDS_DSGETDC_LONG, IDS_DSGETDC_SHORT, pResults->DsGetDc.fPerformed, 
							 pResults->DsGetDc.hr, 0);
		
		if (pParams->fReallyVerbose || !FHrOK(pResults->DsGetDc.hr))
			PrintMessageList(pParams, &pResults->DsGetDc.lmsgOutput);
	}

}

/*!--------------------------------------------------------------------------
	DsGetDcPerInterfacePrint
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void DsGetDcPerInterfacePrint( NETDIAG_PARAMS* pParams,
								NETDIAG_RESULT*  pResults,
								INTERFACE_RESULT *pInterfaceResults)
{
	// no per-interface results
}


/*!--------------------------------------------------------------------------
	DsGetDcCleanup
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void DsGetDcCleanup( NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
{
	MessageListCleanUp(&pResults->DsGetDc.lmsgOutput);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\format.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       format.h
//
//--------------------------------------------------------------------------

#ifndef HEADER_FORMAT
#define HEADER_FORMAT


void    PrintNewLine(NETDIAG_PARAMS *pParams, int cNewLine);
void    PrintTestTitleResult(NETDIAG_PARAMS *pParams,
                             UINT idsTestLongName,
                             UINT idsTestShortName,
                             BOOL fPerformed,
                             HRESULT hr,
                             int nIndent);
void    PrintError(NETDIAG_PARAMS *pParams, UINT idsContext, HRESULT hr);

LPTSTR  MAP_YES_NO(BOOL fYes);
LPTSTR  MAP_ON_OFF(BOOL fOn);
LPTSTR  MapWinsNodeType(UINT Parm);
LPTSTR  MapAdapterType(UINT type);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\ipcfg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ipcfg.h
//
//--------------------------------------------------------------------------

#ifndef HEADER_IPCFG
#define HEADER_IPCFG

HRESULT IpConfigTest(NETDIAG_PARAMS*  pParams,
					 NETDIAG_RESULT*  pResults);

void IpConfigCleanup(IN NETDIAG_PARAMS *pParams,
					 IN OUT NETDIAG_RESULT *pResults);


HRESULT	InitIpconfig(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults);

LONG CountInterfaces(PIP_ADAPTER_INFO ListAdapterInfo);

int AddIpAddressString(PIP_ADDR_STRING AddressList, LPSTR Address, LPSTR Mask);

VOID FreeIpAddressStringList(PIP_ADDR_STRING pAddressList);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\global.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       global.h
//
//--------------------------------------------------------------------------

#ifndef HEADER_GLOBAL
#define HEADER_GLOBAL

/*!--------------------------------------------------------------------------
	WsaInitialize
		Initialize winsock.		
	Author: NSun
 ---------------------------------------------------------------------------*/
int
WsaInitialize(
			  NETDIAG_PARAMS * pParams,
			  NETDIAG_RESULT *pResults
			 );


NET_API_STATUS
BrDgReceiverIoControl(
    IN  HANDLE FileHandle,
    IN  ULONG DgReceiverControlCode,
    IN  PLMDR_REQUEST_PACKET Drp,
    IN  ULONG DrpSize,
    IN  PVOID SecondBuffer OPTIONAL,
    IN  ULONG SecondBufferLength,
    OUT PULONG Information OPTIONAL
    );


NET_API_STATUS
DeviceControlGetInfo(
    IN  HANDLE FileHandle,
    IN  ULONG DeviceControlCode,
    IN  PVOID RequestPacket,
    IN  ULONG RequestPacketLength,
    OUT LPVOID *OutputBuffer,
    IN  ULONG PreferedMaximumLength,
    IN  ULONG BufferHintSize,
    OUT PULONG Information OPTIONAL
    );


NET_API_STATUS
OpenBrowser(
    OUT PHANDLE BrowserHandle
    );

int match( const char * p, const char * s );

LONG CountInterfaces(PIP_ADAPTER_INFO ListAdapterInfo);




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\global.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      global.c
//
//  Abstract:
//
//    Test to ensure that a workstation has network (IP) connectivity to
//      the outside.
//
//  Author:
//
//     15-Dec-1997 (cliffv)
//      Anilth  - 4-20-1998
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//    1-June-1998 (denisemi) add DnsServerHasDCRecords to check DC dns records
//                           registration
//
//    26-June-1998 (t-rajkup) add general tcp/ip , dhcp and routing,
//                            winsock, ipx, wins and netbt information.
//--

//
// Common include files.
//
#include "precomp.h"


#include "ipcfgtest.h"


/*!--------------------------------------------------------------------------
    WsaInitialize
        Initialize winsock.
    Author: NSun
 ---------------------------------------------------------------------------*/
int
WsaInitialize(
              NETDIAG_PARAMS * pParams,
              NETDIAG_RESULT *pResults
             )
{
    int         iStatus;
    WORD        wVersionRequested;
    int         err;
    WSADATA     wsaData;

    // Requesting version 1.1
    // ----------------------------------------------------------------
    wVersionRequested = MAKEWORD( 1, 1 );

    iStatus = WSAStartup( wVersionRequested, &wsaData );
    if (iStatus != 0)
    {
        PrintMessage(pParams, IDS_GLOBAL_WSA_WSAStartup_Failed);
//      TracePrintf(_T("WSAStartup (1.1) failed with WinSock error %d"),
//              iStatus);
        return iStatus;
    }

    if ( (LOBYTE( wsaData.wVersion ) != 1) ||
         (HIBYTE( wsaData.wVersion ) != 1) )
    {
        WSACleanup();
        PrintMessage(pParams, IDS_GLOBAL_WSA_BadWSAVersion,
                     wsaData.wVersion);
        return WSANOTINITIALISED;
    }

    // Set the results of the WSA call into the results structure
    // ----------------------------------------------------------------
    pResults->Global.wsaData = wsaData;

    return NO_ERROR;
}





NET_API_STATUS
BrDgReceiverIoControl(
    IN  HANDLE FileHandle,
    IN  ULONG DgReceiverControlCode,
    IN  PLMDR_REQUEST_PACKET Drp,
    IN  ULONG DrpSize,
    IN  PVOID SecondBuffer OPTIONAL,
    IN  ULONG SecondBufferLength,
    OUT PULONG Information OPTIONAL
    )
/*++

Routine Description:

Arguments:

    FileHandle - Supplies a handle to the file or device on which the service
        is being performed.

    DgReceiverControlCode - Supplies the NtDeviceIoControlFile function code
        given to the datagram receiver.

    Drp - Supplies the datagram receiver request packet.

    DrpSize - Supplies the length of the datagram receiver request packet.

    SecondBuffer - Supplies the second buffer in call to NtDeviceIoControlFile.

    SecondBufferLength - Supplies the length of the second buffer.

    Information - Returns the information field of the I/O status block.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/

{
    NTSTATUS ntstatus;
    IO_STATUS_BLOCK IoStatusBlock;
    PLMDR_REQUEST_PACKET RealDrp;
    HANDLE CompletionEvent;
    LPBYTE Where;

    if (FileHandle == NULL) {
        return ERROR_NOT_SUPPORTED;
    }

    //
    // Allocate a copy of the request packet where we can put the transport and
    //  emulated domain name in the packet itself.
    //
    RealDrp = Malloc(     DrpSize+
                          Drp->TransportName.Length+sizeof(WCHAR)+
                          Drp->EmulatedDomainName.Length+sizeof(WCHAR) );

    if (RealDrp == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    ZeroMemory( RealDrp, DrpSize+
                         Drp->TransportName.Length+sizeof(WCHAR)+
                         Drp->EmulatedDomainName.Length+sizeof(WCHAR) );

    //
    // Copy the request packet into the local copy.
    //
    RtlCopyMemory(RealDrp, Drp, DrpSize);
    RealDrp->Version = LMDR_REQUEST_PACKET_VERSION_DOM;

    Where = (LPBYTE)RealDrp+DrpSize;
    if (Drp->TransportName.Length != 0) {
        RealDrp->TransportName.Buffer = (LPWSTR)Where;
        RealDrp->TransportName.MaximumLength = Drp->TransportName.Length+sizeof(WCHAR);
        RtlCopyUnicodeString(&RealDrp->TransportName, &Drp->TransportName);
        Where += RealDrp->TransportName.MaximumLength;
    }

    if (Drp->EmulatedDomainName.Length != 0) {
        RealDrp->EmulatedDomainName.Buffer = (LPWSTR)Where;
        RealDrp->EmulatedDomainName.MaximumLength = Drp->EmulatedDomainName.Length+sizeof(WCHAR);
        RtlCopyUnicodeString(&RealDrp->EmulatedDomainName, &Drp->EmulatedDomainName);
        Where += RealDrp->EmulatedDomainName.MaximumLength;
    }



    //
    // Create a completion event
    //
    CompletionEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    if (CompletionEvent == NULL) {

        Free(RealDrp);

        return(GetLastError());
    }

    //
    // Send the request to the Datagram Receiver DD.
    //

    ntstatus = NtDeviceIoControlFile(
                   FileHandle,
                   CompletionEvent,
                   NULL,
                   NULL,
                   &IoStatusBlock,
                   DgReceiverControlCode,
                   RealDrp,
                   (ULONG)(Where-(LPBYTE)RealDrp),
                   SecondBuffer,
                   SecondBufferLength
                   );

    if (NT_SUCCESS(ntstatus)) {

        //
        //  If pending was returned, then wait until the request completes.
        //

        if (ntstatus == STATUS_PENDING) {

            do {
                ntstatus = WaitForSingleObjectEx(CompletionEvent, 0xffffffff, TRUE);
            } while ( ntstatus == WAIT_IO_COMPLETION );
        }


        if (NT_SUCCESS(ntstatus)) {
            ntstatus = IoStatusBlock.Status;
        }
    }

    if (ARGUMENT_PRESENT(Information)) {
        *Information = (ULONG)IoStatusBlock.Information;
    }

    Free(RealDrp);

    CloseHandle(CompletionEvent);

    return NetpNtStatusToApiStatus(ntstatus);
}

NET_API_STATUS
DeviceControlGetInfo(
    IN  HANDLE FileHandle,
    IN  ULONG DeviceControlCode,
    IN  PVOID RequestPacket,
    IN  ULONG RequestPacketLength,
    OUT LPVOID *OutputBuffer,
    IN  ULONG PreferedMaximumLength,
    IN  ULONG BufferHintSize,
    OUT PULONG Information OPTIONAL
    )
/*++

Routine Description:

    This function allocates the buffer and fill it with the information
    that is retrieved from the datagram receiver.

Arguments:

    DeviceDriverType - Supplies the value which indicates whether to call
        the datagram receiver.

    FileHandle - Supplies a handle to the file or device of which to get
        information about.

    DeviceControlCode - Supplies the NtFsControlFile or NtIoDeviceControlFile
        function control code.

    RequestPacket - Supplies a pointer to the device request packet.

    RrequestPacketLength - Supplies the length of the device request packet.

    OutputBuffer - Returns a pointer to the buffer allocated by this routine
        which contains the use information requested.  This pointer is set to
         NULL if return code is not NERR_Success.

    PreferedMaximumLength - Supplies the number of bytes of information to
        return in the buffer.  If this value is MAXULONG, we will try to
        return all available information if there is enough memory resource.

    BufferHintSize - Supplies the hint size of the output buffer so that the
        memory allocated for the initial buffer will most likely be large
        enough to hold all requested data.

    Information - Returns the information code from the NtFsControlFile or
        NtIoDeviceControlFile call.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status;
    NTSTATUS ntstatus;
    DWORD OutputBufferLength;
    DWORD TotalBytesNeeded = 1;
    ULONG OriginalResumeKey;
    IO_STATUS_BLOCK IoStatusBlock;
    PLMDR_REQUEST_PACKET Drrp = (PLMDR_REQUEST_PACKET) RequestPacket;
    HANDLE CompletionEvent;

#define INITIAL_ALLOCATION_SIZE  48*1024  // First attempt size (48K)
#define FUDGE_FACTOR_SIZE        1024  // Second try TotalBytesNeeded
                                       //     plus this amount

    OriginalResumeKey = Drrp->Parameters.EnumerateNames.ResumeHandle;

    //
    // If PreferedMaximumLength is MAXULONG, then we are supposed to get all
    // the information, regardless of size.  Allocate the output buffer of a
    // reasonable size and try to use it.  If this fails, the Redirector FSD
    // will say how much we need to allocate.
    //
    if (PreferedMaximumLength == MAXULONG) {
        OutputBufferLength = (BufferHintSize) ?
                             BufferHintSize :
                             INITIAL_ALLOCATION_SIZE;
    }
    else {
        OutputBufferLength = PreferedMaximumLength;
    }

    OutputBufferLength = ROUND_UP_COUNT(OutputBufferLength, ALIGN_WCHAR);

    if ((*OutputBuffer = LocalAlloc( LMEM_ZEROINIT, OutputBufferLength)) == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    CompletionEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    if (CompletionEvent == (HANDLE)-1) {
        LocalFree(*OutputBuffer);
        *OutputBuffer = NULL;
        return(GetLastError());
    }

    Drrp->Parameters.EnumerateServers.EntriesRead = 0;

    //
    // Make the request of the Datagram Receiver
    //

    ntstatus = NtDeviceIoControlFile(
                     FileHandle,
                     CompletionEvent,
                     NULL,              // APC routine
                     NULL,              // APC context
                     &IoStatusBlock,
                     DeviceControlCode,
                     Drrp,
                     RequestPacketLength,
                     *OutputBuffer,
                     OutputBufferLength
                     );

    if (NT_SUCCESS(ntstatus)) {

        //
        //  If pending was returned, then wait until the request completes.
        //

        if (ntstatus == STATUS_PENDING) {
            do {
                ntstatus = WaitForSingleObjectEx(CompletionEvent, 0xffffffff, TRUE);
            } while ( ntstatus == WAIT_IO_COMPLETION );
        }

        if (NT_SUCCESS(ntstatus)) {
            ntstatus = IoStatusBlock.Status;
        }
    }

    //
    // Map NT status to Win error
    //
    status = NetpNtStatusToApiStatus(ntstatus);

    if (status == ERROR_MORE_DATA) {

        ASSERT(
                FIELD_OFFSET(
                    LMDR_REQUEST_PACKET,
                    Parameters.EnumerateNames.TotalBytesNeeded
                    ) ==
                FIELD_OFFSET(
                    LMDR_REQUEST_PACKET,
                    Parameters.EnumerateServers.TotalBytesNeeded
                    )
                );

        ASSERT(
                FIELD_OFFSET(
                    LMDR_REQUEST_PACKET,
                    Parameters.GetBrowserServerList.TotalBytesNeeded
                    ) ==
                FIELD_OFFSET(
                    LMDR_REQUEST_PACKET,
                    Parameters.EnumerateServers.TotalBytesNeeded
                    )
                );

        TotalBytesNeeded = Drrp->Parameters.EnumerateNames.TotalBytesNeeded;
    }

    if ((TotalBytesNeeded > OutputBufferLength) &&
        (PreferedMaximumLength == MAXULONG)) {
        PLMDR_REQUEST_PACKET Drrp = (PLMDR_REQUEST_PACKET) RequestPacket;

        //
        // Initial output buffer allocated was too small and we need to return
        // all data.  First free the output buffer before allocating the
        // required size plus a fudge factor just in case the amount of data
        // grew.
        //

        LocalFree(*OutputBuffer);

        OutputBufferLength =
            ROUND_UP_COUNT((TotalBytesNeeded + FUDGE_FACTOR_SIZE),
                           ALIGN_WCHAR);

        if ((*OutputBuffer = LocalAlloc(LMEM_ZEROINIT, OutputBufferLength)) == NULL) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }


        ASSERT(
                FIELD_OFFSET(
                    LMDR_REQUEST_PACKET,
                    Parameters.EnumerateNames.ResumeHandle
                    ) ==
                FIELD_OFFSET(
                    LMDR_REQUEST_PACKET,
                    Parameters.EnumerateServers.ResumeHandle
                    )
                );

        ASSERT(
                FIELD_OFFSET(
                    LMDR_REQUEST_PACKET,
                    Parameters.EnumerateNames.ResumeHandle
                    ) ==
                FIELD_OFFSET(
                    LMDR_REQUEST_PACKET,
                    Parameters.GetBrowserServerList.ResumeHandle
                    )
                );

        Drrp->Parameters.EnumerateNames.ResumeHandle = OriginalResumeKey;
        Drrp->Parameters.EnumerateServers.EntriesRead = 0;

        //
        //  Make the request of the Datagram Receiver
        //

        ntstatus = NtDeviceIoControlFile(
                         FileHandle,
                         CompletionEvent,
                         NULL,              // APC routine
                         NULL,              // APC context
                         &IoStatusBlock,
                         DeviceControlCode,
                         Drrp,
                         RequestPacketLength,
                         *OutputBuffer,
                         OutputBufferLength
                         );

        if (NT_SUCCESS(ntstatus)) {

            //
            //  If pending was returned, then wait until the request completes.
            //

            if (ntstatus == STATUS_PENDING) {
                do {
                    ntstatus = WaitForSingleObjectEx(CompletionEvent, 0xffffffff, TRUE);
                } while ( ntstatus == WAIT_IO_COMPLETION );
            }

            if (NT_SUCCESS(ntstatus)) {
                ntstatus = IoStatusBlock.Status;
            }
        }

        status = NetpNtStatusToApiStatus(ntstatus);

    }


    //
    // If not successful in getting any data, or if the caller asked for
    // all available data with PreferedMaximumLength == MAXULONG and
    // our buffer overflowed, free the output buffer and set its pointer
    // to NULL.
    //
    if ((status != NERR_Success && status != ERROR_MORE_DATA) ||
        (TotalBytesNeeded == 0) ||
        (PreferedMaximumLength == MAXULONG && status == ERROR_MORE_DATA) ||
        (Drrp->Parameters.EnumerateServers.EntriesRead == 0)) {

        LocalFree(*OutputBuffer);
        *OutputBuffer = NULL;

        //
        // PreferedMaximumLength == MAXULONG and buffer overflowed means
        // we do not have enough memory to satisfy the request.
        //
        if (status == ERROR_MORE_DATA) {
            status = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    CloseHandle(CompletionEvent);

    return status;

    UNREFERENCED_PARAMETER(Information);
}

NET_API_STATUS
OpenBrowser(
    OUT PHANDLE BrowserHandle
    )
/*++

Routine Description:

    This function opens a handle to the bowser device driver.

Arguments:

    OUT PHANDLE BrowserHandle - Returns the handle to the browser.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NTSTATUS Status;

    UNICODE_STRING DeviceName;

    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;


    //
    // Open the redirector device.
    //
    RtlInitUnicodeString(&DeviceName, DD_BROWSER_DEVICE_NAME_U);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &DeviceName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenFile(
                   BrowserHandle,
                   SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE,
                   &ObjectAttributes,
                   &IoStatusBlock,
                   FILE_SHARE_READ | FILE_SHARE_WRITE,
                   FILE_SYNCHRONOUS_IO_NONALERT
                   );

    if (NT_SUCCESS(Status)) {
        Status = IoStatusBlock.Status;
    }

    return NetpNtStatusToApiStatus(Status);

}






// ========================================================================
// * matches one or more chars, eg. match( "a*b", "a..b" ).
// ? matches exactly one char,  eg. match( "a?b", "a.b" ).

int match( const char * p, const char * s )
/*++
Routine Description:
This routine is used to compare addresses.
Author:
 07/01/98 Rajkumar
--*/
{
    switch( *p ){
        case '\0' : return ! *s ;
        case '*'  : return match( p+1, s ) || *s && match( p, s+1 );
        case '?'  : return *s && match( p+1, s+1 );
        default   : return *p == *s && match( p+1, s+1 );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\format.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      format.c
//
//  Abstract:
//
//    Test to ensure that a workstation has network (IP) connectivity to
//		the outside.
//
//  Author:
//
//     15-Dec-1997 (cliffv)
//      Anilth	- 4-20-1998 
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//    1-June-1998 (denisemi) add DnsServerHasDCRecords to check DC dns records
//                           registration
//
//    26-June-1998 (t-rajkup) add general tcp/ip , dhcp and routing,
//                            winsock, ipx, wins and netbt information. 
//--

//
// Common include files.
//
#include "precomp.h"


#include "ipcfgtest.h"


void FormatWin32Error(DWORD dwErr, TCHAR *pszBuffer, UINT cchBuffer)
{
	DWORD	dwErrMsg;
	
	assert(dwErr != ERROR_SUCCESS);

	dwErrMsg = FormatMessage(
							 FORMAT_MESSAGE_FROM_SYSTEM,
							 NULL,
							 dwErr,
							 0,
							 pszBuffer,
							 cchBuffer,
							 NULL);
	pszBuffer[cchBuffer-1] = 0;

}


static TCHAR	s_szPass[32] = _T("");
static TCHAR	s_szFail[32] = _T("");
static TCHAR	s_szSkip[32] = _T("");

void PrintTestTitleResult(NETDIAG_PARAMS *pParams, UINT idsTestLongName, UINT idsTestShortName,
						  BOOL fPerformed, HRESULT hr, int nIndent)
{
	TCHAR	szBuffer[256];
	TCHAR	szTitle[256];
	TCHAR	szTitleTest[256];
	LPTSTR	pszPassFail = NULL;
	int		cch, i;
	TCHAR	szContactInfo[MAX_CONTACT_STRING] = _T("");

	if (s_szPass[0] == 0)
	{
		LoadString(NULL, IDS_GLOBAL_PASS, s_szPass, DimensionOf(s_szPass));
		LoadString(NULL, IDS_GLOBAL_FAIL, s_szFail, DimensionOf(s_szFail));
		LoadString(NULL, IDS_GLOBAL_SKIP, s_szSkip, DimensionOf(s_szSkip));
	}

	// Fill the buffer up with ' .'
	for ( i=0; i<DimensionOf(szBuffer); i+= 2)
	{
		szBuffer[i] = _T(' ');
		szBuffer[i+1] = _T('.');
	}

	// Fill up the indents
	for ( i=0; i<nIndent; i++)
		szBuffer[i] = _T(' ');

	// Add the test name
	LoadString(NULL, idsTestLongName, szTitle,
			   DimensionOf(szTitle));
	szTitle[DimensionOf(szTitle)-1] = 0;

	wsprintf(szTitleTest, _T("%s test"), szTitle);

	cch = StrLen(szTitleTest);

	// Do NOT use StrCpyN or lstrcpyn here!
	// They will automatically fill in a terminating NULl character
	// which I do not want.
	_tcsncpy(szBuffer+nIndent, szTitleTest, cch);

	if (!fPerformed)
		pszPassFail = s_szSkip;
	else
	{
		if (FHrOK(hr))
			pszPassFail = s_szPass;
		else
		{
			TCHAR	szTitleShort[256];
			pszPassFail = s_szFail;

			LoadString(NULL, idsTestShortName, szTitleShort,
						DimensionOf(szTitleShort));
			LoadContact(szTitleShort, szContactInfo, DimensionOf(szContactInfo));
		}
	}


	if ((nIndent + cch) > 35)
		wsprintf(szBuffer+nIndent+cch, _T(": %s\n"), pszPassFail);
	else
		wsprintf(szBuffer+35, _T(": %s\n"), pszPassFail);

	PrintMessageSz(pParams, szBuffer);

	//print the contact info if any
	if (_tcslen(szContactInfo))
	{

		// Fill up the indents
		for ( i=0; i<nIndent; i++)
		{
			szBuffer[i] = _T(' ');
		}

		szBuffer[i] = 0;

		PrintMessageSz(pParams, szBuffer);

		PrintMessage(pParams, IDS_CONTACT, szContactInfo);
	}
}


void PrintNewLine(NETDIAG_PARAMS *pParams, int cNewLine)
{
	int		i;
	for ( i=0; i<cNewLine; i++)
		PrintMessageSz(pParams, _T("\n"));
}

LPTSTR MAP_YES_NO(BOOL fYes)
{
	static	TCHAR	s_szYes[64] = _T("");
	static	TCHAR	s_szNo[64] = _T("");

	if (s_szYes[0] == 0)
	{
		LoadString(NULL, IDS_GLOBAL_YES, s_szYes, DimensionOf(s_szYes));
		LoadString(NULL, IDS_GLOBAL_NO, s_szNo, DimensionOf(s_szNo));
	}

	return fYes ? s_szYes : s_szNo;
}


LPTSTR MAP_ON_OFF(BOOL fOn)
{
	static	TCHAR	s_szOn[64] = _T("");
	static	TCHAR	s_szOff[64] = _T("");

	if (s_szOn[0] == 0)
	{
		LoadString(NULL, IDS_GLOBAL_ON, s_szOn, DimensionOf(s_szOn));
		LoadString(NULL, IDS_GLOBAL_OFF, s_szOff, DimensionOf(s_szOff));
	}

	return fOn ? s_szOn : s_szOff;
}


LPTSTR MapWinsNodeType(UINT Parm)
{
	static	BOOL s_fMapWinsNodeTypeInit = FALSE;
	static	LPTSTR s_pszWinsNodeType[LAST_NODE_TYPE+1];
    DWORD dwParm = LAST_NODE_TYPE + 1;


	if (!s_fMapWinsNodeTypeInit)
	{
		s_fMapWinsNodeTypeInit = TRUE;

		// Load all of the strings, (they can be leaked)
		s_pszWinsNodeType[0] = NULL;
		s_pszWinsNodeType[1] = LoadAndAllocString(IDS_GLOBAL_BROADCAST_NODE);
		s_pszWinsNodeType[2] = LoadAndAllocString(IDS_GLOBAL_PEER_PEER_NODE);
		s_pszWinsNodeType[3] = LoadAndAllocString(IDS_GLOBAL_MIXED_NODE);
		s_pszWinsNodeType[4] = LoadAndAllocString(IDS_GLOBAL_HYBRID_NODE);
		assert(LAST_NODE_TYPE == 4);
	}
			
    //
    // 1, 2, 4, 8 => log2(n) + 1 [1, 2, 3, 4]
    //

    switch (Parm) {
    case 0:

        //
        // according to JStew value of 0 will be treated as BNode (default)
        //

    case BNODE:
        dwParm = 1;
        break;

    case PNODE:
        dwParm = 2;
        break;

    case MNODE:
        dwParm = 3;
        break;

    case HNODE:
        dwParm = 4;
        break;
    }
    if ((dwParm >= FIRST_NODE_TYPE) && (dwParm <= LAST_NODE_TYPE)) {
        return s_pszWinsNodeType[dwParm];
    }

    //
    // if no node type is defined then we default to Hybrid
    //

    return s_pszWinsNodeType[LAST_NODE_TYPE];
}

#define MAX_ADAPTER_TYPES	8

LPTSTR MapAdapterType(UINT type)
{
	static	BOOL	s_fInitMapAdapterType = FALSE;
	static	LPTSTR	s_pszAdapterTypes[MAX_ADAPTER_TYPES];

	if (!s_fInitMapAdapterType)
	{
		s_fInitMapAdapterType = TRUE;

		s_pszAdapterTypes[0] = LoadAndAllocString(IDS_GLOBAL_ADAPTER_OTHER);
		s_pszAdapterTypes[1] = LoadAndAllocString(IDS_GLOBAL_ADAPTER_ETHERNET);
		s_pszAdapterTypes[2] = LoadAndAllocString(IDS_GLOBAL_ADAPTER_TOKEN_RING);
		s_pszAdapterTypes[3] = LoadAndAllocString(IDS_GLOBAL_ADAPTER_FDDI);
		s_pszAdapterTypes[4] = LoadAndAllocString(IDS_GLOBAL_ADAPTER_PPP);
		s_pszAdapterTypes[5] = LoadAndAllocString(IDS_GLOBAL_ADAPTER_LOOPBACK);
		s_pszAdapterTypes[6] = LoadAndAllocString(IDS_GLOBAL_ADAPTER_SLIP);
		s_pszAdapterTypes[7] = LoadAndAllocString(IDS_GLOBAL_ADAPTER_UNKNOWN);
	}
			
    switch (type)
	{
		case IF_TYPE_OTHER:
			return s_pszAdapterTypes[0];

		case IF_TYPE_ETHERNET_CSMACD:
			return s_pszAdapterTypes[1];

		case IF_TYPE_ISO88025_TOKENRING:
			return s_pszAdapterTypes[2];
			
		case IF_TYPE_FDDI:
			return s_pszAdapterTypes[3];

		case IF_TYPE_PPP:
			return s_pszAdapterTypes[4];
			
		case IF_TYPE_SOFTWARE_LOOPBACK:
			return s_pszAdapterTypes[5];
			
		case IF_TYPE_SLIP:
			return s_pszAdapterTypes[6];
			
		default:
			return s_pszAdapterTypes[7];
	}
    return _T("");
}

void PrintError(NETDIAG_PARAMS *pParams, UINT idsContext, HRESULT hr)
{

	PTSTR	ptzSysMsg = NULL;
	UINT cch = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, 
					NULL, hr, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
					(PTSTR)&ptzSysMsg, 0, NULL);

	if (!cch)	// not found with system
    {
		TCHAR	t[20]; 
    	
		_ultot(hr, t, 16);
		PrintMessage(pParams, idsContext, ptzSysMsg);
	}
	else
	{
		PrintMessage(pParams, idsContext, ptzSysMsg);
		LocalFree(ptzSysMsg);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\ipcfg.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      ipcfg.c
//
//  Abstract:
//
//      Queries into network drivers
//
//  Author:
//
//      Anilth	- 4-20-1998 
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//--

#include "precomp.h"
#include "ipcfg.h"
#include "regutil.h"
#include "mprapi.h"		// for friendly-name interface mapping
#include "strings.h"

LPTSTR MapScopeId(PVOID Param);
LPTSTR MapAdapterType(UINT type);
LPTSTR MapAdapterAddress(PIP_ADAPTER_INFO pAdapterInfo, LPTSTR Buffer);
VOID PingDhcpServer(NETDIAG_PARAMS *pParams, IPCONFIG_TST *pIpConfig);
VOID PingWinsServers(NETDIAG_PARAMS *pParams, IPCONFIG_TST *pIpConfig);


/*==========================< Iphlpapi functions >===========================*/

DWORD GetAdaptersInfo(
    PIP_ADAPTER_INFO pAdapterInfo,
    PULONG pOutBufLen
  );

DWORD GetNetworkParams(
    PFIXED_INFO pFixedInfo,
    PULONG pOutBufLen
  );
// -----------------------------------------------------------------
HRESULT GetAdditionalInfo(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults);




HRESULT
IpConfigTest(
  NETDIAG_PARAMS*  pParams,
  NETDIAG_RESULT*  pResults
 )
{
	HRESULT		hr = hrOK;
	int			i;
	IP_ADAPTER_INFO	*	pIpAdapterInfo;
	IPCONFIG_TST *	pIpConfig;
	ULONG			uDefGateway, uAddress, uMask;
	DWORD			dwDefGateway, dwAddress, dwMask;
	
	hr = InitIpconfig(pParams, pResults);
	if (!FHrSucceeded(hr))
	{
		// "Cannot retrieve IP configuration from registry!\n"
		PrintDebug(pParams, 0, IDS_IPCFG_CANNOT_GET_IP_INFO);
		return hr;
    }

	for ( i = 0; i<pResults->cNumInterfaces; i++)
	{
		pIpConfig = &pResults->pArrayInterface[i].IpConfig;
		pIpAdapterInfo = pIpConfig->pAdapterInfo;

		if (!pResults->pArrayInterface[i].IpConfig.fActive ||
			NETCARD_DISCONNECTED == pResults->pArrayInterface[i].dwNetCardStatus)
			continue;

		// Ping the DHCP server
		if (pIpAdapterInfo->DhcpEnabled)
		{
			if (!ZERO_IP_ADDRESS(pIpAdapterInfo->DhcpServer.IpAddress.String))
				PingDhcpServer(pParams,	pIpConfig);
			else
			{
				pIpConfig->hrPingDhcpServer = E_FAIL;
				pIpConfig->hr = E_FAIL;
				// "            [WARNING] Though, the card is Dhcp Enabled, you dont have a valid DHCP server address for the card.\n"
				SetMessage(&pIpConfig->msgPingDhcpServer,
						   Nd_Quiet,
						   IDS_IPCFG_INVALID_DHCP_ADDRESS);
			}
		}

		if (pResults->pArrayInterface[i].fNbtEnabled)
		{
			// Ping the primary and secondary WINS servers
			PingWinsServers(pParams, pIpConfig);
		}


        if(pIpAdapterInfo->GatewayList.IpAddress.String[0] != 0)
        {
		    // If the default gateway is defined, 
		    // then test to see if the gateway is on the same subnet as our IP address
		    //
		    uDefGateway = inet_addrA(pIpAdapterInfo->GatewayList.IpAddress.String);
		    uAddress = inet_addrA(pIpAdapterInfo->IpAddressList.IpAddress.String);
		    uMask = inet_addrA(pIpAdapterInfo->IpAddressList.IpMask.String);
		    
		    dwDefGateway = ntohl(uDefGateway);
		    dwAddress = ntohl(uAddress);
		    dwMask = ntohl(uMask);
		    
		    if ((dwDefGateway & dwMask) != (dwAddress & dwMask))
		    {
			    pIpConfig->hr = E_FAIL;
			    pIpConfig->hrDefGwSubnetCheck = E_FAIL;
		    }
        }
		
	}
   
	return hr;
}


LPTSTR MapScopeId(PVOID Param)
{
    return !strcmp((LPTSTR)Param, _T("*")) ? _T("") : (LPTSTR)Param;
}

#define dim(X) (sizeof(X)/sizeof((X)[0]))

/*!--------------------------------------------------------------------------
	MapGuidToServiceName
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
LPTSTR MapGuidToServiceName(LPCTSTR pszServiceGuid)
{
    DWORD dwRetVal = ERROR_SUCCESS;
    static TCHAR s_szServiceName[MAX_ALLOWED_ADAPTER_NAME_LENGTH + 1];
    WCHAR swzServiceGuid[256], swzServiceName[256];

	// Copy guid into return buffer
	lstrcpyn(s_szServiceName, pszServiceGuid, DimensionOf(s_szServiceName));

    if( NULL == pfnGuidToFriendlyName )
		return s_szServiceName;

	StrCpyWFromT(swzServiceGuid, pszServiceGuid);

    if( !pfnGuidToFriendlyName(swzServiceGuid,
							swzServiceName,
							DimensionOf(swzServiceName)) )
	{
		StrnCpyTFromW(s_szServiceName, swzServiceName, DimensionOf(s_szServiceName));
    }

	return s_szServiceName;
}

/*!--------------------------------------------------------------------------
	MapGuidToServiceNameW
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
LPWSTR MapGuidToServiceNameW(LPCWSTR pswzServiceGuid)
{
    DWORD dwRetVal = ERROR_SUCCESS;
    static WCHAR s_swzServiceName[1024];

	// Copy guid into return buffer
	StrnCpyW(s_swzServiceName, pswzServiceGuid, DimensionOf(s_swzServiceName));

    if (NULL == pfnGuidToFriendlyName)
        return s_swzServiceName;

	if (ERROR_SUCCESS != pfnGuidToFriendlyName((LPWSTR) pswzServiceGuid,
						   s_swzServiceName,
						   DimensionOf(s_swzServiceName)) )
    {
        //we still want to keep the GUID as service name if cannot find the friendly name
        StrnCpyW(s_swzServiceName, pswzServiceGuid, DimensionOf(s_swzServiceName));
    }

    return s_swzServiceName;
}

/*!--------------------------------------------------------------------------
	MapGuidToAdapterName
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
LPTSTR MapGuidToAdapterName(LPCTSTR pszAdapterGuid)
{
	HANDLE	hConfig;
    WCHAR swzAdapterGuid[256], swzAdapterName[256];
	static TCHAR s_szAdapterName[1024];
	HRESULT	hr = hrOK;

	// Copy guid into return buffer
	StrnCpy(s_szAdapterName, pszAdapterGuid, DimensionOf(s_szAdapterName));

	StrnCpyWFromT(swzAdapterGuid, pszAdapterGuid, DimensionOf(swzAdapterGuid));

	CheckErr( MprConfigServerConnect(NULL, &hConfig) );
	CheckErr( MprConfigGetFriendlyName(hConfig, swzAdapterGuid,
									   swzAdapterName,
									   sizeof(swzAdapterName)
									  ) );
	MprConfigServerDisconnect(hConfig);

	StrnCpyTFromW(s_szAdapterName, swzAdapterName, DimensionOf(s_szAdapterName));

Error:
    return s_szAdapterName;
}

void
PingDhcpServer(
			   NETDIAG_PARAMS *pParams,
			   IPCONFIG_TST *pIpConfig)
{

	PrintStatusMessage(pParams, 4, IDS_IPCFG_STATUS_MSG);
	
	if (IsIcmpResponseA(pIpConfig->pAdapterInfo->DhcpServer.IpAddress.String))
	{
		pIpConfig->hrPingDhcpServer = S_OK;

		PrintStatusMessage(pParams,0, IDS_GLOBAL_PASS_NL);

		// "            Pinging DHCP server - reachable\n"
		SetMessage(&pIpConfig->msgPingDhcpServer,
				   Nd_ReallyVerbose,
				   IDS_IPCFG_PING_DHCP_OK);
	}
	else
	{
		pIpConfig->hrPingDhcpServer = S_FALSE;
		if (FHrSucceeded(pIpConfig->hr))
			pIpConfig->hr = S_FALSE;

		PrintStatusMessage(pParams,0, IDS_GLOBAL_FAIL_NL);

		// "            Pinging DHCP server  - not reachable\n"
		// "            WARNING: DHCP server may be down.\n"
		SetMessage(&pIpConfig->msgPingDhcpServer,
				   Nd_Quiet,
				   IDS_IPCFG_PING_DHCP_BAD);
	}
}

VOID
PingWinsServers(
				NETDIAG_PARAMS*  pParams,
				IPCONFIG_TST *pIpConfig)
{
	TCHAR	szBuffer[256];
	
	if (!ZERO_IP_ADDRESS(pIpConfig->pAdapterInfo->PrimaryWinsServer.IpAddress.String))
	{
		PrintStatusMessage(pParams,4, IDS_IPCFG_WINS_STATUS_MSG);
	
		if (IsIcmpResponseA(pIpConfig->pAdapterInfo->PrimaryWinsServer.IpAddress.String))
		{
			pIpConfig->hrPingPrimaryWinsServer = S_OK;

			PrintStatusMessage(pParams,0, IDS_GLOBAL_PASS_NL);

			// "            Pinging Primary WINS Server %s - reachable\n"
			SetMessage(&pIpConfig->msgPingPrimaryWinsServer,
					   Nd_ReallyVerbose,
					   IDS_IPCFG_PING_WINS,
					   pIpConfig->pAdapterInfo->PrimaryWinsServer.IpAddress.String);
					   
		}
		else
		{
			pIpConfig->hrPingPrimaryWinsServer = S_FALSE;
			if (FHrSucceeded(pIpConfig->hr))
				pIpConfig->hr = S_FALSE;

			PrintStatusMessage(pParams,0, IDS_GLOBAL_FAIL_NL);

			// "            Pinging Primary WINS Server %s - not reachable\n"
			SetMessage(&pIpConfig->msgPingPrimaryWinsServer,
					   Nd_Quiet,
					   IDS_IPCFG_PING_WINS_FAIL,
					   pIpConfig->pAdapterInfo->PrimaryWinsServer.IpAddress.String);
		}
	}
	
	if (!ZERO_IP_ADDRESS(pIpConfig->pAdapterInfo->SecondaryWinsServer.IpAddress.String))
	{
		PrintStatusMessage(pParams,4, IDS_IPCFG_WINS2_STATUS_MSG);
	
		if (IsIcmpResponseA(pIpConfig->pAdapterInfo->SecondaryWinsServer.IpAddress.String))
		{
			pIpConfig->hrPingSecondaryWinsServer = S_OK;

			PrintStatusMessage(pParams,0, IDS_GLOBAL_PASS_NL);

			// "            Pinging Secondary WINS Server %s - reachable\n"
			SetMessage(&pIpConfig->msgPingSecondaryWinsServer,
					   Nd_ReallyVerbose,
					   IDS_IPCFG_PING_WINS2,
					   pIpConfig->pAdapterInfo->SecondaryWinsServer.IpAddress.String);
		}
		else
		{
			pIpConfig->hrPingSecondaryWinsServer = S_FALSE;
			if (FHrSucceeded(pIpConfig->hr))
				pIpConfig->hr = S_FALSE;
		
			PrintStatusMessage(pParams,0, IDS_GLOBAL_FAIL_NL);

			// "            Pinging Secondary WINS Server %s - not reachable\n"
			SetMessage(&pIpConfig->msgPingSecondaryWinsServer,
					   Nd_Quiet,
					   IDS_IPCFG_PING_WINS2_FAIL,
					   pIpConfig->pAdapterInfo->SecondaryWinsServer.IpAddress.String);
		}
	}
	
	return;
}





LPTSTR MapAdapterAddress(PIP_ADAPTER_INFO pAdapterInfo, LPTSTR Buffer)
{

    LPTSTR format;
    int separator;
    int len;
    int i;
    LPTSTR pbuf = Buffer;
    UINT mask;

    len = min((int)pAdapterInfo->AddressLength, sizeof(pAdapterInfo->Address));

	mask = 0xff;
	separator = TRUE;
	
    switch (pAdapterInfo->Type)
	{
    case IF_TYPE_ETHERNET_CSMACD:
    case IF_TYPE_ISO88025_TOKENRING:
    case IF_TYPE_FDDI:
        format = _T("%02X");
        break;

    default:
        format = _T("%02x");
        break;
    }
	
    for (i = 0; i < len; ++i)
	{
        pbuf += wsprintf(pbuf, format, pAdapterInfo->Address[i] & mask);
        if (separator && (i != len - 1))
		{
            pbuf += wsprintf(pbuf, _T("-"));
        }
    }
    return Buffer;
}


void IpConfigCleanup(IN NETDIAG_PARAMS *pParams,
					 IN OUT NETDIAG_RESULT *pResults)
{
	int		i;
	IPCONFIG_TST *	pIpConfig;
	
	// Free up the global information
	// ----------------------------------------------------------------
	Free(pResults->IpConfig.pFixedInfo);
	pResults->IpConfig.pFixedInfo = NULL;

	// free up the list of adapters
	// ----------------------------------------------------------------
	Free(pResults->IpConfig.pAdapterInfoList);
	pResults->IpConfig.pAdapterInfoList = NULL;

	// set all of the adapter pointers to NULL
	// ----------------------------------------------------------------
	for ( i=0; i < pResults->cNumInterfaces; i++)
	{
		pIpConfig = &pResults->pArrayInterface[i].IpConfig;
		
		FreeIpAddressStringList(pIpConfig->DnsServerList.Next);
		pIpConfig->pAdapterInfo = NULL;

		ClearMessage(&pIpConfig->msgPingDhcpServer);
		ClearMessage(&pIpConfig->msgPingPrimaryWinsServer);
		ClearMessage(&pIpConfig->msgPingSecondaryWinsServer);
	}

	pResults->IpConfig.fInitIpconfigCalled = FALSE;
}




int AddIpAddressString(PIP_ADDR_STRING AddressList, LPSTR Address, LPSTR Mask)
{

    PIP_ADDR_STRING ipAddr;

    if (AddressList->IpAddress.String[0])
	{
        for (ipAddr = AddressList; ipAddr->Next; ipAddr = ipAddr->Next)
		{
            ;
        }
        ipAddr->Next = (PIP_ADDR_STRING) Malloc(sizeof(IP_ADDR_STRING));
        if (!ipAddr->Next)
		{
            return FALSE;
        }
		ZeroMemory(ipAddr->Next, sizeof(IP_ADDR_STRING));
        ipAddr = ipAddr->Next;
    }
	else
	{
        ipAddr = AddressList;
    }
	lstrcpynA(ipAddr->IpAddress.String, Address,
			  sizeof(ipAddr->IpAddress.String));
	lstrcpynA(ipAddr->IpMask.String, Mask,
			  sizeof(ipAddr->IpMask.String));
    return TRUE;
}

VOID FreeIpAddressStringList(PIP_ADDR_STRING pAddressList)
{
	PIP_ADDR_STRING	pNext;

	if (pAddressList == NULL)
		return;

	do
	{
		// get the next address
		pNext = pAddressList->Next;

		// free the current one
		Free(pAddressList);

		// move onto the next
		pAddressList = pNext;
		
	} while( pNext );

	return;
}

// Go through the ADAPTER_INFO list to count the number of interfaces
LONG CountInterfaces(PIP_ADAPTER_INFO ListAdapterInfo)
{
    LONG cNum = 0;
    PIP_ADAPTER_INFO pAdapter;
    for(pAdapter = ListAdapterInfo; pAdapter != NULL; pAdapter = pAdapter->Next) {
        cNum ++;
    }
    return cNum;
}


/*!--------------------------------------------------------------------------
	InitIpconfig

	Description:
	This function will get all the ipconfig information by using calls into 
	iphlpapi.lib.

	The iphlpapi.lib returns an IP_ADAPTER_INFO structure which doesnt contain
	many fields present int the ADAPTER_INFO structure found in ipconfig code.
	Since the majority of the code  uses ADAPTER_INFO structure, this fucntion
	will copy the values found in IP_ADAPTER_INFO  to ADAPTER_INFO.
	
	The values which are not supplied by iphlpapi.lib calls will be obtained
	by ourselves.
	
	Arguments:
	None.
	
	Author:
	05-aug-1998 (t-rajkup)
	
	Creation History:
	The function aims at breaking nettest code away from ipconfig code.
	
	Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT
InitIpconfig(IN NETDIAG_PARAMS *pParams,
			 IN OUT NETDIAG_RESULT *pResults)
{
	DWORD		dwError;
	ULONG		uSize = 0;
	int			i;
	HRESULT		hr = hrOK;
	LONG		cInterfaces;
	IP_ADAPTER_INFO	*	pIpAdapter;
	HINSTANCE	hDll;
	
	// Just initialize this once
	if (pResults->IpConfig.fInitIpconfigCalled == TRUE)
		return hrOK;
	
	// LoadLibrary the pfnGuidToFriendlyName
	// ----------------------------------------------------------------
	hDll = LoadLibrary(_T("netcfgx.dll"));
	if (hDll)
	{
		pfnGuidToFriendlyName = (PFNGUIDTOFRIENDLYNAME) GetProcAddress(hDll, "GuidToFriendlyName");
	}

	// Get the size of the FIXED_INFO structure and allocate
	// some memory for it.
	// ----------------------------------------------------------------
	GetNetworkParams(NULL, &uSize);
	pResults->IpConfig.pFixedInfo = Malloc(uSize);
	if (pResults->IpConfig.pFixedInfo == NULL)
		return E_OUTOFMEMORY;

	ZeroMemory(pResults->IpConfig.pFixedInfo, uSize);

	dwError = GetNetworkParams(pResults->IpConfig.pFixedInfo, &uSize);

	if (dwError != ERROR_SUCCESS)
	{
		TCHAR	szError[256];
		FormatWin32Error(dwError, szError, DimensionOf(szError));

		PrintMessage(pParams, IDS_GLOBAL_ERR_InitIpConfig,
					 szError, dwError);
		CheckErr( dwError );
	}
	

	// Get the per-interface information from IP
	// ----------------------------------------------------------------
	GetAdaptersInfo(NULL, &uSize);

	pResults->IpConfig.pAdapterInfoList = Malloc(uSize);
	if (pResults->IpConfig.pAdapterInfoList == NULL)
	{
		Free(pResults->IpConfig.pFixedInfo);
		CheckHr( E_OUTOFMEMORY );
	}

	ZeroMemory(pResults->IpConfig.pAdapterInfoList, uSize);

	dwError = GetAdaptersInfo(pResults->IpConfig.pAdapterInfoList, &uSize);

	if (dwError != ERROR_SUCCESS)
	{
		TCHAR	szError[256];
		FormatWin32Error(dwError, szError, DimensionOf(szError));

		PrintMessage(pParams, IDS_GLOBAL_ERR_GetAdaptersInfo,
					 szError, dwError);
		CheckErr( dwError );
	}

	   
	// Now that we have the full list, count the number of interfaces
	// and setup the per-interface section of the results structure.
	// ----------------------------------------------------------------
	cInterfaces = CountInterfaces(pResults->IpConfig.pAdapterInfoList);

	// Allocate some additional interfaces (just in case for IPX)
	// ----------------------------------------------------------------
	pResults->pArrayInterface = Malloc((cInterfaces+8) * sizeof(INTERFACE_RESULT));
	if (pResults->pArrayInterface == NULL)
		CheckHr( E_OUTOFMEMORY );
	ZeroMemory(pResults->pArrayInterface, (cInterfaces+8)*sizeof(INTERFACE_RESULT));

	// set the individual interface pointers
	// ----------------------------------------------------------------
	pResults->cNumInterfaces = cInterfaces;
	pResults->cNumInterfacesAllocated = cInterfaces + 8;
	pIpAdapter = pResults->IpConfig.pAdapterInfoList;
	for (i=0; i<cInterfaces; i++)
	{
		assert(pIpAdapter);
		pResults->pArrayInterface[i].IpConfig.pAdapterInfo = pIpAdapter;

		pResults->pArrayInterface[i].fActive = TRUE;
		pResults->pArrayInterface[i].IpConfig.fActive = TRUE;
		
		if( FLAG_DONT_SHOW_PPP_ADAPTERS &&
			(pIpAdapter->Type == IF_TYPE_PPP))
		{
			// NDIS Wan adapter... Check to see if it has got any address..
			
			if( ZERO_IP_ADDRESS(pIpAdapter->IpAddressList.IpAddress.String) )
			{
				//  No address ? Dont display this!
				pResults->pArrayInterface[i].IpConfig.fActive = FALSE;

				// If IP is not active, then don't activate the entire
				// adapter.  If IPX is active, then it can reactivate
				// the adapter.
				pResults->pArrayInterface[i].fActive = FALSE;
			}
		}

		pResults->pArrayInterface[i].pszName = StrDup(pIpAdapter->AdapterName);

		pResults->pArrayInterface[i].pszFriendlyName =
			StrDup( MapGuidToAdapterName(pIpAdapter->AdapterName) );

		pIpAdapter = pIpAdapter->Next;   
	}
	
	// Read the rest of the per adapter information not provided by
	// GetAdaptersInfo
	// ----------------------------------------------------------------
	CheckHr( GetAdditionalInfo(pParams, pResults) );


	pResults->IpConfig.fInitIpconfigCalled = TRUE;
	pResults->IpConfig.fEnabled = TRUE;

Error:
	if (!FHrSucceeded(hr))
	{
		pResults->IpConfig.fEnabled = FALSE;
		IpConfigCleanup(pParams, pResults);
	}
	return hr;
}


DWORD GetNetbiosOptions(LPSTR paszAdapterName, BOOL * pfNbtOptions)
{
	HANDLE h;
    OBJECT_ATTRIBUTES objAttr;
    IO_STATUS_BLOCK iosb;
    STRING name;
    UNICODE_STRING uname;
    NTSTATUS status;
	char path[MAX_PATH];
	tWINS_NODE_INFO NodeInfo;    

	strcpy(path, "\\Device\\NetBT_Tcpip_");
    strcat(path, paszAdapterName);

    RtlInitString(&name, path);
    RtlAnsiStringToUnicodeString(&uname, &name, TRUE);

    InitializeObjectAttributes(
        &objAttr,
        &uname,
        OBJ_CASE_INSENSITIVE,
        (HANDLE)NULL,
        (PSECURITY_DESCRIPTOR)NULL
        );

    status = NtCreateFile(&h,
                          SYNCHRONIZE | GENERIC_EXECUTE,
                          &objAttr,
                          &iosb,
                          NULL,
                          FILE_ATTRIBUTE_NORMAL,
                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                          FILE_OPEN_IF,
                          0,
                          NULL,
                          0
                          );

    RtlFreeUnicodeString(&uname);

    if (!NT_SUCCESS(status)) {
        DEBUG_PRINT(("GetWinsServers: NtCreateFile(path=%s) failed, err=%d\n",
                     path, GetLastError() ));
        return FALSE;
    }

    status = NtDeviceIoControlFile(h,
                                   NULL,
                                   NULL,
                                   NULL,
                                   &iosb,
                                   IOCTL_NETBT_GET_WINS_ADDR,
                                   NULL,
                                   0,
                                   (PVOID)&NodeInfo,
                                   sizeof(NodeInfo)
                                   );
    
    if (status == STATUS_PENDING) {
        status = NtWaitForSingleObject(h, TRUE, NULL);
        if (NT_SUCCESS(status)) {
            status = iosb.Status;
        }
    }

    NtClose(h);

    if (!NT_SUCCESS(status)) {
        DEBUG_PRINT(("GetWinsServers: NtDeviceIoControlFile failed, err=%d\n",
                     GetLastError() ));

        return FALSE;
    }

	*pfNbtOptions = NodeInfo.NetbiosEnabled;

	return TRUE;
}

/*!--------------------------------------------------------------------------
	GetAdditionalInfo
	++
	Description:
	Read the information not provided by GetAdaptersInfo and also copy the data
	into the PADAPTER_INFO structure.
	
	Arguments:
	None.
	
	Author:
	05-Aug-1998 (t-rajkup)
	--
		
	Author: NSun
 ---------------------------------------------------------------------------*/
HRESULT	GetAdditionalInfo(IN NETDIAG_PARAMS *pParams,
						  IN OUT NETDIAG_RESULT *pResults)
{
	PIP_ADAPTER_INFO pIpAdapterInfo;
	HKEY             key;
	char             dhcpServerAddress[4 * 4];
	BOOL             ok;
	ULONG            length;
	DWORD            DhcpClassIDLen;
	int				i;
	INTERFACE_RESULT	*pInterface = NULL;
	
	
	for (i=0; i<pResults->cNumInterfaces; i++)
	{
		pInterface = pResults->pArrayInterface + i;
		pIpAdapterInfo = pInterface->IpConfig.pAdapterInfo;
		assert(pIpAdapterInfo);
		
		if (pIpAdapterInfo->AdapterName[0] &&
			OpenAdapterKey(pIpAdapterInfo->AdapterName, &key) )
		{		  
			if( ! ReadRegistryDword(key,
									c_szRegIPAutoconfigurationEnabled,
									&(pInterface->IpConfig.fAutoconfigEnabled) ))
			{			  
				// AUTOCONFIG enabled if no regval exists for this...
				pInterface->IpConfig.fAutoconfigEnabled = TRUE;
			}                        
			
			if ( pInterface->IpConfig.fAutoconfigEnabled )
			{
				ReadRegistryDword(key,
								  c_szRegAddressType,
								  &(pInterface->IpConfig.fAutoconfigActive)
								 );
				
			}
			
			
			//
			// domain: first try Domain then DhcpDomain
			//
			
			length = sizeof(pInterface->IpConfig.szDomainName);
			ok = ReadRegistryOemString(key,
									   L"Domain",
									   pInterface->IpConfig.szDomainName,
									   &length
									  );
			
			if (!ok)
			{
				length = sizeof(pInterface->IpConfig.szDomainName);
				ok = ReadRegistryOemString(key,
										   L"DhcpDomain",
										   pInterface->IpConfig.szDomainName,
										   &length
										  );
			}
			
			// DNS Server list.. first try NameServer and then try
			// DhcpNameServer..
			
			ok = ReadRegistryIpAddrString(key,
										  c_szRegNameServer,
										  &(pInterface->IpConfig.DnsServerList)
										 );
			
			if (!ok) {
				ok = ReadRegistryIpAddrString(key,
											  c_szRegDhcpNameServer,
											  &(pInterface->IpConfig.DnsServerList)
											 );
				
			}
			
			
			//
			// Read the DHCP Class Id for this interface - Rajkumar
			//
			
			ZeroMemory(pInterface->IpConfig.szDhcpClassID,
					   sizeof(pInterface->IpConfig.szDhcpClassID));
			
			ReadRegistryString(key,
							   c_szRegDhcpClassID,
							   pInterface->IpConfig.szDhcpClassID,
							   &DhcpClassIDLen
							  );
			
			RegCloseKey(key);
			
			//
			// before getting the WINS info we must set the NodeType
			//
			pInterface->IpConfig.uNodeType = pResults->IpConfig.pFixedInfo->NodeType;
		}
		else
		{
			// IDS_IPCFG_10003  "Opening registry key for %s failed!\n" 
			PrintMessage(pParams, IDS_IPCFG_10003,pIpAdapterInfo->AdapterName);
			return S_FALSE;
		} 	  

		//be default, NetBt is enabled
		pInterface->fNbtEnabled = TRUE; 
		GetNetbiosOptions(pIpAdapterInfo->AdapterName, &pInterface->fNbtEnabled);

		if (pInterface->fNbtEnabled)
		{
			pResults->Global.fHasNbtEnabledInterface = TRUE;
		}
	}
	
	return TRUE; 
}


/*!--------------------------------------------------------------------------
	IpConfigGlobalPrint
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void IpConfigGlobalPrint(IN NETDIAG_PARAMS *pParams,
						 IN OUT NETDIAG_RESULT *pResults)
{
	PFIXED_INFO		pFixedInfo = pResults->IpConfig.pFixedInfo;

	if (pParams->fReallyVerbose)
	{
		PrintNewLine(pParams, 2);

		// IDS_IPCFG_10005 "IP General configuration \n" 
		// IDS_IPCFG_10006 "    LMHOSTS Enabled :" 
		PrintMessage(pParams, IDS_IPCFG_10005);
		PrintMessage(pParams, IDS_IPCFG_10006);
		
		if (pResults->Global.dwLMHostsEnabled) 
			PrintMessage(pParams, IDS_GLOBAL_YES_NL);
		else
			PrintMessage(pParams, IDS_GLOBAL_NO_NL);
		
		// IDS_IPCFG_10009 "    DNS for WINS resolution:" 
		PrintMessage(pParams, IDS_IPCFG_10009);
		if (pResults->Global.dwDnsForWINS)
			PrintMessage(pParams, IDS_GLOBAL_ENABLED_NL);
		else
			PrintMessage(pParams, IDS_GLOBAL_DISABLED_NL); 

		// NBT node type
        // ------------------------------------------------------------
        PrintMessage(pParams, IDSSZ_IPCFG_NODETYPE,
					 MapWinsNodeType(pFixedInfo->NodeType));
        
        // NBT scope id
        // ------------------------------------------------------------
        PrintMessage(pParams, IDSSZ_IPCFG_NBTSCOPEID,
					 MapScopeId(pFixedInfo->ScopeId));

        // ip routing
        // ------------------------------------------------------------
        PrintMessage(pParams, IDSSZ_IPCFG_RoutingEnabled,
					 MAP_YES_NO(pFixedInfo->EnableRouting));

        // WINS proxy
        // ------------------------------------------------------------
        PrintMessage(pParams, IDSSZ_IPCFG_WinsProxyEnabled,
					 MAP_YES_NO(pFixedInfo->EnableProxy));

        // DNS resolution for apps using NetBIOS
        // ------------------------------------------------------------
        PrintMessage(pParams, IDSSZ_IPCFG_DnsForNetBios,
                       MAP_YES_NO(pFixedInfo->EnableDns));

        // separate fixed and adapter information with an empty line
        // ------------------------------------------------------------
        PrintMessage(pParams, IDS_GLOBAL_EmptyLine);
    }

}


/*!--------------------------------------------------------------------------
	IpConfigPerInterfacePrint
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void IpConfigPerInterfacePrint(IN NETDIAG_PARAMS *pParams,
							   IN NETDIAG_RESULT *pResults,
							   IN INTERFACE_RESULT *pInterfaceResults)
{
   PIP_ADDR_STRING dnsServer;
   PFIXED_INFO		pFixedInfo = pResults->IpConfig.pFixedInfo;
   IP_ADAPTER_INFO*	pIpAdapterInfo;
   PIP_ADDR_STRING ipAddr;
   IPCONFIG_TST *	pIpCfgResults;
   ULONG			uDefGateway, uAddress, uMask;
   DWORD			dwDefGateway, dwAddress, dwMask;
   int				ids;
		
   pIpAdapterInfo = pInterfaceResults->IpConfig.pAdapterInfo;
   
   pIpCfgResults = &(pInterfaceResults->IpConfig);

   if (!pIpCfgResults->fActive)
	   return;

   PrintNewLine(pParams, 1);
   if(pParams->fReallyVerbose)
   {
	   // IDS_IPCFG_10012 "        Adapter type :   %s\n" 
	   PrintMessage(pParams, IDS_IPCFG_10012,
			  MapAdapterType(pIpAdapterInfo->Type));
   }
	
   PrintMessage(pParams, IDSSZ_IPCFG_HostName, 
					pFixedInfo->HostName,
					pIpCfgResults->szDomainName[0] ? _T(".") : _T(""),
					pIpCfgResults->szDomainName[0] ?
					pIpCfgResults->szDomainName : _T(""));
   
	   
	   
      // return;
   
   if (pParams->fReallyVerbose)
   {
	   
	   // IDS_IPCFG_10014 "        Description                : %s\n" 
	   PrintMessage(pParams, IDS_IPCFG_10014, pIpAdapterInfo->Description );
	   
	   if (pIpAdapterInfo->AddressLength)
	   {		   
		   char buffer[MAX_ADAPTER_ADDRESS_LENGTH * sizeof(_T("02-"))];
		   
		   // IDS_IPCFG_10015 "        Physical Address           : %s\n" 
		   PrintMessage(pParams, IDS_IPCFG_10015,
						MapAdapterAddress(pIpAdapterInfo, buffer));
	   }
	   
	   // IDS_IPCFG_10016 "        Dhcp Enabled               : %s\n" 
	   PrintMessage(pParams, IDS_IPCFG_10016,
			  MAP_YES_NO(pIpAdapterInfo->DhcpEnabled));
	   
	   
	   // IDS_IPCFG_10017 "        DHCP ClassID               : %s\n" 
	   PrintMessage(pParams, IDS_IPCFG_10017, pIpCfgResults->szDhcpClassID);
	   
	   // IDS_IPCFG_10018 "        Autoconfiguration Enabled  : %s\n" 
	   PrintMessage(pParams, IDS_IPCFG_10018,
					MAP_YES_NO(pIpCfgResults->fAutoconfigEnabled));
	   
   }
   
   //
   // the following 3 items are the only items displayed (per adapter) if
   // /all was NOT requested on the command line
   //
   
   for (ipAddr = &pIpAdapterInfo->IpAddressList;
		ipAddr;
		ipAddr = ipAddr->Next)
   {
	   
	   
	   if (pIpCfgResults->fAutoconfigActive)
		   // IDS_IPCFG_10019  "        Autoconfiguration IP Address : %s\n" 
		   PrintMessage(pParams, IDS_IPCFG_10019,ipAddr->IpAddress.String);
	   else
		   // IDS_IPCFG_10020  "        IP Address                 : %s\n" 
		   PrintMessage(pParams, IDS_IPCFG_10020,ipAddr->IpAddress.String);
	   	  	   
	   // IDS_IPCFG_10021 "        Subnet Mask                : %s\n" 
	   PrintMessage(pParams, IDS_IPCFG_10021, ipAddr->IpMask.String );
   }
   
   //
   // there will only be one default gateway
   //
   // IDS_IPCFG_10022 "        Default Gateway            : %s\n" 
   PrintMessage(pParams, IDS_IPCFG_10022,
				pIpAdapterInfo->GatewayList.IpAddress.String );
   
   if (pParams->fReallyVerbose)
   {   
	   if (pIpAdapterInfo->DhcpEnabled && FALSE == pIpCfgResults->fAutoconfigActive) {
		   
		   //
		   // there will only be 1 DHCP server (that we get info from)
		   //
		   
		   // IDS_IPCFG_10023 "        DHCP Server                : %s\n" 
		   PrintMessage(pParams, IDS_IPCFG_10023,
				  pIpAdapterInfo->DhcpServer.IpAddress.String );
		   
	   }
   }
	   
   //
   // there is only 1 primary and 1 secondary WINS server
   //
	   
//   if (pParams->fReallyVerbose)
   {
	   if (pIpAdapterInfo->PrimaryWinsServer.IpAddress.String[0]
		   && !ZERO_IP_ADDRESS(pIpAdapterInfo->PrimaryWinsServer.IpAddress.String))
	   {
		   // IDS_IPCFG_10024 "        Primary WINS Server        : %s\n" 
		   PrintMessage(pParams, IDS_IPCFG_10024,
				  pIpAdapterInfo->PrimaryWinsServer.IpAddress.String );
		   
	   }
	   
	   if (pIpAdapterInfo->SecondaryWinsServer.IpAddress.String[0]
		   && !ZERO_IP_ADDRESS(pIpAdapterInfo->SecondaryWinsServer.IpAddress.String)) {
		   // IDS_IPCFG_10025 "        Secondary WINS Server      : %s\n" 
		   PrintMessage(pParams, IDS_IPCFG_10025,
				  pIpAdapterInfo->SecondaryWinsServer.IpAddress.String);
	   }

	   if (!pInterfaceResults->fNbtEnabled)
	   {
		   //IDS_IPCFG_NBT_DISABLED					"        NetBIOS over Tcpip . . . . : Disabled\n" 
		   PrintMessage(pParams, IDS_IPCFG_NBT_DISABLED);
	   }
   }

   //
   // only display lease times if this adapter is DHCP enabled and we
   // have a non-0 IP address and not using autoconfigured address..
   //
   
   if (pParams->fReallyVerbose) {
	   
	   if (pIpAdapterInfo->DhcpEnabled
		   && !ZERO_IP_ADDRESS(pIpAdapterInfo->IpAddressList.IpAddress.String)
		   && !pIpCfgResults->fAutoconfigActive) {
		   
		   // IDS_IPCFG_10026 "        Lease Obtained             : %s\n" 
		   PrintMessage(pParams, IDS_IPCFG_10026 ,
				  MapTime(pIpAdapterInfo->LeaseObtained) );
		   
		   // IDS_IPCFG_10027 "        Lease Expires              : %s\n" 
		   PrintMessage(pParams, IDS_IPCFG_10027,
				  MapTime(pIpAdapterInfo->LeaseExpires) );
	   }	
	   
   }

      //
   // display the list of DNS servers. If the list came from SYSTEM.INI then
   // just display that, else if the list came from DHCP.BIN, get all DNS
   // servers for all NICs and display the compressed list
   //
   
   PrintMessage(pParams, IDS_IPCFG_DnsServers);
   if (pIpCfgResults->DnsServerList.IpAddress.String[0])
   {
	   dnsServer = &pIpCfgResults->DnsServerList;

	   // print out the first one
	   PrintMessage(pParams, IDSSZ_GLOBAL_StringLine,
					dnsServer->IpAddress.String);

	   dnsServer = dnsServer->Next;
	   for ( ;
			dnsServer;
			dnsServer = dnsServer->Next)
	   {
		   // IDS_IPCFG_10013  "                             " 
		   PrintMessage(pParams, IDS_IPCFG_10013);     
		   PrintMessage(pParams, IDSSZ_GLOBAL_StringLine, dnsServer->IpAddress.String);
	   }
   }
   


   PrintNewLine(pParams, 1);

   // If this is a verbose output, or if an error occurred with
   // any of the tests then we will need a header
   // -----------------------------------------------------------------
   if (pParams->fReallyVerbose || !FHrOK(pIpCfgResults->hr))
   {
	   // IDS_IPCFG_10029 "        IpConfig results : " 
	   PrintMessage(pParams, IDS_IPCFG_10029);
	   if (FHrOK(pIpCfgResults->hr))
		   ids = IDS_GLOBAL_PASS_NL;
	   else
		   ids = IDS_GLOBAL_FAIL_NL;
	   PrintMessage(pParams, ids);
   }
   
   //
   // Ping the dhcp server
   //
   PrintNdMessage(pParams, &pInterfaceResults->IpConfig.msgPingDhcpServer);
   
   //
   // Ping the WINS servers
   //
   PrintNdMessage(pParams, &pInterfaceResults->IpConfig.msgPingPrimaryWinsServer);
   PrintNdMessage(pParams, &pInterfaceResults->IpConfig.msgPingSecondaryWinsServer);

   //
   // Test to see if the gateway is on the same subnet as our IP address
   //
   if (!FHrOK(pInterfaceResults->IpConfig.hrDefGwSubnetCheck))
   {
	   PrintNewLine(pParams, 1);
	   if (pIpAdapterInfo->DhcpEnabled)
		   PrintMessage(pParams, IDS_IPCFG_WARNING_BOGUS_SUBNET_DHCP);
	   else
		   PrintMessage(pParams, IDS_IPCFG_WARNING_BOGUS_SUBNET);
   }
   
      
   //
   // if there's more to come, separate lists with empty line
   //
   PrintNewLine(pParams, 1);
}


/*!--------------------------------------------------------------------------
	ZERO_IP_ADDRESS
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
BOOL ZERO_IP_ADDRESS(LPCTSTR pszIp)
{
	return (pszIp == NULL) ||
			(*pszIp == 0) ||
			(strcmp(pszIp, _T("0.0.0.0")) == 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\ipcfgmsg.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    ipcfgmsg.mc

Abstract:

    Contains internationalizable message text for IPCONFIG

Author:

    Richard L Firth (rfirth) 05-Mar-1994

Revision History:

    05-Mar-1994 rfirth    Created
    31-Jul-97   MohsinA   PNP patterns for NT50.

--*/
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: MSG_IPCONFIG_BANNER
//
// MessageText:
//
//  
//  Windows 2000 IP Configuration
//  
//
#define MSG_IPCONFIG_BANNER              0x00002710L

//
// MessageId: MSG_PRIMARY_HOST_NAME
//
// MessageText:
//
//  Host Name . . . . . . . . . . . . : %0
//
#define MSG_PRIMARY_HOST_NAME            0x00002711L

//
// MessageId: MSG_PRIMARY_DOMAIN_NAME
//
// MessageText:
//
//  Primary DNS Suffix  . . . . . . . : %0
//
#define MSG_PRIMARY_DOMAIN_NAME          0x00002712L

//
// MessageId: MSG_DOMAIN_NAME
//
// MessageText:
//
//  Connection-specific DNS Suffix  . : %0
//
#define MSG_DOMAIN_NAME                  0x00002713L

//
// MessageId: MSG_DNS_SERVERS
//
// MessageText:
//
//  DNS Servers . . . . . . . . . . . : %0
//
#define MSG_DNS_SERVERS                  0x00002714L

//
// MessageId: MSG_NODE_TYPE
//
// MessageText:
//
//  Node Type . . . . . . . . . . . . : %1
//
#define MSG_NODE_TYPE                    0x00002715L

//
// MessageId: MSG_SCOPE_ID
//
// MessageText:
//
//  NetBIOS Scope ID. . . . . . . . . : %1
//
#define MSG_SCOPE_ID                     0x00002716L

//
// MessageId: MSG_IP_ROUTING
//
// MessageText:
//
//  IP Routing Enabled. . . . . . . . : %1
//
#define MSG_IP_ROUTING                   0x00002717L

//
// MessageId: MSG_PROXY
//
// MessageText:
//
//  WINS Proxy Enabled. . . . . . . . : %1
//
#define MSG_PROXY                        0x00002718L

//
// MessageId: MSG_DNS_RESOLUTION
//
// MessageText:
//
//  NetBIOS Resolution Uses DNS . . . : %1
//
#define MSG_DNS_RESOLUTION               0x00002719L

//
// MessageId: MSG_DNS_SEARCH_LIST
//
// MessageText:
//
//  DNS Suffix Search List. . . . . . : %0
//
#define MSG_DNS_SEARCH_LIST              0x0000271AL

//
// These two entries are just there for alignment
// they should align with all entries above
//
//
// MessageId: MSG_DNS_SEARCH_LIST_ENTRY
//
// MessageText:
//
//                                      %0
//
#define MSG_DNS_SEARCH_LIST_ENTRY        0x0000271BL

//
// MessageId: MSG_DNS_SERVERS_ENTRY
//
// MessageText:
//
//                                      %0
//
#define MSG_DNS_SERVERS_ENTRY            0x0000271CL

//
// MessageId: MSG_PHYSICAL_ADDRESS
//
// MessageText:
//
//  Physical Address. . . . . . . . . : %1
//
#define MSG_PHYSICAL_ADDRESS             0x0000271DL

//
// MessageId: MSG_DESCRIPTION
//
// MessageText:
//
//  Description . . . . . . . . . . . : %1
//
#define MSG_DESCRIPTION                  0x0000271EL

//
// MessageId: MSG_DESCRIPTION_0
//
// MessageText:
//
//  Description . . . . . . . . . . . : %0
//
#define MSG_DESCRIPTION_0                0x0000271FL

//
// MessageId: MSG_DHCP_ENABLED
//
// MessageText:
//
//  DHCP Enabled. . . . . . . . . . . : %1
//
#define MSG_DHCP_ENABLED                 0x00002720L

//
// MessageId: MSG_AUTOCONFIG_ENABLED
//
// MessageText:
//
//  Autoconfiguration Enabled . . . . : %1
//
#define MSG_AUTOCONFIG_ENABLED           0x00002721L

//
// MessageId: MSG_IP_ADDRESS
//
// MessageText:
//
//  IP Address. . . . . . . . . . . . : %1
//
#define MSG_IP_ADDRESS                   0x00002722L

//
// MessageId: MSG_AUTOCONFIG_ADDRESS
//
// MessageText:
//
//  Autoconfiguration IP Address. . . : %1
//
#define MSG_AUTOCONFIG_ADDRESS           0x00002723L

//
// MessageId: MSG_SUBNET_MASK
//
// MessageText:
//
//  Subnet Mask . . . . . . . . . . . : %1
//
#define MSG_SUBNET_MASK                  0x00002724L

//
// MessageId: MSG_DEFAULT_GATEWAY
//
// MessageText:
//
//  Default Gateway . . . . . . . . . : %1
//
#define MSG_DEFAULT_GATEWAY              0x00002725L

//
// MessageId: MSG_DHCP_SERVER
//
// MessageText:
//
//  DHCP Server . . . . . . . . . . . : %1
//
#define MSG_DHCP_SERVER                  0x00002726L

//
// MessageId: MSG_WINS_SERVER_1
//
// MessageText:
//
//  Primary WINS Server . . . . . . . : %1
//
#define MSG_WINS_SERVER_1                0x00002727L

//
// MessageId: MSG_WINS_SERVER_2
//
// MessageText:
//
//  Secondary WINS Server . . . . . . : %1
//
#define MSG_WINS_SERVER_2                0x00002728L

//
// MessageId: MSG_LEASE_OBTAINED
//
// MessageText:
//
//  Lease Obtained. . . . . . . . . . : %1
//
#define MSG_LEASE_OBTAINED               0x00002729L

//
// MessageId: MSG_LEASE_EXPIRES
//
// MessageText:
//
//  Lease Expires . . . . . . . . . . : %1
//
#define MSG_LEASE_EXPIRES                0x0000272AL

//
// MessageId: MSG_MEDIA_DISCONNECTED
//
// MessageText:
//
//  Media State . . . . . . . . . . . : Cable Disconnected
//
#define MSG_MEDIA_DISCONNECTED           0x0000272BL

//
// MessageId: MSG_MEDIA_UNKNOWN_STATE
//
// MessageText:
//
//  Media State . . . . . . . . . . . : Unknown
//
#define MSG_MEDIA_UNKNOWN_STATE          0x0000272CL

//
// MessageId: MSG_DHCP_CLASS_ID
//
// MessageText:
//
//  DHCP Class ID . . . . . . . . . . : %1
//
#define MSG_DHCP_CLASS_ID                0x0000272DL

//
// MessageId: MSG_ERROR_STRING
//
// MessageText:
//
//  Error: %1
//
#define MSG_ERROR_STRING                 0x0000272EL

//
// MessageId: MSG_ADAPTER
//
// MessageText:
//
//  %1adapter %2:
//  
//
#define MSG_ADAPTER                      0x0000272FL

//
// MessageId: MSG_FATAL_ERROR
//
// MessageText:
//
//  Fatal error: %1
//  
//
#define MSG_FATAL_ERROR                  0x00002730L

//
// MessageId: MSG_INCORRECT_ARGS
//
// MessageText:
//
//  Error: Command line is incomplete or arguments conflict.
//  
//
#define MSG_INCORRECT_ARGS               0x00002731L

//
// MessageId: MSG_UNRECOGNIZED_ARG
//
// MessageText:
//
//  Error: Unrecognized command line argument "%1"
//  
//
#define MSG_UNRECOGNIZED_ARG             0x00002732L

//
// MessageId: MSG_USAGE
//
// MessageText:
//
//  
//  USAGE:
//     ipconfig [/? | /all | /release [adapter] | /renew [adapter] 
//              | /flushdns | /registerdns
//              | /showclassid adapter
//              | /setclassid adapter [classidtoset] ]
//  
//     adapter    Full name or pattern with '*' and '?' to 'match',
//                * matches any character, ? matches one character.
//     Options
//         /?           Display this help message.
//         /all         Display full configuration information.
//         /release     Release the IP address for the specified adapter.
//         /renew       Renew the IP address for the specified adapter.
//         /flushdns    Purges the DNS Resolver cache.
//         /registerdns Refreshes all DHCP leases and re-registers DNS names
//         /displaydns  Display the contents of the DNS Resolver Cache.
//         /showclassid Displays all the dhcp class IDs allowed for adapter.
//         /setclassid  Modifies the dhcp class id.
//  
//  The default is to display only the IP address, subnet mask and
//  default gateway for each adapter bound to TCP/IP.
//  
//  For Release and Renew, if no adapter name is specified, then the IP address
//  leases for all adapters bound to TCP/IP will be released or renewed.
//  
//  For SetClassID, if no class id is specified, then the classid is removed.
//  
//  Examples:
//      > ipconfig                       ... Show information.
//      > ipconfig /all                  ... Show detailed information
//      > ipconfig /renew                ... renew all adapters
//      > ipconfig /renew EL*            ... renew adapters named EL....
//      > ipconfig /release *ELINK?21*   ... release all matching adapters,
//                                           eg. ELINK-21, myELELINKi21adapter.
//
#define MSG_USAGE                        0x00002733L

//
// MessageId: MSG_BNODE
//
// MessageText:
//
//  Broadcast%0
//
#define MSG_BNODE                        0x00002734L

//
// MessageId: MSG_PNODE
//
// MessageText:
//
//  Peer-Peer%0
//
#define MSG_PNODE                        0x00002735L

//
// MessageId: MSG_MNODE
//
// MessageText:
//
//  Mixed%0
//
#define MSG_MNODE                        0x00002736L

//
// MessageId: MSG_HNODE
//
// MessageText:
//
//  Hybrid%0
//
#define MSG_HNODE                        0x00002737L

//
// MessageId: MSG_IF_TYPE_OTHER
//
// MessageText:
//
//  Other %0
//
#define MSG_IF_TYPE_OTHER                0x00002738L

//
// MessageId: MSG_IF_TYPE_ETHERNET
//
// MessageText:
//
//  Ethernet %0
//
#define MSG_IF_TYPE_ETHERNET             0x00002739L

//
// MessageId: MSG_IF_TYPE_TOKEN_RING
//
// MessageText:
//
//  Token Ring %0
//
#define MSG_IF_TYPE_TOKEN_RING           0x0000273AL

//
// MessageId: MSG_IF_TYPE_FDDI
//
// MessageText:
//
//  FDDI %0
//
#define MSG_IF_TYPE_FDDI                 0x0000273BL

//
// MessageId: MSG_IF_TYPE_PPP
//
// MessageText:
//
//  PPP %0
//
#define MSG_IF_TYPE_PPP                  0x0000273CL

//
// MessageId: MSG_IF_TYPE_LOOPBACK
//
// MessageText:
//
//  Loopback %0
//
#define MSG_IF_TYPE_LOOPBACK             0x0000273DL

//
// MessageId: MSG_IF_TYPE_SLIP
//
// MessageText:
//
//  SLIP %0
//
#define MSG_IF_TYPE_SLIP                 0x0000273EL

//
// MessageId: MSG_YES
//
// MessageText:
//
//  Yes%0
//
#define MSG_YES                          0x0000273FL

//
// MessageId: MSG_NO
//
// MessageText:
//
//  No%0
//
#define MSG_NO                           0x00002740L

//
// MessageId: MSG_INIT_FAILED
//
// MessageText:
//
//  Failed to initialize%0
//
#define MSG_INIT_FAILED                  0x00002741L

//
// MessageId: MSG_TCP_NOT_RUNNING
//
// MessageText:
//
//  TCP/IP is not running on this system%0
//
#define MSG_TCP_NOT_RUNNING              0x00002742L

//
// MessageId: MSG_REG_BINDINGS_ERROR
//
// MessageText:
//
//  Cannot access adapter bindings registry key%0
//
#define MSG_REG_BINDINGS_ERROR           0x00002743L

//
// MessageId: MSG_REG_INCONSISTENT_ERROR
//
// MessageText:
//
//  Inconsistent registry contents%0
//
#define MSG_REG_INCONSISTENT_ERROR       0x00002744L

//
// MessageId: MSG_TCP_BINDING_ERROR
//
// MessageText:
//
//  TCP/IP not bound to any adapters%0
//
#define MSG_TCP_BINDING_ERROR            0x00002745L

//
// MessageId: MSG_MEMORY_ERROR
//
// MessageText:
//
//  Allocating memory%0
//
#define MSG_MEMORY_ERROR                 0x00002746L

//
// MessageId: MSG_ALL
//
// MessageText:
//
//  all%0
//
#define MSG_ALL                          0x00002747L

//
// MessageId: MSG_RELEASE
//
// MessageText:
//
//  Release%0
//
#define MSG_RELEASE                      0x00002748L

//
// MessageId: MSG_RENEW
//
// MessageText:
//
//  Renew%0
//
#define MSG_RENEW                        0x00002749L

//
// MessageId: MSG_FLUSH_DNS
//
// MessageText:
//
//  FlushDNS%0
//
#define MSG_FLUSH_DNS                    0x0000274AL

//
// MessageId: MSG_REFRESH
//
// MessageText:
//
//  RegisterDNS%0
//
#define MSG_REFRESH                      0x0000274BL

//
// MessageId: MSG_DISPLAY_DNS
//
// MessageText:
//
//  DisplayDNS%0
//
#define MSG_DISPLAY_DNS                  0x0000274CL

//
// MessageId: MSG_DISPLAY_CLASSID
//
// MessageText:
//
//  ShowClassID%0
//
#define MSG_DISPLAY_CLASSID              0x0000274DL

//
// MessageId: MSG_SET_CLASSID
//
// MessageText:
//
//  SetClassID%0
//
#define MSG_SET_CLASSID                  0x0000274EL

//
// MessageId: MSG_ADAPTER_NOT_FOUND
//
// MessageText:
//
//  Error: Adapter "%1" is not bound to TCP/IP
//
#define MSG_ADAPTER_NOT_FOUND            0x0000274FL

//
// MessageId: MSG_NO_ADAPTERS_BOUND
//
// MessageText:
//
//  Error: No adapters bound to TCP/IP
//
#define MSG_NO_ADAPTERS_BOUND            0x00002750L

//
// MessageId: MSG_CANT_FIND_LIBRARY
//
// MessageText:
//
//  Fatal: Cannot find dynamic link library "%1"
//
#define MSG_CANT_FIND_LIBRARY            0x00002751L

//
// MessageId: MSG_CANT_FIND_ROUTINE
//
// MessageText:
//
//  Fatal: Cannot find function "%1" in library "%2"
//
#define MSG_CANT_FIND_ROUTINE            0x00002752L

//
// MessageId: MSG_ADAPTER_NAME_ERROR
//
// MessageText:
//
//  Error: The adapter name "%1" is invalid
//
#define MSG_ADAPTER_NAME_ERROR           0x00002753L

//
// MessageId: MSG_RELEASE_FAILED
//
// MessageText:
//
//  The following error occurred when releasing adapter %2: %1
//
#define MSG_RELEASE_FAILED               0x00002754L

//
// MessageId: MSG_ACQUIRE_FAILED
//
// MessageText:
//
//  The following error occurred when renewing adapter %2: %1
//
#define MSG_ACQUIRE_FAILED               0x00002755L

//
// MessageId: MSG_REFRESH_FAILED
//
// MessageText:
//
//  Error: %1: Refreshing DNS names
//
#define MSG_REFRESH_FAILED               0x00002756L

//
// MessageId: MSG_RELEASE_SUCCEEDED
//
// MessageText:
//
//  IP address successfully released for adapter "%2"
//
#define MSG_RELEASE_SUCCEEDED            0x00002757L

//
// MessageId: MSG_RELEASE_OK
//
// MessageText:
//
//  IP address successfully released for adapter "%1"
//
#define MSG_RELEASE_OK                   0x00002758L

//
// MessageId: MSG_REFRESH_SUCCEEDED
//
// MessageText:
//
//  Registration of the DNS resource records for all adapters of this computer has been initiated. Any errors will be reported in the Event Viewer in 15 minutes.
//
#define MSG_REFRESH_SUCCEEDED            0x00002759L

//
// MessageId: MSG_CLASSID_MODIFIED
//
// MessageText:
//
//  DHCP ClassId successfully modified for adapter "%1"
//
#define MSG_CLASSID_MODIFIED             0x0000275AL

//
// MessageId: MSG_CLASSID_MODIFY_FAILED
//
// MessageText:
//
//  Error: %1
//  DHCP ClassId was not modified for adapter "%2"
//
#define MSG_CLASSID_MODIFY_FAILED        0x0000275BL

//
// MessageId: MSG_NO_DHCP_ENABLED
//
// MessageText:
//
//  Error: No adapters bound to TCP/IP are enabled for DHCP
//
#define MSG_NO_DHCP_ENABLED              0x0000275CL

//
// MessageId: MSG_ADAPTER_NOT_DHCP
//
// MessageText:
//
//  Error: %1
//  Adapter "%2" is not enabled for DHCP
//
#define MSG_ADAPTER_NOT_DHCP             0x0000275DL

//
// MessageId: MSG_CLASSES_LIST_HEADER
//
// MessageText:
//
//  DHCP Class ID for Adapter "%1":
//
#define MSG_CLASSES_LIST_HEADER          0x0000275EL

//
// MessageId: MSG_CLASSID_NAME
//
// MessageText:
//
//  DHCP ClassID Name . . . . . . . . : %1
//
#define MSG_CLASSID_NAME                 0x0000275FL

//
// MessageId: MSG_CLASSID_DESCRIPTION
//
// MessageText:
//
//  DHCP ClassID Description  . . . . : %1
//
#define MSG_CLASSID_DESCRIPTION          0x00002760L

//
// MessageId: MSG_CLASSID_FAILED
//
// MessageText:
//
//  Error: %1
//  Failed to obtain the DHCP class ID list for adapter "%2"
//
#define MSG_CLASSID_FAILED               0x00002761L

//
// MessageId: MSG_CLASSES_LIST_EMPTY
//
// MessageText:
//
//  There are no DHCP classes for adapter "%1".
//
#define MSG_CLASSES_LIST_EMPTY           0x00002762L

//
// MessageId: MSG_ACCESS_DENIED
//
// MessageText:
//
//  Unexpected network failure or insufficient access%0
//
#define MSG_ACCESS_DENIED                0x00002763L

//
// MessageId: MSG_SERVER_UNAVAILABLE
//
// MessageText:
//
//  DHCP Server unreachable%0
//
#define MSG_SERVER_UNAVAILABLE           0x00002764L

//
// MessageId: MSG_ALREADY_RELEASED
//
// MessageText:
//
//  IP Address for adapter %1 is already released
//
#define MSG_ALREADY_RELEASED             0x00002765L

//
// MessageId: MSG_ADDRESS_CONFLICT
//
// MessageText:
//
//  The DHCP client obtained an address that is already in use on the network.
//
#define MSG_ADDRESS_CONFLICT             0x00002766L

//
// MessageId: MSG_CANT_OPERATE_DISCONNECTED_MEDIA
//
// MessageText:
//
//  No operation can be performed on adapter %1 as this connection has its media/cable disconnected.
//
#define MSG_CANT_OPERATE_DISCONNECTED_MEDIA 0x00002767L

//
// MessageId: MSG_CANT_RELEASE_AUTOCONFIG_ADAPTER
//
// MessageText:
//
//  Adapter %1 was automatically configured and does not currently have a DHCP address.  The IP address for this adapter can not be released.
//
#define MSG_CANT_RELEASE_AUTOCONFIG_ADAPTER 0x00002768L

//
// MessageId: MSG_NO_DHCP_ADDRESS
//
// MessageText:
//
//  All adapters bound to DHCP do not have DHCP addresses.  The addresses were automatically configured and can not be released.
//
#define MSG_NO_DHCP_ADDRESS              0x00002769L

//
// MessageId: MSG_FLUSHDNS_FAILED
//
// MessageText:
//
//  Could not flush the DNS Resolver Cache.
//
#define MSG_FLUSHDNS_FAILED              0x0000276AL

//
// MessageId: MSG_DHCP_NO_CONTEXT
//
// MessageText:
//
//  An internal error occurred.  Disconnect and reconnect the network interface or reboot the machine.
//
#define MSG_DHCP_NO_CONTEXT              0x0000276BL

//
// MessageId: MSG_FLUSHDNS_SUCCEEDED
//
// MessageText:
//
//  Successfully flushed the DNS Resolver Cache.
//
#define MSG_FLUSHDNS_SUCCEEDED           0x0000276CL

//
// MessageId: MSG_DISPLAYDNS_FAILED
//
// MessageText:
//
//  Could not display the DNS Resolver Cache.
//
#define MSG_DISPLAYDNS_FAILED            0x0000276DL

//
// MessageId: MSG_DNS_RECORD_NAME
//
// MessageText:
//
//       Record Name . . . . . : %0
//
#define MSG_DNS_RECORD_NAME              0x0000276EL

//
// MessageId: MSG_DNS_RECORD_TYPE
//
// MessageText:
//
//       Record Type . . . . . : %0
//
#define MSG_DNS_RECORD_TYPE              0x0000276FL

//
// MessageId: MSG_DNS_RECORD_TTL
//
// MessageText:
//
//       Time To Live  . . . . : %0
//
#define MSG_DNS_RECORD_TTL               0x00002770L

//
// MessageId: MSG_DNS_RECORD_DATALEN
//
// MessageText:
//
//       Data Length . . . . . : %0
//
#define MSG_DNS_RECORD_DATALEN           0x00002771L

//
// MessageId: MSG_DNS_RECORD_SECTION
//
// MessageText:
//
//       Section . . . . . . . : %0
//
#define MSG_DNS_RECORD_SECTION           0x00002772L

//
// MessageId: MSG_DNS_A_RECORD
//
// MessageText:
//
//       A (Host) Record . . . : %0
//
#define MSG_DNS_A_RECORD                 0x00002773L

//
// MessageId: MSG_DNS_SRV_RECORD
//
// MessageText:
//
//       SRV Record  . . . . . : %0
//
#define MSG_DNS_SRV_RECORD               0x00002774L

//
// MessageId: MSG_DNS_SOA_RECORD
//
// MessageText:
//
//       SOA Record  . . . . . : %0
//
#define MSG_DNS_SOA_RECORD               0x00002775L

//
// MessageId: MSG_DNS_NS_RECORD
//
// MessageText:
//
//       NS Record   . . . . . : %0
//
#define MSG_DNS_NS_RECORD                0x00002776L

//
// MessageId: MSG_DNS_PTR_RECORD
//
// MessageText:
//
//       PTR Record  . . . . . : %0
//
#define MSG_DNS_PTR_RECORD               0x00002777L

//
// MessageId: MSG_DNS_MX_RECORD
//
// MessageText:
//
//       MX Record . . . . . . : %0
//
#define MSG_DNS_MX_RECORD                0x00002778L

//
// MessageId: MSG_DNS_AAAA_RECORD
//
// MessageText:
//
//       AAAA Record . . . . . : %0
//
#define MSG_DNS_AAAA_RECORD              0x00002779L

//
// MessageId: MSG_DNS_ATMA_RECORD
//
// MessageText:
//
//       ATMA Record . . . . . : %0
//
#define MSG_DNS_ATMA_RECORD              0x0000277AL

//
// MessageId: MSG_DNS_CNAME_RECORD
//
// MessageText:
//
//       CNAME Record  . . . . : %0
//
#define MSG_DNS_CNAME_RECORD             0x0000277BL

//
// MessageId: MSG_DNS_ERR_NO_RECORDS
//
// MessageText:
//
//            Negative cache entry for no records%0
//
#define MSG_DNS_ERR_NO_RECORDS           0x0000277CL

//
// MessageId: MSG_DNS_ERR_NAME_ERROR
//
// MessageText:
//
//            Negative cache entry for name error%0
//
#define MSG_DNS_ERR_NAME_ERROR           0x0000277DL

//
// MessageId: MSG_DNS_ERR_UNABLE_TO_DISPLAY
//
// MessageText:
//
//            Record data for type could not be displayed%0
//
#define MSG_DNS_ERR_UNABLE_TO_DISPLAY    0x0000277EL

//
// MessageId: MSG_DNS_ERR_EXPIRED_CACHE_ENTRY
//
// MessageText:
//
//            Record data for type has expired%0
//
#define MSG_DNS_ERR_EXPIRED_CACHE_ENTRY  0x0000277FL

//
// MessageId: MSG_NETBIOS_DISABLED
//
// MessageText:
//
//  NetBIOS over Tcpip. . . . . . . . : Disabled
//
#define MSG_NETBIOS_DISABLED             0x00002780L
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\ipcfgtest.h ===
/*++
Copyright (C) Microsoft Corporation, 1999 - 1999 

Module Name:
  ipcfgtest.h

Author:
  05-Aug-1998 ( t-rajkup )

Arguments:
  None.

--*/
#ifndef HEADER_IPCFGTEST
#define HEADER_IPCFGTEST

#define DEBUG_PRINT(S) /* nothing */
#define TRACE_PRINT(S) /* nothing */

#define TCPIP_PARAMS_INTER_KEY "Tcpip\\Parameters\\Interfaces\\"
#define SERVICES_KEY        "SYSTEM\\CurrentControlSet\\Services"

#define STRING_ARRAY_DELIMITERS " \t,;"

#define MAX_STRING_LIST_LENGTH  32  // arbitrary

#ifndef FLAG_DONT_SHOW_PPP_ADAPTERS
#define FLAG_DONT_SHOW_PPP_ADAPTERS 0
#endif

BOOL	ZERO_IP_ADDRESS(LPCTSTR pszIp);
#define MAP_ADAPTER_GUID_TO_NAME(Guid)  MapAdapterGuidToName(Guid)

#define LAST_NODE_TYPE  4

#define NODE_TYPE_BROADCAST             1
#define NODE_TYPE_PEER_PEER             2
#define NODE_TYPE_MIXED                 4
#define NODE_TYPE_HYBRID                8

#define FIRST_NODE_TYPE 1

#define MAX_ALLOWED_ADAPTER_NAME_LENGTH (MAX_ADAPTER_NAME_LENGTH + 256)

#define BNODE               NODE_TYPE_BROADCAST
#define PNODE               NODE_TYPE_PEER_PEER
#define MNODE               NODE_TYPE_MIXED
#define HNODE               NODE_TYPE_HYBRID

typedef DWORD (__stdcall *PFNGUIDTOFRIENDLYNAME)(LPWSTR szGuidPath, LPWSTR szBuffer, DWORD cchBuffer);
 
extern PFNGUIDTOFRIENDLYNAME pfnGuidToFriendlyName;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\iploopbk.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      iploopbk.c
//
//  Abstract:
//
//      Queries into network drivers
//
//  Author:
//
//      Anilth	- 4-20-1998 
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//--


#include "precomp.h"

//-------------------------------------------------------------------------//
//######  I p L o o p B k T e s t ()  #####################################//
//-------------------------------------------------------------------------//
//  Abstract:                                                              //
//      Pings the IP loopback address. If this succeeds then the IP stack  //
//      is most probably in a working state.                               //
//  Arguments:                                                             //
//      none                                                               //
//  Return value:                                                          //
//      TRUE  - test passed                                                //
//      FALSE - test failed                                                //
//  Global variables used:                                                 //
//		none                                              		           //
//-------------------------------------------------------------------------//
HRESULT IpLoopBkTest( NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
{
    BOOL RetVal = TRUE;
	HRESULT	hr = hrOK;

	if (!pResults->IpConfig.fEnabled)
		return hrOK;

	PrintStatusMessage(pParams,0, IDS_IPLOOPBK_STATUS_MSG);

    RetVal = IsIcmpResponse( _T("127.0.0.1") );

    if ( RetVal == FALSE )
	{
		PrintStatusMessage(pParams,0, IDS_GLOBAL_FAIL_NL);

		hr = S_FALSE;
		pResults->LoopBack.hr = S_FALSE;
		SetMessage(&pResults->LoopBack.msgLoopBack,
					 Nd_Quiet,
				   IDS_IPLOOPBK_FAIL);
    }
    else
	{
		PrintStatusMessage(pParams,0, IDS_GLOBAL_PASS_NL);
		
		hr = S_OK;
		pResults->LoopBack.hr = S_OK;
		SetMessage(&pResults->LoopBack.msgLoopBack,
				Nd_ReallyVerbose,
				   IDS_IPLOOPBK_PASS);
    }

    return hr;

} /* END OF IpLoopBkTest() */


/*!--------------------------------------------------------------------------
	IpLoopBkGlobalPrint
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void IpLoopBkGlobalPrint( NETDIAG_PARAMS* pParams,
						  NETDIAG_RESULT*  pResults)
{
	if (!pResults->IpConfig.fEnabled)
	{
		return;
	}
	
	if (pParams->fVerbose || !FHrOK(pResults->LoopBack.hr))
	{
		PrintNewLine(pParams, 2);
		PrintTestTitleResult(pParams, IDS_IPLOOPBK_LONG, IDS_IPLOOPBK_SHORT, TRUE, pResults->LoopBack.hr, 0);
		PrintNdMessage(pParams, &pResults->LoopBack.msgLoopBack);
	}
}

/*!--------------------------------------------------------------------------
	IpLoopBkPerInterfacePrint
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void IpLoopBkPerInterfacePrint( NETDIAG_PARAMS* pParams,
								NETDIAG_RESULT*  pResults,
								INTERFACE_RESULT *pInterfaceResults)
{
	// no per-interface results
}


/*!--------------------------------------------------------------------------
	IpLoopBkCleanup
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void IpLoopBkCleanup( NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
{
	ClearMessage(&pResults->LoopBack.msgLoopBack);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\ipxtest.h ===
/*--

Copyright (C) Microsoft Corporation, 1999 - 1999 

Module Name:

     ipxtest.h

Abstract:

     Header file for ipx test

Author:
   
     4-Aug-1998 (t-rajkup)

Revision History:

     None.

--*/

#ifndef HEADER_IPXTEST
#define HEADER_IPXTEST

#define INVALID_HANDLE  (HANDLE)(-1)

#define REORDER_ULONG(_Ulong) \
    ((((_Ulong) & 0xff000000) >> 24) | \
     (((_Ulong) & 0x00ff0000) >> 8) | \
     (((_Ulong) & 0x0000ff00) << 8) | \
     (((_Ulong) & 0x000000ff) << 24))

HRESULT InitIpxConfig(NETDIAG_PARAMS *pParams,
					  NETDIAG_RESULT *pResults);

#define IPX_TYPE_LAN		1
#define IPX_TYPE_UP_WAN		2
#define IPX_TYPE_DOWN_WAN	3

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\ipxtest.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      ipxtest.c
//
//  Abstract:
//
//      Queries into network drivers
//
//  Author:
//
//      Anilth	- 4-20-1998
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//--
#include "precomp.h"
#include "ipxtest.h"

static HANDLE s_isnipxfd = INVALID_HANDLE;
static wchar_t isnipxname[] = L"\\Device\\NwlnkIpx";



void IPXprint_config(NETDIAG_PARAMS *pParams,
					 NETDIAG_RESULT *pResults
   );

int do_isnipxioctl(
                   IN HANDLE fd,
                   IN int cmd,
                   OUT char *datap,
                   IN int dlen
                   );

HRESULT LoadIpxInterfaceInfo(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults);
void get_emsg(NETDIAG_PARAMS *pParams, int rc);



HRESULT InitIpxConfig(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults)
{
	UNICODE_STRING FileString;
	OBJECT_ATTRIBUTES ObjectAttributes;
	IO_STATUS_BLOCK IoStatusBlock;
	NTSTATUS Status;
	HRESULT	hr = hrOK;

	PrintStatusMessage(pParams,0, IDS_IPX_STATUS_MSG);
	
	/** Open the isnipx driver **/
	
	RtlInitUnicodeString (&FileString, isnipxname);
	
	InitializeObjectAttributes(
							   &ObjectAttributes,
							   &FileString,
							   OBJ_CASE_INSENSITIVE,
							   NULL,
							   NULL);
	
	Status = NtOpenFile(
						&pResults->Ipx.hIsnIpxFd,
						SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
						&ObjectAttributes,
						&IoStatusBlock,
						FILE_SHARE_READ | FILE_SHARE_WRITE,
						FILE_SYNCHRONOUS_IO_ALERT);
	
	pResults->Ipx.fInstalled = TRUE;
	pResults->Ipx.fEnabled = TRUE;
	
	if (!NT_SUCCESS(Status))
	{
		pResults->Ipx.hIsnIpxFd = INVALID_HANDLE;
		
		// IDS_IPX_15603  "Opening \\Device\\NwlnkIpx failed\n"
		PrintDebug(pParams, 4, IDS_IPX_15603);

		pResults->Ipx.fInstalled = FALSE;
		pResults->Ipx.fEnabled = FALSE;

		// IPX is not installed, do not return the error code
		// but return S_FALSE.
		return S_FALSE;
	}

	// Fill in the IPX adapter interface data
	hr = LoadIpxInterfaceInfo(pParams, pResults);
	
	return hr;
}

IPX_TEST_FRAME*	PutIpxFrame(	
	// returns 0-3
	ULONG		uFrameType,
	// returns virtual net if NicId = 0
	ULONG		uNetworkNumber,
	// adapter's MAC address
	const UCHAR*	pNode,
	LIST_ENTRY*	pListHead		// if its NULL, then the new created will be head
)
{
	IPX_TEST_FRAME*	pFrame = NULL; 
	if(pListHead == NULL) return NULL;

	pFrame = (IPX_TEST_FRAME*)malloc(sizeof(IPX_TEST_FRAME));

	if(pFrame == NULL)	return NULL;

	if( pListHead->Flink == NULL && pListHead->Blink == NULL)	// the head is not initilized
		InitializeListHead(pListHead);

	pFrame->uFrameType = uFrameType;
	pFrame->uNetworkNumber = uNetworkNumber;
	memcpy(&pFrame->Node[0], pNode, sizeof(pFrame->Node));

	InsertTailList(pListHead, &(pFrame->list_entry));

	return pFrame;
}

HRESULT LoadIpxInterfaceInfo(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults)
{
	int rc;
	USHORT nicid, nicidcount;
	ISN_ACTION_GET_DETAILS getdetails;
	HANDLE hMpr = NULL;
	DWORD dwErr;
	PVOID	pv;
	HRESULT		hr = hrOK;
	int			i, iIpx;
	INTERFACE_RESULT *	pIfResults;
	LPTSTR		pszAdapterName = NULL;
	
	unsigned char	node[6] = {0, 0,0,0,0,1};

	// Initialize the map from guid to interface name
	CheckErr( MprConfigServerConnect(NULL, &hMpr) );
	assert(hMpr != INVALID_HANDLE);
	
	/** First query nicid 0 **/
	
	getdetails.NicId = 0;
	
	rc = do_isnipxioctl(pResults->Ipx.hIsnIpxFd, MIPX_CONFIG, (char *)&getdetails, sizeof(getdetails));
	if (rc)
	{
		// IDS_IPX_15604 "Error querying config nwlnkipx :"
		PrintDebug(pParams, 0, IDS_IPX_15604);
		if (pParams->fDebugVerbose)
		{
			get_emsg(pParams, rc);
		}
		goto Error;
	}
	
	//
	// The NicId 0 query returns the total number.
	//
	nicidcount = getdetails.NicId;

	// We should have an open spot for the IPX internal interface
	// ----------------------------------------------------------------
	assert(pResults->cNumInterfacesAllocated > pResults->cNumInterfaces);

	
	// Set the first IPX interface as the IPX internal
	iIpx = pResults->cNumInterfaces;

	
	// Add the internal interface
	pIfResults = pResults->pArrayInterface + iIpx;
	pIfResults->fActive = TRUE;
	pIfResults->Ipx.fActive = TRUE;
	pIfResults->pszName = StrDup(_T("Internal"));
	pIfResults->pszFriendlyName = LoadAndAllocString(IDS_IPX_INTERNAL);
	pIfResults->Ipx.uNicId = 0;
	pIfResults->Ipx.fBindingSet = 0;
	pIfResults->Ipx.uType = 0;

	// multiple frame types
	PutIpxFrame(0, REORDER_ULONG(getdetails.NetworkNumber), node, &(pIfResults->Ipx.list_entry_Frames));

	iIpx++;		// move on to the next new interface structure
	pResults->cNumInterfaces++;
	
    InitializeListHead(&pResults->Dns.lmsgOutput);
    
	for (nicid = 1; nicid <= nicidcount; nicid++)
	{

		// get the next structure
		getdetails.NicId = nicid;
		
		rc = do_isnipxioctl(pResults->Ipx.hIsnIpxFd, MIPX_CONFIG, (char *)&getdetails, sizeof(getdetails)
						   );
		if (rc)
		{
			continue;
		}

		// convert the adapter name into ASCII
		pszAdapterName = StrDupTFromW(getdetails.AdapterName);

		// see if this interface is already in the list
		pIfResults = NULL;
		for ( i=0; i<pResults->cNumInterfaces; i++)
		{
			if (lstrcmpi(pResults->pArrayInterface[i].pszName,
						 pszAdapterName) == 0)
			{
				pIfResults = pResults->pArrayInterface + i;
				break;
			}
			
		}

		// if we didn't find a match, use one of the newly allocated
		// interfaces
		if (pIfResults == NULL)
		{
			// We need a new interface result structure, grab one
			// (if it is free), else allocate more.
			if (pResults->cNumInterfaces >= pResults->cNumInterfacesAllocated)
			{
				// Need to do a realloc to get more memory
				pv = Realloc(pResults->pArrayInterface,
							 sizeof(INTERFACE_RESULT)*(pResults->cNumInterfacesAllocated+8));
				if (pv == NULL)
					CheckHr( E_OUTOFMEMORY );

				pResults->pArrayInterface = pv;
				
				// Zero out the new section of memory
				ZeroMemory(pResults->pArrayInterface + pResults->cNumInterfacesAllocated,
						   sizeof(INTERFACE_RESULT)*8);

				pResults->cNumInterfacesAllocated += 8;
			}
			
			pIfResults = pResults->pArrayInterface + iIpx;
			iIpx++;
			pResults->cNumInterfaces++;

			pIfResults->pszName = _tcsdup(pszAdapterName);
		}

		free(pszAdapterName);
		pszAdapterName = NULL;

		// Enable IPX on this interface
		pIfResults->fActive = TRUE;
		pIfResults->Ipx.fActive = TRUE;

		pIfResults->Ipx.uNicId = nicid;

		// support multiple frame types
		PutIpxFrame(getdetails.FrameType, REORDER_ULONG(getdetails.NetworkNumber), &(getdetails.Node[0]), &(pIfResults->Ipx.list_entry_Frames));
		
		// Translate the adapter name (if needed)
		if (!pIfResults->pszFriendlyName)
		{
			if (getdetails.Type == IPX_TYPE_LAN)
			{
				WCHAR swzName[512];
				PWCHAR pszGuid = &(getdetails.AdapterName[0]);
				
				dwErr = MprConfigGetFriendlyName(hMpr,
					pszGuid,
					swzName,
					sizeof(swzName));
				
				if (dwErr == NO_ERROR)
					pIfResults->pszFriendlyName = StrDupTFromW(swzName);
				else
					pIfResults->pszFriendlyName =
						StrDupTFromW(getdetails.AdapterName);
			}
			else
				pIfResults->pszFriendlyName =
									StrDupTFromW(getdetails.AdapterName);
		}

		pIfResults->Ipx.fBindingSet = getdetails.BindingSet;
	}
	
Error:
	
	/** Close up and exit **/
	
	// Cleanup interface map
	if (hMpr)
		MprConfigServerDisconnect(hMpr);
	
	return hr;
}



HRESULT
IpxTest(NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
{
	return hrOK;
}



int do_isnipxioctl(
            IN HANDLE fd,
            IN int cmd,
            OUT char *datap,
            IN  int dlen)
{
    NTSTATUS Status;
    UCHAR buffer[sizeof(NWLINK_ACTION) + sizeof(ISN_ACTION_GET_DETAILS) - 1];
    PNWLINK_ACTION action;
    IO_STATUS_BLOCK IoStatusBlock;
    int rc;

    /** Fill out the structure **/

    action = (PNWLINK_ACTION)buffer;

    action->Header.TransportId = ISN_ACTION_TRANSPORT_ID;
    action->OptionType = NWLINK_OPTION_CONTROL;
    action->BufferLength = sizeof(ULONG) + dlen;
    action->Option = cmd;
    RtlMoveMemory(action->Data, datap, dlen);

    /** Issue the ioctl **/

    Status = NtDeviceIoControlFile(
                 fd,
                 NULL,
                 NULL,
                 NULL,
                 &IoStatusBlock,
                 IOCTL_TDI_ACTION,
                 NULL,
                 0,
                 action,
                 FIELD_OFFSET(NWLINK_ACTION,Data) + dlen);

    if (Status != STATUS_SUCCESS) {
        if (Status == STATUS_INVALID_PARAMETER) {
            rc = ERANGE;
        } else {
            rc = EINVAL;
        }
    } else {
        if (dlen > 0) {
            RtlMoveMemory (datap, action->Data, dlen);
        }
        rc = 0;
    }

    return rc;

}

void get_emsg(NETDIAG_PARAMS *pParams, int rc)
{
    /**
        We have 3 defined error codes that can come back.

        1 - EINVAL means that we sent down parameters wrong
                   (SHOULD NEVER HAPPEN)

        2 - ERANGE means that the board number is invalid
                   (CAN HAPPEN IF USER ENTERS BAD BOARD)

        3 - ENOENT means that on remove - the address given
                   is not in the source routing table.
    **/

    switch (rc) {

    case EINVAL:
		// IDS_IPX_15605 "we sent down parameters wrong\n"
        PrintMessage(pParams, IDS_IPX_15605);
        break;

    case ERANGE:
		// IDS_IPX_15606 "board number is invalid\n"
        PrintMessage(pParams, IDS_IPX_15606);
        break;

    case ENOENT:
		// IDS_IPX_15607 "remove - the address given is not in the source routing table\n"
        PrintMessage(pParams, IDS_IPX_15607);
        break;

    default:
		// IDS_IPX_15608 "Unknown Error\n"
        PrintMessage(pParams, IDS_IPX_15608);
        break;
    }

    return;
}




/*!--------------------------------------------------------------------------
	IpxGlobalPrint
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void IpxGlobalPrint( NETDIAG_PARAMS* pParams,
						  NETDIAG_RESULT*  pResults)
{
	if (!pResults->Ipx.fInstalled)
		return;

#if 0
	if (pParams->fVerbose)
	{
		PrintNewLine(pParams, 2);
		PrintTestTitleResult(pParams, IDS_IPX_LONG, IDS_IPX_SHORT, TRUE, pResults->Ipx.hr, 0);
	}
#endif
}

/*!--------------------------------------------------------------------------
	IpxPerInterfacePrint
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void IpxPerInterfacePrint( NETDIAG_PARAMS* pParams,
								NETDIAG_RESULT*  pResults,
								INTERFACE_RESULT *pInterfaceResults)
{
	int		ids;
	LPTSTR	pszFrameType = NULL;
	LIST_ENTRY* pEntry = NULL;
	IPX_TEST_FRAME* pFrameEntry = NULL;
	
	// no per-interface results
	if (!pResults->Ipx.fInstalled)
	{
		if (pParams->fReallyVerbose)
			// IDS_IPX_15609 "        IPX test : IPX is not installed on this machine.\n"
			PrintMessage(pParams, IDS_IPX_15609);
		return;
	}


	if (!pInterfaceResults->Ipx.fActive)
		return;

	// IDS_IPX_15610 "\n        Ipx configration\n"
	PrintMessage(pParams, IDS_IPX_15610);

	// support multiple frame types
	// loop all the frame in the list_entry
	pEntry = pInterfaceResults->Ipx.list_entry_Frames.Flink;

    for ( pEntry = pInterfaceResults->Ipx.list_entry_Frames.Flink ;
          pEntry != &pInterfaceResults->Ipx.list_entry_Frames ;
          pEntry = pEntry->Flink )
	{
		pFrameEntry = CONTAINING_RECORD(pEntry, IPX_TEST_FRAME, list_entry);

		ASSERT(pFrameEntry);
		// network number
		// IDS_IPX_15611 "            Network Number : %.8x\n"
		PrintMessage(pParams, IDS_IPX_15611,
				 pFrameEntry->uNetworkNumber);

		// node
		// IDS_IPX_15612 "            Node : %2.2x%2.2x%2.2x%2.2x%2.2x%2.2x\n"
		PrintMessage(pParams, IDS_IPX_15612,
		   pFrameEntry->Node[0],
		   pFrameEntry->Node[1],
		   pFrameEntry->Node[2],
		   pFrameEntry->Node[3],
		   pFrameEntry->Node[4],
		   pFrameEntry->Node[5]);

		// frame type
		switch (pFrameEntry->uFrameType)
		{
			case 0 : ids = IDS_IPX_ETHERNET_II;		break;
			case 1 : ids = IDS_IPX_802_3;			break;
			case 2 : ids = IDS_IPX_802_2;			break;
			case 3 : ids = IDS_IPX_SNAP;			break;
			case 4 : ids = IDS_IPX_ARCNET;			break;
			default:
					 ids = IDS_IPX_UNKNOWN;			break;
		}
		pszFrameType = LoadAndAllocString(ids);
				
		// IDS_IPX_15613 "            Frame type : %s\n"
		PrintMessage(pParams, IDS_IPX_15613, pszFrameType);
	
		Free(pszFrameType);

		PrintNewLine(pParams, 1);
	}

	// type
	PrintNewLine(pParams, 1);
}


/*!--------------------------------------------------------------------------
	IpxCleanup
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void IpxCleanup( NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
{
	int i;
	LIST_ENTRY*	pEntry = NULL;
	IPX_TEST_FRAME* pFrameEntry = NULL;
	INTERFACE_RESULT*	pIfResults = NULL;
	
	if (pResults->Ipx.hIsnIpxFd != INVALID_HANDLE)
		NtClose(pResults->Ipx.hIsnIpxFd);
	pResults->Ipx.hIsnIpxFd = INVALID_HANDLE;


	// per interface stuff -- loop through
	for ( i = 0; i < pResults->cNumInterfacesAllocated; i++)
	{
		pIfResults = pResults->pArrayInterface + i;
		
		if(pIfResults->Ipx.list_entry_Frames.Flink)	// there is data need to be cleaned up
		{
			while (!IsListEmpty(&(pIfResults->Ipx.list_entry_Frames)))
			{
				pEntry = RemoveHeadList(&(pIfResults->Ipx.list_entry_Frames));
				// find data pointer
				pFrameEntry = CONTAINING_RECORD(pEntry, IPX_TEST_FRAME, list_entry);

				free(pFrameEntry);
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\kerberos.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      kerberos.c
//
//  Abstract:
//
//      Queries into network drivers
//
//  Author:
//
//      Anilth	- 4-20-1998 
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//--

#include "precomp.h"

HRESULT KerberosTest( NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
{
	HRESULT	hr = S_OK;
	PTESTED_DOMAIN Context = pParams->pDomain;

	NET_API_STATUS NetStatus;
	NTSTATUS Status;
	BOOL RetVal = TRUE;

	HANDLE LogonHandle = NULL;
	STRING Name;
	ULONG PackageId;
	KERB_QUERY_TKT_CACHE_REQUEST CacheRequest;
	PKERB_QUERY_TKT_CACHE_RESPONSE CacheResponse = NULL;
	ULONG ResponseSize;
	NTSTATUS SubStatus;
	ULONG Index;

	WCHAR KrbtgtOldTicketName[MAX_PATH+1];
	UNICODE_STRING KrbtgtOldTicketNameString;
	WCHAR KrbtgtTicketName[MAX_PATH+1];
	UNICODE_STRING KrbtgtTicketNameString;
	BOOLEAN KrbtgtTicketFound = FALSE;
	WCHAR OurMachineOldTicketName[MAX_PATH+1];
	UNICODE_STRING OurMachineOldTicketNameString;
	WCHAR OurMachineTicketName[MAX_PATH+1];
	UNICODE_STRING OurMachineTicketNameString;
	BOOLEAN OurMachineTicketFound = FALSE;
	TCHAR	endTime[MAX_PATH];	// though MAX_PATH is not directly related to time, it's sufficient
	TCHAR	renewTime[MAX_PATH];
    PTESTED_DOMAIN  TestedDomain;


	LPWSTR pwszDnsHostName;


	InitializeListHead(&pResults->Kerberos.lmsgOutput);

	PrintStatusMessage(pParams, 4, IDS_KERBEROS_STATUS_MSG);


	//
	// Only Members and Domain controllers use Kerberos.
	//

	if (!( pResults->Global.pPrimaryDomainInfo->MachineRole == DsRole_RoleMemberWorkstation ||
    	pResults->Global.pPrimaryDomainInfo->MachineRole == DsRole_RoleMemberServer ||
	    pResults->Global.pPrimaryDomainInfo->MachineRole == DsRole_RoleBackupDomainController ||
	    pResults->Global.pPrimaryDomainInfo->MachineRole == DsRole_RolePrimaryDomainController ))
	{
		PrintStatusMessage(pParams, 0, IDS_GLOBAL_SKIP_NL);
		pResults->Kerberos.fPerformed = FALSE;
		return hr;
	}
    
	//if there is no GUID for the primary domain, then it is NOT W2k domain
	if (! (pResults->Global.pPrimaryDomainInfo->Flags & DSROLE_PRIMARY_DOMAIN_GUID_PRESENT))

	{
		AddIMessageToList(&pResults->Kerberos.lmsgOutput, Nd_Quiet, 0, IDS_KERBEROS_NOT_W2K_PRIMARY_DOMAIN);
		goto L_ERR;
	}

	//
	// If we're logged onto a local account,
	//  we can't test kerberos.
	//
	if ( pResults->Global.pLogonDomain == NULL ) 
	{
		AddIMessageToList(&pResults->Kerberos.lmsgOutput, Nd_Quiet, 0, IDS_KERBEROS_LOCALUSER);
		goto L_ERR;
	}

    TestedDomain = pResults->Global.pLogonDomain;

	//
	// If we're logged with cached credentials,
	//  we can't test kerberos.
	//
	if ( pResults->Global.fLogonWithCachedCredentials ) 
	{
		AddIMessageToList(&pResults->Kerberos.lmsgOutput, Nd_Quiet, 0, IDS_KERBEROS_CACHED);
		goto L_ERR;
	}


	//
	// If a DC hasn't been discovered yet,
	//  find one.
	//
    if ( TestedDomain->DcInfo == NULL ) 
	{
			LPTSTR pszDcType;

            if ( TestedDomain->fTriedToFindDcInfo ) {
                RetVal = FALSE;
                //IDS_DCLIST_NO_DC "    '%ws': Cannot find DC to get DC list from (Test skipped).\n"
                AddMessageToList(&pResults->Kerberos.lmsgOutput, Nd_Quiet, 
                                 IDS_DCLIST_NO_DC, TestedDomain->PrintableDomainName);
                goto L_ERR;
            }

			pszDcType = LoadAndAllocString(IDS_DCTYPE_DC);

            NetStatus = DoDsGetDcName( pParams,
                                       pResults,
                                       &pResults->Kerberos.lmsgOutput,
                                       TestedDomain,
                                       DS_DIRECTORY_SERVICE_PREFERRED,
                                       pszDcType, //"DC",
                                       FALSE,
                                       &TestedDomain->DcInfo );

			Free(pszDcType);

            TestedDomain->fTriedToFindDcInfo = TRUE;

            if ( NetStatus != NO_ERROR ) 
            {
                RetVal = FALSE;
			    AddIMessageToList(&pResults->Kerberos.lmsgOutput, Nd_Quiet, 0, IDS_KERBEROS_NODC);
			    CHK_HR_CONTEXT(pResults->Kerberos, hr = HRESULT_FROM_WIN32(NetStatus), 0);
            }
        }


	//
	// If we're logged onto an account in an NT 4 domain,
	//  we can't test kerberos.
	//
	if ( (TestedDomain->DcInfo->Flags & DS_KDC_FLAG) == 0 ) 
	{
		AddIMessageToList(&pResults->Kerberos.lmsgOutput, Nd_Quiet, 0, IDS_KERBEROS_NOKDC, pResults->Global.pLogonDomainName, pResults->Global.pLogonUser );
		goto L_ERR;
	}


	pResults->Kerberos.fPerformed = TRUE;

	//
	// Connect to the LSA.
	//

	Status = LsaConnectUntrusted( &LogonHandle );

	if (!NT_SUCCESS(Status)) {
		RetVal = FALSE;
		CHK_HR_CONTEXT(pResults->Kerberos, hr = HRESULT_FROM_WIN32(Status), IDS_KERBEROS_NOLSA);
	}

	RtlInitString( &Name, MICROSOFT_KERBEROS_NAME_A );

	Status = LsaLookupAuthenticationPackage(
            LogonHandle,
            &Name,
            &PackageId );

	if (!NT_SUCCESS(Status)) {
		RetVal = FALSE;
		//IDS_KERBEROS_NOPACKAGE              "    [FATAL] Cannot lookup package %Z.\n"
		AddIMessageToList(&pResults->Kerberos.lmsgOutput, Nd_Quiet, 0, IDS_KERBEROS_NOPACKAGE, &Name);
		CHK_HR_CONTEXT(pResults->Kerberos, hr = HRESULT_FROM_WIN32(Status), IDS_KERBEROS_HRERROR);
	}

	//
	// Get the ticket cache from Kerberos.
	//

	CacheRequest.MessageType = KerbQueryTicketCacheMessage;
	CacheRequest.LogonId.LowPart = 0;
	CacheRequest.LogonId.HighPart = 0;

	Status = LsaCallAuthenticationPackage(
            LogonHandle,
            PackageId,
            &CacheRequest,
            sizeof(CacheRequest),
            (PVOID *) &CacheResponse,
            &ResponseSize,
            &SubStatus
            );

	if (!NT_SUCCESS(Status) || !NT_SUCCESS(SubStatus)) {
		AddIMessageToList(&pResults->Kerberos.lmsgOutput, Nd_Quiet, 0, IDS_KERBEROS_NOCACHE, &Name);
		RetVal = FALSE;
		if(!NT_SUCCESS(Status))
		{
			CHK_HR_CONTEXT(pResults->Kerberos, hr = HRESULT_FROM_WIN32(Status), IDS_KERBEROS_HRERROR);
		}
		else
		{
			CHK_HR_CONTEXT(pResults->Kerberos, hr = HRESULT_FROM_WIN32(SubStatus), IDS_KERBEROS_HRERROR);
		}
	}

	//
	// Build the names of some mandatory tickets.
	//

	
	wcscpy( KrbtgtOldTicketName, GetSafeStringW(pResults->Global.pPrimaryDomainInfo->DomainNameFlat) );
	wcscat( KrbtgtOldTicketName, L"\\krbtgt" );
	RtlInitUnicodeString( &KrbtgtOldTicketNameString, KrbtgtOldTicketName );

	wcscpy(KrbtgtTicketName, L"krbtgt" );
	wcscat(KrbtgtTicketName, L"/" );
	wcscat(KrbtgtTicketName, GetSafeStringW(pResults->Global.pPrimaryDomainInfo->DomainNameDns) );
	RtlInitUnicodeString( &KrbtgtTicketNameString, KrbtgtTicketName );

	wcscpy( OurMachineOldTicketName, GetSafeStringW(pResults->Global.pPrimaryDomainInfo->DomainNameFlat) );
	wcscat( OurMachineOldTicketName, L"\\" );
	wcscat( OurMachineOldTicketName, GetSafeStringW(pResults->Global.swzNetBiosName) );
	wcscat( OurMachineOldTicketName, L"$" );
	RtlInitUnicodeString( &OurMachineOldTicketNameString, OurMachineOldTicketName );


	// russw
	// Need to convert szDnsHostName from TCHAR to WCHAR
	pwszDnsHostName = StrDupWFromT(pResults->Global.szDnsHostName);

	wcscpy( OurMachineTicketName, L"host/");
	wcscat( OurMachineTicketName, GetSafeStringW(pwszDnsHostName));

	RtlInitUnicodeString( &OurMachineTicketNameString, OurMachineTicketName );

	LocalFree (pwszDnsHostName);
	

	// old
	//wcscpy( OurMachineTicketName, GetSafeStringW(pResults->Global.szDnsHostName) );
	// wcscat( OurMachineTicketName, L"$" )
	
	//
	// Ensure those tickets are defined.
	//


	AddIMessageToList(&pResults->Kerberos.lmsgOutput, Nd_ReallyVerbose, 0, IDS_KERBEROS_CACHEDTICKER);

	for (Index = 0; Index < CacheResponse->CountOfTickets ; Index++ ) 
	{

    	if ( RtlEqualUnicodeString( &CacheResponse->Tickets[Index].ServerName,
                                &KrbtgtOldTicketNameString, TRUE ) 
             || RtlEqualUnicodeString( &CacheResponse->Tickets[Index].ServerName,
                                &KrbtgtTicketNameString,  TRUE )) 
	    {
    	    KrbtgtTicketFound = TRUE;
	    }
		
    	if ( RtlEqualUnicodeString( &CacheResponse->Tickets[Index].ServerName,
                                &OurMachineOldTicketNameString, TRUE ) 
            || RtlEqualUnicodeString( &CacheResponse->Tickets[Index].ServerName,
                                &OurMachineTicketNameString, TRUE )) 
	    {
    	    OurMachineTicketFound = TRUE;
	    }

 		AddIMessageToList(&pResults->Kerberos.lmsgOutput, Nd_ReallyVerbose, 0, IDS_KERBEROS_SERVER, &CacheResponse->Tickets[Index].ServerName);

	 	sPrintTime(endTime, CacheResponse->Tickets[Index].EndTime);
 		sPrintTime(renewTime, CacheResponse->Tickets[Index].RenewTime);
	 	AddIMessageToList(&pResults->Kerberos.lmsgOutput, Nd_ReallyVerbose, 0, IDS_KERBEROS_ENDTIME, endTime);
 		AddIMessageToList(&pResults->Kerberos.lmsgOutput, Nd_ReallyVerbose, 0, IDS_KERBEROS_RENEWTIME, renewTime);

		//
		// Complain if required tickets were not found.
		//
	}

	if ( !KrbtgtTicketFound ) 
	{
		AddIMessageToList(&pResults->Kerberos.lmsgOutput, Nd_Quiet, 0, IDS_KERBEROS_NOTICKET, KrbtgtTicketName);
		RetVal = FALSE;
	}

	if ( !OurMachineTicketFound ) 
	{
		AddIMessageToList(&pResults->Kerberos.lmsgOutput, Nd_Quiet, 0, IDS_KERBEROS_NOTICKET, OurMachineTicketName);
		RetVal = FALSE;
	}

	//
	// Let subsequent tests know that kerberos is working.
	//
	if ( RetVal ) 
	{	
		pResults->Global.fKerberosIsWorking = TRUE;
	}


L_ERR:

    if (LogonHandle != NULL) 
    {
        LsaDeregisterLogonProcess(LogonHandle);
    }

    if (CacheResponse != NULL) 
    {
        LsaFreeReturnBuffer(CacheResponse);
    }

    if (!RetVal && hr == S_OK)
	{
		pResults->Kerberos.hr = hr = E_FAIL;
		PrintStatusMessage(pParams, 0, IDS_GLOBAL_FAIL_NL);
	}
	else
	{
		PrintStatusMessage(pParams, 0, IDS_GLOBAL_PASS_NL);
	}
    
	return S_OK;
} 

void KerberosGlobalPrint(IN NETDIAG_PARAMS *pParams, IN OUT NETDIAG_RESULT *pResults)
{
	if (pParams->fVerbose || !FHrOK(pResults->Kerberos.hr))
	{
		PrintNewLine(pParams, 2);
		PrintTestTitleResult(pParams, IDS_KERBEROS_LONG, IDS_KERBEROS_SHORT, pResults->Kerberos.fPerformed,
							pResults->Kerberos.hr, 0);

		if (pParams->fReallyVerbose || !FHrOK(pResults->Kerberos.hr))
			PrintMessageList(pParams, &pResults->Kerberos.lmsgOutput);

		if (!FHrOK(pResults->Kerberos.hr))
		{
			if(pResults->Kerberos.idsContext)
				PrintError(pParams, pResults->Kerberos.idsContext, pResults->Kerberos.hr);
		}
	}

}

void KerberosPerInterfacePrint(IN NETDIAG_PARAMS *pParams,
							 IN OUT NETDIAG_RESULT *pResults,
							 IN INTERFACE_RESULT *pIfResult)
{
	// no perinterface information
}

void KerberosCleanup(IN NETDIAG_PARAMS *pParams,
						 IN OUT NETDIAG_RESULT *pResults)
{
	MessageListCleanUp(&pResults->Kerberos.lmsgOutput);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\ipsec.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 2000
//
//  Module Name:
//
//      ipsec.c
//
//  Abstract:
//
//      IP Security stats for netdiag
//
//  Author:
//
//      DKalin  - 8/3/1999
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//      Changed behavior for Whistler - now we report registry/OU settings only
//        More specific code moved to ipseccmd.exe tool
//--

#include "precomp.h"

#include <snmp.h>
#include "tcpinfo.h"
#include "ipinfo.h"
#include "llinfo.h"


#include <windows.h>
#include <winsock2.h>
#include <ipexport.h>
#include <icmpapi.h>
#include <stdlib.h>
#include <assert.h>
#include <tchar.h>
#include <wincrypt.h>
#include <stdio.h>
#include <objbase.h>
#include <dsgetdc.h>
#include <lm.h>
#include <userenv.h>

#define MAXSTRLEN	(1024) 
#define  STRING_TEXT_SIZE 4096
#define  NETDIAG_TEXT_LIMIT 3072

// policy source constants
#define PS_NO_POLICY  0
#define PS_DS_POLICY  1
#define PS_LOC_POLICY 2

// magic strings
#define IPSEC_SERVICE_NAME TEXT("policyagent")
#define GPEXT_KEY TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\GPExtensions")
TCHAR   pcszGPTIPSecKey[]    = TEXT("SOFTWARE\\Policies\\Microsoft\\Windows\\IPSEC\\GPTIPSECPolicy");
TCHAR   pcszGPTIPSecName[]   = TEXT("DSIPSECPolicyName");
TCHAR   pcszGPTIPSecFlags[]  = TEXT("DSIPSECPolicyFlags");
TCHAR   pcszGPTIPSecPath[]   = TEXT("DSIPSECPolicyPath");
TCHAR   pcszLocIPSecKey[]    = TEXT("SOFTWARE\\Policies\\Microsoft\\Windows\\IPSEC\\Policy\\Local");
TCHAR   pcszLocIPSecPol[]    = TEXT("ActivePolicy");
TCHAR   pcszCacheIPSecKey[]  = TEXT("SOFTWARE\\Policies\\Microsoft\\Windows\\IPSEC\\Policy\\Cache");
TCHAR   pcszIPSecPolicy[]    = TEXT("ipsecPolicy");
TCHAR   pcszIPSecName[]      = TEXT("ipsecName");
TCHAR   pcszIPSecDesc[]      = TEXT("description");
TCHAR   pcszIPSecTimestamp[] = TEXT("whenChanged");

// BAIL_xx defines
#define BAIL_ON_WIN32_ERROR(dwError) \
    if (dwError) {\
        goto error; \
    }


#define BAIL_ON_FAILURE(hr) \
    if (FAILED(hr)) {\
        goto error; \
    }

typedef struct 
{
	int     iPolicySource;            // one of the three constants mentioned above
	TCHAR   pszPolicyName[MAXSTRLEN]; // policy name
	TCHAR   pszPolicyDesc[MAXSTRLEN]; // policy description
	TCHAR   pszPolicyPath[MAXSTRLEN]; // policy path (DN or RegKey)
	time_t  timestamp;                // last updated time
} POLICY_INFO, *PPOLICY_INFO;

typedef struct
{
	SERVICE_STATUS       servStat;    // service status
	QUERY_SERVICE_CONFIG servConfig;  // service configuration
} SERVICE_INFO, *PSERVICE_INFO;

typedef struct
{
	TCHAR   pszComputerOU[MAXSTRLEN]; // this computer' OU name
	PGROUP_POLICY_OBJECT pGPO;        // GPO that is assigning IPSec Policy
	TCHAR   pszPolicyOU  [MAXSTRLEN]; // OU that has the GPO assigned
} DS_POLICY_INFO, *PDS_POLICY_INFO;

DWORD MyFormatMessage ( DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId,
  LPTSTR lpBuffer, DWORD nSize, va_list *Arguments );

void reportError ( HRESULT hr, NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults );
void reportServiceInfo ( NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults );
HRESULT getPolicyInfo ( );
DWORD getMorePolicyInfo ( );
DWORD getServiceInfo ( PSERVICE_INFO pInfo );
PGROUP_POLICY_OBJECT getIPSecGPO ( );
void StringToGuid( TCHAR * szValue, GUID * pGuid );

BOOL bTestSkipped = FALSE;
BOOL bTestPassed = FALSE;
POLICY_INFO    piAssignedPolicy;
SERVICE_INFO   siIPSecStatus;
DS_POLICY_INFO dpiAssignedPolicy;
TCHAR   pszBuf[STRING_TEXT_SIZE];
WCHAR  StringTxt[STRING_TEXT_SIZE];

BOOL
IPSecTest(NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
//++
//  Description:
//      This is IPSec test
// 
//  Arguments:
//      None.
//
//  Author:
//      DKalin 08/03/99
//--
{

	DWORD dwError = ERROR_SUCCESS;
    HRESULT hr = ERROR_SUCCESS;
	PGROUP_POLICY_OBJECT pGPO = NULL;

    PrintStatusMessage( pParams, 4, IDS_IPSEC_STATUS_MSG );

    InitializeListHead(&pResults->IPSec.lmsgGlobalOutput);
    InitializeListHead(&pResults->IPSec.lmsgAdditOutput);

	dwError = getServiceInfo(&siIPSecStatus);

	if (dwError != ERROR_SUCCESS || siIPSecStatus.servStat.dwCurrentState != SERVICE_RUNNING)
	{
		// test skipped
		bTestSkipped = TRUE;
        if (dwError == ERROR_SERVICE_DOES_NOT_EXIST)
		{
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
					IDS_IPSEC_PA_NOT_INSTALLED );
		}
		else if (dwError == ERROR_SUCCESS)
		{
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
					IDS_IPSEC_PA_NOT_STARTED );
			reportServiceInfo(pParams, pResults);
		}
		else
		{
			// some error
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
					IDS_IPSEC_PA_NO_INFO );
			reportError(dwError, pParams, pResults);
		}
		return S_OK;
	}
	else
	{
		// test passed
		bTestPassed = TRUE;

		reportServiceInfo(pParams, pResults);
    	hr = getPolicyInfo();

		if (hr != ERROR_SUCCESS)
		{
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
					IDS_IPSEC_NO_POLICY_INFO );
			reportError(hr, pParams, pResults);
		}
		else
		{
			switch (piAssignedPolicy.iPolicySource)
			{
			case PS_NO_POLICY:
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
						IDS_IPSEC_NO_POLICY );
				break;
			case PS_DS_POLICY:
				getMorePolicyInfo();
				pGPO = getIPSecGPO();

				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
						IDS_IPSEC_DS_POLICY );
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
						IDS_IPSEC_POLICY_NAME, piAssignedPolicy.pszPolicyName );

				// description and timestamp - not available yet
				/*
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
						IDS_IPSEC_DESCRIPTION, piAssignedPolicy.pszPolicyDesc );
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
						IDS_IPSEC_TIMESTAMP );
				if (piAssignedPolicy.timestamp == 0)
				{
					AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
							IDS_GLOBAL_ADAPTER_UNKNOWN);
				}
				else
				{
					AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
							IDSSZ_GLOBAL_String, _tctime(&(piAssignedPolicy.timestamp)));
				}
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
						IDS_GLOBAL_EmptyLine);
				*/

				// GPO / OU
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
					IDS_IPSEC_GPO);
				if (pGPO)
				{
					AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
							IDSSZ_GLOBAL_String, pGPO->lpDisplayName);
				}
				else
				{
					AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
							IDS_GLOBAL_ADAPTER_UNKNOWN);
				}
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
						IDS_GLOBAL_EmptyLine);
                
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
					IDS_IPSEC_OU);
				if (pGPO)
				{
					AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
							IDSSZ_GLOBAL_String, pGPO->lpLink);
				}
				else
				{
					AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
							IDS_GLOBAL_ADAPTER_UNKNOWN);
				}
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
						IDS_GLOBAL_EmptyLine);

				// policy path
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
					IDS_IPSEC_POLICY_PATH);
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
					IDSSZ_GLOBAL_StringLine, piAssignedPolicy.pszPolicyPath);

				// cleanup GPO
				if (pGPO)
				{
					FreeGPOList (pGPO);
				}
				break;
			case PS_LOC_POLICY:
				getMorePolicyInfo();
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
						IDS_IPSEC_LOC_POLICY );
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
						IDS_IPSEC_POLICY_NAME, piAssignedPolicy.pszPolicyName );

				// description and timestamp
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
						IDS_IPSEC_DESCRIPTION, piAssignedPolicy.pszPolicyDesc );
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
						IDS_IPSEC_TIMESTAMP );
				if (piAssignedPolicy.timestamp == 0)
				{
					AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
							IDS_GLOBAL_ADAPTER_UNKNOWN);
					AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
							IDS_GLOBAL_EmptyLine);
				}
				else
				{
					AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
							IDSSZ_GLOBAL_String, _tctime(&(piAssignedPolicy.timestamp)));
				}

				// local policy path
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
					IDS_IPSEC_POLICY_PATH);
				AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
					IDS_IPSEC_LOCAL_PATH, piAssignedPolicy.pszPolicyPath);
				break;
			}
		}
		AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
				IDS_IPSEC_IPSECCMD );
	}

    return S_OK;
}

void IPSecGlobalPrint(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults)
{
	PrintMessage(pParams, IDS_GLOBAL_EmptyLine);
	if (bTestSkipped)
	{
		PrintTestTitleResult(pParams, IDS_IPSEC_LONG, IDS_IPSEC_SHORT, FALSE, S_FALSE, 0);
	}
	if (bTestPassed)
	{
        PrintTestTitleResult(pParams, IDS_IPSEC_LONG, IDS_IPSEC_SHORT, TRUE, S_OK, 0);
	}
    PrintMessageList(pParams, &pResults->IPSec.lmsgGlobalOutput);
    PrintMessageList(pParams, &pResults->IPSec.lmsgAdditOutput);
}


void IPSecPerInterfacePrint(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults, INTERFACE_RESULT *pInterfaceResults)
{
       return;
}


void IPSecCleanup(IN NETDIAG_PARAMS *pParams,
                     IN OUT NETDIAG_RESULT *pResults)
{
    MessageListCleanUp(&pResults->IPSec.lmsgGlobalOutput);
    MessageListCleanUp(&pResults->IPSec.lmsgAdditOutput);
}

//#define MSG_HANDLE_INVALID TEXT("Handle is invalid. Is IPSEC Policy Agent Service running?")

// this will call SDK' FormatMessage function but will also correct some awkward messages
// will work only for FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_SYSTEM flag combination
DWORD MyFormatMessage(
  DWORD dwFlags,      // source and processing options
  LPCVOID lpSource,   // pointer to  message source
  DWORD dwMessageId,  // requested message identifier
  DWORD dwLanguageId, // language identifier for requested message
  LPTSTR lpBuffer,    // pointer to message buffer
  DWORD nSize,        // maximum size of message buffer
  va_list *Arguments  // pointer to array of message inserts
)
{
	LPTSTR* tmp = (LPTSTR*) lpBuffer;

	switch (dwMessageId)
	{
/*	case ERROR_INVALID_HANDLE: // patch for "handle is invalid" message. Suggest to check if service is started
		if (dwFlags == (FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_SYSTEM))
		{
			*tmp = (LPTSTR) malloc((_tcslen(MSG_HANDLE_INVALID)+1)*sizeof(TCHAR));
			_tcscpy(*tmp, MSG_HANDLE_INVALID);
			return _tcslen(*tmp);
		}
		else
		{
			return FormatMessage(dwFlags,lpSource,dwMessageId,dwLanguageId,lpBuffer,nSize,Arguments);
		}
*/	default: // call standard method
		return FormatMessage(dwFlags,lpSource,dwMessageId,dwLanguageId,lpBuffer,nSize,Arguments);
	}
}

/********************************************************************
	FUNCTION: getPolicyInfo

	PURPOSE:  gets information about currently assigned policy 
	          into piAssignedPolicy global structure
	INPUT:    none

	RETURNS:  HRESULT. Will return ERROR_SUCCESS if everything is fine.
*********************************************************************/

HRESULT getPolicyInfo ( )
{
	LONG    lRegistryCallResult;
	HKEY    hRegKey;

	DWORD   dwType;            // for RegQueryValueEx
	DWORD   dwBufLen;          // for RegQueryValueEx

	lRegistryCallResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
										pcszGPTIPSecKey,
										0,
										KEY_READ,
										&hRegKey);

	if (lRegistryCallResult == ERROR_SUCCESS)
	{
		DWORD dwType;
		DWORD dwValue;
		DWORD dwLength = sizeof(DWORD);

		// query for flags, if flags aint' there or equal to 0, we don't have domain policy
		lRegistryCallResult = RegQueryValueEx(hRegKey,
					                          pcszGPTIPSecFlags,
					                          NULL,
					                          &dwType,
					                          (LPBYTE)&dwValue,
					                          &dwLength);

		if (lRegistryCallResult == ERROR_SUCCESS)
		{
			if (dwValue == 0)
				lRegistryCallResult = ERROR_FILE_NOT_FOUND;
		}

		// now get name
		if (lRegistryCallResult == ERROR_SUCCESS)
		{
			dwBufLen = MAXSTRLEN*sizeof(TCHAR);
			lRegistryCallResult = RegQueryValueEx( hRegKey,
												   pcszGPTIPSecName,
												   NULL,
												   &dwType, // will be REG_SZ
												   (LPBYTE) pszBuf,
												   &dwBufLen);
		}
	}

	if (lRegistryCallResult == ERROR_SUCCESS)
	{
		piAssignedPolicy.iPolicySource = PS_DS_POLICY;
		piAssignedPolicy.pszPolicyPath[0] = 0;
		_tcscpy(piAssignedPolicy.pszPolicyName, pszBuf);

		dwBufLen = MAXSTRLEN*sizeof(TCHAR);
		lRegistryCallResult = RegQueryValueEx( hRegKey,
											   pcszGPTIPSecPath,
											   NULL,
											   &dwType, // will be REG_SZ
											   (LPBYTE) pszBuf,
											   &dwBufLen);
		if (lRegistryCallResult == ERROR_SUCCESS)
		{
			_tcscpy(piAssignedPolicy.pszPolicyPath, pszBuf);
		}

		RegCloseKey(hRegKey);
		return ERROR_SUCCESS;
	}
	else
	{
		RegCloseKey(hRegKey);
		if (lRegistryCallResult == ERROR_FILE_NOT_FOUND)
		{   // DS reg key not found, check local
			lRegistryCallResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
												pcszLocIPSecKey,
												0,
												KEY_READ,
												&hRegKey);
			if (lRegistryCallResult == ERROR_SUCCESS)
			{
				dwBufLen = MAXSTRLEN*sizeof(TCHAR);
				lRegistryCallResult = RegQueryValueEx( hRegKey,
													   pcszLocIPSecPol,
													   NULL,
													   &dwType, // will be REG_SZ
													   (LPBYTE) pszBuf,
													   &dwBufLen);
			}
			else
			{
				return lRegistryCallResult; // return whatever error we got
			}

			RegCloseKey(hRegKey);

			if (lRegistryCallResult == ERROR_FILE_NOT_FOUND)
			{	// no policy assigned
				piAssignedPolicy.iPolicySource = PS_NO_POLICY;
				piAssignedPolicy.pszPolicyPath[0] = 0;
				piAssignedPolicy.pszPolicyName[0] = 0;
				return ERROR_SUCCESS;
			}
			else
			{	// read it
				lRegistryCallResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
													pszBuf,
													0,
													KEY_READ,
													&hRegKey);
				_tcscpy(piAssignedPolicy.pszPolicyPath, pszBuf);
				if (lRegistryCallResult == ERROR_SUCCESS)
				{
					dwBufLen = MAXSTRLEN*sizeof(TCHAR);
					lRegistryCallResult = RegQueryValueEx( hRegKey,
														   pcszIPSecName,
														   NULL,
														   &dwType, // will be REG_SZ
														   (LPBYTE) pszBuf,
														   &dwBufLen);
				}

				RegCloseKey(hRegKey);

				if (lRegistryCallResult == ERROR_FILE_NOT_FOUND)
					{	// no policy assigned
						piAssignedPolicy.iPolicySource = PS_NO_POLICY;
						piAssignedPolicy.pszPolicyPath[0] = 0;
						return ERROR_SUCCESS;
					}
				else if (lRegistryCallResult == ERROR_SUCCESS)
				{	// found it
					piAssignedPolicy.iPolicySource = PS_LOC_POLICY;
					_tcscpy(piAssignedPolicy.pszPolicyName, pszBuf);
				}
			}
		}
		return (HRESULT) lRegistryCallResult;
	}
}

/********************************************************************
	FUNCTION: getServiceInfo

	PURPOSE:  gets information about current state and configuration of IPSec Service 
	          into *pInfo structure
	INPUT:    pInfo - pointer to SERVICE_INFO structure which will be updated with current information
	TODO:	  

	RETURNS:  Win32 error codes. Will return ERROR_SUCCESS if everything is fine.
	          ERROR_SERVICE_DOES_NOT_EXIST is returned is service is not installed on the system
*********************************************************************/

DWORD getServiceInfo ( OUT PSERVICE_INFO pInfo )
{
	DWORD dwError = ERROR_SUCCESS;
	DWORD dwRequiredSize = 0;
	PVOID pLargeConfig = 0;
    SC_HANDLE   schMan = NULL;
    SC_HANDLE   schPA = NULL;

	if (!pInfo)
	{
		return ERROR_INVALID_PARAMETER;
	}

   memset(&(pInfo->servStat), 0, sizeof(SERVICE_STATUS));
   memset(&(pInfo->servConfig), 0, sizeof(QUERY_SERVICE_CONFIG));

	   
   schMan = OpenSCManager(NULL, NULL, GENERIC_READ);

   if (schMan == NULL)
   {
	   dwError = GetLastError();
	   goto error;
   }

   schPA = OpenService(schMan, IPSEC_SERVICE_NAME, GENERIC_READ);

   if (schMan == NULL)
   {
      dwError = GetLastError();
      goto error;
   }
   
   if (!QueryServiceStatus(schPA, &(pInfo->servStat)))
   {
      dwError = GetLastError();
      goto error;
   }
   
   if (!QueryServiceConfig(schPA, &(pInfo->servConfig), sizeof(QUERY_SERVICE_CONFIG), &dwRequiredSize))
   {
      dwError = GetLastError();
	  if (dwError == ERROR_INSUFFICIENT_BUFFER)
	  {
		  pLargeConfig = malloc(dwRequiredSize);
		  if (!pLargeConfig)
		  {
			  goto error;
		  }
          if (!QueryServiceConfig(schPA, (LPQUERY_SERVICE_CONFIG) pLargeConfig, dwRequiredSize, &dwRequiredSize))
		  {
		      dwError = GetLastError();
			  goto error;
		  }
		  // else we just got the information, copy over to *pInfo
		  memcpy(&(pInfo->servConfig), pLargeConfig, sizeof(QUERY_SERVICE_CONFIG));
		  dwError = ERROR_SUCCESS;
	  }

      goto error;
   }

error:
    if (schPA)
		CloseServiceHandle(schPA);
	if (schMan)
		CloseServiceHandle(schMan);
	if (pLargeConfig)
	{
		free(pLargeConfig);
	}
	return dwError;
}

/********************************************************************
	FUNCTION: reportError

	PURPOSE:  prints out message code and message itself
	INPUT: HRESULT - error code

	RETURNS: none
*********************************************************************/

void reportError ( HRESULT hr, NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults )
{
	LPTSTR msg = NULL;

	MyFormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_SYSTEM,  
		NULL, hr, 0, (LPTSTR) &msg,    0,    NULL );
		
	AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
				IDS_IPSEC_ERROR_MSG, hr, msg );
}

/********************************************************************
	FUNCTION: reportServiceInfo

	PURPOSE:  prints out service status and startup information
	INPUT: none

	RETURNS: none
*********************************************************************/
void reportServiceInfo ( NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults )
{
	// print status information
	AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
			IDS_IPSEC_PA_STATUS );
	switch (siIPSecStatus.servStat.dwCurrentState)
	{
		case SERVICE_RUNNING:
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
					IDS_IPSEC_PA_STARTED );
			break;
		case SERVICE_STOPPED:
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
					IDS_IPSEC_PA_STOPPED );
			break;
		case SERVICE_PAUSED:
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
					IDS_IPSEC_PA_PAUSED );
			break;
		default:
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
					IDS_GLOBAL_ADAPTER_UNKNOWN);
			break;
	}
	AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
			IDS_GLOBAL_EmptyLine);

	// print config information
	AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
			IDS_IPSEC_PA_STARTUP );
	switch (siIPSecStatus.servConfig.dwStartType)
	{
		case SERVICE_AUTO_START:
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
					IDS_IPSEC_PA_AUTOMATIC );
			break;
		case SERVICE_DEMAND_START:
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
					IDS_IPSEC_PA_MANUAL );
			break;
		case SERVICE_DISABLED:
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
					IDS_IPSEC_PA_DISABLED );
			break;
		default:
			AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
					IDS_GLOBAL_ADAPTER_UNKNOWN);
			break;
	}
	AddMessageToList( &pResults->IPSec.lmsgGlobalOutput, Nd_Verbose, 
			IDS_GLOBAL_EmptyLine);
}

/********************************************************************
	FUNCTION: getIPSecGPO

	PURPOSE:  returns GPO that is assigning IPSec Policy
	INPUT:    none

	RETURNS: pointer to GROUP_POLICY_OBJECT structure
	         NULL if policy is not assigned or if GPO information is not retrievable
	NOTES:   Tested only with domain GPOs
	         Behaves unpredictably when run for the computer 
			   that does not have active Directory IPSec policy assigned
			 CALLER is responsible for freeing the memory!
*********************************************************************/
PGROUP_POLICY_OBJECT getIPSecGPO ( )
{
    HKEY hKey, hSubKey;
    DWORD dwType, dwSize, dwIndex, dwNameSize;
    LONG lResult;
    TCHAR szName[50];
    GUID guid;
    PGROUP_POLICY_OBJECT pGPO, pGPOTemp;
	PGROUP_POLICY_OBJECT pGPOReturn = NULL;
	DWORD dwResult;

    //
    // Enumerate the extensions
    //

    lResult = RegOpenKeyEx (HKEY_LOCAL_MACHINE, GPEXT_KEY, 0, KEY_READ, &hKey);

    if (lResult == ERROR_SUCCESS)
    {

        dwIndex = 0;
        dwNameSize = 50;

        while ((dwResult = RegEnumKeyEx (hKey, dwIndex++, szName, &dwNameSize, NULL, NULL,
                          NULL, NULL)) == ERROR_SUCCESS)
        {

	        dwNameSize = 50;

            //
            // Skip the registry extension since we did it above
            //

            if (lstrcmpi(TEXT("{35378EAC-683F-11D2-A89A-00C04FBBCFA2}"), szName))
            {

                //
                // Get the list of GPOs this extension applied
                //

                StringToGuid(szName, &guid);

                lResult = GetAppliedGPOList (GPO_LIST_FLAG_MACHINE, NULL, NULL,
                                             &guid, &pGPO);

                if (lResult == ERROR_SUCCESS)
                {
                    if (pGPO)
                    {
                        //
                        // Get the extension's friendly display name
                        //

                        lResult = RegOpenKeyEx (hKey, szName, 0, KEY_READ, &hSubKey);

                        if (lResult == ERROR_SUCCESS)
                        {
							if (!lstrcmpi(TEXT("{e437bc1c-aa7d-11d2-a382-00c04f991e27}"), szName))
                            {
                               // found IPSec
								return pGPO;
                            }
							else
							{
								FreeGPOList(pGPO);
							}
						}
					}
				}
			}
		}
	}

	return pGPOReturn;
}

//*************************************************************
//
//  StringToGuid()
//
//  Purpose:    Converts a GUID in string format to a GUID structure
//
//  Parameters: szValue - guid in string format
//              pGuid   - guid structure receiving the guid
//
//
//  Return:     void
//
//*************************************************************

void StringToGuid( TCHAR * szValue, GUID * pGuid )
{
    TCHAR wc;
    INT i;

    //
    // If the first character is a '{', skip it
    //
    if ( szValue[0] == TEXT('{') )
        szValue++;

    //
    // Since szValue may be used again, no permanent modification to
    // it is be made.
    //

    wc = szValue[8];
    szValue[8] = 0;
    pGuid->Data1 = _tcstoul( &szValue[0], 0, 16 );
    szValue[8] = wc;
    wc = szValue[13];
    szValue[13] = 0;
    pGuid->Data2 = (USHORT)_tcstoul( &szValue[9], 0, 16 );
    szValue[13] = wc;
    wc = szValue[18];
    szValue[18] = 0;
    pGuid->Data3 = (USHORT)_tcstoul( &szValue[14], 0, 16 );
    szValue[18] = wc;

    wc = szValue[21];
    szValue[21] = 0;
    pGuid->Data4[0] = (unsigned char)_tcstoul( &szValue[19], 0, 16 );
    szValue[21] = wc;
    wc = szValue[23];
    szValue[23] = 0;
    pGuid->Data4[1] = (unsigned char)_tcstoul( &szValue[21], 0, 16 );
    szValue[23] = wc;

    for ( i = 0; i < 6; i++ )
    {
        wc = szValue[26+i*2];
        szValue[26+i*2] = 0;
        pGuid->Data4[2+i] = (unsigned char)_tcstoul( &szValue[24+i*2], 0, 16 );
        szValue[26+i*2] = wc;
    }
}

/********************************************************************
	FUNCTION: getMorePolicyInfo

	PURPOSE:  gets additional information about currently assigned policy 
	          into piAssignedPolicy global structure
	INPUT:    none, uses global piAssignedPolicy structure
	          particularly
			    iPolicySource
				pszPolicyName
				pszPolicyPath
			  fields

	RETURNS:  HRESULT. Will return ERROR_SUCCESS if everything is fine.
	          Currently fills pszPolicyDesc and timestamp fields of the global structure

    NOTES:    This is separate from getPolicyInfo routine for two reasons
	             a) the information obtained here is optional and error during this particular routine
				    is not considered fatal
				 b) the code structure is simpler as this routine is "built on top" of what getPolicyInfo provides
*********************************************************************/

DWORD getMorePolicyInfo ( )
{
	DWORD   dwError = ERROR_SUCCESS;
	HKEY    hRegKey = NULL;

	DWORD   dwType;            // for RegQueryValueEx
	DWORD   dwBufLen;          // for RegQueryValueEx
	DWORD   dwValue;
	DWORD   dwLength = sizeof(DWORD);

	PTCHAR* ppszExplodeDN = NULL;

	// set some default values
    piAssignedPolicy.pszPolicyDesc[0] = 0;
	piAssignedPolicy.timestamp  = 0;

	switch (piAssignedPolicy.iPolicySource)
	{
		case PS_LOC_POLICY:
			// open the key
			dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
									piAssignedPolicy.pszPolicyPath,
									0,
									KEY_READ,
									&hRegKey);
			BAIL_ON_WIN32_ERROR(dwError);

			// timestamp
			dwError = RegQueryValueEx(hRegKey,
					                  pcszIPSecTimestamp,
					                  NULL,
					                  &dwType,
					                  (LPBYTE)&dwValue,
					                  &dwLength);
			BAIL_ON_WIN32_ERROR(dwError);
			piAssignedPolicy.timestamp = dwValue;

			// description
			dwBufLen = MAXSTRLEN*sizeof(TCHAR);
			dwError  = RegQueryValueEx( hRegKey,
						 			    pcszIPSecDesc,
										NULL,
										&dwType, // will be REG_SZ
										(LPBYTE) pszBuf,
										&dwBufLen);
			BAIL_ON_WIN32_ERROR(dwError);
			_tcscpy(piAssignedPolicy.pszPolicyDesc, pszBuf);

			break;

		case PS_DS_POLICY:
			// get the policy name from DN
            _tcscpy(pszBuf, pcszCacheIPSecKey);
			ppszExplodeDN = ldap_explode_dn(piAssignedPolicy.pszPolicyPath, 1);
			if (!ppszExplodeDN)
			{
				goto error;
			}
			_tcscat(pszBuf, TEXT("\\"));
			_tcscat(pszBuf, ppszExplodeDN[0]);

			// open the regkey
			dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
									pszBuf,
									0,
									KEY_READ,
									&hRegKey);
			BAIL_ON_WIN32_ERROR(dwError);

			/* - tomestamp and description are not available yet
			// timestamp
			dwError = RegQueryValueEx(hRegKey,
					                  pcszIPSecTimestamp,
					                  NULL,
					                  &dwType,
					                  (LPBYTE)&dwValue,
					                  &dwLength);
			BAIL_ON_WIN32_ERROR(dwError);
			piAssignedPolicy.timestamp = dwValue;

			// description
			dwBufLen = MAXSTRLEN*sizeof(TCHAR);
			dwError  = RegQueryValueEx( hRegKey,
						 			    pcszIPSecDesc,
										NULL,
										&dwType, // will be REG_SZ
										(LPBYTE) pszBuf,
										&dwBufLen);
			BAIL_ON_WIN32_ERROR(dwError);
			_tcscpy(piAssignedPolicy.pszPolicyDesc, pszBuf);
			*/

			break;
	}

error:
	if (hRegKey)
	{
		RegCloseKey(hRegKey);
	}
	if (ppszExplodeDN)
	{
		ldap_value_free(ppszExplodeDN);
	}
	return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\ldaptest.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      ldaptest.c
//
//  Abstract:
//
//      Queries into network drivers
//
//  Author:
//
//      Anilth  - 4-20-1998 
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//--

#include "precomp.h"
#include "malloc.h"

BOOL TestLdapOnDc(IN PTESTED_DC TestedDc, NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults);
DWORD TestSpnOnDC(IN PTESTED_DC pDcInfo, NETDIAG_RESULT*  pResults);

HRESULT LDAPTest( NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
{
    HRESULT     hr = S_OK;

    BOOL RetVal = TRUE;
    PTESTED_DOMAIN TestedDomain = pParams->pDomain;
    PTESTED_DC TestedDc = NULL;
    PLIST_ENTRY ListEntry;
    BOOLEAN OneLdapFailed = FALSE;
    BOOLEAN OneLdapWorked = FALSE;
    BOOL fSpnTested = FALSE;
    BOOL fSpnPassed = FALSE;

    NET_API_STATUS NetStatus;

    //if the machine is a member machine or DC, LDAP Test will get called. 
    //Otherwise, the test will be skipped
    pResults->LDAP.fPerformed = TRUE;

    // assume link entry is initialized to 0000
    if(pResults->LDAP.lmsgOutput.Flink == NULL)
        InitializeListHead(&pResults->LDAP.lmsgOutput);

    PrintStatusMessage(pParams, 4, IDS_LDAP_STATUS_MSG, TestedDomain->PrintableDomainName);

    //
    // If a DC hasn't been discovered yet,
    //  find one.
    //

    if ( TestedDomain->DcInfo == NULL ) 
    {
        LPTSTR pszDcType;

        if ( TestedDomain->fTriedToFindDcInfo ) 
        {
            CHK_HR_CONTEXT(pResults->LDAP, S_FALSE, IDS_LDAP_NODC);
        }

        pszDcType = LoadAndAllocString(IDS_DCTYPE_DC);
        NetStatus = DoDsGetDcName( pParams,
                                   pResults,
                                   &pResults->LDAP.lmsgOutput,
                                   TestedDomain,
                                   DS_DIRECTORY_SERVICE_PREFERRED,
                                   "DC",
                                   FALSE,
                                   &TestedDomain->DcInfo );
        Free(pszDcType);

        TestedDomain->fTriedToFindDcInfo = TRUE;

        if ( NetStatus != NO_ERROR ) 
        {
            CHK_HR_CONTEXT(pResults->LDAP, hr = HRESULT_FROM_WIN32(NetStatus), IDS_LDAP_NODC);
        }
    }



    //
    // Ensure the DC is running the Ds.
    //

    if ( (TestedDomain->DcInfo->Flags & DS_DS_FLAG) == 0 ) 
    {
        AddIMessageToList(&pResults->LDAP.lmsgOutput, Nd_Quiet, 0, IDS_LDAP_NOTRUNNINGDS, 
                          TestedDomain->DcInfo->DomainControllerName);
    }

    //
    // Test ldap on all of the found DCs in the domain.
    //

    for ( ListEntry = TestedDomain->TestedDcs.Flink ;
          ListEntry != &TestedDomain->TestedDcs ;
          ListEntry = ListEntry->Flink ) {


        //
        // Loop through the list of DCs in this domain
        //

        TestedDc = CONTAINING_RECORD( ListEntry, TESTED_DC, Next );

        //
        // Only run test on DCs that might support LDAP.
        //

        if ( TestedDc->Flags & DC_IS_NT5 ) 
        {
            if ( !TestLdapOnDc( TestedDc, pParams, pResults ) ) 
                OneLdapFailed = TRUE;
            else
                OneLdapWorked = TRUE;

            //test the SPN registration if this is a DC on the primary domain
            if (TestedDomain->fPrimaryDomain)
            {
                fSpnTested = TRUE;
                if (TestSpnOnDC(TestedDc, pResults))
                    fSpnPassed = TRUE;
            }
        } 
        else 
        {
            AddIMessageToList(&pResults->LDAP.lmsgOutput, Nd_ReallyVerbose, 0, 
                        IDS_LDAP_NOTRUNNINGDS_SKIP, TestedDc->ComputerName);
        }

    }

    //
    // If one of the DCs failed,
    //  and none worked.
    //  Don't do any more tests.
    //
    if ( OneLdapFailed  && !OneLdapWorked ) 
    {
        AddIMessageToList(&pResults->LDAP.lmsgOutput, Nd_Quiet, 0, 
                    IDS_LDAP_NOLDAPSERVERSWORK, TestedDomain->PrintableDomainName);
        
        CHK_HR_CONTEXT(pResults->LDAP, hr = E_FAIL, 0);
    }

    if ( fSpnTested && !fSpnPassed )
    {
        //IDS_LDAP_NO_SPN                       "    [FATAL] The default SPNs are not properly registered on and DCs.\n"
        AddIMessageToList(&pResults->LDAP.lmsgOutput, Nd_Quiet, 0, 
                    IDS_LDAP_NO_SPN);
        CHK_HR_CONTEXT(pResults->LDAP, hr = E_FAIL, 0);
    }

L_ERR:

    //$REVIEW (nsun) we should return S_FALSE or S_OK 
    //so that we can go on with other tests
    if (!FHrOK(hr))
        hr = S_FALSE;
    return hr;
} 

DWORD TestSpnOnDC(IN PTESTED_DC pDcInfo, NETDIAG_RESULT*  pResults)
{
    WCHAR FlatName[ MAX_PATH + 1 ];
    PWSTR Dot ;
    HANDLE hDs = NULL;
    ULONG NetStatus ;
    PDS_NAME_RESULTW Result ;
    LPWSTR Flat = FlatName;
    LDAP *ld = NULL;
    int rc;
    LDAPMessage *e, *res;
    WCHAR *base_dn;
    WCHAR *search_dn, search_ava[ MAX_PATH + 30 ];
    WCHAR Domain[ MAX_PATH + 1 ];
    CHAR szDefaultFqdnSpn[MAX_PATH + 10];
    CHAR szDefaultShortSpn[MAX_PATH + 10];
    BOOL fFqdnSpnFound = FALSE;
    BOOL fShortSpnFound = FALSE;
    BOOL fFailQuerySpn = FALSE;
    
    USES_CONVERSION;

    //construct the default SPN's
    lstrcpy(szDefaultFqdnSpn, _T("HOST/"));
    lstrcat(szDefaultFqdnSpn, pResults->Global.szDnsHostName);
    lstrcpy(szDefaultShortSpn, _T("HOST/"));
    lstrcat(szDefaultShortSpn, W2T(pResults->Global.swzNetBiosName));

    wcscpy(Domain, GetSafeStringW(pDcInfo->TestedDomain->DnsDomainName ? 
                                                pDcInfo->TestedDomain->DnsDomainName :
                                                pDcInfo->TestedDomain->NetbiosDomainName));

    ld = ldap_open(W2A(pDcInfo->ComputerName), LDAP_PORT);
    if (ld == NULL) {
        DebugMessage2("ldap_init failed = %x", LdapGetLastError());
        fFailQuerySpn = TRUE;
        goto L_ERROR;
    }

    rc = ldap_bind_s(ld, NULL, NULL, LDAP_AUTH_NEGOTIATE);
    if (rc != LDAP_SUCCESS) {
        DebugMessage2("ldap_bind failed = %x", LdapGetLastError());
        fFailQuerySpn = TRUE;
        goto L_ERROR;

    }

    NetStatus = DsBindW( NULL, Domain, &hDs );
    if ( NetStatus != 0 )
    {
        DebugMessage3("Failed to bind to DC of domain %ws, %#x\n", 
               Domain, NetStatus );
        fFailQuerySpn = TRUE;
        goto L_ERROR;
    }

    Dot = wcschr( Domain, L'.' );

    if ( Dot )
    {
        *Dot = L'\0';
    }
    
    wcscpy( FlatName, Domain );

    if ( Dot )
    {
        *Dot = L'.' ;
    }

    wcscat( FlatName, L"\\" );
    wcscat( FlatName, pResults->Global.swzNetBiosName );
    wcscat( FlatName, L"$" );

    NetStatus = DsCrackNamesW(
                    hDs,
                    0,
                    DS_NT4_ACCOUNT_NAME,
                    DS_FQDN_1779_NAME,
                    1,
                    &Flat,
                    &Result );

    if ( NetStatus != 0)
    {
        DebugMessage3("Failed to crack name %ws into the FQDN, %#x\n",
               FlatName, NetStatus );

        DsUnBind( &hDs );

        fFailQuerySpn = TRUE;
        goto L_ERROR;
    }

    search_dn = pResults->Global.swzNetBiosName;

    if (0 == Result->cItems)
    {
        DsUnBind( &hDs );

        fFailQuerySpn = TRUE;
        goto L_ERROR;
    }

    if (DS_NAME_NO_ERROR != Result->rItems[0].status || NULL == Result->rItems[0].pName)
    {
        DsUnBind( &hDs );

        fFailQuerySpn = TRUE;
        goto L_ERROR;
    }

    base_dn = wcschr(Result->rItems[0].pName, L',');

    if (!base_dn)
        base_dn = Result->rItems[0].pName;
    else
        base_dn++;
    
    DsUnBind( &hDs );

    swprintf(search_ava, L"(sAMAccountName=%s$)", search_dn);

    rc = ldap_search_s(ld, W2A(base_dn), LDAP_SCOPE_SUBTREE,
               W2A(search_ava), NULL, 0, &res);
    
    //base_dn can no longer be used because base_dn refers to that buffer
    DsFreeNameResultW( Result );

    if (rc != LDAP_SUCCESS) {
        DebugMessage2("ldap_search_s failed: %s", ldap_err2string(rc));
        fFailQuerySpn = TRUE;
        goto L_ERROR;
    }

    for (e = ldap_first_entry(ld, res);
     e;
     e = ldap_next_entry(ld, e)) 
    {
        BerElement *b;
        CHAR *attr;
        
        //IDS_LDAP_REG_SPN  "Registered Service Principal Names:\n"
        AddIMessageToList(&pResults->LDAP.lmsgOutput, Nd_ReallyVerbose, 0, 
                    IDS_LDAP_REG_SPN);
        
        for (attr = ldap_first_attribute(ld, e, &b);
             attr;
             attr = ldap_next_attribute(ld, e, b)) 
        {
            CHAR **values, **p;
            values = ldap_get_values(ld, e, attr);
            for (p = values; *p; p++) 
            {
                if (strcmp(attr, "servicePrincipalName") == 0)
                {
                    // IDS_LDAP_SPN_NAME    "    %s\n"
                    AddIMessageToList(&pResults->LDAP.lmsgOutput, Nd_ReallyVerbose, 0,
                                    IDS_LDAP_SPN_NAME, *p);
                    
                    if (0 == _stricmp(*p, szDefaultFqdnSpn))
                        fFqdnSpnFound = TRUE;
                    else if (0 == _stricmp(*p, szDefaultShortSpn))
                        fShortSpnFound = TRUE;
                }
            }
            ldap_value_free(values);
            ldap_memfree(attr);
        }

    }

    ldap_msgfree(res);

L_ERROR:
    if (ld)
    {
        ldap_unbind(ld);
    }

    //Only report fatal error when we successfully query SPN registration
    //and all DCs doesn't have the default SPN's
    if (fFailQuerySpn)
    {
        //IDS_LDAP_SPN_FAILURE  "Failed to query SPN registration from DC %ws.\n"
        AddIMessageToList(&pResults->LDAP.lmsgOutput, Nd_Quiet, 0,
                        IDS_LDAP_SPN_FAILURE, pDcInfo->ComputerName);
        return TRUE;
    }
    else if (!fFqdnSpnFound || !fShortSpnFound)
    {
        //IDS_LDAP_SPN_MISSING              "    [WARNING] The default SPN registration for '%s' is missing on DC '%ws'.\n"
        if (!fFqdnSpnFound)
            AddIMessageToList(&pResults->LDAP.lmsgOutput, Nd_Quiet, 0,
                        IDS_LDAP_SPN_MISSING, szDefaultFqdnSpn, pDcInfo->ComputerName);

        if (!fShortSpnFound)
            AddIMessageToList(&pResults->LDAP.lmsgOutput, Nd_Quiet, 0,
                        IDS_LDAP_SPN_MISSING, szDefaultShortSpn, pDcInfo->ComputerName);

        return FALSE;
    }
    else
        return TRUE;
}

void LDAPGlobalPrint(IN NETDIAG_PARAMS *pParams, IN OUT NETDIAG_RESULT *pResults)
{
    if (pParams->fVerbose || !FHrOK(pResults->LDAP.hr))
    {
        PrintNewLine(pParams, 2);
        PrintTestTitleResult(pParams, IDS_LDAP_LONG, IDS_LDAP_SHORT, pResults->LDAP.fPerformed, 
                             pResults->LDAP.hr, 0);
        
        if (!FHrOK(pResults->LDAP.hr))
        {
            if(pResults->LDAP.idsContext)
                PrintError(pParams, pResults->LDAP.idsContext, pResults->LDAP.hr);
        }

        PrintMessageList(pParams, &pResults->LDAP.lmsgOutput);
    }

}

void LDAPPerInterfacePrint(IN NETDIAG_PARAMS *pParams,
                             IN OUT NETDIAG_RESULT *pResults,
                             IN INTERFACE_RESULT *pIfResult)
{
    // no perinterface information
}

void LDAPCleanup(IN NETDIAG_PARAMS *pParams,
                         IN OUT NETDIAG_RESULT *pResults)
{
    MessageListCleanUp(&pResults->LDAP.lmsgOutput);
    pResults->LDAP.lmsgOutput.Flink =  NULL;
}


BOOL
TestLdapOnDc(
    IN PTESTED_DC TestedDc,NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults
    )
/*++

Routine Description:


    Ensure we can use LDAP focused at the specified DC

Arguments:

    TestedDc - Description of DC to test

Return Value:

    TRUE: Test suceeded.
    FALSE: Test failed

--*/
{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;
    BOOL RetVal = TRUE;
    int LdapMessageId;
    PLDAPMessage LdapMessage = NULL;
    PLDAPMessage CurrentEntry;
    int LdapError;
    ULONG AuthType;
    LPSTR AuthTypeName;
    LPWSTR DcIpAddress;

    LDAP *LdapHandle = NULL;

    //
    // Avoid this test if the DC is already known to be down.
    //

    if ( TestedDc->Flags & DC_IS_DOWN ) {
        AddIMessageToList(&pResults->LDAP.lmsgOutput, Nd_ReallyVerbose, 0, 
                IDS_LDAP_DCDOWN, TestedDc->ComputerName);

        goto Cleanup;
    }

    //
    // If there is no IP Address,
    //  get it.
    //

    if ( !GetIpAddressForDc( TestedDc ) ) {
        AddIMessageToList(&pResults->LDAP.lmsgOutput, Nd_Quiet, 0, 
                IDS_LDAP_NOIPADDR, TestedDc->ComputerName);
        RetVal = FALSE;
        goto Cleanup;
    }

    DcIpAddress = TestedDc->DcIpAddress;

    //
    // Loop trying each type of authentication.
    //

    for ( AuthType = 0; AuthType < 3; AuthType++ ) {
        int AuthMethod;
        SEC_WINNT_AUTH_IDENTITY_W NtAuthIdentity;
        LPSTR AuthGuru;

        //
        // Bind as appropropriate
        //

        RtlZeroMemory( &NtAuthIdentity, sizeof(NtAuthIdentity));
        NtAuthIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
        switch ( AuthType ) {
        case 0:
            AuthTypeName = "un-";
            break;
        case 1:
            AuthTypeName = "NTLM ";
            AuthMethod = LDAP_AUTH_NTLM;
            AuthGuru = NTLM_GURU;
            break;
        case 2:
            AuthTypeName = "Negotiate ";
            AuthMethod = LDAP_AUTH_NEGOTIATE;
            AuthGuru = KERBEROS_GURU;
            break;

        }

        //
        // Only Members and Domain controllers can use authenticated RPC.
        //

        if ( AuthType != 0 ) {
            if ( pResults->Global.pPrimaryDomainInfo->MachineRole == DsRole_RoleMemberWorkstation ||
                 pResults->Global.pPrimaryDomainInfo->MachineRole == DsRole_RoleMemberServer ||
                 pResults->Global.pPrimaryDomainInfo->MachineRole == DsRole_RoleBackupDomainController ||
                 pResults->Global.pPrimaryDomainInfo->MachineRole == DsRole_RolePrimaryDomainController ) {

                //
                // If we're logged onto a local account,
                //  we can't test authenticated RPC.
                //

                if ( pResults->Global.pLogonDomain == NULL ) {
                    AddIMessageToList(&pResults->LDAP.lmsgOutput, Nd_Quiet, 0, 
                        IDS_LDAP_LOGONASLOCALUSER, 
                        pResults->Global.pLogonDomainName, 
                        pResults->Global.pLogonUser, 
                        AuthTypeName, TestedDc->ComputerName);
                    goto Cleanup;
                }

            } else {
                goto Cleanup;
            }
        }

        AddIMessageToList(&pResults->LDAP.lmsgOutput, Nd_ReallyVerbose, 0, 
                    IDS_LDAP_DOAUTHEN, 
                    AuthTypeName, TestedDc->ComputerName);

        //
        // Cleanup from a previous iteration.
        //

        if ( LdapMessage != NULL ) 
        {
            ldap_msgfree( LdapMessage );
            LdapMessage = NULL;
        }

        if ( LdapHandle != NULL ) 
        {
            ldap_unbind( LdapHandle );
            LdapHandle = NULL;
        }

        //
        // Connect to the DC.
        //

        LdapHandle = ldap_openW( DcIpAddress, LDAP_PORT );

        if ( LdapHandle == NULL ) 
        {

            AddIMessageToList(&pResults->LDAP.lmsgOutput, Nd_Quiet, 0, 
                    IDS_LDAP_CANNOTOPEN, 
                    TestedDc->ComputerName, DcIpAddress );
            goto Cleanup;
        }

        //
        // Bind to the DC.
        //

        if ( AuthType != 0 ) {
            LdapError = ldap_bind_s( LdapHandle, NULL, (char *)&NtAuthIdentity, AuthMethod );

            if ( LdapError != LDAP_SUCCESS ) {
                AddIMessageToList(&pResults->LDAP.lmsgOutput, Nd_Quiet, 0, 
                    IDS_LDAP_CANNOTBIND, 
                    AuthTypeName, TestedDc->ComputerName, ldap_err2stringA(LdapError) );

                //
                // Try other authentication methods.
                //
                RetVal = FALSE;
                continue;
            }


        }


        //
        // Do a trivial search to isolate LDAP problems from authentication
        //  problems
        //

        LdapError = ldap_search_sA(
                            LdapHandle,
                            NULL,       // DN
                            LDAP_SCOPE_BASE,
                            "(objectClass=*)",          // filter
                            NULL,
                            FALSE,
                            &LdapMessage );

        if ( LdapError != LDAP_SUCCESS ) {
            AddIMessageToList(&pResults->LDAP.lmsgOutput, Nd_Quiet, 0, 
                    IDS_LDAP_CANNOTSEARCH, 
                    AuthTypeName, TestedDc->ComputerName, ldap_err2stringA(LdapError) );
            goto Cleanup;
        }

        //
        // How many entries were returned.
        //
        AddIMessageToList(&pResults->LDAP.lmsgOutput, Nd_ReallyVerbose, 0, 
                IDS_LDAP_ENTRIES, 
                ldap_count_entries( LdapHandle, LdapMessage ) );


        //
        // Print the entries.
        //

        CurrentEntry = ldap_first_entry( LdapHandle, LdapMessage );

        while ( CurrentEntry != NULL ) 
        {
            PVOID Context;
            char *AttrName;

            //
            // Test for error
            //
            if ( LdapHandle->ld_errno != 0 ) 
            {
                AddIMessageToList(&pResults->LDAP.lmsgOutput, Nd_Quiet, 0, 
                        IDS_LDAP_CANNOTFIRSTENTRY, 
                        TestedDc->ComputerName, ldap_err2stringA(LdapHandle->ld_errno) );
                goto Cleanup;
            }

            //
            // Walk through the list of returned attributes.
            //

            AttrName = ldap_first_attributeA( LdapHandle, CurrentEntry, (PVOID)&Context );
            while ( AttrName != NULL ) 
            {
                PLDAP_BERVAL *Berval;


                //
                // Test for error
                //

                if ( LdapHandle->ld_errno != 0 ) {
                    AddIMessageToList(&pResults->LDAP.lmsgOutput, Nd_Quiet, 0, 
                            IDS_LDAP_CANNOTFIRSTATTR, 
                            TestedDc->ComputerName, ldap_err2stringA(LdapHandle->ld_errno) );
                    goto Cleanup;
                }

                //
                // Grab the attribute and it's value
                //

                AddIMessageToList(&pResults->LDAP.lmsgOutput, Nd_ReallyVerbose, 0, 
                        IDS_LDAP_ATTR, AttrName );

                Berval = ldap_get_values_lenA( LdapHandle, CurrentEntry, AttrName );

                if ( Berval == NULL ) 
                {
                    AddIMessageToList(&pResults->LDAP.lmsgOutput, Nd_Quiet, 0, 
                        IDS_LDAP_CANNOTLEN, 
                        TestedDc->ComputerName, ldap_err2stringA(LdapHandle->ld_errno) );
                    goto Cleanup;
                } 
                else 
                {
                    int i;
                    for ( i=0; Berval[i] != NULL; i++ ) {
                        AddIMessageToList(&pResults->LDAP.lmsgOutput, Nd_ReallyVerbose, 0, 
                            IDS_LDAP_VAL, 
                            Berval[i]->bv_len, Berval[i]->bv_val );
                    }
                    ldap_value_free_len( Berval );
                }


                //
                // Get the next entry
                //

                AttrName = ldap_next_attributeA( LdapHandle, CurrentEntry, (PVOID)Context );
            }


            //
            // Get the next entry
            //

            CurrentEntry = ldap_next_entry( LdapHandle, CurrentEntry );

        }

    }



Cleanup:


    if ( LdapMessage != NULL ) {
        ldap_msgfree( LdapMessage );
    }

    return RetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\machine.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      machine.c
//
//  Abstract:
//
//    Test to ensure that a workstation has network (IP) connectivity to
//      the outside.
//
//  Author:
//
//     15-Dec-1997 (cliffv)
//      Anilth  - 4-20-1998 
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//--

//
// Common include files.
//
#include "precomp.h"
#include "strings.h"

HRESULT GetHotfixInfo(NETDIAG_RESULT *pResults, HKEY hkeyLocalMachine);


/*!--------------------------------------------------------------------------
    GetMachineSpecificInfo
        Get the OS info for the specified machine.
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT GetMachineSpecificInfo(IN NETDIAG_PARAMS *pParams,
                               IN OUT NETDIAG_RESULT *pResults)
{
    HKEY    hkey = HKEY_LOCAL_MACHINE;
    HKEY    hkeyBuildNumber = NULL;
    HKEY    hkeyNTType;
    DWORD   dwErr;
    DWORD   dwType, dwLen;
    DWORD   dwMaxLen = 0;
    HRESULT hr = hrOK;
    TCHAR   szBuffer[256];

    CheckErr( RegOpenKeyEx( hkey,
                            c_szRegKeyWindowsNTCurrentVersion,
                            0,
                            KEY_READ,
                            &hkeyBuildNumber) );

    RegQueryInfoKey(hkeyBuildNumber,
                    NULL,           // lpclass
                    NULL,           // lpcbClass
                    NULL,           // lpReserved
                    NULL,           // lpcSubkeys
                    NULL,           // lpcbMaxSubkeyLen
                    NULL,           // lpcbMaxClassLen
                    NULL,           // lpcValues
                    NULL,           // lpcbMaxValueNameLen
                    &dwMaxLen,      // lpcbMaxValueLen
                    NULL,           // lpSecurity
                    NULL);          // last write time

    pResults->Global.pszCurrentVersion = Malloc((dwMaxLen+1) * sizeof(TCHAR));
    if (pResults->Global.pszCurrentVersion == NULL)
        CheckHr( E_OUTOFMEMORY );

    pResults->Global.pszCurrentBuildNumber = Malloc((dwMaxLen+1) * sizeof(TCHAR));
    if (pResults->Global.pszCurrentBuildNumber == NULL)
        CheckHr( E_OUTOFMEMORY );

    pResults->Global.pszCurrentType = Malloc((dwMaxLen+1) * sizeof(TCHAR));
    if (pResults->Global.pszCurrentType == NULL)
        CheckHr( E_OUTOFMEMORY );

    dwLen = dwMaxLen;
    CheckErr( RegQueryValueEx(hkeyBuildNumber,
                              c_szRegCurrentType,
                              (LPDWORD) NULL,
                              &dwType,
                              (LPBYTE) pResults->Global.pszCurrentType,
                              &dwLen) );

    dwLen = dwMaxLen;
    CheckErr( RegQueryValueEx(hkeyBuildNumber,
                              c_szRegCurrentVersion,
                              (LPDWORD) NULL,
                              &dwType,
                              (LPBYTE) pResults->Global.pszCurrentVersion,
                              &dwLen) );

    dwLen = dwMaxLen;
    dwErr = RegQueryValueEx( hkeyBuildNumber,
                             c_szRegCurrentBuildNumber,
                             (LPDWORD) NULL,
                             &dwType,
                             (LPBYTE) pResults->Global.pszCurrentBuildNumber,
                             &dwLen);

    if (dwErr != ERROR_SUCCESS) {

        dwLen = dwMaxLen;
        dwErr = RegQueryValueEx( hkeyBuildNumber,
                                 c_szRegCurrentBuild,
                                 (LPDWORD) NULL,
                                 &dwType,
                                 (LPBYTE) pResults->Global.pszCurrentBuildNumber,
                                 & dwLen);

    }

    GetEnvironmentVariable(_T("PROCESSOR_IDENTIFIER"),
                           szBuffer,
                           DimensionOf(szBuffer));
    pResults->Global.pszProcessorInfo = StrDup(szBuffer);

    
    CheckErr( RegOpenKeyEx( hkey,
                            c_szRegKeyControlProductOptions,
                            0,
                            KEY_READ,
                            &hkeyNTType) );
    dwLen = DimensionOf(szBuffer);
    dwErr = RegQueryValueEx( hkeyNTType,
                             _T("ProductType"),
                             (LPDWORD) NULL,
                             &dwType,
                             (LPBYTE) szBuffer,
                             & dwLen);
    if (dwErr == ERROR_SUCCESS)
    {
        if (StriCmp(szBuffer, _T("WinNT")) == 0)
        {
            pResults->Global.pszServerType = LoadAndAllocString(IDS_GLOBAL_PROFESSIONAL); 
        }
        else
        {
            pResults->Global.pszServerType = LoadAndAllocString(IDS_GLOBAL_SERVER); 
        }
    }

    // get the hotfix information
    GetHotfixInfo(pResults, hkey);


    
    hr = HResultFromWin32(dwErr);

Error:
    if ( hkeyNTType != NULL )
        (VOID) RegCloseKey(hkeyNTType);
    
    if ( hkeyBuildNumber != NULL )
        (VOID) RegCloseKey(hkeyBuildNumber);
    
    if (FAILED(hr))
    {
        //IDS_GLOBAL_NO_MACHINE_INFO    "[FATAL] Failed to get system information of this machine.\n"
        PrintMessage(pParams, IDS_GLOBAL_NO_MACHINE_INFO);
    }

    return hr;
}


/*!--------------------------------------------------------------------------
    GetHotfixInfo
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT GetHotfixInfo(NETDIAG_RESULT *pResults, HKEY hkeyLocalMachine)
{
    HRESULT hr = hrOK;
    HKEY    hkeyHotFix = NULL;
    HKEY    hkeyMainHotFix = NULL;
    TCHAR   szBuffer[MAX_PATH];
    DWORD   cchBuffer = MAX_PATH;
    DWORD   i = 0;
    DWORD   cSubKeys = 0;
    DWORD   dwType, dwLen, dwInstalled;
    
    // Open the hotfix registry key
    CheckErr( RegOpenKeyEx( hkeyLocalMachine,
                            c_szRegKeyHotFix,
                            0,
                            KEY_READ,
                            &hkeyMainHotFix) );

    // Get the list of summary information
    RegQueryInfoKey(hkeyMainHotFix,
                    NULL,           // lpclass
                    NULL,           // lpcbClass
                    NULL,           // lpReserved
                    &cSubKeys,      // lpcSubkeys
                    NULL,           // lpcbMaxSubkeyLen
                    NULL,           // lpcbMaxClassLen
                    NULL,           // lpcValues
                    NULL,           // lpcbMaxValueNameLen
                    NULL,           // lpcbMaxValueLen
                    NULL,           // lpSecurity
                    NULL);          // last write time


    assert(pResults->Global.pHotFixes == NULL);
    pResults->Global.pHotFixes = Malloc(sizeof(HotFixInfo)*cSubKeys);
    if (pResults->Global.pHotFixes == NULL)
        CheckHr(E_OUTOFMEMORY);
    ZeroMemory(pResults->Global.pHotFixes, sizeof(HotFixInfo)*cSubKeys);
    
    // Enumerate the keys under this to get the list of hotfixes
    while ( RegEnumKeyEx( hkeyMainHotFix,
                          i,
                          szBuffer,                 
                          &cchBuffer,
                          NULL,
                          NULL,
                          NULL,
                          NULL) == ERROR_SUCCESS)
    {

        // Now add an entry for each key
        pResults->Global.pHotFixes[i].fInstalled = FALSE;
        pResults->Global.pHotFixes[i].pszName = StrDup(szBuffer);

        // Open up the key and get the installed value
        assert(hkeyHotFix == NULL);
        CheckErr( RegOpenKeyEx( hkeyMainHotFix,
                                szBuffer,
                                0,
                                KEY_READ,
                                &hkeyHotFix) );

        // Now get the value
        dwType = REG_DWORD;
        dwInstalled = FALSE;
        dwLen = sizeof(DWORD);
        if (RegQueryValueEx(hkeyHotFix,
                            c_szRegInstalled,
                            (LPDWORD) NULL,
                            &dwType,
                            (LPBYTE) &dwInstalled,
                            &dwLen) == ERROR_SUCCESS)
        {
            if (dwType == REG_DWORD)
                pResults->Global.pHotFixes[i].fInstalled = dwInstalled;
        }


        if (hkeyHotFix)
            RegCloseKey(hkeyHotFix);
        hkeyHotFix = NULL;
        i ++;
        pResults->Global.cHotFixes++;
        cchBuffer = MAX_PATH;
    }

Error:
    if (hkeyHotFix)
        RegCloseKey(hkeyHotFix);
    
    if (hkeyMainHotFix)
        RegCloseKey(hkeyMainHotFix);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\machine.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       machine.h
//
//--------------------------------------------------------------------------

#ifndef HEADER_MACHINE
#define HEADER_MACHINE


HRESULT	GetMachineSpecificInfo(IN NETDIAG_PARAMS *pParams,
							   IN OUT NETDIAG_RESULT *pResults);

void DoSystemPrint(IN NETDIAG_PARAMS *pParams, IN NETDIAG_RESULT *pResults);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\member.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      member.c
//
//  Abstract:
//
//      Queries into network drivers
//
//  Author:
//
//      Anilth  - 4-20-1998 
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//--


#include "precomp.h"
#undef IsEqualGUID
#include "objbase.h"
#include "regutil.h"
#include "strings.h"

const WCHAR c_wszUserDnsDomain[] = L"USERDNSDOMAIN";

BOOL IsSysVolReady(NETDIAG_PARAMS* pParams);

/*!--------------------------------------------------------------------------
    MemberTest

    Determine the machines role and membership.

    Arguments:

    None.

    Return Value:
    
    TRUE: Test suceeded.
    FALSE: Test failed
        
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT MemberTest(NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
{
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC   pPrimaryDomain = NULL;
    DWORD       dwErr;
    NTSTATUS Status;
    DWORD LogonServerLength;
    WCHAR swzLogonServer[MAX_PATH+1];
    int     iBuildNo;
    BOOL    fDomain;        // TRUE if domain, FALSE is workgroup

    LSA_HANDLE PolicyHandle = NULL;
    PPOLICY_DNS_DOMAIN_INFO pPolicyDomainInfo = NULL;
    OBJECT_ATTRIBUTES ObjAttributes;

    PrintStatusMessage(pParams,0, IDS_MEMBER_STATUS_MSG);

    //
    // Get the build number of this machine
    //
    if (pResults->Global.pszCurrentBuildNumber &&
        (pResults->Global.pszCurrentBuildNumber[0] == 0))
    {
        PrintStatusMessage(pParams,0, IDS_GLOBAL_FAIL_NL);
        PrintStatusMessage(pParams,0, IDS_MEMBER_CANNOT_DETERMINE_BUILD);
        pResults->Global.hrMemberTestResult = E_FAIL;
        return E_FAIL;
    }

    iBuildNo = _ttoi( pResults->Global.pszCurrentBuildNumber );

    
    // Assmume that the test has succeeded
    pResults->Global.hrMemberTestResult = hrOK;


    //
    // Get the name of the domain this machine is a member of
    //

    dwErr = DsRoleGetPrimaryDomainInformation(
                                              NULL,   // local call
                                              DsRolePrimaryDomainInfoBasic,
                                              (PBYTE *) &pPrimaryDomain);
    pResults->Global.pPrimaryDomainInfo = pPrimaryDomain;
    if (dwErr != NO_ERROR)
    {
        PrintStatusMessage(pParams,0, IDS_GLOBAL_FAIL_NL);
        PrintStatusMessage(pParams,0, IDS_MEMBER_CANNOT_DETERMINE_DOMAIN);
        pResults->Global.hrMemberTestResult = E_FAIL;
        goto Cleanup;
    }

    //
    // Handle being a member of a domain
    //
    if ( pPrimaryDomain->MachineRole != DsRole_RoleStandaloneWorkstation &&
         pPrimaryDomain->MachineRole != DsRole_RoleStandaloneServer )
    {       
        //
        // Ensure the netlogon service is running.
        //
        
        dwErr = IsServiceStarted( _T("Netlogon") );
        
        if ( dwErr != NO_ERROR )
        {
            PrintStatusMessage(pParams,0, IDS_GLOBAL_FAIL_NL);
            PrintStatusMessage(pParams,0, IDS_MEMBER_NETLOGON_NOT_RUNNING);
        }
        else
        {
            pResults->Global.fNetlogonIsRunning = TRUE;
        }
        
        //
        // Save the name of this domain as a domain to test.
        //  Do NOT free this up.  This will get freed up
        //  by the code that frees up the list of domains.

        pResults->Global.pMemberDomain = AddTestedDomain( pParams,
                                    pResults,
                                    pPrimaryDomain->DomainNameFlat,
                                    pPrimaryDomain->DomainNameDns,
                                    TRUE );
        if (pResults->Global.pMemberDomain == NULL)
        {
            PrintStatusMessage(pParams,0, IDS_GLOBAL_FAIL_NL);
            pResults->Global.hrMemberTestResult = S_FALSE;
            goto Cleanup;
        }
        
        
        
        //
        // Get the SID of the domain we're a member of
        //
        
        InitializeObjectAttributes(
                                   &ObjAttributes,
                                   NULL,
                                   0L,
                                   NULL,
                                   NULL
                                  );
        
        Status = LsaOpenPolicy(
                               NULL,
                               &ObjAttributes,
                               POLICY_VIEW_LOCAL_INFORMATION,
                               &PolicyHandle );
        
        if (! NT_SUCCESS(Status))
        {
            PrintStatusMessage(pParams,0, IDS_GLOBAL_FAIL_NL);
            PrintDebugSz(pParams, 0, _T("    [FATAL] Member: Cannot LsaOpenPolicy."));
            pResults->Global.hrMemberTestResult = S_FALSE;
            goto Cleanup;
        }
        
        Status = LsaQueryInformationPolicy(
                                           PolicyHandle,
                                           PolicyDnsDomainInformation,
                                           (PVOID *) &pPolicyDomainInfo
                                          );
        
        if (! NT_SUCCESS(Status))
        {
            PrintStatusMessage(pParams,0, IDS_GLOBAL_FAIL_NL);
            if (pParams->fDebugVerbose)
            PrintDebugSz(pParams, 0, _T("    [FATAL] Member: Cannot LsaQueryInformationPolicy (PolicyDnsDomainInformation).") );
            pResults->Global.hrMemberTestResult = S_FALSE;
            goto Cleanup;
        }
        
        if ( pPolicyDomainInfo->Sid == NULL )
        {
            PrintStatusMessage(pParams,0, IDS_GLOBAL_FAIL_NL);
            
            // IDS_MEMBER_11206 "    [FATAL] Member: Cannot LsaQueryInformationPolicy has no domain sid." 
            PrintDebug(pParams, 0, IDS_MEMBER_11206 );
            pResults->Global.hrMemberTestResult = S_FALSE;
            goto Cleanup;
        }
        
        //
        // Save the domain sid for other tests
        //
        pResults->Global.pMemberDomain->DomainSid =
            Malloc(RtlLengthSid(pPolicyDomainInfo->Sid));
        if (pResults->Global.pMemberDomain->DomainSid == NULL)
        {
            PrintStatusMessage(pParams,0, IDS_GLOBAL_FAIL_NL);
            // IDS_MEMBER_11207 "    Member: Out of memory\n" 
            PrintDebug(pParams, 0, IDS_MEMBER_11207);
            pResults->Global.hrMemberTestResult = S_FALSE;
            goto Cleanup;
        }
        
        RtlCopyMemory( pResults->Global.pMemberDomain->DomainSid,
                       pPolicyDomainInfo->Sid,
                       RtlLengthSid( pPolicyDomainInfo->Sid ) );
    }

    //Bug 293635, check whether system volume is ready if the machine is a DC
    if (DsRole_RoleBackupDomainController == pPrimaryDomain->MachineRole ||
        DsRole_RolePrimaryDomainController == pPrimaryDomain->MachineRole)
    {
        pResults->Global.fSysVolNotReady = !IsSysVolReady(pParams);
        if (pResults->Global.fSysVolNotReady)
            pResults->Global.hrMemberTestResult = S_FALSE;
    }
    
    
    //
    // Get the name of the logged on user.
    //
    Status = LsaGetUserName( &pResults->Global.pLogonUser,
                             &pResults->Global.pLogonDomainName );
    
    if ( !NT_SUCCESS(Status))
    {
        PrintStatusMessage(pParams,0, IDS_GLOBAL_FAIL_NL);
        PrintStatusMessage(pParams,0, IDS_MEMBER_UNKNOWN_LOGON);
        pResults->Global.hrMemberTestResult = S_FALSE;
        goto Cleanup;
    }
    

    //
    // If we're not logged onto a local account,
    //  add the logon domain to the list of tested domains
    //
    
    if ( _wcsicmp( pResults->Global.swzNetBiosName,
                   pResults->Global.pLogonDomainName->Buffer ) != 0 )
    {
        LPWSTR pwszLogonDomainDnsName = NULL;
        DWORD cchLogonDomainDnsName = 0;

        cchLogonDomainDnsName = GetEnvironmentVariableW(c_wszUserDnsDomain, 
                                                    NULL,
                                                    0);

        if (cchLogonDomainDnsName)
        {
            pwszLogonDomainDnsName = Malloc(sizeof(WCHAR) * cchLogonDomainDnsName);
            ZeroMemory(pwszLogonDomainDnsName, sizeof(WCHAR) * cchLogonDomainDnsName);
            cchLogonDomainDnsName = GetEnvironmentVariableW(c_wszUserDnsDomain,
                                                    pwszLogonDomainDnsName,
                                                    cchLogonDomainDnsName);
        }

        // Save the name of this domain as a domain to test.
        // ------------------------------------------------------------     
        if (cchLogonDomainDnsName && pwszLogonDomainDnsName && lstrlenW(pwszLogonDomainDnsName))
        {
            pResults->Global.pLogonDomain = AddTestedDomain( pParams, pResults,
                pResults->Global.pLogonDomainName->Buffer,
                pwszLogonDomainDnsName,
                FALSE );
        }
        else
        {
            pResults->Global.pLogonDomain = AddTestedDomain( pParams, pResults,
                pResults->Global.pLogonDomainName->Buffer,
                NULL,
                FALSE );
        }
        
        if (pwszLogonDomainDnsName)
            Free(pwszLogonDomainDnsName);

        if ( pResults->Global.pLogonDomain == NULL )
        {
            PrintStatusMessage(pParams,0, IDS_GLOBAL_FAIL_NL);
            pResults->Global.hrMemberTestResult = S_FALSE;
            goto Cleanup;
        }
        
    }
    
    //
    // Get the name of the logon server.
    //  
    LogonServerLength = GetEnvironmentVariableW(
                                                L"LOGONSERVER",
                                                swzLogonServer,
                                                DimensionOf(swzLogonServer));
    if ( LogonServerLength != 0 )
    {
        //
        // If the caller was supposed to logon to a domain,
        //  and this isn't a DC,
        //  see if the user logged on with cached credentials.
        //
        if ( pResults->Global.pLogonDomain != NULL &&
             pPrimaryDomain->MachineRole != DsRole_RoleBackupDomainController &&
             pPrimaryDomain->MachineRole != DsRole_RolePrimaryDomainController ) {
            LPWSTR pswzLogonServer;
            
            if ( swzLogonServer[0] == L'\\' && swzLogonServer[1] == L'\\')
            {
                pswzLogonServer = &swzLogonServer[2];
            }
            else
            {
                pswzLogonServer = &swzLogonServer[0];
            }
            
            pResults->Global.pswzLogonServer = _wcsdup(swzLogonServer);
        
            if ( _wcsicmp( pResults->Global.swzNetBiosName, pswzLogonServer ) == 0 )
            {
                pResults->Global.fLogonWithCachedCredentials = TRUE;                
            }           
        }
    }

    if (pPrimaryDomain->DomainNameFlat == NULL)
    {
        // the NetBIOS name is not specified
        if (FHrSucceeded(pResults->Global.hrMemberTestResult))
            pResults->Global.hrMemberTestResult = S_FALSE;
    }

    PrintStatusMessage(pParams,0, IDS_GLOBAL_PASS_NL);
    
Cleanup:
    
    if ( pPolicyDomainInfo != NULL ) {
        (void) LsaFreeMemory((PVOID) pPolicyDomainInfo);
    }
    if ( PolicyHandle != NULL ) {
        (void) LsaClose(PolicyHandle);
    }

    return pResults->Global.hrMemberTestResult;
}

//Check if System Volume is ready
//Author:   NSun
BOOL IsSysVolReady(NETDIAG_PARAMS* pParams)
{
    DWORD   dwData = 1;
    DWORD   dwSize = sizeof(dwData);
    LONG    lRet;
    BOOL    fRetVal = TRUE;
    HKEY    hkeyNetLogonParams = NULL;

    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                c_szRegNetLogonParams,
                0,
                KEY_READ,
                &hkeyNetLogonParams);
    
    if (ERROR_SUCCESS == lRet)
    {
        //it's ok that the SysVolReady value doesn't exist
        if (ReadRegistryDword(hkeyNetLogonParams,
                            c_szRegSysVolReady,
                            &dwData))
        {
            if (0 == dwData)
                fRetVal = FALSE;
        }

        RegCloseKey(hkeyNetLogonParams);
    }
    else
        PrintDebugSz(pParams, 0, _T("Failed to open the registry of NetLogon parameters.\n"));

    return fRetVal;
}

/*!--------------------------------------------------------------------------
    MemberGlobalPrint
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void MemberGlobalPrint(IN NETDIAG_PARAMS *pParams,
                         IN OUT NETDIAG_RESULT *pResults)
{
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC   pPrimaryDomain = NULL;
    BOOL                fDomain = TRUE;
    TCHAR               szName[256];
    int                 ids;

    if (pParams->fVerbose || !FHrOK(pResults->Global.hrMemberTestResult))
    {
        PrintNewLine(pParams, 2);
        PrintTestTitleResult(pParams, IDS_MEMBER_LONG, IDS_MEMBER_SHORT, TRUE,
                             pResults->Global.hrMemberTestResult, 0);
    }

    pPrimaryDomain = pResults->Global.pPrimaryDomainInfo;

    if (!pPrimaryDomain)
        goto L_ERROR;

    //Bug 293635, check whether system volume is ready if the machine is a DC
    if (pResults->Global.fSysVolNotReady && 
        (DsRole_RoleBackupDomainController == pPrimaryDomain->MachineRole ||
         DsRole_RolePrimaryDomainController == pPrimaryDomain->MachineRole))
    {
        PrintMessage(pParams, IDS_MEMBER_SYSVOL_NOT_READY);
    }

    if (pParams->fReallyVerbose)
        //IDS_MEMBER_11208 "    Machine is a:        "
        PrintMessage(pParams, IDS_MEMBER_11208 );

    switch ( pPrimaryDomain->MachineRole )
    {
        case DsRole_RoleStandaloneWorkstation:
            // IDS_MEMBER_11209 "Standalone Workstation" 
            ids = IDS_MEMBER_11209;
            fDomain = FALSE;
            break;
        case DsRole_RoleMemberWorkstation:
            // IDS_MEMBER_11210 "Member Workstation"
            ids = IDS_MEMBER_11210;
            fDomain = TRUE;
            break;
        case DsRole_RoleStandaloneServer:
            // IDS_MEMBER_11211 "Standalone Server" 
            ids = IDS_MEMBER_11211;
            fDomain = FALSE;
            break;
        case DsRole_RoleMemberServer:
            // IDS_MEMBER_11212 "Member Server" 
            ids = IDS_MEMBER_11212;
            fDomain = TRUE;
            break;
        case DsRole_RoleBackupDomainController:
            // IDS_MEMBER_11213 "Backup Domain Controller" 
            ids = IDS_MEMBER_11213;
            fDomain = TRUE;
            break;
        case DsRole_RolePrimaryDomainController:
            // IDS_MEMBER_11214 "Primary Domain Controller" 
            ids = IDS_MEMBER_11214;
            fDomain = TRUE;
            break;
        default:
            if (pParams->fReallyVerbose)
            {
                // IDS_MEMBER_11215 "<Unknown Role> %ld" 
                PrintMessage(pParams, IDS_MEMBER_11215,
                             pPrimaryDomain->MachineRole );
            }
            ids = 0;
            fDomain = TRUE;
            break;
    }

    if (pParams->fReallyVerbose && ids)
        PrintMessage(pParams, ids);

    if (pParams->fReallyVerbose)
        PrintNewLine(pParams, 1);

    if ( pPrimaryDomain->DomainNameFlat == NULL )
    {
        // IDS_MEMBER_11217  "    Netbios Domain name is not specified: "
        // IDS_MEMBER_11232  "    Netbios Workgroup name is not specified: "
        ids = fDomain ? IDS_MEMBER_11217 : IDS_MEMBER_11232;
    
        PrintMessage(pParams, ids);
    }
    else
    {
        // IDS_MEMBER_11216  "    Netbios Domain name: %ws\n" 
        // IDS_MEMBER_11218  "    Netbios Workgroup name: %ws\n" 
        ids = fDomain ? IDS_MEMBER_11216 : IDS_MEMBER_11218;
    
        if (pParams->fReallyVerbose)
            PrintMessage(pParams,  ids,
                         pPrimaryDomain->DomainNameFlat );
    }
    
    if ( pPrimaryDomain->DomainNameDns == NULL )
    {
        // IDS_MEMBER_11219 "    Dns domain name is not specified.\n" 
        PrintMessage(pParams,  IDS_MEMBER_11219 );
    }
    else
    {
        if (pParams->fReallyVerbose)
            // IDS_MEMBER_11220 "    Dns domain name:     %ws\n" 
            PrintMessage(pParams,  IDS_MEMBER_11220,
                         pPrimaryDomain->DomainNameDns );
    }
    
    if ( pPrimaryDomain->DomainForestName == NULL )
    {
        // IDS_MEMBER_11221 "    Dns forest name is not specified.\n" 
        PrintMessage(pParams,  IDS_MEMBER_11221 );
    }
    else
    {
        if (pParams->fReallyVerbose)
            // IDS_MEMBER_11222 "    Dns forest name:     %ws\n" 
            PrintMessage(pParams,  IDS_MEMBER_11222,
                    pPrimaryDomain->DomainForestName );
    }
    
    
    if ( pParams->fReallyVerbose )
    {
        WCHAR swzGuid[64];

        // IDS_MEMBER_11223  "    Domain Guid:         " 
        PrintMessage(pParams, IDS_MEMBER_11223);
        StringFromGUID2(&pPrimaryDomain->DomainGuid, 
                        swzGuid, 
                        DimensionOf(swzGuid));
        PrintMessage(pParams, IDS_GLOBAL_WSTRING, swzGuid);
        PrintNewLine(pParams, 1);
    
        if ( pPrimaryDomain->MachineRole != DsRole_RoleStandaloneWorkstation &&
             pPrimaryDomain->MachineRole != DsRole_RoleStandaloneServer )
        {       
            // IDS_MEMBER_11227 "    Domain Sid:          " 
            PrintMessage(pParams, IDS_MEMBER_11227);
            PrintSid( pParams, pResults->Global.pMemberDomain->DomainSid );
        }

        // IDS_MEMBER_11228  "    Logon User:          %wZ\n" 
        PrintMessage(pParams, IDS_MEMBER_11228, pResults->Global.pLogonUser );
        // IDS_MEMBER_11229  "    Logon Domain:        %wZ\n" 
        PrintMessage(pParams, IDS_MEMBER_11229, pResults->Global.pLogonDomainName );
    }
    
    if ( pParams->fReallyVerbose)
    {
        if (pResults->Global.pswzLogonServer &&
            pResults->Global.pswzLogonServer[0])
            // IDS_MEMBER_11230 "    Logon Server:        %ws\n" 
            PrintMessage(pParams, IDS_MEMBER_11230, pResults->Global.pswzLogonServer );
        
        if (pResults->Global.fLogonWithCachedCredentials)
        {
            // IDS_MEMBER_11231 "    [WARNING] Member: User was logged on with cached credentials\n" 
            PrintMessage(pParams, IDS_MEMBER_11231);
        }
    }

L_ERROR:
    return;
}

/*!--------------------------------------------------------------------------
    MemberPerInterfacePrint
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void MemberPerInterfacePrint(IN NETDIAG_PARAMS *pParams,
                             IN NETDIAG_RESULT *pResults,
                             IN INTERFACE_RESULT *pIfResult)
{
}

/*!--------------------------------------------------------------------------
    MemberCleanup
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void MemberCleanup(IN NETDIAG_PARAMS *pParams,
                     IN OUT NETDIAG_RESULT *pResults)
{
    free(pResults->Global.pswzLogonServer);
    pResults->Global.pswzLogonServer = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

    makefile.inc.

!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\nbtutil.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       nbtutil.h
//
//--------------------------------------------------------------------------

#ifndef HEADER_NBTUTIL
#define HEADER_NBTUTIL

PNETBT_TRANSPORT FindNetbtTransport(NETDIAG_RESULT *pResults,
									LPWSTR TransportName);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\nbtutil.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      domutil.c
//
//  Abstract:
//
//    Test to ensure that a workstation has network (IP) connectivity to
//		the outside.
//
//  Author:
//
//     15-Dec-1997 (cliffv)
//      Anilth	- 4-20-1998 
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//    1-June-1998 (denisemi) add DnsServerHasDCRecords to check DC dns records
//                           registration
//
//    26-June-1998 (t-rajkup) add general tcp/ip , dhcp and routing,
//                            winsock, ipx, wins and netbt information. 
//--

//
// Common include files.
//
#include "precomp.h"
#include "nbtutil.h"


/*!--------------------------------------------------------------------------
	FindNetbtTransport

    Determine if the specified Netbt transport is configured.

	Arguments:
	
	TransportName - Name of transport to find.
	
	Return Value:

    Pointer to struct describing transport
    NULL: Transport is not configured

	Author: KennT
 ---------------------------------------------------------------------------*/
PNETBT_TRANSPORT
FindNetbtTransport(
				   NETDIAG_RESULT *pResults,
				   LPWSTR pswzTransportName
				  )
{
    PLIST_ENTRY ListEntry;
    PNETBT_TRANSPORT pNetbtTransport;

    //
    // Loop through the list of netbt transports finding this one.
    //

    for ( ListEntry = pResults->NetBt.Transports.Flink ;
          ListEntry != &pResults->NetBt.Transports ;
          ListEntry = ListEntry->Flink )
	{
        //
        // If the transport names match,
        //  return the entry
        //

        pNetbtTransport = CONTAINING_RECORD( ListEntry, NETBT_TRANSPORT, Next );

        if ( _wcsicmp( pNetbtTransport->pswzTransportName, pswzTransportName ) == 0 ) {
            return pNetbtTransport;
        }

    }

    return NULL;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\nbtnm.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      nbtnm.c
//
//  Abstract:
//
//      Queries into network drivers
//
//  Author:
//
//      Anilth  - 4-20-1998
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//      NSun   - 9-03-1998
//
//--
#include "precomp.h"

#include "dhcptest.h"

const TCHAR c_szPath[] = _T("\\Device\\NetBT_Tcpip_");
TCHAR pDeviceName[NBT_MAXIMUM_BINDINGS][MAX_NAME+1];

TCHAR * printable( IN TCHAR *  string, IN TCHAR *  StrOut );

//$REVIEW (nsun) previously using ReadNbtNameRegistry() see Bug 152014
LONG GetInterfaceList( IN OUT TCHAR pDeviceName[][MAX_NAME+1], IN OUT PUCHAR pScope );
NTSTATUS OpenNbt(IN char path[][MAX_NAME+1], OUT PHANDLE pHandle, int max_paths);
NTSTATUS DeviceIoCtrl(
    IN HANDLE           fd,
    IN PVOID            ReturnBuffer,
    IN ULONG            BufferSize,
    IN ULONG            Ioctl,
    IN PVOID            pInput,
    IN ULONG            SizeInput
    );


/*  =======================================================================
 *  name_type()     --  describe NBT Name types
 *
 */

char *
name_type(int t)
{
    if (t & GROUP_NAME)    return("GROUP");
    else                   return("UNIQUE");
}


//-------------------------------------------------------------------------//
//######  N b t N m T e s t ()  ###########################################//
//-------------------------------------------------------------------------//
//  Abstract:                                                              //
//      Test that the names                                                //
//          <00> - wks svc name = NETBIOS computer name                    //
//          <03> - messenger svc name                                      //
//          <20> - server svc name                                         //
//      are present on all interfaces and that they are not in conflict    //
//  Arguments:                                                             //
//      none                                                               //
//  Return value:                                                          //
//      TRUE  - test passed                                                //
//      FALSE - test failed                                                //
//  Global variables used:                                                 //
//      none                                                       //
//  Revision History:                                                      //
//      List remote machines cache too - Rajkumar 06/30/98                 //
//-------------------------------------------------------------------------//
HRESULT NbtNmTest(NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
{
    HRESULT   hr = S_OK;
    TCHAR   pScope[MAX_NAME + 1];
    int    index;
    HANDLE hNbt = (HANDLE) -1;
    ULONG  BufferSize = sizeof(tADAPTERSTATUS);
    PVOID  pBuffer = NULL;
    LONG   lCount;
    int    nNameProblemCnt = 0;
    BOOL   is00, is03, is20, isGlobal00, isGlobal03, isGlobal20;

    tADAPTERSTATUS *pAdapterStatus;
    NAME_BUFFER    *pNames;
    NTSTATUS status;
    TDI_REQUEST_QUERY_INFORMATION QueryInfo;

    //
    // Variables for Netbios Name resolution option - Rajkumar
    //

    HKEY hkeyNetBTKey;
    HKEY hkeyNBTAdapterKey;
    DWORD valueType;
    DWORD valueLength;
    DWORD NetbiosOptions;
    INT err;

    //
    // For remote cache information
    //

    UCHAR* Addr;
    TCHAR   HostAddr[20];

    //
    // End of changes - Rajkumar 06/17/98
    //

    PrintStatusMessage(pParams, 4, IDS_NBTNM_STATUS_MSG);

    //Init the global message link list
    InitializeListHead( &pResults->NbtNm.lmsgGlobalOutput );

    if (!pResults->Global.fHasNbtEnabledInterface)
    {
        AddMessageToList( &pResults->NbtNm.lmsgGlobalOutput, Nd_Verbose, IDS_NBTNM_ALL_DISABELED);
        return S_OK;
    }

    //
    //  get the names of all the interfaces from the registry
    //
    if ( ERROR_SUCCESS != GetInterfaceList( pDeviceName, pScope ) )
    {
        //IDS_NBTNM_12201                  "    [FATAL] failed to read NBT interface info from the registry!\n"
        AddMessageToListId( &pResults->NbtNm.lmsgGlobalOutput, Nd_Quiet, IDS_NBTNM_12201 );
        hr = S_FALSE;
        goto end_NbtNmTest;
    }


    if ( *pScope == '\0')
        //IDS_NBTNM_12202                  "   No NetBT scope defined\n"
        AddMessageToListId( &pResults->NbtNm.lmsgGlobalOutput, Nd_ReallyVerbose, IDS_NBTNM_12202 );
    else
        //IDS_NBTNM_12203                  "   NetBT scope: %s\n"
        AddMessageToList(  &pResults->NbtNm.lmsgGlobalOutput, Nd_ReallyVerbose, IDS_NBTNM_12203, pScope );

    //
    //  loop through the interfaces and get the names on them
    //

    isGlobal00 = isGlobal03 = isGlobal20 = FALSE;
    for ( index = 0; index < NBT_MAXIMUM_BINDINGS && pDeviceName[index][0]; index++ )
    {
        LPTSTR  pszAdapterName;
        INTERFACE_RESULT*    pIfResults;
        UINT    c03NameProblem = 0;

        pIfResults = NULL;

        //try to find a match in the current interface list
//$REVIEW   It seems we should always find a match here. Maybe we need print
//        a FAIL message if cannot find a match.
        if( 0 == _tcsncmp(c_szPath, pDeviceName[index], _tcslen(c_szPath)))
        {
//            LPTSTR pszAdapterName;
            int i;
            pszAdapterName = _tcsdup( pDeviceName[index] + _tcslen(c_szPath));
            for ( i=0; i<pResults->cNumInterfaces; i++)
            {
                if (_tcscmp(pResults->pArrayInterface[i].pszName,
                         pszAdapterName) == 0)
                {
                pIfResults = pResults->pArrayInterface + i;
                break;
                }
            }
            Free(pszAdapterName);
        }

        if(NULL == pIfResults)
        {
            //we should be able to get the match. That is weird!
            DebugMessage("[WARNING] A NetBT interface is not in our TCPIP interface list!\n");

            // We need a new interface result structure, grab one
            // (if it is free), else allocate more.
            if (pResults->cNumInterfaces >= pResults->cNumInterfacesAllocated)
            {
                PVOID   pv;
                // Need to do a realloc to get more memory
                pv = Realloc(pResults->pArrayInterface,
                             sizeof(INTERFACE_RESULT)*(pResults->cNumInterfacesAllocated+8));
                if (pv == NULL)
                {
                    DebugMessage(" Realloc memory failed. \n");
                    hr = E_OUTOFMEMORY;
                    goto end_NbtNmTest;
                }

                pResults->pArrayInterface = pv;
                pResults->cNumInterfacesAllocated += 8;
            }

            pIfResults = pResults->pArrayInterface + pResults->cNumInterfaces;
            pResults->cNumInterfaces++;

            ZeroMemory(pIfResults, sizeof(INTERFACE_RESULT));
            pIfResults->pszName = _tcsdup(pszAdapterName);
            pIfResults->pszFriendlyName = _tcsdup(_T("Additional NetBT interface"));

            pIfResults->fActive = TRUE;
            pIfResults->NbtNm.fActive = TRUE;
            pIfResults->NbtNm.fQuietOutput = FALSE;
        }
        else
        {
            pIfResults->NbtNm.fActive = pIfResults->fActive;
        }

        if(!pIfResults->NbtNm.fActive || 
            NETCARD_DISCONNECTED == pIfResults->dwNetCardStatus)
            continue;

        InitializeListHead( &pIfResults->NbtNm.lmsgOutput );

        if (!pIfResults->fNbtEnabled)
        {
            AddMessageToList(&pIfResults->NbtNm.lmsgOutput, Nd_Verbose, IDS_NBTNM_IF_DISABLED);
			continue;
        }

/*        //$REVIEW Can we skip WAN adapters
        if ( _tcsstr( pDeviceName[index], "NdisWan" ) ) {
            //
            //  let's not worry about WAN interfaces yet
            //
            continue;
        }
*/

        // Strip off the "\Device\" off of the beginning of
            // the string
        //IDS_NBTNM_12204                  "   %s\n"
        AddMessageToList( &pIfResults->NbtNm.lmsgOutput, Nd_ReallyVerbose, IDS_NBTNM_12204, MapGuidToServiceName(pDeviceName[index]+8));

        status = OpenNbt( &pDeviceName[index], &hNbt, NBT_MAXIMUM_BINDINGS - index );


        //
        //  let's get the names on this interface
        //

        pBuffer = Malloc( BufferSize );
        if ( !pBuffer ) {
            DebugMessage(" [FATAL] name table buffer allocation failed!\n" );
            hr = E_OUTOFMEMORY;
            CloseHandle( hNbt );
            goto end_NbtNmTest;
        }
        ZeroMemory( pBuffer, BufferSize );

        QueryInfo.QueryType = TDI_QUERY_ADAPTER_STATUS; // node status or whatever

        //
        //  find the right buffer size
        //
        status = STATUS_BUFFER_OVERFLOW;
        while ( status == STATUS_BUFFER_OVERFLOW )
        {
//$REVIEW there should be a better way to decide the buffer size
            status = DeviceIoCtrl(hNbt,
                                  pBuffer,
                                  BufferSize,
                                  IOCTL_TDI_QUERY_INFORMATION,
                                  &QueryInfo,
                                  sizeof(TDI_REQUEST_QUERY_INFORMATION)
                                );
            if ( status == STATUS_BUFFER_OVERFLOW ) {
                Free( pBuffer );
                BufferSize *= 2;
                pBuffer = Malloc( BufferSize );
                if ( !pBuffer ) {
                    DebugMessage( "       [FATAL] Buffer allocation for name table retrieval failed.\n" );
                    hr = E_OUTOFMEMORY;
                    CloseHandle( hNbt );
                    goto end_NbtNmTest;
                }
                ZeroMemory( pBuffer, BufferSize );
            }
        }

        //
        // at this point we have the local name table in pBuffer
        //

        pAdapterStatus = (tADAPTERSTATUS *)pBuffer;
        if ( (pAdapterStatus->AdapterInfo.name_count == 0) ||
             (status != STATUS_SUCCESS) )
        {
            //IDS_NBTNM_12205                  "       No names have been found.\n"
            AddMessageToListId(&pIfResults->NbtNm.lmsgOutput, Nd_Verbose,  IDS_NBTNM_12205 );
            Free( pBuffer );
            CloseHandle( hNbt );
            continue;
        }

        pNames = pAdapterStatus->Names;
        lCount = pAdapterStatus->AdapterInfo.name_count;

        //
        //  cycle thorugh the names
        //

        nNameProblemCnt = 0;
        is00 = is03 = is20 = FALSE;
        while( lCount-- )
        {
            TCHAR szNameOut[NETBIOS_NAME_SIZE +4];
        //$REVIEW (nsun) BUG227186 CliffV said problems with <03> name is not fatal.
        // Just need a warning message.
            BOOL    f03Name = FALSE;

            if ( pNames->name[NETBIOS_NAME_SIZE-1] == 0x0 )
            {
                isGlobal00 = TRUE;
                is00 = TRUE;
                if ( !(pNames->name_flags & GROUP_NAME) ) {
                    // unique name
                    memcpy( nameToQry, pNames->name, (NETBIOS_NAME_SIZE-1));
                }
            }
            if ( pNames->name[NETBIOS_NAME_SIZE-1] == 0x3 ) {
                isGlobal03 = TRUE;
                is03 = TRUE;
                f03Name = TRUE;
            }
            if ( pNames->name[NETBIOS_NAME_SIZE-1] == 0x20 ) {
                isGlobal20 = TRUE;
                is20 = TRUE;
            }

            //IDS_NBTNM_12206                  "\t%-15.15s<%02.2X>  %-10s  "
            AddMessageToList( &pIfResults->NbtNm.lmsgOutput,
                       Nd_ReallyVerbose,
                       IDS_NBTNM_12206,
                       printable(pNames->name, szNameOut),
                       pNames->name[NETBIOS_NAME_SIZE-1],
                       name_type(pNames->name_flags));

            switch(pNames->name_flags & 0x0F)
            {
                case DUPLICATE_DEREG:
                   //IDS_NBTNM_12207                  "CONFLICT_DEREGISTERED"
                   AddMessageToListId( &pIfResults->NbtNm.lmsgOutput, Nd_ReallyVerbose, IDS_NBTNM_12207 );

                   if(f03Name)
                       c03NameProblem ++;
                   else
                       nNameProblemCnt++;
                   break;
                case DUPLICATE:
                   //IDS_NBTNM_12208                  "CONFLICT"
                   AddMessageToListId( &pIfResults->NbtNm.lmsgOutput, Nd_ReallyVerbose, IDS_NBTNM_12208 );

                   if(f03Name)
                       c03NameProblem ++;
                   else
                       nNameProblemCnt++;
                   break;
                case REGISTERING:
                    //IDS_NBTNM_12209                  "REGISTERING"
                   AddMessageToListId( &pIfResults->NbtNm.lmsgOutput, Nd_ReallyVerbose, IDS_NBTNM_12209 );

                   if(f03Name)
                       c03NameProblem ++;
                   else
                       nNameProblemCnt++;
                   break;
                case DEREGISTERED:
                    //IDS_NBTNM_12210                  "DEREGISTERED"
                   AddMessageToListId( &pIfResults->NbtNm.lmsgOutput, Nd_ReallyVerbose, IDS_NBTNM_12210 );

                   if(f03Name)
                       c03NameProblem ++;
                   else
                       nNameProblemCnt++;
                   break;
                case REGISTERED:
                    //IDS_NBTNM_12211                  "REGISTERED"
                   AddMessageToListId( &pIfResults->NbtNm.lmsgOutput, Nd_ReallyVerbose, IDS_NBTNM_12211 );
                   break;
                default:
//$REVIEW Should have a PM to review words and grammar of the output message, DONT_KNOW
                    //IDS_NBTNM_12212                  "DONT_KNOW"
                   AddMessageToListId( &pIfResults->NbtNm.lmsgOutput, Nd_ReallyVerbose, IDS_NBTNM_12212 );
                   if(f03Name)
                       c03NameProblem ++;
                   else
                       nNameProblemCnt++;
                   break;
            }
            pNames++;

            //IDS_GLOBAL_EmptyLine                  "\n"
            AddMessageToListId( &pIfResults->NbtNm.lmsgOutput, Nd_ReallyVerbose, IDS_GLOBAL_EmptyLine );
        } /* while() all the names on a given interface */

        if ( nNameProblemCnt != 0 )
        {
            pIfResults->NbtNm.fQuietOutput = TRUE;
            //if not really verbose, the device name is not printed before.
            if( !pParams->fReallyVerbose)
            {
                //IDS_NBTNM_12204                  "   %s\n"
                AddMessageToList( &pIfResults->NbtNm.lmsgOutput, Nd_Quiet, IDS_NBTNM_12204, pDeviceName[index] );
            }
            //IDS_NBTNM_12214                  "    [FATAL] At least one of your NetBT names is not registered properly!\n"
            AddMessageToListId( &pIfResults->NbtNm.lmsgOutput, Nd_Quiet, IDS_NBTNM_12214 );
            //IDS_NBTNM_12215                  "    You have a potential name conflict!\n"
            AddMessageToListId( &pIfResults->NbtNm.lmsgOutput, Nd_Quiet, IDS_NBTNM_12215 );
            //IDS_NBTNM_12216                  "    Please check that the machine name is unique!\n"
            AddMessageToList( &pIfResults->NbtNm.lmsgOutput, Nd_Quiet, IDS_NBTNM_12216 );
            hr = S_FALSE;
        }
        else if( c03NameProblem != 0 )
        {
            //if not really verbose, the device name is not printed before.
            if( !pParams->fReallyVerbose)
            {
                //IDS_NBTNM_12204                  "   %s\n"
                AddMessageToList( &pIfResults->NbtNm.lmsgOutput, Nd_Quiet, IDS_NBTNM_12204, pDeviceName[index] );
            }
            //IDS_NBTNM_03PROBLEM           "    [WARNING] At least one of your <03> NetBT names is not registered properly!\n"
            AddMessageToListId( &pIfResults->NbtNm.lmsgOutput, Nd_Quiet, IDS_NBTNM_03PROBLEM );

        }

        if ( !(is00 && is03 && is20) )
        {
            //if not really verbose, the device name is not printed before.
            if( !pParams->fReallyVerbose)
            {
                //IDS_NBTNM_12204                  "   %s\n"
                AddMessageToList( &pIfResults->NbtNm.lmsgOutput, Nd_ReallyVerbose, IDS_NBTNM_12204, pDeviceName[index] );
            }
            //IDS_NBTNM_12217                  "    [WARNING] At least one of the <00>, <03>, <20> names is missing!\n"
            AddMessageToListId( &pIfResults->NbtNm.lmsgOutput, Nd_Verbose, IDS_NBTNM_12217 );
        }

        nNameProblemCnt = 0;

        if (pParams->fReallyVerbose)
        {

            err = RegOpenKey(HKEY_LOCAL_MACHINE,
                         "SYSTEM\\CurrentControlSet\\Services\\NetBT\\Parameters\\Interfaces",
                         &hkeyNetBTKey
                         );

            // if we are here , then we are working on a LAN card
            if( ERROR_SUCCESS != err )
            {
                DebugMessage("Error Opening \\NetBT\\Parameters\\Interfaces Key\n");
                goto continue_NbtNmTest;
            }

            err = RegOpenKey(hkeyNetBTKey,
                             pDeviceName[index]+14,
                             &hkeyNBTAdapterKey
                             );
            if( ERROR_SUCCESS != err )
            {
                DebugMessage2("Error Reading Adapter %s Key\n", pDeviceName[index]+14);
                goto continue_NbtNmTest;
            }

            valueLength = sizeof(DWORD);
            err = RegQueryValueEx(hkeyNBTAdapterKey,
                               "NetbiosOptions",
                               NULL,
                               &valueType,
                               (LPBYTE)&NetbiosOptions,
                               &valueLength
                              );
            if( ERROR_SUCCESS != err)
            {
                DebugMessage("Error Reading NetbiosOptions\n");
                goto continue_NbtNmTest;
            }

            //IDS_NBTNM_12218                  "\n          NetBios Resolution : "
            AddMessageToListId( &pIfResults->NbtNm.lmsgOutput, Nd_ReallyVerbose, IDS_NBTNM_12218);
            switch( NetbiosOptions )
            {
            case 0:
                //IDS_NBTNM_12219                  "via DHCP \n\n"
                AddMessageToListId( &pIfResults->NbtNm.lmsgOutput, Nd_ReallyVerbose, IDS_NBTNM_12219);
                break;
            case 1:
                //IDS_NBTNM_12220                  "Enabled\n\n"
                AddMessageToListId( &pIfResults->NbtNm.lmsgOutput, Nd_ReallyVerbose, IDS_NBTNM_12220);
                break;
            case 2:
                //IDS_NBTNM_12221                  "Disabled\n\n"
                AddMessageToListId( &pIfResults->NbtNm.lmsgOutput, Nd_ReallyVerbose, IDS_NBTNM_12221);
                break;
            default:
                //IDS_NBTNM_12222                  "Invalid Option Value!\n"
                AddMessageToListId( &pIfResults->NbtNm.lmsgOutput, Nd_ReallyVerbose, IDS_NBTNM_12222);
                break;
            }
        }
continue_NbtNmTest:

        //
        // Start of code changes for dumping remote machine cache entries - Rajkumar
        //


        status = STATUS_BUFFER_OVERFLOW;
        while ( status == STATUS_BUFFER_OVERFLOW )
        {
            status = DeviceIoCtrl(hNbt,
                                  pBuffer,
                                  BufferSize,
                                  IOCTL_NETBT_GET_REMOTE_NAMES,
                                  NULL,
                                  0
                                );
            if ( status == STATUS_BUFFER_OVERFLOW )
            {
                Free( pBuffer );
                BufferSize *= 2;
                pBuffer = Malloc( BufferSize );
                if ( !pBuffer || (BufferSize == 0xFFFF) )
                {
                    DebugMessage( "       [FATAL] Buffer allocation for name table retrieval failed.\n" );
                    hr = E_OUTOFMEMORY;
                    CloseHandle( hNbt );
                    goto end_NbtNmTest;
                }
                ZeroMemory( pBuffer, BufferSize );
            }
        }


        pAdapterStatus = (tADAPTERSTATUS *)pBuffer;
        if ( (pAdapterStatus->AdapterInfo.name_count == 0) ||
             (status != STATUS_SUCCESS)
           )
        {
            //IDS_NBTNM_12224                  "       No remote names have been found.\n"
            AddMessageToListId( &pIfResults->NbtNm.lmsgOutput, Nd_Verbose, IDS_NBTNM_12224 );
            CloseHandle( hNbt );
            Free( pBuffer );
//$REVIEW Should we return S_FALSE here?
            continue;
        }

        pNames = pAdapterStatus->Names;
        lCount = pAdapterStatus->AdapterInfo.name_count;

        //IDS_NBTNM_12225                  "\t\tNetbios Remote Cache Table\n"
        AddMessageToListId( &pIfResults->NbtNm.lmsgOutput, Nd_ReallyVerbose, IDS_NBTNM_12225);
        //IDS_NBTNM_12226                  "\tName      Type        HostAddress      Life [sec]\n"
        AddMessageToListId( &pIfResults->NbtNm.lmsgOutput, Nd_ReallyVerbose, IDS_NBTNM_12226);
        //IDS_NBTNM_12227                  "\t--------------------------------------------------\n"
        AddMessageToListId( &pIfResults->NbtNm.lmsgOutput, Nd_ReallyVerbose, IDS_NBTNM_12227);

        if (lCount == 0)
            //IDS_NBTNM_12228                  "\nNone\n\n"
            AddMessageToListId( &pIfResults->NbtNm.lmsgOutput, Nd_ReallyVerbose, IDS_NBTNM_12228);

        while (lCount-- )
        {
            TCHAR    szNameOut[NETBIOS_NAME_SIZE +4];

            //IDS_NBTNM_12229                  "\t%-15.15s<%02.2X>  %-10s  "
            AddMessageToList( &pIfResults->NbtNm.lmsgOutput,
                       Nd_ReallyVerbose,
                       IDS_NBTNM_12229,
                       printable(pNames->name, szNameOut),
                       pNames->name[NETBIOS_NAME_SIZE-1],
                       name_type(pNames->name_flags));

            Addr = &(UCHAR)((tREMOTE_CACHE *)pNames)->IpAddress;
            _stprintf( HostAddr, "%d.%d.%d.%d", Addr[3], Addr[2], Addr[1], Addr[0]);
            //IDS_NBTNM_12231                  "%-20.20s    %-d\n"
            AddMessageToList( &pIfResults->NbtNm.lmsgOutput, Nd_ReallyVerbose, IDS_NBTNM_12231, HostAddr, ((tREMOTE_CACHE *)pNames)->Ttl);

            ((tREMOTE_CACHE *)pNames)++;
        }

        //IDS_GLOBAL_EmptyLine                  "\n"
        AddMessageToList( &pIfResults->NbtNm.lmsgOutput, Nd_ReallyVerbose, IDS_GLOBAL_EmptyLine);
        Free(pBuffer);
        //
        // End of code changes
        //

        CloseHandle(hNbt);
    } /* for ( all the interfaces ) */


    if ( !(isGlobal00 && isGlobal03 && isGlobal20) )
    {
        //IDS_NBTNM_12233                  "    [WARNING] You don't have a single interface with the <00>, <03>, <20> names defined!\n"
        AddMessageToListId( &pResults->NbtNm.lmsgGlobalOutput, Nd_Quiet, IDS_NBTNM_12233 );
    }
    else
    {
        //IDS_NBTNM_12234                  "\n    PASS - your NetBT configuration looks OK\n"
        AddMessageToListId( &pResults->NbtNm.lmsgGlobalOutput, Nd_ReallyVerbose, IDS_NBTNM_12234 );
        //IDS_NBTNM_12235                  "           there is at least one interface where the <00>, <03>, <20>\n"
        AddMessageToList( &pResults->NbtNm.lmsgGlobalOutput, Nd_ReallyVerbose, IDS_NBTNM_12235 );
        //IDS_NBTNM_12236                  "           names are defined and they are not in conflict.\n"
        AddMessageToListId( &pResults->NbtNm.lmsgGlobalOutput, Nd_ReallyVerbose, IDS_NBTNM_12236 );
     }

end_NbtNmTest:
    if ( FHrOK(hr) )
    {
        PrintStatusMessage(pParams, 0, IDS_GLOBAL_PASS_NL);
    }
    else
    {
        PrintStatusMessage(pParams, 0, IDS_GLOBAL_FAIL_NL);
    }

    pResults->NbtNm.hrTestResult = hr;
    return hr;
} /* END OF NbtNmTest() */


//-------------------------------------------------------------------------//
//######  O p e n N b t ()  ###############################################//
//-------------------------------------------------------------------------//
//  Abstract:                                                              //
//      Opens a handle to the device                                       //
//  Arguments:                                                             //
//      path    - path to the driver                                       //
//      pHandle - the handle that we return from this function             //
//      max_paths - I think this is unused                                 //
//  Return value:                                                          //
//      0  if successful                                                   //
//      -1 otherwise                                                       //
//  Global variables used:                                                 //
//      none                                                               //
//-------------------------------------------------------------------------//
NTSTATUS
OpenNbt(
    IN TCHAR path[][MAX_NAME+1],
    OUT PHANDLE pHandle,
    int max_paths
    )
{
    HANDLE              StreamHandle;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    STRING              name_string;
    UNICODE_STRING      uc_name_string;
    NTSTATUS            status;
    LONG                index=0;

    assert( max_paths <= NBT_MAXIMUM_BINDINGS );

    while ((path[index][0] != 0) && (index < max_paths))
    {

        RtlInitString(&name_string, path[index]);
        RtlAnsiStringToUnicodeString(&uc_name_string, &name_string, TRUE);

        InitializeObjectAttributes(
            &ObjectAttributes,
            &uc_name_string,
            OBJ_CASE_INSENSITIVE,
            (HANDLE) NULL,
            (PSECURITY_DESCRIPTOR) NULL
            );

        status = NtCreateFile(
                    &StreamHandle,
                    SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                    &ObjectAttributes,
                    &IoStatusBlock,
                    NULL,
                    FILE_ATTRIBUTE_NORMAL,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    FILE_OPEN_IF,
                    0,
                    NULL,
                    0);

        RtlFreeUnicodeString(&uc_name_string);

        if (NT_SUCCESS(status)) {
            *pHandle = StreamHandle;
            return(status);
        }

        ++index;
    }

    return (status);
} /* END OF OpenNbt() */


//-------------------------------------------------------------------------//
//######  D e v i c e I o C t r l ()  #####################################//
//-------------------------------------------------------------------------//
//  Abstract:                                                              //
//      Wrapper for NtDeviceIoControlFile                                  //
//  Arguments:                                                             //
//  Return value:                                                          //
//  Global variables used:                                                 //
//      none                                                               //
//-------------------------------------------------------------------------//
NTSTATUS
DeviceIoCtrl(
    IN HANDLE           fd,
    IN PVOID            ReturnBuffer,
    IN ULONG            BufferSize,
    IN ULONG            Ioctl,
    IN PVOID            pInput,
    IN ULONG            SizeInput
    )
{
    NTSTATUS                        status;
    int                             retval;
    ULONG                           QueryType;
    IO_STATUS_BLOCK                 iosb;


    status = NtDeviceIoControlFile(
                      fd,                      // Handle
                      NULL,                    // Event
                      NULL,                    // ApcRoutine
                      NULL,                    // ApcContext
                      &iosb,                   // IoStatusBlock
                      Ioctl,                   // IoControlCode
                      pInput,                  // InputBuffer
                      SizeInput,               // InputBufferSize
                      (PVOID) ReturnBuffer,    // OutputBuffer
                      BufferSize);             // OutputBufferSize


    if (status == STATUS_PENDING)
    {
        status = NtWaitForSingleObject(
                    fd,                         // Handle
                    TRUE,                       // Alertable
                    NULL);                      // Timeout
        if (NT_SUCCESS(status))
        {
            status = iosb.Status;
        }
    }

    return(status);

} /* END OF DeviceIoCtrl() */


//------------------------------------------------------------------------

/*++

Routine Description:

    This procedure converts non prinatble characaters to periods ('.')

Arguments:
    string - the string to convert
    StrOut - ptr to a string to put the converted string into

Return Value:

    a ptr to the string that was converted (Strout)

--*/

TCHAR *
printable(
    IN TCHAR *  string,
    IN TCHAR *  StrOut
    )
{
    unsigned char *Out;
    unsigned char *cp;
    LONG     i;

    Out = StrOut;
    for (cp = string, i= 0; i < NETBIOS_NAME_SIZE; cp++,i++) {
        if (isprint(*cp)) {
            *Out++ = *cp;
            continue;
        }

        if (*cp >= 128) { /* extended characters are ok */
            *Out++ = *cp;
            continue;
        }
        *Out++ = '.';
    }
    return(StrOut);
}



//------------------------------------------------------------------------
NTSTATUS
GetInterfaceList(   IN OUT TCHAR pDeviceName[][MAX_NAME+1],
                    IN OUT PUCHAR pScope
                )
{
    HANDLE              StreamHandle;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    STRING              name_string, AnsiString;
    UNICODE_STRING      uc_name_string;
    NTSTATUS            status;
    char                pNbtWinsDeviceName[MAX_NAME] = "\\Device\\NetBt_Wins_Export";

    PUCHAR  SubKeyParms="system\\currentcontrolset\\services\\netbt\\parameters";
    HKEY    Key;
    LONG    Type;
    ULONG   size;
    CHAR    pScopeBuffer[BUFF_SIZE];
    PUCHAR  Scope="ScopeId";

    NETBT_INTERFACE_INFO    *pInterfaceInfo;
    ULONG                   InterfaceInfoSize=10*sizeof(NETBT_ADAPTER_INDEX_MAP)+sizeof(ULONG);
    PVOID                   pInput = NULL;
    ULONG                   SizeInput = 0;

    LONG    i, index=0;

    pInterfaceInfo = LocalAlloc(LMEM_FIXED,InterfaceInfoSize);
    if (!pInterfaceInfo)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    RtlInitString(&name_string, pNbtWinsDeviceName);
    RtlAnsiStringToUnicodeString(&uc_name_string, &name_string, TRUE);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &uc_name_string,
        OBJ_CASE_INSENSITIVE,
        (HANDLE) NULL,
        (PSECURITY_DESCRIPTOR) NULL
        );

    status = NtCreateFile (&StreamHandle,
                           SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                           &ObjectAttributes,
                           &IoStatusBlock,
                           NULL,
                           FILE_ATTRIBUTE_NORMAL,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           FILE_OPEN_IF,
                           0,
                           NULL,
                           0);

    RtlFreeUnicodeString(&uc_name_string);

    if (NT_SUCCESS (status))
    {
        do
        {
            status = DeviceIoCtrl(StreamHandle,
                                 pInterfaceInfo,
                                 InterfaceInfoSize,
                                 IOCTL_NETBT_GET_INTERFACE_INFO,
                                 pInput,
                                 SizeInput);

            if (status == STATUS_BUFFER_OVERFLOW)
            {
                LocalFree(pInterfaceInfo);

                InterfaceInfoSize *=2;
                pInterfaceInfo = LocalAlloc(LMEM_FIXED,InterfaceInfoSize);
                if (!pInterfaceInfo || (InterfaceInfoSize == 0xFFFF))
                {
                    NtClose(StreamHandle);
                    DebugMessage("\nUnable to allocate packet");
                    return(STATUS_INSUFFICIENT_RESOURCES);
                }
            }
            else if (!NT_SUCCESS (status))
            {
                NtClose(StreamHandle);
                return(status);
            }

        } while (status == STATUS_BUFFER_OVERFLOW);
        NtClose (StreamHandle);

        for (i=0; i<pInterfaceInfo->NumAdapters; i++)
        {
            RtlInitString(&name_string, NULL);
            RtlInitUnicodeString(&uc_name_string, pInterfaceInfo->Adapter[i].Name);
            if (NT_SUCCESS(RtlUnicodeStringToAnsiString(&name_string, &uc_name_string, TRUE)))
            {
                size = (name_string.Length > MAX_NAME) ? MAX_NAME : name_string.Length;

                strncpy(pDeviceName[index], name_string.Buffer, size);
                pDeviceName[index][size] = '\0';
                RtlFreeAnsiString (&name_string);

                index++;
            }
        }

        LocalFree(pInterfaceInfo);

        //
        // NULL out the next device string ptr
        //
        if (index < NBT_MAXIMUM_BINDINGS)
        {
            pDeviceName[index][0] = '\0';
        }

        //
        // Read the ScopeId key!
        //
        size = BUFF_SIZE;
        *pScope = '\0';     // By default
        status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     SubKeyParms,
                     0,
                     KEY_READ,
                     &Key);

        if (status == ERROR_SUCCESS)
        {
            // now read the Scope key
            status = RegQueryValueEx(Key, Scope, NULL, &Type, pScopeBuffer, &size);
            if (status == ERROR_SUCCESS)
            {
                strcpy(pScope,pScopeBuffer);
            }
            status = RegCloseKey(Key);
        }

        status = STATUS_SUCCESS;
    }

    return status;
}

/*
//-------------------------------------------------------------------------//
//######  R e a d R e g i s t r y ()  #####################################//
//-------------------------------------------------------------------------//
//  Abstract:                                                              //
//      Reads the names of the NetBT devices and the NetBT scope name form //
//      the registry. The names are stored in the Linkage/Export section   //
//      under the NetBT key.                                               //
//  Arguments:                                                             //
//      pScope - buffer where to store the scope string                    //
//  Return value:                                                          //
//      0  if successful                                                   //
//      -1 otherwise                                                       //
//  Global variables used:                                                 //
//      none                                                               //
//-------------------------------------------------------------------------//
LONG ReadNbtNameRegistry( IN OUT TCHAR pDeviceName[][MAX_NAME+1],
                          IN OUT PUCHAR pScope )
{

    LPCTSTR  c_szSubKeyParams = _T("system\\currentcontrolset\\services\\netbt\\parameters");
    LPCTSTR  c_szSubKeyLinkage = _T("system\\currentcontrolset\\services\\netbt\\linkage");
    HKEY    Key;
    LPCTSTR  c_szScope = _T("ScopeId");
    LPCTSTR  c_szExport = _T("Export");
    DWORD    dwType;
    LONG    status;
    LONG    status2;
    DWORD   size;
    LPBYTE  pBuffer;

    size = BUFF_SIZE;
    status = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                           c_szSubKeyLinkage,
                           0,
                           KEY_READ,
                           &Key
                         );
    if ( ERROR_SUCCESS != status)
    {
        return status;
    }

    // now read the Export values

    status = RegQueryValueEx( Key,
                              c_szExport,
                              NULL,
                              &dwType,
                              NULL,
                              &size
                             );


    pBuffer = Malloc(size);
    if( NULL == pBuffer)
    {
        DebugMessage("Out of Memory!\n");
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    ZeroMemory( pBuffer, size );

    status = RegQueryValueEx( Key,
                              c_szExport,
                              NULL,
                              &dwType,
                              pBuffer,
                              &size
                            );

    if ( ERROR_SUCCESS != status)
    {
        RegCloseKey(Key);
        return status;
    }

    if ( status == ERROR_SUCCESS )
    {

        LPBYTE  curPtr = pBuffer;
        LONG    index = 0;

        //
        // Copy over all the export keys
        //

        while( (*curPtr) && (index < NBT_MAXIMUM_BINDINGS) )
        {
            _tcscpy( pDeviceName[index], curPtr );
            ++index;
            curPtr += strlen(curPtr) + 1;
        }

        //
        // NULL out the next device string ptr
        //
        if ( index < NBT_MAXIMUM_BINDINGS ) {
            pDeviceName[index][0] = 0;
        }
    }

    Free(pBuffer);

    status = RegCloseKey( Key );

    if ( status != ERROR_SUCCESS )
        DebugMessage("Error closing the Registry key\n");


    status2 = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                           c_szSubKeyParams,
                           0,
                           KEY_READ,
                           &Key
                         );

    if ( status2 == ERROR_SUCCESS )
    {
        // now read the linkage values
        status2 = RegQueryValueEx( Key,
                                  c_szScope,
                                  NULL,
                                  &dwType,
                                  pScope,
                                  &size
                                );
        if( ERROR_SUCCESS != status2)
        {
            // No ScopeId!
            *pScope = 0;
        }

        status2 = RegCloseKey(Key);
    }

    return status;

}
*/




void NbtNmGlobalPrint(IN NETDIAG_PARAMS *pParams,
                         IN OUT NETDIAG_RESULT *pResults)
{
    if (pParams->fVerbose || pResults->NbtNm.hrTestResult != S_OK)
    {
        PrintNewLine(pParams, 2);
        PrintTestTitleResult(pParams, 
                             IDS_NBTNM_LONG, 
                             IDS_NBTNM_SHORT, 
                             pResults->Global.fHasNbtEnabledInterface ? TRUE : FALSE,
                             pResults->NbtNm.hrTestResult, 0);
    }

    PrintMessageList(pParams, &pResults->NbtNm.lmsgGlobalOutput);
}

void NbtNmPerInterfacePrint(IN NETDIAG_PARAMS *pParams,
                             IN OUT NETDIAG_RESULT *pResults,
                             IN INTERFACE_RESULT *pIfResults)
{
    if (!pIfResults->NbtNm.fActive ||
        NETCARD_DISCONNECTED == pIfResults->dwNetCardStatus)
        return;


    if(pParams->fVerbose || pIfResults->NbtNm.fQuietOutput)
    {
        PrintTestTitleResult(pParams, 
                             IDS_NBTNM_LONG, 
                             IDS_NBTNM_SHORT, 
                             pIfResults->fNbtEnabled ? TRUE : FALSE,
                             pResults->NbtNm.hrTestResult, 8);
    }

    PrintMessageList(pParams, &pIfResults->NbtNm.lmsgOutput);
}

void NbtNmCleanup(IN NETDIAG_PARAMS *pParams,
                         IN OUT NETDIAG_RESULT *pResults)
{
    int i;
    MessageListCleanUp(&pResults->NbtNm.lmsgGlobalOutput);
    for(i = 0; i < pResults->cNumInterfaces; i++)
    {
        if(pResults->pArrayInterface[i].NbtNm.fActive)
            MessageListCleanUp(&pResults->pArrayInterface[i].NbtNm.lmsgOutput);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\nbtxport.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      nbttrprt.c
//
//  Abstract:
//
//      Queries into network drivers
//
//  Author:
//
//      Anilth  - 4-20-1998 
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//--

#include "precomp.h"
#include "nbtutil.h"

BOOLEAN NlTransportGetIpAddress(IN LPWSTR TransportName,
                                OUT PULONG IpAddress,
                               IN OUT NETDIAG_RESULT *pResults);

/*!--------------------------------------------------------------------------
    NetBTTest
    Do whatever initialization Cliff's routines need that Karoly's will really
    do as a part of his tests.

    Arguments:
    
    None.
    
    Return Value:
    
    S_OK: Test suceeded.
    S_FALSE: Test failed
        
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT
NetBTTest(NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
{
    HRESULT     hr = hrOK;
    NET_API_STATUS NetStatus;
    PWKSTA_TRANSPORT_INFO_0 pWti0 = NULL;
    DWORD EntriesRead;
    DWORD TotalEntries;
    DWORD i;
    PNETBT_TRANSPORT pNetbtTransport;
    LONG    cNetbtTransportCount = 0;

    //
    //  Generate a global list of NetbtTransports.
    //  ?? Karoly, Please populate GlobalNetbtTransports and cNetbtTransportCount
    //      using some mechanism lower level mechanism.
    //
    
	if (!pResults->Global.fHasNbtEnabledInterface)
	{
		pResults->NetBt.fPerformed = FALSE;
		//IDS_NETBT_SKIP
		SetMessage(&pResults->NetBt.msgTestResult,
                   Nd_Verbose,
                   IDS_NETBT_SKIP);
		return S_OK;
	}

	PrintStatusMessage(pParams,0, IDS_NETBT_STATUS_MSG);

	pResults->NetBt.fPerformed = TRUE;

    NetStatus = NetWkstaTransportEnum(
                                      NULL,
                                      0,
                                      (LPBYTE *)&pWti0, 
                                      0xFFFFFFFF,      // MaxPreferredLength
                                      &EntriesRead,
                                      &TotalEntries,
                                      NULL );          // Optional resume handle

    if (NetStatus != NERR_Success)
    {
        // IDS_NETBT_11403 "    NetBt : [FATAL] Unable to retrieve transport list from Redir. [%s]\n"
        SetMessage(&pResults->NetBt.msgTestResult,
                   Nd_Quiet,
                   IDS_NETBT_11403, NetStatusToString(NetStatus));
        
        // the test failed, but we can continue with the other tests
        hr = S_FALSE;
    }
    else
    {
        cNetbtTransportCount = 0;
        
        for ( i=0; i<EntriesRead; i++ )
        {
            UNICODE_STRING TransportName;

            RtlInitUnicodeString( &TransportName, (LPWSTR)pWti0[i].wkti0_transport_name );

            if ( TransportName.Length >= sizeof(NETBT_DEVICE_PREFIX) &&
                _wcsnicmp( TransportName.Buffer, NETBT_DEVICE_PREFIX, (sizeof(NETBT_DEVICE_PREFIX)/sizeof(WCHAR)-1)) == 0 ) {

                //
                // Determine if this is a duplicate transport
                //
                pNetbtTransport = FindNetbtTransport( pResults, TransportName.Buffer );

                if ( pNetbtTransport != NULL )
                {
                    // IDS_NETBT_DUPLICATE "    NetBt : [WARNING] Transport %-16.16wZ is a duplicate"
                    PrintStatusMessage(pParams,0, IDS_NETBT_DUPLICATE,
                                       &TransportName);

                }
                else
                {

                    //
                    // Allocate a new netbt transport
                    //
                    pNetbtTransport = (PNETBT_TRANSPORT) Malloc(
                        sizeof(NETBT_TRANSPORT) +
                        TransportName.Length + sizeof(WCHAR));
                    
                    if ( pNetbtTransport == NULL )
                    {
                        // IDS_NETBT_11404 "    NetBt : [FATAL] Out of memory."
                        SetMessage(&pResults->NetBt.msgTestResult,
                                   Nd_Quiet,
                                   IDS_NETBT_11404);
        
                        // the test failed, but we can continue with the other tests
                        hr = S_FALSE;
                        goto Cleanup;
                    }

                    ZeroMemory( pNetbtTransport, 
                        sizeof(NETBT_TRANSPORT) +
                        TransportName.Length + sizeof(WCHAR));

                    wcscpy( pNetbtTransport->pswzTransportName, TransportName.Buffer );
                    pNetbtTransport->Flags = 0;

                    if ( !NlTransportGetIpAddress( pNetbtTransport->pswzTransportName,
                        &pNetbtTransport->IpAddress,
                        pResults) )
                    {
                        // the test failed, but we can continue with the other tests
                        hr = S_FALSE;
                        goto Cleanup;
                    }

                    InsertTailList( &pResults->NetBt.Transports,
                                    &pNetbtTransport->Next );
                    cNetbtTransportCount ++;
                }
            }
        }

        if ( cNetbtTransportCount == 0 )
        {
            // IDS_NETBT_11405 "    NetBt : [FATAL] No NetBt transports are configured"
            SetMessage(&pResults->NetBt.msgTestResult,
                       Nd_Quiet,
                       IDS_NETBT_11405);
            
            // the test failed, but we can continue with the other tests
            hr = S_FALSE;
        }
        else
        {
            int     ids;
            TCHAR   szBuffer[256];

            if (cNetbtTransportCount > 1)
            {
                ids = IDS_NETBT_11406;
                // IDS_NETBT_11406 "    %ld NetBt transport%s currently configured.\n"
            }
            else
            {
                ids = IDS_NETBT_11407;
                // IDS_NETBT_11407 "    1 NetBt transport currently configured.\n"
            }
            SetMessage(&pResults->NetBt.msgTestResult,
                       Nd_Verbose,
                       ids,
                       cNetbtTransportCount);
        }
    }

    
    pResults->NetBt.cTransportCount = cNetbtTransportCount;

Cleanup:
    if ( pWti0 )
    {
        NetApiBufferFree( pWti0 );
    }

    pResults->NetBt.hr = hr;

    return hr;
}


BOOLEAN
NlTransportGetIpAddress(
                        IN LPWSTR pswzTransportName,
                        OUT PULONG IpAddress,
                        IN OUT NETDIAG_RESULT *pResults
    )
/*++

Routine Description:

    Get the IP Address associated with the specified transport.

Arguments:

    pswzTransportName - Name of the transport to query.

    IpAddress - IP address of the transport.
        Zero if the transport currently has no address or
            if the transport is not IP.

Return Value:

    TRUE: transport is an IP transport

--*/
{
    NTSTATUS Status;
    BOOLEAN RetVal = FALSE;

    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING TransportNameString;
    HANDLE TransportHandle = NULL;
    ULONG IpAddresses[NBT_MAXIMUM_BINDINGS+1];
    ULONG BytesReturned;

    //
    // Open the transport device directly.
    //

    *IpAddress = 0;

    RtlInitUnicodeString( &TransportNameString, pswzTransportName );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &TransportNameString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL );

    Status = NtOpenFile(
                   &TransportHandle,
                   SYNCHRONIZE,
                   &ObjectAttributes,
                   &IoStatusBlock,
                   0,
                   0 );

    if (NT_SUCCESS(Status)) {
        Status = IoStatusBlock.Status;

    }

    if (! NT_SUCCESS(Status))
    {
        // IDS_NETBT_11408 "    [FATAL] Cannot open netbt driver '%ws'\n"
        SetMessage(&pResults->NetBt.msgTestResult,
                   Nd_Quiet,
                   IDS_NETBT_11408,
                   pswzTransportName);
        goto Cleanup;
    }

    //
    // Query the IP Address
    //

    if (!DeviceIoControl( TransportHandle,
                          IOCTL_NETBT_GET_IP_ADDRS,
                          NULL,
                          0,
                          IpAddresses,
                          sizeof(IpAddresses),
                          &BytesReturned,
                          NULL))
    {
        TCHAR   szBuffer[256];
        
        Status = NetpApiStatusToNtStatus(GetLastError());
        // IDS_NETBT_11409 "    [FATAL] Cannot get IP address from netbt driver '%ws':"
        SetMessage(&pResults->NetBt.msgTestResult,
                   Nd_Quiet,
                   IDS_NETBT_11409,
                   pswzTransportName);
        goto Cleanup;
    }

    //
    // Return IP Address
    //  (Netbt returns the address in host order.)
    //

    *IpAddress = htonl(*IpAddresses);
    RetVal = TRUE;

Cleanup:

    if ( TransportHandle != NULL )
    {
        (VOID) NtClose( TransportHandle );
    }

    return RetVal;
}

void NetBTGlobalPrint(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults)
{
    PLIST_ENTRY ListEntry;
    PNETBT_TRANSPORT pNetbtTransport;

    if (pParams->fVerbose || !FHrOK(pResults->NetBt.hr))
    {
        PrintNewLine(pParams, 2);
        PrintTestTitleResult(pParams,
                             IDS_NETBT_LONG,
                             IDS_NETBT_SHORT,
                             pResults->NetBt.fPerformed,
                             pResults->NetBt.hr,
                             0);
    }


    if ( pParams->fVerbose && pResults->NetBt.fPerformed)
    {
        // IDS_NETBT_11411 "    List of NetBt transports currently configured.\n"
        PrintMessage(pParams, IDS_NETBT_11411);
    }

    // Iterate through the transports
    //
    for ( ListEntry = pResults->NetBt.Transports.Flink ;
          ListEntry != &pResults->NetBt.Transports ;
          ListEntry = ListEntry->Flink )
    {
        //
        // If the transport names match,
        //  return the entry
        //

        pNetbtTransport = CONTAINING_RECORD( ListEntry, NETBT_TRANSPORT, Next );

        if (pParams->fVerbose)
        {
            // Strip off the "\Device\" off of the beginning of
            // the string
            
            // IDS_NETBT_11412 "        %ws\n"
            PrintMessage(pParams, IDS_NETBT_11412,
                         MapGuidToServiceNameW(pNetbtTransport->pswzTransportName+8));
        }

    }

    PrintNdMessage(pParams, &pResults->NetBt.msgTestResult);
}

void NetBTPerInterfacePrint(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults, INTERFACE_RESULT *pInterfaceResults)
{
}

void NetBTCleanup(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults)
{
    PNETBT_TRANSPORT pNetbtTransport;
    PLIST_ENTRY pListEntry;
    PLIST_ENTRY pListHead = &pResults->NetBt.Transports;
    
    // Need to remove all entries from the list
    while (!IsListEmpty(pListHead))
    {
        pListEntry = RemoveHeadList(pListHead);
        pNetbtTransport = CONTAINING_RECORD( pListEntry, NETBT_TRANSPORT, Next );
        Free( pNetbtTransport );
    }
    
    ClearMessage(&pResults->NetBt.msgTestResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\modemtst.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      modemtst.c
//
//  Abstract:
//
//      Queries into network drivers
//
//  Author:
//
//      Anilth  - 4-20-1998 
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//--
#include "precomp.h"
#undef IsEqualGUID
#include <ras.h>
#include <tapi.h>
#include <unimodem.h>


#define PRINT_MODEM( _i, _ids, _mdm) \
        PrintMessage(pParams, _ids, \
         MAP_ON_OFF(pResults->Modem.pModemDevice[_i].dwModemOptions & _mdm))


void GetLineId(NETDIAG_RESULT *pResults,
               int cModems,
               HLINEAPP hLineApp,
               DWORD dwDeviceID);

HRESULT
ModemTest(NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
//
// Description:
//
// This function performs diagnostics on all the line devices
//
// Arguments
// None
//
// Return:
// None
{
    
    LONG lReturn;
    DWORD dwNumDevs = 0;
    DWORD dwAPIVersion = TAPI_CURRENT_VERSION;
    HLINEAPP hLineApp = 0;
    DWORD dwDeviceID;
//  char pszDeviceClass[] = "tapi/line/diagnostics";
    char pszDeviceClass[] = "comm";
    LPVARSTRING lpVarString = NULL;
    VARSTRING   varStringT;
    DWORD   dwSize;
    LINEINITIALIZEEXPARAMS  lineParams;
    int         cModems = 0;
    
    PUMDEVCFG               lpDevConfig     = NULL;
    LPMODEMSETTINGS lpModemSettings = NULL;
    LPCOMMCONFIG    lpCommConfig    = NULL;
    HRESULT         hr = hrOK;

    PrintStatusMessage(pParams, 4, IDS_MODEM_STATUS_MSG);
    
    ZeroMemory(&lineParams, sizeof(lineParams));
    lineParams.dwTotalSize = sizeof(lineParams);
    lineParams.dwOptions = LINEINITIALIZEEXOPTION_USEEVENT;
    
    pResults->Modem.fPerformed = TRUE;

    lReturn = lineInitializeEx(
                               &hLineApp,
                               NULL,
                               NULL,
                               "NetDiag",
                               &dwNumDevs,
                               &dwAPIVersion,
                               &lineParams);
    
    
    //
    // Check whether this version can support our calls.
    // 
    
    
    if (lReturn != 0)
    {
        SetMessage(&pResults->Modem.ndOutput,
                   Nd_Quiet,
                   IDS_MODEM_LINEINIT_FAILED,
                   lReturn);
        pResults->Modem.hr = E_FAIL;
        return S_FALSE;
    }
    
    if (dwNumDevs == 0)
    {
        SetMessage(&pResults->Modem.ndOutput,
                   Nd_ReallyVerbose,
                   IDS_MODEM_NO_DEVICES);
        pResults->Modem.hr = hrOK;
        pResults->Modem.fPerformed = FALSE; //test is skipped
        return hrOK;
    }


    // Need to allocate a device structure for each device
    Free(pResults->Modem.pModemDevice);

    pResults->Modem.pModemDevice = (MODEM_DEVICE *) Malloc(
        sizeof(MODEM_DEVICE) * dwNumDevs);
    if (pResults->Modem.pModemDevice == NULL)
        return E_OUTOFMEMORY;

    ZeroMemory(pResults->Modem.pModemDevice,
               sizeof(MODEM_DEVICE) * dwNumDevs);
    pResults->Modem.cModems = dwNumDevs;
    
    //
    // Get the line device configuration settings
    //
    
    for (dwDeviceID = 0; dwDeviceID < dwNumDevs ; dwDeviceID++)
    {

        Free(lpVarString);
        lpVarString = NULL;


        // Get the proper size for the structure
        ZeroMemory(&varStringT, sizeof(VARSTRING));
        varStringT.dwTotalSize = sizeof(VARSTRING);
        lReturn = lineGetDevConfig(dwDeviceID,
                                   &varStringT,
                                   pszDeviceClass);

        if ((lReturn != 0) && (lReturn != LINEERR_STRUCTURETOOSMALL))
            continue;

        // dwSize = varStringT.dwNeededSize + sizeof(VARSTRING);
        dwSize = varStringT.dwNeededSize;
        
        lpVarString = (VARSTRING *) Malloc(dwSize);
        ZeroMemory(lpVarString, dwSize);
        lpVarString->dwTotalSize = dwSize;
        lpVarString->dwStringFormat = STRINGFORMAT_BINARY;
        lReturn = lineGetDevConfig(dwDeviceID,
                                   lpVarString,
                                   pszDeviceClass);

        
        if (lReturn != 0)
        {           
            DebugMessage2("Error: lineGetDevConfig for line id %d\n",lReturn);
            continue;
        }
        
        //
        // Interpret the results
        //
        
        if (lpVarString->dwStringFormat == STRINGFORMAT_BINARY
            && lpVarString->dwStringSize > sizeof(UMDEVCFG))
        {           
            lpDevConfig = (PUMDEVCFG) ((LPBYTE) lpVarString + lpVarString->dwStringOffset);
            lpCommConfig    = &lpDevConfig->commconfig;
            
            if (lpCommConfig->dwProviderSubType == PST_MODEM)
            {
                lpModemSettings = (LPMODEMSETTINGS)((LPBYTE) lpCommConfig + lpCommConfig->dwProviderOffset);

                GetLineId(pResults, cModems, hLineApp, dwDeviceID);
                
                pResults->Modem.pModemDevice[cModems].dwNegotiatedSpeed =
                    lpModemSettings->dwNegotiatedDCERate;
                pResults->Modem.pModemDevice[cModems].dwModemOptions =
                    lpModemSettings->dwNegotiatedModemOptions;
                pResults->Modem.pModemDevice[cModems].dwDeviceID = dwDeviceID;
                
                cModems++;
            } 
            
        }
        
    }

    pResults->Modem.cModems = cModems;
    
    Free(lpVarString);
    
    //
    // Shutdown TAPI
    //
    
    lReturn = lineShutdown(hLineApp);
    
    if (lReturn != 0)
    {       
//      if (pParams->fDebugVerbose)
//          printf("Error : lineShutdown!\n");
        pResults->Modem.hr = S_FALSE;
        return S_FALSE;
    }
    
    pResults->Modem.hr = hrOK;
    return hrOK;
    
}



/*!--------------------------------------------------------------------------
    ModemGlobalPrint
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void ModemGlobalPrint( NETDIAG_PARAMS* pParams,
                          NETDIAG_RESULT*  pResults)
{
    int     i;
    
    if (pParams->fVerbose || !FHrOK(pResults->Modem.hr))
    {
        PrintNewLine(pParams, 2);
        PrintTestTitleResult(pParams, IDS_MODEM_LONG, IDS_MODEM_SHORT, pResults->Modem.fPerformed,
                             pResults->Modem.hr, 0);

        PrintNdMessage(pParams, &pResults->Modem.ndOutput);

        if (pParams->fReallyVerbose)
        {
            for ( i=0; i<pResults->Modem.cModems; i++)
            {
                PrintNewLine(pParams, 1);
                PrintMessage(pParams, IDS_MODEM_NAME,
                             pResults->Modem.pModemDevice[i].pszName);
                PrintMessage(pParams, IDS_MODEM_DEVICEID,
                             pResults->Modem.pModemDevice[i].dwDeviceID);
                PrintMessage(pParams, IDS_MODEM_PORT,
                             pResults->Modem.pModemDevice[i].pszPort);
                PrintMessage(pParams, IDS_MODEM_NEGOTIATED_SPEED,
                             pResults->Modem.pModemDevice[i].dwNegotiatedSpeed);
                
                PRINT_MODEM( i, IDS_MODEM_COMPRESSION, MDM_COMPRESSION);
                PRINT_MODEM( i, IDS_MODEM_ERROR_CONTROL, MDM_ERROR_CONTROL);
                PRINT_MODEM( i, IDS_MODEM_FORCED_EC, MDM_FORCED_EC);
                PRINT_MODEM( i, IDS_MODEM_CELLULAR, MDM_CELLULAR);
                PRINT_MODEM( i, IDS_MODEM_FLOWCONTROL_HARD, MDM_FLOWCONTROL_HARD);
                PRINT_MODEM( i, IDS_MODEM_FLOWCONTROL_SOFT, MDM_FLOWCONTROL_SOFT);
                PRINT_MODEM( i, IDS_MODEM_CCITT_OVERRIDE, MDM_CCITT_OVERRIDE);
                PRINT_MODEM( i, IDS_MODEM_SPEED_ADJUST, MDM_SPEED_ADJUST);
                PRINT_MODEM( i, IDS_MODEM_TONE_DIAL, MDM_TONE_DIAL);
                PRINT_MODEM( i, IDS_MODEM_BLIND_DIAL, MDM_BLIND_DIAL);
                PRINT_MODEM( i, IDS_MODEM_V23_OVERRIDE, MDM_V23_OVERRIDE);
                
            }
        }
    }
}

/*!--------------------------------------------------------------------------
    ModemPerInterfacePrint
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void ModemPerInterfacePrint( NETDIAG_PARAMS* pParams,
                                NETDIAG_RESULT*  pResults,
                                INTERFACE_RESULT *pInterfaceResults)
{
    // no per-interface results
}


/*!--------------------------------------------------------------------------
    ModemCleanup
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
void ModemCleanup( NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
{
    int     i;
    
    ClearMessage(&pResults->Modem.ndOutput);

    for (i=0; i<pResults->Modem.cModems; i++)
    {
        Free(pResults->Modem.pModemDevice[i].pszPort);
        pResults->Modem.pModemDevice[i].pszPort = NULL;
    }
    
    Free(pResults->Modem.pModemDevice);
    pResults->Modem.pModemDevice = NULL;
    pResults->Modem.cModems = 0;
}


void GetLineId(NETDIAG_RESULT *pResults,
               int cModems,
               HLINEAPP hLineApp,
               DWORD dwDeviceID)
{
    HLINE   hLine = 0;
    LONG    lReturn;
    VARSTRING   varString;
    VARSTRING * lpVarString;
    LINEDEVCAPS lineDevCaps;
    LINEDEVCAPS * pLineDevCaps = NULL;
    
    
    lReturn = lineOpen(hLineApp,
                       dwDeviceID,
                       &hLine,
                       TAPI_CURRENT_VERSION,
                       0,
                       0,
                       LINECALLPRIVILEGE_NONE,
                       LINEMEDIAMODE_UNKNOWN,
                       NULL);

    if (lReturn == 0)
    {
        ZeroMemory(&varString, sizeof(VARSTRING));
        varString.dwTotalSize = sizeof(VARSTRING);
        lReturn = lineGetID(hLine, 0, 0, LINECALLSELECT_LINE,
                            &varString, "comm/datamodem/portname");
        if ((lReturn == 0) || (lReturn == LINEERR_STRUCTURETOOSMALL))
        {
            lpVarString = (VARSTRING *) Malloc(varString.dwNeededSize);
            if (lpVarString)
            {
				ZeroMemory(lpVarString, varString.dwNeededSize);
				lpVarString->dwTotalSize = varString.dwNeededSize;
                lReturn = lineGetID(hLine, 0, 0, LINECALLSELECT_LINE,
                                    lpVarString, "comm/datamodem/portname");
                pResults->Modem.pModemDevice[cModems].pszPort =
                    StrDupTFromA((char *) (lpVarString + 1));

                Free(lpVarString);
            }
        }
        
        lineClose(hLine);
    }

    // Get the name of this line

    ZeroMemory(&lineDevCaps, sizeof(lineDevCaps));
    lineDevCaps.dwTotalSize = sizeof(LINEDEVCAPS);
    lineDevCaps.dwStringFormat = STRINGFORMAT_UNICODE;
    
    lReturn = lineGetDevCaps(hLineApp,
                             dwDeviceID,
                             TAPI_CURRENT_VERSION, 
                             0,
                             &lineDevCaps);

    if ((lReturn == 0) || (lReturn == LINEERR_STRUCTURETOOSMALL))
    {
        pLineDevCaps = (LINEDEVCAPS *) Malloc(lineDevCaps.dwNeededSize);
		if (pLineDevCaps)
		{
			ZeroMemory(pLineDevCaps, lineDevCaps.dwNeededSize);
			pLineDevCaps->dwTotalSize = lineDevCaps.dwNeededSize;
			pLineDevCaps->dwStringFormat = STRINGFORMAT_UNICODE;
                
			lReturn = lineGetDevCaps(hLineApp,
									 dwDeviceID,
									 TAPI_CURRENT_VERSION,
									 0,
									 pLineDevCaps);
			if (lReturn == 0)
			{
				if (pLineDevCaps->dwStringFormat == STRINGFORMAT_UNICODE)
				{
					pResults->Modem.pModemDevice[cModems].pszName =
						StrDupTFromW((WCHAR *) (((BYTE *) pLineDevCaps) +
									 pLineDevCaps->dwLineNameOffset));
				}
				else
				{
					pResults->Modem.pModemDevice[cModems].pszName =
						StrDupTFromA((char *) (((BYTE *) pLineDevCaps) +
									 pLineDevCaps->dwLineNameOffset));
				}
			}
		}
        
    }
                   

    if (pLineDevCaps)
        Free(pLineDevCaps);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\ndcommon.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ndcommon.h
//
//--------------------------------------------------------------------------

//
// Common include files.
//
#ifndef HEADER_COMMONTMP
#define HEADER_COMMONTMP

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <lmcons.h>
#include <rpc.h>
#include <tchar.h>

#include <align.h>      // ROUND_UP_COUNT ...
// Porting to Source Depot - smanda #include <accessp.h>    // DsGetDc initialization
#include <dsgetdc.h>    // DsGetDcName()
#include <dsrole.h>     // DsRoleGetPrimaryDomainInfo
#include <dnsapi.h>     // DNS APIs
// #include <..\..\dns\dnslib\dnslib.h>     // Private DNS routines
// #include <dnslib.h>     // Private DNS routines
#include <icanon.h>     // NAMETYPE_* defines
#define _AVOID_IP_ADDRESS 1
//#include <ipconfig.h>   // ipconfig utility definitions
#include <lmaccess.h>   // NetLogonControl2
#include <lmapibuf.h>   // NetApiBufferFree
#include <lmerr.h>      // NERR_ equates.
#include <lmserver.h>   // Server API defines and prototypes
#include <lmuse.h>      // NetUse* API
#include <netlogon.h>   // Netlogon mailslot messages
#include <logonp.h>     // NetpLogon routines


#define SECURITY_WIN32
#define SECURITY_KERBEROS
#include <sspi.h>       // Needed by kerberos.h
#include <kerberos.h>   // Kerberos tests
// Porting to Source Depot - smanda #include <names.h>      // NetpIsDomainNameValid
#include <netlib.h>     // NetpCopy...
#include <netlibnt.h>   // NetpNtStatusToApiStatus
#include <ntddbrow.h>   // Interface to browser driver
#include <nbtioctl.h>   // Interface to netbt driver
//#include <nlcommon.h>   // DsGetDcName internal routines.
#include <ntlsa.h>      // LSA APIs
#include <ntdsapi.h>
#include <stdlib.h>     // C library functions (rand, etc)
#define _TSTR_H_INCLUDED    // Lie to prevent collision with ipconfig.h
#include <tstring.h>    // Transitional string routines.
#include <stdio.h>
#include <winldap.h>
#include <brcommon.h>
#include <lmbrowsr.h>
#include <lmremutl.h>
#include <rxserver.h>

#include <iprtrmib.h> // Rajkumar

#include <iptypes.h>
#include <llinfo.h>

#include <assert.h>
#include <ipexport.h>
#include <winsock.h>
#include <icmpapi.h>

#include "ipcfgtest.h"


/*==========================< Includes for IPX Test >=======================*/

#include "errno.h"
#include "tdi.h"
#include "isnkrnl.h"

//
//  include support code for the NetBT ioctls
//

#include <nb30.h>
#include <nbtioctl.h>

/*==========================< Includes for DHCP Test >=====================*/

//#include <dhcp.h>
//#include <dhcpdef.h>

/*==========================< Includes for IPX Test >=======================*/

#include <mprapi.h>


#define BUFF_SIZE 650


/*===========================< NetBT vars >===============================*/

#define NETBIOS_NAME_SIZE 16

#define ALL_IP_TRANSPORTS 0xFFFFFFFF
#define NL_IP_ADDRESS_LENGTH 15
#define NL_MAX_DNS_LENGTH       255

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\ndisquer.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      ndisquer.c
//
//  Abstract:
//
//      Queries into network drivers
//
//  Author:
//
//      Anilth  - 4-20-1998 
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//--

#include "precomp.h"
#pragma pack(push)
#pragma pack()
#include <ndispnp.h>
#pragma pack(pop)
#include <malloc.h>
//#include <cfgmgr32.h>

const TCHAR c_szDevicePath[] = _T("\\DEVICE\\");
const LPCTSTR c_ppszNetCardStatus[] = {
    "CONNECTED",
    "DISCONNECTED",
    "UNKNOWN"
    };

LPTSTR UTOTWithAlloc(IN PUNICODE_STRING U);

DWORD
CheckThisDriver(
    NETDIAG_RESULT *pResults, 
    PNDIS_INTERFACE pInterface, 
    DWORD *pdwNetCardStatus);


WCHAR               BLBuf[4096];
PNDIS_ENUM_INTF     Interfaces = (PNDIS_ENUM_INTF)BLBuf;

//
//  This routine first gets the list of all Network drivers and then query
//  them for the statistics
//
//  Arguments:
//      None.
//
//  Return Value:
//      TRUE:  Test suceeded.
//      FALSE: Test failed
//
HRESULT NdisTest(NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
{
    HRESULT     hr = S_OK;

    BOOL        bAtleastOneDriverOK = FALSE;

    int iIfIndex;

    PrintStatusMessage( pParams, 4, IDS_NDIS_STATUS_MSG );
    
    InitializeListHead(&pResults->Ndis.lmsgOutput);

    //IDS_NDIS_16000                  "\n    Information of Netcard drivers:\n\n" 
    AddMessageToListId( &pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, IDS_NDIS_16000);

    if (NdisEnumerateInterfaces(Interfaces, sizeof(BLBuf)))
    {
        UINT        i;

        for (i = 0; i < Interfaces->TotalInterfaces; i++) 
        {
            //we also put the netcard status to the per interface results if the interface
            //is bound to tcpip or ipx
            INTERFACE_RESULT*    pIfResults = NULL;
            LPTSTR pszDeviceDescription = UTOTWithAlloc(&Interfaces->Interface[i].DeviceDescription);
            LPTSTR pszDeviceName = UTOTWithAlloc(&Interfaces->Interface[i].DeviceName);
            DWORD  dwCardStatus = NETCARD_CONNECTED;
            
            if (pszDeviceDescription == NULL || pszDeviceName == NULL)
            {
            // memory allocation failed
               continue;
            }

//$REVIEW should we ignore WAN minports?
            if(NULL != _tcsstr(pszDeviceDescription, "WAN Miniport")){
                // ignore WAN miniports
                continue;
            }

            if(NULL != _tcsstr(pszDeviceDescription, "ATM Emulated LAN")){
                // ignore ATM Emulated LAN
                continue;
            }

            if(NULL != _tcsstr(pszDeviceDescription, "Direct Parallel"))
            {
                // ignore "Direct Parallel" interface because it doesn't support NdisQueryStatistics()
                continue;
            }


            //IDS_NDIS_16001                  "    ---------------------------------------------------------------------------\n" 
            AddMessageToListId( &pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, IDS_NDIS_16001);
            //IDS_NDIS_16002                  "    Description: %s\n" 
            AddMessageToList( &pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, 
                                IDS_NDIS_16002, pszDeviceDescription);

            //IDS_NDIS_16003                  "    Device: %s\n" 
            AddMessageToList( &pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, 
                                IDS_NDIS_16003, pszDeviceName);

            //try to find a match in the current interface list
            if( 0 == StrniCmp(c_szDevicePath, pszDeviceName, _tcslen(c_szDevicePath)))
            {
                LPTSTR pszAdapterName = pszDeviceName + _tcslen(c_szDevicePath);
    
                for ( iIfIndex=0; iIfIndex<pResults->cNumInterfaces; iIfIndex++)
                {
                    if (_tcscmp(pResults->pArrayInterface[iIfIndex].pszName,
                             pszAdapterName) == 0)
                    {
                        pIfResults = pResults->pArrayInterface + iIfIndex;
                        break;
                    }
                }
            }

            Free(pszDeviceDescription);
            Free(pszDeviceName);

            CheckThisDriver(pResults, &Interfaces->Interface[i], &dwCardStatus);

            if(NETCARD_CONNECTED == dwCardStatus)
                bAtleastOneDriverOK = TRUE;

            //if the interface is in the tcpip or ipx binding path, save the status
            //in the per interface result
            if (pIfResults)
                pIfResults->dwNetCardStatus = dwCardStatus;

        }
    } 
    else 
    {
        //IDS_NDIS_16004                  "    Enumerate failed 0x%lX\n" 
        AddMessageToList( &pResults->Ndis.lmsgOutput, Nd_Quiet, IDS_NDIS_16004, Win32ErrorToString(GetLastError()));
        hr = S_FALSE;
    }


    //IDS_NDIS_16005                  "    ---------------------------------------------------------------------------\n" 
    AddMessageToList( &pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, IDS_NDIS_16005);

    if(!bAtleastOneDriverOK)
    {
        BOOL    fAllCardDown = TRUE;
        for ( iIfIndex=0; iIfIndex<pResults->cNumInterfaces; iIfIndex++)
        {
            if (NETCARD_DISCONNECTED != pResults->pArrayInterface[iIfIndex].dwNetCardStatus)
            {
                fAllCardDown = FALSE;
                break;
            }
        }

        //IDS_NDIS_16006                  "    [FATAL] - None of the Netcard drivers gave satisfactory results!\n" 
        AddMessageToListId( &pResults->Ndis.lmsgOutput, Nd_Quiet, IDS_NDIS_16006);
        if (fAllCardDown)
        {
            //IDS_NDIS_ALL_CARD_DOWN            "\nSince there is no network connection for this machine, we do not need to perform any more network diagnostics.\n"
            AddMessageToListId( &pResults->Ndis.lmsgOutput, Nd_Quiet, IDS_NDIS_ALL_CARD_DOWN);
            hr = E_FAIL;
        }
        else
            hr = S_FALSE;                                                              
    } 
    else 
    {
        //IDS_NDIS_16007                  "    [SUCCESS] - At least one Netcard driver gave satisfactory results!\n" 
        AddMessageToList( &pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, IDS_NDIS_16007);
    }


    if ( FHrOK(hr) )
    {
        PrintStatusMessage(pParams, 0, IDS_GLOBAL_PASS_NL);
    }
    else
    {
        PrintStatusMessage(pParams, 0, IDS_GLOBAL_FAIL_NL);
    }

    pResults->Ndis.hrTestResult = hr;
    return hr;
}

//Convert a UNICODE_STRING to a TString with memory allocation.
//It's the caller's responsibility to free the memory with Free()
LPTSTR UTOTWithAlloc(IN PUNICODE_STRING U)
{
    LPTSTR pszBuf = (LPTSTR)Malloc(U->Length + sizeof(TCHAR));
    if (pszBuf != NULL)
       StrnCpyTFromW(pszBuf, U->Buffer, U->Length/(sizeof(*(U->Buffer))) + 1);
    return pszBuf;
}

//Map a NetCardStatus code to the description string
LPCTSTR MapNetCardStatusToString(DWORD  dwNicStatus)
{
    return c_ppszNetCardStatus[dwNicStatus];
}

#define SECS_PER_DAY    (24*60*60)
#define SECS_PER_HOUR   (60*60)
#define SECS_PER_MIN    60

//Check and print the NIC driver status. pdwNetCardStatus will contain the net card status when
//the function returns. If the query failed, *pdwNetCardStatus will be set
// as NETCARD_STATUS_UNKNOWN.
// Return:   the Windows Error code.
DWORD
CheckThisDriver(NETDIAG_RESULT *pResults, PNDIS_INTERFACE pInterface, DWORD *pdwNetCardStatus)
{
    NIC_STATISTICS  Stats;
    DWORD   dwReturnVal = ERROR_SUCCESS;
    DWORD   dwNicStatus = NETCARD_CONNECTED;
    
    assert(pdwNetCardStatus);

    memset(&Stats, 0, sizeof(NIC_STATISTICS));
    Stats.Size = sizeof(NIC_STATISTICS);

    if(NdisQueryStatistics(&pInterface->DeviceName, &Stats))
    {
        //IDS_NDIS_16008                  "\n    Media State:                     %s\n" 
        AddMessageToListId(&pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, IDS_NDIS_16008);
        switch(Stats.MediaState)
        {
        case MEDIA_STATE_CONNECTED:
            AddMessageToListId(&pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, IDS_NDIS_CONNECTED);
            break;
        case MEDIA_STATE_DISCONNECTED:
            dwNicStatus = NETCARD_DISCONNECTED; 
            AddMessageToListId(&pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, IDS_NDIS_DISCONNECTED);
            break;
        default:
            dwNicStatus = NETCARD_STATUS_UNKNOWN;
            AddMessageToListId(&pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, IDS_NDIS_UNKNOWN);
            break;
        }

        //IDS_NDIS_16009                  "\n    Device State:                     " 
        AddMessageToListId( &pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, IDS_NDIS_16009);
        switch(Stats.DeviceState)
        {
        case DEVICE_STATE_CONNECTED:
            AddMessageToListId(&pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, IDS_NDIS_CONNECTED);
            break;
        case DEVICE_STATE_DISCONNECTED:
            AddMessageToListId(&pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, IDS_NDIS_DISCONNECTED);
            break;
        default:
            AddMessageToListId(&pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, IDS_NDIS_UNKNOWN);
            break;
        }
        

        //IDS_NDIS_16010                  "    Connect Time:                    " 
        AddMessageToList( &pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, IDS_NDIS_16010);
        if (Stats.ConnectTime > SECS_PER_DAY)
        {
            //IDS_NDIS_16011                  "%d days, " 
            AddMessageToList( &pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, IDS_NDIS_16011, Stats.ConnectTime / SECS_PER_DAY);
            Stats.ConnectTime %= SECS_PER_DAY;
        }
        //IDS_NDIS_16012                  "%02d:" 
        AddMessageToList( &pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, IDS_NDIS_16012, Stats.ConnectTime / SECS_PER_HOUR);
        Stats.ConnectTime %= SECS_PER_HOUR;
        //IDS_NDIS_16013                  "%02d:" 
        AddMessageToList( &pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, IDS_NDIS_16013, Stats.ConnectTime / SECS_PER_MIN);
        Stats.ConnectTime %= SECS_PER_MIN;
        //IDS_NDIS_16014                  "%02d\n" 
        AddMessageToList( &pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, IDS_NDIS_16014, Stats.ConnectTime);

        Stats.LinkSpeed *= 100;
        if (Stats.LinkSpeed >= 1000000000)
            //IDS_NDIS_16015                  "    Media Speed:                     %d Gbps\n" 
          AddMessageToList( &pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, IDS_NDIS_16015, 
                                                    Stats.LinkSpeed / 1000000);
        else if (Stats.LinkSpeed >= 1000000)
            //IDS_NDIS_16016                  "    Media Speed:                     %d Mbps\n" 
          AddMessageToList( &pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, IDS_NDIS_16016, 
                                                    Stats.LinkSpeed / 1000000);
        else if (Stats.LinkSpeed >= 1000)
            //IDS_NDIS_16017                  "    Media Speed:                     %d Kbps\n" 
          AddMessageToList( &pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, IDS_NDIS_16017, 
                                                    Stats.LinkSpeed / 1000);
        else
            //IDS_NDIS_16018                  "    Media Speed:                     %d bps\n" 
          AddMessageToList( &pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, IDS_NDIS_16018, 
                                                    Stats.LinkSpeed);

        //IDS_NDIS_16019                  "\n    Packets Sent:                    %d\n" 
        AddMessageToList( &pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, IDS_NDIS_16019, Stats.PacketsSent);
        //IDS_NDIS_16020                  "    Bytes Sent (Optional):           %d\n" 
        AddMessageToList( &pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, IDS_NDIS_16020, Stats.BytesSent);

        //IDS_NDIS_16021                  "\n    Packets Received:                %d\n" 
        AddMessageToList( &pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, IDS_NDIS_16021, 
                                                    Stats.PacketsReceived);
        //IDS_NDIS_16022                  "    Directed Pkts Recd (Optional):   %d\n" 
        AddMessageToList( &pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, IDS_NDIS_16022, 
                                                Stats.DirectedPacketsReceived);
        //IDS_NDIS_16023                  "    Bytes Received (Optional):       %d\n" 
        AddMessageToList( &pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, IDS_NDIS_16023, 
                                                Stats.BytesReceived);
        //IDS_NDIS_16024                  "    Directed Bytes Recd (Optional):  %d\n\n" 
        AddMessageToList( &pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, IDS_NDIS_16024, 
                                                Stats.DirectedBytesReceived);

        if (Stats.PacketsSendErrors != 0)
            //IDS_NDIS_16025                  "    Packets SendError:               %d\n" 
            AddMessageToList( &pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, IDS_NDIS_16025, 
                                                Stats.PacketsSendErrors);
        if (Stats.PacketsReceiveErrors != 0)
            //IDS_NDIS_16026                  "    Packets RecvError:               %d\n" 
            AddMessageToList( &pResults->Ndis.lmsgOutput, Nd_ReallyVerbose, IDS_NDIS_16026, 
                                                Stats.PacketsReceiveErrors);
    
        // if we received packets, consider this driver to be fine
        if(NETCARD_CONNECTED != dwNicStatus)
        {
            //IDS_NDIS_16029                "	[WARNING] The net card '%wZ' may not work!\n"
            AddMessageToList( &pResults->Ndis.lmsgOutput, Nd_Quiet, IDS_NDIS_16029,
                              &pInterface->DeviceDescription);
        }
        else if (!Stats.PacketsReceived)
        {
            //IDS_NDIS_NO_RCV                   "    [WARNING] The net card '%wZ' may not be working because it receives no packets!\n"
            AddMessageToList( &pResults->Ndis.lmsgOutput, Nd_Quiet, IDS_NDIS_NO_RCV,
                              &pInterface->DeviceDescription);
        }
    } else {
        dwReturnVal = GetLastError();
        //IDS_NDIS_16027                  "    GetStats failed for '%wZ'. [%s]\n" 
        AddMessageToList( &pResults->Ndis.lmsgOutput, Nd_Quiet, IDS_NDIS_16027, 
                          &pInterface->DeviceDescription, Win32ErrorToString(dwReturnVal));
        
        dwNicStatus = NETCARD_STATUS_UNKNOWN;
    }

    
    *pdwNetCardStatus = dwNicStatus;

    return dwReturnVal;
}


void NdisGlobalPrint(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults)
{
    if (pParams->fVerbose || !FHrOK(pResults->Ndis.hrTestResult))
    {
        PrintNewLine(pParams, 2);
        PrintTestTitleResult(pParams,
                             IDS_NDIS_LONG,
                             IDS_NDIS_SHORT,
                             TRUE,
                             pResults->Ndis.hrTestResult,
                             0);
    }

    PrintMessageList(pParams, &pResults->Ndis.lmsgOutput);
}

void NdisPerInterfacePrint(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults, INTERFACE_RESULT *pInterfaceResults)
{
    if (pParams->fVerbose || NETCARD_CONNECTED != pInterfaceResults->dwNetCardStatus)
    {
        PrintNewLine(pParams, 1);
        if (NETCARD_CONNECTED != pInterfaceResults->dwNetCardStatus)
        {
            PrintTestTitleResult(pParams, IDS_NDIS_LONG, IDS_NDIS_SHORT, TRUE, S_FALSE, 8);
            //IDS_NDIS_16030    "	NetCard Status			%s\n"
            PrintMessage(pParams, IDS_NDIS_16030, MapNetCardStatusToString(pInterfaceResults->dwNetCardStatus));
            if (NETCARD_DISCONNECTED == pInterfaceResults->dwNetCardStatus)
                PrintMessage(pParams, IDS_NDIS_CARD_DOWN);
        }
        else
            PrintTestTitleResult(pParams, IDS_NDIS_LONG, IDS_NDIS_SHORT, TRUE, S_OK, 8);
    }
}


void NdisCleanup(IN NETDIAG_PARAMS *pParams,
                     IN OUT NETDIAG_RESULT *pResults)
{
    MessageListCleanUp(&pResults->Ndis.lmsgOutput);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\ndstruct.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       ndstruct.h
//
//--------------------------------------------------------------------------

#ifndef HEADER_NDSTRUCT
#define HEADER_NDSTRUCT


typedef struct _NETBT_TRANSPORT {
    LIST_ENTRY Next;

    //
    // Flags describing this Netbt transport
    //

    DWORD Flags;

#define BOUND_TO_REDIR    0x001 // Transport is bound to the redir
#define BOUND_TO_BOWSER   0x002 // Transport is bound to the bowser
#define IP_ADDRESS_IN_DNS 0x004 // IP address is registered in DNS

    //
    // IP Address for this transport
    //

    ULONG IpAddress;

    //
    // Name of the transport (Must be the last field in the structure)
    //
    WCHAR pswzTransportName[1];
} NETBT_TRANSPORT, *PNETBT_TRANSPORT;


//
// Structure describing a single tested domain
//

typedef struct _TESTED_DOMAIN {
    LIST_ENTRY Next;

    //
    // Name of the domain.
    //
    //  Queryable domain is NULL for the domain we're a member of so we can
    //  pass NULL to DsGetDcName for that domain.  Doing so has better query
    //  characteristics since it tries both the Netbios and DNS domain names.
    //
    //LPWSTR DomainName;
    LPWSTR  NetbiosDomainName;      // NULL if not known
    LPWSTR  DnsDomainName;          // NULL if not known
    LPWSTR  PrintableDomainName;    // Pointer to a non-NULL domain name string

    LPWSTR QueryableDomainName;  // Can be NULL for domain we're a member of
    BOOL    fPrimaryDomain;      // True if the domain is domain we're a member of 

    //BOOL IsNetbios;     // True if DomainName is syntactically a Netbios name
    //BOOL IsDns;         // True if DomainName is syntactically a Dns name

    //
    // Domain Sid of the domain (if known)
    //
	BOOL fDomainSid;		// do we have the domain sid?
    PSID DomainSid;

    //
    // DcInfo for a DS_PREFERRED DC in the domain.
    //
    PDOMAIN_CONTROLLER_INFOW DcInfo;
    BOOL    fTriedToFindDcInfo;

    //
    // List of DCs to test.
    //

    LIST_ENTRY TestedDcs;

} TESTED_DOMAIN, *PTESTED_DOMAIN;

//
// Structure describing a single tested DC
//

typedef struct _TESTED_DC {
    LIST_ENTRY Next;

    //
    // Name of the DC
    //
    // This will be the DNS DC name if we know it.  Otherwise it will be the
    // Netbios DC name.
    //
    LPWSTR ComputerName;

    WCHAR NetbiosDcName[CNLEN+1];

	ULONG	Rid;

    //
    // IP Address of the DC
    //  NULL: Not yet known
    //

    LPWSTR DcIpAddress;

    //
    // Backlink to domain this DC belongs to
    //

    PTESTED_DOMAIN TestedDomain;

    //
    // Flags describing this DC.
    //

    ULONG Flags;

#define DC_IS_DOWN      0x001   // DC cannot be pinged
#define DC_IS_NT5       0x002   // DC is running NT 5 (or newer)
#define DC_IS_NT4       0x004   // DC is running NT 4 (or older)
#define DC_PINGED       0x008   // The DC pinged
#define DC_FAILED_PING	0x010	// The DC ping failed


} TESTED_DC, *PTESTED_DC;


//
// Generic interface to DsGetDcName

typedef DWORD (WINAPI DSGETDCNAMEW)(
    IN LPCWSTR ComputerName OPTIONAL,
    IN LPCWSTR DomainName OPTIONAL,
    IN GUID *DomainGuid OPTIONAL,
    IN LPCWSTR SiteName OPTIONAL,
    IN ULONG Flags,
    OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
    );



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\ndutils.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      ndutils.c
//
//  Abstract:
//
//      Queries into network drivers
//
//  Author:
//
//      Anilth  - 4-20-1998 
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//--

#include "precomp.h"
#include "global.h"
#include <ntstatus.dbg>
#include <winerror.dbg>
#include "ipcfg.h"

#define MAX_NET_STATUS_LENGTH 80
#define MAX_WINERR_SIZE       80

const TCHAR c_szSectionName[] = _T("NetDiagContact");
const TCHAR c_szFileName[] = _T("NdContact.ini");


HRESULT HResultFromWin32(DWORD dwErr)
{
    return HRESULT_FROM_WIN32(dwErr);
}

LPTSTR Win32ErrorToString(DWORD Id)
{
    
    int i = 0;
    static TCHAR s_szWinerr[MAX_WINERR_SIZE + 1];
    
    while (winerrorSymbolicNames[ i ].SymbolicName) 
    {
        if (winerrorSymbolicNames[ i ].MessageId == Id) 
        {
            _tcsncpy( s_szWinerr, A2T(winerrorSymbolicNames[ i ].SymbolicName), 
                      MAX_WINERR_SIZE);

            return s_szWinerr;
        } 
        else 
        {
            i ++;
        }
    }

    
    //if we reach here, then we cannot find the Win32 Error string

    _stprintf(s_szWinerr, _T("%X"), (DWORD)Id);
    
    return s_szWinerr;

}

LPSTR
FindSymbolicNameForStatus(
    DWORD Id
    )
{
    ULONG i;

    i = 0;
    if (Id == 0) {
        return "STATUS_SUCCESS";
    }

    if (Id & 0xC0000000) {
        while (ntstatusSymbolicNames[ i ].SymbolicName) {
            if (ntstatusSymbolicNames[ i ].MessageId == (NTSTATUS)Id) {
                return ntstatusSymbolicNames[ i ].SymbolicName;
            } else {
                i += 1;
            }
        }
    }

    i = 0;
    while (winerrorSymbolicNames[ i ].SymbolicName) {
        if (winerrorSymbolicNames[ i ].MessageId == Id) {
            return winerrorSymbolicNames[ i ].SymbolicName;
        } else {
            i += 1;
        }
    }

#ifdef notdef
    while (neteventSymbolicNames[ i ].SymbolicName) {
        if (neteventSymbolicNames[ i ].MessageId == Id) {
            return neteventSymbolicNames[ i ].SymbolicName
        } else {
            i += 1;
        }
    }
#endif // notdef

    return NULL;
}




VOID
PrintSid(
    IN NETDIAG_PARAMS *pParams,
    IN PSID Sid OPTIONAL
    )
/*++

Routine Description:

    Prints a SID

Arguments:

    Sid - SID to output

Return Value:

    none

--*/
{

    if ( Sid == NULL ) 
    {
        //IDS_UTIL_SID_NULL      "(null)\n"
        PrintMessage(pParams, IDS_UTIL_SID_NULL);
    } 
    else 
    {
        UNICODE_STRING SidString;
        NTSTATUS Status;

        Status = RtlConvertSidToUnicodeString( &SidString, Sid, TRUE );

        if ( !NT_SUCCESS(Status) ) 
        {
            //IDS_UTIL_SID_INVALID       "Invalid 0x%lX\n"
            PrintMessage(pParams, IDS_UTIL_SID_INVALID, Status);
        } 
        else 
        {
            //IDS_GLOBAL_UNICODE_STRING          "%wZ"
            PrintMessage(pParams, IDS_GLOBAL_UNICODE_STRING, &SidString);
            PrintNewLine(pParams, 1);
            RtlFreeUnicodeString( &SidString );
        }
    }

}



NET_API_STATUS
IsServiceStarted(
    IN LPTSTR pszServiceName
    )

/*++

Routine Description:

    This routine queries the Service Controller to find out if the
    specified service has been started.

Arguments:

    pszServiceName - Supplies the name of the service.

Return Value:

    NO_ERROR: if the specified service has been started
    -1: the service was stopped normally
    Otherwise returns the reason the service isn't running.


--*/
{
    NET_API_STATUS NetStatus;
    SC_HANDLE hScManager;
    SC_HANDLE hService;
    SERVICE_STATUS ServiceStatus;


    if ((hScManager = OpenSCManager(
                          NULL,
                          NULL,
                          SC_MANAGER_CONNECT
                          )) == (SC_HANDLE) NULL) {

        NetStatus = GetLastError();

        DebugMessage2(" IsServiceStarted(): OpenSCManager failed. [%s]\n", NetStatusToString(NetStatus));

        return NetStatus;
    }

    if ((hService = OpenService(
                        hScManager,
                        pszServiceName,
                        SERVICE_QUERY_STATUS
                        )) == (SC_HANDLE) NULL) 
    {

        NetStatus = GetLastError();

        DebugMessage3(" IsServiceStarted(): OpenService '%s' failed. [%s]\n", 
                            pszServiceName, NetStatusToString(NetStatus) );

        (void) CloseServiceHandle(hScManager);

        return NetStatus;
    }

    if (! QueryServiceStatus(
              hService,
              &ServiceStatus
              )) {


        NetStatus = GetLastError();

        DebugMessage3(" IsServiceStarted(): QueryServiceStatus '%s' failed. [%s]\n", 
                        pszServiceName, NetStatusToString(NetStatus) );

        (void) CloseServiceHandle(hScManager);
        (void) CloseServiceHandle(hService);

        return NetStatus;
    }

    (void) CloseServiceHandle(hScManager);
    (void) CloseServiceHandle(hService);

    switch ( ServiceStatus.dwCurrentState ) 
    {
        case SERVICE_RUNNING:
        case SERVICE_CONTINUE_PENDING:
        case SERVICE_PAUSE_PENDING:
        case SERVICE_PAUSED:
            NetStatus = NO_ERROR;
            break;
        case SERVICE_STOPPED:
        case SERVICE_START_PENDING:
        case SERVICE_STOP_PENDING:
            if ( ServiceStatus.dwWin32ExitCode == ERROR_SERVICE_SPECIFIC_ERROR ) 
            {
                NetStatus = ServiceStatus.dwServiceSpecificExitCode;
                if ( NetStatus == NO_ERROR ) 
                {
                    NetStatus = ServiceStatus.dwWin32ExitCode;
                }
            } 
            else 
            {
                NetStatus = ServiceStatus.dwWin32ExitCode;
                if ( NetStatus == NO_ERROR ) 
                {
                    NetStatus = -1;
                }
            }
            break;
        default:
            NetStatus = ERROR_INTERNAL_ERROR;
            break;
    }

    return NetStatus;

} // IsServiceStarted



LPSTR MapTime(DWORD_PTR TimeVal)
//++
//
// Description:
//  Converts IP lease time to more human-sensible string
//
//  ENTRY   TimeVal - DWORD (time_t) time value (number of milliseconds since
//                  virtual year dot)
//
//
//  RETURNS pointer to string
// 
//  ASSUMES 1.  The caller realizes this function returns a pointer to a static
//            buffer, hence calling this function a second time, but before
//            the results from the previous call have been used, will destroy
//            the previous results
//--
{

    struct tm* pTime;
    static char timeBuf[128];
    static char oemTimeBuf[256];

    if (pTime = localtime(&TimeVal)) {

        SYSTEMTIME systemTime;
        char* pTimeBuf = timeBuf;
        int n;

        systemTime.wYear = pTime->tm_year + 1900;
        systemTime.wMonth = pTime->tm_mon + 1;
        systemTime.wDayOfWeek = (WORD)pTime->tm_wday;
        systemTime.wDay = (WORD)pTime->tm_mday;
        systemTime.wHour = (WORD)pTime->tm_hour;
        systemTime.wMinute = (WORD)pTime->tm_min;
        systemTime.wSecond = (WORD)pTime->tm_sec;
        systemTime.wMilliseconds = 0;
        n = GetDateFormat(0, DATE_LONGDATE, &systemTime, NULL, timeBuf, sizeof(timeBuf));
        timeBuf[n - 1] = ' ';
        GetTimeFormat(0, 0, &systemTime, NULL, &timeBuf[n], sizeof(timeBuf) - n);

        //
        // we have to convert the returned ANSI string to the OEM charset
        // 
        //

        if (CharToOem(timeBuf, oemTimeBuf)) {
            return oemTimeBuf;
        }

        return timeBuf;
    }
    return "";
}



//used in DCListTest and TrustTest
NTSTATUS
NettestSamConnect(
                  IN NETDIAG_PARAMS *pParams,
                  IN LPWSTR DcName,
                  OUT PSAM_HANDLE SamServerHandle
    )
/*++

Routine Description:

    Determine if the DomainSid field of the TestDomain matches the DomainSid
    of the domain.

Arguments:

    DcName - Dc to connect to

    SamServerHandle - Returns a Sam server handle

Return Value:

    TRUE: Test suceeded.
    FALSE: Test failed

--*/
{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;
    
    UNICODE_STRING ServerNameString;
    SAM_HANDLE LocalSamHandle = NULL;

    BOOL    fImpersonatingAnonymous = FALSE;
    HANDLE  hCurrentToken;

    //
    // Connect to the SAM server
    //

    RtlInitUnicodeString( &ServerNameString, DcName );

    Status = SamConnect(
                &ServerNameString,
                &LocalSamHandle,
                SAM_SERVER_LOOKUP_DOMAIN,
                NULL);

    //
    // Consider the case where we don't have access to the DC.
    //  We might be logged on locally due to the domain sid being wrong.
    //

    if ( Status == STATUS_ACCESS_DENIED ) {

        //
        // Try impersonating the anonymous token.
        //

        //
        // Check to see if we're already impsonating
        //

        Status = NtOpenThreadToken(
                        NtCurrentThread(),
                        TOKEN_IMPERSONATE,
                        TRUE,       // as self to ensure we never fail
                        &hCurrentToken );

        if ( Status == STATUS_NO_TOKEN ) {
            //
            // We're not already impersonating
            hCurrentToken = NULL;

        } else if ( !NT_SUCCESS( Status) ) {
            PrintGuruMessage("    [WARNING] Cannot NtOpenThreadToken" );
            PrintGuru( NetpNtStatusToApiStatus( Status ), SAM_GURU );
            goto Cleanup;
        }


        //
        // Impersonate the anonymous token
        //
        Status = NtImpersonateAnonymousToken( NtCurrentThread() );

        if ( !NT_SUCCESS( Status)) {
            PrintGuruMessage("    [WARNING] Cannot NtOpenThreadToken" );
            PrintGuru( NetpNtStatusToApiStatus( Status ), SAM_GURU );
            goto Cleanup;
        }

        fImpersonatingAnonymous = TRUE;

        //
        // Try the SamConnect again
        //

        Status = SamConnect(
                    &ServerNameString,
                    &LocalSamHandle,
                    SAM_SERVER_LOOKUP_DOMAIN,
                    NULL);

        if ( Status == STATUS_ACCESS_DENIED ) {
                // One can configure SAM this way so it isn't fatal
                DebugMessage2("    [WARNING] Cannot connect to SAM on '%ws' using a NULL session.", DcName );
            goto Cleanup;
        }
    }


    if ( !NT_SUCCESS(Status)) {
        LocalSamHandle = NULL;
        DebugMessage2("    [FATAL] Cannot connect to SAM on '%ws'.", DcName );
        goto Cleanup;
    }

    //
    // Success
    //


    *SamServerHandle = LocalSamHandle;
    Status = STATUS_SUCCESS;


    //
    // Cleanup locally used resources
    //
Cleanup:
    if ( fImpersonatingAnonymous ) {
        NTSTATUS TempStatus;

        TempStatus = NtSetInformationThread(
                         NtCurrentThread(),
                         ThreadImpersonationToken,
                         &hCurrentToken,
                         sizeof(HANDLE) );

        if (!NT_SUCCESS( TempStatus)) {
            DebugMessage2( "SamConnect: Unexpected error reverting to self: 0x%lx\n",
                     TempStatus );
        }

    }

    return Status;
}




//only used in Kerberos test so far
VOID
sPrintTime(
    LPSTR str,
    LARGE_INTEGER ConvertTime
    )
/*++

Routine Description:

    Print the specified time

Arguments:

    Comment - Comment to print in front of the time

    Time - GMT time to print (Nothing is printed if this is zero)

Return Value:

    None

--*/
{
    //
    // If we've been asked to convert an NT GMT time to ascii,
    //  Do so
    //

    if ( ConvertTime.QuadPart != 0 ) {
        LARGE_INTEGER LocalTime;
        TIME_FIELDS TimeFields;
        NTSTATUS Status;

        Status = RtlSystemTimeToLocalTime( &ConvertTime, &LocalTime );
        if ( !NT_SUCCESS( Status )) {
            sprintf(str, "Can't convert time from GMT to Local time" );
            LocalTime = ConvertTime;
        }

        RtlTimeToTimeFields( &LocalTime, &TimeFields );

        sprintf(str, "%ld/%ld/%ld %ld:%2.2ld:%2.2ld",
                TimeFields.Month,
                TimeFields.Day,
                TimeFields.Year,
                TimeFields.Hour,
                TimeFields.Minute,
                TimeFields.Second );
    }
}


/*!--------------------------------------------------------------------------
    GetComputerNameInfo
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT GetComputerNameInfo(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults)
{
    DWORD   cchSize;
    WCHAR   swzNetBiosName[MAX_COMPUTERNAME_LENGTH+1];

    cchSize = DimensionOf(swzNetBiosName);

    if ( !GetComputerNameW( swzNetBiosName, &cchSize ) )
    {
        PrintMessage(pParams, IDS_GLOBAL_NoComputerName);
        return HResultFromWin32(GetLastError());
    }

    lstrcpynW(pResults->Global.swzNetBiosName, swzNetBiosName,
              MAX_COMPUTERNAME_LENGTH+1);

    return hrOK;
}


/*!--------------------------------------------------------------------------
    GetDNSInfo
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT GetDNSInfo(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults)
{
    UINT    cchSize;
    TCHAR   szDnsName[DNS_MAX_NAME_LENGTH+1];
    HRESULT hr = hrOK;
    //
    // Get the DNS host name.
    //

    memset(szDnsName,0,sizeof(TCHAR)*(DNS_MAX_NAME_LENGTH+1));
    cchSize = DimensionOf(szDnsName);


    if (!GetComputerNameExA( ComputerNameDnsFullyQualified,
                            szDnsName,
                            &cchSize))
    {
        PrintMessage(pParams, IDS_GLOBAL_ERR_NoDnsName);
    }
    else
    {
        lstrcpyn(pResults->Global.szDnsHostName, szDnsName, DNS_MAX_NAME_LENGTH+1);
        // Look for the first '.' in the name
        pResults->Global.pszDnsDomainName = strchr(pResults->Global.szDnsHostName,
                                                   _T('.'));
    

        if (pResults->Global.pszDnsDomainName != NULL)
        {
            pResults->Global.pszDnsDomainName++;
        }
    }
    return hr;
}


/*!--------------------------------------------------------------------------
    GetNetBTParameters
        -
    Author: KennT
 ---------------------------------------------------------------------------*/
HRESULT GetNetBTParameters(IN NETDIAG_PARAMS *pParams,
                           IN OUT NETDIAG_RESULT *pResults)
{
    LONG    err;
    HRESULT hr = hrOK;
    HKEY hkeyServices;
    HKEY hkeyNetBT;
    DWORD dwLMHostsEnabled;
    DWORD dwDnsForWINS;
    DWORD dwType;
    DWORD dwLength;

    if (!pParams->fVerbose)
        return hrOK;

    // set defaults
    pResults->Global.dwLMHostsEnabled = E_FAIL;
    pResults->Global.dwDnsForWINS = E_FAIL;
    
    err = RegOpenKey(HKEY_LOCAL_MACHINE,
                     _T("SYSTEM\\CurrentControlSet\\Services"),
                     &hkeyServices
                    );
    if (err != ERROR_SUCCESS)
    {
        pResults->Global.dwLMHostsEnabled = HResultFromWin32(err);
        pResults->Global.dwDnsForWINS = HResultFromWin32(err);

        PrintDebugSz(pParams, 0, _T("Services opening failed\n"));
    }
    else
    {           
        err = RegOpenKey(hkeyServices,
                         _T("NetBT\\Parameters"),
                         &hkeyNetBT
                        );
        if (err != ERROR_SUCCESS)
        {
            pResults->Global.dwLMHostsEnabled = HResultFromWin32(err);
            pResults->Global.dwDnsForWINS = HResultFromWin32(err);

            PrintDebugSz(pParams, 0, _T("Parameters opening failed\n"));
        }
        else
        {
            dwLength = sizeof(DWORD);
            err = RegQueryValueEx(hkeyNetBT,
                                  _T("EnableLMHOSTS"),
                                  NULL,
                                  &dwType,
                                  (LPBYTE)&dwLMHostsEnabled,
                                  &dwLength
                                 );
            if (err != ERROR_SUCCESS)
            {
                pResults->Global.dwLMHostsEnabled = HResultFromWin32(err);
                DebugMessage("Quering EnableLMHOSTS failed !\n");
            }
            else
            {
                pResults->Global.dwLMHostsEnabled = dwLMHostsEnabled;
            }
            
            //
            //  In NT 5.0 - Dns for wins resolution is enabled by
            //  default and the "EnableDNS" key will not be found.
            //  If it is not found, we will assume its enabled.
            //  In NT 4.0 - the key will be there and its value
            //  should let us know whether the option is enabled
            //  or disabled
            //
            
            dwLength = sizeof(DWORD);
            err = RegQueryValueEx(hkeyNetBT,
                                  "EnableDNS",
                                  NULL,
                                  &dwType,
                                  (LPBYTE)&dwDnsForWINS,
                                  &dwLength
                                 );
            
            if (err == ERROR_SUCCESS)
            {
                pResults->Global.dwDnsForWINS = dwDnsForWINS;
            }
            else
            {
                pResults->Global.dwDnsForWINS = TRUE;
            }
                        
        }
    }

    return hrOK;
}


ULONG inet_addrW(LPCWSTR pswz)
{
    ULONG   ulReturn;
    CHAR *  psaz;

    psaz = StrDupAFromW(pswz);
    if (psaz == NULL)
        return 0;

    ulReturn = inet_addrA(psaz);
    Free(psaz);
    
    return ulReturn;
}




LPTSTR
NetStatusToString(
    NET_API_STATUS NetStatus
    )
/*++

Routine Description:

    Conver a net status code or a Windows error code to the description string.
    NOTE: The string is garuanteed to be valid only right after NetStatusToString is called. 

Arguments:

    NetStatus - The net status code to print.

Return Value:

    The status description string

--*/
{
    static TCHAR   s_szSymbolicName[MAX_NET_STATUS_LENGTH + 1];
    ZeroMemory(s_szSymbolicName, sizeof(s_szSymbolicName));

    switch (NetStatus) 
    {
    case NERR_Success:
        _tcscpy( s_szSymbolicName, _T("NERR_Success") );
        break;

    case NERR_DCNotFound:
        _tcscpy( s_szSymbolicName, _T("NERR_DCNotFound") );
        break;

    case NERR_UserNotFound:
        _tcscpy( s_szSymbolicName, _T("NERR_UserNotFound") );
        break;

    case NERR_NetNotStarted:
        _tcscpy( s_szSymbolicName, _T("NERR_NetNotStarted") );
        break;

    case NERR_WkstaNotStarted:
        _tcscpy( s_szSymbolicName, _T("NERR_WkstaNotStarted") );
        break;

    case NERR_ServerNotStarted:
        _tcscpy( s_szSymbolicName, _T("NERR_ServerNotStarted") );
        break;

    case NERR_BrowserNotStarted:
        _tcscpy( s_szSymbolicName, _T("NERR_BrowserNotStarted") );
        break;

    case NERR_ServiceNotInstalled:
        _tcscpy( s_szSymbolicName, _T("NERR_ServiceNotInstalled") );
        break;

    case NERR_BadTransactConfig:
        _tcscpy( s_szSymbolicName, _T("NERR_BadTransactConfig") );
        break;

    default:
        {
            LPSTR paszName = FindSymbolicNameForStatus( NetStatus );
            USES_CONVERSION;
            
            
            if (NULL == paszName)
            {
                _stprintf(s_szSymbolicName, _T("%X"), (DWORD)NetStatus);
            }
            else
            {
                _tcsncpy( s_szSymbolicName, A2T(paszName), MAX_NET_STATUS_LENGTH);
            }
        }
        break;

    }

    return s_szSymbolicName;
}

//Load contact info from the [NetDiagContact] section of the ini file.
//  pszTestName     [in]    short name of the test, which is also the key name in the ini file
//  pszContactInfo  [out]   the string of contact info. It will be empty string of the key cannot be found.
//  cChSize         [in]    the buffer size, in characters, of pszContactInfo
//
//  return: the number of characters copied to the buffer.
DWORD LoadContact(LPCTSTR pszTestName, LPTSTR pszContactInfo, DWORD cChSize)
{
    return GetPrivateProfileString(c_szSectionName,
                                pszTestName,
                                _T(""),
                                pszContactInfo,
                                cChSize,
                                c_szFileName);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\netcard.h ===
/*--

Copyright (C) Microsoft Corporation, 1999 - 1999 

Module Name:

     netcard.h

Abstract:

     Contains definitions, globals and function prototypes used by "ndis" test.

Author:
   
     4-Aug-1998 (t-rajkup)

Environment:

     User mode only.
     
Revision History:
      
     None.
--*/

#ifndef HEADER__NETCARD
#define HEADER__NETCARD

/*==========================< ndis test - includes >=======================*/
#include <wmium.h>
#include <initguid.h>
#include <ndisguid.h>
#define  WIRELESS_WAN
#include <ntddndis.h>
#include <qos.h>

/*==========================< ndis test - functions >=====================*/

ULONG
ShowGuidData(
   IN ULONG       argc,
   IN ULONG       ulOidCode,
   IN PUCHAR      pucNamePtr,
   IN PUCHAR      pucDataPtr,
   IN ULONG       ulDataSize
   );

typedef
ULONG
(*WMI_OPEN)(
   GUID        *pGuid,
   ULONG       DesiredAccess,
   WMIHANDLE   *DataBlockHandle
   );


typedef
ULONG
(*WMI_CLOSE)(
   WMIHANDLE   DataBlockHandle
   );

typedef
ULONG
(*WMI_QUERYALL)(
   WMIHANDLE   DataBlockHandle,
   PULONG      pulBufferSize,
   PVOID       pvBuffer
   );


typedef
ULONG
(*WMI_QUERYSINGLE)(
   WMIHANDLE   DataBlockHandle,
   LPCSTR      InstanceName,
   PULONG      pulBufferSize,
   PVOID       pvBuffer
   );

typedef
ULONG
(*WMI_NOTIFY)(
   LPGUID      pGuid,
   BOOLEAN     Enable,
   PVOID       DeliveryInfo,
   ULONG       DeliveryContext,
   ULONG       Flags
   );

ULONG
NdtWmiOpenBlock(
   IN GUID           *pGuid,
   IN OUT WMIHANDLE  *pWmiHandle
   );

BOOLEAN
fShowQueryInfoResults(
    PUCHAR        pucBuffer,
    ULONG         ulBytesReturned,
    NDIS_OID      ulOID,
    ULONG         argc
    );

VOID
LoadWmiLibrary(
    HINSTANCE   hWmiLib
   );

ULONG
NdtWmiQueryAllData(
   IN WMIHANDLE      WmiHandle,
   IN OUT PULONG     pulBufferSize,
   IN OUT PVOID      pvBuffer,
   IN BOOLEAN        fCheckShort
   );


VOID
_CRTAPI1
HapiPrint(PCHAR   Format,
          ...  );


VOID
_CRTAPI1
HapiPrintEx(PCHAR    Format,
            va_list  args);


VOID
ShowIrdaOids(ULONG   ulOid,
             PULONG  pulDataPtr,
             ULONG   ulBytesReturned,
             PULONG  pulTypeNeeded,
             PULONG  pulArraySize
            );


VOID
ShowWirelessWanOids(ULONG  ulOid,
                    PULONG pulDataPtr,
                    ULONG  ulBytesReturned,
                    PULONG pulTypeNeeded,
                    PULONG pulArraySize
                   );

VOID
ShowAtmOids(ULONG    ulOid,
            PULONG   pulDataPtr,
            ULONG    ulBytesReturned,
            PULONG   pulTypeNeeded,
            PULONG   pulArraySize
            );

VOID
ShowArcnetOids(ULONG    ulOid,
               PULONG   pulDataPtr,
               PULONG   pulTypeNeeded
              );


VOID
ShowFddiOids(ULONG   ulOid,
             PULONG  pulDataPtr,
             ULONG   ulBytesReturned,
             PULONG  pulTypeNeeded,
             PULONG  pulArraySize
            );

VOID
ShowTokenRingOids(ULONG    ulOid,
                  PULONG   pulDataPtr,
                  PULONG   pulTypeNeeded
                  );

VOID
ShowEthernetOids(ULONG  ulOid,
                 PULONG pulDataPtr,
                 ULONG  ulBytesReturned,
                 PULONG pulTypeNeeded,
                 PULONG pulArraySize
                );

VOID
ShowPnpPowerOids(ULONG     ulOid,
                 PULONG    pulDataPtr,
                 ULONG     ulBytesReturned,
                 PULONG    pulTypeNeeded,
                 PULONG    pulArraySize
                 );

VOID
ShowGeneralOids(ULONG   ulOid,
                PULONG  pulDataPtr,
                ULONG   ulBytesReturned,
                PULONG  pulTypeNeeded,
                PULONG  pulArraySize
                );

VOID
ShowCoGeneralOids(ULONG   ulOid,
                  PULONG  pulDataPtr,
                  ULONG   ulBytesReturned,
                  PULONG  pulTypeNeeded,
                  PULONG  pulArraySize
                  );

VOID
NdtPrintOidName(
   ULONG   ulOidCode
  );

static
VOID
ShowHardwareStatus(
   IN ULONG   ulStatus
   );

static
VOID
ShowMediaList(
   IN PULONG   pulMedia,
   IN ULONG    ulNumMedia
   );


static
VOID
ShowSupportedGuids(
   IN PVOID    pvDataPtr,
   IN ULONG    ulTotalBytes
   );

static
VOID
ShowTimeCaps(
   IN PVOID    pvDataPtr
   );

PVOID
GetEmbeddedData(
   PNDIS_VAR_DATA_DESC pNdisVarDataDesc
  );

static
VOID
FixMediaList(
   IN OUT PULONG  pulMedia,
   IN     ULONG   ulNumMedia
   );

static
VOID
EthPrintAddress(
   PUCHAR  pucAddress
   );

static
VOID
TokenRingShowAddress(
   IN PUCHAR   pucAddress,
   IN ULONG    ulLength
   );

static
VOID
FddiShowAddress(
   IN PUCHAR   pucAddress,
   IN ULONG    ulLength
   );

static
VOID
FddiShowRawData(
   IN PUCHAR   pucBuffer,
   IN ULONG    ulLength
   );


static
VOID
ShowWWHeaderFormat(
   ULONG
   ulFormat
   );

VOID
PrintWNodeHeader(
    PWNODE_HEADER   pWnodeHeader
   );

VOID
NdtPrintStatus(
   NDIS_STATUS lGeneralStatus
  );

PUCHAR
OffsetToPtr(
     PVOID pvBase,
     ULONG ulOffset
  );

ULONG
NdtWmiQuerySingleInstance(
     WMIHANDLE WmiHandle,
     PCHAR     strDeviceName,
     PULONG    pulBufferSize,
     PVOID     pvBuffer,
     BOOLEAN   fCheckShort
  );

VOID
GetMediaList(
     PULONG    pulMedia,
     ULONG     ulNumMedia
   );

int
GetNumOids(
   PNDIS_MEDIUM medium,
   int  index
   );

int
GetBaseAddr(
   PNDIS_MEDIUM medium,
   int  index
   );

typedef struct _ATM_VC_RATES_SUPPORTED
{
        ULONG                                           MinCellRate;
        ULONG                                           MaxCellRate;
} ATM_VC_RATES_SUPPORTED, *PATM_VC_RATES_SUPPORTED;

//
// ATM Service Category
//
#define ATM_SERVICE_CATEGORY_CBR        1       // Constant Bit Rate
#define ATM_SERVICE_CATEGORY_VBR        2       // Variable Bit Rate
#define ATM_SERVICE_CATEGORY_UBR        4       // Unspecified Bit Rate
#define ATM_SERVICE_CATEGORY_ABR        8       // Available Bit Rate

//
// AAL types that the miniport supports
//
#define AAL_TYPE_AAL0                   1
#define AAL_TYPE_AAL1                   2
#define AAL_TYPE_AAL34                  4
#define AAL_TYPE_AAL5                   8

typedef struct _ATM_VPIVCI
{
        ULONG                                           Vpi;
        ULONG                                           Vci;
} ATM_VPIVCI, *PATM_VPIVCI;

struct _CONSTANT_ENTRY
{
   LONG     lValue;        // integer value
   PCHAR    strName;       // constant name
};
typedef struct _CONSTANT_ENTRY *PCONSTANT_ENTRY;
typedef struct _CONSTANT_ENTRY CONSTANT_ENTRY;

/*==========================< ndis test - globals >=======================*/

#define strNtDeviceHeader  "\\DEVICE\\"

//
// Globals used in infering problems
//

BOOL     NdisFlag;
ULONG    ulFirstErrorCount;
ULONG    ulSecondErrorCount;


#define NDIS_SLEEP_TIME 2000 // 2 second
#define NDIS_MAX_ERROR_COUNT 1  // max no of error counts that can be seen between 2 successice error count readings
#define NDIS_MAX_RCV_ERROR  10000 // max no of rcv errors
#define NDIS_MAX_TX_ERROR   10000 // max no of xmit errors


#define ulNDIS_VERSION_40              40
#define ulNDIS_VERSION_50              50

//
// constants for operating system
//
#define ulINVALID_OS          0x00000000
#define ulWINDOWS_95          0x00000001
#define ulWINDOWS_NT          0x00000002

//
// hibernate/standby/wake-related constants
//
#define ulHIBERNATE     1
#define ulSTANDBY       2
#define ulWAKEUPTIMER   4

#define ulTEST_SUCCESSFUL  0x00
#define ulTEST_WARNED      0x01
#define ulTEST_FAILED     0x02
#define ulTEST_BLOCKED     0x03

//
// media type definitions for use with scripts
//


#define ulMEDIUM_ETHERNET     0x01
#define ulMEDIUM_TOKENRING    0x02
#define ulMEDIUM_FDDI         0x03
#define ulMEDIUM_ARCNET       0x04
#define ulMEDIUM_WIRELESSWAN  0x05
#define ulMEDIUM_IRDA         0x06
#define ulMEDIUM_ATM          0x07
#define ulMEDIUM_NDISWAN      0x08


// packettype
#define ulSTRESS_FIXEDSIZE    0x00000000
#define ulSTRESS_RANDOMSIZE   0x00000001
#define ulSTRESS_CYCLICAL     0x00000002
#define ulSTRESS_SMALLSIZE    0x00000003

// packet makeup
#define ulSTRESS_RAND         0x00000000
#define ulSTRESS_SMALL        0x00000010
#define ulSTRESS_ZEROS        0x00000020
#define ulSTRESS_ONES         0x00000030

// response type
#define ulSTRESS_FULLRESP     0x00000000
#define ulSTRESS_NORESP       0x00000100
#define ulSTRESS_ACK          0x00000200
#define ulSTRESS_ACK10        0x00000300


// windowing (speed control)
#define ulSTRESS_WINDOW_ON    0x00000000
#define ulSTRESS_WINDOW_OFF   0x00001000

//
// verify received packets, or just count them
// (or'ed in with main options)
//

#define ulPERFORM_VERIFYRECEIVES  0x00000008
#define ulPERFORM_INDICATE_RCV    0x00000000

//
// main performance test options
//

#define ulPERFORM_SENDONLY       0x00000000
#define ulPERFORM_SEND           0x00000001
#define ulPERFORM_BOTH           0x00000002
#define ulPERFORM_RECEIVE        0x00000003
#define ulPERFORM_MODEMASK       0x00000003

// receive-type options
// valid for both Receive and ReceivePacket
//

//
// DEFAULT
// PR -- uses lookahead if whole packet, else transfer data
// PRP -- uses packet from ReceivePacket if small (<= 256), else queues packet for DPC
//

#define ulRECEIVE_DEFAULT              0x00000000

//
// NOCOPY
// PR -- use just lookahead, even if NOT whole packet.  Used to check lookahead
// PRP -- use from ReceivePacket no matter what the size
//

#define ulRECEIVE_NOCOPY               0x00000001

//
// TRANSFER
//   PR  -- call NdisTransferData from Receive handler
//   PRP -- call NdisTransferData from ReceivePacket Handler
//

#define ulRECEIVE_TRANSFER             0x00000002

//
// PARTIAL_TRANSFER
//   same as transfer EXCEPT copies random length before transfer
//

#define ulRECEIVE_PARTIAL_TRANSFER     0x00000003
#define ulMAX_NDIS30_RECEIVE_OPTION    0x00000003

//
// following options just apply to Ndis40 (ReceivePacket handler)
//

//
// IGNORE -- used to detect what path is being used..
//    PNP -- ignore all packets
//
#define ulRECEIVE_PACKETIGNORE         0x00000004

//
//   do local copy of packet, rest of work done in DPC
//
#define ulRECEIVE_LOCCOPY              0x00000005

//
// PRP -- queues all packets for handling in DPC
//

#define ulRECEIVE_QUEUE                0x00000006


//
// double queue packet
//   PRP -- packet queued twice (on main queue, and on secondary queue where
//          all that is done with it in DPC is remove it)
//
#define ulRECEIVE_DOUBLE_QUEUE         0x00000007
//
// triple queue packet
//
#define ulRECEIVE_TRIPLE_QUEUE         0x00000008
#define ulMAX_NDIS40_RECEIVE_OPTION    0x00000008

//
// This can be ORed with any of the following.  Caused any extra
// receives to be thrown away.  Allows tests to be run on corp net
//
#define ulRECEIVE_ALLOW_BUSY_NET       0x80000000


//
// This value is passed from the script to run the particular type of test.
//
//  Type of Priority test
//
#define ulPRIORITY_TYPE_802_3          0x0001
#define ulPRIORITY_TYPE_802_1P         0x0002

//  Send Type
#define ulPRIORITY_SEND                0x0001
#define ulPRIORITY_SEND_PACKETS        0x0002


#define NDIS_STATUS_SUCCESS                  ((NDIS_STATUS)STATUS_SUCCESS)
#define NDIS_STATUS_PENDING                  ((NDIS_STATUS)STATUS_PENDING)
#define NDIS_STATUS_NOT_RECOGNIZED           ((NDIS_STATUS)0x00010001L)
#define NDIS_STATUS_NOT_COPIED               ((NDIS_STATUS)0x00010002L)
#define NDIS_STATUS_NOT_ACCEPTED             ((NDIS_STATUS)0x00010003L)

#define NDIS_STATUS_CALL_ACTIVE              ((NDIS_STATUS)0x00010007L)
#define NDIS_STATUS_ONLINE                   ((NDIS_STATUS)0x40010003L)
#define NDIS_STATUS_RESET_START              ((NDIS_STATUS)0x40010004L)
#define NDIS_STATUS_RESET_END                ((NDIS_STATUS)0x40010005L)
#define NDIS_STATUS_RING_STATUS              ((NDIS_STATUS)0x40010006L)


#define NDIS_STATUS_CLOSED                   ((NDIS_STATUS)0x40010007L)
#define NDIS_STATUS_WAN_LINE_UP              ((NDIS_STATUS)0x40010008L)
#define NDIS_STATUS_WAN_LINE_DOWN            ((NDIS_STATUS)0x40010009L)
#define NDIS_STATUS_WAN_FRAGMENT             ((NDIS_STATUS)0x4001000AL)
#define NDIS_STATUS_MEDIA_CONNECT            ((NDIS_STATUS)0x4001000BL)

#define NDIS_STATUS_MEDIA_DISCONNECT         ((NDIS_STATUS)0x4001000CL)
#define NDIS_STATUS_HARDWARE_LINE_UP         ((NDIS_STATUS)0x4001000DL)
#define NDIS_STATUS_HARDWARE_LINE_DOWN       ((NDIS_STATUS)0x4001000EL)
#define NDIS_STATUS_INTERFACE_UP             ((NDIS_STATUS)0x4001000FL)
#define NDIS_STATUS_INTERFACE_DOWN           ((NDIS_STATUS)0x40010010L)

#define NDIS_STATUS_MEDIA_BUSY               ((NDIS_STATUS)0x40010011L)
#define NDIS_STATUS_MEDIA_SPECIFIC_INDICATION ((NDIS_STATUS)0x40010012L)
#define NDIS_STATUS_WW_INDICATION            NDIS_STATUS_MEDIA_SPECIFIC_INDICATION
#define NDIS_STATUS_LINK_SPEED_CHANGE        ((NDIS_STATUS)0x40010013L)
#define NDIS_STATUS_NOT_RESETTABLE           ((NDIS_STATUS)0x80010001L)
#define NDIS_STATUS_SOFT_ERRORS              ((NDIS_STATUS)0x80010003L)
#define NDIS_STATUS_HARD_ERRORS              ((NDIS_STATUS)0x80010004L)
#define NDIS_STATUS_BUFFER_OVERFLOW          ((NDIS_STATUS)STATUS_BUFFER_OVERFLOW)

#define NDIS_STATUS_FAILURE                  ((NDIS_STATUS)STATUS_UNSUCCESSFUL)
#define NDIS_STATUS_RESOURCES                ((NDIS_STATUS)STATUS_INSUFFICIENT_RESOURCES)
#define NDIS_STATUS_CLOSING                  ((NDIS_STATUS)0xC0010002L)
#define NDIS_STATUS_BAD_VERSION              ((NDIS_STATUS)0xC0010004L)
#define NDIS_STATUS_BAD_CHARACTERISTICS      ((NDIS_STATUS)0xC0010005L)

#define NDIS_STATUS_ADAPTER_NOT_FOUND        ((NDIS_STATUS)0xC0010006L)
#define NDIS_STATUS_OPEN_FAILED              ((NDIS_STATUS)0xC0010007L)
#define NDIS_STATUS_DEVICE_FAILED            ((NDIS_STATUS)0xC0010008L)
#define NDIS_STATUS_MULTICAST_FULL           ((NDIS_STATUS)0xC0010009L)
#define NDIS_STATUS_MULTICAST_EXISTS         ((NDIS_STATUS)0xC001000AL)

#define NDIS_STATUS_MULTICAST_NOT_FOUND      ((NDIS_STATUS)0xC001000BL)
#define NDIS_STATUS_REQUEST_ABORTED          ((NDIS_STATUS)0xC001000CL)
#define NDIS_STATUS_RESET_IN_PROGRESS        ((NDIS_STATUS)0xC001000DL)
#define NDIS_STATUS_CLOSING_INDICATING       ((NDIS_STATUS)0xC001000EL)
#define NDIS_STATUS_NOT_SUPPORTED            ((NDIS_STATUS)STATUS_NOT_SUPPORTED)


#define NDIS_STATUS_INVALID_PACKET           ((NDIS_STATUS)0xC001000FL)
#define NDIS_STATUS_OPEN_LIST_FULL           ((NDIS_STATUS)0xC0010010L)
#define NDIS_STATUS_ADAPTER_NOT_READY        ((NDIS_STATUS)0xC0010011L)
#define NDIS_STATUS_ADAPTER_NOT_OPEN         ((NDIS_STATUS)0xC0010012L)
#define NDIS_STATUS_NOT_INDICATING           ((NDIS_STATUS)0xC0010013L)

#define NDIS_STATUS_INVALID_LENGTH           ((NDIS_STATUS)0xC0010014L)
#define NDIS_STATUS_INVALID_DATA             ((NDIS_STATUS)0xC0010015L)
#define NDIS_STATUS_BUFFER_TOO_SHORT         ((NDIS_STATUS)0xC0010016L)
#define NDIS_STATUS_INVALID_OID              ((NDIS_STATUS)0xC0010017L)
#define NDIS_STATUS_ADAPTER_REMOVED          ((NDIS_STATUS)0xC0010018L)


#define NDIS_STATUS_UNSUPPORTED_MEDIA        ((NDIS_STATUS)0xC0010019L)
#define NDIS_STATUS_GROUP_ADDRESS_IN_USE     ((NDIS_STATUS)0xC001001AL)
#define NDIS_STATUS_FILE_NOT_FOUND           ((NDIS_STATUS)0xC001001BL)
#define NDIS_STATUS_ERROR_READING_FILE       ((NDIS_STATUS)0xC001001CL)
#define NDIS_STATUS_ALREADY_MAPPED           ((NDIS_STATUS)0xC001001DL)

#define NDIS_STATUS_RESOURCE_CONFLICT        ((NDIS_STATUS)0xC001001EL)
#define NDIS_STATUS_NO_CABLE                 ((NDIS_STATUS)0xC001001FL)
#define NDIS_STATUS_INVALID_SAP              ((NDIS_STATUS)0xC0010020L)
#define NDIS_STATUS_SAP_IN_USE               ((NDIS_STATUS)0xC0010021L)
#define NDIS_STATUS_INVALID_ADDRESS          ((NDIS_STATUS)0xC0010022L)


#define NDIS_STATUS_VC_NOT_ACTIVATED         ((NDIS_STATUS)0xC0010023L)
#define NDIS_STATUS_DEST_OUT_OF_ORDER        ((NDIS_STATUS)0xC0010024L) // cause 27
#define NDIS_STATUS_VC_NOT_AVAILABLE         ((NDIS_STATUS)0xC0010025L) // cause 35,45
#define NDIS_STATUS_CELLRATE_NOT_AVAILABLE   ((NDIS_STATUS)0xC0010026L) // cause 37
#define NDIS_STATUS_INCOMPATABLE_QOS         ((NDIS_STATUS)0xC0010027L) // cause 49

#define NDIS_STATUS_AAL_PARAMS_UNSUPPORTED   ((NDIS_STATUS)0xC0010028L) // cause 93
#define NDIS_STATUS_NO_ROUTE_TO_DESTINATION  ((NDIS_STATUS)0xC0010029L) // cause 3
#define NDIS_STATUS_TOKEN_RING_OPEN_ERROR    ((NDIS_STATUS)0xC0011000L)


CONSTANT_ENTRY NdisTestConstantTable[] =
{
   //
   //  OID definitions (from ntddndis.h)
   //
   OID_GEN_SUPPORTED_LIST              ,  "OID_GEN_SUPPORTED_LIST"            ,     // 1
   OID_GEN_HARDWARE_STATUS             ,  "OID_GEN_HARDWARE_STATUS"           ,
   OID_GEN_MEDIA_SUPPORTED             ,  "OID_GEN_MEDIA_SUPPORTED"           ,
   OID_GEN_MEDIA_IN_USE                ,  "OID_GEN_MEDIA_IN_USE"              ,     // 4
   OID_GEN_MAXIMUM_LOOKAHEAD           ,  "OID_GEN_MAXIMUM_LOOKAHEAD"         ,
   OID_GEN_MAXIMUM_FRAME_SIZE          ,  "OID_GEN_MAXIMUM_FRAME_SIZE"        ,
   OID_GEN_LINK_SPEED                  ,  "OID_GEN_LINK_SPEED"                ,
   OID_GEN_TRANSMIT_BUFFER_SPACE       ,  "OID_GEN_TRANSMIT_BUFFER_SPACE"     ,     // 8
   OID_GEN_RECEIVE_BUFFER_SPACE        ,  "OID_GEN_RECEIVE_BUFFER_SPACE"      ,
   OID_GEN_TRANSMIT_BLOCK_SIZE         ,  "OID_GEN_TRANSMIT_BLOCK_SIZE"       ,
   OID_GEN_RECEIVE_BLOCK_SIZE          ,  "OID_GEN_RECEIVE_BLOCK_SIZE"        ,
   OID_GEN_VENDOR_ID                   ,  "OID_GEN_VENDOR_ID"                 ,     // 12
   OID_GEN_VENDOR_DESCRIPTION          ,  "OID_GEN_VENDOR_DESCRIPTION"        ,
   OID_GEN_CURRENT_PACKET_FILTER       ,  "OID_GEN_CURRENT_PACKET_FILTER"     ,
   OID_GEN_CURRENT_LOOKAHEAD           ,  "OID_GEN_CURRENT_LOOKAHEAD"         ,
   OID_GEN_DRIVER_VERSION              ,  "OID_GEN_DRIVER_VERSION"            ,     // 16
   OID_GEN_MAXIMUM_TOTAL_SIZE          ,  "OID_GEN_MAXIMUM_TOTAL_SIZE"        ,
   OID_GEN_PROTOCOL_OPTIONS            ,  "OID_GEN_PROTOCOL_OPTIONS"          ,
   OID_GEN_MAC_OPTIONS                 ,  "OID_GEN_MAC_OPTIONS"               ,
   OID_GEN_MEDIA_CONNECT_STATUS        ,  "OID_GEN_MEDIA_CONNECT_STATUS"      ,     // 20
   OID_GEN_MAXIMUM_SEND_PACKETS        ,  "OID_GEN_MAXIMUM_SEND_PACKETS"      ,
   OID_GEN_VENDOR_DRIVER_VERSION       ,  "OID_GEN_VENDOR_DRIVER_VERSION"     ,
   OID_GEN_SUPPORTED_GUIDS             ,  "OID_GEN_SUPPORTED_GUIDS"           ,
   OID_GEN_NETWORK_LAYER_ADDRESSES     ,  "OID_GEN_NETWORK_LAYER_ADDRESSES"   ,     // 24

   OID_GEN_XMIT_OK                     ,  "OID_GEN_XMIT_OK"                   ,
   OID_GEN_RCV_OK                      ,  "OID_GEN_RCV_OK"                    ,
   OID_GEN_XMIT_ERROR                  ,  "OID_GEN_XMIT_ERROR"                ,
   OID_GEN_RCV_ERROR                   ,  "OID_GEN_RCV_ERROR"                 ,     // 28
   OID_GEN_RCV_NO_BUFFER               ,  "OID_GEN_RCV_NO_BUFFER"             ,

   OID_GEN_DIRECTED_BYTES_XMIT         ,  "OID_GEN_DIRECTED_BYTES_XMIT"       ,
   OID_GEN_DIRECTED_FRAMES_XMIT        ,  "OID_GEN_DIRECTED_FRAMES_XMIT"      ,
   OID_GEN_MULTICAST_BYTES_XMIT        ,  "OID_GEN_MULTICAST_BYTES_XMIT"      ,     // 32
   OID_GEN_MULTICAST_FRAMES_XMIT       ,  "OID_GEN_MULTICAST_FRAMES_XMIT"     ,
   OID_GEN_BROADCAST_BYTES_XMIT        ,  "OID_GEN_BROADCAST_BYTES_XMIT"      ,
   OID_GEN_BROADCAST_FRAMES_XMIT       ,  "OID_GEN_BROADCAST_FRAMES_XMIT"     ,
   OID_GEN_DIRECTED_BYTES_RCV          ,  "OID_GEN_DIRECTED_BYTES_RCV"        ,     // 36
   OID_GEN_DIRECTED_FRAMES_RCV         ,  "OID_GEN_DIRECTED_FRAMES_RCV"       ,
   OID_GEN_MULTICAST_BYTES_RCV         ,  "OID_GEN_MULTICAST_BYTES_RCV"       ,
   OID_GEN_MULTICAST_FRAMES_RCV        ,  "OID_GEN_MULTICAST_FRAMES_RCV"      ,
   OID_GEN_BROADCAST_BYTES_RCV         ,  "OID_GEN_BROADCAST_BYTES_RCV"       ,     // 40
   OID_GEN_BROADCAST_FRAMES_RCV        ,  "OID_GEN_BROADCAST_FRAMES_RCV"      ,
   OID_GEN_RCV_CRC_ERROR               ,  "OID_GEN_RCV_CRC_ERROR"             ,
   OID_GEN_TRANSMIT_QUEUE_LENGTH       ,  "OID_GEN_TRANSMIT_QUEUE_LENGTH"     ,
   OID_GEN_GET_TIME_CAPS               ,  "OID_GEN_GET_TIME_CAPS"             ,     // 44
   OID_GEN_GET_NETCARD_TIME            ,  "OID_GEN_GET_NETCARD_TIME"          ,     // 45

  //
  // 802.3 Objects
  //
  OID_802_3_PERMANENT_ADDRESS         ,  "OID_802_3_PERMANENT_ADDRESS"       ,     // 1
  OID_802_3_CURRENT_ADDRESS           ,  "OID_802_3_CURRENT_ADDRESS"         ,
  OID_802_3_MULTICAST_LIST            ,  "OID_802_3_MULTICAST_LIST"          ,
  OID_802_3_MAXIMUM_LIST_SIZE         ,  "OID_802_3_MAXIMUM_LIST_SIZE"       ,     // 4
  OID_802_3_MAC_OPTIONS               ,  "OID_802_3_MAC_OPTIONS"             ,

  OID_802_3_RCV_ERROR_ALIGNMENT       ,  "OID_802_3_RCV_ERROR_ALIGNMENT"     ,
  OID_802_3_XMIT_ONE_COLLISION        ,  "OID_802_3_XMIT_ONE_COLLISION"      ,
  OID_802_3_XMIT_MORE_COLLISIONS      ,  "OID_802_3_XMIT_MORE_COLLISIONS"    ,     // 8

  OID_802_3_XMIT_DEFERRED             ,  "OID_802_3_XMIT_DEFERRED"           ,
  OID_802_3_XMIT_MAX_COLLISIONS       ,  "OID_802_3_XMIT_MAX_COLLISIONS"     ,
  OID_802_3_RCV_OVERRUN               ,  "OID_802_3_RCV_OVERRUN"             ,
  OID_802_3_XMIT_UNDERRUN             ,  "OID_802_3_XMIT_UNDERRUN"           ,     // 12
  OID_802_3_XMIT_HEARTBEAT_FAILURE    ,  "OID_802_3_XMIT_HEARTBEAT_FAILURE"  ,
  OID_802_3_XMIT_TIMES_CRS_LOST       ,  "OID_802_3_XMIT_TIMES_CRS_LOST"     ,
  OID_802_3_XMIT_LATE_COLLISIONS      ,  "OID_802_3_XMIT_LATE_COLLISIONS"    ,     // 15

  //
  // 802.5 Objects
  //
  OID_802_5_PERMANENT_ADDRESS         ,  "OID_802_5_PERMANENT_ADDRESS"       ,     // 1
  OID_802_5_CURRENT_ADDRESS           ,  "OID_802_5_CURRENT_ADDRESS"         ,
  OID_802_5_CURRENT_FUNCTIONAL        ,  "OID_802_5_CURRENT_FUNCTIONAL"      ,
  OID_802_5_CURRENT_GROUP             ,  "OID_802_5_CURRENT_GROUP"           ,     // 4
  OID_802_5_LAST_OPEN_STATUS          ,  "OID_802_5_LAST_OPEN_STATUS"        ,
  OID_802_5_CURRENT_RING_STATUS       ,  "OID_802_5_CURRENT_RING_STATUS"     ,
  OID_802_5_CURRENT_RING_STATE        ,  "OID_802_5_CURRENT_RING_STATE"      ,

  OID_802_5_LINE_ERRORS               ,  "OID_802_5_LINE_ERRORS"             ,     // 8
  OID_802_5_LOST_FRAMES               ,  "OID_802_5_LOST_FRAMES"             ,

  OID_802_5_BURST_ERRORS              ,  "OID_802_5_BURST_ERRORS"            ,
  OID_802_5_AC_ERRORS                 ,  "OID_802_5_AC_ERRORS"               ,
  OID_802_5_ABORT_DELIMETERS          ,  "OID_802_5_ABORT_DELIMETERS"        ,     // 12
  OID_802_5_FRAME_COPIED_ERRORS       ,  "OID_802_5_FRAME_COPIED_ERRORS"     ,
  OID_802_5_FREQUENCY_ERRORS          ,  "OID_802_5_FREQUENCY_ERRORS"        ,
  OID_802_5_TOKEN_ERRORS              ,  "OID_802_5_TOKEN_ERRORS"            ,
  OID_802_5_INTERNAL_ERRORS           ,  "OID_802_5_INTERNAL_ERRORS"         ,     // 16

     //
   // Fddi objects
   //
   OID_FDDI_LONG_PERMANENT_ADDR        ,  "OID_FDDI_LONG_PERMANENT_ADDR"      ,     // 1
   OID_FDDI_LONG_CURRENT_ADDR          ,  "OID_FDDI_LONG_CURRENT_ADDR"        ,
   OID_FDDI_LONG_MULTICAST_LIST        ,  "OID_FDDI_LONG_MULTICAST_LIST"      ,
   OID_FDDI_LONG_MAX_LIST_SIZE         ,  "OID_FDDI_LONG_MAX_LIST_SIZE"       ,     // 4
   OID_FDDI_SHORT_PERMANENT_ADDR       ,  "OID_FDDI_SHORT_PERMANENT_ADDR"     ,
   OID_FDDI_SHORT_CURRENT_ADDR         ,  "OID_FDDI_SHORT_CURRENT_ADDR"       ,
   OID_FDDI_SHORT_MULTICAST_LIST       ,  "OID_FDDI_SHORT_MULTICAST_LIST"     ,
   OID_FDDI_SHORT_MAX_LIST_SIZE        ,  "OID_FDDI_SHORT_MAX_LIST_SIZE"      ,     // 8

   OID_FDDI_ATTACHMENT_TYPE            ,  "OID_FDDI_ATTACHMENT_TYPE"          ,
   OID_FDDI_UPSTREAM_NODE_LONG         ,  "OID_FDDI_UPSTREAM_NODE_LONG"       ,
   OID_FDDI_DOWNSTREAM_NODE_LONG       ,  "OID_FDDI_DOWNSTREAM_NODE_LONG"     ,
   OID_FDDI_FRAME_ERRORS               ,  "OID_FDDI_FRAME_ERRORS"             ,     // 12
   OID_FDDI_FRAMES_LOST                ,  "OID_FDDI_FRAMES_LOST"              ,
   OID_FDDI_RING_MGT_STATE             ,  "OID_FDDI_RING_MGT_STATE"           ,
   OID_FDDI_LCT_FAILURES               ,  "OID_FDDI_LCT_FAILURES"             ,
   OID_FDDI_LEM_REJECTS                ,  "OID_FDDI_LEM_REJECTS"              ,     // 16
   OID_FDDI_LCONNECTION_STATE          ,  "OID_FDDI_LCONNECTION_STATE"        ,
   //
   // fddi SMT/MAC/PATH/PORT/IF objects
   //
   OID_FDDI_SMT_STATION_ID             ,  "OID_FDDI_SMT_STATION_ID"           ,
   OID_FDDI_SMT_OP_VERSION_ID          ,  "OID_FDDI_SMT_OP_VERSION_ID"        ,
   OID_FDDI_SMT_HI_VERSION_ID          ,  "OID_FDDI_SMT_HI_VERSION_ID"        ,     // 20
   OID_FDDI_SMT_LO_VERSION_ID          ,  "OID_FDDI_SMT_LO_VERSION_ID"        ,
   OID_FDDI_SMT_MANUFACTURER_DATA      ,  "OID_FDDI_SMT_MANUFACTURER_DATA"    ,
   OID_FDDI_SMT_USER_DATA              ,  "OID_FDDI_SMT_USER_DATA"            ,
   OID_FDDI_SMT_MIB_VERSION_ID         ,  "OID_FDDI_SMT_MIB_VERSION_ID"       ,     // 24
   OID_FDDI_SMT_MAC_CT                 ,  "OID_FDDI_SMT_MAC_CT"               ,
   OID_FDDI_SMT_NON_MASTER_CT          ,  "OID_FDDI_SMT_NON_MASTER_CT"        ,
   OID_FDDI_SMT_MASTER_CT              ,  "OID_FDDI_SMT_MASTER_CT"            ,
   OID_FDDI_SMT_AVAILABLE_PATHS        ,  "OID_FDDI_SMT_AVAILABLE_PATHS"      ,     // 28
   OID_FDDI_SMT_CONFIG_CAPABILITIES    ,  "OID_FDDI_SMT_CONFIG_CAPABILITIES"  ,
   OID_FDDI_SMT_CONFIG_POLICY          ,  "OID_FDDI_SMT_CONFIG_POLICY"        ,
   OID_FDDI_SMT_CONNECTION_POLICY      ,  "OID_FDDI_SMT_CONNECTION_POLICY"    ,
   OID_FDDI_SMT_T_NOTIFY               ,  "OID_FDDI_SMT_T_NOTIFY"             ,     // 32
   OID_FDDI_SMT_STAT_RPT_POLICY        ,  "OID_FDDI_SMT_STAT_RPT_POLICY"      ,
   OID_FDDI_SMT_TRACE_MAX_EXPIRATION   ,  "OID_FDDI_SMT_TRACE_MAX_EXPIRATION" ,
   OID_FDDI_SMT_PORT_INDEXES           ,  "OID_FDDI_SMT_PORT_INDEXES"         ,
   OID_FDDI_SMT_MAC_INDEXES            ,  "OID_FDDI_SMT_MAC_INDEXES"          ,     // 36
   OID_FDDI_SMT_BYPASS_PRESENT         ,  "OID_FDDI_SMT_BYPASS_PRESENT"       ,
   OID_FDDI_SMT_ECM_STATE              ,  "OID_FDDI_SMT_ECM_STATE"            ,
   OID_FDDI_SMT_CF_STATE               ,  "OID_FDDI_SMT_CF_STATE"             ,
   OID_FDDI_SMT_HOLD_STATE             ,  "OID_FDDI_SMT_HOLD_STATE"           ,     // 40
   OID_FDDI_SMT_REMOTE_DISCONNECT_FLAG , "OID_FDDI_SMT_REMOTE_DISCONNECT_FLAG",
   OID_FDDI_SMT_STATION_STATUS         ,  "OID_FDDI_SMT_STATION_STATUS"       ,
   OID_FDDI_SMT_PEER_WRAP_FLAG         ,  "OID_FDDI_SMT_PEER_WRAP_FLAG"       ,
   OID_FDDI_SMT_MSG_TIME_STAMP         ,  "OID_FDDI_SMT_MSG_TIME_STAMP"       ,     // 44
   OID_FDDI_SMT_TRANSITION_TIME_STAMP  ,  "OID_FDDI_SMT_TRANSITION_TIME_STAMP",
   OID_FDDI_SMT_SET_COUNT              ,  "OID_FDDI_SMT_SET_COUNT"            ,
   OID_FDDI_SMT_LAST_SET_STATION_ID    ,  "OID_FDDI_SMT_LAST_SET_STATION_ID"  ,


   OID_FDDI_MAC_FRAME_STATUS_FUNCTIONS , "OID_FDDI_MAC_FRAME_STATUS_FUNCTIONS",     // 48
   OID_FDDI_MAC_BRIDGE_FUNCTIONS       ,  "OID_FDDI_MAC_BRIDGE_FUNCTIONS"     ,
   OID_FDDI_MAC_T_MAX_CAPABILITY       ,  "OID_FDDI_MAC_T_MAX_CAPABILITY"     ,
   OID_FDDI_MAC_TVX_CAPABILITY         ,  "OID_FDDI_MAC_TVX_CAPABILITY"       ,
   OID_FDDI_MAC_AVAILABLE_PATHS        ,  "OID_FDDI_MAC_AVAILABLE_PATHS"      ,     // 52
   OID_FDDI_MAC_CURRENT_PATH           ,  "OID_FDDI_MAC_CURRENT_PATH"         ,
   OID_FDDI_MAC_UPSTREAM_NBR           ,  "OID_FDDI_MAC_UPSTREAM_NBR"         ,
   OID_FDDI_MAC_DOWNSTREAM_NBR         ,  "OID_FDDI_MAC_DOWNSTREAM_NBR"       ,
   OID_FDDI_MAC_OLD_UPSTREAM_NBR       ,  "OID_FDDI_MAC_OLD_UPSTREAM_NBR"     ,     // 56
   OID_FDDI_MAC_OLD_DOWNSTREAM_NBR     ,  "OID_FDDI_MAC_OLD_DOWNSTREAM_NBR"   ,
   OID_FDDI_MAC_DUP_ADDRESS_TEST       ,  "OID_FDDI_MAC_DUP_ADDRESS_TEST"     ,
   OID_FDDI_MAC_REQUESTED_PATHS        ,  "OID_FDDI_MAC_REQUESTED_PATHS"      ,
   OID_FDDI_MAC_DOWNSTREAM_PORT_TYPE   ,  "OID_FDDI_MAC_DOWNSTREAM_PORT_TYPE" ,     // 60
   OID_FDDI_MAC_INDEX                  ,  "OID_FDDI_MAC_INDEX"                ,
   OID_FDDI_MAC_SMT_ADDRESS            ,  "OID_FDDI_MAC_SMT_ADDRESS"          ,
   OID_FDDI_MAC_LONG_GRP_ADDRESS       ,  "OID_FDDI_MAC_LONG_GRP_ADDRESS"     ,
   OID_FDDI_MAC_SHORT_GRP_ADDRESS      ,  "OID_FDDI_MAC_SHORT_GRP_ADDRESS"    ,     // 64
   OID_FDDI_MAC_T_REQ                  ,  "OID_FDDI_MAC_T_REQ"                ,
   OID_FDDI_MAC_T_NEG                  ,  "OID_FDDI_MAC_T_NEG"                ,
   OID_FDDI_MAC_T_MAX                  ,  "OID_FDDI_MAC_T_MAX"                ,
   OID_FDDI_MAC_TVX_VALUE              ,  "OID_FDDI_MAC_TVX_VALUE"            ,     // 68
   OID_FDDI_MAC_T_PRI0                 ,  "OID_FDDI_MAC_T_PRI0"               ,
   OID_FDDI_MAC_T_PRI1                 ,  "OID_FDDI_MAC_T_PRI1"               ,
   OID_FDDI_MAC_T_PRI2                 ,  "OID_FDDI_MAC_T_PRI2"               ,
   OID_FDDI_MAC_T_PRI3                 ,  "OID_FDDI_MAC_T_PRI3"               ,     // 72
   OID_FDDI_MAC_T_PRI4                 ,  "OID_FDDI_MAC_T_PRI4"               ,
   OID_FDDI_MAC_T_PRI5                 ,  "OID_FDDI_MAC_T_PRI5"               ,
   OID_FDDI_MAC_T_PRI6                 ,  "OID_FDDI_MAC_T_PRI6"               ,
   OID_FDDI_MAC_FRAME_CT               ,  "OID_FDDI_MAC_FRAME_CT"             ,     // 76
   OID_FDDI_MAC_COPIED_CT              ,  "OID_FDDI_MAC_COPIED_CT"            ,
   OID_FDDI_MAC_TRANSMIT_CT            ,  "OID_FDDI_MAC_TRANSMIT_CT"          ,
   OID_FDDI_MAC_TOKEN_CT               ,  "OID_FDDI_MAC_TOKEN_CT"             ,
   OID_FDDI_MAC_ERROR_CT               ,  "OID_FDDI_MAC_ERROR_CT"             ,     // 80
   OID_FDDI_MAC_LOST_CT                ,  "OID_FDDI_MAC_LOST_CT"              ,
   OID_FDDI_MAC_TVX_EXPIRED_CT         ,  "OID_FDDI_MAC_TVX_EXPIRED_CT"       ,
   OID_FDDI_MAC_NOT_COPIED_CT          ,  "OID_FDDI_MAC_NOT_COPIED_CT"        ,
   OID_FDDI_MAC_LATE_CT                ,  "OID_FDDI_MAC_LATE_CT"              ,     // 84
   OID_FDDI_MAC_RING_OP_CT             ,  "OID_FDDI_MAC_RING_OP_CT"           ,
   OID_FDDI_MAC_FRAME_ERROR_THRESHOLD  ,  "OID_FDDI_MAC_FRAME_ERROR_THRESHOLD",
   OID_FDDI_MAC_FRAME_ERROR_RATIO      ,  "OID_FDDI_MAC_FRAME_ERROR_RATIO"    ,
   OID_FDDI_MAC_NOT_COPIED_THRESHOLD   ,  "OID_FDDI_MAC_NOT_COPIED_THRESHOLD" ,     // 88
   OID_FDDI_MAC_NOT_COPIED_RATIO       ,  "OID_FDDI_MAC_NOT_COPIED_RATIO"     ,
   OID_FDDI_MAC_RMT_STATE              ,  "OID_FDDI_MAC_RMT_STATE"            ,
   OID_FDDI_MAC_DA_FLAG                ,  "OID_FDDI_MAC_DA_FLAG"              ,
   OID_FDDI_MAC_UNDA_FLAG              ,  "OID_FDDI_MAC_UNDA_FLAG"            ,     // 92
   OID_FDDI_MAC_FRAME_ERROR_FLAG       ,  "OID_FDDI_MAC_FRAME_ERROR_FLAG"     ,
   OID_FDDI_MAC_NOT_COPIED_FLAG        ,  "OID_FDDI_MAC_NOT_COPIED_FLAG"      ,
   OID_FDDI_MAC_MA_UNITDATA_AVAILABLE  ,  "OID_FDDI_MAC_MA_UNITDATA_AVAILABLE",
   OID_FDDI_MAC_HARDWARE_PRESENT       ,  "OID_FDDI_MAC_HARDWARE_PRESENT"     ,     // 96
   OID_FDDI_MAC_MA_UNITDATA_ENABLE     ,  "OID_FDDI_MAC_MA_UNITDATA_ENABLE"   ,

   

   OID_FDDI_PATH_INDEX                 ,  "OID_FDDI_PATH_INDEX"               ,
   OID_FDDI_PATH_RING_LATENCY          ,  "OID_FDDI_PATH_RING_LATENCY"        ,
   OID_FDDI_PATH_TRACE_STATUS          ,  "OID_FDDI_PATH_TRACE_STATUS"        ,     // 100
   OID_FDDI_PATH_SBA_PAYLOAD           ,  "OID_FDDI_PATH_SBA_PAYLOAD"         ,
   OID_FDDI_PATH_SBA_OVERHEAD          ,  "OID_FDDI_PATH_SBA_OVERHEAD"        ,
   OID_FDDI_PATH_CONFIGURATION         ,  "OID_FDDI_PATH_CONFIGURATION"       ,
   OID_FDDI_PATH_T_R_MODE              ,  "OID_FDDI_PATH_T_R_MODE"            ,     // 104
   OID_FDDI_PATH_SBA_AVAILABLE         ,  "OID_FDDI_PATH_SBA_AVAILABLE"       ,
   OID_FDDI_PATH_TVX_LOWER_BOUND       ,  "OID_FDDI_PATH_TVX_LOWER_BOUND"     ,
   OID_FDDI_PATH_T_MAX_LOWER_BOUND     ,  "OID_FDDI_PATH_T_MAX_LOWER_BOUND"   ,
   OID_FDDI_PATH_MAX_T_REQ             ,  "OID_FDDI_PATH_MAX_T_REQ"           ,     // 108

   OID_FDDI_PORT_MY_TYPE               ,  "OID_FDDI_PORT_MY_TYPE"             ,
   OID_FDDI_PORT_NEIGHBOR_TYPE         ,  "OID_FDDI_PORT_NEIGHBOR_TYPE"       ,
   OID_FDDI_PORT_CONNECTION_POLICIES   ,  "OID_FDDI_PORT_CONNECTION_POLICIES" ,
   OID_FDDI_PORT_MAC_INDICATED         ,  "OID_FDDI_PORT_MAC_INDICATED"       ,     // 112
   OID_FDDI_PORT_CURRENT_PATH          ,  "OID_FDDI_PORT_CURRENT_PATH"        ,
   OID_FDDI_PORT_REQUESTED_PATHS       ,  "OID_FDDI_PORT_REQUESTED_PATHS"     ,
   OID_FDDI_PORT_MAC_PLACEMENT         ,  "OID_FDDI_PORT_MAC_PLACEMENT"       ,
   OID_FDDI_PORT_AVAILABLE_PATHS       ,  "OID_FDDI_PORT_AVAILABLE_PATHS"     ,     // 116
   OID_FDDI_PORT_MAC_LOOP_TIME         ,  "OID_FDDI_PORT_MAC_LOOP_TIME"       ,
   OID_FDDI_PORT_PMD_CLASS             ,  "OID_FDDI_PORT_PMD_CLASS"           ,
   OID_FDDI_PORT_CONNECTION_CAPABILITIES  ,  "OID_FDDI_PORT_CONNECTION_CAPABILITIES",
   OID_FDDI_PORT_INDEX                 ,  "OID_FDDI_PORT_INDEX"               ,     // 120
   OID_FDDI_PORT_MAINT_LS              ,  "OID_FDDI_PORT_MAINT_LS"            ,
   OID_FDDI_PORT_BS_FLAG               ,  "OID_FDDI_PORT_BS_FLAG"             ,
   OID_FDDI_PORT_PC_LS                 ,  "OID_FDDI_PORT_PC_LS"               ,
   OID_FDDI_PORT_EB_ERROR_CT           ,  "OID_FDDI_PORT_EB_ERROR_CT"         ,     // 124
   OID_FDDI_PORT_LCT_FAIL_CT           ,  "OID_FDDI_PORT_LCT_FAIL_CT"         ,
   OID_FDDI_PORT_LER_ESTIMATE          ,  "OID_FDDI_PORT_LER_ESTIMATE"        ,
   OID_FDDI_PORT_LEM_REJECT_CT         ,  "OID_FDDI_PORT_LEM_REJECT_CT"       ,
   OID_FDDI_PORT_LEM_CT                ,  "OID_FDDI_PORT_LEM_CT"              ,     // 128
   OID_FDDI_PORT_LER_CUTOFF            ,  "OID_FDDI_PORT_LER_CUTOFF"          ,
   OID_FDDI_PORT_LER_ALARM             ,  "OID_FDDI_PORT_LER_ALARM"           ,
   OID_FDDI_PORT_CONNNECT_STATE        ,  "OID_FDDI_PORT_CONNNECT_STATE"      ,
   OID_FDDI_PORT_PCM_STATE             ,  "OID_FDDI_PORT_PCM_STATE"           ,     // 132
   OID_FDDI_PORT_PC_WITHHOLD           ,  "OID_FDDI_PORT_PC_WITHHOLD"         ,
   OID_FDDI_PORT_LER_FLAG              ,  "OID_FDDI_PORT_LER_FLAG"            ,
   OID_FDDI_PORT_HARDWARE_PRESENT      ,  "OID_FDDI_PORT_HARDWARE_PRESENT"    ,

   
   OID_FDDI_SMT_STATION_ACTION         ,  "OID_FDDI_SMT_STATION_ACTION"       ,     // 136
   OID_FDDI_PORT_ACTION                ,  "OID_FDDI_PORT_ACTION"              ,


   OID_FDDI_IF_DESCR                   ,  "OID_FDDI_IF_DESCR"                 ,
   OID_FDDI_IF_TYPE                    ,  "OID_FDDI_IF_TYPE"                  ,
   OID_FDDI_IF_MTU                     ,  "OID_FDDI_IF_MTU"                   ,     // 140
   OID_FDDI_IF_SPEED                   ,  "OID_FDDI_IF_SPEED"                 ,
   OID_FDDI_IF_PHYS_ADDRESS            ,  "OID_FDDI_IF_PHYS_ADDRESS"          ,
   OID_FDDI_IF_ADMIN_STATUS            ,  "OID_FDDI_IF_ADMIN_STATUS"          ,
   OID_FDDI_IF_OPER_STATUS             ,  "OID_FDDI_IF_OPER_STATUS"           ,     // 144
   OID_FDDI_IF_LAST_CHANGE             ,  "OID_FDDI_IF_LAST_CHANGE"           ,
   OID_FDDI_IF_IN_OCTETS               ,  "OID_FDDI_IF_IN_OCTETS"             ,
   OID_FDDI_IF_IN_UCAST_PKTS           ,  "OID_FDDI_IF_IN_UCAST_PKTS"         ,
   OID_FDDI_IF_IN_NUCAST_PKTS          ,  "OID_FDDI_IF_IN_NUCAST_PKTS"        ,     // 148
   OID_FDDI_IF_IN_DISCARDS             ,  "OID_FDDI_IF_IN_DISCARDS"           ,
   OID_FDDI_IF_IN_ERRORS               ,  "OID_FDDI_IF_IN_ERRORS"             ,
   OID_FDDI_IF_IN_UNKNOWN_PROTOS       ,  "OID_FDDI_IF_IN_UNKNOWN_PROTOS"     ,
   OID_FDDI_IF_OUT_OCTETS              ,  "OID_FDDI_IF_OUT_OCTETS"            ,     // 152
   OID_FDDI_IF_OUT_UCAST_PKTS          ,  "OID_FDDI_IF_OUT_UCAST_PKTS"        ,
   OID_FDDI_IF_OUT_NUCAST_PKTS         ,  "OID_FDDI_IF_OUT_NUCAST_PKTS"       ,
   OID_FDDI_IF_OUT_DISCARDS            ,  "OID_FDDI_IF_OUT_DISCARDS"          ,
   OID_FDDI_IF_OUT_ERRORS              ,  "OID_FDDI_IF_OUT_ERRORS"            ,     // 156
   OID_FDDI_IF_OUT_QLEN                ,  "OID_FDDI_IF_OUT_QLEN"              ,
   OID_FDDI_IF_SPECIFIC                ,  "OID_FDDI_IF_SPECIFIC"              ,     // 158


   //
   // WAN objects
   //

   OID_WAN_PERMANENT_ADDRESS           ,  "OID_WAN_PERMANENT_ADDRESS"         ,     // 1
   OID_WAN_CURRENT_ADDRESS             ,  "OID_WAN_CURRENT_ADDRESS"           ,
   OID_WAN_QUALITY_OF_SERVICE          ,  "OID_WAN_QUALITY_OF_SERVICE"        ,
   OID_WAN_PROTOCOL_TYPE               ,  "OID_WAN_PROTOCOL_TYPE"             ,     // 4
   OID_WAN_MEDIUM_SUBTYPE              ,  "OID_WAN_MEDIUM_SUBTYPE"            ,
   OID_WAN_HEADER_FORMAT               ,  "OID_WAN_HEADER_FORMAT"             ,
   OID_WAN_GET_INFO                    ,  "OID_WAN_GET_INFO"                  ,
   OID_WAN_SET_LINK_INFO               ,  "OID_WAN_SET_LINK_INFO"             ,     // 8
   OID_WAN_GET_LINK_INFO               ,  "OID_WAN_GET_LINK_INFO"             ,
   OID_WAN_LINE_COUNT                  ,  "OID_WAN_LINE_COUNT"                ,

   OID_WAN_GET_BRIDGE_INFO             ,  "OID_WAN_GET_BRIDGE_INFO"           ,
   OID_WAN_SET_BRIDGE_INFO             ,  "OID_WAN_SET_BRIDGE_INFO"           ,     // 12
   OID_WAN_GET_COMP_INFO               ,  "OID_WAN_GET_COMP_INFO"             ,
   OID_WAN_SET_COMP_INFO               ,  "OID_WAN_SET_COMP_INFO"             ,
   OID_WAN_GET_STATS_INFO              ,  "OID_WAN_GET_STATS_INFO"            ,     // 15

   
   //
   // ARCNET objects
   //
   OID_ARCNET_PERMANENT_ADDRESS        ,  "OID_ARCNET_PERMANENT_ADDRESS"      ,     // 1
   OID_ARCNET_CURRENT_ADDRESS          ,  "OID_ARCNET_CURRENT_ADDRESS"        ,
   OID_ARCNET_RECONFIGURATIONS         ,  "OID_ARCNET_RECONFIGURATIONS"       ,     // 3
   //
   // ATM objects
   //
   OID_ATM_SUPPORTED_VC_RATES          ,  "OID_ATM_SUPPORTED_VC_RATES"        ,     // 1
   OID_ATM_SUPPORTED_SERVICE_CATEGORY  ,  "OID_ATM_SUPPORTED_SERVICE_CATEGORY",
   OID_ATM_SUPPORTED_AAL_TYPES         ,  "OID_ATM_SUPPORTED_AAL_TYPES"       ,
   OID_ATM_HW_CURRENT_ADDRESS          ,  "OID_ATM_HW_CURRENT_ADDRESS"        ,     // 4
   OID_ATM_MAX_ACTIVE_VCS              ,  "OID_ATM_MAX_ACTIVE_VCS"            ,
   OID_ATM_MAX_ACTIVE_VCI_BITS         ,  "OID_ATM_MAX_ACTIVE_VCI_BITS"       ,
   OID_ATM_MAX_ACTIVE_VPI_BITS         ,  "OID_ATM_MAX_ACTIVE_VPI_BITS"       ,
   OID_ATM_MAX_AAL0_PACKET_SIZE        ,  "OID_ATM_MAX_AAL0_PACKET_SIZE"      ,     // 8
   OID_ATM_MAX_AAL1_PACKET_SIZE        ,  "OID_ATM_MAX_AAL1_PACKET_SIZE"      ,
   OID_ATM_MAX_AAL34_PACKET_SIZE       ,  "OID_ATM_MAX_AAL34_PACKET_SIZE"     ,
   OID_ATM_MAX_AAL5_PACKET_SIZE        ,  "OID_ATM_MAX_AAL5_PACKET_SIZE"      ,

   OID_ATM_SIGNALING_VPIVCI            ,  "OID_ATM_SIGNALING_VPIVCI"          ,     // 12
   OID_ATM_ASSIGNED_VPI                ,  "OID_ATM_ASSIGNED_VPI"              ,
   OID_ATM_ACQUIRE_ACCESS_NET_RESOURCES,  "OID_ATM_ACQUIRE_ACCESS_NET_RESOURCES" ,
   OID_ATM_RELEASE_ACCESS_NET_RESOURCES,  "OID_ATM_RELEASE_ACCESS_NET_RESOURCES" ,
   OID_ATM_ILMI_VPIVCI                 ,  "OID_ATM_ILMI_VPIVCI"               ,     // 16
   OID_ATM_DIGITAL_BROADCAST_VPIVCI    ,  "OID_ATM_DIGITAL_BROADCAST_VPIVCI"  ,
   OID_ATM_GET_NEAREST_FLOW            ,  "OID_ATM_GET_NEAREST_FLOW"          ,
   OID_ATM_ALIGNMENT_REQUIRED          ,  "OID_ATM_ALIGNMENT_REQUIRED"        ,
// OID_ATM_LECS_ADDRESS???
   OID_ATM_SERVICE_ADDRESS             ,  "OID_ATM_SERVICE_ADDRESS"           ,     // 20

   OID_ATM_RCV_CELLS_OK                ,  "OID_ATM_RCV_CELLS_OK"              ,
   OID_ATM_XMIT_CELLS_OK               ,  "OID_ATM_XMIT_CELLS_OK"             ,
   OID_ATM_RCV_CELLS_DROPPED           ,  "OID_ATM_RCV_CELLS_DROPPED"         ,

   OID_ATM_RCV_INVALID_VPI_VCI         ,  "OID_ATM_RCV_INVALID_VPI_VCI"       ,     // 24
   OID_ATM_CELLS_HEC_ERROR             ,  "OID_ATM_CELLS_HEC_ERROR"           ,
   OID_ATM_RCV_REASSEMBLY_ERROR        ,  "OID_ATM_RCV_REASSEMBLY_ERROR"      ,     // 26


   //
   // PCCA (Wireless) objects
   //
   // All WirelessWAN devices must support the following OIDs
   //
   OID_WW_GEN_NETWORK_TYPES_SUPPORTED  ,  "OID_WW_GEN_NETWORK_TYPES_SUPPORTED"   ,  // 1
   OID_WW_GEN_NETWORK_TYPE_IN_USE      ,  "OID_WW_GEN_NETWORK_TYPE_IN_USE"       ,
   OID_WW_GEN_HEADER_FORMATS_SUPPORTED ,  "OID_WW_GEN_HEADER_FORMATS_SUPPORTED"  ,
   OID_WW_GEN_HEADER_FORMAT_IN_USE     ,  "OID_WW_GEN_HEADER_FORMAT_IN_USE"      ,  // 4
   OID_WW_GEN_INDICATION_REQUEST       ,  "OID_WW_GEN_INDICATION_REQUEST"        ,
   OID_WW_GEN_DEVICE_INFO              ,  "OID_WW_GEN_DEVICE_INFO"               ,
   OID_WW_GEN_OPERATION_MODE           ,  "OID_WW_GEN_OPERATION_MODE"            ,
   OID_WW_GEN_LOCK_STATUS              ,  "OID_WW_GEN_LOCK_STATUS"               ,  // 8
   OID_WW_GEN_DISABLE_TRANSMITTER      ,  "OID_WW_GEN_DISABLE_TRANSMITTER"       ,
   OID_WW_GEN_NETWORK_ID               ,  "OID_WW_GEN_NETWORK_ID"                ,
   OID_WW_GEN_PERMANENT_ADDRESS        ,  "OID_WW_GEN_PERMANENT_ADDRESS"         ,
   OID_WW_GEN_CURRENT_ADDRESS          ,  "OID_WW_GEN_CURRENT_ADDRESS"           ,  // 12
   OID_WW_GEN_SUSPEND_DRIVER           ,  "OID_WW_GEN_SUSPEND_DRIVER"            ,
   OID_WW_GEN_BASESTATION_ID           ,  "OID_WW_GEN_BASESTATION_ID"            ,
   OID_WW_GEN_CHANNEL_ID               ,  "OID_WW_GEN_CHANNEL_ID"                ,
   OID_WW_GEN_ENCRYPTION_SUPPORTED     ,  "OID_WW_GEN_ENCRYPTION_SUPPORTED"      ,  // 16
   OID_WW_GEN_ENCRYPTION_IN_USE        ,  "OID_WW_GEN_ENCRYPTION_IN_USE"         ,
   OID_WW_GEN_ENCRYPTION_STATE         ,  "OID_WW_GEN_ENCRYPTION_STATE"          ,
   OID_WW_GEN_CHANNEL_QUALITY          ,  "OID_WW_GEN_CHANNEL_QUALITY"           ,
   OID_WW_GEN_REGISTRATION_STATUS      ,  "OID_WW_GEN_REGISTRATION_STATUS"       ,  // 20
   OID_WW_GEN_RADIO_LINK_SPEED         ,  "OID_WW_GEN_RADIO_LINK_SPEED"          ,
   OID_WW_GEN_LATENCY                  ,  "OID_WW_GEN_LATENCY"                   ,
   OID_WW_GEN_BATTERY_LEVEL            ,  "OID_WW_GEN_BATTERY_LEVEL"             ,
   OID_WW_GEN_EXTERNAL_POWER           ,  "OID_WW_GEN_EXTERNAL_POWER"            ,  // 24

   //
   // Network Dependent OIDs - Mobitex:
   //
   OID_WW_MBX_SUBADDR                  ,  "OID_WW_MBX_SUBADDR"                   ,
   OID_WW_MBX_FLEXLIST                 ,  "OID_WW_MBX_FLEXLIST"                  ,
   OID_WW_MBX_GROUPLIST                ,  "OID_WW_MBX_GROUPLIST"                 ,
   OID_WW_MBX_TRAFFIC_AREA             ,  "OID_WW_MBX_TRAFFIC_AREA"              ,  // 28
   OID_WW_MBX_LIVE_DIE                 ,  "OID_WW_MBX_LIVE_DIE"                  ,
   OID_WW_MBX_TEMP_DEFAULTLIST         ,  "OID_WW_MBX_TEMP_DEFAULTLIST"          ,

   //
   // Network Dependent OIDs - Pinpoint:
   //
   OID_WW_PIN_LOC_AUTHORIZE            ,  "OID_WW_PIN_LOC_AUTHORIZE"             ,
   OID_WW_PIN_LAST_LOCATION            ,  "OID_WW_PIN_LAST_LOCATION"             ,  // 32
   OID_WW_PIN_LOC_FIX                  ,  "OID_WW_PIN_LOC_FIX"                   ,

   
   //
   // Network Dependent - CDPD:
   //
   OID_WW_CDPD_SPNI                    ,  "OID_WW_CDPD_SPNI"                     ,
   OID_WW_CDPD_WASI                    ,  "OID_WW_CDPD_WASI"                     ,
   OID_WW_CDPD_AREA_COLOR              ,  "OID_WW_CDPD_AREA_COLOR"               ,  // 36
   OID_WW_CDPD_TX_POWER_LEVEL          ,  "OID_WW_CDPD_TX_POWER_LEVEL"           ,
   OID_WW_CDPD_EID                     ,  "OID_WW_CDPD_EID"                      ,
   OID_WW_CDPD_HEADER_COMPRESSION      ,  "OID_WW_CDPD_HEADER_COMPRESSION"       ,
   OID_WW_CDPD_DATA_COMPRESSION        ,  "OID_WW_CDPD_DATA_COMPRESSION"         ,  // 40
   OID_WW_CDPD_CHANNEL_SELECT          ,  "OID_WW_CDPD_CHANNEL_SELECT"           ,
   OID_WW_CDPD_CHANNEL_STATE           ,  "OID_WW_CDPD_CHANNEL_STATE"            ,
   OID_WW_CDPD_NEI                     ,  "OID_WW_CDPD_NEI"                      ,
   OID_WW_CDPD_NEI_STATE               ,  "OID_WW_CDPD_NEI_STATE"                ,  // 44
   OID_WW_CDPD_SERVICE_PROVIDER_IDENTIFIER,  "OID_WW_CDPD_SERVICE_PROVIDER_IDENTIFIER" ,
   OID_WW_CDPD_SLEEP_MODE              ,  "OID_WW_CDPD_SLEEP_MODE"               ,
   OID_WW_CDPD_CIRCUIT_SWITCHED        ,  "OID_WW_CDPD_CIRCUIT_SWITCHED"         ,
   OID_WW_CDPD_TEI                     ,  "OID_WW_CDPD_TEI"                      ,  // 48
   OID_WW_CDPD_RSSI                    ,  "OID_WW_CDPD_RSSI"                     ,

   //
   // Network Dependent - Ardis:
   //
   OID_WW_ARD_SNDCP                    ,  "OID_WW_ARD_SNDCP"                     ,
   OID_WW_ARD_TMLY_MSG                 ,  "OID_WW_ARD_TMLY_MSG"                  ,
   OID_WW_ARD_DATAGRAM                 ,  "OID_WW_ARD_DATAGRAM"                  ,  // 52

   //
   // Network Dependent - DataTac:
   //
   OID_WW_TAC_COMPRESSION              ,  "OID_WW_TAC_COMPRESSION"               ,
   OID_WW_TAC_SET_CONFIG               ,  "OID_WW_TAC_SET_CONFIG"                ,
   OID_WW_TAC_GET_STATUS               ,  "OID_WW_TAC_GET_STATUS"                ,
   OID_WW_TAC_USER_HEADER              ,  "OID_WW_TAC_USER_HEADER"               ,  // 56

   //
   // Network Dependent - Metricom:
   //
   OID_WW_MET_FUNCTION                 ,  "OID_WW_MET_FUNCTION"                  ,  // 57

      //
   // IRDA objects
   //
   OID_IRDA_RECEIVING                  ,  "OID_IRDA_RECEIVING"                   ,  // 1
   OID_IRDA_TURNAROUND_TIME            ,  "OID_IRDA_TURNAROUND_TIME"             ,
   OID_IRDA_SUPPORTED_SPEEDS           ,  "OID_IRDA_SUPPORTED_SPEEDS"            ,
   OID_IRDA_LINK_SPEED                 ,  "OID_IRDA_LINK_SPEED"                  ,  // 4
   OID_IRDA_MEDIA_BUSY                 ,  "OID_IRDA_MEDIA_BUSY"                  ,

   OID_IRDA_EXTRA_RCV_BOFS             ,  "OID_IRDA_EXTRA_RCV_BOFS"              ,
   OID_IRDA_RATE_SNIFF                 ,  "OID_IRDA_RATE_SNIFF"                  ,
   OID_IRDA_UNICAST_LIST               ,  "OID_IRDA_UNICAST_LIST"                ,  // 8
   OID_IRDA_MAX_UNICAST_LIST_SIZE      ,  "OID_IRDA_MAX_UNICAST_LIST_SIZE"       ,
   OID_IRDA_MAX_RECEIVE_WINDOW_SIZE    ,  "OID_IRDA_MAX_RECEIVE_WINDOW_SIZE"     ,
   OID_IRDA_MAX_SEND_WINDOW_SIZE       ,  "OID_IRDA_MAX_SEND_WINDOW_SIZE"        ,  // 11

   //
   // broadcast pc objects
   //
#ifdef   BROADCAST_PC
#ifdef   OLD_BPC
   OID_DSS_DATA_DEVICES                ,  "OID_DSS_DATA_DEVICES"                 ,
   OID_DSS_TUNING_DEVICES              ,  "OID_DSS_TUNING_DEVICES"               ,
   OID_DSS_DATA_DEVICE_CAPS            ,  "OID_DSS_DATA_DEVICE_CAPS"             ,
   OID_DSS_PROGRAM_GUIDE               ,  "OID_DSS_PROGRAM_GUIDE"                ,  // 4
   OID_DSS_LAST_STATUS                 ,  "OID_DSS_LAST_STATUS"                  ,
   OID_DSS_DATA_DEVICE_SETTINGS        ,  "OID_DSS_DATA_DEVICE_SETTINGS"         ,
   OID_DSS_DATA_DEVICE_CONNECT         ,  "OID_DSS_DATA_DEVICE_CONNECT"          ,
   OID_DSS_DATA_DEVICE_DISCONNECT      ,  "OID_DSS_DATA_DEVICE_DISCONNECT"       ,  // 8
   OID_DSS_DATA_DEVICE_ENABLE          ,  "OID_DSS_DATA_DEVICE_ENABLE"           ,
   OID_DSS_DATA_DEVICE_TUNING          ,  "OID_DSS_DATA_DEVICE_TUNING"           ,
   OID_DSS_CONDITIONAL_ACCESS          ,  "OID_DSS_CONDITIONAL_ACCESS"           ,
   OID_DSS_POOL_RETURN                 ,  "OID_DSS_POOL_RETURN"                  ,  // 12
   OID_DSS_FORCE_RECEIVE               ,  "OID_DSS_FORCE_RECEIVE"                ,
   OID_DSS_SUBSCID_FILTER              ,  "OID_DSS_SUBSCID_FILTER"               ,
   OID_DSS_TUNING_DEVICE_SETTINGS      ,  "OID_DSS_TUNING_DEVICE_SETTINGS"       ,
   OID_DSS_POOL_RESERVE                ,  "OID_DSS_POOL_RESERVE"                 ,  // 16
   OID_DSS_ADAPTER_SPECIFIC            ,  "OID_DSS_ADAPTER_SPECIFIC"             ,  // 17
   0xfedcba98                          ,  "YE_OLD_BOGUS_OID"                     ,  // so I
don't have to update count below
#else
   OID_BPC_ADAPTER_CAPS                ,  "OID_BPC_ADAPTER_CAPS"                 ,  // 1
   OID_BPC_DEVICES                     ,  "OID_BPC_DEVICES"                      ,
   OID_BPC_DEVICE_CAPS                 ,  "OID_BPC_DEVICE_CAPS"                  ,
   OID_BPC_DEVICE_SETTINGS             ,  "OID_BPC_DEVICE_SETTINGS"              ,  // 4
   OID_BPC_CONNECTION_STATUS           ,  "OID_BPC_CONNECTION_STATUS"            ,
   OID_BPC_ADDRESS_COMPARE             ,  "OID_BPC_ADDRESS_COMPARE"              ,
   OID_BPC_PROGRAM_GUIDE               ,  "OID_BPC_PROGRAM_GUIDE"                ,
   OID_BPC_LAST_ERROR                  ,  "OID_BPC_LAST_ERROR"                   ,  // 8
   OID_BPC_POOL                        ,  "OID_BPC_POOL"                         ,
   OID_BPC_PROVIDER_SPECIFIC           ,  "OID_BPC_PROVIDER_SPECIFIC"            ,
   OID_BPC_ADAPTER_SPECIFIC            ,  "OID_BPC_ADAPTER_SPECIFIC"             ,
   OID_BPC_CONNECT                     ,  "OID_BPC_CONNECT"                      ,  // 12
   OID_BPC_COMMIT                      ,  "OID_BPC_COMMIT"                       ,
   OID_BPC_DISCONNECT                  ,  "OID_BPC_DISCONNECT"                   ,
   OID_BPC_CONNECTION_ENABLE           ,  "OID_BPC_CONNECTION_ENABLE"            ,
   OID_BPC_POOL_RESERVE                ,  "OID_BPC_POOL_RESERVE"                 ,  // 16
   OID_BPC_POOL_RETURN                 ,  "OID_BPC_POOL_RETURN"                  ,
   OID_BPC_FORCE_RECEIVE               ,  "OID_BPC_FORCE_RECEIVE"                ,  // 18
#endif
#endif

   //
   //  PnP and PM OIDs
   //
   OID_PNP_CAPABILITIES                ,  "OID_PNP_CAPABILITIES"                 ,  // 1
   OID_PNP_SET_POWER                   ,  "OID_PNP_SET_POWER"                    ,
   OID_PNP_QUERY_POWER                 ,  "OID_PNP_QUERY_POWER"                  ,
   OID_PNP_ADD_WAKE_UP_PATTERN         ,  "OID_PNP_ADD_WAKE_UP_PATTERN"          ,  // 4
   OID_PNP_REMOVE_WAKE_UP_PATTERN      ,  "OID_PNP_REMOVE_WAKE_UP_PATTERN"       ,
   OID_PNP_WAKE_UP_PATTERN_LIST        ,  "OID_PNP_WAKE_UP_PATTERN_LIST"         ,
   OID_PNP_ENABLE_WAKE_UP              ,  "OID_PNP_ENABLE_WAKE_UP"               ,

   //
   //  PnP/PM Statistics (Optional).
   //
   OID_PNP_WAKE_UP_OK                  ,  "OID_PNP_WAKE_UP_OK"                   ,  // 8
   OID_PNP_WAKE_UP_ERROR               ,  "OID_PNP_WAKE_UP_ERROR"                ,  // 9

   //
   // Generic CoNdis Oids.. (note that numbers overlap Generic Oids
   //
   OID_GEN_CO_SUPPORTED_LIST           ,  "OID_GEN_CO_SUPPORTED_LIST"            ,  // 1
   OID_GEN_CO_HARDWARE_STATUS          ,  "OID_GEN_CO_HARDWARE_STATUS"           ,
   OID_GEN_CO_MEDIA_SUPPORTED          ,  "OID_GEN_CO_MEDIA_SUPPORTED"           ,
   OID_GEN_CO_MEDIA_IN_USE             ,  "OID_GEN_CO_MEDIA_IN_USE"              ,  // 4
   OID_GEN_CO_LINK_SPEED               ,  "OID_GEN_CO_LINK_SPEED"                ,
   OID_GEN_CO_VENDOR_ID                ,  "OID_GEN_CO_VENDOR_ID"                 ,
   OID_GEN_CO_VENDOR_DESCRIPTION       ,  "OID_GEN_CO_VENDOR_DESCRIPTION"        ,
   OID_GEN_CO_DRIVER_VERSION           ,  "OID_GEN_CO_DRIVER_VERSION"            ,  // 8
   OID_GEN_CO_PROTOCOL_OPTIONS         ,  "OID_GEN_CO_PROTOCOL_OPTIONS"          ,
   OID_GEN_CO_MAC_OPTIONS              ,  "OID_GEN_CO_MAC_OPTIONS"               ,
   OID_GEN_CO_MEDIA_CONNECT_STATUS     ,  "OID_GEN_CO_MEDIA_CONNECT_STATUS"      ,
   OID_GEN_CO_VENDOR_DRIVER_VERSION    ,  "OID_GEN_CO_VENDOR_DRIVER_VERSION"     ,  // 12
   OID_GEN_CO_MINIMUM_LINK_SPEED       ,  "OID_GEN_CO_MINIMUM_LINK_SPEED"        ,
   OID_GEN_CO_SUPPORTED_GUIDS          ,  "OID_GEN_CO_SUPPORTED_GUIDS"           ,

   OID_GEN_CO_GET_TIME_CAPS            ,  "OID_GEN_CO_GET_TIME_CAPS"             ,
   OID_GEN_CO_GET_NETCARD_TIME         ,  "OID_GEN_CO_GET_NETCARD_TIME"          ,  // 16

   OID_GEN_CO_XMIT_PDUS_OK             ,  "OID_GEN_CO_XMIT_PDUS_OK"              ,
   OID_GEN_CO_RCV_PDUS_OK              ,  "OID_GEN_CO_RCV_PDUS_OK"               ,
   OID_GEN_CO_XMIT_PDUS_ERROR          ,  "OID_GEN_CO_XMIT_PDUS_ERROR"           ,
   OID_GEN_CO_RCV_PDUS_ERROR           ,  "OID_GEN_CO_RCV_PDUS_ERROR"            ,  // 20
   OID_GEN_CO_RCV_PDUS_NO_BUFFER       ,  "OID_GEN_CO_RCV_PDUS_NO_BUFFER"        ,

   OID_GEN_CO_RCV_CRC_ERROR            ,  "OID_GEN_CO_RCV_CRC_ERROR"             ,
   OID_GEN_CO_TRANSMIT_QUEUE_LENGTH    ,  "OID_GEN_CO_TRANSMIT_QUEUE_LENGTH"     ,
   OID_GEN_CO_BYTES_XMIT               ,  "OID_GEN_CO_BYTES_XMIT"                ,  // 24
   OID_GEN_CO_BYTES_RCV                ,  "OID_GEN_CO_BYTES_RCV"                 ,
   OID_GEN_CO_BYTES_XMIT_OUTSTANDING   ,  "OID_GEN_CO_BYTES_XMIT_OUTSTANDING"    ,
   OID_GEN_CO_NETCARD_LOAD             ,  "OID_GEN_CO_NETCARD_LOAD"              ,
   OID_GEN_CO_DEVICE_PROFILE           ,  "OID_GEN_CO_DEVICE_PROFILE"            ,  // 28

   //
   // filter types
   //
   NDIS_PACKET_TYPE_DIRECTED           ,  "DIRECTED"                          ,
   NDIS_PACKET_TYPE_MULTICAST          ,  "MULTICAST"                         ,
   NDIS_PACKET_TYPE_ALL_MULTICAST      ,  "ALLMULTICAST"                      ,
   NDIS_PACKET_TYPE_BROADCAST          ,  "BROADCAST"                         ,
   NDIS_PACKET_TYPE_SOURCE_ROUTING     ,  "SOURCEROUTING"                     ,
   NDIS_PACKET_TYPE_PROMISCUOUS        ,  "PROMISCUOUS"                       ,
   NDIS_PACKET_TYPE_SMT                ,  "SMT"                               ,
   NDIS_PACKET_TYPE_ALL_LOCAL          ,  "ALL_LOCAL"                         ,
   NDIS_PACKET_TYPE_MAC_FRAME          ,  "MACFRAME"                          ,
   NDIS_PACKET_TYPE_FUNCTIONAL         ,  "FUNCTIONAL"                        ,
   NDIS_PACKET_TYPE_ALL_FUNCTIONAL     ,  "ALLFUNCTIONAL"                     ,
   NDIS_PACKET_TYPE_GROUP              ,  "GROUP"                             ,
   0x00000000                          ,  "NONE"                              ,

   //
   // test result returns
   //
   ulTEST_SUCCESSFUL                   ,  "TEST_SUCCESSFUL"                   ,
   ulTEST_WARNED                       ,  "TEST_WARNED"                       ,
   ulTEST_FAILED                       ,  "TEST_FAILED"                       ,
   ulTEST_BLOCKED                      ,  "TEST_BLOCKED"                      ,

   //
   // media types for return to shell
   //
   ulMEDIUM_ETHERNET                   ,  "MEDIUM_ETHERNET"                   ,
   ulMEDIUM_TOKENRING                  ,  "MEDIUM_TOKENRING"                  ,
   ulMEDIUM_FDDI                       ,  "MEDIUM_FDDI"                       ,
   ulMEDIUM_ARCNET                     ,  "MEDIUM_ARCNET"                     ,
   ulMEDIUM_WIRELESSWAN                ,  "MEDIUM_WIRELESSWAN"                ,
   ulMEDIUM_IRDA                       ,  "MEDIUM_IRDA"                       ,
   ulMEDIUM_ATM                        ,  "MEDIUM_ATM"                        ,
   ulMEDIUM_NDISWAN                    ,  "MEDIUM_NDISWAN"                    ,


#ifdef   BROADCAST_PC
   ulMEDIUM_DIX                        ,  "MEDIUM_DIX"                        ,
#endif

   //
   // stress test-type constants
   //
   ulSTRESS_FIXEDSIZE                  ,  "STRESS_FIXEDSIZE"                  ,
   ulSTRESS_RANDOMSIZE                 ,  "STRESS_RANDOMSIZE"                 ,
   ulSTRESS_CYCLICAL                   ,  "STRESS_CYCLICAL"                   ,
   ulSTRESS_SMALLSIZE                  ,  "STRESS_SMALLSIZE"                  ,

   ulSTRESS_RAND                       ,  "STRESS_RAND"                       ,
   ulSTRESS_SMALL                      ,  "STRESS_SMALL"                      ,
   ulSTRESS_ZEROS                      ,  "STRESS_ZEROS"                      ,
   ulSTRESS_ONES                       ,  "STRESS_ONES"                       ,

   ulSTRESS_FULLRESP                   ,  "STRESS_FULLRESP"                   ,
   ulSTRESS_NORESP                     ,  "STRESS_NORESP"                     ,
   ulSTRESS_ACK                        ,  "STRESS_ACK"                        ,
   ulSTRESS_ACK10                      ,  "STRESS_ACK10"                      ,

   ulSTRESS_WINDOW_ON                  ,  "STRESS_WINDOWING_ON"               ,
   ulSTRESS_WINDOW_OFF                 ,  "STRESS_WINDOWING_OFF"              ,

   //
   // perform test-type constants
   //
   ulPERFORM_VERIFYRECEIVES            ,  "PERFORM_VERIFY_RECEIVES"           ,
   ulPERFORM_INDICATE_RCV              ,  "PERFORM_INDICATE_RECEIVES"         ,
   ulPERFORM_SEND                      ,  "PERFORM_SEND"                      ,
   ulPERFORM_BOTH                      ,  "PERFORM_SEND_AND_RECEIVE"          ,
   ulPERFORM_RECEIVE                   ,  "PERFORM_RECEIVE"                   ,

   //
   // priority test-type constants
   //
   ulPRIORITY_TYPE_802_3               ,  "PRIORITY_TYPE_802_3"               ,
   ulPRIORITY_TYPE_802_1P              ,  "PRIORITY_TYPE_802_1P"              ,
   ulPRIORITY_SEND                     ,  "PRIORITY_SEND"                     ,
   ulPRIORITY_SEND_PACKETS             ,  "PRIORITY_SEND_PACKETS"             ,



   //
   // receive option constants
   //
   ulRECEIVE_DEFAULT                   ,  "RECEIVE_DEFAULT"                   ,
   ulRECEIVE_PACKETIGNORE              ,  "RECEIVE_PACKETIGNORE"              ,
   ulRECEIVE_NOCOPY                    ,  "RECEIVE_NOCOPY"                    ,
   ulRECEIVE_TRANSFER                  ,  "RECEIVE_TRANSFER"                  ,
   ulRECEIVE_PARTIAL_TRANSFER          ,  "RECEIVE_PARTIAL_TRANSFER"          ,
   ulRECEIVE_LOCCOPY                   ,  "RECEIVE_LOCCOPY"                   ,
   ulRECEIVE_QUEUE                     ,  "RECEIVE_QUEUE"                     ,
   ulRECEIVE_DOUBLE_QUEUE              ,  "RECEIVE_DOUBLE_QUEUE"              ,
   ulRECEIVE_TRIPLE_QUEUE              ,  "RECEIVE_TRIPLE_QUEUE"              ,
   ulMAX_NDIS30_RECEIVE_OPTION         ,  "MAX_NDIS30_RECEIVE_OPTION"         ,
   ulMAX_NDIS40_RECEIVE_OPTION         ,  "MAX_NDIS40_RECEIVE_OPTION"         ,
   ulRECEIVE_ALLOW_BUSY_NET            ,  "RECEIVE_ALLOW_BUSY_NET"            ,

   //
   // Ndis MAC option bits (OID_GEN_MAC_OPTIONS).
   //

   NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA ,  "NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA"  ,
   NDIS_MAC_OPTION_RECEIVE_SERIALIZED  ,  "NDIS_MAC_OPTION_RECEIVE_SERIALIZED",
   NDIS_MAC_OPTION_TRANSFERS_NOT_PEND  ,  "NDIS_MAC_OPTION_TRANSFERS_NOT_PEND",
   NDIS_MAC_OPTION_NO_LOOPBACK         ,  "NDIS_MAC_OPTION_NO_LOOPBACK"       ,
   NDIS_MAC_OPTION_FULL_DUPLEX         ,  "NDIS_MAC_OPTION_FULL_DUPLEX"       ,
   NDIS_MAC_OPTION_EOTX_INDICATION     ,  "NDIS_MAC_OPTION_EOTX_INDICATION"   ,

   //
   // NDIS.SYS versions
   //
   ulNDIS_VERSION_40                   ,  "NDIS_VERSION_4_0"                  ,
   ulNDIS_VERSION_50                   ,  "NDIS_VERSION_5_0"                  ,

   //
   // operating system constants
   //
   ulINVALID_OS                        ,  "INVALID_OPERATING_SYSTEM"          ,
   ulWINDOWS_NT                        ,  "WINDOWS_NT"                        ,
   ulWINDOWS_95                        ,  "WINDOWS_95"                        ,

   //
   // service types for flowspec
   //
   SERVICETYPE_NOTRAFFIC               ,  "NO_TRAFFIC"                        ,
   SERVICETYPE_BESTEFFORT              ,  "BEST_EFFORT"                       ,
   SERVICETYPE_CONTROLLEDLOAD          ,  "CONTROLLED_LOAD"                   ,
   SERVICETYPE_GUARANTEED              ,  "GUARANTEED"                        ,

   //
   // service types for flowspec
   //
   SERVICETYPE_NOTRAFFIC               ,  "NO_TRAFFIC"                        ,
   SERVICETYPE_BESTEFFORT              ,  "BEST_EFFORT"                       ,
   SERVICETYPE_CONTROLLEDLOAD          ,  "CONTROLLED_LOAD"                   ,
   SERVICETYPE_GUARANTEED              ,  "GUARANTEED"                        ,

   //
   // address families
   //
   0x01                                ,  "ADDRESS_FAMILY_Q2931"              ,
   0x08000                             ,  "ADDRESS_FAMILY_PROXY"              ,

   //
   // atm supported service types
   //
   ATM_SERVICE_CATEGORY_CBR            ,  "CONSTANT_BIT_RATE"                 ,
   ATM_SERVICE_CATEGORY_VBR            ,  "VARIABLE_BIT_RATE"                 ,
   ATM_SERVICE_CATEGORY_UBR            ,  "UNSPECIFIED_BIT_RATE"              ,
   ATM_SERVICE_CATEGORY_ABR            ,  "AVAILABLE_BIT_RATE"                ,

   //
   // AAL TYPES
   //
   AAL_TYPE_AAL0                       ,  "AAL_TYPE_AAL0"                     ,
   AAL_TYPE_AAL1                       ,  "AAL_TYPE_AAL1"                     ,
   AAL_TYPE_AAL34                      ,  "AAL_TYPE_AAL34"                    ,
   AAL_TYPE_AAL5                       ,  "AAL_TYPE_AAL5"                     ,

   //
   // wake up types (used with enablewakeup
   //
   NDIS_PNP_WAKE_UP_MAGIC_PACKET       ,  "WAKE_UP_MAGIC_PACKET"              ,
   NDIS_PNP_WAKE_UP_PATTERN_MATCH      ,  "WAKE_UP_PATTERN_MATCH"             ,
   NDIS_PNP_WAKE_UP_LINK_CHANGE        ,  "WAKE_UP_LINK_CHANGE"               ,

   //
   // ndis status definitions (used with startwaitforevent)
   //
   NDIS_STATUS_RESET_START             ,  "NDIS_STATUS_RESET_START"           ,
   NDIS_STATUS_RESET_END               ,  "NDIS_STATUS_RESET_END"             ,
   NDIS_STATUS_MEDIA_CONNECT           ,  "NDIS_STATUS_MEDIA_CONNECT"         ,
   NDIS_STATUS_MEDIA_DISCONNECT        ,  "NDIS_STATUS_MEDIA_DISCONNECT"      ,
   NDIS_STATUS_WAN_LINE_UP             ,  "NDIS_STATUS_WAN_LINE_UP"           ,
   NDIS_STATUS_WAN_LINE_DOWN           ,  "NDIS_STATUS_WAN_LINE_DOWN"         ,
   NDIS_STATUS_HARDWARE_LINE_UP        ,  "NDIS_STATUS_HARDWARE_LINE_UP"      ,
   NDIS_STATUS_HARDWARE_LINE_DOWN      ,  "NDIS_STATUS_HARDWARE_LINE_DOWN"    ,
   NDIS_STATUS_INTERFACE_UP            ,  "NDIS_STATUS_INTERFACE_UP"          ,
   NDIS_STATUS_INTERFACE_DOWN          ,  "NDIS_STATUS_INTERFACE_DOWN"        ,

   //
   // values in bitmask returned for getpowerstates
   //
   ulHIBERNATE                         ,  "HIBERNATE_SUPPORTED"               ,
   ulSTANDBY                           ,  "STANDBY_SUPPORTED"                 ,
   ulWAKEUPTIMER                       ,  "WAKEUP_TIMER_SUPPORTED"            ,
   //
   // script constants, for which set of tests to do
   // (used in value for G_TestOptions) -- bitmap
   //
   0x00000001                          ,  "DO_FUNCTIONAL_TESTS"               ,
   0x00000002                          ,  "DO_STRESS_TESTS"                   ,
   0x00000004                          ,  "DO_PERFORMANCE_TESTS"              ,
   0x00000008                          ,  "DO_HCT_TESTS"                      ,
   0x00000010                          ,  "DO_RUNTEST"                        ,
   0x00010000                          ,  "ENABLE_VERBOSE_FLAG"               ,
   0x00020000                          ,  "SKIP_1CARD_TESTS"                  ,

#ifdef   BROADCAST_PC
   BPC_MIN_DIM                         ,  "BPC_MIN_DIM"                       ,
#endif

   //
   // end of constants
   //
   0,  0,
};



typedef struct   OID_GUID
{
   ULONG    ulOid;
   const
   GUID     *pGuid;
} OID_GUID;

//
// Max number of OIDs for which a GUID is defined
//

#define MAX_GEN_OID_GUID         25
#define MAX_ETH_OID_GUID          8
#define MAX_TRING_OID_GUID        9
#define MAX_FDDI_OID_GUID        17

//
// Starting position of OIDs for a particular media in pLanOidGuidList array
//
#define ETH_START_INDEX           26
#define TRING_START_INDEX         34
#define FDDI_START_INDEX          43
//
// Media  supported by the card and the count of the no of medium
//

#define MAX_NO_OF_MEDIUM 10
PNDIS_MEDIUM WhichMediums;
int SupportedMediumCount;

//
// GUID list for LAN media
//
OID_GUID pLanOidGuidList[] = {
//
// required general info
//
   OID_GEN_HARDWARE_STATUS       ,  &GUID_NDIS_GEN_HARDWARE_STATUS      ,
   OID_GEN_MEDIA_SUPPORTED       ,  &GUID_NDIS_GEN_MEDIA_SUPPORTED      ,
   OID_GEN_MEDIA_IN_USE          ,  &GUID_NDIS_GEN_MEDIA_IN_USE         ,
   OID_GEN_MAXIMUM_LOOKAHEAD     ,  &GUID_NDIS_GEN_MAXIMUM_LOOKAHEAD    ,
   OID_GEN_MAXIMUM_FRAME_SIZE    ,  &GUID_NDIS_GEN_MAXIMUM_FRAME_SIZE   ,
   OID_GEN_LINK_SPEED            ,  &GUID_NDIS_GEN_LINK_SPEED           ,
   OID_GEN_TRANSMIT_BUFFER_SPACE ,  &GUID_NDIS_GEN_TRANSMIT_BUFFER_SPACE,
   OID_GEN_RECEIVE_BUFFER_SPACE  ,  &GUID_NDIS_GEN_RECEIVE_BUFFER_SPACE ,
   OID_GEN_TRANSMIT_BLOCK_SIZE   ,  &GUID_NDIS_GEN_TRANSMIT_BLOCK_SIZE  ,
   OID_GEN_RECEIVE_BLOCK_SIZE    ,  &GUID_NDIS_GEN_RECEIVE_BLOCK_SIZE   ,
   OID_GEN_VENDOR_ID             ,  &GUID_NDIS_GEN_VENDOR_ID            ,
   OID_GEN_VENDOR_DESCRIPTION    ,  &GUID_NDIS_GEN_VENDOR_DESCRIPTION   ,
   OID_GEN_CURRENT_PACKET_FILTER ,  &GUID_NDIS_GEN_CURRENT_PACKET_FILTER,
   OID_GEN_CURRENT_LOOKAHEAD     ,  &GUID_NDIS_GEN_CURRENT_LOOKAHEAD    ,
   OID_GEN_DRIVER_VERSION        ,  &GUID_NDIS_GEN_DRIVER_VERSION       ,
   OID_GEN_MAXIMUM_TOTAL_SIZE    ,  &GUID_NDIS_GEN_MAXIMUM_TOTAL_SIZE   ,
   OID_GEN_MAC_OPTIONS           ,  &GUID_NDIS_GEN_MAC_OPTIONS          ,
   OID_GEN_MEDIA_CONNECT_STATUS  ,  &GUID_NDIS_GEN_MEDIA_CONNECT_STATUS ,
   OID_GEN_MAXIMUM_SEND_PACKETS  ,  &GUID_NDIS_GEN_MAXIMUM_SEND_PACKETS ,
   OID_GEN_VENDOR_DRIVER_VERSION ,  &GUID_NDIS_GEN_VENDOR_DRIVER_VERSION,
//
// Required general statistics
//
   OID_GEN_XMIT_OK               ,  &GUID_NDIS_GEN_XMIT_OK              ,
   OID_GEN_RCV_OK                ,  &GUID_NDIS_GEN_RCV_OK               ,
   OID_GEN_XMIT_ERROR            ,  &GUID_NDIS_GEN_XMIT_ERROR           ,
   OID_GEN_RCV_ERROR             ,  &GUID_NDIS_GEN_RCV_ERROR            ,
   OID_GEN_RCV_NO_BUFFER         ,  &GUID_NDIS_GEN_RCV_NO_BUFFER        ,
//
// ethernet information
//
   OID_802_3_PERMANENT_ADDRESS      ,  &GUID_NDIS_802_3_PERMANENT_ADDRESS  ,
   OID_802_3_CURRENT_ADDRESS        ,  &GUID_NDIS_802_3_CURRENT_ADDRESS    ,
   OID_802_3_MULTICAST_LIST         ,  &GUID_NDIS_802_3_MULTICAST_LIST     ,
   OID_802_3_MAXIMUM_LIST_SIZE      ,  &GUID_NDIS_802_3_MAXIMUM_LIST_SIZE  ,
   OID_802_3_MAC_OPTIONS            ,  &GUID_NDIS_802_3_MAC_OPTIONS        ,
//
// ethernet statistics
//
   OID_802_3_RCV_ERROR_ALIGNMENT    ,  &GUID_NDIS_802_3_RCV_ERROR_ALIGNMENT,
   OID_802_3_XMIT_ONE_COLLISION     ,  &GUID_NDIS_802_3_XMIT_ONE_COLLISION ,
   OID_802_3_XMIT_MORE_COLLISIONS   ,  &GUID_NDIS_802_3_XMIT_MORE_COLLISIONS  ,
//
// Token-Ring info
//
   OID_802_5_PERMANENT_ADDRESS      ,  &GUID_NDIS_802_5_PERMANENT_ADDRESS  ,
   OID_802_5_CURRENT_ADDRESS        ,  &GUID_NDIS_802_5_CURRENT_ADDRESS    ,
   OID_802_5_CURRENT_FUNCTIONAL     ,  &GUID_NDIS_802_5_CURRENT_FUNCTIONAL ,
   OID_802_5_CURRENT_GROUP          ,  &GUID_NDIS_802_5_CURRENT_GROUP      ,
   OID_802_5_LAST_OPEN_STATUS       ,  &GUID_NDIS_802_5_LAST_OPEN_STATUS   ,
   OID_802_5_CURRENT_RING_STATUS    ,  &GUID_NDIS_802_5_CURRENT_RING_STATUS,
   OID_802_5_CURRENT_RING_STATE     ,  &GUID_NDIS_802_5_CURRENT_RING_STATE ,
//
// token ring statistics
//
   OID_802_5_LINE_ERRORS            ,  &GUID_NDIS_802_5_LINE_ERRORS        ,
   OID_802_5_LOST_FRAMES            ,  &GUID_NDIS_802_5_LOST_FRAMES        ,
//
// FDDI information
//
   OID_FDDI_LONG_PERMANENT_ADDR     ,  &GUID_NDIS_FDDI_LONG_PERMANENT_ADDR ,
   OID_FDDI_LONG_CURRENT_ADDR       ,  &GUID_NDIS_FDDI_LONG_CURRENT_ADDR   ,
   OID_FDDI_LONG_MULTICAST_LIST     ,  &GUID_NDIS_FDDI_LONG_MULTICAST_LIST ,
   OID_FDDI_LONG_MAX_LIST_SIZE      ,  &GUID_NDIS_FDDI_LONG_MAX_LIST_SIZE  ,
   OID_FDDI_SHORT_PERMANENT_ADDR    ,  &GUID_NDIS_FDDI_SHORT_PERMANENT_ADDR,
   OID_FDDI_SHORT_CURRENT_ADDR      ,  &GUID_NDIS_FDDI_SHORT_CURRENT_ADDR  ,
   OID_FDDI_SHORT_MULTICAST_LIST    ,  &GUID_NDIS_FDDI_SHORT_MULTICAST_LIST,
   OID_FDDI_SHORT_MAX_LIST_SIZE     ,  &GUID_NDIS_FDDI_SHORT_MAX_LIST_SIZE ,
//
// FDDI statistics
//

   OID_FDDI_ATTACHMENT_TYPE         ,  &GUID_NDIS_FDDI_ATTACHMENT_TYPE     ,
   OID_FDDI_UPSTREAM_NODE_LONG      ,  &GUID_NDIS_FDDI_UPSTREAM_NODE_LONG  ,
   OID_FDDI_DOWNSTREAM_NODE_LONG    ,  &GUID_NDIS_FDDI_DOWNSTREAM_NODE_LONG,
   OID_FDDI_FRAME_ERRORS            ,  &GUID_NDIS_FDDI_FRAME_ERRORS        ,
   OID_FDDI_FRAMES_LOST             ,  &GUID_NDIS_FDDI_FRAMES_LOST         ,
   OID_FDDI_RING_MGT_STATE          ,  &GUID_NDIS_FDDI_RING_MGT_STATE      ,
   OID_FDDI_LCT_FAILURES            ,  &GUID_NDIS_FDDI_LCT_FAILURES        ,
   OID_FDDI_LEM_REJECTS             ,  &GUID_NDIS_FDDI_LEM_REJECTS         ,
   OID_FDDI_LCONNECTION_STATE       ,  &GUID_NDIS_FDDI_LCONNECTION_STATE   ,
};

//
// GUID list for ATM (CoNdis) media
//
OID_GUID    pAtmOidGuidList[] = {
//
// required CoNdis info
//
   OID_GEN_CO_HARDWARE_STATUS    ,  &GUID_NDIS_GEN_CO_HARDWARE_STATUS   ,
   OID_GEN_CO_MEDIA_SUPPORTED    ,  &GUID_NDIS_GEN_CO_MEDIA_SUPPORTED   ,
   OID_GEN_CO_MEDIA_IN_USE       ,  &GUID_NDIS_GEN_CO_MEDIA_IN_USE      ,
   OID_GEN_CO_LINK_SPEED         ,  &GUID_NDIS_GEN_CO_LINK_SPEED        ,
   OID_GEN_CO_VENDOR_ID          ,  &GUID_NDIS_GEN_CO_VENDOR_ID         ,
   OID_GEN_CO_VENDOR_DESCRIPTION ,  &GUID_NDIS_GEN_CO_VENDOR_DESCRIPTION   ,
   OID_GEN_CO_DRIVER_VERSION     ,  &GUID_NDIS_GEN_CO_DRIVER_VERSION    ,
   OID_GEN_CO_MAC_OPTIONS        ,  &GUID_NDIS_GEN_CO_MAC_OPTIONS       ,
   OID_GEN_CO_MEDIA_CONNECT_STATUS, &GUID_NDIS_GEN_CO_MEDIA_CONNECT_STATUS ,
   OID_GEN_CO_VENDOR_DRIVER_VERSION,&GUID_NDIS_GEN_CO_VENDOR_DRIVER_VERSION,
   OID_GEN_CO_MINIMUM_LINK_SPEED ,  &GUID_NDIS_GEN_CO_MINIMUM_LINK_SPEED,
//
// required condis stats
//
   OID_GEN_CO_XMIT_PDUS_OK       ,  &GUID_NDIS_GEN_CO_XMIT_PDUS_OK         ,
   OID_GEN_CO_RCV_PDUS_OK        ,  &GUID_NDIS_GEN_CO_RCV_PDUS_OK          ,
   OID_GEN_CO_XMIT_PDUS_ERROR    ,  &GUID_NDIS_GEN_CO_XMIT_PDUS_ERROR      ,
   OID_GEN_CO_RCV_PDUS_ERROR     ,  &GUID_NDIS_GEN_CO_RCV_PDUS_ERROR       ,
   OID_GEN_CO_RCV_PDUS_NO_BUFFER ,  &GUID_NDIS_GEN_CO_RCV_PDUS_NO_BUFFER   ,

//
// ATM information
//
   OID_ATM_SUPPORTED_VC_RATES       ,  &GUID_NDIS_ATM_SUPPORTED_VC_RATES   ,
   OID_ATM_SUPPORTED_SERVICE_CATEGORY, &GUID_NDIS_ATM_SUPPORTED_SERVICE_CATEGORY ,
   OID_ATM_SUPPORTED_AAL_TYPES      ,  &GUID_NDIS_ATM_SUPPORTED_AAL_TYPES  ,
   OID_ATM_HW_CURRENT_ADDRESS       ,  &GUID_NDIS_ATM_HW_CURRENT_ADDRESS   ,
   OID_ATM_MAX_ACTIVE_VCS           ,  &GUID_NDIS_ATM_MAX_ACTIVE_VCS       ,
   OID_ATM_MAX_ACTIVE_VCI_BITS      ,  &GUID_NDIS_ATM_MAX_ACTIVE_VCI_BITS  ,
   OID_ATM_MAX_ACTIVE_VPI_BITS      ,  &GUID_NDIS_ATM_MAX_ACTIVE_VPI_BITS  ,
   OID_ATM_MAX_AAL0_PACKET_SIZE     ,  &GUID_NDIS_ATM_MAX_AAL0_PACKET_SIZE ,
   OID_ATM_MAX_AAL1_PACKET_SIZE     ,  &GUID_NDIS_ATM_MAX_AAL1_PACKET_SIZE ,
   OID_ATM_MAX_AAL34_PACKET_SIZE    ,  &GUID_NDIS_ATM_MAX_AAL34_PACKET_SIZE,
   OID_ATM_MAX_AAL5_PACKET_SIZE     ,  &GUID_NDIS_ATM_MAX_AAL5_PACKET_SIZE ,
//
// ATM STATS
//
   OID_ATM_RCV_CELLS_OK             ,  &GUID_NDIS_ATM_RCV_CELLS_OK         ,
   OID_ATM_XMIT_CELLS_OK            ,  &GUID_NDIS_ATM_XMIT_CELLS_OK        ,
   OID_ATM_RCV_CELLS_DROPPED        ,  &GUID_NDIS_ATM_RCV_CELLS_DROPPED
};


//
// GUID list for status indications
//
OID_GUID    pStatusGuidList[] = {

   NDIS_STATUS_RESET_START          ,  &GUID_NDIS_STATUS_RESET_START       ,
   NDIS_STATUS_RESET_END            ,  &GUID_NDIS_STATUS_RESET_END         ,
   NDIS_STATUS_MEDIA_CONNECT        ,  &GUID_NDIS_STATUS_MEDIA_CONNECT     ,
   NDIS_STATUS_MEDIA_DISCONNECT     ,  &GUID_NDIS_STATUS_MEDIA_DISCONNECT  ,
   NDIS_STATUS_MEDIA_SPECIFIC_INDICATION  ,  &GUID_NDIS_STATUS_MEDIA_SPECIFIC_INDICATION,
   NDIS_STATUS_LINK_SPEED_CHANGE    ,  &GUID_NDIS_STATUS_LINK_SPEED_CHANGE
};


const ULONG ulStatusListSize = sizeof(pStatusGuidList) / sizeof(OID_GUID);
HINSTANCE         hNdtWmiLib;

WMI_OPEN          pWmiOpenBlock;
WMI_CLOSE         pWmiCloseBlock;
WMI_QUERYALL      pWmiQueryAllData;
WMI_QUERYSINGLE   pWmiQuerySingleInstance;
WMI_NOTIFY        pWmiNotificationRegistration;

#define ulNETWORK_ADDRESS_LENGTH        6
#define ulMAX_INFOBUFFER_BYTES         (ulNETWORK_ADDRESS_LENGTH * 256)


BOOLEAN        gfUseCoNdisOids = FALSE;

#define ulFUNCTIONAL_ADDRESS_LENGTH     4

#define ulOID_STATS_MASK      0x00030000
#define ulOID_QUERYSMT        0x00030000


struct   NETADDR
{
   UCHAR    padrNet[ulNETWORK_ADDRESS_LENGTH];
   UCHAR    ucSubType;
};


typedef struct NETADDR   *PNETADDR;


#define ulNumGenOids       45
#define ulNumEthOids       15
#define ulNumTrOids        16
#define ulNumFddiOids      158
#define ulNumArcnetOids    3
#define ulNumAtmOids       26
#define ulNumWirelessOids  57
#define ulNumIrdaOids      11
#define ulNumCoGenOids     28
#define ulNumNdisWanOids   15
#define ulNumPnpOids       9

CONSTANT_ENTRY *pceOidEntry = &NdisTestConstantTable[0];
ULONG          ulOidEntryLength  = ulNumGenOids
                                 + ulNumEthOids
                                 + ulNumTrOids
                                 + ulNumFddiOids
                                 + ulNumArcnetOids
                                 + ulNumAtmOids
                                 + ulNumNdisWanOids
                                 + ulNumWirelessOids
#ifdef   BROADCAST_PC
                                 + ulNumDssOids
#endif
                                 + ulNumPnpOids
                                 + ulNumIrdaOids;

CONSTANT_ENTRY *pceCoOidEntry = &NdisTestConstantTable[ulNumGenOids];
ULONG          ulCoOidEntryLength = ulNumCoGenOids
                                  + ulNumEthOids
                                  + ulNumTrOids
                                  + ulNumFddiOids
                                  + ulNumArcnetOids
                                  + ulNumAtmOids
                                  + ulNumNdisWanOids
                                  + ulNumWirelessOids
#ifdef   BROADCAST_PC
                                  + ulNumDssOids
#endif
                                  + ulNumPnpOids
                                  + ulNumIrdaOids;


#define ulNEED_TYPE_INVALID   0
#define ulNEED_FUNCT_ADDR     1
#define ulNEED_FULL_ADDR      2
#define ulNEED_WORD           3
#define ulNEED_DWORD          4
#define ulNEED_ARCNET_ADDR    5
#define ulNEED_SHORT_ADDR     6
#define ulNEED_GUID           7

#define ulELEMENT_ARG         3

//
// OID-related constants
// most significant byte = media type
//


#define ulOID_MEDIA_MASK      0xFF000000
#define ulOID_ALL_MEDIA       0x00000000
#define ulOID_ETHERNET        0x01000000
#define ulOID_TOKENRING       0x02000000
#define ulOID_FDDI            0x03000000
#define ulOID_ARCNET          0x06000000
#define ulOID_ATM             0x08000000
#define ulOID_WIRELESSWAN     0x09000000
#define ulOID_IRDA            0x0A000000
#define ulOID_PNP_POWER       0xFD000000
#define ulOID_PRIVATE         0xFF000000

#ifdef   BROADCAST_PC
#define ulMEDIUM_DIX          0x09
#endif


#define  NDT_STATUS_NO_SERVERS            ((NDIS_STATUS)0x4001FFFFL)
#define  NDT_STATUS_TIMEDOUT              ((NDIS_STATUS)0x4001FFFDL)

//
// Sturctures used in looking up what media specific oids must be queried
//

typedef struct _MEDIA_OID_TABLE {
  NDIS_MEDIUM medium;
  int         start_index; // starting index of the media specific oids in pLanOidGuidList
  int         max_oids;
} MEDIA_OID_TABLE, *PMEDIA_OID_TABLE;

MEDIA_OID_TABLE pMediaOidTable[] = {
//  medium, starting position in the array, max no of oids
    NdisMedium802_3, ETH_START_INDEX, MAX_ETH_OID_GUID,
    NdisMedium802_5, TRING_START_INDEX, MAX_TRING_OID_GUID,
    NdisMediumFddi, FDDI_START_INDEX, MAX_FDDI_OID_GUID,
};

#define MAX_MEDIA_OID_TABLE_ENTRY            3

/*=========================< ndis test - macros >============================*/

#define PRINT(_args_)                  \
   {                                   \
         HapiPrint _args_;             \
   }

#define  IS_NETADDR(arg)    (argv[arg]->ulTypeId == ulNETADDR_TYPE)   
    

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\netdiag.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       netdiag.h
//
//--------------------------------------------------------------------------

#ifndef HEADER_NETDIAG
#define HEADER_NETDIAG


//////////////////////////////////////////////////////////////////////////////
//
// Constants particular to the current NT development environment
//
//////////////////////////////////////////////////////////////////////////////

//
// Developers responsible for tested portions of NT
//

#define NET_GURU     "[Contact NSun]"
#define DHCP_GURU    "[Contact ThiruB/RameshV]"
#define TCPIP_GURU   "[Contact PradeepB]"
#define NETBT_GURU   "[Contact MAlam]"
#define WINSOCK_GURU "[Contact KarolyS]"
#define REDIR_GURU   "[Contact SethuR]"
#define BOWSER_GURU  "[Contact CliffV]"
#define DNS_GURU     "[Contact DnsDev]"
#define SAM_GURU     "[Contact MurliS]"
#define LSA_GURU     "[Contact MacM]"
#define DSGETDC_GURU "[Contact CliffV]"
#define NETLOGON_GURU "[Contact CliffV]"
#define KERBEROS_GURU "[Contact ChandanS]"
#define NTLM_GURU     "[Contact ChandanS]"
#define LDAP_GURU     "[Contact AnoopA]"

//////////////////////////////////////////////////////////////////////////////
//
// Constants particular to the current version of NT.
//
//////////////////////////////////////////////////////////////////////////////

#define NETBT_DEVICE_PREFIX L"\\device\\Netbt_tcpip_{"

//
// Complain about pre-IDW builds
//
#define NTBUILD_IDW 1716
#define NTBUILD_DYNAMIC_DNS 1716
#define NTBUILD_BOWSER 1716
#define NTBUILD_DNSSERVERLIST 1728


//
// New functions for displaying routing table - Rajkumar
//

#define WILD_CARD (ULONG)(-1)
#define ROUTE_DATA_STRING_SIZE 300
#define NTOA(STR,ADDR)                                         \
             strncpy( STR,                                     \
                      inet_ntoa(*(struct in_addr*)(&(ADDR))),  \
                      sizeof(STR)-1 )

#ifdef _UNICODE
#define INET_ADDR(_sz)	inet_addrW(_sz)
#else
#define INET_ADDR(_sz)	inet_addrA(_swz)
#endif

ULONG inet_addrW(LPCWSTR pswz);
#define inet_addrA(_psz)	inet_addr(_psz)



#define MAX_METRIC 9999
#define ROUTE_SEPARATOR ','

#define MAX_CONTACT_STRING 256

// Some winsock defines


//////////////////////////////////////////////////////////////////////////////
//
// Globals
//
//////////////////////////////////////////////////////////////////////////////

//extern BOOL IpConfigCalled;
//extern BOOL ProblemBased;
extern int  ProblemNumber;

//
// This has been made global so that we dump the information in WinsockTest - Rajkumar
//

//extern WSADATA wsaData;

//extern PFIXED_INFO GlobalIpconfigFixedInfo;
//extern PADAPTER_INFO GlobalIpconfigAdapterInfo;
//extern PIP_ADAPTER_INFO IpGlobalIpconfigAdapterInfo;

//extern BOOLEAN GlobalDhcpEnabled;

//
// Structure describing a single Netbt Transport
//


//extern LIST_ENTRY GlobalNetbtTransports;


//extern LIST_ENTRY GlobalTestedDomains;



//
// Globals defining the command line arguments.
//

//extern BOOL Verbose;
extern BOOL ReallyVerbose;
//extern BOOL DebugVerbose;
//extern BOOL GlobalFixProblems;
//extern BOOL GlobalDcAccountEnum;

extern PTESTED_DOMAIN GlobalQueriedDomain;

//
// Describe the domain this machine is a member of
//

//extern int GlobalNtBuildNumber;
//extern PDSROLE_PRIMARY_DOMAIN_INFO_BASIC GlobalDomainInfo;
//extern PTESTED_DOMAIN GlobalMemberDomain;

//
// Who we're currently logged on as
//

//extern PUNICODE_STRING GlobalLogonUser;
//extern PUNICODE_STRING GlobalLogonDomainName;
//extern PTESTED_DOMAIN GlobalLogonDomain;
//extern BOOLEAN GlobalLogonWithCachedCredentials;

//
// A Zero GUID for comparison
//

extern GUID NlDcZeroGuid;

//
// State determined by previous tests
//

//extern BOOL GlobalNetlogonIsRunning;   // Netlogon is running on this machine
//extern BOOL GlobalKerberosIsWorking;   // Kerberos is working

//
// Netbios name of this machine
//

//extern WCHAR GlobalNetbiosComputerName[MAX_COMPUTERNAME_LENGTH+1];
//extern CHAR GlobalDnsHostName[DNS_MAX_NAME_LENGTH+1];
//extern LPSTR GlobalDnsDomainName;

// Commented out to port to Source Depot - smanda
#ifdef SLM_TREE
extern DSGETDCNAMEW NettestDsGetDcNameW;
#else
extern DSGETDCNAMEW DsGetDcNameW;
#endif

void PrintMessage(NETDIAG_PARAMS *pParams, UINT uMessageID, ...);
void PrintMessageSz(NETDIAG_PARAMS *pParams, LPCTSTR pszMessage);

int match( const char * p, const char * s );

//only used in Kerberos test so far
VOID sPrintTime(LPSTR str, LARGE_INTEGER ConvertTime);

DWORD LoadContact(LPCTSTR pszTestName, LPTSTR pszContactInfo, DWORD cChSize);

NET_API_STATUS IsServiceStarted(IN LPTSTR pszServiceName);

VOID PrintSid(IN NETDIAG_PARAMS *pParams, IN PSID Sid OPTIONAL);

LPSTR MapTime(DWORD_PTR TimeVal);

#ifdef _UNICODE
#define IsIcmpResponse(_psz)	IsIcmpResponseW(_psz)
#else
#define IsIcmpResponse(_psz)	IsIcmpResponseA(_psz)
#endif

BOOL IsIcmpResponseW(LPCWSTR pswzIpAddrStr);
BOOL IsIcmpResponseA(LPCSTR	pszIpAddrStr);

PTESTED_DOMAIN
AddTestedDomain(
                IN NETDIAG_PARAMS *pParams,
                IN NETDIAG_RESULT *pResults,
                IN LPWSTR pswzNetbiosDomainName,
                IN LPWSTR pswzDnsDomainName,
                IN BOOL bPrimaryDomain
    );


//used in DCListTest and TrustTest
NTSTATUS NettestSamConnect(
                  IN NETDIAG_PARAMS *pParams,
                  IN LPWSTR DcName,
                  OUT PSAM_HANDLE SamServerHandle
                 );

/*---------------------------------------------------------------------------
	Misc. utilities
 ---------------------------------------------------------------------------*/
HRESULT	GetComputerNameInfo(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults);
HRESULT GetDNSInfo(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults);
HRESULT GetNetBTParameters(IN NETDIAG_PARAMS *pParams,
						   IN OUT NETDIAG_RESULT *pResults);
LPTSTR NetStatusToString( NET_API_STATUS NetStatus );
LPTSTR Win32ErrorToString(DWORD Id);

#define DimensionOf(rg)	(sizeof(rg) / sizeof(*rg))



/*---------------------------------------------------------------------------
	Error handling utilities
 ---------------------------------------------------------------------------*/
#define CheckHr(x) \
	if ((hr = (x)) & (0x80000000)) \
	   goto Error;

#define CheckErr(x) \
	if ((hr = HResultFromWin32(x)) & (0x80000000)) \
		goto Error;

HRESULT HResultFromWin32(DWORD dwErr);

#define FHrSucceeded(hr)	SUCCEEDED(hr)
#define FHrOK(hr)			((hr) == S_OK)
#define FHrFailed(hr)		FAILED(hr)

#define hrOK	S_OK

// if hr failed, assign hr and ids contect to the structure, and goto L_ERR
#define CHK_HR_CONTEXT(w, h, IDS){	\
	if (FAILED(h))	{\
	(w).hr = (h), (w).idsContext = (IDS); goto L_ERR;}}


/*!--------------------------------------------------------------------------
	FormatError
		This function will lookup the error message associated with
		the HRESULT.
	Author: KennT
 ---------------------------------------------------------------------------*/
void FormatError(HRESULT hr, TCHAR *pszBuffer, UINT cchBuffer);
void FormatWin32Error(DWORD dwErr, TCHAR *pszBuffer, UINT cchBuffer);




/*---------------------------------------------------------------------------
	Tracing utilites
 ---------------------------------------------------------------------------*/

void TraceBegin();
void TraceEnd();
void TraceError(LPCSTR pszString, HRESULT hr);
void TraceResult(LPCSTR pszString, HRESULT hr);
void TraceSz(LPCSTR pszString);



/*---------------------------------------------------------------------------
	Character utilities
 ---------------------------------------------------------------------------*/
LPTSTR MapGuidToAdapterName(LPCTSTR AdapterGuid);
LPTSTR MapGuidToServiceName(LPCTSTR AdapterGuid);
LPWSTR MapGuidToServiceNameW(LPCWSTR AdapterGuid);


/*---------------------------------------------------------------------------
	Memory allocation utilities
 ---------------------------------------------------------------------------*/
#define Malloc(_cb)		malloc(_cb)
#define Realloc(_pv, _cb)	realloc(_pv, _cb)
#define Free(_pv)		free(_pv)


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\nstest.h ===
/*++
Copyright (C) Microsoft Corporation, 1999 - 1999 

Module Name:

   nstest.h

Abstract:

   Header file for netstat test.

Author:
   
   4-Aug-1998 Rajkumar ( 08/04/98 ).
++*/

#ifndef HEADER_NSTEST
#define HEADER_NSTEST

#include <snmp.h>

#include "common2.h"
#include "tcpinfo.h"
#include "ipinfo.h"
//#include "tcpcmd.h"
#include "llinfo.h"

/*==========================<Function prototypes>=============================*/




#define MAX_HOST_NAME_SIZE        ( 260)
#define MAX_SERVICE_NAME_SIZE     ( 200)

extern BOOL NumFlag = FALSE;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\nwtest.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      nwtest.c
//
//  Abstract:
//
//      Queries into network drivers
//
//  Author:
//
//      Anilth	- 4-20-1998
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//--
#include "precomp.h"
#include "nwtest.h"

HRESULT
NetwareTest(NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
//++
//
//   Description:
//   This routine enumerates bindery or tree logins and in the case of tree login gives the
//   default context.
//   It also gets the server attached to.
//
//   Argument:
//   None.
//
//   Author:
//   Rajkumar .P 07/21/98
//
{
//    PTESTED_DOMAIN Context = pParams->pDomain;

    LPWSTR pszCurrentContext = NULL;
    DWORD dwPrintOptions;

    LPWSTR pszName;
    WCHAR  szUserName[MAX_PATH+1] = L"";
    WCHAR  szNoName[2] = L"";
    DWORD_PTR ResumeKey = 0;
    LPBYTE pBuffer = NULL;
    DWORD  EntriesRead = 0;

    DWORD  dwMessageId;

    UNICODE_STRING uContext;
    WCHAR  szContext[MAX_PATH+1];
    LPWSTR pszTemp;

    // Get the current default tree or server name
    DWORD err ;
    PCONN_STATUS pConnStatus = NULL;
    DWORD i;
    PCONN_STATUS pConnStatusTmp;
    PCONN_STATUS pConnStatusUser;
    PCONN_STATUS pConnStatusNoUser;
    HANDLE handleRdr;
    LPWSTR pszText;

    // WNet calls related declarations;
    DWORD dwError;
    LPNETRESOURCE lpNetResource = NULL;
    HANDLE  hEnum;
    DWORD   dwCount;
    LPNETRESOURCE lpBuffer;
    DWORD         BufferSize;

	HRESULT			hr = hrOK;


	InitializeListHead( &pResults->Netware.lmsgOutput );

	PrintStatusMessage(pParams, 4, IDS_NETWARE_STATUS_MSG);
	
    //
    // Check if client services for netware has been installed
    //
/*
	dwError = WNetOpenEnum(
							RESOURCE_GLOBALNET,
							RESOURCETYPE_ANY | RESOURCETYPE_PRINT | RESOURCETYPE_DISK,
							0,
							lpNetResource,
							&hEnum);

	if (dwError != NO_ERROR) {
       if (dwError == ERROR_NO_NETWORK)
          printf("No Network is present\n");
       printf("WNetOpenEnum failed. Not Able to determine client services for netware is installed\n");
       return FALSE;
    }

    lpBuffer = LocalAlloc(LMEM_ZEROINIT,sizeof(NETRESOURCE) * 100); // arbit

    dwError = WNetEnumResource(
                     hEnum,
                     &dwCount,
                     lpBuffer,
                     &BufferSize);


    if (dwError != NO_ERROR) {

       if (DebugVerbose)
           printf("Error: WNetEnumResource\n");

       if (dwError == ERROR_NO_MORE_ITEMS)
         printf("ERROR_NO_MORE_ITEM\n");

       dwError = GetLastError();

       if (dwError == ERROR_MORE_DATA) {
         if (DebugVerbose)
           printf("ERROR_MORE_DATA\n");
       }

       if (dwError == ERROR_INVALID_HANDLE)
          printf("ERROR_INVALID_HANDLE\n");

       if (dwError == ERROR_NO_NETWORK)
          printf("ERROR_NO_NETWORK\n");

       if (dwError == ERROR_EXTENDED_ERROR)
          printf("ERROR_EXTENDED_ERROR\n");
    }
    else {
        printf("dwCount %d \n",dwCount);
    }

    LocalFree(lpBuffer);
*/

    // end of WNet calls

	err = NwQueryInfo( &dwPrintOptions, &pszCurrentContext );
	
	if ( err == NO_ERROR )
	{
		
		szContext[0] = 0;
		uContext.Buffer = szContext;
		uContext.Length = uContext.MaximumLength
						  = sizeof(szContext)/sizeof(szContext[0]);
		
		if ( pszCurrentContext )
		{
			pszName = pszCurrentContext;
		}
		else
		{
			pszName = szNoName;
		}
		
		if ( pszName[0] == TREECHAR )
		{
			// Get the tree name from the full name *TREE\CONTEXT
			
			if ( pszTemp = wcschr( pszName, L'\\' ))
				*pszTemp = 0;
			
			dwMessageId = NW_MESSAGE_NOT_LOGGED_IN_TREE;
		}
		else
		{
			dwMessageId = NW_MESSAGE_NOT_LOGGED_IN_SERVER;
		}
		
		if ( pszName[0] != 0 )  // there is preferred server/tree
		{
			err = NwGetConnectionStatus( pszName,
										 &ResumeKey,
										 &pBuffer,
										 &EntriesRead );
		}
		
		if ( err == NO_ERROR  && EntriesRead > 0 )
			// For trees, we'll get more than one entry
		{
			pConnStatus = (PCONN_STATUS) pBuffer;
			
			if ( EntriesRead > 1 && pszName[0] == TREECHAR )
			{
				// If there is more than one entry for trees,
				// then we need to find one entry where username is not null.
				// If we cannot find one, then just use the first one.
				
				pConnStatusTmp = pConnStatus;
				pConnStatusUser = NULL;
				pConnStatusNoUser = NULL;
				
				for ( i = 0; i < EntriesRead ; i++ )
				{
					if ( pConnStatusTmp->fNds )
					{
						pConnStatusNoUser = pConnStatusTmp;
						
						if (  ( pConnStatusTmp->pszUserName != NULL )
							  && (  ( pConnStatusTmp->dwConnType
									  == NW_CONN_NDS_AUTHENTICATED_NO_LICENSE )
									|| ( pConnStatusTmp->dwConnType
										 == NW_CONN_NDS_AUTHENTICATED_LICENSED )
								 )
						   )
						{
							// Found it
							pConnStatusUser = pConnStatusTmp;
							break;
						}
					}
					
					// Continue with the next item
					pConnStatusTmp = (PCONN_STATUS)
									 ( (DWORD_PTR) pConnStatusTmp
									   + pConnStatusTmp->dwTotalLength);
				}
				
				if ( pConnStatusUser )
				{
					// found one nds entry with a user name
					pConnStatus = pConnStatusUser;
				}
				else if ( pConnStatusNoUser )
				{
					// use an nds entry with no user name
					pConnStatus = pConnStatusNoUser;
				}
				// else use the first entry
			}
			
			if (  ( pConnStatus->pszUserName )
				  && ( pConnStatus->pszUserName[0] != 0 )
			   )
			{
				NwAbbreviateUserName( pConnStatus->pszUserName,
									  szUserName);
				
				NwMakePrettyDisplayName( szUserName );
				
				if ( pszName[0] != TREECHAR )
				{
					dwMessageId = NW_MESSAGE_LOGGED_IN_SERVER;
				}
				else
				{
					dwMessageId = NW_MESSAGE_LOGGED_IN_TREE;
				}
			}
			
			if ( pszName[0] == TREECHAR )
			{
				// For trees, we need to get the current context
				
				// Open a handle to the redirector
				handleRdr = NULL;
				err = RtlNtStatusToDosError(
											 NwNdsOpenRdrHandle( &handleRdr ));
				
				if ( err == NO_ERROR )
				{
					UNICODE_STRING uTree;
					RtlInitUnicodeString( &uTree, pszName+1 ); // get past '*'
					
					// Get the current context in the default tree
					err = RtlNtStatusToDosError(
												NwNdsGetTreeContext( handleRdr,
						&uTree,
						&uContext));
				}
				
				if ( handleRdr != NULL )
					NtClose( handleRdr );
			}
		}
		
		if ( !err )
		{
			switch (dwMessageId)
			{
				case NW_MESSAGE_NOT_LOGGED_IN_TREE:
					// "You are not logged in to the directory tree %s. "
					AddMessageToList(&pResults->Netware.lmsgOutput,
									 Nd_Quiet,
									 IDS_NETWARE_NOT_LOGGED_IN_TREE,
									 pszName[0] == TREECHAR ? pszName + 1: pszName);
					hr = S_FALSE;
					break;
				case NW_MESSAGE_NOT_LOGGED_IN_SERVER:
					// "You are not logged in to your preferred server %s.\n"
					AddMessageToList(&pResults->Netware.lmsgOutput,
									 Nd_Quiet,
									 IDS_NETWARE_NOT_LOGGED_IN_SERVER,
									 pszName[0] == TREECHAR ? pszName + 1: pszName);
					hr = S_FALSE;
					break;
				case NW_MESSAGE_LOGGED_IN_SERVER:
					// "You are logged in to the server %s with user name %s.\n"
					AddMessageToList(&pResults->Netware.lmsgOutput,
									 Nd_Verbose,
									 IDS_NETWARE_LOGGED_IN_SERVER,
									 pszName[0] == TREECHAR ? pszName + 1: pszName,
									 szUserName);
					pResults->Netware.pszServer = StrDupTFromW(pszName[0] == TREECHAR ?
						pszName + 1 : pszName);
					pResults->Netware.pszUser = StrDupTFromW(szUserName);
					pResults->Netware.pszTree = StrDup(_T(""));
					pResults->Netware.pszContext = StrDup(_T(""));
					break;
				case NW_MESSAGE_LOGGED_IN_TREE:
					// "You are logged in to the directory tree %s with user name %s.\nThe current workstation name context is %s.\n"
					AddMessageToList(&pResults->Netware.lmsgOutput,
									 Nd_Verbose,
									 IDS_NETWARE_LOGGED_IN_TREE,
									 pszName[0] == TREECHAR ? pszName + 1: pszName,
									 szUserName,
									 szContext);
					pResults->Netware.pszTree = StrDupTFromW(pszName[0] == TREECHAR ?
						pszName + 1 : pszName);
					pResults->Netware.pszUser = StrDupTFromW(szUserName);
					pResults->Netware.pszContext = StrDupTFromW(szContext);
					pResults->Netware.pszServer = StrDup(_T(""));
			}

			// Read from the conn status if possible
			if (pConnStatus)
			{
				pResults->Netware.fConnStatus = TRUE;

				if (pConnStatus->pszUserName)
				{
					Free(pResults->Netware.pszUser);
					pResults->Netware.pszUser =
						StrDupTFromW(pConnStatus->pszUserName);
				}

				if (pConnStatus->pszServerName)
				{
					Free(pResults->Netware.pszServer);
					pResults->Netware.pszServer =
						StrDupTFromW(pConnStatus->pszServerName);
				}
				
				if (pConnStatus->pszTreeName)
				{
					Free(pResults->Netware.pszTree);
					pResults->Netware.pszTree =
						StrDupTFromW(pConnStatus->pszTreeName);
				}

				pResults->Netware.fNds = pConnStatus->fNds;
				pResults->Netware.dwConnType = pConnStatus->dwConnType;
			}
			else
				pResults->Netware.fConnStatus = FALSE;
			
		}
		
		if ( pBuffer != NULL )
		{
			LocalFree( pBuffer );
			pBuffer = NULL;
		}
	}
	
	if ( pszCurrentContext != NULL )
	{
		LocalFree( pszCurrentContext );
		pszCurrentContext = NULL;
	}
	
	if ( err != NO_ERROR )
	{
//		if (DebugVerbose)
//			printf("Error %s occurred while trying to get connection information.\n",err);
//		printf("Error getting connection information\n");
		hr = S_FALSE;
	}
		
	return hr;
	
}




WORD
NwParseNdsUncPath(
    IN OUT LPWSTR * Result,
    IN LPWSTR ContainerName,
    IN ULONG flag
)
/*++

Routine Description:

    This function is used to extract either the tree name, fully distinguished
    name path to an object, or object name, out of a complete NDS UNC path.

Arguments:

    Result - parsed result buffer.
    ContainerName - Complete NDS UNC path that is to be parsed.
    flag - Flag indicating operation to be performed:

         PARSE_NDS_GET_TREE_NAME
         PARSE_NDS_GET_PATH_NAME
         PARSE_NDS_GET_OBJECT_NAME


Return Value:

    Length of string in result buffer. If error occured, 0 is returned.

--*/ // NwParseNdsUncPath
{
    USHORT length = 2;
    USHORT totalLength = (USHORT) wcslen( ContainerName );

    if ( totalLength < 2 )
        return 0;

    //
    // First get length to indicate the character in the string that indicates the
    // "\" in between the tree name and the rest of the UNC path.
    //
    // Example:  \\<tree name>\<path to object>[\|.]<object>
    //                        ^
    //                        |
    //
    while ( length < totalLength && ContainerName[length] != L'\\' )
    {
        length++;
    }

    if ( flag == PARSE_NDS_GET_TREE_NAME )
    {
        *Result = (LPWSTR) ( ContainerName + 2 );

        return ( length - 2 ) * sizeof( WCHAR ); // Take off 2 for the two \\'s
    }

    if ( flag == PARSE_NDS_GET_PATH_NAME && length == totalLength )
    {
        *Result = ContainerName;

        return 0;
    }

    if ( flag == PARSE_NDS_GET_PATH_NAME )
    {
        *Result = ContainerName + length + 1;

        return ( totalLength - length - 1 ) * sizeof( WCHAR );
    }

    *Result = ContainerName + totalLength - 1;
    length = 1;

    while ( **Result != L'\\' )
    {
        *Result--;
        length++;
    }

    *Result++;
    length--;

    return length * sizeof( WCHAR );
}


NTSTATUS NwNdsOpenRdrHandle(
    OUT PHANDLE  phNwRdrHandle
)
{

    NTSTATUS ntstatus;
    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ACCESS_MASK DesiredAccess = SYNCHRONIZE | GENERIC_READ;

    WCHAR NameStr[] = L"\\Device\\NwRdr\\*";
    UNICODE_STRING uOpenName;

    //
    // Prepare the open name.
    //

    RtlInitUnicodeString( &uOpenName, NameStr );

   //
   // Set up the object attributes.
   //

   InitializeObjectAttributes(
       &ObjectAttributes,
       &uOpenName,
       OBJ_CASE_INSENSITIVE,
       NULL,
       NULL );

   ntstatus = NtOpenFile(
                  phNwRdrHandle,
                  DesiredAccess,
                  &ObjectAttributes,
                  &IoStatusBlock,
                  FILE_SHARE_VALID_FLAGS,
                  FILE_SYNCHRONOUS_IO_NONALERT );

   if ( !NT_ERROR(ntstatus) &&
        !NT_INFORMATION(ntstatus) &&
        !NT_WARNING(ntstatus))  {

       return IoStatusBlock.Status;

   }

   return ntstatus;
}

NTSTATUS
NwNdsGetTreeContext (
    IN HANDLE hNdsRdr,
    IN PUNICODE_STRING puTree,
    OUT PUNICODE_STRING puContext
)
/*+++

    This gets the current context of the requested tree.

---*/
{

    NTSTATUS ntstatus;
    IO_STATUS_BLOCK IoStatusBlock;

    PNWR_NDS_REQUEST_PACKET Rrp;
    DWORD RrpSize;

    //
    // Set up the request.
    //

    RrpSize = sizeof( NWR_NDS_REQUEST_PACKET ) + puTree->Length;

    Rrp = LocalAlloc( LMEM_ZEROINIT, RrpSize );

    if ( !Rrp ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    try {

        (Rrp->Parameters).GetContext.TreeNameLen = puTree->Length;

        RtlCopyMemory( (BYTE *)(Rrp->Parameters).GetContext.TreeNameString,
                       puTree->Buffer,
                       puTree->Length );

        (Rrp->Parameters).GetContext.Context.MaximumLength = puContext->MaximumLength;
        (Rrp->Parameters).GetContext.Context.Length = 0;
        (Rrp->Parameters).GetContext.Context.Buffer = puContext->Buffer;

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        ntstatus = STATUS_INVALID_PARAMETER;
        goto ExitWithCleanup;
    }

    try {

        ntstatus = NtFsControlFile( hNdsRdr,
                                    NULL,
                                    NULL,
                                    NULL,
                                    &IoStatusBlock,
                                    FSCTL_NWR_NDS_GETCONTEXT,
                                    (PVOID) Rrp,
                                    RrpSize,
                                    NULL,
                                    0 );

    } except ( EXCEPTION_EXECUTE_HANDLER ) {

        ntstatus = GetExceptionCode();
        goto ExitWithCleanup;
    }

    //
    // Copy out the length; the buffer has already been written.
    //

    puContext->Length = (Rrp->Parameters).GetContext.Context.Length;

ExitWithCleanup:

    LocalFree( Rrp );
    return ntstatus;
}



DWORD
NwGetConnectionStatus(
    IN  LPWSTR  pszRemoteName,
    OUT PDWORD_PTR ResumeKey,
    OUT LPBYTE  *Buffer,
    OUT PDWORD  EntriesRead
)
{
    DWORD err = NO_ERROR;
    DWORD dwBytesNeeded = 0;
    DWORD dwBufferSize  = TWO_KB;

    *Buffer = NULL;
    *EntriesRead = 0;

    do {

        *Buffer = (LPBYTE) LocalAlloc( LMEM_ZEROINIT, dwBufferSize );

        if ( *Buffer == NULL )
            return ERROR_NOT_ENOUGH_MEMORY;

        err = NWPGetConnectionStatus( pszRemoteName,
                                      ResumeKey,
                                      *Buffer,
                                      dwBufferSize,
                                      &dwBytesNeeded,
                                      EntriesRead );

        if ( err == ERROR_INSUFFICIENT_BUFFER )
        {
            dwBufferSize = dwBytesNeeded + EXTRA_BYTES;
            LocalFree( *Buffer );
            *Buffer = NULL;
        }

    } while ( err == ERROR_INSUFFICIENT_BUFFER );

    if ( err == ERROR_INVALID_PARAMETER )  // not attached
    {
        err = NO_ERROR;
        *EntriesRead = 0;
    }

    return err;
}

VOID
NwAbbreviateUserName(
    IN  LPWSTR pszFullName,
    OUT LPWSTR pszUserName
)
{
    LPWSTR pszTemp;
    LPWSTR pszLast;
    WCHAR NextChar;

    if ( pszUserName == NULL )
        return;

    pszTemp = pszFullName;
    pszLast = pszTemp;

    *pszUserName = 0;

    while ( pszTemp = wcschr( pszTemp, L'='))
    {

        NextChar = *(++pszTemp);

        while ( NextChar != 0 && NextChar != L'.' )
        {
            *(pszUserName++) = *pszTemp;
             NextChar = *(++pszTemp);
        }

        if ( NextChar == 0 )
        {
            pszLast = NULL;
            break;
        }

        *(pszUserName++) = *pszTemp;   // put back the '.'
        pszLast = ++pszTemp;
    }

    if ( pszLast != NULL )
    {
        while ( *pszLast != 0 )
           *(pszUserName++) = *(pszLast++);
    }

    *pszUserName = 0;
}

VOID
NwMakePrettyDisplayName(
    IN  LPWSTR pszName
)
{

    if ( pszName )
    {
        CharLower((LPSTR)pszName );
        CharUpperBuff( (LPSTR)pszName, 1);
    }
}


DWORD
NWPGetConnectionStatus(
    IN     LPWSTR  pszRemoteName,
    IN OUT PDWORD_PTR ResumeKey,
    OUT    LPBYTE  Buffer,
    IN     DWORD   BufferSize,
    OUT    PDWORD  BytesNeeded,
    OUT    PDWORD  EntriesRead
)
{
    NTSTATUS ntstatus = STATUS_SUCCESS;
    HANDLE            handleRdr = NULL;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK   IoStatusBlock;
    UNICODE_STRING    uRdrName;
    WCHAR             RdrPrefix[] = L"\\Device\\NwRdr\\*";

    PNWR_REQUEST_PACKET RequestPacket = NULL;
    DWORD             RequestPacketSize = 0;
    DWORD             dwRemoteNameLen = 0;

    //
    // Set up the object attributes.
    //

    RtlInitUnicodeString( &uRdrName, RdrPrefix );

    InitializeObjectAttributes( &ObjectAttributes,
                                &uRdrName,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL );

    ntstatus = NtOpenFile( &handleRdr,
                           SYNCHRONIZE | FILE_LIST_DIRECTORY,
                           &ObjectAttributes,
                           &IoStatusBlock,
                           FILE_SHARE_VALID_FLAGS,
                           FILE_SYNCHRONOUS_IO_NONALERT );

    if ( !NT_SUCCESS(ntstatus) )
        goto CleanExit;

    dwRemoteNameLen = pszRemoteName? wcslen(pszRemoteName)*sizeof(WCHAR) : 0;

    RequestPacketSize = sizeof( NWR_REQUEST_PACKET ) + dwRemoteNameLen;

    RequestPacket = (PNWR_REQUEST_PACKET) LocalAlloc( LMEM_ZEROINIT,
                                                      RequestPacketSize );

    if ( RequestPacket == NULL )
    {
        ntstatus = STATUS_NO_MEMORY;
        goto CleanExit;
    }

    //
    // Fill out the request packet for FSCTL_NWR_GET_CONN_STATUS.
    //

    RequestPacket->Parameters.GetConnStatus.ResumeKey = *ResumeKey;

    RequestPacket->Version = REQUEST_PACKET_VERSION;
    RequestPacket->Parameters.GetConnStatus.ConnectionNameLength = dwRemoteNameLen;

    RtlCopyMemory( &(RequestPacket->Parameters.GetConnStatus.ConnectionName[0]),
                   pszRemoteName,
                   dwRemoteNameLen );

    ntstatus = NtFsControlFile( handleRdr,
                                NULL,
                                NULL,
                                NULL,
                                &IoStatusBlock,
                                FSCTL_NWR_GET_CONN_STATUS,
                                (PVOID) RequestPacket,
                                RequestPacketSize,
                                (PVOID) Buffer,
                                BufferSize );

    if ( NT_SUCCESS( ntstatus ))
        ntstatus = IoStatusBlock.Status;

    *EntriesRead = RequestPacket->Parameters.GetConnStatus.EntriesReturned;
    *ResumeKey   = RequestPacket->Parameters.GetConnStatus.ResumeKey;
    *BytesNeeded = RequestPacket->Parameters.GetConnStatus.BytesNeeded;

CleanExit:

    if ( handleRdr != NULL )
        NtClose( handleRdr );

    if ( RequestPacket != NULL )
        LocalFree( RequestPacket );

    return RtlNtStatusToDosError( ntstatus );
}


BOOL
NwIsNdsSyntax(
    IN LPWSTR lpstrUnc
)
{
    HANDLE hTreeConn;
    DWORD  dwOid;
    DWORD  status = NO_ERROR;

    if ( lpstrUnc == NULL )
        return FALSE;

    status = NwOpenAndGetTreeInfo( lpstrUnc, &hTreeConn, &dwOid );

    if ( status != NO_ERROR )
    {
        return FALSE;
    }

    CloseHandle( hTreeConn );

    return TRUE;
}

DWORD
NwOpenAndGetTreeInfo(
    LPWSTR pszNdsUNCPath,
    HANDLE *phTreeConn,
    DWORD  *pdwOid
)
{
    NTSTATUS ntstatus = STATUS_SUCCESS;
    WCHAR          lpServerName[NW_MAX_SERVER_LEN];
    UNICODE_STRING ServerName;

    UNICODE_STRING ObjectName;

    *phTreeConn = NULL;

    ServerName.Length = 0;
    ServerName.MaximumLength = sizeof( lpServerName );
    ServerName.Buffer = lpServerName;

    ObjectName.Buffer = NULL;
    ObjectName.MaximumLength = ( wcslen( pszNdsUNCPath) + 1 ) * sizeof( WCHAR );

    ObjectName.Length = NwParseNdsUncPath( (LPWSTR *) &ObjectName.Buffer,
                                           pszNdsUNCPath,
                                           PARSE_NDS_GET_TREE_NAME );

    if ( ObjectName.Length == 0 || ObjectName.Buffer == NULL )
    {
        return ERROR_PATH_NOT_FOUND;
    }

    //
    // Open a NDS tree connection handle to \\treename
    //
    ntstatus = NwNdsOpenTreeHandle( &ObjectName, phTreeConn );

    if ( !NT_SUCCESS( ntstatus ))
    {
        return RtlNtStatusToDosError( ntstatus );
    }

    //
    // Get the path to the container to open.
    //
    ObjectName.Length = NwParseNdsUncPath( (LPWSTR *) &ObjectName.Buffer,
                                           pszNdsUNCPath,
                                           PARSE_NDS_GET_PATH_NAME );

    if ( ObjectName.Length == 0 )
    {
        UNICODE_STRING Root;

        RtlInitUnicodeString(&Root, L"[Root]");

        //
        // Resolve the path to get a NDS object id.
        //
        ntstatus =  NwNdsResolveName( *phTreeConn,
                                      &Root,
                                      pdwOid,
                                      &ServerName,
                                      NULL,
                                      0 );

    }
    else
    {
        //
        // Resolve the path to get a NDS object id.
        //
        ntstatus =  NwNdsResolveName( *phTreeConn,
                                      &ObjectName,
                                      pdwOid,
                                      &ServerName,
                                      NULL,
                                      0 );

    }

    if ( ntstatus == STATUS_SUCCESS && ServerName.Length )
    {
        DWORD    dwHandleType;

        //
        // NwNdsResolveName succeeded, but we were referred to
        // another server, though pdwOid is still valid.

        if ( *phTreeConn )
            CloseHandle( *phTreeConn );

        *phTreeConn = NULL;

        //
        // Open a NDS generic connection handle to \\ServerName
        //
        ntstatus = NwNdsOpenGenericHandle( &ServerName,
                                           &dwHandleType,
                                           phTreeConn );

        if ( ntstatus != STATUS_SUCCESS )
        {
            return RtlNtStatusToDosError(ntstatus);
        }

        ASSERT( dwHandleType != HANDLE_TYPE_NCP_SERVER );
    }

    if ( !NT_SUCCESS( ntstatus ))
    {

        if ( *phTreeConn != NULL )
        {
            CloseHandle( *phTreeConn );
            *phTreeConn = NULL;
        }
        return RtlNtStatusToDosError(ntstatus);
    }

    return NO_ERROR;

}


static
DWORD
NwRegQueryValueExW(
    IN HKEY hKey,
    IN LPWSTR lpValueName,
    OUT LPDWORD lpReserved,
    OUT LPDWORD lpType,
    OUT LPBYTE  lpData,
    IN OUT LPDWORD lpcbData
    )
/*++

Routine Description:

    This routine supports the same functionality as Win32 RegQueryValueEx
    API, except that it works.  It returns the correct lpcbData value when
    a NULL output buffer is specified.

    This code is stolen from the service controller.

Arguments:

    same as RegQueryValueEx

Return Value:

    NO_ERROR or reason for failure.

--*/
{
    NTSTATUS ntstatus;
    UNICODE_STRING ValueName;
    PKEY_VALUE_FULL_INFORMATION KeyValueInfo;
    DWORD BufSize;


    UNREFERENCED_PARAMETER(lpReserved);

    //
    // Make sure we have a buffer size if the buffer is present.
    //
    if ((ARGUMENT_PRESENT(lpData)) && (! ARGUMENT_PRESENT(lpcbData))) {
        return ERROR_INVALID_PARAMETER;
    }

    RtlInitUnicodeString(&ValueName, lpValueName);

    //
    // Allocate memory for the ValueKeyInfo
    //
    BufSize = *lpcbData + sizeof(KEY_VALUE_FULL_INFORMATION) +
              ValueName.Length
              - sizeof(WCHAR);  // subtract memory for 1 char because it's included
                                // in the sizeof(KEY_VALUE_FULL_INFORMATION).

    KeyValueInfo = (PKEY_VALUE_FULL_INFORMATION) LocalAlloc(
                                                     LMEM_ZEROINIT,
                                                     (UINT) BufSize
                                                     );

    if (KeyValueInfo == NULL) {
//        if (DebugVerbose)
//           printf("NWWORKSTATION: NwRegQueryValueExW: LocalAlloc failed %lu\n",
//                 GetLastError());
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    ntstatus = NtQueryValueKey(
                   hKey,
                   &ValueName,
                   KeyValueFullInformation,
                   (PVOID) KeyValueInfo,
                   (ULONG) BufSize,
                   (PULONG) &BufSize
                   );

    if ((NT_SUCCESS(ntstatus) || (ntstatus == STATUS_BUFFER_OVERFLOW))
          && ARGUMENT_PRESENT(lpcbData)) {

        *lpcbData = KeyValueInfo->DataLength;
    }

    if (NT_SUCCESS(ntstatus)) {

        if (ARGUMENT_PRESENT(lpType)) {
            *lpType = KeyValueInfo->Type;
        }


        if (ARGUMENT_PRESENT(lpData)) {
            memcpy(
                lpData,
                (LPBYTE)KeyValueInfo + KeyValueInfo->DataOffset,
                KeyValueInfo->DataLength
                );
        }
    }

    (void) LocalFree((HLOCAL) KeyValueInfo);

    return RtlNtStatusToDosError(ntstatus);

}


DWORD
NwReadRegValue(
    IN HKEY Key,
    IN LPWSTR ValueName,
    OUT LPWSTR *Value
    )
/*++

Routine Description:

    This function allocates the output buffer and reads the requested
    value from the registry into it.

Arguments:

    Key - Supplies opened handle to the key to read from.

    ValueName - Supplies name of the value to retrieve data.

    Value - Returns a pointer to the output buffer which points to
        the memory allocated and contains the data read in from the
        registry.  This pointer must be freed with LocalFree when done.

Return Value:

    ERROR_NOT_ENOUGH_MEMORY - Failed to create buffer to read value into.

    Error from registry call.

--*/
{
    LONG    RegError;
    DWORD   NumRequired = 0;
    DWORD   ValueType;


    //
    // Set returned buffer pointer to NULL.
    //
    *Value = NULL;

    RegError = NwRegQueryValueExW(
                   Key,
                   ValueName,
                   NULL,
                   &ValueType,
                   (LPBYTE) NULL,
                   &NumRequired
                   );

    if (RegError != ERROR_SUCCESS && NumRequired > 0) {

        if ((*Value = (LPWSTR) LocalAlloc(
                                      LMEM_ZEROINIT,
                                      (UINT) NumRequired
                                      )) == NULL) {

//        if (DebugVerbose)
//            printf("NWWORKSTATION: NwReadRegValue: LocalAlloc of size %lu failed %lu\n", NumRequired, GetLastError());
//
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        RegError = NwRegQueryValueExW(
                       Key,
                       ValueName,
                       NULL,
                       &ValueType,
                       (LPBYTE) *Value,
                       &NumRequired
                       );
    }
    else if (RegError == ERROR_SUCCESS) {
//        if (DebugVerbose)
//        printf("NWWORKSTATION: NwReadRegValue got SUCCESS with NULL buffer.");
        return ERROR_FILE_NOT_FOUND;
    }

    if (RegError != ERROR_SUCCESS) {

        if (*Value != NULL) {
            (void) LocalFree((HLOCAL) *Value);
            *Value = NULL;
        }

        return (DWORD) RegError;
    }

    return NO_ERROR;
}



DWORD
NwpGetCurrentUserRegKey(
    IN  DWORD DesiredAccess,
    OUT HKEY  *phKeyCurrentUser
    )
/*++

Routine Description:

    This routine opens the current user's registry key under
    \HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\NWCWorkstation\Parameters

Arguments:

    DesiredAccess - The access mask to open the key with

    phKeyCurrentUser - Receives the opened key handle

Return Value:

    Returns the appropriate Win32 error.

--*/
{
    DWORD err;
    HKEY hkeyWksta;
    LPWSTR CurrentUser;
    DWORD Disposition;

    //
    // Open HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services
    // \NWCWorkstation\Parameters
    //
    err = RegOpenKeyExW(
                   HKEY_LOCAL_MACHINE,
                   NW_WORKSTATION_REGKEY,
                   REG_OPTION_NON_VOLATILE,
                   KEY_READ,
                   &hkeyWksta
                   );

    if ( err ) {
//        if (DebugVerbose)
//           printf("NWPROVAU: NwGetCurrentUserRegKey open Paramters key unexpected error %lu!\n",err);
        return err;
    }
    //
    // Get the current user's SID string.
    //
    err = NwReadRegValue(
              hkeyWksta,
              NW_CURRENTUSER_VALUENAME,
              &CurrentUser
              );


    if ( err ) {
//        if (DebugVerbose)
//           printf("NWPROVAU: NwGetCurrentUserRegKey read CurrentUser value unexpected error %lu !\n", err);
 (void) RegCloseKey( hkeyWksta );
        return err;
    }

    (void) RegCloseKey( hkeyWksta );

    //
    // Open HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services
    // \NWCWorkstation\Parameters\Option
    //
    err = RegOpenKeyExW(
                   HKEY_LOCAL_MACHINE,
                   NW_WORKSTATION_OPTION_REGKEY,
                   REG_OPTION_NON_VOLATILE,
                   KEY_READ,
                   &hkeyWksta
                   );
    if ( err ) {
//        if (DebugVerbose)
//           printf("NWPROVAU: NwGetCurrentUserRegKey open Parameters\\Option key unexpected error %lu!\n", err);
        return err;
    }

    //
    // Open current user's key
    //
    err = RegOpenKeyExW(
              hkeyWksta,
              CurrentUser,
              REG_OPTION_NON_VOLATILE,
              DesiredAccess,
              phKeyCurrentUser
              );

    if ( err == ERROR_FILE_NOT_FOUND)
    {

        //
        // Create <NewUser> key under NWCWorkstation\Parameters\Option
        //
        err = RegCreateKeyExW(
                  hkeyWksta,
                  CurrentUser,
                  0,
                  WIN31_CLASS,
                  REG_OPTION_NON_VOLATILE,
                  DesiredAccess,
                  NULL,                      // security attr
                  phKeyCurrentUser,
                  &Disposition
                  );

    }

    if ( err ) {
//        if (DebugVerbose)
//           printf("NWPROVAU: NwGetCurrentUserRegKey open or create of Parameters\\Option\\%ws key failed %lu\n", CurrentUser, err);
    }

    (void) RegCloseKey( hkeyWksta );
    (void) LocalFree((HLOCAL)CurrentUser) ;
    return err;
}


DWORD
NwQueryInfo(
    OUT PDWORD pnPrintOptions,
    OUT LPWSTR *ppszPreferredSrv
    )
/*++

Routine Description:
    This routine gets the user's preferred server and print options from
    the registry.

Arguments:

    pnPrintOptions - Receives the user's print option

    ppszPreferredSrv - Receives the user's preferred server


Return Value:

    Returns the appropriate Win32 error.

--*/
{

    HKEY hKeyCurrentUser = NULL;
    DWORD BufferSize;
    DWORD BytesNeeded;
    DWORD PrintOption;
    DWORD ValueType;
    LPWSTR PreferredServer ;
    DWORD err ;

    //
    // get to right place in registry and allocate dthe buffer
    //
    if (err = NwpGetCurrentUserRegKey( KEY_READ, &hKeyCurrentUser))
    {
        //
        // If somebody mess around with the registry and we can't find
        // the registry, just use the defaults.
        //
        *ppszPreferredSrv = NULL;
   //     *pnPrintOptions = NW_PRINT_OPTION_DEFAULT;
        return NO_ERROR;
    }

    BufferSize = sizeof(WCHAR) * (MAX_PATH + 2) ;
    PreferredServer = (LPWSTR) LocalAlloc(LPTR, BufferSize) ;
    if (!PreferredServer)
        return (GetLastError()) ;

    //
    // Read PreferredServer value into Buffer.
    //
    BytesNeeded = BufferSize ;

    err = RegQueryValueExW( hKeyCurrentUser,
                            NW_SERVER_VALUENAME,
                            NULL,
                            &ValueType,
                            (LPBYTE) PreferredServer,
                            &BytesNeeded );

    if (err != NO_ERROR)
    {
        //
        // set to empty and carry on
        //
        PreferredServer[0] = 0;
    }


    if (hKeyCurrentUser != NULL)
        (void) RegCloseKey(hKeyCurrentUser) ;

    *ppszPreferredSrv = PreferredServer ;
    return NO_ERROR ;
}


/*!--------------------------------------------------------------------------
	NetwareGlobalPrint
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void NetwareGlobalPrint( NETDIAG_PARAMS* pParams,
						  NETDIAG_RESULT*  pResults)
{
	int		ids;
	LPTSTR	pszConnType;
	
	if (!pResults->Ipx.fEnabled)
	{
		return;
	}
	
	if (pParams->fVerbose || !FHrOK(pResults->Netware.hr))
	{
		BOOL		fVerboseT, fReallyVerboseT;
		
		PrintNewLine(pParams, 2);
		PrintMessage(pParams, IDS_NETWARE_TITLE_MSG);

		fVerboseT = pParams->fVerbose;
		fReallyVerboseT = pParams->fReallyVerbose;
		pParams->fReallyVerbose = TRUE;

		PrintMessageList(pParams, &pResults->Netware.lmsgOutput);

		pParams->fReallyVerbose = fReallyVerboseT;
		pParams->fVerbose = fVerboseT;


		// Now print out the results
		if (FHrOK(pResults->Netware.hr))
		{
			// Print out the user name, server name, tree and context
			PrintMessage(pParams,
						 IDS_NETWARE_USER_NAME,
						 pResults->Netware.pszUser == 0 ? _T("") : pResults->Netware.pszUser);
			PrintMessage(pParams,
						 IDS_NETWARE_SERVER_NAME,
						 pResults->Netware.pszServer == 0 ? _T("") : pResults->Netware.pszServer);
			PrintMessage(pParams,
						 IDS_NETWARE_TREE_NAME,
						 pResults->Netware.pszTree == 0 ? _T("") : pResults->Netware.pszTree);
			PrintMessage(pParams,
						 IDS_NETWARE_CONTEXT,
						 pResults->Netware.pszContext == 0 ? _T("") : pResults->Netware.pszContext);

			// Print out the connection type and nds
			if (pResults->Netware.fConnStatus)
			{
				PrintMessage(pParams,
							 IDS_NETWARE_NDS,
							 MAP_YES_NO(pResults->Netware.fNds));

				switch (pResults->Netware.dwConnType)
				{
					case NW_CONN_NOT_AUTHENTICATED:
						ids = IDS_NETWARE_CONN_NOT_AUTHENTICATED;
						break;
					case NW_CONN_BINDERY_LOGIN:
						ids = IDS_NETWARE_CONN_BINDERY_LOGIN;
						break;
					case NW_CONN_NDS_AUTHENTICATED_NO_LICENSE:
						ids = IDS_NETWARE_CONN_NDS_AUTHENTICATED_NO_LICENSE;
						break;
					case NW_CONN_NDS_AUTHENTICATED_LICENSED:
						ids = IDS_NETWARE_CONN_NDS_AUTHENTICATED_LICENSED;
						break;
					case NW_CONN_DISCONNECTED:
						ids = IDS_NETWARE_CONN_DISCONNECTED;
						break;
					default:
						ids = IDS_NETWARE_CONN_UNKNOWN;
						break;
				}
				PrintMessage(pParams,
							 ids,
							 pResults->Netware.dwConnType);
			}
		}
	}
}

/*!--------------------------------------------------------------------------
	NetwarePerInterfacePrint
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void NetwarePerInterfacePrint( NETDIAG_PARAMS* pParams,
								NETDIAG_RESULT*  pResults,
								INTERFACE_RESULT *pInterfaceResults)
{
	// no per-interface results
}


/*!--------------------------------------------------------------------------
	NetwareCleanup
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void NetwareCleanup( NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
{
	Free(pResults->Netware.pszUser);
	pResults->Netware.pszUser = NULL;
	
	Free(pResults->Netware.pszServer);
	pResults->Netware.pszServer = NULL;
	
	Free(pResults->Netware.pszTree);
	pResults->Netware.pszTree = NULL;
	
	Free(pResults->Netware.pszContext);
	pResults->Netware.pszContext = NULL;
	
	MessageListCleanUp(&pResults->Netware.lmsgOutput);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\nettst.h ===
/*

Copyright (C) Microsoft Corporation, 1998 - 1999

Module Name:

           nettst.h

Abstract:

           This will be the header file for nettest.dll
           It is intended to be used by both the user of the dll and the source code
           for the dll.

Author:
           Aug-13-1998 ( t-rajkup )

*/


//
// Before including this file, the source files for dll will redefine NETTESTAPI
// to _declspec(dllexport)
//    - Rajkumar 
//

#ifndef NETTESTAPI
#define NETTESTAPI _declspec(dllimport)
#endif

/*=============================< Defines >=======================================*/

// defines used in ipconfig structures
#define MAX_ADAPTER_DESCRIPTION_LENGTH  128 // arb.
#define MAX_ADAPTER_NAME_LENGTH         256 // arb.
#define MAX_ADAPTER_ADDRESS_LENGTH      8   // arb.
#define MAX_HOSTNAME_LEN                128 // arb.
#define MAX_DOMAIN_NAME_LEN             128 // arb.
#define MAX_SCOPE_ID_LEN                256 // arb.

// defines used in  dhcp response info

#define MAX_SUBNET_MASK                 32  // arb.
#define MAX_IP_ADDR                     32  // arb.
#define MAX_EXPIRY_TIME_LEN             128 // arb.
#define DHCP_BOOT_REPLY                 2   // arb.

// defines used in wins test

// status values returned by wins name query test 
#define WINS_QUERY_SUCCEEDED                 0x00000001
#define WINS_QUERY_FAILED                    0x00000002

// defines used in netstat test
#define        MAX_PHYSADDR_SIZE       8


// defines used in dhcp test
#define  EXPIRY_TIME_LEN         128 //arb.

/*=============================< Data Structures >================================*/

// NOTE: Need to include iptypes.h for definition of IP_ADDR_STRING.

// This structure contains the fixed information returned by ipconfig test

typedef struct _IPCONFIG_FIXED_INFO {
  char    HostName[MAX_HOSTNAME_LEN + 4] ;
  char    DomainName[MAX_DOMAIN_NAME_LEN + 4];
  PIP_ADDR_STRING     CurrentDnsServer;
  IP_ADDR_STRING      DnsServerList;
  UINT    NodeType; // see node type related definitions in iptypes.h
  char    ScopeId[MAX_SCOPE_ID_LEN + 4];
  UINT    EnableRouting;
  UINT    EnableProxy;
  UINT    EnableDns; 
} IPCONFIG_FIXED_INFO, *PIPCONFIG_FIXED_INFO;


// This structure contains per adapter information returned by ipconfig test

typedef struct _IPCONFIG_ADAPTER_INFO {
  struct _IPCONFIG_ADAPTER_INFO *Next;
  char      AdapterName[MAX_ADAPTER_NAME_LENGTH + 4];
  char      Description[MAX_ADAPTER_DESCRIPTION_LENGTH + 4];
  UINT      AddressLength;
  BYTE      Address[MAX_ADAPTER_ADDRESS_LENGTH];
  DWORD     Index;
  UINT      Type; // adapter type.  See iptypes for definitions on type of adapters
  UINT      DhcpEnabled;
  PIP_ADDR_STRING   CurrentIpAddress;
  IP_ADDR_STRING    IpAddressList;
  IP_ADDR_STRING    GatewayList;
  IP_ADDR_STRING    DhcpServer;
  BOOL              PingDhcp; // whether pinging of dhcp server succeeded
  BOOL      HaveWins;
  //
  // NOTE: According to KarolyS, it is possible to list upto 12 wins servers
  // and this is supposed to be included in nettest code. -  Rajkumar
  //
  IP_ADDR_STRING    PrimaryWinsServer;
  BOOL              PingPrimary; // whether pinging of primary WINS succeeded
  IP_ADDR_STRING    SecondaryWinsServer;
  BOOL              PingSecondary; // whether pinging of secondary WINS succeeded
  time_t    LeaseObtained;
  time_t    LeaseExpires;
  char      DhcpClassID[MAX_DOMAIN_NAME_LEN];
  UINT      AutoconfigEnabled; // is autoconfiguration possible ?
  UINT      AutoconfigActive;  // is the adapter currently autoconfigured ?
  UINT      NodeType;
  char      DomainName[MAX_DOMAIN_NAME_LEN + 1];
  IP_ADDR_STRING    DnsServerList;
} IPCONFIG_ADAPTER_INFO, *PIPCONFIG_ADAPTER_INFO;

//
// Structure used in dhcp response
//
typedef struct _DHCP_RESPONSE_INFO {
  USHORT MessageType; // BOOT_REPLY always
  struct in_addr SubnetMask; 
  struct in_addr ServerIp;
  struct in_addr DomainName;
  char   ExpiryTime[EXPIRY_TIME_LEN]; 
} DHCP_RESPONSE_INFO, *PDHCP_RESPONSE_INFO;

//
// structures returned by netstat test
// 

typedef struct _INTERFACESTATS{
        ulong         if_index;
        ulong         if_type;
        ulong         if_mtu;
        ulong         if_speed;
        ulong         if_physaddrlen;
        uchar         if_physaddr[MAX_PHYSADDR_SIZE];
        ulong         if_adminstatus;
        ulong         if_operstatus;
        ulong         if_lastchange;
        ulong         if_inoctets;
        ulong         if_inucastpkts;
        ulong         if_innucastpkts;
        ulong         if_indiscards;
        ulong         if_inerrors;
        ulong         if_inunknownprotos;
        ulong         if_outoctets;
        ulong         if_outucastpkts;
        ulong         if_outnucastpkts;
        ulong         if_outdiscards;
        ulong         if_outerrors;
        ulong         if_outqlen;
        ulong         if_descrlen;
        uchar         if_descr[1];
} INTERFACESTATS, *PINTERFACESTATS;

typedef struct _TCPCONNECTIONSTATS {
    ulong       tct_state;
    ulong       tct_localaddr;
    ulong       tct_localport;
    ulong       tct_remoteaddr;
    ulong       tct_remoteport;
    struct _TCPCONNECTIONSTATS *Next; 
} TCPCONNECTIONSTATS, *PTCPCONNECTIONSTATS;

typedef struct _UDPCONNECTIONSTATS {
    ulong       ue_localaddr;
    ulong       ue_localport;
    struct _UDPCONNECTIONSTATS *Next;
} UDPCONNECTIONSTATS, *PUDPCONNECTIONSTATS;


typedef struct _IPINFO  {
    ulong      ipsi_forwarding;
    ulong      ipsi_defaultttl;
    ulong      ipsi_inreceives;
    ulong      ipsi_inhdrerrors;
    ulong      ipsi_inaddrerrors;
    ulong      ipsi_forwdatagrams;
    ulong      ipsi_inunknownprotos;
    ulong      ipsi_indiscards;
    ulong      ipsi_indelivers;

    ulong      ipsi_outrequests;
    ulong      ipsi_routingdiscards;
    ulong      ipsi_outdiscards;
    ulong      ipsi_outnoroutes;
    ulong      ipsi_reasmtimeout;
    ulong      ipsi_reasmreqds;
    ulong      ipsi_reasmoks;
    ulong      ipsi_reasmfails;
    ulong      ipsi_fragoks;
    ulong      ipsi_fragfails;
    ulong      ipsi_fragcreates;
    ulong      ipsi_numif;
    ulong      ipsi_numaddr;
    ulong      ipsi_numroutes;
} IPINFO, *PIPINFO;

typedef struct _TCP_STATS {
    ulong       ts_rtoalgorithm;
    ulong       ts_rtomin;
    ulong       ts_rtomax;
    ulong       ts_maxconn;
    ulong       ts_activeopens;
    ulong       ts_passiveopens;
    ulong       ts_attemptfails;
    ulong       ts_estabresets;
    ulong       ts_currestab;
    ulong       ts_insegs;
    ulong       ts_outsegs;
    ulong       ts_retranssegs;
    ulong       ts_inerrs;
    ulong       ts_outrsts;
    ulong       ts_numconns;
} TCP_STATS, *PTCP_STATS;

typedef struct _UDP_STATS {
    ulong       us_indatagrams; // datagrams received
    ulong       us_noports; // no ports
    ulong       us_inerrors; // Receive Errors
    ulong       us_outdatagrams; // datagrams sent
} UDP_STATS, *PUDP_STATS;

typedef struct _ICMPSTATS {
    ulong       icmps_msgs; // messages
    ulong       icmps_errors; // Errors
    ulong       icmps_destunreachs; // destination unreachable
    ulong       icmps_timeexcds; // time exceedeed
    ulong       icmps_parmprobs; // parameter problems
    ulong       icmps_srcquenchs; // source quenchs
    ulong       icmps_redirects; // redirects
    ulong       icmps_echos; // echos
    ulong       icmps_echoreps; // echo replies
    ulong       icmps_timestamps; // timestamps
    ulong       icmps_timestampreps; // timestamps replies
    ulong       icmps_addrmasks; // address masks
    ulong       icmps_addrmaskreps; // address mask replies
} ICMPSTATS, *PICMPSTATS;

/*================================< Entry Points >===============================*/

// The user of this entry point must allocate memory for these structures
NETTESTAPI    BOOL IpConfigTest(PIPCONFIG_FIXED_INFO pIpFixedInfo,
                                PULONG               pFixedSize,
                                PIPCONFIG_ADAPTER_INFO pIpAdapterInfo,
                                PULONG               pAdapterInfo);

NETTESTAPI    BOOL CheckDhcp(PIPCONFIG_ADAPTER_INFO pIpAdapterInfo,PDHCP_RESPONSE_INFO pDhcpResponse);

NETTESTAPI    DWORD QueryWINS(PIP_ADDRESS_STRING WinsServerAddr);

//
// This entry point will allocate the memory needed. It will not expect the user
// to allocate memory for these structures. Freeing of this allcoated memory is
// user's reponsibility. There can be additional entry points which can be supplied
// which can be used to free this memory
//

NETTESTAPI    BOOL NetstatInfo(PINTERFACESTATS pIfcStat,
                               PTCPCONNECTIONSTATS   pTcpConnStats,
                               PUDPCONNECTIONSTATS   pUdpConnStats,
                               PIPINFO               pIpInfo,
                               PTCP_STATS            pTcpStats,
                               PUDP_STATS            pUdpStats,
                               ICMPSTATS             pIcmpStats);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\netstat.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      netstat.c
//
//  Abstract:
//
//      Queries into network drivers
//
//  Author:
//
//      Anilth  - 4-20-1998 
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//--

#include "precomp.h"

#include <snmp.h>
#include "snmputil.h"
#include "tcpinfo.h"
#include "ipinfo.h"
#include "llinfo.h"


#define MAX_HOST_NAME_SIZE        ( 260)
#define MAX_SERVICE_NAME_SIZE     ( 200)
#define MAX_NUM_DIGITS              30

BOOL NumFlag = FALSE;


LPTSTR FormatNumber(DWORD dwNumber);

VOID DisplayInterface( NETDIAG_PARAMS* pParams, NETDIAG_RESULT* pResults, 
                       IfEntry *pEntry,  IfEntry *ListHead ); //used in DoInterface()
HRESULT DoInterface( NETDIAG_PARAMS* pParams, NETDIAG_RESULT* pResults );

static DWORD
GenerateHostNameServiceString(
   OUT char *       pszBuffer,
   IN OUT int *     lpcbBufLen,
   IN  BOOL         fNumFlag,
   IN  BOOL         fLocalHost,
   IN  const char * pszProtocol,
   IN  ulong        uAddress,
   IN  ulong        uPort
);
void DisplayTcpConnEntry( NETDIAG_PARAMS* pParams, NETDIAG_RESULT* pResults, 
                          TcpConnEntry *pTcp );
void DisplayUdpConnEntry( NETDIAG_PARAMS* pParams, NETDIAG_RESULT* pResults, 
                          UdpConnEntry *pUdp );
HRESULT DoConnections( NETDIAG_PARAMS* pParams, NETDIAG_RESULT* pResults );

void DisplayIP( NETDIAG_PARAMS* pParams, NETDIAG_RESULT* pResults, 
                   IpEntry *pEntry); //called by DoIp
HRESULT DoIP( NETDIAG_PARAMS* pParams, NETDIAG_RESULT* pResults );

void DisplayTCP( NETDIAG_PARAMS* pParams, NETDIAG_RESULT* pResults, 
                 TcpEntry *pEntry );
HRESULT DoTCP( NETDIAG_PARAMS* pParams, NETDIAG_RESULT* pResults );


VOID DisplayUDP( NETDIAG_PARAMS* pParams, NETDIAG_RESULT* pResults, 
                 UdpEntry *pEntry ); // called by DoUDP()
HRESULT DoUDP( NETDIAG_PARAMS* pParams, NETDIAG_RESULT* pResults ); 



void DisplayICMP( NETDIAG_PARAMS* pParams, NETDIAG_RESULT* pResults, 
                  IcmpEntry *pEntry );
HRESULT DoICMP( NETDIAG_PARAMS* pParams, NETDIAG_RESULT* pResults );



BOOL
NetstatTest(NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
//++
//  Description:
//      This test prints all the stats that netstat outputs
// 
//  Arguments:
//      None.
//
//  Author:
//      Rajkumar 08/04/98
//--
{

    HRESULT hr = S_OK;
    ulong Result;
    
    InitializeListHead(&pResults->Netstat.lmsgGlobalOutput);
    InitializeListHead(&pResults->Netstat.lmsgInterfaceOutput);
    InitializeListHead(&pResults->Netstat.lmsgConnectionGlobalOutput);
    InitializeListHead(&pResults->Netstat.lmsgTcpConnectionOutput);
    InitializeListHead(&pResults->Netstat.lmsgUdpConnectionOutput);
    InitializeListHead(&pResults->Netstat.lmsgIpOutput);
    InitializeListHead(&pResults->Netstat.lmsgTcpOutput);
    InitializeListHead(&pResults->Netstat.lmsgUdpOutput);
    InitializeListHead(&pResults->Netstat.lmsgIcmpOutput);

    if (!pParams->fReallyVerbose)
        return hr;

    PrintStatusMessage( pParams, 4, IDS_NETSTAT_STATUS_MSG );
    //
    // initialize the snmp interface
    //
    
    Result = InitSnmp();
  
    if( NO_ERROR != Result )
    {
        //IDS_NETSTAT_14401                  "Initialization of SNMP failed.\n" 
        AddMessageToListId( &pResults->Netstat.lmsgGlobalOutput, Nd_Quiet, IDS_NETSTAT_14401);
        return S_FALSE;
    }
    
    //
    // Show ethernet statistics
    //
    
    hr = DoInterface( pParams, pResults );
    
    //
    // Show connections
    //
    
    if( S_OK == hr )
        hr = DoConnections( pParams, pResults );
    
    
    //
    // Display IP statistics
    //
    
    if( S_OK == hr )
        hr = DoIP( pParams, pResults );
    
    //
    // Display TCP statistics
    //
    
    if( S_OK == hr )
        hr = DoTCP( pParams, pResults );
    
    //
    // Display UDP statistics
    //
    
    if( S_OK == hr )
        hr = DoUDP( pParams, pResults );
    
    //
    // Display ICMP statistics
    //
    
    if( S_OK == hr )
        hr = DoICMP( pParams, pResults );
    
    pResults->Netstat.hrTestResult = hr;
    return hr;
}


//*****************************************************************************
//
// Name:        DisplayInterface
//
// Description: Display interface statistics.
//
// Parameters:  IfEntry *pEntry: pointer to summary data entry.
//              ulong VerboseFlag: boolean indicating desire for verbosity.
//              IfEntry *ListHead: pointer to list of entries.  Used if
//                      verbosity desired.
//
// Returns:     void.
//
// History:
//  01/21/94  JayPh     Created.
//
//*****************************************************************************

VOID DisplayInterface( NETDIAG_PARAMS* pParams, NETDIAG_RESULT* pResults, 
                       IfEntry *pEntry,  IfEntry *ListHead )
{
    char     *TmpStr;
    IfEntry  *pIfList;
    char      PhysAddrStr[32];
    
    //IDS_NETSTAT_14402                  "\n\nInterface Statistics\n\n" 
    AddMessageToListId( &pResults->Netstat.lmsgInterfaceOutput, Nd_ReallyVerbose, IDS_NETSTAT_14402);

    //IDS_NETSTAT_14403                  "                                Received             Sent\n" 
    AddMessageToListId( &pResults->Netstat.lmsgInterfaceOutput, Nd_ReallyVerbose, IDS_NETSTAT_14403);

    //IDS_NETSTAT_14404                  "Unicast Packets             %12u     %12u\n" 
    AddMessageToList( &pResults->Netstat.lmsgInterfaceOutput, Nd_ReallyVerbose, 
                     IDS_NETSTAT_14404, 
                     pEntry->Info.if_inoctets,
                     pEntry->Info.if_outoctets );


    //IDS_NETSTAT_14405                  "Non-unicast packets         %12u     %12u\n" 
    AddMessageToList( &pResults->Netstat.lmsgInterfaceOutput, Nd_ReallyVerbose, 
                      IDS_NETSTAT_14405,
                      pEntry->Info.if_innucastpkts,
                      pEntry->Info.if_outnucastpkts );

    //IDS_NETSTAT_14406                  "Discards                    %12u     %12u\n" 
    AddMessageToList( &pResults->Netstat.lmsgInterfaceOutput, Nd_ReallyVerbose, 
            IDS_NETSTAT_14406,
            pEntry->Info.if_indiscards,
            pEntry->Info.if_outdiscards );

//IDS_NETSTAT_14407                  "Errors                      %12u     %12u\n" 
    AddMessageToList( &pResults->Netstat.lmsgInterfaceOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14407,
            pEntry->Info.if_inerrors,
            pEntry->Info.if_outerrors );


//IDS_NETSTAT_14408                  "Unknown protocols           %12u     %12u\n" 
    AddMessageToList( &pResults->Netstat.lmsgInterfaceOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14408,
            pEntry->Info.if_inunknownprotos );

    if ( pParams->fReallyVerbose)
    {
        // Also display configuration info

        // Traverse the list of interfaces, displaying config info

        pIfList = CONTAINING_RECORD( ListHead->ListEntry.Flink,
                                     IfEntry,
                                     ListEntry );

        while ( pIfList != ListHead )
        {
            //IDS_NETSTAT_14409                  "\nInterface index         =  %u\n" 
            AddMessageToList( &pResults->Netstat.lmsgInterfaceOutput, Nd_ReallyVerbose, 
                    IDS_NETSTAT_14409,
                    pIfList->Info.if_index );

            //IDS_NETSTAT_14410                  "Description             =  %s\n" 
            AddMessageToList( &pResults->Netstat.lmsgInterfaceOutput, Nd_ReallyVerbose, 
                    IDS_NETSTAT_14410,
                    pIfList->Info.if_descr );

            //IDS_NETSTAT_14411                  "Type                    =  %u\n" 
            AddMessageToList( &pResults->Netstat.lmsgInterfaceOutput, Nd_ReallyVerbose,
                    IDS_NETSTAT_14411,
                    pIfList->Info.if_type );

            //IDS_NETSTAT_14412                  "MTU                     =  %u\n" 
            AddMessageToList( &pResults->Netstat.lmsgInterfaceOutput, Nd_ReallyVerbose,
                    IDS_NETSTAT_14412,
                    pIfList->Info.if_mtu );

            //IDS_NETSTAT_14413                  "Speed                   =  %u\n" 
            AddMessageToList( &pResults->Netstat.lmsgInterfaceOutput, Nd_ReallyVerbose,
                    IDS_NETSTAT_14413,
                    pIfList->Info.if_speed );


            sprintf( PhysAddrStr,
                     "%02x-%02X-%02X-%02X-%02X-%02X",
                     pIfList->Info.if_physaddr[0],
                     pIfList->Info.if_physaddr[1],
                     pIfList->Info.if_physaddr[2],
                     pIfList->Info.if_physaddr[3],
                     pIfList->Info.if_physaddr[4],
                     pIfList->Info.if_physaddr[5] );

            //IDS_NETSTAT_14414                  "Physical Address        =  %s\n" 
            AddMessageToList( &pResults->Netstat.lmsgInterfaceOutput, Nd_ReallyVerbose,
                    IDS_NETSTAT_14414,
                    PhysAddrStr );

            //IDS_NETSTAT_14415                  "Administrative Status   =  %u\n" 
            AddMessageToList( &pResults->Netstat.lmsgInterfaceOutput, Nd_ReallyVerbose,
                    IDS_NETSTAT_14415,
                    pIfList->Info.if_adminstatus );

            //IDS_NETSTAT_14416                  "Operational Status      =  %u\n" 
            AddMessageToList( &pResults->Netstat.lmsgInterfaceOutput, Nd_ReallyVerbose,
                    IDS_NETSTAT_14416,
                    pIfList->Info.if_operstatus );

            //IDS_NETSTAT_14417                  "Last Changed            =  %u\n" 
            AddMessageToList( &pResults->Netstat.lmsgInterfaceOutput, Nd_ReallyVerbose,
                    IDS_NETSTAT_14417,
                    pIfList->Info.if_lastchange );

            //IDS_NETSTAT_14418                  "Output Queue Length     =  %u\n\n" 
            AddMessageToList( &pResults->Netstat.lmsgInterfaceOutput, Nd_ReallyVerbose,
                    IDS_NETSTAT_14418,
                    pIfList->Info.if_outqlen );

            // Get pointer to next entry in list

            pIfList = CONTAINING_RECORD( pIfList->ListEntry.Flink,
                                         IfEntry,
                                         ListEntry );
        }
    }
}


HRESULT DoInterface( NETDIAG_PARAMS* pParams, NETDIAG_RESULT* pResults )
//++
// Description:
//   Displays statistics of current connections
//-- 
{

    IfEntry            *ListHead;
    IfEntry            *pIfList;
    IfEntry             SumOfEntries;
    ulong              Result;

    // Get the statistics

    ListHead = (IfEntry *)GetTable( TYPE_IF, &Result );

    if ( ListHead == NULL )
    {
        //IDS_NETSTAT_14419                  "Getting interface statistics table failed.\n" 
        AddMessageToList( &pResults->Netstat.lmsgInterfaceOutput, Nd_Quiet, IDS_NETSTAT_14419);
        return S_FALSE;
    }

    // Clear the summation structure

    ZeroMemory( &SumOfEntries, sizeof( IfEntry ) );

    // Traverse the list of interfaces, summing the different fields

    pIfList = CONTAINING_RECORD( ListHead->ListEntry.Flink,
                                 IfEntry,
                                 ListEntry );

    while (pIfList != ListHead)
    {
        SumOfEntries.Info.if_inoctets += pIfList->Info.if_inoctets;
        SumOfEntries.Info.if_inucastpkts += pIfList->Info.if_inucastpkts;
        SumOfEntries.Info.if_innucastpkts += pIfList->Info.if_innucastpkts;
        SumOfEntries.Info.if_indiscards += pIfList->Info.if_indiscards;
        SumOfEntries.Info.if_inerrors += pIfList->Info.if_inerrors;
        SumOfEntries.Info.if_inunknownprotos +=
                                              pIfList->Info.if_inunknownprotos;
        SumOfEntries.Info.if_outoctets += pIfList->Info.if_outoctets;
        SumOfEntries.Info.if_outucastpkts += pIfList->Info.if_outucastpkts;
        SumOfEntries.Info.if_outnucastpkts += pIfList->Info.if_outnucastpkts;
        SumOfEntries.Info.if_outdiscards += pIfList->Info.if_outdiscards;
        SumOfEntries.Info.if_outerrors += pIfList->Info.if_outerrors;

        // Get pointer to next entry in list

        pIfList = CONTAINING_RECORD( pIfList->ListEntry.Flink,
                                     IfEntry,
                                     ListEntry );
    }

    DisplayInterface( pParams, pResults, &SumOfEntries, ListHead );

    // All done with list, free it.

    FreeTable( (GenericTable *)ListHead );

    return S_OK;
}





//*****************************************************************************
//
// Name:        DisplayTcpConnEntry
//
// Description: Display information about 1 tcp connection.
//
// Parameters:  TcpConnEntry *pTcp: pointer to a tcp connection structure.
//
// Returns:     void.
//
// History:
//
//*****************************************************************************

void DisplayTcpConnEntry( NETDIAG_PARAMS* pParams, NETDIAG_RESULT* pResults, 
                          TcpConnEntry *pTcp )
{
    char            LocalStr[MAX_HOST_NAME_SIZE + MAX_SERVICE_NAME_SIZE];
    char            RemoteStr[MAX_HOST_NAME_SIZE + MAX_SERVICE_NAME_SIZE];
    DWORD dwErr;
    int BufLen;
    int FlagVerbose;

    if( pTcp->Info.tct_state !=  TCP_CONN_LISTEN )
        FlagVerbose = Nd_Verbose;
    else
        FlagVerbose = Nd_ReallyVerbose;

    //IDS_NETSTAT_14420                  "TCP" 
    AddMessageToList( &pResults->Netstat.lmsgTcpConnectionOutput, FlagVerbose, 
                        IDS_NETSTAT_14420);

    BufLen = sizeof( LocalStr);
    dwErr = GenerateHostNameServiceString( LocalStr,
                                           &BufLen,
                                          NumFlag != 0, TRUE,
                                          "tcp",
                                          pTcp->Info.tct_localaddr,
                                          pTcp->Info.tct_localport);
    ASSERT( dwErr == NO_ERROR);

    BufLen = sizeof( RemoteStr);
    dwErr = GenerateHostNameServiceString( RemoteStr,
                                       &BufLen,
                                       NumFlag != 0, FALSE,
                                       "tcp",
                                       pTcp->Info.tct_remoteaddr,
                                       pTcp->Info.tct_remoteport );
    ASSERT( dwErr == NO_ERROR);


    //IDS_NETSTAT_14421                  "   %-20s  %-40s" 
    AddMessageToList( &pResults->Netstat.lmsgTcpConnectionOutput, FlagVerbose, 
                      IDS_NETSTAT_14421,LocalStr,RemoteStr);

    switch ( pTcp->Info.tct_state )
    {
    case TCP_CONN_CLOSED:
        //IDS_NETSTAT_14422                  "  CLOSED\n" 
        AddMessageToListId( &pResults->Netstat.lmsgTcpConnectionOutput, FlagVerbose, 
                            IDS_NETSTAT_14422);
        break;

    case TCP_CONN_LISTEN:

        // Tcpip generates dummy sequential remote ports for
        // listening connections to avoid getting stuck in snmp.
        // MohsinA, 12-Feb-97.

        pTcp->Info.tct_remoteport = 0;

        //IDS_NETSTAT_14423                  "  LISTENING\n" 
        AddMessageToListId( &pResults->Netstat.lmsgTcpConnectionOutput, FlagVerbose, 
                          IDS_NETSTAT_14423);
        break;

    case TCP_CONN_SYN_SENT:
        //IDS_NETSTAT_14424                  "  SYN_SENT\n" 
        AddMessageToListId( &pResults->Netstat.lmsgTcpConnectionOutput, FlagVerbose, 
                            IDS_NETSTAT_14424);
        break;

    case TCP_CONN_SYN_RCVD:
        //IDS_NETSTAT_14425                  "  SYN_RECEIVED\n" 
        AddMessageToListId( &pResults->Netstat.lmsgTcpConnectionOutput, FlagVerbose, 
                            IDS_NETSTAT_14425); 
        break;

    case TCP_CONN_ESTAB:
        //IDS_NETSTAT_14426                  "  ESTABLISHED\n" 
        AddMessageToListId( &pResults->Netstat.lmsgTcpConnectionOutput, FlagVerbose, 
                            IDS_NETSTAT_14426);
        break;

    case TCP_CONN_FIN_WAIT1:
        //IDS_NETSTAT_14427                  "  FIN_WAIT_1\n" 
        AddMessageToListId( &pResults->Netstat.lmsgTcpConnectionOutput, FlagVerbose, 
                            IDS_NETSTAT_14427);
        break;

    case TCP_CONN_FIN_WAIT2:
        //IDS_NETSTAT_14428                  "  FIN_WAIT_2\n" 
        AddMessageToListId( &pResults->Netstat.lmsgTcpConnectionOutput, FlagVerbose, 
                            IDS_NETSTAT_14428); 
        break;

    case TCP_CONN_CLOSE_WAIT:
        //IDS_NETSTAT_14429                  "  CLOSE_WAIT\n" 
        AddMessageToListId( &pResults->Netstat.lmsgTcpConnectionOutput, FlagVerbose, 
                            IDS_NETSTAT_14429);
        break;

    case TCP_CONN_CLOSING:
        //IDS_NETSTAT_14430                  "  CLOSING\n" 
        AddMessageToListId( &pResults->Netstat.lmsgTcpConnectionOutput, FlagVerbose, 
                            IDS_NETSTAT_14430);
        break;

    case TCP_CONN_LAST_ACK:
        //IDS_NETSTAT_14431                  "  LAST_ACK\n" 
        AddMessageToListId( &pResults->Netstat.lmsgTcpConnectionOutput, FlagVerbose, 
                          IDS_NETSTAT_14431);
        break;

    case TCP_CONN_TIME_WAIT:
        //IDS_NETSTAT_14432                  "  TIME_WAIT\n" 
        AddMessageToListId( &pResults->Netstat.lmsgTcpConnectionOutput, FlagVerbose, 
                            IDS_NETSTAT_14432);
        break;

    default:
        DEBUG_PRINT(("DisplayTcpConnEntry: State=%d?\n ",
                     pTcp->Info.tct_state ));
    }


}


//*****************************************************************************
//
// Name:        DisplayUdpConnEntry
//
// Description: Display information on 1 udp connection
//
// Parameters:  UdpConnEntry *pUdp: pointer to udp connection structure.
//
// Returns:     void.
//
//
//*****************************************************************************

void DisplayUdpConnEntry( NETDIAG_PARAMS* pParams, NETDIAG_RESULT* pResults, 
                          UdpConnEntry *pUdp )
{
    char            LocalStr[MAX_HOST_NAME_SIZE + MAX_SERVICE_NAME_SIZE];
    int             BufLen;
    DWORD           dwErr;

    
    //IDS_NETSTAT_14433                  "UDP" 
    AddMessageToListId( &pResults->Netstat.lmsgUdpConnectionOutput, Nd_ReallyVerbose, IDS_NETSTAT_14433);

    BufLen = sizeof( LocalStr);
    dwErr = GenerateHostNameServiceString( LocalStr,
                                           &BufLen,
                                          NumFlag != 0, TRUE,
                                          "udp",
                                          pUdp->Info.ue_localaddr,
                                          pUdp->Info.ue_localport);
    ASSERT( dwErr == NO_ERROR);



    //IDS_NETSTAT_14434                  "  %-20s  %-40s\n" 
    AddMessageToList( &pResults->Netstat.lmsgUdpConnectionOutput, Nd_ReallyVerbose, IDS_NETSTAT_14434,LocalStr, _T("*:*") );
}


static DWORD
GenerateHostNameServiceString(
   OUT char *       pszBuffer,
   IN OUT int *     lpcbBufLen,
   IN  BOOL         fNumFlag,
   IN  BOOL         fLocalHost,
   IN  const char * pszProtocol,
   IN  ulong        uAddress,
   IN  ulong        uPort
)
/*++
  Description:
     Generates the <hostname>:<service-string> from the address and port
     information supplied. The result is stored in the pszBuffer passed in.
     If fLocalHost == TRUE, then the cached local host name is used to
     improve performance.

  Arguments:
    pszBuffer     Buffer to store the resulting string.
    lpcbBufLen    pointer to integer containing the count of bytes in Buffer
                   and on return contains the number of bytes written.
                   If the buffer is insufficient, then the required bytes is
                   stored here.
    fNumFlag      generates the output using numbers for host and port number.
    fLocalHost    indicates if we want the service string for local host or
                   remote host. Also for local host, this function generates
                   the local host name without FQDN.
    pszProtocol   specifies the protocol used for the service.
    uAddress      unisgned long address of the service.
    uPort         unsinged long port number.

  Returns:
    Win32 error codes. NO_ERROR on success.

  History:
      Added this function to avoid FQDNs  for local name + abstract the common
       code used multiple times in old code.
      Also this function provides local host name caching.
--*/
{
    char            LocalBuffer[MAX_HOST_NAME_SIZE];    // to hold dummy output
    char            LocalServiceEntry[MAX_SERVICE_NAME_SIZE];
    int             BufferLen;
    char  *         pszHostName = NULL;              // init a pointer.
    char  *         pszServiceName = NULL;
    DWORD           dwError = NO_ERROR;
    struct hostent * pHostEnt;
    struct servent * pServEnt;
    uchar *          pTmp;

    // for caching local host name
    static char  s_LocalHostName[MAX_HOST_NAME_SIZE];
    static  BOOL s_fLocalHostName = FALSE;


    if ( pszBuffer == NULL) {
        return ( ERROR_INSUFFICIENT_BUFFER);
    }

    *pszBuffer = '\0';         // initialize to null string

    if ( !fNumFlag) {
        if ( fLocalHost) {
            if ( s_fLocalHostName) {
                pszHostName = s_LocalHostName;   // pull from the cache
            } else {
                int Result = gethostname( s_LocalHostName,
                                         sizeof( s_LocalHostName));
                if ( Result == 0) {

                    char * pszFirstDot;

                    //
                    // Cache the copy of local host name now.
                    // Limit the host name to first part of host name.
                    // NO FQDN
                    //
                    s_fLocalHostName = TRUE;

                    pszFirstDot = strchr( s_LocalHostName, '.');
                    if ( pszFirstDot != NULL) {

                        *pszFirstDot = '\0';  // terminate string
                    }

                    pszHostName = s_LocalHostName;

                }
            } // if ( s_fLocalhost)


        } else {
            // Remote Host Name.
            pHostEnt = gethostbyaddr( (uchar *) &uAddress,
                                     4,       // IP address is 4 bytes,
                                     PF_INET);

            pszHostName = ( pHostEnt != NULL) ? pHostEnt->h_name: NULL;
        }


        pServEnt = getservbyport( htons( ( u_short) uPort), pszProtocol);
        pszServiceName = ( pServEnt != NULL) ? pServEnt->s_name : NULL;

    }  else {  // !fNumFlag

        pszServiceName = NULL;
        pszHostName = NULL;
    }


    //
    // Format the data for output.
    //

    if ( pszHostName == NULL) {

        //
        //  Print the IP address itself
        //
        uchar * pTmp = ( uchar *) & uAddress;

        pszHostName = LocalBuffer;

        sprintf(  pszHostName, "%u.%u.%u.%u",
                pTmp[0],
                pTmp[1],
                pTmp[2],
                pTmp[3]);
    }


    //  Now pszHostName has the name of the host.

    if ( pszServiceName == NULL) {

        pszServiceName = LocalServiceEntry;
        //IDS_NETSTAT_14436                  "%u" 
        sprintf(  pszServiceName, "%u", uPort);
    }

    // Now pszServiceName has the service name/portnumber

    BufferLen = strlen( pszHostName) + strlen( pszServiceName) + 2;
    // 2 bytes extra for ':' and null-character.

    if ( *lpcbBufLen < BufferLen ) {

        dwError = ERROR_INSUFFICIENT_BUFFER;
    } else {

        sprintf(  pszBuffer, "%s:%s", pszHostName, pszServiceName);
    }

    *lpcbBufLen = BufferLen;

    return ( dwError);

} // GenerateHostNameServiceString()

HRESULT DoConnections( NETDIAG_PARAMS* pParams, NETDIAG_RESULT* pResults)
//++
// Description:
//   Displays ethernet statistics
// 
//-- 
{

  HRESULT       hr = S_OK;
  TcpConnEntry  *pTcpHead;
  UdpConnEntry  *pUdpHead;
  TcpConnEntry  *pTcp;
  UdpConnEntry  *pUdp;
  ulong          Result;


  //IDS_NETSTAT_14438                  "\n\nActive Connections\n" 
  AddMessageToListId( &pResults->Netstat.lmsgConnectionGlobalOutput, Nd_Verbose, IDS_NETSTAT_14438);
//IDS_NETSTAT_14439                  "\nProto Local Address         Foreign Address                           State\n" 
  AddMessageToListId( &pResults->Netstat.lmsgConnectionGlobalOutput, Nd_Verbose, IDS_NETSTAT_14439);

  // Get TCP connection table

  pTcpHead = (TcpConnEntry *)GetTable( TYPE_TCPCONN, &Result );
  if ( pTcpHead == NULL )
  {
        //IDS_NETSTAT_14440                  "Getting TCP connections failed!\n" 
        AddMessageToList( &pResults->Netstat.lmsgTcpConnectionOutput, Nd_Quiet,IDS_NETSTAT_14440);
        hr = S_FALSE;
  }
  else
  {
      // Get pointer to first entry in list
      pTcp = CONTAINING_RECORD( pTcpHead->ListEntry.Flink,
                            TcpConnEntry,
                            ListEntry );

      while (pTcp != pTcpHead)
      {
          if ( ( pTcp->Info.tct_state !=  TCP_CONN_LISTEN ) ||
              (( pTcp->Info.tct_state ==  TCP_CONN_LISTEN )) )
          {
            // Display the Tcp connection info
              DisplayTcpConnEntry( pParams, pResults, pTcp );
          }

          // Get the next entry in the table
           pTcp = CONTAINING_RECORD( pTcp->ListEntry.Flink,
                                TcpConnEntry,
                                ListEntry );
       }

       FreeTable( (GenericTable *)pTcpHead );
  }

  // Get UDP connection table

  pUdpHead = (UdpConnEntry *)GetTable( TYPE_UDPCONN, &Result );
  if ( pUdpHead == NULL )
  {
      //IDS_NETSTAT_14441                  "Getting UDP connections failed!\n" 
      AddMessageToList( &pResults->Netstat.lmsgUdpConnectionOutput, Nd_Quiet, IDS_NETSTAT_14441);
      hr = S_FALSE;
  }
  else
  {
    // Get pointer to first entry in list

    pUdp = CONTAINING_RECORD( pUdpHead->ListEntry.Flink,
                                UdpConnEntry,
                                ListEntry );

    while (pUdp != pUdpHead)
    {
       // Display the Udp connection info

       DisplayUdpConnEntry( pParams, pResults, pUdp);

       // Get the next entry in the table

       pUdp = CONTAINING_RECORD( pUdp->ListEntry.Flink,
                                 UdpConnEntry,
                                 ListEntry );
     }

     FreeTable( (GenericTable *)pUdpHead );
  }

  return hr;
}


void DisplayIP( NETDIAG_PARAMS* pParams, NETDIAG_RESULT* pResults, 
                IpEntry *pEntry)
{
    //IDS_NETSTAT_14442                  "\n\nIP  Statistics\n\n" 
    AddMessageToList( &pResults->Netstat.lmsgIpOutput, Nd_ReallyVerbose, 
            IDS_NETSTAT_14442);

    //IDS_NETSTAT_14443                  "Packets Received              =   %s\n" 
    AddMessageToList( &pResults->Netstat.lmsgIpOutput, Nd_ReallyVerbose, 
            IDS_NETSTAT_14443, FormatNumber( pEntry->Info.ipsi_inreceives ));

    //IDS_NETSTAT_14444                  "Received Header Errors        =   %u\n" 
    AddMessageToList( &pResults->Netstat.lmsgIpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14444,
            FormatNumber( pEntry->Info.ipsi_inhdrerrors ) );

    //IDS_NETSTAT_14445                  "Received Address Errors       =   %u\n" 
    AddMessageToList( &pResults->Netstat.lmsgIpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14445,
            FormatNumber( pEntry->Info.ipsi_inaddrerrors ) );

    //IDS_NETSTAT_14446                  "Datagrams Forwarded           =   %u\n" 
    AddMessageToList( &pResults->Netstat.lmsgIpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14446,
            FormatNumber( pEntry->Info.ipsi_forwdatagrams ) );

    //IDS_NETSTAT_14447                  "Unknown Protocols Received    =   %u\n" 
    AddMessageToList( &pResults->Netstat.lmsgIpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14447,
            FormatNumber( pEntry->Info.ipsi_inunknownprotos ) );

    //IDS_NETSTAT_14448                  "Received Packets Discarded    =   %u\n" 
    AddMessageToList( &pResults->Netstat.lmsgIpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14448,
            FormatNumber( pEntry->Info.ipsi_indiscards ) );

    //IDS_NETSTAT_14449                  "Received Packets Delivered    =   %u\n" 
    AddMessageToList( &pResults->Netstat.lmsgIpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14449,
            FormatNumber( pEntry->Info.ipsi_indelivers ) );

    //IDS_NETSTAT_14450                  "Output Requests               =   %u\n" 
    AddMessageToList( &pResults->Netstat.lmsgIpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14450,
            FormatNumber( pEntry->Info.ipsi_outrequests ) );

    //IDS_NETSTAT_14451                  "Routing Discards              =   %u\n" 
    AddMessageToList( &pResults->Netstat.lmsgIpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14451,
            FormatNumber( pEntry->Info.ipsi_routingdiscards ) );

    //IDS_NETSTAT_14452                  "Discarded Output Packets      =   %u\n" 
    AddMessageToList( &pResults->Netstat.lmsgIpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14452,
            FormatNumber( pEntry->Info.ipsi_outdiscards ) );

    //IDS_NETSTAT_14453                  "Output Packet No Route        =   %u\n" 
    AddMessageToList( &pResults->Netstat.lmsgIpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14453,
            FormatNumber( pEntry->Info.ipsi_outnoroutes ) );

    //IDS_NETSTAT_14454                  "Reassembly  Required          =   %u\n" 
    AddMessageToList( &pResults->Netstat.lmsgIpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14454,
            FormatNumber( pEntry->Info.ipsi_reasmreqds ) );


    //IDS_NETSTAT_14455                  "Reassembly Successful         =   %u\n" 
    AddMessageToList( &pResults->Netstat.lmsgIpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14455,
            FormatNumber( pEntry->Info.ipsi_reasmoks ) );

    //IDS_NETSTAT_14456                  "Reassembly Failures           =   %u\n" 
    AddMessageToList( &pResults->Netstat.lmsgIpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14456,
            FormatNumber( pEntry->Info.ipsi_reasmfails ));

    //IDS_NETSTAT_14457                  "Datagrams successfully fragmented  =   %u\n" 
    AddMessageToList( &pResults->Netstat.lmsgIpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14457,
            FormatNumber( pEntry->Info.ipsi_fragoks ) );

    //IDS_NETSTAT_14458                  "Datagrams failing fragmentation    =   %u\n" 
    AddMessageToList( &pResults->Netstat.lmsgIpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14458,
            FormatNumber( pEntry->Info.ipsi_fragfails ) );

    //IDS_NETSTAT_14459                  "Fragments Created                  =   %u\n" 
    AddMessageToList( &pResults->Netstat.lmsgIpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14459,
            FormatNumber( pEntry->Info.ipsi_fragcreates ) );

    //IDS_NETSTAT_14460                  "Forwarding                        =    %u\n" 
    AddMessageToList( &pResults->Netstat.lmsgIpOutput, Nd_ReallyVerbose,
                IDS_NETSTAT_14460,
                FormatNumber( pEntry->Info.ipsi_forwarding ) );

    //IDS_NETSTAT_14461                  "Default TTL                       =    %u\n" 
    AddMessageToList( &pResults->Netstat.lmsgIpOutput, Nd_ReallyVerbose,
                IDS_NETSTAT_14461,
                FormatNumber( pEntry->Info.ipsi_defaultttl ));

    //IDS_NETSTAT_14462                  "Reassembly  timeout               =    %u\n" 
    AddMessageToList( &pResults->Netstat.lmsgIpOutput, Nd_ReallyVerbose,
                IDS_NETSTAT_14462,
                FormatNumber( pEntry->Info.ipsi_reasmtimeout ) );
}


HRESULT DoIP( NETDIAG_PARAMS* pParams, NETDIAG_RESULT* pResults )
{
 IpEntry            *ListHead;
 IpEntry            *pIpList;
 ulong               Result;

 // Get the statistics

 ListHead = (IpEntry *)GetTable( TYPE_IP, &Result );
 if ( ListHead == NULL )
 {
     //IDS_NETSTAT_14463                  "Getting IP statistics failed.\n" 
     AddMessageToListId( &pResults->Netstat.lmsgIpOutput, Nd_Quiet, IDS_NETSTAT_14463);
     return S_FALSE;
 }

 // Traverse the list of interfaces, summing the different fields

 pIpList = CONTAINING_RECORD( ListHead->ListEntry.Flink,
                              IpEntry,
                              ListEntry );

 DisplayIP( pParams, pResults, pIpList );

 // All done with list, free it.

 FreeTable( (GenericTable *)ListHead );

 return S_OK;
}


HRESULT DoTCP(NETDIAG_PARAMS* pParams, NETDIAG_RESULT* pResults)
{
   TcpEntry           *ListHead;
   TcpEntry           *pTcpList;
   ulong               Result;

   // Get the statistics

   ListHead = (TcpEntry *)GetTable( TYPE_TCP, &Result );
   if ( ListHead == NULL )
   {
        //IDS_NETSTAT_14464                  "Getting TCP statistics failed.\n" 
       AddMessageToListId( &pResults->Netstat.lmsgTcpOutput, Nd_Quiet, IDS_NETSTAT_14464);
       return S_FALSE;
   }

   // Traverse the list, summing the different fields

   pTcpList = CONTAINING_RECORD( ListHead->ListEntry.Flink,
                                 TcpEntry,
                                 ListEntry );

   DisplayTCP( pParams, pResults, pTcpList );

   // All done with list, free it.

   FreeTable( (GenericTable *)ListHead );

   return S_OK;
}




 
void DisplayTCP( NETDIAG_PARAMS* pParams, NETDIAG_RESULT* pResults, 
                 TcpEntry *pEntry)
{
    //IDS_NETSTAT_14465                  "\n\nTCP Statistics \n\n" 
    AddMessageToListId( &pResults->Netstat.lmsgTcpOutput, Nd_ReallyVerbose, IDS_NETSTAT_14465);

//    FormatNumber( pEntry->Info.ts_activeopens, szNumberBuffer, sizeof(szNumberBuffer)/sizeof(TCHAR), FALSE);
    
    //IDS_NETSTAT_14466                  "Active Opens               =    %s\n" 
    AddMessageToList( &pResults->Netstat.lmsgTcpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14466,
            FormatNumber( pEntry->Info.ts_activeopens ) );

    //IDS_NETSTAT_14467                  "Passive Opens              =    %s\n" 
    AddMessageToList( &pResults->Netstat.lmsgTcpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14467,
            FormatNumber( pEntry->Info.ts_passiveopens ) );

    //IDS_NETSTAT_14468                  "Failed Connection Attempts =    %s\n" 
    AddMessageToList( &pResults->Netstat.lmsgTcpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14468,
            FormatNumber( pEntry->Info.ts_attemptfails ) );

    //IDS_NETSTAT_14469                  "Reset Connections          =    %s\n" 
    AddMessageToList( &pResults->Netstat.lmsgTcpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14469,
            FormatNumber( pEntry->Info.ts_estabresets ) );

    //IDS_NETSTAT_14470                  "Current Connections        =    %s\n" 
    AddMessageToList( &pResults->Netstat.lmsgTcpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14470,
            FormatNumber( pEntry->Info.ts_currestab ) );

    
    //IDS_NETSTAT_14471                  "Received Segments          =    %s\n" 
    AddMessageToList( &pResults->Netstat.lmsgTcpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14471,
            FormatNumber( pEntry->Info.ts_insegs ) );

    
    //IDS_NETSTAT_14472                  "Segment Sent               =    %s\n" 
    AddMessageToList( &pResults->Netstat.lmsgTcpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14472,
            FormatNumber( pEntry->Info.ts_outsegs ) );

    
    //IDS_NETSTAT_14473                  "Segment Retransmitted      =    %s\n" 
    AddMessageToList( &pResults->Netstat.lmsgTcpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14473,
            FormatNumber( pEntry->Info.ts_retranssegs ) );


    
    //IDS_NETSTAT_14474                  "Retransmission Timeout Algorithm  =   " 
    AddMessageToListId( &pResults->Netstat.lmsgTcpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14474);

    switch ( pEntry->Info.ts_rtoalgorithm )
    {
        case 1:
            //IDS_NETSTAT_14475                  "other\n" 
            AddMessageToListId( &pResults->Netstat.lmsgTcpOutput, Nd_ReallyVerbose,
                    IDS_NETSTAT_14475);
            break;

        case 2:
            //IDS_NETSTAT_14476                  "constant\n" 
            AddMessageToListId( &pResults->Netstat.lmsgTcpOutput, Nd_ReallyVerbose,
                    IDS_NETSTAT_14476);
            break;

        case 3:
            //IDS_NETSTAT_14477                  "rsre\n" 
            AddMessageToListId( &pResults->Netstat.lmsgTcpOutput, Nd_ReallyVerbose,
                    IDS_NETSTAT_14477);
            break;

        case 4:
            //IDS_NETSTAT_14478                  "vanj\n " 
            AddMessageToList( &pResults->Netstat.lmsgTcpOutput, Nd_ReallyVerbose,
                    IDS_NETSTAT_14478);
            break;

        default:
            //IDS_NETSTAT_14479                  "unknown\n " 
            AddMessageToList( &pResults->Netstat.lmsgTcpOutput, Nd_ReallyVerbose,
                    IDS_NETSTAT_14479,
                    pEntry->Info.ts_rtoalgorithm );
            break;

    }

    
    //IDS_NETSTAT_14480                  "Minimum Retransmission Timeout  = %s\n" 
    AddMessageToList( &pResults->Netstat.lmsgTcpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14480,
            FormatNumber( pEntry->Info.ts_rtomin ) );

    //IDS_NETSTAT_14481                  "Maximum Retransmission Timeout  = %s\n" 
    AddMessageToList( &pResults->Netstat.lmsgTcpOutput, Nd_ReallyVerbose,
                IDS_NETSTAT_14481,
                FormatNumber( pEntry->Info.ts_rtomax ) );

    //IDS_NETSTAT_14482                  "Maximum Number of Connections   = %s\n" 
    AddMessageToList( &pResults->Netstat.lmsgTcpOutput, Nd_ReallyVerbose,
                IDS_NETSTAT_14482,
                FormatNumber( pEntry->Info.ts_maxconn ) );
}


HRESULT DoUDP( NETDIAG_PARAMS* pParams, NETDIAG_RESULT* pResults )
{

 UdpEntry           *ListHead;
 UdpEntry           *pUdpList;
 ulong               Result;

 // Get the statistics

 ListHead = (UdpEntry *)GetTable( TYPE_UDP, &Result );
 if ( ListHead == NULL )
 {
    //IDS_NETSTAT_14483                  "Getting UDP statistics failed.\n" 
     AddMessageToListId( &pResults->Netstat.lmsgUdpOutput, Nd_Quiet, IDS_NETSTAT_14483 );
     return S_FALSE;
 }

 // Traverse the list of interfaces, summing the different fields

 pUdpList = CONTAINING_RECORD( ListHead->ListEntry.Flink,
                               UdpEntry,
                               ListEntry );

 DisplayUDP( pParams, pResults, pUdpList );

 // All done with list, free it.

 FreeTable( (GenericTable *)ListHead );

 return S_OK;
}

VOID DisplayUDP( NETDIAG_PARAMS* pParams, NETDIAG_RESULT* pResults, 
                 UdpEntry *pEntry) 
{


//IDS_NETSTAT_14484                  "\n\nUDP Statistics\n\n" 
  AddMessageToListId( &pResults->Netstat.lmsgUdpOutput, Nd_ReallyVerbose, IDS_NETSTAT_14484);

//IDS_NETSTAT_14485                  "Datagrams Received    =   %s\n" 
  AddMessageToList( &pResults->Netstat.lmsgUdpOutput, Nd_ReallyVerbose, 
          IDS_NETSTAT_14485, FormatNumber( pEntry->Info.us_indatagrams ) );

//IDS_NETSTAT_14486                  "No Ports              =   %s\n" 
  AddMessageToList( &pResults->Netstat.lmsgUdpOutput, Nd_ReallyVerbose,
          IDS_NETSTAT_14486, FormatNumber(pEntry->Info.us_noports) );

//IDS_NETSTAT_14487                  "Receive Errors        =   %s\n" 
  AddMessageToList( &pResults->Netstat.lmsgUdpOutput, Nd_ReallyVerbose,
          IDS_NETSTAT_14487, FormatNumber(pEntry->Info.us_inerrors) );

//IDS_NETSTAT_14488                  "Datagrams Sent        =   %s\n" 
  AddMessageToList( &pResults->Netstat.lmsgUdpOutput, Nd_ReallyVerbose,
          IDS_NETSTAT_14488, FormatNumber(pEntry->Info.us_outdatagrams) );
}


HRESULT DoICMP( NETDIAG_PARAMS* pParams, NETDIAG_RESULT* pResults )
{

 IcmpEntry          *ListHead;
 IcmpEntry          *pIcmpList;
 ulong              Result;

 // Get the statistics

 ListHead = (IcmpEntry *)GetTable( TYPE_ICMP, &Result );

 if ( ListHead == NULL )
   {
    //IDS_NETSTAT_14489                  "Getting ICMP statistics failed.\n" 
     AddMessageToListId( &pResults->Netstat.lmsgIcmpOutput, Nd_Quiet,
                        IDS_NETSTAT_14489);
     return S_FALSE;
   }

 // Traverse the list of interfaces, summing the different fields

 pIcmpList = CONTAINING_RECORD( ListHead->ListEntry.Flink,
                               IcmpEntry,
                               ListEntry );

 DisplayICMP( pParams, pResults, pIcmpList );

 // All done with list, free it.

 FreeTable( (GenericTable *)ListHead );

 return S_OK;
}

void DisplayICMP( NETDIAG_PARAMS* pParams, NETDIAG_RESULT* pResults, 
                  IcmpEntry *pEntry )
{

    //IDS_NETSTAT_14490                  "\n\nICMP Statistics \n\n" 
   AddMessageToListId( &pResults->Netstat.lmsgIcmpOutput, Nd_ReallyVerbose, 
            IDS_NETSTAT_14490);
    //IDS_NETSTAT_14491                  "\t\t\t  Received              Sent\n" 
   AddMessageToListId( &pResults->Netstat.lmsgIcmpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14491);


    //IDS_NETSTAT_14492                  "Messages                 %7s          %7s\n" 
   AddMessageToList( &pResults->Netstat.lmsgIcmpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14492,
            FormatNumber(pEntry->InInfo.icmps_msgs),
            FormatNumber(pEntry->OutInfo.icmps_msgs) );

    //IDS_NETSTAT_14493                  "Errors                   %7s          %7s\n" 
    AddMessageToList( &pResults->Netstat.lmsgIcmpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14493,
            FormatNumber(pEntry->InInfo.icmps_errors),
            FormatNumber(pEntry->OutInfo.icmps_errors) );

    //IDS_NETSTAT_14494                  "Destination  Unreachable %7s          %7s\n" 
    AddMessageToList( &pResults->Netstat.lmsgIcmpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14494,
            FormatNumber(pEntry->InInfo.icmps_destunreachs),
            FormatNumber(pEntry->OutInfo.icmps_destunreachs) );

    //IDS_NETSTAT_14495                  "Time    Exceeded         %7s          %7s\n" 
    AddMessageToList( &pResults->Netstat.lmsgIcmpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14495,
            FormatNumber(pEntry->InInfo.icmps_timeexcds),
            FormatNumber(pEntry->OutInfo.icmps_timeexcds) );

    //IDS_NETSTAT_14496                  "Parameter Problems       %7s          %7s\n" 
    AddMessageToList( &pResults->Netstat.lmsgIcmpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14496,
            FormatNumber(pEntry->InInfo.icmps_parmprobs),
            FormatNumber(pEntry->OutInfo.icmps_parmprobs) );

    //IDS_NETSTAT_14497                  "Source Quenchs           %7s          %7s\n" 
    AddMessageToList( &pResults->Netstat.lmsgIcmpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14497,
            FormatNumber(pEntry->InInfo.icmps_srcquenchs),
            FormatNumber(pEntry->OutInfo.icmps_srcquenchs) );

    //IDS_NETSTAT_14498                  "Redirects                %7s          %7s\n" 
    AddMessageToList( &pResults->Netstat.lmsgIcmpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14498,
            FormatNumber(pEntry->InInfo.icmps_redirects),
            FormatNumber(pEntry->OutInfo.icmps_redirects) );

    
    //IDS_NETSTAT_14499                  "Echos                    %7s          %7s\n" 
    AddMessageToList( &pResults->Netstat.lmsgIcmpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14499,
            FormatNumber(pEntry->InInfo.icmps_echos),
            FormatNumber(pEntry->OutInfo.icmps_echos) );

    //IDS_NETSTAT_14500                  "Echo Replies             %7s          %7s\n" 
    AddMessageToList( &pResults->Netstat.lmsgIcmpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14500,
            FormatNumber(pEntry->InInfo.icmps_echoreps),
            FormatNumber(pEntry->OutInfo.icmps_echoreps) );

    //IDS_NETSTAT_14501                  "Timestamps               %7s          %7s\n" 
    AddMessageToList( &pResults->Netstat.lmsgIcmpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14501,
            FormatNumber(pEntry->InInfo.icmps_timestamps),
            FormatNumber(pEntry->OutInfo.icmps_timestamps) );

    //IDS_NETSTAT_14502                  "Timestamp Replies        %7s          %7s\n" 
    AddMessageToList( &pResults->Netstat.lmsgIcmpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14502,
            FormatNumber(pEntry->InInfo.icmps_timestampreps),
            FormatNumber(pEntry->OutInfo.icmps_timestampreps) );

    //IDS_NETSTAT_14503                  "Address Masks            %7s          %7s\n" 
    AddMessageToList( &pResults->Netstat.lmsgIcmpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14503,
            FormatNumber(pEntry->InInfo.icmps_addrmasks),
            FormatNumber(pEntry->OutInfo.icmps_addrmasks) );

    //IDS_NETSTAT_14504                  "Address Mask Replies     %7s          %7s\n" 
    AddMessageToList( &pResults->Netstat.lmsgIcmpOutput, Nd_ReallyVerbose,
            IDS_NETSTAT_14504,
            FormatNumber(pEntry->InInfo.icmps_addrmaskreps),
            FormatNumber(pEntry->OutInfo.icmps_addrmaskreps) );

}


//----------------------------------------------------------------------------
// Function:    FormatNumber
//
// This function takes an integer and formats a string with the value
// represented by the number, grouping digits by powers of one-thousand
//----------------------------------------------------------------------------

LPTSTR FormatNumber(DWORD dwNumber)
{
//  assert(cchBuffer > 14);
    
    static TCHAR s_szBuffer[MAX_NUM_DIGITS];
    BOOL fSigned = TRUE;
    static TCHAR szNegativeSign[4] = TEXT("");
    static TCHAR szThousandsSeparator[4] = TEXT("");

    DWORD i, dwLength;
    TCHAR szDigits[12], pszTemp[20];
        TCHAR* pszsrc, *pszdst;



    //
    // Retrieve the thousands-separator for the user's locale
    //

    if (szThousandsSeparator[0] == TEXT('\0'))
    {
        GetLocaleInfo(
            LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, szThousandsSeparator, 4
            );
    }


    //
    // If we are formatting a signed value, see if the value is negative
    //

    if (fSigned)
    {
        if ((INT)dwNumber >= 0)
            fSigned = FALSE;
        else
        {
            //
            // The value is negative; retrieve the locale's negative-sign
            //

            if (szNegativeSign[0] == TEXT('\0')) {

                GetLocaleInfo(
                    LOCALE_USER_DEFAULT, LOCALE_SNEGATIVESIGN, szNegativeSign, 4
                    );
            }

            dwNumber = abs((INT)dwNumber);
        }
    }


    //
    // Convert the number to a string without thousands-separators
    //

    _ltot(dwNumber, szDigits, 10);
    //padultoa(dwNumber, szDigits, 0);

    dwLength = lstrlen(szDigits);


    //
    // If the length of the string without separators is n,
    // then the length of the string with separators is n + (n - 1) / 3
    //

    i = dwLength;
    dwLength += (dwLength - 1) / 3;


    //
    // Write the number to the buffer in reverse
    //

    pszsrc = szDigits + i - 1; pszdst = pszTemp + dwLength;

    *pszdst-- = TEXT('\0');

    while (TRUE) {
        if (i--) { *pszdst-- = *pszsrc--; } else { break; }
        if (i--) { *pszdst-- = *pszsrc--; } else { break; }
        if (i--) { *pszdst-- = *pszsrc--; } else { break; }
        if (i) { *pszdst-- = *szThousandsSeparator; } else { break; }
    }

    s_szBuffer[0] = 0;
    
    if (fSigned)
        lstrcat(s_szBuffer, szNegativeSign);

    lstrcat(s_szBuffer, pszTemp);
    return s_szBuffer;
}


void NetstatGlobalPrint(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults)
{
    if (!pParams->fReallyVerbose)
        return;
    
    if (pParams->fVerbose || !FHrOK(pResults->Netstat.hrTestResult))
    {
        PrintNewLine(pParams, 2);
        PrintTestTitleResult(pParams,
                             IDS_NETSTAT_LONG,
							 IDS_NETSTAT_SHORT,
                             TRUE,
                             pResults->Netstat.hrTestResult,
                             0);
    }

    PrintMessageList(pParams, &pResults->Netstat.lmsgGlobalOutput);
    PrintMessageList(pParams, &pResults->Netstat.lmsgInterfaceOutput);
    PrintMessageList(pParams, &pResults->Netstat.lmsgConnectionGlobalOutput);
    PrintMessageList(pParams, &pResults->Netstat.lmsgTcpConnectionOutput);
    PrintMessageList(pParams, &pResults->Netstat.lmsgUdpConnectionOutput);
    PrintMessageList(pParams, &pResults->Netstat.lmsgIpOutput);
    PrintMessageList(pParams, &pResults->Netstat.lmsgTcpOutput);
    PrintMessageList(pParams, &pResults->Netstat.lmsgUdpOutput);
    PrintMessageList(pParams, &pResults->Netstat.lmsgIcmpOutput);
}


void NetstatPerInterfacePrint(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults, INTERFACE_RESULT *pInterfaceResults)
{
    if (!pParams->fReallyVerbose)
        return;
    
}


void NetstatCleanup(IN NETDIAG_PARAMS *pParams,
                     IN OUT NETDIAG_RESULT *pResults)
{
    MessageListCleanUp(&pResults->Netstat.lmsgGlobalOutput);
    MessageListCleanUp(&pResults->Netstat.lmsgInterfaceOutput);
    MessageListCleanUp(&pResults->Netstat.lmsgConnectionGlobalOutput);
    MessageListCleanUp(&pResults->Netstat.lmsgTcpConnectionOutput);
    MessageListCleanUp(&pResults->Netstat.lmsgUdpConnectionOutput);
    MessageListCleanUp(&pResults->Netstat.lmsgIpOutput);
    MessageListCleanUp(&pResults->Netstat.lmsgTcpOutput);
    MessageListCleanUp(&pResults->Netstat.lmsgUdpOutput);
    MessageListCleanUp(&pResults->Netstat.lmsgIcmpOutput);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\nettest.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      nettest.c
//
//  Abstract:
//
//    Test to ensure that a workstation has network (IP) connectivity to
//      the outside.
//
//  Author:
//
//     15-Dec-1997 (cliffv)
//      Anilth  - 4-20-1998
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//    1-June-1998 (denisemi) add DnsServerHasDCRecords to check DC dns records
//                           registration
//
//    26-June-1998 (t-rajkup) add general tcp/ip , dhcp and routing,
//                            winsock, ipx, wins and netbt information.
//--

//
// Common include files.
//
#include "precomp.h"

#include "ipxtest.h"
#include "ipcfgtest.h"
#include "machine.h"
#include "global.h"
#include "crtdbg.h"
#include <locale.h>


//////////////////////////////////////////////////////////////////////////////
//
// Globals
//
//////////////////////////////////////////////////////////////////////////////

const TCHAR   c_szLogFileName[] = _T("NetDiag.log");

//BOOL IpConfigCalled = FALSE;
//BOOL ProblemBased   = FALSE;
int  ProblemNumber;


//
// New functions for displaying routing table - Rajkumar
//

#define WILD_CARD (ULONG)(-1)
#define ROUTE_DATA_STRING_SIZE 300
#define MAX_METRIC 9999
#define ROUTE_SEPARATOR ','

int match( const char * p, const char * s );





// Replaced by pResults->IpConfig.pFixedInfo
//PFIXED_INFO GlobalIpconfigFixedInfo = NULL;

// Replaced by per-adapter info, pResults->pArrayInterface[i].IpConfig
//PADAPTER_INFO GlobalIpconfigAdapterInfo = NULL;

// Replaced by per-adapter info, pResults->pArrayInterface[i].IpConfig.pAdapterInfo
//PIP_ADAPTER_INFO IpGlobalIpconfigAdapterInfo = NULL;

// See pResults->IpConfig.fDhcpEnabled
//BOOLEAN GlobalDhcpEnabled;

// See pResults->NetBt.Transports
//LIST_ENTRY GlobalNetbtTransports;

// See pResults->NetBt.cTransportCount
//ULONG GlobalNetbtTransportCount;

// !!! not replaced yet
// See pResults->Global.listTestedDomains
//LIST_ENTRY GlobalTestedDomains;



//
// Globals defining the command line arguments.
//

// Replaced by pParams->fVerbose
//BOOL Verbose;

// Replaced by pParams->fReallyVerbose
// Maintain this global variable so that we don't mess up the compiling
// of getdcnam.c
BOOL ReallyVerbose;

// Replaced by pParams->fDebugVerbose
//BOOL DebugVerbose;

// Replaced by pParams->fFixProblems
//BOOL GlobalFixProblems;

// Replaced by pParams->fDcAccountEnum
//BOOL GlobalDcAccountEnum;


// !!! not replaced yet
//PTESTED_DOMAIN GlobalQueriedDomain;

//
// Describe the domain this machine is a member of
//

// Replaced by pResults->Global.pszCurrentBuildNumber
//int GlobalNtBuildNumber;

// Replaced by pResults->Global.pPrimaryDomainInfo
//PDSROLE_PRIMARY_DOMAIN_INFO_BASIC GlobalDomainInfo = NULL;

// Replaced by pResults->Global.pMemberDomain
//PTESTED_DOMAIN GlobalMemberDomain;

//
// Who we're currently logged on as
//

// Replaced by pResults->Global.pLogonUser
//PUNICODE_STRING GlobalLogonUser;

// Replaced by pResults->Global.pLogonDomainName
//PUNICODE_STRING GlobalLogonDomainName;

// Replaced by pResults->Global.pLogonDomain
//PTESTED_DOMAIN GlobalLogonDomain;

// Replaced by pResults->Global.fLogonWithCachedCredentials
//BOOLEAN GlobalLogonWithCachedCredentials = FALSE;

//
// A Zero GUID for comparison
//

GUID NlDcZeroGuid;

//
// State determined by previous tests
//

// Replaced by pResults->Global.fNetlogonIsRunning
//BOOL GlobalNetlogonIsRunning = FALSE;   // Netlogon is running on this machine

// !!! not replaced yet
// Replaced by pResults->Global.fKerberosIsWorking
//BOOL GlobalKerberosIsWorking = FALSE;   // Kerberos is working

//
// Netbios name of this machine
//

// Replaced by pResults->Global.swzNetBiosName
//WCHAR GlobalNetbiosComputerName[MAX_COMPUTERNAME_LENGTH+1];

// Replaced by pResults->Global.szDnsHostName
//CHAR GlobalDnsHostName[DNS_MAX_NAME_LENGTH+1];

// Replaced by pResults->Global.pszDnsDomainName
//LPSTR GlobalDnsDomainName;


//(nsun) this macro already exists in <objbase.h>
//
// Macro for comparing GUIDs
//
/*
#define InlineIsEqualGUID(rguid1, rguid2)  \
        (((PLONG) rguid1)[0] == ((PLONG) rguid2)[0] &&   \
        ((PLONG) rguid1)[1] == ((PLONG) rguid2)[1] &&    \
        ((PLONG) rguid1)[2] == ((PLONG) rguid2)[2] &&    \
        ((PLONG) rguid1)[3] == ((PLONG) rguid2)[3])

#define IsEqualGUID(rguid1, rguid2) InlineIsEqualGUID(rguid1, rguid2)
*/

DSGETDCNAMEW NettestDsGetDcNameW;

PFNGUIDTOFRIENDLYNAME pfnGuidToFriendlyName = NULL;


/*---------------------------------------------------------------------------
    Function prototypes
 ---------------------------------------------------------------------------*/
HRESULT LoadNamesForListOfTests();
void    FreeNamesForListOfTests();
void DoGlobalPrint(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults);
void DoPerInterfacePrint(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults);



/*---------------------------------------------------------------------------
    Functions provided by ipconfig
 ---------------------------------------------------------------------------*/

#define DECLARE_TEST_FUNCTIONS(_test) \
    HRESULT _test##Test(NETDIAG_PARAMS *, NETDIAG_RESULT *); \
    void _test##GlobalPrint(NETDIAG_PARAMS *, NETDIAG_RESULT *); \
    void _test##PerInterfacePrint(NETDIAG_PARAMS *, NETDIAG_RESULT *, INTERFACE_RESULT *); \
    void _test##Cleanup(NETDIAG_PARAMS *, NETDIAG_RESULT *);


DECLARE_TEST_FUNCTIONS(IpConfig);
DECLARE_TEST_FUNCTIONS(Member);
DECLARE_TEST_FUNCTIONS(IpLoopBk);
DECLARE_TEST_FUNCTIONS(NetBT);
DECLARE_TEST_FUNCTIONS(Autonet);
DECLARE_TEST_FUNCTIONS(DefGw);
DECLARE_TEST_FUNCTIONS(NbtNm);
DECLARE_TEST_FUNCTIONS(Wins);
DECLARE_TEST_FUNCTIONS(Bindings);
DECLARE_TEST_FUNCTIONS(Dns);
DECLARE_TEST_FUNCTIONS(Browser);
DECLARE_TEST_FUNCTIONS(Winsock);
DECLARE_TEST_FUNCTIONS(Route);
DECLARE_TEST_FUNCTIONS(Netstat);
DECLARE_TEST_FUNCTIONS(Ndis);
DECLARE_TEST_FUNCTIONS(WAN);
#ifndef _WIN64
//Netware and IPX support is removed from WIN64
DECLARE_TEST_FUNCTIONS(Netware);
DECLARE_TEST_FUNCTIONS(Ipx);
#endif
DECLARE_TEST_FUNCTIONS(Trust);
DECLARE_TEST_FUNCTIONS(Modem);
DECLARE_TEST_FUNCTIONS(Kerberos);
DECLARE_TEST_FUNCTIONS(DcList);
DECLARE_TEST_FUNCTIONS(LDAP);
DECLARE_TEST_FUNCTIONS(DsGetDc);
DECLARE_TEST_FUNCTIONS(IPSec);


//////////////////////////////////////////////////////////////////////////////
//
// List of tests to run
//
//////////////////////////////////////////////////////////////////////////////

typedef struct
{
    // Each of these strings has a max of 256 characters
    UINT    uIdsShortName;      // ID of the string for the short name
    UINT    uIdsLongName;       // ID of the string for the long name

    HRESULT (*TestProc)(NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults);
    void (*SystemPrintProc)(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pRes);
    void (*GlobalPrintProc)(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pRes);
    void (*PerInterfacePrintProc)(NETDIAG_PARAMS *pParams,
                                  NETDIAG_RESULT *pRes,
                                  INTERFACE_RESULT *pIfRes);
    void (*CleanupProc)(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults);
    BOOL    fSkippable;
    BOOL    fPerDomainTest;
    BOOL     fSkipped;
    BOOL    fPerformed;

    // We will call LoadString() on the id's above to get these
    // strings.
    LPTSTR  pszShortName;
    LPTSTR  pszLongName;
} TEST_INFO;


#define EACH_TEST(_szID, _uShortIDS, _uLongIDS, _skip, _perdomain) \
{ _uShortIDS, _uLongIDS, _szID##Test, NULL, _szID##GlobalPrint, \
    _szID##PerInterfacePrint, _szID##Cleanup, _skip, _perdomain, \
    FALSE, FALSE, NULL, NULL}

#define SYSTEM_PRINT_TEST(_szID, _uShortIDS, _uLongIDS, _skip, _perdomain) \
{ _uShortIDS, _uLongIDS, _szID##Test, _szID##GlobalPrint, NULL, \
    _szID##PerInterfacePrint, _szID##Cleanup, _skip, _perdomain, \
    FALSE, FALSE, NULL, NULL}

//
// Tests below are marked "skippable" unless subsequent tests will AV if the
// test isn't run.
//
static TEST_INFO s_rgListOfTests[] =
{
    // IP Configuration
    SYSTEM_PRINT_TEST( Ndis,    IDS_NDIS_SHORT, IDS_NDIS_LONG, FALSE, FALSE),
    EACH_TEST( IpConfig,IDS_IPCONFIG_SHORT, IDS_IPCONFIG_LONG,  TRUE, FALSE),
    EACH_TEST( Member,  IDS_MEMBER_SHORT,   IDS_MEMBER_LONG,    FALSE,FALSE),
    EACH_TEST( NetBT,   IDS_NETBT_SHORT,    IDS_NETBT_LONG,     FALSE,FALSE),
    EACH_TEST( Autonet, IDS_AUTONET_SHORT,  IDS_AUTONET_LONG,   TRUE, FALSE),
    EACH_TEST( IpLoopBk,IDS_IPLOOPBK_SHORT, IDS_IPLOOPBK_LONG,  TRUE, FALSE),
    EACH_TEST( DefGw,   IDS_DEFGW_SHORT,    IDS_DEFGW_LONG,     TRUE, FALSE),
    EACH_TEST( NbtNm,   IDS_NBTNM_SHORT,    IDS_NBTNM_LONG,     TRUE, FALSE),
    EACH_TEST( Wins,    IDS_WINS_SHORT,     IDS_WINS_LONG,      TRUE, FALSE),
    EACH_TEST( Winsock, IDS_WINSOCK_SHORT,  IDS_WINSOCK_LONG,   TRUE, FALSE),
    EACH_TEST( Dns,     IDS_DNS_SHORT,      IDS_DNS_LONG,       TRUE, FALSE),
    EACH_TEST( Browser, IDS_BROWSER_SHORT,  IDS_BROWSER_LONG,   TRUE, FALSE),
    EACH_TEST( DsGetDc, IDS_DSGETDC_SHORT,  IDS_DSGETDC_LONG,   TRUE, TRUE ),
    EACH_TEST( DcList,  IDS_DCLIST_SHORT,   IDS_DCLIST_LONG,    TRUE, TRUE ),
    EACH_TEST( Trust,   IDS_TRUST_SHORT,    IDS_TRUST_LONG,     TRUE, FALSE),
    EACH_TEST( Kerberos,IDS_KERBEROS_SHORT, IDS_KERBEROS_LONG,  TRUE, FALSE ),
    EACH_TEST( LDAP,    IDS_LDAP_SHORT, IDS_LDAP_LONG,          TRUE,  TRUE ),
    EACH_TEST( Route,   IDS_ROUTE_SHORT, IDS_ROUTE_LONG, TRUE, FALSE ),
    EACH_TEST( Netstat, IDS_NETSTAT_SHORT, IDS_NETSTAT_LONG, TRUE, FALSE),
    EACH_TEST( Bindings,IDS_BINDINGS_SHORT, IDS_BINDINGS_LONG,  TRUE, FALSE),
    EACH_TEST( WAN,     IDS_WAN_SHORT,      IDS_WAN_LONG,       TRUE, FALSE),
    EACH_TEST( Modem,   IDS_MODEM_SHORT,    IDS_MODEM_LONG,     TRUE, FALSE),
#ifndef _WIN64
//Netware and IPX support is removed from WIN64
    EACH_TEST( Netware, IDS_NETWARE_SHORT,  IDS_NETWARE_LONG,   TRUE, FALSE),
    EACH_TEST( Ipx,     IDS_IPX_SHORT,      IDS_IPX_LONG,       TRUE, FALSE),
#endif
    EACH_TEST( IPSec,   IDS_IPSEC_SHORT,    IDS_IPSEC_LONG,     TRUE, FALSE)

};


/////////////////////////////////////////////////////////////////////////////
//
// List of problems and the corresponding tests to run
//
/////////////////////////////////////////////////////////////////////////////


// max no of tests
#define NO_OF_TESTS 25

typedef BOOL (*FuncPtr)(NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults);

typedef struct _A_PROBLEM {
    LPTSTR problem; // Problem description
    LONG n; // no of tests
    FuncPtr TestProc[NO_OF_TESTS];
} A_PROBLEM;

// Number of problems defined
#define NO_OF_PROBLEMS 2

A_PROBLEM ListOfProblems[] = {
    _T("Fake test"),  1 , IpConfigTest, NULL, NULL,NULL,NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL
//    "Not Able to Reach Other Segments Of the Network",  1 , DefGwTest, NULL, NULL,NULL,NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,
//    "Not Able to Resolve NetBios Names",  1 , WINSTest, NULL, NULL,NULL,NULL,NULL,NULL,NULL, NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL
};


/*!--------------------------------------------------------------------------
    ParseArgs

    Routine Description:
        Parse the command line arguments

    Arguments:
        argc - the number of command-line arguments.
        argv - an array of pointers to the arguments.
        pParams - this function sets these values
        pResults - additional output

    Return Value:
        0: All OK
        Exit status
    Author: KennT
 ---------------------------------------------------------------------------*/
int
ParseArgs(
          IN int argc,
          IN TCHAR ** argv,
          IN OUT NETDIAG_PARAMS *pParams,
          IN OUT NETDIAG_RESULT *pResults
         )
{
    LPSTR pszArgument;
    LPSTR TestName;
    int ArgumentIndex;
    ULONG i;
    BOOL  SeenTestOption = FALSE;
    PTESTED_DOMAIN pQueriedDomain;

    //
    // Flags used by problem option
    //

    BOOL OtherOptions = FALSE;

    //
    // Set the defaults
    //

    pParams->fVerbose = TRUE;
    pParams->fReallyVerbose = FALSE;
    pParams->fDebugVerbose = FALSE;
    pParams->fFixProblems = FALSE;
    pParams->fDcAccountEnum = FALSE;

    pParams->fProblemBased = FALSE;
    pParams->nProblemNumber = 0;


    //
    // Loop through the arguments handle each in turn
    //

    for ( ArgumentIndex=1; ArgumentIndex<argc; ArgumentIndex++ ) {

        pszArgument = argv[ArgumentIndex];

        if ( StriCmp( pszArgument, _T("/q") ) == 0 ||
             StriCmp( pszArgument, _T("-q") ) == 0 )
        {
            if ( pParams->fReallyVerbose || pParams->fProblemBased )
            {
                goto Usage;
            }
            pParams->fVerbose = FALSE;
            OtherOptions = TRUE;
        }
        else if ( StriCmp( pszArgument, _T("/v") ) == 0 ||
                  StriCmp( pszArgument, _T("-v") ) == 0 )
        {
            if ( !pParams->fVerbose || pParams->fProblemBased)
            {
                goto Usage;
            }
            pParams->fVerbose = TRUE;
            pParams->fReallyVerbose = TRUE;
            OtherOptions = TRUE;

        }
        else if ( StriCmp( pszArgument, _T("/debug") ) == 0 ||
                  StriCmp( pszArgument, _T("-debug") ) == 0 )
        {
            if ( !pParams->fVerbose || pParams->fProblemBased)
            {
                goto Usage;
            }
            pParams->fVerbose = TRUE;
            pParams->fReallyVerbose = TRUE;
            pParams->fDebugVerbose = TRUE;
            OtherOptions = TRUE;

        }
        else if ( StriCmp( pszArgument, _T("/fix") ) == 0 ||
                  StriCmp( pszArgument, _T("-fix") ) == 0 )
        {
            if (pParams->fProblemBased)
               goto Usage;

            pParams->fFixProblems = TRUE;
            OtherOptions = TRUE;

        }
        else if ( StriCmp( pszArgument, _T("/DcAccountEnum") ) == 0 ||
                  StriCmp( pszArgument, _T("-DcAccountEnum") ) == 0 )
        {
            if (pParams->fProblemBased)
               goto Usage;

            pParams->fDcAccountEnum = TRUE;
            OtherOptions = TRUE;

        //
        // Allow the caller to specify the name of a domain to query.
        //
        }
        else if ( StrniCmp( pszArgument, _T("/d:"), 3 ) == 0 ||
                  StrniCmp( pszArgument, _T("-d:"), 3 ) == 0 )
        {
            WCHAR UnicodeDomainName[MAX_PATH+1];

            if (pParams->fProblemBased)
                goto Usage;

            OtherOptions = TRUE;
            NetpCopyStrToWStr( UnicodeDomainName, &pszArgument[3] );

            pQueriedDomain = AddTestedDomain(pParams, pResults,
                UnicodeDomainName, NULL, FALSE );

            if ( pQueriedDomain == NULL )
            {
                goto Usage;
            }

        //
        // Allow the caller to skip certain tests
        //

        }
        else if ( StrniCmp( pszArgument, _T("/skip:"), 6 ) == 0 ||
                  StrniCmp( pszArgument, _T("-skip:"), 6 ) == 0 )
        {

            TestName = &pszArgument[6];
            OtherOptions = TRUE;

            if (pParams->fProblemBased)
                goto Usage;

            for ( i=0; i < DimensionOf(s_rgListOfTests); i++)
            {
                if ( StriCmp( s_rgListOfTests[i].pszShortName, TestName ) == 0 )
                {
                    //
                    // If the caller specified a non-optional test,
                    //  tell him.
                    //

                    if ( !s_rgListOfTests[i].fSkippable )
                    {
                        //IDS_GLOBAL_NOT_OPTIONAL        "'%s' is not an optional test.\n"
                        PrintMessage(pParams, IDS_GLOBAL_NOT_OPTIONAL, TestName );
                        goto Usage;
                    }

                    s_rgListOfTests[i].fSkipped = TRUE;
                    break;
                }
            }

            if ( i >= DimensionOf(s_rgListOfTests) )
            {
                //IDS_GLOBAL_NOT_VALID_TEST     "'%s' is not an valid test name.\n"
                PrintMessage( pParams, IDS_GLOBAL_NOT_VALID_TEST, TestName );
                goto Usage;
            }

        //
        // Handle all other parameters
        //

        }
        else if ( StrniCmp( pszArgument, _T("/test:"),6 ) == 0 ||
                  StrniCmp( pszArgument, _T("-test:"),6 ) == 0 )
        {

            TestName = &pszArgument[6];
            OtherOptions = TRUE;

            if (pParams->fProblemBased)
                goto Usage;

            for ( i =0; i < DimensionOf(s_rgListOfTests); i++)
            {
                if ( StriCmp( s_rgListOfTests[i].pszShortName, TestName ) == 0)
                       s_rgListOfTests[i].fSkipped = FALSE;
                else {
                   if (!SeenTestOption && s_rgListOfTests[i].fSkippable)
                       s_rgListOfTests[i].fSkipped = TRUE;
               }
            }
           SeenTestOption = TRUE;
        }
        else if( StrniCmp( pszArgument, _T("/l"), 5) == 0 ||
                 StrniCmp( pszArgument, _T("-l"), 5) == 0 )
        {
			/* We change to always log the output
            pParams->pfileLog = fopen(c_szLogFileName, "wt");
            if( NULL == pParams->pfileLog )
            {
                //IDS_NETTEST_LOGFILE_ERROR "[ERROR]    Cannot open %s to log output!\n"
                PrintMessage(pParams, IDS_NETTEST_LOGFILE_ERROR, c_szLogFileName);
                return 1;
            }
            else
            {
                pParams->fLog = TRUE;
            }
			*/
        }
/*$REVIEW (nsun) we won't support problem configuration for NT5.0
        else if ( StrniCmp( pszArgument, _T("/problem:"),9) == 0 ||
                  StrniCmp( pszArgument, _T("-problem:"),9) == 0 )
        {

           TestName = &pszArgument[9];

           i = atoi(TestName);

           if ( i > NO_OF_PROBLEMS)
           {
              printf("Incorrect problem number\n");
              exit(0);
           }

           if (OtherOptions)
              goto Usage;

           pParams->fProblemBased = TRUE;
           pParams->nProblemNumber = i-1;
        }
*/
        else
        {
Usage:
            // IDS_NETTEST_17000 "\nUsage: %s [/Options]>\n", argv[0] );
            // IDS_NETTEST_17001 "   /q - Quiet output (errors only)\n" );
            // IDS_NETTEST_17002 "   /v - Verbose output \n");
            // IDS_NETTEST_LOG   "   /l - Log output to NetDiag.log \n"
            // IDS_NETTEST_17003 "   /debug - Even more verbose.\n");
            // IDS_NETTEST_17004 "   /d:<DomainName> - Find a DC in the specified domain.\n");
            // IDS_NETTEST_17005 "   /fix - fix trivial problems.\n");
            // IDS_NETTEST_17006 "   /DcAccountEnum - Enumerate DC machine accounts.\n");
            // IDS_NETTEST_17007 "   /test:<test name>  - tests only this test. Non - skippable tests will still be run\n");
            // IDS_NETTEST_17008 "   Valid tests are :-\n");
            PrintMessage(pParams, IDS_NETTEST_17000, argv[0]);
            PrintMessage(pParams, IDS_NETTEST_17001);
            PrintMessage(pParams, IDS_NETTEST_17002);
            PrintMessage(pParams, IDS_NETTEST_LOG);
            PrintMessage(pParams, IDS_NETTEST_17003);
            PrintMessage(pParams, IDS_NETTEST_17004);
            PrintMessage(pParams, IDS_NETTEST_17005);
            PrintMessage(pParams, IDS_NETTEST_17006);
            PrintMessage(pParams, IDS_NETTEST_17007);
            PrintMessage(pParams, IDS_NETTEST_17008);

            for ( i =0; i < DimensionOf(s_rgListOfTests); i++)
            {
                // IDS_GLOBAL_TEST_NAME     "        %s - %s Test\n"
                PrintMessage(pParams, IDS_GLOBAL_TEST_NAME,
                       s_rgListOfTests[i].pszShortName,
                       s_rgListOfTests[i].pszLongName);
            }

            // IDS_GLOBAL_SKIP              "   /skip:<TestName> - skip the named test.  Valid tests are:\n"
            PrintMessage( pParams, IDS_GLOBAL_SKIP_OPTION);
            for ( i =0; i < DimensionOf(s_rgListOfTests); i++)
            {
                if ( s_rgListOfTests[i].fSkippable )
                {
                    // IDS_GLOBAL_TEST_NAME     "        %s - %s Test\n"
                    PrintMessage( pParams,
                           IDS_GLOBAL_TEST_NAME,
                           s_rgListOfTests[i].pszShortName,
                           s_rgListOfTests[i].pszLongName );
                }
            }
            return 1;
        }
    }

    return 0;
}





int __cdecl
main(
    IN int argc,
    IN TCHAR ** argv
    )
{
    int RetVal;
    LONG i;
    LONG err;
    BOOL Failed = FALSE;
    int     iWSAStatus;
    HRESULT hr = hrOK;

    NETDIAG_PARAMS Params;
    NETDIAG_RESULT Results;

	// set the locale to the system default
	setlocale( LC_ALL, "");

    // Turn on debug checking
    // ----------------------------------------------------------------
#ifdef _DEBUG
    int     tmpFlag;

    tmpFlag = _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG);

    tmpFlag |= _CRTDBG_CHECK_ALWAYS_DF;
    tmpFlag |= _CRTDBG_DELAY_FREE_MEM_DF;
    tmpFlag |= _CRTDBG_LEAK_CHECK_DF;

//  _CrtSetDbgFlag( tmpFlag );
#endif

    // Global initialization.
    // ----------------------------------------------------------------
    RtlZeroMemory( &NlDcZeroGuid, sizeof(NlDcZeroGuid) );
    ZeroMemory(&Params, sizeof(NETDIAG_PARAMS));
    ZeroMemory(&Results, sizeof(NETDIAG_RESULT));

    InitializeListHead( &Results.NetBt.Transports );
//    InitializeListHead( &GlobalNetbtTransports );
//    InitializeListHead( &GlobalTestedDomains );
    InitializeListHead( &Results.Global.listTestedDomains );
//    GlobalDnsHostName[0] = 0;
//    GlobalDhcpEnabled = FALSE;
//    GlobalDnsDomainName = NULL;

    // Load the names of all the tests (this is used by the ParseArgs).
    // which is why it needs to get loaded first.
    // ----------------------------------------------------------------
    CheckHr( LoadNamesForListOfTests() );

    // Parse input flags.
    // ----------------------------------------------------------------
    RetVal = ParseArgs( argc, argv, &Params, &Results);
    if ( RetVal != 0 )
    {
        return 1;
    }

	Params.pfileLog = fopen(c_szLogFileName, "wt");
    if( NULL == Params.pfileLog )
    {
        //IDS_NETTEST_LOGFILE_ERROR "[ERROR]    Cannot open %s to log output!\n"
        PrintMessage(&Params, IDS_NETTEST_LOGFILE_ERROR, c_szLogFileName);
    }
    else
    {
        Params.fLog = TRUE;
    }


    // Initialize Winsock
    // ----------------------------------------------------------------
    iWSAStatus = WsaInitialize(&Params, &Results);
    if ( iWSAStatus )
    {
        return 1;
    }

/*
   if (pParams->fProblemBased) {
    for (i =0; i < ListOfProblems[pParams->nProblemNumber].n; i++) {
       if ( !(*ListOfProblems[pParams->nProblemNumber].TestProc[i])((PVOID)NULL) )
            Failed = TRUE;
     }

   if (Failed)
      PrintMessage(pParams, IDS_GLOBAL_Problem);
   else
      PrintMessage(pParams, IDS_GLOBAL_NoProblem);
   return 0;
   }
*/

    // Get the NetBIOS computer name of this computer
    // ----------------------------------------------------------------
    CheckHr( GetComputerNameInfo(&Params, &Results) );


    // Get the DNS host name and DNS domain.
    // ----------------------------------------------------------------
    CheckHr( GetDNSInfo(&Params, &Results) );


    // Get OS-version info, etc..
    // ----------------------------------------------------------------
    CheckHr( GetMachineSpecificInfo(&Params, &Results) );


    // Other non-ip config info - Rajkumar
    // ----------------------------------------------------------------
    CheckHr( GetNetBTParameters(&Params, &Results) );

    if ( Params.fVerbose )
    {
        PrintNewLine(&Params, 1);
    }

    //
    // Grab all the information from the registry that 'ipconfig /all'
    //  would print.
    //
    // This routine doesn't always return on fatal errors.
    //

    hr = InitIpconfig(&Params, &Results);
    if (!FHrSucceeded(hr))
    {
        PrintMessage(&Params, IDS_GLOBAL_NoIpCfg);
        CheckHr( hr );
    }

#ifndef _WIN64
    hr = InitIpxConfig(&Params, &Results);
    if (!FHrSucceeded(hr))
    {
        CheckHr( hr );
    }
#endif

    //
    // Determine if any adapter has DHCP enabled.
    //
    for ( i = 0; i<Results.cNumInterfaces; i++)
    {
        if (Results.pArrayInterface[i].IpConfig.fActive &&
            Results.pArrayInterface[i].IpConfig.pAdapterInfo->DhcpEnabled)
        {
            Results.IpConfig.fDhcpEnabled = TRUE;
            break;
        }
    }

    //if to detect a predefined problem
    if (Params.fProblemBased) {
        for (i =0; i < ListOfProblems[Params.nProblemNumber].n; i++) {
            if ( !(*ListOfProblems[Params.nProblemNumber].TestProc[i])(&Params, &Results) )
                Failed = TRUE;
        }

        if (Failed)
            PrintMessage(&Params, IDS_GLOBAL_Problem);
        else
            PrintMessage(&Params, IDS_GLOBAL_NoProblem);
        return 0;
    }

    //
    // Test individual components
    //

    for ( i=0; i < DimensionOf(s_rgListOfTests); i++ )
    {
        // If the caller wanted to skip this test,
        //  do so now.
        // ------------------------------------------------------------
        if ( s_rgListOfTests[i].fSkipped )
            continue;


        //We will perform this test
        s_rgListOfTests[i].fPerformed = TRUE;

        //
        // If the test is to be run for each tested domain,
        //  do so.
        //

        if ( s_rgListOfTests[i].fPerDomainTest )
        {
            PTESTED_DOMAIN TestedDomain;
            PLIST_ENTRY pListEntry;


            //
            // Loop through the list of tested domains
            //

            for ( pListEntry = Results.Global.listTestedDomains.Flink ;
                  pListEntry != &Results.Global.listTestedDomains ;
                  pListEntry = pListEntry->Flink ) {

                //
                // If the entry is found,
                //  use it.
                //

                TestedDomain = CONTAINING_RECORD( pListEntry, TESTED_DOMAIN, Next );

                Params.pDomain = TestedDomain;

                //
                // Run this test.
                //

                if ( FHrFailed((*s_rgListOfTests[i].TestProc)(&Params, &Results))) {
                    Failed = TRUE;
                }
            }

            //
            // If any test failed,
            //  we're done.
            //

            if ( Failed ) {
                goto Print_Results;
            }

        //
        // If the test is to be run just once,
        //  do it.
        //

        } else {

            //
            // Run this test.
            //

            if ( FHrFailed((*s_rgListOfTests[i].TestProc)(&Params, &Results)))
            {
                goto Print_Results;
            }
        }
    }


Print_Results:
    // Now that we've run through all of the tests, run through the
    // print outs


    if (Params.fReallyVerbose)
    {
        // IDS_GLOBAL_COMPLETE      "\n    Tests complete.\n\n\n"
        PrintMessage( &Params, IDS_GLOBAL_COMPLETE );
    }
    else
    {
        PrintNewLine(&Params, 2);
    }

    DoSystemPrint(&Params, &Results);

    DoPerInterfacePrint(&Params, &Results);

    DoGlobalPrint(&Params, &Results);

    //
    // All tests passed.
    //
    // IDS_GLOBAL_SUCCESS       "\nThe command completed successfully\n"

    PrintMessage( &Params, IDS_GLOBAL_SUCCESS);

Error:
    FreeNamesForListOfTests();

    if(Params.pfileLog != NULL && Params.fLog)
    {
        fclose(Params.pfileLog);
    }

    ResultsCleanup(&Params, &Results);

    return hr != S_OK;

}



HRESULT LoadNamesForListOfTests()
{
    int     i;
    TCHAR   szBuffer[256];

    for (i=0; i < DimensionOf(s_rgListOfTests); i++)
    {
        szBuffer[0] = 0;
        LoadString(NULL, s_rgListOfTests[i].uIdsShortName, szBuffer,
                   DimensionOf(szBuffer));
        s_rgListOfTests[i].pszShortName = _tcsdup(szBuffer);

        szBuffer[0] = 0;
        LoadString(NULL, s_rgListOfTests[i].uIdsLongName, szBuffer,
                   DimensionOf(szBuffer));
        s_rgListOfTests[i].pszLongName = StrDup(szBuffer);
    }
    return hrOK;
}

void FreeNamesForListOfTests()
{
    int     i;

    for (i=0; i < DimensionOf(s_rgListOfTests); i++)
    {
        Free(s_rgListOfTests[i].pszShortName);
        s_rgListOfTests[i].pszShortName = NULL;

        Free(s_rgListOfTests[i].pszLongName);
        s_rgListOfTests[i].pszLongName = NULL;
    }
}


void DoSystemPrint(IN NETDIAG_PARAMS *pParams,
                   IN NETDIAG_RESULT *pResults)
{
    int     cInstalled;
    int     i;
    int     ids;
    
    PrintMessage(pParams, IDSWSZ_GLOBAL_ComputerName, pResults->Global.swzNetBiosName);
    PrintMessage(pParams, IDSSZ_GLOBAL_DnsHostName, pResults->Global.szDnsHostName );
    if (pParams->fReallyVerbose)
        PrintMessage(pParams, IDSSZ_DnsDomainName,
                     pResults->Global.pszDnsDomainName);
    
    // "    System info : %s (Build %s)\n" 
    PrintMessage(pParams, IDS_MACHINE_15801,
           pResults->Global.pszServerType,
           pResults->Global.pszCurrentBuildNumber);
    
    // "    Processor : %s\n" 
    PrintMessage(pParams, IDS_MACHINE_15802,
           pResults->Global.pszProcessorInfo);

    if (pResults->Global.cHotFixes == 0)
        // "    Hotfixes : none detected\n" 
        PrintMessage(pParams, IDS_MACHINE_15803);
    else
    {
        // If in Verbose mode, only print out the hotfixes that are
        // installed

        if (pParams->fReallyVerbose)
        {
            // print out a list of all hotfixes
            // "    Hotfixes :\n" 
            PrintMessage(pParams, IDS_MACHINE_15804);
            
            // "        Installed?      Name\n" 
            PrintMessage(pParams, IDS_MACHINE_15805);
            for (i=0; i<pResults->Global.cHotFixes; i++)
            {
                if (pResults->Global.pHotFixes[i].fInstalled)
                    ids = IDS_MACHINE_YES_INSTALLED;
                else
                    ids = IDS_MACHINE_NO_INSTALLED;
                    PrintMessage(pParams, ids,
                                 pResults->Global.pHotFixes[i].pszName);
            }
        }
        else
        {
            // print out a list of the installed hotfixes
            // count the number of installed hotfixes
            cInstalled = 0;
            for (i=0; i<pResults->Global.cHotFixes; i++)
            {
                if (pResults->Global.pHotFixes[i].fInstalled)
                    cInstalled++;
            }

            if (cInstalled == 0)
            {
                // "    Hotfixes : not hotfixes have been installed\n" 
                PrintMessage(pParams, IDS_MACHINE_15806);
            }
            else
            {
                // "    List of installed hotfixes : \n" 
                PrintMessage(pParams, IDS_MACHINE_15807);
                for (i=0; i<pResults->Global.cHotFixes; i++)
                {
                    if (pResults->Global.pHotFixes[i].fInstalled)
                    {
                        //  "        %s\n" 
                        PrintMessage(pParams, IDS_MACHINE_15808, pResults->Global.pHotFixes[i].pszName);
                    }
                }
            }
        }
    }   


    for ( i=0; i < DimensionOf(s_rgListOfTests); i++ )
    {
        // If the caller wanted to skip this test,
        //  do so now.
        // ------------------------------------------------------------
        if ( s_rgListOfTests[i].fSkipped  || !s_rgListOfTests[i].fPerformed)
            continue;

        if(s_rgListOfTests[i].SystemPrintProc)
            s_rgListOfTests[i].SystemPrintProc(pParams, pResults);
    }
    PrintNewLine(pParams, 1);

}


void DoGlobalPrint(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults)
{
    int     i;

    // IDS_GLOBAL_RESULTS       "\nGlobal results\n\n"
    PrintMessage( pParams, IDS_GLOBAL_RESULTS );
    for ( i=0; i < DimensionOf(s_rgListOfTests); i++ )
    {
        // If the caller wanted to skip this test,
        //  do so now.
        // ------------------------------------------------------------
        if ( s_rgListOfTests[i].fSkipped || !s_rgListOfTests[i].fPerformed)
            continue;

        if(s_rgListOfTests[i].GlobalPrintProc)
            s_rgListOfTests[i].GlobalPrintProc(pParams, pResults);
    }
    PrintNewLine(pParams, 1);
}

void DoPerInterfacePrint(NETDIAG_PARAMS *pParams,
                         NETDIAG_RESULT *pResults)
{
    int     i, iIf;
    INTERFACE_RESULT *  pIfResult;

    //IDS_GLOBAL_INTERFACE_RESULTS  "\nPer interface results:\n\n"
    PrintMessage( pParams, IDS_GLOBAL_INTERFACE_RESULTS );
    // Loop through the interfaces
    for ( iIf = 0; iIf < pResults->cNumInterfaces; iIf++)
    {
        pIfResult = pResults->pArrayInterface + iIf;

        if (!pIfResult->fActive)
            continue;

        PrintNewLine(pParams, 1);

        // Print out the interface name
        PrintMessage(pParams, IDSSZ_IPCFG_Adapter,
                     pResults->pArrayInterface[iIf].pszFriendlyName ?
                     pResults->pArrayInterface[iIf].pszFriendlyName :
                     MapGuidToAdapterName(pIfResult->IpConfig.pAdapterInfo->AdapterName));

        if (pParams->fReallyVerbose)
            PrintMessage(pParams, IDS_IPCFG_10004,
                         pResults->pArrayInterface[iIf].pszName);

        for ( i=0; i < DimensionOf(s_rgListOfTests); i++ )
        {
            // If the caller wanted to skip this test,
            //  do so now.
            // ------------------------------------------------------------
            if ( s_rgListOfTests[i].fSkipped || !s_rgListOfTests[i].fPerformed )
                continue;

            s_rgListOfTests[i].PerInterfacePrintProc(pParams, pResults,
                pIfResult);
        }

        fflush(stdout);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\precomp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       precomp.h
//
//--------------------------------------------------------------------------

#include "ndcommon.h"
// Porting to Source Depot - smanda #include <nlcommon.h>
#include <winsock2.h>
#include "ndstruct.h"
#include "params.h"
#include "results.h"
#include "netdiag.h"
#include "resource.h"

#include "dcutil.h"
#include "domutil.h"

#include "xportst.h"
#include "format.h"

#include "tfschar.h"

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\nwtest.h ===
/*--

Copyright (C) Microsoft Corporation, 1999 - 1999 

Module Name:

    nwtest.h

Abstract:

    This module contains definitions, includes and function prototypes needed for
    the netware test.

Environment:

    User mode.

Revision History:

    4-Aug-1998 (t-rajkup)

--*/

#ifndef HEADER_NWTEST
#define NWTEST

#include <ntregapi.h> //KEY_READ define
#include <nwrnames.h> // NW_SERVER_VALUENAME & NW_PRINT_OPTION_DEFAULT
#include <winreg.h>
// porting to Source Depot - smanda #include <ntddnwfs.h>
// porting to Source Depot - smanda #include <nwutil.h> // TWO_KB
// porting to Source Depot - smanda #include <ndsapi32.h> // HANDLE_TYPE_NCP_SERVER
#include <winuser.h>

// includes for WNet API calls
#include <nspapi.h>
#include <winnetwk.h>

#define ARGUMENT_PRESENT(ArgumentPointer)    (\
    (CHAR *)(ArgumentPointer) != (CHAR *)(NULL) )

#define TREECHAR   L'*'

#define NW_MESSAGE_NOT_LOGGED_IN_TREE                  1
#define NW_MESSAGE_NOT_LOGGED_IN_SERVER                2
#define NW_MESSAGE_LOGGED_IN_SERVER                    3
#define NW_MESSAGE_LOGGED_IN_TREE                      4

#define  EXTRA_BYTES  256
#define TWO_KB   2048

//
// Flags used for the function NwParseNdsUncPath()
//
#define  PARSE_NDS_GET_TREE_NAME    0
#define  PARSE_NDS_GET_PATH_NAME    1
#define  PARSE_NDS_GET_OBJECT_NAME  2

//
// Commonly reference value for NCP Server name length
//
#define NW_MAX_SERVER_LEN      48



//
// CONN_STATUS structures for the new shell.
//

typedef struct _CONN_STATUS {
    DWORD   dwTotalLength;     // The total length including packed strings.
    LPWSTR  pszServerName;     // The server name.
    LPWSTR  pszUserName;       // The user name.
    LPWSTR  pszTreeName;       // The tree name or NULL for a 2.x or 3.x server.
    DWORD   nConnNum;          // The connection number used on nw srv.
    BOOL    fNds;              // TRUE if NDS, False for Bindery servers
    BOOL    fPreferred;        // TRUE if the connection is a preferred server with no explicit uses.
    DWORD   dwConnType;        // Authentication status of the connection.
} CONN_STATUS, *PCONN_STATUS;

#define NW_CONN_NOT_AUTHENTICATED            0x00000000
#define NW_CONN_BINDERY_LOGIN                0x00000001
#define NW_CONN_NDS_AUTHENTICATED_NO_LICENSE 0x00000002
#define NW_CONN_NDS_AUTHENTICATED_LICENSED   0x00000003
#define NW_CONN_DISCONNECTED                 0x00000004

//
// NtDeviceIoControlFile/NtFsControlFile IoControlCode values for this device.
//
// Warning:  Remember that the low two bits of the code specify how the
//           buffers are passed to the driver!
//
//
//      Method = 00 - Buffer both input and output buffers for the request
//      Method = 01 - Buffer input, map output buffer to an MDL as an IN buff
//      Method = 10 - Buffer input, map output buffer to an MDL as an OUT buff
//      Method = 11 - Do not buffer either the input or output
//

#define IOCTL_NWRDR_BASE                  FILE_DEVICE_NETWORK_FILE_SYSTEM

#define _NWRDR_CONTROL_CODE(request, method, access) \
                CTL_CODE(IOCTL_NWRDR_BASE, request, method, access)

#define FSCTL_NWR_START                 _NWRDR_CONTROL_CODE(200, METHOD_IN_DIRECT, FILE_ANY_ACCESS)
#define FSCTL_NWR_STOP                  _NWRDR_CONTROL_CODE(201, METHOD_BUFFERED,  FILE_ANY_ACCESS)
#define FSCTL_NWR_LOGON                 _NWRDR_CONTROL_CODE(202, METHOD_BUFFERED,  FILE_ANY_ACCESS)
#define FSCTL_NWR_LOGOFF                _NWRDR_CONTROL_CODE(203, METHOD_BUFFERED,  FILE_ANY_ACCESS)
#define FSCTL_NWR_GET_CONNECTION        _NWRDR_CONTROL_CODE(204, METHOD_NEITHER,   FILE_ANY_ACCESS)
#define FSCTL_NWR_ENUMERATE_CONNECTIONS _NWRDR_CONTROL_CODE(205, METHOD_NEITHER,   FILE_ANY_ACCESS)
#define FSCTL_NWR_DELETE_CONNECTION     _NWRDR_CONTROL_CODE(207, METHOD_BUFFERED,  FILE_ANY_ACCESS)
#define FSCTL_NWR_BIND_TO_TRANSPORT     _NWRDR_CONTROL_CODE(208, METHOD_BUFFERED,  FILE_ANY_ACCESS)
#define FSCTL_NWR_CHANGE_PASS           _NWRDR_CONTROL_CODE(209, METHOD_BUFFERED,  FILE_ANY_ACCESS)
#define FSCTL_NWR_SET_INFO              _NWRDR_CONTROL_CODE(211, METHOD_BUFFERED,  FILE_ANY_ACCESS)

#define FSCTL_NWR_GET_USERNAME          _NWRDR_CONTROL_CODE(215, METHOD_NEITHER,   FILE_ANY_ACCESS)
#define FSCTL_NWR_CHALLENGE             _NWRDR_CONTROL_CODE(216, METHOD_BUFFERED,  FILE_ANY_ACCESS)
#define FSCTL_NWR_GET_CONN_DETAILS      _NWRDR_CONTROL_CODE(217, METHOD_NEITHER,   FILE_ANY_ACCESS)
#define FSCTL_NWR_GET_MESSAGE           _NWRDR_CONTROL_CODE(218, METHOD_NEITHER,   FILE_ANY_ACCESS)
#define FSCTL_NWR_GET_STATISTICS        _NWRDR_CONTROL_CODE(219, METHOD_NEITHER,   FILE_ANY_ACCESS)
#define FSCTL_NWR_GET_CONN_STATUS       _NWRDR_CONTROL_CODE(220, METHOD_NEITHER,   FILE_ANY_ACCESS)
#define FSCTL_NWR_GET_CONN_INFO         _NWRDR_CONTROL_CODE(221, METHOD_NEITHER,   FILE_ANY_ACCESS)
#define FSCTL_NWR_GET_PREFERRED_SERVER  _NWRDR_CONTROL_CODE(222, METHOD_NEITHER,   FILE_ANY_ACCESS)
#define FSCTL_NWR_GET_CONN_PERFORMANCE  _NWRDR_CONTROL_CODE(223, METHOD_NEITHER,   FILE_ANY_ACCESS)
#define FSCTL_NWR_SET_SHAREBIT          _NWRDR_CONTROL_CODE(224, METHOD_NEITHER,   FILE_ANY_ACCESS)
#define FSCTL_NWR_GET_CONN_DETAILS2     _NWRDR_CONTROL_CODE(225, METHOD_NEITHER,   FILE_ANY_ACCESS)
#define FSCTL_NWR_CLOSEALL              _NWRDR_CONTROL_CODE(226, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define FSCTL_NWR_NDS_SETCONTEXT        NWR_ANY_NDS(1)
#define FSCTL_NWR_NDS_GETCONTEXT        NWR_ANY_NDS(2)
#define FSCTL_NWR_NDS_VERIFY_TREE       NWR_ANY_NDS(3)
#define FSCTL_NWR_NDS_RESOLVE_NAME      NWR_ANY_NDS(4)
#define FSCTL_NWR_NDS_LIST_SUBS         NWR_ANY_NDS(5)
#define FSCTL_NWR_NDS_READ_INFO         NWR_ANY_NDS(6)
#define FSCTL_NWR_NDS_READ_ATTR         NWR_ANY_NDS(7)
#define FSCTL_NWR_NDS_OPEN_STREAM       NWR_ANY_NDS(8)
#define FSCTL_NWR_NDS_GET_QUEUE_INFO    NWR_ANY_NDS(9)
#define FSCTL_NWR_NDS_GET_VOLUME_INFO   NWR_ANY_NDS(10)
#define FSCTL_NWR_NDS_RAW_FRAGEX        NWR_ANY_NDS(11)
#define FSCTL_NWR_NDS_CHANGE_PASS       NWR_ANY_NDS(12)
#define FSCTL_NWR_NDS_LIST_TREES        NWR_ANY_NDS(13)

#define IOCTL_NWR_RAW_HANDLE            _NWRDR_CONTROL_CODE(1002,METHOD_NEITHER,   FILE_ANY_ACCESS)

//
//  UserNcp control code definitions. The parameter (X) to NWR_ANY_NCP
//  is the function code to be placed in the NCP.
//

#define NWR_ANY_NCP(X)                  _NWRDR_CONTROL_CODE(0x400 | (X), METHOD_NEITHER, FILE_ANY_ACCESS)
#define NWR_ANY_F2_NCP(X)               _NWRDR_CONTROL_CODE(0x500 | (X), METHOD_NEITHER, FILE_ANY_ACCESS)
#define NWR_ANY_HANDLE_NCP(X)           _NWRDR_CONTROL_CODE(0x600 | (X), METHOD_NEITHER, FILE_ANY_ACCESS)
#define NWR_ANY_NDS(X)                  _NWRDR_CONTROL_CODE(0x700 | (X), METHOD_NEITHER, FILE_ANY_ACCESS)

#define FSCTL_NWR_NCP_E3H               NWR_ANY_NCP(0x17)
#define FSCTL_NWR_NCP_E2H               NWR_ANY_NCP(0x16)
#define FSCTL_NWR_NCP_E1H               NWR_ANY_NCP(0x15)
#define FSCTL_NWR_NCP_E0H               NWR_ANY_NCP(0x14)

//
// Redirector Request Packet used by the Workstation service
// to pass parameters to the Redirector through Buffer 1 of
// NtFsControlFile.
//
// Additional output of each FSCtl is found in Buffer 2.
//

#define REQUEST_PACKET_VERSION  0x00000001L // Structure version.

typedef struct _NWR_REQUEST_PACKET {

    ULONG Version;                      // Version of structure in Buffer 2

    union {


        //
        // For FSCTL_NWR_BIND_TO_TRANSPORT
        //
        struct {
            ULONG QualityOfService;     // Quality of service indicator   IN
            ULONG TransportNameLength;  // Not including terminator       IN
            WCHAR TransportName[1];     // Name of transport provider     IN
        } Bind;


        //
        // For FSCTL_NWR_LOGON
        //
        struct {
            LUID LogonId;               // User logon session identifier  IN
            ULONG UserNameLength;       // Byte count not including NULL  IN
            ULONG PasswordLength;       // Byte count not including NULL  IN
            ULONG ServerNameLength;     // Byte count not including NULL  IN
            ULONG ReplicaAddrLength;    // IPX address of the nearest dir server
                                        // replica (for NDS login only).
                                        // It's either sizeof(TDI_ADDRESS_IPX)
                                        // or 0.                          IN
            ULONG PrintOption;          // Print options for user         IN
            WCHAR UserName[1];          // User name not NULL terminated. IN

            // Password string          // Default password for connection,
                                        //    not NULL terminated, packed
                                        //    in buffer immediately after
                                        //    UserName.                   IN

            // ServerName               // Preferred server name packed in
                                        //    buffer immediately after
                                        //    Password.                   IN

            // IpxAddress               // Address copied from the SAP response
                                        // packet, packed immediately after
                                        // the servername.                IN
        } Logon;

        //
        // For FSCTL_NWR_CHANGE_PASS
        //
        struct {

            ULONG UserNameLength;
            ULONG PasswordLength;
            ULONG ServerNameLength;
            WCHAR UserName[1];

            // Password string          // New password.                  IN

            // ServerName               // Server with the new password   IN

        } ChangePass;

        //
        // For FSCTL_NWR_LOGOFF
        //
        struct {
            LUID LogonId;               // User logon session identifier  IN
        } Logoff;

        //
        // For FSCTL_NWR_DELETE_CONNECTION
        //
        struct {
            BOOLEAN UseForce;           // Force flag                     IN
        } DeleteConn;

        //
        // For FSCTL_NWR_GET_CONNECTION
        //
        struct {
            ULONG BytesNeeded;          // Size (byte count) required of
                                        //    output buffer including
                                        //    terminator                  OUT
            ULONG DeviceNameLength;     // Not including terminator       IN
            WCHAR DeviceName[4];        // Name of DOS device             IN
        } GetConn;

        //
        // FSCTL_NWR_ENUMERATE_CONNECTIONS
        //
        struct {
            ULONG EntriesRequested;    // Number of entries to get        IN
            ULONG EntriesReturned;     // Entries returned in respose buf OUT
            ULONG_PTR ResumeKey;       // Handle to next entry to get     IN OUT
            ULONG BytesNeeded;         // Size (byte count) of next entry OUT
            ULONG ConnectionType;      // Resource type requested         IN
            LUID  Uid;                 // Uid to search for               IN
        } EnumConn;

        //
        // FSCTL_NWR_SET_INFO
        //
        struct {
            ULONG PrintOption;
            ULONG MaximumBurstSize;

            ULONG PreferredServerLength; // Byte count not including NULL  IN
            ULONG ProviderNameLength;    // Byte count not including NULL  IN
            WCHAR PreferredServer[1];    // Preferred server name not NULL
                                         // terminated.
            // ProviderName string       // Provider name not NULL terminated.
                                         // Packed in buffer immediately
                                         // after PreferredServer

        } SetInfo;

        //
        // FSCTL_NWR_GET_CONN_STATUS
        //
        struct {
            ULONG ConnectionNameLength; // IN: Length of the connection name we want.
            ULONG_PTR ResumeKey;        // IN: Resume key for a continued request.
            ULONG EntriesReturned;      // OUT: Entries returned in respose buffer.
            ULONG BytesNeeded;          // OUT: Size (byte count) of next entry.
            WCHAR ConnectionName[1];    // IN: Connection name described above.
        } GetConnStatus;

        //
        // FSCTL_NWR_GET_CONN_INFO
        //
        struct {
            ULONG ConnectionNameLength; // IN: Length of the connection name we want.
            WCHAR ConnectionName[1];    // IN: Connection name described above.
        } GetConnInfo;

        //
        // FSCTL_NWR_GET_CONN_PERFORMANCE
        //
        struct {

            //
            // These are the fields for the NETCONNECTINFOSTRUCT.
            //

            DWORD dwFlags;
            DWORD dwSpeed;
            DWORD dwDelay;
            DWORD dwOptDataSize;

            //
            // This is the remote name in question.
            //

            ULONG RemoteNameLength;
            WCHAR RemoteName[1];
        } GetConnPerformance;

        struct {
            ULONG DebugFlags;           // Value for NwDebug
        } DebugValue;

    } Parameters;

} NWR_REQUEST_PACKET, *PNWR_REQUEST_PACKET;

typedef struct _NWR_NDS_REQUEST_PACKET {

    //
    // Version of structure in Buffer 2.
    //

    ULONG Version;

    union {

        //
        //  For FSCTL_NWR_NDS_RESOLVE_NAME
        //

        struct {
            ULONG ObjectNameLength;         // IN
            DWORD ResolverFlags;            // IN
            DWORD BytesWritten;             // OUT
            WCHAR ObjectName[1];            // IN
        } ResolveName;

        //
        //  For FSCTL_NWR_NDS_READ_INFO
        //

        struct {
            DWORD ObjectId;                 // IN
            DWORD BytesWritten;             // OUT
        } GetObjectInfo;

        //
        //  For FSCTL_NWR_NDS_LIST_SUBS
        //

        struct {
            DWORD ObjectId;                 // IN
            DWORD_PTR IterHandle;           // IN
            DWORD BytesWritten;             // OUT
        } ListSubordinates;

        //
        // For FSCTL_NWR_NDS_READ_ATTR
        //

        struct {
            DWORD ObjectId;                 // IN
            DWORD_PTR IterHandle;           // IN
            DWORD BytesWritten;             // OUT
            DWORD AttributeNameLength;      // IN
            WCHAR AttributeName[1];         // IN
        } ReadAttribute;

        //
        // For FSCTL_NWR_NDS_OPEN_STREAM
        //

        struct {
            DWORD FileLength;                 // OUT
            DWORD StreamAccess;               // IN
            DWORD ObjectOid;                  // IN
            UNICODE_STRING StreamName;        // IN
            WCHAR StreamNameString[1];        // IN
        } OpenStream;

        //
        // For FSCTL_NWR_NDS_SET_CONTEXT
        //

        struct {
            DWORD TreeNameLen ;               // IN
            DWORD ContextLen;                 // IN
            WCHAR TreeAndContextString[1];    // IN
        } SetContext;

        //
        // For FSCTL_NWR_NDS_GET_CONTEXT
        //

        struct {
            UNICODE_STRING Context;           // OUT
            DWORD TreeNameLen ;               // IN
            WCHAR TreeNameString[1];          // IN
        } GetContext;

        //
        // For FSCTL_NWR_NDS_VERIFY_TREE
        //

        struct {
            UNICODE_STRING TreeName;          // IN
            WCHAR NameString[1];              // IN
        } VerifyTree;

        //
        // For FSCTL_NWR_NDS_GET_QUEUE_INFO
        //

        struct {
            UNICODE_STRING QueueName;          // IN
            UNICODE_STRING HostServer;         // OUT
            DWORD QueueId;                     // OUT
        } GetQueueInfo;

        //
        // For FSCTL_NWR_NDS_GET_VOLUME_INFO
        //

        struct {
            DWORD ServerNameLen;    // OUT
            DWORD TargetVolNameLen; // OUT
            DWORD VolumeNameLen;    // IN
            WCHAR VolumeName[1];    // IN
        } GetVolumeInfo;

        //
        // For FSCTL_NWR_NDS_RAW_FRAGEX
        //

        struct {
            DWORD NdsVerb;          // IN
            DWORD RequestLength;    // IN
            DWORD ReplyLength;      // OUT
            BYTE  Request[1];       // IN
        } RawRequest;

        //
        // For FSCTL_NWR_NDS_CHANGE_PASS
        //

        struct {

            DWORD NdsTreeNameLength;
            DWORD UserNameLength;
            DWORD CurrentPasswordLength;
            DWORD NewPasswordLength;

            //
            // The above strings should be end to
            // end starting at StringBuffer.
            //

            WCHAR StringBuffer[1];
        } ChangePass;

        //
        // For FSCTL_NWR_NDS_LIST_TREES
        //

        struct {

            DWORD NtUserNameLength;   // IN
            LARGE_INTEGER UserLuid;   // OUT
            DWORD TreesReturned;      // OUT
            WCHAR NtUserName[1];      // IN
        } ListTrees;

    } Parameters;

} NWR_NDS_REQUEST_PACKET, *PNWR_NDS_REQUEST_PACKET;


NTSTATUS
NwNdsOpenTreeHandle(
    IN PUNICODE_STRING puNdsTree,
    OUT PHANDLE  phNwRdrHandle
);

// NwNdsOpenTreeHandle( PUNICODE_STRING, PHANDLE )
//
// Given an NDS tree name, this opens a handle the the redirector
// for accessing that tree.  The handle should closed using the
// standard NT CloseHandle() call. This function is only a
// simple wrapper around NT OpenFile().

//
// Administrativa.
//

#define HANDLE_TYPE_NCP_SERVER  1
#define HANDLE_TYPE_NDS_TREE    2


NTSTATUS
NwNdsOpenGenericHandle(
    IN PUNICODE_STRING puNdsTree,
    OUT LPDWORD  lpdwHandleType,
    OUT PHANDLE  phNwRdrHandle
);

// NwNdsOpenGenericHandle( PUNICODE_STRING, LPDWORD, PHANDLE )
//
// Given a name, this opens a handle the the redirector for accessing that
// named tree or server. lpdwHandleType is set to either HANDLE_TYPE_NCP_SERVER
// or HANDLE_TYPE_NDS_TREE accordingly. The handle should be closed using
// the standard NT CloseHandle() call. This function is only a simple
// wrapper around NT OpenFile().

NTSTATUS
NwNdsResolveName (
    IN HANDLE           hNdsTree,
    IN PUNICODE_STRING  puObjectName,
    OUT DWORD           *dwObjectId,
    OUT PUNICODE_STRING puReferredServer,
    OUT PBYTE           pbRawResponse,
    IN DWORD            dwResponseBufferLen
);

// NwNdsResolveName(HANDLE, PUNICODE_STRING, PDWORD)
//
// Resolve the given name to an NDS object id.  This utilizes
// NDS verb 1.
//
// There is currently no interface for canonicalizing names.
// This call will use the default context if one has been set
// for this NDS tree.
//
// puReferredServer must point to a UNICODE_STRING with enough
// space to hold a server name (MAX_SERVER_NAME_LENGTH) *
// sizeof( WCHAR ).
//
// If dwResponseBufferLen is not 0, and pbRawResponse points
// to a writable buffer of length dwResponseBufferLen, then
// this routine will also return the entire NDS response in
// the raw response buffer.  The NDS response is described
// by NDS_RESPONSE_RESOLVE_NAME.
//
// Arguments:
//
//     HANDLE hNdsTree - The name of the NDS tree that we are interested in looking into.
//     PUNICODE_STRING puObjectName - The name that we want resolved into an object id.
//     DWORD *dwObjectId - The place where we will place the object id.
//     BYTE *pbRawResponse - The raw response buffer, if desired.
//     DWORD dwResponseBufferLen - The length of the raw response buffer.

WORD
NwParseNdsUncPath(
    IN OUT LPWSTR * Result,
    IN LPWSTR ContainerName,
    IN ULONG flag
);

NTSTATUS NwNdsOpenRdrHandle(
    OUT PHANDLE  phNwRdrHandle
);

NTSTATUS
NwNdsGetTreeContext (
    IN HANDLE hNdsRdr,
    IN PUNICODE_STRING puTree,
    OUT PUNICODE_STRING puContext
);

VOID
NwAbbreviateUserName(
    IN  LPWSTR pszFullName,
    OUT LPWSTR pszUserName
);

VOID
NwMakePrettyDisplayName(
    IN  LPWSTR pszName
);

DWORD
NWPGetConnectionStatus(
    IN     LPWSTR  pszRemoteName,
    IN OUT PDWORD_PTR ResumeKey,
    OUT    LPBYTE  Buffer,
    IN     DWORD   BufferSize,
    OUT    PDWORD  BytesNeeded,
    OUT    PDWORD  EntriesRead
);

BOOL
NwIsNdsSyntax(
    IN LPWSTR lpstrUnc
);

DWORD
NwOpenAndGetTreeInfo(
    LPWSTR pszNdsUNCPath,
    HANDLE *phTreeConn,
    DWORD  *pdwOid
);

static
DWORD
NwRegQueryValueExW(
    IN HKEY hKey,
    IN LPWSTR lpValueName,
    OUT LPDWORD lpReserved,
    OUT LPDWORD lpType,
    OUT LPBYTE  lpData,
    IN OUT LPDWORD lpcbData
    );

DWORD
NwReadRegValue(
    IN HKEY Key,
    IN LPWSTR ValueName,
    OUT LPWSTR *Value
    );

DWORD
NwpGetCurrentUserRegKey(
    IN  DWORD DesiredAccess,
    OUT HKEY  *phKeyCurrentUser
    );

DWORD
NwQueryInfo(
    OUT PDWORD pnPrintOptions,
    OUT LPWSTR *ppszPreferredSrv
    );

DWORD
NwGetConnectionStatus(
    IN  LPWSTR  pszRemoteName,
    OUT PDWORD_PTR ResumeKey,
    OUT LPBYTE  *Buffer,
    OUT PDWORD  EntriesRead
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\params.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       params.h
//
//--------------------------------------------------------------------------

#ifndef HEADER_PARAMS
#define HEADER_PARAMS

//////////////////////////////////////////////////////////////////////////////

//most user defined parameters, this will be passed to each test routine
typedef struct {
    PTESTED_DOMAIN pDomain;
    BOOL    fVerbose;
    BOOL    fReallyVerbose;
    BOOL    fDebugVerbose;
    BOOL    fFixProblems; //GlobalFixProblems;
    BOOL    fDcAccountEnum;   //GlobalDcAccountEnum;
    BOOL    fProblemBased;  // ProblemBased
    int     nProblemNumber; // ProblemNumber
    FILE*   pfileLog;       // pointer to the log file
    BOOL    fLog;
} NETDIAG_PARAMS;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\regutil.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      regutil.c
//
//  Abstract:
//
//      Queries into network drivers
//
//  Author:
//
//      Anilth  - 4-20-1998 
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//--

#include "precomp.h"
#include "ipcfg.h"

//Registry Reading functions, should be able to be replaced by HrReg... standard routines

BOOL ReadRegistryString(HKEY Key, LPCTSTR ParameterName, LPTSTR String, LPDWORD Length)
{

    LONG err;
    DWORD valueType;

    *String = '\0';
    err = RegQueryValueEx(Key,
                          ParameterName,
                          NULL, // reserved
                          &valueType,
                          (LPBYTE)String,
                          Length
                          );

    if (err == ERROR_SUCCESS) {

        ASSERT(valueType == REG_SZ || valueType == REG_MULTI_SZ);

        DEBUG_PRINT(("ReadRegistryString(%s): val = \"%s\", type = %d, len = %d\n",
                    ParameterName,
                    String,
                    valueType,
                    *Length
                    ));


    } else {

        DEBUG_PRINT(("ReadRegistryString(%s): err = %d\n", ParameterName, err));

    }

    return ((err == ERROR_SUCCESS) && (*Length > sizeof('\0')));
}



BOOL ReadRegistryIpAddrString(HKEY Key, LPCTSTR ParameterName, PIP_ADDR_STRING IpAddr)
{

    LONG err;
    DWORD valueLength = 0;
    DWORD valueType;
    LPBYTE valueBuffer;
    
    UINT stringCount;
    LPTSTR stringPointer;
    LPTSTR stringAddress[MAX_STRING_LIST_LENGTH + 1];
    UINT i;
    
    err = RegQueryValueEx(Key,
                          ParameterName,
                          NULL, // reserved
                          &valueType,
                          NULL,
                          &valueLength
                         );
    if ((err == ERROR_SUCCESS)) 
    {
        if((valueLength > 1) && (valueType == REG_SZ)
           || (valueLength > 2) && (valueType == REG_MULTI_SZ) ) 
        {
            valueBuffer = Malloc(valueLength);
            if( NULL == valueBuffer) 
            {
                DebugMessage("Out of Memory!");
                err = ERROR_NOT_ENOUGH_MEMORY;
                goto Error;
            }
            err = RegQueryValueEx(Key,
                                  ParameterName,
                                  NULL, // reserved
                                  &valueType,
                                  valueBuffer,
                                  &valueLength
                                 );
            
            if ((err == ERROR_SUCCESS) && (valueLength > 1)) 
            {
                stringPointer = valueBuffer;
                
                DEBUG_PRINT(("ReadRegistryIpAddrString(%s): \"%s\", len = %d\n",
                             ParameterName,
                             valueBuffer,
                             valueLength
                            ));
                
                if( REG_SZ == valueType ) 
                {
                    stringPointer += strspn(stringPointer, STRING_ARRAY_DELIMITERS);
                    stringAddress[0] = stringPointer;
                    stringCount = 1;
                    while (stringPointer = strpbrk(stringPointer, STRING_ARRAY_DELIMITERS)) 
                    {
                        *stringPointer++ = '\0';
                        stringPointer += strspn(stringPointer, STRING_ARRAY_DELIMITERS);
                        stringAddress[stringCount] = stringPointer;
                        if (*stringPointer) 
                        {
                            ++stringCount;
                        }
                    }
                    
                    for (i = 0; i < stringCount; ++i) 
                    {
                        AddIpAddressString(IpAddr, stringAddress[i], "");
                    }
                } 
                else if( REG_MULTI_SZ == valueType ) 
                {
                    stringCount = 0;
                    while(strlen(stringPointer)) 
                    {
                        AddIpAddressString(IpAddr, stringPointer, "");
                        stringPointer += 1+strlen(stringPointer);
                        stringCount ++;
                    }
                    if( 0 == stringCount ) 
                        err = ERROR_PATH_NOT_FOUND;
                } 
                else 
                {
                    err = ERROR_PATH_NOT_FOUND;
                }
            } 
            else 
            {
                
                DEBUG_PRINT(("ReadRegistryIpAddrString(%s): err = %d, len = %d\n",
                             ParameterName,
                             err,
                             valueLength
                            ));
                
                err = ERROR_PATH_NOT_FOUND;
            }
            
            Free(valueBuffer);
        } 
        else 
        {
            
            DEBUG_PRINT(("ReadRegistryIpAddrString(%s): err = %d, type = %d, len = %d\n",
                         ParameterName,
                         err,
                         valueType,
                         valueLength
                        ));
            
            err = ERROR_PATH_NOT_FOUND;
        }
    }
Error:
    return (err == ERROR_SUCCESS);
}

BOOL ReadRegistryOemString(HKEY Key, LPWSTR ParameterName, LPTSTR String, LPDWORD Length)
{

    LONG err;
    DWORD valueType;
    DWORD valueLength;

    //
    // first, get the length of the string
    //

    *String = '\0';
    err = RegQueryValueExW(Key,
                           ParameterName,
                           NULL, // reserved
                           &valueType,
                           NULL,
                           &valueLength
                           );
    if ((err == ERROR_SUCCESS) && (valueType == REG_SZ)) 
    {
        if ((valueLength <= *Length) && (valueLength > sizeof(L'\0'))) 
        {

            UNICODE_STRING unicodeString;
            OEM_STRING oemString;
            LPWSTR str = (LPWSTR)Malloc(valueLength);

            if(NULL == str)
            {
                assert(FALSE);
                DebugMessage("Out of memory!\n");
                err = ERROR_NOT_ENOUGH_MEMORY;
                goto Error;
            }

            //
            // read the UNICODE string into allocated memory
            //

            err = RegQueryValueExW(Key,
                                   ParameterName,
                                   NULL,
                                   &valueType,
                                   (LPBYTE)str,
                                   &valueLength
                                   );
            if (err == ERROR_SUCCESS) {

                //
                // convert the UNICODE string to OEM character set
                //
                RtlInitUnicodeString(&unicodeString, str);
                if ( RtlUnicodeStringToOemString(&oemString, &unicodeString, TRUE) == STATUS_SUCCESS)
                {
                   if (oemString.Buffer != NULL)
                   {
                      strcpy(String, oemString.Buffer);
                      DEBUG_PRINT(("ReadRegistryOemString(%ws): val = \"%s\", len = %d\n",
                              ParameterName,
                              String,
                              valueLength
                              ));
                   }
                   RtlFreeOemString(&oemString);
                }

            } else {

                DEBUG_PRINT(("ReadRegistryOemString(%ws): err = %d, type = %d, len = %d\n",
                            ParameterName,
                            err,
                            valueType,
                            valueLength
                            ));

            }

            Free(str);

        } 
        else 
        {
            DEBUG_PRINT(("ReadRegistryOemString(%ws): err = %d, type = %d, len = %d\n",
                        ParameterName,
                        err,
                        valueType,
                        valueLength
                        ));

            err = !ERROR_SUCCESS;
        }
    } else {

        DEBUG_PRINT(("ReadRegistryOemString(%ws): err = %d, type = %d, len = %d\n",
                    ParameterName,
                    err,
                    valueType,
                    valueLength
                    ));

        err = !ERROR_SUCCESS;
    }
Error:

    return (err == ERROR_SUCCESS);
}

BOOL ReadRegistryDword(HKEY Key, LPCTSTR ParameterName, LPDWORD Value)
{

    LONG err;
    DWORD valueLength;
    DWORD valueType;

    valueLength = sizeof(*Value);
    err = RegQueryValueEx(Key,
                          ParameterName,
                          NULL, // reserved
                          &valueType,
                          (LPBYTE)Value,
                          &valueLength
                          );
    if ((err == ERROR_SUCCESS) && (valueType == REG_DWORD) && (valueLength == sizeof(DWORD)))
{

        DEBUG_PRINT(("ReadRegistryDword(%s): val = %d, type = %d, len = %d\n",
                    ParameterName,
                    *Value,
                    valueType,
                    valueLength
                    ));

    } else {

        DEBUG_PRINT(("ReadRegistryDword(%d,%s): err = %d\n",
                     Key, ParameterName, err));

        err = !ERROR_SUCCESS;
    }

    return (err == ERROR_SUCCESS);
}

BOOL
OpenAdapterKey(
  const LPTSTR AdapterName,
  PHKEY Key
 )
{
   LONG err;
   CHAR keyName[MAX_ADAPTER_NAME_LENGTH + sizeof(TCPIP_PARAMS_INTER_KEY)];
   HKEY ServicesKey;

   if (NULL == AdapterName) {
	   DEBUG_PRINT("No Adapter Name");
	   return FALSE;
   }

   //
   // open the handle to this adapter's TCPIP parameter key
   //

   strcpy(keyName, TCPIP_PARAMS_INTER_KEY );
   strcat(keyName, AdapterName);

   err = RegOpenKey(HKEY_LOCAL_MACHINE,SERVICES_KEY,&ServicesKey);

   if (err != ERROR_SUCCESS) {
     DEBUG_PRINT("Opening Services key failed!\n");
     return FALSE;
   }

   err = RegOpenKey(ServicesKey, keyName, Key );

   if( err != ERROR_SUCCESS ){
       DEBUG_PRINT(("OpenAdapterKey: RegOpenKey ServicesKey %s, err=%d\n",
                    keyName, GetLastError() ));
   }else{
       TRACE_PRINT(("Exit OpenAdapterKey: %s ok\n", keyName ));
   }

   return (err == ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by netdiag.rc
//

// Test IDs are in 9000-9999
#define IDS_IPCONFIG_SHORT              9000
#define IDS_IPCONFIG_LONG               9001
#define IDS_MEMBER_SHORT                9002
#define IDS_MEMBER_LONG                 9003   
#define IDS_NETBT_SHORT                 9004
#define IDS_NETBT_LONG                  9005   
#define IDS_AUTONET_SHORT               9006
#define IDS_AUTONET_LONG                9007   
#define IDS_IPLOOPBK_SHORT              9008
#define IDS_IPLOOPBK_LONG               9009   
#define IDS_DEFGW_SHORT                 9010
#define IDS_DEFGW_LONG                  9011   
#define IDS_NBTNM_SHORT                 9012
#define IDS_NBTNM_LONG                  9013   
#define IDS_WINS_SHORT                  9014
#define IDS_WINS_LONG                   9015   
#define IDS_WINSOCK_SHORT               9016
#define IDS_WINSOCK_LONG                9017   
#define IDS_DNS_SHORT                   9018
#define IDS_DNS_LONG                    9019   
#define IDS_BROWSER_SHORT               9020
#define IDS_BROWSER_LONG                9021   
#define IDS_DSGETDC_SHORT               9022
#define IDS_DSGETDC_LONG                9023   
#define IDS_DCLIST_SHORT                9024
#define IDS_DCLIST_LONG                 9025   
#define IDS_TRUST_SHORT                 9026
#define IDS_TRUST_LONG                  9027   
#define IDS_KERBEROS_SHORT              9028
#define IDS_KERBEROS_LONG               9029   
#define IDS_LDAP_SHORT                  9030
#define IDS_LDAP_LONG                   9031   
#define IDS_ROUTE_SHORT                 9032
#define IDS_ROUTE_LONG                  9033   
#define IDS_NETSTAT_SHORT               9034
#define IDS_NETSTAT_LONG                9035   
#define IDS_NDIS_SHORT                  9036
#define IDS_NDIS_LONG                   9037   
#define IDS_BINDINGS_SHORT              9038
#define IDS_BINDINGS_LONG               9039   
#define IDS_WAN_SHORT                   9040
#define IDS_WAN_LONG                    9041   
#define IDS_MODEM_SHORT                 9042
#define IDS_MODEM_LONG                  9043   
#define IDS_NETWARE_SHORT               9044
#define IDS_NETWARE_LONG                9045   
#define IDS_IPX_SHORT                   9046
#define IDS_IPX_LONG                    9047
#define IDS_IPSEC_SHORT                 9048
#define IDS_IPSEC_LONG                  9049



//Global String IDs should be 10001 - 11000
#define IDS_GLOBAL_EmptyLine                        10001
#define IDSSZ_GLOBAL_StringLine                     10002
#define IDS_GLOBAL_Problem                          10003
#define IDS_GLOBAL_NoProblem                        10004
#define IDS_GLOBAL_NoComputerName                   10005
#define IDSWSZ_GLOBAL_ComputerName                  10006
#define IDSSZ_GLOBAL_DnsHostName                    10007
#define IDSSZ_DnsDomainName                         10008
#define IDS_GLOBAL_NoIpCfg                          10009
#define IDS_GLOBAL_WSA_WSAStartup_Failed            10010
#define IDS_GLOBAL_WSA_BadWSAVersion                10011
#define IDS_GLOBAL_OutOfMemory                      10012
#define IDS_GLOBAL_ERR_NoDnsName                    10013
#define IDS_GLOBAL_ERR_InitIpConfig                 10014
#define IDS_GLOBAL_ERR_GetAdaptersInfo              10015
#define IDSSZ_GLOBAL_String                         10016
#define IDS_GLOBAL_PASS                             10017
#define IDS_GLOBAL_FAIL                             10018
#define IDS_GLOBAL_PASS_NL                          10019
#define IDS_GLOBAL_FAIL_NL                          10020
#define IDS_GLOBAL_INDENT                           10021
#define IDS_GLOBAL_YES_NL                           10022
#define IDS_GLOBAL_NO_NL                            10023
#define IDS_GLOBAL_ENABLED_NL                       10024
#define IDS_GLOBAL_DISABLED_NL                      10025
#define IDS_GLOBAL_YES                              10026
#define IDS_GLOBAL_NO                               10027
#define IDS_GLOBAL_BROADCAST_NODE                   10028
#define IDS_GLOBAL_PEER_PEER_NODE                   10029
#define IDS_GLOBAL_MIXED_NODE                       10030
#define IDS_GLOBAL_HYBRID_NODE                      10031
#define IDS_GLOBAL_ADAPTER_OTHER                    10032
#define IDS_GLOBAL_ADAPTER_ETHERNET                 10033
#define IDS_GLOBAL_ADAPTER_TOKEN_RING               10034
#define IDS_GLOBAL_ADAPTER_FDDI                     10035
#define IDS_GLOBAL_ADAPTER_PPP                      10036
#define IDS_GLOBAL_ADAPTER_LOOPBACK                 10037
#define IDS_GLOBAL_ADAPTER_SLIP                     10038
#define IDS_GLOBAL_ADAPTER_UNKNOWN                  10039
#define IDS_GLOBAL_ON                               10040
#define IDS_GLOBAL_OFF                              10041
#define IDS_GLOBAL_WSTRING                          10042
#define IDS_GLOBAL_UNICODE_STRING                   10043
#define IDS_GLOBAL_NOT_OPTIONAL                     10044
#define IDS_GLOBAL_NOT_VALID_TEST                   10045
#define IDS_GLOBAL_TEST_NAME                        10046
#define IDS_GLOBAL_SKIP_OPTION                      10047
#define IDS_GLOBAL_SUCCESS                          10048
#define IDS_GLOBAL_COMPLETE                         10049

#define IDS_GLOBAL_INTERFACE_RESULTS                10051
#define IDS_GLOBAL_RESULTS                          10052
#define IDS_GLOBAL_STATUS                           10053
#define IDS_GLOBAL_DC_DOWN                          10054
#define IDS_GLOBAL_SKIP                             10055
#define IDS_GLOBAL_SKIP_NL                          10056
#define IDS_CONTACT                                 10057
#define IDS_DCTYPE_DC                               10058
#define IDS_DCTYPE_PDC                              10059
#define IDS_DCTYPE_W2K_DC                           10060

#define IDS_GLOBAL_NO_MACHINE_INFO                  10061

#define IDS_GLOBAL_PROFESSIONAL                     10062
#define IDS_GLOBAL_SERVER                           10063



//IpConfig test String IDs should be 11000-11200
#define IDSSZ_IPCFG_NODETYPE                         11001
#define IDSSZ_IPCFG_NBTSCOPEID                       11002
#define IDSSZ_IPCFG_RoutingEnabled                   11003
#define IDSSZ_IPCFG_WinsProxyEnabled                 11004
#define IDSSZ_IPCFG_DnsForNetBios                    11005
#define IDSSZ_IPCFG_Adapter                          11006
#define IDSSZ_IPCFG_HostName                         11007
#define IDS_IPCFG_DnsServers                         11008
#define IDS_IPCFG_STATUS_MSG                         11009
#define IDS_IPCFG_WINS_STATUS_MSG                   11010
#define IDS_IPCFG_WINS2_STATUS_MSG                  11011
#define IDS_IPCFG_PING_WINS                         11012
#define IDS_IPCFG_PING_WINS2                        11013
#define IDS_IPCFG_PING_WINS_FAIL                    11014
#define IDS_IPCFG_PING_WINS2_FAIL                   11015
#define IDS_IPCFG_10003                             11016
#define IDS_IPCFG_10004                             11017
#define IDS_IPCFG_10005                             11018 
#define IDS_IPCFG_10006                             11019 
#define IDS_IPCFG_10009                             11020 
#define IDS_IPCFG_10012                             11021 
#define IDS_IPCFG_10013                             11022 
#define IDS_IPCFG_10014                             11023 
#define IDS_IPCFG_10015                             11024 
#define IDS_IPCFG_10016                             11025 
#define IDS_IPCFG_10017                             11026 
#define IDS_IPCFG_10018                             11027 
#define IDS_IPCFG_10019                             11028 
#define IDS_IPCFG_10020                             11029 
#define IDS_IPCFG_10021                             11030 
#define IDS_IPCFG_10022                             11031 
#define IDS_IPCFG_10023                             11032 
#define IDS_IPCFG_10024                             11033 
#define IDS_IPCFG_10025                             11034 
#define IDS_IPCFG_10026                             11035 
#define IDS_IPCFG_10027                             11036 
#define IDS_IPCFG_10029                             11037
#define IDS_IPCFG_PING_DHCP_OK                      11038
#define IDS_IPCFG_PING_DHCP_BAD                     11039
#define IDS_IPCFG_CANNOT_GET_IP_INFO                11040
#define IDS_IPCFG_INVALID_DHCP_ADDRESS              11041
#define IDS_IPCFG_WARNING_BOGUS_SUBNET              11042
#define IDS_IPCFG_WARNING_BOGUS_SUBNET_DHCP         11043
#define IDS_IPCFG_NBT_DISABLED                      11044

//Member test 11201 - 11400
#define IDS_MEMBER_STATUS_MSG               11201
#define IDS_MEMBER_CANNOT_DETERMINE_BUILD   11202
#define IDS_MEMBER_CANNOT_DETERMINE_DOMAIN  11203
#define IDS_MEMBER_NETLOGON_NOT_RUNNING     11204
#define IDS_MEMBER_UNKNOWN_LOGON            11205
#define  IDS_MEMBER_11206                  11206 
#define  IDS_MEMBER_11207                  11207 
#define  IDS_MEMBER_11208                  11208 
#define  IDS_MEMBER_11209                  11209 
#define  IDS_MEMBER_11210                  11210 
#define  IDS_MEMBER_11211                  11211 
#define  IDS_MEMBER_11212                  11212 
#define  IDS_MEMBER_11213                  11213 
#define  IDS_MEMBER_11214                  11214 
#define  IDS_MEMBER_11215                  11215
#define  IDS_MEMBER_11216                  11216
#define  IDS_MEMBER_11217                  11217 
#define  IDS_MEMBER_11218                  11218 
#define  IDS_MEMBER_11219                  11219 
#define  IDS_MEMBER_11220                  11220 
#define  IDS_MEMBER_11221                  11221 
#define  IDS_MEMBER_11222                  11222 
#define  IDS_MEMBER_11223                  11223 
#define  IDS_MEMBER_11227                  11227 
#define  IDS_MEMBER_11228                  11228 
#define  IDS_MEMBER_11229                  11229 
#define  IDS_MEMBER_11230                  11230 
#define  IDS_MEMBER_11231                  11231 
#define  IDS_MEMBER_11232                  11232
#define  IDS_MEMBER_SYSVOL_NOT_READY       11233

//NetBT Transports test  11401 - 11600
#define IDS_NETBT_STATUS_MSG                11401
#define IDS_NETBT_DUPLICATE                 11402
#define IDS_NETBT_11403                     11403
#define IDS_NETBT_11404                     11404
#define IDS_NETBT_11405                     11405
#define IDS_NETBT_11406                     11406
#define IDS_NETBT_11407                     11407
#define IDS_NETBT_11408                     11408
#define IDS_NETBT_11409                     11409
#define IDS_NETBT_SKIP                      11410
#define IDS_NETBT_11411                     11411
#define IDS_NETBT_11412                     11412

//AutoNet test 11601 - 11800
#define  IDS_AUTONET_11601                  11601 
#define  IDS_AUTONET_11602                  11602 
#define  IDS_AUTONET_11603                  11603 
#define  IDS_AUTONET_11604                  11604 
#define  IDS_AUTONET_11605                  11605 
#define  IDS_AUTONET_11606                  11606 
#define  IDS_AUTONET_STATUS_MSG             11607

//LpLoopBk test 11801 - 12000
#define IDS_IPLOOPBK_STATUS_MSG             11801
#define IDS_IPLOOPBK_NO_IP                  11802
#define IDS_IPLOOPBK_PASS                   11803
#define IDS_IPLOOPBK_FAIL                   11804

//Default gateway (DefGW) test 12001 - 12200
#define  IDS_DEFGW_12001                  12001
#define  IDS_DEFGW_12002                  12002 
#define  IDS_DEFGW_12003                  12003 
#define  IDS_DEFGW_12004                  12004 
#define  IDS_DEFGW_12005                  12005 
#define  IDS_DEFGW_12006                  12006 
#define  IDS_DEFGW_12007                  12007 
#define  IDS_DEFGW_12008                  12008 
#define  IDS_DEFGW_12009                  12009 
#define  IDS_DEFGW_12010                  12010 
#define  IDS_DEFGW_12011                  12011 
#define  IDS_DEFGW_12012                  12012
#define  IDS_DEFGW_STATUS_MSG           12399


//NbtNm test 12201 - 12400
#define  IDS_NBTNM_12201                  12201 
#define  IDS_NBTNM_12202                  12202 
#define  IDS_NBTNM_12203                  12203 
#define  IDS_NBTNM_12204                  12204 
#define  IDS_NBTNM_12205                  12205 
#define  IDS_NBTNM_12206                  12206 
#define  IDS_NBTNM_12207                  12207 
#define  IDS_NBTNM_12208                  12208 
#define  IDS_NBTNM_12209                  12209 
#define  IDS_NBTNM_12210                  12210 
#define  IDS_NBTNM_12211                  12211 
#define  IDS_NBTNM_12212                  12212 
#define  IDS_NBTNM_12214                  12214 
#define  IDS_NBTNM_12215                  12215 
#define  IDS_NBTNM_12216                  12216 
#define  IDS_NBTNM_12217                  12217 
#define  IDS_NBTNM_12218                  12218 
#define  IDS_NBTNM_12219                  12219 
#define  IDS_NBTNM_12220                  12220 
#define  IDS_NBTNM_12221                  12221 
#define  IDS_NBTNM_12222                  12222 
#define  IDS_NBTNM_ALL_DISABELED          12223
#define  IDS_NBTNM_12224                  12224 
#define  IDS_NBTNM_12225                  12225 
#define  IDS_NBTNM_12226                  12226 
#define  IDS_NBTNM_12227                  12227 
#define  IDS_NBTNM_12228                  12228 
#define  IDS_NBTNM_12229                  12229 
#define  IDS_NBTNM_12231                  12231 
#define  IDS_NBTNM_12233                  12233 
#define  IDS_NBTNM_12234                  12234 
#define  IDS_NBTNM_12235                  12235 
#define  IDS_NBTNM_12236                  12236
#define  IDS_NBTNM_STATUS_MSG             12237 
#define  IDS_NBTNM_03PROBLEM              12238
#define  IDS_NBTNM_IF_DISABLED            12239


//WINS test 12401 - 12600
#define IDS_WINS_QUERY_NO_PRIMARY           12401
#define IDS_WINS_QUERY_PRIMARY              12402
#define IDS_WINS_QUERY_NO_SECONDARY         12403
#define IDS_WINS_QUERY_SECONDARY            12404
#define IDS_WINS_STATUS_MSG                 12405 
#define IDS_WINS_12406                      12406 
#define IDS_WINS_12407                      12407 
#define IDS_WINS_12408                      12408 
#define IDS_WINS_12409                      12409 
#define IDS_WINS_12413                      12413 
#define IDS_WINS_12414                      12414 
#define IDS_WINS_12415                      12415
#define IDS_WINS_12416                      12416
#define IDS_WINS_NBT_DISABLED               12417


//Winsock test 12601 - 12800
#define IDS_WINSOCK_FAILED_START            12601
#define IDS_WINSOCK_FAILED_ENUM             12602
#define IDS_WINSOCK_FAILED_UDPSOCKET        12603
#define IDS_WINSOCK_STATUS_MSG              12604
#define  IDS_WINSOCK_12605                  12605 
#define  IDS_WINSOCK_12606                  12606 
#define  IDS_WINSOCK_12607                  12607 
#define  IDS_WINSOCK_12608                  12608 
#define  IDS_WINSOCK_12609                  12609 
#define  IDS_WINSOCK_12610                  12610 
#define  IDS_WINSOCK_12611                  12611 

//DNS test 12801 - 13000
#define IDS_DNS_CHECKING_DNS_SERVERS        12801
#define IDS_DNS_SERVER_IS_UP                12802
#define IDS_DNS_CANNOT_TEST_DNS             12803
#define IDS_DNS_CANNOT_CONVERT_DNS_ADDRESS  12804
#define IDS_DNS_SERVER_IS_DOWN              12805
#define IDS_DNS_THINKS_IP_IS_UNCONFIGURED   12806
#define IDS_DNS_IS_UNCONFIGURED             12807
#define IDS_DNS_HAS_NO_RECORD               12808
#define IDS_DNS_CANNOT_QUERY                12809
#define IDS_DNS_HAS_A_RECORD                12810
#define IDS_DNS_HAS_NO_A_RECORD             12811
#define IDS_DNS_STATUS_MSG                  12812
#define IDS_DNS_RESOLVER_CACHE_IS_OFF       12813
#define IDS_DNS_CANNOT_PING                 12814
#define IDS_DNS_NAME_VALID_NT5_ONLY         12817
#define IDS_DNS_NAME_INVALID                12818
#define IDS_DNS_12819                       12819 
#define IDS_DNS_12820                       12820 
#define IDS_DNS_12821                       12821 
#define IDS_DNS_12822                       12822 
#define IDS_DNS_12823                       12823 
#define IDS_DNS_12825                       12825 
#define IDS_DNS_12826                       12826 
#define IDS_DNS_12827                       12827 
#define IDS_DNS_12828                       12828 
#define IDS_DNS_12829                       12829 
#define IDS_DNS_12830                       12830 
#define IDS_DNS_12831                       12831 
#define IDS_DNS_12832                       12832 
#define IDS_DNS_12833                       12833 
#define IDS_DNS_12834                       12834 
#define IDS_DNS_12835                       12835 
#define IDS_DNS_12836                       12836 
#define IDS_DNS_12837                       12837 
#define IDS_DNS_12838                       12838 
#define IDS_DNS_12839                       12839 
#define IDS_DNS_12840                       12840 
#define IDS_DNS_12841                       12841 
#define IDS_DNS_12842                       12842 
#define IDS_DNS_12843                       12843 
#define IDS_DNS_12844                       12844 
#define IDS_DNS_12845                       12845 
#define IDS_DNS_12846                       12846 
#define IDS_DNS_12847                       12847 
#define IDS_DNS_12848                       12848 
#define IDS_DNS_12849                       12849 
#define IDS_DNS_12850                       12850 
#define IDS_DNS_12851                       12851 
#define IDS_DNS_12852                       12852 
#define IDS_DNS_12853                       12853 
#define IDS_DNS_12854                       12854 
#define IDS_DNS_12855                       12855 
#define IDS_DNS_12856                       12856 
#define IDS_DNS_12857                       12857 
#define IDS_DNS_12858                       12858 
#define IDS_DNS_12859                       12859 
#define IDS_DNS_12860                       12860 
#define IDS_DNS_12861                       12861 
#define IDS_DNS_12862                       12862 
#define IDS_DNS_12863                       12863 
#define IDS_DNS_12864                       12864 
#define IDS_DNS_12865                       12865 
#define IDS_DNS_12866                       12866 
#define IDS_DNS_12867                       12867 
#define IDS_DNS_12868                       12868 
#define IDS_DNS_12869                       12869 
#define IDS_DNS_12870                       12870 
#define IDS_DNS_12871                       12871
#define IDS_DNS_12872                       12872
#define IDS_DNS_12873                       12873
#define IDS_DNS_12874                       12874
#define IDS_DNS_DC_FAILURE                  12875
#define IDS_DNS_IPADDR_ERR                  12876
// new
#define IDS_DNS_12877                       12877
#define IDS_DNS_12878                       12878 
#define IDS_DNS_12879                       12879 
#define IDS_DNS_12880                       12880 
#define IDS_DNS_12881                       12881 
#define IDS_DNS_12882                       12882 
#define IDS_DNS_12883                       12883 
#define IDS_DNS_12884                       12884 
#define IDS_DNS_12885                       12885 
#define IDS_DNS_12886                       12886 
#define IDS_DNS_12887                       12887 
#define IDS_DNS_12888                       12888 
#define IDS_DNS_12889                       12889 
#define IDS_DNS_12890                       12890 
#define IDS_DNS_12891                       12891 
#define IDS_DNS_12892                       12892 
#define IDS_DNS_12893                       12893 
#define IDS_DNS_12894                       12894 
#define IDS_DNS_12895                       12895 
#define IDS_DNS_12896                       12896 
#define IDS_DNS_12897                       12897 
#define IDS_DNS_12898                       12898 
#define IDS_DNS_12899                       12899 
#define IDS_DNS_12900                       12900 
#define IDS_DNS_12901                       12901 
#define IDS_DNS_12902                       12902 
#define IDS_DNS_12903                       12903 
#define IDS_DNS_12904                       12904 
#define IDS_DNS_12905                       12905 
#define IDS_DNS_12906                       12906 
#define IDS_DNS_12907                       12907 
#define IDS_DNS_12908                       12908 
#define IDS_DNS_12909                       12909 
#define IDS_DNS_12910                       12910 
#define IDS_DNS_12911                       12911 
#define IDS_DNS_12912                       12912 
#define IDS_DNS_12913                       12913 
#define IDS_DNS_12914                       12914 
#define IDS_DNS_12915                       12915 
#define IDS_DNS_12916                       12916 
#define IDS_DNS_12917                       12917 
#define IDS_DNS_12918                       12918 
#define IDS_DNS_12919                       12919 
#define IDS_DNS_12920                       12920 
#define IDS_DNS_12921                       12921 
#define IDS_DNS_12922                       12922 
#define IDS_DNS_12923                       12923 
#define IDS_DNS_12924                       12924 
#define IDS_DNS_12939                       12939
#define IDS_DNS_12940                       12940
#define IDS_DNS_12941                       12941 
#define IDS_DNS_12942                       12942 
#define IDS_DNS_12943                       12943 
#define IDS_DNS_12944                       12944 
#define IDS_DNS_12945                       12945 
#define IDS_DNS_12946                       12946 
#define IDS_DNS_12947                       12947
#define IDS_DNS_12948                       12948
#define IDS_DNS_12949                       12949
#define IDS_DNS_NO_HOSTNAME                 12950
#define IDS_DNS_12951                       12951 

//Browser test 13001 - 13200
#define  IDS_BROWSER_13001                  13001 
#define  IDS_BROWSER_13002                  13002 
#define  IDS_BROWSER_13003                  13003 
#define  IDS_BROWSER_13004                  13004 
#define  IDS_BROWSER_13005                  13005 
#define  IDS_BROWSER_13006                  13006 
#define  IDS_BROWSER_13007                  13007 
#define  IDS_BROWSER_13008                  13008 
#define  IDS_BROWSER_13009                  13009 
#define  IDS_BROWSER_13010                  13010 
#define  IDS_BROWSER_13011                  13011 
#define  IDS_BROWSER_13012                  13012 
#define  IDS_BROWSER_13013                  13013 
#define  IDS_BROWSER_13014                  13014 
#define  IDS_BROWSER_13015                  13015 
#define  IDS_BROWSER_13016                  13016 
#define  IDS_BROWSER_13017                  13017 
#define  IDS_BROWSER_13018                  13018 
#define  IDS_BROWSER_13019                  13019 
#define  IDS_BROWSER_13020                  13020 
#define  IDS_BROWSER_13021                  13021 
#define  IDS_BROWSER_13022                  13022 
#define  IDS_BROWSER_13023                  13023 
#define  IDS_BROWSER_13024                  13024 
#define  IDS_BROWSER_13025                  13025 
#define  IDS_BROWSER_13026                  13026 
#define  IDS_BROWSER_STATUS_MSG             13027
#define IDS_BROWSER_NETBT_DISABLED          13028

//DsGetDc test 13201 - 13400
#define IDS_DSGETDC_STATUS_MSG              13201
#define IDS_DSGETDC_STATUS_DC               13202
#define IDS_DSGETDC_STATUS_PDC              13203
#define IDS_DSGETDC_STATUS_NT5DC            13204
#define IDS_DSGETDC_FATAL_GUID              13205
#define  IDS_DSGETDC_13206                  13206 
#define  IDS_DSGETDC_13207                  13207 
#define  IDS_DSGETDC_13208                  13208 
#define  IDS_DSGETDC_13209                  13209 
#define  IDS_DSGETDC_13210                  13210 
#define  IDS_DSGETDC_13211                  13211 
#define  IDS_DSGETDC_13212                  13212 
#define  IDS_DSGETDC_13213                  13213 
#define  IDS_DSGETDC_13214                  13214 
#define  IDS_DSGETDC_13215                  13215 
#define  IDS_DSGETDC_13216                  13216 
#define  IDS_DSGETDC_13217                  13217 
#define  IDS_DSGETDC_13218                  13218 
#define  IDS_DSGETDC_13219                  13219 
#define  IDS_DSGETDC_13220                  13220 
#define  IDS_DSGETDC_13221                  13221 
#define  IDS_DSGETDC_13222                  13222 
#define  IDS_DSGETDC_13223                  13223 
#define  IDS_DSGETDC_13224                  13224 
#define  IDS_DSGETDC_13225                  13225 
#define  IDS_DSGETDC_13226                  13226 
#define  IDS_DSGETDC_13227                  13227 
#define  IDS_DSGETDC_13228                  13228 
#define  IDS_DSGETDC_13229                  13229 
#define  IDS_DSGETDC_13230                  13230 
#define  IDS_DSGETDC_13231                  13231 
#define  IDS_DSGETDC_13232                  13232 
#define  IDS_DSGETDC_13233                  13233 
#define  IDS_DSGETDC_13234                  13234 
#define  IDS_DSGETDC_13235                  13235 
#define  IDS_DSGETDC_13236                  13236 
#define  IDS_DSGETDC_13237                  13237 
#define  IDS_DSGETDC_13238                  13238 
#define  IDS_DSGETDC_13239                  13239 
#define  IDS_DSGETDC_13240                  13240 
#define  IDS_DSGETDC_13241                  13241 
#define  IDS_DSGETDC_13242                  13242 
#define  IDS_DSGETDC_13243                  13243 
#define  IDS_DSGETDC_13244                  13244 
#define  IDS_DSGETDC_13245                  13245 
#define  IDS_DSGETDC_13246                  13246 
#define  IDS_DSGETDC_13247                  13247 
#define  IDS_DSGETDC_13248                  13248 
#define  IDS_DSGETDC_13249                  13249 
#define  IDS_DSGETDC_13250                  13250 
#define  IDS_DSGETDC_NT4_PDC                13251

//DCList test 13401 - 13600
#define IDS_DCLIST_NETSERVERENUM_FAILED     13401
#define IDS_DCLIST_DOMAIN_HEADER            13402
#define IDS_DCLIST_DC_INFO                  13403
#define IDS_DCLIST_DC_IS_DOWN               13404
#define IDS_DCLIST_DC_FAILED_PING           13405
#define IDS_DCLIST_STATUS_MSG               13406
#define IDS_DCLIST_NOT_A_NETBIOS_DOMAIN     13407
#define IDS_DCLIST_DOMAIN_SID               13413
#define IDS_DCLIST_RID                      13414
#define IDS_DCLIST_NO_DC                    13415
#define IDS_DCLIST_NO_DC_UP                 13416
#define IDS_DCLIST_NO_ACCESS_DSBIND         13417
#define IDS_DCLIST_ERR_DSBIND               13418
#define IDS_DCLIST_ERR_GETDCINFO            13419
#define IDS_DCLIST_DCS                      13420
#define IDS_DCLIST_13421                    13421 
#define IDS_DCLIST_13422                    13422 
#define IDS_DCLIST_13423                    13423 
#define IDS_DCLIST_13424                    13424 
#define IDS_DCLIST_13425                    13425 
#define IDS_DCLIST_13426                    13426 
#define IDS_DCLIST_13427                    13427 
#define IDS_DCLIST_13428                    13428 
#define IDS_DCLIST_13429                    13429 
#define IDS_DCLIST_13430                    13430 
#define IDS_DCLIST_13431                    13431 
#define IDS_DCLIST_13432                    13432 
#define IDS_DCLIST_13433                    13433 
#define IDS_DCLIST_13434                    13434 
#define IDS_DCLIST_13435                    13435 
#define IDS_DCLIST_NT4_PDC                  13436 


//Trust test 13601 - 13800
#define IDS_TRUST_FAILED_CHANNEL            13601
#define IDS_TRUST_FAILED_LISTDOMAINS        13602
#define IDS_TRUST_FAILED_SECURECHANNEL      13603
#define IDS_TRUST_SECURECHANNEL_TO          13604
#define IDS_TRUST_FAILED_CHANNEL_PDC        13605
#define IDS_TRUST_SECURECHANNEL_TOPDC       13606
#define IDS_TRUST_NOTESTASITSDOWN           13607
#define IDS_TRUST_FAILED_TODCS              13608
#define IDS_TRUST_FAILED_CHANNEL_DCS        13609
#define IDS_TRUST_CHANNEL_DC                13610
#define IDS_TRUST_ENSURESID                 13611
#define IDS_TRUST_MISSINGSID                13612
#define IDS_TRUST_NODC                      13613
#define IDS_TRUST_WRONGSID                  13614
#define IDS_TRUST_FAILED_SAMOPEN            13615
#define IDS_TRUST_STATUS_MSG                13616
#define IDS_TRUST_NO_NBT_DOMAIN             13617
#define IDS_TRUST_NODC_UP                   13618
#define IDS_TRUST_NO_ACCESS                 13619
#define IDS_TRUST_NOT_ADMIN                 13620
#define IDS_TRUST_TODCS_NOT_ADMIN           13621
#define IDS_TRUST_CHANNEL_BROKEN            13622

//Kerberos test 13801 - 14000
#define IDS_KERBEROS_LOCALUSER              13801 
#define IDS_KERBEROS_CACHED                 13802 
#define IDS_KERBEROS_NODC                   13803 
#define IDS_KERBEROS_NOKDC                  13804 
#define IDS_KERBEROS_NOLSA                  13805 
#define IDS_KERBEROS_NOPACKAGE              13806 
#define IDS_KERBEROS_HRERROR                13807 
#define IDS_KERBEROS_NOCACHE                13808 
#define IDS_KERBEROS_CACHEDTICKER           13809
#define IDS_KERBEROS_NOTICKET               13810 
#define IDS_KERBEROS_SERVER                 13811 
#define IDS_KERBEROS_ENDTIME                13812 
#define IDS_KERBEROS_RENEWTIME              13813
#define IDS_KERBEROS_STATUS_MSG             13814
#define IDS_KERBEROS_NOT_W2K_PRIMARY_DOMAIN 13815

//LDAP test 14001 - 14200
#define IDS_LDAP_NODC                       14001
#define IDS_LDAP_NOTRUNNINGDS               14002
#define IDS_LDAP_NOTRUNNINGDS_SKIP          14003
#define IDS_LDAP_NOLDAPSERVERSWORK          14004
#define IDS_LDAP_DCDOWN                     14005
#define IDS_LDAP_NOIPADDR                   14006
#define IDS_LDAP_LOGONASLOCALUSER           14007
#define IDS_LDAP_DOAUTHEN                   14008
#define IDS_LDAP_CANNOTOPEN                 14009
#define IDS_LDAP_CANNOTBIND                 14010
#define IDS_LDAP_CANNOTSEARCH               14011
#define IDS_LDAP_ENTRIES                    14012
#define IDS_LDAP_CANNOTFIRSTENTRY           14013
#define IDS_LDAP_CANNOTFIRSTATTR            14014
#define IDS_LDAP_ATTR                       14015
#define IDS_LDAP_CANNOTLEN                  14016
#define IDS_LDAP_VAL                        14017
#define IDS_LDAP_STATUS_MSG                 14018
#define IDS_LDAP_REG_SPN                    14019
#define IDS_LDAP_SPN_NAME                   14020
#define IDS_LDAP_SPN_FAILURE                14021
#define IDS_LDAP_SPN_MISSING                14022
#define IDS_LDAP_NO_SPN                     14023




//Route test 14201 - 14400
#define  IDS_ROUTE_14201                  14201 
#define  IDS_ROUTE_14202                  14202 
#define  IDS_ROUTE_14203                  14203 
#define  IDS_ROUTE_14204                  14204 
#define  IDS_ROUTE_14205                  14205 
#define  IDS_ROUTE_14206                  14206 
#define  IDS_ROUTE_14207                  14207 
#define  IDS_ROUTE_14208                  14208 
#define  IDS_ROUTE_STATUS_MSG             14209

//NetStat test 14401 - 14600
#define  IDS_NETSTAT_14401                  14401 
#define  IDS_NETSTAT_14402                  14402 
#define  IDS_NETSTAT_14403                  14403 
#define  IDS_NETSTAT_14404                  14404 
#define  IDS_NETSTAT_14405                  14405 
#define  IDS_NETSTAT_14406                  14406 
#define  IDS_NETSTAT_14407                  14407 
#define  IDS_NETSTAT_14408                  14408 
#define  IDS_NETSTAT_14409                  14409 
#define  IDS_NETSTAT_14410                  14410 
#define  IDS_NETSTAT_14411                  14411 
#define  IDS_NETSTAT_14412                  14412 
#define  IDS_NETSTAT_14413                  14413 
#define  IDS_NETSTAT_14414                  14414 
#define  IDS_NETSTAT_14415                  14415 
#define  IDS_NETSTAT_14416                  14416 
#define  IDS_NETSTAT_14417                  14417 
#define  IDS_NETSTAT_14418                  14418 
#define  IDS_NETSTAT_14419                  14419 
#define  IDS_NETSTAT_14420                  14420 
#define  IDS_NETSTAT_14421                  14421 
#define  IDS_NETSTAT_14422                  14422 
#define  IDS_NETSTAT_14423                  14423 
#define  IDS_NETSTAT_14424                  14424 
#define  IDS_NETSTAT_14425                  14425 
#define  IDS_NETSTAT_14426                  14426 
#define  IDS_NETSTAT_14427                  14427 
#define  IDS_NETSTAT_14428                  14428 
#define  IDS_NETSTAT_14429                  14429 
#define  IDS_NETSTAT_14430                  14430 
#define  IDS_NETSTAT_14431                  14431 
#define  IDS_NETSTAT_14432                  14432 
#define  IDS_NETSTAT_14433                  14433 
#define  IDS_NETSTAT_14434                  14434 
#define  IDS_NETSTAT_14438                  14438 
#define  IDS_NETSTAT_14439                  14439 
#define  IDS_NETSTAT_14440                  14440 
#define  IDS_NETSTAT_14441                  14441 
#define  IDS_NETSTAT_14442                  14442 
#define  IDS_NETSTAT_14443                  14443 
#define  IDS_NETSTAT_14444                  14444 
#define  IDS_NETSTAT_14445                  14445 
#define  IDS_NETSTAT_14446                  14446 
#define  IDS_NETSTAT_14447                  14447 
#define  IDS_NETSTAT_14448                  14448 
#define  IDS_NETSTAT_14449                  14449 
#define  IDS_NETSTAT_14450                  14450 
#define  IDS_NETSTAT_14451                  14451 
#define  IDS_NETSTAT_14452                  14452 
#define  IDS_NETSTAT_14453                  14453 
#define  IDS_NETSTAT_14454                  14454 
#define  IDS_NETSTAT_14455                  14455 
#define  IDS_NETSTAT_14456                  14456 
#define  IDS_NETSTAT_14457                  14457 
#define  IDS_NETSTAT_14458                  14458 
#define  IDS_NETSTAT_14459                  14459 
#define  IDS_NETSTAT_14460                  14460 
#define  IDS_NETSTAT_14461                  14461 
#define  IDS_NETSTAT_14462                  14462 
#define  IDS_NETSTAT_14463                  14463 
#define  IDS_NETSTAT_14464                  14464 
#define  IDS_NETSTAT_14465                  14465 
#define  IDS_NETSTAT_14466                  14466 
#define  IDS_NETSTAT_14467                  14467 
#define  IDS_NETSTAT_14468                  14468 
#define  IDS_NETSTAT_14469                  14469 
#define  IDS_NETSTAT_14470                  14470 
#define  IDS_NETSTAT_14471                  14471 
#define  IDS_NETSTAT_14472                  14472 
#define  IDS_NETSTAT_14473                  14473 
#define  IDS_NETSTAT_14474                  14474 
#define  IDS_NETSTAT_14475                  14475 
#define  IDS_NETSTAT_14476                  14476 
#define  IDS_NETSTAT_14477                  14477 
#define  IDS_NETSTAT_14478                  14478 
#define  IDS_NETSTAT_14479                  14479 
#define  IDS_NETSTAT_14480                  14480 
#define  IDS_NETSTAT_14481                  14481 
#define  IDS_NETSTAT_14482                  14482 
#define  IDS_NETSTAT_14483                  14483 
#define  IDS_NETSTAT_14484                  14484 
#define  IDS_NETSTAT_14485                  14485 
#define  IDS_NETSTAT_14486                  14486 
#define  IDS_NETSTAT_14487                  14487 
#define  IDS_NETSTAT_14488                  14488 
#define  IDS_NETSTAT_14489                  14489 
#define  IDS_NETSTAT_14490                  14490 
#define  IDS_NETSTAT_14491                  14491 
#define  IDS_NETSTAT_14492                  14492 
#define  IDS_NETSTAT_14493                  14493 
#define  IDS_NETSTAT_14494                  14494 
#define  IDS_NETSTAT_14495                  14495 
#define  IDS_NETSTAT_14496                  14496 
#define  IDS_NETSTAT_14497                  14497 
#define  IDS_NETSTAT_14498                  14498 
#define  IDS_NETSTAT_14499                  14499 
#define  IDS_NETSTAT_14500                  14500 
#define  IDS_NETSTAT_14501                  14501 
#define  IDS_NETSTAT_14502                  14502 
#define  IDS_NETSTAT_14503                  14503 
#define  IDS_NETSTAT_14504                  14504 
#define  IDS_NETSTAT_STATUS_MSG             14505

//NDIS test 16000- 17000   huge test, need more IDs
#define  IDS_NDIS_16000                  16000 
#define  IDS_NDIS_16001                  16001 
#define  IDS_NDIS_16002                  16002 
#define  IDS_NDIS_16003                  16003 
#define  IDS_NDIS_16004                  16004 
#define  IDS_NDIS_16005                  16005 
#define  IDS_NDIS_16006                  16006 
#define  IDS_NDIS_16007                  16007 
#define  IDS_NDIS_16008                  16008 
#define  IDS_NDIS_16009                  16009 
#define  IDS_NDIS_16010                  16010 
#define  IDS_NDIS_16011                  16011 
#define  IDS_NDIS_16012                  16012 
#define  IDS_NDIS_16013                  16013 
#define  IDS_NDIS_16014                  16014 
#define  IDS_NDIS_16015                  16015 
#define  IDS_NDIS_16016                  16016 
#define  IDS_NDIS_16017                  16017 
#define  IDS_NDIS_16018                  16018 
#define  IDS_NDIS_16019                  16019 
#define  IDS_NDIS_16020                  16020 
#define  IDS_NDIS_16021                  16021 
#define  IDS_NDIS_16022                  16022 
#define  IDS_NDIS_16023                  16023 
#define  IDS_NDIS_16024                  16024 
#define  IDS_NDIS_16025                  16025 
#define  IDS_NDIS_16026                  16026 
#define  IDS_NDIS_16027                  16027 
#define  IDS_NDIS_STATUS_MSG             16028
#define  IDS_NDIS_16029                  16029
#define  IDS_NDIS_16030                  16030
#define  IDS_NDIS_CONNECTED              16031
#define  IDS_NDIS_DISCONNECTED           16032
#define  IDS_NDIS_UNKNOWN                16033
#define  IDS_NDIS_ALL_CARD_DOWN          16034
#define  IDS_NDIS_CARD_DOWN              16035
#define  IDS_NDIS_NO_RCV                 16036


//BINDINGS 14801 - 15000
#define  IDS_BINDINGS_14801                  14801 
#define  IDS_BINDINGS_14802                  14802 
#define  IDS_BINDINGS_14804                  14804 
#define  IDS_BINDINGS_14805                  14805 
#define  IDS_BINDINGS_14806                  14806 
#define  IDS_BINDINGS_14807                  14807 
#define  IDS_BINDINGS_14808                  14808 
#define  IDS_BINDINGS_14810                  14810 
#define  IDS_BINDINGS_14811                  14811 
#define  IDS_BINDINGS_14812                  14812
#define  IDS_BINDINGS_STATUS_MSG             14813

//WAN test 15001 - 15200
#define  IDS_WAN_15001                  15001 
#define  IDS_WAN_15002                  15002 
#define  IDS_WAN_15003                  15003 
#define  IDS_WAN_15004                  15004 
#define  IDS_WAN_15005                  15005 
#define  IDS_WAN_15006                  15006 
#define  IDS_WAN_15008                  15008 
#define  IDS_WAN_15009                  15009 
#define  IDS_WAN_15010                  15010 
#define  IDS_WAN_15011                  15011 
#define  IDS_WAN_15012                  15012 
#define  IDS_WAN_15013                  15013 
#define  IDS_WAN_15014                  15014 
#define  IDS_WAN_15015                  15015 
#define  IDS_WAN_15016                  15016 
#define  IDS_WAN_15017                  15017 
#define  IDS_WAN_15018                  15018 
#define  IDS_WAN_DISABLED               15019 
#define  IDS_WAN_ENABLED                15020 
#define  IDS_WAN_15021                  15021 
#define  IDS_WAN_15024                  15024 
#define  IDS_WAN_15025                  15025 
#define  IDS_WAN_15026                  15026 
#define  IDS_WAN_15027                  15027 
#define  IDS_WAN_15028                  15028 
#define  IDS_WAN_15029                  15029 
#define  IDS_WAN_15030                  15030 
#define  IDS_WAN_15031                  15031 
#define  IDS_WAN_15032                  15032 
#define  IDS_WAN_15033                  15033 
#define  IDS_WAN_15034                  15034 
#define  IDS_WAN_15035                  15035 
#define  IDS_WAN_15036                  15036 
#define  IDS_WAN_15037                  15037 
#define  IDS_WAN_15038                  15038 
#define  IDS_WAN_15039                  15039 
#define  IDS_WAN_15040                  15040 
#define  IDS_WAN_15041                  15041 
#define  IDS_WAN_15042                  15042 
#define  IDS_WAN_15043                  15043 
#define  IDS_WAN_15044                  15044 
#define  IDS_WAN_15045                  15045 
#define  IDS_WAN_15046                  15046 
#define  IDS_WAN_15047                  15047 
#define  IDS_WAN_15048                  15048 
#define  IDS_WAN_15049                  15049 
#define  IDS_WAN_15050                  15050 
#define  IDS_WAN_15051                  15051 
#define  IDS_WAN_15052                  15052 
#define  IDS_WAN_15053                  15053 
#define  IDS_WAN_15054                  15054 
#define  IDS_WAN_15055                  15055
#define  IDS_WAN_15056                  15056
#define  IDS_WAN_STATUS_MSG             15057

//Modem test 15201 - 15400
#define IDS_MODEM_STATUS_MSG            15201
#define IDS_MODEM_LINEINIT_FAILED       15202
#define IDS_MODEM_NO_DEVICES            15203
#define IDS_MODEM_DEVICEID              15204
#define IDS_MODEM_COMPRESSION           15205
#define IDS_MODEM_ERROR_CONTROL         15206
#define IDS_MODEM_FORCED_EC             15207
#define IDS_MODEM_CELLULAR              15208
#define IDS_MODEM_FLOWCONTROL_HARD      15209
#define IDS_MODEM_FLOWCONTROL_SOFT      15210
#define IDS_MODEM_CCITT_OVERRIDE        15211
#define IDS_MODEM_SPEED_ADJUST          15212
#define IDS_MODEM_TONE_DIAL             15213
#define IDS_MODEM_BLIND_DIAL            15214
#define IDS_MODEM_V23_OVERRIDE          15215
#define IDS_MODEM_NEGOTIATED_SPEED      15216
#define IDS_MODEM_PORT                  15217
#define IDS_MODEM_NAME                  15218

//Netware test 15401 - 15600
#define IDS_NETWARE_NOT_LOGGED_IN_TREE  15401
#define IDS_NETWARE_NOT_LOGGED_IN_SERVER    15402
#define IDS_NETWARE_LOGGED_IN_SERVER    15403
#define IDS_NETWARE_LOGGED_IN_TREE      15404
#define IDS_NETWARE_USER_NAME           15405
#define IDS_NETWARE_SERVER_NAME         15406
#define IDS_NETWARE_TREE_NAME           15407
#define IDS_NETWARE_CONTEXT             15408
#define IDS_NETWARE_CONNECTION_TYPE     15409
#define IDS_NETWARE_NDS                 15410
#define IDS_NETWARE_CONN_TYPE           15411
#define IDS_NETWARE_CONN_NOT_AUTHENTICATED 15412
#define IDS_NETWARE_CONN_BINDERY_LOGIN  15413
#define IDS_NETWARE_CONN_NDS_AUTHENTICATED_NO_LICENSE 15414
#define IDS_NETWARE_CONN_NDS_AUTHENTICATED_LICENSED 15415
#define IDS_NETWARE_CONN_DISCONNECTED   15416
#define IDS_NETWARE_CONN_UNKNOWN        15417
#define IDS_NETWARE_STATUS_MSG          15418
#define IDS_NETWARE_TITLE_MSG           15419

//IPX test 15601 - 15800
#define IDS_IPX_STATUS_MSG              15601
#define IDS_IPX_INTERNAL                15602
#define  IDS_IPX_15603                  15603 
#define  IDS_IPX_15604                  15604 
#define  IDS_IPX_15605                  15605 
#define  IDS_IPX_15606                  15606 
#define  IDS_IPX_15607                  15607 
#define  IDS_IPX_15608                  15608 
#define  IDS_IPX_15609                  15609 
#define  IDS_IPX_15610                  15610 
#define  IDS_IPX_15611                  15611 
#define  IDS_IPX_15612                  15612 
#define  IDS_IPX_15613                  15613
#define IDS_IPX_ETHERNET_II             15614
#define IDS_IPX_802_3                   15615
#define IDS_IPX_802_2                   15616
#define IDS_IPX_SNAP                    15617
#define IDS_IPX_ARCNET                  15618
#define IDS_IPX_UNKNOWN                 15619


// IDS for machine-specific info 15801 - 16000
#define  IDS_MACHINE_15801                  15801 
#define  IDS_MACHINE_15802                  15802 
#define  IDS_MACHINE_15803                  15803 
#define  IDS_MACHINE_15804                  15804 
#define  IDS_MACHINE_15805                  15805 
#define  IDS_MACHINE_15806                  15806 
#define  IDS_MACHINE_15807                  15807 
#define  IDS_MACHINE_15808                  15808
#define IDS_MACHINE_YES_INSTALLED       15809
#define IDS_MACHINE_NO_INSTALLED        15810

// IPSec test 17500 - 18000
#define IDS_IPSEC_STATUS_MSG            17500
#define IDS_IPSEC_PA_NOT_STARTED        17501
#define IDS_IPSEC_ERROR_MSG             17502
#define IDS_IPSEC_NO_POLICY_INFO        17503
#define IDS_IPSEC_NO_POLICY             17504
#define IDS_IPSEC_DS_POLICY             17505
#define IDS_IPSEC_LOC_POLICY            17506
#define IDS_IPSEC_POLICY_NAME           17507
#define IDS_IPSEC_POLICY_PATH           17508
#define IDS_IPSEC_PA_NOT_INSTALLED      17509
#define IDS_IPSEC_PA_NO_INFO            17510
#define IDS_IPSEC_PA_STATUS             17511
#define IDS_IPSEC_PA_STARTUP            17512
#define IDS_IPSEC_PA_STARTED            17513
#define IDS_IPSEC_PA_STOPPED            17514
#define IDS_IPSEC_PA_PAUSED             17515
#define IDS_IPSEC_PA_AUTOMATIC          17516
#define IDS_IPSEC_PA_MANUAL             17517
#define IDS_IPSEC_PA_DISABLED           17518
#define IDS_IPSEC_IPSECCMD              17519
#define IDS_IPSEC_DESCRIPTION           17520
#define IDS_IPSEC_TIMESTAMP             17521
#define IDS_IPSEC_LOCAL_PATH            17522
#define IDS_IPSEC_GPO                   17523
#define IDS_IPSEC_OU                    17524

// the nettest.exe/netdiag.exe strings
// nettest 17000 - 17499
#define IDS_NETTEST_17000               17000
#define IDS_NETTEST_17001               17001
#define IDS_NETTEST_17002               17002
#define IDS_NETTEST_17003               17003
#define IDS_NETTEST_17004               17004
#define IDS_NETTEST_17005               17005
#define IDS_NETTEST_17006               17006
#define IDS_NETTEST_17007               17007
#define IDS_NETTEST_17008               17008
#define IDS_NETTEST_LOG                 17009
#define IDS_NETTEST_LOGFILE_ERROR       17010


// utilitis
#define IDS_UTIL_SID_NULL               20000
#define IDS_UTIL_SID_INVALID            20001

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\results.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      results.c
//
//  Abstract:
//
//    Test to ensure that a workstation has network (IP) connectivity to
//		the outside.
//
//  Author:
//
//     15-Dec-1997 (cliffv)
//      Anilth	- 4-20-1998 
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//    1-June-1998 (denisemi) add DnsServerHasDCRecords to check DC dns records
//                           registration
//
//    26-June-1998 (t-rajkup) add general tcp/ip , dhcp and routing,
//                            winsock, ipx, wins and netbt information. 
//--

//
// Common include files.
//
#include "precomp.h"
#include "netdiag.h"
#include "ipcfg.h"



static TCHAR	s_szBuffer[4096];
static TCHAR	s_szFormat[4096];

const TCHAR	c_szWaitDots[] = _T(".");


void PrintMessage(NETDIAG_PARAMS *pParams, UINT uMessageID, ...)
{
    UINT nBuf;
    va_list args;

    va_start(args, uMessageID);

    LoadString(NULL, uMessageID, s_szFormat, sizeof(s_szFormat));

    nBuf = _vstprintf(s_szBuffer, s_szFormat, args);
    assert(nBuf < DimensionOf(s_szBuffer));

    va_end(args);
    
    PrintMessageSz(pParams, s_szBuffer);
}

void PrintMessageSz(NETDIAG_PARAMS *pParams, LPCTSTR pszMessage)
{
    if(pParams->fLog)
    {
        _ftprintf( pParams->pfileLog, pszMessage );
    }

	_tprintf(pszMessage);
    fflush(stdout);
}


/*!--------------------------------------------------------------------------
	ResultsCleanup
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void ResultsCleanup(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults)
{
	int		i;
	
	// Clean up the global variables
	Free( pResults->Global.pszCurrentVersion );
	pResults->Global.pszCurrentVersion = NULL;
	
	Free( pResults->Global.pszCurrentBuildNumber );
	pResults->Global.pszCurrentBuildNumber = NULL;
	
	Free( pResults->Global.pszCurrentType );
	pResults->Global.pszCurrentType = NULL;

	Free( pResults->Global.pszProcessorInfo );
	pResults->Global.pszProcessorInfo = NULL;

	Free( pResults->Global.pszServerType );
	pResults->Global.pszServerType = NULL;

	// delete the individual strings
	for (i=0; i<pResults->Global.cHotFixes; i++)
		Free(pResults->Global.pHotFixes[i].pszName);
	Free( pResults->Global.pHotFixes );
	pResults->Global.pHotFixes = NULL;
	pResults->Global.cHotFixes = 0;

	// Do NOT free this up.  This will get freed up with the list
	// of domains.
	// pResults->Global.pMemberDomain
	// pResults->Global.pLogonDomain
	if (pResults->Global.pMemberDomain)
	{
		Free( pResults->Global.pMemberDomain->DomainSid );
		pResults->Global.pMemberDomain->DomainSid = NULL;
	}

	LsaFreeMemory(pResults->Global.pLogonUser);
	pResults->Global.pLogonUser = NULL;
	LsaFreeMemory(pResults->Global.pLogonDomainName);
	pResults->Global.pLogonDomainName = NULL;
	
	if (pResults->Global.pPrimaryDomainInfo)
	{
		DsRoleFreeMemory(pResults->Global.pPrimaryDomainInfo);
		pResults->Global.pPrimaryDomainInfo = NULL;
	}

	Free( pResults->Global.pswzLogonServer );

	
	IpConfigCleanup(pParams, pResults);

	for (i=0; i<pResults->cNumInterfaces; i++)
	{
		Free(pResults->pArrayInterface[i].pszName);
		pResults->pArrayInterface[i].pszName = NULL;
		
		Free(pResults->pArrayInterface[i].pszFriendlyName);
		pResults->pArrayInterface[0].pszFriendlyName = NULL;
	}

	Free(pResults->pArrayInterface);
	pResults->pArrayInterface = NULL;
	pResults->cNumInterfaces = 0;

}



/*!--------------------------------------------------------------------------
	SetMessageId
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void SetMessageId(NdMessage *pNdMsg, NdVerbose ndv, UINT uMessageId)
{
	assert(pNdMsg);
	ClearMessage(pNdMsg);

	pNdMsg->ndVerbose = ndv;
	pNdMsg->uMessageId = uMessageId;
}


/*!--------------------------------------------------------------------------
	SetMessageSz
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void SetMessageSz(NdMessage *pNdMsg, NdVerbose ndv, LPCTSTR pszMessage)
{
	assert(pNdMsg);
	ClearMessage(pNdMsg);
	
	pNdMsg->ndVerbose = ndv;
	pNdMsg->pszMessage = _tcsdup(pszMessage);
    pNdMsg->uMessageId = 0;
}

/*!--------------------------------------------------------------------------
	SetMessage
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void SetMessage(NdMessage *pNdMsg, NdVerbose ndv, UINT uMessageId, ...)
{
    UINT nBuf;
    va_list args;

    va_start(args, uMessageId);

    LoadString(NULL, uMessageId, s_szFormat, sizeof(s_szFormat));

    nBuf = _vstprintf(s_szBuffer, s_szFormat, args);
    assert(nBuf < sizeof(s_szBuffer));

    va_end(args);
	SetMessageSz(pNdMsg, ndv, s_szBuffer);
}

/*!--------------------------------------------------------------------------
	ClearMessage
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void ClearMessage(NdMessage *pNdMsg)
{
	if (pNdMsg == NULL)
		return;

	if (pNdMsg->pszMessage)			
		Free(pNdMsg->pszMessage);

	ZeroMemory(pNdMsg, sizeof(*pNdMsg));
}


/*!--------------------------------------------------------------------------
	PrintNdMessage
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void PrintNdMessage(NETDIAG_PARAMS *pParams, NdMessage *pNdMsg)
{
	LPCTSTR	pszMsg = NULL;

	assert(pParams);

	if (pNdMsg == NULL)
		return;

	// test verbosity level
	if ((pNdMsg->ndVerbose == Nd_DebugVerbose) &&
		!pParams->fDebugVerbose)
		return;

	if ((pNdMsg->ndVerbose == Nd_ReallyVerbose) &&
		!pParams->fReallyVerbose)
		return;

	if ((pNdMsg->ndVerbose == Nd_Verbose) &&
		!pParams->fVerbose)
		return;

	// get the message to print
	if (pNdMsg->uMessageId)
	{
		LoadString(NULL, pNdMsg->uMessageId, s_szBuffer,
				   DimensionOf(s_szBuffer));
		assert(s_szBuffer[0]);
		pszMsg = s_szBuffer;
	}
	else
		pszMsg = pNdMsg->pszMessage;

	if (pszMsg)
		PrintMessageSz(pParams, pszMsg);

	fflush(stdout);
}


//---------------------------------------------------------------
//  AddMessageToListSz
//      Add a string based message at tail of the list. 
//  Author  NSun
//---------------------------------------------------------------
void AddMessageToListSz(PLIST_ENTRY plistHead, NdVerbose ndv, LPCTSTR pszMsg)
{
    NdMessageList *plMessage = NULL;

    if( NULL == plistHead || NULL == pszMsg )
        return;

    plMessage = Malloc(sizeof(NdMessageList));

    assert(plMessage);
	if (plMessage)
	{
		ZeroMemory(plMessage, sizeof(NdMessageList));

		SetMessageSz(&plMessage->msg, ndv, pszMsg);

		InsertTailList(plistHead, &plMessage->listEntry);
	}
}

void AddIMessageToListSz(PLIST_ENTRY plistHead, NdVerbose ndv, int nIndent, LPCTSTR pszMsg)
{
	TCHAR	szBuffer[4096];
	int		i;
    NdMessageList *plMessage = NULL;

    if( NULL == plistHead || NULL == pszMsg )
        return;

	assert(nIndent < 4096);
	assert((nIndent + StrLen(pszMsg)) < (DimensionOf(szBuffer)-1));

	for (i=0; i<nIndent; i++)
		szBuffer[i] = _T(' ');
	szBuffer[i] = 0;

	StrCat(szBuffer, pszMsg);
	
    plMessage = Malloc(sizeof(NdMessageList));

    assert(plMessage);
	if (plMessage)
	{
		ZeroMemory(plMessage, sizeof(NdMessageList));

		SetMessageSz(&plMessage->msg, ndv, szBuffer);
		
		InsertTailList(plistHead, &plMessage->listEntry);
	}
}


//---------------------------------------------------------------
//  AddMessageToListId
//      Add an ID based message at tail of the list. 
//  Author  NSun
//---------------------------------------------------------------
void AddMessageToListId(PLIST_ENTRY plistHead, NdVerbose ndv, UINT uMessageId)
{
    NdMessageList *plMsg = NULL;
    
    if( NULL == plistHead )
        return;
    
    plMsg = Malloc(sizeof(NdMessageList));
    assert(plMsg); 
    if (plMsg)
    {
       ZeroMemory(plMsg, sizeof(NdMessageList));

       SetMessageId(&plMsg->msg, ndv, uMessageId);

       InsertTailList(plistHead, &plMsg->listEntry);
    }
}


//---------------------------------------------------------------
//  AddMessageToList
//      Add a message based on message ID and optional parameters 
//      at tail of the list. 
//  Author  NSun
//---------------------------------------------------------------
void AddMessageToList(PLIST_ENTRY plistHead, NdVerbose ndv, UINT uMessageId, ...)
{
    NdMessageList *plMessage = NULL;
    UINT nBuf;
    va_list args;

    if(NULL == plistHead) 
        return;

    plMessage = Malloc(sizeof(NdMessageList));

    assert(plMessage); 
    if (plMessage)
    {
       ZeroMemory(plMessage, sizeof(NdMessageList));

       va_start(args, uMessageId);

       LoadString(NULL, uMessageId, s_szFormat, sizeof(s_szFormat));

       nBuf = _vstprintf(s_szBuffer, s_szFormat, args);
       assert(nBuf < sizeof(s_szBuffer));

       va_end(args);
       SetMessageSz(&plMessage->msg, ndv, s_szBuffer);

       InsertTailList(plistHead, &plMessage->listEntry);
    }
}



void AddIMessageToList(PLIST_ENTRY plistHead, NdVerbose ndv, int nIndent, UINT uMessageId, ...)
{
    NdMessageList *plMessage = NULL;
    UINT nBuf;
	LPTSTR		pszFormat;
    va_list args;
	int		i;

    if(NULL == plistHead)
        return;

    plMessage = Malloc(sizeof(NdMessageList));

	for (i=0; i<nIndent; i++)
		s_szFormat[i] = _T(' ');
	s_szFormat[i] = 0;
	pszFormat = s_szFormat + nIndent;

    assert(plMessage); 
    if (plMessage)
    {
       ZeroMemory(plMessage, sizeof(NdMessageList));

       va_start(args, uMessageId);

       LoadString(NULL, uMessageId, pszFormat, 4096 - nIndent);

       nBuf = _vstprintf(s_szBuffer, s_szFormat, args);
       assert(nBuf < sizeof(s_szBuffer));

       va_end(args);
       SetMessageSz(&plMessage->msg, ndv, s_szBuffer);

       InsertTailList(plistHead, &plMessage->listEntry);
    }
}




//---------------------------------------------------------------
//  PrintMessageList
//  
//  Author  NSun
//---------------------------------------------------------------
void PrintMessageList(NETDIAG_PARAMS *pParams, PLIST_ENTRY plistHead)
{
    NdMessageList* plMsg;
    PLIST_ENTRY plistEntry = plistHead->Flink;
    
    if( NULL == plistEntry ) return;
    
    for(; plistEntry != plistHead; plistEntry = plistEntry->Flink)
    {
        assert(plistEntry);
        plMsg = CONTAINING_RECORD( plistEntry, NdMessageList, listEntry );
        PrintNdMessage(pParams, &plMsg->msg);
    }
}


//---------------------------------------------------------------
//  MessageListCleanUp
//  
//  Author  NSun
//---------------------------------------------------------------
void MessageListCleanUp(PLIST_ENTRY plistHead)
{
    PLIST_ENTRY plistEntry = plistHead->Flink;
    NdMessageList* plMsg;
    
    if( NULL == plistEntry ) 
		return;

    while(plistEntry != plistHead)
    {
        assert(plistEntry);
        plMsg = CONTAINING_RECORD( plistEntry, NdMessageList, listEntry );
        plistEntry = plistEntry->Flink;
        ClearMessage(&plMsg->msg);
        Free(plMsg);
    }
}


void PrintStatusMessage(NETDIAG_PARAMS *pParams, int iIndent, UINT uMessageId, ...)
{
	INT nBuf;
    va_list args;
	int	i;

	//if not in really verbose mode, print wait dots
	PrintWaitDots(pParams);

	if (pParams->fReallyVerbose)
	{
		va_start(args, uMessageId);
		
		LoadString(NULL, uMessageId, s_szFormat, sizeof(s_szFormat));
		
		nBuf = _vsntprintf(s_szBuffer, DimensionOf(s_szBuffer), s_szFormat, args);
		assert(nBuf > 0);
		s_szBuffer[DimensionOf(s_szBuffer)-1] = 0;
		assert(nBuf < sizeof(s_szBuffer));
		
		va_end(args);

		if (iIndent)
		{
			for (i=0; i<iIndent; i++)
				s_szFormat[i] = _T(' ');
			s_szFormat[i] = 0;
			PrintMessageSz(pParams, s_szFormat);
		}
		
		PrintMessageSz(pParams, s_szBuffer);
	}
}

void PrintStatusMessageSz(NETDIAG_PARAMS *pParams, int iIndent, LPCTSTR pszMessage)
{
	int		i;
	
	if (pParams->fReallyVerbose)
	{
		if (iIndent)
		{
			for (i=0; i<iIndent; i++)
				s_szFormat[i] = _T(' ');
			s_szFormat[i] = 0;
			PrintMessageSz(pParams, s_szFormat);
		}
		
		PrintMessageSz(pParams, pszMessage);
	}
}


void PrintDebug(NETDIAG_PARAMS *pParams, int iIndent, UINT uMessageId, ...)
{
	INT nBuf;
    va_list args;
	int	i;

	if (pParams->fDebugVerbose)
	{
		va_start(args, uMessageId);
		
		LoadString(NULL, uMessageId, s_szFormat, sizeof(s_szFormat));
		
		nBuf = _vsntprintf(s_szBuffer, DimensionOf(s_szBuffer), s_szFormat, args);
		assert(nBuf > 0);
		s_szBuffer[DimensionOf(s_szBuffer)-1] = 0;
		assert(nBuf < sizeof(s_szBuffer));
		
		va_end(args);

		if (iIndent)
		{
			for (i=0; i<iIndent; i++)
				s_szFormat[i] = _T(' ');
			s_szFormat[i] = 0;
			PrintMessageSz(pParams, s_szFormat);
		}
		
		PrintMessageSz(pParams, s_szBuffer);
	}
}


void PrintDebugSz(NETDIAG_PARAMS *pParams, int iIndent, LPCTSTR pszFormat, ...)
{
	INT nBuf;
    va_list args;
	int	i;

	if (pParams->fDebugVerbose)
	{
		va_start(args, pszFormat);
		
		nBuf = _vsntprintf(s_szBuffer, DimensionOf(s_szBuffer), pszFormat, args);
		assert(nBuf > 0);
		s_szBuffer[DimensionOf(s_szBuffer)-1] = 0;
		assert(nBuf < sizeof(s_szBuffer));
		
		va_end(args);

		if (iIndent)
		{
			for (i=0; i<iIndent; i++)
				s_szFormat[i] = _T(' ');
			s_szFormat[i] = 0;
			PrintMessageSz(pParams, s_szFormat);
		}
		
		PrintMessageSz(pParams, s_szBuffer);
	}
}



VOID
_PrintGuru(
    IN NETDIAG_PARAMS * pParams,
    IN NET_API_STATUS NetStatus,
    IN LPSTR DefaultGuru
    )
/*++

Routine Description:

    Print the Status and the name of the guru handling the status.

Arguments:

    NetStatus - Status used to differentiate
        0:  Just print the guru name
        -1: Just print the guru name

    DefaultGuru - Guru to return if no other guru can be found

Return Value:

    Name of Guru responsible for the specified status

--*/
{
    LPTSTR Guru;

    //
    // If a status was given,
    //  print it.
    //
    if ( NetStatus != 0 && NetStatus != -1) 
    {
        PrintMessageSz( pParams, NetStatusToString(NetStatus) );
    }

    //
    // Some status codes can be attributed base on the value of the status code.
    //
    if ( NetStatus >= WSABASEERR && NetStatus <= WSABASEERR + 2000 ) 
    {
        Guru = WINSOCK_GURU;
    } else if ( NetStatus >= DNS_ERROR_RESPONSE_CODES_BASE && NetStatus <= DNS_ERROR_RESPONSE_CODES_BASE + 1000 ) {
        Guru = DNS_GURU;
    } else {
        Guru = DefaultGuru;
    }

    PrintMessageSz( pParams, Guru );
    PrintNewLine( pParams, 1 );
}


void PrintWaitDots(NETDIAG_PARAMS *pParams)
{
	if (!pParams->fReallyVerbose && !pParams->fDebugVerbose)
	{
		_tprintf(c_szWaitDots);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\results.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       results.h
//
//--------------------------------------------------------------------------

#ifndef HEADER_RESULTS
#define HEADER_RESULTS

#ifdef _DEBUG
    #define DebugMessage(str) printf(str)
    #define DebugMessage2(format, arg) printf(format, arg)
    #define DebugMessage3(format, arg1, arg2) printf(format, arg1, arg2)
#else
    #define DebugMessage(str)
    #define DebugMessage2(format, arg)
    #define DebugMessage3(format, arg1, arg2)
#endif

#ifdef _SHOW_GURU
    #define PrintGuru(status, guru) _PrintGuru(status, guru)
    #define PrintGuruMessage         printf
    #define PrintGuruMessage2        printf
    #define PrintGuruMessage3        printf
#else
    #define PrintGuru(status, guru)
    #define PrintGuruMessage( str )
    #define PrintGuruMessage2( format, arg )
    #define PrintGuruMessage3(format, arg1, arg2)
#endif

#define NETCARD_CONNECTED		0
#define NETCARD_DISCONNECTED	1
#define NETCARD_STATUS_UNKNOWN	2

/*---------------------------------------------------------------------------
	Struct:	HotFixInfo

	This structure holds the information about a single Hotfix.
 ---------------------------------------------------------------------------*/
typedef struct
{
	BOOL	fInstalled;
	LPTSTR	pszName;		// use Free() to free
}	HotFixInfo;



/*---------------------------------------------------------------------------
	NdMessage

	This provides for an easier way to pass messages along.
 ---------------------------------------------------------------------------*/

typedef enum {
	Nd_Quiet = 0,			// i.e. always print
	Nd_Verbose = 1,
	Nd_ReallyVerbose = 2,
	Nd_DebugVerbose = 3,
} NdVerbose;

typedef struct
{
	NdVerbose	ndVerbose;

	// possible combinations
	//		uMessageId == 0, pszMessage == NULL		-- assume not set
	//		uMessageId != 0, pszMessage == NULL		-- use string id
	//		uMessageId == 0, pszMessage != NULL		-- use string
	//		uMessageId != 0, pszMessage != NULL		-- use string id
	//

	// Note: the maximum size for a string loaded through this is 4096!
	UINT	uMessageId;
	LPTSTR	pszMessage;
} NdMessage;

typedef struct ND_MESSAGE_LIST
{
    LIST_ENTRY listEntry;
    NdMessage msg;
}NdMessageList;

void SetMessageId(NdMessage *pNdMsg, NdVerbose ndv, UINT uMessageId);
void SetMessage(NdMessage *pNdMsg, NdVerbose ndv, UINT uMessageId, ...);
void SetMessageSz(NdMessage *pNdMsg, NdVerbose ndv, LPCTSTR pszMessage);
void ClearMessage(NdMessage *pNdMsg);

void PrintNdMessage(NETDIAG_PARAMS *pParams, NdMessage *pNdMsg);

void AddIMessageToList(PLIST_ENTRY plistHead, NdVerbose ndv, int nIndent, UINT uMessageId, ...);
void AddIMessageToListSz(PLIST_ENTRY plistHead, NdVerbose ndv, int nIndent, LPCTSTR pszMsg);

void AddMessageToList(PLIST_ENTRY plistHead, NdVerbose ndv, UINT uMessageId, ...);
void AddMessageToListSz(PLIST_ENTRY plistHead, NdVerbose ndv, LPCTSTR pszMsg);
void AddMessageToListId(PLIST_ENTRY plistHead, NdVerbose ndv, UINT uMessageId);
void PrintMessageList(NETDIAG_PARAMS *pParams, PLIST_ENTRY plistHead);
void MessageListCleanUp(PLIST_ENTRY plistHead);


// These functions are for status messages (the messages that appear at the
// top).
void PrintStatusMessage(NETDIAG_PARAMS *pParams, int iIndent, UINT uMessageId, ...);
void PrintStatusMessageSz(NETDIAG_PARAMS *pParams, int iIndent, LPCTSTR pszMessage);


// Use this for printing debug messages (messages that require fDebugVerbose)
void PrintDebug(NETDIAG_PARAMS *pParams, int nIndent, UINT uMessageId, ...);
void PrintDebugSz(NETDIAG_PARAMS *pParams, int nIndent, LPCTSTR pszMessage, ...);



/*---------------------------------------------------------------------------
	Struct:		GLOBAL_RESULT
 ---------------------------------------------------------------------------*/
typedef struct {
	WCHAR	swzNetBiosName[MAX_COMPUTERNAME_LENGTH+1];
	TCHAR	szDnsHostName[DNS_MAX_NAME_LENGTH+1];
	LPTSTR	pszDnsDomainName;	// this points to a string in szDnsHostName
	
	WSADATA	wsaData;

	// NetBT parameters
	DWORD	dwLMHostsEnabled;	// TRUE, FALSE, or HRESULT on error to read
	DWORD	dwDnsForWINS;	// TRUE, FALSE, or HRESULT on error to read

	// Server/OS information (such as version, build no, etc...)
	LPTSTR	pszCurrentVersion;
	LPTSTR	pszCurrentBuildNumber;
	LPTSTR	pszCurrentType;
	LPTSTR	pszProcessorInfo;
	LPTSTR	pszServerType;
	int		cHotFixes;
	HotFixInfo * pHotFixes;

	// List of domains to be tested
	LIST_ENTRY		listTestedDomains;

	// Domain member information
	// the primary domain info got by using DsRoleGetPrimaryDomainInformation()
	PDSROLE_PRIMARY_DOMAIN_INFO_BASIC pPrimaryDomainInfo;

	PTESTED_DOMAIN	pMemberDomain;	//the primary domain info in the TESTED_DOMAIN struct

	BOOL			fNetlogonIsRunning;
	HRESULT			hrMemberTestResult;		// result of the test

	// Logon information (who we're logged on as)
	PUNICODE_STRING	pLogonUser;
	PUNICODE_STRING	pLogonDomainName;
	PTESTED_DOMAIN	pLogonDomain;
	BOOL			fLogonWithCachedCredentials;
	LPWSTR			pswzLogonServer;

	BOOL			fKerberosIsWorking;
	BOOL			fSysVolNotReady;

	// Is there any interfaces that are NetBT enabled
	BOOL	fHasNbtEnabledInterface;

	
} GLOBAL_RESULT;


/*---------------------------------------------------------------------------
	Struct:	GLOBAL_IPCONFIG
 ---------------------------------------------------------------------------*/
typedef struct {
	// set to TRUE if InitIpconfig has been run
	BOOL	fInitIpconfigCalled;

	// Is IPX actually up and running?
	BOOL	fEnabled;

	//
	// IP-related info (non-DHCP related)
	//
	FIXED_INFO *	pFixedInfo;

	//
	// This is a pointer to the beginning of the adapter list
	// (Use this to free up the list of interfaces)
	//
	IP_ADAPTER_INFO *	pAdapterInfoList;

	// Is DHCP enabled? (on any adapter)
	BOOL				fDhcpEnabled;
} GLOBAL_IPCONFIG;



/*---------------------------------------------------------------------------
	Struct:	IPCONFIG_TST
 ---------------------------------------------------------------------------*/
typedef struct {

	// IP is active on this interface
	BOOL			fActive;

	//
	// Pointer to the IP adapter info for this interface
	// Do NOT free this up!  (free up the entire list by freeing
	// up GLOBAL_IPCONFIG::pAdapterInfoList
	//
	IP_ADAPTER_INFO *	pAdapterInfo;

	TCHAR				szDhcpClassID[MAX_DOMAIN_NAME_LEN];

	// Is autoconfiguration possible?
	DWORD				fAutoconfigEnabled;

	// is the adapter currently autoconfigured?
	DWORD				fAutoconfigActive;

	// WINS node type?
	UINT				uNodeType;

	TCHAR				szDomainName[MAX_DOMAIN_NAME_LEN+1];

	IP_ADDR_STRING		DnsServerList;

	// Can we ping the DHCP server?
	HRESULT				hrPingDhcpServer;
	NdMessage			msgPingDhcpServer;

	// Can we ping the WINS servers?
	HRESULT				hrPingPrimaryWinsServer;
	NdMessage			msgPingPrimaryWinsServer;
	HRESULT				hrPingSecondaryWinsServer;
	NdMessage			msgPingSecondaryWinsServer;

	// hrOK if the default gateway is on the same subnet as the ip address
	HRESULT				hrDefGwSubnetCheck;

	// Test result
	HRESULT				hr;
	
} IPCONFIG_TST;


/*---------------------------------------------------------------------------
	Struct:	GLOBAL_LOOPBACK
 ---------------------------------------------------------------------------*/
typedef struct
{
	NdMessage		msgLoopBack;
	HRESULT			hr;
} GLOBAL_LOOPBACK;


/*---------------------------------------------------------------------------
	Struct:	GLOBAL_IPX
 ---------------------------------------------------------------------------*/
typedef struct
{
	// TRUE if IPX is installed, FALSE otherwise
	BOOL			fInstalled;

	// Is IPX actually up and running?
	BOOL	fEnabled;

	// Handle to IPX
	HANDLE			hIsnIpxFd;
	
	HRESULT			hr;
} GLOBAL_IPX;


/*---------------------------------------------------------------------------
	Struct:	GLOBAL_NETBT_TRANSPORTS
 ---------------------------------------------------------------------------*/
typedef struct
{
	LONG			cTransportCount;
	LIST_ENTRY		Transports;
	
	HRESULT			hr;
	BOOL		fPerformed; //FALSE: there are no inerfaces that are NetBT enabled. Test skipped.

	NdMessage		msgTestResult;
} GLOBAL_NETBT_TRANSPORTS;


/*---------------------------------------------------------------------------
	Struct:	GLOBAL_DEFGW
 ---------------------------------------------------------------------------*/
typedef struct
{
	// S_FALSE if no default gateways were reachable
	// S_OK if at least one default gateway was reached
	HRESULT	hrReachable;
} GLOBAL_DEFGW;

/*---------------------------------------------------------------------------
	Struct:	GLOBAL_AUTONET
 ---------------------------------------------------------------------------*/
typedef struct
{
    BOOL    fAllAutoConfig;
} GLOBAL_AUTONET;


/*---------------------------------------------------------------------------
	Struct:	GLOBAL_NETBTNM
 ---------------------------------------------------------------------------*/
typedef struct
{
    LIST_ENTRY  lmsgGlobalOutput;
    HRESULT hrTestResult;
} GLOBAL_NBTNM;


/*---------------------------------------------------------------------------
	Struct:	GLOBAL_BROWSER
 ---------------------------------------------------------------------------*/
typedef struct
{
    LIST_ENTRY  lmsgOutput;
    HRESULT hrTestResult;
	BOOL	fPerformed;		//test will be skipped if no interfaces have NetBT enabled
} GLOBAL_BROWSER;


/*---------------------------------------------------------------------------
	Struct:	GLOBAL_BINDINGS
 ---------------------------------------------------------------------------*/
typedef struct
{
    LIST_ENTRY lmsgOutput;
    HRESULT hrTestResult;
} GLOBAL_BINDINGS;


/*---------------------------------------------------------------------------
	Struct:	GLOBAL_WAN
 ---------------------------------------------------------------------------*/
typedef struct
{
    LIST_ENTRY	lmsgOutput;
	HRESULT		hr;
	BOOL		fPerformed; //FALSE: there are no active RAS connections. Test skipped.
} GLOBAL_WAN;


/*---------------------------------------------------------------------------
	Struct:	GLOBAL_WINSOCK
 ---------------------------------------------------------------------------*/
typedef struct
{
	UINT				idsContext;// str ID of context, which has %s to take the cause of failure
	HRESULT				hr;	// 0: success, otherwise failed
	DWORD				dwMaxUDP;	// max size of UDP packets, 0 
	DWORD				dwProts;	// number of protocols providers
    LPWSAPROTOCOL_INFO	pProtInfo;	// information on the providers
} GLOBAL_WINSOCK;


typedef struct
{
    DWORD       dwNumRoutes;
    LIST_ENTRY  lmsgRoute;
    DWORD       dwNumPersistentRoutes;
    LIST_ENTRY  lmsgPersistentRoute;
    HRESULT     hrTestResult;
} GLOBAL_ROUTE;

typedef struct
{
    LIST_ENTRY  lmsgOutput;
    HRESULT     hrTestResult;
} GLOBAL_NDIS;

typedef struct
{
    LIST_ENTRY  lmsgGlobalOutput;
    LIST_ENTRY  lmsgInterfaceOutput;   //Interface statistics
    LIST_ENTRY  lmsgConnectionGlobalOutput;
    LIST_ENTRY  lmsgTcpConnectionOutput;    
    LIST_ENTRY  lmsgUdpConnectionOutput;
    LIST_ENTRY  lmsgIpOutput;       // IP statistics
    LIST_ENTRY  lmsgTcpOutput;      // TCP statistics
    LIST_ENTRY  lmsgUdpOutput;      // UDP statistics
    LIST_ENTRY  lmsgIcmpOutput;     // ICMP statistics
    HRESULT     hrTestResult;
} GLOBAL_NETSTAT;


/*---------------------------------------------------------------------------
	Struct:	GLOBAL_IPSEC
 ---------------------------------------------------------------------------*/
typedef struct
{
    LIST_ENTRY  lmsgGlobalOutput;
    LIST_ENTRY  lmsgAdditOutput;
} GLOBAL_IPSEC;

/*---------------------------------------------------------------------------
	Struct:	GLOBAL_DNS
 ---------------------------------------------------------------------------*/

typedef struct {
	HRESULT				hr;
	BOOL				fOutput;
    LIST_ENTRY			lmsgOutput;
} GLOBAL_DNS;


/*---------------------------------------------------------------------------
	Struct:	GLOBAL_NETWARE
 ---------------------------------------------------------------------------*/
typedef struct {
	LPTSTR				pszUser;
	LPTSTR				pszServer;
	LPTSTR				pszTree;
	LPTSTR				pszContext;

	BOOL				fConnStatus;
	BOOL				fNds;
	DWORD				dwConnType;
	
	
    LIST_ENTRY			lmsgOutput;
	HRESULT				hr;
} GLOBAL_NETWARE;


/*---------------------------------------------------------------------------
	Struct:	MODEM_DEVICE
 ---------------------------------------------------------------------------*/
typedef struct
{
	DWORD				dwNegotiatedSpeed;
	DWORD				dwModemOptions;
	DWORD				dwDeviceID;
	LPTSTR				pszPort;
	LPTSTR				pszName;
} MODEM_DEVICE;


/*---------------------------------------------------------------------------
	Struct:	GLOBAL_MODEM
 ---------------------------------------------------------------------------*/
typedef struct {
	NdMessage			ndOutput;

	int					cModems;
	MODEM_DEVICE *		pModemDevice;
	HRESULT				hr;
	BOOL				fPerformed; //FALSE: the machine has no line device, test skipped
} GLOBAL_MODEM;


/*---------------------------------------------------------------------------
	Struct:	GLOBAL_DCLIST
 ---------------------------------------------------------------------------*/
typedef struct
{
    LIST_ENTRY			lmsgOutput;

	BOOL				fPerformed; //FALSE: the machine is not a member machine, nor a DC, test skipped
	NdMessage			msgErr;
	HRESULT				hr;
} GLOBAL_DCLIST;



/*---------------------------------------------------------------------------
	Struct:	GLOBAL_TRUST
 ---------------------------------------------------------------------------*/
typedef struct
{
	LPTSTR				pszContext; // context of failure
	HRESULT				hr;	// 0: success, otherwise failed
	BOOL				fPerformed; //FALSE: the machine is not a member machine, nor a DC, test skipped
    LIST_ENTRY			lmsgOutput;
} GLOBAL_TRUST;


/*---------------------------------------------------------------------------
	Struct:	GLOBAL_KERBEROS
 ---------------------------------------------------------------------------*/
typedef struct
{
	UINT				idsContext;// str ID of context, which has %s to take the cause of failure
	HRESULT				hr;	// 0: success, otherwise failed
	BOOL				fPerformed; //FALSE: the machine is not a member machine, nor a DC, test skipped
    LIST_ENTRY			lmsgOutput;
} GLOBAL_KERBEROS;

/*---------------------------------------------------------------------------
	Struct:	GLOBAL_LDAP
 ---------------------------------------------------------------------------*/
typedef struct
{
	UINT				idsContext;// str ID of context, which has %s to take the cause of failure
	HRESULT				hr;	// 0: success, otherwise failed
	BOOL				fPerformed; //FALSE: the machine is not a member machine, nor a DC, test skipped
    LIST_ENTRY			lmsgOutput;
} GLOBAL_LDAP;


typedef struct
{
	HRESULT				hr;
	BOOL				fPerformed; //FALSE: the machine is not a member machine, nor a DC, test skipped
	LIST_ENTRY			lmsgOutput;
}	GLOBAL_DSGETDC;



/*---------------------------------------------------------------------------
	Struct:	AUTONET_TST
 ---------------------------------------------------------------------------*/
typedef struct {
    BOOL    fAutoNet;
} AUTONET_TST;


/*---------------------------------------------------------------------------
	Struct:	DEF_GW_TST
 ---------------------------------------------------------------------------*/
typedef struct {
    BOOL dwNumReachable;
    LIST_ENTRY lmsgOutput;
} DEF_GW_TST;


/*---------------------------------------------------------------------------
	Struct:	NBT_NM_TST
 ---------------------------------------------------------------------------*/
typedef struct {
    LIST_ENTRY lmsgOutput;
    BOOL    fActive;     //used for additional Nbt interfaces whose pResults->fActive == FALSE
    BOOL    fQuietOutput;
} NBT_NM_TST;


/*---------------------------------------------------------------------------
	Struct:	WINS_TST
 ---------------------------------------------------------------------------*/
typedef struct {
	LIST_ENTRY  	lmsgPrimary;
	LIST_ENTRY  	lmsgSecondary;

	// Test result
	HRESULT			hr;
	BOOL			fPerformed; //if FALSE: there is no WINS servier configured for this interface, test skipped
}WINS_TST;


/*---------------------------------------------------------------------------
	Struct:	DNS_TST
 ---------------------------------------------------------------------------*/
typedef struct {
	// Set to TRUE if there is non-verbose output (i.e. errors)
	BOOL		fOutput;
	LIST_ENTRY	lmsgOutput;
} DNS_TST;

typedef struct {
    int garbage;
} NDIS_TST;


typedef struct ___IPX_TEST_FRAME__ {
	// returns 0-3
	ULONG		uFrameType;

	// returns virtual net if NicId = 0
	ULONG		uNetworkNumber;

	// adapter's MAC address
	UCHAR		Node[6];

	LIST_ENTRY	list_entry;
} IPX_TEST_FRAME;

/*---------------------------------------------------------------------------
	Struct:	IPX_TST
 ---------------------------------------------------------------------------*/
typedef struct {
	// Is this interface enabled for IPX?
	BOOL		fActive;

	// passed into various functions
	USHORT		uNicId;

	// Returns TRUE if set
	BOOL		fBindingSet;

	// 1 = lan, 2 = up wan, 3 = down wan
	UCHAR		uType;

	// to support more than one FRAME type
	LIST_ENTRY	list_entry_Frames;	// it's ZeroMemoryed during init

} IPX_TST;



/*---------------------------------------------------------------------------
	Struct:	INTERFACE_RESULT
 ---------------------------------------------------------------------------*/
typedef struct {

	// If this is set to TRUE, show the data for this interface
	BOOL				fActive;

	// The media-sense status of this card
	DWORD				dwNetCardStatus;

	// Name (or ID) of this adapter (typically a GUID)
	LPTSTR				pszName;
	
	// Friendly name for this adapter
	LPTSTR				pszFriendlyName;

	//if NetBT is enabled
	BOOL				fNbtEnabled;
	
    IPCONFIG_TST        IpConfig;
    AUTONET_TST         AutoNet;
    DEF_GW_TST          DefGw;
    NBT_NM_TST          NbtNm;
    WINS_TST            Wins;
	DNS_TST				Dns;
    NDIS_TST            Ndis;
    IPX_TST             Ipx;    
} INTERFACE_RESULT;



/*---------------------------------------------------------------------------
	Struct:	NETDIAG_RESULT
 ---------------------------------------------------------------------------*/
typedef struct {
    GLOBAL_RESULT		Global;
	GLOBAL_IPCONFIG		IpConfig;
    GLOBAL_LOOPBACK		LoopBack;
	GLOBAL_NETBT_TRANSPORTS	NetBt;
    GLOBAL_DEFGW        DefGw;
    GLOBAL_AUTONET      AutoNet;
    GLOBAL_NBTNM        NbtNm;
    GLOBAL_BROWSER      Browser;
    GLOBAL_BINDINGS     Bindings;
	GLOBAL_WINSOCK		Winsock;
    GLOBAL_WAN          Wan;
	GLOBAL_IPX			Ipx;
	GLOBAL_DNS			Dns;
    GLOBAL_ROUTE        Route;
    GLOBAL_NDIS         Ndis;
    GLOBAL_NETSTAT      Netstat;
	GLOBAL_NETWARE		Netware;
	GLOBAL_TRUST		Trust;
	GLOBAL_MODEM		Modem;
	GLOBAL_KERBEROS		Kerberos;
	GLOBAL_DCLIST		DcList;
	GLOBAL_LDAP			LDAP;
	GLOBAL_DSGETDC		DsGetDc;
	GLOBAL_IPSEC		IPSec;
	
	LONG				cNumInterfaces;
	LONG				cNumInterfacesAllocated;
    INTERFACE_RESULT*	pArrayInterface;
	
} NETDIAG_RESULT;

void ResultsInit(NETDIAG_RESULT* pResults);
void PrintGlobalResults(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults);
void PrintPerInterfaceResults(NETDIAG_PARAMS *pParams,
							  NETDIAG_RESULT *pResults,
							  INTERFACE_RESULT *pIfRes);
void FindInterface(NETDIAG_RESULT *pResult, INTERFACE_RESULT **ppIf);
void ResultsCleanup(NETDIAG_PARAMS *pParams, NETDIAG_RESULT* pResults);

void PrintWaitDots(NETDIAG_PARAMS *pParams);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\regutil.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       regutil.h
//
//--------------------------------------------------------------------------

#ifndef HEADER_REGUTIL
#define HEADER_REGUTIL


BOOL
OpenAdapterKey(
  const LPTSTR Name,
  PHKEY Key
  );

BOOL 
ReadRegistryDword(HKEY Key,
                       LPCTSTR ParameterName,
                       LPDWORD Value);

BOOL ReadRegistryOemString(HKEY Key, 
                           LPWSTR ParameterName,
                           LPTSTR String,
                           LPDWORD Length);

BOOL ReadRegistryIpAddrString(HKEY Key,
                              LPCTSTR ParameterName,
                              PIP_ADDR_STRING IpAddr);

BOOL ReadRegistryString(HKEY Key,
                        LPCTSTR ParameterName,
                        LPTSTR String,
                        LPDWORD Length);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\route.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      route.c
//
//  Abstract:
//
//      Queries into network drivers
//
//  Author:
//
//      Anilth  - 4-20-1998
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//--

#include "precomp.h"

//
// Rajkumar - Two Functions from iphlpapi.dll
//

DWORD
WINAPI
GetIpAddrTable(
    OUT    PMIB_IPADDRTABLE pIpAddrTable,
    IN OUT PULONG           pdwSize,
    IN     BOOL             bOrder
    );

DWORD
InternalGetIpForwardTable(
    OUT   MIB_IPFORWARDTABLE    **ppIpForwardTable,
    IN    HANDLE                hHeap,
    IN    DWORD                 dwAllocFlags
    );
//--------------------------------------------------------


//functions defined in this file
void MapInterface(char *IPAddr, ULONG IfIndex);
BOOLEAN ImprovedInetAddr(char  *AddressString, ULONG *AddressValue);

HRESULT
PrintRoute(
    NETDIAG_RESULT  *pResults,
    char            *Dest,
    ULONG            DestVal,
    char            *Gate,
    ULONG            GateVal,
    BOOLEAN          Persistent,
    const char     * DestPat
    );

LPCTSTR
PrintRouteEntry(
         ULONG Dest,
         ULONG Mask,
         ULONG Gate,
         ULONG Interface,
         ULONG Metric1
         );

HRESULT
PrintPersistentRoutes(
    NETDIAG_RESULT  *pResults,
    char* Dest,
    ULONG DestVal,
    char* Gate,
    ULONG GateVal
   );


BOOL
RouteTest(NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
/*++

Routine Description:

   Enumerate the static and persistent entries in the routing table

Arguments:

   None.

Return Value:
   TRUE

Author:
   Rajkumar 06/27/98

--*/
{
    HRESULT hr = S_OK;

    //$REVIEW only perform the test when is really verbose
    if (!pParams->fReallyVerbose)
        return hr;

    PrintStatusMessage( pParams, 4, IDS_ROUTE_STATUS_MSG );
   //
   // Print all static entries in the ip forward table
   //



   hr = PrintRoute(pResults,
              "*",
              WILD_CARD,
              "*",
              WILD_CARD,
              TRUE,
              "*"
             );

   //
   // Print all the persistent route entries
   //

   if( S_OK == hr )
        hr = PrintPersistentRoutes(pResults,
                                   "*",
                                   WILD_CARD,
                                   "*",
                                   WILD_CARD
                                   );


   pResults->Route.hrTestResult = hr;
   return hr;

}


HRESULT
PrintRoute(
    NETDIAG_RESULT  *pResults,
    char            *Dest,
    ULONG            DestVal,
    char            *Gate,
    ULONG            GateVal,
    BOOLEAN          Persistent,
    const char     * DestPat
    )
/*++

Routine Description:
    This routine prints all the static entries in then IP forward table.
    The entry in the routing table is declared static if  the type of the
    entry is MIB_IPPROTO_LOCAL.

Arguments:

    char *Dest: pointer to destination IP address string.  This
        is NULL if no value was provided/no filtering desired.
    ULONG DestVal: value of destination IP address to filter route
        table with.  If Dest is NULL, this is ignored.
    char *Gate: pointer to gateway IP address string. This is NULL
        if no value was provided/no filtering desired.
    ULONG GateVal: value of gateway IP address to filter route
        table with.  If Gate is NULL, this is ignored.
    BOOL  Persistent: set if persistent routes are to be printed.
Returns: ULONG

Can also be found in nt\private\net\sockets\tcpcmd\route\route.c
  --*/
{
    int                     printcount = 0;
    int                     dwResult, j, k, err, alen;
    DWORD                   i;
    PMIB_IPFORWARDTABLE     prifRouteTable = NULL;
    PMIB_IFTABLE            pIfTable       = NULL;

    // ====================================================================
    // Get Route Table.

    pResults->Route.dwNumRoutes = 0;
    InitializeListHead(&pResults->Route.lmsgRoute);

    dwResult = InternalGetIpForwardTable(&prifRouteTable,
                                         GetProcessHeap(), HEAP_NO_SERIALIZE );

    if(dwResult || !prifRouteTable){
        DEBUG_PRINT(("GetIpForwardTable/2: err=%d, dwResult=%d\n",
                     GetLastError(), dwResult ));
        return S_FALSE;
    }

    if( ! prifRouteTable->dwNumEntries )
    {
        return S_OK;
    }


    for(i = 0; i < prifRouteTable->dwNumEntries; i++)
    {
        PMIB_IPFORWARDROW pfr = &prifRouteTable->table[i];

        // Only print this entry if the destination matches the parameter

        if( ( Dest != NULL )
            &&  ( DestVal != WILD_CARD )
            &&  ( pfr->dwForwardDest != DestVal )
            &&  ( DestPat == NULL )
            )
            continue;

        // Only print this entry if the Gateway matches the parameter

        if( ( Gate != NULL )
            && ( GateVal != WILD_CARD  )
            && ( pfr->dwForwardNextHop != GateVal )
            )
            continue;

        if( DestPat )
        {
            char DestStr[32];
            NetpIpAddressToStr( pfr->dwForwardDest, DestStr );
            if( ! match( DestPat, DestStr ) )
            {
                TRACE_PRINT(("PrintRoute: skipping %s !~ %s\n",
                             DestPat, DestStr ));
                continue;
            }
        }

        // Either we have a match on Dest/Gateway or they are
        // wildcard/don't care.

        // Display the header first time.

        // We are going to display only static routes

        if ( printcount++ < 1 )
            //IDS_ROUTE_14203                  "Network Destination          Netmask             Gateway           Interface    Metric\n"
           AddMessageToListId( &pResults->Route.lmsgRoute, Nd_ReallyVerbose, IDS_ROUTE_14203);

       //IDS_ROUTE_14204                  "%s\n"
        AddMessageToList( &pResults->Route.lmsgRoute, Nd_ReallyVerbose,
                          IDS_ROUTE_14204,
                          PrintRouteEntry( pfr->dwForwardDest,
                                pfr->dwForwardMask,
                                pfr->dwForwardNextHop,
                                pfr->dwForwardIfIndex,
                                pfr->dwForwardMetric1)
              );
    }

    pResults->Route.dwNumRoutes = printcount;

    HeapFree( GetProcessHeap(), HEAP_NO_SERIALIZE, pIfTable );
    HeapFree( GetProcessHeap(), HEAP_NO_SERIALIZE, prifRouteTable);

    return ( NO_ERROR );
}


LPCTSTR
PrintRouteEntry(
         ULONG Dest,
         ULONG Mask,
         ULONG Gate,
         ULONG Interface,
         ULONG Metric1
         )
/*++
Description:
Formats and displays a single route entry.

Arguments:
Dest:      The destination address.
Mask:      The destination netmask.
Gate:      The first hop gateway address.
Interface: The interface address for the gateway net.
Metric1:   The primary route metric.

Author:
 07/01/98 Rajkumar

--*/
{
    static TCHAR  s_szBuffer[512];
    TCHAR   szFormat[128];
    char   DestStr[32];
    char   GateStr[32];
    char   NetmaskStr[32];
    char   MetricStr[32];
    char   IfStr[32];

    NetpIpAddressToStr( Dest, DestStr);
    NetpIpAddressToStr( Gate, GateStr);
    NetpIpAddressToStr( Mask, NetmaskStr);


    MapInterface(IfStr,Interface);

    if( Metric1 > MAX_METRIC )    Metric1 = MAX_METRIC;

    sprintf( MetricStr, "%u", Metric1 );

    //IDS_ROUTE_14205       "%16s  %16s  %16s  %16s  %6s"
    LoadString(NULL, IDS_ROUTE_14205, szFormat, DimensionOf(szFormat));
    assert(szFormat[0]);
    _stprintf(s_szBuffer, szFormat, DestStr,
              NetmaskStr, GateStr, IfStr, MetricStr);
    return s_szBuffer;

}



BOOLEAN
ExtractRoute(
    char  *RouteString,
    ULONG *DestVal,
    ULONG *MaskVal,
    ULONG *GateVal,
    ULONG *MetricVal
    )
/*++
Description:
Extracts the dest, mask, and gateway from a persistent
route string, as stored in the registry.

Arguments:
RouteString : The string to parse.
DestVal     : The place to put the extracted destination
MaskVal     : The place to put the extracted mask
GateVal     : The place to put the extracted gateway
MetricVal   : The place to put the extracted metric


Author:
 07/01/98 Rajkumar . Created.

--*/
{
    char  *addressPtr = RouteString;
    char  *indexPtr = RouteString;
    ULONG  address;
    ULONG  i;
    char   saveChar;
    BOOLEAN EndOfString=FALSE;

    //
    // The route is laid out in the string as "Dest,Mask,Gateway,Mertic".
    //


    //
    // set MetricVal to 1 to take care of persistent routes without the
    // metric value
    //

    *MetricVal = 1;

    for (i=0; i<4 && !EndOfString; i++) {
        //
        // Walk the string to the end of the current item.
        //

        while (1) {

            if (*indexPtr == '\0') {

                if ((i >= 2) && (indexPtr != addressPtr)) {
                    //
                    // End of string
                    //
                    EndOfString = TRUE;
                    break;
                }

                return(FALSE);
            }

            if (*indexPtr == ROUTE_SEPARATOR) {
                break;
            }

            indexPtr++;
        }

        //
        // NULL terminate the current substring and extract the address value.
        //
        saveChar = *indexPtr;

        *indexPtr = '\0';

        if (i==3) {
           address = atoi (addressPtr);
        } else if (!ImprovedInetAddr(addressPtr, &address)) {
            *indexPtr = saveChar;
            return(FALSE);
        }

        *indexPtr = saveChar;

        switch(i) {
        case 0:    *DestVal = address;   break;
        case 1:    *MaskVal = address;   break;
        case 2:    *GateVal = address;   break;
        case 3:    *MetricVal = address; break;
        default:   return FALSE;
        }
        addressPtr = ++indexPtr;
    }

    return(TRUE);
}

//
// Rajkumar - This function is based on route implementation
//

HRESULT
PrintPersistentRoutes(
    NETDIAG_RESULT  *pResults,
    char* Dest,
    ULONG DestVal,
    char* Gate,
    ULONG GateVal
   )
/*++
Routine Description:
Displays the list of persistent routes


Arguments:  Dest     : The destination string. (display filter)
            DestVal  : The numeric destination value. (display filter)
            Gate     : The gateway string. (display filter)
            GateVal  : The numeric gateway value. (display filter)

Returns: None


--*/
{
    //
    // Delete this route from the PersistentRoutes list in the
    // registry if it is there.
    //
    DWORD     status;
    HKEY      key;
    char      valueString[ROUTE_DATA_STRING_SIZE];
    DWORD     valueStringSize;
    DWORD     valueType;
    DWORD     index = 0;
    ULONG     dest, mask, gate, metric;
    BOOLEAN   headerPrinted = FALSE;
    BOOLEAN   match;

    pResults->Route.dwNumPersistentRoutes = 0;
    InitializeListHead(&pResults->Route.lmsgPersistentRoute);

    status = RegOpenKeyA(HKEY_LOCAL_MACHINE, "SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\PersistentRoutes", &key);

    if (status == ERROR_SUCCESS)
    {

        while(1) {


            valueStringSize = ROUTE_DATA_STRING_SIZE - 1;

            status = RegEnumValueA(
                                   key,
                                   index++,
                                   valueString,
                                   &valueStringSize,
                                   NULL,
                                   &valueType,
                                   NULL,
                                   0
                                   );


            if (status != ERROR_SUCCESS)
            {
                if ((status == ERROR_BUFFER_OVERFLOW) ||
                    (status == ERROR_MORE_DATA) )
                {
                    continue;
                }
                else
                    break;
            }

            if (valueType != REG_SZ)
                continue;


            valueString[valueStringSize++] = '\0';


            if ( !ExtractRoute(
                               valueString,
                               &dest,
                               &mask,
                               &gate,
                               &metric
                               )
                )
              {
                  continue;
              }


              //IDS_ROUTE_14207                  "%s\n"
              AddMessageToList( &pResults->Route.lmsgPersistentRoute, Nd_ReallyVerbose,
                                IDS_ROUTE_14207,
                                PrintRouteEntry(dest, mask, gate, 0, metric));

              pResults->Route.dwNumPersistentRoutes++;

        } // end while

        CloseHandle(key);
    }
    else
    {
        DebugMessage2("RegOpenKeyA %s failed\n","Tcpip\\Parameters\\Persistent");
        return S_FALSE;
    }

    return S_OK;
}


void MapInterface(char *IPAddr, ULONG IfIndex)
{

    DWORD IpAddrTableSize=0;
    PMIB_IPADDRTABLE pIpAddrTable=NULL;
    char *TempBuf;
    BOOL bOrder=TRUE;
    HRESULT hr;
    DWORD i;


    sprintf(IPAddr,"%x",IfIndex);

    hr=GetIpAddrTable(NULL,
                      &IpAddrTableSize,
                      bOrder);

    if (hr != ERROR_SUCCESS && hr != ERROR_INSUFFICIENT_BUFFER) {
        DebugMessage("GetIpAddrTable() failed.\n");
        return;
    }

    pIpAddrTable=(PMIB_IPADDRTABLE) Malloc(IpAddrTableSize);

    if (pIpAddrTable == NULL) {
        DebugMessage("Out of Memory in RouteTest::MapInterface().\n");
        return;
    }

    ZeroMemory( pIpAddrTable, IpAddrTableSize );

    hr=GetIpAddrTable(pIpAddrTable,
                          &IpAddrTableSize,
                          bOrder);


    if (hr != ERROR_SUCCESS)
    {
        DebugMessage("GetIpAddrTable() failed.\n");
        Free(pIpAddrTable);
        return;
    }


    for (i=0; i < pIpAddrTable->dwNumEntries; i++)
    {
        if ((pIpAddrTable->table[i].dwIndex == IfIndex) && (pIpAddrTable->table[i].dwAddr != 0) && (pIpAddrTable->table[i].wType & MIB_IPADDR_PRIMARY))
        {
            TempBuf=inet_ntoa(*(struct in_addr*)&pIpAddrTable->table[i].dwAddr);
            if (!TempBuf) {
                break;;
            }
            strcpy(IPAddr, TempBuf);
            break;
        }

    }

    Free(pIpAddrTable);
    return;
}


BOOLEAN
ImprovedInetAddr(
    char  *AddressString,
    ULONG *AddressValue
)
/*++

Description:
Converts an IP address string to its numeric equivalent.

Arguments:
 char *AddressString: The string to convert
 ULONG AddressValue : The place to store the converted value.

Returns: TRUE

Author:
  07/01/98 Rajkumar . Created.
--*/
{
    ULONG address = inet_addr(AddressString);

    if (address == 0xFFFFFFFF) {
        if (strcmp(AddressString, "255.255.255.255") == 0) {
           *AddressValue = address;
           return(TRUE);
        }

        return(FALSE);
    }

    *AddressValue = address;
    return TRUE;
}



void RouteGlobalPrint(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults)
{
    if (!pParams->fReallyVerbose)
        return;

    if (pParams->fReallyVerbose || !FHrOK(pResults->Route.hrTestResult))
    {
        PrintNewLine(pParams, 2);
        PrintTestTitleResult(pParams,
                             IDS_ROUTE_LONG,
							 IDS_ROUTE_SHORT,
							 TRUE,
                             pResults->Route.hrTestResult,
                             0);
    }

    if( pParams->fReallyVerbose)
    {
        if( 0 == pResults->Route.dwNumRoutes)
        {
            //IDS_ROUTE_14201                  "No Entries in the IP Forward Table\n"
            PrintMessage( pParams, IDS_ROUTE_14201);
        }
        else
        {
            //IDS_ROUTE_14202                  "Active Routes :\n"
            PrintMessage( pParams, IDS_ROUTE_14202);
            PrintMessageList(pParams, &pResults->Route.lmsgRoute);
        }

        if( 0 == pResults->Route.dwNumPersistentRoutes)
        {
             //IDS_ROUTE_14208                  "No persistent route entries.\n"
             PrintMessage( pParams, IDS_ROUTE_14208);

        }
        else
        {
            //IDS_ROUTE_14206                  "\nPersistent Route Entries: \n"
            PrintMessage( pParams, IDS_ROUTE_14206);
            PrintMessageList(pParams, &pResults->Route.lmsgPersistentRoute);
        }
    }

}


void RoutePerInterfacePrint(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults, INTERFACE_RESULT *pInterfaceResults)
{
    if (!pParams->fReallyVerbose)
        return;

}


void RouteCleanup(IN NETDIAG_PARAMS *pParams,
                     IN OUT NETDIAG_RESULT *pResults)
{
    MessageListCleanUp(&pResults->Route.lmsgRoute);
    MessageListCleanUp(&pResults->Route.lmsgPersistentRoute);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\sample.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      sample.c
//
//  Abstract:
//
//      Queries into network drivers
//
//  Author:
//
//      Anilth	- 4-20-1998 
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//--


#include "precomp.h"

HRESULT SamplePassTest( NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
{
	if (pParams->fReallyVerbose)
	{
		printf("    Performing the sample pass test... pass\n");
	}
    return S_OK;

} /* END OF SamplePassTest() */


/*!--------------------------------------------------------------------------
	SamplePassGlobalPrint
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void SamplePassGlobalPrint( NETDIAG_PARAMS* pParams,
						  NETDIAG_RESULT*  pResults)
{
	if (pParams->fVerbose)
	{
		printf(" Sample Pass Test : pass\n");
	}
	if (pParams->fReallyVerbose)
	{
		printf("    more text\n");
	}
}

/*!--------------------------------------------------------------------------
	SamplePassPerInterfacePrint
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void SamplePassPerInterfacePrint( NETDIAG_PARAMS* pParams,
								NETDIAG_RESULT*  pResults,
								INTERFACE_RESULT *pInterfaceResults)
{
	// no per-interface results
}


/*!--------------------------------------------------------------------------
	SamplePassCleanup
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void SamplePassCleanup( NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
{
}



HRESULT SampleFailTest( NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
{
	if (pParams->fReallyVerbose)
	{
		printf("    Performing the sample fail test... fail\n");
	}
    return S_FALSE;

} /* END OF SampleFailTest() */


/*!--------------------------------------------------------------------------
	SampleFailGlobalPrint
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void SampleFailGlobalPrint( NETDIAG_PARAMS* pParams,
						  NETDIAG_RESULT*  pResults)
{
	printf(" Sample Fail Test : fail\n");
	printf("    more text\n");
}

/*!--------------------------------------------------------------------------
	SampleFailPerInterfacePrint
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void SampleFailPerInterfacePrint( NETDIAG_PARAMS* pParams,
								NETDIAG_RESULT*  pResults,
								INTERFACE_RESULT *pInterfaceResults)
{
	// no per-interface results
}


/*!--------------------------------------------------------------------------
	SampleFailCleanup
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
void SampleFailCleanup( NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\snmputil.c ===
//*****************************************************************************
//
// Name:        snmputil.c
//
// Description: Provides functions to read tables of data from snmp.
//
// Used by:     netstat.exe, arp.exe, route.exe
//
// History:
//  01/12/94  JayPh     Created.
//  18-Feb-97 MohsinA   Fixing.
//  Copied from net\tcpip\commands\common2\snmpinfo.c
//*****************************************************************************

//*****************************************************************************
//
// Copyright (c) 1994 by Microsoft Corp.  All rights reserved.
//
//*****************************************************************************

// #define DEBUG

//
// Include Files
//

#include "precomp.h"
#include <time.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <snmp.h>

#include "snmputil.h"

//
//

ulong verbose = 0;

//
// Definitions
//

#define MAX_ID_LENGTH           50
#define MAX_RETRY_COUNT         10

// Interface ID values

#define ID_IF_INDEX             1
#define ID_IF_DESC              2
#define ID_IF_TYPE              3
#define ID_IF_MTU               4
#define ID_IF_SPEED             5
#define ID_IF_PHYSADDR          6
#define ID_IF_ADMINSTATUS       7
#define ID_IF_OPERSTATUS        8
#define ID_IF_LASTCHANGE        9
#define ID_IF_INOCTETS          10
#define ID_IF_INUCASTPKTS       11
#define ID_IF_INNUCASTPKTS      12
#define ID_IF_INDISCARDS        13
#define ID_IF_INERRORS          14
#define ID_IF_INUKNOWNPROTOS    15
#define ID_IF_OUTOCTETS         16
#define ID_IF_OUTUCASTPKTS      17
#define ID_IF_OUTNUCASTPKTS     18
#define ID_IF_OUTDISCARDS       19
#define ID_IF_OUTERRORS         20
#define ID_IF_OUTQLEN           21

// IP ID Values

#define ID_IP_FORWARDING        1
#define ID_IP_DEFAULTTTL        2
#define ID_IP_INRECEIVES        3
#define ID_IP_INHDRERRORS       4
#define ID_IP_INADDRERRORS      5
#define ID_IP_FORWDATAGRAMS     6
#define ID_IP_INUNKNOWNPROTOS   7
#define ID_IP_INDISCARDS        8
#define ID_IP_INDELIVERS        9
#define ID_IP_OUTREQUESTS       10
#define ID_IP_OUTDISCARDS       11
#define ID_IP_OUTNOROUTES       12
#define ID_IP_REASMTIMEOUTS     13
#define ID_IP_REASMREQDS        14
#define ID_IP_REASMOKS          15
#define ID_IP_REASMFAILS        16
#define ID_IP_FRAGOKS           17
#define ID_IP_FRAGFAILS         18
#define ID_IP_FRAGCREATES       19
#define ID_IP_ADDRTABLE         20
#define ID_IP_ROUTETABLE        21
#define ID_IP_ARPTABLE          22
#define ID_IP_ROUTINGDISCARDS   23

// IPAddr ID Values

#define ID_IPADDR_ADDR          1
#define ID_IPADDR_INDEX         2
#define ID_IPADDR_MASK          3
#define ID_IPADDR_BCASTADDR     4
#define ID_IPADDR_REASMSIZE     5

// Route ID values

#define ID_ROUTE_DEST           1
#define ID_ROUTE_IFINDEX        2
#define ID_ROUTE_METRIC1        3
#define ID_ROUTE_METRIC2        4
#define ID_ROUTE_METRIC3        5
#define ID_ROUTE_METRIC4        6
#define ID_ROUTE_NEXTHOP        7
#define ID_ROUTE_TYPE           8
#define ID_ROUTE_PROTO          9
#define ID_ROUTE_AGE            10
#define ID_ROUTE_MASK           11
#define ID_ROUTE_METRIC5        12

// ARP ID Values

#define ID_ARP_IFINDEX          1
#define ID_ARP_PHYSADDR         2
#define ID_ARP_NETADDR          3
#define ID_ARP_TYPE             4

// ICMP ID Values

#define ID_ICMP_INMSGS                  1
#define ID_ICMP_INERRORS                2
#define ID_ICMP_INDESTUNREACHES         3
#define ID_ICMP_INTIMEEXCDS             4
#define ID_ICMP_INPARMPROBS             5
#define ID_ICMP_INSRCQUENCHS            6
#define ID_ICMP_INREDIRECTS             7
#define ID_ICMP_INECHOS                 8
#define ID_ICMP_INECHOREPS              9
#define ID_ICMP_INTIMESTAMPS            10
#define ID_ICMP_INTIMESTAMPREPS         11
#define ID_ICMP_INADDRMASKS             12
#define ID_ICMP_INADDRMASKREPS          13
#define ID_ICMP_OUTMSGS                 14
#define ID_ICMP_OUTERRORS               15
#define ID_ICMP_OUTDESTUNREACHES        16
#define ID_ICMP_OUTTIMEEXCDS            17
#define ID_ICMP_OUTPARMPROBS            18
#define ID_ICMP_OUTSRCQUENCHS           19
#define ID_ICMP_OUTREDIRECTS            20
#define ID_ICMP_OUTECHOS                21
#define ID_ICMP_OUTECHOREPS             22
#define ID_ICMP_OUTTIMESTAMPS           23
#define ID_ICMP_OUTTIMESTAMPREPS        24
#define ID_ICMP_OUTADDRMASKS            25
#define ID_ICMP_OUTADDRMASKREPS         26

// TCP ID Values

#define ID_TCP_RTOALGORITHM     1
#define ID_TCP_RTOMIN           2
#define ID_TCP_RTOMAX           3
#define ID_TCP_MAXCONN          4
#define ID_TCP_ACTIVEOPENS      5
#define ID_TCP_PASSIVEOPENS     6
#define ID_TCP_ATTEMPTFAILS     7
#define ID_TCP_ESTABRESETS      8
#define ID_TCP_CURRESTABS       9
#define ID_TCP_INSEGS           10
#define ID_TCP_OUTSEGS          11
#define ID_TCP_RETRANSSEGS      12
#define ID_TCP_CONNTABLE        13
#define ID_TCP_INERRS           14
#define ID_TCP_OUTRSTS          15

// TCP CONN ID Values

#define ID_TCPCONN_STATE        1
#define ID_TCPCONN_LOCALADDR    2
#define ID_TCPCONN_LOCALPORT    3
#define ID_TCPCONN_REMOTEADDR   4
#define ID_TCPCONN_REMOTEPORT   5

// UDP ID Values

#define ID_UDP_INDATAGRAMS      1
#define ID_UDP_NOPORTS          2
#define ID_UDP_INERRORS         3
#define ID_UDP_OUTDATAGRAMS     4
#define ID_UDP_CONNTABLE        5

// UDP CONN ID Values

#define ID_UDPCONN_LOCALADDR    1
#define ID_UDPCONN_LOCALPORT    2

//
// Structure Definitions
//

typedef struct _OIDdef {
    ulong  Length;
    ulong  Val[MAX_ID_LENGTH];
    ulong  EntElemOffset;
    ulong  BackOffset;
} OIDdef;


//
// Local Function Prototypes
//

ulong ReadTable( GenericTable *pList, ulong Type, ulong Size );
void SaveData_IF( GenericTable    *pEntry,
                  RFC1157VarBind   item,
                  OIDdef          *pOid );
void SaveData_IP( GenericTable    *pEntry,
                  RFC1157VarBind   item,
                  OIDdef          *pOid );
void SaveData_IPAddr( GenericTable    *pEntry,
                      RFC1157VarBind   item,
                      OIDdef          *pOid );
void SaveData_ROUTE( GenericTable    *pEntry,
                     RFC1157VarBind   item,
                     OIDdef          *pOid );
void SaveData_ARP( GenericTable    *pEntry,
                   RFC1157VarBind   item,
                   OIDdef          *pOid );
void SaveData_ICMP( GenericTable    *pEntry,
                    RFC1157VarBind   item,
                    OIDdef          *pOid );
void SaveData_TCP( GenericTable    *pEntry,
                   RFC1157VarBind   item,
                   OIDdef          *pOid );
void SaveData_TCPCONN( GenericTable    *pEntry,
                       RFC1157VarBind   item,
                       OIDdef          *pOid );
void SaveData_UDP( GenericTable    *pEntry,
                   RFC1157VarBind   item,
                   OIDdef          *pOid );
void SaveData_UDPCONN( GenericTable    *pEntry,
                       RFC1157VarBind   item,
                       OIDdef          *pOid );


//
// Global Variables
//

// These are used to create object id's

OIDdef PreambleDef   = { 6, { 1,  3,  6, 1, 2, 1 },  0, 0 };
OIDdef IfInfoDef     = { 4, { 2,  2,  1, 1       },  9, 2 };
OIDdef IPInfoDef     = { 2, { 4,  1              },  7, 1 };
OIDdef IPAddrInfoDef = { 4, { 4,  20, 1, 1       },  9, 2 };
OIDdef RouteInfoDef  = { 4, { 4,  21, 1, 1       },  9, 2 };
OIDdef ARPInfoDef    = { 4, { 4,  22, 1, 1       },  9, 2 };
OIDdef ICMPInfoDef   = { 2, { 5,  1,             },  7, 1 };
OIDdef TCPInfoDef    = { 2, { 6,  1              },  7, 1 };
OIDdef TCPConnDef    = { 4, { 6, 13,  1, 1       },  9, 2 };
OIDdef UDPInfoDef    = { 2, { 7,  1              },  7, 1 };
OIDdef UDPConnDef    = { 4, { 7,  5,  1, 1       },  9, 2 };


// These are used to hold the addresses of the functions we use in inetmib1.dll

FARPROC   gQueryAddr;
FARPROC   gInitAddr;

//
// From //ORVILLE/RAZZLE/src/net/snmp/agent/mgmtapi/mgmtapi.c
// See  //ORVILLE/RAZZLE/src/public/sdk/inc/snmp.h
//          SNMP_FUNC_TYPE is WINAPI.
//
// These pointer to functions are imported from mgmtapi.dll (available
// on nt server only with snmp service, but can be copied).
// - MohsinA, 11-Mar-97.
//

BOOL (SNMP_FUNC_TYPE * pSnmpMgrOidToStr )( IN  AsnObjectIdentifier *oid,
                                            OUT LPSTR           *string );


//
// Exported Functions
//

//*****************************************************************************
//
// Name:        InitSnmp
//
// Description: Set up to use inetmib1.dll.  Load the DLL, and get addresses
//              for the interesting procedures.
//              NOTE: This function must be called before calling GetTable().
//
// Parameters:  void.
//
// Returns:     ulong: NO_ERROR if successful, error code otherwise.
//
// History:
//  12/20/93  JayPh     Created.
//
//*****************************************************************************

ulong InitSnmp( void )
{
    HANDLE                     hExtension;
    ulong                      TimeZeroReference;
    HANDLE                     hPollForTrapEvent;
    AsnObjectIdentifier        SupportedView;

    HANDLE                     mgmtapi_dll;

    TimeZeroReference = (ulong)time( (time_t *)0 );


    // Load the management apis, only on servers, but useful for
    // figuring out snmp jargon.

    if( verbose ){
        mgmtapi_dll = LoadLibraryA( "mgmtapi.dll" );
        if( mgmtapi_dll ){
            pSnmpMgrOidToStr
            = (LPVOID) GetProcAddress( mgmtapi_dll, "SnmpMgrOidToStr" );
        }
        if( !mgmtapi_dll || !pSnmpMgrOidToStr ){
            DEBUG_PRINT((
                "InitSnmp: mgmtapi.dll:pSnmpMgrOidToStr() not found.\n"
            ));
        }
    }



    // Load inetmib1.dll and get proc address for SnmpExtensionQuery

    hExtension = LoadLibraryA( "inetmib1.dll" );
    if ( hExtension == NULL )
    {
        DEBUG_PRINT(("InitSnmp: cannot load inetmib1.dll\n"));
        return ( ERROR_FILE_NOT_FOUND );
    }

    gInitAddr = GetProcAddress( hExtension, "SnmpExtensionInit" );
    if ( gInitAddr == NULL )
    {
        DEBUG_PRINT(("InitSnmp: inetmib1.dll:SnmpExtensionInit missing.\n"));
        return ( ERROR_FILE_NOT_FOUND );
    }

    gQueryAddr = GetProcAddress( hExtension, "SnmpExtensionQuery" );
    if ( gQueryAddr == NULL )
    {
        DEBUG_PRINT(("InitSnmp: inetmib1.dll:SnmpExtensionQuery missing.\n"));
        return ( ERROR_FILE_NOT_FOUND );
    }

    // Initialize the extension DLL

    (*gInitAddr)( TimeZeroReference, &hPollForTrapEvent, &SupportedView );

    return ( NO_ERROR );
}


//*****************************************************************************
//
// Name:        GetTable
//
// Description: Gets a consistent table from snmp.  Consistency is achieved by
//              reading the table, reading the table a second time and
//              comparing the two.  If they match, we are done.  If they don't
//              match, we read the table again and compare again.  Repeating
//              until we have a match, or our retry count exceeds a threshold.
//
// Parameters:  ulong Type: type of table to get.
//              ulong *pResult: pointer to location to receive the result code.
//
// Returns:     void *: NULL if some error, otherwise pointer to table.
//
// History:
//  01/12/94  JayPh     Created.
//  18-Feb-97 MohsinA   Removed while loop and pList1.
//*****************************************************************************

void *GetTable( ulong Type, ulong *pResult )
{
    GenericTable   *pList2;
    ulong   Result;
    ulong   RetryCount = 0;
    ulong   Size;

    if( verbose ){
        fprintf(stderr, "GetTable: type = %d\n", Type );
    }

    if ( Type > TYPE_UDPCONN )
    {
        *pResult = ERROR_INVALID_PARAMETER;
        return ( NULL );
    }

    // Allocate memory for the list heads

    switch ( Type )
    {
    case TYPE_IF:
        Size = sizeof( IfEntry ) + MAX_IFDESCR_LEN;
        break;

    case TYPE_IP:
        Size = sizeof( IpEntry );
        break;

    case TYPE_IPADDR:
        Size = sizeof( IpAddrEntry );
        break;

    case TYPE_ROUTE:
        Size = sizeof( RouteEntry );
        break;

    case TYPE_ARP:
        Size = sizeof( ArpEntry );
        break;

    case TYPE_ICMP:
        Size = sizeof( IcmpEntry );
        break;

    case TYPE_TCP:
        Size = sizeof( TcpEntry );
        break;

    case TYPE_TCPCONN:
        Size = sizeof( TcpConnEntry );
        break;

    case TYPE_UDP:
        Size = sizeof( UdpEntry );
        break;

    case TYPE_UDPCONN:
        Size = sizeof( UdpConnEntry );
        break;

    }

    // Don't need pList1 - MohsinA, 18-Feb-97.

    pList2 = (GenericTable *)SNMP_malloc( Size );
    if ( pList2 == NULL )
    {
        *pResult = ERROR_NOT_ENOUGH_MEMORY;
        return ( NULL );
    }

    InitializeListHead( &pList2->ListEntry );

    // Read the table into List2

    Result = ReadTable( pList2, Type, Size );
    if ( Result != NO_ERROR )
    {
        FreeTable( pList2 );
        *pResult = Result;
        return ( NULL );
    }


    // Useless while loop removed. - MohsinA, 18-Feb-97.

    *pResult = NO_ERROR;
    return ( pList2 );
}


//*****************************************************************************
//
// Name:        FreeTable
//
// Description: Free all entries in the list, including the list head.
//
// Parameters:  GenericTable *pList: pointer to head of list.
//
// Returns:     void.
//
// History:
//  01/12/94  JayPh     Created.
//
//*****************************************************************************

void FreeTable( GenericTable *pList )
{
    GenericTable  *pTmp;
    LIST_ENTRY    *pTmpList;

    while ( !IsListEmpty( &pList->ListEntry ) )
    {
        pTmpList = RemoveHeadList( &pList->ListEntry );
        pTmp = CONTAINING_RECORD( pTmpList,
                                  GenericTable,
                                  ListEntry );
        SNMP_free( pTmp );
    }

    SNMP_free( pList );
}


//
// Internal Functions
//

//*****************************************************************************
//
// Name:        ReadTable
//
// Description: Queries the MIB and builds a table representing the data we are
//              interested in.
//
// Parameters:  GenericTable *pList: address of unitialized head of the entry
//                      list.
//              ulong Type: type of table we want.
//              ulong Size: size of a table entry.
//
// Returns:     ulong: NO_ERROR if no error, and table is built.
//
// History:
//  01/12/94  JayPh     Created.
//
//*****************************************************************************

ulong ReadTable( GenericTable *pList, ulong Type, ulong Size )
{
    AsnInteger          GetNextReq = ASN_RFC1157_GETNEXTREQUEST;
    RFC1157VarBind      item;
    RFC1157VarBindList  VarBinds = { &item, 1 };
    AsnObjectIdentifier oidBackup;
    AsnInteger          ErrorStatus = 0;
    AsnInteger          ErrorIndex = 0;
    ulong              *pId;
    GenericTable       *pTable;
    ulong               LastField = 0;
    uchar              *pTmp;
    ulong               i;
    OIDdef             *pOid;
    ulong               BreakLoop = FALSE;

    if( verbose ){
        fprintf(stderr,"ReadTable: type = %d\n", Type);
    }

    // Walk SNMP database, building local table.

    pId = (ulong *)SNMP_malloc( (sizeof( ulong ) * MAX_ID_LENGTH) );
    if ( pId == NULL )
    {
        return ( ERROR_NOT_ENOUGH_MEMORY );
    }

    item.name.ids = pId;

    // Build OID from preamble and table-specific suffix

    // Copy preamble

    for ( i = 0; i < PreambleDef.Length; i++ )
    {
        *pId++ = PreambleDef.Val[i];
    }

    // Get pointer to table-specific info

    switch ( Type )
    {
    case TYPE_IF:
        pOid = &IfInfoDef;
        break;

    case TYPE_IP:
        pOid = &IPInfoDef;
        break;

    case TYPE_IPADDR:
        pOid = &IPAddrInfoDef;
        break;

    case TYPE_ROUTE:
        pOid = &RouteInfoDef;
        break;

    case TYPE_ARP:
        pOid = &ARPInfoDef;
        break;

    case TYPE_ICMP:
        pOid = &ICMPInfoDef;
        break;

    case TYPE_TCP:
        pOid = &TCPInfoDef;
        break;

    case TYPE_TCPCONN:
        pOid = &TCPConnDef;
        break;

    case TYPE_UDP:
        pOid = &UDPInfoDef;
        break;

    case TYPE_UDPCONN:
        pOid = &UDPConnDef;
        break;

    }

    // Copy table-specific info

    for ( i = 0; i < pOid->Length; i++ )
    {
        *pId++ = pOid->Val[i];
    }

    item.name.idLength = PreambleDef.Length + pOid->Length;
    item.value.asnType = ASN_NULL;

    pTable = pList;

    // Walk the mib until the table-specific termination condition is met.

    while( 1 )
    {
        // Get next

        (*gQueryAddr)( GetNextReq, &VarBinds, &ErrorStatus, &ErrorIndex );

        if( verbose )
        {
            int   q;

            fprintf(stderr,"value=%8d oid= ", item.value.asnValue.number );

            //
            // Print the object name, use mgmtapi.dll.
            //

            if( pSnmpMgrOidToStr ){
                LPSTR String = NULL;
                int   err;
                err = (* pSnmpMgrOidToStr )( &item.name, &String );
                if( SNMPAPI_ERROR != err ){
                    fprintf(stderr," %s ", String );
                }
                SnmpUtilMemFree( String );
            }

            if( !pSnmpMgrOidToStr || (verbose > 1) ){

                //
                // Print the oid, in ``1.3.6.1.2.1'' style.
                //

                for ( q = 0; q < (int) item.name.idLength; q++ ){

                    // Must align the output to read huge tables.

                    if( q < 6 ){
                        fprintf( stderr,"%d.", item.name.ids[q]);
                    }else if( q < 9 ){
                        fprintf( stderr,"%2d.", item.name.ids[q]);
                    }else{
                        fprintf( stderr,"%3d.", item.name.ids[q]);
                    }
                }
            }
            fprintf(stderr,"\n");

        }


        if ( ErrorStatus != 0 )
        {
            SnmpUtilVarBindFree( &item );
            return ( ErrorStatus );
        }

        // We want to break out of this while loop if the defining part of the
        // OID changes

        if ( item.name.idLength < ( PreambleDef.Length + pOid->Length ) )
        {
            break;
        }

        for ( i = PreambleDef.Length;
              i < PreambleDef.Length + pOid->Length - pOid->BackOffset;
              i++ )
        {
            if ( item.name.ids[i] != pOid->Val[i - PreambleDef.Length] )
            {
                BreakLoop = TRUE;
                break;
            }
        }

        if ( BreakLoop )
        {
            break;
        }

        // We want to ignore certain entries.  EG: the TCP statistics will also
        // return the TCP connection table, which we don't want (there is a
        // separate Type code for that).

        switch ( Type )
        {
        case TYPE_IP:
            if ( ( item.name.ids[pOid->EntElemOffset] == ID_IP_ADDRTABLE ) ||
                 ( item.name.ids[pOid->EntElemOffset] == ID_IP_ROUTETABLE ) ||
                 ( item.name.ids[pOid->EntElemOffset] == ID_IP_ARPTABLE ) )
            {
                continue;
            }
            break;

        case TYPE_TCP:
            if ( item.name.ids[pOid->EntElemOffset] == ID_TCP_CONNTABLE )
            {
                continue;
            }
            break;

        case TYPE_UDP:
            if ( item.name.ids[pOid->EntElemOffset] == ID_UDP_CONNTABLE )
            {
                continue;
            }
            break;

        }

        // Entry handling:
        //
        // There are 3 cases to consider:
        // 1. If the list is empty, OR at the end of the list AND the
        //    CurrField == LastField.
        //   Then add a new entry to the list.
        // 2. CurrField != LastField.
        //   Then reset pointer to start of the list.
        // 3. Otherwise
        //   Then go to next entry in the list.

        if ( ( pTable == pList ) ||
             ( ( pTable->ListEntry.Flink == &pList->ListEntry ) &&
               ( item.name.ids[pOid->EntElemOffset] == LastField ) ) )
        {
            // Add new entry to table

            pTable = (GenericTable *)SNMP_malloc( Size );
            if ( pTable == NULL )
            {
                SnmpUtilVarBindFree( &item );
                return ( ERROR_NOT_ENOUGH_MEMORY );
            }

            InsertTailList( &pList->ListEntry, &pTable->ListEntry );
        }
        else if ( item.name.ids[pOid->EntElemOffset] != LastField )
        {
            // Reset pointer to start of list

            pTable = CONTAINING_RECORD( pList->ListEntry.Flink,
                                        GenericTable,
                                        ListEntry );
        }
        else
        {
            // Move pointer to next entry in list

            pTable = CONTAINING_RECORD( pTable->ListEntry.Flink,
                                        GenericTable,
                                        ListEntry );
        }

        LastField = item.name.ids[pOid->EntElemOffset];

        // Save info in our list.  pTable points to desired entry.

        switch ( Type )
        {
        case TYPE_IF:
            SaveData_IF( pTable, item, pOid );
            break;

        case TYPE_IP:
            SaveData_IP( pTable, item, pOid );
            break;

        case TYPE_IPADDR:
            SaveData_IPAddr( pTable, item, pOid );
            break;

        case TYPE_ROUTE:
            SaveData_ROUTE( pTable, item, pOid );
            break;

        case TYPE_ARP:
            SaveData_ARP( pTable, item, pOid );
            break;

        case TYPE_ICMP:
            SaveData_ICMP( pTable, item, pOid );
            break;

        case TYPE_TCP:
            SaveData_TCP( pTable, item, pOid );
            break;

        case TYPE_TCPCONN:
            SaveData_TCPCONN( pTable, item, pOid );
            break;

        case TYPE_UDP:
            SaveData_UDP( pTable, item, pOid );
            break;

        case TYPE_UDPCONN:
            SaveData_UDPCONN( pTable, item, pOid );
            break;

        }

        SnmpUtilOidCpy( &oidBackup, &(item.name));
        SnmpUtilVarBindFree( &item );
        item.name.idLength = oidBackup.idLength;
        item.name.ids = oidBackup.ids;
    }

    SnmpUtilVarBindFree( &item );

    return ( NO_ERROR );
}



//*****************************************************************************
//
// Name:        SaveData_IF
//
// Description: Saves an element of the data in the interface table.
//
// Parameters:  GenericTable *pEntry; pointer to table entry.
//              RFC1157VarBind item: contains value returned from mib.
//              OIDdef *pOid: contains table-specific data.
//
// Returns:     void.
//
// History:
//  01/12/94  JayPh     Created.
//
//*****************************************************************************

void SaveData_IF( GenericTable    *pEntry,
                  RFC1157VarBind   item,
                  OIDdef          *pOid )
{
    IfEntry  *pIf = ( IfEntry *)pEntry;
    uchar    *pTmp;
    ulong     i;

    switch ( item.name.ids[pOid->EntElemOffset] )
    {
    case ID_IF_INDEX:
        pIf->Info.if_index = item.value.asnValue.number;
        break;

    case ID_IF_DESC:
        pIf->Info.if_descrlen = item.value.asnValue.string.length;

        for ( i = 0; i < pIf->Info.if_descrlen; i++ )
        {
            pIf->Info.if_descr[i] = item.value.asnValue.string.stream[i];
        }
        break;

    case ID_IF_TYPE:
        pIf->Info.if_type = item.value.asnValue.number;
        break;

    case ID_IF_MTU:
        pIf->Info.if_mtu = item.value.asnValue.number;
        break;

    case ID_IF_SPEED:
        pIf->Info.if_speed = item.value.asnValue.number;
        break;

    case ID_IF_PHYSADDR:
        pIf->Info.if_physaddrlen = item.value.asnValue.string.length;

        for ( i = 0; i < pIf->Info.if_physaddrlen; i++ )
        {
            pIf->Info.if_physaddr[i] = item.value.asnValue.string.stream[i];
        }
        break;

    case ID_IF_ADMINSTATUS:
        pIf->Info.if_adminstatus = item.value.asnValue.number;
        break;

    case ID_IF_OPERSTATUS:
        pIf->Info.if_operstatus = item.value.asnValue.number;
        break;

    case ID_IF_LASTCHANGE:
        pIf->Info.if_lastchange = item.value.asnValue.number;
        break;

    case ID_IF_INOCTETS:
        pIf->Info.if_inoctets = item.value.asnValue.number;
        break;

    case ID_IF_INUCASTPKTS:
        pIf->Info.if_inucastpkts = item.value.asnValue.number;
        break;

    case ID_IF_INNUCASTPKTS:
        pIf->Info.if_innucastpkts = item.value.asnValue.number;
        break;

    case ID_IF_INDISCARDS:
        pIf->Info.if_indiscards = item.value.asnValue.number;
        break;

    case ID_IF_INERRORS:
        pIf->Info.if_inerrors = item.value.asnValue.number;
        break;

    case ID_IF_INUKNOWNPROTOS:
        pIf->Info.if_inunknownprotos = item.value.asnValue.number;
        break;

    case ID_IF_OUTOCTETS:
        pIf->Info.if_outoctets = item.value.asnValue.number;
        break;

    case ID_IF_OUTUCASTPKTS:
        pIf->Info.if_outucastpkts = item.value.asnValue.number;
        break;

    case ID_IF_OUTNUCASTPKTS:
        pIf->Info.if_outnucastpkts = item.value.asnValue.number;
        break;

    case ID_IF_OUTDISCARDS:
        pIf->Info.if_outdiscards = item.value.asnValue.number;
        break;

    case ID_IF_OUTERRORS:
        pIf->Info.if_outerrors = item.value.asnValue.number;
        break;

    case ID_IF_OUTQLEN:
        pIf->Info.if_outqlen = item.value.asnValue.number;
        break;

    }
}


//*****************************************************************************
//
// Name:        SaveData_IP
//
// Description: Saves an element of the data in the IP table.
//
// Parameters:  GenericTable *pEntry; pointer to table entry.
//              RFC1157VarBind item: contains value returned from mib.
//              OIDdef *pOid: contains table-specific data.
//
// Returns:     void.
//
// History:
//  01/12/94  JayPh     Created.
//
//*****************************************************************************

void SaveData_IP( GenericTable    *pEntry,
                  RFC1157VarBind   item,
                  OIDdef          *pOid )
{
    IpEntry  *pIp = (IpEntry *)pEntry;
    uchar    *pTmp;

    switch ( item.name.ids[pOid->EntElemOffset] )
    {
    case ID_IP_FORWARDING:
        pIp->Info.ipsi_forwarding = item.value.asnValue.number;
        break;

    case ID_IP_DEFAULTTTL:
        pIp->Info.ipsi_defaultttl = item.value.asnValue.number;
        break;

    case ID_IP_INRECEIVES:
        pIp->Info.ipsi_inreceives = item.value.asnValue.number;
        break;

    case ID_IP_INHDRERRORS:
        pIp->Info.ipsi_inhdrerrors = item.value.asnValue.number;
        break;

    case ID_IP_INADDRERRORS:
        pIp->Info.ipsi_inaddrerrors = item.value.asnValue.number;
        break;

    case ID_IP_FORWDATAGRAMS:
        pIp->Info.ipsi_forwdatagrams = item.value.asnValue.number;
        break;

    case ID_IP_INUNKNOWNPROTOS:
        pIp->Info.ipsi_inunknownprotos = item.value.asnValue.number;
        break;

    case ID_IP_INDISCARDS:
        pIp->Info.ipsi_indiscards = item.value.asnValue.number;
        break;

    case ID_IP_INDELIVERS:
        pIp->Info.ipsi_indelivers = item.value.asnValue.number;
        break;

    case ID_IP_OUTREQUESTS:
        pIp->Info.ipsi_outrequests = item.value.asnValue.number;
        break;

    case ID_IP_OUTDISCARDS:
        pIp->Info.ipsi_outdiscards = item.value.asnValue.number;
        break;

    case ID_IP_OUTNOROUTES:
        pIp->Info.ipsi_outnoroutes = item.value.asnValue.number;
        break;

    case ID_IP_REASMTIMEOUTS:
        pIp->Info.ipsi_reasmtimeout = item.value.asnValue.number;
        break;

    case ID_IP_REASMREQDS:
        pIp->Info.ipsi_reasmreqds = item.value.asnValue.number;
        break;

    case ID_IP_REASMOKS:
        pIp->Info.ipsi_reasmoks = item.value.asnValue.number;
        break;

    case ID_IP_REASMFAILS:
        pIp->Info.ipsi_reasmfails = item.value.asnValue.number;
        break;

    case ID_IP_FRAGOKS:
        pIp->Info.ipsi_fragoks = item.value.asnValue.number;
        break;

    case ID_IP_FRAGFAILS:
        pIp->Info.ipsi_fragfails = item.value.asnValue.number;
        break;

    case ID_IP_FRAGCREATES:
        pIp->Info.ipsi_fragcreates = item.value.asnValue.number;
        break;

    }
}


//*****************************************************************************
//
// Name:        SaveData_IPAddr
//
// Description: Saves an element of the data in the IP table.
//
// Parameters:  GenericTable *pEntry; pointer to table entry.
//              RFC1157VarBind item: contains value returned from mib.
//              OIDdef *pOid: contains table-specific data.
//
// Returns:     void.
//
// History:
//  01/12/94  JayPh     Created.
//
//*****************************************************************************

void SaveData_IPAddr( GenericTable    *pEntry,
                      RFC1157VarBind   item,
                      OIDdef          *pOid )
{
    IpAddrEntry  *pIpAddr = (IpAddrEntry *)pEntry;
    uchar        *pTmp;

    switch ( item.name.ids[pOid->EntElemOffset] )
    {
    case ID_IPADDR_ADDR:
        pTmp = (uchar *)&(pIpAddr->Info.iae_addr);
        pTmp[0] = item.value.asnValue.string.stream[0];
        pTmp[1] = item.value.asnValue.string.stream[1];
        pTmp[2] = item.value.asnValue.string.stream[2];
        pTmp[3] = item.value.asnValue.string.stream[3];
        break;

    case ID_IPADDR_INDEX:
        pIpAddr->Info.iae_index = item.value.asnValue.number;
        break;

    case ID_IPADDR_MASK:
        pTmp = (uchar *)&(pIpAddr->Info.iae_mask);
        pTmp[0] = item.value.asnValue.string.stream[0];
        pTmp[1] = item.value.asnValue.string.stream[1];
        pTmp[2] = item.value.asnValue.string.stream[2];
        pTmp[3] = item.value.asnValue.string.stream[3];
        break;

    case ID_IPADDR_BCASTADDR:
        pIpAddr->Info.iae_bcastaddr = item.value.asnValue.number;
        break;

    case ID_IPADDR_REASMSIZE:
        pIpAddr->Info.iae_reasmsize = item.value.asnValue.number;
        break;

    }
}


//*****************************************************************************
//
// Name:        SaveData_ROUTE
//
// Description: Saves an element of the data in the ROUTE table.
//
// Parameters:  GenericTable *pEntry; pointer to table entry.
//              RFC1157VarBind item: contains value returned from mib.
//              OIDdef *pOid: contains table-specific data.
//
// Returns:     void.
//
// History:
//  01/12/94  JayPh     Created.
//
//*****************************************************************************

void SaveData_ROUTE( GenericTable    *pEntry,
                     RFC1157VarBind   item,
                     OIDdef          *pOid )
{
    RouteEntry  *pRoute = (RouteEntry *)pEntry;
    uchar       *pTmp;

    switch ( item.name.ids[pOid->EntElemOffset] )
    {
    case ID_ROUTE_DEST:
        pTmp = (uchar *)&(pRoute->Info.ire_dest);
        pTmp[0] = item.value.asnValue.string.stream[0];
        pTmp[1] = item.value.asnValue.string.stream[1];
        pTmp[2] = item.value.asnValue.string.stream[2];
        pTmp[3] = item.value.asnValue.string.stream[3];
        break;

    case ID_ROUTE_IFINDEX:
        pRoute->Info.ire_index = item.value.asnValue.number;
        break;

    case ID_ROUTE_METRIC1:
        pRoute->Info.ire_metric1 = item.value.asnValue.number;
        break;

    case ID_ROUTE_METRIC2:
        pRoute->Info.ire_metric2 = item.value.asnValue.number;
        break;

    case ID_ROUTE_METRIC3:
        pRoute->Info.ire_metric3 = item.value.asnValue.number;
        break;

    case ID_ROUTE_METRIC4:
        pRoute->Info.ire_metric4 = item.value.asnValue.number;
        break;

    case ID_ROUTE_NEXTHOP:
        pTmp = (uchar *)&(pRoute->Info.ire_nexthop);
        pTmp[0] = item.value.asnValue.string.stream[0];
        pTmp[1] = item.value.asnValue.string.stream[1];
        pTmp[2] = item.value.asnValue.string.stream[2];
        pTmp[3] = item.value.asnValue.string.stream[3];
        break;

    case ID_ROUTE_TYPE:
        pRoute->Info.ire_type = item.value.asnValue.number;
        break;

    case ID_ROUTE_PROTO:
        pRoute->Info.ire_proto = item.value.asnValue.number;
        break;

    case ID_ROUTE_AGE:
        pRoute->Info.ire_age = item.value.asnValue.number;
        break;

    case ID_ROUTE_MASK:
        pTmp = (uchar *)&(pRoute->Info.ire_mask);
        pTmp[0] = item.value.asnValue.string.stream[0];
        pTmp[1] = item.value.asnValue.string.stream[1];
        pTmp[2] = item.value.asnValue.string.stream[2];
        pTmp[3] = item.value.asnValue.string.stream[3];
        break;

    case ID_ROUTE_METRIC5:
        pRoute->Info.ire_metric5 = item.value.asnValue.number;
        break;

    }
}


//*****************************************************************************
//
// Name:        SaveData_ARP
//
// Description: Saves an element of the data in the ARP table.
//
// Parameters:  GenericTable *pEntry; pointer to table entry.
//              RFC1157VarBind item: contains value returned from mib.
//              OIDdef *pOid: contains table-specific data.
//
// Returns:     void.
//
// History:
//  01/12/94  JayPh     Created.
//
//*****************************************************************************

void SaveData_ARP( GenericTable    *pEntry,
                   RFC1157VarBind   item,
                   OIDdef          *pOid )
{
    ArpEntry  *pArp = (ArpEntry *)pEntry;
    uchar     *pTmp;
    ulong      i;

    switch ( item.name.ids[pOid->EntElemOffset] )
    {
    case ID_ARP_IFINDEX:
        pArp->Info.inme_index = item.value.asnValue.number;
        break;

    case ID_ARP_PHYSADDR:
        pArp->Info.inme_physaddrlen = item.value.asnValue.string.length;

        for ( i = 0; i < pArp->Info.inme_physaddrlen; i++ )
        {
            pArp->Info.inme_physaddr[i] = item.value.asnValue.string.stream[i];
        }
        break;

    case ID_ARP_NETADDR:
        pTmp = (uchar *)&(pArp->Info.inme_addr);
        pTmp[0] = item.value.asnValue.string.stream[0];
        pTmp[1] = item.value.asnValue.string.stream[1];
        pTmp[2] = item.value.asnValue.string.stream[2];
        pTmp[3] = item.value.asnValue.string.stream[3];
        break;

    case ID_ARP_TYPE:
        pArp->Info.inme_type = item.value.asnValue.number;
        break;

    }
}


//*****************************************************************************
//
// Name:        SaveData_ICMP
//
// Description: Saves an element of the data in the ICMP table.
//
// Parameters:  GenericTable *pEntry; pointer to table entry.
//              RFC1157VarBind item: contains value returned from mib.
//              OIDdef *pOid: contains table-specific data.
//
// Returns:     void.
//
// History:
//  01/12/94  JayPh     Created.
//
//*****************************************************************************

void SaveData_ICMP( GenericTable    *pEntry,
                    RFC1157VarBind   item,
                    OIDdef          *pOid )
{
    IcmpEntry  *pIcmp = (IcmpEntry *)pEntry;
    uchar      *pTmp;

    switch ( item.name.ids[pOid->EntElemOffset] )
    {
    case ID_ICMP_INMSGS:
        pIcmp->InInfo.icmps_msgs = item.value.asnValue.number;
        break;

    case ID_ICMP_INERRORS:
        pIcmp->InInfo.icmps_errors = item.value.asnValue.number;
        break;

    case ID_ICMP_INDESTUNREACHES:
        pIcmp->InInfo.icmps_destunreachs = item.value.asnValue.number;
        break;

    case ID_ICMP_INTIMEEXCDS:
        pIcmp->InInfo.icmps_timeexcds = item.value.asnValue.number;
        break;

    case ID_ICMP_INPARMPROBS:
        pIcmp->InInfo.icmps_parmprobs = item.value.asnValue.number;
        break;

    case ID_ICMP_INSRCQUENCHS:
        pIcmp->InInfo.icmps_srcquenchs = item.value.asnValue.number;
        break;

    case ID_ICMP_INREDIRECTS:
        pIcmp->InInfo.icmps_redirects = item.value.asnValue.number;
        break;

    case ID_ICMP_INECHOS:
        pIcmp->InInfo.icmps_echos = item.value.asnValue.number;
        break;

    case ID_ICMP_INECHOREPS:
        pIcmp->InInfo.icmps_echoreps = item.value.asnValue.number;
        break;

    case ID_ICMP_INTIMESTAMPS:
        pIcmp->InInfo.icmps_timestamps = item.value.asnValue.number;
        break;

    case ID_ICMP_INTIMESTAMPREPS:
        pIcmp->InInfo.icmps_timestampreps = item.value.asnValue.number;
        break;

    case ID_ICMP_INADDRMASKS:
        pIcmp->InInfo.icmps_addrmasks = item.value.asnValue.number;
        break;

    case ID_ICMP_INADDRMASKREPS:
        pIcmp->InInfo.icmps_addrmaskreps = item.value.asnValue.number;
        break;

    case ID_ICMP_OUTMSGS:
        pIcmp->OutInfo.icmps_msgs = item.value.asnValue.number;
        break;

    case ID_ICMP_OUTERRORS:
        pIcmp->OutInfo.icmps_errors = item.value.asnValue.number;
        break;

    case ID_ICMP_OUTDESTUNREACHES:
        pIcmp->OutInfo.icmps_destunreachs = item.value.asnValue.number;
        break;

    case ID_ICMP_OUTTIMEEXCDS:
        pIcmp->OutInfo.icmps_timeexcds = item.value.asnValue.number;
        break;

    case ID_ICMP_OUTPARMPROBS:
        pIcmp->OutInfo.icmps_parmprobs = item.value.asnValue.number;
        break;

    case ID_ICMP_OUTSRCQUENCHS:
        pIcmp->OutInfo.icmps_srcquenchs = item.value.asnValue.number;
        break;

    case ID_ICMP_OUTREDIRECTS:
        pIcmp->OutInfo.icmps_redirects = item.value.asnValue.number;
        break;

    case ID_ICMP_OUTECHOS:
        pIcmp->OutInfo.icmps_echos = item.value.asnValue.number;
        break;

    case ID_ICMP_OUTECHOREPS:
        pIcmp->OutInfo.icmps_echoreps = item.value.asnValue.number;
        break;

    case ID_ICMP_OUTTIMESTAMPS:
        pIcmp->OutInfo.icmps_timestamps = item.value.asnValue.number;
        break;

    case ID_ICMP_OUTTIMESTAMPREPS:
        pIcmp->OutInfo.icmps_timestampreps = item.value.asnValue.number;
        break;

    case ID_ICMP_OUTADDRMASKS:
        pIcmp->OutInfo.icmps_addrmasks = item.value.asnValue.number;
        break;

    case ID_ICMP_OUTADDRMASKREPS:
        pIcmp->OutInfo.icmps_addrmaskreps = item.value.asnValue.number;
        break;

    }
}


//*****************************************************************************
//
// Name:        SaveData_TCP
//
// Description: Saves an element of the data in the TCP table.
//
// Parameters:  GenericTable *pEntry; pointer to table entry.
//              RFC1157VarBind item: contains value returned from mib.
//              OIDdef *pOid: contains table-specific data.
//
// Returns:     void.
//
// History:
//  01/12/94  JayPh     Created.
//
//*****************************************************************************

void SaveData_TCP( GenericTable    *pEntry,
                   RFC1157VarBind   item,
                   OIDdef          *pOid )
{
    TcpEntry  *pTcp = (TcpEntry *)pEntry;
    uchar     *pTmp;

    switch ( item.name.ids[pOid->EntElemOffset] )
    {
    case ID_TCP_RTOALGORITHM:
        pTcp->Info.ts_rtoalgorithm = item.value.asnValue.number;
        break;

    case ID_TCP_RTOMIN:
        pTcp->Info.ts_rtomin = item.value.asnValue.number;
        break;

    case ID_TCP_RTOMAX:
        pTcp->Info.ts_rtomax = item.value.asnValue.number;
        break;

    case ID_TCP_MAXCONN:
        pTcp->Info.ts_maxconn = item.value.asnValue.number;
        break;

    case ID_TCP_ACTIVEOPENS:
        pTcp->Info.ts_activeopens = item.value.asnValue.number;
        break;

    case ID_TCP_PASSIVEOPENS:
        pTcp->Info.ts_passiveopens = item.value.asnValue.number;
        break;

    case ID_TCP_ATTEMPTFAILS:
        pTcp->Info.ts_attemptfails = item.value.asnValue.number;
        break;

    case ID_TCP_ESTABRESETS:
        pTcp->Info.ts_estabresets = item.value.asnValue.number;
        break;

    case ID_TCP_CURRESTABS:
        pTcp->Info.ts_currestab = item.value.asnValue.number;
        break;

    case ID_TCP_INSEGS:
        pTcp->Info.ts_insegs = item.value.asnValue.number;
        break;

    case ID_TCP_OUTSEGS:
        pTcp->Info.ts_outsegs = item.value.asnValue.number;
        break;

    case ID_TCP_RETRANSSEGS:
        pTcp->Info.ts_retranssegs = item.value.asnValue.number;
        break;

    case ID_TCP_INERRS:
        pTcp->Info.ts_inerrs = item.value.asnValue.number;
        break;

    case ID_TCP_OUTRSTS:
        pTcp->Info.ts_outrsts = item.value.asnValue.number;
        break;

    }
}


//*****************************************************************************
//
// Name:        SaveData_TCPCONN
//
// Description: Saves an element of the data in the TCP connection table.
//
// Parameters:  GenericTable *pEntry; pointer to table entry.
//              RFC1157VarBind item: contains value returned from mib.
//              OIDdef *pOid: contains table-specific data.
//
// Returns:     void.
//
// History:
//  01/12/94  JayPh     Created.
//
//*****************************************************************************

void SaveData_TCPCONN( GenericTable    *pEntry,
                       RFC1157VarBind   item,
                       OIDdef          *pOid )
{
    TcpConnEntry  *pTcp = (TcpConnEntry *)pEntry;
    uchar         *pTmp;

    switch ( item.name.ids[pOid->EntElemOffset] )
    {
    case ID_TCPCONN_STATE:
        pTcp->Info.tct_state = item.value.asnValue.number;
        break;

    case ID_TCPCONN_LOCALADDR:
        pTmp = (uchar *)&(pTcp->Info.tct_localaddr);
        pTmp[0] = item.value.asnValue.string.stream[0];
        pTmp[1] = item.value.asnValue.string.stream[1];
        pTmp[2] = item.value.asnValue.string.stream[2];
        pTmp[3] = item.value.asnValue.string.stream[3];
        break;

    case ID_TCPCONN_LOCALPORT:
        pTcp->Info.tct_localport = item.value.asnValue.number;
        break;

    case ID_TCPCONN_REMOTEADDR:
        pTmp = (uchar *)&(pTcp->Info.tct_remoteaddr);
        pTmp[0] = item.value.asnValue.string.stream[0];
        pTmp[1] = item.value.asnValue.string.stream[1];
        pTmp[2] = item.value.asnValue.string.stream[2];
        pTmp[3] = item.value.asnValue.string.stream[3];
        break;

    case ID_TCPCONN_REMOTEPORT:
        pTcp->Info.tct_remoteport = item.value.asnValue.number;
        break;

    }
}


//*****************************************************************************
//
// Name:        SaveData_UDP
//
// Description: Saves an element of the data in the UDP table.
//
// Parameters:  GenericTable *pEntry; pointer to table entry.
//              RFC1157VarBind item: contains value returned from mib.
//              OIDdef *pOid: contains table-specific data.
//
// Returns:     void.
//
// History:
//  01/12/94  JayPh     Created.
//
//*****************************************************************************

void SaveData_UDP( GenericTable    *pEntry,
                   RFC1157VarBind   item,
                   OIDdef          *pOid )
{
    UdpEntry  *pUdp = (UdpEntry *)pEntry;
    uchar     *pTmp;

    switch ( item.name.ids[pOid->EntElemOffset] )
    {
    case ID_UDP_INDATAGRAMS:
        pUdp->Info.us_indatagrams = item.value.asnValue.number;
        break;

    case ID_UDP_NOPORTS:
        pUdp->Info.us_noports = item.value.asnValue.number;
        break;

    case ID_UDP_INERRORS:
        pUdp->Info.us_inerrors = item.value.asnValue.number;
        break;

    case ID_UDP_OUTDATAGRAMS:
        pUdp->Info.us_outdatagrams = item.value.asnValue.number;
        break;

    }
}


//*****************************************************************************
//
// Name:        SaveData_UDPCONN
//
// Description: Saves an element of the data in the UDP connection table.
//
// Parameters:  GenericTable *pEntry; pointer to table entry.
//              RFC1157VarBind item: contains value returned from mib.
//              OIDdef *pOid: contains table-specific data.
//
// Returns:     void.
//
// History:
//  01/12/94  JayPh     Created.
//
//*****************************************************************************

void SaveData_UDPCONN( GenericTable    *pEntry,
                       RFC1157VarBind   item,
                       OIDdef          *pOid )
{
    UdpConnEntry  *pUdp = (UdpConnEntry *)pEntry;
    uchar         *pTmp;

    switch ( item.name.ids[pOid->EntElemOffset] )
    {
    case ID_UDPCONN_LOCALADDR:
        pTmp = (uchar *)&(pUdp->Info.ue_localaddr);
        pTmp[0] = item.value.asnValue.string.stream[0];
        pTmp[1] = item.value.asnValue.string.stream[1];
        pTmp[2] = item.value.asnValue.string.stream[2];
        pTmp[3] = item.value.asnValue.string.stream[3];
        break;

    case ID_UDPCONN_LOCALPORT:
        pUdp->Info.ue_localport = item.value.asnValue.number;
        break;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\snmputil.h ===
//*****************************************************************************
//
// Name:	snmputil.h
//
// Description:	
//
// History:
//  01/13/94  smanda	Created.
//  Copied from \sdnt\net\tcpip\commands\common2\common2.h
//
//*****************************************************************************

//*****************************************************************************
//
// Copyright (c) 1994 by Microsoft Corp.  All rights reserved.
//
//*****************************************************************************

#ifndef __SNMPUTIL_H__
#define __SNMPUTIL_H__

//
// Include Files
//

#include "ipexport.h"
#include "ipinfo.h"
#include "llinfo.h"
#include "tcpinfo.h"


//
// Definitions
//

#define MAX_ID_LENGTH		50

// Table Types

#define TYPE_IF		0
#define TYPE_IP		1
#define TYPE_IPADDR	2
#define TYPE_ROUTE	3
#define TYPE_ARP	4
#define TYPE_ICMP	5
#define TYPE_TCP	6
#define TYPE_TCPCONN	7
#define TYPE_UDP	8
#define TYPE_UDPCONN	9


//
// Structure Definitions
//

typedef struct _GenericTable {
    LIST_ENTRY  ListEntry;
} GenericTable;

typedef struct _IfEntry {
    LIST_ENTRY  ListEntry;
    IFEntry     Info;
} IfEntry;

typedef struct _IpEntry {
    LIST_ENTRY  ListEntry;
    IPSNMPInfo  Info;
} IpEntry;

typedef struct _IpAddrEntry {
    LIST_ENTRY   ListEntry;
    IPAddrEntry  Info;
} IpAddrEntry;

typedef struct _RouteEntry {
    LIST_ENTRY    ListEntry;
    IPRouteEntry  Info;
} RouteEntry;

typedef struct _ArpEntry {
    LIST_ENTRY         ListEntry;
    IPNetToMediaEntry  Info;
} ArpEntry;

typedef struct _IcmpEntry {
    LIST_ENTRY  ListEntry;
    ICMPStats   InInfo;
    ICMPStats   OutInfo;
} IcmpEntry;

typedef struct _TcpEntry {
    LIST_ENTRY  ListEntry;
    TCPStats    Info;
} TcpEntry;

typedef struct _TcpConnEntry {
    LIST_ENTRY         ListEntry;
    TCPConnTableEntry  Info;
} TcpConnEntry;

typedef struct _UdpEntry {
    LIST_ENTRY  ListEntry;
    UDPStats    Info;
} UdpEntry;

typedef struct _UdpConnEntry {
    LIST_ENTRY  ListEntry;
    UDPEntry    Info;
} UdpConnEntry;


//
// Function Prototypes
//

ulong InitSnmp( void );
void *GetTable( ulong Type, ulong *pResult );
void FreeTable( GenericTable *pList );
ulong ReadTable( GenericTable *pList, ulong Type, ulong Size );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\strings.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       strings.c
//
//--------------------------------------------------------------------------

#include "precomp.h"

#include "strings.h"
#define _STRINGS_DEFINE_STRINGS
#include "strings.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\wantest.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      wantest.c
//
//  Abstract:
//
//      Queries into network drivers
//
//  Author:
//
//      Anilth	- 4-20-1998 
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//--
#include "precomp.h"
#undef IsEqualGUID
#include <ras.h>
#include <tapi.h>
#include <unimodem.h>


//$REVIEW (nsun) is this reasonable
#define MAX_RASCONN  100


BOOL
WANTest(NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
// Description:
// This routine tests the WAN/TAPI configurations
//
//
// Author:
//  NSun
//
{
 HRESULT    hr = S_OK;
 DWORD dwReturn;
 DWORD dwByteCount;
 RASCONN pRasConn[MAX_RASCONN];
 RASENTRY RasEntry;
 DWORD    dwEntryInfoSize;
 RAS_STATS RasStats;

 DWORD   dwNumConnections;
 DWORD   i;


 PrintStatusMessage( pParams, 4, IDS_WAN_STATUS_MSG );

 InitializeListHead( &pResults->Wan.lmsgOutput );

 dwByteCount  = sizeof(RASCONN) * MAX_RASCONN;

 //
 // dwSize identifies the version of the structure being passed
 //

 pRasConn[0].dwSize = sizeof(RASCONN);

 dwReturn = RasEnumConnections(pRasConn,
                          &dwByteCount,
                          &dwNumConnections);


 if (dwReturn != 0) {
//IDS_WAN_15001                  "RasEnumConnections failed\n" 
  AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Quiet, IDS_WAN_15001);
  hr = S_FALSE;
  goto LERROR;
 }
     

 if (dwNumConnections == 0) {
//IDS_WAN_15002                  "No active remote access connections.\n" 
    AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15002);
	goto LERROR;
 }

 pResults->Wan.fPerformed = TRUE;

 for ( i = 0; i < dwNumConnections; i++) 
 {
  
     //IDS_WAN_15003                  "Entry Name: " 
     AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15003);

     if  (pRasConn[i].szEntryName[0] == '.') 
     {
         //IDS_WAN_15004                  "N/A, phone number %s\n" 
         AddMessageToList( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15004, pRasConn[i].szEntryName+1); // skip the dot
        
         //IDS_WAN_15005                  "The following is default entry properties.\n" 
         AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15005);
		 pRasConn[i].szEntryName[0] = 0;
      }
     else
        //IDS_WAN_15006                  "%s\n" 
        AddMessageToList( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15006, pRasConn[i].szEntryName);


   RasEntry.dwSize = sizeof(RasEntry);

   dwEntryInfoSize = sizeof(RasEntry);

   dwReturn =  RasGetEntryProperties(NULL,
                                     pRasConn[i].szEntryName,
                                     &RasEntry,
                                     &dwEntryInfoSize,
                                     NULL,
                                     NULL);

   if (dwReturn != 0) {
	 //IDS_WAN_15056		"RasGetEntryProperties for %s failed. [%s]\n"
     AddMessageToList( &pResults->Wan.lmsgOutput, Nd_Quiet, IDS_WAN_15056, 
						 pRasConn[i].szEntryName, NetStatusToString(dwReturn));
     hr = S_FALSE;
     continue;
   }                                                                           

   //
   // dump the connection properties
   //

   // print the device type

   //IDS_WAN_15008                  "Device Type: " 
   AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15008);

   //$ REVIEW
   // Why are there '\n''s at the end of the names?

   if (!_tcscmp(RasEntry.szDeviceType,_T("RASDT_Modem\n")))
   {
	   // IDS_WAN_15009 "Modem\n" 
	   AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose,
						   IDS_WAN_15009);
   }
   else if (!_tcscmp(RasEntry.szDeviceType,_T("RASDT_Isdn\n")))
   {
	   // IDS_WAN_15010 "ISDN card\n" 
      AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose,
						  IDS_WAN_15010);
   }
   else if (!_tcscmp(RasEntry.szDeviceType,_T("RASDT_X25\n")))
   {
        //IDS_WAN_15011 "X25 card\n" 
      AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose,
						  IDS_WAN_15011);
   }
   else if (!_tcscmp(RasEntry.szDeviceType,_T("RASDT_Vpn\n")))
   {
        //IDS_WAN_15012                  "Virtual Private Network\n" 
      AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose,
						  IDS_WAN_15012);
   }
   else if (!_tcscmp(RasEntry.szDeviceType,_T("RASDT_PAD")))
   {
        //IDS_WAN_15013                  "Packet Assembler / Dissasembler\n" 
      AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose,
						  IDS_WAN_15013);
   }


   //
   // Framing protocol in use
   //

//IDS_WAN_15014                  "Framing protocol : " 
   AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15014);
   if (RasEntry.dwFramingProtocol & RASFP_Ppp) 
//IDS_WAN_15015                  " PPP\n" 
       AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15015);
   else
   if (RasEntry.dwFramingProtocol & RASFP_Slip)
//IDS_WAN_15016                  " Slip\n" 
       AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15016);
   else
   if (RasEntry.dwFramingProtocol & RASFP_Ras)
//IDS_WAN_15017                  " MS Proprietary protocol\n" 
       AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15017);
  


   //
   // PPP and LCP Settings
   //
 
   if (RasEntry.dwFramingProtocol & RASFP_Ppp) {

        //IDS_WAN_15018                  "LCP Extensions : " 
       AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15018);
       if (RasEntry.dwfOptions & RASEO_DisableLcpExtensions)
            //IDS_WAN_DISABLED                  " Disabled\n" 
           AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_DISABLED);
       else
            //IDS_WAN_ENABLED                  " Enabled\n" 
           AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_ENABLED);

        //IDS_WAN_15021                  "Software Compression : " 
       AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15021);
       if (RasEntry.dwfOptions & RASEO_SwCompression) 
            //IDS_WAN_ENABLED                  " Enabled\n" 
          AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_ENABLED);
       else
            //IDS_WAN_DISABLED                  " Disabled\n" 
          AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_DISABLED);

   }

   //
   // Network protocols in use and options
   // 

    //IDS_WAN_15024                  "Network protocols :\n " 
   AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15024);
   if (RasEntry.dwfNetProtocols & RASNP_NetBEUI) 
        //IDS_WAN_15025                  "     NetBEUI\n" 
       AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15025); 
   if (RasEntry.dwfNetProtocols & RASNP_Ipx) 
        //IDS_WAN_15026                  "     IPX\n" 
       AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15026);
   if (RasEntry.dwfNetProtocols & RASNP_Ip)
//IDS_WAN_15027                  "     TCP/IP\n" 
       AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15027); 

   //
   // TCP/IP options
   //


   if (RasEntry.dwfNetProtocols & RASNP_Ip) {

    //IDS_WAN_15028                  "IP Address :  " 
   AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15028);
   if (RasEntry.dwfOptions & RASEO_SpecificIpAddr)
        //IDS_WAN_15029                  "Specified\n" 
       AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15029);
   else
        //IDS_WAN_15030                  "Server Assigned\n" 
       AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15030);

    //IDS_WAN_15031                  "Name Server: " 
   AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15031);
   if (RasEntry.dwfOptions & RASEO_SpecificNameServers)
        //IDS_WAN_15032                  "Specified\n" 
       AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15032);
   else
        //IDS_WAN_15033                  "Server Assigned\n" 
       AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15033);

   // IP hdr compression makes sense only if we use PPP

   if (RasEntry.dwFramingProtocol & RASFP_Ppp) {

        //IDS_WAN_15034                  "IP Header compression : " 
     AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15034);
     if (RasEntry.dwfOptions & RASEO_IpHeaderCompression)
            //IDS_WAN_15035                  " Enabled\n" 
         AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15035);
     else
        //IDS_WAN_15036                  " Disabled\n" 
         AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15036); 
     }

    //IDS_WAN_15037                  "Use default gateway on remote network : " 
   AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15037);
   if (RasEntry.dwfOptions & RASEO_RemoteDefaultGateway) 
        //IDS_WAN_15038                  "Enabled\n" 
       AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15038);
   else
//IDS_WAN_15039                  "Disabled\n" 
       AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15039); 

   }

   //
   // Collect statistics regarding this connection
   //

   RasStats.dwSize = sizeof(RAS_STATS); // pass version information

   dwReturn = RasGetConnectionStatistics(
                                 pRasConn[i].hrasconn,
                                 &RasStats);

   if (dwReturn != 0) {
        //IDS_WAN_15040                  "    RasGetConnectionStatistics for %s failed. [%s]\n" 
       AddMessageToList( &pResults->Wan.lmsgOutput, Nd_Quiet, IDS_WAN_15040,
						   pRasConn[i].szEntryName, NetStatusToString(dwReturn) ); 
       hr = S_FALSE;
       continue;
   }
  
    //IDS_WAN_15041                  "\n\tConnection Statistics:\n" 
   AddMessageToListId( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15041); 

    //IDS_WAN_15042                  "\tBytes Transmitted     : %d\n" 
   AddMessageToList( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15042, RasStats.dwBytesXmited);
    //IDS_WAN_15043                  "\tBytes Received        : %d\n" 
   AddMessageToList( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15043,RasStats.dwBytesRcved);
    //IDS_WAN_15044                  "\tFrames Transmitted    : %d\n" 
   AddMessageToList( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15044,RasStats.dwFramesXmited);
    //IDS_WAN_15045                  "\tFrames Received       : %d\n" 
   AddMessageToList( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15045,RasStats.dwFramesRcved);
    //IDS_WAN_15046                  "\tCRC    Errors         : %d\n" 
   AddMessageToList( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15046,RasStats.dwFramesRcved);
    //IDS_WAN_15047                  "\tTimeout Errors        : %d\n" 
   AddMessageToList( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15047,RasStats.dwTimeoutErr);
    //IDS_WAN_15048                  "\tAlignment Errors      : %d\n" 
   AddMessageToList( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15048,RasStats.dwAlignmentErr);
    //IDS_WAN_15049                  "\tH/W Overrun Errors    : %d\n" 
   AddMessageToList( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15049,RasStats.dwHardwareOverrunErr);
    //IDS_WAN_15050                  "\tFraming Errors        : %d\n" 
   AddMessageToList( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15050,RasStats.dwFramingErr);
    //IDS_WAN_15051                  "\tBuffer Overrun Errors : %d\n" 
   AddMessageToList( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15051,RasStats.dwBufferOverrunErr);
    //IDS_WAN_15052                  "\tCompression Ratio In  : %d\n" 
   AddMessageToList( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15052,RasStats.dwCompressionRatioIn);
    //IDS_WAN_15053                  "\tCompression Ratio Out : %d\n" 
   AddMessageToList( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15053,RasStats.dwCompressionRatioOut);
    //IDS_WAN_15054                  "\tBaud Rate ( Bps )     : %d\n" 
   AddMessageToList( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15054,RasStats.dwBps);
    //IDS_WAN_15055                  "\tConnection Duration   : %d\n" 
   AddMessageToList( &pResults->Wan.lmsgOutput, Nd_Verbose, IDS_WAN_15055,RasStats.dwConnectDuration);
  

 } // end of for loop

LERROR:
 pResults->Wan.hr = hr;
 return hr;
}



void WANGlobalPrint(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults)
{
	if (pParams->fVerbose)
	{
		PrintNewLine(pParams, 2);
		PrintTestTitleResult(pParams,
							 IDS_WAN_LONG,
							 IDS_WAN_SHORT,
							 pResults->Wan.fPerformed,
							 pResults->Wan.hr,
							 0);
	}
	
    PrintMessageList(pParams, &pResults->Wan.lmsgOutput);
}

void WANPerInterfacePrint(NETDIAG_PARAMS *pParams, NETDIAG_RESULT *pResults, INTERFACE_RESULT *pInterfaceResults)
{
    //Not a PerInterface test
}

void WANCleanup(IN NETDIAG_PARAMS *pParams, IN OUT NETDIAG_RESULT *pResults)
{
    MessageListCleanUp(&pResults->Wan.lmsgOutput);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\tfschar.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       tfschar.c
//
//--------------------------------------------------------------------------


#include "precomp.h"

#include <malloc.h>

/*!--------------------------------------------------------------------------
	StrCpyAFromW
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(LPSTR)	StrCpyAFromW(LPSTR psz, LPCWSTR pswz)
{
	USES_CONVERSION;
	return StrCpyA(psz, W2CA(pswz));
}

/*!--------------------------------------------------------------------------
	StrCpyWFromA
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(LPWSTR)	StrCpyWFromA(LPWSTR pswz, LPCSTR psz)
{
	USES_CONVERSION;
	return StrCpyW(pswz, A2CW(psz));
}

/*!--------------------------------------------------------------------------
	StrnCpyAFromW
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(LPSTR)	StrnCpyAFromW(LPSTR psz, LPCWSTR pswz, int iMax)
{
	USES_CONVERSION;
	return StrnCpyA(psz, W2CA(pswz), iMax);
}

/*!--------------------------------------------------------------------------
	StrnCpyWFromA
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(LPWSTR)	StrnCpyWFromA(LPWSTR pswz, LPCSTR psz, int iMax)
{
	USES_CONVERSION;
	return StrnCpyW(pswz, A2CW(psz), iMax);
}

/*!--------------------------------------------------------------------------
	StrDupA
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(LPSTR)	StrDupA( LPCSTR psz )
{
    if (psz)
    {
	   // Multiply by 2 to account for DBCS strings
   	   LPSTR	pszcpy = Malloc(sizeof(char)*CbStrLenA(psz)*2);
       if (pszcpy)
	      return StrCpyA(pszcpy, psz);
    }
    return NULL;
}

/*!--------------------------------------------------------------------------
	StrDupW
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(LPWSTR)	StrDupW( LPCWSTR pswz )
{
    if (pswz)
    {
	   LPWSTR	pswzcpy = Malloc(sizeof(WCHAR)*CbStrLenW(pswz));
       if (pswzcpy)
	      return StrCpyW(pswzcpy, pswz);
    }
    return NULL;
}


/*!--------------------------------------------------------------------------
	StrDupAFromW
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(LPSTR)	StrDupAFromW( LPCWSTR pwsz )
{
	USES_CONVERSION;
	return StrDupA( W2CA(pwsz) );
}

/*!--------------------------------------------------------------------------
	StrDupWFromA
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(LPWSTR)	StrDupWFromA( LPCSTR psz )
{
	USES_CONVERSION;
	return StrDupW( A2CW(psz) );
}



/*!--------------------------------------------------------------------------
	StrnCmpA
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(int) StrnCmpA(LPCSTR psz1, LPCSTR psz2, int nLen)
{
	USES_CONVERSION;
	// It's easier to convert it to a wide string than do the
	// conversion.  (it's a pain having to deal with DBCS characters).
	return StrnCmpW(A2CW(psz1), A2CW(psz2), nLen);
}


/*!--------------------------------------------------------------------------
	StrnCmpW
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(int) StrnCmpW(LPCWSTR pswz1, LPCWSTR pswz2, int nLen)
{   
	WCHAR *pswz1Temp = AllocaStrDupW(pswz1);        // These memory allocs get memory on the stack, so we do not need to free them
	WCHAR *pswz2Temp = AllocaStrDupW(pswz2);


    // The next three if statements could be replaced with: if( !pswz1Temp || !pswz2Temp) return StrCmpW(pswz1Temp, pswz2Temp);
    // since lstrcmp can handle NULL parameters. But if we do this prefix gets mad.
    //
    if( pswz1Temp == NULL && pswz2Temp == NULL )
    {
        // They are equal both NULL
        //
        return 0;
    }

    if( pswz1Temp == NULL)
    {
        // The first one is NULL thus the second string is greater
        //
        return -1;
    }

    if( pswz2Temp == NULL )
    {
        // The second one is NULL thus the first one is bigger
        //
        return 1;
    }
        
    if (pswz1Temp != NULL && StrLenW(pswz1Temp) > nLen)
       pswz1Temp[nLen] = 0;
	if (pswz2Temp != NULL && StrLenW(pswz2Temp) > nLen)
	   pswz2Temp[nLen] = 0;
	
    
    return StrCmpW(pswz1Temp, pswz2Temp);
}


/*!--------------------------------------------------------------------------
	StrniCmpA
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(int) StrniCmpA(LPCSTR psz1, LPCSTR psz2, int nLen)
{
	CHAR *psz1Temp = AllocaStrDupA(psz1);
	CHAR *psz2Temp = AllocaStrDupA(psz2);

	CharUpperBuffA(psz1Temp, StrLenA(psz1Temp));
	CharUpperBuffA(psz2Temp, StrLenA(psz2Temp));

	return StrnCmpA(psz1Temp, psz2Temp, nLen);
}


/*!--------------------------------------------------------------------------
	StrniCmpW
		-
	Author: KennT
 ---------------------------------------------------------------------------*/
TFSCORE_API(int) StrniCmpW(LPCWSTR pswz1, LPCWSTR pswz2, int nLen)
{
	WCHAR *pswz1Temp = AllocaStrDupW(pswz1);
	WCHAR *pswz2Temp = AllocaStrDupW(pswz2);

	CharUpperBuffW(pswz1Temp, StrLenW(pswz1Temp));
	CharUpperBuffW(pswz2Temp, StrLenW(pswz2Temp));

	return StrnCmpW(pswz1Temp, pswz2Temp, nLen);
}

/////////////////////////////////////////////////////////////////////////////
// Global UNICODE<>ANSI translation helpers

LPWSTR WINAPI AtlA2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars)
{
	assert(lpa != NULL);
	assert(lpw != NULL);
	// verify that no illegal character present
	// since lpw was allocated based on the size of lpa
	// don't worry about the number of chars
	lpw[0] = '\0';
	MultiByteToWideChar(CP_ACP, 0, lpa, -1, lpw, nChars);
	return lpw;
}

LPSTR WINAPI AtlW2AHelper(LPSTR lpa, LPCWSTR lpw, int nChars)
{
	assert(lpw != NULL);
	assert(lpa != NULL);
	// verify that no illegal character present
	// since lpa was allocated based on the size of lpw
	// don't worry about the number of chars
	lpa[0] = '\0';
	WideCharToMultiByte(CP_ACP, 0, lpw, -1, lpa, nChars, NULL, NULL);
	return lpa;
}

LPTSTR LoadAndAllocString(UINT ids)
{
	TCHAR	* psz = NULL;
	TCHAR	* pszT = NULL;
	INT	cch = 0;
	int		iRet;

	cch = 64;
	psz = Malloc(64*sizeof(TCHAR));
	if (psz == NULL)
		return NULL;
					
	iRet = LoadString(NULL, ids, psz, cch);

	if (iRet == 0)
    {
		// couldn't find the string
        Free(psz);
		return NULL;
    }

	while (iRet >= (cch - 1))
	{
		cch += 64;
		pszT = Realloc(psz, (cch*sizeof(TCHAR)));
		if (pszT == NULL)
		{
			Free(psz);
			return NULL;
		}
		psz = pszT;

		iRet = LoadString(NULL, ids, psz, cch);
	}
	
	return psz;
}

LPTSTR GetSafeString(LPTSTR psz)
{
	static LPTSTR s_szEmpty = _T("");
	return psz ? psz : s_szEmpty;
}

LPWSTR GetSafeStringW(LPWSTR pwsz)
{
	static LPWSTR s_wszEmpty = L"";
	return pwsz ? pwsz : s_wszEmpty;
}

LPSTR GetSafeStringA(LPSTR pasz)
{
	static LPSTR s_aszEmpty = "";
	return pasz ? pasz : s_aszEmpty;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\trust.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      trust.c
//
//  Abstract:
//
//      Queries into network drivers
//
//  Author:
//
//      Anilth  - 4-20-1998 
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//--

#include "precomp.h"





BOOL DomainSidRight(    IN PTESTED_DOMAIN TestedDomain,
     NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults
 );


HRESULT TrustTest( NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
{
    HRESULT hr = S_OK;

    PTESTED_DOMAIN Context = pParams->pDomain;

    NET_API_STATUS NetStatus;
    
    PNETLOGON_INFO_2 NetlogonInfo2 = NULL;

    NET_API_STATUS  TrustedNetStatus = 0;
    LPWSTR TrustedDomainList = NULL;
    PTESTED_DOMAIN TestedDomain = pResults->Global.pMemberDomain;
    PLIST_ENTRY ListEntry;
    LPBYTE InputDataPtr;
    int             i;

    // validDC is the count of valid Domain Controllers with which secure channel can be set.
    int validDC = 0;
        

    InitializeListHead(&pResults->Trust.lmsgOutput);

    PrintStatusMessage(pParams, 4, IDS_TRUST_STATUS_MSG);
    
    //
    // Only Members and BDCs have trust relationships to their primary domain
    //

    if (!
        (pResults->Global.pPrimaryDomainInfo->MachineRole == DsRole_RoleMemberWorkstation ||
        pResults->Global.pPrimaryDomainInfo->MachineRole == DsRole_RoleMemberServer ||
        pResults->Global.pPrimaryDomainInfo->MachineRole == DsRole_RoleBackupDomainController )
        )
    {
        PrintStatusMessage(pParams, 0, IDS_GLOBAL_SKIP_NL);     
        return hr;  // not to test standalone
    }

    pResults->Trust.fPerformed = TRUE;
    //
    // Check to see that the domain Sid of the primary domain is right.
    //

    if ( !DomainSidRight( pResults->Global.pMemberDomain, pParams, pResults ) ) {
        hr = S_FALSE;
        goto L_ERR;
    }

    //
    // Use the secure channel
    //
    // If some other caller did this in the recent past,
    //  this doesn't even use the secure channel.
    //
    // On a BDC, this doesn't use the secure channel.
    //

    TrustedNetStatus = NetEnumerateTrustedDomains( NULL, &TrustedDomainList );
    if ( TrustedNetStatus != NO_ERROR ) {
        AddIMessageToList(&pResults->Trust.lmsgOutput, Nd_Quiet, 0,
                          IDS_TRUST_FAILED_LISTDOMAINS, 
                          pResults->Global.pPrimaryDomainInfo->DomainNameFlat,
                          NetStatusToString(TrustedNetStatus));
    }

    // Don't complain yet since the real secure channel status is more
    // important to the user.

    //
    // Check the current status of the secure channel.
    //  (This may still be cached and out of date.)
    //

    InputDataPtr = (LPBYTE)(pResults->Global.pPrimaryDomainInfo->DomainNameDns ? 
                                    pResults->Global.pPrimaryDomainInfo->DomainNameDns :
                                    pResults->Global.pPrimaryDomainInfo->DomainNameFlat);

    NetStatus = I_NetLogonControl2(
                    NULL,
                    NETLOGON_CONTROL_TC_QUERY,
                    2,  // Query level
                    (LPBYTE)&(InputDataPtr),
                    (LPBYTE *)&NetlogonInfo2 );


    // put message to message list
    if ( NetStatus != NO_ERROR ) 
    {
        //IDS_TRUST_FAILED_SECURECHANNEL      "	 Cannot get secure channel status for domain '%ws' from Netlogon. [%s]"
        AddIMessageToList(&pResults->Trust.lmsgOutput, Nd_Quiet, 0,
                          IDS_TRUST_FAILED_SECURECHANNEL, 
                          pResults->Global.pPrimaryDomainInfo->DomainNameFlat,
                          NetStatusToString(NetStatus));
        hr = S_FALSE;
        goto L_ERR;
    }

    if ( NetlogonInfo2->netlog2_tc_connection_status != NO_ERROR ) 
    {
        //IDS_TRUST_CHANNEL_BROKEN            "    [FATAL] Secure channel to domain '%ws' is broken. [%s]\n"
        AddIMessageToList(&pResults->Trust.lmsgOutput, Nd_Quiet, 0,
                          IDS_TRUST_CHANNEL_BROKEN,
                          pResults->Global.pPrimaryDomainInfo->DomainNameFlat,
                          NetStatusToString(NetlogonInfo2->netlog2_tc_connection_status));
        hr = S_FALSE;
        goto L_ERR;
    }

    AddIMessageToList(&pResults->Trust.lmsgOutput, Nd_Verbose, 0,
                          IDS_TRUST_SECURECHANNEL_TO, 
                          pResults->Global.pPrimaryDomainInfo->DomainNameFlat, 
                          NetlogonInfo2->netlog2_trusted_dc_name);
    

    // free the data buffer returned earlies
    if ( NetlogonInfo2 != NULL ) {
        NetApiBufferFree( NetlogonInfo2 );
        NetlogonInfo2 = NULL;
    }
    
    // test further
    switch(pResults->Global.pPrimaryDomainInfo->MachineRole){
    //
    // On a backup domain controller,
    //  only setup a secure channel to the PDC.
    //
    case    DsRole_RoleBackupDomainController:
        //
        // Check the current status of the secure channel.
        //  (This may be still cached and out of date.)
        //

        NetlogonInfo2 = NULL;
        InputDataPtr = (LPBYTE)(pResults->Global.pPrimaryDomainInfo->DomainNameDns ? 
                                    pResults->Global.pPrimaryDomainInfo->DomainNameDns :
                                    pResults->Global.pPrimaryDomainInfo->DomainNameFlat);

        // connect to PDC
        NetStatus = I_NetLogonControl2(
                        NULL,
                        NETLOGON_CONTROL_REDISCOVER,
                        2,  // Query level
                            (LPBYTE)&InputDataPtr,
                        (LPBYTE *)&NetlogonInfo2 );

        if (NetStatus == ERROR_ACCESS_DENIED)
        {
            //IDS_TRUST_NOT_ADMIN       "    Cannot test secure channel to PDC since you are not an administrator.\n"
            AddIMessageToList(&pResults->Trust.lmsgOutput, Nd_Quiet, 0,
                              IDS_TRUST_NOT_ADMIN);
            goto L_ERR;
        }
            

        if(NetStatus != NO_ERROR)
        {
            //IDS_TRUST_FAILED_CHANNEL_PDC      "    [FATAL] Cannot set secure channel for domain '%ws' to PDC. [%s]\n"
            AddIMessageToList(&pResults->Trust.lmsgOutput, Nd_Quiet, 0, 
                             IDS_TRUST_FAILED_CHANNEL_PDC,
                             pResults->Global.pPrimaryDomainInfo->DomainNameFlat,
                             NetStatusToString(NetStatus));
            hr = S_FALSE;
            goto L_ERR;
        }

        if ( NetlogonInfo2->netlog2_tc_connection_status != NO_ERROR ) 
        {
            AddIMessageToList(&pResults->Trust.lmsgOutput, Nd_Quiet, 0, 
                             IDS_TRUST_FAILED_CHANNEL_PDC,
                             pResults->Global.pPrimaryDomainInfo->DomainNameFlat,
                             NetStatusToString(NetStatus));
            hr = S_FALSE;
            goto L_ERR;
        }

        AddIMessageToList(&pResults->Trust.lmsgOutput, Nd_ReallyVerbose, 0,
                          IDS_TRUST_SECURECHANNEL_TOPDC, 
                          pResults->Global.pPrimaryDomainInfo->DomainNameFlat, 
                          NetlogonInfo2->netlog2_trusted_dc_name);
        
    
        if ( NetlogonInfo2 != NULL ) 
        {
            NetApiBufferFree( NetlogonInfo2 );
            NetlogonInfo2 = NULL;
        }


        break;
        
        // On a workstation or member server,
    //  try the secure channel to ever DC in the domain.
    //

    case    DsRole_RoleMemberServer:
    case    DsRole_RoleMemberWorkstation:

        if ( TestedDomain->NetbiosDomainName == NULL ) {
                //IDS_TRUST_NO_NBT_DOMAIN   "    [FATAL] Cannot test secure channel since no netbios domain name '%ws' to DC '%ws'."
                AddMessageToList( &pResults->Trust.lmsgOutput, Nd_Quiet, IDS_TRUST_NO_NBT_DOMAIN, TestedDomain->PrintableDomainName );
                PrintGuruMessage2("    [FATAL] Cannot test secure channel since no netbios domain name '%ws' to DC '%ws'.", TestedDomain->PrintableDomainName );
                PrintGuru( 0, NETLOGON_GURU );
                hr = S_FALSE;
                goto L_ERR;
            }

        //
        // Ensure secure channel can be set with atleast one DC.
        //

        for ( ListEntry = TestedDomain->TestedDcs.Flink ;
                  ListEntry != &TestedDomain->TestedDcs ;
                  ListEntry = ListEntry->Flink )
        {
            WCHAR RediscoverName[MAX_PATH+1+MAX_PATH+1];
            PTESTED_DC TestedDc;


            //
            // Loop through the list of DCs in this domain
            //

            TestedDc = CONTAINING_RECORD( ListEntry, TESTED_DC, Next );

            if ( TestedDc->Flags & DC_IS_DOWN ) {
                AddIMessageToList(&pResults->Trust.lmsgOutput, Nd_ReallyVerbose, 0,
                          IDS_TRUST_NOTESTASITSDOWN, 
                          TestedDc->ComputerName );
                continue;
            }

            //
            // Build the name to rediscover
            //

            wcscpy( RediscoverName, GetSafeStringW(TestedDomain->DnsDomainName ? 
                                                    TestedDomain->DnsDomainName :
                                                    TestedDomain->NetbiosDomainName));
            wcscat( RediscoverName, L"\\" );
            wcscat( RediscoverName, GetSafeStringW(TestedDc->ComputerName) );


            //
            // Check the current status of the secure channel.
            //  (This may be still cached and out of date.)
            //

            InputDataPtr = (LPBYTE)RediscoverName;
            NetStatus = I_NetLogonControl2(
                            NULL,
                            NETLOGON_CONTROL_REDISCOVER,
                            2,  // Query level
                            (LPBYTE)&InputDataPtr,
                            (LPBYTE *)&NetlogonInfo2 );

            if ( NetStatus != NO_ERROR ) 
            {
                if ( ERROR_ACCESS_DENIED == NetStatus )
                {
                    AddIMessageToList(&pResults->Trust.lmsgOutput, Nd_Quiet, 0, 
                                 IDS_TRUST_TODCS_NOT_ADMIN);
                }
                else
                {
                    //IDS_TRUST_FAILED_TODCS              "    Cannot test secure channel for domain '%ws' to DC '%ws'. [%s]\n"
                    AddIMessageToList(&pResults->Trust.lmsgOutput, Nd_Quiet, 0, 
                                 IDS_TRUST_FAILED_TODCS,
                                 TestedDomain->PrintableDomainName,
                                 TestedDc->NetbiosDcName,
                                 NetStatusToString(NetStatus));

                }

                continue;
            }

            if ( NetlogonInfo2->netlog2_tc_connection_status != NO_ERROR ) 
            {
                AddIMessageToList(&pResults->Trust.lmsgOutput, Nd_Quiet, 0,
                          IDS_TRUST_FAILED_CHANNEL_DCS, 
                          TestedDomain->PrintableDomainName,
                          TestedDc->NetbiosDcName  );
                continue;
            }

            AddIMessageToList(&pResults->Trust.lmsgOutput, Nd_ReallyVerbose, 0,
                          IDS_TRUST_CHANNEL_DC, 
                          TestedDomain->PrintableDomainName,
                          NetlogonInfo2->netlog2_trusted_dc_name  );
            validDC++;
        }
        if (validDC == 0)
            hr = S_FALSE;
        
        break;
    }



L_ERR:

    if ( NetlogonInfo2 != NULL ) {
        NetApiBufferFree( NetlogonInfo2 );
        NetlogonInfo2 = NULL;
    }

    if ( TrustedDomainList != NULL ) {
        NetApiBufferFree( TrustedDomainList );
        TrustedDomainList = NULL;
    }
    
    PrintStatusMessage(pParams, 0, FHrOK(hr) ? IDS_GLOBAL_PASS_NL : IDS_GLOBAL_FAIL_NL);

    pResults->Trust.hr = hr;

    return hr;
} 

void TrustGlobalPrint(IN NETDIAG_PARAMS *pParams, IN OUT NETDIAG_RESULT *pResults)
{
    // print out the test result
    if (pParams->fVerbose || !FHrOK(pResults->Trust.hr))
    {
        PrintNewLine(pParams, 2);
        PrintTestTitleResult(pParams, IDS_TRUST_LONG, IDS_TRUST_SHORT, pResults->Trust.fPerformed, 
                             pResults->Trust.hr, 0);

        PrintMessageList(pParams, &pResults->Trust.lmsgOutput);
    }

}

void TrustPerInterfacePrint(IN NETDIAG_PARAMS *pParams,
                             IN OUT NETDIAG_RESULT *pResults,
                             IN INTERFACE_RESULT *pIfResult)
{
    // no perinterface information
}

void TrustCleanup(IN NETDIAG_PARAMS *pParams,
                         IN OUT NETDIAG_RESULT *pResults)
{
    MessageListCleanUp(&pResults->Trust.lmsgOutput);

}



BOOL
DomainSidRight(
    IN PTESTED_DOMAIN TestedDomain,
     NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults
    )
/*++

Routine Description:

    Determine if the DomainSid field of the TestDomain matches the DomainSid
    of the domain.

Arguments:

    TestedDomain - Domain to test

Return Value:

    TRUE: Test suceeded.
    FALSE: Test failed

--*/
{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;
    BOOL RetVal = TRUE;

    SAM_HANDLE LocalSamHandle = NULL;
    SAM_HANDLE DomainHandle = NULL;

    PTESTED_DC  pTestedDc;


    //
    // Initialization
    //

    AddIMessageToList(&pResults->Trust.lmsgOutput, Nd_ReallyVerbose, 0,
                          IDS_TRUST_ENSURESID, 
                          TestedDomain->PrintableDomainName);

    if ( TestedDomain->DomainSid == NULL ) {
        AddIMessageToList(&pResults->Trust.lmsgOutput, Nd_Quiet, 0,
                              IDS_TRUST_MISSINGSID, 
                              TestedDomain->PrintableDomainName);
        RetVal = FALSE;
        goto Cleanup;
    }

    //
    // If we don't yet know a DC in the domain,
    //  find one.
    //

    if ( TestedDomain->DcInfo == NULL ) 
    {
        LPTSTR pszDcType;

        if ( TestedDomain->fTriedToFindDcInfo ) {
            //IDS_DCLIST_NO_DC "    '%ws': Cannot find DC to get DC list from [test skiped].\n"
            AddMessageToList( &pResults->Trust.lmsgOutput, Nd_Verbose, IDS_TRUST_NODC, TestedDomain->PrintableDomainName);
            goto Cleanup;
        }

        pszDcType = LoadAndAllocString(IDS_DCTYPE_DC);
        NetStatus = DoDsGetDcName( pParams,
                                   pResults,
                                   &pResults->Trust.lmsgOutput,
                                   TestedDomain,
                                   DS_DIRECTORY_SERVICE_PREFERRED,
                                   pszDcType, //"DC",
                                   FALSE,
                                   &TestedDomain->DcInfo );
        Free(pszDcType);

        TestedDomain->fTriedToFindDcInfo = TRUE;

        if ( NetStatus != NO_ERROR ) {
            //IDS_TRUST_NODC    "    '%ws': Cannot find DC to get DC list from [test skiped].\n"
            AddIMessageToList(&pResults->Trust.lmsgOutput, Nd_Verbose, 0, 
                            IDS_TRUST_NODC, TestedDomain->PrintableDomainName);
            AddIMessageToList(&pResults->Trust.lmsgOutput, Nd_Verbose, 4, 
                              IDS_GLOBAL_STATUS, NetStatusToString(NetStatus));
            
            // This isn't fatal.
            RetVal = TRUE;
            goto Cleanup;
        }
    }

    //
    // Get a DC that's UP.
    //

    pTestedDc = GetUpTestedDc( TestedDomain );

    if ( pTestedDc == NULL ) {
        AddMessageToList( &pResults->Trust.lmsgOutput, Nd_Verbose, 
                          IDS_TRUST_NODC_UP, TestedDomain->PrintableDomainName);
        PrintGuruMessage2("    '%ws': No DCs are up (Cannot run test).\n",
                TestedDomain->PrintableDomainName );
        PrintGuru( NetStatus, DSGETDC_GURU );
        // This isn't fatal.
        RetVal = TRUE;
        goto Cleanup;
    }


    //
    // Connect to the SAM server
    //

    Status = NettestSamConnect(
                               pParams,
                               pTestedDc->ComputerName,
                               &LocalSamHandle );

    if ( !NT_SUCCESS(Status)) {
        if ( Status == STATUS_ACCESS_DENIED ) {
            //IDS_TRUST_NO_ACCESS   "    [WARNING] Don't have access to test your domain sid for domain '%ws'. [Test skipped]\n"
            AddMessageToList( &pResults->Trust.lmsgOutput, Nd_Verbose, 
                              IDS_TRUST_NO_ACCESS, TestedDomain->PrintableDomainName );
        }
        // This isn't fatal.
        RetVal = TRUE;
        goto Cleanup;
    }


    //
    // Open the domain.
    //  Ask for no access to avoid access denied.
    //

    Status = SamOpenDomain( LocalSamHandle,
                            0,
                            pResults->Global.pMemberDomain->DomainSid,
                            &DomainHandle );

    if ( Status == STATUS_NO_SUCH_DOMAIN ) {
        AddIMessageToList(&pResults->Trust.lmsgOutput, Nd_Quiet, 0, IDS_TRUST_WRONGSID, TestedDomain->PrintableDomainName );
        RetVal = FALSE;
        goto Cleanup;

    }

    if ( !NT_SUCCESS( Status ) ) {
        AddIMessageToList(&pResults->Trust.lmsgOutput, Nd_Quiet, 0, IDS_TRUST_FAILED_SAMOPEN, pTestedDc->ComputerName );
        RetVal = FALSE;
        goto Cleanup;
    }


    //
    // Cleanup locally used resources
    //
Cleanup:
    if ( DomainHandle != NULL ) {
        (VOID) SamCloseHandle( DomainHandle );
    }

    if ( LocalSamHandle != NULL ) {
        (VOID) SamCloseHandle( LocalSamHandle );
    }

    return RetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\winsock.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      winsock.c
//
//  Abstract:
//
//      Queries into network drivers
//
//  Author:
//
//      Anilth	- 4-20-1998 
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//--

#include "precomp.h"


HRESULT WinsockTest( NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
{
	int    err,i;
	LPWSAPROTOCOL_INFO  lpProtocolBuffer = NULL;
	DWORD  reqd_length;
	SOCKET sock;
	UINT   optval;
	int    optlen;
	WSADATA WSAData;
	HRESULT	hr = S_OK;

	PrintStatusMessage(pParams,0, IDS_WINSOCK_STATUS_MSG);


	err = WSAStartup(MAKEWORD( 2, 0 ), &WSAData); 
	if(err != 0)	// error
	{
		CHK_HR_CONTEXT(pResults->Winsock, hr = HRESULT_FROM_WIN32(err), IDS_WINSOCK_FAILED_START);
	};
	
	// determine the length of the buffer needed
	reqd_length = 0;

	err = WSAEnumProtocols(NULL, NULL, &reqd_length);
	if(reqd_length == 0 || reqd_length == -1)
	{
		err = WSAGetLastError();
		CHK_HR_CONTEXT(pResults->Winsock, hr = HRESULT_FROM_WIN32(err), IDS_WINSOCK_FAILED_ENUM);
	};

	lpProtocolBuffer = (LPWSAPROTOCOL_INFO)Malloc(reqd_length);

	if (lpProtocolBuffer == NULL) {
		CHK_HR_CONTEXT(pResults->Winsock, hr = E_OUTOFMEMORY, IDS_WINSOCK_FAILED_ENUM);
	}

    ZeroMemory( lpProtocolBuffer, reqd_length );

  	// get the information of the protocols
	err = WSAEnumProtocols(
                   NULL,
                   (LPWSAPROTOCOL_INFO)lpProtocolBuffer,
                   (LPDWORD)&reqd_length
                  );

	if(err == SOCKET_ERROR)
	{
		err = WSAGetLastError();
		CHK_HR_CONTEXT(pResults->Winsock, hr = HRESULT_FROM_WIN32(err), IDS_WINSOCK_FAILED_ENUM);
	}

	pResults->Winsock.dwProts = err;	// number of protocols
	pResults->Winsock.pProtInfo = lpProtocolBuffer;	// protocol information array

	//
	// Other TCP/IP information
	//
	sock = socket(PF_INET,SOCK_DGRAM,IPPROTO_UDP);

	if ( sock == INVALID_SOCKET)
	{
		err = WSAGetLastError();
		CHK_HR_CONTEXT(pResults->Winsock, hr = HRESULT_FROM_WIN32(err), IDS_WINSOCK_FAILED_UDPSOCKET);
	}

	optlen = sizeof(optval);

	err = getsockopt(sock, SOL_SOCKET, SO_MAX_MSG_SIZE, (char FAR*)&optval, (int FAR*)&optlen);

	if (err == SOCKET_ERROR) 
	{
		err = WSAGetLastError();
		CHK_HR_CONTEXT(pResults->Winsock, hr = HRESULT_FROM_WIN32(err), IDS_WINSOCK_FAILED_UDPSOCKET);
	}

	pResults->Winsock.dwMaxUDP = optval;

L_ERR:
	WSACleanup();

    //$REVIEW (nsun) we should return S_FALSE so that we can go on with 
    //other tests
    if (!FHrOK(hr))
        hr = S_FALSE;

	return hr;

} /* END OF WINSTest() */

void WinsockGlobalPrint(IN NETDIAG_PARAMS *pParams, IN OUT NETDIAG_RESULT *pResults)
{
	DWORD i = 0;
	LPWSAPROTOCOL_INFO	pProtInfo = pResults->Winsock.pProtInfo;
	
	// print out the test result
	if (pParams->fVerbose || !FHrOK(pResults->Winsock.hr))
	{
		PrintNewLine(pParams, 2);
		PrintTestTitleResult(pParams,
							 IDS_WINSOCK_LONG,
							 IDS_WINSOCK_SHORT,
							 TRUE,
							 pResults->Winsock.hr, 0);
	}
	if (pParams->fReallyVerbose || !FHrOK(pResults->Winsock.hr))
	{
		if (!FHrOK(pResults->Winsock.hr))
		{
			PrintError(pParams, pResults->Winsock.idsContext, pResults->Winsock.hr);
		}
	}

	if (pParams->fReallyVerbose)
	{
		if(pProtInfo)
		{
			// if there is any information about the providers
			// "    The number of protocols which have been reported : %d\n" 
			PrintMessage(pParams, IDS_WINSOCK_12605, pResults->Winsock.dwProts); 

			for (i = 0; i < pResults->Winsock.dwProts ; i++)
			{
				// "        Description: %s\n" 
    			PrintMessage(pParams, IDS_WINSOCK_12606,pProtInfo->szProtocol);
				// "            Provider Version   :%d\n" 
			    PrintMessage(pParams, IDS_WINSOCK_12607,pProtInfo->iVersion);
				switch(pProtInfo++->dwMessageSize){
				case	0:
					// "            Max message size  : Stream Oriented\n" 
					PrintMessage(pParams, IDS_WINSOCK_12608);
					break;
			    case	1:
					// "            Max message size  : Message Oriented\n" 
					PrintMessage(pParams, IDS_WINSOCK_12609);
					break;
			    case	0xffffffff:
					// "            Max message size  : depends on MTU\n" 
					PrintMessage(pParams, IDS_WINSOCK_12610);
					break;
				}
			}
		}
 
		// if there is any information about the UDP size
		if(pResults->Winsock.dwMaxUDP)
			// "\n    Max UDP size : %d bytes\n" 
			PrintMessage(pParams, IDS_WINSOCK_12611,pResults->Winsock.dwMaxUDP);   
	}

}

void WinsockPerInterfacePrint(IN NETDIAG_PARAMS *pParams,
							 IN OUT NETDIAG_RESULT *pResults,
							 IN INTERFACE_RESULT *pIfResult)
{
	// no perinterface information
}

void WinsockCleanup(IN NETDIAG_PARAMS *pParams,
						 IN OUT NETDIAG_RESULT *pResults)
{
	if(pResults->Winsock.pProtInfo)
	{
		free(pResults->Winsock.pProtInfo);
	}
	ZeroMemory(&(pResults->Winsock), sizeof(GLOBAL_WINSOCK));		
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\tfschar.h ===
//============================================================================
// Copyright (C) Microsoft Corporation, 1997- 1999 
//
// File:	tfschar.h
//
//	String functions that are used in general for TFS code.
//
// History:
//
//	05/28/97	Kenn Takara				Created.
//
//	Declarations for some common code/macros.
//============================================================================


#ifndef _TFSCHAR_H
#define _TFSCHAR_H

#if _MSC_VER >= 1000	// VC 5.0 or later
#pragma once
#endif

#define TFSCORE_API(x)	x


//$ Win95: kennt, the list of Unicode-enabled functions on Win95 will
// have to be checked.  Does lstrlenW work, but lstrcpyW doesn't? (that's
// what the ATL versions of the functions imply).


/*---------------------------------------------------------------------------
	String copy functions
 ---------------------------------------------------------------------------*/

// Baisc conversion functions
TFSCORE_API(LPSTR)	StrCpyAFromW(LPSTR psz, LPCWSTR pswz);
TFSCORE_API(LPWSTR)	StrCpyWFromA(LPWSTR pswz, LPCSTR psz);

TFSCORE_API(LPSTR)	StrnCpyAFromW(LPSTR psz, LPCWSTR pswz, int iMax);
TFSCORE_API(LPWSTR)	StrnCpyWFromA(LPWSTR pswz, LPCSTR psz, int iMax);

#define	StrCpy		lstrcpy
#define StrnCpy		lstrcpyn

#define StrCpyW		lstrcpyW
#define StrCpyA		lstrcpyA
#define StrnCpyW	lstrcpynW
#define StrnCpyA	lstrcpynA

#define StrCpyOle	StrCpyW
#define StrnCpyOle	StrnCpyW

#ifdef _UNICODE

	#define StrCpyAFromT	StrCpyAFromW
	#define StrCpyTFromA	StrCpyWFromA
	#define StrCpyTFromW	lstrcpy
	#define StrCpyWFromT	lstrcpy

	#define StrnCpyAFromT	StrnCpyAFromW
	#define StrnCpyTFromA	StrnCpyWFromA
	#define StrnCpyTFromW	lstrcpyn
	#define StrnCpyWFromT	lstrcpyn

#else
	
	#define StrCpyAFromT	lstrcpy
	#define StrCpyTFromA	lstrcpy
	#define	StrCpyTFromW	StrCpyAFromW
	#define StrCpyWFromT	StrCpyWFromA

	#define StrnCpyAFromT	lstrcpyn
	#define StrnCpyTFromA	lstrcpyn
	#define	StrnCpyTFromW	StrnCpyAFromW
	#define StrnCpyWFromT	StrnCpyWFromA

#endif


#define StrCpyOleFromT		StrCpyWFromT
#define StrCpyTFromOle		StrCpyTFromW

#define StrCpyOleFromA		StrCpyWFromA
#define StrCpyAFromOle		StrCpyAFromW
#define StrCpyWFromOle		StrCpyW
#define StrCpyOleFromW		StrCpyW

#define StrnCpyOleFromT		StrnCpyWFromT
#define StrnCpyTFromOle		StrnCpyTFromW
#define StrnCpyOleFromA		StrnCpyWFromA
#define StrnCpyAFromOle		StrnCpyAFromW
#define StrnCpyOleFromW		StrnCpyW
#define StrnCpyWFromOle		StrnCpyW


/*---------------------------------------------------------------------------
	String length functions
 ---------------------------------------------------------------------------*/

#define StrLen			lstrlen
#define StrLenA			lstrlenA
#define StrLenW			lstrlenW
#define StrLenOle		StrLenW

//
//	CbStrLenA() is inaccurate for DBCS strings!  It will return the
//	incorrect number of bytes needed.
//

#define CbStrLenA(psz)	((StrLenA(psz)+1)*sizeof(char))
#define CbStrLenW(psz)	((StrLenW(psz)+1)*sizeof(WCHAR))

#ifdef _UNICODE
	#define CbStrLen(psz)	CbStrLenW(psz)
#else
	#define CbStrLen(psz)	CbStrLenA(psz)
#endif


// Given a number of characters, this it the minimal number of TCHARs
// that needs to be allocated to hold the string
#define MinTCharNeededForCch(ch)	((ch) * (2/sizeof(TCHAR)))
#define MinCbNeededForCch(ch)		(sizeof(TCHAR)*MinTCharNeededForCch(ch))

// Given a cb (count of bytes) this is the maximal number of characters
// that can be in this string
#define MaxCchFromCb(cb)		((cb) / sizeof(TCHAR))


#ifdef _UNICODE
	// Given a cb, this is the minimum number of chars found in this string
	// MinCchFromCb
	#define MinCchFromCb(cb)	((cb) / sizeof(WCHAR))
#else
	// Number of characters is only half due to DBCS
	#define MinCchFromCb(cb)	((cb) / (2*sizeof(char)))
#endif

/*---------------------------------------------------------------------------
	String dup functions

	The returned string from these functions must be freed using delete!
 ---------------------------------------------------------------------------*/
	
TFSCORE_API(LPSTR)	StrDupA( LPCSTR psz );
TFSCORE_API(LPWSTR)	StrDupW( LPCWSTR pws );

TFSCORE_API(LPSTR)	StrDupAFromW( LPCWSTR pwsz );
TFSCORE_API(LPWSTR)	StrDupWFromA( LPCSTR psz );

#ifdef _UNICODE
	#define	StrDup			StrDupW
	#define StrDupTFromW	StrDupW
	#define StrDupWFromT	StrDupW
	#define	StrDupTFromA	StrDupWFromA
	#define StrDupAFromT	StrDupAFromW

	#define StrDupOleFromA	StrDupWFromA
	#define StrDupAFromOle	StrDupAFromW
	#define StrDupOleFromW	StrDupW
	#define StrDupWFromOle	StrDupW
	#define StrDupOleFromT	StrDupOleFromW
	#define StrDupTFromOle	StrDupWFromOle
#else
	#define StrDup			StrDupA
	#define StrDupTFromA	StrDupA
	#define StrDupAFromT	StrDupA
	#define StrDupTFromW	StrDupAFromW
	#define StrDupWFromT	StrDupWFromA

	#define StrDupOleFromA	StrDupWFromA
	#define StrDupAFromOle	StrDupAFromW
	#define StrDupOleFromW	StrDupW
	#define StrDupWFromOle	StrDupW
	#define StrDupOleFromT	StrDupOleFromA
	#define StrDupTFromOle	StrDupAFromOle
#endif


//	AllocaStrDup
//	AllocaStrDupA
//	AllocaStrDupW
//
//	These functions will dup a string on the STACK.
//
#define AllocaStrDupA(lpa) (\
	((LPCSTR)lpa == NULL) ? NULL : (\
		StrCpyA((LPSTR) alloca(CbStrLenA(lpa)*2), lpa)))

#define AllocaStrDupW(lpw) (\
	((LPCWSTR)lpw == NULL) ? NULL : (\
		StrCpyW((LPWSTR) alloca(CbStrLenW(lpw)), lpw)))

#ifdef _UNICODE
	#define AllocaStrDup	AllocaStrDupW
#else
	#define AllocaStrDup	AllocaStrDupA
#endif





/*---------------------------------------------------------------------------
	String comparison functions
 ---------------------------------------------------------------------------*/
#define StrCmpA		lstrcmpA
#define StrCmpW		lstrcmpW
#define StrCmpOle	StrCmpW

TFSCORE_API(int) StrnCmpA(LPCSTR psz1, LPCSTR psz2, int nLen);
TFSCORE_API(int) StrnCmpW(LPCWSTR pswz1, LPCWSTR pswz2, int nLen);

#define StriCmpA	lstrcmpiA
#define StriCmpW	lstrcmpiW
#define StriCmpOle	StriCmpW

TFSCORE_API(int) StrniCmpA(LPCSTR psz1, LPCSTR psz2, int nLen);
TFSCORE_API(int) StrniCmpW(LPCWSTR pswz1, LPCWSTR pswz2, int nLen);


#ifdef _UNICODE
	#define StrCmp		StrCmpW
	#define StrnCmp		StrnCmpW
	#define StriCmp		StriCmpW
	#define StrniCmp	StrniCmpW
#else
	#define StrCmp		StrCmpA
	#define StrnCmp		StrnCmpA
	#define StriCmp		StriCmpA
	#define StrniCmp	StrniCmpA
#endif


/*---------------------------------------------------------------------------
	String concatenation routines
 ---------------------------------------------------------------------------*/
#define	StrCatW			lstrcatW
#define StrCatA			lstrcatA

#ifdef _UNICODE
	#define StrCat		StrCatW
#else
	#define StrCat		StrCatA
#endif


/*---------------------------------------------------------------------------
	LoadString helpers
 ---------------------------------------------------------------------------*/
LPTSTR	LoadAndAllocString(UINT ids);

/*---------------------------------------------------------------------------
	Get safe strings
 ---------------------------------------------------------------------------*/
LPTSTR GetSafeString(LPTSTR psz);
LPWSTR GetSafeStringW(LPWSTR pwsz);
LPSTR GetSafeStringA(LPSTR pasz);

/*---------------------------------------------------------------------------
	Local conversion routines (conversions performed on stack!)
 ---------------------------------------------------------------------------*/

// Make sure MFC's afxconv.h hasn't already been loaded to do this
#ifndef USES_CONVERSION
	#ifndef _DEBUG
		#define USES_CONVERSION int _convert; _convert
	#else
		#define USES_CONVERSION int _convert = 0
	#endif

/////////////////////////////////////////////////////////////////////////////
// Global UNICODE<>ANSI translation helpers

LPWSTR WINAPI AtlA2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars);
LPSTR WINAPI AtlW2AHelper(LPSTR lpa, LPCWSTR lpw, int nChars);

#define A2W(lpa) (\
	((LPCSTR)lpa == NULL) ? NULL : (\
		_convert = (lstrlenA(lpa)+1),\
		AtlA2WHelper((LPWSTR) alloca(_convert*2), lpa, _convert)))

#define W2A(lpw) (\
	((LPCWSTR)lpw == NULL) ? NULL : (\
		_convert = (lstrlenW(lpw)+1)*2,\
		AtlW2AHelper((LPSTR) alloca(_convert), lpw, _convert)))

#define A2CW(lpa) ((LPCWSTR)A2W(lpa))
#define W2CA(lpw) ((LPCSTR)W2A(lpw))


#ifdef _UNICODE
	#define T2A W2A
	#define A2T A2W
	#define T2W(_lp)	(_lp)
	#define W2T(_lp)	(_lp)
	#define T2CA W2CA
	#define A2CT A2CW
	#define T2CW(_lp)	(_lp)
	#define W2CT(_lp)	(_lp)
#else
	#define T2W A2W
	#define W2T W2A
	#define T2A(_lp)	(_lp)
	#define A2T(_lp)	(_lp)
	#define T2CW A2CW
	#define W2CT W2CA
	#define T2CA(_lp)	(_lp)
	#define A2CT(_lp)	(_lp)
#endif

#endif	// !USES_CONVERSION

#endif	// _TFSCHAR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\winstest.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      winstest.c
//
//  Abstract:
//
//      Queries into network drivers
//
//  Author:
//
//      Anilth  - 4-20-1998 
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//--

#include "precomp.h"
#include "dhcptest.h"

static const TCHAR  s_szSpace12[] = _T("            ");
const int c_iWaitTime = 2000;

BOOL IsNameResponse( NETDIAG_PARAMS * pParams, char* ipAddrStr );
int Probe( NETDIAG_PARAMS *pParams, TCHAR *szSrvIpAddr, SOCKET listenNameSvcSock );

//-------------------------------------------------------------------------//
//######  W I N S T e s t ()  #############################################//
//-------------------------------------------------------------------------//
//  Abstract:                                                              //
//      Queries the all the configured WINS servers to make sure that      //
//      they are reachable and that they have the proper name-IP mapping   //
//      for this workstation.                                              //
//  Arguments:                                                             //
//      none                                                               //
//  Return value:                                                          //
//      TRUE  - test passed                                                //
//      FALSE - test failed                                                //
//  Global variables used:                                                 //
//      none                                                               //
//-------------------------------------------------------------------------//
HRESULT WinsTest( NETDIAG_PARAMS* pParams, NETDIAG_RESULT*  pResults)
{
    IPCONFIG_TST *  pIpConfig;
    WINS_TST *      pWinsResult;
    PIP_ADAPTER_INFO  pIpAdapter;
    IP_ADDR_STRING winsSrv;
    int            nWinsSrvOk = 0;
    HRESULT         hr = hrOK;
    int             i;
    TCHAR           szBuffer[256];

    
    // IDS_WINS_STATUS_MSG  "    Testing the WINS server... \n" 
    PrintStatusMessage(pParams, 4, IDS_WINS_STATUS_MSG);

    //
    //  try to send name queries to the WINS servers on all adapters
    //
    for ( i = 0; i < pResults->cNumInterfaces; i++ )
    {
        UINT nIfWinsOk = 0;

        pIpConfig = &pResults->pArrayInterface[i].IpConfig;
        pIpAdapter = pResults->pArrayInterface[i].IpConfig.pAdapterInfo;
        InitializeListHead( &pResults->pArrayInterface[i].Wins.lmsgPrimary );
        InitializeListHead( &pResults->pArrayInterface[i].Wins.lmsgSecondary );

        if (!pIpConfig->fActive || 
            NETCARD_DISCONNECTED == pResults->pArrayInterface[i].dwNetCardStatus)
            continue;

		if (!pResults->pArrayInterface[i].fNbtEnabled)
			continue;

        PrintStatusMessage(pParams, 8, IDSSZ_GLOBAL_StringLine, pResults->pArrayInterface[i].pszFriendlyName);

        pWinsResult = &pResults->pArrayInterface[i].Wins;

        //
        //  looping through the primary WINS server list
        //

        winsSrv = pIpAdapter->PrimaryWinsServer;
        if ( ZERO_IP_ADDRESS(winsSrv.IpAddress.String) )
        {
            if(pParams->fReallyVerbose)
                PrintMessage(pParams, IDS_WINS_QUERY_NO_PRIMARY,
                             s_szSpace12);
            AddMessageToList(&pWinsResult->lmsgPrimary,
                             Nd_ReallyVerbose, IDS_WINS_QUERY_NO_PRIMARY,
                             s_szSpace12);
        }
        else
        {
            pWinsResult->fPerformed = TRUE;

            while ( TRUE )
            {
                if (pParams->fReallyVerbose)
                    PrintMessage(pParams, IDS_WINS_QUERY_PRIMARY,
                                 s_szSpace12,
                                 winsSrv.IpAddress.String);
            
                AddMessageToList(&pWinsResult->lmsgPrimary,
                                 Nd_ReallyVerbose,
                                 IDS_WINS_QUERY_PRIMARY,
                                 s_szSpace12,
                                 winsSrv.IpAddress.String);
            
                if ( IsNameResponse(pParams, winsSrv.IpAddress.String) )
                {
                    if (pParams->fReallyVerbose)
                        PrintMessage(pParams, IDS_GLOBAL_PASS_NL);
                    AddMessageToList(&pWinsResult->lmsgPrimary,
                                     Nd_ReallyVerbose,
                                     IDS_GLOBAL_PASS_NL);
                    nWinsSrvOk++;
                    nIfWinsOk++;
                }
                else
                {
                    if (pParams->fReallyVerbose)
                        PrintMessage(pParams, IDS_GLOBAL_FAIL_NL);
                    AddMessageToList(&pWinsResult->lmsgPrimary,
                                       Nd_ReallyVerbose,
                                       IDS_GLOBAL_FAIL_NL);
                }
            
                if ( winsSrv.Next == NULL )
                {
                    break;
                }

                winsSrv = *(winsSrv.Next);
            }
        }

        //
        //  looping through the secondary WINS server list
        //

        winsSrv = pIpAdapter->SecondaryWinsServer;
        if ( ZERO_IP_ADDRESS(winsSrv.IpAddress.String) )
        {
            if(pParams->fReallyVerbose)
                PrintMessage(pParams, IDS_WINS_QUERY_NO_SECONDARY,
                             s_szSpace12);
            AddMessageToList(&pWinsResult->lmsgSecondary,
                             Nd_ReallyVerbose, IDS_WINS_QUERY_NO_SECONDARY,
                             s_szSpace12);
        }
        else
        {
            pWinsResult->fPerformed = TRUE;

            while ( TRUE )
            {
                if (pParams->fReallyVerbose)
                    PrintMessage(pParams, IDS_WINS_QUERY_SECONDARY,
                                 s_szSpace12,
                                 winsSrv.IpAddress.String);
            
                AddMessageToList(&pWinsResult->lmsgSecondary,
                                 Nd_ReallyVerbose,
                                 IDS_WINS_QUERY_SECONDARY,
                                 s_szSpace12,
                                 winsSrv.IpAddress.String);
            
                if ( IsNameResponse(pParams, winsSrv.IpAddress.String) )
                {
                    if (pParams->fReallyVerbose)
                        PrintMessage(pParams, IDS_GLOBAL_PASS_NL);
                    AddMessageToList(&pWinsResult->lmsgSecondary,
                                     Nd_ReallyVerbose,
                                     IDS_GLOBAL_PASS_NL);
                    nWinsSrvOk++;
                    nIfWinsOk++;
                }
                else
                {
                    if (pParams->fReallyVerbose)
                        PrintMessage(pParams, IDS_GLOBAL_FAIL_NL);
                    AddMessageToList(&pWinsResult->lmsgSecondary,
                                       Nd_ReallyVerbose,
                                       IDS_GLOBAL_FAIL_NL);
                }

                if ( winsSrv.Next == NULL ) { break; }

                winsSrv = *(winsSrv.Next);
            }
        }
        
        if( 0 == nIfWinsOk )
            pWinsResult->hr = S_FALSE;
        else
            pWinsResult->hr = S_OK;

    } /* end of for loop scanning all the adapters */

//$REVIEW   No global test result for WINS test
    if ( nWinsSrvOk != 0)
    {
        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }
        

    return hr;
} /* END OF WINSTest() */



//-------------------------------------------------------------------------//
//######  P r o b e  ()  ##################################################//
//-------------------------------------------------------------------------//
//  Abstract:                                                              //
//      Assembles and sends a name query to the DHCP server.               //
//  Arguments:                                                             //
//      none                                                               //
//  Return value:                                                          //
//      TRUE if a response has been received from the server               //
//      FALSE otherwise                                                    //
//  Global variables used:                                                 //
//      g_isDebug (reading only)                                   //
//                                                                         //
//  Comments:                                                              //
//  This will not work for b-type nodes for which you need to set the B bit//
//  and broadcast the packet instead of unicast xmission  - Rajkumar       //
//-------------------------------------------------------------------------//
int Probe( NETDIAG_PARAMS *pParams, TCHAR *szSrvIpAddr, SOCKET listenNameSvcSock ) {

    char                nbtFrameBuf[MAX_NBT_PACKET_SIZE];
    NM_FRAME_HDR       *pNbtHeader = (NM_FRAME_HDR *)nbtFrameBuf;
    NM_QUESTION_SECT   *pNbtQuestion = (NM_QUESTION_SECT *)( nbtFrameBuf + sizeof(NM_FRAME_HDR) );
    struct sockaddr_in  destSockAddr;                       
    char               *pDest, *pName;
    int                 nBytesSent = 0, i;


    /* RFC 1002 section 4.2.12

                        1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         NAME_TRN_ID           |0|  0x0  |0|0|1|0|0 0|B|  0x0  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          0x0001               |           0x0000              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          0x0000               |           0x0000              |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   /                         QUESTION_NAME                         /
   /                                                               /
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           NB (0x0020)         |        IN (0x0001)            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   */
    
    pNbtHeader->xid            = NM_QRY_XID;
    pNbtHeader->flags          = NBT_NM_OPC_QUERY | 
                                 NBT_NM_OPC_REQUEST | 
                                 NBT_NM_FLG_RECURS_DESRD;
    pNbtHeader->question_cnt   = 0x0100;
    pNbtHeader->answer_cnt     = 0;
    pNbtHeader->name_serv_cnt  = 0;
    pNbtHeader->additional_cnt = 0;

    // pDest is filling nbtQuestion->q_name 
    pNbtQuestion->q_type       = NBT_NM_QTYP_NB;
    pNbtQuestion->q_class      = NBT_NM_QCLASS_IN;

    //
    //  translate the name
    //

    pDest = (char *)&(pNbtQuestion->q_name);
    pName = nameToQry;

    // the first byte of the name is the length field = 2*16
    *pDest++ = NBT_NAME_SIZE;

    // step through name converting ascii to half ascii, for 32 times
    for ( i = 0; i < (NBT_NAME_SIZE / 2) ; i++ ) {
        *pDest++ = (*pName >> 4) + 'A';
        *pDest++ = (*pName++ & 0x0F) + 'A';
    }
    *pDest++ = '\0';
    *pDest = '\0';

    //
    // send the name query frame
    // 
    destSockAddr.sin_family = PF_INET;
    destSockAddr.sin_port = htons(137);     // NBT_NAME_SERVICE_PORT;
    destSockAddr.sin_addr.s_addr = inet_addr( szSrvIpAddr );
    for ( i = 0; i < 8 ; i++ ) { destSockAddr.sin_zero[i] = 0; }

    nBytesSent = sendto( listenNameSvcSock,
                         (PCHAR )nbtFrameBuf, 
                         sizeof(NM_FRAME_HDR) + sizeof(NM_QUESTION_SECT),
                         0,
                         (struct sockaddr *)&destSockAddr,
                         sizeof( struct sockaddr )
                       );


    PrintDebugSz(pParams, 0, _T("\n      querying name %s on server %s\n"), nameToQry, szSrvIpAddr );
    PrintDebugSz(pParams, 0, _T( "          bytes sent %d\n"), nBytesSent );

    if ( nBytesSent == SOCKET_ERROR )
    {
        PrintDebugSz(pParams, 0, _T("    Error %d in sendto()!\n"), WSAGetLastError() );
        return FALSE;
    }

    //
    //  the other thread should see the incoming frame and increment m_nMsgCnt
    //
    return TRUE;

} /* END OF Probe() */




//-------------------------------------------------------------------------//
//######  I s N a m e R e s p o n s e ()  #################################//
//-------------------------------------------------------------------------//
//  Abstract:                                                              //
//      Sends a NetBT name Query to the IP address provided as input param //
//  Arguments:                                                             //
//      ipAddrStr - IP address where the Name Query is to be sent          //
//  Return value:                                                          //
//      TRUE  - test passed                                                //
//      FALSE - test failed                                                //
//  Global variables used:                                                 //
//      none                                                               //
//-------------------------------------------------------------------------//
BOOL IsNameResponse( NETDIAG_PARAMS *pParams, char* ipAddrStr ) {

    DWORD   optionValue;    // helper var for setsockopt()
    SOCKADDR_IN sockAddr;       // struct holding source socket info
    SOCKET      listenNameSvcSock;

    DWORD  listeningThreadId;
    int iTimeout;
    
    int nBytesRcvd = 0;
    char        MsgBuf[1500];
    SOCKADDR_IN senderSockAddr;
    int         nSockAddrSize = sizeof( senderSockAddr );

    BOOL fRet = TRUE;

    //
    //  create socket to listen to name svc responses from the WINS server
    //

    listenNameSvcSock = socket( PF_INET, SOCK_DGRAM, IPPROTO_UDP );
    if ( listenNameSvcSock  == INVALID_SOCKET ) {
        if (pParams->fReallyVerbose)
//IDS_WINS_12406                  "    Failed to create a socket to listen to WINS traffic. Error = %d \n" 
            PrintMessage(pParams, IDS_WINS_12406, WSAGetLastError() );
        return FALSE;
    }

    optionValue = TRUE;
    if ( setsockopt(listenNameSvcSock, SOL_SOCKET, SO_REUSEADDR, (const char *)&optionValue, sizeof(optionValue)) ) {
        if (pParams->fReallyVerbose)
//IDS_WINS_12407                  "    Failed to set the SO_REUSEADDR option for the socket. Error = %d\n" 
            PrintMessage(pParams, IDS_WINS_12407, WSAGetLastError() );
        return FALSE;
    }

    optionValue = FALSE;
    if ( setsockopt(listenNameSvcSock, SOL_SOCKET, SO_BROADCAST, (const char *)&optionValue, sizeof(optionValue)) ) {
        if (pParams->fReallyVerbose)
//IDS_WINS_12408                  "    Failed to set the SO_BROADCAST option for the socket. Error = %d\n" 
            PrintMessage(pParams, IDS_WINS_12408, WSAGetLastError() );
        return FALSE;
    }

    iTimeout = c_iWaitTime;
    if ( setsockopt(listenNameSvcSock, SOL_SOCKET, SO_RCVTIMEO, (char*)&iTimeout, sizeof(iTimeout)))
    {
        if (pParams->fReallyVerbose)
//IDS_WINS_12416                    "    Failed to set the SO_RCVTIMEO option for the socket. Error = %d\n"
            PrintMessage(pParams, IDS_WINS_12416, WSAGetLastError());

        return FALSE;
    }

    sockAddr.sin_family = PF_INET;
    sockAddr.sin_addr.s_addr = INADDR_ANY;
    sockAddr.sin_port = 0;
    RtlZeroMemory( sockAddr.sin_zero, 8 );

    if ( bind(listenNameSvcSock, (LPSOCKADDR )&sockAddr, sizeof(sockAddr)) == SOCKET_ERROR ) {
        if (pParams->fReallyVerbose)
//IDS_WINS_12409                  "\n    Failed to bind the listening socket for the socket. Error = %d\n" 
            PrintMessage(pParams, IDS_WINS_12409, WSAGetLastError() );
        return FALSE;
    }

    //
    //  let's ask the WINS server for our own name
    //

    Probe( pParams, ipAddrStr, listenNameSvcSock );

    nBytesRcvd = recvfrom( listenNameSvcSock, MsgBuf, sizeof(MsgBuf), 0, (LPSOCKADDR )&senderSockAddr, &nSockAddrSize );
    if ( nBytesRcvd == SOCKET_ERROR )
    {
        //since we are sending UDP packets, it's not reliable. Do the query again
        Probe (pParams, ipAddrStr, listenNameSvcSock);
        if (SOCKET_ERROR == recvfrom( listenNameSvcSock, MsgBuf, 
                                sizeof(MsgBuf), 
                                0, 
                                (LPSOCKADDR )&senderSockAddr, 
                                &nSockAddrSize ))
        {
            fRet = FALSE;
        }
    }

    //
    //  final clean up
    //
    closesocket(listenNameSvcSock);
    
    return fRet;
} /* END OF IsNameResponse() */


void WinsGlobalPrint(IN NETDIAG_PARAMS *pParams,
                         IN OUT NETDIAG_RESULT *pResults)
{
}

void WinsPerInterfacePrint(IN NETDIAG_PARAMS *pParams,
                             IN OUT NETDIAG_RESULT *pResults,
                             IN INTERFACE_RESULT *pIfResult)
{
//    PIP_ADAPTER_INFO  pIpAdapter = pIfResult->IpConfig.pAdapterInfo;
//    IP_ADDR_STRING winsSrv;

    if (!pIfResult->IpConfig.fActive ||
        NETCARD_DISCONNECTED == pIfResult->dwNetCardStatus)
        return;

    if (pParams->fVerbose || !FHrOK(pIfResult->Wins.hr))
    {
        PrintNewLine(pParams, 1);
        PrintTestTitleResult(pParams, IDS_WINS_LONG, IDS_WINS_SHORT, pIfResult->Wins.fPerformed, 
                             pIfResult->Wins.hr, 8);
    }

    
    PrintMessageList(pParams, &pIfResult->Wins.lmsgPrimary);

    PrintMessageList(pParams, &pIfResult->Wins.lmsgSecondary);

    if (pIfResult->Wins.fPerformed)
    {
        if (pIfResult->Wins.hr == hrOK)
        {
            if (pParams->fReallyVerbose)
                // IDS_WINS_12413  "            The test was successful, at least one WINS server was found.\n" 
                PrintMessage(pParams, IDS_WINS_12413);
        }
        else
        {
            // IDS_WINS_12414  "            The test failed.  We were unable to query the WINS servers.\n" 
            PrintMessage(pParams, IDS_WINS_12414);
        }
    }
    else if (pParams->fVerbose)
	{
		if (!pIfResult->fNbtEnabled)
		{
			//IDS_WINS_NBT_DISABLED			"            NetBT is disable on this interface. [Test skipped].\n"
			PrintMessage(pParams, IDS_WINS_NBT_DISABLED);
		}
		else
		{
			//IDS_WINS_12415   "            There are no WINS servers configured for this interface.\n"
			PrintMessage(pParams, IDS_WINS_12415);
		}
	}
        
}

void WinsCleanup(IN NETDIAG_PARAMS *pParams,
                         IN OUT NETDIAG_RESULT *pResults)
{
    int i;
    for(i = 0; i < pResults->cNumInterfaces; i++)
    {
        MessageListCleanUp(&pResults->pArrayInterface[i].Wins.lmsgPrimary);
        MessageListCleanUp(&pResults->pArrayInterface[i].Wins.lmsgSecondary);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\strings.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       strings.h
//
//--------------------------------------------------------------------------


#undef CONST_STRING
#undef CONST_STRINGA
#undef CONST_STRINGW

#ifdef _STRINGS_DEFINE_STRINGS

    #define CONST_STRING(rg,s)   const TCHAR rg[] = TEXT(s);
    #define CONST_STRINGA(rg,s) const char rg[] = s;
    #define CONST_STRINGW(rg,s)  const WCHAR rg[] = s;

#else

    #define CONST_STRING(rg,s)   extern const TCHAR rg[];
    #define CONST_STRINGA(rg,s) extern const char rg[];
    #define CONST_STRINGW(rg,s)  extern const WCHAR rg[];

#endif

CONST_STRING(c_szRegKeyControlProductOptions, "System\\CurrentControlSet\\Control\\ProductOptions")
CONST_STRING(c_szRegKeyHotFix, "Software\\Microsoft\\Windows NT\\CurrentVersion\\Hotfix")
CONST_STRING(c_szRegKeyTcpIpParamsInterfaces, "Tcpip\\Parameters\\Interfaces\\")
CONST_STRING(c_szRegKeyWindowsNTCurrentVersion, "Software\\Microsoft\\Windows NT\\CurrentVersion")


CONST_STRING(c_szRegAddressType,		"AddressType")
CONST_STRING(c_szRegCurrentBuild,		"CurrentBuild")
CONST_STRING(c_szRegCurrentBuildNumber,	"CurrentBuildNumber")
CONST_STRING(c_szRegCurrentType,		"CurrentType")
CONST_STRING(c_szRegCurrentVersion,		"CurrentVersion")
CONST_STRING(c_szRegDhcpClassID,		"DhcpClassID")
CONST_STRING(c_szRegDhcpNameServer,		"DhcpNameServer")
CONST_STRING(c_szRegInstalled,			"Installed")
CONST_STRING(c_szRegIPAutoconfigurationEnabled,	"IPAutoconfigurationEnabled")
CONST_STRING(c_szRegNameServer,			"NameServer")

CONST_STRING(c_szRegNetLogonParams, "System\\CurrentControlSet\\Services\\Netlogon\\Parameters")
CONST_STRING(c_szRegSysVolReady, "SysVolReady")
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\xportst.c ===
//++
//
//  Copyright (C) Microsoft Corporation, 1987 - 1999
//
//  Module Name:
//
//      xportst.c
//
//  Abstract:
//
//      Tests for the transports on the local workstation
//
//  Author:
//
//      1-Feb-1998 (karolys)
//
//  Environment:
//
//      User mode only.
//      Contains NT-specific code.
//
//  Revision History:
//
//--


/*==========================< Include files >==============================*/
#include "precomp.h"

#define BUFF_SIZE 650



/*===========================< NetBT vars >===============================*/

#define NETBIOS_NAME_SIZE 16

/*==========================< DHCP Include>==============================*/

#include "dhcptest.h"


/*=======================< Function prototypes >=================================*/

DWORD
OpenDriver(
    OUT HANDLE *Handle,
    IN LPWSTR DriverName
    )
//++
//
// Routine Description:
//
//    This function opens a specified IO drivers.
//
// Arguments:
//
//    Handle - pointer to location where the opened drivers handle is
//        returned.
//
//    DriverName - name of the driver to be opened.
//
// Return Value:
//
//    Windows Error Code.
//--
{

 OBJECT_ATTRIBUTES   objectAttributes;
 IO_STATUS_BLOCK     ioStatusBlock;
 UNICODE_STRING      nameString;
 NTSTATUS            status;

 *Handle = NULL;

 //
 // Open a Handle to the IP driver.
 //

 RtlInitUnicodeString(&nameString, DriverName);

 InitializeObjectAttributes(
     &objectAttributes,
     &nameString,
     OBJ_CASE_INSENSITIVE,
     (HANDLE) NULL,
     (PSECURITY_DESCRIPTOR) NULL
     );

 status = NtCreateFile(
     Handle,
     SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
     &objectAttributes,
     &ioStatusBlock,
     NULL,
     FILE_ATTRIBUTE_NORMAL,
     FILE_SHARE_READ | FILE_SHARE_WRITE,
     FILE_OPEN_IF,
     0,
     NULL,
     0
     );

 return( RtlNtStatusToDosError( status ) );

}



//-------------------------------------------------------------------------//
//######  I s I c m p R e s p o n s e ()  #################################//
//-------------------------------------------------------------------------//
BOOL 
IsIcmpResponseA( 
    LPCSTR  pszIpAddrStr
    ) 
//++
//
//  Routine Description:
//
//      Sends ICMP echo request frames to the IP address specified.
//    
//  Arguments:
//
//      pszIAddrStr - address to ping
//
//  Return Value:
//
//      TRUE:  Test suceeded.
//      FALSE: Test failed
//
//--
{

    char   *SendBuffer, *RcvBuffer;
    int     i, nReplyCnt;
    int     nReplySum = 0;
    HANDLE  hIcmp;
    PICMP_ECHO_REPLY reply;

    //
    //  contact ICMP driver
    //
    hIcmp = IcmpCreateFile();
    if ( hIcmp == INVALID_HANDLE_VALUE ) 
    {
        DebugMessage( "    [FATAL] Cannot get ICMP handle." );
        return FALSE;
    }

    //
    //  prepare buffers
    //
    SendBuffer = Malloc( DEFAULT_SEND_SIZE );
    if ( SendBuffer == NULL ) 
    {
        DebugMessage("    [FATAL] Cannot allocate buffer for the ICMP echo frame." );
        return FALSE;
    }
    ZeroMemory( SendBuffer, DEFAULT_SEND_SIZE );

    RcvBuffer = Malloc( MAX_ICMP_BUF_SIZE );
    if ( RcvBuffer == NULL ) 
    {
        Free( SendBuffer );
        DebugMessage("    [FATAL] Cannot allocate buffer for the ICMP echo frame." );
        return FALSE;
    }
    ZeroMemory( RcvBuffer, MAX_ICMP_BUF_SIZE );

    //
    //  send ICMP echo request
    //
    for ( i = 0; i < PING_RETRY_CNT; i++ ) 
    {
        nReplyCnt = IcmpSendEcho( hIcmp,
                                  inet_addr(pszIpAddrStr),
                                  SendBuffer,
                                  (unsigned short )DEFAULT_SEND_SIZE,
                                  NULL,
                                  RcvBuffer,
                                  MAX_ICMP_BUF_SIZE,
                                  DEFAULT_TIMEOUT
                                );
        //
        //  test for destination unreachables
        //
        if ( nReplyCnt != 0 ) 
        {
            reply = (PICMP_ECHO_REPLY )RcvBuffer;
            if ( reply->Status == IP_SUCCESS ) 
            {
                nReplySum += nReplyCnt;
            }
        }

    } /* for loop */

    //
    //  cleanup
    //
    Free( SendBuffer );
    Free( RcvBuffer );
    IcmpCloseHandle( hIcmp );
    if ( nReplySum == 0 ) 
    { 
        return FALSE; 
    }
    else 
    { 
        return TRUE; 
    }

} /* END OF IsIcmpResponse() */



BOOL 
IsIcmpResponseW( 
    LPCWSTR  pszIpAddrStr
    )
{
    LPSTR   pszAddr = NULL;
    BOOL    fRetval;

    pszAddr = StrDupAFromW(pszIpAddrStr);
    if (pszAddr == NULL)
        return FALSE;

    fRetval = IsIcmpResponseA(pszAddr);

    Free(pszAddr);
    
    return fRetval; 
}






//-------------------------------------------------------------------------//
//######  W S L o o p B k T e s t ()  #####################################//
//-------------------------------------------------------------------------//
//  Abstract:                                                              //
//      Opens a datagram socket and sends a UDP frame through the loopback.//
//      If the frame comes back then Winsock and AFD are most probably OK. //
//  Arguments:                                                             //
//      none                                                               //
//  Return value:                                                          //
//      TRUE  - test passed                                                //
//      FALSE - test failed                                                //
//  Global variables used:                                                 //
//      none                                                               //
//-------------------------------------------------------------------------//
BOOL WSLoopBkTest( PVOID Context ) {

    BOOL   RetVal = TRUE;
    SOCKET tstSock; 
    DWORD  optionValue;     // helper var for setsockopt()
    SOCKADDR_IN sockAddr;   // struct holding source socket info

    //
    //  create a socket
    //
    /*
    tstSock = socket( PF_INET, SOCK_DGRAM, IPPROTO_UDP );
    if ( tstSock  == INVALID_SOCKET ) {
        printf( "    [FATAL] socket creation failed!\n" );
        printf( "    You have a potential Winsock problem!\n" );
        return FALSE;
    }    

    tstSock = WSASocket( PF_INET, 
                         SOCK_DGRAM, 
                         IPPROTO_UDP, 
                         NULL,
                         0,
                         WSA_FLAG_OVERLAPPED 
                       ); 
    if ( tstSock  == INVALID_SOCKET ) {
        printf( "    [FATAL] socket creation failed!\n" );
        printf( "    You have a potential Winsock problem!\n" );
        return FALSE;
    }

    sockAddr.sin_family = PF_INET;
    sockAddr.sin_addr.s_addr = 0;           // use any local address
    sockAddr.sin_port = htons( PORT_4_LOOPBK_TST );
//    RtlZeroMemory( sockAddr.sin_zero, 8 );

    if ( bind(tstSock, (LPSOCKADDR )&sockAddr, sizeof(sockAddr)) == SOCKET_ERROR ) {
        printf( "    [FATAL] bind() failed with error %d!\n", WSAGetLastError() );
        printf( "    You have a potential Winsock problem!\n" );
        return FALSE;
    }
    */





    return RetVal;

    UNREFERENCED_PARAMETER( Context );

} /* END OF WSLoopBkTest() */


    
 



//######################  END OF FILE xportst.c  ##########################//
//-------------------------------------------------------------------------//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netwatch\main.h ===
//  main.h
//
//  Copyright 2000 Microsoft Corporation, all rights reserved
//
//  Created   2-00  anbrad
//

#ifdef _GLOBALS
#define Extern
#define EQ(x) = x
#else
#define Extern extern
#define EQ(x)
#endif

Extern UINT         g_unTimer;
Extern DWORD        g_dwRetryAttempts;
Extern BOOL         g_fTrayPresent;
Extern HINSTANCE    g_hInst;
Extern TCHAR        g_szMsg[1024];
Extern TCHAR        g_szName[64];
Extern TCHAR        g_szProblem[1024];

#define SZ_MAIN_WINDOW_CLASS_NAME   TEXT("BloodhoundCls")
#define SZ_MAIN_WINDOW_TITLE        TEXT("BloodHound Agent")
#define WM_USER_TRAYCALLBACK        (WM_USER+1)

INT_PTR CALLBACK DlgProcMsg(HWND, UINT, WPARAM, LPARAM);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netwatch\main.cpp ===
//  main.cpp
//
//  Copyright 2000 Microsoft Corporation, all rights reserved
//
//  Created   2-00  anbrad
//

#include <shellapi.h>
#include "resource.h"

#include "shelltray.h"
#include "netwatch.h"
#define _GLOBALS
#include "main.h"
#include "update.h"

#define TIMER_NUM           1
#define TIMER_FREQUENCY     5000


LRESULT CALLBACK MainWindowProc (
    HWND    hwnd,
    UINT    unMsg,
    WPARAM  wParam,
    LPARAM  lParam)
{
    BOOL    fDoDefault = FALSE;
    LRESULT lr = 0;

    switch (unMsg)
    {
        case WM_CREATE:
            AddTrayIcon(hwnd);
            StartListening(hwnd);
            break;

        case WM_DESTROY:
            StopCapture();

            RemoveTrayIcon(hwnd);
            if (g_unTimer)
            {
                KillTimer (hwnd, g_unTimer);
                g_unTimer = 0;
            }

            PostQuitMessage (0);
            break;

        case WM_USER_TRAYCALLBACK:
            ProcessTrayCallback(hwnd, wParam, lParam);
            break;

        default:
            fDoDefault = TRUE;
    }

    if (fDoDefault)
    {
        lr = DefWindowProc (hwnd, unMsg, wParam, lParam);
    }

    return lr;
}

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE pPrevInstance, LPSTR lpCmdLine, int nShowCmd)
{
    MSG msg;
    WNDCLASSEX  wcex;

    g_hInst = GetModuleHandle (NULL);

    //
    // Register our window class.
    //
    ZeroMemory (&wcex, sizeof(wcex));
    wcex.cbSize        = sizeof(wcex);
    wcex.style         = CS_HREDRAW | CS_VREDRAW;
    wcex.lpfnWndProc   = MainWindowProc;
    wcex.hInstance     = g_hInst;
    wcex.hCursor       = LoadCursor (NULL, IDC_ARROW);
    wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
    wcex.lpszClassName = SZ_MAIN_WINDOW_CLASS_NAME;

    if (!RegisterClassEx (&wcex))
        return 0;

    if (!CheckForUpdate())
    {
    
        _tcscpy(g_szMsg, "Updating netwatch.exe");

        HWND hDlg = CreateDialog(
                        g_hInst,
                        MAKEINTRESOURCE(IDD_MESSAGE),
                        NULL,
                        DlgProcMsg);

        ShowWindow(hDlg, SW_SHOWNORMAL);

        while (GetMessage (&msg, NULL, 0, 0))
        {
            TranslateMessage (&msg);
            DispatchMessage (&msg);
        }
        return 0;
    }

    // Create our main window.
    //
    HWND hwnd;

    hwnd = CreateWindowEx (
                0,
                SZ_MAIN_WINDOW_CLASS_NAME,
                SZ_MAIN_WINDOW_TITLE,
                WS_OVERLAPPEDWINDOW,
                0, 0, 0, 0,
                NULL, NULL, g_hInst, NULL);
    if (hwnd)
    {
        ShowWindow (hwnd, SW_HIDE);

        // Main message loop.
        //
        while (GetMessage (&msg, NULL, 0, 0))
        {
            TranslateMessage (&msg);
            DispatchMessage (&msg);
        }
    }

    UnregisterClass (SZ_MAIN_WINDOW_CLASS_NAME, g_hInst);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netdiag\xportst.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       xportst.h
//
//--------------------------------------------------------------------------

#ifndef HEADER_XPORTST
#define HEADER_XPORTST

/*=======================< Function prototypes >===========================*/
BOOL WSLoopBkTest( PVOID Context );
BOOL NqTest(PVOID Context);

HRESULT
InitIpconfig(IN NETDIAG_PARAMS *pParams,
			 IN OUT NETDIAG_RESULT *pResults);



/*============================< Constants >================================*/
#define DEFAULT_SEND_SIZE 32
#define MAX_ICMP_BUF_SIZE ( sizeof(ICMP_ECHO_REPLY) + 0xfff7 + MAX_OPT_SIZE )
#define DEFAULT_TIMEOUT   1000L
#define PING_RETRY_CNT    4
#define PORT_4_LOOPBK_TST 3038      

//
//  WINS related constants
//
#define NM_QRY_XID 0x6DFC

#define NBT_NAME_SIZE 32
#define MAX_NBT_PACKET_SIZE 1500

#define NBT_NM_OPC_REQUEST      0x0000
#define NBT_NM_OPC_RESPONSE     0x0080

#define NBT_NM_OPC_QUERY        0x0000
#define NBT_NM_OPC_REGISTRATION 0x0028
#define NBT_NM_OPC_RELEASE      0x0030
#define NBT_NM_OPC_WACK         0x0038
#define NBT_NM_OPC_REFRESH      0x0040

//
//  Name Service Flags
//
#define NBT_NM_FLG_BCAST        0x1000
#define NBT_NM_FLG_RECURS_AVAIL 0x8000   
#define NBT_NM_FLG_RECURS_DESRD 0x0001
#define NBT_NM_FLG_TRUNCATED 0x0002
#define NBT_NM_FLG_AUTHORITATIV 0x0004

//
//  Name Service question types
//
#define NBT_NM_QTYP_NB 0x2000
#define NBT_NM_QTYP_NBSTAT 0x2100

#define NBT_NM_QCLASS_IN 0x0100



/*=====================< type/struct declarations >========================*/
#include "pshpack1.h"

typedef struct {
	WORD  xid;
	WORD  flags;
	WORD  question_cnt;
	WORD  answer_cnt;
	WORD  name_serv_cnt;
	WORD  additional_cnt;
} NM_FRAME_HDR;


typedef struct {
	BYTE q_name[NBT_NAME_SIZE+2];
	WORD q_type;
	WORD q_class;
} NM_QUESTION_SECT;

#include "poppack.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netwatch\dsubmit.h ===
//  dsubmit.h
//
//  Copyright 2000 Microsoft Corporation, all rights reserved
//
//  Created   2-00  anbrad
//

INT_PTR CALLBACK DlgProcSubmit(HWND, UINT, WPARAM, LPARAM);
void CentreWindow(HWND hwnd);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netwatch\dsubmit.cpp ===
//  dsubmit.cpp
//
//  Copyright 2000 Microsoft Corporation, all rights reserved
//
//  Created   2-00  anbrad
//

#include "pch.h"
#pragma hdrstop

#include "dsubmit.h"
#include "resource.h"
#include "main.h"

const DWORD c_cbName = sizeof(g_szName)/sizeof(TCHAR);
const DWORD c_cbProblem = sizeof(g_szProblem)/sizeof(TCHAR);

INT_PTR CALLBACK DlgProcSubmit(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    DWORD cbName = c_cbName;


    switch (msg)
    {
    case WM_INITDIALOG:

        CentreWindow(hwnd);

        SendMessage (GetDlgItem(hwnd, IDC_USER), EM_LIMITTEXT, c_cbName, 0);
        SendMessage (GetDlgItem(hwnd, IDC_PROBLEM), EM_LIMITTEXT, c_cbProblem, 0);

        GetUserName(g_szName, &cbName);

        if (cbName)
        {
            SetDlgItemText(hwnd, IDC_USER, g_szName);
            SetFocus(GetDlgItem(hwnd, IDC_PROBLEM));
            return FALSE;
        }
        return TRUE;

    case WM_COMMAND:
		switch (LOWORD(wParam))
		{
        case IDOK:
            GetDlgItemText(hwnd, IDC_USER, g_szName, c_cbName);
            GetDlgItemText(hwnd, IDC_PROBLEM, g_szProblem, c_cbProblem);
            EndDialog(hwnd, TRUE);
            break;
        case IDCANCEL:
            g_szName[0] = '\0';
            g_szProblem[0] = '\0';

            EndDialog(hwnd, FALSE);
            break;
        }
        return TRUE;
    default:
        return FALSE;
    }
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//
//  CentreWindow
//
//  Positions a window so that it is centered in its parent.
//
//////////////////////////////////////////////////////////////////////////////

void CentreWindow(HWND hwnd)
{
	RECT   rect;
	RECT   rectParent;
	HWND   hwndParent;
	LONG   dx, dy;
	LONG   dxParent, dyParent;
	LONG   Style;

	//
	//  Get window rect.
	//
	GetWindowRect(hwnd, &rect);

	dx = rect.right - rect.left;
	dy = rect.bottom - rect.top;

	//
	//  Get parent rect.
	//
	Style = GetWindowLong(hwnd, GWL_STYLE);
	if ((Style & WS_CHILD) == 0)
	{
		hwndParent = GetDesktopWindow();
	}
	else
	{
		hwndParent = GetParent(hwnd);
		if (hwndParent == NULL)
		{
			 hwndParent = GetDesktopWindow();
		}
	}
	GetWindowRect(hwndParent, &rectParent);

	dxParent = rectParent.right - rectParent.left;
	dyParent = rectParent.bottom - rectParent.top;

	//
	//  Centre the child in the parent.
	//
	rect.left = (dxParent - dx) / 2;
	rect.top	= (dyParent - dy) / 3;

	//
	//  Move the child into position.
	//
	SetWindowPos( hwnd,
				    NULL,
				    rect.left,
				    rect.top,
				    0,
				    0,
				    SWP_NOSIZE | SWP_NOZORDER );

	SetForegroundWindow(hwnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netwatch\msg.cpp ===
//  msg.cpp
//
//  Copyright 2000 Microsoft Corporation, all rights reserved
//
//  Created   2-00  anbrad
//


#include "resource.h"
#include "dsubmit.h"
#include "main.h"

static UINT_PTR uTimer;

INT_PTR CALLBACK DlgProcMsg(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg)
    {
    case WM_INITDIALOG:

        CentreWindow(hwnd);
        SetDlgItemText(hwnd, IDC_MSG, g_szMsg);
        uTimer = SetTimer(hwnd, 1, 1000, NULL);
    
        return TRUE;

    case WM_TIMER:
        KillTimer(hwnd, uTimer);
        PostQuitMessage(0);
        EndDialog(hwnd, 0);
        break;
    default:
        return FALSE;
    };

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netwatch\adapter.h ===
//  adapter.h
//
//  Copyright 2000 Microsoft Corporation, all rights reserved
//
//  Created   2-00  anbrad
//

class CAdapter
{
public:
    CAdapter() :
    m_hBlob (NULL),
    m_pRtc(NULL),
    m_dwLinkSpeed(0),
    m_dwFrames (0),
    m_qBytes (0),
    m_dwHeaderOffset (0),
    m_dwLastTimeStamp(0),
    m_bps(0),
    RawTimeDelta(0),
    m_qLastBitsCount(0)
{
    m_szCaptureFile[0] = '\0';
}

    // We keep all our totals here
    HBLOB   m_hBlob;
    IDelaydC*   m_pRtc;
    BYTE    MacAddress[6];
    DWORD   m_dwLinkSpeed;              //... Link speed in Mbits.

    DWORD   m_dwFrames;
    __int64 m_qBytes;

    TCHAR   m_szCaptureFile[MAX_PATH];
    DWORD   m_dwHeaderOffset;
    hyper   m_dwLastTimeStamp;
    DWORD   m_bps;                  
    hyper   RawTimeDelta;
    hyper   m_qLastBitsCount;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netwatch\netwatch.h ===
//  netwatch.h
//
//  Copyright 2000 Microsoft Corporation, all rights reserved
//
//  Created   2-00  anbrad
//

HRESULT StartListening(HWND hwndParent);
void StartCapture();
void RestartCapture();
void StopCapture();
void SaveCapture();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netwatch\netwatch.cpp ===
//  netwatch.cpp
//
//  Copyright 2000 Microsoft Corporation, all rights reserved
//
//  Created   2-00  anbrad
//

#include "netwatch.h"
#include <shlwapi.h>
#include "main.h"
#include "dsubmit.h"

// NETMON includes
#include "blob.h"
#include "irtc.h"
#include "idelaydc.h"
#include "nmerr.h"

#include "adapter.h"    // CAdapter

static DWORD AddressOffsetTable[] = { 0, 0, 2, 1 };
DWORD WINAPI StatusCallbackProc( UPDATE_EVENT Event );

DWORD m_dwAdapters;
CAdapter* m_pAdapters;

HRESULT StartListening(HWND hwndParent)
{
    HRESULT rc;
    HBLOB   FilterBlob = 0;
    PBLOB_TABLE pBlobTable;

    //
    // Create a netmon blob
    //
    CreateBlob(&FilterBlob);

    //
    // We want realtime data
    //
    if (NOERROR != (rc = SetBoolInBlob( FilterBlob,
                                        OWNER_NPP,
                                        CATEGORY_CONFIG,
                                        TAG_INTERFACE_DELAYED_CAPTURE,
                                        TRUE)))
    {
        return E_FAIL;
    }

    //
    // Get the table of devices we can use
    //
    if (NOERROR != GetNPPBlobTable(
                    FilterBlob,  
                    &pBlobTable))
    {
        return E_FAIL;
    }

    if (pBlobTable->dwNumBlobs < 0)
        return E_FAIL;

    m_dwAdapters = pBlobTable->dwNumBlobs;

    m_pAdapters = new CAdapter[m_dwAdapters];

    if (!m_pAdapters)
        return E_FAIL;

    for (CAdapter* pAdapter = m_pAdapters;
        pAdapter < m_pAdapters + m_dwAdapters;
        ++pAdapter)
    {
    
        // Grab the first one.
        pAdapter->m_hBlob = pBlobTable->hBlobs[pAdapter - m_pAdapters];
    
        if (!SUCCEEDED(rc = CreateNPPInterface(pAdapter->m_hBlob,
                                               IID_IDelaydC,
                                               (LPVOID*) &pAdapter->m_pRtc)))
        {
            return E_FAIL;
        }

        const char* MacType;
        if (NMERR_SUCCESS != GetStringFromBlob(pAdapter->m_hBlob,
                                               OWNER_NPP,
                                               CATEGORY_NETWORKINFO,
                                               TAG_MACTYPE,
                                               &MacType))
        {
            return E_FAIL;
        }

        //
        // Grab the Mac Address
        //
        if (NMERR_SUCCESS != GetMacAddressFromBlob(pAdapter->m_hBlob,
                                                   OWNER_NPP,
                                                   CATEGORY_LOCATION,
                                                   TAG_MACADDRESS,
                                                   pAdapter->MacAddress))
        {
            return E_FAIL;
        }

    }

    // Start the capture
    StartCapture();

    return S_OK;
}

void StartCapture()
{
    DWORD rc;

    NETWORKINFO NetworkInfo;
    HBLOB       hErrorBlob;
    BOOL        WantProtocolInfo = TRUE;
    DWORD       Value = 1;
    BOOL        bRas;

    // initialize the error blob
    CreateBlob(&hErrorBlob);

    for (CAdapter* pAdapter = m_pAdapters;
        pAdapter < m_pAdapters + m_dwAdapters;
        ++pAdapter)
    {
        pAdapter->m_dwFrames = 0;
        pAdapter->m_qBytes   = 0;

        rc = GetBoolFromBlob(
                pAdapter->m_hBlob,
                OWNER_NPP,
                CATEGORY_LOCATION,
                TAG_RAS,
                &bRas);

        if( rc != NMERR_SUCCESS )
        {
            goto START_FAILURE;    
        }

        if (bRas)
            continue;

        //
        // get the networkinfo from the blob that we may need
        //
        rc = GetNetworkInfoFromBlob(pAdapter->m_hBlob, 
                                   &NetworkInfo);

        pAdapter->m_dwLinkSpeed = NetworkInfo.LinkSpeed;
        pAdapter->m_dwHeaderOffset = AddressOffsetTable[NetworkInfo.MacType];
    
        //
        // Set the WantProtocolInfo
        //
        rc  = SetBoolInBlob( pAdapter->m_hBlob,
                             OWNER_NPP,
                             CATEGORY_CONFIG,
                             TAG_WANT_PROTOCOL_INFO,
                             WantProtocolInfo);
        if( rc != NMERR_SUCCESS )
        {
            goto START_FAILURE;    
        }

        //
        // connect to and configure the specified network
        //
        rc = HRESULT_TO_NMERR(pAdapter->m_pRtc->Connect(
                                        pAdapter->m_hBlob,
                                        StatusCallbackProc,
                                        (LPVOID)pAdapter,
                                        hErrorBlob));
        if( rc != NMERR_SUCCESS )
        {
            // the connect failed
            goto START_FAILURE;    
        }

        //
        // start the capture
        //
        rc = HRESULT_TO_NMERR(pAdapter->m_pRtc->Start(pAdapter->m_szCaptureFile));
        if( rc != NMERR_SUCCESS )
        {
            // the start failed
            goto START_FAILURE;    
        }
    }   // for each adapter
START_FAILURE:
    DestroyBlob(hErrorBlob);
}

void SaveCapture()
{
    DWORD rc;
    TCHAR szScratch[MAX_PATH];
    TCHAR szMachine[MAX_COMPUTERNAME_LENGTH+1];
    DWORD dwMachine = MAX_COMPUTERNAME_LENGTH+1;
    TCHAR szFileName[MAX_PATH];
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD dwWritten;
    HBLOB hErrorBlob = NULL;

    CreateBlob(&hErrorBlob);

    ZeroMemory(szMachine, sizeof(szMachine));
    GetComputerName(szMachine, &dwMachine);

    for (CAdapter* pAdapter = m_pAdapters;
        pAdapter < m_pAdapters + m_dwAdapters;
        ++pAdapter)
    {
        if (_tcslen(pAdapter->m_szCaptureFile) == 0)
            continue;

        //
        // copy capture file to 
        // \\scratch\scratch\anbrad\user:MACHINE1 1234.cap
        //
        _tcscpy (szFileName, pAdapter->m_szCaptureFile);
        PathStripPath(szFileName);

        _tcscpy (szScratch, "\\\\scratch\\scratch\\anbrad\\");
        _tcscat (szScratch, g_szName);
        _tcscat (szScratch, " - ");
        _tcscat (szScratch, szMachine);
        _tcscat (szScratch, " ");
        _tcscat (szScratch, szFileName);

        if (!CopyFile(pAdapter->m_szCaptureFile, szScratch, FALSE))
        {
            DWORD dw = GetLastError();
            goto Error;
        }

        //
        // Save the problem
        //

        PathRemoveExtension(szScratch);
        PathAddExtension(szScratch, TEXT(".txt"));
        
        hFile = CreateFile(
                    szScratch,
                    GENERIC_READ | GENERIC_WRITE,
                    0,
                    NULL,
                    CREATE_NEW,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL);

        if (INVALID_HANDLE_VALUE == hFile)
            goto Error;
        
        if (!WriteFile(hFile, g_szProblem, _tcslen(g_szProblem), &dwWritten, NULL))
            goto Error;

        rc = HRESULT_TO_NMERR(pAdapter->m_pRtc->Configure( 
                                pAdapter->m_hBlob,
                                hErrorBlob));

        if( rc != NMERR_SUCCESS )
        {
            // the start failed
            goto Error;
        }

        //
        // start the capture
        //
        rc = HRESULT_TO_NMERR(pAdapter->m_pRtc->Start(pAdapter->m_szCaptureFile));
        if( rc != NMERR_SUCCESS )
        {
            // the start failed
            goto Error;
        }

    }
Error:
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);

    if (hErrorBlob)
        DestroyBlob(hErrorBlob);
    return;
}

void EndCapture()
{
    DWORD rc;
    STATISTICS stats;

    for (CAdapter* pAdapter = m_pAdapters;
        pAdapter < m_pAdapters + m_dwAdapters;
        ++pAdapter)
    {
        //
        // stop capturing                            
        //
        pAdapter->m_pRtc->Stop(&stats);

        // disconnect from the network
        rc = HRESULT_TO_NMERR(pAdapter->m_pRtc->Disconnect());
        if( rc != NMERR_SUCCESS )
        {
            //TRACE("NPPDisconnect failed: %d\n", rc);
        }
    }
}

void StopCapture()
{
    STATISTICS stats;

    for (CAdapter* pAdapter = m_pAdapters;
        pAdapter < m_pAdapters + m_dwAdapters;
        ++pAdapter)
    {
        //
        // stop capturing                            
        //
        pAdapter->m_pRtc->Stop(&stats);
    }
}

void RestartCapture()
{
    DWORD rc;
    HBLOB hErrorBlob = NULL;

    CreateBlob(&hErrorBlob);

    for (CAdapter* pAdapter = m_pAdapters;
        pAdapter < m_pAdapters + m_dwAdapters;
        ++pAdapter)
    {
        rc = HRESULT_TO_NMERR(pAdapter->m_pRtc->Configure( 
                                pAdapter->m_hBlob,
                                hErrorBlob));

        if( rc != NMERR_SUCCESS )
        {
            // the start failed
            goto Error;
        }

        //
        // start the capture
        //
        rc = HRESULT_TO_NMERR(pAdapter->m_pRtc->Start(pAdapter->m_szCaptureFile));
        if( rc != NMERR_SUCCESS )
        {
            // the start failed
            goto Error;
        }

    }

Error:
    if (hErrorBlob)
        DestroyBlob(hErrorBlob);
}

// ----------------------------------------------------------------------------
DWORD WINAPI  StatusCallbackProc( UPDATE_EVENT Event )
{
    CAdapter* pAdapter = (CAdapter*) Event.lpUserContext;

    // we could do stuff here, but what?

    return( NMERR_SUCCESS );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netwatch\pch.cpp ===
//  pch.cpp
//
//  Copyright 2000 Microsoft Corporation, all rights reserved
//
//  Created   2-00  anbrad
//

#include "pch.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netwatch\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by netwatch.rc
//
#define IDI_FACE                        100
#define IDD_MESSAGE                     101
#define IDD_SUBMIT                      102
#define IDC_USER                        103
#define IDC_PROBLEM                     104
#define IDC_STATIC                      -1
#define CMIDM_TRAY_CLOSE                200
#define POPUP_TRAY                      300
#define IDC_MSG                         1000

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netwatch\pch.h ===
//  pch.h
//
//  Copyright 2000 Microsoft Corporation, all rights reserved
//
//  Created   2-00  anbrad
//

#pragma once

// Turns off "string too long - truncated to 255 characters in the debug
// information, debugger cannot evaluate symbol."
//
#pragma warning (disable: 4786)

#include <windows.h>
#include <stdlib.h>
#include <tchar.h>
#include <shellapi.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netwatch\shelltray.cpp ===
//  shelltray.cpp
//
//  Copyright 2000 Microsoft Corporation, all rights reserved
//
//  Created   2-00 -  anbrad
//

#include "main.h"
#include "shelltray.h"

#include "resource.h"
#include "netwatch.h"
#include "dsubmit.h"

void OpenContextMenu(HWND hwnd, POINT * pPoint);
void OnTaskBarIconRButtonUp(HWND hwnd);

//----------------------------------------------------------------------------
// AddTrayIcon
//
void
AddTrayIcon(
    HWND hwnd)
{
    NOTIFYICONDATA  nid;
    HICON           hiconTray = LoadIcon(g_hInst, MAKEINTRESOURCE(IDI_FACE));

    if (hiconTray)
    {
        nid.uID                 = 0;
        nid.cbSize              = sizeof(NOTIFYICONDATA);
        nid.hWnd                = hwnd;
        nid.uCallbackMessage    = WM_USER_TRAYCALLBACK;
        nid.hIcon               = hiconTray;
        nid.uFlags              = NIF_MESSAGE | NIF_ICON | NIF_TIP;

        lstrcpy(nid.szTip, TEXT("Double click to save your network trace."));
    }

    g_fTrayPresent = Shell_NotifyIcon(NIM_ADD, &nid);
}

//----------------------------------------------------------------------------
// RemoveTrayIcon
//
void
RemoveTrayIcon(
    HWND hwnd)
{
    NOTIFYICONDATA  nid;

    if (g_fTrayPresent)
    {
        nid.uID                 = 0;
        nid.cbSize              = sizeof(NOTIFYICONDATA);
        nid.hWnd                = hwnd;
        nid.uCallbackMessage    = WM_USER_TRAYCALLBACK;
        nid.uFlags              = 0;
    }

    g_fTrayPresent = !(Shell_NotifyIcon(NIM_DELETE, &nid));
}

//----------------------------------------------------------------------------
// UpdateTrayIcon
//
void
UpdateTrayIcon(
    HWND hwnd)
{
    NOTIFYICONDATA  nid;

    if (g_fTrayPresent)
    {
        nid.uID                 = 0;
        nid.cbSize              = sizeof(NOTIFYICONDATA);
        nid.hWnd                = hwnd;
        nid.uCallbackMessage    = WM_USER_TRAYCALLBACK;
        nid.uFlags              = NIF_TIP;

        _tcscpy(nid.szTip, TEXT("Double click to save your network trace."));
    }

    Shell_NotifyIcon(NIM_MODIFY, &nid);
}


//----------------------------------------------------------------------------
// ProcessTrayCallback
//
void
ProcessTrayCallback(
    HWND    hwnd,
    WPARAM  wParam, 
    LPARAM  lParam)
{
    UINT uID        = (UINT) wParam;
    UINT uMouseMsg  = (UINT) lParam;
    static bInDialog;


    switch(uMouseMsg)
    {
    case WM_LBUTTONDBLCLK:
        
        if (!bInDialog)
        {
            bInDialog = TRUE;
            StopCapture();

            if (IDOK == DialogBox(
                            g_hInst,
                            MAKEINTRESOURCE(IDD_SUBMIT),
                            NULL,
                            DlgProcSubmit))
            {
                SaveCapture();
            }
            else
            {
                RestartCapture();
            }
        
            bInDialog = FALSE;
        }
        break;

    case WM_RBUTTONUP:
        OnTaskBarIconRButtonUp(hwnd);
        break;
    }
}

void OnTaskBarIconRButtonUp(HWND hwnd)
{
    POINT   pt;

    GetCursorPos(&pt);
    OpenContextMenu(hwnd, &pt);
}

#if (WINVER > 0x0400)
VOID SetIconFocus(HWND hwnd)
{
    NOTIFYICONDATA nid;

    ZeroMemory (&nid, sizeof(nid));
    nid.cbSize  = sizeof(NOTIFYICONDATA);
    nid.hWnd    = hwnd;
    nid.uID     = 0;

//    Shell_NotifyIcon(NIM_SETFOCUS, &nid);
}
#endif

void OpenContextMenu(HWND hwnd, POINT * pPoint)
{
    HRESULT         hr                      = S_OK;
    INT             iCmd                    = 0;
    INT             iMenu                   = 0;
    HMENU           hmenu                   = 0;
    BOOL            fDisconnected           = FALSE;
    INT             iIdCustomMin            = -1;
    INT             iIdCustomMax            = -1;
    BOOL            fBranded                = FALSE;

    // Find the connection info based on the tray icon id.
    //
    hmenu = LoadMenu(g_hInst, MAKEINTRESOURCE(POPUP_TRAY));
    if (hmenu)
    {
        // Get the first menu from the popup. For some reason, this hack is
        // required instead of tracking on the outside menu
        //
        HMENU   hmenuTrack  = GetSubMenu(hmenu, 0);

        // Set the default menu item
        //
        SetMenuDefaultItem(hmenuTrack, CMIDM_TRAY_CLOSE, FALSE);

        // Set the owner window to be foreground as a hack so the
        // popup menu disappears when the user clicks elsewhere.
        //
        SetForegroundWindow(hwnd);

        // Part of the above hack. Bring up the menu and figure out the result
        iCmd = TrackPopupMenu(hmenuTrack, TPM_RETURNCMD | TPM_NONOTIFY | TPM_RIGHTBUTTON,
                              pPoint->x, pPoint->y, 0, hwnd, NULL);
        DestroyMenu(hmenu);

        MSG msgTmp;
        while (PeekMessage(&msgTmp, hwnd, WM_LBUTTONDOWN, WM_LBUTTONUP, PM_REMOVE))
        {
            DispatchMessage(&msgTmp);
        }

        // Process the command
        //
        switch (iCmd)
        {
            case CMIDM_TRAY_CLOSE:
                SendMessage(hwnd, WM_DESTROY, 0, 0);
                break;

            // Tray menu cancelled without selection  
            //
            case 0:     
                break;

            // Unknown command
            //
            default:
                break;
        }

        // Shift the focus back to the shell
        //
#if (WINVER > 0x0400)
        SetIconFocus(hwnd);
#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netwatch\shelltray.h ===
//  shelltray.h
//
//  Copyright 2000 Microsoft Corporation, all rights reserved
//
//  Created   2-00  anbrad
//

void AddTrayIcon(HWND hwnd);
void RemoveTrayIcon(HWND hwnd);
void UpdateTrayIcon(HWND hwnd);
void ProcessTrayCallback(HWND hwnd, WPARAM wParam, LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netwatch\update.cpp ===
//  update.cpp
//
//  Copyright 2000 Microsoft Corporation, all rights reserved
//
//  Created   2-00 -  anbrad
//

#include "update.h"
#include "main.h"
#include <shlwapi.h>

#include "resource.h"

const TCHAR c_szNetwatch[] = TEXT("\\\\scratch\\scratch\\anbrad\\netwatch.exe");


bool WaitForOrigProcess()
{
    DWORD dw;
    LPCTSTR szCmd = GetCommandLine();
    LPCTSTR szSpace;

    szSpace = szCmd;

    while (*szSpace)
    {
        if (*szSpace == ' ')
            break;

        ++szSpace;
    }

    if (*szSpace)
    {
        ++szSpace;

        dw = atol(szSpace);

        WaitForSingleObject ((HANDLE)dw, INFINITE);

        return true;
    }
    return false;   
}

bool CheckForUpdate()
{
    bool rt;
    bool bDel;

    FILETIME ftCurrent;
    FILETIME ftScratch;
    
    WIN32_FIND_DATA ffd;
    HANDLE h = INVALID_HANDLE_VALUE;
    HANDLE hDel = INVALID_HANDLE_VALUE;
    HANDLE hOurProcess = NULL;

    TCHAR szModule[MAX_PATH];
    TCHAR szDeleteModule[MAX_PATH];
    TCHAR szCommand[128];

    bDel = WaitForOrigProcess();

    h = FindFirstFile(c_szNetwatch, &ffd);

    if (INVALID_HANDLE_VALUE == h)
    {
        rt = true;
        goto Exit;
    }

    ftScratch = ffd.ftLastWriteTime;
    
    GetModuleFileName(g_hInst, szModule, sizeof(szModule)/sizeof(TCHAR));

    FindClose(h);
    
    h = FindFirstFile(szModule, &ffd);

    if (INVALID_HANDLE_VALUE == h)
    {
        rt = true;
        goto Exit;
    }


    // netwatch1.exe
    _tcscpy (szDeleteModule, szModule);
    PathRemoveExtension(szDeleteModule);
    _tcscat(szDeleteModule, "1");
    PathAddExtension(szDeleteModule, ".exe");

    if (bDel)
        DeleteFile(szDeleteModule);
    
    ftCurrent = ffd.ftLastWriteTime;

    if ((ftCurrent.dwHighDateTime > ftScratch.dwHighDateTime) ||
        ((ftCurrent.dwHighDateTime == ftScratch.dwHighDateTime) && 
         (ftCurrent.dwLowDateTime >= ftScratch.dwLowDateTime)))
    {
        rt = true;
        goto Exit;
    }

    // If we get here then we need to UPDATE


    // 
    // Rename current file
    //
    if (!MoveFile(szModule, szDeleteModule))
    {
        rt = true;
        goto Exit;
    }

    if (!CopyFile(c_szNetwatch, szModule, TRUE))
    {
        rt = true;
        goto Exit;
    }

    hOurProcess = OpenProcess(SYNCHRONIZE, TRUE, GetCurrentProcessId());

    wsprintf(szCommand, "%s %d", szModule, hOurProcess);


    STARTUPINFO si;
    ZeroMemory(&si, sizeof(si));
    si.cb = sizeof(si);

    PROCESS_INFORMATION pi;
    
    CreateProcess(NULL, szCommand, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi);

     rt = false;
Exit:
    if (INVALID_HANDLE_VALUE != h)
        FindClose(h);

    if (hOurProcess)
        CloseHandle(hOurProcess);

    return rt;    // keep going
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netwatch\update.h ===
//  update.h
//
//  Copyright 2000 Microsoft Corporation, all rights reserved
//
//  Created   2-00  anbrad
//

bool CheckForUpdate();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\wmi\dglogs\dglogscom.h ===
// DglogsCom.h : Declaration of the CDglogsCom

#ifndef __DGLOGSCOM_H_
#define __DGLOGSCOM_H_

#include "dglogsres.h"       // main symbols
#include "DglogsCP.h"
#include "Diagnostics.h"

/////////////////////////////////////////////////////////////////////////////
// CDglogsCom
class ATL_NO_VTABLE CDglogsCom : 
	//public CComObjectRootEx<CComSingleThreadModel>,
    public CComObjectRootEx<CComMultiThreadModelNoCS>,
	public CComCoClass<CDglogsCom, &CLSID_DglogsCom>,
	public IConnectionPointContainerImpl<CDglogsCom>,
	public IDispatchImpl<IDglogsCom, &IID_IDglogsCom, &LIBID_DGLOGSLib>,
	public CProxy_IDglogsComEvents< CDglogsCom >,
    public IProvideClassInfo2Impl<&CLSID_DglogsCom, NULL,&LIBID_DGLOGSLib> 
{
public:
	CDglogsCom();

DECLARE_REGISTRY_RESOURCEID(IDR_DGLOGSCOM)
//DECLARE_REGISTRY_RESOURCEID(IDR_DGNET)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDglogsCom)
	COM_INTERFACE_ENTRY(IDglogsCom)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
	COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IProvideClassInfo2) 
END_COM_MAP()

BEGIN_CONNECTION_POINT_MAP(CDglogsCom)
	CONNECTION_POINT_ENTRY(DIID__IDglogsComEvents)
END_CONNECTION_POINT_MAP()


// IDglogsCom
public:
	STDMETHOD(ExecQuery)(/*[in]*/ BSTR bstrCatagory, /*[in]*/ LONG bFlag, /*[out, retval]*/ BSTR *pbstrResult);
    STDMETHOD(Initialize)(BSTR *pbstrResult);
    STDMETHOD(StopQuery)();
public:
    DWORD        m_dwThreadId;
    CDiagnostics m_Diagnostics;

public:
    HANDLE m_hThreadTerminated;
    HANDLE m_hTerminateThread;
    LONG   m_lThreadCount;
};

#endif //__DGLOGSCOM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\wmi\dglogs\dglogs.cpp ===
// Dglogs.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f Dglogsps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "Dglogs.h"

#include "Dglogs_i.c"
#include "DglogsCom.h"
#include "Diagnostics.h"
#include "dgnet.h"

extern GUID CLSID_Dgnet;

CComModule _Module;

// COM Map takes care of registering the dgnet.dll
// the CDglogsCom and CGotNet are regestered
//
BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_DglogsCom, CDglogsCom)
    OBJECT_ENTRY(CLSID_Dgnet, CGotNet)
END_OBJECT_MAP()

// Global variables
//
HMODULE      g_hModule;

// Netsh functions
//
STDAPI       RegisterhNetshHelper();
STDAPI       UnRegisterNetShHelper();

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_DGLOGSLib);
        DisableThreadLibraryCalls(hInstance);
        g_hModule = (HMODULE) hInstance;        
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // Register with Netsh
    RegisterhNetshHelper();
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    // Unregister from netsh
    UnRegisterNetShHelper();
    return _Module.UnregisterServer(TRUE);
}



STDAPI RegisterhNetshHelper()
{
    HKEY hNetSh;
    long lRet = NOERROR;
    WCHAR szwModule[MAX_PATH];
    HRESULT hr;

    // Open the netsh registry entry
    //
    lRet = RegOpenKey(HKEY_LOCAL_MACHINE,
                      L"SOFTWARE\\Microsoft\\NetSh",
                      &hNetSh);

    if( ERROR_SUCCESS == lRet )
    {
        // Get the dll filename
        //
        if( GetModuleFileName( (HMODULE)g_hModule, szwModule,  MAX_PATH ) )
        {        
            // Add dglogs under netsh
            //
            lRet = RegSetValueEx(hNetSh, 
                                 L"dglogs", 
                                 0, 
                                 REG_SZ, 
                                 (CONST BYTE *)szwModule, 
                                 (lstrlen(szwModule)+1) * sizeof(WCHAR) );
        }

        // Close the regsitry key
        //
        RegCloseKey(hNetSh);
    }

    return lRet == ERROR_SUCCESS ? NOERROR:ERROR;
}


STDAPI UnRegisterNetShHelper()
{
    HKEY hNetSh;
    long lRet = NOERROR;

    // Open the netsh registry entry
    //
    lRet = RegOpenKey(HKEY_LOCAL_MACHINE,
                      L"SOFTWARE\\Microsoft\\NetSh",
                      &hNetSh);

    if( ERROR_SUCCESS == lRet )
    {
        // Delete our entry
        //
        RegDeleteValue(hNetSh,L"dglogs");
        RegCloseKey(hNetSh);
    }

    return lRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\netwatch\version.h ===
//  version.h
//
//  Copyright 2000 Microsoft Corporation, all rights reserved
//
//  Created   2-00  anbrad
//

#pragma once

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_APP
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Net capture Utility"
#define VER_INTERNALNAME_STR            "netwatch.exe"

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\wmi\dglogs\dglogscp.h ===
#ifndef _DGLOGSCP_H_
#define _DGLOGSCP_H_







template <class T>
class CProxy_IDglogsComEvents : public IConnectionPointImpl<T, &DIID__IDglogsComEvents, CComDynamicUnkArray>
{
	//Warning this class may be recreated by the wizard.
public:
	VOID Fire_ProgressReport(BSTR * pbstrMsg, LONG nPercentDone)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[2];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[1] = (BSTR )*pbstrMsg;
				pvars[0] = nPercentDone;
				DISPPARAMS disp = { pvars, NULL, 2, 0 };
				pDispatch->Invoke(0x1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\wmi\dglogs\dglogsnetsh.h ===
/*++

Copyright (c) 1999, Microsoft Corporation

Module Name:

    sample\prstring.h

Abstract:

    The file contains definitions of command line option tag strings.

--*/

#include "stdafx.h"
//#include <netsh.h>
#include <netshp.h>
#include "diagnostics.h"

// context's version
#define DGLOGS_CONTEXT_VERSION          1

// Version number
#define DGLOGS_HELPER_VERSION           1

DWORD WINAPI
InitHelperDllEx(
    IN  DWORD      dwNetshVersion,
    OUT PVOID      pReserved
    );

DWORD 
WINAPI
DglogsStartHelper(
    IN CONST GUID *pguidParent,
    IN DWORD       dwVersion
    );

DWORD
HandleShow(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    );

DWORD
HandleShowGui(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    );

DWORD
HandlePing(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    );

DWORD
HandleConnect(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    );



DWORD
WINAPI
SampleDump(
    IN      LPCWSTR     pwszRouter,
    IN OUT  LPWSTR     *ppwcArguments,
    IN      DWORD       dwArgCount,
    IN      LPCVOID     pvData
    );

////////////////////////////////////////
// TOKENS
////////////////////////////////////////
#define TOKEN_DGLOGS                        L"diag"


////////////////////////////////////////
// Configuration commands
////////////////////////////////////////

// Commands supported by most protocols
//
#define CMD_DUMP                            L"dump"
#define CMD_HELP1                           L"help"
#define CMD_HELP2                           L"?"

// Group Commands
//
#define CMD_GROUP_SHOW                      L"show"
#define CMD_GROUP_PING                      L"ping"
#define CMD_GROUP_CONNECT                   L"connect"

// commands
//
#define CMD_MAIL                            L"mail"
#define CMD_NEWS                            L"news"
#define CMD_PROXY                           L"ieproxy"
#define CMD_OS                              L"os"
#define CMD_COMPUTER                        L"computer"
#define CMD_VERSION                         L"version"
#define CMD_DNS                             L"dns"
#define CMD_GATEWAY                         L"gateway"
#define CMD_DHCP                            L"dhcp"
#define CMD_IP                              L"ip"
#define CMD_WINS                            L"wins"
#define CMD_ADAPTER                         L"adapter"
#define CMD_MODEM                           L"modem"
#define CMD_CLIENT                          L"client"
#define CMD_ALL                             L"all"
#define CMD_TEST                            L"test"
#define CMD_GUI                             L"gui"
#define CMD_LOOPBACK                        L"loopback"
#define CMD_IPHOST                          L"iphost"
#define SWITCH_VERBOSE                      L"/v"
#define SWITCH_PROPERTIES                   L"/p"

// show commands
//
#define CMD_SHOW_MAIL                       CMD_MAIL       //L"show mail"
#define CMD_SHOW_NEWS                       CMD_NEWS       //L"show news"
#define CMD_SHOW_PROXY                      CMD_PROXY      //L"show ieproxy"
#define CMD_SHOW_OS                         CMD_OS         //L"show os"
#define CMD_SHOW_COMPUTER                   CMD_COMPUTER   //L"show computer"
#define CMD_SHOW_VERSION                    CMD_VERSION    //L"show version"
#define CMD_SHOW_DNS                        CMD_DNS        //L"show dns"
#define CMD_SHOW_GATEWAY                    CMD_GATEWAY    //L"show gateway"
#define CMD_SHOW_DHCP                       CMD_DHCP       //L"show dhcp"
#define CMD_SHOW_IP                         CMD_IP         //L"show ip"
#define CMD_SHOW_WINS                       CMD_WINS       //L"show wins"
#define CMD_SHOW_ADAPTER                    CMD_ADAPTER    //L"show adapter"
#define CMD_SHOW_MODEM                      CMD_MODEM      //L"show modem"
#define CMD_SHOW_CLIENT                     CMD_CLIENT     //L"show client"
#define CMD_SHOW_ALL                        CMD_ALL        //L"show all"
#define CMD_SHOW_TEST                       CMD_TEST       //L"show test"
#define CMD_SHOW_GUI                        CMD_GUI        //L"show gui"

// ping commands
//
#define CMD_PING_MAIL                       CMD_MAIL       //L"ping mail"
#define CMD_PING_NEWS                       CMD_NEWS       //L"ping news"
#define CMD_PING_PROXY                      CMD_PROXY      //L"ping ieproxy"
#define CMD_PING_DNS                        CMD_DNS        //L"ping dns"
#define CMD_PING_GATEWAY                    CMD_GATEWAY    //L"ping gateway"
#define CMD_PING_DHCP                       CMD_DHCP       //L"ping dhcp"
#define CMD_PING_IP                         CMD_IP         //L"ping ip"
#define CMD_PING_WINS                       CMD_WINS       //L"ping wins"
#define CMD_PING_ADAPTER                    CMD_ADAPTER    //L"ping adapter"
#define CMD_PING_LOOPBACK                   CMD_LOOPBACK   //L"ping loopback"
#define CMD_PING_IPHOST                     CMD_IPHOST     //L"ping iphost"

// connect commands
//
#define CMD_CONNECT_MAIL                    CMD_MAIL    //L"connect mail"
#define CMD_CONNECT_NEWS                    CMD_NEWS    //L"connect news"
#define CMD_CONNECT_PROXY                   CMD_PROXY   //L"connect ieproxy"
#define CMD_CONNECT_IPHOST                  CMD_IPHOST  //L"connect iphost"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\wmi\dglogs\dglogscom.cpp ===
// DglogsCom.cpp : Implementation of CDglogsCom
#include "stdafx.h"
#include "Dglogs.h"
#include "DglogsCom.h"
#include "Commdlg.h"


// Counts the total number of worker threads running.
//
LONG g_lThreadCount;

/*++

Routine Description
    Collects the diagnostics information that the client requested. A worker thread is spawened so 
    the UI (webpage) does not have to wait for the diagnostics to complete. If the UI waits 
    the web page freezes.

Arguments
    lpParameter -- Pointer to the DglogsCom Object

Return Value
    error code

--*/
DWORD WINAPI DiagnosticsThreadProc(LPVOID lpParameter)
{
    BSTR bstrResult;
    CDglogsCom *pDglogsCom = (CDglogsCom *)lpParameter;
    HRESULT hr;


    // Every thread in COM needs to initialize COM in order to use COM
    //
    hr = CoInitializeEx(NULL,COINIT_MULTITHREADED);
    if( SUCCEEDED(hr) )
    {
        // Tell the Diagnostics object that we are accessing it though COM not netsh
        //
        pDglogsCom->m_Diagnostics.SetInterface(COM_INTERFACE);

        // Tell the Diagnostics object to send status reports to the client
        //
        pDglogsCom->m_Diagnostics.RequestStatusReport(TRUE,pDglogsCom);

        // Execute the clients query
        //
        pDglogsCom->m_Diagnostics.ExecQuery();
        
        // Uniniatlize COM
        //
        CoUninitialize();
    }    

    // do not know how to describe this (yet) 
    //
    SetEvent(pDglogsCom->m_hThreadTerminated);

    // There are 0 local threads.
    //
    pDglogsCom->m_lThreadCount = 0;

    // The thread has completed its work. Thus the thread count is 0 again. (Only one thread at a time
    //
    InterlockedExchange(&g_lThreadCount,0);
    
    ExitThread(0);

    return 0;
}

/*++

Routine Description
    Initialize the COM object and the Diagnostics object

Arguments
    pbstrResult -- Not used

Return Value
    HRESULT

--*/
STDMETHODIMP CDglogsCom::Initialize(BSTR *pbstrResult)
{
    if( _Module.GetLockCount() > 1)
    {
    }

    return S_OK;
}

/*++

Routine Description
    Process the clients request by creating a thread to collect the data,

Arguments
    bstrCatagory -- List of the catagories to collect divided by semicollens i.e. "ieproxy;mail;news;adapter"
    bFlag        -- The actions to perform i.e. PING, SHOW, CONNECT
    pbstrResult  -- Stores the result as an XML string

Return Value
    HRESULT

--*/
STDMETHODIMP CDglogsCom::ExecQuery(BSTR bstrCatagory, LONG bFlag, BSTR *pbstrResult)
{
	
    HANDLE hThread;
    WCHAR szFilename[MAX_PATH+1];
    
    *pbstrResult = NULL;

    // For security reason we can not run inside of internet explorer. Otherwise 
    // someone could create a web page using this active X component and collect
    // the clients info. If IE is renamed to something else other than explorer,exe
    // IE will not run Active X controls or scripts
    if( GetModuleFileName(NULL,szFilename,MAX_PATH) )
    {
        LPWSTR ExeName;
        LONG len = wcslen(szFilename) - wcslen(L"helpctr.exe");
        if( len <= 0 || _wcsicmp(&szFilename[len], L"helpctr.exe") != 0 )
        {            
            // The name of process is not helpctr, refuse to run but do not tell the 
            // user why. 
            *pbstrResult = SysAllocString(ids(IDS_FAILED));                        
            //return E_FAIL;
            return S_FALSE;
        }                
    }
    else
    {        
        // Unable to get process name, fail and abort. Do not provide rason for
        // failure.
        *pbstrResult = SysAllocString(ids(IDS_FAILED));                        
        //return E_FAIL;
        return S_FALSE;
    }   

    // Check if an other thread is already in this function
    //
    if( InterlockedCompareExchange(&g_lThreadCount,1,0) == 0 )
    {

        m_lThreadCount = 1;

        // The information is passed to the thread via gloabl parameters. In the near future it will be passed
        // as parameters.
        //
        m_Diagnostics.SetQuery((WCHAR *)bstrCatagory,bFlag);        

        // In order to cancel the thread we set events. The worker thread checks to see if the main thread
        // has set the cancel event
        //
        m_hThreadTerminated = CreateEvent(NULL, TRUE, FALSE, NULL);
        m_hTerminateThread  = CreateEvent(NULL, TRUE, FALSE, NULL);

        // Set the cancel option so the worker thread can be canceled at any time.
        //
        m_Diagnostics.SetCancelOption(m_hTerminateThread);

        // Create a worker thread to collect the information from WMI.
        //
        hThread = CreateThread(NULL,                    // Security Attributes
                               0,                       // Stack Size
                               DiagnosticsThreadProc,   // Start Proc
                               this,                    // Thread Paramter
                               0,                       // Creation flags
                               &m_dwThreadId            // ID of thethread being created
                               );
    

        if( hThread )
        {
            // We are done with the thread. Close it.
            //
            CloseHandle(hThread);
            *pbstrResult = SysAllocString(ids(IDS_PASSED));
            return S_OK;
        }
        else
        {
            // Could not create the thread. So the thread count is 0 again;
            //
            InterlockedExchange(&g_lThreadCount,0);
            *pbstrResult = SysAllocString(ids(IDS_FAILED));
            return E_FAIL;
        }
    }

    *pbstrResult = SysAllocString(ids(IDS_FAILED));
    return S_FALSE;
}

/*++

Routine Description
    Cancels the worker thread

Arguments

Return Value
    HRESULT

--*/
STDMETHODIMP CDglogsCom::StopQuery()
{   
    // Check if there is a worker thread.
    //
    if( m_lThreadCount )
    {
        // There is a worker thread for this instance. Set an event to tell it to stop processing
        //
        SetEvent(m_hTerminateThread);  

        // If the worker thread is doing an RPC call send the quit message.
        // In theory this should cancel the RPC call
        //
        PostThreadMessage(m_dwThreadId, WM_QUIT, NULL, NULL);

        // Wait until it's terminated
        //
        if (WAIT_OBJECT_0 == WaitForSingleObject(m_hThreadTerminated, 10000))
        {
            ResetEvent(m_hThreadTerminated);
        }
        return S_OK;
    }
    
    return S_FALSE;
}


/*++

Routine Description
    Inialize the COM object

Arguments
    
Return Value
    HRESULT

--*/
CDglogsCom::CDglogsCom()
{    

    if( m_Diagnostics.Initialize(COM_INTERFACE) == FALSE )
    {
        // TODO figure out what error code to return if Inialize fails
        //
        return;
    }

    if( _Module.GetLockCount() == 0)
    {
        g_lThreadCount = 0;
    }   
}


/*++

Routine Description
    Uninialize the COM object

Arguments
    
Return Value
    HRESULT

--*/
CDglogsCom::~CDglogsCom()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\wmi\dglogs\dglogsnetsh.cpp ===
#include "dglogsnetsh.h"
//#include <netsh.h>

// Imported netsh.exe function
//
RegisterHelper22  RegisterHelper2  = NULL;
RegisterContext22 RegisterContext2 = NULL;
PrintMessage22    PrintMessage2    = NULL;


const WCHAR c_szTroublshootCmdLine[] = L"explorer.exe hcp://system/netdiag/dglogs.htm";

//extern CDiagnostics g_Diagnostics;

CDiagnostics * g_pDiagnostics;

static const GUID g_MyGuid = 
{ 0xcc41b21b, 0x8040, 0x4bb0, { 0xac, 0x2a, 0x82, 0x6, 0x23, 0x16, 0x9, 0x40 } };


//
// declare the command structs.  you need to declare the
// structs based on how you will be grouping them.  so,
// for example, the three 'show' commands should be in
// the same struct so you can put them in a single group
//
CMD_ENTRY g_TopLevelCommands[] =
{
    CREATE_CMD_ENTRY(SHOW_GUI, HandleShowGui),
};

// table of SHOW commands
//
static CMD_ENTRY isShowCmdTable[] =
{
    CREATE_CMD_ENTRY(SHOW_MAIL,     HandleShow),
    CREATE_CMD_ENTRY(SHOW_NEWS,     HandleShow),
    CREATE_CMD_ENTRY(SHOW_PROXY,    HandleShow),
    CREATE_CMD_ENTRY(SHOW_VERSION,  HandleShow),
    CREATE_CMD_ENTRY(SHOW_OS,       HandleShow),
    CREATE_CMD_ENTRY(SHOW_COMPUTER, HandleShow),
    CREATE_CMD_ENTRY(SHOW_WINS,     HandleShow),
    CREATE_CMD_ENTRY(SHOW_DNS,      HandleShow),
    CREATE_CMD_ENTRY(SHOW_GATEWAY,  HandleShow),
    CREATE_CMD_ENTRY(SHOW_DHCP,     HandleShow),
    CREATE_CMD_ENTRY(SHOW_IP,       HandleShow),
    CREATE_CMD_ENTRY(SHOW_ADAPTER,  HandleShow),
    CREATE_CMD_ENTRY(SHOW_CLIENT,   HandleShow),
    CREATE_CMD_ENTRY(SHOW_MODEM,    HandleShow),
    CREATE_CMD_ENTRY(SHOW_ALL,      HandleShow),
    CREATE_CMD_ENTRY(SHOW_TEST,     HandleShow),
};

// table of PING commands
//
static CMD_ENTRY isPingCmdTable[] =
{
    CREATE_CMD_ENTRY(PING_MAIL,     HandlePing),
    CREATE_CMD_ENTRY(PING_NEWS,     HandlePing),
    CREATE_CMD_ENTRY(PING_PROXY,    HandlePing),
    CREATE_CMD_ENTRY(PING_WINS,     HandlePing),
    CREATE_CMD_ENTRY(PING_DNS,      HandlePing),
    CREATE_CMD_ENTRY(PING_GATEWAY,  HandlePing),
    CREATE_CMD_ENTRY(PING_DHCP,     HandlePing),
    CREATE_CMD_ENTRY(PING_IP,       HandlePing),
    CREATE_CMD_ENTRY(PING_ADAPTER,  HandlePing),
    CREATE_CMD_ENTRY(PING_LOOPBACK, HandlePing),
    CREATE_CMD_ENTRY(PING_IPHOST,   HandlePing),
};

// table of connect commands
//
static CMD_ENTRY isConnectCmdTable[] =
{
    CREATE_CMD_ENTRY(CONNECT_MAIL,     HandleConnect),
    CREATE_CMD_ENTRY(CONNECT_NEWS,     HandleConnect),
    CREATE_CMD_ENTRY(CONNECT_PROXY,    HandleConnect),
    CREATE_CMD_ENTRY(CONNECT_IPHOST,   HandleConnect),
};


// table of above group commands
//
static CMD_GROUP_ENTRY isGroupCmds[] = 
{
    CREATE_CMD_GROUP_ENTRY(GROUP_SHOW,    isShowCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_PING,    isPingCmdTable),
    CREATE_CMD_GROUP_ENTRY(GROUP_CONNECT, isConnectCmdTable),
};


DWORD WINAPI
InitHelperDllEx(
    IN  DWORD      dwNetshVersion,
    OUT PVOID      pReserved
    )
{
    DWORD  dwSize = 0;
    NS_HELPER_ATTRIBUTES attMyAttributes;
    GUID                 guidNetShGuid = NETSH_ROOT_GUID;
    HMODULE hModule;
    HMODULE hModuleNow;

    hModule = LoadLibrary(L"netsh.exe");

    if( !hModule || hModule != GetModuleHandle(NULL) )
    {
        return FALSE;
    }

    // Load the netsh.exe functions we require.
    //
    RegisterHelper2  = (RegisterHelper22)  GetProcAddress(hModule,"RegisterHelper");
    if( RegisterHelper2 )
    {
        RegisterContext2 = (RegisterContext22) GetProcAddress(hModule,"RegisterContext");
        if( RegisterContext2 )
        {
            PrintMessage2    = (PrintMessage22)    GetProcAddress(hModule,"PrintMessage");                
        }
    }

    if( !PrintMessage2 )
    {
        // If PrintMessage2 failed to load they all failed and we bail.
        //
        return FALSE;
    }

    g_pDiagnostics = new CDiagnostics;

    if( !g_pDiagnostics )
    {
        return FALSE;
    }


    if( g_pDiagnostics->Initialize(NETSH_INTERFACE) == FALSE )
    {
        // TODO figure out what error code to return if Inialize fails
        //
        return FALSE;
    }

    g_pDiagnostics->SetInterface(NETSH_INTERFACE);
    // Register this module as a helper to the netsh root
    // context.
    //
    ZeroMemory( &attMyAttributes, sizeof(attMyAttributes) );
    attMyAttributes.dwVersion          = DGLOGS_HELPER_VERSION;
    attMyAttributes.guidHelper         = g_MyGuid;
    attMyAttributes.pfnStart           = DglogsStartHelper;
    attMyAttributes.pfnStop            = NULL;

    DWORD dwErr = RegisterHelper2( &guidNetShGuid, &attMyAttributes );

    return dwErr;
}


DWORD 
WINAPI
DglogsStartHelper(
    IN CONST GUID *pguidParent,
    IN DWORD       dwVersion
    )
{
    DWORD dwErr = NO_ERROR;
    NS_CONTEXT_ATTRIBUTES attMyAttributes;

    // Initialize
    //
    ZeroMemory(&attMyAttributes, sizeof(attMyAttributes));

    attMyAttributes.pwszContext = TOKEN_DGLOGS;
    attMyAttributes.guidHelper  = g_MyGuid;
    attMyAttributes.dwVersion   = DGLOGS_CONTEXT_VERSION;
    attMyAttributes.dwFlags     = 0;
    attMyAttributes.ulNumTopCmds= sizeof(g_TopLevelCommands)/sizeof(CMD_ENTRY);
    attMyAttributes.pTopCmds    = (CMD_ENTRY (*)[])g_TopLevelCommands;
    attMyAttributes.ulNumGroups = sizeof(isGroupCmds)/sizeof(CMD_GROUP_ENTRY);
    attMyAttributes.pCmdGroups  = (CMD_GROUP_ENTRY (*)[])isGroupCmds;
    attMyAttributes.pfnDumpFn   = SampleDump;

    dwErr = RegisterContext2( &attMyAttributes );
                
    return dwErr;
}


DWORD
HandleShowGui(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
{
    BOOL                fResult     = TRUE;
    STARTUPINFO         si;
    PROCESS_INFORMATION pi;
    WCHAR               szCmdLine[MAX_PATH+1];

    ZeroMemory((LPVOID) &si, sizeof(si));

    si.cb = sizeof(STARTUPINFO);

    // Note, we must do this, since CreateProcess will change this string
    //
    lstrcpyW(szCmdLine, c_szTroublshootCmdLine);

    fResult = CreateProcess(
        NULL,
        szCmdLine,
        NULL,
        NULL,
        FALSE,
        0,
        NULL,
        NULL,
        &si,
        &pi);
    if (fResult)
    {
        CloseHandle(pi.hThread);
        CloseHandle(pi.hProcess);
    }

    return 0;
}

DWORD
HandleShow(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description
    Handles the Show command

Arguments
    none

Return Value
    none

--*/
{
    WCHAR *pszwVerbose = NULL;
    WCHAR *pszwInstance = NULL;
    BOOLEAN bFlags = FLAG_VERBOSE_LOW;

    // Need three arguments (show,netdiag catagory)
    //
    if( lstrcmpi(ppwcArguments[2], CMD_ADAPTER) == 0 ||
        lstrcmpi(ppwcArguments[2], CMD_MODEM)   == 0 ||
        lstrcmpi(ppwcArguments[2], CMD_CLIENT)  == 0 ||
        lstrcmpi(ppwcArguments[2], CMD_WINS)    == 0 ||
        lstrcmpi(ppwcArguments[2], CMD_DHCP)    == 0 ||
        lstrcmpi(ppwcArguments[2], CMD_DNS)     == 0 ||
        lstrcmpi(ppwcArguments[2], CMD_IP)      == 0 ||
        lstrcmpi(ppwcArguments[2], CMD_GATEWAY) == 0 )
    {
        switch(dwArgCount)
        {
        case 5:
            if( lstrcmpi(ppwcArguments[3],SWITCH_VERBOSE) == 0 ||
                lstrcmpi(ppwcArguments[3],SWITCH_PROPERTIES) == 0 )
            {
                // Has first the switch then the instance
                //
                pszwVerbose = ppwcArguments[3];
                pszwInstance = ppwcArguments[4];
            }
            else if( lstrcmpi(ppwcArguments[4],SWITCH_VERBOSE) == 0 ||
                     lstrcmpi(ppwcArguments[4],SWITCH_PROPERTIES) == 0 )
            {
                // Has first the instance and then the switch
                //
                pszwVerbose = ppwcArguments[4];
                pszwInstance = ppwcArguments[3];                
            }
            else
            {
                // Invalid number of arguments
                //
                return ERROR_INVALID_SYNTAX;
            }
            break;

        case 4:
            if( lstrcmpi(ppwcArguments[3],SWITCH_VERBOSE) == 0 ||
                lstrcmpi(ppwcArguments[3],SWITCH_PROPERTIES) == 0)
            {
                pszwVerbose = ppwcArguments[3];
            }
            else 
            {
                // Has na instance but no swicth
                //
                pszwInstance = ppwcArguments[3];       
                
            }
            break;

        case 3:
            // No instance and no switch
            //
            break;

        default:
                // Invalid number of arguments
                //
                return ERROR_INVALID_SYNTAX;

        }
    }
    else if( dwArgCount == 4 && 
             (lstrcmpi(ppwcArguments[3],SWITCH_VERBOSE) == 0 ||
              lstrcmpi(ppwcArguments[3],SWITCH_PROPERTIES) == 0))
    {
                // Has a switch
                //
                pszwVerbose = ppwcArguments[3];
    }
    else if( dwArgCount == 4 && lstrcmpi(ppwcArguments[3],SWITCH_PROPERTIES) == 0)
    {
                // Has a switch
                //
                pszwVerbose = ppwcArguments[3];
    }
    else if( dwArgCount != 3 )
    {
        // Invalid number of arguments
        //
        return ERROR_INVALID_SYNTAX;
    }

    if( pszwVerbose )
    {
        if( lstrcmpi(pszwVerbose,SWITCH_VERBOSE) == 0 )
        {
            bFlags = FLAG_VERBOSE_HIGH;
        }

        if( lstrcmpi(pszwVerbose,SWITCH_PROPERTIES) == 0 )
        {
            bFlags = FLAG_VERBOSE_MEDIUM;
        }
    }

                        
    g_pDiagnostics->ExecQuery(ppwcArguments[2], (bFlags | FLAG_CMD_SHOW) ,pszwInstance);

    return 0;
}

DWORD
HandlePing(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description
    Handles the Ping command

Arguments
    none

Return Value
    none

--*/

{

    WCHAR *pszwInstance = NULL;

    // ERROR_INVALID_SYNTAX;

    if( lstrcmpi(ppwcArguments[2],CMD_ADAPTER) == 0 ||
        lstrcmpi(ppwcArguments[2],CMD_WINS)    == 0 ||
        lstrcmpi(ppwcArguments[2],CMD_DHCP)    == 0 ||
        lstrcmpi(ppwcArguments[2],CMD_DNS)     == 0 ||
        lstrcmpi(ppwcArguments[2],CMD_IP)      == 0 ||
        lstrcmpi(ppwcArguments[2],CMD_GATEWAY) == 0 )
    {
        switch(dwArgCount)
        {
        case 4:
            pszwInstance = ppwcArguments[3];
            break;
        case 3:
            break;
        default:
            // Invalid number of arguments
            //
            return ERROR_INVALID_SYNTAX;
        }
    }
    else if( lstrcmpi(ppwcArguments[2], CMD_IPHOST) == 0 )        
    {
        if( dwArgCount == 4 )
        {
            // The IP host name/Address
            //
            pszwInstance = ppwcArguments[3];
        }
        else
        {
            // Invalid number of arguments
            //
            return ERROR_INVALID_SYNTAX;
        }
    }
    else if( dwArgCount != 3 )
    {
        // Invalid number of arguments
        //
        return ERROR_INVALID_SYNTAX;
    }

    // Ping the catagory
    //
    g_pDiagnostics->ExecQuery(ppwcArguments[2], (FLAG_VERBOSE_MEDIUM | FLAG_CMD_PING) ,pszwInstance);

    return 0;
}

DWORD
HandleConnect(
    IN      LPCWSTR   pwszMachine,
    IN OUT  LPWSTR   *ppwcArguments,
    IN      DWORD     dwCurrentIndex,
    IN      DWORD     dwArgCount,
    IN      DWORD     dwFlags,
    IN      LPCVOID   pvData,
    OUT     BOOL     *pbDone
    )
/*++

Routine Description
    Handles the connect command

Arguments
    none

Return Value
    none

--*/

{

    WCHAR *pszwIPHost = NULL;
    WCHAR *pszwPort = NULL;    
    
    if( lstrcmpi(ppwcArguments[2],CMD_IPHOST) == 0 )    
    {
        // IPhost
        //
        if( dwArgCount == 5 )
        {
            // IP host name/Address
            //
            pszwIPHost = ppwcArguments[3];
            pszwPort = ppwcArguments[4];
        }
        else
        {
            // Invalid number of arguments
            //
            return ERROR_INVALID_SYNTAX;
        }
    }
    else if( dwArgCount != 3 )
    {
        // Invalid number of arguments
        //
        return ERROR_INVALID_SYNTAX;
    }

    // Establish the TCP connection
    //
    g_pDiagnostics->ExecQuery(ppwcArguments[2], (FLAG_VERBOSE_MEDIUM | FLAG_CMD_CONNECT) ,pszwIPHost, pszwPort);

    return 0;
}

DWORD
WINAPI
SampleDump(
    IN      LPCWSTR     pwszRouter,
    IN OUT  LPWSTR     *ppwcArguments,
    IN      DWORD       dwArgCount,
    IN      LPCVOID     pvData
    )
/*++

Routine Description
    No Idea what this function is for, but it looks like I need it for something

Arguments
    none

Return Value
    none

--*/

{   
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\wmi\dglogs\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\wmi\dglogs\diagnostics.h ===
#include "stdafx.h"
#include "WmiGateway.h"
#include "util.h"

#ifndef DIAGNOSTICS_H
#define DIAGNOSTICS_H


class CDglogsCom;

// Field types. Describes the field
//
#define TYPE_PING             0x01
#define TYPE_CONNECT          0x02
#define TYPE_SUBNET           0x04
#define TYPE_TEXT             0x08
#define TYPE_HIDE             0x10
#define TYPE_IP               0x20



// Flags indicating what type of data should be displayed
//
#define FLAG_VERBOSE_LOW      0x01
#define FLAG_VERBOSE_MEDIUM   0x02
#define FLAG_VERBOSE_HIGH     0x04
#define FLAG_CMD_PING         0x08
#define FLAG_CMD_SHOW         0x10
#define FLAG_CMD_CONNECT      0x20



#define CMD_SHOW        0x01
#define CMD_PING        0x02
#define CMD_CONNECT     0x04

class CDiagnostics
{
public:

BOOL
IsInvalidIPAddress(
    IN LPCSTR pszHostName
    );

BOOL
IsInvalidIPAddress(
    IN LPCWSTR pszHostName
    );


inline BOOL ShouldTerminate();

void SetCancelOption(HANDLE hTerminateThread)
{
    m_hTerminateThread = hTerminateThread;
    m_bTerminate;
}
void CDiagnostics::ClearQuery();
private:
    HANDLE m_hTerminateThread;
    BOOL m_bTerminate;
    wstring m_wstrCatagories;
private:
void 
CDiagnostics::FillIcmpData(
    IN OUT CHAR  *pIcmp, 
    IN     DWORD dwDataSize
    );
DWORD 
CDiagnostics::DecodeResponse(
    IN  PCHAR  pBuf, 
    IN  int    nBytes,
    IN  struct sockaddr_in *pFrom,
    IN  int nIndent
    );
USHORT 
CDiagnostics::CheckSum(
    IN USHORT *pBuffer, 
    IN DWORD dwSize
    );

int 
CDiagnostics::Ping(
    IN  LPCTSTR pszwHostName, 
    IN int nIndent
    );

int 
CDiagnostics::Ping2(WCHAR *warg);

void
CDiagnostics::print_statistics(  );

BOOL
CDiagnostics::Connect(
    IN LPCTSTR pszwHostName,
    IN DWORD dwPort
    );

public:
    CDiagnostics();

    BOOLEAN m_bAdaterHasIPAddress;

    void SetMachine(WCHAR *pszMachine)
    {
        m_WmiGateway.SetMachine(pszMachine);
    }
    wstring &CDiagnostics::Escape(LPCTSTR pszw);

    void    SetInterface(INTERFACE_TYPE bInterface);
    BOOLEAN Initialize(INTERFACE_TYPE bInterface);
    void    SetQuery(WCHAR *pszwCatagory = NULL, BOOL bFlag = NULL, WCHAR *pszwParam1 = NULL, WCHAR *pszwParam2 = NULL);
    BOOLEAN ExecQuery(WCHAR *pszwCatagory = NULL, BOOL bFlag = NULL, WCHAR *pszwParam1 = NULL, WCHAR *pszwParam2 = NULL);
    BOOLEAN ExecClientQuery(WCHAR *pszwInstance);
    BOOLEAN ExecModemQuery(WCHAR *pszwInstance);
    BOOLEAN RemoveInvalidAdapters(EnumWbemProperty & PropList);
    BOOLEAN ExecAdapterQuery(WCHAR *pszwInstance);
    BOOLEAN ExecDNSQuery(WCHAR *pszwInstance);
    BOOLEAN ExecIPQuery(WCHAR *pszwInstance);
    BOOLEAN ExecWinsQuery(WCHAR *pszwInstance);
    BOOLEAN ExecGatewayQuery(WCHAR *pszwInstance);
    BOOLEAN ExecDhcpQuery(WCHAR *pszwInstance);
    BOOLEAN ExecComputerQuery();
    BOOLEAN ExecOSQuery();
    BOOLEAN ExecVersionQuery();
    BOOLEAN ExecProxyQuery();
    BOOLEAN ExecNewsQuery();
    BOOLEAN ExecMailQuery();    
    BOOLEAN ExecLoopbackQuery();
    BOOLEAN CDiagnostics::ExecIPHost(WCHAR *pszwHostName,WCHAR *pszwHostPort);

    BOOLEAN IsLocked()
    {
        
    }

    WCHAR m_wszCaption[MAX_PATH*10];
    _bstr_t m_bstrCaption;

    template<class t>
    WCHAR * GetCaption(list<t> &l, DWORD nInstance)
    {
        list<t>::iterator iter;

        if( lstrcmp((WCHAR *)m_bstrCaption, L"") != 0 )
        {
            return (WCHAR *)m_bstrCaption;
        }

        for( iter = l.begin(); iter != l.end(); iter++)
        {
            if( lstrcmp(iter->pszwName,m_pszwCaption) == 0 )            
            {
                if( iter->bFlags & TYPE_TEXT )
                {
                    return m_pszwCaption;
                }

                if( nInstance < iter->Value.size() )
                {
                    
                    return iter->Value[nInstance].bstrVal;                    
                }
                return NULL;
            }        
        }
        return NULL;
    }


    template<class t>
    DWORD GetNumberOfInstances(list<t> &l)
    {
        list<t>::iterator iter;
        if( l.empty() )
        {
            return 0;
        }

        iter = l.begin();
        return iter->Value.size();
    }

    template<class t>
    BOOLEAN FormatEnum(list<t> &l, WCHAR *pszwInstance = NULL, BOOLEAN bPass = 2)
    {
        WCHAR *pszwCaption = NULL; 
        list<t>::iterator iter;
        WCHAR szwStatus[MAX_PATH];
        LONG nPercent;
        m_nIndex = 0;
        m_nInstance = GetNumberOfInstances(l);
        m_bCaptionDisplayed = FALSE;
    
        m_bHeaderStatus = 2;
        m_bValueStatus = 2;
        m_bCaptionStatus = bPass;

        if( ShouldTerminate() ) return FALSE;

        lstrcmp(szwStatus,L"");

        if( !m_WmiGateway.m_wstrWbemError.empty() )
        {
            XMLHeader(TRUE,m_szwHeader,ids(IDS_WMIERROR),m_szwCategory);
            NetShHeader(TRUE,m_szwHeader,ids(IDS_WMIERROR));

            XMLCaption(TRUE,NULL);
            NetShCaption(TRUE,NULL);

            XMLField(TRUE,NULL);   
            NetShField(TRUE,NULL);   
    
            if( (m_bFlags & FLAG_VERBOSE_LOW)==0 )
            {
                XMLProperty(TRUE,(WCHAR *)m_WmiGateway.m_wstrWbemError.c_str());
                NetShProperty(TRUE,(WCHAR *)m_WmiGateway.m_wstrWbemError.c_str());
            }

            XMLProperty(FALSE,NULL);    
            NetShProperty(FALSE,NULL);    

            XMLField(FALSE,NULL);        
            NetShField(FALSE,NULL);

            XMLCaption(FALSE);
            NetShCaption(FALSE);

            XMLHeader(FALSE,ids(IDS_FAILED));
            NetShHeader(FALSE,ids(IDS_FAILED));

            return FALSE;
        }
        if( m_nInstance <= 1 )
        {
             pszwCaption = GetCaption(l,0);
        }

        XMLHeader(TRUE,m_szwHeader,pszwCaption,m_szwCategory);
        NetShHeader(TRUE,m_szwHeader,pszwCaption);
    
        if( m_nCatagoriesRequested && m_nInstance)
        {
            nPercent = 97/(m_nCatagoriesRequested * m_nInstance);
        }
        else
        {
            nPercent = 3;
        }
        m_bHeaderStatus = bPass; //2;

        for( DWORD i = 0; i < m_nInstance; i++)
        {   
            m_bCaptionStatus = 2;
            if( ShouldTerminate() ) return FALSE;
            ReportStatus(m_szwHeader,nPercent);
            m_nIndex++;

            FormatInstance(l, i,pszwInstance);

            m_bCaptionDisplayed = FALSE;
        }

        if( m_bHeaderStatus == TRUE )
        {
            lstrcpy(szwStatus,ids(IDS_PASSED));
        }
        else
        if( m_bHeaderStatus == FALSE )
        {
            lstrcpy(szwStatus,ids(IDS_FAILED));
        }
        else
        {
            lstrcpy(szwStatus,L"");                
        }


        XMLHeader(FALSE,szwStatus);
        NetShHeader(FALSE,szwStatus);

        return TRUE;
    }

    template<class t>
    BOOLEAN FormatInstance(list<t> &l, DWORD nInstance, WCHAR *pszwInstance)
    {
        list<t>::iterator iter;
        WCHAR *pszwCaption = GetCaption(l,nInstance);
        WCHAR   szwStatus[MAX_PATH] = L"";                

        m_bAdaterHasIPAddress = FALSE;
        for( iter = l.begin(); iter != l.end(); iter++)
        {
            if( lstrcmp(iter->pszwName,L"IPAddress") == 0 )
            {
                int nIndex = 0;
                _bstr_t bstr;
                while( SUCCEEDED(GetVariant(iter->Value[nInstance],nIndex,bstr)) && m_bAdaterHasIPAddress == FALSE)
                {
                    if( lstrcmp((WCHAR *)bstr,L"0.0.0.0") != 0 && lstrcmp((WCHAR *)bstr,L"") != 0)
                    {                        
                        m_bAdaterHasIPAddress = TRUE;
                    }
                    nIndex++;
                }                    
            }
        }

        //m_bAdaterHasIPAddress = FALSE;

        m_bCaptionStatus = 2;

        if( pszwInstance )
        {
            if( IsNumber(pszwInstance) )
            {
                if( m_nIndex != wcstol(pszwInstance,NULL,10) )
                {
                    return 2;
                }
            }
            else
            if( !IsContained(pszwCaption,pszwInstance) )
            {
                return 2;
            }
        }

        if( m_bFlags & FLAG_VERBOSE_LOW )
        {
            XMLCaption(TRUE,pszwCaption);
            NetShCaption(TRUE,pszwCaption);
        }
        else
        {
            for( iter = l.begin(); iter != l.end(); iter++)
            {        
                m_bFieldStatus = 2;

                if( ShouldTerminate() ) return FALSE;

                if( iter->bFlags & TYPE_TEXT )
                {
                    XMLCaption(TRUE,pszwCaption);
                    XMLField(TRUE,NULL);   
                    XMLProperty(TRUE,iter->pszwName);
                    XMLProperty(FALSE,NULL);    
                    XMLField(FALSE,NULL);

                    NetShCaption(TRUE,pszwCaption);
                    NetShField(TRUE,NULL);   
                    NetShProperty(TRUE,iter->pszwName);
                    NetShProperty(FALSE,NULL);    
                    NetShField(FALSE,NULL);
                }
                else 
                if( nInstance < iter->Value.size() && Filter(iter->Value[nInstance],iter->bFlags) )
                {
                    XMLCaption(TRUE,pszwCaption);
                    NetShCaption(TRUE,pszwCaption);
                    XMLField(TRUE,iter->pszwName);                
                    NetShField(TRUE,iter->pszwName);

                    FormatProperty(l,nInstance,iter->Value[nInstance], iter->bFlags);

                    switch(m_bFieldStatus)
                    {
                    case TRUE:
                        lstrcpy(szwStatus,ids(IDS_PASSED));
                        break;

                    case FALSE:
                        lstrcpy(szwStatus,ids(IDS_FAILED));                
                        break;
                    default:
                        lstrcpy(szwStatus,L"");
                        break;
                    }

                    XMLField(FALSE,szwStatus);
                    NetShField(FALSE,szwStatus);
                }
            }
        }

        if( m_bCaptionStatus == TRUE )
        {
            lstrcpy(szwStatus,ids(IDS_PASSED));                
        }
        else if( m_bCaptionStatus == FALSE )
        {
            lstrcpy(szwStatus,ids(IDS_FAILED));                
        }
        else
        {
            lstrcpy(szwStatus,L"");                
        }

    
        XMLCaption(FALSE,szwStatus);
        NetShCaption(FALSE,szwStatus);

        return 0;
    }


    template<class t>
    BOOLEAN FormatProperty(list<t> &l, DWORD nInstance, _variant_t &vValue, BOOLEAN bFlags)
    {
        _bstr_t bstrValue;
        LPCTSTR pszwData = NULL;
        LPCTSTR pszwComment = NULL;
        WCHAR   szwStatus[MAX_PATH];
        WCHAR   szwComment[MAX_PATH];
        DWORD   nIndex = 0;
        INT nValue =0;
        //BOOLEAN bStatus = 2;    

        while( SUCCEEDED(GetVariant(vValue,nIndex++,bstrValue)) )
        {
            nValue++;
            m_bValueStatus = 2;

            if( ShouldTerminate() ) return FALSE;
            pszwData = NULL;
            lstrcpy(szwStatus,L"");
            lstrcpy(szwComment,L"");

            if( lstrcmp((WCHAR *)bstrValue,L"") == 0)
            {
                bstrValue = ids(IDS_EMPTY);
                NetShProperty(TRUE,bstrValue,szwComment);
            }
            else
            {
                if( ((bFlags & TYPE_SUBNET) || (bFlags & TYPE_PING)) && IsInvalidIPAddress((WCHAR*)bstrValue))
                {
                    // Should we report an error i.e. invalid IP address?
                    //
                    lstrcpy(szwComment,ids(IDS_INVALIDIP));
                    NetShProperty(TRUE,bstrValue,szwComment);
                }
                else
                {
                    if( (bFlags & TYPE_SUBNET) )
                    {
                        if( IsSameSubnet(Get(l,L"IPAddress",nInstance),Get(l,L"IPSubnet",nInstance),(WCHAR *)bstrValue) )
                        {
                            lstrcpy(szwComment,ids(IDS_SAMESUBNET));
                        }
                        else
                        {
                            lstrcpy(szwComment,ids(IDS_DIFFERENTSUBNET));
                        }
                    }
                    NetShProperty(TRUE,bstrValue,szwComment);
                    if( (bFlags & TYPE_PING) && (m_bFlags & FLAG_CMD_PING))
                    {
                        if( IsInvalidIPAddress((WCHAR*)bstrValue) )
                        {
                            lstrcpy(szwComment,ids(IDS_INVALIDIP));
                        }
                        else
                        {
                            WCHAR szw[MAX_PATH];
                            wsprintf(szw,ids(IDS_PINGING_STATUS),(WCHAR *)bstrValue);
                            ReportStatus(szw,0);
                            if( Ping2(bstrValue) )
                            {                  
                                m_bHeaderStatus   = m_bHeaderStatus == FALSE ? FALSE : TRUE;
                                m_bCaptionStatus  = m_bCaptionStatus == FALSE ? FALSE : TRUE;
                                m_bFieldStatus    = m_bFieldStatus == FALSE ? FALSE : TRUE;
                                m_bValueStatus    = TRUE;
                            }
                            else
                            {
                                m_bHeaderStatus   = FALSE;
                                m_bCaptionStatus  = FALSE;
                                m_bFieldStatus    = FALSE;
                                m_bValueStatus    = FALSE;   
                            }
                            pszwData = m_wstrPing.c_str();
                        }
                    }
                }
            }
       
            if( m_bValueStatus == TRUE )
            {
                lstrcpy(szwStatus,ids(IDS_PASSED));                
            }
            else if( m_bValueStatus == FALSE )
            {
                lstrcpy(szwStatus,ids(IDS_FAILED));                
            }
            else
            {
                lstrcpy(szwStatus,L"");                
            }

            XMLProperty(TRUE,bstrValue,pszwData,szwComment);
            XMLProperty(FALSE,szwStatus);
            NetShProperty(FALSE,szwStatus);

        }

        if( nValue == 0 ) 
        {
            NetShProperty(TRUE,ids(IDS_EMPTY),L"");
            NetShProperty(FALSE,L"");
        }

        return 0; //bStatus;
    }

    template<class t>
    void HideAll(list<t> &l)
    {
        list<t>::iterator iter;

        for(iter = l.begin(); iter != l.end(); iter++)
        {
            iter->bFlags = TYPE_HIDE;
        }

    }

    BOOLEAN FormatPing(WCHAR * pszwText);

    BOOLEAN GetXMLResult(BSTR *pbstr);
    BOOLEAN Filter(_variant_t &vValue, BOOLEAN bFlags);

    void RequestStatusReport(BOOLEAN bReportStatus, CDglogsCom *pDglogsCom)
    {
        m_bReportStatus = bReportStatus;
        m_pDglogsCom = pDglogsCom;
    }

    void ReportStatus(LPCTSTR pszwMsg, LONG lValue);

    ~CDiagnostics();

public:
    wstring         m_wstrXML;
    wstring         m_wstrText;
    wstring         m_wstrPing;

private:
    wstring         m_wstrEscapeXml;
    INTERFACE_TYPE  m_bInterface;
    CWmiGateway     m_WmiGateway;
    WCHAR *         m_pszwCaption;
    WCHAR           m_szwHeader[MAX_PATH * 10];
    WCHAR           m_szwCategory[MAX_PATH * 10];
    BOOLEAN         m_bCaptionDisplayed;
    DWORD           m_nInstance;
    BOOLEAN         m_bStatus;

private:
    PWCHAR      m_pszwCatagory;
    BOOL        m_bFlags;
    PWCHAR      m_pszwParam1;
    PWCHAR      m_pszwParam2;

public:
    CDglogsCom *m_pDglogsCom;

private:
    void EventCall(LPCTSTR pszwStatusReport, LONG lPercent);

private:
    BOOLEAN         m_IsNetdiagDisplayed;
    BOOLEAN         m_IsContainerDisplayed;
    BOOLEAN         m_IsPropertyListDisplayed;
    BOOLEAN         m_IsPropertyDisplayed;
    BOOLEAN         m_IsValueDisplayed;
    DWORD           m_nPropertyLegth;
    DWORD           m_nValueIndex;
    DWORD           m_nIndent;
    DWORD           m_nIndex;
    BOOLEAN         m_bReportStatus;
    WCHAR           m_szwStatusReport[MAX_PATH * 10];
    LONG            m_lTotalWork;
    LONG            m_lWorkDone;
    LONG            m_nCatagoriesRequested;

    BOOLEAN         m_bHeaderStatus;
    BOOLEAN         m_bCaptionStatus;
    BOOLEAN         m_bFieldStatus;
    BOOLEAN         m_bPropertyStatus;
    BOOLEAN         m_bValueStatus;


private:

    void XMLNetdiag(BOOLEAN bStartTag, LPCTSTR pszwValue = NULL);
    void XMLHeader(BOOLEAN bStartTag, WCHAR *pszwHeader = NULL, WCHAR *pszwCaption = NULL, WCHAR *pszwCategory = NULL);
    void XMLCaption(BOOLEAN bStartTag, WCHAR *pszwCaption = NULL);
    void XMLField(BOOLEAN bStartTag, WCHAR *pszwField = NULL);
    void XMLProperty(BOOLEAN bStartTag, WCHAR *pszwProperty = NULL, LPCTSTR pszwData = NULL, LPCTSTR pszwComment = NULL);
    
private:
    void NetShNetdiag(BOOLEAN bStartTag, LPCTSTR pszwValue = NULL);
    void NetShHeader(BOOLEAN bStartTag,LPCTSTR pszwValue = NULL,LPCTSTR pszwCaption = NULL);
    void NetShCaption(BOOLEAN bStartTag,LPCTSTR pszwValue = NULL);
    void NetShField(BOOLEAN bStartTag,LPCTSTR pszwValue = NULL);
    void NetShProperty(BOOLEAN bStartTag,LPCTSTR pszwValue = NULL,LPCTSTR pszwComment = NULL,BOOL bFlags = 0);





};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\wmi\dglogs\network.h ===
#include "stdafx.h"

int 
Ping(
    IN LPCTSTR pszwHostName, 
    IN int     nIndent
    );

BOOL
Connect(
    IN LPCTSTR pszwHostName,
    IN DWORD   dwPort
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\wmi\dglogs\network.cpp ===
#include "network.h"
#include "diagnostics.h"
#include "util.h"

//SOCKET sockRaw = INVALID_SOCKET;

#define DEF_PACKET_SIZE 32
#define MAX_PACKET      1024
#define ICMP_ECHO       8
#define ICMP_ECHOREPLY  0
#define ICMP_MIN        8 // minimum 8 byte icmp packet (just header)

// ICMP header
//
typedef struct _ihdr {
  BYTE   i_type;
  BYTE   i_code;      // type sub code
  USHORT i_cksum;
  USHORT i_id;
  USHORT i_seq;
  ULONG  timestamp;   // This is not the std header, but we reserve space for time
}IcmpHeader;

// The IP header
//
typedef struct iphdr {
    unsigned int   h_len:4;          // length of the header
    unsigned int   version:4;        // Version of IP
    unsigned char  tos;              // Type of service
    unsigned short total_len;        // total length of the packet
    unsigned short ident;            // unique identifier
    unsigned short frag_and_flags;   // flags
    unsigned char  ttl; 
    unsigned char  proto;            // protocol (TCP, UDP etc)
    unsigned short checksum;         // IP checksum
    unsigned int   sourceIP;
    unsigned int   destIP;

}IpHeader;

void 
CDiagnostics::FillIcmpData(
    IN OUT CHAR  *pIcmp, 
    IN     DWORD dwDataSize
    )
/*++

Routine Description
    Creates a ICMP packet by filling in the fields of a passed in structure

Arguments
    pIcmp      Pointer to an ICMP buffer
    dwDataSize Size of the buffer

Return Value
    none

--*/
{
  IcmpHeader *pIcmpHdr;
  PCHAR pIcmpData;

  pIcmpHdr = (IcmpHeader*)pIcmp;

  // Fill in the IMCP buffer
  //
  pIcmpHdr->i_type = ICMP_ECHO;
  pIcmpHdr->i_code = 0;
  pIcmpHdr->i_id = (USHORT)GetCurrentProcessId();
  pIcmpHdr->i_cksum = 0;
  pIcmpHdr->i_seq = 0;

  // Append the size of the ICMP packet
  //
  pIcmpData = pIcmp + sizeof(IcmpHeader);

  // Place some junk in the buffer.
  //
  memset(pIcmpData,'E', dwDataSize - sizeof(IcmpHeader));
}

DWORD 
CDiagnostics::DecodeResponse(
    IN  PCHAR  pBuf, 
    IN  int    nBytes,
    IN  struct sockaddr_in *pFrom,
    IN  int nIndent
    ) 
/*++

Routine Description
    The response is an IP packet. We must decode the IP header to locate 
    the ICMP data 

Arguments
    pBuf    Pointer to the recived IP packet
    nBytes  Size of the recived buffer
    pFrom   Information about who the packet is from
    nIndent How much to indent the text by

Return Value
    none

--*/
{
    IpHeader *pIphdr;
    IcmpHeader *pIcmphdr;
    USHORT uIphdrLength;

    pIphdr = (IpHeader *)pBuf;

    // number of 32-bit words *4 = bytes
    //
    uIphdrLength = pIphdr->h_len * 4 ; 
         
    if ( nBytes  < uIphdrLength + ICMP_MIN)
    {
        // Invalid length
        //
        return ERROR_INVALID_DATA;
    }

    // Extract the ICMP header
    //
    pIcmphdr = (IcmpHeader*)(pBuf + uIphdrLength);

    if (pIcmphdr->i_type != ICMP_ECHOREPLY)
    {
        // Invalid type
        //
        return ERROR_INVALID_DATA;
    }
    
    if (pIcmphdr->i_id != (USHORT)GetCurrentProcessId())
    {
        // Invalid process ID
        //
        return ERROR_INVALID_DATA;
    }


    WCHAR szw[5000];

    wsprintf(szw,ids(IDS_PING_PACKET),nBytes,inet_ntoa(pFrom->sin_addr),pIcmphdr->i_seq,GetTickCount() - pIcmphdr->timestamp);
    FormatPing(szw);

    return S_OK;
}


USHORT 
CDiagnostics::CheckSum(
    IN USHORT *pBuffer, 
    IN DWORD dwSize
    ) 
/*++

Routine Description
    Computes the checksum for the packet

Arguments
    pBuffer Buffer containing the packet
    dwSize  Size of the buffer

Return Value
    Checksum value

--*/
{

  DWORD dwCheckSum=0;

  while(dwSize >1) 
  {
    dwCheckSum+=*pBuffer++;
    dwSize -= sizeof(USHORT);
  }
  
  if( dwSize ) 
  {
    dwCheckSum += *(UCHAR*)pBuffer;
  }

  dwCheckSum = (dwCheckSum >> 16) + (dwCheckSum & 0xffff);
  dwCheckSum += (dwCheckSum >>16);

  return (USHORT)(~dwCheckSum);
}


BOOL
CDiagnostics::IsInvalidIPAddress(
    IN LPCWSTR pszHostName
    )
{
    CHAR szIPAddress[MAX_PATH];

    if( lstrlen(pszHostName) > 255 )
    {
        return TRUE;
    }
    for(INT i=0; pszHostName[i]!=L'\0'; i++)
    {
        szIPAddress[i] = pszHostName[i];
    }
    szIPAddress[i] = 0;
    return IsInvalidIPAddress(szIPAddress);
}

BOOL
CDiagnostics::IsInvalidIPAddress(
    IN LPCSTR pszHostName
    )
/*++

Routine Description
    Checks to see if an IP Host is a in valid IP address
        0.0.0.0 is not valid
        255.255.255.255 is not valid
        "" is not valid

Arguments
    pszHostName  Host Address

Return Value
    TRUE   Is invalid IP address
    FALSE  Valid IP address

--*/
{
    BYTE bIP[4];
    int iRetVal;
    LONG lAddr;

    if( NULL == pszHostName || strcmp(pszHostName,"") == 0 || strcmp(pszHostName,"255.255.255.255") ==0)
    {
        // Invalid IP Host
        //
        return TRUE;
    }


    lAddr = inet_addr(pszHostName);

    if( INADDR_NONE != lAddr )
    {
        // Formatted like an IP address X.X.X.X
        //
        if( lAddr == 0 )
        {
            // Invalid IP address 0.0.0.0
            //
            return TRUE;
        }
    }
    
    return FALSE;
}

int 
CDiagnostics::Ping(
    IN  LPCTSTR pszwHostName, 
    IN int nIndent
    )
/*++

Routine Description
    Pings a host

Arguments
    pszwHostName Host to ping
    nIndent      How much to indent when displaying the ping text

Return Value
    TRUE   Successfully pinged
    FALSE  Failed to ping

--*/
{
    SOCKET sockRaw;
    DWORD dwTimeout;
    struct sockaddr_in dest,from;
    hostent * pHostent;
    DWORD dwRetVal;
    int lDataSize, lFromSize = sizeof(from);
    CHAR bIcmp[MAX_PACKET], bRecvbuf[MAX_PACKET];
    CHAR szAscii[MAX_PATH + 1];
    BOOL bPinged = TRUE;
    WCHAR szw[5000];

    sockRaw = INVALID_SOCKET;

    FormatPing(NULL);

    // Convert the wide string into a char string, the winsock functions can not handle wchar stuff
    //
    if( !wcstombs(szAscii,pszwHostName,MAX_PATH) )
    {
        // Could not convert the string from wide char to char, might be empty, thus invalid IP
        //
        wsprintf(szw,ids(IDS_INVALID_IP),pszwHostName);
        FormatPing(szw);
        return FALSE;
    }

    // Check if the IP address is pingable
    //
    if( IsInvalidIPAddress(szAscii) )
    {
        // We refuse to waste time on ping the IP address
        //

        wsprintf(szw,ids(IDS_INVALID_IP),pszwHostName);
        FormatPing(szw);
        return FALSE;
    }
    

    // Create a winsock socket
    //
    sockRaw = WSASocket(AF_INET,
                        SOCK_RAW,
                        IPPROTO_ICMP,
                        NULL, 
                        0,
                        WSA_FLAG_OVERLAPPED);    

    if( INVALID_SOCKET == sockRaw )
    {
        // Unable to create socket
        //
        wsprintf(szw,ids(IDS_SOCKET_CREATE_FAIL));
        FormatPing(szw);
        return FALSE;
    }

    // Set recieve timeout to 1 second
    //
    dwTimeout = 1000;
    dwRetVal = setsockopt(sockRaw,
                          SOL_SOCKET,
                          SO_RCVTIMEO,
                          (char*)&dwTimeout,
                          sizeof(dwTimeout));

    if( SOCKET_ERROR  == dwRetVal )
    {
        // Unable to set socket options
        //
        wsprintf(szw,ids(IDS_SOCKET_CREATE_FAIL));
        FormatPing(szw);
        closesocket(sockRaw);
        sockRaw = INVALID_SOCKET;
        return FALSE;
    }

    // Set send timeout to one second
    //
    dwTimeout = 1000;
    dwRetVal = setsockopt(sockRaw,
                        SOL_SOCKET,
                        SO_SNDTIMEO,
                        (char*)&dwTimeout,
                        sizeof(dwTimeout));

    if( SOCKET_ERROR  == dwRetVal )
    {
        // Unable to set socket options
        //
        wsprintf(szw,ids(IDS_SOCKET_CREATE_FAIL));
        FormatPing(szw);
        sockRaw = INVALID_SOCKET;
        closesocket(sockRaw);
        return FALSE;
    }

    // Set the destination info
    //
    memset(&dest, 0, sizeof(dest));

    dest.sin_family = AF_INET;
    pHostent = gethostbyname(szAscii); 
    
    if( !pHostent )
    {
        // Unable to resolve name
        //
        wsprintf(szw,ids(IDS_RESOLVE_NAME_FAIL));
        FormatPing(szw);
        closesocket(sockRaw);
        sockRaw = INVALID_SOCKET;
        return FALSE;
    }

    // Create the ICMP packet
    //
    ULONG ulAddr;

    memcpy(&ulAddr,pHostent->h_addr,pHostent->h_length);
    dest.sin_addr.s_addr = ulAddr;


    lDataSize = DEF_PACKET_SIZE;
    lDataSize += sizeof(IcmpHeader);  


    // Fill the ICMP packet
    //
    FillIcmpData(bIcmp,lDataSize);

    int nFailPingCount = 0;

    // Send four ICMP packets and wait for a response
    //
    for(DWORD dwPacketsSent = 0; dwPacketsSent < 4; dwPacketsSent++)
    {     
        int nWrote, nRead;

        if( ShouldTerminate() ) goto end;
        // Fillin the ICMP header
        //
        ((IcmpHeader*)bIcmp)->i_cksum = 0;
        ((IcmpHeader*)bIcmp)->timestamp = GetTickCount();

        ((IcmpHeader*)bIcmp)->i_seq = (USHORT) dwPacketsSent;
        ((IcmpHeader*)bIcmp)->i_cksum = CheckSum((USHORT*)bIcmp,lDataSize);

        // Send the ICMP packet
        //
        nWrote = sendto(sockRaw,
                        bIcmp,
                        lDataSize,
                        0,
                        (struct sockaddr*)&dest,
                        sizeof(dest));

        if( SOCKET_ERROR == nWrote )
        {
            // Unable to send packet
            //
            nFailPingCount++;
            bPinged = FALSE;
            wsprintf(szw,ids(IDS_SEND_FAIL),dwPacketsSent);
            FormatPing(szw);
            continue;
        }

        BOOLEAN bTryAgain = FALSE;
        do
        {

            bTryAgain = FALSE;

            if( ShouldTerminate() ) goto end;
            // Recive the packet
            //
            nRead = recvfrom(sockRaw,
                             bRecvbuf,
                             MAX_PACKET,
                             0,
                             (struct sockaddr*)&from,
                             (int *)&lFromSize);

            if( nRead != SOCKET_ERROR && lFromSize!=0 && memcmp(&dest.sin_addr,&from.sin_addr,sizeof(IN_ADDR))!=0 )
            {
                // This is not who we sent the packet to.
                // try again.
                //
                bTryAgain = TRUE;
            }
        }
        while(bTryAgain);

        if( ShouldTerminate() ) goto end;

        if (nRead == SOCKET_ERROR)
        {
            // Did not receive response
            //
            bPinged = FALSE;
            nFailPingCount++;
            wsprintf(szw,ids(IDS_UNREACHABLE));
            FormatPing(szw);
            continue;
        }

        if (S_OK != DecodeResponse(bRecvbuf, nRead, &from,nIndent))
        {
            nFailPingCount++                ;
            bPinged = FALSE;
            wsprintf(szw,ids(IDS_UNREACHABLE));
            FormatPing(szw);
            continue;
        }
    }
end:
    // Close the socket
    //
    if( sockRaw != INVALID_SOCKET )
    {
        closesocket(sockRaw);
    }

    return nFailPingCount == 0 ? TRUE:FALSE;
}

BOOL
CDiagnostics::Connect(
    IN LPCTSTR pszwHostName,
    IN DWORD dwPort
    )
/*++

Routine Description
    Establish a TCP connect

Arguments
    pszwHostName Host to ping
    dwPort       Port to connect to

Return Value
    TRUE   Successfully connected
    FALSE  Failed to establish connection

--*/

{
    SOCKET s;
    SOCKADDR_IN sAddr;
    CHAR szAscii[MAX_PATH + 1];
    hostent * pHostent;


    // Create the socket
    //
    s = socket(AF_INET, SOCK_STREAM, PF_UNSPEC);
    if (INVALID_SOCKET == s)
    {
        return FALSE;
    }

    // Bind this socket to the server's socket address
    //
    memset(&sAddr, 0, sizeof (sAddr));
    sAddr.sin_family = AF_INET;
    sAddr.sin_port = htons((u_short)dwPort);
    
    wcstombs(szAscii,(WCHAR *)pszwHostName,MAX_PATH);
    pHostent = gethostbyname(szAscii); 
    
    if( !pHostent )
    {
        return FALSE;
    }

    // Set the destination info
    //
    ULONG ulAddr;

    memcpy(&ulAddr,pHostent->h_addr,pHostent->h_length);
    sAddr.sin_addr.s_addr = ulAddr;

    // Attempt to connect
    //
    if (connect(s, (SOCKADDR*)&sAddr, sizeof(SOCKADDR_IN)) == 0)
    {
        // Connection succeded
        //
        closesocket(s);
        return TRUE;
    }
    else
    {
        // Connection failed
        //
        closesocket(s);
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\wmi\dglogs\oe.h ===
#include <initguid.h>
#include <oaidl.h>
#include <imnact.h>     // account manager stuff
#include <imnxport.h>
#include <msident.h>

HRESULT GetOEDefaultMailServer2(OUT INETSERVER & rInBoundServer,
                                OUT DWORD      & dwInBoundMailType,
                                OUT INETSERVER & rOutBoundServer,
                                OUT DWORD      & dwOutBoundMailType);


HRESULT GetOEDefaultNewsServer2(OUT INETSERVER & rNewsServer);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\wmi\dglogs\diagnostics.cpp ===
#include "diagnostics.h"
//#include <netsh.h>
#include <netshp.h>
#include "Dglogs.h"
#include "DglogsCom.h"
#include "Commdlg.h"
#include "oe.h"

extern PrintMessage22 PrintMessage2;

#undef PrintMessage
#define PrintMessage PrintMessage2


// Wbem Repositories
//
#define TXT_WBEM_REP_CIMV2     L"\\root\\cimv2"

// Wbem Namespaces
//
#define TXT_WBEM_NS_COMPUTER   L"win32_computersystem"
#define TXT_WBEM_NS_OS         L"win32_operatingsystem"
#define TXT_WBEM_NS_NETWORK    L"win32_networkadapterconfiguration"
#define TXT_WBEM_NS_CLIENT     L"win32_networkclient"
#define TXT_WBEM_NS_WMI        L"win32_wmisetting"
#define TXT_WBEM_NS_NETDIAG    L"netdiagnostics"
#define TXT_WBEM_NS_MODEM      L"win32_potsmodem"

// Captions for the different catagories
//
#define TXT_ADAPTER_CAPTION    L"Caption"
#define TXT_CLIENT_CAPTION     L"Name"
#define TXT_MAIL_CAPTION       L"InBoundMailServer"
#define TXT_NEWS_CAPTION       L"NewsServer"
#define TXT_PROXY_CAPTION      L"IEProxy"
#define TXT_COMPUTER_CAPTION   L"Caption"
#define TXT_OS_CAPTION         L"Caption"
#define TXT_VERSION_CAPTION    L"Version"
#define TXT_MODEM_CAPTION      L"Caption"
#define TXT_LOOPBACK_CAPTION   L"Loopback"


enum MAIL_TYPE
{
    MAIL_NONE,
    MAIL_SMTP,
    MAIL_SMTP2,
    MAIL_IMAP,
    MAIL_POP3,
    MAIL_HTTP,
};


/*++

Routine Description
    The worker thread uses this function to check if the main thread has canceled the worker thread.
    i.e. the work thread should abort what ever it is doing, clean up and terminate.

Arguments
    none

Return Value
    TRUE the worker thread has been terminated
    FALSE the worker thread has not been terminated

--*/
inline BOOL CDiagnostics::ShouldTerminate()
{
    if( m_bTerminate )
    {
        // The worker thread already has been canceled.
        //
        return TRUE;
    }

    if (WaitForSingleObject(m_hTerminateThread, 0) == WAIT_OBJECT_0)
    {
        // Worker thread has been canceled
        //
        m_bTerminate = FALSE;
        return TRUE;
    }
    else
    {
        // Worker thread has not yet been canceled.
        //
        return FALSE;
    }
}

/*++

Routine Description
    Initialize the Diagnostics Object

Arguments
    none

Return Value

--*/
CDiagnostics::CDiagnostics()
{
    m_bFlags  = 0;
    m_bInterface = NO_INTERFACE;
    lstrcpy(m_szwStatusReport,L"");
    m_bReportStatus = FALSE;
    m_lWorkDone = 0;
    m_lTotalWork = 0;
    ClearQuery();
}

/*++

Routine Description
    Uniniailize the Diagnostics object

Arguments
    none

Return Value

--*/
CDiagnostics::~CDiagnostics()
{
    // Close the winsock
    //
    WSACleanup();
}

/*++

Routine Description
    Set the interface i.e. Netsh or COM

Arguments
    bInterface -- Interface used to access the data

Return Value

--*/
void CDiagnostics::SetInterface(INTERFACE_TYPE bInterface) 
{ 
    m_bInterface = bInterface; 
}

/*++

Routine Description
    Iniatilze the Diagnostics object

Arguments
    

Return Value
    TRUE -- Successfully 
    else FALSE
--*/
BOOLEAN CDiagnostics::Initialize(INTERFACE_TYPE bInterface)
{
    int iRetVal;
    WSADATA wsa;

    m_bInterface = bInterface;

    // Initialize the WmiGateway object
    //
    if( FALSE == m_WmiGateway.WbemInitialize(bInterface) )
    {
        return FALSE;
    }

    // Initialize Winsock
    //
    iRetVal = WSAStartup(MAKEWORD(2,1), &wsa);
    if( iRetVal )
    {
        return FALSE;
    }
    
    return TRUE;
}

/*++

Routine Description
    Sends an event to client informing the client of its progress.

Arguments
    pszwStatusReport -- Message telling the client what it CDiagnostics is currently doing
    lPercent         -- A percentage indicating its progress.

Return Value
    error code

--*/
void CDiagnostics::EventCall(LPCTSTR pszwStatusReport, LONG lPercent)
{
    if( m_pDglogsCom )
    {
        // Alocate memory for the message and send it to the client
        //
        BSTR bstrResult = SysAllocString(pszwStatusReport);
        m_pDglogsCom->Fire_ProgressReport(&bstrResult,lPercent);
    }
}

/*++

Routine Description
    Sends an event to client informing the client of its progress.

Arguments
    pszwMsg -- Message telling the client what it CDiagnostics is currently doing
    lValue  -- A percentage indicating its progress.

Return Value
    void

Note: 
    If lValue is -1 then send the finished message

--*/
void CDiagnostics::ReportStatus(LPCTSTR pszwMsg, LONG lValue)
{
    // Check if the client requested the Status report option
    //
    if( m_bReportStatus )
    {
        if( lValue == -1 )
        {
            // Send the finished message. 100% complete and the final XML result
            //
            EventCall(ids(IDS_FINISHED_STATUS), 100);
            EventCall(pszwMsg, lValue);
            m_lWorkDone = 0;
            m_lTotalWork = 0;
        }
        else
        {
            // Compute the total percentage completed. Make sure we never go over 100%
            //
            m_lWorkDone += m_lWorkDone+lValue < 100?lValue:0;
            EventCall(pszwMsg, m_lWorkDone);
        }
    }
}

/*++

Routine Description
    Counts the occurance of chars in a string

Arguments
    pszw -- String to search
    c  -- Char to count the occurnce of

Return Value
    number of time c occured in pszw

Note: 
    If lValue is -1 then send the finished message

--*/
int wcscount(LPCTSTR pszw, WCHAR c)
{
    int n =0;
    for(int i=0; pszw[i]!=L'\0'; i++)
    {
        if( pszw[i] == c )
        {
            if( i > 0 && pszw[i-1]!=c) n++;
        }
    }
    return n;
}

/*++

Routine Description
    Set the query information

Arguments
    pszwCatagory -- Catagory
    bFlag --  Flags (Show, PING, Connect)
    pszwParam1 -- Instance | iphost
    pszwParam2 -- Port number

Return Value
    void

--*/
void CDiagnostics::SetQuery(WCHAR *pszwCatagory, BOOL bFlag, WCHAR *pszwParam1, WCHAR *pszwParam2)
{
    if( pszwCatagory )
    {
        // Set the catagory. Need to make a copy of the Catagory since the string might disapper i.e. threads
        //
        m_wstrCatagories = pszwCatagory;
        m_pszwCatagory = (PWCHAR)m_wstrCatagories.c_str();
    }

    if( bFlag )
    {
        m_bFlags = bFlag;
    }

    if( pszwParam1 )
    {
        m_pszwParam1 = pszwParam1;
    }

    if( pszwParam2 )
    {
        m_pszwParam2 = pszwParam2;
    }
}


/*++

Routine Description
    Clears the Set query information

Arguments
    void 

Return Value
    void

--*/
void CDiagnostics::ClearQuery()
{

    m_pszwCatagory = NULL;
    m_bFlags = NULL;
    m_pszwParam1 = NULL;
    m_pszwParam2 = NULL;
}

/*++

Routine Description
    Execute the query

Arguments 

Return Value
    void

--*/
BOOLEAN CDiagnostics::ExecQuery(WCHAR *pszwCatagory, BOOL bFlags, WCHAR *pszwParam1, WCHAR *pszwParam2)
{
    WCHAR *pszw;
    BOOL bAll = FALSE;

    SetQuery(pszwCatagory,bFlags,pszwParam1,pszwParam2);
    m_WmiGateway.SetCancelOption(m_hTerminateThread);

    m_bTerminate = FALSE;
    m_lWorkDone = 0;
    m_lTotalWork = 0;

    m_bstrCaption = L"";

    if( m_pszwParam1 && !wcsstr(m_pszwParam1,L"*") )
    {
        if( m_bFlags & FLAG_VERBOSE_LOW )
        {
            m_bFlags &= ~FLAG_VERBOSE_LOW;
            m_bFlags |=  FLAG_VERBOSE_MEDIUM;
        }
    }

    if( !m_pszwCatagory )
    {
        ClearQuery();
        return FALSE;
    }

    ReportStatus(ids(IDS_COLLECTINGINFO_STATUS),3);
           
    if( wcsstr(m_pszwCatagory,L"test") )
    {
        if( (m_bFlags & FLAG_VERBOSE_LOW) )
        {
            m_bFlags &= ~FLAG_CMD_SHOW;
        }
        else
        {
            m_bFlags |= FLAG_CMD_SHOW;
        }
        if( m_bFlags & FLAG_VERBOSE_LOW )
        {
            m_bFlags &= ~FLAG_VERBOSE_LOW;
            m_bFlags |=  FLAG_VERBOSE_MEDIUM;
        }
        m_bFlags |= FLAG_CMD_PING | FLAG_CMD_CONNECT;
        bAll = TRUE;
    }

    if( wcsstr(m_pszwCatagory,L"all") )
    {
        bAll = TRUE;
    }

    pszw = new WCHAR[lstrlen(m_pszwCatagory) + 3];
    if( !pszw )
    {
        ClearQuery();
        return FALSE;
    }

    wsprintf(pszw,L";%s;",m_pszwCatagory);
    ToLowerStr(pszw);

    m_nCatagoriesRequested = wcscount(pszw,L';') - 1;

    XMLNetdiag(TRUE);
    NetShNetdiag(TRUE);

    if( ShouldTerminate() ) goto End;
    if( wcsstr(pszw,L";iphost;") )
    {
        ExecIPHost(m_pszwParam1,m_pszwParam2);
    }

    if( ShouldTerminate() ) goto End;
    if( bAll || wcsstr(pszw,L";mail;") )
    {
        ExecMailQuery();
    }

    if( ShouldTerminate() ) goto End;
    if( bAll || wcsstr(pszw,L";news;") )
    {
        ExecNewsQuery();
    }

    if( ShouldTerminate() ) goto End;
    if( bAll || wcsstr(pszw,L";ieproxy;") )
    {
        ExecProxyQuery();
    }

    if( ShouldTerminate() ) goto End;
    if( bAll || wcsstr(pszw,L";loopback;") )
    {
        ExecLoopbackQuery();
    }

    if( ShouldTerminate() ) goto End;
    if( bAll || wcsstr(pszw,L";computer;") )
    {
        ExecComputerQuery();
    }

    if( ShouldTerminate() ) goto End;
    if( bAll || wcsstr(pszw,L";os;") )
    {
        ExecOSQuery();
    }

    if( ShouldTerminate() ) goto End;
    if( bAll || wcsstr(pszw,L";version;") )
    {
        ExecVersionQuery();
    }

    if( ShouldTerminate() ) goto End;
    if( bAll || wcsstr(pszw,L";modem;") )
    {
        ExecModemQuery(m_pszwParam1);
    }

    if( ShouldTerminate() ) goto End;
    if( bAll || wcsstr(pszw,L";adapter;")  )
    {
        ExecAdapterQuery(m_pszwParam1);
    }

    {
        BOOL bFlagSave = m_bFlags;
        m_bFlags &= ~FLAG_VERBOSE_LOW;
        m_bFlags &= ~FLAG_VERBOSE_HIGH;
        m_bFlags |= FLAG_VERBOSE_MEDIUM;
        
        if( ShouldTerminate() ) goto End;
        if( wcsstr(pszw,L";dns;")  )
        {
            ExecDNSQuery(m_pszwParam1);
        }

        if( ShouldTerminate() ) goto End;
        if( wcsstr(pszw,L";gateway;")  )
        {
            ExecGatewayQuery(m_pszwParam1);
        }

        if( ShouldTerminate() ) goto End;
        if( wcsstr(pszw,L";dhcp;")  )
        {
            ExecDhcpQuery(m_pszwParam1);
        }

        if( ShouldTerminate() ) goto End;
        if( wcsstr(pszw,L";ip;") )
        {
            ExecIPQuery(m_pszwParam1);
        }

        if( ShouldTerminate() ) goto End;
        if( wcsstr(pszw,L";wins;") )
        {
            ExecWinsQuery(m_pszwParam1);
        }
        m_bFlags = bFlagSave;
    }


    if( ShouldTerminate() ) goto End;
    if( bAll || wcsstr(pszw,L";client;")  )
    {
        ExecClientQuery(m_pszwParam1);
    }


End:
    delete pszw;
    if( ShouldTerminate() ) return FALSE;

    XMLNetdiag(FALSE);
    NetShNetdiag(FALSE);
    
    Sleep(50);
    ReportStatus(m_wstrXML.c_str(),-1);    
    
    ClearQuery();

    return TRUE;
}


wstring &CDiagnostics::Escape(LPCTSTR pszw)
{

    m_wstrEscapeXml = L"";

    if( !pszw )
    {
        return m_wstrEscapeXml;
    }
    
    for(int i=0; pszw[i]!=L'\0'; i++)
    {
        switch(pszw[i])
        {
        case L'&':
            m_wstrEscapeXml += L"&amp;";
            break;
        case L'\'':
            m_wstrEscapeXml += L"&apos;";
            break;
        case L'\"':
            m_wstrEscapeXml += L"&quot;";
            break;
        case L'<':
            m_wstrEscapeXml += L"&lt;";
            break;
        case L'>':
            m_wstrEscapeXml += L"&gt;";
            break;
        default:
            m_wstrEscapeXml += pszw[i];

        }
    }

    return m_wstrEscapeXml;
}
void CDiagnostics::XMLNetdiag(BOOLEAN bStartTag, LPCTSTR pszwValue)
{
    if( m_bInterface == COM_INTERFACE )
    {
        if( bStartTag )
        {
            m_wstrXML = wstring(L"<Netdiag Name = \"Network Diagnostics\">\n");
        }
        else
        {
            m_wstrXML += wstring(L"<Status Value = \"") + Escape(pszwValue) + wstring(L"\"> </Status>\n");
            m_wstrXML += wstring(L"</Netdiag>\n");
        }           
    }
}

void CDiagnostics::XMLHeader(BOOLEAN bStartTag, WCHAR *pszwHeader, WCHAR *pszwCaption, WCHAR *pszwCategory)
{
    if( m_bInterface == COM_INTERFACE )
    {
        if( bStartTag )
        {
            m_wstrXML += wstring(L"<Container Name = \"") + Escape(pszwHeader) + wstring(L"\" ");
            m_wstrXML += wstring(L"Category = \"") + Escape(pszwCategory) + wstring(L"\" ");
            m_wstrXML += wstring(L"Caption = \"") + Escape(pszwCaption) + wstring(L"\">\n");
        }
        else
        {
            m_wstrXML += wstring(L"<Status Value = \"") + Escape(pszwHeader) + wstring(L"\"> </Status>\n");
            m_wstrXML += wstring(L"</Container>");
        }
    }
}

void CDiagnostics::XMLCaption(BOOLEAN bStartTag, WCHAR *pszwCaption)
{
    if( m_bInterface == COM_INTERFACE )
    {
        if( bStartTag )
        {
            pszwCaption = (m_nInstance == 1)?NULL:pszwCaption;
            if( m_bCaptionDisplayed == FALSE )
            {
                m_wstrXML += wstring(L"<ClassObjectEnum Name = \"") + Escape(pszwCaption) + wstring(L"\">\n");
                m_bCaptionDisplayed = TRUE;
                m_IsPropertyListDisplayed = TRUE;
            }
        }
        else
        {
            if( m_IsPropertyListDisplayed )
            {
                m_wstrXML += wstring(L"<Status Value = \"") + Escape(pszwCaption) + wstring(L"\"> </Status>\n");
                m_wstrXML += wstring(L"</ClassObjectEnum>\n");
            }
            m_IsPropertyListDisplayed = FALSE;
            //m_bCaptionDisplayed = FALSE;
        }
    }
}

void CDiagnostics::XMLField(BOOLEAN bStartTag, WCHAR *pszwField)
{
    if( m_bInterface == COM_INTERFACE )
    {
        if( bStartTag )
        {
            m_wstrXML += wstring(L"<Property Name = \"") + Escape(pszwField) + wstring(L"\">\n");
        }
        else
        {
            m_wstrXML += wstring(L"<Status Value = \"") + Escape(pszwField) + wstring(L"\"> </Status>\n");
            m_wstrXML += wstring(L"</Property>\n");
        }
    }
}

void CDiagnostics::XMLProperty(BOOLEAN bStartTag, WCHAR *pszwProperty, LPCTSTR pszwData, LPCTSTR pszwComment)
{
    if( m_bInterface == COM_INTERFACE )
    {
        if( bStartTag )
        {
            m_wstrXML += wstring(L"<PropertyValue ");
            m_wstrXML += wstring(L"Value = \"")   + Escape(pszwProperty) + wstring(L"\" ");
            m_wstrXML += wstring(L"Data = \"")    + Escape(pszwData)     + wstring(L"\" ");
            m_wstrXML += wstring(L"Comment = \"") + Escape(pszwComment)  + wstring(L"\" ");
            m_wstrXML += wstring(L">\n");

        }
        else
        {
            m_wstrXML += Escape(pszwProperty);
            m_wstrXML += wstring(L"</PropertyValue>\n");
            //m_bCaptionDisplayed = FALSE;
        }
    }
}



BOOLEAN CDiagnostics::Filter(_variant_t &vValue, BOOLEAN bFlags)
{
    BOOLEAN retVal;
    BOOLEAN bShow    = (m_bFlags & FLAG_CMD_SHOW);
    BOOLEAN bPing    = (m_bFlags & FLAG_CMD_PING) && (bFlags & TYPE_PING);
    BOOLEAN bConnect = (m_bFlags & FLAG_CMD_CONNECT) && (bFlags & TYPE_CONNECT);

    if( m_bFlags & FLAG_VERBOSE_LOW )
    {
        return FALSE;
    }

    if( bFlags & TYPE_HIDE ) 
    {
        return FALSE;
    }

    if( (m_bFlags & FLAG_VERBOSE_HIGH)==0 && (retVal = IsVariantEmpty(vValue)) )
    {
        return FALSE;
    }

    if( (bFlags & TYPE_IP) && !m_bAdaterHasIPAddress )
    {
        return FALSE;
    }

    if( !bShow )
    {
        if( bPing || bConnect)
        {
            return TRUE;
        }
        return FALSE;
    }

    return TRUE;
}

template<class t>
_variant_t *Get(list<t> &l, WCHAR *pszwName, DWORD nInstance)
{
    list<t>::iterator iter;
    if( l.empty() )
    {
        return NULL;
    }
    for( iter = l.begin(); iter != l.end(); iter++)
    {
        if( lstrcmp(iter->pszwName,pszwName) == 0 )
        {
            if( nInstance < iter->Value.size() )
            {
                return &iter->Value[nInstance];
            }
            else
            {
                return NULL;
            }
        }
    }
    return NULL;
}   

template<class t>
BOOLEAN RemoveInstance(list<t> &l, DWORD nInstance)
{
    list<t>::iterator iter;
    //vector<t>::iterator iterVector;
  //  DWORD i=0;
    for( iter = l.begin(); iter != l.end(); iter++)
    {
        //iterVector = iter
        iter->Value.erase(iter->Value.begin() + nInstance);
/*        if( nInstance == i )
        {
            l.erase(iter);
            return TRUE;
        }
        i++;
*/
    }
    return FALSE;
}

template<class t>
void Set(list<t> &l, WCHAR *pszwName, BOOLEAN bFlags, _variant_t &vValue)
{    
    list<t>::iterator iter;

    for( iter = l.begin(); iter != l.end(); iter++)
    {
        if( lstrcmp(iter->pszwName,pszwName) == 0 )
        {
            iter->Value.push_back(vValue);
            return;
        }
    }
    l.push_back(Property(pszwName,bFlags));
    iter = l.end();
    iter--;
    iter->Value.push_back(vValue);

    return;
}



BOOLEAN CDiagnostics::FormatPing(WCHAR * pszwText)
{        
    if( m_bInterface == NETSH_INTERFACE )
    {
        if( pszwText )
        {
            LONG nIndent = m_IsNetdiagDisplayed + m_IsContainerDisplayed + m_IsPropertyListDisplayed +  m_IsPropertyDisplayed + m_IsValueDisplayed;
            DisplayMessageT(L"%1!s!%2!s!\n",Indent(nIndent),pszwText); 
            return TRUE;
        }
    }

    if( m_bInterface == COM_INTERFACE )
    {
        if( !pszwText )
        {
            m_wstrPing.erase(m_wstrPing.begin(),m_wstrPing.end());
        }
        else if( m_wstrPing.empty() )
        {
            m_wstrPing = pszwText;
        }
        else
        {
            m_wstrPing += wstring(L"|") + pszwText;
        }
        return TRUE;
    }

    return FALSE;
}


BOOLEAN CDiagnostics::ExecClientQuery(WCHAR *pszwInstance)
{
    if( !(m_bFlags & FLAG_CMD_SHOW) )
    {
        return FALSE;
    }

    EnumWbemProperty PropList;
    
    m_pszwCaption = TXT_CLIENT_CAPTION;
    lstrcpy(m_szwCategory,ids(IDS_CATEGORY_NETWORKADAPTERS));
    lstrcpy(m_szwHeader,ids(IDS_CLIENT_HEADER));

    PropList.push_back(WbemProperty(NULL,0,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_CLIENT));
    m_WmiGateway.GetWbemProperties(PropList);
    FormatEnum(PropList,pszwInstance);

    return TRUE;
}

BOOLEAN CDiagnostics::ExecModemQuery(WCHAR *pszwInstance)
{
    EnumWbemProperty PropList;
 
    m_pszwCaption = TXT_MODEM_CAPTION;
    lstrcpy(m_szwHeader,ids(IDS_MODEM_HEADER));
    lstrcpy(m_szwCategory,ids(IDS_CATEGORY_MODEM));

    PropList.push_back(WbemProperty(NULL,0,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_MODEM));
    m_WmiGateway.GetWbemProperties(PropList);
    FormatEnum(PropList,pszwInstance);

    return TRUE;
}
BOOLEAN CDiagnostics::RemoveInvalidAdapters(EnumWbemProperty & PropList)
{
    DWORD i = 0;
    _variant_t *pvIPEnabled;

    do
    {
        pvIPEnabled = Get(PropList,L"IPEnabled",i);
        if( pvIPEnabled )
        {
            if( pvIPEnabled->vt == VT_BOOL && pvIPEnabled->boolVal!=-1 )
            {
                RemoveInstance(PropList,i);
            }
            else
            {
                i++;
            }

        }
    }
    while(pvIPEnabled);

    return TRUE;
}

BOOLEAN CDiagnostics::ExecAdapterQuery(WCHAR *pszwInstance)
{
    EnumWbemProperty PropList;
    EnumWbemProperty::iterator iter;

    m_pszwCaption = TXT_ADAPTER_CAPTION;    
    lstrcpy(m_szwHeader,ids(IDS_ADAPTER_HEADER));
    lstrcpy(m_szwCategory,ids(IDS_CATEGORY_NETWORKADAPTERS));
    PropList.push_back(WbemProperty(NULL,0,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_NETWORK));
    m_WmiGateway.GetWbemProperties(PropList);

    for(iter = PropList.begin(); iter != PropList.end(); iter++)
    {
        if( 0 == lstrcmp(iter->pszwName, L"DNSServerSearchOrder") ||
            0 == lstrcmp(iter->pszwName, L"IPAddress")            ||
            0 == lstrcmp(iter->pszwName, L"WINSPrimaryServer")    ||
            0 == lstrcmp(iter->pszwName, L"WINSSecondaryServer")  ||
            0 == lstrcmp(iter->pszwName, L"DHCPServer")           )
        {
            iter->bFlags = TYPE_PING | TYPE_IP;
        }

        if( 0 == lstrcmp(iter->pszwName, L"DefaultIPGateway") )
        {
            iter->bFlags = TYPE_PING | TYPE_SUBNET | TYPE_IP;
        }
    }

    if( !(m_bFlags & FLAG_VERBOSE_HIGH) )
    {
        RemoveInvalidAdapters(PropList);
        /*
        DWORD i = 0;
        _variant_t *pvIPEnabled;

        do
        {
            pvIPEnabled = Get(PropList,L"IPEnabled",i);
            if( pvIPEnabled )
            {
                if( pvIPEnabled->vt == VT_BOOL && pvIPEnabled->boolVal!=-1 )
                {
                    RemoveInstance(PropList,i);
                }
                else
                {
                    i++;
                }

            }
        }
        while(pvIPEnabled);
        */
    }
    
    FormatEnum(PropList,pszwInstance);

    return TRUE;
}

BOOLEAN CDiagnostics::ExecDNSQuery(WCHAR *pszwInstance)
{
    EnumWbemProperty PropList;

    m_pszwCaption = TXT_ADAPTER_CAPTION;
    lstrcpy(m_szwHeader,ids(IDS_DNS_HEADER));
    lstrcpy(m_szwCategory,ids(IDS_CATEGORY_NETWORKADAPTERS));

    PropList.push_back(WbemProperty(L"DNSServerSearchOrder",TYPE_PING | TYPE_IP ,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_NETWORK));
    PropList.push_back(WbemProperty(m_pszwCaption,TYPE_HIDE,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_NETWORK));
	PropList.push_back(WbemProperty(L"IPAddress",TYPE_HIDE,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_NETWORK));
    PropList.push_back(WbemProperty(L"IPEnabled",TYPE_HIDE,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_NETWORK));
    
    m_WmiGateway.GetWbemProperties(PropList);

    if( !(m_bFlags & FLAG_VERBOSE_HIGH) )
    {
        RemoveInvalidAdapters(PropList);
    }

    FormatEnum(PropList,pszwInstance);

    return TRUE;
}

BOOLEAN CDiagnostics::ExecIPQuery(WCHAR *pszwInstance)
{
    EnumWbemProperty PropList;

    m_pszwCaption = TXT_ADAPTER_CAPTION;
    lstrcpy(m_szwHeader,ids(IDS_IP_HEADER));
    lstrcpy(m_szwCategory,ids(IDS_CATEGORY_NETWORKADAPTERS));

    PropList.push_back(WbemProperty(L"IPAddress",TYPE_PING | TYPE_IP,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_NETWORK));    
    PropList.push_back(WbemProperty(m_pszwCaption,TYPE_HIDE,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_NETWORK));
	PropList.push_back(WbemProperty(L"IPAddress",TYPE_HIDE,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_NETWORK));
    PropList.push_back(WbemProperty(L"IPEnabled",TYPE_HIDE,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_NETWORK));

    m_WmiGateway.GetWbemProperties(PropList);

    if( !(m_bFlags & FLAG_VERBOSE_HIGH) )
    {
        RemoveInvalidAdapters(PropList);
    }

    FormatEnum(PropList,pszwInstance);

    return TRUE;
}

BOOLEAN CDiagnostics::ExecWinsQuery(WCHAR *pszwInstance)
{
    EnumWbemProperty PropList;
    
    m_pszwCaption = TXT_ADAPTER_CAPTION;
    lstrcpy(m_szwHeader,ids(IDS_WINS_HEADER));
    lstrcpy(m_szwCategory,ids(IDS_CATEGORY_NETWORKADAPTERS));

    PropList.push_back(WbemProperty(L"WINSPrimaryServer",TYPE_PING | TYPE_IP,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_NETWORK));
    PropList.push_back(WbemProperty(L"WINSSecondaryServer",TYPE_PING | TYPE_IP,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_NETWORK));
    PropList.push_back(WbemProperty(m_pszwCaption,TYPE_HIDE,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_NETWORK));
	PropList.push_back(WbemProperty(L"IPAddress",TYPE_HIDE,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_NETWORK));
    PropList.push_back(WbemProperty(L"IPEnabled",TYPE_HIDE,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_NETWORK));
    
    m_WmiGateway.GetWbemProperties(PropList);

    if( !(m_bFlags & FLAG_VERBOSE_HIGH) )
    {
        RemoveInvalidAdapters(PropList);
    }

    FormatEnum(PropList,pszwInstance);

    return TRUE;
}

BOOLEAN CDiagnostics::ExecGatewayQuery(WCHAR *pszwInstance)
{
    EnumWbemProperty PropList;
    
    m_pszwCaption = TXT_ADAPTER_CAPTION;
    lstrcpy(m_szwHeader,ids(IDS_GATEWAY_HEADER));
    lstrcpy(m_szwCategory,ids(IDS_CATEGORY_NETWORKADAPTERS));

    PropList.push_back(WbemProperty(L"DefaultIPGateway",TYPE_PING | TYPE_IP | TYPE_SUBNET,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_NETWORK));
    PropList.push_back(WbemProperty(L"IPAddress",TYPE_HIDE,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_NETWORK));
    PropList.push_back(WbemProperty(L"IPSubnet",TYPE_HIDE,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_NETWORK));
    PropList.push_back(WbemProperty(m_pszwCaption,TYPE_HIDE,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_NETWORK));
    PropList.push_back(WbemProperty(L"IPEnabled",TYPE_HIDE,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_NETWORK));
    
    m_WmiGateway.GetWbemProperties(PropList);

    if( !(m_bFlags & FLAG_VERBOSE_HIGH) )
    {
        RemoveInvalidAdapters(PropList);
    }

    FormatEnum(PropList,pszwInstance);

    return TRUE;
}

BOOLEAN CDiagnostics::ExecDhcpQuery(WCHAR *pszwInstance)
{
    EnumWbemProperty PropList;
    
    m_pszwCaption = TXT_ADAPTER_CAPTION;
    lstrcpy(m_szwHeader,ids(IDS_DHCP_HEADER));
    lstrcpy(m_szwCategory,ids(IDS_CATEGORY_NETWORKADAPTERS));

    PropList.push_back(WbemProperty(L"DHCPServer",TYPE_PING | TYPE_IP,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_NETWORK));
    PropList.push_back(WbemProperty(m_pszwCaption,TYPE_HIDE,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_NETWORK));
	PropList.push_back(WbemProperty(L"IPAddress",TYPE_HIDE,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_NETWORK));

    m_WmiGateway.GetWbemProperties(PropList);

    if( !(m_bFlags & FLAG_VERBOSE_HIGH) )
    {
        RemoveInvalidAdapters(PropList);
    }

    FormatEnum(PropList,pszwInstance);

    return TRUE;
}

BOOLEAN CDiagnostics::ExecComputerQuery()
{
    if( !(m_bFlags & FLAG_CMD_SHOW) )
    {
        return FALSE;
    }
    EnumWbemProperty PropList;
    
    m_pszwCaption = TXT_COMPUTER_CAPTION;
    lstrcpy(m_szwCategory,ids(IDS_CATEGORY_SYSTEMINFO));
    lstrcpy(m_szwHeader,ids(IDS_COMPUTER_HEADER));

    PropList.push_back(WbemProperty(NULL,0,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_COMPUTER));
    m_WmiGateway.GetWbemProperties(PropList);
    FormatEnum(PropList);

    return TRUE;
}

BOOLEAN CDiagnostics::ExecOSQuery()
{
    if( !(m_bFlags & FLAG_CMD_SHOW) )
    {
        return FALSE;
    }

    EnumWbemProperty PropList;

    m_pszwCaption = TXT_OS_CAPTION;
    lstrcpy(m_szwHeader,ids(IDS_OS_HEADER));
    lstrcpy(m_szwCategory,ids(IDS_CATEGORY_SYSTEMINFO));

    PropList.push_back(WbemProperty(NULL,0,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_OS));
    m_WmiGateway.GetWbemProperties(PropList);
    FormatEnum(PropList);

    return TRUE;
}

BOOLEAN CDiagnostics::ExecVersionQuery()
{
    if( !(m_bFlags & FLAG_CMD_SHOW) )
    {
        return FALSE;
    }

    EnumWbemProperty PropList;
    
    m_pszwCaption = TXT_VERSION_CAPTION;
    lstrcpy(m_szwHeader,ids(IDS_VERSION_HEADER));
    lstrcpy(m_szwCategory,ids(IDS_CATEGORY_SYSTEMINFO));

    PropList.push_back(WbemProperty(L"Version",0,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_OS));
    PropList.push_back(WbemProperty(L"BuildVersion",0,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_WMI));
    m_WmiGateway.GetWbemProperties(PropList);
    FormatEnum(PropList);

    return TRUE;
}
LPWSTR GetMailType(DWORD dwType)
{
    switch(dwType)
    {
    case MAIL_SMTP:
        return ids(IDS_SMTP); 
    case MAIL_SMTP2:
        return ids(IDS_SMTP);
    case MAIL_POP3:
        return ids(IDS_POP3);
    case MAIL_IMAP:
        return ids(IDS_IMAP);
    case MAIL_HTTP:
        return ids(IDS_HTTP);
    default:
        return ids(IDS_UNKNOWN);
    }
}


BOOLEAN CDiagnostics::ExecNewsQuery()
{    
    HRESULT hr;
    INETSERVER rNewsServer;
    EnumProperty PropList;
    BOOLEAN bConnect = 2;

    m_pszwCaption = TXT_NEWS_CAPTION;
    lstrcpy(m_szwHeader,ids(IDS_NEWS_HEADER));
    lstrcpy(m_szwCategory,ids(IDS_CATEGORY_INTERNET));

    hr = GetOEDefaultNewsServer2(rNewsServer); 

    if( SUCCEEDED(hr) )
    {        
        if( strcmp(rNewsServer.szServerName,"")  != 0 )
        {
            Property Prop;           

            m_bstrCaption = rNewsServer.szServerName;

            Prop.Clear();
            Prop.SetProperty(L"NewsNNTPPort",TYPE_CONNECT);
            Prop.Value.push_back(_variant_t((LONG)rNewsServer.dwPort));
            PropList.push_back(Prop);

            Prop.Clear();
            Prop.SetProperty(L"NewsServer",TYPE_PING | TYPE_CONNECT);
            Prop.Value.push_back(_variant_t(rNewsServer.szServerName));
            PropList.push_back(Prop);            

            if( (m_bFlags & FLAG_CMD_CONNECT) )
            {
                _bstr_t bstrServer = rNewsServer.szServerName;
                WCHAR wszConnect[MAX_PATH*10];
               
                if( Connect((LPWSTR)bstrServer,rNewsServer.dwPort) )
                {
                    //L"Successfully connected to %hs port %d"
                    swprintf(wszConnect,ids(IDS_CONNECTEDTOSERVERSUCCESS),rNewsServer.szServerName,rNewsServer.dwPort);               
                    bConnect = TRUE;
                }
                else
                {

                    //"Unable to connect to %hs port %d"
                    wsprintf(wszConnect,ids(IDS_CONNECTEDTOSERVERFAILED),rNewsServer.szServerName,rNewsServer.dwPort);               
                    bConnect = FALSE;
                }
                    
                PropList.push_back(Property(wszConnect,TYPE_TEXT | TYPE_CONNECT));
                
            }
        }
    }
    else
    {            
        m_bstrCaption = ids(IDS_NOTCONFIGURED);
        PropList.push_back(Property((WCHAR*)m_bstrCaption,TYPE_TEXT));
    }

    FormatEnum(PropList, NULL, bConnect);

    m_bstrCaption = L"";


    return TRUE;
}

BOOLEAN CDiagnostics::ExecMailQuery()
{    
    EnumProperty PropList;
    INETSERVER rInBoundMailServer;
    INETSERVER rOutBoundMailServer;
    DWORD dwInBoundMailType;
    DWORD dwOutBoundMailType;
    HRESULT hr;
    WCHAR szw[1000];
    BOOLEAN bConnect = 2;
    BOOLEAN bMailConfigured = FALSE;

    

    // Set the caption, header and category information (describes this object)
    //
    m_pszwCaption = TXT_MAIL_CAPTION;
    lstrcpy(m_szwHeader,ids(IDS_MAIL_HEADER));
    lstrcpy(m_szwCategory,ids(IDS_CATEGORY_INTERNET));

    hr = GetOEDefaultMailServer2(rInBoundMailServer, 
                                 dwInBoundMailType,
                                 rOutBoundMailServer, 
                                 dwOutBoundMailType);

    if( SUCCEEDED(hr) )
    {
        if( strcmp(rInBoundMailServer.szServerName,"")  != 0 )
        {

            Property Prop;
            _variant_t varValue;

            m_bstrCaption = rInBoundMailServer.szServerName;

            Prop.Clear();
            Prop.SetProperty(L"InBoundMailPort",TYPE_CONNECT);
            Prop.Value.push_back(_variant_t((LONG)rInBoundMailServer.dwPort));
            PropList.push_back(Prop);

            Prop.Clear();
            Prop.SetProperty(L"InBoundMailServer",TYPE_CONNECT | (dwInBoundMailType!=MAIL_HTTP ? TYPE_PING : 0));
            Prop.Value.push_back(_variant_t(rInBoundMailServer.szServerName));
            PropList.push_back(Prop);            

            Prop.Clear();
            Prop.SetProperty(L"InBoundMailType",0);
            Prop.Value.push_back(_variant_t(GetMailType(dwInBoundMailType)));
            PropList.push_back(Prop);

            if( (m_bFlags & FLAG_CMD_CONNECT) && dwInBoundMailType != MAIL_HTTP)
            {
                _bstr_t bstrServer = rInBoundMailServer.szServerName;
                WCHAR wszConnect[MAX_PATH*10];
               
                if( Connect((LPWSTR)bstrServer,rInBoundMailServer.dwPort) )
                {
                    swprintf(wszConnect,ids(IDS_CONNECTEDTOSERVERSUCCESS),rInBoundMailServer.szServerName,rInBoundMailServer.dwPort);               
                    bConnect = TRUE;
                }
                else
                {
                    wsprintf(wszConnect,ids(IDS_CONNECTEDTOSERVERFAILED),rInBoundMailServer.szServerName,rInBoundMailServer.dwPort);               
                    bConnect = FALSE;
                }
                    
                PropList.push_back(Property(wszConnect,TYPE_TEXT | TYPE_CONNECT));
                
            }

            bMailConfigured = TRUE;
        }

        if( strcmp(rOutBoundMailServer.szServerName,"")  != 0 )
        {

            Property Prop;
            _variant_t varValue;

            if( bMailConfigured )
            {
                m_bstrCaption += L" / ";
            }

            m_bstrCaption += rOutBoundMailServer.szServerName;

            Prop.Clear();
            Prop.SetProperty(L"OutBoundMailPort",TYPE_CONNECT);
            Prop.Value.push_back(_variant_t((LONG)rOutBoundMailServer.dwPort));
            PropList.push_back(Prop);

            Prop.Clear();
            Prop.SetProperty(L"OutBoundMailServer",TYPE_PING | TYPE_CONNECT);
            Prop.Value.push_back(_variant_t(rOutBoundMailServer.szServerName));
            PropList.push_back(Prop);            

            Prop.Clear();
            Prop.SetProperty(L"OutBoundMailType",0);
            Prop.Value.push_back(_variant_t(GetMailType(dwOutBoundMailType)));
            PropList.push_back(Prop);

            if( (m_bFlags & FLAG_CMD_CONNECT) && dwOutBoundMailType != MAIL_HTTP)
            {
                _bstr_t bstrServer = rOutBoundMailServer.szServerName;
                WCHAR wszConnect[MAX_PATH*10];
               
                if( Connect((LPWSTR)bstrServer,rOutBoundMailServer.dwPort) )
                {
                    swprintf(wszConnect,ids(IDS_CONNECTEDTOSERVERSUCCESS),rOutBoundMailServer.szServerName,rOutBoundMailServer.dwPort);               
                    bConnect = TRUE;
                }
                else
                {
                    wsprintf(wszConnect,ids(IDS_CONNECTEDTOSERVERFAILED),rOutBoundMailServer.szServerName,rOutBoundMailServer.dwPort);               
                    bConnect = FALSE;
                }
                    
                PropList.push_back(Property(wszConnect,TYPE_TEXT | TYPE_CONNECT));
                
            }

            bMailConfigured = TRUE;
        }

        if( !bMailConfigured )
        {
            m_bstrCaption = ids(IDS_NOTCONFIGURED);
            PropList.push_back(Property((WCHAR*)m_bstrCaption,TYPE_TEXT));
        }
    }
    else
    {
        m_bstrCaption = ids(IDS_NOTCONFIGURED);
        PropList.push_back(Property((WCHAR*)m_bstrCaption,TYPE_TEXT));
    }
    FormatEnum(PropList, NULL, bConnect);

    m_bstrCaption = L"";
    return TRUE;
}

/*
BOOLEAN CDiagnostics::ExecMailQuery()
{
    EnumWbemProperty PropList;
    _variant_t *pvPort, *pvServer, *pvType;
    WCHAR szw[MAX_PATH];
    BOOL bFlag;
    BOOLEAN bConnectPass = 2;
    ULONG ulFail = 0;
    HRESULT hr;
 
    INETSERVER rInBoundMailServer;
    INETSERVER rOutBoundMailServer;
    DWORD dwInBoundMailType;
    DWORD dwOutBoundMailType;
    WCHAR wsz[1000];

    hr = GetOEDefaultMailServer2(rInBoundMailServer, 
                                 dwInBoundMailType,
                                 rOutBoundMailServer, 
                                 dwOutBoundMailType);

    if( SUCCEEDED(hr) )
    {
        wsprintf(wsz,L"Inbound Mail Server %hs Port %d Type %d\nOutbound Mail Server %hs Port %d Type %d\n",
                 rInBoundMailServer.szServerName,rInBoundMailServer.dwPort,dwInBoundMailType,
                 rOutBoundMailServer.szServerName,rOutBoundMailServer.dwPort,dwOutBoundMailType);

        OutputDebugString(wsz);
    }
    else
    {
        wsprintf(wsz,L"Unable to get Mail server %X\n",hr);
        OutputDebugString(wsz);
    }

    m_pszwCaption = TXT_MAIL_CAPTION;
    lstrcpy(m_szwHeader,ids(IDS_MAIL_HEADER));
    lstrcpy(m_szwCategory,ids(IDS_CATEGORY_INTERNET));

    PropList.push_back(WbemProperty(L"InBoundMailPort",TYPE_CONNECT,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_NETDIAG));
    PropList.push_back(WbemProperty(L"InBoundMailServer",TYPE_PING | TYPE_CONNECT,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_NETDIAG));    
    PropList.push_back(WbemProperty(L"InBoundMailType",0,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_NETDIAG));    

    PropList.push_back(WbemProperty(L"OutBoundMailPort",TYPE_CONNECT,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_NETDIAG));
    PropList.push_back(WbemProperty(L"OutBoundMailServer",TYPE_PING | TYPE_CONNECT,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_NETDIAG));    
    PropList.push_back(WbemProperty(L"OutBoundMailType",0,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_NETDIAG));    

    int i;
//TryAgain:
    m_WmiGateway.GetWbemProperties(PropList);
    i = 0;
    for(i=0; i<2; i++)
    {
        switch(i)
        {
        case 0:
            pvServer = Get(PropList,L"InBoundMailServer",0);
            pvPort = Get(PropList,L"InBoundMailPort",0);
            pvType = Get(PropList,L"InBoundMailType",0);
            break;
        case 1:
            pvServer = Get(PropList,L"OutBoundMailServer",0);
            pvPort = Get(PropList,L"OutBoundMailPort",0);
            pvType = Get(PropList,L"InBoundMailType",0);
            break;
        }

        if( pvServer == NULL || pvPort == NULL ||
            pvServer->vt != VT_BSTR ||
            pvPort->vt   != VT_I4 ||
            lstrcmp(pvServer->bstrVal,L"") == 0)
        {
            //HideAll(PropList);
            //lstrcpy(szw,ids(IDS_NOTCONFIGURED));
            //m_pszwCaption = szw;
            //PropList.push_back(WbemProperty(szw,TYPE_TEXT));
            ulFail++;
            //if( ulFail % 2 == 0 && ulFail < 10) goto TryAgain;
        }
        else
        {
            WCHAR *pszwType = (WCHAR *)pvType->bstrVal;
            WCHAR *pszw = (WCHAR *)pvServer->bstrVal;
            LONG  dwPort = pvPort->lVal;

            if( (lstrcmp(pszwType,L"SMTP")==0 || lstrcmp(pszwType,L"SMTP2")==0) && dwPort!=110 )
            {
                // Not standard SMTP port 
            }
            if( lstrcmp(pszwType,L"POP3")==0 && dwPort!=25)
            {
                // Not standard POP3 port 
            }
            if( lstrcmp(pszwType,L"IMAP")==0 && dwPort==143)
            {
                // Not standard IMAP port 
            }
            if( lstrcmp(pszwType,L"HTTP")==0 && dwPort!=0)
            {
                // Not standard HTTP port. Should not have a port number
            }

            if( (m_bFlags & FLAG_CMD_CONNECT) )
            {
                WCHAR szwConnect[MAX_PATH];
                DWORD nConnect = 0;

                WCHAR szw[MAX_PATH];
                WCHAR szwLastPort[MAX_PATH] = L"";

                if( lstrlen(pszw) > 200 )
                {
                    WCHAR cTmp = pszw[200];
                    pszw[200] = L'\0';
                    wsprintf(szw,L"Connecting to %s port %d",pszw,dwPort);
                    pszw[200] = cTmp;
                }
                else
                {
                    wsprintf(szw,L"Connecting to %s port %d",pszw,dwPort);
                }

                ReportStatus(szw,0);
                bConnectPass = TRUE;
                if( Connect(pszw,dwPort) )
                {
                    wsprintf(szwConnect,L"Successfully connected to %s port %d",pszw,dwPort);                
                    bConnectPass = TRUE;
                }
                else
                {
                    wsprintf(szwConnect,L"Unable to connect to %s port %d",pszw,dwPort);                
                    bConnectPass = FALSE;
                }
                    
                PropList.push_back(WbemProperty(szwConnect,TYPE_TEXT | TYPE_CONNECT));
            }
        }
    }

    FormatEnum(PropList, NULL, bConnectPass);

    return TRUE;
}
*/
/*
BOOLEAN CDiagnostics::ExecNewsQuery()
{
    EnumWbemProperty PropList;
    _variant_t *pvPort, *pvServer;
    WCHAR szw[MAX_PATH];
    BOOLEAN bConnectPass = 2;
    
    m_pszwCaption = TXT_NEWS_CAPTION;
    lstrcpy(m_szwHeader,ids(IDS_NEWS_HEADER));
    lstrcpy(m_szwCategory,ids(IDS_CATEGORY_INTERNET));

    PropList.push_back(WbemProperty(L"NewsNNTPPort",TYPE_CONNECT,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_NETDIAG));
    PropList.push_back(WbemProperty(L"NewsServer",TYPE_PING | TYPE_CONNECT,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_NETDIAG));
    m_WmiGateway.GetWbemProperties(PropList);

    pvServer = Get(PropList,L"NewsServer",0);
    pvPort = Get(PropList,L"NewsNNTPPort",0);

    if( !pvServer || !pvPort ||
        pvServer->vt != VT_BSTR ||
        pvPort->vt != VT_I4 ||
        lstrcmp(pvServer->bstrVal,L"") == 0)
    {
        HideAll(PropList);
        lstrcpy(szw,ids(IDS_NOTCONFIGURED));
        m_pszwCaption = szw;
        PropList.push_back(WbemProperty(szw,TYPE_TEXT));
    }
    else
    if( (m_bFlags & FLAG_CMD_CONNECT) )
    {
        WCHAR szwConnect[MAX_PATH];
        DWORD nConnect = 0;
        WCHAR *pszw = (WCHAR *)pvServer->bstrVal;
        LONG  dwPort = pvPort->lVal;

        WCHAR szw[MAX_PATH];
        if( lstrlen(pszw) > 200 )
        {
            WCHAR cTmp = pszw[200];
            pszw[200] = L'\0';
            wsprintf(szw,L"Connecting to %s port %d",pszw,dwPort);
            pszw[200] = cTmp;
        }
        else
        {
            wsprintf(szw,L"Connecting to %s port %d",pszw,dwPort);
        }

        ReportStatus(szw,0);

        wsprintf(szwConnect,ids(IDS_SERVERCONNECTSTART));
        if( Connect(pszw,dwPort) )
        {
            wsprintf(szwConnect,L"%s%s%d",szwConnect,nConnect?L",":L"",dwPort);
            nConnect++;
        }
        if( !nConnect )
        {
            wsprintf(szwConnect,L"%s%s",szwConnect,ids(IDS_NONE));
            bConnectPass = FALSE;
        }
        else
        {
            bConnectPass = TRUE;
        }

        wsprintf(szwConnect,L"%s%s",szwConnect,ids(IDS_SERVERCONNECTEND));
        PropList.push_back(WbemProperty(szwConnect,TYPE_TEXT | TYPE_CONNECT));
    }


    FormatEnum(PropList,NULL,bConnectPass);

    return TRUE;
}
*/

BOOLEAN CDiagnostics::ExecProxyQuery()
{
    EnumWbemProperty PropList;
    _variant_t *pvPort, *pvServer, *pvUsed;
    WCHAR szw[MAX_PATH];
    BOOLEAN bConnectPass = 2;
    
    m_pszwCaption = TXT_PROXY_CAPTION;
    lstrcpy(m_szwHeader,ids(IDS_PROXY_HEADER));
    lstrcpy(m_szwCategory,ids(IDS_CATEGORY_INTERNET));

    PropList.push_back(WbemProperty(L"IEProxyPort",TYPE_CONNECT,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_NETDIAG));
    PropList.push_back(WbemProperty(L"IEProxy",TYPE_PING | TYPE_CONNECT,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_NETDIAG));
    PropList.push_back(WbemProperty(L"bIEProxy",TYPE_HIDE,TXT_WBEM_REP_CIMV2,TXT_WBEM_NS_NETDIAG));
    m_WmiGateway.GetWbemProperties(PropList);
    
    pvServer = Get(PropList,L"IEProxy",0);
    pvPort = Get(PropList,L"IEProxyPort",0);
    pvUsed = Get(PropList,L"bIEProxy",0);

    if( !pvServer || !pvPort || !pvUsed ||
        pvServer->vt != VT_BSTR ||
        pvPort->vt != VT_I4 ||
        lstrcmp(pvServer->bstrVal,L"") == 0)
    {
        HideAll(PropList);
        m_bstrCaption = ids(IDS_NOTCONFIGURED);
        //PropList.push_back(Property((WCHAR*)m_bstrCaption,TYPE_TEXT));
        lstrcpy(szw,ids(IDS_NOTCONFIGURED));
        m_pszwCaption = szw;
        //PropList.push_back(WbemProperty(szw,TYPE_TEXT));
    }
    else
    if( pvUsed->boolVal )
    {
        if( (m_bFlags & FLAG_CMD_CONNECT) )
        {
            WCHAR szwConnect[MAX_PATH];
            DWORD nConnect = 0;
            WCHAR *pszw = (WCHAR *)pvServer->bstrVal;
            LONG  dwPort = pvPort->lVal;

            WCHAR szw[MAX_PATH];
            if( lstrlen(pszw) > 200 )
            {
                WCHAR cTmp = pszw[200];
                pszw[200] = L'\0';
                wsprintf(szw,ids(IDS_CONNECTINGTOSERVER_STATUS),pszw,dwPort);
                pszw[200] = cTmp;
            }
            else
            {
                wsprintf(szw,ids(IDS_CONNECTINGTOSERVER_STATUS),pszw,dwPort);
            }

            ReportStatus(szw,0);

            wsprintf(szwConnect,ids(IDS_SERVERCONNECTSTART));
            if( Connect(pszw,dwPort) )
            {
                wsprintf(szwConnect,L"%s%s%d",szwConnect,nConnect?L",":L"",dwPort);
                nConnect++;
            }
            if( !nConnect )
            {
                wsprintf(szwConnect,L"%s%s",szwConnect,ids(IDS_NONE));
                bConnectPass = FALSE;
            }
            else
            {
                bConnectPass = TRUE;
            }

            wsprintf(szwConnect,L"%s%s",szwConnect,ids(IDS_SERVERCONNECTEND));
            PropList.push_back(WbemProperty(szwConnect,TYPE_TEXT | TYPE_CONNECT));
        }
    }
    else
    {
            HideAll(PropList);
            lstrcpy(szw,ids(IDS_IEPROXYNOTUSED));
            m_pszwCaption = szw;
            //PropList.push_back(WbemProperty(szw,TYPE_TEXT));
            m_bstrCaption = ids(IDS_NOTCONFIGURED);
    }

    FormatEnum(PropList,NULL, bConnectPass);

    m_bstrCaption = L"";
    return TRUE;
}

BOOLEAN CDiagnostics::ExecLoopbackQuery()
{
    EnumWbemProperty PropList;
    EnumWbemProperty::iterator iter;

    _variant_t vLoopback = L"127.0.0.1";
    
    m_pszwCaption = TXT_LOOPBACK_CAPTION;
    lstrcpy(m_szwHeader,ids(IDS_LOOPBACK_HEADER));
    lstrcpy(m_szwCategory,ids(IDS_CATEGORY_INTERNET));

    PropList.push_back(WbemProperty(L"Loopback",TYPE_PING));    

    iter = PropList.begin();
    iter->Value.push_back(vLoopback);

    FormatEnum(PropList);

    return TRUE;
}



BOOLEAN CDiagnostics::ExecIPHost(WCHAR *pszwHostName,WCHAR *pszwHostPort)
{
    EnumProperty PropList;
    WCHAR szw[MAX_PATH];
    BOOL bFlag;

    m_pszwCaption = L"IPHost";
    lstrcpy(m_szwHeader,L"IPHost");
    
    Set(PropList, L"IPHost",TYPE_CONNECT | TYPE_PING,_variant_t(pszwHostName));

    if( m_bFlags & FLAG_CMD_CONNECT )
    {
        WCHAR szw[MAX_PATH];
        WCHAR szwConnect[MAX_PATH];
        
        Set(PropList, L"Port",TYPE_CONNECT,_variant_t(pszwHostPort));
        wsprintf(szw,L"Connecting to %s port %s",pszwHostName,pszwHostPort);
        ReportStatus(szw,0);
        wsprintf(szwConnect,ids(IDS_SERVERCONNECTSTART));
        if( IsNumber(pszwHostPort) && Connect(pszwHostName,wcstol(pszwHostPort,NULL,10)) )
        {
            wsprintf(szwConnect,L"%s%s",szwConnect,pszwHostPort);
        }
        else
        {
            wsprintf(szwConnect,L"%s%s",szwConnect,ids(IDS_NONE));
        }

        wsprintf(szwConnect,L"%s%s",szwConnect,ids(IDS_SERVERCONNECTEND));
        PropList.push_back(Property(szwConnect,TYPE_TEXT | TYPE_CONNECT));
    }

    FormatEnum(PropList);

    return TRUE;
        
}

BOOLEAN CDiagnostics::GetXMLResult(BSTR *pbstr)
{
    if( m_wstrXML.empty() )
    {
        return FALSE;
    }

    *pbstr = SysAllocString(m_wstrXML.c_str());
    if( pbstr ==  NULL )
    {
        return FALSE;
    }
    return TRUE;
}


void CDiagnostics::NetShNetdiag(BOOLEAN bStartTag, LPCTSTR pszwValue)
{
    if( m_bInterface == NETSH_INTERFACE )
    {
        m_nIndent = 0;
        m_IsNetdiagDisplayed = FALSE;
    }
}

void CDiagnostics::NetShHeader(BOOLEAN bStartTag,LPCTSTR pszwValue,LPCTSTR pszwCaption)
{
    if( m_bInterface == NETSH_INTERFACE )
    {
        if( bStartTag )
        {
            DisplayMessageT(L"\n");
            if( pszwValue )
            {
                LONG nIndent = m_IsNetdiagDisplayed;
                DisplayMessageT(L"%1!s!%2!s!",Indent(nIndent),pszwValue);
                if( pszwCaption )
                {
                    DisplayMessageT(L" (%1!s!)",pszwCaption);
                }
                DisplayMessageT(L"\n");
                m_IsContainerDisplayed = TRUE;
            }
            else
            {
                m_IsContainerDisplayed = FALSE;
            }
        }
        else
        {
            m_IsContainerDisplayed = FALSE;
        }
    }
}

void CDiagnostics::NetShCaption(BOOLEAN bStartTag,LPCTSTR pszwValue)
{
    if( m_bInterface == NETSH_INTERFACE )
    {
        if( bStartTag )
        {
            if( m_nInstance > 1 )
            {
                if( m_bCaptionDisplayed == FALSE )
                {
                    if( pszwValue )
                    {
                        LONG nIndent = m_IsNetdiagDisplayed + m_IsContainerDisplayed;
                        DisplayMessageT(L"%1!s!%2!2d!. %3!s!\n",Indent(nIndent),m_nIndex, pszwValue);
                        m_IsPropertyListDisplayed = TRUE;
                    }
                    else
                    {
                        m_IsPropertyListDisplayed = FALSE;
                    }

                    m_bCaptionDisplayed = TRUE;
                }
            }
        }
        else
        {
            m_IsPropertyListDisplayed = FALSE;
            //m_bCaptionDisplayed = FALSE;
        }
    }
}

void CDiagnostics::NetShField(BOOLEAN bStartTag,LPCTSTR pszwValue)
{
    if( m_bInterface == NETSH_INTERFACE )
    {                       
        if( bStartTag )
        {
            m_nPropertyLegth = 0;

            LONG nIndent = m_IsNetdiagDisplayed + m_IsContainerDisplayed + m_IsPropertyListDisplayed;
            if( pszwValue )
            {
                m_nPropertyLegth = DisplayMessageT(L"%1!s!%2!s! = ",Indent(nIndent),pszwValue);
            }
            else
            {
                m_nPropertyLegth = DisplayMessageT(L"%1!s!",Indent(nIndent));
            }
            m_nValueIndex = 0;
            m_IsPropertyDisplayed = TRUE;
        }
        else
        {        
            m_IsPropertyDisplayed = FALSE;
        }
    }
}

void CDiagnostics::NetShProperty(BOOLEAN bStartTag,LPCTSTR pszwValue,LPCTSTR pszwComment,BOOL bFlags)
{
    if( m_bInterface == NETSH_INTERFACE )
    {
        if( bStartTag )
        {
            if( (bFlags & TYPE_PING) )
            {
                LONG nIndent = m_IsNetdiagDisplayed + m_IsContainerDisplayed + m_IsPropertyListDisplayed + m_IsPropertyDisplayed;
                if( m_nValueIndex == 0 )
                {
                    DisplayMessageT(L"\n");
                }
                DisplayMessageT(L"%1!s!%2!s! %3!s!\n",Indent(nIndent),pszwValue?pszwValue:L"",pszwComment?pszwComment:L"");
                m_nValueIndex++;
            }
            else
            {
                DisplayMessageT(L"%1!s!%2!s! %3!s!\n",m_nValueIndex++?Space(m_nPropertyLegth):L"",pszwValue?pszwValue:L"",pszwComment?pszwComment:L"");
            }
            m_IsValueDisplayed = TRUE;
        }
        else
        {
            m_IsValueDisplayed = FALSE;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\wmi\dglogs\ping.cpp ===
#include "diagnostics.h"

#include <stdio.h>
#include <stdlib.h>
#include <winsock2.h>
#include <Ipexport.h>
#include <icmpapi.h>
#include <ctype.h>

#define DEFAULT_SEND_SIZE           32
#define DEFAULT_TTL                 128
#define DEFAULT_TOS                 0
#define DEFAULT_COUNT               4
#define DEFAULT_TIMEOUT             4000L
#define DEFAULT_BUFFER_SIZE         (0x2000 - 8)
#define MIN_INTERVAL                1000L

struct IPErrorTable {
    IP_STATUS  Error;                   // The IP Error    
    DWORD ErrorNlsID;                   // NLS string ID
} ErrorTable[] =
{
    { IP_BUF_TOO_SMALL,         PING_BUF_TOO_SMALL},
    { IP_DEST_NET_UNREACHABLE,  PING_DEST_NET_UNREACHABLE},
    { IP_DEST_HOST_UNREACHABLE, PING_DEST_HOST_UNREACHABLE},
    { IP_DEST_PROT_UNREACHABLE, PING_DEST_PROT_UNREACHABLE},
    { IP_DEST_PORT_UNREACHABLE, PING_DEST_PORT_UNREACHABLE},
    { IP_NO_RESOURCES,          PING_NO_RESOURCES},
    { IP_BAD_OPTION,            PING_BAD_OPTION},
    { IP_HW_ERROR,              PING_HW_ERROR},
    { IP_PACKET_TOO_BIG,        PING_PACKET_TOO_BIG},
    { IP_REQ_TIMED_OUT,         PING_REQ_TIMED_OUT},
    { IP_BAD_REQ,               PING_BAD_REQ},
    { IP_BAD_ROUTE,             PING_BAD_ROUTE},
    { IP_TTL_EXPIRED_TRANSIT,   PING_TTL_EXPIRED_TRANSIT},
    { IP_TTL_EXPIRED_REASSEM,   PING_TTL_EXPIRED_REASSEM},
    { IP_PARAM_PROBLEM,         PING_PARAM_PROBLEM},
    { IP_SOURCE_QUENCH,         PING_SOURCE_QUENCH},
    { IP_OPTION_TOO_BIG,        PING_OPTION_TOO_BIG},
    { IP_BAD_DESTINATION,       PING_BAD_DESTINATION},
    { IP_NEGOTIATING_IPSEC,     PING_NEGOTIATING_IPSEC},
    { IP_GENERAL_FAILURE,       PING_GENERAL_FAILURE}
};

UINT  num_send=0, num_recv=0, time_min=(UINT)-1, time_max=0, time_total=0;
IPAddr address=0;                      



LPWSTR NlsPutMsg(HMODULE Handle, unsigned usMsgNum, ...);


unsigned long get_pingee(char *ahstr, char **hstr, int *was_inaddr, int dnsreq);

//void print_statistics();

int CDiagnostics::Ping2(WCHAR *warg)
{
    HANDLE IcmpHandle;
    IP_OPTION_INFORMATION SendOpts;
    UCHAR  *Opt = NULL;                // Pointer to send options
    UCHAR  Flags = 0;
    char   SendBuffer[DEFAULT_SEND_SIZE];
    char   RcvBuffer[DEFAULT_BUFFER_SIZE];
    UINT   SendSize = DEFAULT_SEND_SIZE;
    UINT   RcvSize  = DEFAULT_BUFFER_SIZE;
    UINT   i;  
    UINT   j;
    char   *hostname = NULL;
    int    was_inaddr;
    int    dnsreq = 0;
    struct in_addr addr;
    DWORD   numberOfReplies;
    UINT    Count = DEFAULT_COUNT;
    DWORD   errorCode;
    PICMP_ECHO_REPLY  reply;
    LPWSTR wszMsg, wszMsg2, wszMsg3, wszMsg4, wszMsg5;
    int SuccessCount = 0;
    char *arg;

    num_send=0;
    num_recv=0, 
    time_min=(UINT)-1;
    time_max=0;
    time_total=0;
    address=0;                      

    if( warg == NULL )
    {
        wszMsg = NlsPutMsg(g_hModule,PING_NO_MEMORY,GetLastError());
        FormatPing(wszMsg);
        LocalFree(wszMsg);
        return FALSE;
    }

    int len = lstrlen(warg);
    if( len == 0 )
    {
        wszMsg = NlsPutMsg(g_hModule, IDS_PINGMSG_2,warg);
        FormatPing(wszMsg);
        LocalFree(wszMsg);
        return FALSE;
    }

    // Add the '\0' char
    len++;

    arg = (CHAR *)HeapAlloc(GetProcessHeap(),0,len * sizeof(WCHAR));
    if( !arg )
    {
        wszMsg = NlsPutMsg(g_hModule,IDS_PINGMSG_1,GetLastError());
        FormatPing(wszMsg);
        LocalFree(wszMsg);
        return FALSE;
    }
    if( -1 == wcstombs(arg,warg,len) )
    {
        wszMsg = NlsPutMsg(g_hModule, IDS_PINGMSG_2,warg);
        FormatPing(wszMsg);
        LocalFree(wszMsg);
        HeapFree(GetProcessHeap(),0,arg);
        return FALSE;
    }
    
    FormatPing(NULL);

    address = get_pingee(arg, &hostname, &was_inaddr, dnsreq);
    if ( !address || (address == INADDR_NONE) ) {
        wszMsg = NlsPutMsg(g_hModule, IDS_PINGMSG_2,warg);
        FormatPing(wszMsg);
        LocalFree(wszMsg);
        return 0;
        /*
        printf("Ping request could not find host %s. Please check the name and try again.\n",arg);
        exit(1);
        */
    }    


    IcmpHandle = IcmpCreateFile();    

    if (IcmpHandle == INVALID_HANDLE_VALUE) {         
        wszMsg = NlsPutMsg(g_hModule, IDS_PINGMSG_3,GetLastError());
        FormatPing(wszMsg);
        LocalFree(wszMsg);
        return 0;

        /*
        printf( "Unable to contact IP driver, error code %d.\n",
                GetLastError() );        
        exit(1);
        */
    }

    //
    // Initialize the send buffer pattern.
    //
    for (i = 0; i < SendSize; i++) {
        SendBuffer[i] = 'a' + (i % 23);
    }

    
    //
    // Initialize the send options
    //
    SendOpts.OptionsData = NULL;
    SendOpts.OptionsSize = 0;
    SendOpts.Ttl = DEFAULT_TTL;
    SendOpts.Tos = DEFAULT_TOS;
    SendOpts.Flags = Flags;

    addr.s_addr = address;


    if (hostname) {
        wszMsg = NlsPutMsg(g_hModule, IDS_PINGMSG_4,hostname,inet_ntoa(addr),SendSize);
        FormatPing(wszMsg);
        LocalFree(wszMsg);
        /*
        printf("\nPinging %s [%s] with %d bytes of data:\n\n",hostname,inet_ntoa(addr),SendSize);
        */
    }
    else
    {
        wszMsg = NlsPutMsg(g_hModule, IDS_PINGMSG_5,inet_ntoa(addr),SendSize);
        FormatPing(wszMsg);
        LocalFree(wszMsg);

        /*
        printf("\nPinging %s with %d bytes of data:\n\n",inet_ntoa(addr), SendSize);
        */
    }

    for (i = 0; i < Count; i++) {

        if( ShouldTerminate() ) goto end;

        numberOfReplies = IcmpSendEcho2(IcmpHandle,
                                        0,
                                        NULL,
                                        NULL,
                                        address,
                                        SendBuffer,
                                        (unsigned short) SendSize,
                                        &SendOpts,
                                        RcvBuffer,
                                        RcvSize,
                                        DEFAULT_TIMEOUT);       

        num_send++;

        if (numberOfReplies == 0) {

            errorCode = GetLastError();

            if (errorCode < IP_STATUS_BASE) {
                wszMsg = NlsPutMsg(g_hModule, IDS_PINGMSG_6,errorCode);
                FormatPing(wszMsg);
                LocalFree(wszMsg);

                /*
                printf("PING: transmit failed, error code %d.\n",errorCode);
                */
            } else {
                for (j = 0; ErrorTable[j].Error != errorCode &&
                    ErrorTable[j].Error != IP_GENERAL_FAILURE;j++)
                    ;

                wszMsg = NlsPutMsg(g_hModule, ErrorTable[j].ErrorNlsID);
                FormatPing(wszMsg);
                LocalFree(wszMsg);

                /*
                printf("%s\n",ErrorTable[j].ErrorNlsID);
                */
            }

            if (i < (Count - 1)) {
                Sleep(MIN_INTERVAL);
            }

        } else {

            /*
            wszMsg = NlsPutMsg(g_hModule, ErrorTable[j].ErrorNlsID);
            FormatPing(wszMsg);
            LocalFree(wszMsg);
            */

            reply = (PICMP_ECHO_REPLY) RcvBuffer;

            while (numberOfReplies--) {
                struct in_addr addr;

                addr.S_un.S_addr = reply->Address;

                wszMsg = NlsPutMsg(g_hModule, IDS_PINGMSG_7, inet_ntoa(addr));
                /*
                printf("Reply from %s: ",inet_ntoa(addr));
                */
                if (reply->Status == IP_SUCCESS) {

                    wszMsg2 = NlsPutMsg(g_hModule, IDS_PINGMSG_8, wszMsg, (int) reply->DataSize);
                    /*
                    printf("bytes=%d ",(int) reply->DataSize);
                    */
                    if (reply->DataSize != SendSize) {
                        wszMsg3 = NlsPutMsg(g_hModule, IDS_PINGMSG_9, wszMsg2, (int) reply->DataSize);
                        /*
                        printf("(sent %d) ",SendSize);
                        */
                    } else {
                        char *sendptr, *recvptr;

                        sendptr = &(SendBuffer[0]);
                        recvptr = (char *) reply->Data;

                        wszMsg3 = NlsPutMsg(g_hModule, IDS_PINGMSG_14, wszMsg2);
                        for (j = 0; j < SendSize; j++)
                            if (*sendptr++ != *recvptr++) {
                                wszMsg3 = NlsPutMsg(g_hModule, IDS_PINGMSG_10, wszMsg2,j);
                                /*
                                printf("- MISCOMPARE at offset %d - ",j);
                                */
                                break;
                            }                        
                        
                    }

                    if (reply->RoundTripTime) {

                        wszMsg4 = NlsPutMsg(g_hModule, IDS_PINGMSG_11, wszMsg3,reply->RoundTripTime);
                        /*
                        printf("time=%dms ",reply->RoundTripTime);
                        */
                        // Collect stats.

                        time_total += reply->RoundTripTime;
                        if ( reply->RoundTripTime < time_min ) {
                            time_min = reply->RoundTripTime;
                        }
                        if ( reply->RoundTripTime > time_max ) {
                            time_max = reply->RoundTripTime;
                        }
                    }

                    else {

                        wszMsg4 = NlsPutMsg(g_hModule, IDS_PINGMSG_12,wszMsg3);
                        /*
                        printf("time<1ms ");
                        */
                        time_min = 0;
                    }

                    wszMsg5 = NlsPutMsg(g_hModule, IDS_PINGMSG_13, wszMsg4,reply->RoundTripTime);

                    /*
                    printf("TTL=%d\n",(UINT)reply->Options.Ttl);
                    */
                    if (reply->Options.OptionsSize) {
                        // void, we have no options
                        //ProcessOptions(reply, (BOOLEAN) dnsreq);
                    }

                    FormatPing(wszMsg5);
                    if(wszMsg)  LocalFree(wszMsg);
                    if(wszMsg2) LocalFree(wszMsg2);
                    if(wszMsg3) LocalFree(wszMsg3);
                    if(wszMsg4) LocalFree(wszMsg4);
                    if(wszMsg5) LocalFree(wszMsg5);
                    SuccessCount++;
                } else {
                    for (j=0; ErrorTable[j].Error != IP_GENERAL_FAILURE; j++) {
                        if (ErrorTable[j].Error == reply->Status) {
                            break;
                        }
                    }
                    wszMsg = NlsPutMsg(g_hModule, ErrorTable[j].ErrorNlsID);                    
                    FormatPing(wszMsg);
                    LocalFree(wszMsg);
                    /*
                    printf("%s",ErrorTable[j].ErrorNlsID);
                    */
                }

                num_recv++;
                reply++;
            }

            if (i < (Count - 1)) {
                reply--;

                if (reply->RoundTripTime < MIN_INTERVAL) {
                    Sleep(MIN_INTERVAL - reply->RoundTripTime);
                }
            }
        }
    }

    print_statistics();

end:
    
    (void)IcmpCloseHandle(IcmpHandle);

    HeapFree(GetProcessHeap(),0,arg);
    return SuccessCount == Count;
}

unsigned long
get_pingee(char *ahstr, char **hstr, int *was_inaddr, int dnsreq)
{
    struct hostent *hostp = NULL;
    long            inaddr;

    if ( strcmp( ahstr, "255.255.255.255" ) == 0 ) {
        return(0L);
    }

    if ((inaddr = inet_addr(ahstr)) == -1L) {
        hostp = gethostbyname(ahstr);
        if (hostp) {
            /*
             * If we find a host entry, set up the internet address
             */
            inaddr = *(long *)hostp->h_addr;
            *was_inaddr = 0;
        } else {
            // Neither dotted, not name.
            return(0L);
        }

    } else {
        // Is dotted.
        *was_inaddr = 1;
        if (dnsreq == 1) {
            hostp = gethostbyaddr((char *)&inaddr,sizeof(inaddr),AF_INET);
        }
    }

    *hstr = hostp ? hostp->h_name : (char *)NULL;
    return(inaddr);
}


void
CDiagnostics::print_statistics(  )
{
    struct in_addr addr;
    LPWSTR wszMsg;

    if (num_send > 0) {
        addr.s_addr = address;

        if (time_min == (UINT) -1) {  // all times were off.
            time_min = 0;
        }

        wszMsg = NlsPutMsg(g_hModule, IDS_PINGMSG_15,inet_ntoa(addr));                    
        FormatPing(wszMsg);
        LocalFree(wszMsg);

        /*
        printf("\n");
        printf("Ping statistics for %s:\n",inet_ntoa(addr));
        */

        wszMsg = NlsPutMsg(g_hModule, IDS_PINGMSG_16,
                           num_send, num_recv,num_send - num_recv,(UINT) ( 100 * (num_send - num_recv) / num_send ));                    
        FormatPing(wszMsg);
        LocalFree(wszMsg);

        /*
        printf("    Packets: Sent = %d, Received = %d, Lost = %d (%u%% loss)\n",
               num_send, num_recv,num_send - num_recv,(UINT) ( 100 * (num_send - num_recv) / num_send ));
        */
        if (num_recv > 0) {

            wszMsg = NlsPutMsg(g_hModule, IDS_PINGMSG_17);                    
            FormatPing(wszMsg);
            LocalFree(wszMsg);

            /*
            printf("Approximate round trip times in milli-seconds:\n");
            */

            wszMsg = NlsPutMsg(g_hModule, IDS_PINGMSG_18,
                               time_min, time_max, time_total / num_recv);                    
            FormatPing(wszMsg);
            LocalFree(wszMsg);

            /*
            printf("    Minimum = %dms, Maximum = %dms, Average = %dms\n",time_min, time_max, time_total / num_recv);
            */
        }
    }
}

LPWSTR
NlsPutMsg(HMODULE Handle, unsigned usMsgNum, ...)
{
    unsigned msglen;
    VOID * vp = NULL;
    va_list arglist;
    DWORD StrLen;
    WCHAR wszFormat[5000];      //BUGBUG hardcode value
    int ret;

    if( (ret=LoadString(Handle,usMsgNum,wszFormat,5000))!=0 )
    {
        va_start(arglist, usMsgNum);
        if (!(msglen = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | 
                                     FORMAT_MESSAGE_FROM_STRING,
                                     wszFormat,
                                     0,
                                     0L,    // Default country ID.
                                     (LPTSTR)&vp,
                                     0,
                                     &arglist)))

        {
            return NULL; 

        }
    }
    return (LPWSTR)vp;

    /*
    // Convert vp to oem
    StrLen=strlen(vp);
    CharToOemBuff((LPCTSTR)vp,(LPSTR)vp,StrLen);

    msglen = _write(Handle, vp, StrLen);
    LocalFree(vp);

    return(msglen);
    */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\wmi\dglogs\util.h ===
#ifndef UTIL_H
#define UTIL_H

#include "stdafx.h"

void 
ToLowerStr(
    WCHAR *pszwText
    );

WCHAR * 
Space(
    int nSpace
    );

WCHAR * 
Indent(
    int nIndent
    );

BOOLEAN 
IsNumber(
    IN LPCTSTR pszw
    );

BOOLEAN 
wcsstri(
    IN LPCTSTR pszw,
    IN LPCTSTR pszwSrch,
    IN int nLen = -1
    );

BOOLEAN 
IsContained(
    IN LPCTSTR pszwInstance, 
    IN LPCTSTR pszwSrch
    );

HRESULT 
GetVariant(
    IN  _variant_t  &vValue, 
    IN  long        nIndex, 
    OUT _bstr_t     &bstr
    );

BOOLEAN 
IsVariantEmpty(
    _variant_t &vValue
    );

WCHAR *
ids(
    LONG nIndex
    );

BOOLEAN 
IsSameSubnet(
        IN LPCTSTR pszwIP1, 
        IN LPCTSTR pszwIP2, 
        IN LPCTSTR pszwSubnetMask
        );

BOOLEAN 
IsSameSubnet(
    IN _variant_t *vIPAddress, 
    IN _variant_t *vSubnetMask, 
    IN WCHAR *pszwIPAddress2
    );

/*
BOOLEAN 
IsInvalidIPAddress(
    LPCTSTR pszwIPAddress
    );
*/
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\wmi\dglogs\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__664DE28F_B5C4_4970_8235_E7602E03D253__INCLUDED_)
#define AFX_STDAFX_H__664DE28F_B5C4_4970_8235_E7602E03D253__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
extern HMODULE g_hModule;
#include <windows.h>
#include <atlcom.h>
#include <comdef.h>
#include <string>
#include <map>
#include <vector>
#include <list>
#include <wbemidl.h>
#include <wbemcli.h>
#include <winsock2.h>
#include "dglogsres.h"
#include "network.h"
#include <netsh.h>

// Functions loaded from netsh.exe. We can not link to netsh.exe since it conflicts with wmi.exe or something like that.
//
typedef DWORD (WINAPI *RegisterHelper22)(CONST GUID *, CONST NS_HELPER_ATTRIBUTES *);
typedef DWORD (WINAPI *RegisterContext22)(CONST NS_CONTEXT_ATTRIBUTES *);
typedef DWORD (WINAPI *PrintMessage22)(LPCWSTR, ...);


using namespace std;

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__664DE28F_B5C4_4970_8235_E7602E03D253__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\wmi\dglogs\util.cpp ===
#include "util.h"

WCHAR g_szwIds[MAX_PATH + 1];
WCHAR g_szwSpace[MAX_PATH + 1];

WCHAR *
ids(LONG nIndex)
{
    if( LoadString((HINSTANCE)g_hModule,nIndex,g_szwIds,MAX_PATH) )
    {
        return g_szwIds;
    }
    else
    {
        return L"";
    }
}

WCHAR * 
Space(
    int nSpace
    )
{
    for(int i=0; i<nSpace && i< MAX_PATH; i++)
    {
        g_szwSpace[i] = L' ';
    }

    g_szwSpace[i] = L'\0';

    return g_szwSpace;
}

WCHAR * 
Indent(
    int nIndent
    )
{
    return Space(nIndent * 4);
}
BOOLEAN 
IsNumber(
    IN LPCTSTR pszw
    )
{
    if( !pszw )
    {
        return FALSE;
    }
    for(int i=0; pszw[i]!=L'\0'; i++)
    {
        if( !isdigit(pszw[i]) )
        {
            return FALSE;
        }
    }
    return TRUE;
}

BOOLEAN 
IsContained(
    IN LPCTSTR pszwInstance, 
    IN LPCTSTR pszwSrch
    )
/*++

Routine Description
    This method compares two strings and determines if the strings resemble each 
    other. If the strings are identical, then they resemble each other.
    If the search string (pszwSrch) starts or ends with a '*', then the  method
    checks if the search string is contained inside of the instance string (pszwInstance).
    i.e. pszwInstance = 3Com 3C918 Integrated Fast Ethernet Controller (3C905B-TX Compatible)
         pszwSrch = com* |  *com
    then pszwSrch resembles pszwInstance. The string compare is not case sensative.

Arguments
    pszwInstance    The instance string
    pszwSrch        The search string

Return Value
    TRUE if the strings resemble each other
    else FALSE

--*/
{
    LPCTSTR pszw = NULL;
    int nLen;

    if( !pszwSrch || !pszwInstance || lstrcmpi(pszwSrch,L"*")==0 )
    {
        //  The strings are empty, so they match.
        //
        return TRUE;
    }

    if( pszwSrch[0] == L'*' )
    {
        // The search string starts with a '*', check if the search 
        // string is contained in the instance string
        //
        pszw = &pszwSrch[1];
        
        if( wcsstri(pszwInstance,pszw) )
        {
            // Search string is contain within the instance string
            //
            return TRUE;
        }
    }

    nLen = lstrlen(pszwSrch);
    if( nLen > 1 && pszwSrch[nLen -1] == L'*' )
    {
        // The search string ends with a '*'. check if the search 
        // string is contained in the instance string
        //
        if( wcsstri(pszwInstance,pszwSrch,nLen-1) )
        {
            // Search string is contain within the instance string
            //
            return TRUE;
        }
    }
    
    if( lstrcmpi(pszwInstance,pszwSrch) == 0 )
    {
        // No '*'. Check if the strings are the same
        //
        return TRUE;
    }

    // Strings do not resemble each other
    //
    return FALSE;
}

void 
ToLowerStr(
    WCHAR *pszwText
    )
{
    while( pszwText && *pszwText )
    {
        *pszwText = towlower(*pszwText);
        pszwText++;
    }
}

BOOLEAN 
wcsstri(
    IN LPCTSTR pszw,
    IN LPCTSTR pszwSrch,
    IN int nLen
    )
{
    BOOLEAN bMatch = FALSE;
    int i=0,j=0;

    if( !pszw || !pszwSrch )
    {
        // Invalid pointers
        //
        return FALSE;
    }

    for(i=0; pszw[i]!=L'\0'; i++)
    {
        if( j == nLen )
        {
            return bMatch;
        }
        if( pszwSrch[j] == L'\0' )
        {
            return bMatch;
        }
        if( towlower(pszw[i]) == towlower(pszwSrch[j]) )
        {
            j++;
            bMatch = TRUE;
        }
        else
        {
            j=0;
            bMatch = FALSE;
        }
    }

    return FALSE;
}


BOOLEAN IsVariantEmpty(_variant_t &vValue)
{
    _bstr_t bstr;
    if( SUCCEEDED(GetVariant(vValue,0,bstr)) )
    {
        return lstrcmp(bstr,L"") == 0;
    }
    return TRUE;
}

BOOLEAN MakeIPByteArray(LPCTSTR pszwIPAddress, BYTE bIPByte[])
{
    LONG nByteValue = 0;
    LONG nByte = 0;

    for(int i=0; pszwIPAddress[i]!=0; i++)
    {
        if( pszwIPAddress[i] == L'.')
        {
            if( nByteValue > 255 )
            {
                return FALSE;
            }
            bIPByte[nByte] = nByteValue;
            nByteValue = 0;
            nByte++;
        }
        else
        {
            if( !iswdigit(pszwIPAddress[i]) )
            {
                return FALSE;
            }
            nByteValue = nByteValue * 10 + (pszwIPAddress[i] - L'0');
        }
    }
    bIPByte[nByte] = nByteValue;

    return (nByte != 3)?FALSE:TRUE;
}
/*
BOOLEAN IsInvalidIPAddress(LPCTSTR pszwIPAddress)
{
    BYTE bIPByte[4];

    if( MakeIPByteArray(pszwIPAddress,bIPByte) )
    {
        INT iZeroCount = 0;
        INT i255Count = 0;
        for(INT i=0; i<4; i++)
        {
            if( pszwIPAddress[i] == 0 )
            {
                iZeroCount++;
            }

            if( pszwIPAddress[i] == 255 )
            {
                i255Count++;
            }
        }

        if( i255Count == 4 || iZeroCount == 4 )
        {
            return TRUE;
        }
    }

    return FALSE;
}
*/
BOOLEAN 
IsSameSubnet(
        IN LPCTSTR pszwIP1, 
        IN LPCTSTR pszwIP2, 
        IN LPCTSTR pszwSubnetMask
        )
/*++

Routine Description
    This method determines if two IP address are in the same subnet.

Arguments
    pszwIP1         IP Address one
    pszwIP2         IP Address two
    pszwSubnetMask  Subnet mask

Return Value
    TRUE if they are in the same subnet
    FALSE if they are not in the smae subnet

--*/
{
    BYTE bIP1[4];
    BYTE bIP2[4];
    BYTE bSubnetMask[4];
    int iRetVal;

    if( !MakeIPByteArray(pszwIP1,bIP1) )
    {
        return FALSE;
    }
    if( !MakeIPByteArray(pszwIP2,bIP2) )
    {
        return FALSE;
    }
    if( !MakeIPByteArray(pszwSubnetMask,bSubnetMask) )
    {
        return FALSE;
    }


    // Check if IP1 and IP2 are in the same subnet
    //
    for( int i = 0; i< 4; i++)
    {
        // If (IP1 & with Subnetmas) == (IP2 & with subnet) then they are in the same subnet
        //
        if( (bIP1[i] & bSubnetMask[i]) != (bIP2[i] & bSubnetMask[i]) )
        {
            // No the same subnet
            //
            return FALSE;
        }
    }

    // Same subnet
    //
    return TRUE;
}

BOOLEAN 
IsSameSubnet(
    IN _variant_t *vIPAddress, 
    IN _variant_t *vSubnetMask, 
    IN WCHAR *pszwIPAddress2
    )
{
    DWORD i = 0;
    DWORD j = 0;
    _bstr_t bstrIP;
    _bstr_t bstrSubnetMask;

    if( !vIPAddress || !vSubnetMask || !pszwIPAddress2 )
    {
        return FALSE;
    }
    
    while( S_OK == GetVariant(*vIPAddress,i,bstrIP) )
    {
        j = 0;
        while( S_OK == GetVariant(*vSubnetMask,j,bstrSubnetMask) )
        {
            if( IsSameSubnet(bstrIP, pszwIPAddress2, bstrSubnetMask) )
            {
                return TRUE;
            }
            j++;
        }
        i++;
    }

    return FALSE;
}



HRESULT 
GetVariant(
        IN  _variant_t  &vValue, 
        IN  long        nIndex, 
        OUT _bstr_t     &bstr
        )
/*++

Routine Description
    This method extracts nth piece of data from a variant, converts it into a bstring
    and returns the bstring.

Arguments
    vValue      Variant to extract data from
    nIndex      The index into the variant array (for non-arrays nIndex always is 0)
    bstr        Stores the variant as a bstr

Return Value
    S_OK successfull
    else HRESULT

--*/
{
    HRESULT hr = S_FALSE;
    BYTE g[100];
    LPVOID  pData = (LPVOID)g;
    
    WCHAR szw[MAX_PATH];
    _variant_t vTmp;

    if( nIndex >= 25 )
    {
        // The array is to big. We are cutting it short
        return E_INVALIDARG;
    }
    if( (vValue.vt & VT_ARRAY) )
    {
        // The variant contains an array. get the nIndex element from the array
        //
        hr = SafeArrayGetElement(vValue.parray,&nIndex,pData);

        if( S_OK == hr )
        {
            
            // Convert the extracted data into a string
            //
            switch( vValue.vt & ~VT_ARRAY )
            {
            case VT_BSTR:
                bstr = (BSTR)*((BSTR *)pData);
                return S_OK;

            case VT_I2:
                bstr = (short)*((short *)pData);
                return S_OK;

            case VT_I4:
                bstr = (long)*((LONG *)pData);
                return S_OK;

            case VT_UI1:
                bstr = (BYTE)*((BYTE *)pData);
                return S_OK;

            case VT_NULL:
                return S_FALSE;

            case VT_EMPTY:
                return S_FALSE;

            case VT_BOOL:
            {
                if( (VARIANT_BOOL *)pData )
                {
                    bstr = ids(IDS_TRUE);
                }
                else
                {
                    bstr = ids(IDS_FALSE);
                }
            }

            default:
                bstr = L"";
                return S_OK;
            }
        }
    }
    else
    {
        if( nIndex == 0)
        {
            //  The variant is not an array. In this case nIndex always needs to be 0
            //
            if( vValue.vt == VT_NULL || vValue.vt == VT_EMPTY)
            {
                // The variant is empty
                //
                bstr = L"";
                return S_FALSE;
            }
            else if( (vValue.vt == VT_EMPTY) || (vValue.vt == VT_BSTR && lstrlen(vValue.bstrVal) == 0) )
            {
                // The variant is empty
                //
                bstr = L"";
                return S_FALSE;
            }
            else if( vValue.vt == VT_BOOL )
            {
                if( vValue.boolVal )
                {
                    bstr = ids(IDS_TRUE);
                }
                else
                {
                    bstr = ids(IDS_FALSE);
                }
            }
            else
            {
                // The variant contains valid data. Convert the data into a bstring.
                //
                vTmp = vValue;
                vTmp.ChangeType(VT_BSTR);
                bstr = vTmp.bstrVal;
            }
            return S_OK;
        }
    }

    return E_INVALIDARG;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\wmi\dglogs\oe.cpp ===
// oe.cpp
//
#include "oe.h"


/*
HRESULT GetServerAndPort(IN INETSERVER & rServer, OUT CHost & host, OUT DWORD & dwPort)
{
#ifdef UNICODE
    TCHAR wcsServer[128];

    mbstowcs(wcsServer, rServer.szServerName, 128);
	host.SetHost(wcsServer);
#else
	host.SetHost(rServer.szServerName);
#endif
	dwPort = (long)rServer.dwPort;   
    
    return S_OK;
}
*/

enum MAIL_TYPE
{
    MAIL_NONE,
    MAIL_SMTP,
    MAIL_SMTP2,
    MAIL_IMAP,
    MAIL_POP3,
    MAIL_HTTP,
};

HRESULT GetDefaultOutBoundMailServer2(IN  IImnAccount * pIImnAccount,
                                      OUT INETSERVER  & rServer,
                                      OUT DWORD       & dwMailType)
{    
    ISMTPTransport     *pSMTPTransport;
    ISMTPTransport2    *pSMTPTransport2;
    HRESULT hr;

    // Create the SMTP transport object
    //
    hr = CoCreateInstance(CLSID_ISMTPTransport, NULL, CLSCTX_INPROC_SERVER, IID_ISMTPTransport, (LPVOID *)&pSMTPTransport);
    if( SUCCEEDED(hr) )
    {
        // Get the SMTP server information
        //
		hr = pSMTPTransport->InetServerFromAccount(pIImnAccount, &rServer);
        dwMailType = MAIL_SMTP;
        pSMTPTransport->Release();
    }

    if( FAILED(hr) )
    {
        // Unable to get SMTP server info, lets try and get SMTP transport 2 server information
        // 
        hr = CoCreateInstance(CLSID_ISMTPTransport, NULL, CLSCTX_INPROC_SERVER, IID_ISMTPTransport2, (LPVOID *)&pSMTPTransport2);
        if( SUCCEEDED(hr) )
        {
            // Get SMTP2 server info
            //
            hr = pSMTPTransport2->InetServerFromAccount(pIImnAccount, &rServer);
            dwMailType = MAIL_SMTP2;
            pSMTPTransport->Release();
        }
    }

    if( FAILED(hr) )
    {
        // Make sure to clear the struct
        //
        memset(&rServer,0,sizeof(rServer));
        dwMailType = MAIL_NONE;
    }
    
    return hr;
}


HRESULT GetDefaultInBoundMailServer2(IN  IImnAccount * pIImnAccount,
                                     OUT INETSERVER  & rServer,
                                     OUT DWORD       & dwMailType)
{    
    IPOP3Transport *pPOP3Transport;
    IIMAPTransport *pIMAPTransport;
    IHTTPMailTransport *pHTTPTransport;
    HRESULT hr;


    // Create the HTTP transport object
    //
    hr = CoCreateInstance(CLSID_IHTTPMailTransport, NULL, CLSCTX_INPROC_SERVER, IID_IHTTPMailTransport, (LPVOID *)&pHTTPTransport);
    if( SUCCEEDED(hr) )
    {
        // Get the HTTP server information
        //
		hr = pHTTPTransport->InetServerFromAccount(pIImnAccount, &rServer);
        dwMailType = MAIL_HTTP;
        pHTTPTransport->Release();
    }

    if( FAILED(hr) )
    {
        // Create the POP3 transport object
        //
        hr = CoCreateInstance(CLSID_IPOP3Transport, NULL, CLSCTX_INPROC_SERVER, IID_IPOP3Transport, (LPVOID *)&pPOP3Transport);
        if( SUCCEEDED(hr) )
        {
            // Get the POP3 server information
            //
		    hr = pPOP3Transport->InetServerFromAccount(pIImnAccount, &rServer);
            dwMailType = MAIL_POP3;
            pPOP3Transport->Release();
        }
    }

    if( FAILED(hr) )
    {
        // Create the SMTP transport object
        //
        hr = CoCreateInstance(CLSID_IIMAPTransport, NULL, CLSCTX_INPROC_SERVER, IID_IIMAPTransport, (LPVOID *)&pIMAPTransport);
        if( SUCCEEDED(hr) )
        {
            // Get the SMTP server information
            //
			hr = pIMAPTransport->InetServerFromAccount(pIImnAccount, &rServer);
            dwMailType = MAIL_IMAP;            
            pIMAPTransport->Release();
        }
   }


    if( FAILED(hr) )
    {
        memset(&rServer,0,sizeof(rServer));    
        dwMailType = MAIL_NONE;
    }
    
    return hr;
}


HRESULT GetOEDefaultMailServer2(OUT INETSERVER & rInBoundServer,
                                OUT DWORD      & dwInBoundMailType,
                                OUT INETSERVER & rOutBoundServer,
                                OUT DWORD      & dwOutBoundMailType)
{   
    IImnAccountManager2 *pIImnAccountManager2 = NULL;
    IImnAccountManager  *pIImnAccountManager = NULL;
    IImnAccount         *pIImnAccount = NULL;
    HRESULT hr;


    hr = CoCreateInstance(CLSID_ImnAccountManager, NULL, CLSCTX_INPROC_SERVER, IID_IImnAccountManager, (void**)&pIImnAccountManager);	
    if( SUCCEEDED(hr) )
    {
	    hr = pIImnAccountManager->QueryInterface(__uuidof(IImnAccountManager2), (void**)&pIImnAccountManager2);
	    if(SUCCEEDED(hr))
	    {
		    hr = pIImnAccountManager2->InitUser(NULL, (GUID)UID_GIBC_DEFAULT_USER, 0);

	    }   
	
        if(SUCCEEDED(hr))
	    {        
		    hr = pIImnAccountManager->Init(NULL);
	    }

        if( SUCCEEDED(hr) )
        {
	        hr = pIImnAccountManager->GetDefaultAccount(ACCT_MAIL, &pIImnAccount);
	        if( SUCCEEDED(hr) )
            {      
                HRESULT hr2, hr3;

                hr = E_FAIL;

                hr2 = GetDefaultInBoundMailServer2(pIImnAccount,rInBoundServer,dwInBoundMailType);
                hr3 = GetDefaultOutBoundMailServer2(pIImnAccount,rOutBoundServer,dwOutBoundMailType);

                if( SUCCEEDED(hr2) || SUCCEEDED(hr3) )
                {
                    hr = S_OK;
                }
                pIImnAccount->Release();
            }
        }

        pIImnAccountManager->Release();
        if( pIImnAccountManager2 )
        {
            pIImnAccountManager2->Release();
        }
    }

    return hr;
}


HRESULT GetOEDefaultNewsServer2(OUT INETSERVER & rNewsServer)
{   
    IImnAccountManager2 *pIImnAccountManager2 = NULL;
    IImnAccountManager  *pIImnAccountManager = NULL;
    IImnAccount         *pIImnAccount = NULL;
    INNTPTransport    	*pNNTPTransport;	
    HRESULT hr;


    hr = CoCreateInstance(CLSID_ImnAccountManager, NULL, CLSCTX_INPROC_SERVER, IID_IImnAccountManager, (void**)&pIImnAccountManager);	
    if( SUCCEEDED(hr) )
    {
	    hr = pIImnAccountManager->QueryInterface(__uuidof(IImnAccountManager2), (void**)&pIImnAccountManager2);
	    if(SUCCEEDED(hr))
	    {
		    hr = pIImnAccountManager2->InitUser(NULL, (GUID)UID_GIBC_DEFAULT_USER, 0);

	    }   
	
        if(SUCCEEDED(hr))
	    {        
		    hr = pIImnAccountManager->Init(NULL);
	    }

        if( SUCCEEDED(hr) )
        {
	        hr = pIImnAccountManager->GetDefaultAccount(ACCT_NEWS, &pIImnAccount);
	        if( SUCCEEDED(hr) )
            {
		        hr = CoCreateInstance(CLSID_INNTPTransport, NULL, CLSCTX_INPROC_SERVER, IID_INNTPTransport, (LPVOID *)&pNNTPTransport);
		        if(SUCCEEDED(hr))
		        {

			        hr = pNNTPTransport->InetServerFromAccount(pIImnAccount, &rNewsServer);                
                    pIImnAccount->Release();
                }
            }
        }

        pIImnAccountManager->Release();
        if( pIImnAccountManager2 )
        {
            pIImnAccountManager2->Release();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\wmi\dglogs\wmigateway.cpp ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:

    dglogswmi.cpp

Abstract:

    The file contains the methods for class CWmi. CWmi retrives information from WMI
    
--*/
#include "StdAfx.h"
#include "WmiGateway.h"
#include <wbemtime.h>
/*++

Routine Description
    The worker thread uses this function to check if the main thread has canceled the worker thread.
    i.e. the work thread should abort what ever it is doing, clean up and terminate.

Arguments
    none

Return Value
    TRUE the worker thread has been terminated
    FALSE the worker thread has not been terminated

--*/
inline BOOL CWmiGateway::ShouldTerminate()
{
    if( m_bTerminate )
    {
        return TRUE;
    }

    if (WaitForSingleObject(m_hTerminateThread, 0) == WAIT_OBJECT_0)
    {
        m_bTerminate = FALSE;
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


CWmiGateway::CWmiGateway()
/*++

Routine Description
    Constructor, initializes member variables and creates the Wbem class object

Arguments
    none

Return Value
    none

--*/
{
    HRESULT hr = S_OK;
    m_wstrMachine = L".";
    m_pWbemLocater = NULL;
}

BOOL
CWmiGateway::WbemInitialize(INTERFACE_TYPE bInterface)
{
    HRESULT hr = E_FAIL;

    // Initialize COM
    //
    if( bInterface == COM_INTERFACE )
    {
        hr = CoInitializeEx(NULL,COINIT_MULTITHREADED); //COINIT_APARTMENTTHREADED );    
    }
    else if(  bInterface == NETSH_INTERFACE )
    {
        hr = CoInitializeEx(NULL,COINIT_APARTMENTTHREADED); //COINIT_APARTMENTTHREADED );    
    }
    if( FAILED(hr) )    // RPC_E_CHANGED_MODE
    {
        // Failed to initialize com
        //
        return E_FAIL;
    }

    // Create the WMI object
    //
    hr = CoCreateInstance(CLSID_WbemLocator,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IWbemLocator,
                          (void **)&m_pWbemLocater); 

    if( FAILED(hr) )
    {
        m_pWbemLocater = NULL;
        return FALSE;
    }

    return TRUE;
}

VOID CWmiGateway::SetMachine(WCHAR *pszwMachine)
{
    EmptyCache();
    m_wstrMachine = pszwMachine;
}

IWbemServices *
CWmiGateway::GetWbemService(
        IN LPCTSTR pszwService
        )
/*++

Routine Description
    Connects to a Wbem Service (Repository i.e. root\default). The connection to the Wbem service
    is cached so if the Service is requested again, the service is retrived from the cache. When 
    the class is destroyed the connection to the cached Wbem services is released.

Arguments
    pszwService     Wbem Service to connect to. (i.e. root\default)

Return Value
    A pointer to the Wbem service connection. 
    If the connection fails, the method returns NULL

--*/
{
    WbemServiceCache::iterator iter;
    IWbemServices *pWbemServices = NULL;
    //WCHAR szPath[MAX_PATH];

    _bstr_t bstrService;
    HRESULT hr;

    if( !m_pWbemLocater )
    {
        // Wbem class object was not created.
        //
        return NULL;
    }
    
    //wsprintf(szPath,L"\\\\%s%s", L"."/*m_wstrMachine.c_str()*/, pszwService); //L"\\\\%s%s", /*m_wstrMachine.c_str()*/L".\\",  pszwService );
    //MessageBox(NULL,szPath,NULL,MB_OK);
    // Check if the wbem service is cached.
    //
    iter = m_WbemServiceCache.find(pszwService);

    if( iter == m_WbemServiceCache.end() )
    {
        // We did not create and cache the wbem service yet, do it now
        //
        hr = m_pWbemLocater->ConnectServer(_bstr_t(pszwService),
                                           NULL,                    // User name 
                                           NULL,                    // user password
                                           NULL,NULL,NULL,NULL,
                                           &pWbemServices);
        if( SUCCEEDED(hr) )
        {
            // Set the authentication information for the WbemService
            //
            hr = CoSetProxyBlanket(pWbemServices,
                                   RPC_C_AUTHN_WINNT,
                                   RPC_C_AUTHZ_NONE,
                                   NULL,
                                   RPC_C_AUTHN_LEVEL_CALL,
                                   RPC_C_IMP_LEVEL_IMPERSONATE,
                                   NULL,
                                   EOAC_NONE);

            if( SUCCEEDED(hr) )
            {
                // Cache the newly created WbemService
                //
                m_WbemServiceCache[pszwService] = pWbemServices;
            }
            else
            {
                // Failed to set the proxy blankey on the service, release the wbem service
                //
                pWbemServices->Release();
                pWbemServices = NULL;
            }
        }
        
        return pWbemServices;

    }

    // We found the requested WbemService in our cache, return it
    //
    return iter->second;
}

IEnumWbemClassObject * 
CWmiGateway::GetEnumWbemClassObject(
        IN LPCTSTR pszwService,
        IN LPCTSTR pszwNameSpace
        )
/*++

Routine Description
    Creates an IEnumWbemClassObject. The IEnumWbemClassObject contains all of the instance
    of a class object. This pointer is not chached, since the instances are a snap shot
    of WMI at the time the object is created. So if we reuse the class object the data
    will be out-of-date. The caller must release the created IEnumWbemClassObject 
    (i.e. pEnumWbemClassObject->Release() );

Arguments
    pszwService     Wbem Service to connect to. (i.e. root\default)
    pszwNameSpace   Wbem Name space to connect to. (i.e. NetDiagnostics, Win32_NetworkAdapterConfiguration)

Return Value
    A pointer to the IEnumWbemClassObject. 
    If the the class object can not be created, the method reurns NULL

--*/
{
    IWbemServices *pWbemServices = NULL;
    IEnumWbemClassObject *pEnumWbemClassObject = NULL;

    // Get the requested WbemService
    //
    pWbemServices = GetWbemService(pszwService);

    if( pWbemServices )
    {
        // Create the EnumWbemClassObject. No need to check the 
        // return value. If this function fails pEnumWbemClassObject 
        // will be NULL
        //
        (void)pWbemServices->CreateInstanceEnum(_bstr_t(pszwNameSpace),
                                                0L,
                                                NULL,
                                                &pEnumWbemClassObject);
    }

    return pEnumWbemClassObject;
}

IWbemClassObject * 
CWmiGateway::GetWbemClassObject(
        LPCTSTR pszwService,
        LPCTSTR pszwNameSpace,
        const int nInstance)
/*++

Routine Description
    Creates an IWbemClassObject. The IWbemClassObject is an instance of the IEnumWbemClassObject
    This pointer is not chached, since the instance is a snap shot of WMI at the time the object 
    is created. So if we reuse the class object the data will be out-of-date. The caller must release 
    the IWbemClassObject (i.e. pWbemClassObject->Release() )

Arguments
    pszwService     Wbem Service to connect to. (i.e. root\default)
    pszwNameSpace   Wbem Name space to connect to. (i.e. NetDiagnostics, Win32_NetworkAdapterConfiguration)
    nInstance       The instance of IEnumWbemClassObject to retrive. Default is to grab the first instance (nInstance  0)

Return Value
    A pointer to the IWbemClassObject
    If the class object can not be created, the method returns NULL.

--*/
{
    IEnumWbemClassObject *pEnumWbemClassObject = NULL;
    IWbemClassObject *pWbemClassObject = NULL;
    ULONG uReturned;
    HRESULT hr;

    // Get the EnumWbemClass object (Contains all of the instances)
    //
    pEnumWbemClassObject = GetEnumWbemClassObject(pszwService,pszwNameSpace);

    if( pEnumWbemClassObject )
    {
        // Jump to the nth instance
        //
        hr = pEnumWbemClassObject->Skip(WBEM_INFINITE, nInstance);
        
        if( WBEM_S_NO_ERROR == hr )
        {
            // Get the nth classobject (i.e. instance). If this call fails pWbemClassObject is NULL
            // Next grabs the instances you skipped to.
            //
            hr = pEnumWbemClassObject->Next(WBEM_INFINITE,
                                            1,
                                            &pWbemClassObject,
                                            &uReturned);
        }

        // Release the IEnumWbemClassObject
        //
        pEnumWbemClassObject->Release();
    }

    return pWbemClassObject;
}

    
void CWmiGateway::ReleaseAll(IEnumWbemClassObject *pEnumWbemClassObject, IWbemClassObject *pWbemClassObject[], int nInstances)
{
    if( pWbemClassObject )
    {
        for(ULONG i = 0; i < nInstances; i++)
        {
            if( pWbemClassObject[i] )
            {
                pWbemClassObject[i]->Release();
                pWbemClassObject[i] = NULL;
            }
        }                                           
    }
    if( pEnumWbemClassObject )
    {
        pEnumWbemClassObject->Release();
    }
}

HRESULT 
CWmiGateway::GetWbemProperties(     
        IN OUT  EnumWbemProperty &EnumProp
        )
{
    
    HRESULT hr = S_OK;
    EnumWbemProperty::iterator iter, iter2;
    IWbemServices *pWbemServices = NULL;
    IEnumWbemClassObject *pEnumWbemClassObject = NULL;        
    IWbemClassObject *pWbemClassObject[100]; // = NULL;
    WCHAR pszwRepository[MAX_PATH * 80] = L""; 
    WCHAR pszwNamespace[MAX_PATH * 80] = L"";  
    ULONG   nInstances = 0;

    m_wstrWbemError = L"";

    for( iter = EnumProp.begin(); iter != EnumProp.end(); iter++)
    {
        if( iter->pszwRepository && lstrcmpi(iter->pszwRepository,pszwRepository) != 0 )
        {            
            if( pWbemServices )
            {
                pWbemServices->Release();
                pWbemServices = NULL;
            }

            lstrcpy(pszwRepository,iter->pszwRepository);
            lstrcpy(pszwNamespace, L"");
            pWbemServices = GetWbemService(pszwRepository);
            if( ShouldTerminate() ) goto End;
            if( !pWbemServices )
            {
                if( !m_wstrWbemError.empty() )
                {
                    m_wstrWbemError += L";";
                }
                m_wstrWbemError += wstring(L"Unable to connect to WMI service '") + wstring(pszwRepository) + wstring(L"'");
            }
        }
        
        if( iter->pszwNamespace && lstrcmpi(pszwNamespace, iter->pszwNamespace)  != 0 )
        {
            lstrcpy(pszwNamespace, iter->pszwNamespace);

            if( pWbemServices )
            {

                ReleaseAll(pEnumWbemClassObject,pWbemClassObject,nInstances);

                hr = pWbemServices->CreateInstanceEnum(_bstr_t(pszwNamespace),
                                                       0L,
                                                       NULL,
                                                       &pEnumWbemClassObject);

                if( SUCCEEDED(hr) )
                {
                    hr = pEnumWbemClassObject->Next(WBEM_INFINITE,
                                                100,             // Get all of the instances
                                                pWbemClassObject,
                                                &nInstances);
                    if( ShouldTerminate() )  goto End;
                    if( SUCCEEDED(hr) )
                    {
                        for(ULONG i = 0; i< nInstances; i++)
                        {
                            (void)pWbemClassObject[i]->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY);
                        }
                    }
                }
                else
                {
                    if( !m_wstrWbemError.empty() )
                    {
                        m_wstrWbemError += L";";
                    }
                    m_wstrWbemError += wstring(L"Unable to connect to WMI namespace '") + wstring(pszwNamespace) + wstring(L"'");
                }

            }
        }

        if( pWbemClassObject && nInstances)
        {
            VARIANT vValue;

            VariantInit(&vValue);

            if( !iter->pszwName || lstrcmp(iter->pszwName,L"") == 0)
            {
                BSTR bstrFieldname;
                int nProperty = 0;
                CIMTYPE CimType;
                
                while( WBEM_S_NO_ERROR == pWbemClassObject[0]->Next(0,&bstrFieldname, NULL, &CimType, NULL) )
                {
                    if( ShouldTerminate() )  goto End;

                    if( lstrcmp((WCHAR *)bstrFieldname,L"OEMLogoBitmap")==0 ) continue;
                    // Do not get arrays they are to did handles i.e. bitmaps
                    //if( CimType == CIM_FLAG_ARRAY ) continue;                    

                    if( nProperty == 0 )
                    {
                        iter->SetProperty((WCHAR *)bstrFieldname,0);
                        iter2 = iter;
                        iter2++;
                    }
                    else
                    {
                        if( iter2 == EnumProp.end() )
                        {
                            EnumProp.push_back(WbemProperty((WCHAR *)bstrFieldname,0,NULL,NULL));
                            iter2 = EnumProp.end();
                        }
                        else
                        {                            
                            iter2 = EnumProp.insert(iter2,WbemProperty((WCHAR *)bstrFieldname,0,NULL,NULL));
                            iter2++;
                        }
                    }

                    SysFreeString(bstrFieldname);
                    nProperty++;
                }
            }

            for(ULONG i = 0; i < nInstances; i++)
            {        
                HRESULT hr;
                CIMTYPE vtType;
                hr = pWbemClassObject[i]->Get(iter->pszwName,0,&vValue,&vtType,NULL);
                if( ShouldTerminate() )  goto End;
                if( SUCCEEDED(hr) )
                {
                    if( vValue.vt != VT_NULL && vtType == CIM_DATETIME && vValue.bstrVal!=  NULL && lstrcmp((WCHAR *)vValue.bstrVal,L"")!=0 )
                    {
                        
                        WBEMTime wt(vValue.bstrVal);
                        
                        WCHAR szBuff[MAX_PATH];
                        WCHAR szwDateTime[MAX_PATH*2];
                        SYSTEMTIME SysTime;
                        if( wt.GetSYSTEMTIME(&SysTime) )
                        {
                            FILETIME FileTime, LocalFileTime;
                            SYSTEMTIME UTCTIme, LocalTime;
                            memcpy(&UTCTIme,&SysTime,sizeof(SYSTEMTIME));
                            SystemTimeToFileTime(&UTCTIme,&FileTime);
                            FileTimeToLocalFileTime(&FileTime, &LocalFileTime);
                            FileTimeToSystemTime(&LocalFileTime, &LocalTime); 
                            memcpy(&SysTime,&LocalTime,sizeof(SYSTEMTIME));


                            lstrcpy(szwDateTime,L"");

                            if (0 != GetTimeFormat(LOCALE_USER_DEFAULT, //GetThreadLocale(), 
                                                   0, 
                                                   &SysTime, 
                                                   NULL,
                                                   szBuff, 
                                                   sizeof(szBuff)))
                            {                                
                                //vValue.bstrVal = szBuff;
                                lstrcpy(szwDateTime,szBuff);
                            } 

                            if (0 != GetDateFormat(LOCALE_USER_DEFAULT, //GetThreadLocale(), 
                                                   0, 
                                                   &SysTime, 
                                                   NULL,
                                                   szBuff, 
                                                   sizeof(szBuff)))
                            {
                                //vValue.bstrVal = szBuff;
                                wsprintf(szwDateTime,L"%s %s",szwDateTime,szBuff);
                            } 
                            //SysFreeString(vValue.bstrVal);
                            VariantClear(&vValue);
                            vValue.bstrVal = SysAllocString((WCHAR *)szwDateTime);                            
                            vValue.vt = VT_BSTR;
                        }
                        
                        
                    }
                    iter->Value.push_back(vValue);
                    VariantClear(&vValue);
                }
            }
        }
    }


End:
    ReleaseAll(pEnumWbemClassObject,pWbemClassObject,nInstances);        
    return hr;
}


HRESULT 
CWmiGateway::GetWbemProperty(
        IN  LPCTSTR    pszwService,
        IN  LPCTSTR    pszwNameSpace,
        IN  LPCTSTR    pszwField,
        OUT _variant_t & vValue
        )
{
    IWbemClassObject *pWbemClassObject;
    HRESULT hr = S_OK;
    
    pWbemClassObject = GetWbemClassObject(pszwService,pszwNameSpace);
    if( pWbemClassObject )
    {
        hr = pWbemClassObject->Get(pszwField,
                                   0,
                                   &vValue,
                                   NULL,
                                   NULL);        

        pWbemClassObject->Release();
    }

    return hr;
    
}

void CWmiGateway::EmptyCache()
{
    
    // Empty the WbemService cache
    //
    //DebugBreak();


    m_WbemServiceCache.erase(m_WbemServiceCache.begin(), 
                             m_WbemServiceCache.end());
    
}

// Netsh does not free its helpers if it is aborted or the user runs netsh with /?
// The Wbem object dissapears from under neath us. try and except do not work inside 
// of the destructor.
//
ReleaseWbemObject(IWbemLocator *p)
{
    __try
    {
        p->Release();
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        //DebugBreak();
    }

    return 0;
}
CWmiGateway::~CWmiGateway()
/*++

Routine Description
    Destructor, free all member variables and release the wbem connection

Arguments
    none

Return Value
    none

--*/
{    
    //DebugBreak();



    EmptyCache();

    if( m_pWbemLocater )
    {
        ReleaseWbemObject(m_pWbemLocater);
        m_pWbemLocater = NULL;       

    }
    
    
    CoUninitialize();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\wmi\dgnet\async.hh ===
// async.hh
//

#include "command.h"
#include "queue.h"
#include "worker.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\wmi\dgnet\command.h ===
// command.h
//

#pragma once

class CCommand
{
public:
    virtual ~CCommand() {};

	virtual void Go()=0;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\wmi\dgnet\alloc.h ===
// alloc.h
//
//  Allocator that uses the process heap.  new/delete gets confused across
//  the dll boundary
//

#pragma once

#ifndef __ALLOC_H
#define __ALLOC_H

// TEMPLATE FUNCTION _Allocate
template<class _Ty> inline
	_Ty _FARQ *_Heap_Allocate(_PDFT _N, _Ty _FARQ *)
	{if (_N < 0)
		_N = 0;
	return ((_Ty _FARQ *)HeapAlloc(GetProcessHeap(), 0,
		(_SIZT)_N * sizeof (_Ty))); }

// TEMPLATE CLASS allocator

template<class _Ty>
	class heap_allocator {
public:
	typedef _SIZT size_type;
	typedef _PDFT difference_type;
	typedef _Ty _FARQ *pointer;
	typedef const _Ty _FARQ *const_pointer;
	typedef _Ty _FARQ& reference;
	typedef const _Ty _FARQ& const_reference;
	typedef _Ty value_type;
	pointer address(reference _X) const
		{return (&_X); }
	const_pointer address(const_reference _X) const
		{return (&_X); }
	
    pointer allocate(size_type _N, const void *)
		{return (_Heap_Allocate((difference_type)_N, (pointer)0)); }
	
    char _FARQ *_Charalloc(size_type _N)
		{return (_Heap_Allocate((difference_type)_N,
			(char _FARQ *)0)); }
	
    void deallocate(void _FARQ *_P, size_type)
        { HeapFree(GetProcessHeap(), 0, _P); }
	
    void construct(pointer _P, const _Ty& _V)
		{_Construct(_P, _V); }
	void destroy(pointer _P)
		{_Destroy(_P); }
	_SIZT max_size() const
		{_SIZT _N = (_SIZT)(-1) / sizeof (_Ty);
		return (0 < _N ? _N : 1); }

    bool operator== (const heap_allocator& rhs)
    {   return true; }
	};

#endif // __ALLOC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\wmi\dglogs\wmigateway.h ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:

    WmiGateway.h

Abstract:

    The file contains the the class definition for CWmiGateway. CWmiGateway is a class
    that extracts information from WMI,
    
--*/

#pragma once

#include "stdafx.h"
#ifndef WMIGATEWAY_H
#define WMIGATEWAY_H

// Defines which interface the client is using to communicate with us
//
typedef enum
{
    NO_INTERFACE    = 0,
    COM_INTERFACE   = 1,
    NETSH_INTERFACE = 2,
}INTERFACE_TYPE;

// A cache for all the repositories opened. We cache this information since it can take a long time
// to connect to a repository through WMI.
//
typedef map<wstring, CComPtr<IWbemServices> > WbemServiceCache; 

struct Property
{
public:
    void SetProperty(LPCTSTR pszwPropertyName, BOOLEAN bPropertyFlags)
    {
        if( pszwPropertyName )
        {
            pszwName = new WCHAR[lstrlen(pszwPropertyName) + 1];
            if( pszwName )
            {
                lstrcpy(pszwName,pszwPropertyName);
            }
        }
        else
        {
            pszwName = NULL;
        }
        bFlags   = bPropertyFlags;
    }



public:
    Property()
    {
        pszwName = NULL;
    }

    Property(const Property *ref):Value(ref->Value)
    {
        if( ref != this )
        {
            SetProperty(ref->pszwName,ref->bFlags);
        }
    }

    Property(const Property &ref):Value(ref.Value)
    {
        if( &ref != this )
        {
            SetProperty(ref.pszwName,ref.bFlags);
        }
    }

    Property(LPCTSTR pszwPropertyName, BOOLEAN bPropertyFlags = 0)
    {
        SetProperty(pszwPropertyName,bPropertyFlags);
    }

    void Clear()
    {
        if ( pszwName )
        {
            delete pszwName;
            pszwName = NULL;
        }

        Value.clear();
    }

    ~Property()
    {
        Clear();
    }

public:
    LPTSTR  pszwName;
    BOOLEAN bFlags;
       
    typedef vector< _variant_t > Values;

    Values Value;
};

typedef list< Property > EnumProperty;


struct WbemProperty: public Property
{
    
public:
    void SetWbemProperty(LPCTSTR pszwWbemRepository = NULL, LPCTSTR pszwWbemNamespace = NULL)
    {
        if( pszwWbemRepository != NULL )
        {
            pszwRepository = new WCHAR[lstrlen(pszwWbemRepository) + 1];
            if( pszwRepository )
            {
                lstrcpy(pszwRepository,pszwWbemRepository);
            }
        }
        else
        {
            pszwRepository = NULL;
        }

        if( pszwWbemNamespace != NULL )
        {
            pszwNamespace = new WCHAR[lstrlen(pszwWbemNamespace) + 1];
            if( pszwNamespace )
            {
                lstrcpy(pszwNamespace,pszwWbemNamespace);
            }
        }
        else
        {
            pszwNamespace = NULL;
        }
    }

public:
    WbemProperty()
    {
        pszwRepository = NULL;
        pszwNamespace = NULL;
    }

    WbemProperty(const WbemProperty * ref):Property(ref->pszwName,ref->bFlags)
    {
        if( ref != this )
        {
            SetWbemProperty(ref->pszwRepository,ref->pszwNamespace);
        }
    }
    
    WbemProperty(const WbemProperty & ref): Property(ref.pszwName,ref.bFlags)
    {
        if( &ref != this )
        {
            SetWbemProperty(ref.pszwRepository,ref.pszwNamespace);
        }
    }

    WbemProperty(LPCTSTR pszwPropertyName, BOOLEAN bPropertyFlags = 0, LPCTSTR pszwWbemRepository = NULL, LPCTSTR pszwWbemNamespace = NULL):
        Property(pszwPropertyName,bPropertyFlags)
    {
        SetWbemProperty(pszwWbemRepository,pszwWbemNamespace);
    }

    ~WbemProperty()
    {
        if ( pszwRepository )
        {
            delete pszwRepository;
        }
        if ( pszwNamespace )
        {
            delete pszwNamespace;
        }

        pszwRepository = NULL;
        pszwNamespace = NULL;

    }
    LPTSTR pszwRepository;
    LPTSTR pszwNamespace;
};


typedef list< WbemProperty > EnumWbemProperty;


class CWmiGateway
/*++

Class Description
    TBD
--*/
{
public:
    CWmiGateway();

    void SetCancelOption(HANDLE hTerminateThread)
    {
        m_hTerminateThread = hTerminateThread;
        m_bTerminate = FALSE;
    }

inline BOOL CWmiGateway::ShouldTerminate();

private:
    HANDLE m_hTerminateThread;
    BOOL m_bTerminate;
    wstring m_wstrMachine;

public:
    BOOL WbemInitialize(INTERFACE_TYPE bInterface);

    VOID SetMachine(WCHAR *pszwMachine);
    void EmptyCache();

    IWbemServices * 
    GetWbemService(
            IN LPCTSTR pszService
            );

    IEnumWbemClassObject * 
    GetEnumWbemClassObject(
            IN LPCTSTR pszwService,
            IN LPCTSTR pszwNameSpace
            );

    IWbemClassObject * 
    GetWbemClassObject(
            IN LPCTSTR   pszwService,
            IN LPCTSTR   pszwNameSpace,
            IN const int nInstance = 0
            );

HRESULT 
CWmiGateway::GetWbemProperties(     
        IN OUT  EnumWbemProperty &EnumProp
        );

void 
ReleaseAll(
        IN IEnumWbemClassObject *pEnumWbemClassObject, 
        IN IWbemClassObject *pWbemClassObject[], 
        IN int nInstance
        );

HRESULT 
GetWbemProperty(
        IN  LPCTSTR    pszwService,
        IN  LPCTSTR    pszwNameSpace,
        IN  LPCTSTR    pszwField,
        OUT _variant_t &vValue
        );

    ~CWmiGateway();

    wstring m_wstrWbemError;
private:
    IWbemLocator     *m_pWbemLocater;
    WbemServiceCache m_WbemServiceCache; 
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\wmi\dgnet\connect.cpp ===
// connect.cpp
//
#pragma hdrstop

#include "host.h"

HRESULT Connect (CHost& host, INT port, bool& bRet)
{
    SOCKET s;
    SOCKADDR_IN sAddr;
    HRESULT hr;

    s= socket(AF_INET, SOCK_STREAM, PF_UNSPEC);

    if (INVALID_SOCKET == s)
    {
        bRet = false;
        return WSAGetLastError();
    }

    // Bind this socket to the server's socket address
    memset(&sAddr, 0, sizeof (sAddr));
    sAddr.sin_family = AF_INET;
    sAddr.sin_addr.s_addr = host;
    sAddr.sin_port = htons((u_short)port);
    
    if (connect(s, (SOCKADDR*)&sAddr, sizeof(SOCKADDR_IN)) == 0)
    {
        bRet = true;
        closesocket(s);
        return S_OK;
    }
    else
    {
        bRet = false;
        hr = WSAGetLastError();
        closesocket(s);
        return hr;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\wmi\dgnet\autoall.h ===
// autoall.h
//
// A plethora of smart pointers / objects
//
// INDEX:
// auto_bstr    - BSTR
// auto_tm      - CoTaskFreeMemory
// auto_sid     - FreeSid
// auto_sa      - SafeArray
// auto_rel     - COM 
// auto_reg     - HKEY
// auto_pv      - PROPVARIANT
// auto_prg     - [] delete (pointer to range)
// pointer      - delete
// auto_hr      - throw HRESULT
// auto_os      - throw DWORD
// auto_imp     - Impersonation / Rever
// auto_handle  - HANDLE 
// auto_cs      - CriticalSection
// auto_leave   - LeaveCriticalSection
// auto_var     - VARIANT
// auto_virt    - VirtualFree 
// RCObject     - Reference counting
// RCPtr<T>
// auto_menu    - DestroyMenu
//
// History:
//      1/25/99 anbrad Unified from many differnt files created over the ages
//      2/8/99  anbrad added auto_menu

// auto_bstr ******************************************************************
//
// Smart Pointers for BSTR

#pragma once

#include <xstddef>

// Forward declarations
//
// If you get class not defined you may just need to include a file or two.
// These are listed below.

    class auto_bstr;    // (oleauto.h)  __wtypes_h__
template<class _Ty>
    class auto_tm;      //
    class auto_sid;     //
    class auto_sa;      // (ole2.h)     __oaidl_h__
template<class T, class I = T>
    class auto_rel;     //
    class auto_reg;     //
    class auto_pv;      // (propidl.h)  __propidl_h__
template<class _Ty>
    class auto_prg;     //
template<class _Ty>
    class pointer;      //
    class auto_hr;      //
    class auto_os;      //
    class auto_imp;     // (atlconv.h)  __ATLCONV_H__
template<class T> 
    class auto_handle;  //
    class auto_cs;      //
    class auto_leave;   //
    class auto_var;     // (oleauto.h) __wtypes_h__ && (comutil.h) _INC_COMUTIL
template<class _Ty> 
    class auto_virt;    // (winbase.h)
    class auto_menu;

#if defined (__wtypes_h__)
class auto_bstr
{
public:
	auto_bstr( BSTR b= 0, bool o= true)
	: _bstr(b), _Owns(o)
	{}
	~auto_bstr()
	{
		if(_bstr && _Owns)
			::SysFreeString(_bstr);
	}

	bool Ownership(bool fOwns)
		{ return _Owns = fOwns; }

	operator BSTR() { return _bstr; }
	operator const BSTR() const { return _bstr; }
	BSTR* operator &() {return &_bstr; }
	auto_bstr& operator=(auto_bstr& rhs)
	{
		if(_bstr == rhs._bstr)
			return *this;

		clear();
		_Owns= rhs._Owns;
		_bstr= rhs.release();

		return *this;
	}
	
	auto_bstr& operator=(BSTR bstr)
	{
		clear();
		_bstr= bstr;
		_Owns= true;
		return *this;
	}
	operator bool()
		{ return NULL != _bstr; }
	operator !()
		{ return NULL == _bstr; }
    
    WCHAR operator[] (int index) 
        {   return _bstr[index]; }
        
	void clear()
	{
		if(_bstr && _Owns)
		{
			::SysFreeString(_bstr);
		}
		_bstr= NULL;
	}

	BSTR release()
	{
		BSTR bstr= _bstr;

		_bstr= NULL;
		return bstr;
	}
	
protected:
	bool _Owns;
	BSTR _bstr;
	};
#endif // __wtypes_h__

// auto_tm ********************************************************************
//
// Smart Pointers for memory freed with CoTaskFreeMem

template<class _Ty>
class auto_tm
{
public:
	typedef _Ty element_type;

    explicit auto_tm(_Ty *_P = 0) _THROW0()
		: _Owns(_P != 0), _Ptr(_P) {}
	auto_tm(const auto_tm<_Ty>& _Y) _THROW0()
		: _Owns(_Y._Owns), _Ptr(_Y.release()) {}
	auto_tm<_Ty>& operator=(const auto_tm<_Ty>& _Y) _THROW0()
		{if (_Ptr != _Y.get())
			{if (_Owns && _Ptr)
				CoTaskMemFree(_Ptr);
			_Owns = _Y._Owns;
			_Ptr = _Y.release(); }
		else if (_Y._Owns)
			_Owns = true;
		return (*this); }
	auto_tm<_Ty>& operator=(_Ty* _Y) _THROW0()
		{	{if (_Owns && _Ptr)
				CoTaskMemFree(_Ptr);
			_Owns = _Y != 0;
			_Ptr = _Y; }
		return (*this); }

	~auto_tm()
		{if (_Owns && _Ptr)
			CoTaskMemFree(_Ptr);}
	_Ty** operator&() _THROW0()
		{if (_Owns && _Ptr)
			CoTaskMemFree(_Ptr);
		 _Owns = true;
		 _Ptr = 0;
		 return &_Ptr; 
		}
    operator _Ty* () const
        { return _Ptr; }
    _Ty& operator*() const _THROW0()
		{return (*get()); }
	_Ty *operator->() const _THROW0()
		{return (get()); }
    _Ty& operator[] (int ndx) const _THROW0()
        {return *(get() + ndx); }
	_Ty *get() const _THROW0()
		{return (_Ptr); }
	_Ty *release() const _THROW0()
		{((auto_tm<_Ty> *)this)->_Owns = false;
		return (_Ptr); }
	bool Ownership(bool fOwns)
		{ return _Owns = fOwns; }
protected:
	bool _Owns;
	_Ty *_Ptr;
	};

// auto_sid *******************************************************************
//
// Smart Pointers for SID's (Security ID's)

class auto_sid
{
public:
    explicit auto_sid(SID* p = 0)
        : m_psid(p) {};
    auto_sid(auto_sid& rhs)
        : m_psid(rhs.release()) {};

    ~auto_sid()
        { reset(); };

    auto_sid& operator= (auto_sid& rhs)
    {   if (this != rhs.getThis())
            reset (rhs.release() );
        return *this;
    };

    SID operator*() const 
        { return *m_psid; };
    void** operator& ()
        { reset(); return (void**)&m_psid; };
    operator SID* ()
        { return m_psid; };
    
    // Checks for NULL
    BOOL operator== (LPVOID lpv)
        { return m_psid == lpv; };
    BOOL operator!= (LPVOID lpv)
        { return m_psid != lpv; };

    // return value of current dumb pointer
    SID*  get() const
        { return m_psid; };

    // relinquish ownership
    SID*  release()
    {   SID* oldpsid = m_psid;
        m_psid = 0;
        return oldpsid;
    };

    // delete owned pointer; assume ownership of p
    void reset (SID* p = 0)
    {   
        if (m_psid)
			FreeSid(m_psid);
        m_psid = p;
    };

private:
    // operator& throws off operator=
    const auto_sid* getThis() const
    {   return this; };

    SID* m_psid;
};

// auto_sa ********************************************************************
//
// Smart Pointers for SafeArray's (those VB arrays)

#ifdef __oaidl_h__
class auto_sa
{
public:
	auto_sa()
	: _psa(0),
	  _Owns(true)
	{}
	~auto_sa()
	{
		if(_psa && _Owns)
		{
			_psa->cLocks= 0;
			::SafeArrayDestroy(_psa);
		}
	}

	bool Ownership(bool fOwns)
		{ return _Owns = fOwns; }

	operator SAFEARRAY *() { return _psa; }
	operator const SAFEARRAY *() const { return _psa; }
	auto_sa& operator=(auto_sa& rhs)
	{
		if(_psa == rhs._psa)
			return *this;

		clear();
		_Owns= rhs._Owns;
		_psa= rhs.release();

		return *this;
	}

	auto_sa& operator=(SAFEARRAY* psa)
	{
		clear();
		_psa= psa;
		_Owns= true;
		return *this;
	}
	operator bool()
		{ return NULL != _psa; }
	operator !()
		{ return NULL == _psa; }

	void clear()
	{
		if(_psa && _Owns)
		{
			_psa->cLocks= 0;
			::SafeArrayDestroy(_psa);
		}
		_psa= NULL;
	}

	SAFEARRAY* release()
	{
		SAFEARRAY* psa= _psa;

		_psa= NULL;
		return psa;
	}
		

protected:
	SAFEARRAY *_psa;
	bool _Owns;
};
#endif

// auto_rel *******************************************************************
//
// Smart pointer for COM interfaces
//
// class I - Multi-Inheritance casting for ATL type classes
// ergo C2385 - T::Release() is ambiguous

template<class T, class I = T>
class auto_rel
{
public:
    auto_rel()
	{
		p = 0;
	}

    auto_rel(T* p2)
	{
		assign(p2);
	}

    auto_rel(const auto_rel<T, I>& p2)
	{
		assign(p2.p);
	}

    auto_rel(void* p2)
	{
		if(p2)
		{
			auto_hr hr = ((IUnknown*)p2)->QueryInterface(__uuidof(T), (void**)&p);
		}
		else
		{
			p = 0;
		}
	}

    ~auto_rel()
	{
		clear(p);
	}

	// for the NULL case - have to have int explicitly or it won't compile
	// due to an ambiguous conversion (can't decide between T* and void*).
	auto_rel<T, I>& operator =(int p2)
    {   
		clear(p);
		p = 0;
		return(*this);
    }

    // normal case is nice and fast - do the assign before the clear in case
	// p2 == p (so we don't accidentally delete it if we hold the only ref).
	auto_rel<T, I>& operator =(T* p2)
    {   
		T* p3 = p;
		assign(p2);
		clear(p3);
		return(*this);
    }

    // copy is also fast - must have copy otherwise compiler generates it
	// and it doesn't correctly addref.
	auto_rel<T, I>& operator =(const auto_rel<T, I>& p2)
    {   
		T* p3 = p;
		assign(p2.p);
		clear(p3);
		return(*this);
    }

	// QI if its not a T* - has to be void* rather than IUnknown since if
	// T happens to be IUnknown it produces a conflict and won't compile.
	auto_rel<T, I>& operator =(void* p2)
    {   
		if(p2)
		{
			T* p3 = p;
			auto_hr hr = ((IUnknown*)p2)->QueryInterface(__uuidof(T), (void**)&p);
			clear(p3);
		}
		else
		{
			clear(p);
			p = 0;
		}
		return(*this);
    }

    T& operator *() const
	{
		if(!p)
		{
			throw(E_POINTER);
		}
		return(*p);
	}

    T* operator ->() const
	{
		if(!p)
		{
			throw(E_POINTER);
		}
		return(p);
	}

    // CComPtr doesn't clear like we do for this one
	T** operator &()
	{
		clear(p);
		p = 0;
		return(&p);
	}

	T** Address()
	{
		return(&p);
	}

    operator T*()
	{
		return(p);
	}

    operator void*()
	{
		return((IUnknown*)p);
	}

	operator bool()
	{
		return(!!p);
	}
	
	operator bool() const
	{
		return(!!p);
	}

	bool operator !()
	{
		return(!p);
	}
	
	bool operator !() const
	{
		return(!p);
	}

    bool operator ==(void* p2)
    {
		return(p == p2);
	}
    
	bool operator !=(void* p2)
    {
		return(p != p2);
	}
    
	bool operator ==(const auto_rel<T, I>& p2)
    {
		return p == p2.p;
	}
    
	bool operator <(const auto_rel<T, I>& p2)
    {
		return p < p2.p;
	}

    T* p;

private:
	void clear(T* p2)
	{
		if(p2)
		{
#ifdef DEBUG
			ULONG cRef = 
#endif
			((I*)p2)->Release();
		}
	}

	void assign(T* p2)
	{
		if(p = p2)
		{
			((I*)p)->AddRef();
		}
	}

};

// auto_os ********************************************************************
//
// Smart pointer for OS system calls.

class auto_os
{
public:
    auto_os() : dw(0) {}

    auto_os& operator= (LONG rhs)
    {   
        dw = rhs;

#ifdef _DEBUG_AUTOHR
        if (debug().CheckOsFail())
            throw (int)debug().m_pInfo->m_os;
#endif

        if (rhs)
        {
#ifdef _DEBUG_AUTOHR
            if (debug().m_pInfo->m_bDebugBreakOnError)
#ifdef _M_IX86
                __asm int 3;
#else
                DebugBreak();
#endif
#endif
            throw (int)rhs;
        }
        return *this;
    };
    auto_os& operator= (BOOL rhs)
    {   
        dw = rhs;

#ifdef _DEBUG_AUTOHR
        if (debug().CheckOsFail())
            throw (int)(debug().m_pInfo->m_os);
#endif

        if (!rhs)
        {
#ifdef _DEBUG_AUTOHR
            if (debug().m_pInfo->m_bDebugBreakOnError)
#ifdef _M_IX86
                __asm int 3;
#else
                DebugBreak();
#endif
#endif
            throw (int)GetLastError();
        }
        return *this;
    };

    operator LONG ()
        { return dw; }

    friend void operator| (BOOL b, auto_os& rhs)
    {
        rhs = b;
    }

    friend void operator| (LONG l, auto_os& rhs)
    {
        rhs = l;
    }
protected:
    DWORD dw;
};

// auto_reg *******************************************************************
//
// Smart pointer for HKEY's

class auto_reg
{
public:
    auto_reg(HKEY p = 0)
        : h(p) {};
    auto_reg(auto_reg& rhs)
        : h(rhs.release()) {};

    ~auto_reg()
        { if (h) RegCloseKey(h); };

    auto_reg& operator= (auto_reg& rhs)
    {   if (this != rhs.getThis())
            reset (rhs.release() );
        return *this;
    };
    auto_reg& operator= (HKEY rhs)
    {   if ((NULL == rhs) || (INVALID_HANDLE_VALUE == rhs))
        {   // be sure and go through auto_os for dbg.lib
            auto_os os;
            os = (BOOL)FALSE;
        }
        reset (rhs);
        return *this;
    };

    HKEY* operator& ()
        { reset(); return &h; };
    operator HKEY ()
        { return h; };
    
    // Checks for NULL
    bool operator== (LPVOID lpv)
        { return h == lpv; };
    bool operator!= (LPVOID lpv)
        { return h != lpv; };

    // return value of current dumb pointer
    HKEY  get() const
        { return h; };

    // relinquish ownership
    HKEY  release()
    {   HKEY oldh = h;
        h = 0;
        return oldh;
    };

    // delete owned pointer; assume ownership of p
    BOOL reset (HKEY p = 0)
    {
        BOOL rt = TRUE;

        if (h)
			rt = RegCloseKey(h);
        h = p;
        
        return rt;
    };

private:
    // operator& throws off operator=
    const auto_reg* getThis() const
    {   return this; };

    HKEY h;
};

// auto_pv ********************************************************************
//
// Smart pointer for PROPVARIANT's
//
// pretty minimal functionality, designed to provide auto release only
// 
#ifdef __propidl_h__
class auto_pv : public ::tagPROPVARIANT {
public:
	// Constructors
	//
	auto_pv() throw();

	// Destructor
	//
	~auto_pv() throw();

	// Low-level operations
	//
	void Clear() throw();

	void Attach(PROPVARIANT& varSrc) throw();
	PROPVARIANT Detach() throw();

	bool Ownership(bool fOwns)
		{ return _Owns = fOwns; }

protected:
	bool _Owns;
};

// Default constructor
//
inline auto_pv::auto_pv() throw()
: _Owns(true)
{
	::PropVariantInit(this);
}

// destructor
inline auto_pv::~auto_pv() throw()
{
	if(_Owns)
		::PropVariantClear(this);
	else
		::PropVariantInit(this);
}


// Clear the auto_var
//
inline void auto_pv::Clear() throw()
{
	if(_Owns)
		::PropVariantClear(this);
	else
		::PropVariantInit(this);
}

inline void auto_pv::Attach(PROPVARIANT& varSrc) throw()
{
	//
	// Free up previous VARIANT
	//
	Clear();

	//
	// Give control of data to auto_var
	//
	memcpy(this, &varSrc, sizeof(varSrc));
	varSrc.vt = VT_EMPTY;
}

inline PROPVARIANT auto_pv::Detach() throw()
{
	PROPVARIANT varResult = *this;
	this->vt = VT_EMPTY;

	return varResult;
}
#endif

// auto_prg *******************************************************************
//
// Same as auto_ptr/pointer but for an array
// auto pointer to range

template<class _Ty>
class auto_prg
{
public:
	typedef _Ty element_type;

    explicit auto_prg(_Ty *_P = 0) _THROW0()
		: _Owns(_P != 0), _Ptr(_P) {}
	auto_prg(const auto_prg<_Ty>& _Y) _THROW0()
		: _Owns(_Y._Owns), _Ptr(_Y.release()) {}
	auto_prg<_Ty>& operator=(const auto_prg<_Ty>& _Y) _THROW0()
		{if (_Ptr != _Y.get())
			{if (_Owns)
				delete [] _Ptr;
			_Owns = _Y._Owns;
			_Ptr = _Y.release(); }
		else if (_Y._Owns)
			_Owns = true;
		return (*this); }
	auto_prg<_Ty>& operator=(_Ty* _Y) _THROW0()
		{	{if (_Owns)
				delete [] _Ptr;
			_Owns = _Y != 0;
			_Ptr = _Y; }
		return (*this); }

	~auto_prg()
		{if (_Owns)
			delete [] _Ptr; }
	_Ty** operator&() _THROW0()
		{ return &_Ptr; }
    operator _Ty* () const
        { return _Ptr; }
    _Ty& operator*() const _THROW0()
		{return (*get()); }
	_Ty *operator->() const _THROW0()
		{return (get()); }
    _Ty& operator[] (unsigned long ndx) const _THROW0()
        {return *(get() + ndx); }
    _Ty& operator[] (int ndx) const _THROW0()
        {return *(get() + ndx); }
	_Ty *get() const _THROW0()
		{return (_Ptr); }
	_Ty *release() const _THROW0()
		{((auto_prg<_Ty> *)this)->_Owns = false;
		return (_Ptr); }
	bool Ownership(bool fOwns)
		{ return _Owns = fOwns; }
protected:
	bool _Owns;
	_Ty *_Ptr;
	};

// pointer ********************************************************************
//
// Same as auto_ptr (with the operator's you normally use)
//

template<class _Ty>
class pointer
{
public:
	typedef _Ty element_type;

    explicit pointer(_Ty *_P = 0) _THROW0()
		: _Owns(_P != 0), _Ptr(_P) {}
	pointer(const pointer<_Ty>& _Y) _THROW0()
		: _Owns(_Y._Owns), _Ptr(_Y.release()) {}
	pointer<_Ty>& operator=(const pointer<_Ty>& _Y) _THROW0()
		{if (_Ptr != _Y.get())
			{if (_Owns)
				delete _Ptr;
			_Owns = _Y._Owns;
			_Ptr = _Y.release(); }
		else if (_Y._Owns)
			_Owns = true;
		return (*this); }
	pointer<_Ty>& operator=(_Ty* _Y) _THROW0()
		{	{if (_Owns)
				delete _Ptr;
			_Owns = _Y != 0;
			_Ptr = _Y; }
		return (*this); }

	~pointer()
		{if (_Owns)
			delete _Ptr; }
	_Ty** operator&() _THROW0()
		{ return &_Ptr; }
    operator _Ty* () const
        { return _Ptr; }
    _Ty& operator*() const _THROW0()
		{return (*get()); }
	_Ty *operator->() const _THROW0()
		{return (get()); }
    _Ty& operator[] (int ndx) const _THROW0()
        {return *(get() + ndx); }
	_Ty *get() const _THROW0()
		{return (_Ptr); }
	_Ty *release() const _THROW0()
		{((pointer<_Ty> *)this)->_Owns = false;
		return (_Ptr); }
	bool Ownership(bool fOwns)
		{ return _Owns = fOwns; }
protected:
	bool _Owns;
	_Ty *_Ptr;
};

// auto_hr ********************************************************************
//
// Throws and HRESULT to keep from writing a thousand if (hr) ....
//

class auto_hr
{
public:
    auto_hr() : hr(S_OK) {}
    
	auto_hr(HRESULT rhs)
	{
		(*this) = rhs;
	}

    auto_hr& operator= (HRESULT rhs)
    {   
        hr = rhs;

#ifdef _DEBUG_AUTOHR
        if (debug().CheckHrFail())
            throw HRESULT (debug().m_pInfo->m_hr);
#endif

        if (FAILED(rhs))
        {
#ifdef _DEBUG_AUTOHR
            if (debug().m_pInfo->m_bDebugBreakOnError)
#ifdef _M_IX86
                __asm int 3;
#else
                DebugBreak();
#endif
#endif
            throw HRESULT(rhs);
        }
        return *this;
    };

    operator HRESULT ()
        { return hr; }

	HRESULT operator <<(HRESULT h)
	{
        hr = h;
        
		return hr;
	}

protected:
    auto_hr& operator= (bool rhs) { return *this; }
    auto_hr& operator= (int rhs)  { return *this; }
    auto_hr& operator= (ULONG rhs) { return *this; }

    HRESULT hr;
};

// auto_handle ****************************************************************
//
// Smart pointer for any HANDLE that needs a CloseHandle()
//

template<class T> class auto_handle;

// CHandleProxy
//
// By Proxy I mean this is just a mux for return values.  C++ won't let you
// differentiate calls with just a different return value.
// 
// You can return an object and have that implicitly cast to different values.
// Sneaky but it works well.
//
// The class will just be inlined out, and doesn't really have anything but a
// pointer.

template<class T>
class CHandleProxy
{
public:
    CHandleProxy (auto_handle<T>& ah) :
        m_ah(ah) {};
    CHandleProxy (const auto_handle<T>& ah) :
        m_ah(const_cast<auto_handle<T>&> (ah)) {};
    
    operator T* () { return &m_ah.h; }
    operator const T* () const { return &m_ah.h; }
  
    operator auto_handle<T>* () { return &m_ah; }

protected:
    mutable auto_handle<T>& m_ah;
};

template<class T>
class auto_handle
{
public:
    auto_handle(T p = 0)
        : h(p) {};
    auto_handle(const auto_handle<T>& rhs)
        : h(rhs.release()) {};

    ~auto_handle()
        { if (h && INVALID_HANDLE_VALUE != h) CloseHandle(h); };

    auto_handle<T>& operator= (const auto_handle<T>& rhs)
    {   if (this != rhs.getThis())
            reset (rhs.release() );
        return *this;
    };
    auto_handle<T>& operator= (T rhs)
    {   if ((NULL == rhs) || (INVALID_HANDLE_VALUE == rhs))
        {   
        	// be sure and go through auto_os for dbg.lib
            auto_os os;
            os = (BOOL)FALSE;
        }
        reset (rhs);
        return *this;
    };

    CHandleProxy<T> operator& ()
        { reset(); return CHandleProxy<T> (*this); };  // &h; 
    const CHandleProxy<T> operator& () const
        {  return CHandleProxy<T> (*this); };  // &h; 
    operator T ()
        { return h; };
    
    // Checks for NULL
	bool operator! ()
		{ return h == NULL; }
	operator bool()
		{ return h != NULL; }
    bool operator== (LPVOID lpv) const
        { return h == lpv; };
    bool operator!= (LPVOID lpv) const
        { return h != lpv; };
    bool operator== (const auto_handle<T>& rhs) const
        { return h == rhs.h; };
    bool operator< (const auto_handle<T>& rhs) const
        { return h < rhs.h; };

    // return value of current dumb pointer
    T  get() const
        { return h; };

    // relinquish ownership
    T  release() const
    {   T oldh = h;
        h = 0;
        return oldh;
    };

    // delete owned pointer; assume ownership of p
    BOOL reset (T p = 0)
    {
        BOOL rt = TRUE;

        if (h && INVALID_HANDLE_VALUE != h)
			rt = CloseHandle(h);
        h = p;
        
        return rt;
    };

private:
    friend class CHandleProxy<T>;

    // operator& throws off operator=
    const auto_handle<T> * getThis() const
    {   return this; };

    // mutable is needed for release call in ctor and copy ctor
    mutable T h;
};

// auto_imp *******************************************************************
//
// Impersonate a user and revert
//

#ifdef __ATLCONV_H__
class auto_imp
{
public:
	auto_imp() :
		m_hUser(0)
	{
	}

	~auto_imp()
	{
		if(m_hUser)
		{
			RevertToSelf();
			CloseHandle(m_hUser);
		}
	}

	HRESULT Impersonate(LPOLESTR pszDomain, LPOLESTR pszName, LPOLESTR pszPassword)
	{
		HRESULT hr = S_OK;
		
		try
		{
			USES_CONVERSION;
			auto_os os;
			auto_handle<HANDLE> hUser;

			os = LogonUser(OLE2T(pszName), OLE2T(pszDomain), pszPassword ? OLE2T(pszPassword) : _T(""), LOGON32_LOGON_INTERACTIVE, LOGON32_PROVIDER_DEFAULT, &hUser);
			os = ImpersonateLoggedOnUser(hUser);
			m_hUser = hUser.release();
		}
		catch(HRESULT hrException)
		{
			hr = hrException;
		}

		return(hr);
	}
	
	HRESULT Impersonate(LPOLESTR pszDomainName, LPOLESTR pszPassword)
	{
		LPOLESTR pszSeperator;
		_bstr_t sName;
		_bstr_t sDomain;
		
		pszSeperator = wcschr(pszDomainName, '\\');
		if(pszSeperator)
		{
			*pszSeperator = 0;
			sDomain = pszDomainName;
			*pszSeperator = '\\';
			sName = pszSeperator + 1;
		}
		else
		{
			sName = pszDomainName;
		}

		return Impersonate(sDomain, sName, pszPassword);
	}
	
protected:
	HANDLE m_hUser;
};
#endif // __ATLCONV_H__

// auto_cs ********************************************************************
//
// Smart object for CriticalSections

#ifdef TRYENTRYCS
typedef BOOL (WINAPI *LPTRYENTERCRITICALSECTION)(LPCRITICAL_SECTION lpCriticalSection);
static LPTRYENTERCRITICALSECTION g_pfnTryEnter = NULL;
#endif

class auto_leave;

class auto_cs
{
public:
    auto_cs()
    {
    	InitializeCriticalSection(&m_cs);
#ifdef TRYENTRYCS
	    if (!g_pfnTryEnter)
	    {
		    HINSTANCE hinst = GetModuleHandleA("kernel32.dll");
		    if (INVALID_HANDLE_VALUE != hinst)
		    {
			    // note: GetProcAddress is ANSI only, there is no A flavor
			    g_pfnTryEnter = (LPTRYENTERCRITICALSECTION)GetProcAddress(
				    hinst, "TryEnterCriticalSection");
		    }
	    }
#endif
    }

    ~auto_cs()
    {
        DeleteCriticalSection(&m_cs);
    };

    // return value of current dumb pointer
    LPCRITICAL_SECTION  get() 
    { return &m_cs; };

    LPCRITICAL_SECTION  get() const
    { return (LPCRITICAL_SECTION)&m_cs; };

protected:
    CRITICAL_SECTION m_cs;
};

// auto_leave *****************************************************************
//
// Smart LeaveCriticalSections

class auto_leave
{
public:
    auto_leave(auto_cs& cs)
        : m_ulCount(0), m_pcs(cs.get()) {}
    auto_leave(const auto_cs&  cs) 
    {
        m_ulCount =0;
        m_pcs = cs.get();
    }
  
    ~auto_leave()
    {
        reset();
    }
	auto_leave& operator=(auto_cs& cs)
	{
		reset();
		m_pcs = cs.get();
		return *this;
	}

    void EnterCriticalSection()
    { ::EnterCriticalSection(m_pcs); m_ulCount++; }
    void LeaveCriticalSection()
    {
    	if (m_ulCount)
    	{
    		m_ulCount--;
    		::LeaveCriticalSection(m_pcs);
    	}
	}
#ifdef TRYENTRYCS
	BOOL TryEnterCriticalSection()
	{
		if (g_pfnTryEnter)
		{
			if ((*g_pfnTryEnter)(m_pcs))
			{
				m_ulCount++;
				return TRUE;
			}
			return FALSE;
		}
		else
		{
			::EnterCriticalSection(m_pcs);
			m_ulCount++;
			return TRUE;
		}
	}
#endif

protected:
	void reset()
	{
		while (m_ulCount)
        {
            LeaveCriticalSection();
        }
        m_pcs = 0;
	}
	ULONG				m_ulCount;
    LPCRITICAL_SECTION	m_pcs;
};

class _bstr_t;
class auto_var;

// auto_var *******************************************************************
//
// Wrapper class for VARIANT
//
// NOTE : the one included w/ C++ has mem leaks in op= and op&.  Otherwise this
//        is a direct copy

/*
 * VARENUM usage key,
 *
 * * [V] - may appear in a VARIANT
 * * [T] - may appear in a TYPEDESC
 * * [P] - may appear in an OLE property set
 * * [S] - may appear in a Safe Array
 * * [C] - supported by class auto_var
 *
 *
 *  VT_EMPTY            [V]   [P]        nothing
 *  VT_NULL             [V]   [P]        SQL style Null
 *  VT_I2               [V][T][P][S][C]  2 byte signed int
 *  VT_I4               [V][T][P][S][C]  4 byte signed int
 *  VT_R4               [V][T][P][S][C]  4 byte real
 *  VT_R8               [V][T][P][S][C]  8 byte real
 *  VT_CY               [V][T][P][S][C]  currency
 *  VT_DATE             [V][T][P][S][C]  date
 *  VT_BSTR             [V][T][P][S][C]  OLE Automation string
 *  VT_DISPATCH         [V][T][P][S][C]  IDispatch *
 *  VT_ERROR            [V][T]   [S][C]  SCODE
 *  VT_BOOL             [V][T][P][S][C]  True=-1, False=0
 *  VT_VARIANT          [V][T][P][S]     VARIANT *
 *  VT_UNKNOWN          [V][T]   [S][C]  IUnknown *
 *  VT_DECIMAL          [V][T]   [S][C]  16 byte fixed point
 *  VT_I1                  [T]           signed char
 *  VT_UI1              [V][T][P][S][C]  unsigned char
 *  VT_UI2                 [T][P]        unsigned short
 *  VT_UI4                 [T][P]        unsigned short
 *  VT_I8                  [T][P]        signed 64-bit int
 *  VT_UI8                 [T][P]        unsigned 64-bit int
 *  VT_INT                 [T]           signed machine int
 *  VT_UINT                [T]           unsigned machine int
 *  VT_VOID                [T]           C style void
 *  VT_HRESULT             [T]           Standard return type
 *  VT_PTR                 [T]           pointer type
 *  VT_SAFEARRAY           [T]          (use VT_ARRAY in VARIANT)
 *  VT_CARRAY              [T]           C style array
 *  VT_USERDEFINED         [T]           user defined type
 *  VT_LPSTR               [T][P]        null terminated string
 *  VT_LPWSTR              [T][P]        wide null terminated string
 *  VT_FILETIME               [P]        FILETIME
 *  VT_BLOB                   [P]        Length prefixed bytes
 *  VT_STREAM                 [P]        Name of the stream follows
 *  VT_STORAGE                [P]        Name of the storage follows
 *  VT_STREAMED_OBJECT        [P]        Stream contains an object
 *  VT_STORED_OBJECT          [P]        Storage contains an object
 *  VT_BLOB_OBJECT            [P]        Blob contains an object
 *  VT_CF                     [P]        Clipboard format
 *  VT_CLSID                  [P]        A Class ID
 *  VT_VECTOR                 [P]        simple counted array
 *  VT_ARRAY            [V]              SAFEARRAY*
 *  VT_BYREF            [V]              void* for local use
 */

#if defined (__wtypes_h__) && defined(_INC_COMUTIL) // where VARIANT/_com_error is defined
class auto_var : public ::tagVARIANT {
public:
	// Constructors
	//
	auto_var() throw();

	auto_var(const VARIANT& varSrc) throw(_com_error);
	auto_var(const VARIANT* pSrc) throw(_com_error);
	auto_var(const auto_var& varSrc) throw(_com_error);

	auto_var(VARIANT& varSrc, bool fCopy) throw(_com_error);			// Attach VARIANT if !fCopy

	auto_var(short sSrc, VARTYPE vtSrc = VT_I2) throw(_com_error);	// Creates a VT_I2, or a VT_BOOL
	auto_var(long lSrc, VARTYPE vtSrc = VT_I4) throw(_com_error);		// Creates a VT_I4, a VT_ERROR, or a VT_BOOL
	auto_var(float fltSrc) throw();									// Creates a VT_R4
	auto_var(double dblSrc, VARTYPE vtSrc = VT_R8) throw(_com_error);	// Creates a VT_R8, or a VT_DATE
	auto_var(const CY& cySrc) throw();								// Creates a VT_CY
	auto_var(const _bstr_t& bstrSrc) throw(_com_error);				// Creates a VT_BSTR
	auto_var(const wchar_t *pSrc) throw(_com_error);					// Creates a VT_BSTR
	auto_var(const char* pSrc) throw(_com_error);						// Creates a VT_BSTR
	auto_var(IDispatch* pSrc, bool fAddRef = true) throw();			// Creates a VT_DISPATCH
	auto_var(bool bSrc) throw();										// Creates a VT_BOOL
	auto_var(IUnknown* pSrc, bool fAddRef = true) throw();			// Creates a VT_UNKNOWN
	auto_var(const DECIMAL& decSrc) throw();							// Creates a VT_DECIMAL
	auto_var(BYTE bSrc) throw();										// Creates a VT_UI1

	// Destructor
	//
	~auto_var() throw(_com_error);

	// Extractors
	//
	operator short() const throw(_com_error);			// Extracts a short from a VT_I2
	operator long() const throw(_com_error);			// Extracts a long from a VT_I4
	operator float() const throw(_com_error);			// Extracts a float from a VT_R4
	operator double() const throw(_com_error);			// Extracts a double from a VT_R8
	operator CY() const throw(_com_error);				// Extracts a CY from a VT_CY
	operator _bstr_t() const throw(_com_error);			// Extracts a _bstr_t from a VT_BSTR
	operator IDispatch*() const throw(_com_error);		// Extracts a IDispatch* from a VT_DISPATCH
	operator bool() const throw(_com_error);			// Extracts a bool from a VT_BOOL
	operator IUnknown*() const throw(_com_error);		// Extracts a IUnknown* from a VT_UNKNOWN
	operator DECIMAL() const throw(_com_error);			// Extracts a DECIMAL from a VT_DECIMAL
	operator BYTE() const throw(_com_error);			// Extracts a BTYE (unsigned char) from a VT_UI1
	
	// Assignment operations
	//
	auto_var& operator=(const VARIANT& varSrc) throw(_com_error);
	auto_var& operator=(const VARIANT* pSrc) throw(_com_error);
	auto_var& operator=(const auto_var& varSrc) throw(_com_error);

	auto_var& operator=(short sSrc) throw(_com_error);				// Assign a VT_I2, or a VT_BOOL
	auto_var& operator=(long lSrc) throw(_com_error);					// Assign a VT_I4, a VT_ERROR or a VT_BOOL
	auto_var& operator=(float fltSrc) throw(_com_error);				// Assign a VT_R4
	auto_var& operator=(double dblSrc) throw(_com_error);				// Assign a VT_R8, or a VT_DATE
	auto_var& operator=(const CY& cySrc) throw(_com_error);			// Assign a VT_CY
	auto_var& operator=(const _bstr_t& bstrSrc) throw(_com_error);	// Assign a VT_BSTR
	auto_var& operator=(const wchar_t* pSrc) throw(_com_error);		// Assign a VT_BSTR
	auto_var& operator=(const char* pSrc) throw(_com_error);			// Assign a VT_BSTR
	auto_var& operator=(IDispatch* pSrc) throw(_com_error);			// Assign a VT_DISPATCH
 	auto_var& operator=(bool bSrc) throw(_com_error);					// Assign a VT_BOOL
	auto_var& operator=(IUnknown* pSrc) throw(_com_error);			// Assign a VT_UNKNOWN
	auto_var& operator=(const DECIMAL& decSrc) throw(_com_error);		// Assign a VT_DECIMAL
	auto_var& operator=(BYTE bSrc) throw(_com_error);					// Assign a VT_UI1

	// Comparison operations
	//
	bool operator==(const VARIANT& varSrc) const throw(_com_error);
	bool operator==(const VARIANT* pSrc) const throw(_com_error);

	bool operator!=(const VARIANT& varSrc) const throw(_com_error);
	bool operator!=(const VARIANT* pSrc) const throw(_com_error);

	// Low-level operations
	//
	void Clear() throw(_com_error);

	void Attach(VARIANT& varSrc) throw(_com_error);
	VARIANT Detach() throw(_com_error);

	void ChangeType(VARTYPE vartype, const auto_var* pSrc = NULL) throw(_com_error);

	void SetString(const char* pSrc) throw(_com_error); // used to set ANSI string
};

//////////////////////////////////////////////////////////////////////////////////////////
//
// Constructors
//
//////////////////////////////////////////////////////////////////////////////////////////

// Default constructor
//
inline auto_var::auto_var() throw()
{
	::VariantInit(this);
}

// Construct a auto_var from a const VARIANT&
//
inline auto_var::auto_var(const VARIANT& varSrc) throw(_com_error)
{
	::VariantInit(this);
	_com_util::CheckError(::VariantCopy(this, const_cast<VARIANT*>(&varSrc)));
}

// Construct a auto_var from a const VARIANT*
//
inline auto_var::auto_var(const VARIANT* pSrc) throw(_com_error)
{
	::VariantInit(this);
	_com_util::CheckError(::VariantCopy(this, const_cast<VARIANT*>(pSrc)));
}

// Construct a auto_var from a const auto_var&
//
inline auto_var::auto_var(const auto_var& varSrc) throw(_com_error)
{
	::VariantInit(this);
	_com_util::CheckError(::VariantCopy(this, const_cast<VARIANT*>(static_cast<const VARIANT*>(&varSrc))));
}

// Construct a auto_var from a VARIANT&.  If fCopy is FALSE, give control of
// data to the auto_var without doing a VariantCopy.
//
inline auto_var::auto_var(VARIANT& varSrc, bool fCopy) throw(_com_error)
{
	if (fCopy) {
		::VariantInit(this);
		_com_util::CheckError(::VariantCopy(this, &varSrc));
	} else {
		memcpy(this, &varSrc, sizeof(varSrc));
		V_VT(&varSrc) = VT_EMPTY;
	}
}

// Construct either a VT_I2 VARIANT or a VT_BOOL VARIANT from
// a short (the default is VT_I2)
//
inline auto_var::auto_var(short sSrc, VARTYPE vtSrc) throw(_com_error)
{
	if ((vtSrc != VT_I2) && (vtSrc != VT_BOOL)) {
		_com_issue_error(E_INVALIDARG);
	}

	if (vtSrc == VT_BOOL) {
		V_VT(this) = VT_BOOL;
		V_BOOL(this) = (sSrc ? VARIANT_TRUE : VARIANT_FALSE);
	}
	else {
		V_VT(this) = VT_I2;
		V_I2(this) = sSrc;
	}
}

// Construct either a VT_I4 VARIANT, a VT_BOOL VARIANT, or a
// VT_ERROR VARIANT from a long (the default is VT_I4)
//
inline auto_var::auto_var(long lSrc, VARTYPE vtSrc) throw(_com_error)
{
	if ((vtSrc != VT_I4) && (vtSrc != VT_ERROR) && (vtSrc != VT_BOOL)) {
		_com_issue_error(E_INVALIDARG);
	}

	if (vtSrc == VT_ERROR) {
		V_VT(this) = VT_ERROR;
		V_ERROR(this) = lSrc;
	}
	else if (vtSrc == VT_BOOL) {
		V_VT(this) = VT_BOOL;
		V_BOOL(this) = (lSrc ? VARIANT_TRUE : VARIANT_FALSE);
	}
	else {
		V_VT(this) = VT_I4;
		V_I4(this) = lSrc;
	}
}

// Construct a VT_R4 VARIANT from a float
//
inline auto_var::auto_var(float fltSrc) throw()
{
	V_VT(this) = VT_R4;
	V_R4(this) = fltSrc;
}

// Construct either a VT_R8 VARIANT, or a VT_DATE VARIANT from
// a double (the default is VT_R8)
//
inline auto_var::auto_var(double dblSrc, VARTYPE vtSrc) throw(_com_error)
{
	if ((vtSrc != VT_R8) && (vtSrc != VT_DATE)) {
		_com_issue_error(E_INVALIDARG);
	}

	if (vtSrc == VT_DATE) {
		V_VT(this) = VT_DATE;
		V_DATE(this) = dblSrc;
	}
	else {
		V_VT(this) = VT_R8;
		V_R8(this) = dblSrc;
	}
}

// Construct a VT_CY from a CY
//
inline auto_var::auto_var(const CY& cySrc) throw()
{
	V_VT(this) = VT_CY;
	V_CY(this) = cySrc;
}

// Construct a VT_BSTR VARIANT from a const _bstr_t&
//
inline auto_var::auto_var(const _bstr_t& bstrSrc) throw(_com_error)
{
	V_VT(this) = VT_BSTR;

	BSTR bstr = static_cast<wchar_t*>(bstrSrc);
	V_BSTR(this) = ::SysAllocStringByteLen(reinterpret_cast<char*>(bstr),
										   ::SysStringByteLen(bstr));

	if (V_BSTR(this) == NULL) {
		_com_issue_error(E_OUTOFMEMORY);
	}
}

// Construct a VT_BSTR VARIANT from a const wchar_t*
//
inline auto_var::auto_var(const wchar_t* pSrc) throw(_com_error)
{
	V_VT(this) = VT_BSTR;
	V_BSTR(this) = ::SysAllocString(pSrc);

	if (V_BSTR(this) == NULL && pSrc != NULL) {
		_com_issue_error(E_OUTOFMEMORY);
	}
}

// Construct a VT_BSTR VARIANT from a const char*
//
inline auto_var::auto_var(const char* pSrc) throw(_com_error)
{
	V_VT(this) = VT_BSTR;
	V_BSTR(this) = _com_util::ConvertStringToBSTR(pSrc);

	if (V_BSTR(this) == NULL && pSrc != NULL) {
		_com_issue_error(E_OUTOFMEMORY);
	}
}

// Construct a VT_DISPATCH VARIANT from an IDispatch*
//
inline auto_var::auto_var(IDispatch* pSrc, bool fAddRef) throw()
{
	V_VT(this) = VT_DISPATCH;
	V_DISPATCH(this) = pSrc;

	// Need the AddRef() as VariantClear() calls Release(), unless fAddRef
	// false indicates we're taking ownership
	//
	if (fAddRef) {
		V_DISPATCH(this)->AddRef();
	}
}

// Construct a VT_BOOL VARIANT from a bool
//
inline auto_var::auto_var(bool bSrc) throw()
{
	V_VT(this) = VT_BOOL;
	V_BOOL(this) = (bSrc ? VARIANT_TRUE : VARIANT_FALSE);
}

// Construct a VT_UNKNOWN VARIANT from an IUnknown*
//
inline auto_var::auto_var(IUnknown* pSrc, bool fAddRef) throw()
{
	V_VT(this) = VT_UNKNOWN;
	V_UNKNOWN(this) = pSrc;

	// Need the AddRef() as VariantClear() calls Release(), unless fAddRef
	// false indicates we're taking ownership
	//
	if (fAddRef) {
		V_UNKNOWN(this)->AddRef();
	}
}

// Construct a VT_DECIMAL VARIANT from a DECIMAL
//
inline auto_var::auto_var(const DECIMAL& decSrc) throw()
{
	// Order is important here! Setting V_DECIMAL wipes out the entire VARIANT
	//
	V_DECIMAL(this) = decSrc;
	V_VT(this) = VT_DECIMAL;
}

// Construct a VT_UI1 VARIANT from a BYTE (unsigned char)
//
inline auto_var::auto_var(BYTE bSrc) throw()
{
	V_VT(this) = VT_UI1;
	V_UI1(this) = bSrc;
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// Extractors
//
//////////////////////////////////////////////////////////////////////////////////////////

// Extracts a VT_I2 into a short
//
inline auto_var::operator short() const throw(_com_error)
{
	if (V_VT(this) == VT_I2) {
		return V_I2(this); 
	}

	auto_var varDest;

	varDest.ChangeType(VT_I2, this);

	return V_I2(&varDest);
}

// Extracts a VT_I4 into a long
//
inline auto_var::operator long() const throw(_com_error)
{
	if (V_VT(this) == VT_I4) {
		return V_I4(this); 
	}

	auto_var varDest;

	varDest.ChangeType(VT_I4, this);

	return V_I4(&varDest);
}

// Extracts a VT_R4 into a float
//
inline auto_var::operator float() const throw(_com_error)
{
	if (V_VT(this) == VT_R4) {
		return V_R4(this); 
	}

	auto_var varDest;

	varDest.ChangeType(VT_R4, this);

	return V_R4(&varDest);
}

// Extracts a VT_R8 into a double
//
inline auto_var::operator double() const throw(_com_error)
{
	if (V_VT(this) == VT_R8) {
		return V_R8(this); 
	}

	auto_var varDest;

	varDest.ChangeType(VT_R8, this);

	return V_R8(&varDest);
}

// Extracts a VT_CY into a CY
//
inline auto_var::operator CY() const throw(_com_error)
{
	if (V_VT(this) == VT_CY) {
		return V_CY(this); 
	}

	auto_var varDest;

	varDest.ChangeType(VT_CY, this);

	return V_CY(&varDest);
}

// Extracts a VT_BSTR into a _bstr_t
//
inline auto_var::operator _bstr_t() const throw(_com_error)
{
	if (V_VT(this) == VT_BSTR) {
		return V_BSTR(this);
	}

	auto_var varDest;

	varDest.ChangeType(VT_BSTR, this);

	return V_BSTR(&varDest);
}

// Extracts a VT_DISPATCH into an IDispatch*
//
inline auto_var::operator IDispatch*() const throw(_com_error)
{
	if (V_VT(this) == VT_DISPATCH) {
		V_DISPATCH(this)->AddRef();
		return V_DISPATCH(this);
	}

	auto_var varDest;

	varDest.ChangeType(VT_DISPATCH, this);

	V_DISPATCH(&varDest)->AddRef();
	return V_DISPATCH(&varDest);
}

// Extract a VT_BOOL into a bool
//
inline auto_var::operator bool() const throw(_com_error)
{
	if (V_VT(this) == VT_BOOL) {
		return V_BOOL(this) ? true : false;
	}

	auto_var varDest;

	varDest.ChangeType(VT_BOOL, this);

	return V_BOOL(&varDest) ? true : false;
}

// Extracts a VT_UNKNOWN into an IUnknown*
//
inline auto_var::operator IUnknown*() const throw(_com_error)
{
	if (V_VT(this) == VT_UNKNOWN) {
		return V_UNKNOWN(this);
	}

	auto_var varDest;

	varDest.ChangeType(VT_UNKNOWN, this);

	return V_UNKNOWN(&varDest);
}

// Extracts a VT_DECIMAL into a DECIMAL
//
inline auto_var::operator DECIMAL() const throw(_com_error)
{
	if (V_VT(this) == VT_DECIMAL) {
		return V_DECIMAL(this);
	}

	auto_var varDest;

	varDest.ChangeType(VT_DECIMAL, this);

	return V_DECIMAL(&varDest);
}

// Extracts a VT_UI1 into a BYTE (unsigned char)
//
inline auto_var::operator BYTE() const throw(_com_error)
{
	if (V_VT(this) == VT_UI1) {
		return V_UI1(this);
	}

	auto_var varDest;

	varDest.ChangeType(VT_UI1, this);

	return V_UI1(&varDest);
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// Assignment operations
//
//////////////////////////////////////////////////////////////////////////////////////////

// Assign a const VARIANT& (::VariantCopy handles everything)
//
inline auto_var& auto_var::operator=(const VARIANT& varSrc) throw(_com_error)
{
    Clear();
    _com_util::CheckError(::VariantCopy(this, const_cast<VARIANT*>(&varSrc)));

	return *this;
}

// Assign a const VARIANT* (::VariantCopy handles everything)
//
inline auto_var& auto_var::operator=(const VARIANT* pSrc) throw(_com_error)
{
    Clear();
	_com_util::CheckError(::VariantCopy(this, const_cast<VARIANT*>(pSrc)));

	return *this;
}

// Assign a const auto_var& (::VariantCopy handles everything)
//
inline auto_var& auto_var::operator=(const auto_var& varSrc) throw(_com_error)
{
    Clear();
	_com_util::CheckError(::VariantCopy(this, const_cast<VARIANT*>(static_cast<const VARIANT*>(&varSrc))));

	return *this;
}

// Assign a short creating either VT_I2 VARIANT or a 
// VT_BOOL VARIANT (VT_I2 is the default)
//
inline auto_var& auto_var::operator=(short sSrc) throw(_com_error)
{
	if (V_VT(this) == VT_I2) {
		V_I2(this) = sSrc;
	}
	else if (V_VT(this) == VT_BOOL) {
		V_BOOL(this) = (sSrc ? VARIANT_TRUE : VARIANT_FALSE);
	}
	else {
		// Clear the VARIANT and create a VT_I2
		//
		Clear();

		V_VT(this) = VT_I2;
		V_I2(this) = sSrc;
	}

	return *this;
}

// Assign a long creating either VT_I4 VARIANT, a VT_ERROR VARIANT
// or a VT_BOOL VARIANT (VT_I4 is the default)
//
inline auto_var& auto_var::operator=(long lSrc) throw(_com_error)
{
	if (V_VT(this) == VT_I4) {
		V_I4(this) = lSrc;
	}
	else if (V_VT(this) == VT_ERROR) {
		V_ERROR(this) = lSrc;
	}
	else if (V_VT(this) == VT_BOOL) {
		V_BOOL(this) = (lSrc ? VARIANT_TRUE : VARIANT_FALSE);
	}
	else {
		// Clear the VARIANT and create a VT_I4
		//
		Clear();

		V_VT(this) = VT_I4;
		V_I4(this) = lSrc;
	}

	return *this;
}

// Assign a float creating a VT_R4 VARIANT 
//
inline auto_var& auto_var::operator=(float fltSrc) throw(_com_error)
{
	if (V_VT(this) != VT_R4) {
		// Clear the VARIANT and create a VT_R4
		//
		Clear();

		V_VT(this) = VT_R4;
	}

	V_R4(this) = fltSrc;

	return *this;
}

// Assign a double creating either a VT_R8 VARIANT, or a VT_DATE
// VARIANT (VT_R8 is the default)
//
inline auto_var& auto_var::operator=(double dblSrc) throw(_com_error)
{
	if (V_VT(this) == VT_R8) {
		V_R8(this) = dblSrc;
	}
	else if(V_VT(this) == VT_DATE) {
		V_DATE(this) = dblSrc;
	}
	else {
		// Clear the VARIANT and create a VT_R8
		//
		Clear();

		V_VT(this) = VT_R8;
		V_R8(this) = dblSrc;
	}

	return *this;
}

// Assign a CY creating a VT_CY VARIANT 
//
inline auto_var& auto_var::operator=(const CY& cySrc) throw(_com_error)
{
	if (V_VT(this) != VT_CY) {
		// Clear the VARIANT and create a VT_CY
		//
		Clear();

		V_VT(this) = VT_CY;
	}

	V_CY(this) = cySrc;

	return *this;
}

// Assign a const _bstr_t& creating a VT_BSTR VARIANT
//
inline auto_var& auto_var::operator=(const _bstr_t& bstrSrc) throw(_com_error)
{
	// Clear the VARIANT (This will SysFreeString() any previous occupant)
	//
	Clear();

	V_VT(this) = VT_BSTR;

	if (!bstrSrc) {
		V_BSTR(this) = NULL;
	}
	else {
		BSTR bstr = static_cast<wchar_t*>(bstrSrc);
		V_BSTR(this) = ::SysAllocStringByteLen(reinterpret_cast<char*>(bstr),
											   ::SysStringByteLen(bstr));

		if (V_BSTR(this) == NULL) {
			_com_issue_error(E_OUTOFMEMORY);
		}
	}

	return *this;
}

// Assign a const wchar_t* creating a VT_BSTR VARIANT
//
inline auto_var& auto_var::operator=(const wchar_t* pSrc) throw(_com_error)
{
	// Clear the VARIANT (This will SysFreeString() any previous occupant)
	//
	Clear();

	V_VT(this) = VT_BSTR;

	if (pSrc == NULL) {
		V_BSTR(this) = NULL;
	}
	else {
		V_BSTR(this) = ::SysAllocString(pSrc);

		if (V_BSTR(this) == NULL) {
			_com_issue_error(E_OUTOFMEMORY);
		}
	}

	return *this;
}

// Assign a const char* creating a VT_BSTR VARIANT
//
inline auto_var& auto_var::operator=(const char* pSrc) throw(_com_error)
{
	// Clear the VARIANT (This will SysFreeString() any previous occupant)
	//
	Clear();

	V_VT(this) = VT_BSTR;
	V_BSTR(this) = _com_util::ConvertStringToBSTR(pSrc);

	if (V_BSTR(this) == NULL && pSrc != NULL) {
		_com_issue_error(E_OUTOFMEMORY);
	}

	return *this;
}

// Assign an IDispatch* creating a VT_DISPATCH VARIANT 
//
inline auto_var& auto_var::operator=(IDispatch* pSrc) throw(_com_error)
{
	// Clear the VARIANT (This will Release() any previous occupant)
	//
	Clear();

	V_VT(this) = VT_DISPATCH;
	V_DISPATCH(this) = pSrc;

	// Need the AddRef() as VariantClear() calls Release()
	//
	V_DISPATCH(this)->AddRef();

	return *this;
}

// Assign a bool creating a VT_BOOL VARIANT 
//
inline auto_var& auto_var::operator=(bool bSrc) throw(_com_error)
{
	if (V_VT(this) != VT_BOOL) {
		// Clear the VARIANT and create a VT_BOOL
		//
		Clear();

		V_VT(this) = VT_BOOL;
	}

	V_BOOL(this) = (bSrc ? VARIANT_TRUE : VARIANT_FALSE);

	return *this;
}

// Assign an IUnknown* creating a VT_UNKNOWN VARIANT 
//
inline auto_var& auto_var::operator=(IUnknown* pSrc) throw(_com_error)
{
	// Clear VARIANT (This will Release() any previous occupant)
	//
	Clear();

	V_VT(this) = VT_UNKNOWN;
	V_UNKNOWN(this) = pSrc;

	// Need the AddRef() as VariantClear() calls Release()
	//
	V_UNKNOWN(this)->AddRef();

	return *this;
}

// Assign a DECIMAL creating a VT_DECIMAL VARIANT
//
inline auto_var& auto_var::operator=(const DECIMAL& decSrc) throw(_com_error)
{
	if (V_VT(this) != VT_DECIMAL) {
		// Clear the VARIANT
		//
		Clear();
	}

	// Order is important here! Setting V_DECIMAL wipes out the entire VARIANT
	V_DECIMAL(this) = decSrc;
	V_VT(this) = VT_DECIMAL;

	return *this;
}

// Assign a BTYE (unsigned char) creating a VT_UI1 VARIANT
//
inline auto_var& auto_var::operator=(BYTE bSrc) throw(_com_error)
{
	if (V_VT(this) != VT_UI1) {
		// Clear the VARIANT and create a VT_UI1
		//
		Clear();

		V_VT(this) = VT_UI1;
	}

	V_UI1(this) = bSrc;

	return *this;
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// Comparison operations
//
//////////////////////////////////////////////////////////////////////////////////////////

// Compare a auto_var against a const VARIANT& for equality
//
inline bool auto_var::operator==(const VARIANT& varSrc) const throw()
{
	return *this == &varSrc;
}

// Compare a auto_var against a const VARIANT* for equality
//
inline bool auto_var::operator==(const VARIANT* pSrc) const throw()
{
	if (this == pSrc) {
		return true;
	}

	//
	// Variants not equal if types don't match
	//
	if (V_VT(this) != V_VT(pSrc)) {
		return false;
	}

	//
	// Check type specific values
	//
	switch (V_VT(this)) {
		case VT_EMPTY:
		case VT_NULL:
			return true;

		case VT_I2:
			return V_I2(this) == V_I2(pSrc);

		case VT_I4:
			return V_I4(this) == V_I4(pSrc);

		case VT_R4:
			return V_R4(this) == V_R4(pSrc);

		case VT_R8:
			return V_R8(this) == V_R8(pSrc);

		case VT_CY:
			return memcmp(&(V_CY(this)), &(V_CY(pSrc)), sizeof(CY)) == 0;

		case VT_DATE:
			return V_DATE(this) == V_DATE(pSrc);

		case VT_BSTR:
			return (::SysStringByteLen(V_BSTR(this)) == ::SysStringByteLen(V_BSTR(pSrc))) &&
					(memcmp(V_BSTR(this), V_BSTR(pSrc), ::SysStringByteLen(V_BSTR(this))) == 0);

		case VT_DISPATCH:
			return V_DISPATCH(this) == V_DISPATCH(pSrc);

		case VT_ERROR:
			return V_ERROR(this) == V_ERROR(pSrc);

		case VT_BOOL:
			return V_BOOL(this) == V_BOOL(pSrc);

		case VT_UNKNOWN:
			return V_UNKNOWN(this) == V_UNKNOWN(pSrc);

		case VT_DECIMAL:
			return memcmp(&(V_DECIMAL(this)), &(V_DECIMAL(pSrc)), sizeof(DECIMAL)) == 0;

		case VT_UI1:
			return V_UI1(this) == V_UI1(pSrc);

		default:
			_com_issue_error(E_INVALIDARG);
			// fall through
	}

	return false;
}

// Compare a auto_var against a const VARIANT& for in-equality
//
inline bool auto_var::operator!=(const VARIANT& varSrc) const throw()
{
	return !(*this == &varSrc);
}

// Compare a auto_var against a const VARIANT* for in-equality
//
inline bool auto_var::operator!=(const VARIANT* pSrc) const throw()
{
	return !(*this == pSrc);
}

//////////////////////////////////////////////////////////////////////////////////////////
//
// Low-level operations
//
//////////////////////////////////////////////////////////////////////////////////////////

// Clear the auto_var
//
inline void auto_var::Clear() throw(_com_error)
{
	_com_util::CheckError(::VariantClear(this));
}

inline void auto_var::Attach(VARIANT& varSrc) throw(_com_error)
{
	//
	// Free up previous VARIANT
	//
	Clear();

	//
	// Give control of data to auto_var
	//
	memcpy(this, &varSrc, sizeof(varSrc));
	V_VT(&varSrc) = VT_EMPTY;
}

inline VARIANT auto_var::Detach() throw(_com_error)
{
	VARIANT varResult = *this;
	V_VT(this) = VT_EMPTY;

	return varResult;
}

// Change the type and contents of this auto_var to the type vartype and
// contents of pSrc
//
inline void auto_var::ChangeType(VARTYPE vartype, const auto_var* pSrc) throw(_com_error)
{
	//
	// If pDest is NULL, convert type in place
	//
	if (pSrc == NULL) {
		pSrc = this;
	}

	if ((this != pSrc) || (vartype != V_VT(this))) {
		_com_util::CheckError(::VariantChangeType(static_cast<VARIANT*>(this),
												  const_cast<VARIANT*>(static_cast<const VARIANT*>(pSrc)),
												  0, vartype));
	}
}

inline void auto_var::SetString(const char* pSrc) throw(_com_error)
{
	//
	// Free up previous VARIANT
	//
	Clear();

	V_VT(this) = VT_BSTR;
	V_BSTR(this) = _com_util::ConvertStringToBSTR(pSrc);

	if (V_BSTR(this) == NULL && pSrc != NULL) {
		_com_issue_error(E_OUTOFMEMORY);
	}
}

inline auto_var::~auto_var() throw(_com_error)
{
	_com_util::CheckError(::VariantClear(this));
}
#endif // __wtypes_h__

// auto_internet **************************************************************
//
// Smart Pointers for HINTERNET

#ifdef _WININET_
class auto_internet
{
public:
    explicit auto_internet(HINTERNET p = 0)
        : m_p(p) {};
    auto_internet(auto_internet& rhs)
        : m_p(rhs.release()) {};

    ~auto_internet()
        { reset(); };

    auto_internet& operator= (auto_internet& rhs)
    {   if (this != rhs.getThis())
            reset (rhs.release() );
        return *this;
    };

    auto_internet& operator= (HINTERNET rhs)
    {   
        reset (rhs);
        return *this;
    };
//    HINTERNET operator*() const 
//        { return m_p; };
//    void** operator& ()
//        { reset(); return (void**)&m_p; };
    operator HINTERNET ()
        { return m_p; };
    
    // Checks for NULL
    BOOL operator== (LPVOID lpv)
        { return m_p == lpv; };
    BOOL operator!= (LPVOID lpv)
        { return m_p != lpv; };

    // return value of current dumb pointer
    HINTERNET  get() const
        { return m_p; };

    // relinquish ownership
    HINTERNET  release()
    {   HINTERNET oldp = m_p;
        m_p = 0;
        return oldp;
    };

    // delete owned pointer; assume ownership of p
    void reset (HINTERNET p = 0)
    {   
        if (m_p)
			InternetCloseHandle(m_p);
        m_p = p;
    };

private:
    // operator& throws off operator=
    const auto_internet* getThis() const
    {   return this; };

    HINTERNET m_p;
};
#endif  // _WININET_

// auto_virt ******************************************************************
//
// Smart Pointers for memory freed with VirtualFree

#ifdef _WINBASE_
template<class _Ty>
class auto_virt
{
public:
	typedef _Ty element_type;

    explicit auto_virt(_Ty *_P = 0) _THROW0()
		: _Owns(_P != 0), _Ptr(_P) {}
	auto_virt(const auto_virt<_Ty>& _Y) _THROW0()
		: _Owns(_Y._Owns), _Ptr(_Y.release()) {}
	auto_virt<_Ty>& operator=(const auto_virt<_Ty>& _Y) _THROW0()
		{if (_Ptr != _Y.get())
			{if (_Owns && _Ptr)
				VirtualFree(_Ptr);
			_Owns = _Y._Owns;
			_Ptr = _Y.release(); }
		else if (_Y._Owns)
			_Owns = true;
		return (*this); }
	auto_virt<_Ty>& operator=(_Ty* _Y) _THROW0()
		{	{if (_Owns && _Ptr)
				VirtualFree(_Ptr,0,MEM_RELEASE);
			_Owns = _Y != 0;
			_Ptr = _Y; }
		return (*this); }

	~auto_virt()
		{if (_Owns && _Ptr)
			VirtualFree(_Ptr,0,MEM_RELEASE);}
	_Ty** operator&() _THROW0()
		{if (_Owns && _Ptr)
			VirtualFree(_Ptr,0,MEM_RELEASE);
		 _Owns = true;
		 _Ptr = 0;
		 return &_Ptr; 
		}
    operator _Ty* () const
        { return _Ptr; }
    _Ty& operator*() const _THROW0()
		{return (*get()); }
	_Ty *operator->() const _THROW0()
		{return (get()); }
    _Ty& operator[] (int ndx) const _THROW0()
        {return *(get() + ndx); }
	_Ty *get() const _THROW0()
		{return (_Ptr); }
	_Ty *release() const _THROW0()
		{((auto_virt<_Ty> *)this)->_Owns = false;
		return (_Ptr); }
	bool Ownership(bool fOwns)
		{ return _Owns = fOwns; }
protected:
	bool _Owns;
	_Ty *_Ptr;
	};
#endif // _WINBASE_

// RCObject *******************************************************************
//
// Smart objects for reference counting

class RCObject
{
public:
    void addReference()
    { 
        ++refCount;
    }
    void removeReference()
    {
        if (--refCount == 0)
            delete this;
    }

    void markUnshareable()
    {
        shareable = FALSE;
    }

    BOOL isShareable() const
    {
        return shareable;
    }

    BOOL isShared() const
    {
        return refCount > 1;
    }

protected:
    RCObject()
        : refCount(0), shareable(TRUE) {};

    RCObject(const RCObject& rhs)
        : refCount(0), shareable(TRUE) {};
    
    RCObject& operator= (const RCObject& rhs)
    {
        return *this;
    }
    
    virtual ~RCObject() {};

private:
    int refCount;
    BOOL shareable;
};

// RCPtr **********************************************************************
//
// Smart Pointers for reference counting, use w/ RCObject

template<class T>
class RCPtr
{
public:
    RCPtr(T* realPtr = 0);
    RCPtr(const RCPtr&rhs);
    ~RCPtr();

    RCPtr& operator=(const RCPtr& rhs);

    BOOL operator==(const RCPtr&rhs) const;
    BOOL operator< (const RCPtr&rhs) const;
    BOOL operator> (const RCPtr&rhs) const;
	operator bool(void) const;

    T* operator->() const;
    T& operator*() const;
	T* get(void) const;

protected:
    T* pointee;

    void init();
};

template<class T>
void RCPtr<T>::init ()
{
    if (pointee == 0)
        return;

    if (pointee->isShareable() == FALSE)
    {
        pointee = new T(*pointee);
    }

    pointee->addReference();
}

template<class T>
RCPtr<T>::RCPtr (T* realPtr)
: pointee(realPtr)
{
    init();
}

template<class T>
RCPtr<T>::RCPtr (const RCPtr& rhs)
: pointee(rhs.pointee)
{
    init();
}

template<class T>
RCPtr<T>::~RCPtr()
{
    if (pointee)
        pointee->removeReference();
}

template<class T>
RCPtr<T>& RCPtr<T>::operator= (const RCPtr<T>& rhs)
{
    if (pointee != rhs.pointee)
    {
        if (pointee)
            pointee->removeReference();

        pointee = rhs.pointee;

        init();
    }

    return *this;
}

template<class T>
BOOL RCPtr<T>::operator==(const RCPtr&rhs) const
{ return pointee == rhs.pointee; }

template<class T>
BOOL RCPtr<T>::operator< (const RCPtr&rhs) const
{ return pointee < rhs.pointee; }

template<class T>
BOOL RCPtr<T>::operator> (const RCPtr&rhs) const
{ return pointee > rhs.pointee; }

template<class T>
T* RCPtr<T>::operator->() const
{
    return pointee;
}

template<class T>
T& RCPtr<T>::operator*() const
{
    return *pointee;
}

template<class T>
RCPtr<T>::operator bool(void) const
{
	return pointee != NULL;
}

template<class T>
T* RCPtr<T>::get(void) const
{
	return pointee;
}

// auto_menu ******************************************************************
//
// Smart Pointers for DestroyMenu

// auto_reg *******************************************************************
//
// Smart pointer for HKEY's

class auto_menu
{
public:
    auto_menu(HMENU p = 0)
        : h(p) {};
    auto_menu(auto_menu& rhs)
        : h(rhs.release()) {};

    ~auto_menu()
        { if (h) DestroyMenu(h); };

    auto_menu& operator= (auto_menu& rhs)
    {   if (this != rhs.getThis())
            reset (rhs.release() );
        return *this;
    };
    auto_menu& operator= (HMENU rhs)
    {   if ((NULL == rhs) || (INVALID_HANDLE_VALUE == rhs))
        {   // be sure and go through auto_os for dbg.lib
            auto_os os;
            os = (BOOL)FALSE;
        }
        reset (rhs);
        return *this;
    };

    HMENU* operator& ()
        { reset(); return &h; };
    operator HMENU ()
        { return h; };
    
    // Checks for NULL
    bool operator== (LPVOID lpv)
        { return h == lpv; };
    bool operator!= (LPVOID lpv)
        { return h != lpv; };

    // return value of current dumb pointer
    HMENU  get() const
        { return h; };

    // relinquish ownership
    HMENU  release()
    {   HMENU oldh = h;
        h = 0;
        return oldh;
    };

    // delete owned pointer; assume ownership of p
    BOOL reset (HMENU p = 0)
    {
        BOOL rt = TRUE;

        if (h)
			rt = DestroyMenu(h);
        h = p;
        
        return rt;
    };

private:
    // operator& throws off operator=
    const auto_menu* getThis() const
    {   return this; };

    HMENU h;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\wmi\dgnet\dgnet.cpp ===
/******************************************************************
   Copyright (c) 1999 Microsoft Corporation

   GotNet.CPP -- WMI provider class implementation

   Generated by Microsoft WMI Code Generation Engine
  
   TO DO: - See individual function headers
          - When linking, make sure you link to framedyd.lib & 
            msvcrtd.lib (debug) or framedyn.lib & msvcrt.lib (retail).

   Description: 
   
  
  
******************************************************************/

//#include "stdpch.h"
//#pragma hdrstop
#include "stdpch.h"
#include "dgnet.h"

GUID CLSID_Dgnet = { 0x8dabe793,0x23d9,0x45df, {0xa3,0xdb,0xf4,0x42,0x88,0x3b,0xb4,0x79} };


#include "host.h"   // CHost
#include "output.h" // COutput
#include "diag.h"

#include "oe.h"
#include "proxy.h"
#include "connect.h"    // ConnectToPort

// TO DO: Replace "NameSpace" with the appropriate namespace for your
//        provider instance.  For instance:  "root\\default or "root\\cimv2".
//===================================================================
//CGotNet MyGotNetSet (PROVIDER_NAME_GOTNET, L"root\\default") ;

// Property names
//===============

const static WCHAR* pid                   = L"id" ;
/*
const static WCHAR* pInBoundMailServer    = L"InBoundMailServer" ;
const static WCHAR* pInBoundMailPort      = L"InBoundMailPort" ;
const static WCHAR* pInBoundMailType      = L"InBoundMailType" ;
const static WCHAR* pOutBoundMailServer   = L"OutBoundMailServer" ;
const static WCHAR* pOutBoundMailPort     = L"OutBoundMailPort" ;
const static WCHAR* pOutBoundMailType     = L"OutBoundMailType" ;
*/
const static WCHAR* pNewsServer           = L"NewsServer" ;
const static WCHAR* pNewsNNTPPort         = L"NewsNNTPPort" ;

const static WCHAR* pbIEProxy             = L"bIEProxy" ;
const static WCHAR* pIEProxy              = L"IEProxy" ;
const static WCHAR* pIEProxyPort          = L"IEProxyPort" ;



#if 0
// Counts the number of times the com object is referenced
//
long g_nModuleRef = 0;

void 
AddRefModule() 
/*++

Routine Description
    This routine is counts the number of time the dll/COM is being refernce.
    Increments the ref count

Arguments
    none 

Return Value
    none

--*/
{
    InterlockedIncrement(&g_nModuleRef);
}

void 
ReleaseModule()
/*++

Routine Description
    This routine is decrements the ref count.

Arguments
    none 

Return Value
    none

--*/
{
    InterlockedDecrement(&g_nModuleRef);
}
#endif
/*****************************************************************************
 *
 *  FUNCTION    :   CGotNet::CGotNet
 *
 *  DESCRIPTION :   Constructor
 *
 *  INPUTS      :   none
 *
 *  RETURNS     :   nothing
 *
 *  COMMENTS    :   Calls the Provider constructor.
 *
 *****************************************************************************/
CGotNet::CGotNet ()
{
    //AddRefModule();
}

/*****************************************************************************
 *
 *  FUNCTION    :   CGotNet::~CGotNet
 *
 *  DESCRIPTION :   Destructor
 *
 *  INPUTS      :   none
 *
 *  RETURNS     :   nothing
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/
CGotNet::~CGotNet ()
{
    //ReleaseModule();
}
//***************************************************************************
//
// CGotNet::QueryInterface
// CGotNet::AddRef
// CGotNet::Release
//
// Purpose: IUnknown members for CInstPro object.
//***************************************************************************

#if 0
STDMETHODIMP CGotNet::QueryInterface(REFIID riid, LPVOID* ppv)
{
    *ppv=NULL;

    // Since we have dual inheritance, it is necessary to cast the return type

    if(riid== IID_IWbemServices)
       *ppv=(IWbemServices*)this;

    if(IID_IUnknown==riid || riid== IID_IWbemProviderInit)
       *ppv=(IWbemProviderInit*)this;
    

    if (NULL!=*ppv) {
        AddRef();
        return NOERROR;
        }
    else
        return E_NOINTERFACE;
  
}


STDMETHODIMP_(ULONG) CGotNet::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CGotNet::Release(void)
{
    ULONG nNewCount = InterlockedDecrement((long *)&m_cRef);
    if (0L == nNewCount)
        delete this;
    
    return nNewCount;
}
#endif
/***********************************************************************
*                                                                      *
*   CInstPro::Initialize                                                *
*                                                                      *
*   Purpose: This is the implementation of IWbemProviderInit. The method  *
*   is need to initialize with CIMOM.                                    *
*                                                                      *
***********************************************************************/

STDMETHODIMP CGotNet::Initialize(LPWSTR pszUser, LONG lFlags,
                                    LPWSTR pszNamespace, LPWSTR pszLocale,
                                    IWbemServices *pNamespace, 
                                    IWbemContext *pCtx,
                                    IWbemProviderInitSink *pInitSink)
{
    if(pNamespace)
        pNamespace->AddRef();

    m_pNamespace = pNamespace;

    //Let CIMOM know you are initialized
    //==================================
    
    pInitSink->SetStatus(WBEM_S_INITIALIZED,0);
    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
// CInstPro::CreateInstanceEnumAsync
//
// Purpose: Asynchronously enumerates the instances.  
//
//***************************************************************************

SCODE CGotNet::CreateInstanceEnumAsync( const BSTR RefStr, long lFlags, IWbemContext *pCtx,
       IWbemObjectSink FAR* pHandler)
{
    SCODE sc;
    int iCnt;
    IWbemClassObject * pNewInst = NULL;
    HRESULT hr;

    // Do a check of arguments and make sure we have pointer to Namespace
    if(pHandler == NULL || m_pNamespace == NULL)
        return WBEM_E_INVALID_PARAMETER;

    hr = CoImpersonateClient();
    if( hr != S_OK )
    {
        return hr;
    }

    for(iCnt=0; iCnt < 1; iCnt++)
    {
        sc = CreateInst(
                m_pNamespace,
                &pNewInst,
                RefStr,
                pCtx);

        
        if(sc != S_OK)
            break;

        sc = AddProps(pNewInst);

        if(sc != S_OK)
            break;

        // Send the object to the caller

        pHandler->Indicate(1,&pNewInst);
        pNewInst->Release();
    }

    // Set status

    pHandler->SetStatus(0,sc,NULL, NULL);

    CoRevertToSelf();
    return sc;
}


//***************************************************************************
//
// CGotNet::GetObjectByPath
// CGetNet::GetObjectByPathAsync
//
// Purpose: Creates an instance given a particular path value.
//
//***************************************************************************
SCODE CGotNet::GetObjectAsync(const BSTR ObjectPath, long lFlags,IWbemContext  *pCtx,
                    IWbemObjectSink FAR* pHandler)
{

    SCODE sc;
    IWbemClassObject FAR* pObj;
    BOOL bOK = FALSE;

    // Do a check of arguments and make sure we have pointer to Namespace

    if(ObjectPath == NULL || pHandler == NULL || m_pNamespace == NULL)
        return WBEM_E_INVALID_PARAMETER;

    // do the get, pass the object on to the notify
    
    sc = GetByPath(ObjectPath,&pObj, pCtx);
    if(sc == S_OK) 
    {
        pHandler->Indicate(1,&pObj);
        pObj->Release();
        bOK = TRUE;
    }

    sc = (bOK) ? S_OK : WBEM_E_NOT_FOUND;

    // Set Status

    pHandler->SetStatus(0,sc, NULL, NULL);

    return sc;
}
 
//***************************************************************************
//
// CGotNet::GetByPath
//
// Purpose: Creates an instance given a particular Path value.
//
//***************************************************************************

SCODE
CGotNet::GetByPath(
    BSTR ObjectPath, 
    IWbemClassObject FAR* FAR* ppObj,
    IWbemContext  *pCtx)
{
    SCODE sc = S_OK;
    
    if(!_wcsicmp(L"NetDiagnostics=@", ObjectPath))
    {
        sc = CreateInst(
                m_pNamespace,
                ppObj, 
                L"NetDiagnostics", 
                pCtx);

        return sc;
    }

    return WBEM_E_NOT_FOUND;
}
 
HRESULT STDMETHODCALLTYPE
CGotNet::ExecMethodAsync(
    const BSTR ObjectPath, 
    const BSTR MethodName, 
    long lFlags, 
    IWbemContext* pCtx, 
    IWbemClassObject* pInParams, 
    IWbemObjectSink* pResultSink)
{
    if(0 == _wcsicmp(MethodName, L"Ping"))
    {
        return WMIPing(lFlags, pCtx, pInParams, pResultSink);
    }
    else if (0 == _wcsicmp(MethodName, L"ConnectToPort"))
    {
        return WMIConnectToPort(lFlags, pCtx, pInParams, pResultSink);
    }
    else
    {
        return WBEM_E_INVALID_PARAMETER;
    }
}

HRESULT CGotNet::WMIPing(
        long lFlags, 
        IWbemContext* pCtx, 
        IWbemClassObject* pInParams, 
        IWbemObjectSink* pResultSink)
{
    HRESULT hr;    
    IWbemClassObject * pClass = NULL;
    IWbemClassObject * pOutClass = NULL;    
    IWbemClassObject* pOutParams = NULL;
    TEST_INFO ping;
    CHost host;
    TCHAR buffer[100];

    WSADATA wsa;

    DWORD err = WSAStartup(MAKEWORD(2,1), &wsa);
    if( err != 0 )
    {
        err = WSAGetLastError();
    }

    hr = CoImpersonateClient();
    if( hr != S_OK )
    {
        return hr;
    }


    // Allocate some BSTRs
    
    BSTR ClassName = SysAllocString(L"NetDiagnostics");    
    BSTR InputArgName = SysAllocString(L"sInAddr");
    BSTR OutputArgName = SysAllocString(L"sOutArg");
    BSTR retValName = SysAllocString(L"ReturnValue");

    // Get the class object, this is hard coded and matches the class
    // in the MOF.  A more sophisticated example would parse the 
    // ObjectPath to determine the class and possibly the instance.

    hr = m_pNamespace->GetObject(ClassName, 0, pCtx, &pClass, NULL);
	if(hr != S_OK)
	{
		pResultSink->SetStatus(0,hr, NULL, NULL);
        CoRevertToSelf();
		
        return WBEM_S_NO_ERROR;
	}
 

    // This method returns values, and so create an instance of the
    // output argument class.

    hr = pClass->GetMethod(L"Ping", 0, NULL, &pOutClass);
    pOutClass->SpawnInstance(0, &pOutParams);

    // Copy the input argument into the output object    
    
    auto_var var;

    // Get the input argument
    pInParams->Get(InputArgName, 0, &var, NULL, NULL);   
    //wcstombs(buffer, var.bstrVal, 100);
    lstrcpyn(buffer, var.bstrVal, 100);

    ping.host.SetHost(buffer);
    CheckPing(&ping);
    WaitForSingleObject(ping.hEvent, INFINITE);

    
    // put it into the output object
    _variant_t v ((bool)(ping.dwErr == S_OK));

    pOutParams->Put(retValName , 0, &v, 0);      

    v = ping.output.Status();
    pOutParams->Put(OutputArgName , 0, &v, 0); 

    // Send the output object back to the client via the sink. Then 
    // release the pointers and free the strings.

    hr = pResultSink->Indicate(1, &pOutParams);    
    pOutParams->Release();
    pOutClass->Release();    
    pClass->Release();    
    SysFreeString(ClassName);
    SysFreeString(InputArgName);    
    SysFreeString(OutputArgName);
    SysFreeString(retValName);     
    
    // all done now, set the status
    hr = pResultSink->SetStatus(0,WBEM_S_NO_ERROR,NULL,NULL);
    CoRevertToSelf();

    WSACleanup();
    return WBEM_S_NO_ERROR;

}

HRESULT CGotNet::WMIConnectToPort(
    long lFlags, 
    IWbemContext* pCtx, 
    IWbemClassObject* pInParams, 
    IWbemObjectSink* pResultSink)
{
    HRESULT hr;    
    IWbemClassObject * pClass = NULL;
    IWbemClassObject * pOutClass = NULL;    
    IWbemClassObject* pOutParams = NULL;
    TEST_INFO ping;
    CHost host;
    TCHAR buffer[100];
    bool bConnect = false;

    WSADATA wsa;

    DWORD err = WSAStartup(MAKEWORD(2,1), &wsa);
    if( err != 0 )
    {
        err = WSAGetLastError();
    }


    hr = CoImpersonateClient();
    if( hr != S_OK )
    {
        return hr;
    }

    // Allocate some BSTRs
    
    BSTR ClassName = SysAllocString(L"NetDiagnostics");    
    BSTR AddrArgName = SysAllocString(L"sInAddr");
    BSTR PortArgName = SysAllocString(L"port");
    BSTR OutputArgName = SysAllocString(L"sOutArg");
    BSTR retValName = SysAllocString(L"ReturnValue");

    // Get the class object, this is hard coded and matches the class
    // in the MOF.  A more sophisticated example would parse the 
    // ObjectPath to determine the class and possibly the instance.

    hr = m_pNamespace->GetObject(ClassName, 0, pCtx, &pClass, NULL);
	if(hr != S_OK)
	{
		pResultSink->SetStatus(0,hr, NULL, NULL);
        CoRevertToSelf();
		
        return WBEM_S_NO_ERROR;
	}
 

    // This method returns values, and so create an instance of the
    // output argument class.

    hr = pClass->GetMethod(L"ConnectToPort", 0, NULL, &pOutClass);
    pOutClass->SpawnInstance(0, &pOutParams);

    // Copy the input argument into the output object    
    
    auto_var addr;
    auto_var port;
    
    // Get the input argument
    pInParams->Get(AddrArgName, 0, &addr, NULL, NULL);   
    pInParams->Get(PortArgName, 0, &port, NULL, NULL);   

    lstrcpyn(buffer, addr.bstrVal, 100);
    //wcstombs(buffer, addr.bstrVal, 100);

    host.SetHost(buffer);

    Connect(host, port.lVal, bConnect);
    
    // put it into the output object
    _variant_t v (bConnect);

    pOutParams->Put(retValName , 0, &v, 0);      

    v = ping.output.Status();
    pOutParams->Put(OutputArgName , 0, &v, 0); 

    // Send the output object back to the client via the sink. Then 
    // release the pointers and free the strings.

    hr = pResultSink->Indicate(1, &pOutParams);    
    pOutParams->Release();
    pOutClass->Release();    
    pClass->Release();    
    SysFreeString(ClassName);
    SysFreeString(AddrArgName);    
    SysFreeString(PortArgName);    
    SysFreeString(OutputArgName);
    SysFreeString(retValName);     
    
    // all done now, set the status
    hr = pResultSink->SetStatus(0,WBEM_S_NO_ERROR,NULL,NULL);
    CoRevertToSelf();

    WSACleanup();
    return WBEM_S_NO_ERROR;
}


HRESULT CGotNet::AddProps(IWbemClassObject* pInstance)
{
    HRESULT hRes = WBEM_S_NO_ERROR;
    CHost host;
    DWORD dwPort = 0;
    DWORD dwProxyPort = 0;
    DWORD dwProxyEnabled = 0;
    _variant_t v;

    v.Clear();

    /*
    //
    // Grab all the mail server information
    ///////////////////////////////////////
    CHost InBoundMailHost, OutBoundMailHost;
    DWORD dwInBoundPort, dwOutBoundPort;
    TCHAR wszInBoundMailType[MAX_PATH], wszOutBoundMailType[MAX_PATH];

    hRes = GetOEDefaultMailServer(InBoundMailHost,  
                                  dwInBoundPort, 
                                  wszInBoundMailType,
                                  OutBoundMailHost, 
                                  dwOutBoundPort,
                                  wszOutBoundMailType);

    if( SUCCEEDED(hRes) )
    {
        v = InBoundMailHost.GetHost();
        pInstance->Put(pInBoundMailServer, 0, &v, 0);      

        v = (long)dwInBoundPort;
        pInstance->Put(pInBoundMailPort, 0, &v, 0);

        v = wszInBoundMailType;
        pInstance->Put(pInBoundMailType, 0, &v, 0);      


        v = OutBoundMailHost.GetHost();
        pInstance->Put(pOutBoundMailServer, 0, &v, 0);      

        v = (long)dwOutBoundPort;
        pInstance->Put(pOutBoundMailPort, 0, &v, 0);

        v = wszOutBoundMailType;
        pInstance->Put(pOutBoundMailType, 0, &v, 0);      

    }
    
    */
    //
    // Grab all the news server information
    ///////////////////////////////////////
    v.Clear();
    hRes = GetOEDefaultNewsServer(host, dwPort);
    v = host.GetHost();
    pInstance->Put(pNewsServer,  0, &v, 0);
    
    v = (long)dwPort;
    pInstance->Put(pNewsNNTPPort, 0, &v, 0);
    
    v.Clear();
    if (FindProxy(&host, &dwProxyPort, &dwProxyEnabled))
    {
        v = (bool)(dwProxyEnabled == TRUE);
        pInstance->Put(pbIEProxy, 0, &v, 0);

        v.Clear();
        v = host.GetHost();
        pInstance->Put(pIEProxy, 0, &v, 0);

        v.Clear();
        v = (long)dwProxyPort;
        pInstance->Put(pIEProxyPort, 0, &v, 0);
    }
    else
    {
        v = (bool)FALSE;
        pInstance->Put(pbIEProxy, 0, &v, 0);
        pInstance->Put(pIEProxy, 0, NULL, 0);
        pInstance->Put(pIEProxyPort, 0, NULL, 0);
    }

    
    return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\wmi\dgnet\connect.h ===
// connect.h
//

class CHost;

HRESULT Connect (CHost& host, INT port, bool& bRet);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\wmi\dgnet\diag.h ===
// diag.h
//
// API calls for detecting windows status.
//

#ifdef _GLOBALS
#define Extern
#define EQ(x) = (x)
#else
#define Extern extern
#define EQ(x)
#endif

//#define EXPORT __declspec (dllexport)
void EXPORT DiagInit();
void EXPORT DiagShutdown();

class TEST_INFO
{
public:
    TEST_INFO()
    { hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    }
    IN  HANDLE  hEvent;              // triggered when call completes
    IN  CHost   host;                
    OUT DWORD   dwAdditionalInfo;
    OUT DWORD   dwErr;
    OUT double  dTimeDelta;  // how long it tooks
    OUT COutput output;
};

BOOL EXPORT CheckNameLookup(TEST_INFO * lpInfo);
BOOL EXPORT CheckPing(TEST_INFO * lpInfo);
BOOL EXPORT CheckServerPort(TEST_INFO * lpInfo);
void InitOLE();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\wmi\dgnet\gotnet.cpp ===
/******************************************************************
   Copyright (c) 1999 Microsoft Corporation

   GotNet.CPP -- WMI provider class implementation

   Generated by Microsoft WMI Code Generation Engine
  
   TO DO: - See individual function headers
          - When linking, make sure you link to framedyd.lib & 
            msvcrtd.lib (debug) or framedyn.lib & msvcrt.lib (retail).

   Description: 
   
  
  
******************************************************************/

#include "stdpch.h"
#pragma hdrstop
#include "GotNet.h"

#include "host.h"   // CHost
#include "output.h" // COutput
#include "diag.h"

#include "oe.h"
#include "proxy.h"
#include "connect.h"    // ConnectToPort

// TO DO: Replace "NameSpace" with the appropriate namespace for your
//        provider instance.  For instance:  "root\\default or "root\\cimv2".
//===================================================================
//CGotNet MyGotNetSet (PROVIDER_NAME_GOTNET, L"root\\default") ;

// Property names
//===============

const static WCHAR* pid           = L"id" ;
const static WCHAR* pbIEProxy     = L"bIEProxy" ;
const static WCHAR* pIEProxy      = L"IEProxy" ;
const static WCHAR* pIEProxyPort  = L"IEProxyPort" ;

// Counts the number of times the com object is referenced
//
long g_nModuleRef = 0;

void 
AddRefModule() 
/*++

Routine Description
    This routine is counts the number of time the dll/COM is being refernce.
    Increments the ref count

Arguments
    none 

Return Value
    none

--*/
{
    InterlockedIncrement(&g_nModuleRef);
}

void 
ReleaseModule()
/*++

Routine Description
    This routine is decrements the ref count.

Arguments
    none 

Return Value
    none

--*/
{
    InterlockedDecrement(&g_nModuleRef);
}

/*****************************************************************************
 *
 *  FUNCTION    :   CGotNet::CGotNet
 *
 *  DESCRIPTION :   Constructor
 *
 *  INPUTS      :   none
 *
 *  RETURNS     :   nothing
 *
 *  COMMENTS    :   Calls the Provider constructor.
 *
 *****************************************************************************/
CGotNet::CGotNet ()
{
    AddRefModule();
}

/*****************************************************************************
 *
 *  FUNCTION    :   CGotNet::~CGotNet
 *
 *  DESCRIPTION :   Destructor
 *
 *  INPUTS      :   none
 *
 *  RETURNS     :   nothing
 *
 *  COMMENTS    : 
 *
 *****************************************************************************/
CGotNet::~CGotNet ()
{
    ReleaseModule();
}
//***************************************************************************
//
// CGotNet::QueryInterface
// CGotNet::AddRef
// CGotNet::Release
//
// Purpose: IUnknown members for CInstPro object.
//***************************************************************************


STDMETHODIMP CGotNet::QueryInterface(REFIID riid, LPVOID* ppv)
{
    *ppv=NULL;

    // Since we have dual inheritance, it is necessary to cast the return type

    if(riid== IID_IWbemServices)
       *ppv=(IWbemServices*)this;

    if(IID_IUnknown==riid || riid== IID_IWbemProviderInit)
       *ppv=(IWbemProviderInit*)this;
    

    if (NULL!=*ppv) {
        AddRef();
        return NOERROR;
        }
    else
        return E_NOINTERFACE;
  
}


STDMETHODIMP_(ULONG) CGotNet::AddRef(void)
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CGotNet::Release(void)
{
    ULONG nNewCount = InterlockedDecrement((long *)&m_cRef);
    if (0L == nNewCount)
        delete this;
    
    return nNewCount;
}

/***********************************************************************
*                                                                      *
*   CInstPro::Initialize                                                *
*                                                                      *
*   Purpose: This is the implementation of IWbemProviderInit. The method  *
*   is need to initialize with CIMOM.                                    *
*                                                                      *
***********************************************************************/

STDMETHODIMP CGotNet::Initialize(LPWSTR pszUser, LONG lFlags,
                                    LPWSTR pszNamespace, LPWSTR pszLocale,
                                    IWbemServices *pNamespace, 
                                    IWbemContext *pCtx,
                                    IWbemProviderInitSink *pInitSink)
{
    if(pNamespace)
        pNamespace->AddRef();

    m_pNamespace = pNamespace;

    //Let CIMOM know you are initialized
    //==================================
    
    pInitSink->SetStatus(WBEM_S_INITIALIZED,0);
    return WBEM_S_NO_ERROR;
}

//***************************************************************************
//
// CInstPro::CreateInstanceEnumAsync
//
// Purpose: Asynchronously enumerates the instances.  
//
//***************************************************************************

SCODE CGotNet::CreateInstanceEnumAsync( const BSTR RefStr, long lFlags, IWbemContext *pCtx,
       IWbemObjectSink FAR* pHandler)
{
    SCODE sc;
    int iCnt;
    IWbemClassObject FAR* pNewInst;
    HRESULT hr;

    // Do a check of arguments and make sure we have pointer to Namespace
    if(pHandler == NULL || m_pNamespace == NULL)
        return WBEM_E_INVALID_PARAMETER;

    hr = CoImpersonateClient();
    if( hr != S_OK )
    {
        return hr;
    }

    for(iCnt=0; iCnt < 1; iCnt++)
    {
        sc = CreateInst(
                m_pNamespace,
                &pNewInst,
                RefStr,
                pCtx);

        
        if(sc != S_OK)
            break;

        sc = AddProps(pNewInst);

        if(sc != S_OK)
            break;

        // Send the object to the caller

        pHandler->Indicate(1,&pNewInst);
        pNewInst->Release();
    }

    // Set status

    pHandler->SetStatus(0,sc,NULL, NULL);

    CoRevertToSelf();
    return sc;
}


//***************************************************************************
//
// CGotNet::GetObjectByPath
// CGetNet::GetObjectByPathAsync
//
// Purpose: Creates an instance given a particular path value.
//
//***************************************************************************
SCODE CGotNet::GetObjectAsync(const BSTR ObjectPath, long lFlags,IWbemContext  *pCtx,
                    IWbemObjectSink FAR* pHandler)
{

    SCODE sc;
    IWbemClassObject FAR* pObj;
    BOOL bOK = FALSE;

    // Do a check of arguments and make sure we have pointer to Namespace

    if(ObjectPath == NULL || pHandler == NULL || m_pNamespace == NULL)
        return WBEM_E_INVALID_PARAMETER;

    // do the get, pass the object on to the notify
    
    sc = GetByPath(ObjectPath,&pObj, pCtx);
    if(sc == S_OK) 
    {
        pHandler->Indicate(1,&pObj);
        pObj->Release();
        bOK = TRUE;
    }

    sc = (bOK) ? S_OK : WBEM_E_NOT_FOUND;

    // Set Status

    pHandler->SetStatus(0,sc, NULL, NULL);

    return sc;
}
 
//***************************************************************************
//
// CGotNet::GetByPath
//
// Purpose: Creates an instance given a particular Path value.
//
//***************************************************************************

SCODE
CGotNet::GetByPath(
    BSTR ObjectPath, 
    IWbemClassObject FAR* FAR* ppObj,
    IWbemContext  *pCtx)
{
    SCODE sc = S_OK;
    
    if(!_wcsicmp(L"NetDiagnostics=@", ObjectPath))
    {
        sc = CreateInst(
                m_pNamespace,
                ppObj, 
                L"NetDiagnostics", 
                pCtx);

        return sc;
    }

    return WBEM_E_NOT_FOUND;
}
 
HRESULT STDMETHODCALLTYPE
CGotNet::ExecMethodAsync(
    const BSTR ObjectPath, 
    const BSTR MethodName, 
    long lFlags, 
    IWbemContext* pCtx, 
    IWbemClassObject* pInParams, 
    IWbemObjectSink* pResultSink)
{
    if(0 == _wcsicmp(MethodName, L"Ping"))
    {
        return WMIPing(lFlags, pCtx, pInParams, pResultSink);
    }
    else if (0 == _wcsicmp(MethodName, L"ConnectToPort"))
    {
        return WMIConnectToPort(lFlags, pCtx, pInParams, pResultSink);
    }
    else
    {
        return WBEM_E_INVALID_PARAMETER;
    }
}

HRESULT CGotNet::WMIPing(
        long lFlags, 
        IWbemContext* pCtx, 
        IWbemClassObject* pInParams, 
        IWbemObjectSink* pResultSink)
{
    HRESULT hr;    
    IWbemClassObject * pClass = NULL;
    IWbemClassObject * pOutClass = NULL;    
    IWbemClassObject* pOutParams = NULL;
    TEST_INFO ping;
    CHost host;
    char buffer[100];
    WSADATA wsa;

    WSAStartup(MAKEWORD(2,1), &wsa);


    hr = CoImpersonateClient();
    if( hr != S_OK )
    {
        WSACleanup();	
        return hr;
    }


    // Allocate some BSTRs
    
    BSTR ClassName = SysAllocString(L"NetDiagnostics");    
    BSTR InputArgName = SysAllocString(L"sInAddr");
    BSTR OutputArgName = SysAllocString(L"sOutArg");
    BSTR retValName = SysAllocString(L"ReturnValue");

    // Get the class object, this is hard coded and matches the class
    // in the MOF.  A more sophisticated example would parse the 
    // ObjectPath to determine the class and possibly the instance.

    hr = m_pNamespace->GetObject(ClassName, 0, pCtx, &pClass, NULL);
	if(hr != S_OK)
	{
		pResultSink->SetStatus(0,hr, NULL, NULL);
        WSACleanup();	
        CoRevertToSelf();	  
        return WBEM_S_NO_ERROR;
	}
 

    // This method returns values, and so create an instance of the
    // output argument class.

    hr = pClass->GetMethod(L"Ping", 0, NULL, &pOutClass);
    pOutClass->SpawnInstance(0, &pOutParams);

    // Copy the input argument into the output object    
    
    auto_var var;

    // Get the input argument
    pInParams->Get(InputArgName, 0, &var, NULL, NULL);   

    wcstombs(buffer, var.bstrVal, 100);
    ping.host.SetHost(buffer);
    CheckPing(&ping);
    WaitForSingleObject(ping.hEvent, INFINITE);

    
    // put it into the output object
    _variant_t v ((bool)(ping.dwErr == S_OK));

    pOutParams->Put(retValName , 0, &v, 0);      

    v = ping.output.Status();
    pOutParams->Put(OutputArgName , 0, &v, 0); 

    // Send the output object back to the client via the sink. Then 
    // release the pointers and free the strings.

    hr = pResultSink->Indicate(1, &pOutParams);    
    pOutParams->Release();
    pOutClass->Release();    
    pClass->Release();    
    SysFreeString(ClassName);
    SysFreeString(InputArgName);    
    SysFreeString(OutputArgName);
    SysFreeString(retValName);     
    
    // all done now, set the status
    hr = pResultSink->SetStatus(0,WBEM_S_NO_ERROR,NULL,NULL);
    CoRevertToSelf();

    WSACleanup();
    return WBEM_S_NO_ERROR;

}

HRESULT CGotNet::WMIConnectToPort(
    long lFlags, 
    IWbemContext* pCtx, 
    IWbemClassObject* pInParams, 
    IWbemObjectSink* pResultSink)
{
    HRESULT hr;    
    IWbemClassObject * pClass = NULL;
    IWbemClassObject * pOutClass = NULL;    
    IWbemClassObject* pOutParams = NULL;
    TEST_INFO ping;
    CHost host;
    char buffer[100];
    bool bConnect = false;

    hr = CoImpersonateClient();
    if( hr != S_OK )
    {
        return hr;
    }

    // Allocate some BSTRs
    
    BSTR ClassName = SysAllocString(L"NetDiagnostics");    
    BSTR AddrArgName = SysAllocString(L"sInAddr");
    BSTR PortArgName = SysAllocString(L"port");
    BSTR OutputArgName = SysAllocString(L"sOutArg");
    BSTR retValName = SysAllocString(L"ReturnValue");

    // Get the class object, this is hard coded and matches the class
    // in the MOF.  A more sophisticated example would parse the 
    // ObjectPath to determine the class and possibly the instance.

    hr = m_pNamespace->GetObject(ClassName, 0, pCtx, &pClass, NULL);
	if(hr != S_OK)
	{
		pResultSink->SetStatus(0,hr, NULL, NULL);
        CoRevertToSelf();
		
        return WBEM_S_NO_ERROR;
	}
 

    // This method returns values, and so create an instance of the
    // output argument class.

    hr = pClass->GetMethod(L"ConnectToPort", 0, NULL, &pOutClass);
    pOutClass->SpawnInstance(0, &pOutParams);

    // Copy the input argument into the output object    
    
    auto_var addr;
    auto_var port;
    
    // Get the input argument
    pInParams->Get(AddrArgName, 0, &addr, NULL, NULL);   
    pInParams->Get(PortArgName, 0, &port, NULL, NULL);   

    wcstombs(buffer, addr.bstrVal, 100);

    host.SetHost(buffer);

    Connect(host, port.lVal, bConnect);
    
    // put it into the output object
    _variant_t v (bConnect);

    pOutParams->Put(retValName , 0, &v, 0);      

    v = ping.output.Status();
    pOutParams->Put(OutputArgName , 0, &v, 0); 

    // Send the output object back to the client via the sink. Then 
    // release the pointers and free the strings.

    hr = pResultSink->Indicate(1, &pOutParams);    
    pOutParams->Release();
    pOutClass->Release();    
    pClass->Release();    
    SysFreeString(ClassName);
    SysFreeString(AddrArgName);    
    SysFreeString(PortArgName);    
    SysFreeString(OutputArgName);
    SysFreeString(retValName);     
    
    // all done now, set the status
    hr = pResultSink->SetStatus(0,WBEM_S_NO_ERROR,NULL,NULL);
    CoRevertToSelf();

    return WBEM_S_NO_ERROR;
}


HRESULT CGotNet::AddProps(IWbemClassObject* pInstance)
{
    HRESULT hRes = WBEM_S_NO_ERROR;
    CHost host;
    DWORD dwPort = 0;
    DWORD dwProxyPort = 0;
    DWORD dwProxyEnabled = 0;
    _variant_t v;

    v.Clear();
/*
    //
    // Grab all the mail server information
    ///////////////////////////////////////

    CHost InBoundMailHost, OutBoundMailHost;
    DWORD dwInBoundPort, dwOutBoundPort;
    WCHAR wszInBoundMailType, wszOutBoundMailType;

    hRes = GetOEDefaultMailServer(InBoundMailHost,  
                                  dwInBoundPort, 
                                  wszInBoundMailType,
                                  OutBoundMailHost, 
                                  dwOutBoundPort,
                                  wszOutBoundMailType);
    if( SUCCEEDED(hRes) )
    {
        v = InBoundMailHost.GetHost();
        pInstance->Put(pInBoundMailServer, 0, &v, 0);      

        v = (long)dwInBoundPort;
        pInstance->Put(pInBoundMailPort, 0, &v, 0);

        v = wszInBoundMailType
        pInstance->Put(pInBoundMailType, 0, &v, 0);      


        v = OutBoundMailHost.GetHost();
        pInstance->Put(pOutBoundMailServer, 0, &v, 0);      

        v = (long)dwOutBoundPort;
        pInstance->Put(pOutBoundMailPort, 0, &v, 0);

        v = wszOutBoundMailType
        pInstance->Put(pOutBoundMailType, 0, &v, 0);      

    }
*/
    //
    // Grab all the news server information
    ///////////////////////////////////////
    v.Clear();
    hRes = GetOEDefaultNewsServer(host, dwPort);
    v = host.GetHost();
    pInstance->Put(pNewsServer,  0, &v, 0);
    
    v = (long)dwPort;
    pInstance->Put(pNewsNNTPPort, 0, &v, 0);
    

    v.Clear();
    if (FindProxy(&host, &dwProxyPort, &dwProxyEnabled))
    {
        v = (bool)(dwProxyEnabled == TRUE);
        pInstance->Put(pbIEProxy, 0, &v, 0);

        v.Clear();
        v = host.GetHost();
        pInstance->Put(pIEProxy, 0, &v, 0);

        v.Clear();
        v = (long)dwProxyPort;
        pInstance->Put(pIEProxyPort, 0, &v, 0);
    }
    else
    {
        v = (bool)FALSE;
        pInstance->Put(pbIEProxy, 0, &v, 0);
        pInstance->Put(pIEProxy, 0, NULL, 0);
        pInstance->Put(pIEProxyPort, 0, NULL, 0);
    }
    
    return hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\wmi\dgnet\host.h ===
// host.h
//

#include "stdpch.h"
#pragma once

class CHost
{
public:
    CHost() : m_ulAddr(INADDR_NONE) {};
    CHost(LPCTSTR szHost) : m_szHost(szHost), m_ulAddr(INADDR_NONE) {};

    operator unsigned long () 
    {
        if (m_ulAddr == INADDR_NONE)
        {
            char szHost[128]; 
            hostent * hp;
            unsigned long ulAddr;

            if (!m_szHost || !*m_szHost)
                return INADDR_NONE;

#ifdef UNICODE
            wcstombs(szHost, m_szHost, 128);
#else
			strcpy(szHost, m_szHost);
#endif
            if ((ulAddr = inet_addr(szHost)) == INADDR_NONE)
            {            
                if ((hp = gethostbyname(szHost)) != NULL)
                {
        	        memcpy(&(m_ulAddr),hp->h_addr,hp->h_length);

                    return m_ulAddr;
                }                 
                return INADDR_NONE;
            }
            else
            {
                m_ulAddr = ulAddr;
                return m_ulAddr;
            }
        }
        else
            return m_ulAddr;
    }
    LPCTSTR GetHost() { return m_szHost; }

    void SetHost(LPCTSTR szHost)
    { 
        m_szHost = szHost;
        m_ulAddr = INADDR_NONE; 
    }

    tstring m_strDescription;
protected:
    tstring m_szHost;
    ULONG m_ulAddr;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\wmi\dgnet\gotnet.h ===
/******************************************************************
   Copyright (c) 1999 Microsoft Corporation

   GotNet.H -- WMI provider class definition

   Generated by Microsoft WBEM Code Generation Engine
 
   Description: 
   

*******************************************************************/

// Property set identification
//============================

#ifndef _GotNet_H_
#define _GotNet_H_

#define PROVIDER_NAME_GOTNET L"NetDiagnostics"

// Property name externs -- defined in GotNet.cpp
//=================================================

extern const WCHAR* pbIEProxy ;
extern const WCHAR* pbMailPop3Port ;
extern const WCHAR* pbMailSMTPPort ;
extern const WCHAR* pbNewsNNTPPort ;
extern const WCHAR* pbPingGateway ;
extern const WCHAR* pbPingIP ;
extern const WCHAR* pbPingLoopback ;
extern const WCHAR* pbPingMailServer ;
extern const WCHAR* pbPingNewsServer ;
extern const WCHAR* pid ;
extern const WCHAR* pIEProxy ;
extern const WCHAR* pMailServer ;
extern const WCHAR* pNewsServer ;
extern const WCHAR* pPingGateway ;
extern const WCHAR* pPingIP ;
extern const WCHAR* pPingLoopback ;
extern const WCHAR* pPingMailServer ;
extern const WCHAR* pPingNewsServer ;

class CGotNet : public IWbemServices, public IWbemProviderInit
{
public:
    CGotNet();
    virtual ~CGotNet();

protected:
    ULONG              m_cRef;         // Object reference count
    IWbemServices *    m_pNamespace;
public:
    //Non-delegating object IUnknown

    STDMETHODIMP         QueryInterface(REFIID, LPVOID*);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    //IWbemProviderInit

    // -------------IMPLEMENT-------------------------------------------------
    HRESULT STDMETHODCALLTYPE Initialize(
         /* [in] */ LPWSTR pszUser,
         /* [in] */ LONG lFlags,
         /* [in] */ LPWSTR pszNamespace,
         /* [in] */ LPWSTR pszLocale,
         /* [in] */ IWbemServices *pNamespace,
         /* [in] */ IWbemContext *pCtx,
         /* [in] */ IWbemProviderInitSink *pInitSink);

    // -------------IMPLEMENT-------------------------------------------------
    SCODE GetByPath( BSTR Path, IWbemClassObject FAR* FAR* pObj, IWbemContext  *pCtx);

    //IWbemServices  

    // -------------IMPLEMENT-------------------------------------------------
    HRESULT STDMETHODCALLTYPE GetObjectAsync( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

    // -------------IMPLEMENT-------------------------------------------------
    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

    HRESULT STDMETHODCALLTYPE OpenNamespace( 
        /* [in] */ const BSTR Namespace,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
        /* [in] */ IWbemObjectSink __RPC_FAR *pSink) {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE QueryObjectSink( 
        /* [in] */ long lFlags,
        /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE GetObject( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE PutClass( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE PutClassAsync( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE DeleteClass( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE CreateClassEnum( 
        /* [in] */ const BSTR Superclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
        /* [in] */ const BSTR Superclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE PutInstance( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE DeleteInstance( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE ExecQuery( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE ExecMethod( const BSTR, const BSTR, long, IWbemContext*,
        IWbemClassObject*, IWbemClassObject**, IWbemCallResult**) {return WBEM_E_NOT_SUPPORTED;}

    HRESULT STDMETHODCALLTYPE ExecMethodAsync( const BSTR, const BSTR, long, 
        IWbemContext*, IWbemClassObject*, IWbemObjectSink*);


protected:
    HRESULT AddProps(IWbemClassObject*);
    HRESULT WMIPing(
        long lFlags, 
        IWbemContext* pCtx, 
        IWbemClassObject* pInParams, 
        IWbemObjectSink* pResultSink);

    HRESULT WMIConnectToPort(
        long lFlags, 
        IWbemContext* pCtx, 
        IWbemClassObject* pInParams, 
        IWbemObjectSink* pResultSink);

protected:
    // All data members for CGotNet should be included here.   

} ;

SCODE
CreateInst(
    IWbemServices * pNamespace,
    IWbemClassObject ** pNewInst,
    WCHAR * pwcClassName,
	IWbemContext  *pCtx);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\wmi\dgnet\dgnet.h ===
/******************************************************************
   Copyright (c) 1999 Microsoft Corporation

   GotNet.H -- WMI provider class definition

   Generated by Microsoft WBEM Code Generation Engine
 
   Description: 
   

*******************************************************************/

// Property set identification
//============================

#ifndef _GotNet_H_
#define _GotNet_H_
#include "stdpch.h"
#include "dgnetres.h"
#define PROVIDER_NAME_GOTNET L"NetDiagnostics"

// Property name externs -- defined in GotNet.cpp
//=================================================

extern const WCHAR* pbIEProxy ;
extern const WCHAR* pid ;
extern const WCHAR* pIEProxy ;

//GUID CLSID_Dgnet;
//8dabe793-23d9-45df-a3db-f442883bb479
//MIDL_DEFINE_GUID(CLSID, CLSID_Dgnet,0x8dabe793,0x23d9,0x45df,0xa3,0xdb,0xf4,0x42,0x88,0x3b,0xb4,0x79);
//GUID CLSID_Dgnet = { 0x8dabe793,0x23d9,0x45df, {0xa3,0xdb,0xf4,0x42,0x88,0x3b,0xb4,0x79} };

extern GUID CLSID_Dgnet;
/////////////////////////////////////////////////////////////////////////////
// CDglogsCom
class ATL_NO_VTABLE CGotNet : 
    public CComObjectRootEx<CComMultiThreadModelNoCS>,
	public CComCoClass<CGotNet, &CLSID_Dgnet>,
    public IWbemServices, 
    public IWbemProviderInit
{
public:

DECLARE_REGISTRY_RESOURCEID(IDR_DGNET)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CGotNet)
    COM_INTERFACE_ENTRY(IWbemServices)
    COM_INTERFACE_ENTRY(IWbemProviderInit)
END_COM_MAP()

protected:
    ULONG              m_cRef;         // Object reference count
    IWbemServices *    m_pNamespace;
public:
	CGotNet();
    virtual ~CGotNet();

    //IWbemProviderInit

    // -------------IMPLEMENT-------------------------------------------------
    HRESULT STDMETHODCALLTYPE Initialize(
         /* [in] */ LPWSTR pszUser,
         /* [in] */ LONG lFlags,
         /* [in] */ LPWSTR pszNamespace,
         /* [in] */ LPWSTR pszLocale,
         /* [in] */ IWbemServices *pNamespace,
         /* [in] */ IWbemContext *pCtx,
         /* [in] */ IWbemProviderInitSink *pInitSink);

    // -------------IMPLEMENT-------------------------------------------------
    SCODE GetByPath( BSTR Path, IWbemClassObject FAR* FAR* pObj, IWbemContext  *pCtx);

    //IWbemServices  

    // -------------IMPLEMENT-------------------------------------------------
    HRESULT STDMETHODCALLTYPE GetObjectAsync( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

    // -------------IMPLEMENT-------------------------------------------------
    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

    HRESULT STDMETHODCALLTYPE OpenNamespace( 
        /* [in] */ const BSTR Namespace,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
        /* [in] */ IWbemObjectSink __RPC_FAR *pSink) {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE QueryObjectSink( 
        /* [in] */ long lFlags,
        /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE GetObject( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE PutClass( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE PutClassAsync( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE DeleteClass( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE CreateClassEnum( 
        /* [in] */ const BSTR Superclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
        /* [in] */ const BSTR Superclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE PutInstance( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE DeleteInstance( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE ExecQuery( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE ExecMethod( const BSTR, const BSTR, long, IWbemContext*,
        IWbemClassObject*, IWbemClassObject**, IWbemCallResult**) {return WBEM_E_NOT_SUPPORTED;}

    HRESULT STDMETHODCALLTYPE ExecMethodAsync( const BSTR, const BSTR, long, 
        IWbemContext*, IWbemClassObject*, IWbemObjectSink*);


protected:
    HRESULT AddProps(IWbemClassObject*);
    HRESULT WMIPing(
        long lFlags, 
        IWbemContext* pCtx, 
        IWbemClassObject* pInParams, 
        IWbemObjectSink* pResultSink);

    HRESULT WMIConnectToPort(
        long lFlags, 
        IWbemContext* pCtx, 
        IWbemClassObject* pInParams, 
        IWbemObjectSink* pResultSink);

protected:
    // All data members for CGotNet should be included here.   

} ;

SCODE
CreateInst(
    IWbemServices * pNamespace,
    IWbemClassObject ** pNewInst,
    WCHAR * pwcClassName,
	IWbemContext  *pCtx);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\wmi\dgnet\oe.h ===
// oe.h
//

HRESULT EXPORT GetOEDefaultMailServer(CHost& host, DWORD& dwPort);
HRESULT GetOEDefaultMailServer(OUT CHost & InBoundMailHost,  OUT DWORD & dwInBoundMailPort, OUT TCHAR * pszInBoundMailType, 
                               OUT CHost & OutBoundMailHost, OUT DWORD & dwOutBoundMailPort, OUT TCHAR * pszOutBoundMailType);

HRESULT EXPORT GetOEDefaultNewsServer(CHost& host, DWORD& dwPort);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\wmi\dgnet\oe.cpp ===
// oe.cpp
//

#include "stdpch.h"
#pragma hdrstop

#include "host.h"
#include "oe.h"
#include <initguid.h>
#include <oaidl.h>
#include <imnact.h>     // account manager stuff
#include <imnxport.h>
#include <msident.h>

enum MAIL_TYPE
{
    SMTP,
    SMTP2,
    IMAP,
    POP3,
    HTTP,
};

HRESULT GetServerAndPort(IN INETSERVER & rServer, OUT CHost & host, OUT DWORD & dwPort)
{
#ifdef UNICODE
    TCHAR wcsServer[128];

    mbstowcs(wcsServer, rServer.szServerName, 128);
	host.SetHost(wcsServer);
#else
	host.SetHost(rServer.szServerName);
#endif
	dwPort = (long)rServer.dwPort;   
    
    return S_OK;
}


HRESULT GetDefaultOutBoundMailServer(IN  IImnAccount *pIImnAccount,
                                     OUT INETSERVER  & rServer,
                                     OUT WCHAR       *pszMailType)
{    
    ISMTPTransport     *pSMTPTransport;
    ISMTPTransport2    *pSMTPTransport2;
    HRESULT hr;
    WCHAR wsz[1000];

    // Create the SMTP transport object
    //
    hr = CoCreateInstance(CLSID_ISMTPTransport, NULL, CLSCTX_INPROC_SERVER, IID_ISMTPTransport, (LPVOID *)&pSMTPTransport);
    if( SUCCEEDED(hr) )
    {
        // Get the SMTP server information
        //
		hr = pSMTPTransport->InetServerFromAccount(pIImnAccount, &rServer);
        lstrcpy(pszMailType,L"SMTP");
        pSMTPTransport->Release();
    }

    if( FAILED(hr) )
    {
        // Unable to get SMTP server info, lets try and get SMTP transport 2 server information
        // 
        hr = CoCreateInstance(CLSID_ISMTPTransport, NULL, CLSCTX_INPROC_SERVER, IID_ISMTPTransport2, (LPVOID *)&pSMTPTransport2);
        if( SUCCEEDED(hr) )
        {
            // Get SMTP2 server info
            //
            hr = pSMTPTransport2->InetServerFromAccount(pIImnAccount, &rServer);
            lstrcpy(pszMailType,L"SMTP2");
            pSMTPTransport->Release();
        }
    }

    if( FAILED(hr) )
    {
        wsprintf(wsz,L"Unable to get Outbound Mail server %X\n",hr);
        OutputDebugString(wsz);
    }

    if( FAILED(hr) )
    {
        // Make sure to clear the struct
        //
        memset(&rServer,0,sizeof(rServer));
        lstrcpy(pszMailType,L"");
    }
    
    return hr;
}


HRESULT GetDefaultInBoundMailServer(IN  IImnAccount *pIImnAccount,
                                    OUT INETSERVER  & rServer,
                                    OUT WCHAR       *pszMailType)
{    
    IPOP3Transport *pPOP3Transport;
    IIMAPTransport *pIMAPTransport;
    IHTTPMailTransport *pHTTPTransport;
    HRESULT hr;
    WCHAR wsz[1000];


    // Create the HTTP transport object
    //
    hr = CoCreateInstance(CLSID_IHTTPMailTransport, NULL, CLSCTX_INPROC_SERVER, IID_IHTTPMailTransport, (LPVOID *)&pHTTPTransport);
    if( SUCCEEDED(hr) )
    {
        // Get the HTTP server information
        //
		hr = pHTTPTransport->InetServerFromAccount(pIImnAccount, &rServer);
        lstrcpy(pszMailType,L"HTTP");
        pHTTPTransport->Release();
    }

    if( FAILED(hr) )
    {
        // Create the POP3 transport object
        //
        hr = CoCreateInstance(CLSID_IPOP3Transport, NULL, CLSCTX_INPROC_SERVER, IID_IPOP3Transport, (LPVOID *)&pPOP3Transport);
        if( SUCCEEDED(hr) )
        {
            // Get the POP3 server information
            //
		    hr = pPOP3Transport->InetServerFromAccount(pIImnAccount, &rServer);
            lstrcpy(pszMailType,L"POP3");
            pPOP3Transport->Release();
        }
    }

    if( FAILED(hr) )
    {
        // Create the SMTP transport object
        //
        hr = CoCreateInstance(CLSID_IIMAPTransport, NULL, CLSCTX_INPROC_SERVER, IID_IIMAPTransport, (LPVOID *)&pIMAPTransport);
        if( SUCCEEDED(hr) )
        {
            // Get the SMTP server information
            //
			hr = pIMAPTransport->InetServerFromAccount(pIImnAccount, &rServer);
            lstrcpy(pszMailType,L"IMAP");
            pIMAPTransport->Release();
        }
    }

    if( FAILED(hr) )
    {
        wsprintf(wsz,L"Unable to get Inbound Mail server %X\n",hr);
        OutputDebugString(wsz);
    }



    if( FAILED(hr) )
    {
        memset(&rServer,0,sizeof(rServer));    
        lstrcpy(pszMailType,L"");
    }
    
    return hr;
}


HRESULT GetOEDefaultMailServer(OUT CHost & InBoundMailHost,  
                               OUT DWORD & dwInBoundMailPort, 
                               OUT TCHAR * pszInBoundMailType, 
                               OUT CHost & OutBoundMailHost, 
                               OUT DWORD & dwOutBoundMailPort, 
                               OUT TCHAR * pszOutBoundMailType)
{   
    IImnAccountManager2 *pIImnAccountManager2 = NULL;
    IImnAccountManager  *pIImnAccountManager = NULL;
    IImnAccount         *pIImnAccount = NULL;
    HRESULT hr;
    WCHAR wsz[1000];


    hr = CoCreateInstance(CLSID_ImnAccountManager, NULL, CLSCTX_INPROC_SERVER, IID_IImnAccountManager, (void**)&pIImnAccountManager);	
    if( SUCCEEDED(hr) )
    {
	    hr = pIImnAccountManager->QueryInterface(__uuidof(IImnAccountManager2), (void**)&pIImnAccountManager2);
	    if(SUCCEEDED(hr))
	    {
		    hr = pIImnAccountManager2->InitUser(NULL, (GUID)UID_GIBC_DEFAULT_USER, 0);

	    }   
	
	    //if(FAILED(hr))
        if(SUCCEEDED(hr))
	    {        
		    hr = pIImnAccountManager->Init(NULL);
	    }

        if( SUCCEEDED(hr) )
        {
	        hr = pIImnAccountManager->GetDefaultAccount(ACCT_MAIL, &pIImnAccount);
	        if( SUCCEEDED(hr) )
            {
                INETSERVER rServer={0};                
                HRESULT hr2, hr3;

                hr2 = GetDefaultInBoundMailServer(pIImnAccount,rServer,pszInBoundMailType);
                GetServerAndPort(rServer,InBoundMailHost,dwInBoundMailPort);
                hr3 = GetDefaultOutBoundMailServer(pIImnAccount,rServer,pszOutBoundMailType);
                GetServerAndPort(rServer,OutBoundMailHost,dwOutBoundMailPort);

                if( SUCCEEDED(hr2) || SUCCEEDED(hr3) )
                {
                    hr = S_OK;
                }                
                else
                {
                    hr = E_FAIL;
                }
                pIImnAccount->Release();
            }
        }
        else
        {
            wsprintf(wsz,L"Unable to get IImnAccountManager2 %X\n",hr);
            OutputDebugString(wsz);
        }

        pIImnAccountManager->Release();
        if( pIImnAccountManager2 )
        {
            pIImnAccountManager2->Release();
        }
    }

    return hr;
}


HRESULT GetOEDefaultMailServer(CHost& host, DWORD& dwPort)
{
    HRESULT hr;
    WCHAR wsz[700];

	auto_rel<IImnAccountManager> 	pIImnAccountManager;
	auto_rel<IImnAccountManager2> 	pIImnAccountManager2;
	auto_rel<IImnAccount>			pIImnAccount;
	auto_rel<ISMTPTransport>    	pSMTPTransport;
	auto_rel<INNTPTransport>    	pNNTPTransport;	
	INETSERVER  					rServer={0};

    hr = CoCreateInstance(CLSID_ImnAccountManager, NULL, CLSCTX_INPROC_SERVER, IID_IImnAccountManager, (void**)&pIImnAccountManager);
	
    if(FAILED(hr))
    {
        swprintf(wsz,L"Unable to CoCreateInstance %X",hr);
        OutputDebugString(wsz);
		return hr;
    }

	hr = pIImnAccountManager->QueryInterface(__uuidof(IImnAccountManager2), (void**)&pIImnAccountManager2);
	if(SUCCEEDED(hr))
	{
		hr = pIImnAccountManager2->InitUser(NULL, (GUID)UID_GIBC_DEFAULT_USER, 0);
	}
	
	if(FAILED(hr))
	{        
		hr = pIImnAccountManager->Init(NULL);
		if(FAILED(hr))
        {
            swprintf(wsz,L"Unable to pIImnAccountManager->Init %X",hr);
            OutputDebugString(wsz);
			return hr;
        }
	}

	hr = pIImnAccountManager->GetDefaultAccount(ACCT_MAIL, &pIImnAccount);
	if(SUCCEEDED(hr))
	{
		hr = CoCreateInstance(CLSID_ISMTPTransport, NULL, CLSCTX_INPROC_SERVER, IID_ISMTPTransport, (LPVOID *)&pSMTPTransport);
		if(SUCCEEDED(hr))
		{
			hr = pSMTPTransport->InetServerFromAccount(pIImnAccount, &rServer);
			if(SUCCEEDED(hr))
			{
#ifdef UNICODE
                TCHAR wcsServer[128];

                mbstowcs(wcsServer, rServer.szServerName, 128);
				host.SetHost(wcsServer);
#else
				host.SetHost(rServer.szServerName);
#endif
				dwPort = (long)rServer.dwPort;
			}
            else
            {
                swprintf(wsz,L"Unable to pSMTPTransport->InetServerFromAccount %X",hr);
                OutputDebugString(wsz);
            }
		}
        else
        {
            swprintf(wsz,L"Unable to oCreateInstance(CLSID_ISMTPTransport %X",hr);
            OutputDebugString(wsz);
        }
    }
    else
    {
        swprintf(wsz,L"Unable to pIImnAccountManager->GetDefaultAccount %X",hr);
        OutputDebugString(wsz);
    }

    swprintf(wsz,L"HR Value %X",hr);
    OutputDebugString(wsz);

    return hr;
}

HRESULT GetOEDefaultNewsServer(CHost& host, DWORD& dwPort)
{
    HRESULT hr;

	auto_rel<IImnAccountManager> 	pIImnAccountManager;
	auto_rel<IImnAccountManager2> 	pIImnAccountManager2;
	auto_rel<IImnAccount>			pIImnAccount;
	auto_rel<ISMTPTransport>    	pSMTPTransport;
	auto_rel<INNTPTransport>    	pNNTPTransport;	
	INETSERVER  					rServer={0};

    host.SetHost(TEXT(""));

    hr = CoCreateInstance(CLSID_ImnAccountManager, NULL, CLSCTX_INPROC_SERVER, IID_IImnAccountManager, (void**)&pIImnAccountManager);

    if(FAILED(hr))
		return hr;

	hr = pIImnAccountManager->QueryInterface(__uuidof(IImnAccountManager2), (void**)&pIImnAccountManager2);
	if(SUCCEEDED(hr))
	{
		hr = pIImnAccountManager2->InitUser(NULL, (GUID)UID_GIBC_DEFAULT_USER, 0);
	}
	
	if(FAILED(hr))
	{
		hr = pIImnAccountManager->Init(NULL);
		if(FAILED(hr))
			return hr;
	}

	hr = pIImnAccountManager->GetDefaultAccount(ACCT_NEWS, &pIImnAccount);
	if(SUCCEEDED(hr))
	{
		hr = CoCreateInstance(CLSID_INNTPTransport, NULL, CLSCTX_INPROC_SERVER, IID_INNTPTransport, (LPVOID *)&pNNTPTransport);
		if(SUCCEEDED(hr))
		{
			hr = pNNTPTransport->InetServerFromAccount(pIImnAccount, &rServer);
			if(SUCCEEDED(hr))
			{
#ifdef UNICODE
                TCHAR wcsServer[128];

                mbstowcs(wcsServer, rServer.szServerName, 128);
				host.SetHost(wcsServer);
#else
				host.SetHost(rServer.szServerName);
#endif
    			dwPort = (long)rServer.dwPort;

			}
		}
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\wmi\dgnet\output.h ===
// output.h
//

#pragma warning (disable : 4251)

class __declspec(dllexport) COutput
{
public:

    LPCTSTR Status();
    void Reset();

    void __cdecl good(LPCTSTR sz, ...);
    void __cdecl warn(LPCTSTR sz, ...);
    void __cdecl warnErr(LPCTSTR sz, ...);
    void __cdecl err(LPCTSTR sz, ...);

    COutput& operator+= (const COutput& rhs);
protected:
    tstring m_strGood;
    tstring m_strWarn;
    tstring m_strWarnErr;     // non-confirmed bustimication (eg. DNS timeout)
    tstring m_strErr;         
    auto_cs m_cs;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\wmi\dgnet\output.cpp ===
// output.cpp
//

#include "stdpch.h"
#pragma hdrstop

#include "output.h"
#include "tchar.h"

void __cdecl COutput::warnErr(LPCTSTR szFmt, ...)
{
    TCHAR szBuffer[1024];
    va_list valMarker;

    va_start(valMarker, szFmt);

    _vstprintf(szBuffer, szFmt, valMarker);

    va_end(valMarker);

    auto_leave leave(m_cs);

    leave.EnterCriticalSection();
    m_strWarnErr += szBuffer;   
    leave.LeaveCriticalSection();
}

void __cdecl COutput::good(LPCTSTR szFmt, ...)
{
    TCHAR szBuffer[1024];
    va_list valMarker;

    va_start(valMarker, szFmt);

    _vstprintf(szBuffer, szFmt, valMarker);

    va_end(valMarker);

    auto_leave leave(m_cs);

    leave.EnterCriticalSection();
    m_strGood += szBuffer;
    leave.LeaveCriticalSection();
}

void __cdecl COutput::err(LPCTSTR szFmt, ...)
{
    TCHAR szBuffer[1024];
    va_list valMarker;

    va_start(valMarker, szFmt);

    _vstprintf(szBuffer, szFmt, valMarker);

    va_end(valMarker);

    auto_leave leave(m_cs);

    leave.EnterCriticalSection();
    m_strErr += szBuffer;
    leave.LeaveCriticalSection();
}

LPCTSTR  COutput::Status()
{
    static TCHAR szOutput[4096];

    lstrcpy(szOutput, m_strGood.c_str());
    lstrcat(szOutput, m_strWarn.c_str());
    lstrcat(szOutput, m_strErr.c_str());
    lstrcat(szOutput, m_strWarnErr.c_str());

    return szOutput;
}

void COutput::Reset()
{
    m_strGood.resize(0);
    m_strWarn.resize(0);
    m_strWarnErr.resize(0);
    m_strErr.resize(0);
}

COutput& COutput::operator+= (const COutput& rhs)
{
    m_strGood += rhs.m_strGood;
    m_strWarn += rhs.m_strWarn;
    m_strWarnErr += rhs.m_strWarnErr;
    m_strErr  += rhs.m_strErr;

    return *this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\wmi\dgnet\ping.h ===
// ping.h
//

#pragma once 

class CPing : public CCommand
{
public:
    CPing(TEST_INFO* pInfo) : m_pInfo(pInfo) {}
    virtual void Go();

public:
    TEST_INFO * m_pInfo;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\wmi\dgnet\ping.cpp ===
// ping.cpp
//

#include "stdpch.h"
#pragma hdrstop

#include "host.h"
#include "output.h"     // COutput
#include "diag.h"

#include "async.hh"
#include "ping.h"

#include "svcguid.h"
#include "wire.h"       // net structs
#include <conio.h>

void    fill_icmp_data (char *, int);
USHORT  checksum (USHORT *, int);
DWORD   decode_resp (char *,int ,struct sockaddr_in *, COutput& out);


BOOL EXPORT CheckPing(TEST_INFO * lpNL)
{
    g_Q.push_front (new CPing(lpNL));

    return TRUE;
}

void CPing::Go()
{
    SOCKET sockRaw = (SOCKET)NULL;
    struct sockaddr_in dest,from;
    int bread,datasize;
    int fromlen = sizeof(from);
    int timeout;
    int nCount = 0;
    char *icmp_data;
    char *recvbuf;
    unsigned int addr=0;
    USHORT seq_no = 0;
    DWORD dw;

    m_pInfo->dTimeDelta = 0;
    m_pInfo->dwErr = 0;

    if (m_pInfo->host.m_strDescription.size() > 0)
    {
        m_pInfo->output.good(TEXT("pinging (%s) %s<br>"), 
            m_pInfo->host.m_strDescription.c_str(), 
            m_pInfo->host.GetHost());
    }
    else
    {
        m_pInfo->output.good(TEXT("pinging (%s)<br>"), m_pInfo->host.GetHost());
    }

    //
    // WSA_FLAG_OVERLAPPED flag is required for SO_RCVTIMEO, SO_SNDTIMEO
    // option. If NULL is used as last param for WSASocket, all I/O on the socket
    // is synchronous, the internal user mode wait code never gets a chance to 
    // execute, and therefore kernel-mode I/O blocks forever. A socket created 
    // via the socket API has the overlapped I/O attribute set internally. But 
    // here we need to use WSASocket to specify a RAW socket.
    //
    // If you want to use timeout with a synchronous non-overlapped socket created
    // by WSASocket with last param set to NULL, you can set the timeout using the
    // select API, or use WSAEventSelect and set the timeout in the 
    // WSAWaitForMultipleEvents API.
    //

    sockRaw = WSASocket (
                AF_INET,
	            SOCK_RAW,
				IPPROTO_ICMP,
				NULL, 
				0,
				WSA_FLAG_OVERLAPPED);

    if (sockRaw == INVALID_SOCKET)
    {
	    m_pInfo->output.err(TEXT("WSASocket() failed: %d<br>"),m_pInfo->dwErr = WSAGetLastError());
        goto Exit;
    }
    
    __try
    {
	    timeout = 1000;
        bread = setsockopt(
                    sockRaw,
                    SOL_SOCKET,
                    SO_RCVTIMEO,
                    (char*)&timeout,
  		    		sizeof(timeout));
	  
        if(bread == SOCKET_ERROR)
        {
  		    m_pInfo->output.err(TEXT("failed to set recv timeout: %d<br>"), m_pInfo->dwErr = WSAGetLastError());
		    __leave;
	    }
	    
        timeout = 1000;
	    bread = setsockopt(
                    sockRaw,
                    SOL_SOCKET,
                    SO_SNDTIMEO,
                    (char*)&timeout,
  					sizeof(timeout));
	    if(bread == SOCKET_ERROR)
        {
            m_pInfo->output.err(TEXT("failed to set send timeout: %d<br>"), m_pInfo->dwErr = WSAGetLastError());
		    __leave;
	    }
	    memset(&dest, 0, sizeof(dest));

	    dest.sin_family = AF_INET;
	    
        if ((dest.sin_addr.s_addr = m_pInfo->host) == INADDR_NONE)
	    {
		    m_pInfo->output.err(TEXT("failed to gethostbyname (%d)<br>"), m_pInfo->dwErr = WSAHOST_NOT_FOUND);

		    __leave;
	    }	

        datasize = DEF_PACKET_SIZE;
		
	    datasize += sizeof(IcmpHeader);  

	    icmp_data = (char*)xmalloc(MAX_PACKET);
	    recvbuf = (char*)xmalloc(MAX_PACKET);

	    if (!icmp_data)
        {
		    m_pInfo->output.err(TEXT("HeapAlloc failed %d<br>"),m_pInfo->dwErr = GetLastError());
		    __leave;
	    }
  
        memset(icmp_data,0,MAX_PACKET);
	    fill_icmp_data(icmp_data,datasize);

	    while(1)
        {
		    int bwrote;
		
		    if (nCount++ == 4)
                break;
		
		    ((IcmpHeader*)icmp_data)->i_cksum = 0;
		    ((IcmpHeader*)icmp_data)->timestamp = GetTickCount();

		    ((IcmpHeader*)icmp_data)->i_seq = seq_no++;
		    ((IcmpHeader*)icmp_data)->i_cksum = checksum((USHORT*)icmp_data, 
												datasize);
		    bwrote = sendto(sockRaw,icmp_data,datasize,0,(struct sockaddr*)&dest,
						sizeof(dest));

            if (bwrote == SOCKET_ERROR)
            {
		        if (WSAGetLastError() == WSAETIMEDOUT)
                {
	  		        m_pInfo->output.err(TEXT("timed out<br>"));
			        continue;
		        }
		        m_pInfo->output.err(TEXT("sendto failed: %d<br>"),m_pInfo->dwErr = WSAGetLastError());
		        __leave;
		    }
		    
            if (bwrote < datasize )
            {
		        m_pInfo->output.good(TEXT("Wrote %d bytes<br>"),bwrote);
		    }
	
		    bread = recvfrom(
                        sockRaw,
                        recvbuf,
                        MAX_PACKET,
                        0,
                        (struct sockaddr*)&from,
			        	&fromlen);
		
            if (bread == SOCKET_ERROR)
            {
			    if (WSAGetLastError() == WSAETIMEDOUT)
                {
	  		        m_pInfo->output.err(TEXT("timed out<br>"));
                    m_pInfo->dwErr = WSAETIMEDOUT;
			        continue;
			    }
			    m_pInfo->output.err(TEXT("recvfrom failed: %d<br>"),m_pInfo->dwErr = WSAGetLastError());
			    __leave;
		    }
		    if (S_OK != (dw = decode_resp(recvbuf, bread, &from, m_pInfo->output)))
            {
                m_pInfo->dwErr = dw;
                continue;
            }
	    }
    }
    __finally
    {
	    if (sockRaw != INVALID_SOCKET)
            closesocket(sockRaw);
    }

Exit:
    if (m_pInfo->hEvent)
       SetEvent(m_pInfo->hEvent);
}


/* 
	The response is an IP packet. We must decode the IP header to locate 
	the ICMP data 
*/
DWORD  decode_resp(char *buf, int bytes,struct sockaddr_in *from, COutput& out) 
{
	IpHeader *iphdr;
	IcmpHeader *icmphdr;
	unsigned short iphdrlen;

	iphdr = (IpHeader *)buf;

	iphdrlen = iphdr->h_len * 4 ; // number of 32-bit words *4 = bytes

	if (bytes  < iphdrlen + ICMP_MIN)
    {
		out.err(TEXT("Too few bytes from %s<br>"),inet_ntoa(from->sin_addr));
        return ERROR_INVALID_DATA;
	}

	icmphdr = (IcmpHeader*)(buf + iphdrlen);

	if (icmphdr->i_type != ICMP_ECHOREPLY)
    {
		out.err(TEXT("non-echo type %d recvd<br>"),icmphdr->i_type);
        return ERROR_INVALID_DATA;
	}
	
    if (icmphdr->i_id != (USHORT)GetCurrentProcessId())
    {
		out.err(TEXT("someone else's packet!<br>"));
		return ERROR_INVALID_DATA;
	}

#ifdef UNICODE
    const wchar_t * szBytes = TEXT("%d bytes from %S:");
#else
    const char * szBytes = TEXT("%d bytes from %s:");
#endif

    out.good(szBytes, bytes, inet_ntoa(from->sin_addr));
	out.good(TEXT(" icmp_seq = %d. "),icmphdr->i_seq);
	out.good(TEXT(" time: %d ms<br>"),GetTickCount()-icmphdr->timestamp);
	
    return S_OK;
}


USHORT checksum(USHORT *buffer, int size) {

  unsigned long cksum=0;

  while(size >1) {
	cksum+=*buffer++;
	size -=sizeof(USHORT);
  }
  
  if(size ) {
	cksum += *(UCHAR*)buffer;
  }

  cksum = (cksum >> 16) + (cksum & 0xffff);
  cksum += (cksum >>16);
  return (USHORT)(~cksum);
}
/* 
	Helper function to fill in various stuff in our ICMP request.
*/
void fill_icmp_data(char * icmp_data, int datasize){

  IcmpHeader *icmp_hdr;
  char *datapart;

  icmp_hdr = (IcmpHeader*)icmp_data;

  icmp_hdr->i_type = ICMP_ECHO;
  icmp_hdr->i_code = 0;
  icmp_hdr->i_id = (USHORT)GetCurrentProcessId();
  icmp_hdr->i_cksum = 0;
  icmp_hdr->i_seq = 0;
  
  datapart = icmp_data + sizeof(IcmpHeader);
  //
  // Place some junk in the buffer.
  //
  memset(datapart,'E', datasize - sizeof(IcmpHeader));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\wmi\dgnet\proxy.h ===
// proxy.h
//
// Find info about the proxy server, if any
//

class CHost;

BOOL EXPORT FindProxy(CHost* pProxy, LPDWORD pdwPort, LPDWORD pdwEnabled);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\wmi\dgnet\proxy.cpp ===
// proxy.cpp
//

#include "stdpch.h"
#pragma hdrstop

#include "host.h"       // CHost
#include "output.h"     // COutput
#define SECURITY_WIN32
#include "sspi.h"
#include "secext.h"

#include "proxy.h"
#include "tchar.h"

const TCHAR szFileVersion[]	 = TEXT("FileVersion");


BOOL GetRegEntry(HKEY    hKey, 
                 LPCWSTR lpValueName, 
                 LPBYTE  *lpData)
{
    DWORD dwSize = 256;
    DWORD dwRetVal = 0;
    DWORD dwType = 0;

    if( !lpData )
    {
        return FALSE;
    }

    do
    {
        if( *lpData == NULL )
        {
            *lpData = (LPBYTE)HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,dwSize);
            if( !lpData )
            {
                return FALSE;
            }
        }
        else
        {
            LPBYTE pTmp;
            pTmp = (LPBYTE)HeapReAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,*lpData,dwSize);
            if( pTmp )
            {
                *lpData = pTmp;
            }
            else
            {
                return FALSE;
            }
        }

        dwRetVal = RegQueryValueEx(hKey,
                                   lpValueName,
                                   NULL,   
                                   &dwType,
                                   (LPBYTE)*lpData,
                                   &dwSize);
        switch(dwRetVal)
        {
        case ERROR_SUCCESS:
            return TRUE;
        case ERROR_MORE_DATA:
            break;
        default:
            return FALSE;
        }

    }
    while(TRUE);

    return TRUE;
}

BOOL EXPORT FindProxy(CHost* pProxy, LPDWORD pdwPort, LPDWORD pdwEnabled)
{
    auto_reg regIe;
    LONG l;
    TCHAR szBuffer[256];
    DWORD dwType;
    DWORD dwEnabled;
    DWORD cbBuffer;
    UINT  cbVer;
    LPTSTR pszSearch;
    LPTSTR pszStart;
    LPVOID lpVerData;
    DWORD dwVerInfo;
    VS_FIXEDFILEINFO *lpFFI;
    HKEY hKeyRoot = NULL;
    LPTSTR pszIExplore, pszEnd;
    LPTSTR pszSubKey;
    auto_reg regApps;
    LPTSTR pszBuffer = NULL;

    // Find what version of IE we have, so we can figure out where they hide the
    // proxy info.

    // So where o where do iexplore live, eh?

    // Try in the millenium place
    l = RegOpenKeyEx(
            HKEY_CLASSES_ROOT, 
            TEXT("Applications\\iexplore.exe\\shell\\open\\command"),
            0,
            KEY_READ,
            &regApps);

    if (l == ERROR_FILE_NOT_FOUND)
    {
        l = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                TEXT("Software\\Classes\\Applications\\iexplore.exe\\shell\\open\\command"),
                0,
                KEY_READ,
                &regApps);
    }

    if (S_OK != l)
        goto Error;    

    if( !GetRegEntry(regApps,L"",(LPBYTE*)&pszBuffer) )
    {
        goto Error;
    }
/*
    cbBuffer = sizeof(szBuffer);

    l = RegQueryValueEx(regApps,
            regApps,
            TEXT(""),
            NULL,   // reserved
            &dwType,
            (LPBYTE)&szBuffer[0],
            &cbBuffer);

    if (S_OK != l)
        goto Error;

    // strip the quotes out
    pszIExplore = szBuffer;
*/
    pszIExplore = pszBuffer;

    while (*pszIExplore == '\"')
    {
        ++pszIExplore;
    }

    pszEnd = pszIExplore;

    while (*pszEnd && *pszEnd != '\"')
    {
        ++pszEnd;
    }
    *pszEnd  = '\0';

    DWORD dwNoIdea=0;
    if (dwVerInfo = GetFileVersionInfoSize(pszIExplore, &dwNoIdea))
    {
        lpVerData = _alloca(dwVerInfo);

        if (GetFileVersionInfo(pszIExplore, 0, dwVerInfo, lpVerData))
        {
            VerQueryValue(lpVerData, TEXT("\\"), (LPVOID*)&lpFFI, &cbVer);

            // For now we will assume that the proxy settings will not change for for later version of
            // IE. It might be good to get the location of the proxy using api calls
            if (HIWORD(lpFFI->dwFileVersionMS) >= 5)
            {
                    hKeyRoot = HKEY_CURRENT_USER;
                    pszSubKey = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings");
            }
        }
    }


    dwVerInfo = GetLastError();

    // HKCU is not dynamic, so close the current one
    if (hKeyRoot == HKEY_CURRENT_USER)
        RegCloseKey(hKeyRoot);

    if( !hKeyRoot )
    {
        // We did not get a key, something went wrong, abort
        //
        goto Error;
    }

    l = RegOpenKeyEx(
            hKeyRoot, 
            pszSubKey,
            0,
            KEY_READ,
            &regIe);

    if (S_OK != l)
        goto Error;

    //cbBuffer = sizeof(szBuffer);
    //dwType = REG_SZ;

    if( !GetRegEntry(regIe,TEXT("ProxyServer"),(LPBYTE*)&pszBuffer) )
    {
        goto Error;
    }
    
    //pszSearch = _tcsstr(pszBuffer, TEXT("http://"));
    pszSearch = _tcsstr(pszBuffer, TEXT("://"));
    if (pszSearch)
    {
        pszSearch += 3; //7;
        pszStart = pszSearch;
    }
    else
    {
        pszSearch = _tcsstr(pszBuffer, TEXT("="));
        if (pszSearch)
        {
            pszSearch += 1; //7;
            pszStart = pszSearch;
        }
        else
        {
            pszSearch = pszBuffer; 
            pszStart  = pszBuffer; 
        }
    }
    while (*pszSearch && *pszSearch != TEXT(':'))
        ++pszSearch;

    // Grab the port
    if (!*pszSearch)
    {
        *pdwPort = 80;
    }
    else
    {
        *pszSearch = TEXT('\0');
#if UNICODE

        *pdwPort = wcstol(pszSearch + 1,NULL,10);
#else
        //*pdwPort = atol(pszSearch + 1);
        *pdwPort = strtol(pszSearch + 1,NULL,10);
#endif
    }

    pProxy->SetHost(pszStart);
    
    cbBuffer = sizeof (dwEnabled);
    l = RegQueryValueEx(
            regIe,
            TEXT("ProxyEnable"),
            NULL,   // reserved
            &dwType,
            (LPBYTE)&dwEnabled,
            &cbBuffer);

    if (S_OK != l)
        goto Error;

    if (pdwEnabled)
        *pdwEnabled = dwEnabled;

    if (hKeyRoot == HKEY_CURRENT_USER)
        RegCloseKey(HKEY_CURRENT_USER);
//    CoRevertToSelf();

    if( pszBuffer )
    {
        HeapFree(GetProcessHeap(),0,pszBuffer);
    }
    
    return TRUE;
Error:
    if (hKeyRoot == HKEY_CURRENT_USER)
        RegCloseKey(HKEY_CURRENT_USER);
//    CoRevertToSelf();

    if( pszBuffer )
    {
        HeapFree(GetProcessHeap(),0,pszBuffer);
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\wmi\dgnet\stdpch.cpp ===
// stdpch.cpp
//

#include "stdpch.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\wmi\dgnet\utils.cpp ===
//***************************************************************************
//
//  UTILS.CPP
//
//  Module: WMI Instance provider sample code
//
//  Purpose: General purpose utilities.  
//
//  Copyright (c) 1997-1999 Microsoft Corporation
//
//***************************************************************************

#include "stdpch.h"
#pragma hdrstop

//***************************************************************************
//
// CreateInst
//
// Purpose: Creates a new instance and sets
//          the inital values of the properties.
//
// Return:   S_OK if all is well, otherwise an error code is returned
//
//***************************************************************************

SCODE
CreateInst(
    IWbemServices * pNamespace,
    IWbemClassObject ** pNewInst,
    WCHAR * pwcClassName,
	IWbemContext  *pCtx)
{   
    SCODE sc;
    IWbemClassObject * pClass = NULL;

    sc = pNamespace->GetObject(pwcClassName, 0, pCtx, &pClass, NULL);
    
    if(sc != S_OK)
        return WBEM_E_FAILED;
    
    sc = pClass->SpawnInstance(0, pNewInst);
    
    pClass->Release();
    
    if(FAILED(sc))
        return sc;
    
    VARIANT v;
    // Set the key property value.

    v.vt = VT_I4;
    v.lVal = 0;
    sc = (*pNewInst)->Put(L"Id", 0, &v, 0);
    VariantClear(&v);

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\wmi\dgnet\utils.h ===
// utils.h
//

#define ZeroStruct(x) ZeroMemory((LPVOID)(&x), sizeof(x))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\wmi\dgnet\tstring.h ===
// tstring.h
//
// string<> no longer has compare operators like it supposed to.
//

#pragma once

//
// Use the heap allocator if it's been included
//
#ifdef __ALLOC_H
typedef basic_string<wchar_t, char_traits<wchar_t>,
    ::heap_allocator<wchar_t> > whstring;

typedef basic_string<char, char_traits<char>,
    ::heap_allocator<char> > hstring;
#else
#define whstring wstring
#define hstring string
#endif

class tstring : public
#ifdef UNICODE
whstring
#else
hstring
#endif
{
public:
	tstring(){};
	tstring(LPCTSTR sz) :
#ifdef UNICODE
    whstring(sz)
#else
    hstring(sz)
#endif
    {};
	
	operator LPCTSTR()
	{	return c_str();	}

	bool operator<(const tstring& rhs) const
	{	return (compare(rhs)<0);	}
	
	bool operator==(const tstring& rhs)
	{	return (0 == compare(rhs));	}
    
    TCHAR operator[] (int index)
    {   return c_str()[index];    }

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\wmi\dgnet\stdpch.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__664DE28F_B5C4_4970_8235_E7602E03D253__INCLUDED_)
#define AFX_STDAFX_H__664DE28F_B5C4_4970_8235_E7602E03D253__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
extern HMODULE g_hModule;
#include <windows.h>
#include <atlcom.h>
#include <comdef.h>
#include "dgnetres.h"
//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__664DE28F_B5C4_4970_8235_E7602E03D253__INCLUDED)










// stdpch.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#pragma once

// Insert your headers here
//#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <windows.h>
#include <winsock2.h>
//#include <iphlpapi.h>
#include <malloc.h>
#include <objbase.h>
#include <oaidl.h>
#include "comdef.h"

#include <deque>
#include <vector>
#include <string>
#include <xstring>
using namespace std;
#include "alloc.h"
#include "tstring.h"
#include "autoall.h"
#include "utils.h"

#if defined(DEBUG) || defined (_DEBUG)
#include <crtdbg.h>
#endif

#include <wbemcli.h>
#include <wbemprov.h>

#define EXPORT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\wmi\dll\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\wmi\dgnet\queue.h ===
//
// queue.h
//

#pragma once
#include <limits.h>

template <class T, LPTHREAD_START_ROUTINE lpThread>
class CQueue
{
public:
	CQueue()
	  : m_hShutdown(0),
        m_dwThreads(0)
    {
        m_sem = CreateSemaphore(
                    NULL,
                    0,          // initial count
                    LONG_MAX,
                    NULL);
    }


	// Wait
    //
    // This function will return false when the shutdown handle is set.
    //

    bool Wait(T& lhs)
	{
		HANDLE h[2] = {m_sem, m_hShutdown};
        DWORD n;

        n = m_hShutdown ? 2 : 1;

		if (0 == WaitForMultipleObjects(n, &h[0], FALSE, INFINITE))
		{
			EnterCriticalSection();
			lhs = m_dq.back();
			m_dq.pop_back();
			LeaveCriticalSection();
			return true;
		}
        else
			return false;
	}

    // GetItem
    //
    // This will return an item from the Q, or it will return false if empty.
    //

    bool GetItem(T& lhs)
	{
        bool rt;
        if (0 == WaitForSingleObject(m_sem, 0))
		{
			EnterCriticalSection();
            if (m_dq.empty())
            {
                rt = false;
            }
            else
            {
			    lhs = m_dq.back();
			    m_dq.pop_back();
                rt = true;
            }
    	    LeaveCriticalSection();
			return rt;
		}
		else
        {
			return false;
        }
	}

    // This now automatically creates worker threads.
    void push_front(const T& fifo)
    {   
		DWORD dwQueue;
        DWORD dwThreadId;
        auto_leave cs(m_cs);

        //
        // Add to the work Q
        //
        cs.EnterCriticalSection();
        
        m_dq.push_front(fifo);
        
        //
        // Grab current work Q size to make sure we have enough threads
        //
        dwQueue = m_dq.size();
        
        cs.LeaveCriticalSection();

        //
        // Allocation method - Create as many threads as we need
        //
        while (dwQueue > m_dwThreads)
        {
            InterlockedIncrement((LPLONG)&m_dwThreads);

            m_vhThreads.push_back(
                CreateThread(NULL, 0, lpThread, NULL, 0, &dwThreadId));
        }

        ReleaseSemaphore(m_sem, 1, NULL);
    }

	void pop_back(T& lhs)
    {
		auto_leave cs(m_cs);

		cs.EnterCriticalSection();
        lhs = m_dq.back();
    	m_dq.pop_back();
    }

    void EnterCriticalSection()
    {   ::EnterCriticalSection(m_cs.get()); }

    void LeaveCriticalSection()
    {   ::LeaveCriticalSection(m_cs.get()); }

    bool bTimeToShutdown()
    {   return WAIT_TIMEOUT != WaitForSingleObject(m_hShutdown, 0); }

    HANDLE				m_hShutdown;
protected:
	deque <T>	  		m_dq;
	auto_cs			 	m_cs;
	HANDLE 				m_sem;
    DWORD               m_dwThreads;
    vector<HANDLE>      m_vhThreads;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\wmi\dgnet\wire.h ===
// wire.h
//
// Structures used for sending packets over the wire
//

#define ICMP_ECHO 8
#define ICMP_ECHOREPLY 0

#define ICMP_MIN 8 // minimum 8 byte icmp packet (just header)

/* The IP header */
typedef struct iphdr {
	unsigned int h_len:4;          // length of the header
	unsigned int version:4;        // Version of IP
	unsigned char tos;             // Type of service
	unsigned short total_len;      // total length of the packet
	unsigned short ident;          // unique identifier
	unsigned short frag_and_flags; // flags
	unsigned char  ttl; 
	unsigned char proto;           // protocol (TCP, UDP etc)
	unsigned short checksum;       // IP checksum

	unsigned int sourceIP;
	unsigned int destIP;

}IpHeader;

//
// ICMP header
//
typedef struct _ihdr {
  BYTE i_type;
  BYTE i_code; /* type sub code */
  USHORT i_cksum;
  USHORT i_id;
  USHORT i_seq;
  /* This is not the std header, but we reserve space for time */
  ULONG timestamp;
}IcmpHeader;

#define STATUS_FAILED 0xFFFF
#define DEF_PACKET_SIZE 32
#define MAX_PACKET 1024

#define xmalloc(s) HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,(s))
#define xfree(p)   HeapFree (GetProcessHeap(),0,(p))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\wmi\dgnet\worker.cpp ===
// worker.cpp
//

#include "stdpch.h"
#pragma hdrstop

#include "queue.h"
#include "command.h"    // CCommand
#include "worker.h"

CQueue<CCommand*, WorkerThread> g_Q;

DWORD WINAPI WorkerThread(LPVOID lpv)
{
	CCommand * pCmd;
    HANDLE hThread;

	hThread = GetCurrentThread();

	SetThreadPriority(hThread, THREAD_PRIORITY_LOWEST);

    while(g_Q.Wait(pCmd))
	{
        try
        {
		    pCmd->Go();

		    // put in undo list
    		delete pCmd;
        }
        catch(int )
        {
            // hmmm, I am just catching shutdown
        }
        catch(...)
        {
        }
	}
	return 0;
}

#ifdef NOTHING // DEBUG
void* __cdecl ::operator new(size_t n)
{
	return 0;
}

void __cdecl ::operator delete(void* p)
{
}

int __cdecl atexit( void ( __cdecl *func )( void ) )
{
	return 0;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\wmi\dgnet\worker.h ===
// worker.h
//
// API's for the worker threads
//

#pragma once

DWORD WINAPI WorkerThread(LPVOID lpv);

extern CQueue<CCommand*, WorkerThread> g_Q;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\wmi\dll\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__664DE28F_B5C4_4970_8235_E7602E03D253__INCLUDED_)
#define AFX_STDAFX_H__664DE28F_B5C4_4970_8235_E7602E03D253__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
extern HMODULE g_hModule;
#include <windows.h>
#include <atlcom.h>
#include <comdef.h>
#include <string>
#include <map>
#include <vector>
#include <list>
#include <wbemidl.h>
#include <wbemcli.h>
#include <winsock2.h>
#include "dglogsres.h"
#include "network.h"


using namespace std;

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__664DE28F_B5C4_4970_8235_E7602E03D253__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\wmi\dll\dglogs.cpp ===
// Dglogs.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f Dglogsps.mk in the project directory.

#include "stdafx.h"
#include "dglogsres.h"
#include <initguid.h>
#include "Dglogs.h"

#include "Dglogs_i.c"
#include "DglogsCom.h"
#include "Diagnostics.h"
#include "dgnet.h"
//#include "Dglogsnetsh.h"
#include <netsh.h>
//#include <netshp.h>

DWORD WINAPI
InitHelperDllEx(
    IN  DWORD      dwNetshVersion,
    OUT PVOID      pReserved
    );

DWORD WINAPI
InitHelperDll(
    IN  DWORD      dwNetshVersion,
    OUT PVOID      pReserved
    )
{
	return InitHelperDllEx(dwNetshVersion,pReserved);
}

extern GUID CLSID_Dgnet;

CComModule _Module;
BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_DglogsCom, CDglogsCom)
    OBJECT_ENTRY(CLSID_Dgnet, CGotNet)
END_OBJECT_MAP()

HMODULE g_hModule;
CDiagnostics g_Diagnostics;
STDAPI RegisterhNetshHelper();
STDAPI UnRegisterNetShHelper();

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_DGLOGSLib);
        DisableThreadLibraryCalls(hInstance);
        g_hModule = (HMODULE) hInstance;
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // Register with Netsh
    //RegisterhNetshHelper();
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    // Unregister from netsh
    //UnRegisterNetShHelper();
    return _Module.UnregisterServer(TRUE);
}



STDAPI RegisterhNetshHelper()
{
    HKEY hNetSh;
    long lRet = NOERROR;
    WCHAR szwModule[MAX_PATH];
    HRESULT hr;

    // Open the netsh registry entry
    //
    lRet = RegOpenKey(HKEY_LOCAL_MACHINE,
                      L"SOFTWARE\\Microsoft\\NetSh",
                      &hNetSh);

    if( ERROR_SUCCESS == lRet )
    {
        // Get the dll filename
        //
        if( GetModuleFileName( (HMODULE)g_hModule, szwModule,  MAX_PATH ) )
        {        
            // Add dglogs under netsh
            //
            lRet = RegSetValueEx(hNetSh, 
                                 L"dglogs", 
                                 0, 
                                 REG_SZ, 
                                 (CONST BYTE *)szwModule, 
                                 (lstrlen(szwModule)+1) * sizeof(WCHAR) );
        }

        // Close the regsitry key
        //
        RegCloseKey(hNetSh);
    }

    return lRet == ERROR_SUCCESS ? NOERROR:ERROR;
}


STDAPI UnRegisterNetShHelper()
{
    HKEY hNetSh;
    long lRet = NOERROR;

    // Open the netsh registry entry
    //
    lRet = RegOpenKey(HKEY_LOCAL_MACHINE,
                      L"SOFTWARE\\Microsoft\\NetSh",
                      &hNetSh);

    if( ERROR_SUCCESS == lRet )
    {
        // Delete our entry
        //
        RegDeleteValue(hNetSh,L"dglogs");
        RegCloseKey(hNetSh);
    }

    return lRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\wmi\inc\dglogsres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Dglogs.rc
//
#define IDS_PROJNAME                    100
#define IDR_DGLOGSCOM                   101
//#define IDR_DGNET                       103
#define IDS_PING_PACKET                 200
#define IDS_INVALID_IP                  201
#define IDS_SOCKET_CREATE_FAIL          202
#define IDS_RESOLVE_NAME_FAIL           203
#define IDS_SEND_FAIL                   204
#define IDS_TIMED_OUT                   205
#define IDS_PASSED                      206
#define IDS_FAILED                      207
#define IDS_SAMESUBNET                  208
#define IDS_DIFFERENTSUBNET             209
#define IDS_NOTCONFIGURED               210
#define IDS_SERVERCONNECTSTART          211
#define IDS_SERVERCONNECTEND            212
#define IDS_NONE                        213
#define IDS_POP3                        214
#define IDS_POP2                        215
#define IDS_SMTP                        216
#define IDS_IMAP                        217
#define IDS_MAILPORTSCHECKED            218
#define IDS_IEPROXYNOTUSED              219
#define IDS_INVALIDIP                   220
#define IDS_MAIL                        221
#define IDS_UNREACHABLE                 222
#define IDS_CATEGORY_NETWORKADAPTERS    223
#define IDS_CATEGORY_MODEM              224
#define IDS_CATEGORY_SYSTEMINFO         225
#define IDS_CATEGORY_INTERNET           226
#define IDS_ADAPTER_HEADER              227
#define IDS_DNS_HEADER                  228
#define IDS_DHCP_HEADER                 229
#define IDS_WINS_HEADER                 230
#define IDS_IP_HEADER                   231
#define IDS_GATEWAY_HEADER              232
#define IDS_CLIENT_HEADER               233
#define IDS_MAIL_HEADER                 234
#define IDS_NEWS_HEADER                 235
#define IDS_PROXY_HEADER                236
#define IDS_COMPUTER_HEADER             237
#define IDS_OS_HEADER                   238
#define IDS_VERSION_HEADER              239
#define IDS_MODEM_HEADER                240
#define IDS_LOOPBACK_HEADER             241
#define IDS_COLLECTINGINFO_STATUS       242
#define IDS_FINISHED_STATUS             243
#define IDS_CONNECTINGTOSERVER_STATUS   244
#define IDS_PINGING_STATUS              245
#define IDS_CONNECTEDTOSERVERSUCCESS    246
#define IDS_CONNECTEDTOSERVERFAILED     247
#define IDS_OENEWSACCOUNTINFOERROR      248
#define IDS_OEMAILACCOUNTINFOERROR      249
#define IDS_WMIERROR                    250
#define IDS_EMPTY                       251
#define IDS_HTTP                        252
#define IDS_UNKNOWN                     253
#define IDS_TRUE                        254
#define IDS_FALSE                       255


#define IDS_PINGMSG_1                   300
#define IDS_PINGMSG_2                   301
#define IDS_PINGMSG_3                   302
#define IDS_PINGMSG_4                   303
#define IDS_PINGMSG_5                   304
#define IDS_PINGMSG_6                   305
#define IDS_PINGMSG_7                   306
#define IDS_PINGMSG_8                   307
#define IDS_PINGMSG_9                   308
#define IDS_PINGMSG_10                  309
#define IDS_PINGMSG_11                  310
#define IDS_PINGMSG_12                  311
#define IDS_PINGMSG_13                  312
#define IDS_PINGMSG_14                  313
#define IDS_PINGMSG_15                  314
#define IDS_PINGMSG_16                  315
#define IDS_PINGMSG_17                  316
#define IDS_PINGMSG_18                  317


#define PING_BUF_TOO_SMALL              413
#define PING_DEST_NET_UNREACHABLE       414
#define PING_DEST_HOST_UNREACHABLE      415
#define PING_DEST_PROT_UNREACHABLE      416
#define PING_DEST_PORT_UNREACHABLE      417
#define PING_NO_RESOURCES               418
#define PING_BAD_OPTION                 419
#define PING_HW_ERROR                   420
#define PING_PACKET_TOO_BIG             421
#define PING_REQ_TIMED_OUT              422
#define PING_BAD_REQ                    423
#define PING_BAD_ROUTE                  424
#define PING_TTL_EXPIRED_TRANSIT        425
#define PING_TTL_EXPIRED_REASSEM        426
#define PING_PARAM_PROBLEM              427
#define PING_SOURCE_QUENCH              428
#define PING_OPTION_TOO_BIG             429
#define PING_BAD_DESTINATION            430
#define PING_NEGOTIATING_IPSEC          431
#define PING_GENERAL_FAILURE            432
#define PING_NO_MEMORY                  433


#define IPSAMPLELOG_BASE                44000

#define HLP_DUMP                        (IPSAMPLELOG_BASE + 1)
#define HLP_DUMP_EX                     (IPSAMPLELOG_BASE + 2)

#define HLP_GROUP_SHOW                  (IPSAMPLELOG_BASE + 3)
#define HLP_GROUP_PING                  (IPSAMPLELOG_BASE + 4)
#define HLP_GROUP_CONNECT               (IPSAMPLELOG_BASE + 5)

#define HLP_SHOW_MAIL                   (IPSAMPLELOG_BASE + 6)
#define HLP_SHOW_MAIL_EX                (IPSAMPLELOG_BASE + 7)
#define HLP_SHOW_NEWS                   (IPSAMPLELOG_BASE + 8)
#define HLP_SHOW_NEWS_EX                (IPSAMPLELOG_BASE + 9)
#define HLP_SHOW_PROXY                  (IPSAMPLELOG_BASE + 10)
#define HLP_SHOW_PROXY_EX               (IPSAMPLELOG_BASE + 11)
#define HLP_SHOW_OS                     (IPSAMPLELOG_BASE + 12)
#define HLP_SHOW_OS_EX                  (IPSAMPLELOG_BASE + 13)
#define HLP_SHOW_COMPUTER               (IPSAMPLELOG_BASE + 14)
#define HLP_SHOW_COMPUTER_EX            (IPSAMPLELOG_BASE + 15)
#define HLP_SHOW_VERSION                (IPSAMPLELOG_BASE + 16)
#define HLP_SHOW_VERSION_EX             (IPSAMPLELOG_BASE + 17)
#define HLP_SHOW_WINS                   (IPSAMPLELOG_BASE + 18)
#define HLP_SHOW_WINS_EX                (IPSAMPLELOG_BASE + 19)
#define HLP_SHOW_DHCP                   (IPSAMPLELOG_BASE + 20)
#define HLP_SHOW_DHCP_EX                (IPSAMPLELOG_BASE + 21)
#define HLP_SHOW_IP                     (IPSAMPLELOG_BASE + 22)
#define HLP_SHOW_IP_EX                  (IPSAMPLELOG_BASE + 23)
#define HLP_SHOW_DNS                    (IPSAMPLELOG_BASE + 24)
#define HLP_SHOW_DNS_EX                 (IPSAMPLELOG_BASE + 25)
#define HLP_SHOW_GATEWAY                (IPSAMPLELOG_BASE + 26)
#define HLP_SHOW_GATEWAY_EX             (IPSAMPLELOG_BASE + 27)
#define HLP_SHOW_ADAPTER                (IPSAMPLELOG_BASE + 28)
#define HLP_SHOW_ADAPTER_EX             (IPSAMPLELOG_BASE + 29)
#define HLP_SHOW_MODEM                  (IPSAMPLELOG_BASE + 30)
#define HLP_SHOW_MODEM_EX               (IPSAMPLELOG_BASE + 31)
#define HLP_SHOW_CLIENT                 (IPSAMPLELOG_BASE + 32)
#define HLP_SHOW_CLIENT_EX              (IPSAMPLELOG_BASE + 33)
#define HLP_SHOW_ALL                    (IPSAMPLELOG_BASE + 34)
#define HLP_SHOW_ALL_EX                 (IPSAMPLELOG_BASE + 35)


#define HLP_PING_MAIL                   (IPSAMPLELOG_BASE + 36)
#define HLP_PING_MAIL_EX                (IPSAMPLELOG_BASE + 37)
#define HLP_PING_NEWS                   (IPSAMPLELOG_BASE + 38)
#define HLP_PING_NEWS_EX                (IPSAMPLELOG_BASE + 39)
#define HLP_PING_PROXY                  (IPSAMPLELOG_BASE + 40)
#define HLP_PING_PROXY_EX               (IPSAMPLELOG_BASE + 41)
#define HLP_PING_WINS                   (IPSAMPLELOG_BASE + 42)
#define HLP_PING_WINS_EX                (IPSAMPLELOG_BASE + 43)
#define HLP_PING_DHCP                   (IPSAMPLELOG_BASE + 44)
#define HLP_PING_DHCP_EX                (IPSAMPLELOG_BASE + 45)
#define HLP_PING_IP                     (IPSAMPLELOG_BASE + 46)
#define HLP_PING_IP_EX                  (IPSAMPLELOG_BASE + 47)
#define HLP_PING_DNS                    (IPSAMPLELOG_BASE + 48)
#define HLP_PING_DNS_EX                 (IPSAMPLELOG_BASE + 49)
#define HLP_PING_GATEWAY                (IPSAMPLELOG_BASE + 50)
#define HLP_PING_GATEWAY_EX             (IPSAMPLELOG_BASE + 51)
#define HLP_PING_ADAPTER                (IPSAMPLELOG_BASE + 52)
#define HLP_PING_ADAPTER_EX             (IPSAMPLELOG_BASE + 53)
#define HLP_PING_LOOPBACK               (IPSAMPLELOG_BASE + 54)
#define HLP_PING_LOOPBACK_EX            (IPSAMPLELOG_BASE + 55)
#define HLP_PING_IPHOST                 (IPSAMPLELOG_BASE + 56)
#define HLP_PING_IPHOST_EX              (IPSAMPLELOG_BASE + 57)


#define HLP_CONNECT_MAIL                (IPSAMPLELOG_BASE + 58)
#define HLP_CONNECT_MAIL_EX             (IPSAMPLELOG_BASE + 59)
#define HLP_CONNECT_NEWS                (IPSAMPLELOG_BASE + 60)
#define HLP_CONNECT_NEWS_EX             (IPSAMPLELOG_BASE + 61)
#define HLP_CONNECT_PROXY               (IPSAMPLELOG_BASE + 62)
#define HLP_CONNECT_PROXY_EX            (IPSAMPLELOG_BASE + 63)
#define HLP_CONNECT_IPHOST              (IPSAMPLELOG_BASE + 64)
#define HLP_CONNECT_IPHOST_EX           (IPSAMPLELOG_BASE + 65)

#define HLP_SHOW_TEST                   (IPSAMPLELOG_BASE + 66)
#define HLP_SHOW_TEST_EX                (IPSAMPLELOG_BASE + 67)

#define HLP_SHOW_GUI                   (IPSAMPLELOG_BASE + 68)
#define HLP_SHOW_GUI_EX                (IPSAMPLELOG_BASE + 69)




#define WM_PROGRESSREPORT               WM_USER + 1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif

/*
#include <windows.h>
#include <ntverp.h>
*/
/*-----------------------------------------------*/
/* the following lines are specific to this file */
/*-----------------------------------------------*/

/* VER_FILETYPE, VER_FILESUBTYPE, VER_FILEDESCRIPTION_STR
 * and VER_INTERNALNAME_STR must be defined before including COMMON.VER
 * The strings don't need a '\0', since common.ver has them.
 */
//#define VER_FILETYPE    VFT_DLL
/* possible values:     VFT_UNKNOWN
                        VFT_APP
                        VFT_DLL
                        VFT_DRV
                        VFT_FONT
                        VFT_VXD
                        VFT_STATIC_LIB
*/
//#define VER_FILESUBTYPE VFT2_UNKNOWN
/* possible values      VFT2_UNKNOWN
                        VFT2_DRV_PRINTER
                        VFT2_DRV_KEYBOARD
                        VFT2_DRV_LANGUAGE
                        VFT2_DRV_DISPLAY
                        VFT2_DRV_MOUSE
                        VFT2_DRV_NETWORK
                        VFT2_DRV_SYSTEM
                        VFT2_DRV_INSTALLABLE
                        VFT2_DRV_SOUND
                        VFT2_DRV_COMM
*/
/*
#define VER_FILEDESCRIPTION_STR   "Network Diagnostics -- Netsh Helper"
#define VER_INTERNALNAME_STR      "DGLOGS.DLL"
#define VER_ORIGINALFILENAME_STR  "DGLOGS.DLL"

#include "common.ver"   // NT5.0 version file.
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\diagnostics\wmi\inc\dgnetres.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by net.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

#define IDR_DGNET               102

#define IDR_NETMOF              100
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\dlc\api\dlcdebug.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    dlcdebug.c

Abstract:

    CCB dump routines for NT-level CCB

    Contents:
        GetAcslanDebugFlags
        SetAcslanDebugFlags
        AcslanDebugPrint
        AcslanDebugPrintString
        DumpCcb
        MapCcbRetcode
        DumpData
        (DefaultParameterTableDump)
        (DumpParameterTableHeader)
        (DumpBufferCreateParms)
        (DumpBufferFreeParms)
        (DumpBufferGetParms)
        (DumpDirInitializeParms)
        (DumpDirOpenAdapterParms)
        (MapEthernetType)
        (DumpDirOpenDirectParms)
        (DumpDirReadLogParms)
        (MapLogType)
        (DumpDirSetExceptionFlagsParms)
        (DumpDirSetFunctionalAddressParms)
        (DumpDirSetGroupAddressParms)
        (DumpDirStatusParms)
        (MapAdapterType)
        (DumpDirTimerCancelParms)
        (DumpDirTimerCancelGroupParms)
        (DumpDirTimerSetParms)
        (DumpDlcCloseSapParms)
        (DumpDlcCloseStationParms)
        (DumpDlcConnectStationParms)
        (DumpDlcFlowControlParms)
        (MapFlowControl)
        (DumpDlcModifyParms)
        (DumpDlcOpenSapParms)
        (DumpDlcOpenStationParms)
        (DumpDlcReallocateParms)
        (DumpDlcResetParms)
        (DumpDlcSetThresholdParms)
        (DumpDlcStatisticsParms)
        (DumpReadParms)
        (MapOptionIndicator)
        (MapReadEvent)
        (MapDlcStatus)
        (DumpReadCancelParms)
        (DumpReceiveParms)
        (MapRcvReadOption)
        (MapReceiveOptions)
        (DumpReceiveCancelParms)
        (DumpReceiveModifyParms)
        (DumpTransmitDirFrameParms)
        (DumpTransmitIFrameParms)
        (DumpTransmitTestCmdParms)
        (DumpTransmitUiFrameParms)
        (DumpTransmitXidCmdParms)
        (DumpTransmitXidRespFinalParms)
        (DumpTransmitXidRespNotFinalParms)
        (DumpTransmitFramesParms)
        (DumpTransmitParms)
        (DumpTransmitQueue)
        DumpReceiveDataBuffer
        (MapMessageType)

Author:

    Richard L Firth (rfirth) 28-May-1992

Revision History:

--*/

#if DBG

#include <nt.h>
#include <ntrtl.h>      // ASSERT, DbgPrint
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <ctype.h>
#include <dlcapi.h>     // Official DLC API definition
#include "dlcdebug.h"

//
// defines
//

#define DBGDBG  0

//
// macros
//

//
// HEX_TO_NUM - converts an ASCII hex character (0-9A-Fa-f) to corresponding
// number (0-15). Assumes c is hexadecimal digit on input
//

#define HEX_TO_NUM(c)   ((c) - ('0' + (((c) <= '9') ? 0 : ((islower(c) ? 'a' : 'A') - ('9' + 1)))))

//
// local prototypes
//

VOID
AcslanDebugPrintString(
    IN LPSTR String
    );

PRIVATE
VOID
DefaultParameterTableDump(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpParameterTableHeader(
    IN LPSTR CommandName,
    IN PVOID Table
    );

PRIVATE
VOID
DumpBufferCreateParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpBufferFreeParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpBufferGetParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpDirInitializeParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpDirOpenAdapterParms(
    IN PVOID Parameters
    );

PRIVATE
LPSTR
MapEthernetType(
    IN LLC_ETHERNET_TYPE EthernetType
    );

PRIVATE
VOID
DumpDirOpenDirectParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpDirReadLogParms(
    IN PVOID Parameters
    );

PRIVATE
LPSTR
MapLogType(
    IN USHORT Type
    );

PRIVATE
VOID
DumpDirSetExceptionFlagsParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpDirSetFunctionalAddressParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpDirSetGroupAddressParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpDirStatusParms(
    IN PVOID Parameters
    );

PRIVATE
LPSTR
MapAdapterType(
    IN USHORT AdapterType
    );

PRIVATE
VOID
DumpDirTimerCancelParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpDirTimerCancelGroupParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpDirTimerSetParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpDlcCloseSapParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpDlcCloseStationParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpDlcConnectStationParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpDlcFlowControlParms(
    IN PVOID Parameters
    );

PRIVATE
LPSTR
MapFlowControl(
    IN BYTE FlowControl
    );

PRIVATE
VOID
DumpDlcModifyParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpDlcOpenSapParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpDlcOpenStationParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpDlcReallocateParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpDlcResetParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpDlcSetThresholdParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpDlcStatisticsParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpReadParms(
    IN PVOID Parameters
    );

PRIVATE
LPSTR
MapOptionIndicator(
    IN UCHAR OptionIndicator
    );

PRIVATE
LPSTR
MapReadEvent(
    UCHAR Event
    );

PRIVATE
LPSTR
MapDlcStatus(
    WORD Status
    );

PRIVATE
VOID
DumpReadCancelParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpReceiveParms(
    IN PVOID Parameters
    );

PRIVATE
LPSTR
MapReceiveOptions(
    IN UCHAR Options
    );

PRIVATE
LPSTR
MapRcvReadOption(
    IN UCHAR Option
    );

PRIVATE
VOID
DumpReceiveCancelParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpReceiveModifyParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpTransmitDirFrameParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpTransmitIFrameParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpTransmitTestCmdParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpTransmitUiFrameParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpTransmitXidCmdParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpTransmitXidRespFinalParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpTransmitXidRespNotFinalParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpTransmitFramesParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpTransmitParms(
    IN PVOID Parameters
    );

PRIVATE
VOID
DumpTransmitQueue(
    IN PLLC_XMIT_BUFFER Buffer
    );

PRIVATE
LPSTR
MapXmitReadOption(
    IN UCHAR Option
    );

VOID
DumpReceiveDataBuffer(
    IN PVOID Buffer
    );

PRIVATE
LPSTR
MapMessageType(
    UCHAR MessageType
    );

//
// explanations of error codes returned in CCB_RETCODE fields. Explanations
// taken more-or-less verbatim from IBM Local Area Network Technical Reference
// table B-1 ppB-2 to B-5. Includes all errors
//

static LPSTR CcbRetcodeExplanations[] = {
    "Success",
    "Invalid command code",
    "Duplicate command, one already outstanding",
    "Adapter open, should be closed",
    "Adapter closed, should be open",
    "Required parameter missing",
    "Invalid/incompatible option",
    "Command cancelled - unrecoverable failure",
    "Unauthorized access priority",
    "Adapter not initialized, should be",
    "Command cancelled by user request",
    "Command cancelled, adapter closed while command in progress",
    "Command completed Ok, adapter not open",
    "Invalid error code 0x0D",
    "Invalid error code 0x0E",
    "Invalid error code 0x0F",
    "Adapter open, NetBIOS not operational",
    "Error in DIR.TIMER.SET or DIR.TIMER.CANCEL",
    "Available work area exceeded",
    "Invalid LOG.ID",
    "Invalid shared RAM segment or size",
    "Lost log data, buffer too small, log reset",
    "Requested buffer size exceeds pool length",
    "Command invalid, NetBIOS operational",
    "Invalid buffer length",
    "Inadequate buffers available for request",
    "The CCB_PARM_TAB pointer is invalid",
    "A pointer in the CCB parameter table is invalid",
    "Invalid CCB_ADAPTER value",
    "Invalid functional address",
    "Invalid error code 0x1F",
    "Lost data on receive, no buffers available",
    "Lost data on receive, inadequate buffer space",
    "Error on frame transmission, check TRANSMIT.FS data",
    "Error on frame transmit or strip process",
    "Unauthorized MAC frame",
    "Maximum commands exceeded",
    "Unrecognized command correlator",
    "Link not transmitting I frames, state changed from link opened",
    "Invalid transmit frame length",
    "Invalid error code 0x29",
    "Invalid error code 0x2a",
    "Invalid error code 0x2b",
    "Invalid error code 0x2c",
    "Invalid error code 0x2d",
    "Invalid error code 0x2e",
    "Invalid error code 0x2f",
    "Inadequate receive buffers for adapter to open",
    "Invalid error code 0x31",
    "Invalid NODE_ADDRESS",
    "Invalid adapter receive buffer length defined",
    "Invalid adapter transmit buffer length defined",
    "Invalid error code 0x35",
    "Invalid error code 0x36",
    "Invalid error code 0x37",
    "Invalid error code 0x38",
    "Invalid error code 0x39",
    "Invalid error code 0x3a",
    "Invalid error code 0x3b",
    "Invalid error code 0x3c",
    "Invalid error code 0x3d",
    "Invalid error code 0x3e",
    "Invalid error code 0x3f",
    "Invalid STATION_ID",
    "Protocol error, link in invalid state for command",
    "Parameter exceeded maximum allowed",
    "Invalid SAP value or value already in use",
    "Invalid routing information field",
    "Requested group membership in non-existent group SAP",
    "Resources not available",
    "Sap cannot close unless all link stations are closed",
    "Group SAP cannot close, individual SAPs not closed",
    "Group SAP has reached maximum membership",
    "Sequence error, incompatible command in progress",
    "Station closed without remote acknowledgement",
    "Sequence error, cannot close, DLC commands outstanding",
    "Unsuccessful link station connection attempted",
    "Member SAP not found in group SAP list",
    "Invalid remote address, may not be a group address",
    "Invalid pointer in CCB_POINTER field",
    "Invalid error code 0x51",
    "Invalid application program ID",
    "Invalid application program key code",
    "Invalid system key code",
    "Buffer is smaller than buffer size given in DLC.OPEN.SAP",
    "Adapter's system process is not installed",
    "Inadequate stations available",
    "Invalid CCB_PARAMETER_1 parameter",
    "Inadequate queue elements to satisfy request",
    "Initialization failure, cannot open adapter",
    "Error detected in chained READ command",
    "Direct stations not assigned to application program",
    "Dd interface not installed",
    "Requested adapter is not installed",
    "Chained CCBs must all be for same adapter",
    "Adapter initializing, command not accepted",
    "Number of allowed application programs has been exceeded",
    "Command cancelled by system action",
    "Direct stations not available",
    "Invalid DDNAME parameter",
    "Inadequate GDT selectors to satisfy request",
    "Invalid error code 0x66",
    "Command cancelled, CCB resources purged",
    "Application program ID not valid for interface",
    "Segment associated with request cannot be locked",
    "Invalid error code 0x6a",
    "Invalid error code 0x6b",
    "Invalid error code 0x6c",
    "Invalid error code 0x6d",
    "Invalid error code 0x6e",
    "Invalid error code 0x6f",
    "Invalid error code 0x70",
    "Invalid error code 0x71",
    "Invalid error code 0x72",
    "Invalid error code 0x73",
    "Invalid error code 0x74",
    "Invalid error code 0x75",
    "Invalid error code 0x76",
    "Invalid error code 0x77",
    "Invalid error code 0x78",
    "Invalid error code 0x79",
    "Invalid error code 0x7a",
    "Invalid error code 0x7b",
    "Invalid error code 0x7c",
    "Invalid error code 0x7d",
    "Invalid error code 0x7e",
    "Invalid error code 0x7f",
    "Invalid buffer address",
    "Buffer already released",
    "Invalid error code 0x82",
    "Invalid error code 0x83",
    "Invalid error code 0x84",
    "Invalid error code 0x85",
    "Invalid error code 0x86",
    "Invalid error code 0x87",
    "Invalid error code 0x88",
    "Invalid error code 0x89",
    "Invalid error code 0x8a",
    "Invalid error code 0x8b",
    "Invalid error code 0x8c",
    "Invalid error code 0x8d",
    "Invalid error code 0x8e",
    "Invalid error code 0x8f",
    "Invalid error code 0x90",
    "Invalid error code 0x91",
    "Invalid error code 0x92",
    "Invalid error code 0x93",
    "Invalid error code 0x94",
    "Invalid error code 0x95",
    "Invalid error code 0x96",
    "Invalid error code 0x97",
    "Invalid error code 0x98",
    "Invalid error code 0x99",
    "Invalid error code 0x9a",
    "Invalid error code 0x9b",
    "Invalid error code 0x9c",
    "Invalid error code 0x9d",
    "Invalid error code 0x9e",
    "Invalid error code 0x9f",
    "BIND error",
    "Invalid version",
    "NT Error status"
};

#define NUMBER_OF_ERROR_MESSAGES    ARRAY_ELEMENTS(CcbRetcodeExplanations)
#define LAST_DLC_ERROR_CODE         LAST_ELEMENT(CcbRetcodeExplanations)

//
// preset the debug flags to nothing, or to whatever is defined at compile-time
//

DWORD   AcslanDebugFlags = ACSLAN_DEBUG_FLAGS;
FILE*   hDumpFile = NULL;
BYTE    AcslanDumpCcb[LLC_MAX_DLC_COMMAND];
BOOL    HaveCcbFilter = FALSE;

VOID
GetAcslanDebugFlags(
    VOID
    )

/*++

Routine Description:

    This routine is called whenever we have a DLL_PROCESS_ATTACH to the DLL

    checks if there is an environment variable called ACSLAN_DEBUG_FLAGS, and
    loads whatever it finds (as a 32-bit hex number) into AcslanDebugFlags

    checks if there is an environment variable called ACSLAN_DUMP_FILE. If
    there is, then output which otherwise would have gone to the terminal
    goes to the file. The file is opened in "w" mode by default - open for
    write. Current file is destroyed if it exists

    If there is an environment variable called ACSLAN_DUMP_FILTER then this is
    loaded into the AcslanDumpCcb array. This is a string of numbers, the
    position of which corresponds to the CCB command. For each position, 1
    means dump the CCB and 2 means dump the CCB and its parameters. This is an
    additional filter control over that contained in ACSLAN_DEBUG_FLAGS which
    allows control on a per CCB basis. Example:

        ACSLAN_DUMP_CCB=1x0221

    means:

        for CCB 0 (DIR.INTERRUPT) dump the CCB only (no parameter table anyway)
                1 (???) don't do anything (x==0)
                2 (???) don't do anything (x==0)
                3 (DIR.OPEN.ADAPTER) dump the CCB and parameter table
                4 (DIR.CLOSE.ADAPTER) dump the CCB and parameter table
                    (no parameter table, doesn't matter)
                5 (DIR.SET.MULTICAST.ADDRESS) dump the CCB

    etc. We currently recognize up to CCB command 0x36 (54, PURGE.RESOURCES)

Arguments:

    None.

Return Value:

    None.

--*/

{
    LPSTR envVar;
    SYSTEMTIME systemTime;

    if (envVar = getenv(ACSLAN_DEBUG_ENV_VAR)) {
        if (!_strnicmp(envVar, "0x", 2)) {
            envVar += 2;
        }
        for (AcslanDebugFlags = 0; isxdigit(*envVar); ++envVar) {
            AcslanDebugFlags = AcslanDebugFlags * 16 + HEX_TO_NUM(*envVar);
//                + (*envVar
//                    - ('0' + ((*envVar <= '9') ? 0
//                        : ((islower(*envVar) ? 'a' : 'A') - ('9' + 1)))));
        }
    }

    if (envVar = getenv(ACSLAN_DUMP_FILE_VAR)) {

        char* comma;
        static char openMode[3] = "w";

        if (comma = strchr(envVar, ',')) {
            strcpy(openMode, comma+1);
            *comma = 0;
        }
        if ((hDumpFile = fopen(envVar, openMode)) == NULL) {
            DbgPrint("Error: can't create dump file %s\n", envVar);
        } else {
            AcslanDebugFlags |= DEBUG_TO_FILE;
            AcslanDebugFlags &= ~DEBUG_TO_TERMINAL;
        }
    }


#if DBGDBG
    IF_DEBUG(DLL_INFO) {
        PUT(("GetAcslanDebugFlags: AcslanDebugFlags = %#x\n", AcslanDebugFlags));
    }
#endif

    if (envVar = getenv(ACSLAN_DUMP_FILTER_VAR)) {

        int i, len;
        BYTE ch;

        if (strlen(envVar) > sizeof(AcslanDumpCcb) - 1) {

            //
            // if there's too much info then inform the debugger but set up the
            // string anyway
            //

            PUT(("GetAcslanDebugFlags: Error: ACSLAN_DUMP_CCB variable too long: \"%s\"\n", envVar));
            strncpy(AcslanDumpCcb, envVar, sizeof(AcslanDumpCcb) - 1);
            AcslanDumpCcb[sizeof(AcslanDumpCcb) - 1] = 0;
        } else {
            strcpy(AcslanDumpCcb, envVar);
        }

#if DBGDBG
        IF_DEBUG(DLL_INFO) {
            PUT(("GetAcslanDebugFlags: AcslanDumpCcb = %s\n", AcslanDumpCcb));
        }
#endif

        //
        // if there are less characters in the string than CCB commands then
        // default the rest of the commands
        //

        len = strlen(AcslanDumpCcb);
        for (i = len; i < sizeof(AcslanDumpCcb); ++i) {
            AcslanDumpCcb[i] = 0xff;
        }
        AcslanDumpCcb[i] = 0;

        //
        // convert the ASCII characters to numbers
        //

        for (i = 0; i < len; ++i) {
            ch = AcslanDumpCcb[i];
            if (isxdigit(ch)) {
                ch = HEX_TO_NUM(ch);
            } else {
                ch = (BYTE)0xff;
            }
            AcslanDumpCcb[i] = ch;

#if DBGDBG
            PUT(("Command %d: filter=%02x\n", i, ch));
#endif

        }

        HaveCcbFilter = TRUE;
    }

    IF_DEBUG(DLL_INFO) {
        GetSystemTime(&systemTime);
        PUT(("PROCESS STARTED @ %02d:%02d:%02d\n",
            systemTime.wHour, systemTime.wMinute, systemTime.wSecond
            ));
    }
}

VOID
SetAcslanDebugFlags(
    IN DWORD Flags
    )
{
    AcslanDebugFlags = Flags;
}

VOID
AcslanDebugPrint(
    IN LPSTR Format,
    IN ...
    )

/*++

Routine Description:

    Print the debug information to the terminal or debug terminal, depending
    on DEBUG_TO_TERMINAL flag (0x80000000)

Arguments:

    Format  - printf/DbgPrint style format string (ANSI)
    ...     - optional parameters

Return Value:

    None.

--*/

{
    char printBuffer[1024];
    va_list list;

    va_start(list, Format);
    vsprintf(printBuffer, Format, list);

    IF_DEBUG(TO_FILE) {
        fputs(printBuffer, hDumpFile);
    } else IF_DEBUG(TO_TERMINAL) {
        printf(printBuffer);
    } else {
        DbgPrint(printBuffer);
    }
}

VOID
AcslanDebugPrintString(
    IN LPSTR String
    )

/*++

Routine Description:

    Print the debug information to the terminal or debug terminal, depending
    on DEBUG_TO_TERMINAL flag (0x80000000)

Arguments:

    String  - formatted string (ANSI)

Return Value:

    None.

--*/

{
    IF_DEBUG(TO_FILE) {
        fputs(String, hDumpFile);
    } else IF_DEBUG(TO_TERMINAL) {
        printf(String);
    } else {
        DbgPrint(String);
    }
}

VOID
DumpCcb(
    IN PLLC_CCB Ccb,
    IN BOOL DumpAll,
    IN BOOL CcbIsInput
    )

/*++

Routine Description:

    Dumps a CCB and any associated parameter table. Also displays the symbolic
    CCB command and an error code description if the CCB is being returned to
    the caller. Dumps NT format CCBs (flat 32-bit pointers)

Arguments:

    Ccb         - flat 32-bit pointer to CCB2 to dump
    DumpAll     - if TRUE, dumps parameter tables and buffers, else just CCB
    CcbIsInput  - if TRUE, CCB is from user: don't display error code explanation

Return Value:

    None.

--*/

{
    LPSTR   cmdname = "UNKNOWN CCB!";
    BOOL    haveParms = FALSE;
    VOID    (*DumpParms)(PVOID) = DefaultParameterTableDump;
    PVOID   parameterTable = NULL;
    BOOL    parmsInCcb = FALSE;
    BYTE    command;
    DWORD   numberOfTicks;
    BOOL    ccbIsBad = FALSE;
    BOOL    dumpInputParms = TRUE;
    BOOL    dumpOutputParms = TRUE;

    static DWORD LastTicks;
    static BOOL FirstTimeFunctionCalled = TRUE;

    try {
        command = Ccb->uchDlcCommand;
    } except(1) {
        ccbIsBad = TRUE;
    }

    //
    // bomb out if we get a bad CCB address
    //

    if (ccbIsBad) {
        PUT(("*** Error: Bad Address for CCB @ %08x ***\n", Ccb));
        return;
    }

#if DBGDBG
    PUT(("DumpCcb(%x, %d, %d)\n", Ccb, DumpAll, CcbIsInput));
#endif

    IF_DEBUG(DUMP_TIME) {

        DWORD ticksNow = GetTickCount();

        if (FirstTimeFunctionCalled) {
            numberOfTicks = 0;
            FirstTimeFunctionCalled = FALSE;
        } else {
            numberOfTicks = ticksNow - LastTicks;
        }
        LastTicks = ticksNow;
    }

    switch (command) {
    case LLC_BUFFER_CREATE:
        cmdname = "BUFFER.CREATE";
        haveParms = TRUE;
        DumpParms = DumpBufferCreateParms;
        break;

    case LLC_BUFFER_FREE:
        cmdname = "BUFFER.FREE";
        haveParms = TRUE;
        DumpParms = DumpBufferFreeParms;
        break;

    case LLC_BUFFER_GET:
        cmdname = "BUFFER.GET";
        haveParms = TRUE;
        DumpParms = DumpBufferGetParms;
        break;

    case LLC_DIR_CLOSE_ADAPTER:
        cmdname = "DIR.CLOSE.ADAPTER";
        haveParms = FALSE;
        break;

    case LLC_DIR_CLOSE_DIRECT:
        cmdname = "DIR.CLOSE.DIRECT";
        haveParms = FALSE;
        break;

    case LLC_DIR_INITIALIZE:
        cmdname = "DIR.INITIALIZE";
        haveParms = TRUE;
        DumpParms = DumpDirInitializeParms;
        break;

    case LLC_DIR_INTERRUPT:
        cmdname = "DIR.INTERRUPT";
        haveParms = FALSE;
        break;

    case LLC_DIR_OPEN_ADAPTER:
        cmdname = "DIR.OPEN.ADAPTER";
        haveParms = TRUE;
        DumpParms = DumpDirOpenAdapterParms;
        break;

    case LLC_DIR_OPEN_DIRECT:
        cmdname = "DIR.OPEN.DIRECT";
        haveParms = TRUE;
        DumpParms = DumpDirOpenDirectParms;
        break;

    case LLC_DIR_READ_LOG:
        cmdname = "DIR.READ.LOG";
        haveParms = TRUE;
        DumpParms = DumpDirReadLogParms;
        break;

    case LLC_DIR_SET_EXCEPTION_FLAGS:
        cmdname = "DIR.SET.EXCEPTION.FLAGS";
        haveParms = TRUE;
        DumpParms = DumpDirSetExceptionFlagsParms;
        break;

    case LLC_DIR_SET_FUNCTIONAL_ADDRESS:
        cmdname = "DIR.SET.FUNCTIONAL.ADDRESS";
        haveParms = TRUE;
        DumpParms = DumpDirSetFunctionalAddressParms;
        parmsInCcb = TRUE;
        break;

    case LLC_DIR_SET_GROUP_ADDRESS:
        cmdname = "DIR.SET.GROUP.ADDRESS";
        haveParms = TRUE;
        DumpParms = DumpDirSetGroupAddressParms;
        parmsInCcb = TRUE;
        break;

    case LLC_DIR_STATUS:
        cmdname = "DIR.STATUS";
        haveParms = TRUE;
        DumpParms = DumpDirStatusParms;
        break;

    case LLC_DIR_TIMER_CANCEL:
        cmdname = "DIR.TIMER.CANCEL";
        haveParms = TRUE;
        DumpParms = DumpDirTimerCancelParms;
        parmsInCcb = TRUE;
        break;

    case LLC_DIR_TIMER_CANCEL_GROUP:
        cmdname = "DIR.TIMER.CANCEL.GROUP";
        haveParms = TRUE;
        DumpParms = DumpDirTimerCancelGroupParms;
        parmsInCcb = TRUE;
        break;

    case LLC_DIR_TIMER_SET:
        cmdname = "DIR.TIMER.SET";
        haveParms = TRUE;
        DumpParms = DumpDirTimerSetParms;
        parmsInCcb = TRUE;
        break;

    case LLC_DLC_CLOSE_SAP:
        cmdname = "DLC.CLOSE.SAP";
        haveParms = TRUE;
        DumpParms = DumpDlcCloseSapParms;
        parmsInCcb = TRUE;
        break;

    case LLC_DLC_CLOSE_STATION:
        cmdname = "DLC.CLOSE.STATION";
        haveParms = TRUE;
        DumpParms = DumpDlcCloseStationParms;
        parmsInCcb = TRUE;
        break;

    case LLC_DLC_CONNECT_STATION:
        cmdname = "DLC.CONNECT.STATION";
        haveParms = TRUE;
        DumpParms = DumpDlcConnectStationParms;
        break;

    case LLC_DLC_FLOW_CONTROL:
        cmdname = "DLC.FLOW.CONTROL";
        haveParms = TRUE;
        DumpParms = DumpDlcFlowControlParms;
        parmsInCcb = TRUE;
        break;

    case LLC_DLC_MODIFY:
        cmdname = "DLC.MODIFY";
        haveParms = TRUE;
        DumpParms = DumpDlcModifyParms;
        break;

    case LLC_DLC_OPEN_SAP:
        cmdname = "DLC.OPEN.SAP";
        haveParms = TRUE;
        DumpParms = DumpDlcOpenSapParms;
        break;

    case LLC_DLC_OPEN_STATION:
        cmdname = "DLC.OPEN.STATION";
        haveParms = TRUE;
        DumpParms = DumpDlcOpenStationParms;
        break;

    case LLC_DLC_REALLOCATE_STATIONS:
        cmdname = "DLC.REALLOCATE";
        haveParms = TRUE;
        DumpParms = DumpDlcReallocateParms;
        break;

    case LLC_DLC_RESET:
        cmdname = "DLC.RESET";
        break;

    case LLC_DLC_SET_THRESHOLD:
        cmdname = "DLC.SET.THRESHOLD";
        haveParms = TRUE;
        break;

    case LLC_DLC_STATISTICS:
        cmdname = "DLC.STATISTICS";
        haveParms = TRUE;
        DumpParms = DumpDlcStatisticsParms;
        break;

    case 0x25:

        //
        // not supported !
        //

        cmdname = "PDT.TRACE.OFF";
        break;

    case 0x24:

        //
        // not supported !
        //

        cmdname = "PDT.TRACE.ON";
        break;

    case LLC_READ:
        cmdname = "READ";
        haveParms = !CcbIsInput;
        DumpParms = DumpReadParms;
        dumpInputParms = FALSE;
        dumpOutputParms = !CcbIsInput && Ccb->uchDlcStatus == LLC_STATUS_SUCCESS;
        break;

    case LLC_READ_CANCEL:
        cmdname = "READ.CANCEL";
        break;

    case LLC_RECEIVE:
        cmdname = "RECEIVE";
        haveParms = TRUE;
        DumpParms = DumpReceiveParms;
        break;

    case LLC_RECEIVE_CANCEL:
        cmdname = "RECEIVE.CANCEL";
        haveParms = TRUE;
        DumpParms = DumpReceiveCancelParms;
        parmsInCcb = TRUE;
        break;

    case LLC_RECEIVE_MODIFY:
        cmdname = "RECEIVE.MODIFY";
        haveParms = TRUE;
        break;

    case LLC_TRANSMIT_FRAMES:
        cmdname = "TRANSMIT.FRAMES";
        haveParms = TRUE;
        DumpParms = DumpTransmitFramesParms;
        dumpOutputParms = FALSE;
        break;

    case LLC_TRANSMIT_DIR_FRAME:
        cmdname = "TRANSMIT.DIR.FRAME";
        haveParms = TRUE;
        DumpParms = DumpTransmitDirFrameParms;
        dumpOutputParms = FALSE;
        break;

    case LLC_TRANSMIT_I_FRAME:
        cmdname = "TRANSMIT.I.FRAME";
        haveParms = TRUE;
        DumpParms = DumpTransmitIFrameParms;
        dumpOutputParms = FALSE;
        break;

    case LLC_TRANSMIT_TEST_CMD:
        cmdname = "TRANSMIT.TEST.CMD";
        haveParms = TRUE;
        DumpParms = DumpTransmitTestCmdParms;
        dumpOutputParms = FALSE;
        break;

    case LLC_TRANSMIT_UI_FRAME:
        cmdname = "TRANSMIT.UI.FRAME";
        haveParms = TRUE;
        DumpParms = DumpTransmitUiFrameParms;
        break;

    case LLC_TRANSMIT_XID_CMD:
        cmdname = "TRANSMIT.XID.CMD";
        haveParms = TRUE;
        DumpParms = DumpTransmitXidCmdParms;
        dumpOutputParms = FALSE;
        break;

    case LLC_TRANSMIT_XID_RESP_FINAL:
        cmdname = "TRANSMIT.XID.RESP.FINAL";
        haveParms = TRUE;
        DumpParms = DumpTransmitXidRespFinalParms;
        dumpOutputParms = FALSE;
        break;

    case LLC_TRANSMIT_XID_RESP_NOT_FINAL:
        cmdname = "TRANSMIT.XID.RESP.NOT.FINAL";
        haveParms = TRUE;
        DumpParms = DumpTransmitXidRespNotFinalParms;
        dumpOutputParms = FALSE;
        break;

    }

    if (HaveCcbFilter) {

        BYTE filter = AcslanDumpCcb[command];

#if DBGDBG
        PUT(("filter = %02x\n", filter));
#endif

        if (filter == 0xff) {

            //
            // do nothing - 0xff means use default in ACSLAN_DEBUG_FLAGS
            //

        } else {
            if (CcbIsInput) {
                if (!(filter & CF_DUMP_CCB_IN)) {

                    //
                    // not interested in this input CCB
                    //

                    return;
                }
                DumpAll = filter & CF_DUMP_PARMS_IN;
            } else {
                if (!(filter & CF_DUMP_CCB_OUT)) {

                    //
                    // not interested in this output CCB
                    //

                    return;
                }
                DumpAll = filter & CF_DUMP_PARMS_OUT;
            }
        }
    }

    PUT(("\n==============================================================================\n"));

    IF_DEBUG(DUMP_TIME) {
        PUT(("%sPUT CCB @ 0x%08x +%d mSec\n",
            CcbIsInput ? "IN" : "OUT",
            Ccb,
            numberOfTicks
            ));
    } else {
        PUT(("%sPUT CCB @ 0x%08x\n",
            CcbIsInput ? "IN" : "OUT",
            Ccb
            ));
    }

    PUT(("Adapter . . . . %02x\n"
        "Command . . . . %02x [%s]\n"
        "Status. . . . . %02x [%s]\n"
        "Reserved. . . . %02x\n"
        "Next. . . . . . %08x\n"
        "CompletionFlag. %08x\n",
        Ccb->uchAdapterNumber,
        Ccb->uchDlcCommand,
        cmdname,
        Ccb->uchDlcStatus,
        CcbIsInput ? "" : MapCcbRetcode(Ccb->uchDlcStatus),
        Ccb->uchReserved1,
        Ccb->pNext,
        Ccb->ulCompletionFlag
        ));

    if (haveParms) {
        if (parmsInCcb) {
            DumpParms(Ccb->u.pParameterTable);
        } else {
            parameterTable = Ccb->u.pParameterTable;
            PUT(("Parameters. . . %08x\n", parameterTable));
        }
    } else {
        PUT(("Parameters. . . %08x\n", Ccb->u.pParameterTable));
    }

    PUT(("CompletionEvent %08x\n"
        "Reserved. . . . %02x\n"
        "ReadFlag. . . . %02x\n"
        "Reserved. . . . %04x\n",
        Ccb->hCompletionEvent,
        Ccb->uchReserved2,
        Ccb->uchReadFlag,
        Ccb->usReserved3
        ));

    if (parameterTable && DumpAll) {
        if ((CcbIsInput && dumpInputParms) || (!CcbIsInput && dumpOutputParms)) {
            DumpParms(parameterTable);
        }
    }
}

LPSTR
MapCcbRetcode(
    IN  BYTE    Retcode
    )

/*++

Routine Description:

    Returns string describing error code

Arguments:

    Retcode - CCB_RETCODE

Return Value:

    LPSTR

--*/

{
    static char errbuf[128];

    if (Retcode == LLC_STATUS_PENDING) {
        return "Command in progress";
    } else if (Retcode > NUMBER_OF_ERROR_MESSAGES) {
        sprintf(errbuf, "*** Invalid error code 0x%2x ***", Retcode);
        return errbuf;
    }
    return CcbRetcodeExplanations[Retcode];
}

VOID
DumpData(
    IN LPSTR Title,
    IN PBYTE Address,
    IN DWORD Length,
    IN DWORD Options,
    IN DWORD Indent
    )
{
    char dumpBuf[80];
    char* bufptr;
    int i, n, iterations;
    char* hexptr;

    //
    // the usual dump style: 16 columns of hex bytes, followed by 16 columns
    // of corresponding ASCII characters, or '.' where the character is < 0x20
    // (space) or > 0x7f (del?)
    //

    if (Options & DD_LINE_BEFORE) {
        AcslanDebugPrintString("\n");
    }

    try {
        iterations = 0;
        while (Length) {
            bufptr = dumpBuf;
            if (Title && !iterations) {
                strcpy(bufptr, Title);
                bufptr = strchr(bufptr, 0);
            }

            if (Indent && ((Options & DD_INDENT_ALL) || iterations)) {

                int indentLen = (!iterations && Title)
                                    ? ((INT)(Indent - strlen(Title)) < 0)
                                        ? 1
                                        : Indent - strlen(Title)
                                    : Indent;

                memset(bufptr, ' ', indentLen);
                bufptr += indentLen;
            }

            if (!(Options & DD_NO_ADDRESS)) {
                bufptr += sprintf(bufptr, "%p: ", Address);
            }

            n = (Length < 16) ? Length : 16;
            hexptr = bufptr;
            for (i = 0; i < n; ++i) {
                bufptr += sprintf(bufptr, "%02x", Address[i]);
                *bufptr++ = (i == 7) ? '-' : ' ';
            }

            if (Options & DD_UPPER_CASE) {
                _strupr(hexptr);
            }

            if (!(Options & DD_NO_ASCII)) {
                if (n < 16) {
                    for (i = 0; i < 16-n; ++i) {
                        bufptr += sprintf(bufptr, Options & DD_DOT_DOT_SPACE ? ".. " : "   ");
                    }
                }
                bufptr += sprintf(bufptr, "  ");
                for (i = 0; i < n; ++i) {
                    *bufptr++ = (Address[i] < 0x20 || Address[i] > 0x7f) ? '.' : Address[i];
                }
            }

            *bufptr++ = '\n';
            *bufptr = 0;
            AcslanDebugPrintString(dumpBuf);
            Length -= n;
            Address += n;
            ++iterations;
        }

        if (Options & DD_LINE_AFTER) {
            AcslanDebugPrintString("\n");
        }
    } except(1) {
        PUT(("*** Error: Bad Data @ %x, length %d ***\n", Address, Length));
    }
}

PRIVATE
VOID
DefaultParameterTableDump(
    IN  PVOID   Parameters
    )

/*++

Routine Description:

    Displays default message for CCBs which have parameter tables that don't
    have a dump routine yet

Arguments:

    Parameters  - pointer to parameter table

Return Value:

    None.

--*/

{
    PUT(("Parameter table dump not implemented for this CCB\n"));
}

PRIVATE
VOID
DumpParameterTableHeader(
    IN  LPSTR   CommandName,
    IN  PVOID   Table
    )

/*++

Routine Description:

    Displays header for parameter table dump

Arguments:

    CommandName - name of command which owns parameter table
    Table       - flat 32-bit address of parameter table

Return Value:

    None.

--*/

{
    PUT(("\n%s parameter table @ 0x%08x\n", CommandName, Table));
}

PRIVATE
VOID
DumpBufferCreateParms(
    IN PVOID Parameters
    )
{
    PLLC_BUFFER_CREATE_PARMS parms = (PLLC_BUFFER_CREATE_PARMS)Parameters;

    DumpParameterTableHeader("BUFFER.CREATE", Parameters);

    PUT(("Buf Pool Handle %08x\n"
        "Buf Pool Addr . %08x\n"
        "Buffer Size . . %08x\n"
        "Minimum Size. . %08x\n",
        parms->hBufferPool,
        parms->pBuffer,
        parms->cbBufferSize,
        parms->cbMinimumSizeThreshold
        ));
}

PRIVATE
VOID
DumpBufferFreeParms(
    IN  PVOID   Parameters
    )
{
    PLLC_BUFFER_FREE_PARMS parms = (PLLC_BUFFER_FREE_PARMS)Parameters;

    DumpParameterTableHeader("BUFFER.FREE", Parameters);

    PUT(("reserved. . . . %04x\n"
        "buffers left. . %04x\n"
        "reserved. . . . %02x %02x %02x %02x\n"
        "first buffer. . %08x\n",
        parms->usReserved1,
        parms->cBuffersLeft,
        ((PBYTE)&(parms->ulReserved))[0],
        ((PBYTE)&(parms->ulReserved))[1],
        ((PBYTE)&(parms->ulReserved))[2],
        ((PBYTE)&(parms->ulReserved))[3],
        parms->pFirstBuffer
        ));
}

PRIVATE
VOID
DumpBufferGetParms(
    IN  PVOID   Parameters
    )
{
    PLLC_BUFFER_GET_PARMS parms = (PLLC_BUFFER_GET_PARMS)Parameters;

    DumpParameterTableHeader("BUFFER.GET", Parameters);

    PUT(("reserved. . . . %04x\n"
        "buffers left. . %04x\n"
        "buffers to get. %04x\n"
        "buffer size . . %04x\n"
        "first buffer. . %08x\n",
        parms->usReserved1,
        parms->cBuffersLeft,
        parms->cBuffersToGet,
        parms->cbBufferSize,
        parms->pFirstBuffer
        ));
}

PRIVATE
VOID
DumpDirInitializeParms(
    IN  PVOID   Parameters
    )
{
    PLLC_DIR_INITIALIZE_PARMS parms = (PLLC_DIR_INITIALIZE_PARMS)Parameters;

    DumpParameterTableHeader("DIR.INITIALIZE", Parameters);

    PUT(("Bring Ups . . . %04x\n"
        "Reserved. . . . %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n"
        "                %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n"
        "                %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x\n",
        parms->usBringUps,
        parms->Reserved[ 0],
        parms->Reserved[ 1],
        parms->Reserved[ 2],
        parms->Reserved[ 3],
        parms->Reserved[ 4],
        parms->Reserved[ 5],
        parms->Reserved[ 6],
        parms->Reserved[ 7],
        parms->Reserved[ 8],
        parms->Reserved[ 9],
        parms->Reserved[10],
        parms->Reserved[11],
        parms->Reserved[12],
        parms->Reserved[13],
        parms->Reserved[14],
        parms->Reserved[15],
        parms->Reserved[16],
        parms->Reserved[17],
        parms->Reserved[18],
        parms->Reserved[19],
        parms->Reserved[20],
        parms->Reserved[21],
        parms->Reserved[22],
        parms->Reserved[23],
        parms->Reserved[24],
        parms->Reserved[25],
        parms->Reserved[26],
        parms->Reserved[27],
        parms->Reserved[28],
        parms->Reserved[29]
        ));
}

PRIVATE
VOID
DumpDirOpenAdapterParms(
    IN  PVOID   Parameters
    )
{
    PLLC_DIR_OPEN_ADAPTER_PARMS parms = (PLLC_DIR_OPEN_ADAPTER_PARMS)Parameters;
    PLLC_ADAPTER_OPEN_PARMS pAdapterParms = parms->pAdapterParms;
    PLLC_EXTENDED_ADAPTER_PARMS pExtendedParms = parms->pExtendedParms;
    PLLC_DLC_PARMS pDlcParms = parms->pDlcParms;

    DumpParameterTableHeader("DIR.OPEN.ADAPTER", Parameters);

    PUT(("adapter parms . %08x\n"
        "extended parms. %08x\n"
        "DLC parms . . . %08x\n"
        "reserved. . . . %08x\n",
        pAdapterParms,
        pExtendedParms,
        pDlcParms,
        parms->pReserved1
        ));

    if (pAdapterParms) {
        PUT(("\n"
            "Adapter Parms @ %08x\n"
            "open error. . . %04x\n"
            "open options. . %04x\n"
            "node address. . %02x-%02x-%02x-%02x-%02x-%02x\n"
            "group address . %08x\n"
            "func. address . %08x\n"
            "Reserved 1. . . %04x\n"
            "Reserved 2. . . %04x\n"
            "max frame size  %04x\n"
            "Reserved 3. . . %04x %04x %04x %04x\n"
            "bring ups . . . %04x\n"
            "init warnings . %04x\n"
            "Reserved 4. . . %04x %04x %04x\n",
            pAdapterParms,
            pAdapterParms->usOpenErrorCode,
            pAdapterParms->usOpenOptions,
            pAdapterParms->auchNodeAddress[0],
            pAdapterParms->auchNodeAddress[1],
            pAdapterParms->auchNodeAddress[2],
            pAdapterParms->auchNodeAddress[3],
            pAdapterParms->auchNodeAddress[4],
            pAdapterParms->auchNodeAddress[5],
            *(DWORD UNALIGNED *)(&pAdapterParms->auchGroupAddress),
            *(DWORD UNALIGNED *)(&pAdapterParms->auchFunctionalAddress),
            pAdapterParms->usReserved1,
            pAdapterParms->usReserved2,
            pAdapterParms->usMaxFrameSize,
            pAdapterParms->usReserved3[0],
            pAdapterParms->usReserved3[1],
            pAdapterParms->usReserved3[2],
            pAdapterParms->usReserved3[3],
            pAdapterParms->usBringUps,  // blooargh
            pAdapterParms->InitWarnings,
            pAdapterParms->usReserved4[0],
            pAdapterParms->usReserved4[1],
            pAdapterParms->usReserved4[2]
            ));
    }

    if (pExtendedParms) {
        PUT(("\n"
            "Extended Parms @ %08x\n"
            "hBufferPool . . %08x\n"
            "pSecurityDesc . %08x\n"
            "EthernetType. . %08x [%s]\n",
            pExtendedParms,
            pExtendedParms->hBufferPool,
            pExtendedParms->pSecurityDescriptor,
            pExtendedParms->LlcEthernetType,
            MapEthernetType(pExtendedParms->LlcEthernetType)
            ));
    }

    if (pDlcParms) {
        PUT(("\n"
            "DLC Parms @ %08x\n"
            "max SAPs. . . . %02x\n"
            "max links . . . %02x\n"
            "max group SAPs. %02x\n"
            "max group membs %02x\n"
            "T1 Tick 1 . . . %02x\n"
            "T2 Tick 1 . . . %02x\n"
            "Ti Tick 1 . . . %02x\n"
            "T1 Tick 2 . . . %02x\n"
            "T2 Tick 2 . . . %02x\n"
            "Ti Tick 2 . . . %02x\n",
            pDlcParms,
            pDlcParms->uchDlcMaxSaps,
            pDlcParms->uchDlcMaxStations,
            pDlcParms->uchDlcMaxGroupSaps,
            pDlcParms->uchDlcMaxGroupMembers,
            pDlcParms->uchT1_TickOne,
            pDlcParms->uchT2_TickOne,
            pDlcParms->uchTi_TickOne,
            pDlcParms->uchT1_TickTwo,
            pDlcParms->uchT2_TickTwo,
            pDlcParms->uchTi_TickTwo
            ));
    }
}

PRIVATE
LPSTR
MapEthernetType(
    IN LLC_ETHERNET_TYPE EthernetType
    )
{
    switch (EthernetType) {
    case LLC_ETHERNET_TYPE_DEFAULT:
        return "DEFAULT";

    case LLC_ETHERNET_TYPE_AUTO:
        return "AUTO";

    case LLC_ETHERNET_TYPE_802_3:
        return "802.3";

    case LLC_ETHERNET_TYPE_DIX:
        return "DIX";
    }
    return "*** Unknown Ethernet Type ***";
}

PRIVATE
VOID
DumpDirOpenDirectParms(
    IN PVOID Parameters
    )
{
    PLLC_DIR_OPEN_DIRECT_PARMS parms = (PLLC_DIR_OPEN_DIRECT_PARMS)Parameters;

    DumpParameterTableHeader("DIR.OPEN.DIRECT", Parameters);

    PUT(("reserved. . . . %04x %04x %04x %04x\n"
        "open options. . %04x\n"
        "ethernet type . %04x\n"
        "protocol mask . %08x\n"
        "protocol match. %08x\n"
        "protocol offset %04x\n",
        parms->Reserved[0],
        parms->Reserved[1],
        parms->Reserved[2],
        parms->Reserved[3],
        parms->usOpenOptions,
        parms->usEthernetType,
        parms->ulProtocolTypeMask,
        parms->ulProtocolTypeMatch,
        parms->usProtocolTypeOffset
        ));
}

PRIVATE
VOID
DumpDirReadLogParms(
    IN PVOID Parameters
    )
{
    PLLC_DIR_READ_LOG_PARMS parms = (PLLC_DIR_READ_LOG_PARMS)Parameters;

    DumpParameterTableHeader("DIR.READ.LOG", Parameters);

    PUT(("type id . . . . %04x [%s]\n"
        "log buf len . . %04x\n"
        "log buf ptr . . %08x\n"
        "act. log. len.. %04x\n",
        parms->usTypeId,
        MapLogType(parms->usTypeId),
        parms->cbLogBuffer,
        parms->pLogBuffer,
        parms->cbActualLength
        ));
}

PRIVATE
LPSTR
MapLogType(
    IN USHORT Type
    )
{
    switch (Type) {
    case 0:
        return "Adapter Error Log";

    case 1:
        return "Direct Interface Error Log";

    case 2:
        return "Adapter & Direct Interface Error Logs";
    }
    return "*** Unknown Log Type ***";
}

PRIVATE
VOID
DumpDirSetExceptionFlagsParms(
    IN PVOID Parameters
    )
{
    PLLC_DIR_SET_EFLAG_PARMS parms = (PLLC_DIR_SET_EFLAG_PARMS)Parameters;

    DumpParameterTableHeader("DIR.SET.EXCEPTION.FLAGS", Parameters);

    PUT(("Adapter Check Flag. %08x\n"
        "Network Status Flag %08x\n"
        "PC Error Flag . . . %08x\n"
        "System Action Flag. %08x\n",
        parms->ulAdapterCheckFlag,
        parms->ulNetworkStatusFlag,
        parms->ulPcErrorFlag,
        parms->ulSystemActionFlag
        ));
}

PRIVATE
VOID
DumpDirSetFunctionalAddressParms(
    IN PVOID Parameters
    )
{
    PUT(("Functional addr %08x\n", Parameters));
}

PRIVATE
VOID
DumpDirSetGroupAddressParms(
    IN PVOID Parameters
    )
{
    PUT(("Group addr. . . %08x\n", Parameters));
}

PRIVATE
VOID
DumpDirStatusParms(
    IN  PVOID   Parameters
    )
{
    PLLC_DIR_STATUS_PARMS parms = (PLLC_DIR_STATUS_PARMS)Parameters;

    DumpParameterTableHeader("DIR.STATUS", Parameters);

    PUT(("perm node addr. %02x-%02x-%02x-%02x-%02x-%02x\n"
        "local node addr %02x-%02x-%02x-%02x-%02x-%02x\n"
        "group addr. . . %08lx\n"
        "functional addr %08lx\n"
        "max SAPs. . . . %02x\n"
        "open SAPs . . . %02x\n"
        "max stations. . %02x\n"
        "open stations . %02x\n"
        "avail stations. %02x\n"
        "adapter config. %02x\n"
        "reserved 1. . . %02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x\n"
        "reserved 2. . . %08x\n"
        "reserved 3. . . %08x\n"
        "max frame len . %08x\n"
        "last NW status. %04x\n"
        "adapter type. . %04x [%s]\n",
        parms->auchPermanentAddress[0],
        parms->auchPermanentAddress[1],
        parms->auchPermanentAddress[2],
        parms->auchPermanentAddress[3],
        parms->auchPermanentAddress[4],
        parms->auchPermanentAddress[5],
        parms->auchNodeAddress[0],
        parms->auchNodeAddress[1],
        parms->auchNodeAddress[2],
        parms->auchNodeAddress[3],
        parms->auchNodeAddress[4],
        parms->auchNodeAddress[5],
        *(LPDWORD)(&parms->auchGroupAddress),
        *(LPDWORD)(&parms->auchFunctAddr),
        parms->uchMaxSap,
        parms->uchOpenSaps,
        parms->uchMaxStations,
        parms->uchOpenStation,
        parms->uchAvailStations,
        parms->uchAdapterConfig,
        parms->auchReserved1[0],
        parms->auchReserved1[1],
        parms->auchReserved1[2],
        parms->auchReserved1[3],
        parms->auchReserved1[4],
        parms->auchReserved1[5],
        parms->auchReserved1[6],
        parms->auchReserved1[7],
        parms->auchReserved1[8],
        parms->auchReserved1[9],
        parms->ulReserved1,
        parms->ulReserved2,
        parms->ulMaxFrameLength,
        parms->usLastNetworkStatus,
        parms->usAdapterType,
        MapAdapterType(parms->usAdapterType)
        ));
}

PRIVATE
LPSTR
MapAdapterType(
    IN USHORT AdapterType
    )
{
    switch (AdapterType) {
    case 0x0001:
        return "Token Ring Network PC Adapter";

    case 0x0002:
        return "Token Ring Network PC Adapter II";

    case 0x0004:
        return "Token Ring Network Adapter/A";

    case 0x0008:
        return "Token Ring Network PC Adapter II";

    case 0x0020:
        return "Token Ring Network 16/4 Adapter";

    case 0x0040:
        return "Token Ring Network 16/4 Adapter/A";

    case 0x0080:
        return "Token Ring Network Adapter/A";

    case 0x0100:
        return "Ethernet Adapter";

    case 0x4000:
        return "PC Network Adapter";

    case 0x8000:
        return "PC Network Adapter/A";
    }
    return "*** Unknown Adapter Type ***";
}

PRIVATE
VOID
DumpDirTimerCancelParms(
    IN PVOID Parameters
    )
{
    PUT(("timer addr. . . %08x\n", Parameters));
}

PRIVATE
VOID
DumpDirTimerCancelGroupParms(
    IN PVOID Parameters
    )
{
    PUT(("timer cmpl flag %08x\n", Parameters));
}

PRIVATE
VOID
DumpDirTimerSetParms(
    IN PVOID Parameters
    )
{
    PUT(("time value. . . %04x\n", HIWORD(Parameters)));
}

PRIVATE
VOID
DumpDlcCloseSapParms(
    IN PVOID Parameters
    )
{
    PUT(("station id      %04x\n"
        "reserved. . . . %02x %02x\n",
        HIWORD(Parameters),
        HIBYTE(LOWORD(Parameters)),
        LOBYTE(LOWORD(Parameters))
        ));
}

PRIVATE
VOID
DumpDlcCloseStationParms(
    IN PVOID Parameters
    )
{
    PUT(("station id. . . %04x\n"
        "reserved. . . . %02x %02x\n",
        HIWORD(Parameters),
        HIBYTE(LOWORD(Parameters)),
        LOBYTE(LOWORD(Parameters))
        ));
}

PRIVATE
VOID
DumpDlcConnectStationParms(
    IN  PVOID   Parameters
    )
{
    PLLC_DLC_CONNECT_PARMS parms = (PLLC_DLC_CONNECT_PARMS)Parameters;
    LPBYTE routing = parms->pRoutingInfo;
    int i, n;

    DumpParameterTableHeader("DLC.CONNECT.STATION", Parameters);

    PUT(("station id. . . %04x\n"
        "reserved. . . . %04x\n"
        "routing addr. . %08x [",
        parms->usStationId,
        parms->usReserved,
        routing
        ));
    if (routing) {
        n = (int)(routing[0] & 0x1f);
        for (i=0; i<n-1; ++i) {
            PUT(("%02x ", routing[i]));
        }
        PUT(("%02x", routing[i]));
    }
    PUT(("]\n"));
    if (routing) {
        char broadcastIndicators = routing[0] & 0xe0;
        char length = routing[0] & 0x1f;
        char direction = routing[1] & 0x80;
        char largestFrame = routing[1] & 0x70;
        PUT(("Routing Info Description: "));
        if ((broadcastIndicators & 0x80) == 0) {
            PUT(("Non Broadcast "));
        } else if ((broadcastIndicators & 0xc0) == 0x80) {
            PUT(("All Routes Broadcast "));
        } else if ((broadcastIndicators & 0xc0) == 0xc0) {
            PUT(("Single Route Broadcast "));
        }
        PUT(("Length = %d ", length));
        if (direction) {
            PUT(("interpret right-to-left "));
        } else {
            PUT(("interpret left-to-right "));
        }
        switch (largestFrame) {
        case 0x00:
            PUT(("<= 516 bytes in I-field "));
            break;

        case 0x10:
            PUT(("<= 1500 bytes in I-field "));
            break;

        case 0x20:
            PUT(("<= 2052 bytes in I-field "));
            break;

        case 0x30:
            PUT(("<= 4472 bytes in I-field "));
            break;

        case 0x40:
            PUT(("<= 8144 bytes in I-field "));
            break;

        case 0x50:
            PUT(("<= 11407 bytes in I-field "));
            break;

        case 0x60:
            PUT(("<= 17800 bytes in I-field "));
            break;

        case 0x70:
            PUT(("All-Routes Broadcast Frame "));
            break;

        }
        PUT(("\n"));
    }
}

PRIVATE
VOID
DumpDlcFlowControlParms(
    IN PVOID Parameters
    )
{
    PUT(("station id. . . %04x\n"
        "flow control. . %02x [%s]\n",
        HIWORD(Parameters),
        HIBYTE(LOWORD(Parameters)),
        MapFlowControl(HIBYTE(LOWORD(Parameters)))
        ));
}

PRIVATE
LPSTR
MapFlowControl(
    IN BYTE FlowControl
    )
{
    if (FlowControl & 0x80) {
        if (FlowControl & 0x40) {
            return "RESET LOCAL BUSY - BUFFER";
        } else {
            return "RESET LOCAL BUSY - USER";
        }
    } else {
        return "Enter LOCAL BUSY state";
    }
}

PRIVATE
VOID
DumpDlcModifyParms(
    IN PVOID Parameters
    )
{
    PLLC_DLC_MODIFY_PARMS parms = (PLLC_DLC_MODIFY_PARMS)Parameters;

    DumpParameterTableHeader("DLC.MODIFY", Parameters);

    PUT(("reserved. . . . %04x\n"
        "station id. . . %04x\n"
        "timer T1. . . . %02x\n"
        "timer T2. . . . %02x\n"
        "timer Ti. . . . %02x\n"
        "maxout. . . . . %02x\n"
        "maxin . . . . . %02x\n"
        "maxout incr . . %02x\n"
        "max retry count %02x\n"
        "reserved. . . . %02x\n"
        "max info field. %02x\n"
        "access priority %02x\n"
        "reserved. . . . %02x %02x %02x %02x\n"
        "group count . . %02x\n"
        "group list. . . %08x ",
        parms->usRes,
        parms->usStationId,
        parms->uchT1,
        parms->uchT2,
        parms->uchTi,
        parms->uchMaxOut,
        parms->uchMaxIn,
        parms->uchMaxOutIncr,
        parms->uchMaxRetryCnt,
        parms->uchReserved1,
        parms->usMaxInfoFieldLength,
        parms->uchAccessPriority,
        parms->auchReserved3[0],
        parms->auchReserved3[1],
        parms->auchReserved3[2],
        parms->auchReserved3[3],
        parms->cGroupCount,
        parms->pGroupList
        ));

    if (parms->pGroupList) {
        DumpData(NULL,
                 parms->pGroupList,
                 parms->cGroupCount,
                 DD_NO_ADDRESS | DD_NO_ASCII | DD_UPPER_CASE,
                 DEFAULT_FIELD_WIDTH + 8 + 1
                 );
    }

    PUT(("\n"));
}

PRIVATE
VOID
DumpDlcOpenSapParms(
    IN  PVOID   Parameters
    )
{
    PLLC_DLC_OPEN_SAP_PARMS parms = (PLLC_DLC_OPEN_SAP_PARMS)Parameters;

    DumpParameterTableHeader("DLC.OPEN.SAP", Parameters);

    PUT(("station id. . . %04x\n"
        "user stat . . . %04x\n"
        "T1. . . . . . . %02x\n"
        "T2. . . . . . . %02x\n"
        "Ti. . . . . . . %02x\n"
        "max out . . . . %02x\n"
        "max in  . . . . %02x\n"
        "max out incr. . %02x\n"
        "max retry count %02x\n"
        "max members . . %02x\n"
        "max I field . . %04x\n"
        "SAP value . . . %02x\n"
        "options/pri . . %02x\n"
        "link count. . . %02x\n"
        "reserved. . . . %02x %02x\n"
        "group count . . %02x\n"
        "group list. . . %08x\n"
        "status flags. . %08x\n"
        "reserved. . . . %02x %02x %02x %02x %02x %02x %02x %02x\n"
        "links available %02x\n",
        parms->usStationId,
        parms->usUserStatValue,
        parms->uchT1,
        parms->uchT2,
        parms->uchTi,
        parms->uchMaxOut,
        parms->uchMaxIn,
        parms->uchMaxOutI