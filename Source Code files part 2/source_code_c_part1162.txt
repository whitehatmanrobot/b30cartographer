int)( "Couldn't read Dacl at 0x%x\n", pSD->Dacl );
        return;
    }

    (*pfnPrint)( "  Dacl at 0x%x\n", pSD->Dacl );

    (void) GetComputerNameW( ComputerName, &cchComputer );

    for ( USHORT Index = 0; Index < pDacl->AceCount; Index++ )
    {
        if ( ! GetAce( pDacl, Index, (void **) &pAce ) )
            break;

        if ( (pAce->Header.AceType != ACCESS_ALLOWED_ACE_TYPE) &&
             (pAce->Header.AceType != ACCESS_DENIED_ACE_TYPE) )
            continue;
        cchAccount = ACCT_DOM_NAME_SIZE;
        cchDomain  = ACCT_DOM_NAME_SIZE;

        bStatus = LookupAccountSidW(
                    NULL,
                    (PSID)&pAce->SidStart,
                    AccountName,
                    &cchAccount,
                    DomainName,
                    &cchDomain,
                    &SidNameType );

        (*pfnPrint)( "    ACE %d ", Index );
        if ( bStatus )
        {
            if ( DomainName[0] != 0 )
            {
                if ( lstrcmpiW( DomainName, L"BUILTIN" ) != 0 )
                    (*pfnPrint)( "%s\\", DomainName );
                else
                    (*pfnPrint)( "%s\\", ComputerName );
            }
            (*pfnPrint)( "%s ", AccountName );
        }
        else
        {
            (*pfnPrint)( "[couldn't get account name] " );
        }

        if ( ACCESS_ALLOWED_ACE_TYPE == pAce->Header.AceType )
            (*pfnPrint)( "Allowed " );
        else
            (*pfnPrint)( "Denied " );

        if ( pAce->Mask & COM_RIGHTS_EXECUTE )
            (*pfnPrint)( "DCOM Launch\n" );
        else
            (*pfnPrint)( "ACCESS_MASK 0x%x (ntseapi.h)", pAce->Mask );
    }

    Free( pDacl );
}

void
DumpClsid(
    PNTSD_EXTENSION_APIS    pExtApis,
    HANDLE                  hProcess,
    CClsidData *            pClsidData
    )
{
    PNTSD_OUTPUT_ROUTINE    pfnPrint;
    CAppidData *            pAppidData = NULL;
    WCHAR                   String[256];
    BOOL                    bStatus;

    pfnPrint = pExtApis->lpOutputRoutine;

    (*pfnPrint)( "  " );
    DumpGuid( pExtApis, pClsidData->_Clsid );
    (*pfnPrint)( "\n" );
    (*pfnPrint)( "  _pAppid 0x%x\n", pClsidData->_pAppid );
    (*pfnPrint)( "  _pToken 0x%x\n", pClsidData->_pToken );
    (*pfnPrint)( "  _ServerType %d ", pClsidData->_ServerType );
    switch ( pClsidData->_ServerType )
    {
    case SERVERTYPE_EXE32 :
        (*pfnPrint)( "LocalServer32\n" );
        break;
    case SERVERTYPE_SERVICE :
        (*pfnPrint)( "Service\n" );
        break;
    case SERVERTYPE_SURROGATE :
        (*pfnPrint)( "DLL in Surrogate\n" );
        break;
    case SERVERTYPE_EXE16 :
        (*pfnPrint)( "LocalServer (16bit)\n" );
        break;
    }

    (*pfnPrint)( "  _pwszServer 0x%x", pClsidData->_pwszServer );
    bStatus = ReadMemory( pExtApis, hProcess, (DWORD_PTR)pClsidData->_pwszServer, (void *)String, sizeof(String) );
    if ( bStatus )
        pfnPrint( " %S", String );
    (*pfnPrint)( "\n" );

    (*pfnPrint)( "  _pwszDarwinId 0x%x", pClsidData->_pwszDarwinId );
    bStatus = ReadMemory( pExtApis, hProcess, (DWORD_PTR)pClsidData->_pwszDarwinId, (void *)String, sizeof(String) );
    if ( bStatus )
        pfnPrint( " %S", String );
    (*pfnPrint)( "\n" );

    pAppidData = 0;

    if ( pClsidData->_pAppid )
    {
        pAppidData = (CAppidData *) Alloc( sizeof(CAppidData) );

        bStatus = ReadMemory( pExtApis, hProcess, (DWORD_PTR)pClsidData->_pAppid, (void *)pAppidData, sizeof(CAppidData) );

        if ( ! bStatus )
            (*pfnPrint)( "Error trying to read CAppidData at 0x%x\n", pClsidData->_pAppid );
    }

    if ( ! pAppidData )
    {
        (*pfnPrint)( "\n" );
        return;
    }

    (*pfnPrint)( "  _wszAppid %S\n", pAppidData->_wszAppid );
    (*pfnPrint)( "  _bActivateAtStorage %s\n", pAppidData->_bActivateAtStorage ? "TRUE" : "FALSE" );

    (*pfnPrint)( "  _pwszService 0x%x", pAppidData->_pwszService );
    bStatus = ReadMemory( pExtApis, hProcess, (DWORD_PTR)pAppidData->_pwszService, (void *)String, sizeof(String) );
    if ( bStatus )
        pfnPrint( " %S", String );
    (*pfnPrint)( "\n" );

    (*pfnPrint)( "  _pwszServiceParameters 0x%x", pAppidData->_pwszServiceParameters );
    bStatus = ReadMemory( pExtApis, hProcess, (DWORD_PTR)pAppidData->_pwszServiceParameters, (void *)String, sizeof(String) );
    if ( bStatus )
        pfnPrint( " %S", String );
    (*pfnPrint)( "\n" );

    (*pfnPrint)( "  _pwszRunAsUser 0x%x", pAppidData->_pwszRunAsUser );
    bStatus = ReadMemory( pExtApis, hProcess, (DWORD_PTR)pAppidData->_pwszRunAsUser, (void *)String, sizeof(String) );
    if ( bStatus )
        pfnPrint( " %S", String );
    (*pfnPrint)( "\n" );

    (*pfnPrint)( "  _pwszRunAsDomain 0x%x", pAppidData->_pwszRunAsDomain );
    bStatus = ReadMemory( pExtApis, hProcess, (DWORD_PTR)pAppidData->_pwszRunAsDomain, (void *)String, sizeof(String) );
    if ( bStatus )
        pfnPrint( " %S", String );
    (*pfnPrint)( "\n" );

    (*pfnPrint)( "  _pwszRemoteServerNames 0x%x", pAppidData->_pwszRemoteServerNames );
    bStatus = ReadMemory( pExtApis, hProcess, (DWORD_PTR)pAppidData->_pwszRemoteServerNames, (void *)String, sizeof(String) );
    if ( bStatus )
        pfnPrint( " %S", String );
    (*pfnPrint)( "\n" );

    (*pfnPrint)( "  _pLaunchPermission 0x%x (use .sd to display)\n", pAppidData->_pLaunchPermission );
    (*pfnPrint)( "\n" );

    Free( pAppidData );
}

void
DumpSurrogates(
    PNTSD_EXTENSION_APIS    pExtApis,
    HANDLE                  hProcess
    )
{
    PNTSD_OUTPUT_ROUTINE    pfnPrint;
    CSurrogateList *        pSurrogateList = NULL;
    CSurrogateListEntry *   pEntry = NULL;
    WCHAR                   String[256];
    DWORD_PTR               Address;
    GUID                    Guid;
    BOOL                    bStatus;

    pfnPrint = pExtApis->lpOutputRoutine;

    // Gives us the address of gpSurrogateList.
    Address = (*pExtApis->lpGetExpressionRoutine)( "rpcss!gpSurrogateList" );

    if ( ! Address )
        return;

    pSurrogateList = (CSurrogateList *) Alloc( sizeof(CSurrogateList) );

    bStatus = ReadMemory( pExtApis, hProcess, Address, (void *)&Address, sizeof(DWORD) );
    if ( bStatus )
        bStatus = ReadMemory( pExtApis, hProcess, Address, (void *)pSurrogateList, sizeof(CSurrogateList) );

    if ( ! bStatus )
        return;

    (*pfnPrint)( "  gpSurrogateList at 0x%x\n\n", Address );

    for(pEntry = (CSurrogateListEntry *) pSurrogateList->First();
        pEntry;)
    {
       (*pfnPrint)( "  CSurrogateListEntry at 0x%x\n\n", pEntry );
       (*pfnPrint)( "  SurrogateListEntry at 0x%x\n\n", pEntry );
       (*pfnPrint)( "    _pServerListEntry 0x%x\n", pEntry->_pServerListEntry );

       bStatus = DumpServerListEntry( pExtApis, hProcess, (DWORD_PTR)pEntry->_pServerListEntry);
       if(!bStatus)
           break;

       // Read the next list element
       Address = (DWORD_PTR)pEntry;
       pEntry = (CSurrogateListEntry *) Alloc( sizeof(CSurrogateListEntry) );
       bStatus = ReadMemory( pExtApis, hProcess, Address, (void *)pEntry, sizeof(CSurrogateListEntry) );
       if(!bStatus)
           break;
       pEntry = (CSurrogateListEntry *) pEntry->Next();
    }
}

void
DumpServers(
    PNTSD_EXTENSION_APIS    pExtApis,
    HANDLE                  hProcess,
    CHAR *                  pszServerTable
    )
{
    PNTSD_OUTPUT_ROUTINE    pfnPrint;
    CServerTable *          pServerTable = NULL;
    CServerTableEntry *     pServerTableEntry = NULL;
    CServerListEntry *      pServerListEntry = NULL;
    CHAR                    String[256];
    DWORD_PTR               Address;
    GUID                    Guid;
    BOOL                    bStatus;

    pfnPrint = pExtApis->lpOutputRoutine;

    lstrcpy(String, "rpcss!");
    lstrcat(String,pszServerTable);
    // Gives us the address of gpProcessTable or gpClassTable.
    Address = (*pExtApis->lpGetExpressionRoutine)( String );

    if ( ! Address )
    {
	    (*pfnPrint)("Could not get address for %s\n", pszServerTable);
        return;
    }

    pServerTable = (CServerTable *) Alloc( sizeof(CServerTable) );

    // Get address of the actual table
    bStatus = ReadMemory( pExtApis, hProcess, Address, (void *)&Address, sizeof(DWORD) );
    if ( bStatus )
        bStatus = ReadMemory( pExtApis, hProcess, Address, (void *)pServerTable, sizeof(CServerTable) );

    if ( ! bStatus )
        return;

    (*pfnPrint)( "  %s at 0x%x\n\n", pszServerTable, Address );
    (*pfnPrint)( "  CHashTable::_cBuckets %d\n", pServerTable->_cBuckets );
    (*pfnPrint)( "  CHashTable::_cElements %d\n\n", pServerTable->_cElements );

    if ( 0 == pServerTable->_cElements ) // nothing to show, table is empty
        return;

    Address = (DWORD_PTR) pServerTable->_buckets;
    pServerTable->_buckets = (CTableElement **) Alloc( pServerTable->_cBuckets * sizeof(CTableElement *) );

    bStatus = ReadMemory(
                    pExtApis,
                    hProcess,
                    Address,
                    (void *)pServerTable->_buckets,
                    pServerTable->_cBuckets * sizeof(CTableElement *) );

    if ( ! bStatus )
        return;

    for ( DWORD n = 0; n < pServerTable->_cBuckets; n++ )
    {
        for ( DWORD_PTR ClassAddress = (DWORD_PTR) pServerTable->_buckets[n];
              ClassAddress;
              ClassAddress = (DWORD_PTR) pServerTableEntry->_pnext )
        {
            pServerTableEntry = (CServerTableEntry *) Alloc( sizeof(CServerTableEntry) );

            bStatus = ReadMemory(
                            pExtApis,
                            hProcess,
                            ClassAddress,
                            (void *)pServerTableEntry,
                            sizeof(CServerTableEntry) );

            (*pfnPrint)( "  CServerTableEntry 0x%x ", ClassAddress );

            if ( ! bStatus )
            {
                (*pfnPrint)( "[couldn't read address]\n" );
                break;
            }

            ((ID UNALIGNED *)&Guid)[0] = pServerTableEntry->_id;
            ((ID UNALIGNED *)&Guid)[1] = pServerTableEntry->_id2;
            DumpGuid( pExtApis, Guid );
            (*pfnPrint)( "\n    _references            %d", pServerTableEntry->_references );
            (*pfnPrint)( "\n    _EntryType             ");
            switch(pServerTableEntry->_EntryType)
            {
            case ENTRY_TYPE_CLASS:  (*pfnPrint)("ENTRY_TYPE_CLASS");  break;
            case ENTRY_TYPE_PROCESS:  (*pfnPrint)("ENTRY_TYPE_PROCESS");  break;
            default: 
              (*pfnPrint)(" !ERROR! Unknown server entry type!");
              break;
            }
            (*pfnPrint)( "\n    _pParentTableLock      0x%x", pServerTableEntry->_pParentTableLock );
            (*pfnPrint)( "\n    _pParentTable          0x%x", pServerTableEntry->_pParentTable );
            (*pfnPrint)( "\n    _dwProcessId           0x%x (%d)", pServerTableEntry->_dwProcessId, pServerTableEntry->_dwProcessId );
            (*pfnPrint)( "\n    _pProcess              0x%x",      pServerTableEntry->_pProcess );
            (*pfnPrint)( "\n    _pvRunAsHandle         0x%x", pServerTableEntry->_pvRunAsHandle );
            (*pfnPrint)( "\n    _bSuspendedClsid       0x%x", pServerTableEntry->_bSuspendedClsid );
            (*pfnPrint)( "\n    _bSuspendedApplication 0x%x", pServerTableEntry->_bSuspendedApplication );
            (*pfnPrint)( "\n");
            (*pfnPrint)( "    _ServerList :\n" );

            // Allocate enough space to hold a single CServerListEntry
            pServerListEntry = (CServerListEntry*) alloca(sizeof(CServerListEntry));
            if (!pServerListEntry)
                return;

            DWORD_PTR ServerAddress = 0;
            ServerAddress = (DWORD_PTR) (CServerListEntry *)pServerTableEntry->_ServerList._first;						
			while (ServerAddress)
			{					
                bStatus = DumpServerListEntry(pExtApis, hProcess, ServerAddress);
                if(!bStatus)
					break;
								
				// Walk to the next list element:
				bStatus = ReadMemory(
									 pExtApis,
									 hProcess,
									 ServerAddress,
									 (void*)pServerListEntry,
									 sizeof(CServerListEntry));
				if (!bStatus)
				    break;

				ServerAddress = (DWORD_PTR)(CServerListEntry*)pServerListEntry->_flink;
			}						
            (*pfnPrint)( "\n" );
        } // for class table entries in bucket
    } // for class table buckets
}

DWORD
DumpServerListEntry(
    PNTSD_EXTENSION_APIS    pExtApis,
    HANDLE                  hProcess,
    DWORD_PTR               ServerAddress
    )
{
    PNTSD_OUTPUT_ROUTINE    pfnPrint;
    CServerListEntry *      pServerListEntry = NULL;
    BOOL                    bStatus;

    pfnPrint = pExtApis->lpOutputRoutine;


    pServerListEntry = (CServerListEntry *) Alloc( sizeof(CServerListEntry) );

    bStatus = ReadMemory(
                    pExtApis,
                    hProcess,
                    ServerAddress,
                    (void *)pServerListEntry,
                    sizeof(CServerListEntry) );

    (*pfnPrint)( "    CServerListEntry 0x%x ", ServerAddress );

    if ( ! bStatus )
    {
        (*pfnPrint)( "[couldn't read address]\n" );
        return bStatus;
    }

    (*pfnPrint)( "\n" );
    (*pfnPrint)( "\t_references        %d\n", pServerListEntry->_references );
    (*pfnPrint)( "\t_pServerTableEntry 0x%x\n", pServerListEntry->_pServerTableEntry );
    (*pfnPrint)( "\t_pServerProcess    0x%x\n", pServerListEntry->_pServerProcess );
    (*pfnPrint)( "\t_hRpc              0x%x\n", pServerListEntry->_hRpc );
    (*pfnPrint)( "\t_hRpcAnonymous     0x%x\n", pServerListEntry->_hRpcAnonymous );
    (*pfnPrint)( "\t_ipid              0x%x\n", pServerListEntry->_ipid );
    (*pfnPrint)( "\t_Context           %d  ", pServerListEntry->_Context );
    switch ( pServerListEntry->_Context )
    {
    case SERVER_ACTIVATOR :
        (*pfnPrint)( "Activator\n" );
        break;
    case SERVER_SERVICE :
        (*pfnPrint)( "Service\n" );
        break;
    case SERVER_RUNAS :
        (*pfnPrint)( "RunAs\n" );
        break;
    default :
        (*pfnPrint)( "\n" );
    }
    (*pfnPrint)( "\t_State             0x%x ", pServerListEntry->_State );
    if ( pServerListEntry->_State & SERVERSTATE_SUSPENDED )
        (*pfnPrint)( "Suspended " );
    else
        (*pfnPrint)( "Running " );
    if ( pServerListEntry->_State & SERVERSTATE_SINGLEUSE )
        (*pfnPrint)( "SingleUse " );
    if ( pServerListEntry->_State & SERVERSTATE_SURROGATE )
        (*pfnPrint)( "Surrogate " );
    (*pfnPrint)( "\n" );
    (*pfnPrint)( "\t_NumCalls          %d\n", pServerListEntry->_NumCalls );
    (*pfnPrint)( "\t_RegistrationKey   0x%x\n", pServerListEntry->_RegistrationKey );
    (*pfnPrint)( "\t_lThreadToken      0x%x\n", pServerListEntry->_lThreadToken );

    return bStatus;
}

void
DumpProcess(
    PNTSD_EXTENSION_APIS    pExtApis,
    HANDLE                  hProcess,
    CProcess *              pProcess,
    char*                   pszProcessAddr
    )
{
    PNTSD_OUTPUT_ROUTINE    pfnPrint;
    CToken *                pToken;
    CClassReg *             pClassReg = NULL;
    WCHAR                   String[256];
    DWORD                   TokenSize;
    DWORD_PTR               ClassRegAddr;
    BOOL                    bStatus;
    DWORD                   i;
    DWORD                   dwProcessAddr;

    pfnPrint = pExtApis->lpOutputRoutine;

    dwProcessAddr = strtol(pszProcessAddr, NULL, 16);

    (*pfnPrint)( "  _cClientReferences   %d\n", pProcess->_cClientReferences );

    pToken = 0;

    if ( pProcess->_pToken )
    {
        TokenSize = sizeof(CToken);
        pToken = (CToken *) Alloc( TokenSize );
        bStatus = ReadMemory( pExtApis, hProcess, (DWORD_PTR)pProcess->_pToken, (void *)pToken, TokenSize );

        if ( bStatus )
        {
            TokenSize += (pToken->_sid.SubAuthorityCount - 1) * sizeof(ULONG);
            Free( pToken );
            pToken = (CToken *) Alloc( TokenSize );

            bStatus = ReadMemory( pExtApis, hProcess, (DWORD_PTR)pProcess->_pToken, (void *)pToken, TokenSize );
        }
    }

    (*pfnPrint)( "  _pToken              0x%x\n", pProcess->_pToken );
    DumpToken( pExtApis, hProcess, pToken );
    Free( pToken );

    (*pfnPrint)( "  _pwszWinstaDesktop   0x%x", pProcess->_pwszWinstaDesktop );
    bStatus = ReadMemory( pExtApis, hProcess, (DWORD_PTR)pProcess->_pwszWinstaDesktop, (void *)String, sizeof(String) );
    if ( bStatus )
        pfnPrint( " %S", String );
    (*pfnPrint)( "\n" );
		(*pfnPrint)( "  _hProcess            0x%x\n", pProcess->_hProcess);
		(*pfnPrint)( "  _fCacheFree          0x%x\n", pProcess->_fCacheFree);
		(*pfnPrint)( "  _pdsaLocalBindings   0x%x", pProcess->_pdsaLocalBindings);
		if (pProcess->_pdsaLocalBindings)
		{
			(*pfnPrint)("  (\"!rpcssext.dsa 0x%x\" to see contents)", pProcess->_pdsaLocalBindings);
		}
		(*pfnPrint)("\n");
		(*pfnPrint)( "  _pdsaRemoteBindings  0x%x", pProcess->_pdsaRemoteBindings);
		if (pProcess->_pdsaRemoteBindings)
		{
			(*pfnPrint)("  (run \"!rpcssext.dsa 0x%x\" to see contents)", pProcess->_pdsaRemoteBindings);
		}
		(*pfnPrint)("\n");
		
		// Dump list of oxids
		(*pfnPrint)("  _blistOxids (_ulcElements=0x%x, _ulmaxData=0x%x) (\"!rpcssext.blsoxids 0x%x\" to dump list contents)\n",
								pProcess->_blistOxids._ulcElements,
								pProcess->_blistOxids._ulmaxData,
								dwProcessAddr + offsetof(CProcess, _blistOxids) );

		// UNDONE _blistOids
		//CClientOid** ppoids = (CClientOid**)alloca(pProcess->_blist

		(*pfnPrint)( "  _pScmProcessReg      0x%x\n", pProcess->_pScmProcessReg);
		if (pProcess->_pScmProcessReg)
		{
			ScmProcessReg spr;
			bStatus = ReadMemory( pExtApis, hProcess, (DWORD_PTR)pProcess->_pScmProcessReg, (void*)&spr, sizeof(ScmProcessReg));
			if (bStatus)
			{
				(*pfnPrint)( "     _pScmProcessReg->ProcessGuid ");
				DumpGuid(pExtApis, spr.ProcessGUID);
				(*pfnPrint)( "\n");
				(*pfnPrint)( "     _pScmProcessReg->RegistrationToken 0x%x\n", spr.RegistrationToken);
				(*pfnPrint)( "     _pScmProcessReg->ReadinessStatus 0x%x\n", spr.ReadinessStatus);
				(*pfnPrint)( "     _pScmProcessReg->TimeOfLastPing._Time 0x%x\n", spr.TimeOfLastPing._Time);
			}
		}
		(*pfnPrint)( "  _fLockValid          0x%x\n", pProcess->_fLockValid);
		(*pfnPrint)( "  _fReadCustomProtseqs 0x%x\n", pProcess->_fReadCustomProtseqs);
		(*pfnPrint)( "  _pdsaCustomProtseqs  0x%x", pProcess->_pdsaCustomProtseqs);
		if (pProcess->_pdsaCustomProtseqs)
		{
			(*pfnPrint)("  (run \"!rpcssext.dsa 0x%x\" to see contents)", pProcess->_pdsaCustomProtseqs);
		}
		(*pfnPrint)("\n");
		(*pfnPrint)( "  _pvRunAsHandle       0x%x\n", pProcess->_pvRunAsHandle);
    (*pfnPrint)( "  _listClasses\n" );

    ClassRegAddr = (DWORD_PTR) pProcess->_listClasses._first;

    if ( ! ClassRegAddr )
        (*pfnPrint)( "    (empty)\n" );

    while ( ClassRegAddr )
    {
        pClassReg = (CClassReg *) Alloc( sizeof( CClassReg ) );
        if (pClassReg)
        {
            bStatus = ReadMemory( pExtApis, hProcess, ClassRegAddr, (void *)pClassReg, sizeof( CClassReg ) );

            (*pfnPrint)( "    _Guid = " );
            DumpGuid( pExtApis, pClassReg->_Guid );
            (*pfnPrint)( " _Reg = %d\n", pClassReg->_Reg );

            ClassRegAddr = (DWORD_PTR) pClassReg->_flink;
        }
    }

    (*pfnPrint)( "  _procID =            %d\n", pProcess->_procID );
    (*pfnPrint)( "  _hProcHandle =       0x%x\n", pProcess->_hProcHandle );
    (*pfnPrint)( "  _dwFlags =           0x%x (", pProcess->_dwFlags);

    if (pProcess->_dwFlags & PROCESS_SUSPENDED)
      (*pfnPrint)(" PROCESS_SUSPENDED");

    if (pProcess->_dwFlags & PROCESS_RETIRED)
      (*pfnPrint)(" PROCESS_RETIRED");

    if (pProcess->_dwFlags & PROCESS_SPI_DIRTY)
      (*pfnPrint)(" PROCESS_SPI_DIRTY");

    if (pProcess->_dwFlags & PROCESS_RUNDOWN)
      (*pfnPrint)(" PROCESS_RUNDOWN");

    if (pProcess->_dwFlags & PROCESS_PAUSED)
      (*pfnPrint)(" PROCESS_PAUSED");

    (*pfnPrint)(" )\n");
      
    (*pfnPrint)( "  _ftCreated =         0x%I64x", pProcess->_ftCreated );
    SYSTEMTIME systime;

    // The scm records the current UTC time when a process starts up; we convert it here
    // to local time for easier readibility.
    FILETIME ftLocal;
    if (FileTimeToLocalFileTime(&(pProcess->_ftCreated), &ftLocal))
    {
      if (FileTimeToSystemTime(&ftLocal, &systime))
      {
        (*pfnPrint)( " (created at %d:%d:%d on %d/%d/%d)",
                       systime.wHour,
                       systime.wMinute,
                       systime.wSecond,            
                       systime.wMonth,
                       systime.wDay,
                       systime.wYear);
      }
    }
    (*pfnPrint)( "\n" );
    (*pfnPrint)( "\n" );
}

void 
DumpBListOxids(
    PNTSD_EXTENSION_APIS    pExtApis,
    HANDLE                  hProcess,
		CBList*                 plist
    )
{
    PNTSD_OUTPUT_ROUTINE    pfnPrint;
    pfnPrint = pExtApis->lpOutputRoutine;
		(*pfnPrint)("undone\n");	
}

void
DumpToken(
    PNTSD_EXTENSION_APIS    pExtApis,
    HANDLE                  hProcess,
    CToken *                pToken
    )
{
    PNTSD_OUTPUT_ROUTINE    pfnPrint;
    SID_NAME_USE            SidNameUse;
    UNICODE_STRING          UnicodeString;
    char                    UserName[32];
    char                    DomainName[32];
    DWORD                   UserNameSize;
    DWORD                   DomainNameSize;
    BOOL                    bStatus;

    pfnPrint = pExtApis->lpOutputRoutine;

    (*pfnPrint)( "    _luid %d %d\n", pToken->_luid.LowPart, pToken->_luid.HighPart );

    UnicodeString.Length = UnicodeString.MaximumLength = 0;
    UnicodeString.Buffer = 0;

    (void) RtlConvertSidToUnicodeString(
                    &UnicodeString,
                    &pToken->_sid,
                    (BOOLEAN)TRUE // Allocate
                    );

    (*pfnPrint)( "    _sid %S", UnicodeString.Buffer );
    RtlFreeUnicodeString( &UnicodeString );

    UserNameSize = sizeof(UserName) / sizeof(char);
    DomainNameSize = sizeof(DomainName) / sizeof(char);

    bStatus = LookupAccountSid(
                    NULL,
                    &pToken->_sid,
                    UserName,
                    &UserNameSize,
                    DomainName,
                    &DomainNameSize,
                    &SidNameUse );

    if ( bStatus )
        (*pfnPrint)( " (%s\\%s)", DomainName, UserName );

    (*pfnPrint)( "\n" );
}

void
DumpRemoteList(
    PNTSD_EXTENSION_APIS    pExtApis,
    HANDLE                  hProcess
    )
{
    PNTSD_OUTPUT_ROUTINE    pfnPrint;
    CRemoteMachineList *    pMachineList = NULL;
    CRemoteMachine *        pRemoteMachine = NULL;
    CMachineBinding *       pBindEntry;
    WCHAR                   String[256];
    DWORD_PTR               Address;
    GUID                    Guid;
    BOOL                    bStatus;

    pfnPrint = pExtApis->lpOutputRoutine;

    // Gives us the address of gpRemoteMachineList.
    Address = (*pExtApis->lpGetExpressionRoutine)( "rpcss!gpRemoteMachineList" );

    if ( ! Address )
        return;

    pMachineList = (CRemoteMachineList *) Alloc( sizeof(CRemoteMachineList) );

    bStatus = ReadMemory( pExtApis, hProcess, Address, (void *)&Address, sizeof(DWORD) );
    if ( bStatus )
        bStatus = ReadMemory( pExtApis, hProcess, Address, (void *)pMachineList, sizeof(CRemoteMachineList) );

    if ( ! bStatus )
        return;

    (*pfnPrint)( "  gpRemoteMachineList at 0x%x\n", Address );

    for ( DWORD_PTR MachineAddress = (DWORD_PTR) (CRemoteMachine *)pMachineList->_first;
          MachineAddress;
          MachineAddress = (DWORD_PTR) (CRemoteMachine *)pRemoteMachine->_flink )
    {
        pRemoteMachine = (CRemoteMachine *) Alloc( sizeof(CRemoteMachine) );

        bStatus = ReadMemory(
                        pExtApis,
                        hProcess,
                        MachineAddress,
                        (void *)pRemoteMachine,
                        sizeof(CRemoteMachine) );

        (*pfnPrint)( "\n    CRemoteMachine 0x%x ", MachineAddress );

        if ( ! bStatus )
        {
            (*pfnPrint)( "[couldn't read address]\n" );
            break;
        }

        bStatus = ReadMemory( pExtApis, hProcess, (DWORD_PTR)pRemoteMachine->_pwszMachine, (void *)String, sizeof(String) );
        if ( bStatus )
            pfnPrint( "%S", String );
        (*pfnPrint)( "\n" );

        for ( DWORD_PTR BindAddress = (DWORD_PTR) (CMachineBinding *)pRemoteMachine->_BindingList._first;
              BindAddress;
              BindAddress = (DWORD_PTR) (CMachineBinding *)pBindEntry->_flink )
        {
            pBindEntry = (CMachineBinding *) Alloc( sizeof(CMachineBinding) );

            bStatus = ReadMemory(
                            pExtApis,
                            hProcess,
                            BindAddress,
                            (void *)pBindEntry,
                            sizeof(CMachineBinding) );

            (*pfnPrint)( "      CMachineBinding 0x%x ", BindAddress );

            if ( ! bStatus )
            {
                (*pfnPrint)( "[couldn't read address]\n" );
                break;
            }

            (*pfnPrint)( "\n" );

            (*pfnPrint)( "      _hBinding 0x%x\n", pBindEntry->_hBinding );
            (*pfnPrint)( "      _ProtseqId 0x%x %S\n", pBindEntry->_ProtseqId, gaProtseqInfo[pBindEntry->_ProtseqId].pwstrProtseq );
						(*pfnPrint)( "      _AuthnSvc 0x%x\n", pBindEntry->_AuthnSvc);
            (*pfnPrint)( "      _pAuthInfo 0x%x\n", pBindEntry->_pAuthInfo );
        }
    }
}

void
DumpSPI(
    PNTSD_EXTENSION_APIS    pExtApis,
    HANDLE                  hProcess,
    SCMProcessInfo*         pSPI
    )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\actdbg\epts.c ===
/*
 *
 * epts.c
 *
 *  Dupped from dcomss\wrapper\epts.c.
 *
 */

#include "dcomss.h"

PROTSEQ_INFO
gaProtseqInfo[] =
    {
    /* 0x00 */ { STOPPED, 0, 0 },
    /* 0x01 */ { STOPPED, 0, 0 },
    /* 0x02 */ { STOPPED, 0, 0 },
    /* 0x03 */ { STOPPED, 0, 0 },
    /* 0x04 */ { STOPPED, L"ncacn_dnet_nsp", L"#69" },
    /* 0x05 */ { STOPPED, 0, 0 },
    /* 0x06 */ { STOPPED, 0, 0 },
    /* 0x07 */ { STOPPED, L"ncacn_ip_tcp",   L"135" },
    /* 0x08 */ { STOPPED, L"ncadg_ip_udp",   L"135" },
    /* 0x09 */ { STOPPED, L"ncacn_nb_tcp",   L"135" },
    /* 0x0a */ { STOPPED, 0, 0 },
    /* 0x0b */ { STOPPED, 0, 0 },
    /* 0x0c */ { STOPPED, L"ncacn_spx",      L"34280" },
    /* 0x0d */ { STOPPED, L"ncacn_nb_ipx",   L"135" },
    /* 0x0e */ { STOPPED, L"ncadg_ipx",      L"34280" },
    /* 0x0f */ { STOPPED, L"ncacn_np",       L"\\pipe\\epmapper" },
    /* 0x10 */ { STOPPED, L"ncalrpc",        L"epmapper" },
    /* 0x11 */ { STOPPED, 0, 0 },
    /* 0x12 */ { STOPPED, 0, 0 },
    /* 0x13 */ { STOPPED, L"ncacn_nb_nb",    L"135" },
    /* 0x14 */ { STOPPED, 0, 0 },
    /* 0x15 */ { STOPPED, 0, 0 }, // was ncacn_nb_xns - unsupported.
    /* 0x16 */ { STOPPED, L"ncacn_at_dsp", L"Endpoint Mapper" },
    /* 0x17 */ { STOPPED, L"ncadg_at_ddp", L"Endpoint Mapper" },
    /* 0x18 */ { STOPPED, 0, 0 },
    /* 0x19 */ { STOPPED, 0, 0 },
    /* 0x1A */ { STOPPED, L"ncacn_vns_spp",  L"385"},
    /* 0x1B */ { STOPPED, 0, 0 },
    /* 0x1C */ { STOPPED, 0, 0 },
    /* 0x1D */ { STOPPED, L"ncadg_mq",  L"EpMapper"},
    /* 0x1E */ { STOPPED, 0, 0 },
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\actdbg\memory.cxx ===
/*
 *
 * memory.cxx
 *
 *  Routines for reading/writing process memory.
 *
 */

#include "actdbg.hxx"

BOOL
ReadMemory(
    IN  PNTSD_EXTENSION_APIS    pExtApis,
    IN  HANDLE                  hProcess,
    IN  DWORD_PTR               Address,
    IN OUT void *               pBuffer,
    IN  DWORD                   BufferSize
    )
{
    SIZE_T   BytesRead;
    BOOL    bStatus;

    if ( ! Address )
        return FALSE;

    bStatus = ReadProcessMemory(
                    hProcess,
                    (const void *)Address,
                    pBuffer,
                    BufferSize,
                    &BytesRead );

    return bStatus && (BytesRead == BufferSize);
}

BOOL
ReadMemory(
    IN  PNTSD_EXTENSION_APIS    pExtApis,
    IN  HANDLE                  hProcess,
    IN  char *                  pszAddress,
    IN OUT void *               pBuffer,
    IN  DWORD                   BufferSize
    )
{
    DWORD_PTR Address;

    Address = (*pExtApis->lpGetExpressionRoutine)( pszAddress );

    return ReadMemory( pExtApis, hProcess, Address, pBuffer, BufferSize );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\actdbg\miscdbg.cxx ===
/*
 *
 * miscdbg.c
 *
 *  Miscellaneous helper routines.
 *
 */

#include "actdbg.hxx"

BOOL
ParseArgString(
    IN  char *      pszArgString,
    OUT DWORD *     pArgc,
    OUT char *      Argv[MAXARGS]
    )
{
    char * pszArg;

    *pArgc = 0;
    memset( Argv, 0, sizeof(Argv) );

    if ( ! pszArgString )
        return TRUE;

    pszArg = pszArgString;

    for (;;)
    {
        while ( *pszArg == ' ' || *pszArg == '\t' )
            pszArg++;

        if ( *pszArg )
        {
            if ( MAXARGS == *pArgc )
                return FALSE;

            Argv[*pArgc] = pszArg;
            (*pArgc)++;
        }

        while ( *pszArg && *pszArg != L' ' && *pszArg != L'\t' )
            pszArg++;

        if ( ! *pszArg )
            break;

        *pszArg++ = 0;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\dcomtest\umisc.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    UMisc.H

Abstract:

    Header file for OR test applications.

Author:

    Mario Goertzel    [mariogo]       Apr-23-95

Revision History:

--*/

#ifndef __UMISC_H
#define __UMISC_H

#ifdef __cplusplus
extern "C" {
#endif

#define PrintToConsole printf

extern ULONG Errors;
#define EQUAL(X,Y) if ((X)!=(Y)) {PrintToConsole("%s(%d): Error %d: %s (%ld, 0x%lx) != %s (%ld, 0x%lx)\n", __FILE__, __LINE__, ++Errors, #X, (X), (X), #Y, (Y), (Y)); Errors++; }
#undef ASSERT
#define ASSERT(X) if (! (X) ) {PrintToConsole("%s(%d): Error %d: Assertion %s not true\n", __FILE__, __LINE__, ++Errors, #X); DebugBreak(); Errors++; }

void StringArrayEqual(
    IN DUALSTRINGARRAY *,
    IN DUALSTRINGARRAY *
    );

void UuidsEqual(
    IN UUID *,
    IN UUID *
    );

void PrintDualStringArray(
    IN PSZ pszComment,
    IN DUALSTRINGARRAY *pdsa,
    IN BOOL fCompressed
    );

void PrintSid(SID *psid);

#ifdef __cplusplus
}
#endif

#endif // __UMISC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\dcomtest\makefile.inc ===
!ifndef MIDL
MIDL = midl.exe
!endif

MIDL_FLAGS= \
 -Zp8 \
 -I$(INCLUDES) \
 -Oicf \
 -oldnames \
 -char unsigned \
 -error allocation \
 -ms_ext -c_ext \
 -DMIDL_PASS \
 $(C_DEFINES) \
 -prefix server _ \
 -cpp_cmd $(TARGET_CPP) \
 -cpp_opt "-nologo -DMIDL_PASS $(C_DEFINES) -I$(INCLUDES) -E -Tc"

obj\uor.h: uor.idl
     $(MIDL) $(MIDL_FLAGS) -header $@ $**

odeth_s.c : ..\..\idl\internal\daytona\odeth_s.c
	copy $? .

testidl:   obj\uor.h odeth_s.c

clean:
          -erase obj\uor.h   >NUL 2>NUL
	  -erase odeth_s.c   >NUL 2>NUL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\objex\blist.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    BList.cxx

Abstract:

    Implements out of line methods on blists.

Author:

    Mario Goertzel    [MarioGo]

Revision History:

    MarioGo     95-03-02    Bits 'n pieces
    MarioGo     95-09-07    Was blist.inl, change from template to generic class for PPC.
--*/

#include<or.hxx>

ULONG
CBList::Hash(PVOID p)
{
    ULONG t = PtrToUlong(p);

    return ( ((t << 9) ^ (t >> 5) ^ (t >> 15)) % _ulmaxData);
}

ORSTATUS
CBList::Insert(PVOID p)
{
    if (   _data == 0
        || _ulcElements > (_ulmaxData - (_ulmaxData/8 + 1)))
        {
        // Table getting full, grow it.
        // See Kenuth on linear probe hash performance as the table fills.

        ULONG i, ulmaxOldData = _ulmaxData;
        PVOID *ppOldData = _data;
        _data = new PVOID[_ulmaxData * 2];

        if (0 == _data)
            {
            _data = ppOldData;
            return(OR_NOMEM);
            }

        _ulmaxData *= 2;
        _ulcElements = 0;

        OrMemorySet(_data, 0, _ulmaxData*sizeof(PVOID));

        if (ppOldData)
            {
            for(i = 0; i < ulmaxOldData; i++)
                {
                if (ppOldData[i])
                    {
                    ORSTATUS status = Insert(ppOldData[i]);
                    ASSERT(status == OR_OK);
                    }
                }

            delete ppOldData;
            }
        }

    register ULONG i = Hash(p);

    while(_data[i])
        {
        i = (i + 1) % _ulmaxData;
        }
    
    _data[i] = p;
    _ulcElements++;

    return(OR_OK);
}

PVOID 
CBList::Remove(PVOID p)
{
    register ULONG i, hash;

    if (_data)
        {
        i = hash = Hash(p);
    
        if (_data[i] != p)
            {
            do
                {
                i = (i + 1) % _ulmaxData;
                }
            while(_data[i] != p && i != hash);
            }

        if (_data[i] == p)
            {
            _data[i] = 0;
            _ulcElements--;
            return(p);
            }

        ASSERT(i == hash);
        }

    return(0);
}

BOOL
CBList::Member(PVOID p)
{
    int i, hash;

    if (0 == _data)
        return(FALSE);

    i = hash = Hash(p);
    if (_data[i] == p)
        return(TRUE);

    do
        {
        i = (i + 1) % _ulmaxData;
        }
    while(_data[i] != p && i != hash);

    return(_data[i] == p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\dcomtest\umisc.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    UMisc.C

Abstract:

    Helper functions for OR test applications.

Author:

    Mario Goertzel    [mariogo]       Apr-23-95

Revision History:

--*/

#include <or.hxx>
#include <stdio.h>
#include <umisc.h>

// Copied from string.cxx

// Types

struct PROTSEQ_MAPPING {
    USHORT  iProtseqId;
    USHORT *pwszProtseq;
    };

// Globals

static const PROTSEQ_MAPPING
Mappings[] =
    {
    { 0x00, 0 },
    { 0x01, L"mswmsg" },
    { 0x02, 0 },
    { 0x03, 0 },
    { 0x04, L"ncacn_dnet_dsp" },
    { 0x05, 0 },
    { 0x06, 0 },
    { 0x07, L"ncacn_ip_tcp" },
    { 0x08, L"ncadg_ip_udp" },
    { 0x09, L"ncacn_nb_tcp" },
    { 0x0A, 0 },
    { 0x0B, 0 },
    { 0x0C, L"ncacn_spx" },
    { 0x0D, L"ncacn_nb_ipx"},
    { 0x0E, L"ncadg_ipx" },
    { 0x0F, L"ncacn_np"},
    { 0x10, L"ncalrpc"},
    { 0x11, 0},
    { 0x12, L"ncacn_nb_nb"},
    };

#define PROTSEQ_IDS (sizeof(Mappings)/sizeof(PROTSEQ_MAPPING) - 1)

// Public functions

PWSTR
GetProtseq(
    IN USHORT ProtseqId
    )
{
    ASSERT(ProtseqId != 0);

    if (ProtseqId > PROTSEQ_IDS)
        {
        return 0;
        }
    wchar_t *pwszProtseq = Mappings[ProtseqId].pwszProtseq;

    ASSERT(ProtseqId == Mappings[ProtseqId].iProtseqId);

    return(pwszProtseq);
}

USHORT
GetProtseqId(
    IN PWSTR pwszProtseq
    )
{
    ASSERT(pwszProtseq);

    for (USHORT i = 0; i <= PROTSEQ_IDS; i++)
        {
        if (   Mappings[i].pwszProtseq
            && 0 == wcscmp(Mappings[i].pwszProtseq, pwszProtseq) )
            {
            ASSERT(Mappings[i].iProtseqId == i);
            return(i);
            }
        }
    return(0);
}


#if 0
// Construct/Transform various STRINGARRAYS

ORSTATUS ConvertStringArray(
    IN  STRINGARRAY *psa,
    OUT STRINGARRAY **ppsaNew,
    IN  BOOL fHasIds
    )
/* ++

Parameters

    psa - Original array in compressed or regular form.
        Note: Maybe written to and restored during copy.

    ppsaNew - Will contain the new compressed or regular
        form of psa.

    fHasIds - If TRUE, psa is assumed to be compressed and
        ppsaNew will contain the regular (non-compressed) version.
        If FALSE, psa is assume to be regular and ppsaNew is compressed.

-- */
{
    int i, size;
    USHORT *p1, *p2, *p3;
    PWSTR pwstr;

    // Compute size

    size = 1; // final null terminator.

    p1 = psa->awszStringArray;

    if (*p1 == 0)
        {
        // ASSERT(psa->size == 2); // bogus for padded (0 mod 8) arrays
        size = 2;  // two null terminators ONLY.
        }

    while(*p1)
        {
        int sizeT = wcslen(p1);

        if (fHasIds == TRUE)
            {
            pwstr = GetProtseq(*p1);
            if (pwstr != 0)
                {
                size += sizeT + wcslen(pwstr) + 1;
                }
            else
                {
                // Except for interop with future platforms, this
                // should not be hit.
                ASSERT(pwstr);
                // This string will be thrown away from the result.
                }
            }
        else
            {
            p2 = wcschr(p1, L':');  // ':' is not valid in protseq.
            if (p2)
                {
                size += sizeT + 1 - (p2 - p1);  // proseq len (p2 - p1) become 1 for Id.
                }
            else
                {
                ASSERT(p2);
                }
            }

        p1 = wcschr(p1, 0);
        ASSERT(*p1 == 0);
        p1++;  // Start of next string or final NULL.
        }

    *ppsaNew = (STRINGARRAY *)MIDL_user_allocate(sizeof(STRINGARRAY) + size * sizeof(USHORT));

    if (0 == *ppsaNew)
        {
        return(OR_NOMEM);
        }

    (*ppsaNew)->size = size;
    p3 = (*ppsaNew)->awszStringArray;
    *p3 = 0;

    p1 = psa->awszStringArray;

    if (*p1 == 0)
        {
        // Two null terminators only.
        ASSERT(size == 2);
        *(p3 + 1) = 0;
        return(0);
        }

    while(*p1)
        {
        if (fHasIds == TRUE)
            {
            pwstr = GetProtseq(*p1);
            p1++;
            if (pwstr != 0)
                {
                wcscpy(p3, pwstr);
                wcscat(p3, L":");
                wcscat(p3, p1);

                // Move p3 to start of next string (if any);
                p3 = wcschr(p3, 0);
                p3++;
                }
            else
                {
                // String not used, don't know protseq.
                // Would ASSERT during sizing.
                }
            }
        else
            {
            // Must change the protseq to a protseq ID.

            p2 = wcschr(p1, L':');
            if (p2)
                {
                *p2 = 0;
                *p3 = GetProtseqId(p1);
                *p2 = L':';
                if (*p3 != 0)
                    {
                    p3++;
                    p1 = p2 + 1; // Just after ':'
                    wcscpy(p3, p1);

                    // Move p3 to start of next string (if any)
                    p3 = wcschr(p3, 0);
                    p3++;
                    
                    }
                }
            }
        
        p1 = wcschr(p1, 0);
        ASSERT(*p1 == 0);
        p1++;  // Start of next string or final NULL.
        }

    // Second terminator, p3 already points to it.
    *p3 = 0;

    return(OR_OK);
}
#endif

void StringArrayEqual(DUALSTRINGARRAY *pa1, DUALSTRINGARRAY *pa2)
{
    wchar_t *p1, *p2;
    EQUAL(pa1->wNumEntries, pa2->wNumEntries);

    p1 = pa1->aStringArray;
    while(*p1)
        {
        p2 = pa2->aStringArray;
        while(*p2)
            {
            if (wcscmp(p1, p2) == 0)
                {
                break;
                }

            // Try next string.
            while (*p2)
                {
                p2++;
                }

            if (*(p2 + 1) == 0)
                {
                // End of array, didn't find it.
                EQUAL(0,1);
                return;
                }
            }

        // Next string
        while(*p1)
            {
            p1++;
            }
        }
    return;
}

void UuidsEqual(UUID *p, UUID *p2)
{
    EQUAL(memcmp(p, p2, sizeof(UUID)), 0);
}

void PrintDualStringArray(
    IN PSZ pszComment,
    IN DUALSTRINGARRAY *pdsaIn,
    IN BOOL fCompressed
    )
{
    RPC_STATUS status;
    DUALSTRINGARRAY *pdsa = pdsaIn;
    PrintToConsole("%s: dual string array of %d words:\n", pszComment, pdsa->wNumEntries);
    PrintToConsole("\tString Bindings:\n");

    PWSTR pProtseq;
    PWSTR pT = pdsa->aStringArray;
    while(*pT != 0)
        {
        if (fCompressed)
            {
            pProtseq = GetProtseq(*pT);
            PrintToConsole("\t%S:%S\n", pProtseq, pT + 1);
            }
        else
            {
            PrintToConsole("\t%S\n", pT);
            }
            pT = wcschr(pT, 0);
        pT++;
        }
    PrintToConsole("\t0\n");


    PrintToConsole("\tSecurity Bindings:\n");
    pT = &pdsa->aStringArray[pdsa->wSecurityOffset];
    while(*pT != 0)
        {
        PrintToConsole("\tAuthn %i, Authz %i, Principal %S\n", pT[0], pT[1], &pT[2]);
        pT = wcschr(pT, 0);
        pT++;
        }
    PrintToConsole("\t0\n");
}

void PrintSid(SID *psid)
{
    BYTE *p;
    int i;
    __int64 idauth = 0;

    printf("\tS-%u", psid->Revision);

    p = (PBYTE) GetSidIdentifierAuthority(psid);

    for (i = 0; i < 6; i++, p++ )
        {
        *(((PBYTE)&idauth) + 5 - i) = *p;
        }

    printf("-%u", (DWORD)idauth);

    p = GetSidSubAuthorityCount(psid);

    for(i = 0; i < *p; i++)
        {
        PDWORD pdw;
        pdw = GetSidSubAuthority(psid, i);
        printf("-%u", *pdw);
        }

    printf("\n");
    return;
}


LPVOID __RPC_USER MIDL_user_allocate(UINT size)
{
    return(HeapAlloc(GetProcessHeap(), 0, size));
}

void __RPC_USER MIDL_user_free(LPVOID p)
{
    HeapFree(GetProcessHeap(), 0, p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\dcomtest\ortest.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    ortest.c

Abstract:

    Simple test application for testing OR features directly.

Author:

    Mario Goertzel    [MarioGo]

Revision History:

    MarioGo     1/24/1996    Bits 'n pieces

--*/

#include <or.h>
#include <stdio.h>
#include <umisc.h>
#include <uor.h>
#include <epmp.h>

typedef struct {
    ID oid;
    BOOL fReady;
    BOOL fForceSecond;
    } RundownRecord;

// Constants

const PWSTR pwstrOr     = L"ncalrpc:[epmapper]";

// Globals

HANDLE hLocalOr = 0;
HANDLE hServerOrTest = 0;
PHPROCESS hMyProcess = 0;

BOOL fServer = TRUE;
BOOL fInternet = FALSE;

DWORD TestCase = 0;
DWORD Errors = 0;

OXID aOxids[5];             /* shared \                              */
OXID_INFO aOxidInfo[5];     /* shared  > between client and server   */
OID  aOids[100];            /* shared /                              */

RundownRecord aRundowns[100];
DWORD dwlimRundowns = 0;

OID reservedBase;

DUALSTRINGARRAY *pdsaMyExpandedStringBindings;
DUALSTRINGARRAY *pdsaMyCompressedSecurityBindings;
DUALSTRINGARRAY *pdsaMyTestBindings;

DUALSTRINGARRAY *pdsaLocalOrBindings;
MID gLocalMid;

void SyncWithClient(DWORD testcase);
error_status_t SyncWithServer(DWORD testcase);
void AddRundown(ID oid, BOOL fRundownTwice);
void WaitForAllRundowns();
RPC_STATUS ConnectToLocalOr();
RPC_STATUS Startup(PSZ, PSZ);

// Test events

HANDLE  hServerEvent;
HANDLE  hClientEvent;
HANDLE  hRundownEvent;


//
// Intenet port tests - not really related to DCOM
// but is just a client to the endpoint mapper process
// so it runs fine here.
//
// Assumes the following config: (regini dcomtest.ini)
//

extern RPC_STATUS RPC_ENTRY
I_RpcServerAllocatePort(DWORD, PUSHORT);

RPC_STATUS
RunInternetPortTests()
{
    RPC_STATUS status;
    long allocstatus;
    PVOID process1, process2, process3;
    unsigned short port;
    int i;

    for (i = 0; i < 2; i++)
        {
        process1 = process2 = process3 = 0;
    
        if (hLocalOr == 0)
            {
            status =
            RpcBindingFromStringBinding(pwstrOr, &hLocalOr);
            ASSERT(status == RPC_S_OK);
            }
    
        status = OpenEndpointMapper(hLocalOr,
                                    &process1);
    
        ASSERT(status == RPC_S_OK);
    
        status = OpenEndpointMapper(hLocalOr,
                                    &process2);
    
        ASSERT(status == RPC_S_OK);
    
        status = OpenEndpointMapper(hLocalOr,
                                    &process3);
    
        ASSERT(status == RPC_S_OK);
        status = AllocateReservedIPPort(process1,
                                        PORT_DEFAULT,
                                        &allocstatus,
                                        &port);
    
        ASSERT(status == RPC_S_OK);
        EQUAL(allocstatus, RPC_S_OK);
        EQUAL(port, 1026);
    
        status = AllocateReservedIPPort(process1,
                                        PORT_INTERNET,
                                        &allocstatus,
                                        &port);
    
        ASSERT(status == RPC_S_OK);
        EQUAL(allocstatus, RPC_S_OK);
        EQUAL(port, 1028);
    
        status = AllocateReservedIPPort(process1,
                                        PORT_INTERNET,
                                        &allocstatus,
                                        &port);
    
        ASSERT(status == RPC_S_OK);
        EQUAL(allocstatus, RPC_S_OK);
        EQUAL(port, 1029);
    
        status = AllocateReservedIPPort(process2,
                                        PORT_INTRANET,
                                        &allocstatus,
                                        &port);
    
        ASSERT(status == RPC_S_OK);
        EQUAL(allocstatus, RPC_S_OK);
        EQUAL(port, 499);
    
        status = AllocateReservedIPPort(process2,
                                        PORT_INTRANET,
                                        &allocstatus,
                                        &port);
    
        ASSERT(status == RPC_S_OK);
        EQUAL(allocstatus, RPC_S_OK);
        EQUAL(port, 500);
    
        status = AllocateReservedIPPort(process2,
                                        PORT_INTRANET,
                                        &allocstatus,
                                        &port);
    
        ASSERT(status == RPC_S_OK);
        EQUAL(allocstatus, RPC_S_OK);
        EQUAL(port, 501);
    
        status = AllocateReservedIPPort(process2,
                                        PORT_INTRANET,
                                        &allocstatus,
                                        &port);
    
        ASSERT(status == RPC_S_OK);
        EQUAL(allocstatus, RPC_S_OK);
        EQUAL(port, 502);
    
    
        status = AllocateReservedIPPort(process2,
                                        PORT_INTRANET,
                                        &allocstatus,
                                        &port);
    
        ASSERT(status == RPC_S_OK);
        EQUAL(allocstatus, RPC_S_OK);
        EQUAL(port, 1025);
    
    
        status = AllocateReservedIPPort(process2,
                                        PORT_INTRANET,
                                        &allocstatus,
                                        &port);
    
        ASSERT(status == RPC_S_OK);
        EQUAL(allocstatus, RPC_S_OK);
        EQUAL(port, 1027);
    
    
        status = AllocateReservedIPPort(process2,
                                        PORT_INTRANET,
                                        &allocstatus,
                                        &port);
    
        ASSERT(status == RPC_S_OK);
        EQUAL(allocstatus, RPC_S_OUT_OF_RESOURCES);
        EQUAL(port, 0);
    
    
        status = AllocateReservedIPPort(process3,
                                        PORT_INTRANET,
                                        &allocstatus,
                                        &port);
    
        ASSERT(status == RPC_S_OK);
        EQUAL(allocstatus, RPC_S_OUT_OF_RESOURCES);
        EQUAL(port, 0);
    
        status = AllocateReservedIPPort(process3,
                                        PORT_INTERNET,
                                        &allocstatus,
                                        &port);

        ASSERT(status == RPC_S_OK);
        EQUAL(allocstatus, RPC_S_OK);
        EQUAL(port, 1030);
    
        status =
        RpcSmDestroyClientContext(&process2);
        ASSERT(status == RPC_S_OK);
    
        status =
        RpcSmDestroyClientContext(&process3);
        ASSERT(status == RPC_S_OK);
    
        status =
        RpcSmDestroyClientContext(&process1);
        ASSERT(status == RPC_S_OK);

        status =
        RpcBindingFree(&hLocalOr);
        ASSERT(status == RPC_S_OK);
        }

    status = I_RpcServerAllocatePort(RPC_C_USE_INTERNET_PORT,
                                     &port);

    ASSERT(status == RPC_S_OK);
    EQUAL(port, 1026);

    status = I_RpcServerAllocatePort(0,
                                    &port);

    ASSERT(status == RPC_S_OK);
    EQUAL(port, 1028);


    status = I_RpcServerAllocatePort(RPC_C_USE_INTRANET_PORT,
                                    &port);

    ASSERT(status == RPC_S_OK);
    EQUAL(port, 499);

    status = I_RpcServerAllocatePort(RPC_C_USE_INTRANET_PORT,
                                    &port);

    ASSERT(status == RPC_S_OK);
    EQUAL(port, 500);

    status = I_RpcServerAllocatePort(RPC_C_USE_INTRANET_PORT,
                                    &port);

    ASSERT(status == RPC_S_OK);
    EQUAL(port, 501);

    status = I_RpcServerAllocatePort(RPC_C_USE_INTRANET_PORT,
                                    &port);

    ASSERT(status == RPC_S_OK);
    EQUAL(port, 502);

    status = I_RpcServerAllocatePort(RPC_C_USE_INTRANET_PORT,
                                    &port);

    ASSERT(status == RPC_S_OK);
    EQUAL(port, 1025);

    status = I_RpcServerAllocatePort(RPC_C_USE_INTRANET_PORT,
                                    &port);

    ASSERT(status == RPC_S_OK);
    EQUAL(port, 1027);

    status = I_RpcServerAllocatePort(RPC_C_USE_INTRANET_PORT,
                                    &port);

    ASSERT(status == RPC_S_OUT_OF_RESOURCES);
    EQUAL(port, 0);

    status = I_RpcServerAllocatePort(  RPC_C_USE_INTERNET_PORT
                                     | RPC_C_USE_INTRANET_PORT,
                                     &port);
    ASSERT(status == RPC_S_INVALID_ARG);
    EQUAL(port, 0);

    return(RPC_S_OK);
}
// Server side

RPC_STATUS
RunServer()
{
    RPC_STATUS status;
    DWORD t;
    OXID_INFO oi;
    OID oidT;
    int i;
    OID aOidDels[2];

    SyncWithClient(++TestCase);

    // Allocate Oxids and Oids

    aOxidInfo[0].dwTid = 1;
    aOxidInfo[0].dwPid = 42;
    aOxidInfo[0].dwAuthnHint = 4;
    aOxidInfo[0].psa = 0;

    status = UuidCreate(&aOxidInfo[0].ipidRemUnknown);
    ASSERT(status == RPC_S_OK);

    status = ServerAllocateOXIDAndOIDs(
                hLocalOr,
                hMyProcess,
                &aOxids[0],
                FALSE,
                5,
                &aOids[0],
                &t,
                &aOxidInfo[0],
                pdsaMyExpandedStringBindings,
                pdsaMyCompressedSecurityBindings);


    ASSERT(status == RPC_S_OK);
    EQUAL(t, 5);

    status = ServerAllocateOIDs(
                hLocalOr,
                hMyProcess,
                &aOxids[0],
                5,
                &aOids[5],
                &t);

    ASSERT(status == RPC_S_OK);
    EQUAL(t, 5);

    PrintToConsole("Allocated oxid %I64x with OIDs:\n", aOxids[0]);
    for(i = 0; i < 10; i++)
        {
        PrintToConsole("\t%I64x\n", aOids[i]);
        }

    aOxidInfo[1].dwTid = 2;
    aOxidInfo[1].dwPid = 42;
    aOxidInfo[1].dwAuthnHint = 99;
    aOxidInfo[1].psa = 0;

    status = UuidCreate(&aOxidInfo[1].ipidRemUnknown);
    ASSERT(status == RPC_S_OK);

    status = ServerAllocateOXIDAndOIDs(
                hLocalOr,
                hMyProcess,
                &aOxids[1],
                FALSE,
                10,
                &aOids[10],
                &t,
                &aOxidInfo[1],
                pdsaMyExpandedStringBindings,
                pdsaMyTestBindings);

    ASSERT(status == RPC_S_OK);
    EQUAL(t, 10);

    PrintToConsole("Allocated oxid %I64x with OIDs:\n", aOxids[1]);
    for(i = 10; i < 20; i++)
        {
        PrintToConsole("\t%I64x\n", aOids[i]);
        }

    aOxidInfo[2].dwTid = 3;
    aOxidInfo[2].dwPid = 42;
    aOxidInfo[2].dwAuthnHint = 17171717;
    aOxidInfo[2].psa = 0;

    status = UuidCreate(&aOxidInfo[2].ipidRemUnknown);
    ASSERT(status == RPC_S_OK);

    status = ServerAllocateOXIDAndOIDs(
                hLocalOr,
                hMyProcess,
                &aOxids[2],
                FALSE,
                10,
                &aOids[20],
                &t,
                &aOxidInfo[2],
                pdsaMyExpandedStringBindings,
                pdsaMyTestBindings);

    ASSERT(status == RPC_S_OK);
    EQUAL(t, 10);

    PrintToConsole("Allocated oxid %I64x with OIDs:\n", aOxids[2]);
    for(i = 20; i < 30; i++)
        {
        PrintToConsole("\t%I64x\n", aOids[i]);
        }

    SyncWithClient(++TestCase);

    status = ServerFreeOXIDAndOIDs(
                hLocalOr,
                hMyProcess,
                aOxids[1],
                10,
                &aOids[10]
                );

    ASSERT(status == OR_OK);

    status = ServerFreeOXIDAndOIDs(
                hLocalOr,
                hMyProcess,
                aOxids[2],
                10,
                &aOids[20]
                );

    ASSERT(status == OR_OK);

    PrintToConsole("Freed OXID %I64x and %I64x\n", aOxids[1], aOxids[2]);

    SyncWithClient(++TestCase);

    // Wait for rundowns on oxid 0 of OIDs 0, 1, 7 and 9

    AddRundown(aOids[0], FALSE);
    AddRundown(aOids[1], FALSE);
    AddRundown(aOids[7], FALSE);
    AddRundown(aOids[9], FALSE);

    WaitForAllRundowns();

    SyncWithClient(++TestCase);

    TestCase = ~0;
    SyncWithClient(TestCase);

    // Free OID 3 it shouldn't rundown after this; and an invalid oid.

    aOidDels[0] = aOids[3];
    aOidDels[1] = reservedBase;

    status =
    BulkUpdateOIDs(hLocalOr,
                   hMyProcess,
                   0,
                   0,
                   0,
                   0,
                   0,
                   2,
                   aOidDels,
                   0,
                   0
                   );

    // Wait for rundowns on oxid 0 of OIDs 2, 4, 5, 6 and 8
    // Client has exited

    AddRundown(aOids[2], FALSE);
    AddRundown(aOids[4], TRUE);
    AddRundown(aOids[5], FALSE);
    AddRundown(aOids[6], FALSE);
    AddRundown(aOids[8], TRUE);

    WaitForAllRundowns();

    return(RPC_S_OK);
}

// Client side
RPC_STATUS
RunClient()
{
    RPC_STATUS status;
    DUALSTRINGARRAY *pdaRemoteOrBindings = 0;
    OXID_INFO oi;
    MID mid;
    int i;
    OXID_OID_PAIR aUpdates[10];
    OID_MID_PAIR  aDeletes[6];
    OXID_REF aoxidRefs[2];
    LONG aStatus[10];

    SyncWithServer(++TestCase);

    // Server has allocated oxids and oids

    status =
    GetState(hServerOrTest,
             3,
             30,
             3,
             aOxids,
             aOids,
             aOxidInfo,
             &pdaRemoteOrBindings);

    ASSERT(status == RPC_S_OK);
    ASSERT(pdaRemoteOrBindings);
    EQUAL(aOxidInfo[0].psa, 0);

    // Resolve OXID 0
    oi.psa =0;

    status =
    ClientResolveOXID(hLocalOr,
                      hMyProcess,
                      &aOxids[0],
                      pdaRemoteOrBindings,
                      FALSE,
                      &oi,
                      &mid);

    ASSERT(status == RPC_S_OK);
    PrintToConsole("Resolved OXID: %I64x on MID %I64x\n", aOxids[0], mid);
    EQUAL( ( (oi.dwTid == aOxidInfo[0].dwTid) || oi.dwTid == 0), 1);
    EQUAL( ( (oi.dwPid == aOxidInfo[0].dwPid) || oi.dwPid == 0), 1);
    EQUAL(oi.dwAuthnHint, aOxidInfo[0].dwAuthnHint);
    if (memcmp(&oi.ipidRemUnknown, &aOxidInfo[0].ipidRemUnknown, sizeof(IPID)) != 0)
        {
        EQUAL(0, 1);
        }
    PrintDualStringArray("Expanded binding", oi.psa, FALSE);
    MIDL_user_free(oi.psa);

    // Add some valid and invalid oids
    for (i = 0; i < 10; i++)
        {
        aUpdates[i].mid = mid;
        aUpdates[i].oxid = aOxids[0];
        aUpdates[i].oid = aOids[i];
        }

    aUpdates[9].mid = reservedBase;
    aUpdates[8].oxid = reservedBase;
    aUpdates[7].oid = reservedBase;

    status =
    BulkUpdateOIDs(hLocalOr,
                   hMyProcess,
                   10,
                   aUpdates,
                   aStatus,
                   0,
                   0,
                   0,
                   0,
                   0,
                   0);

    ASSERT(status == OR_PARTIAL_UPDATE);
    for(i = 0; i < 7; i++)
        {
        EQUAL(aStatus[i], 0);
        }
    EQUAL(aStatus[7], 0); // Okay to register unknown OID
    EQUAL(aStatus[8], OR_BADOXID);
    EQUAL(aStatus[9], OR_BADOXID);

    // Delete a few

    // Add three not added last call
    // .oxid and .mid correct
    aUpdates[0].oid = aOids[8];
    aUpdates[1].oid = aOids[9];

    // Remove 2 added last call, 1 from this call and 2 invalid
    for(i = 0; i < 6; i++)
        {
        aDeletes[i].oid = aOids[i];
        aDeletes[i].mid = mid;
        }
    aDeletes[2].oid = aOids[9];
    aDeletes[3].oid = reservedBase;
    aDeletes[4].mid = reservedBase;
    aDeletes[5].oid = aOids[6];

    status =
    BulkUpdateOIDs(hLocalOr,
                   hMyProcess,
                   2,
                   aUpdates,
                   aStatus,
                   6,
                   aDeletes,
                   0,
                   0,
                   0,
                   0);

    ASSERT(status == OR_OK);
    EQUAL(aStatus[0], OR_OK);
    EQUAL(aStatus[1], OR_OK);

    // 6 has been added and deleted, add it again.
    aUpdates[0].oid = aOids[6];
    status =
    BulkUpdateOIDs(hLocalOr,
                   hMyProcess,
                   1,
                   aUpdates,
                   aStatus,
                   0,
                   0,
                   0,
                   0,
                   0,
                   0);
    ASSERT(status == OR_OK);
    EQUAL(aStatus[0], OR_OK);

    // Final state: D - added and deleted, A - added, E - D + added, N not added
    // OID:     0   1   2   3   4   5   6   7   8   9   
    // State:   D   D   A   A   A   A   E   N   A   D

    // Resolve OXID 1

    if (mid != gLocalMid)
        {
        MID mid2;
        // No resolve required for local machine.

        PrintToConsole("Remote server; resolving second OXID\n");
        oi.psa = 0;
        status =
        ClientResolveOXID(hLocalOr,
                          hMyProcess,
                          &aOxids[1],
                          pdaRemoteOrBindings,
                          FALSE,
                          &oi,
                          &mid2);
    
        ASSERT(status == RPC_S_OK);
        PrintToConsole("Resolved OXID: %I64x on MID %I64x\n", aOxids[1], mid);
        EQUAL(mid, mid2);
        EQUAL(oi.dwTid, 0);
        EQUAL(oi.dwPid, 0);
        EQUAL(oi.dwAuthnHint, aOxidInfo[1].dwAuthnHint);
        if (memcmp(&oi.ipidRemUnknown, &aOxidInfo[1].ipidRemUnknown, sizeof(IPID)) != 0)
            {
            EQUAL(0, 1);
            }
        PrintDualStringArray("Expanded binding", oi.psa, FALSE);
        MIDL_user_free(oi.psa);
        }

    // Add some of the oids.
    for (i = 0; i < 5; i++)
        {
        aUpdates[i].mid = mid;
        aUpdates[i].oxid = aOxids[1];
        aUpdates[i].oid = aOids[i+10];
        }

    // Release our processes hold on the oxids, this is okay since the OIDs
    // are keeping them alive.

    for (i = 0; i < 2; i++)
        {
        aoxidRefs[i].oxid = aOxids[i];
        aoxidRefs[i].mid  = mid;
        }
    aoxidRefs[0].refs = 1;
    aoxidRefs[1].refs = 4; // invalid, will cause an DbgPrint in checked or.

    status =
    BulkUpdateOIDs(hLocalOr,
                   hMyProcess,
                   5,
                   aUpdates,
                   aStatus,
                   0,
                   0,
                   0,
                   0,
                   2,
                   aoxidRefs);

    ASSERT(status == OR_OK);
    for(i = 0; i < 5; i++)
        {
        EQUAL(aStatus[i], 0);
        }

    SyncWithServer(++TestCase);

    // Server has freed oxids and oids

    // Can't test that adding an invalid OID is caught, because it
    // isn't until the client actually pings the real server.

    // Since the client has already resolved oxid1 we can re-resolve it.

    // Try to lookup oxid 2 which has also been freed, it should fail.

    oi.psa = 0;

    status =
    ClientResolveOXID(hLocalOr,
                      hMyProcess,
                      &aOxids[2],
                      pdaRemoteOrBindings,
                      FALSE,
                      &oi,
                      &mid);

    ASSERT(status == OR_BADOXID);
    EQUAL(oi.psa,0);

    SyncWithServer(++TestCase);

    // Server waited for first set of rundowns

    SyncWithServer(++TestCase);

    SyncWithServer(~0);

    // Server will wait for the last set of rundowns.

    return(RPC_S_OK);
}


int main (int argc, char *argv[])
{
    RPC_STATUS status;
    PSZ pszProtseq, pszServer;

    argc--;
    argv++;

    pszServer = 0;
    pszProtseq = "ncalrpc";

    while(argc)
        {
        switch(argv[0][1])
            {
            case 't':
                pszProtseq = argv[1];
                argc--;
                argv++;
                break;
            case 'l':
            case 'c':
                fServer = FALSE;
                break;
            case 'i':
                fInternet = TRUE;
                break;
            case 's':
                pszServer = argv[1];
                argc--;
                argv++;
                break;
            default:
                PrintToConsole("Usage: ortest [client|-client] [-internet] [-t protseq ] [-s server addr]\n"
                               );
                return(0);
            }
        argc--;
        argv++;
        }

    PrintToConsole("OrTest: %s starting...\n", fInternet ? "internet test" :
                                                   ( fServer ? "server" : "client") );

    if (fInternet)
        {
        status = RunInternetPortTests();
        }
    else
        {
        status = Startup(pszProtseq, pszServer);
        ASSERT(status == RPC_S_OK);

        status = ConnectToLocalOr();
        ASSERT(status == RPC_S_OK);

        if (fServer)
            {
            status = RunServer();
            }
        else
            {
            status = RunClient();
            }
        }
    if (status == RPC_S_OK)
        {
        PrintToConsole("Test Passed\n");
        }
    else
        {
        PrintToConsole("Test Failed %d\n", Errors);
        }

    if (hLocalOr) RpcBindingFree(&hLocalOr);
    if (hMyProcess) RpcSsDestroyClientContext(&hMyProcess);
    if (hServerOrTest) RpcBindingFree(&hServerOrTest);
    Sleep(1000);
    return(0);
}

// Shared initialization code

RPC_STATUS
Startup(PSZ protseq, PSZ server)
{
    RPC_STATUS status;
    DUALSTRINGARRAY *pdsaT, *pdsaT2;
    RPC_BINDING_VECTOR *pbv;

    pdsaMyExpandedStringBindings = (DUALSTRINGARRAY *)MIDL_user_allocate(500*2);
    pdsaMyCompressedSecurityBindings = (DUALSTRINGARRAY *)MIDL_user_allocate(4 + 6*2);
    pdsaMyTestBindings = (DUALSTRINGARRAY *)MIDL_user_allocate(4 + 19*2);
    ASSERT(   pdsaMyExpandedStringBindings
           && pdsaMyCompressedSecurityBindings
           && pdsaMyTestBindings);

    pdsaMyCompressedSecurityBindings->wNumEntries = 6;
    pdsaMyCompressedSecurityBindings->wSecurityOffset = 2;
    pdsaMyCompressedSecurityBindings->aStringArray[0] = 0;
    pdsaMyCompressedSecurityBindings->aStringArray[1] = 0;
    pdsaMyCompressedSecurityBindings->aStringArray[2] = 10;  // authn winnt
    pdsaMyCompressedSecurityBindings->aStringArray[3] = -1;  // authz none
    pdsaMyCompressedSecurityBindings->aStringArray[4] = 0;
    pdsaMyCompressedSecurityBindings->aStringArray[5] = 0;

    _UseProtseq(0, L"ncalrpc", &pdsaT, &pdsaT2); // inits psaMyExpandedStringBindings
    EQUAL( (pdsaT != 0), 1);
    EQUAL( (pdsaT2 != 0), 1);
    MIDL_user_free(pdsaT);
    MIDL_user_free(pdsaT2);

    pdsaMyTestBindings->wNumEntries = 19;
    pdsaMyTestBindings->wSecurityOffset = 2;
    memcpy(pdsaMyTestBindings->aStringArray,
           L"\0\0\x7\xff" L"APrincipal\0\x9\xD\0\0",
           19*2);

    if (fServer)
        {

        // Listen to the remote (if any) protseq.  Not part of the bindings
        // registered with the OR until a callback to UseProtseq is made.
        if (protseq)
            {
            status = RpcServerUseProtseqA(protseq, 0, 0);
            ASSERT(status == RPC_S_OK);
            }

        status = RpcServerInqBindings(&pbv);
        ASSERT(status == RPC_S_OK);

        status =
        RpcEpRegister(_IOrTest_ServerIfHandle, pbv, 0, 0);
        ASSERT(status == RPC_S_OK);

        status =
        RpcBindingVectorFree(&pbv);
        ASSERT(status == RPC_S_OK);

        // Register UseProtseq callback IF
        status =
        RpcServerRegisterIf(_IOrCallback_ServerIfHandle, 0, 0);
        ASSERT(status == RPC_S_OK);

        // Register test to test IF
        status =
        RpcServerRegisterIf(_IOrTest_ServerIfHandle, 0, 0);
        ASSERT(status == RPC_S_OK);

        // Register rundown OID (fake ORPC) callback IF
        status =
        RpcServerRegisterIf(_IRundown_ServerIfHandle, 0, 0);
        ASSERT(status == RPC_S_OK);

        status =
        RpcServerListen(1, 10, TRUE);
        ASSERT(status == RPC_S_OK);

        hServerEvent = CreateEvent(0, FALSE, FALSE, 0);
        hClientEvent = CreateEvent(0, FALSE, FALSE, 0);
        hRundownEvent = CreateEvent(0, FALSE, FALSE, 0);

        ASSERT(hServerEvent && hClientEvent && hRundownEvent);

        PrintToConsole("\tWaiting for client...\n");

        SyncWithClient(++TestCase);

        status = RPC_S_OK;
        }
    else
        {
        PSZ stringbinding;

        // Make binding to remote OR

        status =
        RpcStringBindingComposeA(0, protseq, server, 0, 0, &stringbinding);
        ASSERT(status == RPC_S_OK);
    
        status =
        RpcBindingFromStringBindingA(stringbinding, &hServerOrTest);

        if (status == RPC_S_OK)
            {
            status = TestBinding(hServerOrTest);
            if (status != RPC_S_OK)
                {
                PrintToConsole("Connect to server failed %d\n", status);
                return(status);
                }
            status = SyncWithServer(++TestCase);
            }
        }

    return(status);
}

RPC_STATUS
ConnectToLocalOr()
{
    RPC_STATUS  status;
    DWORD timeout;
    OXID reservedOxid;
    BOOL disable;
    DWORD authn;
    DWORD imp;
    BOOL  mutual;
    BOOL  secref;
    DWORD cServerSvc = 0;
    PUSHORT pServerSvc = 0;
    DWORD cClientSvc = 0;
    PUSHORT pClientSvc = 0;
    int i;
    PWSTR pwstrLegacy = 0;
    DWORD cAuthId = 0;
    PSZ pszAuthId = 0;
    DWORD flags, pid, scm_pid, tokenid;
    
    status =
    RpcBindingFromStringBinding(pwstrOr, &hLocalOr);

    EQUAL(status, RPC_S_OK);

    status = Connect(hLocalOr,
                     &hMyProcess,
                     &timeout,
                     &pdsaLocalOrBindings,
                     &gLocalMid,
                     5,
                     &reservedBase,
                     &flags,
                     &pwstrLegacy,
                     &authn,
                     &imp,
                     &cServerSvc,
                     &pServerSvc,
                     &cClientSvc,
                     &pClientSvc,
                     &pid,
                     &scm_pid,
                     &tokenid);

    ASSERT(status == RPC_S_OK);
    ASSERT(pdsaLocalOrBindings);
    ASSERT(pServerSvc);
    ASSERT(pClientSvc);

    PrintToConsole("Connected to local object resolver:\n\tFlags:\n");
    if (flags & CONNECT_DISABLEDCOM)
        {
        flags &= ~CONNECT_DISABLEDCOM;
        PrintToConsole("\t\tDCOM DISABLED");
        }
    else
        PrintToConsole("\t\tDCOM enabled");

    if (flags & CONNECT_MUTUALAUTH)
        {
        flags &= ~CONNECT_MUTUALAUTH;
        PrintToConsole("\tMutal authn");
        }
    else
        PrintToConsole("\tNo Mutal authn");

    if (flags & CONNECT_SECUREREF)
        {
        flags &= ~CONNECT_SECUREREF;
        PrintToConsole("\tSecure reference counting\n");
        }
    else
        PrintToConsole("\tStandard reference counting\n");


    PrintToConsole("\tSecurity: authn: %d, imp: %d, legacy %S\n", authn, imp, pwstrLegacy);
    PrintToConsole("\tTimeout %d seconds, mid %I64x\n"
                   "\tpid %d, scm pid %d, token id: %d\n",
                   timeout, gLocalMid, pid, scm_pid, tokenid);
    PrintToConsole("\tReserved 5 oids, starting at %I64x\n", reservedBase);
    PrintToConsole("\tServer security services: %d\n", cServerSvc);
    for (i = 0; i < cServerSvc; i++ )
        {
        PrintToConsole("\t\tService: %d is %d\n", i, pServerSvc[i]);
        }
    PrintToConsole("\tClient security services: %d\n", cClientSvc);
    for (i = 0; i < cClientSvc; i++ )
        {
        PrintToConsole("\t\tService: %d is %d\n", i, pClientSvc[i]);
        }
    PrintDualStringArray("Local OR bindings", pdsaLocalOrBindings, TRUE);
    PrintToConsole("\n\n");

    MIDL_user_free(pServerSvc);
    MIDL_user_free(pClientSvc);
    return(RPC_S_OK);
}

// Synchronization between ortest clients and servers

void
SyncWithClient(DWORD Test)
// Called by server thread at start of each test sequence
{
    DWORD status;

    if (Test > 1) SetEvent(hClientEvent);

    PrintToConsole("Waiting for client sync: Test case %d\n", Test);

    // Wait for the client to finish his test case
    status = WaitForSingleObject(hServerEvent, 120*1000);

    if (status == WAIT_TIMEOUT)
        {
        ASSERT(("Client never called back", 0));
        }

    if (Test == ~0)
        {
        SetEvent(hClientEvent);
        Sleep(1000);
        }
    return;
}

// Managers for ortest servers

error_status_t
_TestBinding(
    handle_t hClient
    )
{
    return(RPC_S_OK);
}

error_status_t
_WaitForNextTest(handle_t hClient,
                 DWORD Test)
// Called by client after each test sequence.
{
    DWORD status;

    if (Test != TestCase)
        {
        ASSERT(("Test case sync wrong", 0));
        }

    SetEvent(hServerEvent);

    PrintToConsole("Client ready for test case %d\n", Test);

    status = WaitForSingleObject(hClientEvent, 60*20*1000);

    if (status == WAIT_TIMEOUT)
        {
        ASSERT(("Server never finished test case", 0));
        }

}

error_status_t
SyncWithServer(DWORD Test)
{
    RPC_STATUS status;

    status = WaitForNextTest(hServerOrTest, Test);

    EQUAL(status, RPC_S_OK);
    return(status);
}

error_status_t
_GetState(
    handle_t hClient,
    long cOxids,
    long cOids,
    long cOxidInfos,
    OXID aoxids[],
    OID  aoids[],
    OXID_INFO aois[],
    DUALSTRINGARRAY **ppdsaRemoteOrBindings
    )
{
    int i;
    for (i = 0; i < cOxids; i++)
        {
        aoxids[i] = aOxids[i];
        }
    for (i = 0; i < cOids; i++)
        {
        aoids[i] = aOids[i];
        }
    for(i = 0; i < cOxidInfos; i++)
        {
        aois[i].dwTid = aOxidInfo[i].dwTid;
        aois[i].dwPid = aOxidInfo[i].dwPid;
        aois[i].dwAuthnHint = aOxidInfo[i].dwAuthnHint;
        memcpy(&aois[i].ipidRemUnknown, &aOxidInfo[i].ipidRemUnknown, sizeof(IPID));
        aois[i].psa = 0;
        }
    *ppdsaRemoteOrBindings = MIDL_user_allocate(4 + pdsaLocalOrBindings->wNumEntries * 2);
    memcpy(*ppdsaRemoteOrBindings, pdsaLocalOrBindings, 4 + pdsaLocalOrBindings->wNumEntries * 2);
    return(RPC_S_OK);
}

// Managers for OR callbacks

error_status_t
_UseProtseq(
    IN handle_t hRpc,
    IN PWSTR pwstrProtseq,
    OUT DUALSTRINGARRAY **ppdsa,
    OUT DUALSTRINGARRAY **ppdsaSecurity
    )
{
    RPC_STATUS status;
    BOOL f;
    DWORD t;
    HANDLE hT;
    TOKEN_USER *ptu;
    BYTE  buffer[512];
    WCHAR buffer1[256];

    if (hRpc)
        {
        status = RpcImpersonateClient(0);
        ASSERT(status == RPC_S_OK);

        f = OpenThreadToken(GetCurrentThread(), TOKEN_IMPERSONATE | TOKEN_QUERY, TRUE, &hT);
        EQUAL(f, TRUE);
        CloseHandle(hT);
    
        f = OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hT);
        EQUAL(f, TRUE);
        }
    else
        {
        f = OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hT);
        EQUAL(f, TRUE);
        }

    f = GetTokenInformation(hT,
                            TokenUser,
                            buffer,
                            512,
                            &t);
    EQUAL(f, TRUE);
    ptu = (TOKEN_USER *)buffer;

    CloseHandle(hT);

    t = 256;
    f = GetUserNameW(buffer1, &t);
    if (f == FALSE)
        {
        PrintToConsole("Get user name failed %d\n", GetLastError());
        }

    PrintToConsole("UseProtseq %S called by %S:\n\t", pwstrProtseq, buffer1);
    PrintSid(ptu->User.Sid);

    RpcRevertToSelf();

    if (!fServer && _wcsicmp(pwstrProtseq, L"ncalrpc") != 0)
        {
        ASSERT(0);
        }

    status = RpcServerUseProtseqW(pwstrProtseq, 0, 0);
    ASSERT(status == RPC_S_OK);

    // Construct new bindings array.
    {
    RPC_BINDING_VECTOR * pbv;
    int i, j = 0;
    PWSTR pT = pdsaMyExpandedStringBindings->aStringArray;

    status = RpcServerInqBindings(&pbv);
    EQUAL(status, RPC_S_OK);

    for(i = 0; i < pbv->Count; i++)
        {
        PWSTR pStringBinding = 0;
        status = RpcBindingToStringBinding(pbv->BindingH[i], &pStringBinding);
        EQUAL(status, RPC_S_OK);

        wcscpy(pT, pStringBinding);
        j += wcslen(pT) + 1;
        pT = wcschr(pT, 0);
        pT++;

        status = RpcStringFree(&pStringBinding);
        EQUAL(status, RPC_S_OK);
        EQUAL(pStringBinding, 0);
        }
    
    *pT = 0;
    pdsaMyExpandedStringBindings->wNumEntries = j + 1 + 2;
    pdsaMyExpandedStringBindings->wSecurityOffset = j + 1;
    pT[1] = 0; // no security
    pT[2] = 0;
    }

    *ppdsa = MIDL_user_allocate(sizeof(DUALSTRINGARRAY) + pdsaMyExpandedStringBindings->wNumEntries * 2);

    ASSERT(*ppdsa);

    (*ppdsa)->wNumEntries = pdsaMyExpandedStringBindings->wNumEntries;
    (*ppdsa)->wSecurityOffset = pdsaMyExpandedStringBindings->wSecurityOffset;
    memcpy((*ppdsa)->aStringArray,
           pdsaMyExpandedStringBindings->aStringArray,
           pdsaMyExpandedStringBindings->wNumEntries * 2);


    *ppdsaSecurity = MIDL_user_allocate(sizeof(DUALSTRINGARRAY) + 6*2);
    ASSERT(*ppdsaSecurity);

    (*ppdsaSecurity)->wNumEntries = 6;
    (*ppdsaSecurity)->wSecurityOffset = 2;
    (*ppdsaSecurity)->aStringArray[0] = 0;
    (*ppdsaSecurity)->aStringArray[1] = 0;
    (*ppdsaSecurity)->aStringArray[2] = 10;  // authn winnt
    (*ppdsaSecurity)->aStringArray[3] = -1;  // authz none
    (*ppdsaSecurity)->aStringArray[4] = 0;
    (*ppdsaSecurity)->aStringArray[5] = 0;

    return(0);
}

error_status_t
_RawRundownOid(
    handle_t hRpc,
    ORPCTHIS *pthis,
    LOCALTHIS *plocalthis,
    ORPCTHAT *pthat,
    ULONG cOid,
    OID aOid[],
    UCHAR afOk[]
    )
{
    int i, j;
    RPC_STATUS status;
    BOOL fFound;
    IPID ipidT;
    UCHAR buffer[512];
    WCHAR buffer1[256];
    DWORD t;
    BOOL f;
    HANDLE hT;
    TOKEN_USER *ptu;

    ASSERT(cOid);
    ASSERT(plocalthis->callcat == CALLCAT_SYNCHRONOUS);
    ASSERT(plocalthis->dwClientThread == 0);
    ASSERT(pthis->extensions == 0);
    ASSERT(pthis->version.MajorVersion == COM_MAJOR_VERSION);
    ASSERT(pthis->version.MinorVersion == COM_MINOR_VERSION);
    ASSERT(pthis->flags == ORPCF_LOCAL);
    ASSERT(pthis->reserved1 == 0);
    ASSERT(pthat->extensions == 0);
    pthat->flags = 0;

    status = RpcImpersonateClient(0);
    ASSERT(status == RPC_S_OK);

    t = 256;
    f = GetUserNameW(buffer1, &t);
    if (f == FALSE)
        {
        PrintToConsole("Get user name failed %d\n", GetLastError());
        }
    
    f = OpenThreadToken(GetCurrentThread(), TOKEN_IMPERSONATE | TOKEN_QUERY, TRUE, &hT);
    EQUAL(f, TRUE);
    CloseHandle(hT);

    f = OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hT);
    EQUAL(f, TRUE);

    f = GetTokenInformation(hT,
                            TokenUser,
                            buffer,
                            512,
                            &t);
    EQUAL(f, TRUE);
    ptu = (TOKEN_USER *)buffer;

    CloseHandle(hT);

    status = RpcBindingInqObject(hRpc, &ipidT);
    ASSERT(status == RPC_S_OK);

    PrintToConsole("Rundown of %d oids called by %S:\n\t", cOid, buffer1);
    PrintSid(ptu->User.Sid);

    for (j = 0; j < cOid; j++)
        {
        fFound = FALSE;

        PrintToConsole("Oid %I64x randown\n", aOid[j]);

        for(i = 0; i < dwlimRundowns; i++)
            {
            if (aOid[j] == aRundowns[i].oid)
                {
                fFound = TRUE;
                if (aRundowns[i].fForceSecond)
                    {
                    aRundowns[i].fForceSecond = FALSE;
                    afOk[j] = 0;
                    }
                else
                    {
                    afOk[j] = 1;
                    EQUAL(aRundowns[i].fReady, TRUE);
                    aRundowns[i].fReady = FALSE;

                    aRundowns[i].oid = aRundowns[dwlimRundowns - 1].oid;
                    aRundowns[i].fReady = aRundowns[dwlimRundowns - 1].fReady;
                    aRundowns[i].fForceSecond = aRundowns[dwlimRundowns - 1].fForceSecond;
                    dwlimRundowns--;

                    SetEvent(hRundownEvent);
                    }
                }
            }

        if (!fFound)
            {
            PrintToConsole("Unexpected oid rundown: %I64x\n", aOid[j]);
            afOk[j] = 1;
            }
        }

    RpcRevertToSelf();
    return(0);

}

// Unimplement IRundown base methods

HRESULT
_DummyQueryInterfaceIOSCM(
    handle_t rpc,
    ORPCTHIS *pthis,
    LOCALTHIS *plocalthis,
    ORPCTHAT *pthat,
    DWORD dummy)
{
    ASSERT(0);
}

HRESULT
_DummyAddRefIOSCM(
    handle_t rpc,
    ORPCTHIS *pthis,
    LOCALTHIS *plocalthis,
    ORPCTHAT *pthat,
    DWORD dummy)
{
    ASSERT(0);
}

HRESULT
_DummyReleaseIOSCM(
    handle_t rpc,
    ORPCTHIS *pthis,
    LOCALTHIS *plocalthis,
    ORPCTHAT *pthat,
    DWORD dummy)
{
    ASSERT(0);
}

HRESULT
_DummyRemQuery(
    handle_t handle
    )
{
    ASSERT(0);
}


HRESULT
_DummyRemAddRef(
    handle_t handle
    )
{
    ASSERT(0);
}


HRESULT
_DummyRemRelease(
    handle_t handle
    )
{
    ASSERT(0);
}

HRESULT
_DummyRemChangeRef(
    handle_t handle
    )
{
    ASSERT(0);
}

HRESULT
_DummyRemQueryInterface2(
    handle_t handle
    )
{
    ASSERT(0);
}

// Rundown helpers

void
AddRundown(ID oid, BOOL fRundownTwice)
{
    aRundowns[dwlimRundowns].oid = oid;
    aRundowns[dwlimRundowns].fReady = TRUE;
    aRundowns[dwlimRundowns].fForceSecond = fRundownTwice;

    dwlimRundowns++;
}

void WaitForAllRundowns()
{
    DWORD status;
    int i;
    BOOL fDone;

    PrintToConsole("Waiting for rundowns...\n");

    for(;;)
        {
        status = WaitForSingleObject(hRundownEvent, 19 * 60 * 1000);

        if (status == WAIT_TIMEOUT)
            {
            PrintToConsole("Wait for rundowns took a long time...\n");
            ASSERT(0);
            }

        fDone = TRUE;

        for(i = 0; i < dwlimRundowns; i++)
            {
            if (aRundowns[i].fReady)
                {
                fDone = FALSE;
                }
            }

        if (fDone)
            {
            return;
            }
        }
}

// Needs to link rtifs.lib, but shouldn't be called..
void FixupForUniquePointerServers(void *p)
{
    ASSERT(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\objex\callid.cxx ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    callid.cxx

Abstract:

    Implements a cache of callids used for running down OIDs

    This is almost twice as fast as UuidCreate() but that doesn't
    mean much.  UuidCreate takes 3 microseconds, this 1.4 (hit) or
    4.2 (miss) on a P90.

    This codes real advantage would be on MP machines.  But it is
    not performance critical and is probably overkill.

Author:

    Mario Goertzel    [MarioGo]

Revision History:

    MarioGo     1/18/1996    Bits 'n pieces

--*/

#include <or.hxx>

enum CacheState { CallidEmpty = 0,
                  CallidAllocated = 1,
                  CallidFree = -1 };
                  
struct CacheElement
    {
    CacheState  _state;
    UUID        _callid;
    };

CacheElement CallidCache[4] = { CallidEmpty, {0},
                                CallidEmpty, {0},
                                CallidEmpty, {0},
                                CallidEmpty, {0} };


INT
AllocateCallId(
    OUT UUID &Callid
    )
{
    INT i;
    LONG l;
    RPC_STATUS status;

    for (i = 0; i < 4; i++)
        {
        if (CallidCache[i]._state != CallidAllocated)
            {
            l = InterlockedExchange((PLONG)&CallidCache[i]._state, CallidAllocated);

            switch(l)
                {
                case CallidAllocated:
                    continue;

                case CallidFree:
                    Callid = CallidCache[i]._callid;
                    return(i);

                case CallidEmpty:
                    status = UuidCreate(&Callid);
                    VALIDATE((status, RPC_S_UUID_LOCAL_ONLY, RPC_S_OK, 0));
                    CallidCache[i]._callid = Callid;
                    return(i);
                }
            }
        }
    status = UuidCreate(&Callid);
    VALIDATE((status, RPC_S_UUID_LOCAL_ONLY, RPC_S_OK, 0));
    return(-1);
    }


void
FreeCallId(
    IN INT hint
    )
/*++

Routine Description:

    Frees a callid previously allcoated with AllocateCallId().

Arguments:

    hint - The hint value returned by the previous call to AllocateCallId().

Return Value:

    None

--*/
{
    ASSERT((hint > -2) && (hint < 4));

    if (hint >= 0)
        {
        CallidCache[hint]._state = CallidFree;;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\objex\locks.cxx ===
/*++

Copyright (c) 1995-1996 Microsoft Corporation

Module Name:

    Locks.cxx

Abstract:

    Out of line methods for some of the syncronization classes
    defined in locks.hxx.

Author:

    Mario Goertzel    [MarioGo]

Revision History:

    MarioGo     03-14-95    Moved from misc.cxx.
    MarioGo     01-27-96    Changed from busy (Sleep(0)) wait to event

--*/

#include <or.hxx>

//
// CShareLock methods
//

CSharedLock::CSharedLock(ORSTATUS &status)
{
    exclusive_owner = 0;
    hevent = 0;
    status = RtlInitializeCriticalSection(&lock);
    if (NT_SUCCESS(status))
        {
        hevent = CreateEvent(0, FALSE, FALSE, 0);
        if (0 == hevent)
            {
            status = OR_NOMEM;
            }
        }
}

CSharedLock::~CSharedLock()
{
    // Cannot be deleted if it failed to initialize
    NTSTATUS status = RtlDeleteCriticalSection(&lock);
    ASSERT(NT_SUCCESS(status));
    if (hevent) CloseHandle(hevent);
}

void
CSharedLock::LockShared()
{
    readers++;

    if (writers)
        {
        if ((readers--) == 0)
            {
            SetEvent(hevent);
            }

        EnterCriticalSection(&lock);
        readers++;
        LeaveCriticalSection(&lock);
        }

    exclusive_owner = 0;
}

void
CSharedLock::UnlockShared(void)
{
    ASSERT((LONG)readers > 0);
    ASSERT(exclusive_owner == 0);

    if ( (readers--) == 0 && writers)
        {
        SetEvent(hevent);
        }
}

void
CSharedLock::LockExclusive(void)
{
    EnterCriticalSection(&lock);
    writers++;
    while(readers)
        {
        WaitForSingleObject(hevent, INFINITE);
        }
    ASSERT(writers);
    exclusive_owner = GetCurrentThreadId();
}

void
CSharedLock::UnlockExclusive(void)
{
    ASSERT(HeldExclusive());
    ASSERT(writers);
    writers--;
    exclusive_owner = 0;
    LeaveCriticalSection(&lock);
}

void
CSharedLock::Unlock()
{
    // Either the lock is held exclusively by this thread or the thread
    // has a shared lock. (or the caller has a bug).

    if (HeldExclusive())
        {
        UnlockExclusive();
        }
    else
        {
        UnlockShared();
        }
}

void
CSharedLock::ConvertToExclusive(void)
{
    ASSERT((LONG)readers > 0);
    ASSERT(exclusive_owner == 0);

    if ( (readers--) == 0 && writers )
        SetEvent(hevent);

    EnterCriticalSection(&lock);
    writers++;
    while(readers)
        {
        WaitForSingleObject(hevent, INFINITE);
        }
    ASSERT(writers);
    exclusive_owner = GetCurrentThreadId();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\objex\gentable.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    Table.cxx

Abstract:

    Implementation of the CHashTable and CTableElement.

Author:

    Mario Goertzel    [MarioGo]

Revision History:

    MarioGo     02-15-95    Bits 'n pieces
    MarioGo     12-18-95    Changed from UUID to generic object keys

--*/

#include<or.hxx>

CTableElement *
CTableElement::RemoveMatching(
    IN CTableKey &tk,
    OUT CTableElement **ppRemoved)
/*++

Routine Description:

    Helper function used to remove an element from a
    bucket in the hash table.

Arguments:

    tk - Key to find the element being removed.

    ppRemoved - Contains the element removed or NULL upon return.

Return Value:

    Pointer to the remaining elements in the list if any.  Use
    to replace the current pointer in the bucket.

--*/
{
    CTableElement *pcurrent = this;
    CTableElement *psaved = 0;
    CTableElement *pfirst = this;

    while(pcurrent)
        {
        if (pcurrent->Compare(tk))
            {
            *ppRemoved = pcurrent;
            if (0 != psaved)
                {
                psaved->_pnext = pcurrent->_pnext;
                pcurrent->_pnext = 0;
                return(pfirst);
                }
            else
                {
                // removing the first element in the list
                ASSERT(pcurrent == pfirst);
                psaved = pcurrent->_pnext;
                pcurrent->_pnext = 0;
                return(psaved);
                }
            }

        psaved = pcurrent;
        pcurrent = pcurrent->_pnext;
        }

    *ppRemoved = 0;
    return(pfirst);
}


CTableElement *
CTableElement::RemoveMatching(
    IN CTableElement *pte,
    OUT CTableElement **ppRemoved)
/*++

Routine Description:

    Helper function used to remove an element from a bucket in the hash table.

Arguments:

    pte - Element to be removed, compared by pointer value.

    ppRemoved - Contains the element removed or NULL upon return.

Return Value:

    Pointer to the remaining elements in the list if any.  Use
    to replace the current pointer in the bucket.

--*/
{
    CTableElement *pcurrent = this;
    CTableElement *psaved = 0;
    CTableElement *pfirst = this;

    while(pcurrent)
        {
        if (pcurrent == pte)
            {
            *ppRemoved = pcurrent;
            if (0 != psaved)
                {
                psaved->_pnext = pcurrent->_pnext;
                pcurrent->_pnext = 0;
                return(pfirst);
                }
            else
                {
                // removing the first element in the list
                ASSERT(pcurrent == pfirst);
                psaved = pcurrent->_pnext;
                pcurrent->_pnext = 0;
                return(psaved);
                }
            }

        psaved = pcurrent;
        pcurrent = pcurrent->_pnext;
        }

    *ppRemoved = 0;
    return(pfirst);
}

CHashTable::CHashTable(ORSTATUS &status, UINT start_size)
{
    _cBuckets = start_size;
    _cElements = 0;
    _last = 0;

    _buckets = new CTableElement *[start_size];

    if (0 == _buckets)
        {
        status = OR_NOMEM;
        return;
        }

    for(UINT i = 0; i < _cBuckets; i++)
        {
        _buckets[i] = NULL;
        }

    status = OR_OK;
}


CHashTable::~CHashTable()
{
#if 0
#if DBG
    for(UINT i = 0; i < _cBuckets; i++)
        ASSERT(_buckets[i] == 0);
#endif
    delete _buckets;
#endif
    ASSERT(0);  // D'tor unused 12/95
}

CTableElement *
CHashTable::Lookup(
    IN CTableKey &id
    )
{
    DWORD hash = id.Hash();
    CTableElement *it;

    it = _buckets[hash % _cBuckets];

    while(it)
        {
        if (it->Compare(id))
            {
            return(it);
            }

        it = it->Next();
        }

    return(0);
}

void
CHashTable::Add(
    IN CTableElement *pElement
    )
{
    DWORD hash = pElement->Hash();

    hash %= _cBuckets;

    _buckets[hash] = _buckets[hash]->Insert(pElement);

    _cElements++;

    if (_cElements > _cBuckets)
        {
        // Try to grow the table.  If the allocation fails no need to worry,
        // everything still works but might be a bit slower.

        CTableElement **ppte = new CTableElement *[_cBuckets * 2];

        if (ppte)
            {
            UINT i, uiBucketsOld = _cBuckets;
            CTableElement *pteT1, *pteT2;
            CTableElement **ppteOld = _buckets;

            KdPrintEx((DPFLTR_DCOMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "OR: Growing table: %p\n",
                       this));

            // Change to the larger array of buckets.
            _cBuckets *= 2;
            for(i = 0; i < _cBuckets; i++)
                {
                ppte[i] = NULL;
                }
            _buckets = ppte;

            // Move every element from the old table into the large table.
            for(i = 0; i < uiBucketsOld; i++)
                {
                pteT1 = ppteOld[i];

                while(pteT1)
                    {
                    pteT2 = pteT1->Next();
                    pteT1->Unlink();

                    // Same as calling Add() but don't update _cElements.
                    hash = pteT1->Hash();
                    hash %= _cBuckets;
                    _buckets[hash] = _buckets[hash]->Insert(pteT1);

                    pteT1 = pteT2;
                    }
                }
            }
        }

    return;
}

CTableElement *
CHashTable::Remove(
    IN CTableKey &id
    )
/*++

Routine Description:

    Looks up and removes an element from the table.

Arguments:

    id - The key to match the element to be removed

Return Value:

    NULL - The element was not in the table

    non-NULL - A pointer to the element which was removed.

--*/

{
    DWORD hash = id.Hash();
    CTableElement *pte;

    hash %= _cBuckets;

    _buckets[hash] = (_buckets[hash])->RemoveMatching(id, &pte);

    if (pte)
        {
        _cElements--;

        if (_last == pte)
            {
            _last = _buckets[hash];
            }
        }

    return pte;
}

void
CHashTable::Remove(
    IN CTableElement *pElement
    )
/*++

Routine Description:

    Used to remove an element from the table given a pointer to it.

Arguments:

    pElement - the element to be removed.  This pointer value,
        keys are not compared.

Return Value:

    None

--*/

{
    DWORD hash = pElement->Hash();
    CTableElement *pte;

    hash %= _cBuckets;

    _buckets[hash] = (_buckets[hash])->RemoveMatching(pElement, &pte);

    if (pte)
        {
        ASSERT(pte == pElement);

        _cElements--;

        if (_last == pElement)
            {
            _last = _buckets[hash];
            }
        }

    return;
}

CTableElement *
CHashTable::Another(
    )
/*++

Routine Description:

    Returns an element from the table.  Usually this will be
    element found after the element last returned from this
    function.  It may, due to races not solved here, repeat
    an element or skip an element.

       Races occur when accessing the "_last" memeber; this
    function is called while holding a shared lock. (More
    then one thread may call it at a time.)

    This isn't as bad as it sounds.  _last can only
    be set to null in Remove() which requires exclusive
    access.

Arguments:

    None

Return Value:

    NULL or a pointer to an element in the table.

--*/

{
    CTableElement *panother;
    int i, end;

    if (_cElements == 0)
        {
        return(0);
        }

    if (_last)
        {
        if (panother = _last->Next())
            {
            if (panother)
                {
                _last = panother;
                return(panother);
                }
            }

        ASSERT(panother == 0);

        // no next, start looking from just after last's hash.

        i = _last->Hash();

        // Exersise for the reader  (x + y) mod n == ( x mod n + y mod n ) mod n

        end = i = (i + 1) % _cBuckets;
        }
    else
        {
        // no last, start from the start.
        i = 0;
        end = _cBuckets - 1;
        }

    do
        {
        if (_buckets[i])
            {
            panother = _buckets[i];
            ASSERT(panother);
            _last = panother;
            return(panother);
            }
        i = (i + 1) % _cBuckets;
        }
    while (i != end);

    // Doesn't mean the table is empty, just that we didn't find
    // another element.  These are not the same thing.
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\objex\mid.cxx ===
/*++

Copyright (c) 1995-1996 Microsoft Corporation

Module Name:

    Mid.cxx

Abstract:

    Implements the CMid class.

Author:

    Mario Goertzel    [MarioGo]

Revision History:

    MarioGo     12-13-95    Bits 'n pieces
    MarioGo     02-01-96    Move binding handles out of mid

--*/


#include<or.hxx>

class CObjexPPing : public CParallelPing
{
public:
    CObjexPPing(WCHAR *pBindings, CMid *pMid) :
        _pBindings(pBindings),
        _pMid(pMid)
        {}


    BOOL NextCall(PROTSEQINFO *pProtseqInfo)
    {
        if (*_pBindings)
        {
            pProtseqInfo->pvUserInfo = _pBindings;
            pProtseqInfo->hRpc     = _pMid->MakeBinding(_pBindings);
            _pBindings =  OrStringSearch(_pBindings, 0) +1;
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }

    void ReleaseCall(PROTSEQINFO *pProtseqInfo)
    {
        if (pProtseqInfo->hRpc)
        {
            RpcBindingFree(&pProtseqInfo->hRpc);
        }
    }
private:
    WCHAR *    _pBindings;
    CMid  *    _pMid;
};

void dsaProtocolMerge(DUALSTRINGARRAY *pdsaSrc, DUALSTRINGARRAY **ppdsaDest)
/*++

Routine Description:

    Gives string bindings intersected with the allowed string bindings
    for this machine.

Arguments:

    pdsaSrc - string bindings to intersect
    ppdsaDest - generated string bindings

Return Value:

    none

--*/

{

    *ppdsaDest =  (DUALSTRINGARRAY *)PrivMemAlloc(pdsaSrc->wNumEntries*sizeof(WCHAR) + sizeof(DUALSTRINGARRAY));
    if (!*ppdsaDest)
    {
        return;
    }

    LPWSTR pTempDest = (*ppdsaDest)->aStringArray;


    // NOTE: Do not change the order of these loops
    // It is pertinent to correctly order the final
    // string.

    for (ULONG i=0; i<cMyProtseqs; i++)
    {
        for (LPWSTR pTempSrc = pdsaSrc->aStringArray;
            *pTempSrc;
            pTempSrc = OrStringSearch(pTempSrc, 0) + 1)
        {
            if (aMyProtseqs[i] == *pTempSrc)
            {
                // tower ids are the same
                wcscpy(pTempDest, pTempSrc);
                pTempDest = OrStringSearch(pTempDest, 0) + 1;
            }
        }
    }

    ULONG_PTR len = pTempDest - (*ppdsaDest)->aStringArray;
    if ( len  == 0)
    {
        *pTempDest = 0;
        pTempDest++;
        len++;
    }

    // copy sec bindings
    *pTempDest = 0;
    pTempDest++;
    len++;

    (*ppdsaDest)->wSecurityOffset = (USHORT) len;

    memcpy(pTempDest, pdsaSrc->aStringArray + pdsaSrc->wSecurityOffset,
           (pdsaSrc->wNumEntries - pdsaSrc->wSecurityOffset)*sizeof(WCHAR));

    len += pdsaSrc->wNumEntries - pdsaSrc->wSecurityOffset;
    (*ppdsaDest)->wNumEntries = (USHORT) len;

}

CMid::CMid( DUALSTRINGARRAY *pdsa, BOOL fLocal, ID OldMid ) :
    _fLocal(fLocal),
    _fStale(FALSE),
    _fDynamic(FALSE),
    _fInitialized(FALSE),
    _StringBinding(NULL),
    _fSecure(FALSE),
    _pdsaValidStringBindings(0)
/*++

Routine Description:

    Constructs a CMid object.

Arguments:

    pdsa - The dual string array of the server rpcss.
    fLocal - TRUE if the mid represents this machine.
    OldMid - Optional reassigned machine id.

Return Value:

    none

--*/
{
    DWORD i;

    // this must be allocated to include the size of the embedded dsa.
    dsaCopy(&_dsa, pdsa);

    // Set _fSecure iff we find an authentication service in the
    // dual string array that we are willing to use.
    _wAuthnSvc = RPC_C_AUTHN_NONE;
    for (i = 0; i < s_cRpcssSvc; i++)
    {
        if (ValidAuthnSvc( &_dsa, s_aRpcssSvc[i].wId ))
        {
            _fSecure = TRUE;
        break;
        }
    }

    if (OldMid)
    {
        _id = OldMid;
        ASSERT(fLocal);
    }
    else
    {
        _id = AllocateId();
    }
}

RPC_BINDING_HANDLE
CMid::MakeBinding(WCHAR *pBinding)
/*++

Routine Description:

    Creates a binding handle from a specified string binding or a default
    string binding with or without an endpoint.

Arguments:

    pBinding - The string binding to use or NULL for the default.

Return Value:

    binding handle

--*/
{
    if (!pBinding)
    {
        pBinding = _StringBinding;
    }
    if (pBinding)
    {
        if (_fDynamic)
        {
            // Create binding without an endpoint.
            return ::GetBinding(pBinding);
        }
        else
        {
            return GetBindingToOr(pBinding);
        }
    }
    return 0;
}


RPC_BINDING_HANDLE
CMid::GetBinding()
/*++

Routine Description:

    Gets an RPC binding handle to the remote machine.

Arguments:

    None
    
Return Value:

    0 - when no more binding are available.

    non-zero - A binding to the machine.

--*/
{

    if (IsLocal())
    {
        return(0);
    }

    //
    // if the Mid is already initialized, then just
    // return the binding.
    //

    if (_fInitialized)
    {
        return MakeBinding();
    }

    //
    // merge the strings 
    //
    DUALSTRINGARRAY *pdsaValidStringBindings = 0;

    if (!_pdsaValidStringBindings)
    {
        // merge with valid protocols for this server

        gpClientLock->LockExclusive();

        if (!_pdsaValidStringBindings)
        {
          dsaProtocolMerge(&_dsa, &pdsaValidStringBindings);
 
          if (!pdsaValidStringBindings)
          {
            gpClientLock->UnlockExclusive();
            return 0;
          }
          
          ASSERT(pdsaValidStringBindings);
          _pdsaValidStringBindings = pdsaValidStringBindings;          
        }
        
        gpClientLock->UnlockExclusive();
    }

    // Ping the server on all bindings in parallel to get
    // the correct binding for this server.  This loop executes
    // twice to try the bindings w/o the endpoint.
    //

    ULONG ndx;
    BOOL bNoEndpoint = FALSE;
    RPC_BINDING_HANDLE hserver = NULL;


    { // scope the parallel ping object

        CObjexPPing ping(_pdsaValidStringBindings->aStringArray, this);
        RPC_STATUS status;

        for (;;)
        {
            status = ping.Ping();

            if ( RPC_S_UNKNOWN_IF == status )
            {
                if ( ! bNoEndpoint )
                {
                    for ( unsigned int ProtseqIndex = 0; ProtseqIndex < ping.HandleCount(); ProtseqIndex++ )
                    {
                        RPC_BINDING_HANDLE tmpBinding;
                        status = RpcBindingCopy( ping.Info(ProtseqIndex)->hRpc, &tmpBinding);                        
                        if (status != RPC_S_OK)
                            break;
                            
                        status = RpcBindingFree( &(ping.Info(ProtseqIndex)->hRpc));                        
                        if (status != RPC_S_OK)
                        {
                            RpcBindingFree(&tmpBinding);
                            break;
                        }
                            
                        status = RpcBindingReset(tmpBinding);
                        if (status != RPC_S_OK)
                        {
                            RpcBindingFree(&tmpBinding);
                            break;
                        }
                        
                        ping.Info(ProtseqIndex)->hRpc = tmpBinding;
                    }
                    bNoEndpoint = TRUE;
                    continue;
                }
            }
            if (status == RPC_S_OK && bNoEndpoint)
            {
                _fDynamic = TRUE;
            }
            break;
        }
        if (status == RPC_S_OK)
        {
            hserver = ping.GetWinner()->hRpc;
            ping.GetWinner()->hRpc = NULL;
          
            if (!_StringBinding)
            {
              gpClientLock->LockExclusive();
              if (!_StringBinding)
              {
                  _StringBinding = (WCHAR *) ping.GetWinner()->pvUserInfo;
              }
              gpClientLock->UnlockExclusive();
            }
       }

        ping.Reset();
    } // end scope for ping object

    //
    // the mid is initialized now
    //
    _fInitialized = TRUE;

    return hserver;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\objex\manager.cxx ===
/*++

Copyright (c) 1995-1996 Microsoft Corporation

Module Name:

    Manager.cxx

Abstract:

    Stub/OR interface

Author:

    Mario Goertzel    [mariogo]       Feb-02-1995

Revision Hist:

        MarioGo         02-10-95      Bits 'n pieces
        MarioGo         01-31-96      New local and remote interfaces
        TarunA          10-12-98      OXIDs are referenced on OID basis (Client side)
        TarunA          10-31-98      Added PID of the process connecting

        a-sergiv        07-09-99      Impersonate for the entire duration of
                                      ResolveClientOXID for ncacn_http protocol
                                      (to fix a bad COM Internet Services bug)
--*/

#include <or.hxx>
extern "C"
{
#include <inc.hxx>
}

// These variables hold the list of channel hooks registered for the machine.
// They are updated as the registry changes.
LONG       s_cChannelHook    = 0;
GUID      *s_aChannelHook    = NULL;
HANDLE     s_hChannelHook    = NULL;

// Definition of single instance of this class:
CRpcSecurityCallbackManager* gpCRpcSecurityCallbackMgr;
CPingSetQuotaManager* gpPingSetQuotaManager;

//
// Helper routines
//

extern void CheckLocalCall(IN  handle_t hRpc);

extern BOOL gbDynamicIPChangesEnabled;

void
CheckLocalSecurity(
                  IN handle_t  hClient,
                  IN CProcess *pProcess
                  )
/*++

Routine Description:

    Checks that a client is correctly calling one of the local
    (lclor.idl) methods.

Arguments:

    hClient - Rpc binding handle (SCALL) of the call in progress. If NULL,
        then the call is being made internally and is okay.

    pProcess - Context handle passed in by the client. Must not be zero.

Return Value:

    Raises OR_NOACCESS if not okay.

--*/

{
    UINT type;

    if (   (0 != hClient)
           && (   (I_RpcBindingInqTransportType(hClient, &type) != RPC_S_OK)
                  || (type != TRANSPORT_TYPE_LPC)
                  || (0 == pProcess) ) )
    {
        RpcRaiseException(OR_NOACCESS);
    }

    // pProcess is not needed here.  On LRPC the RPC runtime
    // prevents a different local clients from using a context handle
    // of another client.

    return;
}

//
// Update the channel hook list if it has changed in the registry.
//

void UpdateChannelHooks( LONG *pcChannelHook, GUID **paChannelHook )
{
    BOOL   fSuccess;
    BOOL   fUpdate = FALSE;
    DWORD  result;
    HKEY   hKey;
    DWORD  lType;
    DWORD  lDataSize;
    GUID  *aChannelHook;
    LONG   cChannelHook;
    DWORD  i;
    DWORD  lExtent;
    WCHAR  wExtent[39];
    DWORD  j;

    // Lock
    gpClientLock->LockExclusive();

    // If the handle hasn't been created, create it.
    if (s_hChannelHook == NULL)
    {
        // Nothing can be done if the event can't be created.
        s_hChannelHook = CreateEvent(NULL, FALSE, FALSE, NULL);
        fUpdate = TRUE;
    }

    // If the handle has been created, see if it has been signalled.
    else
    {
        result = WaitForSingleObject(s_hChannelHook, 0);
        fUpdate = result == WAIT_OBJECT_0;
    }

    // Reread the registry if necessary.
    if (fUpdate)
    {

        // Register for changes.
        RegNotifyChangeKeyValue( s_hOle, TRUE,
                                 REG_NOTIFY_CHANGE_NAME       |
                                 REG_NOTIFY_CHANGE_ATTRIBUTES |
                                 REG_NOTIFY_CHANGE_LAST_SET   |
                                 REG_NOTIFY_CHANGE_SECURITY,
                                 s_hChannelHook, TRUE );

        // Open the channel hook key.
        result = RegOpenKeyEx( s_hOle, L"ChannelHook",
                               NULL, KEY_QUERY_VALUE, &hKey );
        if (result == ERROR_SUCCESS)
        {
            // Find out how many values exist.
            cChannelHook = 0;
            RegQueryInfoKey( hKey, NULL, NULL, NULL, NULL, NULL, NULL,
                             (DWORD *) &cChannelHook, NULL, NULL, NULL, NULL );

            // If there are no channel hooks, throw away the old data.
            if (cChannelHook == 0)
            {
                delete s_aChannelHook;
                s_aChannelHook = NULL;
                s_cChannelHook = 0;
                aChannelHook   = NULL;
            }

            // Reuse the existing array.
            else if (cChannelHook <= s_cChannelHook)
                aChannelHook = s_aChannelHook;

            // Allocate memory for them.
            else
                aChannelHook = new GUID[cChannelHook];

            // If there is not enough memory, don't make changes.
            if (aChannelHook != NULL)
            {

                // Enumerate over the channel hook ids.
                j = 0;
                for (i = 0; i < (DWORD)cChannelHook; i++)
                {

                    // Get the next key.
                    lExtent = sizeof(wExtent) / sizeof(WCHAR);
                    result = RegEnumValueW( hKey, i, wExtent, &lExtent, NULL,
                                           &lType, NULL, NULL );

                    // Convert it to a GUID.  Note that lExtent is set to
                    // the length in characters not bytes despite what
                    // the documentation says.
                    if (result == ERROR_SUCCESS && lExtent == 38 &&
                        lType == REG_SZ &&
                        GUIDFromString( wExtent, &aChannelHook[j] ))
                        j += 1;
                }

                // Save the new channel hook array.
                if (aChannelHook != s_aChannelHook)
                    delete s_aChannelHook;
                s_aChannelHook = aChannelHook;
                s_cChannelHook = j;
            }

            // Close the registry key.
            RegCloseKey( hKey );
        }

        // There are no channel hooks.  Throw away the old data.
        else
        {
            delete s_aChannelHook;
            s_aChannelHook = NULL;
            s_cChannelHook = 0;
        }
    }

    // Return the current channel hook list.
    *paChannelHook = (GUID *) MIDL_user_allocate( s_cChannelHook * sizeof(GUID) );
    if (*paChannelHook != NULL)
    {
        *pcChannelHook = s_cChannelHook;
        memcpy( *paChannelHook, s_aChannelHook, s_cChannelHook * sizeof(GUID) );
    }
    else
        *pcChannelHook = 0;

    // Unlock
    gpClientLock->UnlockExclusive();
}

//
//    Manager (server-side) calls to the local OR interface. lclor.idl
//

error_status_t
_Connect(
    IN  handle_t          hClient,
    IN  WCHAR            *pwszWinstaDesktop,
    IN  DWORD             procID,
    IN  DWORD             dwFlags,
    OUT PHPROCESS        *phProcess,
    OUT DWORD            *pTimeoutInSeconds,
    OUT DUALSTRINGARRAY **ppdsaOrBindings,
    OUT MID              *pLocalMid,
    IN  LONG              cIdsToReserve,
    OUT ID               *pidReservedBase,
    OUT DWORD            *pfConnectFlags,
    OUT WCHAR           **pLegacySecurity,
    OUT DWORD            *pAuthnLevel,
    OUT DWORD            *pImpLevel,
    OUT DWORD            *pcServerSvc,
    OUT USHORT          **aServerSvc,
    OUT DWORD            *pcClientSvc,
    OUT SECPKG          **aClientSvc,
    OUT LONG             *pcChannelHook,
    OUT GUID            **paChannelHook,
    OUT DWORD            *pThreadID,
    OUT DWORD            *pScmProcessID,
    OUT ULONG64          *pSignature,
    OUT GUID             *pguidRPCSSProcessIdentifier
    )
{
    ORSTATUS status;
    CProcess *pProcess;
    CToken *pToken;
    BOOL fRet;
	
    // Ensure this is a local client calling (raises an exception
    // if this is not the case):
    CheckLocalCall(hClient);

    // Parameter validation
    if (!pwszWinstaDesktop || !phProcess || !pTimeoutInSeconds ||
        !ppdsaOrBindings || !pLocalMid || !pidReservedBase ||
        !pfConnectFlags || !pLegacySecurity || !pAuthnLevel ||
        !pImpLevel || !pcServerSvc || !aServerSvc || !pcClientSvc ||
        !aClientSvc ||!pcChannelHook || !paChannelHook || !pThreadID ||
        !pScmProcessID || !pSignature)
    {
        return OR_BADPARAM;
    }

    KdPrintEx((DPFLTR_DCOMSS_ID,
               DPFLTR_INFO_LEVEL,
               "OR: Client connected\n"));

    *pfConnectFlags = 0;

    // Fill in security parameters.
    if (s_fEnableDCOM == FALSE)   *pfConnectFlags |= CONNECT_DISABLEDCOM;
    if (s_fCatchServerExceptions) *pfConnectFlags |= CONNECT_CATCH_SERVER_EXCEPTIONS;
    if (s_fBreakOnSilencedServerExceptions) *pfConnectFlags |= CONNECT_BREAK_ON_SILENCED_SERVER_EXCEPTIONS;
    if (s_fMutualAuth) *pfConnectFlags |= CONNECT_MUTUALAUTH;
    if (s_fSecureRefs) *pfConnectFlags |= CONNECT_SECUREREF;

    *pAuthnLevel       = s_lAuthnLevel;
    *pImpLevel         = s_lImpLevel;
	
    // Get legacy security settings
    fRet = GetLegacySecurity(pLegacySecurity);
    if (!fRet)
    {
        return OR_NOMEM;
    }

    // Get client\server svcs
    fRet = GetClientServerSvcs(pcClientSvc, aClientSvc, pcServerSvc, aServerSvc);
    if (!fRet)
    {
        return OR_NOMEM;
    }

    // Fill in channel hooks.
    UpdateChannelHooks( pcChannelHook, paChannelHook );

    *pSignature = 0;

    // This fails during setup but RPCSS can function anyway.
    RegisterAuthInfoIfNecessary();

    status = StartListeningIfNecessary();

    if (status != OR_OK)
    {
        return(status);
    }

    // Do client specific stuff
    status = CopyMyOrBindings(ppdsaOrBindings, NULL);
    if (status != OR_OK)
    {
        return(status);
    }

    status = LookupOrCreateToken(hClient, TRUE, &pToken); // Will check security
    if (status != OR_OK)
    {
        MIDL_user_free(*ppdsaOrBindings);
        *ppdsaOrBindings = 0;
        return(status);
    }

    gpClientLock->LockShared();

    pProcess = new CProcess(pToken, pwszWinstaDesktop, procID, dwFlags, status);
    if (pProcess && status == OR_OK)
    {
        *phProcess = (void *)pProcess;
    }
    else
    {
        if (pProcess)
        {
            gpClientLock->UnlockShared(); // Rundown takes an exclusive
            ReleaseProcess(pProcess);
            gpClientLock->LockShared(); // take it back
        }
        else
        {
            status = OR_NOMEM;
        }
    }

    if (status != OR_OK)
    {
        gpClientLock->ConvertToExclusive();
        MIDL_user_free(*ppdsaOrBindings);
        *ppdsaOrBindings = 0;
        *phProcess = 0;
        if ( pToken )
            pToken->Release();
        *pSignature = 0;
        gpClientLock->UnlockExclusive();
        return(OR_NOMEM);
    }

    *pSignature = (ULONG64) pProcess;

    *pTimeoutInSeconds = BaseTimeoutInterval;
    *pLocalMid = gLocalMid;

    ASSERT( (*phProcess == 0 && *ppdsaOrBindings == 0) || status == OR_OK);

    _AllocateReservedIds(0,
                         cIdsToReserve,
                         pidReservedBase);

    *pScmProcessID = GetCurrentProcessId();
    *pThreadID = InterlockedExchangeAdd((long *)&gNextThreadID,1);
	*pguidRPCSSProcessIdentifier =  *(pProcess->GetGuidProcessIdentifier());

    gpClientLock->UnlockShared();

    return(status);
}


error_status_t
_AllocateReservedIds(
                    IN handle_t hClient,
                    IN LONG cIdsToReserve,
                    OUT ID *pidReservedBase
                    )
/*++

Routine Description:

    // Called by local clients to reserve a range of IDs which will
    // not conflict with any other local IDs.

Arguments:

    hClient - 0 or the connection of the client.

    cIdsToReserve - Number of IDs to reserve.

    pidReservedBase - Starting value of the reserved IDs.  The
        lower DWORD of this can be increatmented to generate
        cIdsToReserve unique IDs.

Return Value:

    OR_OK

--*/
{
    UINT type;
	
    // Ensure this is a local client calling (raises an exception
    // if this is not the case):
    CheckLocalCall(hClient);

    // Parameter validation
    if (!pidReservedBase)
        return OR_BADPARAM;

    if (cIdsToReserve > 10 || cIdsToReserve < 0)
    {
        cIdsToReserve = 10;
    }

    *pidReservedBase = AllocateId(cIdsToReserve);
    return(OR_OK);
}



RPC_STATUS
NegotiateDCOMVersion(
                    IN OUT  COMVERSION *pVersion
                    )
/*++

Routine Description:

    // Called when we receive a COMVERSION from a remote machine
    // to determine which DCOM protocol level to talk.

Arguments:

    pVersion - version of the remote machine. Modified if necessary
               by this routine to be the lower of the two versions.

Return Value:

    OR_OK

--*/
{
    // Parameter validation
    if (!pVersion)
        return OR_BADPARAM;

    if (pVersion->MajorVersion == COM_MAJOR_VERSION)
    {
        if (pVersion->MinorVersion > COM_MINOR_VERSION)
        {
            // since the client has a lower minor version number,
            // use the lower of the two.
            pVersion->MinorVersion = COM_MINOR_VERSION;
        }

        return OR_OK;
    }
    return RPC_E_VERSION_MISMATCH;
}



error_status_t
_ClientResolveOXID(
                  IN  handle_t hClient,
                  IN  PHPROCESS phProcess,
                  IN  OXID *poxidServer,
                  IN  DUALSTRINGARRAY *pdsaServerBindings,
                  IN  LONG fApartment,
                  OUT OXID_INFO *poxidInfo,
                  OUT MID *pDestinationMid,
                  OUT USHORT *pusAuthnSvc
                  )
/*++

Routine Description:

    Discovers the OXID_INFO for an oxid.  Will find local
    OXIDs without any help.  It needs OR bindings in order
    to discover remote OXIDs.

Arguments:

    phProcess - The context handle of the process.

    poxidServer - The OXID (a uuid) to resolve.

    pdsaServerBindings - Compressed string bindings to
        the OR on the server's machine.

    fApartment - non-zero if the client is aparment model.
                REVIEW: What to do with mixed model clients?
                What to do when auto registering an OID?


    poxidInfo - If successful this will contain information about the oxid and
        an expanded string binding to the server oxid's process.


    pulAuthnSvc - if successful this will contain the exact id (ie, will not be snego)
        of the authn svc used to talk to the server.

Return Value:

    OR_NOMEM - Common.

    OR_BADOXID - Unable to resolve it.

    OR_OK - Success.

--*/
{
    // REVIEW: no security check here.  OXID info
    // is not private and you can allocate memory in
    // your process, too.  If we needed to store some
    // info in the client process then a security
    // is needed

    // Parameter validation done below in ResolveClientOXID

    return ResolveClientOXID( hClient,
                              phProcess,
                              poxidServer,
                              pdsaServerBindings,
                              fApartment,
                              0,
                              NULL,
                              poxidInfo,
                              pDestinationMid,
                              FALSE,
                              RPC_C_AUTHN_NONE,
                              NULL,
                              pusAuthnSvc);
}

error_status_t
ResolveClientOXID(
                 handle_t hClient,
                 PHPROCESS phProcess,
                 OXID *poxidServer,
                 DUALSTRINGARRAY *pdsaServerBindings,
                 LONG fApartment,
                 USHORT wProtseqId,
                 WCHAR  *pMachineName,
                 OXID_INFO *poxidInfo,
                 MID *pDestinationMid,
                 BOOL   fUnsecure,
                 USHORT wAuthnSvc,
                 BOOL* pIsLocalOxid,
                 USHORT* pusAuthnSvc
                 )
/*++

Routine Description:

    Discovers the OXID_INFO for an oxid.  Will find local
    OXIDs without any help.  It needs OR bindings in order
    to discover remote OXIDs.

Arguments:

    phProcess - The context handle of the process.
        Since this is called from SCM directly this function
        CAN BE called on the same process by more then one
        thread at a time.

    poxidServer - The OXID (a uuid) to resolve.

    pdsaServerBindings - Compressed string bindings to
        the OR on the server's machine.

    fApartment - non-zero if the client is aparment model.
                REVIEW: What to do with mixed model clients?
                What to do when auto registering an OID?


    poxidInfo - If successful this will contain information about the oxid and
        an expanded string binding to the server oxid's process.

    fUnsecure - if TRUE, activation was done unsecurely so set
        MID appropriately.

    wAuthnSvc - Hint of authentication service that might work or
        RPC_C_AUTHN_NONE if no hint.

    pusAuthnSvc - if successful this will contain the exact id (ie, will not be snego)
        of the authn svc used to talk to the server.

Return Value:

    OR_NOMEM - Common.

    OR_BADOXID - Unable to resolve it.

    OR_OK - Success.

--*/
{
    CProcess    *pProcess;
    CClientOxid *pOxid = NULL;
    CServerOxid *pServerOxid;
    CMid        *pMid;
    ORSTATUS     status = OR_OK;
    BOOL         fReference;
    BOOL         fServerApartment = FALSE;
    BOOL         fResolved = FALSE;
    BOOL         fLazyReleaseNewCopyOfpOxid = FALSE;
    DWORD        i          = 0;
    WCHAR       *pPrincipal = NULL;
    WCHAR       *pMachineNameFromBindings = NULL;
    BOOL         fImpersonating = FALSE;

    // Parameter validation
    if (!poxidServer || !pdsaServerBindings || !poxidInfo ||
        !pDestinationMid || !pusAuthnSvc)
    {
        return OR_BADPARAM;
    }

    pProcess = ReferenceProcess(phProcess);
    ASSERT(pProcess);

    // CheckLocalSecurity will throw an exception if something is wrong
    CheckLocalSecurity(hClient, pProcess);

    if (! dsaValid(pdsaServerBindings))
    {
        return(OR_BADPARAM);
    }

    // If wProtseqId == ID_DCOMHTTP, we should impersonate
    // because RPC will read some info from HKEY_CURRENT_USER.
    // Sometimes ole32 will call us with 0 wProtseqId, in
    // which cases we'll have to look at pdsaServerBindings.

    if(wProtseqId == ID_DCOMHTTP)
    {
        fImpersonating = (RpcImpersonateClient(hClient) == RPC_S_OK);
    }
    else if(wProtseqId == 0)
    {
        if(pdsaServerBindings && pdsaServerBindings->aStringArray
            && *(pdsaServerBindings->aStringArray) == ID_DCOMHTTP)
        {
            fImpersonating = (RpcImpersonateClient(hClient) == RPC_S_OK);
        }
    }

    // Attempt to lookup MID and OXID

    gpClientLock->LockExclusive();

    CMidKey midkey(pdsaServerBindings);

    pMid = (CMid *)gpMidTable->Lookup(midkey);

    if (0 == pMid)
    {
        fReference = TRUE;
        pMid = new(pdsaServerBindings->wNumEntries * sizeof(WCHAR)) CMid(pdsaServerBindings, FALSE);
        if (pMid)
        {
            gpMidTable->Add(pMid);
            pMid->SetAuthnSvc(wAuthnSvc);
        }

        if (0 == pMid)
        {
            status = OR_NOMEM;
        }
    }
    else
    {
        fReference = FALSE;
    }

    if (status == OR_OK)
    {
        CId2Key oxidkey(*poxidServer, pMid->Id());

        pOxid = (CClientOxid *)gpClientOxidTable->Lookup(oxidkey);

        if (0 == pOxid)
        {
            if (!fReference)
            {
                pMid->Reference();
                fReference = TRUE;
            }

            // Need to allocate the OXID.  First step is too resolve it
            // either locally or remotely.

            gpClientLock->UnlockExclusive();

            if (pMid->IsLocal())
            {
                // Local OXID, lookup directly

                gpServerLock->LockShared();

                CIdKey key(*poxidServer);
                pServerOxid = (CServerOxid *)gpServerOxidTable->Lookup(key);

                if (pServerOxid)
                {
                    status = pServerOxid->GetInfo(poxidInfo, TRUE);
                    fServerApartment = pServerOxid->Apartment();
                    // reset the protseq id so we use LRPC.
                    wProtseqId = 0;
                    pMachineName = NULL;
                }
                else
                {
                    status = OR_BADOXID;
                }
                ASSERT(status != OR_OK || dsaValid(poxidInfo->psa));
                gpServerLock->UnlockShared();

            }
            else if (0 == poxidInfo->psa)
            {
                // Remote OXID, call ResolveOxid

                handle_t hRemoteOr;
                void     *pAuthId = NULL;
                USHORT   iBinding;

                poxidInfo->psa = 0;

                ASSERT(!pMachineName);
                status = OR_NOMEM;

                hRemoteOr = pMid->GetBinding();

                if (hRemoteOr)
                {
                    if (pMid->IsSecure())
                    {
                        i = 0;

                        // Form server principal name
                        pMachineNameFromBindings = ExtractMachineName( pMid->GetStringBinding() );
                        if (pMachineNameFromBindings)
                        {
                          pPrincipal = new WCHAR[lstrlenW(pMachineNameFromBindings) +
                                                 (sizeof(RPCSS_SPN_PREFIX) / sizeof(WCHAR)) + 1];
                          if (pPrincipal)
                          {
                            lstrcpyW(pPrincipal, RPCSS_SPN_PREFIX);
                            lstrcatW(pPrincipal, pMachineNameFromBindings);
                          }
                          delete pMachineNameFromBindings;
                        }
                        // It is possible that we already impersonated above,
                        // so it might be unnecessary to do it here.
                        if(!fImpersonating)
                        {
                            status     = RpcImpersonateClient(hClient);
                            if (status != RPC_S_OK)
                            {
                                KdPrintEx((DPFLTR_DCOMSS_ID,
                                           DPFLTR_WARNING_LEVEL,
                                           "OR: Unable to impersonate for resolve %d\n",
                                           status));
                            }
                        }
                    }
                    else
                    {
                        i = s_cRpcssSvc+1;
                    }

                    // The loop index has the following meanings:
                    //    0                     - Try pMid->GetAuthnSvc
                    //    1 through s_cRpcssSvc - Try s_aRpcssSvc
                    //    s_cRpcssSvc+1         - Try unsecure
                    USHORT wFirstSvc = pMid->GetAuthnSvc();
                    for (; i < s_cRpcssSvc + 2; i++)
                    {
                        BOOL bSetSecurityCallBack = FALSE;
                        USHORT usAuthSvcFromCallback;

                        // Choose an authentication service.
                        if (i < s_cRpcssSvc+1)
                        {
                            if (i == 0)
                                wAuthnSvc = wFirstSvc;
                            else
                            {
                                // Skip this authentication service if already
                                // tried.
                                wAuthnSvc = s_aRpcssSvc[i-1].wId;
                                if (wAuthnSvc == wFirstSvc)
                                    continue;
                            }

                            // See if the server uses this authentication service.
                            if (ValidAuthnSvc( pMid->GetStrings(), wAuthnSvc ))
                            {
                                RPC_SECURITY_QOS  qos;
                                qos.Version           = RPC_C_SECURITY_QOS_VERSION;
                                qos.Capabilities      = RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH;
                                qos.IdentityTracking  = RPC_C_QOS_IDENTITY_DYNAMIC;
                                qos.ImpersonationType = RPC_C_IMP_LEVEL_IMPERSONATE;
                                if (wAuthnSvc == RPC_C_AUTHN_GSS_NEGOTIATE)
                                {
                                    pAuthId = ComputeSvcList( pMid->GetStrings() );                                    
                                    if (pAuthId)
                                    {
                                      // if using snego, we need to know what sec pkg is eventually negotiated:
                                      if (gpCRpcSecurityCallbackMgr->RegisterForRpcAuthSvcCallBack(hRemoteOr))
                                        bSetSecurityCallBack = TRUE;
                                    }
                                    else
                                    {
                                      // ComputeSvcList couldn't get the memory; just keep going
                                      status = OR_NOMEM;
                                      continue;
                                    }
                                }

                                // Set the security info
                                // AuthnSvc is unsigned long and 0xFFFF gets 0 extended
                                status = RpcBindingSetAuthInfoEx(hRemoteOr,
                                                             pPrincipal,
                                                             RPC_C_AUTHN_LEVEL_CONNECT,
                                                             wAuthnSvc != 0xFFFF ? wAuthnSvc
                                                                                 : RPC_C_AUTHN_DEFAULT,
                                                             pAuthId,
                                                             0,
                                                             &qos);                                
                                if (status != RPC_S_OK)
                                {
                                    KdPrintEx((DPFLTR_DCOMSS_ID,
                                               DPFLTR_WARNING_LEVEL,
                                               "OR: RpcBindingSetAuthInfo to %d failed!! %d\n",
                                               wAuthnSvc,
                                               status));

                                    if (bSetSecurityCallBack)
                                    {
                                      // Get rid of our callback registration
                                      gpCRpcSecurityCallbackMgr->GetAuthSvcAndTurnOffCallback(hRemoteOr, NULL);
                                    }
                                    delete pAuthId;
                                    pAuthId = NULL;
                                    continue;
                                }
                            }
                            else
                                continue;
                        }

                        // Force the binding handle unsecure.
                        else if (pMid->IsSecure())
                        {
                            wAuthnSvc = RPC_C_AUTHN_NONE;
                            status = RpcBindingSetAuthInfo(hRemoteOr,
                                                           0,
                                                           RPC_C_AUTHN_LEVEL_NONE,
                                                           RPC_C_AUTHN_NONE,
                                                           0,
                                                           0);
                            if (status != RPC_S_OK)
                            {
                                KdPrintEx((DPFLTR_DCOMSS_ID,
                                           DPFLTR_WARNING_LEVEL,
                                           "OR: RpcBindingSetAuthInfo to NONE failed!! %d\n",
                                           status));
                            }
                        }

                        // try calling ResolveOxid2 first, if that fails,
                        // try ResolveOxid.
                        status = ResolveOxid2(hRemoteOr,
                                              poxidServer,
                                              cMyProtseqs,
                                              aMyProtseqs,
                                              &poxidInfo->psa,
                                              &poxidInfo->ipidRemUnknown,
                                              &poxidInfo->dwAuthnHint,
                                              &poxidInfo->version
                                             );

                        if (status == RPC_S_PROCNUM_OUT_OF_RANGE)
                        {
                            // must be a downlevel server (COMVERSION == 5.1), try calling on
                            // the old ResolveOXID method.

                            // REVIEW if it's a downlevel server what does this mean wrt
                            // bug 406902 and the snego mess?   I think we're still okay.
                            poxidInfo->version.MajorVersion = COM_MAJOR_VERSION;
                            poxidInfo->version.MinorVersion = COM_MINOR_VERSION_1;
                            poxidInfo->dwFlags   = 0;

                            status = ResolveOxid(hRemoteOr,
                                                 poxidServer,
                                                 cMyProtseqs,
                                                 aMyProtseqs,
                                                 &poxidInfo->psa,
                                                 &poxidInfo->ipidRemUnknown,
                                                 &poxidInfo->dwAuthnHint
                                                );
                        }
                        
                        // At this point we are done making calls on the binding handle

                        // Turn off the security callback no matter what the result of
                        // the call was
                        if (bSetSecurityCallBack)
                        {
                          if (status == OR_OK)
                          {
                          if (!gpCRpcSecurityCallbackMgr->GetAuthSvcAndTurnOffCallback(hRemoteOr,
                                                                    &usAuthSvcFromCallback))
                          {
                            // something went wrong.  Basically we don't trust what the callback
                            // told us.   Fall back on the original behavior
                              bSetSecurityCallBack = FALSE;
                            }
                          }
                          else
                          {
                            // call did not go through; just cancel the callback registration
                            gpCRpcSecurityCallbackMgr->GetAuthSvcAndTurnOffCallback(hRemoteOr, NULL);
                            bSetSecurityCallBack = FALSE;
                          }
                        }

                        if (status == OR_OK)
                        {
                            status = NegotiateDCOMVersion(&poxidInfo->version);
                        }

                        if (status == OR_OK)
                        {
                            // Remember which auth.svc got used:
                            if (bSetSecurityCallBack)
                            {
                              // we should not have set it unless we're using snego, and we
                              // should have gotten something other than snego back
                              ASSERT(wAuthnSvc == RPC_C_AUTHN_GSS_NEGOTIATE &&
                                     usAuthSvcFromCallback != RPC_C_AUTHN_GSS_NEGOTIATE);

                              // Set the negotiated pkg;  if we got back Kerberos, then cache
                              // Snego.   This will partially fix the fact that we are
                              // hard-coding the authn svc for all future users of this mid
                              if (usAuthSvcFromCallback == RPC_C_AUTHN_GSS_KERBEROS)
                                pMid->SetAuthnSvc( RPC_C_AUTHN_GSS_NEGOTIATE );
                              else
                                pMid->SetAuthnSvc( usAuthSvcFromCallback );
                            }
                            else
                            {
                              // Just use whatever was set on the call
                              pMid->SetAuthnSvc( wAuthnSvc );
                            }

                            if (dsaValid(poxidInfo->psa))
                            {
                                wProtseqId = poxidInfo->psa->aStringArray[0];
                            }
                            else
                            {
                                KdPrintEx((DPFLTR_DCOMSS_ID,
                                           DPFLTR_WARNING_LEVEL,
                                           "OR: Server %s returned a bogus string array: %p\n",
                                           pMid->PrintableName(),
                                           poxidInfo->psa));

                                ASSERT(0);
                                if (poxidInfo->psa)
                                {
                                    MIDL_user_free(poxidInfo->psa);
                                    poxidInfo->psa = 0;
                                }
                                status = OR_BADOXID;
                            }
                            break;
                        }
                        else if (status != RPC_S_ACCESS_DENIED         &&
                                 status != RPC_S_UNKNOWN_AUTHN_SERVICE &&
                                 status != RPC_S_UNKNOWN_AUTHZ_SERVICE &&
                                 status != RPC_S_SEC_PKG_ERROR )
                        {
                            KdPrintEx((DPFLTR_DCOMSS_ID,
                                       DPFLTR_WARNING_LEVEL,
                                       "OR: Remote resolve OXID failed %d\n",
                                       status));

                            break;
                        }
                    }

                    RpcBindingFree(&hRemoteOr);
                    delete pPrincipal;
                    pPrincipal = NULL;
                    delete pAuthId;
                    pAuthId = NULL;
                }
            }
            // Else it's a remote MID, but we were given the OXID info
            // and protseq id from the SCM after a remote activation.
            else
                fResolved = TRUE;

            gpClientLock->LockExclusive();

            ASSERT(fReference);

            if (   OR_OK == status
                   && (pMid->GetAuthnSvc() == RPC_C_AUTHN_NONE ||
                       TRUE  == fUnsecure) )
            {
                KdPrintEx((DPFLTR_DCOMSS_ID,
                           DPFLTR_INFO_LEVEL,
                           "OR: Machine %S, unsecure retry ok, assuming no sec\n",
                           pMid->PrintableName()));
                pMid->SecurityFailed();
            }

            if (status == OR_OK)
            {
                // Lookup the oxid again to make sure it hasn't been added in the meantime.

                pOxid = (CClientOxid *)gpClientOxidTable->Lookup(oxidkey);

                if (0 == pOxid)
                {
                    ASSERT(dsaValid(poxidInfo->psa));
                    pOxid = new CClientOxid(*poxidServer,
                                            pMid,
                                            wProtseqId,
                                            pMachineName,
                                            fServerApartment);

                    if (0 != pOxid)
                    {
                        status = pOxid->UpdateInfo(poxidInfo);

                        if (OR_OK == status)
                        {
                            gpClientOxidTable->Add(pOxid);
                        }
                        else
                        {
                            // Will release mid, will also remove it (unnecessarily)
                            // from the table.
                            delete pOxid;
                            pOxid = NULL;
                        }
                    }
                    else
                    {
                        status = OR_NOMEM;
                        pMid->Release();  // May actually go away..
                    }
                }
                else
                {
                    // Release our now extra reference on the MID
                    DWORD t = pMid->Release();
                    ASSERT(t > 0);
                    pOxid->Reference();
                }

                MIDL_user_free(poxidInfo->psa);
                poxidInfo->psa = 0;
            }
            else
            {
                // Resolve failed, get rid of our extra reference.
                pMid->Release();
            }
        }
        else
        {
            // Found the OXID, must also have found the MID
            ASSERT(fReference == FALSE);

            fResolved = TRUE;

            if ( poxidInfo->psa )
            {
                MIDL_user_free(poxidInfo->psa);
                poxidInfo->psa = 0;
            }

            pOxid->Reference();
        }
    }

    ASSERT( (status != OR_OK) || (pOxid && pMid) );

    if (   status == OR_OK
           && pOxid->IsLocal() == FALSE)
    {
        if (fResolved)
            *poxidServer = 0;
    }

    if(NULL != pIsLocalOxid)
    {
        if((status == OR_OK) && pOxid->IsLocal())
            *pIsLocalOxid = TRUE;
        else
            *pIsLocalOxid = FALSE;
    }

    if (status == OR_OK)
    {
        *pDestinationMid = pMid->Id();

        *pusAuthnSvc = pMid->GetAuthnSvc();

        // GetInfo may release the lock
        status = pOxid->GetInfo(fApartment, poxidInfo);
    }

    if (pOxid)
    {
        pOxid->Release();
    }
    gpClientLock->UnlockExclusive();

    return(status);
}


void
FreeServerOids(
               CProcess *pProcess,
               ULONG cServerOidsToFree,
               OID aServerOidsToFree[]
              )
/*++

Routine Description:

    Frees the OIDs passed in.

Arguments:

    phProcess - The context handle of the process.
        Since this is called from SCM directly this function
        CAN BE called on the same process by more then one
        thread at a time.

    cServerOidsToFree - Count of entries in aServerOidsToFree

    aServerOidsToFree - OIDs allocated by the server process
        and no longer needed.

--*/
{
//    KdPrintEx((DPFLTR_DCOMSS_ID,
//               DPFLTR_WARNING_LEVEL,
//               "OR: FreeServerOids: pProcess:%x cOids:%x pOids:%x\n",
//               pProcess,
//               cServerOidsToFree,
//               aServerOidsToFree));

    ASSERT(gpServerLock->HeldExclusive());

    if (cServerOidsToFree)
    {
        CServerOid *pOid;
        CServerOxid *pOxid;

        for (ULONG i = 0; i < cServerOidsToFree; i++)
        {
            CIdKey oidkey(aServerOidsToFree[i]);

            pOid = (CServerOid *)gpServerOidTable->Lookup(oidkey);
            if (pOid && pOid->IsRunningDown() == FALSE)
            {
                pOxid = pOid->GetOxid();
                ASSERT(pOxid);
                if (pProcess->IsOwner(pOxid))
                {
                    if (pOid->References() == 0)
                    {
                        pOid->Remove();
                        pOid->SetRundown(TRUE);
                        delete pOid;
                    }
                    else
                    {
                        pOid->Free();
                    }
                }
                else
                {
                    KdPrintEx((DPFLTR_DCOMSS_ID,
                               DPFLTR_WARNING_LEVEL,
                               "OR: Process %p tried to free OID %p it didn't own\n",
                               pProcess,
                               pOid));
                }
            }
            else
            {
                KdPrintEx((DPFLTR_DCOMSS_ID,
                           DPFLTR_WARNING_LEVEL,
                           "OR: Process %p freed OID %p that didn't exist\n",
                           pProcess,
                           &aServerOidsToFree[i]));
            }
        }
    }
}


error_status_t
_BulkUpdateOIDs(
               IN handle_t hClient,
               IN PHPROCESS phProcess,
               IN ULONG cOidsToBeAdded,
               IN OXID_OID_PAIR aOidsToBeAdded[],
               OUT LONG aStatusOfAdds[],
               IN ULONG cOidsToBeRemoved,
               IN OID_MID_PAIR aOidsToBeRemoved[],
               IN ULONG cServerOidsToFree,
               IN OID aServerOidsToFree[],
               IN ULONG cServerOidsToUnPin,
               IN OID aServerOidsToUnPin[],
               IN ULONG cClientOxidsToFree,
               IN OXID_REF aClientOxidsToFree[]
               )
/*++

Routine Description:

    Updates the set of remote OIDs in use by a process.

Note:

    An OID maybe removed before it is added.  This means that
    the client was using it and is no longer using it.  In
    this case a single delete from set ping is made to keep
    the object alive.  This is only needed if the client
    has remarshalled a pointer to the object.

Arguments:

    phProcess - Context handle for the process.

    cOidsToBeAdded - Count of aOidsToBeAdded and aStatusOfAdds

    aOidsToBeAdded - OID-OXID-MID pairs representing the
        oids and the owning oxids to add.

    aStatusOfAdds - Some adds may succeed when other fail.
        OR_NOMEM - couldn't allocate storage
        OR_BADOXID - OXID doesn't exist.
        OR_OK (0) - added to set

    cOidsToBeRemoved - Count of entries in aOidsToBeRemoved.

    aOidsToBeRemoved - OID-MID pairs to be removed.

    cServerOidsToFree - Count of entries in aServerOidsToFree

    aServerOidsToFree - OIDs allocated by the client process
        and no longer needed.

    cServerOidsToUnPin - Count of entries in aServerOidsToUnPin

    aServerOidsToUnPin - OIDs that the client process previously 
	    told us were pinned\locked, and now no longer are.

    cClientOxidsToFree - COunt of enties in aClientOxidsToFree

    aClientOxidsToFree - OXIDs owned by a process (due to a direct
        or indirect call to ClientResolveOxid) which are no longer
        in use by the client.

Return Value:

    OR_OK - All updates completed ok.

    OR_PARTIAL_UPDATE - At least one entry in aStatusOfAdds is not OR_OK

--*/
{
    CProcess    *pProcess;
    CClientOxid *pOxid;
    CClientOid  *pOid;
    CClientSet  *pSet;
    CMid        *pMid;
    CToken      *pToken;
    BOOL         fPartial = FALSE;
    BOOL         fNewSet = FALSE;
    DUALSTRINGARRAY *pdsa = NULL;
    ULONG i;

    // Parameter validation.  If zero is passed for the size-of-array param
    // then we don't care about the array param itself (since we never 
    // look at it)  
    if (!(cOidsToBeAdded > 0 ? (aOidsToBeAdded != NULL) : TRUE) ||
        !(cOidsToBeAdded > 0 ? (aStatusOfAdds != NULL) : TRUE) ||
        !(cOidsToBeRemoved > 0 ? (aOidsToBeRemoved != NULL) : TRUE) ||
        !(cServerOidsToFree > 0 ? (aServerOidsToFree != NULL): TRUE) ||
        !(cServerOidsToUnPin > 0 ? (aServerOidsToUnPin != NULL): TRUE) ||
        !(cClientOxidsToFree > 0 ? (aClientOxidsToFree != NULL) : TRUE))
    {
        return OR_BADPARAM;
    }

    pProcess = ReferenceProcess(phProcess);
    ASSERT(pProcess);

    CheckLocalSecurity(hClient, pProcess);

    if (cOidsToBeAdded || cOidsToBeRemoved)
    {
        ORSTATUS status = CopyMyOrBindings(&pdsa, NULL);
        if (status != RPC_S_OK)
        {
            return status;
        }
        gpClientLock->LockExclusive();
    }

    // /////////////////////////////////////////////////////////////////
    // Process Adds.

    for (i = 0; i < cOidsToBeAdded; i++)
    {
        // Lookup up the oxid owning this new oid.

        CId2Key oxidkey(aOidsToBeAdded[i].oxid, aOidsToBeAdded[i].mid);

        pOxid = (CClientOxid *)gpClientOxidTable->Lookup(oxidkey);

        if (0 == pOxid)
        {
            OXID_INFO infoT;
            ORSTATUS  status;
            MID mid;

            gpClientLock->UnlockExclusive();

            infoT.psa = 0;

            USHORT usAuthnSvc;
            status = _ClientResolveOXID(hClient,
                                        phProcess,
                                        &aOidsToBeAdded[i].oxid,
                                        pdsa,
                                        TRUE,
                                        &infoT,
                                        &mid,
                                        &usAuthnSvc);

            gpClientLock->LockExclusive();

            if (status == OR_OK)
            {
                ASSERT(infoT.psa);
                ASSERT(mid == gLocalMid);
                MIDL_user_free(infoT.psa);
                pOxid = (CClientOxid *)gpClientOxidTable->Lookup(oxidkey);
                if (pOxid == 0)
                {
                    KdPrintEx((DPFLTR_DCOMSS_ID,
                               DPFLTR_INFO_LEVEL,
                               "OR: Auto resolving oxid %p failed, wrong machine\n",
                               &oxidkey));

                    status = OR_BADOXID;
                }
            }

            if (status != OR_OK)
            {
                aStatusOfAdds[i] = OR_BADOXID;
                fPartial = TRUE;
                continue;
            }
        }


        // Find or create the set.

        CId2Key setkey(aOidsToBeAdded[i].mid, (ID)pProcess->GetToken());

        pSet = (CClientSet *)gpClientSetTable->Lookup(setkey);

        if (pSet == 0)
        {
            pSet = new CClientSet(pOxid->GetMid(), pProcess->GetToken());

            if (pSet == 0)
            {
                aStatusOfAdds[i] = OR_NOMEM;
                fPartial = TRUE;
                continue;
            }
            else
            {
                gpClientSetTable->Add(pSet);
                pSet->Insert();
                fNewSet = TRUE;
            }
        }

        // Find or create the oid.  If we create it, add a reference
        // to the oxid for the new oid.

        CId3Key oidkey(aOidsToBeAdded[i].oid, aOidsToBeAdded[i].mid, pProcess->GetToken());

        pOid = (CClientOid *)gpClientOidTable->Lookup(oidkey);

        if (0 == pOid)
        {
            pOid = new CClientOid(aOidsToBeAdded[i].oid,
                                  aOidsToBeAdded[i].mid,
                                  pProcess->GetToken(),
                                  pOxid,
                                  pSet
                                 );
            if (fNewSet)
            {
                // pOid either owns a refernce now or we need to
                // cleanup the set anyway.
                pSet->Release();
                fNewSet = FALSE;
            }

            if (pOid)
            {

                aStatusOfAdds[i] = pSet->RegisterObject(pOid);

                if (aStatusOfAdds[i] == OR_OK)
                {
                    gpClientOidTable->Add(pOid);
                }
                else
                {
                    pOid->Release();
                    pOid = 0;
                    fPartial = TRUE;
                    continue;
                }
            }
            else
            {
                aStatusOfAdds[i] = OR_NOMEM;
                fPartial = TRUE;
                continue;
            }

        }
        else
        {
            ASSERT(fNewSet == FALSE);
            pOid->ClientReference();
        }

        // If this fails it will release the oid.
        aStatusOfAdds[i] = pProcess->AddOid(pOid);
        if (aStatusOfAdds[i] != OR_OK)
        {
            fPartial = TRUE;
        }
    } // for oids to add

    // /////////////////////////////////////////////////////////////////
    // Process deletes

    for (i = 0; i < cOidsToBeRemoved; i++)
    {
        CId3Key oidkey(aOidsToBeRemoved[i].oid,
                       aOidsToBeRemoved[i].mid,
                       pProcess->GetToken());

        pOid = (CClientOid *)gpClientOidTable->Lookup(oidkey);

        if (pOid)
        {
            CClientOid *pT = pProcess->RemoveOid(pOid);

            if (pT == 0)
            {
                KdPrintEx((DPFLTR_DCOMSS_ID,
                           DPFLTR_WARNING_LEVEL,
                           "OR: Client process %p tried to remove oid %p which"
                           "it didn't own\n",
                           pProcess,
                           &aOidsToBeRemoved[i]));
            }
            else
                ASSERT(pT == pOid);
        }
        else
            KdPrintEx((DPFLTR_DCOMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "OR: Client %p removed an OID that doesn't exist\n",
                       pProcess));

    } // for oids to delete


    if (cOidsToBeAdded || cOidsToBeRemoved)
    {
        gpClientLock->UnlockExclusive();
    }
	
    ///////////////////////////////////////////////////////////////////
    // Process server oid deletes
    //
    if (cServerOidsToFree > 0)
    {
        gpServerLock->LockExclusive();
        FreeServerOids(pProcess, cServerOidsToFree, aServerOidsToFree);
        gpServerLock->UnlockExclusive();
    }

    ///////////////////////////////////////////////////////////////////
    //
    // Process server oid unpins.  We do not have an array of individual 
    // status update values for this operation; if the client gets back 
    // a success code from BulkUpdateOids, it can assume that all of the 
    // requested unpins were executed correctly.
    //
    // Also note that it is *always* safe to unpin an oid even if it should
    // remain pinned; the worse that can happen is extra rundown calls.
    //
    if (cServerOidsToUnPin > 0)
    {
        gpServerLock->LockExclusive();

        for (i = 0; i < cServerOidsToUnPin; i++)
        {
            CServerOid* pOid;

            CIdKey key(aServerOidsToUnPin[i]);

            pOid = (CServerOid *)gpServerOidTable->Lookup(key);

            // Only unpin the oid if the calling process owns it.  Don't
            // assert if we didn't find it, since under stress we may
            // be executing this code after the owning process\apt died.
            if (pOid && pProcess->IsOwner(pOid->GetOxid()))
            {
                if (pOid->IsPinned())
                {
                    pOid->SetPinned(FALSE);
                }            
            }
        }

        gpServerLock->UnlockExclusive();
    }


    // Done
    if (pdsa)
    {
        MIDL_user_free(pdsa);
    }

    if (fPartial)
    {
        return(OR_PARTIAL_UPDATE);
    }

    return(OR_OK);
}

error_status_t
_ServerAllocateOXIDAndOIDs(
                          IN handle_t hClient,
                          IN PHPROCESS phProcess,
                          OUT OXID *poxidServer,
                          IN LONG fApartment,
                          IN ULONG cOids,
                          OUT OID aOid[],
                          OUT PULONG pOidsAllocated,
                          IN OXID_INFO *poxidInfo, // No bindings
                          IN DUALSTRINGARRAY *pdsaStringBindings,   // Expanded
                          IN DUALSTRINGARRAY *pdsaSecurityBindings, // Compressed
                          OUT DWORD64 *pdwBindingsID,
                          OUT DUALSTRINGARRAY **ppdsaOrBindings
                          )
/*++

Routine Description:

    Allocates an OXID and 0 or more OIDs from the OR.

Arguments:

    phProcess - The context handle of the process containing the OXID.

    poxidServer - The OXID to register.  May only register once.

    cOids - Count of apOids

    apOid - The OIDs to register within the OXID.

    pcOidsAllocated - The number of OIDs actually allocated. Usually the
        same as cOids unless a resource failure occures.  Maybe 0.

    poxidInfo - The OXID_INFO structure for the OXID without bindings.

    pdsaStringBindings - Expanded string binding of the server.

    pdsaSecurityBindings - The compressed security bindings of the server.

    pOidsAllocated - The number of OIDs actually allocated. >= 0 and <= cOids.

    pdwBindingsID -- The id of the bindings returned in ppdsaOrBindings

    ppdsaOrBindings -- The current resolver bindings.  Normally this is not
	    ever allocated, unless dynamic address tracking is enabled.

Return Value:

    OR_OK - success.  Returned even if some OID allocations fail. See the
                      pOidsAllocated parameter.

    OR_NOMEM - Allocation of OXID failed.

    OR_ACCESS_DENIDED - Raised if non-local client

    OR_BADPARAM - if string arrays are incorrect.

--*/
{
    ORSTATUS status = OR_OK;
    CServerOxid *pNewOxid;
    CProcess *pProcess = ReferenceProcess(phProcess);
    ASSERT(pProcess);

    CheckLocalSecurity(hClient, pProcess);

    // Parameter validation
    if (!poxidServer ||
        !(cOids > 0 ? (aOid != NULL) : TRUE) ||
        !pOidsAllocated || !poxidInfo ||
        !pdsaStringBindings || !pdsaSecurityBindings ||
        !pdwBindingsID || !ppdsaOrBindings)
    {
        return OR_BADPARAM;
    }

    gpServerLock->LockExclusive();

    // Save the string bindings back to the process

    if (!dsaValid(pdsaStringBindings) )
    {
        status = OR_BADPARAM;
    }

    if (!dsaValid(pdsaSecurityBindings))
    {
        status = OR_BADPARAM;
    }

    if (status == OR_OK)
    {
        status = pProcess->ProcessBindings(pdsaStringBindings,
                                           pdsaSecurityBindings);
    }
	
    *pdwBindingsID = 0;
    *ppdsaOrBindings = NULL;

    VALIDATE((status, OR_NOMEM, OR_BADPARAM, 0));

    if (status != OR_OK)
    {
        gpServerLock->UnlockExclusive();
        return(status);
    }

    pNewOxid = new CServerOxid(pProcess,
                               fApartment,
                               poxidInfo
                              );

    if (0 == pNewOxid)
    {
        gpServerLock->UnlockExclusive();
        return(OR_NOMEM);
    }

    // Add to process and lookup table.

    status = pProcess->AddOxid(pNewOxid);

    VALIDATE((status, OR_NOMEM, 0));

    pNewOxid->Release(); // process has a reference now or failed

    gpServerLock->UnlockExclusive();

    if (status == OR_OK)
    {
        *poxidServer = pNewOxid->Id();

        status = _ServerAllocateOIDs(0,
                                     phProcess,
                                     poxidServer,
                                     0,
                                     NULL,
                                     cOids,
                                     aOid,
                                     pOidsAllocated);
    }
	
    if (status == OR_OK && gbDynamicIPChangesEnabled)
    {
        if (ppdsaOrBindings && pProcess->NeedsORBindings())
        {
            // If doing dynamic IP changes, give process the current
            // OR bindings
            status = CopyMyOrBindings(ppdsaOrBindings, pdwBindingsID);
            if (status == OR_OK)
            {
                pProcess->BindingsUpdated();
            }
        }
    }

    return(status);
}


error_status_t _ServerAllocateOIDs(
                                  IN  handle_t  hClient,
                                  IN  PHPROCESS phProcess,
                                  IN  OXID      *poxidServer,
                                  IN  ULONG     cOidsReturn,
                                  IN  OID       aOidsReturn[],
                                  IN  ULONG     cOids,
                                  OUT OID       aOids[],
                                  OUT PULONG    pOidsAllocated
                                  )
/*++

Routine Description:

    Registers additional OIDs on behalf of an existing OXID.

Arguments:

    phProcess - The context handle of the process containing the OXID and OIDs.

    poxidServer - The OXID associated with the OIDs.

    cOidsReturn - Count of aOidsReturn

    aOidsReturn - Array of OIDs the process is no longer using.

    cOids - Count of aOids

    aOids - The OIDs to register within the OXID.

    pOidsAllocate - Contains the number of OIDs actually allocated
        when this function returns success.

Return Value:

    OR_OK (0) - Success.

    OR_PARTIAL_UPDATE - No all elements in aStatus are 0.

    OR_NOMEM - OXID or one or more OIDs

--*/
{
    ORSTATUS status = OR_OK;
    CServerOxid *pOxid;
    CServerOid *pOid;
    BOOL fPartial = FALSE;
    CProcess *pProcess = ReferenceProcess(phProcess);
    ASSERT(pProcess);

    CheckLocalSecurity(hClient, pProcess);

    // Parameter validation
    if (!poxidServer || 
        !(cOidsReturn > 0 ? (aOidsReturn != NULL) : TRUE) ||
        !((cOids > 0 ? (aOids != NULL) : TRUE) ||
        !pOidsAllocated))
    {
        return OR_BADPARAM;
    }


    gpServerLock->LockExclusive();

    CIdKey oxidkey(*poxidServer);

    pOxid = (CServerOxid *)gpServerOxidTable->Lookup(oxidkey);

    if (0 == pOxid)
    {
        gpServerLock->UnlockExclusive();
        status = OR_BADOXID;
        return(status);
    }

    if (cOidsReturn)
    {
        // free the Oids returned
        FreeServerOids(pProcess, cOidsReturn, aOidsReturn);
    }


    *pOidsAllocated = 0;

    for (ULONG i = 0; i < cOids; i++)
    {
        pOid = new CServerOid(pOxid);

        if (0 != pOid)
        {
            (*pOidsAllocated)++;
            aOids[i] = pOid->Id();
            gpServerOidTable->Add(pOid);

            // The server doesn't want to keep the OID alive.
            // This will cause the OID to rundown in six minutes
            // unless a set references it in the meantime...

            pOid->Release();
        }
        else
        {
            break;
        }
    }

    gpServerLock->UnlockExclusive();

    ASSERT(status == OR_OK);

    return(status);
}

error_status_t
_ServerFreeOXIDAndOIDs(
                      IN handle_t hClient,
                      IN PHPROCESS phProcess,
                      IN OXID oxidServer,
                      IN ULONG cOids,
                      IN OID aOids[])

{
    CServerOxid *pOxid;
    CServerOid *pOid;
    CProcess *pProcess = ReferenceProcess(phProcess);
    ORSTATUS status;
    UINT i;

    ASSERT(pProcess);

    CheckLocalSecurity(hClient, pProcess);

    // Parameter validation
    if (!(cOids > 0 ? (aOids != NULL) : TRUE))
        return OR_BADPARAM;

    gpServerLock->LockExclusive();

    CIdKey oxidkey(oxidServer);

    pOxid = (CServerOxid *)gpServerOxidTable->Lookup(oxidkey);

    if (0 != pOxid)
    {
        if (pProcess->RemoveOxid(pOxid) == TRUE)
        {
            // Found the OXID and this caller owns it.
            status = OR_OK;
        }
        else
        {
            // Found but not owned by this caller.
            status = OR_NOACCESS;
        }
    }
    else
    {
        // Oxid not found.
        status = OR_BADOXID;
    }

    // Note pOxid maybe invalid once the last OID is removed.

    if (status == OR_OK)
    {
        for (i = 0; i < cOids; i++)
        {
            CIdKey key(aOids[i]); // PERF REVIEW

            pOid = (CServerOid *)gpServerOidTable->Lookup(key);

            if (   (0 != pOid)
                   && (pOid->IsRunningDown() == FALSE)
                   && (pOid->GetOxid() == pOxid) )
            {
                if (pOid->References() == 0)
                {
                    // Unreferenced by any sets; run it down now..
                    pOid->Remove();
                    pOid->SetRundown(TRUE);
                    delete pOid;
                }
                // else - marking it as Free() not need as Oxid is
                //        now marked as not running.
            }
            else
            {
                ASSERT(pOid == 0 || pOxid == pOid->GetOxid());
            }
        }
    }

    gpServerLock->UnlockExclusive();

    return(status);
}


//
//  Manager (server-side) calls to the remote OR interface. objex.idl
//
error_status_t
_ResolveOxid(
            IN  handle_t          hRpc,
            IN  OXID             *poxid,
            IN  USHORT            cRequestedProtseqs,
            IN  USHORT            aRequestedProtseqs[],
            OUT DUALSTRINGARRAY **ppdsaOxidBindings,
            OUT IPID             *pipidRemUnknown,
            OUT DWORD            *pAuthnHint
            )
{
    COMVERSION  ComVersion;

    // just forward to the new manager routine (parameter 
    // validation done by callee)
    return _ResolveOxid2(hRpc,
                         poxid,
                         cRequestedProtseqs,
                         aRequestedProtseqs,
                         ppdsaOxidBindings,
                         pipidRemUnknown,
                         pAuthnHint,
                         &ComVersion);
}

//
//  Manager (server-side) calls to the remote OR interface. objex.idl
//

error_status_t
_ResolveOxid2(
             IN  handle_t          hRpc,
             IN  OXID             *poxid,
             IN  USHORT            cRequestedProtseqs,
             IN  USHORT            aRequestedProtseqs[],
             OUT DUALSTRINGARRAY **ppdsaOxidBindings,
             OUT IPID             *pipidRemUnknown,
             OUT DWORD            *pAuthnHint,
             OUT COMVERSION       *pComVersion
             )
{

    ORSTATUS     status;
    BOOL         fDidLazy;
    CServerOxid *pServerOxid;
    OXID_INFO    oxidInfo;

    // Parameter validation.   Note that it would be exceedingly odd for
    // a client to request zero protseqs, but we handle this anyway.
    if (!poxid || 
        !(cRequestedProtseqs > 0 ? (aRequestedProtseqs != NULL) : TRUE) || 
        !ppdsaOxidBindings || !pipidRemUnknown || 
        !pipidRemUnknown || !pAuthnHint || !pComVersion)
    {
        return OR_BADPARAM;
    }

    oxidInfo.psa = 0;

    // No security check required (possible?).  OXID info is not private.

#if DBG
    UINT         fLocal;
    status = I_RpcBindingIsClientLocal(hRpc, &fLocal);

    if (status != OR_OK)
    {
        fLocal = FALSE;
    }
    ASSERT(fLocal == FALSE);  // Shouldn't be called locally...
#endif

    fDidLazy = FALSE;

    // intersect allowed protseqs with those
    // requested by the client.
    //
    // NOTE: we are modifying memory passed in. This will not cause side
    // effects because this call is always in the context of an RPC, and
    // aRequestedProtseqs is an IN parameter and therefore will not change
    // in the calling process.

    gpClientLock->LockExclusive();
    USHORT cAllowedProtseqs = 0;
    for (USHORT iReqProtseq=0; iReqProtseq < cRequestedProtseqs; iReqProtseq++)
    {
        for (USHORT iAllowProtseq=0; iAllowProtseq < cMyProtseqs; iAllowProtseq++)
        {
            if (aRequestedProtseqs[iReqProtseq] == aMyProtseqs[iAllowProtseq])
            {
                // this protocol is in the allowed list, shift it up
                // if necessary.
                aRequestedProtseqs[cAllowedProtseqs] = aRequestedProtseqs[iReqProtseq];
                cAllowedProtseqs++;
                break;
            }
        }
    }

    cRequestedProtseqs = cAllowedProtseqs;
    gpClientLock->UnlockExclusive();


    gpServerLock->LockShared();

    for (;;)
    {
        CIdKey key(*poxid);

        pServerOxid = (CServerOxid *)gpServerOxidTable->Lookup(key);
        if (!pServerOxid)
        {
            status = OR_BADOXID;
            break;
        }

        status =  pServerOxid->GetRemoteInfo(&oxidInfo,
                                             cRequestedProtseqs,
                                             aRequestedProtseqs);
	
        // Work around: original intersection of clients requested protocols
        //              with this SCM's did'nt match. But we know that client
        //              does'nt send it's entire set, just one so break here
        //
        // Note: W2K sends all protocols on both activations and ResolveOxid
        // calls; NT4 only sends one protocol on activations, and all on
        // ResolveOxid calls.
        //
        if ((cRequestedProtseqs == 0) && (status == OR_I_NOPROTSEQ))
        {
            break;
        }

        if (   status == OR_I_NOPROTSEQ
               && FALSE == fDidLazy )
        {
            // Ask the server to start listening, but only try this once.

            fDidLazy = TRUE;

            status =
            pServerOxid->LazyUseProtseq(cRequestedProtseqs,
                                        aRequestedProtseqs
                                       );

            ASSERT(gpServerLock->HeldExclusive()); // Changed during UseProtseq!

            if (status == OR_OK)
            {
                continue;
            }
        }
        else if (status == OR_I_NOPROTSEQ)
        {
            // We didn't manage to use a matching protseq.
            // Since we can call on any protocal this is possible
            KdPrintEx((DPFLTR_DCOMSS_ID,
                       DPFLTR_WARNING_LEVEL,
                       "OR: Failed to use a matching protseq: %p %p\n",
                       pServerOxid,
                       aRequestedProtseqs));

            status = OR_NOSERVER;
        }
        break;
    }

    gpServerLock->Unlock();

    if (status == OR_OK)
    {
        *pipidRemUnknown = oxidInfo.ipidRemUnknown;
        *ppdsaOxidBindings = oxidInfo.psa;
        *pAuthnHint = oxidInfo.dwAuthnHint;
        *pComVersion = oxidInfo.version;
    }
    else
    {
        // Work around: original intersection of clients requested protocols
        //              with this SCM's did'nt match. But we know that client
        //              does'nt send it's entire set, just one, so send back
        //              an empty set but o.k activation result for bindings
        //
        // Note: W2K sends all protocols on both activations and ResolveOxid
        // calls; NT4 only sends one protocol on activations, and all on
        // ResolveOxid calls.
        //
        if ((cRequestedProtseqs == 0) && (status == OR_I_NOPROTSEQ))
        {
            *pipidRemUnknown = oxidInfo.ipidRemUnknown;
            *ppdsaOxidBindings = NULL;
            *pAuthnHint = oxidInfo.dwAuthnHint;
            *pComVersion = oxidInfo.version;
            status = OR_OK;
        }
    }
    return(status);
}

error_status_t
_SimplePing(
           IN handle_t hRpc,
           IN SETID    *pSetId
           )
{
    ORSTATUS status;
    CServerSet *pServerSet;
    BOOL fShared = TRUE;

    // Parameter validation
    if (!pSetId)
        return OR_BADPARAM;

    if (*pSetId == 0)
    {
        KdPrintEx((DPFLTR_DCOMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "Client %p simple pinged with a setid of 0\n",
                   hRpc,
                   pSetId));

        return(OR_BADSET);
    }

    gpServerLock->LockShared();

    pServerSet = (CServerSet *)gpServerSetTable->Lookup(*pSetId);

    if (pServerSet)
    {
        fShared = pServerSet->Ping(TRUE);
        // The lock maybe exclusive now.
        status = OR_OK;
    }
    else
    {
        status = OR_BADSET;
    }

    // See if another set in the table needs to rundown.
    // PERF REVIEW - how often should I do this?  0 mod 4?

    // Similar code in worker threads.

    ID setid  = gpServerSetTable->CheckForRundowns();

    if (setid)
    {
        if (fShared)
        {
            gpServerLock->ConvertToExclusive();
            fShared = FALSE;
        }

        gpServerSetTable->RundownSetIfNeeded(setid);
    }

    gpServerLock->Unlock();

    return(status);
}

error_status_t
ComplexPingInternal(
            IN  handle_t hRpc,
            IN  SETID   *pSetId,
            IN  USHORT   SequenceNum,
            IN  ULONG    cAddToSet,
            IN  ULONG    cDelFromSet,
            IN  OID      AddToSet[],
            IN  OID      DelFromSet[],
            OUT USHORT  *pPingBackoffFactor
            )
/*++

Routine Description:

    Processes a complex (delta to set) ping for a given set.  This call
    will create the set if necessary.  The call will only be processed
    if the caller is in fact the creator of the set.

    algorithm:

        if set is not allocated
            lookup security info if possible
            allocate set
        else
            lookup set


        if found or created a set
           do a standard ping, updating time stamp and sequence number.
        else return failure.

        if oids to add, add each one.
            ignore unknown OIDs
            if resource allocation fails, abort.

        if oids to delete, process each one.
            ignore unknown OIDs

        if resource failure in adds, return OR_BADOID
        else return success.

Arguments:

    hRpc - Handle (SCONN/SCALL) of client.  Used to check security. If it is
        NULL the call is local and is assumed to be secure.

        REVIEW:
        Since the OR _only_ uses NT system security providers it is assumed
        that impersonation will work.  Other security providers will not.

        We need a generic way to ask for a token and compare tokens in a
        security provider independent way.

    pSetId - The setid to ping.  If it is NULL a new set will be created,
        otherwise, it is assumed to be a set previously allocated by a
        call with a NULL setid to this server.

    SequenceNum - A sequence number shared between the client and server
        to make sure old and out-of-order pings are not processed in a
        non-healthy way.  Note that pings are usually datagram RPC calls
        which are marked as idempotent.

    cAddToSet
    cDelFromSet - The count of element in AddTo/DelFromSet parameter.

    AddToSet
    DelFromSet - OID mostly likly belonging to servers on this machine
        to Add/Remove from the set of OIDs in use by this client.

    pPingBackoffFactor - Maybe set by servers which want to reduce the
        ping load on the server.  Serves only as a HINT for the client.
        Clients do not to ping more offten then:
                (1<<*pPingBackoffFactor)*BasePingInterval seconds.
        Clients may choose to assume this parameter is always 0.

Return Value:

    OR_OK - completed normally

    OR_BADSET - non-zero and unknown setid.

    OR_NOMEM - unable to allocate a resource.  Note that
        on the first ping a set maybe allocated (setid is non-zero
        after call) but some OIDs failed to be allocated.

    OR_BADOID - everything went okay, but some OIDs added where
        not recognized.

--*/

{
    CServerSet    *pServerSet;
    BOOL           fProcessPing;
    BOOL           fBad = FALSE;
    PSID           psid = 0;
    ORSTATUS       status = OR_OK;

    // Parameter validation.
    if (!pSetId || 
        !(cAddToSet > 0 ? (AddToSet != NULL) : TRUE) ||
        !(cDelFromSet > 0 ? (DelFromSet != NULL) : TRUE) ||
        !pPingBackoffFactor)
    {
        return OR_BADPARAM;
    }

    gpServerLock->LockExclusive();

    // Lookup the set

    if (0 != *pSetId)
    {
        pServerSet = (CServerSet *)gpServerSetTable->Lookup(*pSetId);
        if (0 == pServerSet)
        {
            status = OR_BADSET;
        }

        if (status == OR_OK)
        {
            if (pServerSet->CheckSecurity(hRpc) != TRUE)
            {
                KdPrintEx((DPFLTR_DCOMSS_ID,
                           DPFLTR_WARNING_LEVEL,
                           "OR: Security check on set failed! (%d)\n",
                           GetLastError()));

                status = OR_NOACCESS;
            }
        }
    }
    else if (hRpc == 0)
    {
        // Local client
        psid = 0;
        pServerSet = gpServerSetTable->Allocate(SequenceNum,
                                                psid,
                                                hRpc == 0,
                                                *pSetId);

        if (0 == pServerSet)
            status = OR_NOMEM;
        else
            status = OR_OK;

    }
    else
    {
        HANDLE hT;
        BOOL f;
        // Unallocated set, lookup security info and allocate the set.

        KdPrintEx((DPFLTR_DCOMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "OR: New client started pinging: %p\n",
                   hRpc));

        status = RpcImpersonateClient(hRpc);

        if (status == RPC_S_OK)
        {
            f = OpenThreadToken(GetCurrentThread(),
                                TOKEN_IMPERSONATE | TOKEN_QUERY,
                                TRUE,
                                &hT);

            if (!f)
            {
                status = GetLastError();
            }
            else
            {
                status = RPC_S_OK;
            }

        }

        if (status != RPC_S_OK)
        {
            KdPrintEx((DPFLTR_DCOMSS_ID,
                       DPFLTR_WARNING_LEVEL,
                       "OR: Unsecure client started pinging: %d %p\n",
                       status,
                       hRpc));

            status = OR_OK;
        }
        else
        {
            ULONG needed = DEBUG_MIN(1, 24);
            PTOKEN_USER ptu;

            do
            {
                ptu = (PTOKEN_USER)alloca(needed);
                ASSERT(ptu);

                f = GetTokenInformation(hT,
                                        TokenUser,
                                        (PBYTE)ptu,
                                        needed,
                                        &needed);

            } while ( f == FALSE && GetLastError() == ERROR_INSUFFICIENT_BUFFER);

            if (f)
            {
                ASSERT(needed > sizeof(SID));
                psid = new(needed - sizeof(SID)) SID;
                if (psid)
                {
                    f = CopySid(needed, psid, ptu->User.Sid);
                    ASSERT(f == TRUE);
                }
                else
                {
                    status = OR_NOMEM;
                }
            }
            else
            {
                KdPrintEx((DPFLTR_DCOMSS_ID,
                           DPFLTR_WARNING_LEVEL,
                           "OR: Error %d from GetTokenInformation\n",
                           GetLastError()));

                ASSERT(0);
                // Why did this happen. Either return failure to client or
                // continue and make the set unsecure.
                status = OR_NOMEM;
            }

            CloseHandle(hT);
        }

        // Allocate the set

        if (status == OR_OK)
        {
            ASSERT(gpPingSetQuotaManager);
            if (gpPingSetQuotaManager->IsUserQuotaExceeded(psid))
               status = OR_NORESOURCE;
            
            if (OR_OK == status) 
            {
               if (!gpPingSetQuotaManager->ManageQuotaForUser(psid, TRUE))
               {
                  status = OR_NOMEM;
               }
               else
               {
                  pServerSet = gpServerSetTable->Allocate(SequenceNum,
                                                          psid,
                                                          hRpc == 0,
                                                          *pSetId);
      
                  if (0 == pServerSet)
                  {
                      gpPingSetQuotaManager->ManageQuotaForUser(psid, FALSE);
                      status = OR_NOMEM;
                  }
               }
            }
        }
    }

    if (status != OR_OK)
    {
        VALIDATE((status, OR_NOMEM, OR_BADSET, OR_NOACCESS, 0));
        gpServerLock->UnlockExclusive();
        return(status);
    }

    ASSERT(pServerSet);

    fProcessPing = pServerSet->CheckAndUpdateSequenceNumber(SequenceNum);

    if (fProcessPing)
    {
        // Do regular ping

        pServerSet->Ping(FALSE);

        *pPingBackoffFactor = 0;

        // Process Add's
        for (int i = cAddToSet; i ; i--)
        {
            status = pServerSet->AddObject(AddToSet[i - 1]);

            if (status == OR_BADOID)
            {
                fBad = TRUE;
            }
            else if ( status != OR_OK )
            {
                break;
            }
        }

        // Process Deletes - even some adds failed!

        for (i = cDelFromSet; i; i--)
        {
            // Removing can't fail, no way to cleanup.
            pServerSet->RemoveObject(DelFromSet[i - 1]);
        }
    }

    gpServerLock->UnlockExclusive();

    if (status == OR_OK && fBad)
    {
        return(OR_BADOID);
    }

    return(status);
}

error_status_t
_ComplexPing(
            IN  handle_t hRpc,
            IN  SETID   *pSetId,
            IN  USHORT   SequenceNum,
            IN  USHORT   cAddToSet,
            IN  USHORT   cDelFromSet,
            IN  OID      AddToSet[],
            IN  OID      DelFromSet[],
            OUT USHORT  *pPingBackoffFactor
            )
/*--
Routine Description:

      This is the exposed RPC entry point for this function.  We 
      simply call the internal function below.  See description 
      for ComplexPingInternal.   The reason for a separate function
      is because the RPC method is typed to to take USHORT's, but 
      internally it is more convienent to pass ULONG's.

Arguments:
    
      See argument list for ComplexPingInternal

--*/
{
    return ComplexPingInternal(hRpc,
                               pSetId,
                               SequenceNum,
                               cAddToSet,
                               cDelFromSet,
                               AddToSet,
                               DelFromSet,
                               pPingBackoffFactor);
}



error_status_t
_ServerAlive(
            RPC_ASYNC_STATE *pAsync,
            RPC_BINDING_HANDLE hServer
            )
/*++

Routine Description:

    Ping API for the client to validate a binding.  Used when the client
    is unsure of the correct binding for the server.  (Ie. If the server
    has multiple IP addresses).

Arguments:

    hServer - RPC call binding

Return Value:

    OR_OK

--*/
{
    error_status_t RetVal = OR_OK;
    RPC_STATUS rpcstatus;
    RegisterAuthInfoIfNecessary();
    rpcstatus = RpcAsyncCompleteCall(pAsync, &RetVal);
    return (rpcstatus == RPC_S_OK) ? RetVal : rpcstatus;
}



error_status_t
_ServerAlive2(
            RPC_ASYNC_STATE *pAsync,
            RPC_BINDING_HANDLE hServer,
            COMVERSION      *pComVersion,
            DUALSTRINGARRAY **ppdsaOrBindings,
            DWORD           *pReserved
            )
/*++

Routine Description:

    Ping API for the client to validate a binding.  Used when the client
    is unsure of the correct binding or authentication service for the server.
    (Ie. If the server has multiple IP addresses).

Arguments:

    hServer - RPC call binding

Return Value:

    OR_OK

--*/
{
    error_status_t RetVal     = OR_OK;
    RPC_STATUS rpcstatus = RPC_S_OK;

    // Parameter validation
    if (!pComVersion || !ppdsaOrBindings || !pReserved)
        return OR_BADPARAM;

    RegisterAuthInfoIfNecessary();
    pComVersion->MajorVersion = COM_MAJOR_VERSION;
    pComVersion->MinorVersion = COM_MINOR_VERSION;
    *pReserved                 = 0;

    RetVal = CopyMyOrBindings(ppdsaOrBindings, NULL);
    if (RetVal == OR_OK)
    {
        rpcstatus = RpcAsyncCompleteCall(pAsync, &RetVal);
    }
    
    return (rpcstatus == RPC_S_OK) ? RetVal : rpcstatus;
}



void __RPC_USER PHPROCESS_rundown(LPVOID ProcessKey)
{
    CProcess *pProcess = ReferenceProcess(ProcessKey);

    KdPrintEx((DPFLTR_DCOMSS_ID,
               DPFLTR_INFO_LEVEL,
               "OR: Client died\n"));

    ASSERT(pProcess);

    //
    // This revokes OLE class registrations which were not revoked by this
    // dead process.  This must be done here rather then CProcess::Rundown
    // because these things have references to the CProcess object.
    //
    pProcess->RevokeClassRegs();

    pProcess->Cleanup();

    ReleaseProcess(pProcess);

    return;
}



//+---------------------------------------------------------------------------
//
//  Function:   CRpcSecurityCallbackManager::RegisterForRpcAuthSvcCallBack
//
//  Synopsis:   Register the security callback with RPC.  A return value of
//              TRUE means the calling thread may make a call on the supplied
//              binding handle, then call the the RetrieveAuthSvc method
//              for the negotiated authentication svc used on the rpc call.
//
//  Parameters: hRpc -- the binding handle for which the calling thread wants
//                      the negotiated auth. svc.
//
//  Algorithm:  Register the security callback with RPC.    Create a new list
//              element to represent this particular callback, and add to to
//              the list of callbacks.
//
//  Notes:      There is a limitation:  a thread can only be registered for one
//              callback at a time.   This should be ok for expected usage.
//
//----------------------------------------------------------------------------
BOOL CRpcSecurityCallbackManager::RegisterForRpcAuthSvcCallBack(handle_t hRpc)
{
  RPC_STATUS status;
  CRpcSecurityCallback* pNewCallback;

  ASSERT(hRpc != 0 && "Callbacks are meant to be used only for remote calls!");

  // Create a new list element to represent this callback
  pNewCallback = new CRpcSecurityCallback(hRpc, GetCurrentThreadId());
  if (!pNewCallback)
    return FALSE; // out-of-memory, not much we can do

  // Try to register the callback
  status = RpcBindingSetOption(hRpc,
                               RPC_C_OPT_SECURITY_CALLBACK,
                               (ULONG_PTR)CRpcSecurityCallbackManager::RpcSecurityCallbackFunction);
  ASSERT(status == RPC_S_OK); // this should never fail AFAIK
  if (status != RPC_S_OK)
  {
    // again, not much we can do
    delete pNewCallback;
    return FALSE;
  }

  // Okay now we got all we need; add it to the list
  _plistlock->LockExclusive();
  _CallbackList.Insert(pNewCallback);
  _plistlock->UnlockExclusive();

  return TRUE;
};


//+---------------------------------------------------------------------------
//
//  Function:   CRpcSecurityCallbackManager::GetAuthSvcAndTurnOffCallback
//
//  Synopsis:   Tries to retrieve the negotiated authentication service for the
//              call just completed on the supplied binding handle.   Also
//              turns off callbacks on the binding handle.
//
//  Parameters: pusAuthSvc -- if the rpc call was made, this must be a valid ptr;
//                  if that is the case, then upon a return value of TRUE, it
//                  will contain the auth. svc used for the call;  a value of NULL
//                  passed here means the caller doesn't care about the result, he
//                  just wants things cleaned up (typically this means either the
//                  call failed or was never made).
//
//  Returns:    TRUE -- if everything worked
//              FALSE -- something is wrong or you passed a NULL pusAuthSvc
//
//  Algorithm:  Use the caller's thread id to search for the callback result
//
//----------------------------------------------------------------------------
BOOL CRpcSecurityCallbackManager::GetAuthSvcAndTurnOffCallback(handle_t hRpc, USHORT* pusAuthSvc)
{
  RPC_STATUS status;
  CRpcSecurityCallback* pCallback;
  DWORD dwCurrentThread = GetCurrentThreadId();

  _plistlock->LockExclusive();

  // No matter what happens after this, we should turn off callbacks for the handle
  TurnOffCallback(hRpc);

  // Look for the callback result for the calling thread
  for (pCallback = (CRpcSecurityCallback*)_CallbackList.First();
       pCallback;
       pCallback = (CRpcSecurityCallback*)pCallback->Next() )
  {
    if (dwCurrentThread == pCallback->GetRegisteredThreadId())
    {
      // found it
      break;
    }
  };

  // Given the normal usage of this stuff, we should always find a result
  ASSERT(pCallback && "Didn't find rpc sec. callback result; this is unexpected");
  if (!pCallback)
  {
    _plistlock->UnlockExclusive();
    return FALSE;
  };

  if (pusAuthSvc)
  {
    ASSERT(pCallback->WasAuthSvcSet() && "Caller is retrieving auth svc before it was set");
    *pusAuthSvc = pCallback->GetAuthSvcResult();
  }

  // The callback's work is done, so remove it from the list and delete it
  _CallbackList.Remove(pCallback);
  delete pCallback;

  // Check list to see if other threads also had registered callbacks on the
  // same handle.  We will record the result for them in case we turned off the
  // callback above before they got recorded.  In fact, any time two or more threads
  // register for a callback on the same handle we will hit this scenario.
  //
  // I don't think this is 100% foolproof, but it constitutes a best-faith effort
  //
  for (pCallback = (CRpcSecurityCallback*)_CallbackList.First();
       pCallback;
       pCallback = (CRpcSecurityCallback*)pCallback->Next() )
  {
    if (hRpc == pCallback->RegisteredHandle())
    {
      // found a match
      ASSERT(dwCurrentThread != pCallback->GetRegisteredThreadId());
      pCallback->SetAuthSvc(*pusAuthSvc);
    }
  };

  _plistlock->UnlockExclusive();

  return pusAuthSvc ? (*pusAuthSvc != ERROR_AUTHNSVC_VALUE) : FALSE;
};

//+---------------------------------------------------------------------------
//
//  Function:   CRpcSecurityCallbackManager::TurnOffCallback
//
//  Synopsis:   Function to turn off the callback on an rpc binding handle
//
//  Parameters: hRpc -- the binding handle to turn off callbacks on
//
BOOL CRpcSecurityCallbackManager::TurnOffCallback(handle_t hRpc)
{
  RPC_STATUS status;
  status = RpcBindingSetOption(hRpc,
                               RPC_C_OPT_SECURITY_CALLBACK,
                               (ULONG_PTR) NULL );

  ASSERT(status == RPC_S_OK && "RpcBindingSetOption failed when turning off security callback");

  return TRUE;
};


//+---------------------------------------------------------------------------
//
//  Function:   CRpcSecurityCallbackManager::StoreCallbackResult
//
//  Synopsis:   This is a helper function for the callback function; no one
//              else should use it obviously.
//
//  Parameters: usAuthSvc -- the negotiated authentication service for the rpc
//                call that the calling thread presumably just completed.
//
void CRpcSecurityCallbackManager::StoreCallbackResult(USHORT usAuthSvc)
{
  CRpcSecurityCallback* pCallback;
  DWORD dwCurrentThread = GetCurrentThreadId();

  // Only need a shared lock for this
   _plistlock->LockShared();

  for (pCallback = (CRpcSecurityCallback*)_CallbackList.First();
       pCallback;
       pCallback = (CRpcSecurityCallback*)pCallback->Next() )
  {
    if (dwCurrentThread == pCallback->GetRegisteredThreadId())
    {
      // found it
      break;
    }
  };

  ASSERT(pCallback);  // we should always find it

  pCallback->SetAuthSvc(usAuthSvc);

   _plistlock->UnlockShared();

  return;
};


//+---------------------------------------------------------------------------
//
//  Function:   CRpcSecurityCallbackManager::RpcSecurityCallbackFunction
//
//  Synopsis:   This is a callback function; we use this by setting it on a
//              binding handle (using the RPC_C_OPT_SECURITY_CALLBACK option)
//              so that RPC will call us back;  this gives us a chance to
//              determine what authentication svc was negotiated when using
//              snego.
//
//  Parameters: pvContext -- an opaque parameter
//
//  Algorithm:  call I_RpcBindingInqWireIdForSnego (undocumented rpc call)
//              passing it the opaque pvContext parameter.
//
//  Notes:      it would be nice if we could get some info in this callback
//              as to *which* handle the callback is for, but unfortunately
//              kamenm was explicit on this point: pvContext is to remain
//              opaque.  :)
//
//----------------------------------------------------------------------------
void RPC_ENTRY CRpcSecurityCallbackManager::RpcSecurityCallbackFunction(void* pvContext)
{
  RPC_STATUS status;
  UCHAR      ucWireId;

  // Call back to get the authsvc:
  status = I_RpcBindingInqWireIdForSnego((RPC_BINDING_HANDLE)pvContext, &ucWireId);

  ASSERT(status != RPC_S_SEC_PKG_ERROR);   // RPC should not have called us back
                                           // in the first place, so assert on this

  ASSERT(status != RPC_S_INVALID_BINDING); // RPC folks say this can be returned for the
                                           // following reasons:  1) unauthenticated call;
                                           // 2) invalid context; 3) snego was not used in
                                           // the first place.  None of these should apply
                                           // to us, so assert
  if (status == RPC_S_OK)
  {
    ASSERT( (ucWireId != RPC_C_AUTHN_GSS_NEGOTIATE) && "We're supposed to get back the real deal not snego");

    gpCRpcSecurityCallbackMgr->StoreCallbackResult(ucWireId);
  }
  else
  {
    // something went wrong (most likely in the lower level security code).
    gpCRpcSecurityCallbackMgr->StoreCallbackResult(ERROR_AUTHNSVC_VALUE);
  }

  return;
};
DWORD CPingSetQuotaManager::_dwPerUserPingSetQuota = 1000;

//+---------------------------------------------------------------------------
//
//  Function:   CPingSetQuotaManager::ManageQuotaForUser
//
//  Synopsis:   This function manages the pingset quota for the user indicated by 
//              pSID. fAlloc = TRUE means alloc pingset quota, else deduct quota
//
BOOL CPingSetQuotaManager::ManageQuotaForUser(PSID pSid, BOOL fAlloc)
{
   CUserPingSetCount *pNode = NULL;
   RPC_STATUS status = OR_NOMEM;
   
   // first see if have the user in the list
   _plistlock->LockExclusive();
  
  for (pNode = (CUserPingSetCount*)_UserPingSetCountList.First();
       pNode;
       pNode = (CUserPingSetCount*)pNode->Next() )
  {
    if (pNode->IsEqual(pSid))
    {
      // found it
      break;
    }
  };
  if (pNode) 
  {
     // Have one, munge count
     if (fAlloc) 
     {
        pNode->Increment();
     }
     else
     {
        pNode->Decrement();
        // last ping set for this user, delete node
        if (pNode->GetCount() == 0)
        {
           _UserPingSetCountList.Remove(pNode);
           delete pNode;
        }
     }
     status = OR_OK;
  }
  else
  {
     // Don't have one, add. 
     ASSERT( fAlloc == TRUE );
     pNode = new CUserPingSetCount(status, pSid);
     if (pNode && (status == OR_OK) ) 
     {
        // start with 1
        pNode->Increment();
        _UserPingSetCountList.Insert(pNode);
     }
  }
  _plistlock->UnlockExclusive();
  return (OR_OK == status);
}

//+---------------------------------------------------------------------------
//
//  Function:   CPingSetQuotaManager::IsUserQuotaExceeded
//
//  Synopsis:   This function determines if the quota is above limit for a given user
//              pSID. returns TRUE if the limit is reached, FALSE otherwise
//
BOOL CPingSetQuotaManager::IsUserQuotaExceeded(PSID pSid)
{
   CUserPingSetCount *pNode = NULL;
   // first see if have the user in the list
   _plistlock->LockShared();
  
  for (pNode = (CUserPingSetCount*)_UserPingSetCountList.First();
       pNode;
       pNode = (CUserPingSetCount*)pNode->Next() )
  {
    if (pNode->IsEqual(pSid))
    {
      // found it
      break;
    }
  };
  if (pNode)
  {
     DWORD dw = pNode->GetCount();
     if (dw >= _dwPerUserPingSetQuota ) 
     {
        _plistlock->UnlockShared();
        return TRUE;
     }
  }
  _plistlock->UnlockShared();
  return FALSE;
}

void CPingSetQuotaManager::SetPerUserPingSetQuota(DWORD dwQuota)
{
   _dwPerUserPingSetQuota = dwQuota;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\objex\misc.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    Misc.cxx

Abstract:

    Initalization, Heap, debug, thread manager for OR

Author:

    Mario Goertzel    [MarioGo]

Revision History:

    MarioGo     02-11-95    Bits 'n pieces

--*/

#include <or.hxx>
#include <mach.hxx>
#include <excladdr.hxx>
#include <addrrefresh.hxx>

extern "C"
{
#define SECURITY_WIN32 // Used by security.h
#include <security.h>
}

BOOL fListened            = FALSE;
BOOL gfRegisteredAuthInfo = FALSE;

extern BOOL  gbDynamicIPChangesEnabled;
extern DWORD gdwTimeoutPeriodForStaleMids;

const UINT IP_MAXIMUM_RAW_NAME    = 16;   // xxx.xxx.xxx.xxx
const UINT IP_MAXIMUM_PRETTY_NAME = 256;  // DNS limit

// Contains compressed remote protseqs and network addresses 
// for this process, minus any addresses in the current
// exclusion list.  This is a refcounted object
CDualStringArray* gpdsaMyBindings = 0;

// Contains all compressed remote protseqs and network addresses 
// for this process.  Not refcounted.  We maintain this one
// to help when building a new gpdsaMyBindings above.
DUALSTRINGARRAY* gpdsaFullBindings = 0;

//  Contains initial DNS name for TCP
WCHAR  gwszInitialDNSName[IP_MAXIMUM_PRETTY_NAME];

// Authentication services successfully registered.
DWORD      s_cRpcssSvc      = 0;
SECPKG    *s_aRpcssSvc      = NULL;

// Unique ID used to track which global resolver bindings 
// are currently in use.  Note that this starts at one, and
// everybody else starts theirs at zero.  Therefore any 
// updates that originate from PushCurrentBindings should
// take precedence.  This should be looked at\modified only
// when gpClientLock is taken, in sync with modifying
// gpdsaMyBindings.  In addition, this should be incremented
// whenever gpdsaMyBindings is updated with new bindings.
DWORD64 g_dwResolverBindingsID = 1;

// Definitions used for asynchronous mid releases
const DWORD ASYNCMIDRELEASEARGS_SIG = 0xFEDCBA02;

typedef struct _ASYNCMIDRELEASEARGS
{
    DWORD dwAMRASig; // see ASYNCMIDRELEASEARGS_SIG
    HANDLE hTimer;
    CMid* pMidToRelease;
} ASYNCMIDRELEASEARGS;


ORSTATUS
StartListeningIfNecessary()
/*++

Routine Description:

    If the process has not successfully listened to remote
    protocols this routine will try do to so.

Note:

    Will not add ncacn_np to the list of supported Network OLE
    protocols because RpcBindingServerFromClient() doesn't
    work on named pipes and is required to unmarshal an in
    interface pointer.

Arguments:

    n/a

Return Value:

    OR_OK - Success.

    OR_NOMEM - Resource problems.

--*/
{
    RPC_STATUS status;
    PWSTR pwstr = gpwstrProtseqs;
    USHORT id;
    CIPAddrs* pIPAddrs = NULL;
    BOOL bPushNewBindings = FALSE;

    if (fListened == TRUE)
    {
        return(OR_OK);
    }

    gpClientLock->LockExclusive();

    if (fListened == TRUE)
    {
        gpClientLock->UnlockExclusive();
        return(OR_OK);
    }

    OrStringCopy(gwszInitialDNSName, L"");

    if (pwstr)
    {
        while (*pwstr)
        {

            // skip leading white space
            while ((*pwstr == L' ') || (*pwstr == L'\t'))
            {
                pwstr++;
            }

            if (*pwstr)
            {
                id = GetProtseqId(pwstr);

                // ronans - DCOMHTTP
                // we want to add http to the list of bindings even if listening does not
                // succeed as this machine could still be a client of http without being a server
                if (0 != id)
                {
                    KdPrintEx((DPFLTR_DCOMSS_ID,
                               DPFLTR_WARNING_LEVEL,
                               "OR: Trying to listen to [%d]\n",
                               id));

                    if (id == ID_DCOMHTTP )
                        g_fClientHttp = TRUE;

                    status = UseProtseqIfNecessary(id);
                    if (status == RPC_S_OK)
                    {
                        if (id == ID_TCP)
                        {
                            gAddrRefreshMgr.ListenedOnTCP();
                            gAddrRefreshMgr.RegisterForAddressChanges();

                            // There may have been processes which connected before
                            // we were able to listen on tcp.  To make sure they 
                            // have the correct bindings, we must refresh them now.
                            bPushNewBindings = TRUE;
                        }

                        // if listening succeeded - no need to special case http as its in the normal
                        // list of protocols
                        if (id == ID_DCOMHTTP )
                            g_fClientHttp = FALSE;

                        fListened = TRUE;
                        KdPrintEx((DPFLTR_DCOMSS_ID,
                                   DPFLTR_WARNING_LEVEL,
                                   "OR: Listen succeeded on [%d]\n",
                                   id));
                    }
                    else
                        KdPrintEx((DPFLTR_DCOMSS_ID,
                                   DPFLTR_WARNING_LEVEL,
                                   "OR: Listen failed on [%d]\n",
                                   id));
                }
            }

            pwstr = OrStringSearch(pwstr, 0) + 1;
        }
    }

    // Initialize machine name object now that winsock should be started
    status = gpMachineName->Initialize();
    if (status != 0)
    {
        gpClientLock->UnlockExclusive();
        return status;
    }

    if (   FALSE == fListened
           && 0 != gLocalMid)
    {
        // Didn't manage to listen to anything new, no need to
        // recompute all the global arrays.

        gpClientLock->UnlockExclusive();
        return(OR_OK);
    }

    // ??? limit to only those protseqs listed in the registry,
    // if the another service used more protseqs they would show up here.

    RPC_BINDING_VECTOR *pbv;
    PWSTR pwstrT;
    DUALSTRINGARRAY *pdsaT;
    PWSTR *aAddresses;
    USHORT *aProtseqs;
    unsigned short psaLen;
    DWORD i;
    DWORD iProtseq;

    status = RpcServerInqBindings(&pbv);

    if (RPC_S_OK == status)
    {
        aAddresses = new PWSTR[pbv->Count];
        aProtseqs = new USHORT[pbv->Count];

        if (   !aAddresses
               || !aProtseqs)
        {
            RpcBindingVectorFree(&pbv);
            delete aAddresses; // 0 or allocated.
            delete aProtseqs;  // 0 or allocated.
            status = OR_NOMEM;
        }
    }
    else
        status = OR_NOMEM;

    if (status != OR_OK)
    {
        gpClientLock->UnlockExclusive();
        return(status);
    }

    // Build array of protseqs id's and addresses we're listening to.
    pwstr = gpwstrProtseqs;
    if (pwstr)
    {
        psaLen = 0;
        iProtseq = 0;
        // start with the list of allowed protocols
        // listed in the registry.  For each protocol, in order,
        // check to see if there is an endpoint registered for it.

        // NOTE: Do not change the order of these loops
        // It is pertinent to correctly order the final
        // string.
        while (*pwstr)
        {
            id = GetProtseqId(pwstr);

            if (0 != id)
            {
                for (i = 0; i < pbv->Count; i++)
                {
                    PWSTR pwstrStringBinding;

                    status = RpcBindingToStringBinding(pbv->BindingH[i], &pwstrStringBinding);
                    if (status != RPC_S_OK)
                    {
                        break;
                    }
                    ASSERT(pwstrStringBinding);

                    status = RpcStringBindingParse(pwstrStringBinding,
                                                   0,
                                                   &pwstrT,
                                                   &aAddresses[iProtseq],
                                                   0,
                                                   0);

                    RPC_STATUS statusT = RpcStringFree(&pwstrStringBinding);
                    ASSERT(statusT == RPC_S_OK && pwstrStringBinding == 0);

                    if (status != RPC_S_OK)
                    {
                        break;
                    }

                    //
                    // if the protocol name matches we can use this one
                    //

                    if (lstrcmpW(pwstrT, pwstr) == 0)
                    {
                        aProtseqs[iProtseq] = id;

                        status = RpcStringFree(&pwstrT);
                        ASSERT(status == RPC_S_OK && pwstrT == 0);

                        // Disallow datagram protocols till they
                        // support SSL and snego.
                        if (!IsLocal(aProtseqs[iProtseq]) && aProtseqs[iProtseq] != ID_NP &&
                            aProtseqs[iProtseq] != ID_UDP && aProtseqs[iProtseq] != ID_IPX)
                        {
                            // Only hand out remote non-named pipes protseqs.
                            psaLen += 1 + OrStringLen(aAddresses[iProtseq]) + 1;

                            // Save the dns name RPC gave us;  we will need this in future
                            // if the IP's change and we need to rebuild the bindings
                            if (aProtseqs[iProtseq] == ID_TCP)
                            {
                              OrStringCopy(gwszInitialDNSName, aAddresses[iProtseq]);
                            }

                            // compute length w/IP address(es)
                            if (aProtseqs[iProtseq] == ID_TCP || aProtseqs[iProtseq] == ID_UDP)
                            {
                                if (!pIPAddrs)
                                {
                                  pIPAddrs = gpMachineName->GetIPAddrs();
                                }
                                
                                if (pIPAddrs)
                                {
                                  NetworkAddressVector* pNetworkAddrVector = pIPAddrs->_pIPAddresses;

                                  ASSERT(pNetworkAddrVector);
                                    
                                  for (ULONG j=0; j<pNetworkAddrVector->Count; j++)
                                  {
                                    // do not include the loopback address in resolver bindings.
                                    if (lstrcmpW(L"127.0.0.1", pNetworkAddrVector->NetworkAddresses[j]) != 0)
                                    {
                                      psaLen += 1 + OrStringLen(pNetworkAddrVector->NetworkAddresses[j]) + 1;
                                    }
                                  }
                                }
                            }
                        }

                        iProtseq++;
                        break;
                    }
                    else
                    {
                        status = RpcStringFree(&pwstrT);
                        ASSERT(status == RPC_S_OK && pwstrT == 0);
                        status = RpcStringFree(&aAddresses[iProtseq]);
                        ASSERT(status == RPC_S_OK && pwstrT == 0);
                    }

                }
                if (status != RPC_S_OK)
                {
                    break;
                }

            }
            pwstr = OrStringSearch(pwstr, 0) + 1;
        }
    }

    if (status != RPC_S_OK)
    {
        delete aAddresses;
        delete aProtseqs;
        RPC_STATUS status_tmp = RpcBindingVectorFree(&pbv);
        ASSERT(pbv == 0 && status_tmp == RPC_S_OK);
        gpClientLock->UnlockExclusive();
        if (pIPAddrs)
          pIPAddrs->DecRefCount();
        return(status);
    }


    // string bindings final null, authn and authz service list and
    // one final nulls

    if (psaLen == 0)
    {
        // No remote bindings, leave space for an extra NULL.
        psaLen = 1;
    }
    if (s_cRpcssSvc == 0)
    {
        // No authentication services, leave space for an extra NULL.
        psaLen += 1;
    }
    psaLen += (unsigned short)(1 + 3*s_cRpcssSvc + 1);

    pdsaT = new(psaLen * sizeof(WCHAR)) DUALSTRINGARRAY;

    if (!pdsaT)
    {
        delete aAddresses;
        delete aProtseqs;
        status = RpcBindingVectorFree(&pbv);
        ASSERT(pbv == 0 && status == RPC_S_OK);
        gpClientLock->UnlockExclusive();
        if (pIPAddrs)
          pIPAddrs->DecRefCount();
        return OR_NOMEM;
    }

    pdsaT->wNumEntries = psaLen;
    if (s_cRpcssSvc == 0)
        pdsaT->wSecurityOffset = psaLen - 2;
    else
        pdsaT->wSecurityOffset = (unsigned short)(psaLen - 3*s_cRpcssSvc - 1);
    pwstrT = pdsaT->aStringArray;

    for (i = 0; i < iProtseq; i++)
    {
        // Disallow datagram protocols till they
        // support SSL and snego.
        if (!IsLocal(aProtseqs[i]) && aProtseqs[i] != ID_NP &&
            aProtseqs[i] != ID_UDP && aProtseqs[i] != ID_IPX)
        {
            *pwstrT = aProtseqs[i];
            pwstrT++;
            OrStringCopy(pwstrT, aAddresses[i]);
            pwstrT = OrStringSearch(pwstrT, 0) + 1;  // next

            // add the IP address(es)
            if (aProtseqs[i] == ID_TCP || aProtseqs[i] == ID_UDP)
            {
                if (!pIPAddrs)
                {
                    pIPAddrs = gpMachineName->GetIPAddrs();
                }

                if (pIPAddrs)
                {
                    NetworkAddressVector* pNetworkAddrVector = pIPAddrs->_pIPAddresses;
                    ASSERT(pNetworkAddrVector);

                    for (ULONG j=0; j<pNetworkAddrVector->Count; j++)
                    {
                        // do not include the loopback address in resolver bindings.
                        if (lstrcmpW(L"127.0.0.1", pNetworkAddrVector->NetworkAddresses[j]) != 0)
                        {
                            *pwstrT = aProtseqs[i];
                            pwstrT++;
                            OrStringCopy(pwstrT, pNetworkAddrVector->NetworkAddresses[j]);
                            pwstrT = OrStringSearch(pwstrT, 0) + 1;  // next
                        }
                    }
                }
            }
        }

        status = RpcStringFree(&aAddresses[i]);
        ASSERT(status == RPC_S_OK);
    }

    if (pdsaT->wSecurityOffset == 2)
    {
        // No remote bindings, put in first null.
        pdsaT->aStringArray[0] = 0;
        pwstrT++;
    }

    // Zero final terminator
    *pwstrT = 0;
    pwstrT++;

    // Security authn services
    for (i = 0; i < s_cRpcssSvc; i++)
    {
        // Authn service, Authz service (-1 means none), NULL principal name
        *pwstrT = s_aRpcssSvc[i].wId;
        pwstrT++;
        *pwstrT = -1;
        pwstrT++;
        *pwstrT = 0;
        pwstrT++;
    }

    // If there are no authentication services, put in an extra NULL.
    if (s_cRpcssSvc == 0)
    {
        *pwstrT = 0;
        pwstrT++;
    }

    // Final NULL
    *pwstrT = 0;

    ASSERT(dsaValid(pdsaT));

    USHORT cRemoteProtseqs = 0;

    // Convert aProtseqs into remote only array of protseqs and count them.
    for (i = 0; i < iProtseq; i++)
    {
        // Disallow datagram protocols till they
        // support SSL and snego.
        if (!IsLocal(aProtseqs[i]) && aProtseqs[i] != ID_NP &&
            aProtseqs[i] != ID_UDP && aProtseqs[i] != ID_IPX)
        {
            aProtseqs[cRemoteProtseqs] = aProtseqs[i];
            cRemoteProtseqs++;
        }
    }

    delete aAddresses;
    status = RpcBindingVectorFree(&pbv);
    ASSERT(pbv == 0 && status == RPC_S_OK);

    if (pIPAddrs) pIPAddrs->DecRefCount();
    pIPAddrs = NULL;

    gAddrExclusionMgr.InitializeFromRegistry();

    // Obtain bindings filtered by exclusion list
    HRESULT hr;
    DUALSTRINGARRAY* pdsaFiltered;
    hr = gAddrExclusionMgr.BuildExclusionDSA(pdsaT, &pdsaFiltered);
    if (FAILED(hr))
    {
        delete pdsaT;
		gpClientLock->UnlockExclusive();
        return (OR_NOMEM);
    }

    // The mid object makes a copy of pdsaFiltered, it doesn't own it
    CMid *pMid = new(pdsaFiltered->wNumEntries * sizeof(WCHAR)) CMid(pdsaFiltered, TRUE, gLocalMid);
    if (pMid)
    {
        CDualStringArray* pdsaWrapper = new CDualStringArray(pdsaFiltered);
        if (pdsaWrapper)
        {
            if (gpdsaFullBindings) delete gpdsaFullBindings;
            gpdsaFullBindings = pdsaT; // the full bindings
    
            ASSERT(gpClientLock->HeldExclusive());
            gpMidTable->Add(pMid);

            aMyProtseqs = aProtseqs;
            cMyProtseqs = cRemoteProtseqs;
			
            if (gpdsaMyBindings) gpdsaMyBindings->Release();
            gpdsaMyBindings = pdsaWrapper; // the filtered bindings
            gLocalMid = pMid->Id();

            // Increment id counter
            g_dwResolverBindingsID++;
	
            // Release the lock now, so we don't hold it across PushCurrentBindings.
            gpClientLock->UnlockExclusive();

            // Push new bindings if so called for.  Not fatal if this fails
            if (bPushNewBindings)
            {
                PushCurrentBindings();
            }

            return OR_OK;
        }
    }

    // Failed to get memory
    if (pMid) delete pMid;
    delete pdsaT;
    MIDL_user_free(pdsaFiltered);
    delete aProtseqs;
    gpClientLock->UnlockExclusive();
    return(OR_NOMEM);
}

BOOL IsHttpClient()
/*++

Routine Description:

    Returns the global client http flag while holding a lock

Return Value:

    None

--*/
{
    BOOL retval;
    gpClientLock->LockExclusive();

    retval = g_fClientHttp;

    gpClientLock->UnlockExclusive();

    return retval;
}


void CALLBACK 
AsyncMidReleaseTimerCallback(void* pvParam, BOOLEAN TimerOrWaitFired)
/*++

Routine Description:

    Releases the mid object that was queued to a timer in 
    DoAsyncMidRelease below.

Return Value:

    None

--*/
{
    BOOL fResult;
    ASYNCMIDRELEASEARGS* pArgs;

    ASSERT(TimerOrWaitFired);

    pArgs = (ASYNCMIDRELEASEARGS*)pvParam;
    ASSERT(pArgs);
    ASSERT(pArgs->dwAMRASig == ASYNCMIDRELEASEARGS_SIG);
    ASSERT(pArgs->hTimer);
    ASSERT(pArgs->pMidToRelease);

    gpClientLock->LockExclusive();
    
    pArgs->pMidToRelease->Release();

    gpClientLock->UnlockExclusive();
        
    // Make a non-blocking call to delete the timer.
    fResult = DeleteTimerQueueTimer(NULL,
                                    pArgs->hTimer,
                                    NULL);
    ASSERT(fResult);

    // Finally, delete the argument structure
    delete pArgs;
                            
    return;
}

void 
DoAsyncMidRelease(CMid* pMid, DWORD dwReleaseInMSec)
/*++

Routine Description:

    Creates a timer callback that will call ->Release on the
    supplied mid object in the specified amount of time.  If
    the timer creation fails, does an immediate release.

Return Value:

    None

--*/
{
    BOOL bResult;
    HANDLE hNewTimer;
    ASYNCMIDRELEASEARGS* pArgs;

    ASSERT(pMid);
    ASSERT(gpClientLock->HeldExclusive());

    pArgs = new ASYNCMIDRELEASEARGS;
    if (!pArgs)
    {
        // Nothing we can do -- mid will be released synchronously
        // when this occurs.
        return;
    }
    
    // Initialize the struct
    pArgs->dwAMRASig = ASYNCMIDRELEASEARGS_SIG;
    pArgs->hTimer = NULL;
    pArgs->pMidToRelease = pMid;

    pMid->Reference();

    bResult = CreateTimerQueueTimer(&(pArgs->hTimer),
                                    NULL,
                                    AsyncMidReleaseTimerCallback,
                                    pArgs,
                                    dwReleaseInMSec,
                                    0,
                                    WT_EXECUTEINTIMERTHREAD);
    if (!bResult)
    {
        // Timer failed; release struct and mid object immediately to 
        // avoid leaking them.  Like above, mid is released sync.
        pMid->Release();
        delete pArgs;
    }
    return;
}

RPC_STATUS
ComputeNewResolverBindings(void)
/*++

Routine Description:

    Creates the local OR bindings using the current IP addresses, and
    places the results in gpdsaFullBindings.  gpdsaFullBindings is then
    passed to the address exclusion mgr object, who creates a "filtered"
    set of bindings, which omits any currently excluded addresses; these
    bindings are saved in gpdsaMyBindings.

    Caller must be holding gpClientLock.

Return Value:

    RPC_S_OK
    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES

--*/
{
    BOOL  fDoneTCP = FALSE;
    BOOL  fDoneUDP = FALSE;
    DWORD i;
    CIPAddrs* pIPAddrs;
    DWORD dwNumAddrs;
	
    ASSERT(gpdsaMyBindings);
    ASSERT(gpClientLock->HeldExclusive());

    pIPAddrs = gpMachineName->GetIPAddrs();
    dwNumAddrs = pIPAddrs ? pIPAddrs->_pIPAddresses->Count : 0;

    // compute size of new dsa (for each IP address, leave space
    // for max IP name size * 2 (one for TCP/IP and one for UDP).
    DWORD psaLen = (dwNumAddrs * IP_MAXIMUM_RAW_NAME * sizeof(RPC_CHAR) * 2);
    psaLen += sizeof(DUALSTRINGARRAY) + (gpdsaMyBindings->DSA()->wNumEntries * sizeof(USHORT));
    DWORD dwDNSLen = OrStringLen(gwszInitialDNSName);
    if (dwDNSLen > 0)
    {
        psaLen += dwDNSLen + 2;
    }

    // Allocate space for the new bindings
    DUALSTRINGARRAY *pdsaT = new(psaLen) DUALSTRINGARRAY;
    if (pdsaT == NULL)
    {
        if (pIPAddrs) pIPAddrs->DecRefCount();
        return RPC_S_OUT_OF_RESOURCES;
    }

    PWSTR pwstrT   = pdsaT->aStringArray;
    PWSTR pwstrSrc = gpdsaFullBindings->aStringArray;

    // copy in the information. For TCP/IP and UDP, we copy in the
    // new IP addresses. For all others, we leave as is.

    psaLen = 0;
    while (*pwstrSrc)
    {
        USHORT id = *pwstrSrc;      // current tower id
        pwstrSrc++;

        if (id == NCACN_IP_TCP)
        {
            if (!fDoneTCP)
            {
                // copy in the DNS name, if any, obtained initially from RPC
                // in StartListeningIfNecessary
                if (dwDNSLen > 0)
                {
                  *pwstrT = id;
                  pwstrT++;
                  OrStringCopy(pwstrT, gwszInitialDNSName);
                  pwstrT += dwDNSLen + 1;
                  psaLen += dwDNSLen + 2;
                }

                // copy in the new IP addresses
                fDoneTCP = TRUE;
                for (UINT i=0; i<dwNumAddrs; i++)
                {
                    *pwstrT = id;       // copy in the tower id
                    pwstrT++;
                    OrStringCopy(pwstrT, pIPAddrs->_pIPAddresses->NetworkAddresses[i]);
                    int len = OrStringLen(pIPAddrs->_pIPAddresses->NetworkAddresses[i]) + 1;
                    pwstrT += len;
                    psaLen += len + 1;
                }
            }
        }
        else if (id == NCADG_IP_UDP)
        {
            if (!fDoneUDP)
            {
                // copy in the new IP addresses
                fDoneUDP = TRUE;
                for (UINT i=0; i<dwNumAddrs; i++)
                {
                    *pwstrT = id;       // copy in the tower id
                    pwstrT++;
                    OrStringCopy(pwstrT, pIPAddrs->_pIPAddresses->NetworkAddresses[i]);
                    int len = OrStringLen(pIPAddrs->_pIPAddresses->NetworkAddresses[i]) + 1;
                    pwstrT += len;
                    psaLen += len + 1;
                }
            }
        }
        else
        {
            // just copy the existing entry unchanged.
            *pwstrT = id;               // copy in the tower id
            pwstrT++;
            OrStringCopy(pwstrT, pwstrSrc);
            int len = OrStringLen(pwstrSrc) + 1;
            pwstrT += len;
            psaLen += len + 1;
        }

        // skip to the next towerid entry
        pwstrSrc += OrStringLen(pwstrSrc) + 1;
    }

    // Zero final terminator
    if (psaLen == 0)
    {
        *((DWORD*) pwstrT) = 0;
        pwstrT += 2;
        psaLen += 2;
    }
    else
    {
        *pwstrT = 0;
        pwstrT++;
        psaLen += 1;
    }

    // Security authn services
    pdsaT->wSecurityOffset = (unsigned short) psaLen;
    for (i = 0; i < s_cRpcssSvc; i++)
    {
        // Authn service, Authz service (-1 means none), NULL principal name
        *pwstrT = s_aRpcssSvc[i].wId;
        pwstrT++;
        *pwstrT = -1;
        pwstrT++;
        *pwstrT = 0;
        pwstrT++;
    }

    // If there are no authentication services, put in an extra NULL.
    if (s_cRpcssSvc == 0)
    {
        *pwstrT = 0;
        pwstrT++;
        psaLen += 1;
    }

    // Final NULL
    psaLen += 3*s_cRpcssSvc + 1;
    *pwstrT = 0;

    // update the size
    pdsaT->wNumEntries = (unsigned short) psaLen;

    ASSERT(dsaValid(pdsaT));

    // Done with ipaddrs
    if (pIPAddrs) pIPAddrs->DecRefCount();
    pIPAddrs = NULL;

    // Always replace the current "full" bindings, so they
    // are always up-to-date.
    delete gpdsaFullBindings;
    gpdsaFullBindings = pdsaT;
    pdsaT = NULL;

    HRESULT hr;
    DUALSTRINGARRAY* pdsaFiltered;
    hr = gAddrExclusionMgr.BuildExclusionDSA(gpdsaFullBindings, &pdsaFiltered);
    if (FAILED(hr))
        return RPC_S_OUT_OF_RESOURCES;

    if (dsaCompare(gpdsaMyBindings->DSA(), pdsaFiltered))
    {
        // the old and new local resolver strings are the same
        // so don't change anything, just throw away the new one.
        MIDL_user_free(pdsaFiltered);
        return RPC_S_OK;
    }

    // The two are different.  First, let's see if an old mid entry
    // for the new bindings is still in the table.
    CMid* pNewLocalMid = NULL;
    CMid* pOldMatchingLocalMid = NULL;

    pOldMatchingLocalMid = (CMid*)gpMidTable->Lookup(CMidKey(pdsaFiltered));
    if (pOldMatchingLocalMid)
    {
        // Returned mid should be both local and stale
        ASSERT(pOldMatchingLocalMid->IsLocal());
        ASSERT(pOldMatchingLocalMid->IsStale());
    }
    else
    {
        // Not in the table already, create a new mid

        // The mid object makes a copy of pdsaFiltered, it doesn't own it
        pNewLocalMid = new(pdsaFiltered->wNumEntries * sizeof(WCHAR)) 
                        CMid(pdsaFiltered, TRUE, gLocalMid);
        if (!pNewLocalMid)
        {
            MIDL_user_free(pdsaFiltered);
            return RPC_S_OUT_OF_RESOURCES;          
        }
    }

    // Always need to construct a new gpdsaMyBindings
    CDualStringArray* pdsaWrapper = new CDualStringArray(pdsaFiltered);
    if (pdsaWrapper)
    {
        ASSERT(gpClientLock->HeldExclusive());

        if (pOldMatchingLocalMid)
        {
            // Mark the mid that's already in the table
            // as no longer stale, and reference it so it 
            // stays in the table.
            pOldMatchingLocalMid->Reference();
            pOldMatchingLocalMid->MarkStale(FALSE);
        }
        else
        {
            // Add new local mid to the table; it's "not stale" by default
            ASSERT(pNewLocalMid);
            gpMidTable->Add(pNewLocalMid);
        }
        
        // Mark the current mid as stale
        CMid* pCurrentMid = (CMid*)gpMidTable->Lookup(CMidKey(gpdsaMyBindings->DSA()));
        ASSERT(pCurrentMid);
        pCurrentMid->MarkStale(TRUE);
		
        // The old local mid object would normally be guaranteed to remain in the table 
        // for as long as gpClientLock is held.  It is possible that an activation in-flight
        // concurrent with this thread may try to look up the old local mid shortly 
        // after this code finishes, and if not found the oxid resolution will proceed
        // as if the mid was a remote machine, not local.  This leads to major problems.
        // To get around this somewhat fuzzy window, we addref the old mid (thus keeping
        // it in the table), and ask for a timer callback at a later time when we will 
        // be virtually guaranteed that all such in-flight local activations referencing 
        // the old mid will have completed.   
        DoAsyncMidRelease(pCurrentMid, gdwTimeoutPeriodForStaleMids);

        // DoAsyncMidRelease takes a reference to be released later; still need
        // to release it here.
        pCurrentMid->Release();
	
        // Release old bindings
        gpdsaMyBindings->Release();

        // Remember new ones
        gpdsaMyBindings = pdsaWrapper;
        
        // Increment id counter
        g_dwResolverBindingsID++;

        return RPC_S_OK;
    }
    
    // No mem
    if (pNewLocalMid) delete pNewLocalMid;

    MIDL_user_free(pdsaFiltered);

    return RPC_S_OUT_OF_RESOURCES;
}

RPC_STATUS
CopyMyOrBindings(DUALSTRINGARRAY **ppdsaOrBindings, DWORD64* pdwBindingsID)
/*++

Routine Description:

    Copies the current OR bindings to return to the
    caller.   

Parameters:

    ppdsaOrBindings -- where to put the bindings when done
    pdwBindingsID -- if successful, contains the binding id of the 
                     returned bindings.  Can be NULL if the client
                     does not care.

Return Value:

    RPC_S_OK
    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES

--*/
{
    HRESULT hr;
    RPC_STATUS status = RPC_S_OK;
    CDualStringArray* pdsaBindings;
    DWORD64 dwBindingsID;

    SCMVDATEHEAP();

    // Take lock only long enough to take a reference on
    // the current bindings
    gpClientLock->LockExclusive();
    
    pdsaBindings = gpdsaMyBindings;
    if (pdsaBindings)
        pdsaBindings->AddRef();

    // Save id now while we're under the lock
    dwBindingsID = g_dwResolverBindingsID;

    // We call this here in case we failed to register for 
    // address change notifications.  If it previously succeeded,
    // then this call is a no-op, otherwise it might succeed
    // this time around.
    gAddrRefreshMgr.RegisterForAddressChanges();

    gpClientLock->UnlockExclusive();

    ASSERT(pdsaBindings);
    if (!pdsaBindings)
        return RPC_S_OUT_OF_RESOURCES;

    hr = dsaAllocateAndCopy(ppdsaOrBindings, pdsaBindings->DSA());
    if (SUCCEEDED(hr) && pdwBindingsID)
    {
        *pdwBindingsID = dwBindingsID;
    }

    pdsaBindings->Release();

    SCMVDATEHEAP();

    return ((hr == S_OK) ? RPC_S_OK : RPC_S_OUT_OF_RESOURCES);
}

/*
// Debugging hack: for when you only want to debug the bindings
// update stuff with one process instead of every process 
// on the box.  
DWORD GetUpdateablePID()
{
    HKEY hOle;
    DWORD error;
    DWORD dwValue = -1;
    DWORD dwType;
    DWORD dwBufSize = sizeof(DWORD);

    error = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                         L"SOFTWARE\\Microsoft\\OLE", 
                         NULL, 
                         KEY_READ,
                         &hOle);
    if (error == ERROR_SUCCESS)
    {
        error = RegQueryValueEx(
                        hOle,
                        L"UpdateablePID",
                        0,
                        &dwType,
                        (BYTE*)&dwValue,
                        &dwBufSize);

        RegCloseKey(hOle);
    }
    return dwValue;
}
*/


void 
GetCurrentBindingsAndID(DWORD64* pdwBindingsID, CDualStringArray** ppDSABindings)
/*++

Routine Description:

    Returns to the caller the current bindings and their id.  *ppDSABindings 
    will have a refcount added.

Return Value:
	
    void

--*/

{
    ASSERT(!gpClientLock->HeldExclusive());
    ASSERT(pdwBindingsID && ppDSABindings);

    // Take reference on gpClientLock long enough to grab a 
    // reference on the current bindins
    gpClientLock->LockExclusive();
    
    ASSERT(gpdsaMyBindings);
    *ppDSABindings = gpdsaMyBindings;
    (*ppDSABindings)->AddRef();
    *pdwBindingsID = g_dwResolverBindingsID;
    
    gpClientLock->UnlockExclusive();
    
    return;
}

void 
PushCurrentBindings()
/*++

Routine Description:

    Propagates the current resolver bindings to all currently
    running processes.  

Return Value:
	
    void

--*/
{
    ORSTATUS status;
    DWORD64 dwBindingsID;
    CDualStringArray* pDSABindings = NULL;

    ASSERT(!gpClientLock->HeldExclusive());

    // If not enabled, don't do it
    if (!gbDynamicIPChangesEnabled)
        return;
	
    GetCurrentBindingsAndID(&dwBindingsID, &pDSABindings);
    ASSERT(pDSABindings);

    // Take a shared lock on the process list, and copy all of
    // the contained processes to a separate list, with an
    // extra refcount added.  Then we release the lock, and 
    // push the new bindings to each process.   New processes
    // that connect after we leave the lock will automatically
    // get the newest bindings.
    gpProcessListLock->LockShared();
    
    // Allocate space on the stack to remember each process in
    // the list.
    DWORD i = 0;
    DWORD dwTotalProcesses = gpProcessList->Size();

    // Check for nothing to do.  This can occur early during boot.
    if (dwTotalProcesses == 0)
    {
        gpProcessListLock->UnlockShared();
        pDSABindings->Release();
        return;
    }

    CProcess* pprocess;
    CProcess** ppProcessList = 
        (CProcess**)_alloca(sizeof(CProcess*) * dwTotalProcesses);

    // Copy contents of current list
    CBListIterator all_procs(gpProcessList);  
    while (pprocess = (CProcess*)all_procs.Next())
    {
        ppProcessList[i++] = pprocess;
        pprocess->Reference();
    }

    ASSERT(i == dwTotalProcesses);

    gpProcessListLock->UnlockShared();

    // Now that we're outside the lock, update each process with 
    // the new bindings.  Note that even if another refresh
    // beats us, the process object tracks the binding id's, so 
    // the right thing will happen.
    for (i = 0; i < dwTotalProcesses; i++)
    {
        status = ppProcessList[i]->UpdateResolverBindings(dwBindingsID, pDSABindings->DSA());                                                            
        if (status != OR_OK)
        {
            // For use with the debugging hack above
            //        if (pprocess->GetPID() != GetUpdateablePID())
            //            continue;

            // Right now I'm considering this a best-case effort; it
            // can expectedly fail in some circumstances; eg, a process
            // initializes COM, does work, then uninit's COM and stops
            // listening on the ole32<->rpcss interfaces.   
            KdPrintEx((DPFLTR_DCOMSS_ID,
                    DPFLTR_WARNING_LEVEL,
                    "OR: failed to update dynamic resolver "
                    "bindings for process pid=%d\n",
                    ppProcessList[i]->GetPID()));
        }
    }

    // Release references on process objects
    gpServerLock->LockExclusive();

    for (i = 0; i < dwTotalProcesses; i++)
    {
        ppProcessList[i]->Release();
    }

    gpServerLock->UnlockExclusive();

    pDSABindings->Release();

    return;
}



void
RegisterAuthInfoIfNecessary()
/*++

Routine Description:

    Initializes all COM authentication services.  The list is computed in
    ComputeSecurity.  Ignore failures.  On normal boots the authentication
    services register without error on the first call.  During setup the
    authentication services never register but the machine receives no
    remote secure activation requests.

Return Value:

    none

--*/
{
    DWORD   Status;
    SECPKG *pSvcList;
    DWORD   i;
    DWORD   j = 0;
    DWORD   k;
    DWORD   cClientSvcs;
    SECPKG* aClientSvcs;
    DWORD   cServerSvcs;
    USHORT* aServerSvcs;

    // Doesn't matter if we call RegisterAuthInfo more than once by chance.
    if (gfRegisteredAuthInfo)
        return;

    // Retrieve client\server services
    if (!GetClientServerSvcs(&cClientSvcs, &aClientSvcs, &cServerSvcs, &aServerSvcs))
        return;

    if (cServerSvcs == 0)
    {
        CleanupClientServerSvcs(cClientSvcs, aClientSvcs, cServerSvcs, aServerSvcs);
        return;
    }

    // Allocate an array to hold the list of authentication services that
    // were successfully registered.
    pSvcList = new SECPKG[cServerSvcs];
    if (pSvcList == NULL)
    {
        CleanupClientServerSvcs(cClientSvcs, aClientSvcs, cServerSvcs, aServerSvcs);
        return;
    }

    ZeroMemory(pSvcList, sizeof(SECPKG) * cServerSvcs);

    // Loop over the list of authentication services to register.
    for (i = 0; i < cServerSvcs; i++)
    {
        Status = RpcServerRegisterAuthInfo( NULL, aServerSvcs[i], NULL, NULL );
        if (Status == RPC_S_OK)
        {
            pSvcList[j].wId   = aServerSvcs[i];
            pSvcList[j].pName = NULL;
            for (k= 0; k < cClientSvcs; k++)
            {
                if (aClientSvcs[k].wId == aServerSvcs[i])
                {
                    if (aClientSvcs[k].pName)
                    {
                        DWORD dwLen = lstrlen(aClientSvcs[k].pName) + 1;
                        
                        pSvcList[j].pName = new WCHAR[dwLen];
                        if (!pSvcList[j].pName)
                        {
                            // No mem; cleanup previously-allocated stuff and return
                            for (i = 0; i < cServerSvcs; i++)
                            {
                                if (pSvcList[i].pName)
                                {
                                    delete pSvcList[i].pName;
                                }
                            }
                            delete pSvcList;
                            CleanupClientServerSvcs(cClientSvcs, aClientSvcs, cServerSvcs, aServerSvcs);
                            return;
                        }

                        lstrcpy(pSvcList[j].pName, aClientSvcs[k].pName);
                    }
                    break;
                }
            }
            ASSERT( pSvcList[j].pName != NULL );
            j++;
        }
    }

    CleanupClientServerSvcs(cClientSvcs, aClientSvcs, cServerSvcs, aServerSvcs);
    cClientSvcs = 0;
    aClientSvcs = NULL;
    cServerSvcs = 0;
    aServerSvcs = NULL;

    // If no authentication services were registered.
    if (j == 0)
        return;

    // Save the new service list if no other thread has.
    gpClientLock->LockExclusive();
    if (!gfRegisteredAuthInfo)
    {
        gfRegisteredAuthInfo = TRUE;
        s_cRpcssSvc          = j;
        s_aRpcssSvc          = pSvcList;
        pSvcList             = NULL;
    }
    gpClientLock->UnlockExclusive();

    // Free the service list if not saved in a global.
    if (pSvcList)
    {
        for (i = 0; i < cServerSvcs; i++)
        {
            if (pSvcList[i].pName)
            {
                delete pSvcList[i].pName;
            }
        }
        delete pSvcList;
    }

    return;
}

void *ComputeSvcList( const DUALSTRINGARRAY *pBinding )
/*++

Routine Description:

    Allocates and returns an initialized auth identity structure that
    contains a list of authentication services for snego.

--*/
{
    SEC_WINNT_AUTH_IDENTITY_EXW *pAuthId;
    DWORD                        cbAuthId;
    DWORD                        i;
    WCHAR                       *pEnd;

    // Compute the size of the authentication service name strings.
    cbAuthId = sizeof(*pAuthId);
    for (i = 0; i < s_cRpcssSvc; i++)
        if (s_aRpcssSvc[i].wId != RPC_C_AUTHN_GSS_NEGOTIATE &&
            (pBinding == NULL ||
             ValidAuthnSvc( pBinding, s_aRpcssSvc[i].wId )))
            cbAuthId += (lstrlenW( s_aRpcssSvc[i].pName ) + 1)*
                        sizeof(WCHAR);

    // Allocate the authentication identity structure.    
    pAuthId = (SEC_WINNT_AUTH_IDENTITY_EXW *)PrivMemAlloc(cbAuthId);
    if (pAuthId == NULL)
        return NULL;
	
    // Initialize it.
    pEnd                       = (WCHAR *) (pAuthId+1);
    pAuthId->Version           = SEC_WINNT_AUTH_IDENTITY_VERSION;
    pAuthId->Length            = sizeof(*pAuthId);
    pAuthId->User              = NULL;
    pAuthId->UserLength        = 0;
    pAuthId->Domain            = NULL;
    pAuthId->DomainLength      = 0;
    pAuthId->Password          = NULL;
    pAuthId->PasswordLength    = 0;
    pAuthId->Flags             = SEC_WINNT_AUTH_IDENTITY_UNICODE;
    pAuthId->PackageList       = pEnd;
    pAuthId->PackageListLength = (cbAuthId - sizeof(*pAuthId)) /
                                 sizeof(WCHAR);

    // Copy in the authentication service name strings.
    for (i = 0; i < s_cRpcssSvc; i++)
        if (s_aRpcssSvc[i].wId != RPC_C_AUTHN_GSS_NEGOTIATE &&
            (pBinding == NULL ||
             ValidAuthnSvc( pBinding, s_aRpcssSvc[i].wId )))
        {
            lstrcpyW( pEnd, s_aRpcssSvc[i].pName );
            pEnd      += lstrlenW( pEnd );
            pEnd[0]    = L',';
            pEnd      += 1;
        }
    pEnd   -= 1;
    pEnd[0] = 0;

    return pAuthId;
}

/*++

Routine Description:

   Return TRUE if the specified authentication service is in the
   dual string array.

--*/
BOOL ValidAuthnSvc( const DUALSTRINGARRAY *pBinding, WORD wService )
{
    const WCHAR *pwstrT = &pBinding->aStringArray[pBinding->wSecurityOffset];

    while (*pwstrT)
    {
        if (*pwstrT == wService)
        {
        return TRUE;
        }

        pwstrT = OrStringSearch((PWSTR) pwstrT, 0) + 1;
    }
    return FALSE;
}

//
// Local ID allocation
//


ID
AllocateId(
          IN LONG cRange
          )
/*++

Routine Description:

    Allocates a unique local ID.

    This id is 64bits.  The low 32 bits are a sequence number which
    is incremented with each call.  The high 32bits are seconds
    since 1980.  The ID of 0 is not used.

Limitations:

    No more then 2^32 IDs can be generated in a given second without a duplicate.

    When the time stamp overflows, once every >126 years, the sequence numbers
    are likely to be generated in such a way as to collide with those from 126
    years ago.

    There is no prevision in the code to deal with overflow or duplications.

Arguments:

    cRange -  Number to allocate in sequence, default is 1.

Return Value:

    A 64bit id.

--*/
{
    static LONG sequence = 1;
    FILETIME ft;
    LARGE_INTEGER id;
    DWORD seconds;
    BOOL fSuccess;

    ASSERT(cRange > 0 && cRange < 11);

    GetSystemTimeAsFileTime(&ft);

    fSuccess = RtlTimeToSecondsSince1980((PLARGE_INTEGER)&ft,
                                         &seconds);

    ASSERT(fSuccess); // Only fails when time is <1980 or >2115

    do
    {
        id.HighPart = seconds;
        id.LowPart = InterlockedExchangeAdd(&sequence, cRange);
    }
    while (id.QuadPart == 0 );

    return(id.QuadPart);
}


//
// Debug helper(s)
//

#if DBG

int __cdecl __RPC_FAR ValidateError(
                                   IN ORSTATUS Status,
                                   IN ...)
/*++
Routine Description

    Tests that 'Status' is one of an expected set of error codes.
    Used on debug builds as part of the VALIDATE() macro.

Example:

    VALIDATE( (Status,
               OR_BADSET,
               // more error codes here
               OR_OK,
               0)  // list must be terminated with 0
               );

     This function is called with the OrStatus and expected errors codes
     as parameters.  If OrStatus is not one of the expected error
     codes and it not zero a message will be printed to the debugger
     and the function will return false.  The VALIDATE macro ASSERT's the
     return value.

Arguments:

    Status - Status code in question.

    ... - One or more expected status codes.  Terminated with 0 (OR_OK).

Return Value:

    TRUE - Status code is in the list or the status is 0.

    FALSE - Status code is not in the list.

--*/
{
    RPC_STATUS CurrentStatus;
    va_list Marker;

    if (Status == 0) return(TRUE);

    va_start(Marker, Status);

    while (CurrentStatus = va_arg(Marker, RPC_STATUS))
    {
        if (CurrentStatus == Status)
        {
            return(TRUE);
        }
    }

    va_end(Marker);

    KdPrintEx((DPFLTR_DCOMSS_ID,
               DPFLTR_WARNING_LEVEL,
               "OR Assertion: unexpected failure %lu\n",
               (unsigned long)Status));

    return(FALSE);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\objex\or.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    or.h

Abstract:

    General include file for C things the OR.  This file is pre-compiled.

Author:

    Mario Goertzel    [mariogo]       Feb-10-95

Revision History:

--*/

#ifndef __OR_H
#define __OR_H

#include <dcomss.h>

#include <stddef.h>
#include <malloc.h> // alloca
#include <limits.h>
#include <math.h>

#include <lclor.h> // Local OR if from private\dcomidl
#include <objex.h> // Remote OR if from private\dcomidl
#include <orcb.h>  // Callback if from private\dcomidl
#include <rawodeth.h> // Raw RPC -> ORPC OID rundown interface

#ifdef __cplusplus
extern "C" {
#endif

#define IN
#define OUT
#define CONST const

#define OrStringCompare(str1, str2, len) wcscmp((str1), (str2), (len))
#define OrStringLen(str) wcslen(str)
#define OrStringCat(str1, str2) wcscat((str1), (str2))
#define OrStringCopy(str1, str2) wcscpy((str1), (str2))
#define OrMemorySet(p, value, len) memset((p), (value), (len))
#define OrMemoryCompare(p1, p2, len) memcmp((p1), (p2), (len))
#define OrMemoryCopy(dest, src, len) memcpy((dest), (src), (len))
// OrStringSearch in or.hxx

//
// The OR uses Win32 (RPC) error codes.
//

typedef LONG ORSTATUS;

// When the OR code asigns and error it uses
// one of the following mappings:
// There are no internal error codes.

#define OR_OK               RPC_S_OK
#define OR_NOMEM            RPC_S_OUT_OF_MEMORY
#define OR_NORESOURCE       RPC_S_OUT_OF_RESOURCES
#define OR_NOACCESS         ERROR_ACCESS_DENIED
#define OR_BADOXID          OR_INVALID_OXID
#define OR_BADOID           OR_INVALID_OID
#define OR_BADSET           OR_INVALID_SET
#define OR_NOSERVER         RPC_S_SERVER_UNAVAILABLE
#define OR_BADPARAM         ERROR_INVALID_PARAMETER

// Internal codes used to indicate a special event.
#define OR_I_RETRY          0xC0210051UL
#define OR_I_NOPROTSEQ      0xC0210052UL

#define UNUSED(_x_) ((void *)(_x_))

#if DBG

#define DEBUG_MIN(a,b) (min((a),(b)))

extern int __cdecl ValidateError(
    IN ORSTATUS Status,
    IN ...);


#define VALIDATE(X) if (!ValidateError X) ASSERT(0);

#if DBG_DETAIL
#undef ASSERT
#define ASSERT( exp ) \
    if (! (exp) ) \
        { \
        DbgPrintEx(DPFLTR_DCOMSS_ID, \
                   DPFLTR_ERROR_LEVEL, \
                   "OR: Assertion failed: %s(%d) %s\n", \
                   __FILE__, \
                   __LINE__, \
                   #exp); \
        DebugBreak(); \
        }
#endif // DETAIL

#else  // DBG
#define DEBUG_MIN(a,b) (max((a),(b)))
#define VALIDATE(X)
#endif // DBG

extern DWORD ObjectExporterWorkerThread(LPVOID);
extern DWORD ObjectExporterTaskThread(LPVOID);

#ifdef __cplusplus
}
#endif

#endif // __OR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\objex\orclnt.cxx ===
/*++

Copyright (c) 1995-1996 Microsoft Corporation

Module Name:

    OrClnt.cxx

Abstract:

    Object resolver client side class implementations.  CClientOxid, CClientOid,
    CClientSet classes are implemented here.

Author:

    Mario Goertzel    [MarioGo]

Revision History:

    MarioGo     04-03-95    Combined many smaller .cxx files
    MarioGo     01-05-96    Locally unique IDs

--*/

#include<or.hxx>

extern
error_status_t
ComplexPingInternal(
            IN  handle_t hRpc,
            IN  SETID   *pSetId,
            IN  USHORT   SequenceNum,
            IN  ULONG    cAddToSet,
            IN  ULONG    cDelFromSet,
            IN  OID      AddToSet[],
            IN  OID      DelFromSet[],
            OUT USHORT  *pPingBackoffFactor
            );

class CTestBindingPPing : public CParallelPing
{
public:
    CTestBindingPPing(WCHAR *pBindings) :
        _pBindings(pBindings)
        {}


    BOOL NextCall(PROTSEQINFO *pProtseqInfo)
    {
        if (*_pBindings)
        {
            pProtseqInfo->pvUserInfo = _pBindings;
            pProtseqInfo->hRpc     = TestBindingGetHandle(_pBindings);
            _pBindings =  OrStringSearch(_pBindings, 0) + 1;
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }

    void ReleaseCall(PROTSEQINFO *pProtseqInfo)
    {
        if (pProtseqInfo->hRpc)
        {
            RpcBindingFree(&pProtseqInfo->hRpc);
        }
    }
private:
    WCHAR *    _pBindings;
};

//
// CClientOid methods
//

CClientOid::~CClientOid()
{
    ASSERT(gpClientLock->HeldExclusive());
    ASSERT(!In());
    ASSERT(Out());
    ASSERT(_pOxid);
    ASSERT(_pSet);

    _pOxid->Release();
    _pSet->Release();

    gpClientOidTable->Remove(this);
}

//
// CClientOxid methods.
//

ORSTATUS
CClientOxid::GetInfo(
                    IN  BOOL fApartment,
                    OUT OXID_INFO *pInfo
                    )
/*++

Routine Description:

    Returns the OXID_INFO structure for this oxid.

    The gpClientLock is held and there should also be
    a reference held by the calling routine upon entry to
    this method.

Arguments:

    fApartment - TRUE iif the client is apartment model.

    pInfo - Will contain the standard info, a single _expanded_
        string binding and complete security bindings.
        MIDL_user_allocated.

Return Value:

    OR_NOMEM - Unable to allocate a parameter.

    OR_OK - Normally.

--*/
{
    USHORT   protseq;
    PWSTR    pwstrT;
    ORSTATUS status = OR_OK;
    DUALSTRINGARRAY *psa;

    ASSERT(dsaValid(_oxidInfo.psa));


    if (0 == _wProtseq)
    {
        // Local server

        protseq = ID_LPC;

        pwstrT = FindMatchingProtseq(protseq, _oxidInfo.psa->aStringArray);

        ASSERT(pwstrT != 0);

        if (0 != pwstrT)
        {
            psa =
            GetStringBinding(pwstrT,
                             _oxidInfo.psa->aStringArray + _oxidInfo.psa->wSecurityOffset);

            if (0 == psa)
            {
                status = OR_NOMEM;
            }
        }
        else
        {
            status = OR_BADOXID;
        }
    }
    else
    {
        // Remote server, find a string binding to use.

        psa = 0;
        PWSTR pwstrBinding = 0;

        // First, check if there is a known good binding to use.

        if (_iStringBinding != 0xFFFF)
        {
            pwstrBinding = &_oxidInfo.psa->aStringArray[_iStringBinding];
        }
        else
        {
            pwstrT = NULL;
            if (_pMachineName)
            {
                pwstrT = FindMatchingProtseq(_pMachineName,
                                             _wProtseq,
                                             _oxidInfo.psa->aStringArray);
            }

            if (pwstrT)
            {
                pwstrBinding = pwstrT;
                _iStringBinding = (USHORT)(pwstrT - _oxidInfo.psa->aStringArray);
            }
            else
            {
                // no stringbinding for the Protseq and machine name we succeeded on
                // previously.  Ping all these guys in parallel and see if any work
                CTestBindingPPing ping(_oxidInfo.psa->aStringArray);

                gpClientLock->UnlockExclusive();
                RPC_STATUS status = ping.Ping();
                gpClientLock->LockExclusive();

                if (status == RPC_S_OK)
                {
                    pwstrBinding = (WCHAR*) ping.GetWinner()->pvUserInfo;
                    _iStringBinding = (USHORT)(pwstrBinding - _oxidInfo.psa->aStringArray);
                }

                ping.Reset();
            }

        }

        if (0 != pwstrBinding)
        {
            // Found a binding
            ASSERT(pwstrBinding == &_oxidInfo.psa->aStringArray[_iStringBinding]);
            psa = GetStringBinding(pwstrBinding,
                                   _oxidInfo.psa->aStringArray + _oxidInfo.psa->wSecurityOffset);
            if (0 == psa)
            {
                status = OR_NOMEM;
            }
        }
        else
        {
            KdPrintEx((DPFLTR_DCOMSS_ID,
                       DPFLTR_WARNING_LEVEL,
                       "OR: Unable to find a binding for oxid %p (to %S)\n",
                       this,
                       _oxidInfo.psa->aStringArray + 1));

            if (status == OR_OK)
                status = OR_BADOXID;
        }
    }

    if (status == OR_OK)
    {
        // copy all the data into the OXID_INFO
        memcpy(pInfo, &_oxidInfo, sizeof(_oxidInfo));
        pInfo->psa = psa;
    }

    return(status);
}

ORSTATUS
CClientOxid::UpdateInfo(OXID_INFO *pInfo)
{
    DUALSTRINGARRAY *pdsaT;

    ASSERT(pInfo);
    ASSERT(gpClientLock->HeldExclusive());

    if (pInfo->psa)
    {
        ASSERT(dsaValid(pInfo->psa));

        pdsaT = new(sizeof(USHORT) * pInfo->psa->wNumEntries) DUALSTRINGARRAY;

        if (!pdsaT)
        {
            return(OR_NOMEM);
        }

        dsaCopy(pdsaT, pInfo->psa);

        delete _oxidInfo.psa;
    }
    else
    {
        pdsaT = _oxidInfo.psa;
    }

    // copy in the new data
    memcpy(&_oxidInfo, pInfo, sizeof(_oxidInfo));
    _oxidInfo.psa = pdsaT;

    ASSERT(dsaValid(_oxidInfo.psa));
    return(OR_OK);
}

void
CClientOxid::Reference()
/*++

Routine Description:

    As as CReferencedObject::Reference except that it knows to
    pull the oxid out of the plist when the refcount was 0.

Arguments:

    None

Return Value:

    None

--*/
{
    BOOL fRemove = (this->References() == 0);

    // We may remove something from a PList more then once;
    // it won't hurt anything.  This avoids trying to remove
    // more often then necessary.

    this->CReferencedObject::Reference();

    if (fRemove)
    {
        CPListElement * t = Remove();
        ASSERT(t == &this->_plist || t == 0);
    }
}

DWORD
CClientOxid::Release()
/*++

Routine Description:

    Overrides CReferencedObject::Release since OXIDs must wait for
    a timeout period before being deleted.

Arguments:

    None

Return Value:

    0 - object fully released.

    non-zero - object nt fully released by you.

--*/

{
    ASSERT(gpClientLock->HeldExclusive());

    LONG c = CReferencedObject::Dereference();

    if (c ==  0)
    {
        Insert();
    }

    ASSERT(c >= 0);

    return(c);
}


//
// CClientSet methods
//

ORSTATUS
CClientSet::RegisterObject(CClientOid *pOid)
/*++

Routine Description:

    Adds a new oid to the set of oids owned by this set.

Arguments:

    pOid - A pointer to the OID to add to the set.  The caller gives
        his reference to this set.

Return Value:

    None

--*/

{
    ORSTATUS status;

    ASSERT(gpClientLock->HeldExclusive());

    ASSERT(_blistOids.Member(pOid) == FALSE);

    status = _blistOids.Insert(pOid);

    if (status == OR_OK)
    {
        ObjectUpdate(pOid);
        _cFailedPings = 0;
    }

    VALIDATE((status, OR_NOMEM, 0));

    return(status);
}

ORSTATUS
CClientSet::PingServer()
/*++

Routine Description:

    Performs a nice simple ping of the remote set.

Note:

    Exactly and only one thread may call this method on
    a given instance of a CClientSet at a time.

    No lock held when called.

    Overview of state transitions on a CClientOid during
    a complex ping:

    In()  Out()   Actions before ping; after ping
    FALSE FALSE   A ; C A U
    FALSE TRUE    R ; R U
    TRUE  FALSE   N ; N
    TRUE  TRUE    R ; C R U

    Before:
    A - Added to list of IDs to be added.
    N - Ignored
    R - Added to list of IDs to be removed.

    // States may change during the call.

    After:
    C - Check if ping call was successful.  If not, skip next action.
    R - If the Out() state is still TRUE, remove it.
    N - ignored
    A - Set In() state to TRUE
    U - If Out() state changed during the call, set _fChange.

    If three pings fail in a row, all Out()==TRUE OIDs are
    actually Released() and no new pings are made until ObjectUpdate()
    is called again.

Arguments:

    None

Return Value:

    OR_OK - Pinged okay

    OR_NOMEM - Resource allocation failed

    OR_I_PARTIAL_UPDATE - Pinged okay, but more pings
        are needed to fully update the remote set.

    Other - Error from RPC.

--*/
{
    ORSTATUS status;
    ULONG cAdds = 0;
    ULONG cDels = 0;
    ULONG i;
    WCHAR* pPrincipal = NULL;
    WCHAR* pMachineNameFromBindings = NULL;

#ifndef _CHICAGO_
    CToken *pToken;

    if (_fSecure)
    {
        pToken = (CToken *)Id2();
        ASSERT(pToken != 0);
        pToken->Impersonate();
    }
#endif

    if (_fChange)
    {
        USHORT wBackoffFactor;
        OID *aAdds = 0;
        OID *aDels = 0;
        CClientOid **apoidAdds;
        CClientOid **apoidDels = 0;
        CClientOid *pOid;

        gpClientLock->LockShared();

        // Since we own a shared lock, nobody can modify the contents
        // of the set or change the references on an OID in the set
        // while we do this calculation.

        ASSERT(_fChange);
        _fChange = FALSE;

        DWORD debugSize = _blistOids.Size();
        ASSERT(debugSize);

        CBListIterator oids(&_blistOids);

        while (pOid = (CClientOid *)oids.Next())
        {
            if (pOid->Out() == FALSE)
            {
                if (pOid->In() == FALSE)
                {
                    // Referenced and not in set, add it.
                    cAdds++;
                }
            }
            else
            {
                // Not referenced, remove it.
                cDels++;
            }
        }

        ASSERT(debugSize == _blistOids.Size());
        oids.Reset(&_blistOids);

        DWORD cbAlloc = (sizeof(OID) * (cAdds + cDels)) +
                        (sizeof(CClientOid*) * (cAdds + cDels));
        PVOID pvMem;
		
        // Alloc no more than 16k on the stack.
        if (cbAlloc < 0x4000)
        {
            pvMem = NULL;
            aAdds = (OID *) alloca(cbAlloc);
        }
        else
        {
            pvMem = PrivMemAlloc(cbAlloc);
            aAdds = (OID *) pvMem;
        }

        if (!aAdds)
        {
            gpClientLock->UnlockShared();
            if (_fSecure)
            {
                pToken = (CToken *)Id2();
                ASSERT(pToken != 0);
                pToken->Revert();
            }
            return OR_NOMEM;
        }


        apoidAdds = (CClientOid **) ( aAdds + cAdds);
        aDels = (OID *)( apoidAdds + cAdds);
        apoidDels = (CClientOid **)(aDels + cDels);

        DWORD debugAdds = cAdds;
        DWORD debugDels = cDels;

        cAdds = cDels = 0;

        while (pOid = (CClientOid *)oids.Next())
        {
            if (pOid->Out() == FALSE)
            {
                if (pOid->In() == FALSE)
                {
                    // Referenced and not yet added
                    aAdds[cAdds] = pOid->Id();
                    apoidAdds[cAdds] = pOid;
                    cAdds++;
                }
            }
            else
            {
                aDels[cDels] = pOid->Id();
                apoidDels[cDels] = pOid;
                cDels++;
            }
        }

        ASSERT(debugSize == _blistOids.Size());
        ASSERT(debugAdds == cAdds);
        ASSERT(debugDels == cDels);

        gpClientLock->UnlockShared();

        KdPrintEx((DPFLTR_DCOMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "OR: Pinging set %p on %S, (%d, %d)\n",
                   this,
                   _pMid->PrintableName(),
                   cAdds,
                   cDels));

        // Allocate a connection if needed
        if (   FALSE == _pMid->IsLocal()
               && 0 == _hServer )
        {
            _hServer = _pMid->GetBinding();


            if (!_hServer)
            {
                _iBinding = 0;
                status = OR_NOMEM;
            }
            else
            {
                if (_pMid->IsSecure())
                {
                    // set security on the binding handle.
                    _fSecure = TRUE;
 
                    RPC_SECURITY_QOS  qos;
                    
                    pMachineNameFromBindings = ExtractMachineName( _pMid->GetStringBinding() );
                    if (pMachineNameFromBindings)
                    {
                         pPrincipal = new WCHAR[lstrlenW(pMachineNameFromBindings) +
                                             (sizeof(RPCSS_SPN_PREFIX) / sizeof(WCHAR)) + 1];
                          if (pPrincipal)
                          {
                              lstrcpyW(pPrincipal, RPCSS_SPN_PREFIX);
                              lstrcatW(pPrincipal, pMachineNameFromBindings);
                          }
                          delete pMachineNameFromBindings;
                    }  
					
                    USHORT wAuthnSvc  = _pMid->GetAuthnSvc();
                    
                    if (wAuthnSvc == RPC_C_AUTHN_GSS_NEGOTIATE)
                        _pAuthIdentity = (COAUTHIDENTITY*) ComputeSvcList( _pMid->GetStrings() );
                    
                    if ( (wAuthnSvc == RPC_C_AUTHN_GSS_NEGOTIATE) && !_pAuthIdentity)
                    {
                        _fSecure = FALSE;
                        status = OR_NOMEM;
                    }
                    else
                    {
                        qos.Version           = RPC_C_SECURITY_QOS_VERSION;
                        qos.Capabilities      = RPC_C_QOS_CAPABILITIES_DEFAULT;
                        qos.IdentityTracking  = RPC_C_QOS_IDENTITY_DYNAMIC;
                        qos.ImpersonationType = RPC_C_IMP_LEVEL_IDENTIFY;
                        // AuthnSvc is unsigned long and 0xFFFF will get 0 extended
                        status = RpcBindingSetAuthInfoEx(_hServer,
                                                         pPrincipal,
                                                         RPC_C_AUTHN_LEVEL_CONNECT,
                                                         wAuthnSvc != 0xFFFF ? wAuthnSvc
                                                                             : RPC_C_AUTHN_DEFAULT,
                                                         _pAuthIdentity,
                                                         0,
                                                         &qos);
                        if (status != RPC_S_OK)
                            _fSecure = FALSE;
                    }
                    delete pPrincipal;
                }
                else
                {
                    _fSecure = FALSE;
                    status = OR_OK;
                }
            }
        }
        else
        {
            status = OR_OK;
        }

        if (OR_OK == status)
        {           
            if (_pMid->IsLocal())
            {
                // For local pings, do it all in one call.
                for (;;)
                {
                    _sequence++;
                    status = ComplexPingInternal(
                                   _hServer,
                                   &_setid,
                                   _sequence,
                                   cAdds,
                                   cDels,
                                   aAdds,
                                   aDels,
                                   &wBackoffFactor
                                   );
                    if (status == OR_BADSET)
                    {
                        // Restart loop, allocating new set 
                        ASSERT(_setid);
                        _sequence = 0;
                        _setid = 0;
                        continue;
                    }
                    else if (status == OR_BADOID)
                    {
                        // This is really okay, all Dels must be deleted,
                        // and if the add failed now, it will always fail.
                        KdPrintEx((DPFLTR_DCOMSS_ID,
                                   DPFLTR_WARNING_LEVEL,
                                   "OR: Client specified unknown OID(s). %p %p %p\n",
                                   this,
                                   aAdds,
                                   apoidAdds));

                        status = OR_OK;
                    }
                    break;
                }
            }
            else
            {
                //
                // _ComplexPing is typed as taking USHORT's for the count of Adds and
                // Dels -- astoundingly there are people in the world who seem to be
                // using more object references than a USHORT can hold.  Rather than 
                // changing the protocol, we separate the adds\dels into USHRT_MAX 
                // size chunks.
                //
                // However, this is not necessary for local pings, which is why that case
                // is handled separately above.
                //
                const ULONG MAX_PING_CHUNK_SIZE = USHRT_MAX;

                ULONG cAddsTotal = 0;
                ULONG cDelsTotal = 0;                
                ULONG cCallsNeeded;
				
                cCallsNeeded = max((ULONG)ceil((double)cAdds / (double)MAX_PING_CHUNK_SIZE), 
                                   (ULONG)ceil((double)cDels / (double)MAX_PING_CHUNK_SIZE));
				
                // Loop the necessary # of times.  Certain conditions can cause us
                // re-start the loop, eg security errors, or bad set errors.
                for (i = 0; i < cCallsNeeded; i++)
                {   
                    // Figure out how many adds\dels we are doing on this
                    // iteration.  Remember that the # of adds\dels are
                    // independent of each other.
                    USHORT cAddsPerCall;
                    USHORT cDelsPerCall;
                    OID*   pAddsPerCall;
                    OID*   pDelsPerCall;

                    if (cAddsTotal < cAdds)
                    {
                        // More adds to do.  
                        cAddsPerCall = (USHORT)(min(cAdds - (i * MAX_PING_CHUNK_SIZE), 
                                           MAX_PING_CHUNK_SIZE));
                    }
                    else                        
                        cAddsPerCall = 0;  // done with adds

                    if (cDelsTotal < cDels)
                    {
                        // More dels to do.  
                        cDelsPerCall = (USHORT)(min(cDels - (i * MAX_PING_CHUNK_SIZE), 
                                           MAX_PING_CHUNK_SIZE));
                    }
                    else                        
                        cDelsPerCall = 0;  // done with dels

                    // Setup pointers
                    pAddsPerCall = (cAddsPerCall > 0) ? 
                                   aAdds + (i * MAX_PING_CHUNK_SIZE) : NULL;
                    pDelsPerCall = (cDelsPerCall > 0) ? 
                                   aDels + (i * MAX_PING_CHUNK_SIZE) : NULL;
                    
                    ASSERT(_hServer);
                    ASSERT((cAddsPerCall > 0) || (cDelsPerCall > 0));
                    ASSERT(pAddsPerCall || pDelsPerCall);

                    // Update totals
                    cAddsTotal += cAddsPerCall;
                    cDelsTotal += cDelsPerCall;
					
                    _sequence++;
                    status = ComplexPing(
                                   _hServer,
                                   &_setid,
                                   _sequence,
                                   cAddsPerCall,
                                   cDelsPerCall,
                                   pAddsPerCall,
                                   pDelsPerCall,
                                   &wBackoffFactor
                                   );
                    if (status == OR_OK)
                    {
                        // Keep going -- might have more chunks to process
                    }
                    else if (status == OR_BADOID)
                    {
                        // This is really okay, all Dels must be deleted,
                        // and if the add failed now, it will always fail.
                        KdPrintEx((DPFLTR_DCOMSS_ID,
                                   DPFLTR_WARNING_LEVEL,
                                   "OR: Client specified unknown OID(s). %p %p %p\n",
                                   this,
                                   aAdds,
                                   apoidAdds));

                        status = OR_OK;
                    }
                    else if (status == OR_NOMEM
                        || status == RPC_S_OUT_OF_RESOURCES
                        || status == RPC_S_SERVER_TOO_BUSY)
                    {
                        // On these errors we quit immediately.  No retry attempts
                        // even if there are further chunks to process.
                        break;
                    }
                    else if (status == RPC_S_ACCESS_DENIED ||
                             status == RPC_S_SEC_PKG_ERROR)
                    {
                        _fSecure = FALSE;
                        status   = RpcBindingSetAuthInfo(_hServer,
                                                       0,
                                                       RPC_C_AUTHN_LEVEL_NONE,
                                                       RPC_C_AUTHN_NONE,
                                                       0,
                                                       0);
                        if (status == RPC_S_OK)
                        {
                            // Restart loop using unsecure calls
                            i = -1;    // restart loop from beginning
                            cAddsTotal = 0;
                            cDelsTotal = 0;                         
                        }
                    }
                    else if (status == OR_BADSET)
                    {
                        // Set invalid; reallocate (don't free the binding).
                        ASSERT(_setid);
                        KdPrintEx((DPFLTR_DCOMSS_ID,
                                   DPFLTR_WARNING_LEVEL,
                                   "OR: Set %p invalid; recreating..\n",
                                   this));

                        _setid = 0;
                        _sequence = 0;
                        cAddsTotal = 0;
                        cDelsTotal = 0;                         
                        i = -1;  // reset loop
                    }
                    else
                    {
                        // Assume communication failure, free binding, and exit the
                        // loop (we'll re-allocate a new binding on the next ping)
                        RPC_STATUS mystatus = RpcBindingFree(&_hServer);
                        ASSERT(mystatus == RPC_S_OK && _hServer == 0);
                        _sequence--;
                        break;
                    }
                }
            }
        }

        pToken->Revert();

        gpClientLock->LockExclusive();

        this->Reference();         // Keep set alive until we finish

        if (status == OR_OK)
        {
            // Success, process the adds
            for (i = 0; i < cAdds; i++)
            {
                pOid = apoidAdds[i];

                pOid->Added();

                if (FALSE != pOid->Out())
                {
                    // NOT referenced now, make sure it gets deleted next period.
                    ObjectUpdate(pOid);
                }
            }

            // Process deletes.
            for (i = 0; i < cDels; i++)
            {
                pOid = apoidDels[i];

                pOid->Deleted();

                if (FALSE != pOid->Out())
                {
                    // Well what do you yah know, we can _finally_ delete an oid.

                    CClientOid *pT = (CClientOid *)_blistOids.Remove(pOid);
                    ASSERT(pT == pOid);

                    DWORD t = pOid->Release();
                    ASSERT(t == 0);
                }
                else
                {
                    // We deleted from the set but now somebody is referencing it.
                    // Make sure we re-add it next time.
                    ObjectUpdate(pOid);
                }
            }

            _cFailedPings = 0;
        }
        else
        {
            _fChange = TRUE;
        }

        DWORD c = this->Release();
        if (c)
        {
            ASSERT(_blistOids.Size());
            this->Insert();
        }
        else
        {
            ASSERT(cAdds == 0 && cDels != 0);
        }
        // Set (this) pointer maybe invalid

        gpClientLock->UnlockExclusive();
        if (pvMem)
            PrivMemFree(pvMem);
    }
    else
    {
        KdPrintEx((DPFLTR_DCOMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "OR: Pinging set %p on %S.\n",
                   this,
                   _pMid->PrintableName()));

        ASSERT(_setid != 0);

        if (_pMid->IsLocal())
        {
            ASSERT(_cFailedPings == 0);
            ASSERT(_hServer == 0);
            status = _SimplePing(0, &_setid);
            ASSERT(status == OR_OK);
        }
        else
        {
            ASSERT(_hServer);
            if (_cFailedPings <= 3)
            {
                status = SimplePing(_hServer, &_setid);
                if (status != OR_OK)
                {
                    _cFailedPings++;
                    if (_cFailedPings > 3)
                    {
                        KdPrintEx((DPFLTR_DCOMSS_ID,
                                   DPFLTR_WARNING_LEVEL,
                                   "OR: Server %S (set %p) has failed 3 pings...\n",
                                   _pMid->PrintableName(),
                                   this));
                    }
                }
                else
                {
                    _cFailedPings = 0;
                }
            }
            else
            {
                status = OR_OK;
            }
        }
        this->Insert();
        pToken->Revert();
    }

    // Set (this) maybe invalid.
#if DBG
    if (status != OR_OK)
    {
        KdPrintEx((DPFLTR_DCOMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "OR: ping %p failed %d\n",
                   this,
                   status));
    }
#endif

    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\objex\objex.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    ObjEx.cxx

Abstract:

    Main entry point for the object exporter service.

Author:

    Mario Goertzel    [MarioGo]

Revision History:

    MarioGo     02-28-95    Bits 'n pieces
    ronans      04-14-97    HTTP support

--*/


#include <or.hxx>
#include <mach.hxx>
#include <misc.hxx>
extern "C"
{
#define SECURITY_WIN32 // Used by sspi.h
#include <sspi.h>      // EnumerateSecurityPackages
}

//
// Process globals - read-only except during init.
//

// MID of the string bindings for this machine.
MID    gLocalMid = 0;

// Contains the buffer of protseq's to listen on from the registry
PWSTR gpwstrProtseqs = 0;

// Number of remote protseqs used by this process.
USHORT cMyProtseqs = 0;

// ProtseqIds of the remote protseqs used by this process.
USHORT *aMyProtseqs = 0;

BOOL g_fClientHttp = FALSE;
//
// Process globals - read-write
//

CSharedLock *gpServerLock = 0;
CSharedLock *gpClientLock = 0;
CSharedLock *gpProcessListLock = 0;
CSharedLock *gpIPCheckLock = 0;

CHashTable  *gpServerOxidTable = 0;

CHashTable  *gpClientOxidTable = 0;
CPList      *gpClientOxidPList = 0;

CHashTable      *gpServerOidTable = 0;
CServerOidPList *gpServerOidPList = 0;
CList           *gpServerPinnedOidList = 0;

CHashTable  *gpClientOidTable = 0;

CServerSetTable  *gpServerSetTable = 0;

CHashTable  *gpClientSetTable = 0;
CPList      *gpClientSetPList = 0;

CHashTable *gpMidTable = 0;

CList *gpTokenList = 0;

DWORD gNextThreadID = 1;

//+-------------------------------------------------------------------------
//
//  Function:   ComputeSecurity
//
//  Synopsis:   Looks up some registry keys and enumerates the security
//              packages on this machine.
//
//--------------------------------------------------------------------------
// These variables hold values read out of the registry and cached.
// s_fEnableDCOM is false if DCOM is disabled.  The others contain
// authentication information for legacy applications.
BOOL       s_fCatchServerExceptions;
BOOL       s_fBreakOnSilencedServerExceptions;
BOOL       s_fEnableDCOM;
DWORD      s_lAuthnLevel;
DWORD      s_lImpLevel;
BOOL       s_fMutualAuth;
BOOL       s_fSecureRefs;
WCHAR     *s_pLegacySecurity;
DWORD      s_dwLegacySecurityLen; // cached length of s_pLegacySecurity

// ronans - s_fEnableDCOMHTTP is false if DCOMHTTP is disabled.
BOOL       s_fEnableDCOMHTTP;

// s_sServerSvc is a list of security providers that OLE servers can use.
// s_aClientSvc is a list of security providers that OLE clients can use.
// The difference is that Chicago only supports the client side of some
// security providers and OLE servers must know how to determine the
// principal name for the provider.  Clients get the principal name from
// the server.
DWORD      s_cServerSvc      = 0;
USHORT    *s_aServerSvc      = NULL;
DWORD      s_cClientSvc      = 0;
SECPKG    *s_aClientSvc      = NULL;

// The registry key for OLE's registry data.
HKEY       s_hOle            = NULL;

//+-------------------------------------------------------------------------
//
//  Function:   FindSvc
//
//  Synopsis:   Returns index of the specified authentication service or -1.
//
//--------------------------------------------------------------------------
DWORD FindSvc( USHORT AuthnSvc, USHORT *aAuthnSvc, DWORD cAuthnSvc )
{
    DWORD i;

    // Look for the id in the array.
    for (i = 0; i < cAuthnSvc; i++)
        if (aAuthnSvc[i] == AuthnSvc)
            return i;
    return -1;
}

//+-------------------------------------------------------------------------
//
//  Function:   FindSvc
//
//  Synopsis:   Returns index of the specified authentication service or -1.
//
//--------------------------------------------------------------------------
DWORD FindSvc( USHORT AuthnSvc, SECPKG *aAuthnSvc, DWORD cAuthnSvc )
{
    DWORD i;

    // Look for the id in the array.
    for (i = 0; i < cAuthnSvc; i++)
        if (aAuthnSvc[i].wId == AuthnSvc)
            return i;
    return -1;
}

//+-------------------------------------------------------------------------
//
//  Function:   ComputeSecurity
//
//  Synopsis:   Looks up some registry keys and enumerates the security
//              packages on this machine.
//
//--------------------------------------------------------------------------
void ComputeSecurity()
{
    SecPkgInfo *pAllPkg;
    SecPkgInfo *pNext;
    HRESULT     hr;
    DWORD       i;
    DWORD       j;
    DWORD       lMaxLen;
    HKEY        hKey;
    DWORD       lType;
    DWORD       lData;
    DWORD       lDataSize;
    WCHAR       cBuffer[80];
    WCHAR      *pSecProt = cBuffer;
    DWORD       cServerSvc;
    USHORT     *aServerSvc = NULL;
    DWORD       cClientSvc;
    SECPKG     *aClientSvc = NULL;
    BOOL        fFiltered = FALSE;

    // Get the list of security packages.
    cClientSvc = 0;
    cServerSvc = 0;
    hr = EnumerateSecurityPackages( &lMaxLen, &pAllPkg );
    if (hr == SEC_E_OK)
    {
        // Allocate memory for both service lists.
        aServerSvc = (USHORT*)MIDL_user_allocate(sizeof(USHORT) * lMaxLen);
        aClientSvc = (SECPKG*)MIDL_user_allocate(sizeof(SECPKG) * lMaxLen);
        if (aServerSvc == NULL || aClientSvc == NULL)
        {
            hr = E_OUTOFMEMORY;
            MIDL_user_free(aServerSvc);
            MIDL_user_free(aClientSvc);
            aServerSvc = NULL;
            aClientSvc = NULL;

            // if out-of-mem, don't keep going.
            FreeContextBuffer(pAllPkg);
            return;     
        }
        else
        {
            ZeroMemory(aServerSvc, sizeof(USHORT) * lMaxLen);
            ZeroMemory(aClientSvc, sizeof(SECPKG) * lMaxLen);

            // Check all packages.
            pNext = pAllPkg;
            for (i = 0; i < lMaxLen; i++)
            {
                // Authentication services with RPC id SECPKG_ID_NONE (0xffff)
                // won't work with RPC.
                if (pNext->wRPCID != SECPKG_ID_NONE)
                {
                    // Determine if clients can use the package but don't
                    // save duplicates.
                    if ((pNext->fCapabilities & SECPKG_FLAG_CONNECTION) &&
                        FindSvc(pNext->wRPCID, aClientSvc, cClientSvc) == -1)
                    {
                        // Copy rpcid
                        aClientSvc[cClientSvc].wId = pNext->wRPCID;

                        // Copy secpkg name if there is one
                        if (pNext->Name)
                        {
                            DWORD dwBufSize = (lstrlen(pNext->Name) + 1) * sizeof(WCHAR);

                            aClientSvc[cClientSvc].pName = (WCHAR*)MIDL_user_allocate(dwBufSize);
                            if (!aClientSvc[cClientSvc].pName)
                            {
                                // No mem.  Clean up what we have, and return
                                FreeContextBuffer(pAllPkg);
                                CleanupClientServerSvcs(cClientSvc, 
                                                        aClientSvc,
                                                        cServerSvc,
                                                        aServerSvc);
                                return;
                            }
                            lstrcpy(aClientSvc[cClientSvc].pName, pNext->Name);
                        }
                        cClientSvc++;
                    }

                    // Determine if servers can use the package but don't save dups.
                    if ( (pNext->fCapabilities & SECPKG_FLAG_CONNECTION) &&
                          ~(pNext->fCapabilities & (SECPKG_FLAG_CLIENT_ONLY)) &&
                          FindSvc(pNext->wRPCID, aServerSvc, cServerSvc) == -1)
                    {
                        aServerSvc[cServerSvc++] = pNext->wRPCID;
                    }
                }
                pNext++;
            }
        }
        FreeContextBuffer(pAllPkg);
        pAllPkg = NULL;
    }

    // Sort and filter the security provider list by the security protocol value.
    hr = RegOpenKeyEx( HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\RPC",
                           NULL, KEY_QUERY_VALUE, &hKey );
    if (hr == ERROR_SUCCESS)
    {
        // Query the value for DCOM Security
        // Note:  this key is undocumented and is meant only for use by the test team.
        lDataSize = sizeof(cBuffer);
        hr = RegQueryValueEx( hKey, L"DCOM Security", NULL, &lType,
                              (unsigned char *) pSecProt, &lDataSize );

        // Retry with more space if necessary
        if (hr == ERROR_MORE_DATA)
        {
            pSecProt = (WCHAR *) _alloca(lDataSize);
            hr = RegQueryValueEx( hKey, L"DCOM Security", NULL, &lType,
                                  (unsigned char *) pSecProt, &lDataSize );
        }
        if (hr == ERROR_SUCCESS && lType == REG_MULTI_SZ && lDataSize > 3)
        {
            fFiltered    = TRUE;

            // Save original list
            DWORD       cServerSvcPreFilter = cServerSvc;
            USHORT     *aServerSvcPreFilter = aServerSvc;
    
            cServerSvc = 0;
            aServerSvc = NULL;

            // Allocate memory for server service list.
            aServerSvc = (USHORT*)MIDL_user_allocate(sizeof(USHORT) * cServerSvcPreFilter);
            if (!aServerSvc)
            {
                // No mem, cleanup and return
                CleanupClientServerSvcs(cClientSvc, 
                                        aClientSvc,
                                        cServerSvcPreFilter,
                                        aServerSvcPreFilter);
                return;
            }

            ZeroMemory(aServerSvc, sizeof(USHORT) * cServerSvcPreFilter);

            // Fill in filtered list
            while (*pSecProt != 0 && (cServerSvc < cServerSvcPreFilter))
            {
                i = _wtoi( pSecProt );
                ASSERT(i <= USHRT_MAX); // this would be a test bug

                if (FindSvc( (USHORT)i, aServerSvcPreFilter, (USHORT)cServerSvcPreFilter ) != -1)
                    aServerSvc[cServerSvc++] = (USHORT)i;
                pSecProt += wcslen(pSecProt)+1;
            }

            // Cleanup old server svc list.   Will save filtered list below on normal path
            MIDL_user_free(aServerSvcPreFilter);
            aServerSvcPreFilter = NULL;
            cServerSvcPreFilter = 0;
        }

        // Close the key.
        RegCloseKey( hKey );
    }

    // Find snego in the client list.
    for (i = 0; i < cClientSvc; i++)
        if (aClientSvc[i].wId == RPC_C_AUTHN_GSS_NEGOTIATE)
            break;

    // If snego exists and is not first, move it first.
    if (i < cClientSvc && i != 0)
    {
        SECPKG sSwap = s_aClientSvc[i];
        memmove( &aClientSvc[1], &aClientSvc[0], sizeof(SECPKG)*i );
        aClientSvc[0] = sSwap;
    }

    // If there is no DCOM security value, move snego first in the server list.
    if (!fFiltered)
    {
        // Find snego in the server list.
        for (i = 0; i < cServerSvc; i++)
            if (aServerSvc[i] == RPC_C_AUTHN_GSS_NEGOTIATE)
                break;

        // If snego exists and is not first, move it first.
        if (i < cServerSvc && i != 0)
        {
            USHORT usSwap = aServerSvc[i];
            memmove( &aServerSvc[1], &aServerSvc[0], sizeof(USHORT)*i );
            aServerSvc[0] = usSwap;
        }
    }

    // Save new client\server svc lists.
    SetClientServerSvcs(cClientSvc, aClientSvc, cServerSvc, aServerSvc);

    // Set all the security flags to their default values.
    s_fEnableDCOM       = FALSE;
    s_fEnableDCOMHTTP   = FALSE;
    s_fCatchServerExceptions = TRUE;
    s_fBreakOnSilencedServerExceptions = FALSE;
    s_lAuthnLevel       = RPC_C_AUTHN_LEVEL_CONNECT;
    s_lImpLevel         = RPC_C_IMP_LEVEL_IDENTIFY;
    s_fMutualAuth       = FALSE;
    s_fSecureRefs       = FALSE;

    // Open the security key.  s_hOle will only be non-NULL on the first pass
    // thru this code, after that we keep it open forever.
    if (s_hOle == NULL)
    {
        HKEY hOle = NULL;
        hr = RegOpenKeyEx( HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\OLE",
                               NULL, KEY_READ, &hOle );
        if (hr != ERROR_SUCCESS)
            return;
        
        LPVOID pv = InterlockedCompareExchangePointer ( (void **) &s_hOle, (void *) hOle, NULL);
        if ( pv != NULL )
        {
            RegCloseKey(hOle);
        }
    }

    ASSERT(s_hOle);

    // Query the value for EnableDCOM.
    lDataSize = sizeof(lData );
    hr = RegQueryValueEx( s_hOle, L"EnableDCOM", NULL, &lType,
                          (unsigned char *) &lData, &lDataSize );
    if (hr == ERROR_SUCCESS && lType == REG_SZ && lDataSize != 0)
    {
        if (*((WCHAR *) &lData) == L'y' ||
            *((WCHAR *) &lData) == L'Y')
            s_fEnableDCOM = TRUE;
    }

    // ronans - Query the value for EnableDCOMHTTP.
    lDataSize = sizeof(lData );
    hr = RegQueryValueEx( s_hOle, L"EnableDCOMHTTP", NULL, &lType,
                          (unsigned char *) &lData, &lDataSize );
    if (hr == ERROR_SUCCESS && lType == REG_SZ && lDataSize != 0)
    {
        if (*((WCHAR *) &lData) == L'y' ||
            *((WCHAR *) &lData) == L'Y')
        {
            s_fEnableDCOMHTTP = TRUE;
            KdPrintEx((DPFLTR_DCOMSS_ID,
                       DPFLTR_WARNING_LEVEL,
                       "OR: EnableDCOMHTTP set to TRUE\n"));
        }
    }

    if (!s_fEnableDCOMHTTP)
    {
        KdPrintEx((DPFLTR_DCOMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "OR: EnableDCOMHTTP set to FALSE\n"));
    }

    // Query the value for IgnoreServerExceptions. This value is just
    // to let some ISVs debug their servers a little easier. In normal
    // operation these exceptions should be caught.
    lDataSize = sizeof(lData );
    hr = RegQueryValueEx( s_hOle, L"IgnoreServerExceptions", NULL, &lType,
                          (unsigned char *) &lData, &lDataSize );
    if (hr == ERROR_SUCCESS && lType == REG_SZ && lDataSize != 0)
    {
        if (*((WCHAR *) &lData) == L'y' ||
            *((WCHAR *) &lData) == L'Y')
            s_fCatchServerExceptions = FALSE;
    }

    // Allow ISVs to enable debugbreaks on all silenced exceptions if there's a debugger present
    lDataSize = sizeof(lData );
    hr = RegQueryValueEx( s_hOle, L"BreakOnSilencedServerExceptions", NULL, &lType,
                          (unsigned char *) &lData, &lDataSize );
    if (hr == ERROR_SUCCESS && lType == REG_SZ && lDataSize != 0)
    {
        if (*((WCHAR *) &lData) == L'y' ||
            *((WCHAR *) &lData) == L'Y')
            s_fBreakOnSilencedServerExceptions = TRUE;
    }

    // Query the value for the legacy services. Note: this key is undocumented 
    // and is meant only for use by the test team.
    lDataSize = 0;
    hr = RegQueryValueEx( s_hOle, L"LegacyAuthenticationService", NULL,
                          &lType, NULL, &lDataSize );
    if (hr == ERROR_SUCCESS && lType == REG_BINARY &&
        lDataSize >= sizeof(SECURITYBINDING))
    {
        WCHAR* pNewLegacySecurity = (WCHAR*)MIDL_user_allocate(sizeof(BYTE) * lDataSize);

        if (pNewLegacySecurity != NULL)
        {
            hr = RegQueryValueEx( s_hOle, L"LegacyAuthenticationService", NULL,
                                  &lType, (unsigned char *) pNewLegacySecurity,
                                  &lDataSize );

            // Verify that the data is a security binding.
            if (hr != ERROR_SUCCESS                 ||
                lType != REG_BINARY                 ||
                lDataSize < sizeof(SECURITYBINDING) ||
                pNewLegacySecurity[1] != 0           ||
                pNewLegacySecurity[(lDataSize >> 1) - 1] != 0)
            {
                MIDL_user_free(pNewLegacySecurity);
                pNewLegacySecurity = NULL;
                lDataSize = 0;
            }

            // Set it whether success or not. A misconfigured registry will cause
            // us to set it back to NULL.
            SetLegacySecurity(pNewLegacySecurity, lDataSize);
        }
    }

    // Query the value for the authentication level.
    lDataSize = sizeof(lData);
    hr = RegQueryValueEx( s_hOle, L"LegacyAuthenticationLevel", NULL,
                          &lType, (unsigned char *) &lData, &lDataSize );
    if (hr == ERROR_SUCCESS && lType == REG_DWORD)
    {
        s_lAuthnLevel = lData;
    }

    // Query the value for the impersonation level.
    lDataSize = sizeof(lData);
    hr = RegQueryValueEx( s_hOle, L"LegacyImpersonationLevel", NULL,
                          &lType, (unsigned char *) &lData, &lDataSize );
    if (hr == ERROR_SUCCESS && lType == REG_DWORD)
    {
        s_lImpLevel = lData;
    }

    // Query the value for mutual authentication.
    lDataSize = sizeof(lData);
    hr = RegQueryValueEx( s_hOle, L"LegacyMutualAuthentication", NULL,
                          &lType, (unsigned char *) &lData, &lDataSize );
    if (hr == ERROR_SUCCESS && lType == REG_SZ && lDataSize != 0)
    {
        if (*((WCHAR *) &lData) == L'y' ||
            *((WCHAR *) &lData) == L'Y')
            s_fMutualAuth = TRUE;
    }

    // Query the value for secure interface references.
    lDataSize = sizeof(lData);
    hr = RegQueryValueEx( s_hOle, L"LegacySecureReferences", NULL,
                          &lType, (unsigned char *) &lData, &lDataSize );
    if (hr == ERROR_SUCCESS && lType == REG_SZ && lDataSize != 0)
    {
        if (*((WCHAR *) &lData) == L'y' ||
            *((WCHAR *) &lData) == L'Y')
            s_fSecureRefs = TRUE;
    }
    ASSERT(gpPingSetQuotaManager);
    
    // Query the value for per-user pingset quota.
    lDataSize = sizeof(lData);
    hr = RegQueryValueEx( s_hOle, L"UserPingSetQuota", NULL,
                          &lType, (unsigned char *) &lData, &lDataSize );
    if (hr == ERROR_SUCCESS && lType == REG_DWORD && lDataSize != 0)
    {
       gpPingSetQuotaManager->SetPerUserPingSetQuota(lData);
    }
}

void
CleanupClientServerSvcs(
        DWORD   cClientSvcs, 
        SECPKG* aClientSvcs,
        DWORD   cServerSvcs,  // unused
        USHORT* aServerSvcs
)
{
    DWORD i;

    for (i = 0; i < cClientSvcs; i++)
    {
        if (aClientSvcs[i].pName)
        {
            MIDL_user_free(aClientSvcs[i].pName);
        }
    }
    MIDL_user_free(aClientSvcs);

    MIDL_user_free(aServerSvcs);

    return;
}

void
SetClientServerSvcs(
        DWORD   cClientSvcs, 
        SECPKG* aClientSvcs,
        DWORD   cServerSvcs,
        USHORT* aServerSvcs
)
/*++

Routine Description:

    Saves the supplied client\server security svcs.

Return Value:

    None
         
--*/
{
    gpClientLock->LockExclusive();
        
    // Cleanup the old ones
    CleanupClientServerSvcs(s_cClientSvc, s_aClientSvc, s_cServerSvc, s_aServerSvc);

    // Save the new ones
    s_cClientSvc = cClientSvcs;
    s_aClientSvc = aClientSvcs;
    s_cServerSvc = cServerSvcs;
    s_aServerSvc = aServerSvcs;

    gpClientLock->UnlockExclusive();

    return;
}

BOOL
GetClientServerSvcs(
        DWORD*   pcClientSvcs, 
        SECPKG** paClientSvcs,
        DWORD*   pcServerSvcs,
        USHORT** paServerSvcs
)
/*++

Routine Description:

    Saves the supplied client\server security svcs.

Return Value:

    TRUE -- success
    FALSE -- no mem
         
--*/
{   
    BOOL fReturn = FALSE;
    SECPKG* aClientSvcs = NULL;
    USHORT* aServerSvcs = NULL;
    
    gpClientLock->LockShared();

    *pcClientSvcs = 0;
    *paClientSvcs = NULL;
    *pcServerSvcs = 0;
    *paServerSvcs = NULL;

    aServerSvcs = (USHORT*)MIDL_user_allocate(sizeof(USHORT) * s_cServerSvc);
    if (aServerSvcs)
    {
        // Copy server svcs
        CopyMemory(aServerSvcs, s_aServerSvc, sizeof(USHORT) * s_cServerSvc);

        aClientSvcs = (SECPKG*)MIDL_user_allocate(sizeof(SECPKG) * s_cClientSvc);
        if (aClientSvcs)
        {
            DWORD i;

            ZeroMemory(aClientSvcs, sizeof(SECPKG) * s_cClientSvc);

            // Copy client svcs
            for (i = 0; i < s_cClientSvc; i++)
            {
                // Copy the id
                aClientSvcs[i].wId = s_aClientSvc[i].wId;
            
                // Copy the name if it has one
                if (s_aClientSvc[i].pName)
                {
                    DWORD dwLen = lstrlen(s_aClientSvc[i].pName) + 1;

                    aClientSvcs[i].pName = (WCHAR*)MIDL_user_allocate(sizeof(WCHAR) * dwLen);
                    if (!aClientSvcs[i].pName)
                    {
                        // Cleanup what we have, then return
                        CleanupClientServerSvcs(s_cClientSvc, 
                                                aClientSvcs,
                                                s_cServerSvc,
                                                aServerSvcs);
                        
                        break;
                    }
                    
                    lstrcpy(aClientSvcs[i].pName, s_aClientSvc[i].pName);
                }
            }

            if (i == s_cClientSvc)
            {
                // Success - caller will now own the memory
                *pcClientSvcs = s_cClientSvc;
                *paClientSvcs = aClientSvcs;
                *pcServerSvcs = s_cServerSvc;
                *paServerSvcs = aServerSvcs;
                fReturn = TRUE;
            }
        }
        else
        {
            MIDL_user_free(aServerSvcs);
        }
    }

    gpClientLock->UnlockShared();

    return fReturn;
}

BOOL
GetLegacySecurity(
        WCHAR** ppszLegacySecurity
)
{
    BOOL fRet = TRUE;
    DWORD dwLen;

    *ppszLegacySecurity = NULL;

    gpClientLock->LockShared();
    
    if (s_dwLegacySecurityLen)
    {
        *ppszLegacySecurity = (WCHAR*)MIDL_user_allocate(sizeof(BYTE) * s_dwLegacySecurityLen);
        if (*ppszLegacySecurity)
        {
            CopyMemory(*ppszLegacySecurity, s_pLegacySecurity, sizeof(BYTE) * s_dwLegacySecurityLen);
            fRet = TRUE;
        }
        else
            fRet = FALSE;
    }

    gpClientLock->UnlockShared();

    return fRet;
};

void
SetLegacySecurity(
		WCHAR* pszLegacySecurity,
		DWORD dwDataSize
)
{
    gpClientLock->LockExclusive();
    
    // Free the old one, save the new one
    MIDL_user_free(s_pLegacySecurity);
    s_pLegacySecurity = pszLegacySecurity;

    // Cache the size of the new data
    s_dwLegacySecurityLen = dwDataSize;

    gpClientLock->UnlockExclusive();

    return;
}

//
// Startup
//

static CONST PWSTR gpwstrProtocolsPath  = L"Software\\Microsoft\\Rpc";
static CONST PWSTR gpwstrProtocolsValue = L"DCOM Protocols";

DWORD StartObjectExporter(
    void
    )
/*++

Routine Description:

    Starts the object resolver service.

Arguments:

    None

Return Value:

    None

Notes:   This function is a bit weak on cleanup code in case of errors.  This
         is because if this function fails for any reason, RPCSS will not 
         start.   Usually this function will never fail since 1) we always
         start at machine boot, when lots of memory is available; and 2) we 
         don't support stopping or restarting of RPCSS.
         

--*/

{
    ORSTATUS status;
    int i;
    DWORD tid;
    HANDLE hThread;
    RPC_BINDING_VECTOR *pbv;

    status = RtlInitializeCriticalSection(&gcsFastProcessLock);
    if (!NT_SUCCESS(status))
        return status;

    status = RtlInitializeCriticalSection(&gcsTokenLock);
    if (!NT_SUCCESS(status))
        return status;


    status = OR_OK;
    // Allocate PingSet quota  manager
    gpPingSetQuotaManager = new CPingSetQuotaManager(status);
    if ((status != OR_OK) || !gpPingSetQuotaManager)
        {
        delete gpPingSetQuotaManager;
        gpPingSetQuotaManager = NULL;
        return OR_NOMEM;
        }
    // Lookup security data.
    ComputeSecurity();
    UpdateState(SERVICE_START_PENDING);

    // Allocate tables
    // Assume 16 exporting processes/threads.
    gpServerOxidTable = new CHashTable(status, DEBUG_MIN(16,4));
    if (status != OR_OK)
        {
        delete gpServerOxidTable;
        gpServerOxidTable = 0;
        }

    // Assume 11 exported OIDs per process/thread.
    gpServerOidTable = new CHashTable(status, 11*(DEBUG_MIN(16,4)));
    if (status != OR_OK)
        {
        delete gpServerOidTable;
        gpServerOidTable = 0;
        }

    gpServerSetTable = new CServerSetTable(status);
    if (status != OR_OK)
        {
        delete gpServerSetTable;
        gpServerSetTable = 0;
        }

    // Assume < 16 imported OXIDs
    gpClientOxidTable = new CHashTable(status, DEBUG_MIN(16,4));
    if (status != OR_OK)
        {
        delete gpClientOxidTable;
        gpClientOxidTable = 0;
        }

    // Assume an average of 4 imported object ids per imported oxid
    gpClientOidTable = new CHashTable(status, 4*DEBUG_MIN(16,4));
    if (status != OR_OK)
        {
        delete gpClientOidTable;
        gpClientOidTable = 0;
        }

    // Assume <16 servers (remote machines) in use per client.
    gpClientSetTable = new CHashTable(status, DEBUG_MIN(16,4));
    if (status != OR_OK)
        {
        delete gpClientSetTable;
        gpClientSetTable = 0;
        }

    gpMidTable = new CHashTable(status, DEBUG_MIN(16,2));
    if (status != OR_OK)
        {
        delete gpMidTable;
        gpMidTable = 0;
        }

    // Allocate lists
    gpClientOxidPList = new CPList(status, BasePingInterval);
    if (status != OR_OK)
    {
        delete gpClientOxidPList;
        gpClientOxidPList = 0;
    }

    gpServerOidPList = new CServerOidPList(status);
    if (status != OR_OK)
    {
        delete gpServerOidPList;
        gpServerOidPList = 0;
    }

    gpClientSetPList = new CPList(status, BasePingInterval);
    if (status != OR_OK)
    {
        delete gpClientSetPList;
        gpClientSetPList = 0;
    }

    gpTokenList = new CList();
    gpProcessList = new CBList(DEBUG_MIN(128,4));
    gpServerPinnedOidList = new CList();

    // Allocate RPC security callback manager
    gpCRpcSecurityCallbackMgr = new CRpcSecurityCallbackManager(status);
    if (status != OR_OK)
        {
        delete gpCRpcSecurityCallbackMgr;
        gpCRpcSecurityCallbackMgr = NULL;
        }

    if (   status != OR_OK
        || !gpServerLock
        || !gpClientLock
        || !gpServerOxidTable
        || !gpClientOxidTable
        || !gpClientOxidPList
        || !gpServerOidTable
        || !gpServerOidPList
        || !gpClientOidTable
        || !gpMidTable
        || !gpServerSetTable
        || !gpClientSetTable
        || !gpClientSetPList
        || !gpTokenList
        || !gpProcessList
        || !gpServerPinnedOidList
        || !gpCRpcSecurityCallbackMgr
        )
        {
        return(OR_NOMEM);
        }

    // Read protseqs from the registry

    DWORD  dwType;
    DWORD  dwLenBuffer = 118;
    HKEY hKey;

    status =
    RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                 gpwstrProtocolsPath,
                 0,
                 KEY_READ,
                 &hKey);

    ASSERT(gpwstrProtseqs == 0);

    if (status == ERROR_SUCCESS)
        {
        do
            {
            delete gpwstrProtseqs;
            gpwstrProtseqs = new WCHAR[(dwLenBuffer + 1 )/2];
            if (gpwstrProtseqs)
                {
                status = RegQueryValueEx(hKey,
                                         gpwstrProtocolsValue,
                                         0,
                                         &dwType,
                                         (PBYTE)gpwstrProtseqs,
                                         &dwLenBuffer
                                         );
                }
            else
                {
                return(OR_NOMEM);
                }

            }
        while (status == ERROR_MORE_DATA);

        RegCloseKey(hKey);
        }

    if (  status != ERROR_SUCCESS
        || dwType != REG_MULTI_SZ )
        {
        KdPrintEx((DPFLTR_DCOMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "OR: No protseqs configured\n"));

        delete gpwstrProtseqs;
        gpwstrProtseqs = 0;
        }

    // Always listen to local protocols
    // If this fails, the service should fail.
    status = UseProtseqIfNecessary(ID_LPC);
    if (status != RPC_S_OK)
        {
        return(status);
        }

    UpdateState(SERVICE_START_PENDING);

    // set g_fClientHttp to false initially
    g_fClientHttp = FALSE;

    // This fails during setup.  If it fails, only remote secure activations
    // will be affected so it is safe to ignore.
    RegisterAuthInfoIfNecessary();

    // Construct remote protseq id and compressed binding arrays.
    status = StartListeningIfNecessary();

    if (status != OR_OK)
        {
        return(status);
        }

    UpdateState(SERVICE_START_PENDING);

    // Register OR server interfaces.
    status =
    RpcServerRegisterIf(_ILocalObjectExporter_ServerIfHandle, 0, 0);

    ASSERT(status == RPC_S_OK);

    status =
    RpcServerRegisterIf(_IObjectExporter_ServerIfHandle, 0, 0);

    ASSERT(status == RPC_S_OK);

    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\objex\orsvr.cxx ===
/*++

Copyright (c) 1995-1996 Microsoft Corporation

Module Name:

    OrSvr.cxx

Abstract:

    Object resolver server side class implementations.  CServerOxid, CServerOid,
    CServerSet and CServerSetTable classes are implemented here.

Author:

    Mario Goertzel    [MarioGo]

Revision History:

    MarioGo     04-03-95    Combined many smaller .cxx files
    MarioGo     01-12-96    Locally unique IDs

--*/

#include<or.hxx>

//
// ScanForOrphanedPinnedOids
//
// This function is called from CServerOxid::ProcessRelease when
// the soxid is deregistered or the server dies.  
//
void 
ScanForOrphanedPinnedOids(CServerOxid* pDeadOxid)
{
    CListElement* pLE;
    CServerOid* pOid;
    CServerOid* pNextOid;

    ASSERT(gpServerLock->HeldExclusive());

    // Walk the list, unpinning oids which were owned by the 
    // dead soxid.
    pLE = gpServerPinnedOidList->First();
    pOid = pLE ? CServerOid::ContainingRecord2(pLE) : NULL;
    while (pOid)
    {
        pLE = pLE->Next();
        pNextOid = pLE ? CServerOid::ContainingRecord2(pLE) : NULL;

        if (pOid->GetOxid() == pDeadOxid)
        {
            // This will remove it from the pinned list
            pOid->SetPinned(FALSE);
        }

        pOid = pNextOid;
    }

    ASSERT(gpServerLock->HeldExclusive());

    return;
}


//
// CServerOid methods
//

void
CServerOid::Reference()
{
    ASSERT(gpServerLock->HeldExclusive());

    BOOL fRemove = (this->References() == 0);

    // We may remove something from a PList more then once; this won't
    // hurt anything.  fRemove is used to avoid trying to remove it more
    // often then necessary without taking lock.

    this->CIdTableElement::Reference();

    if (fRemove)
        {
        CPListElement * t = Remove();
        ASSERT(t == &this->_plist || t == 0);
        }
}

DWORD
CServerOid::Release()
{
    ASSERT(gpServerLock->HeldExclusive());

    DWORD c = this->CReferencedObject::Dereference();

    if (0 == c)
        {
        // If another thread is already running this down it
        // means we got referenced and released during the rundown
        // callback.  That thread will figure out what to do.

        if (IsRunningDown())
            {
            KdPrintEx((DPFLTR_DCOMSS_ID,
                       DPFLTR_WARNING_LEVEL,
                       "OR: Oid running down in release: %p\n",
                       this));
            }
        else if (IsFreed() || this->_pOxid->IsRunning() == FALSE)
            {
            // Server freed this OID already; no need to run it down
            KdPrintEx((DPFLTR_DCOMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "OR: OID %p freed by server so not rundown\n",
                       this));

            SetRundown(TRUE);
            delete this;
            }
        else
            {
            // All serverset (or pinned) references have been released. Put 
            // ourselves into the oid plist so we can be rundown.
            ASSERT(!IsPinned());       
            Insert();
            }
        }

    // this pointer maybe invalid.
    return(c);
}

CServerOid::~CServerOid()
{
    ASSERT(gpServerLock->HeldExclusive());
    ASSERT(_pOxid);
    ASSERT(_fRunningDown);
    ASSERT(!IsPinned());

    _pOxid->Release();

    gpServerOidTable->Remove(this);
}

void
CServerOid::KeepAlive()
// A client has removed this oid from its set.  This keeps
// the oid alive for another timeout period.
{
    ASSERT(gpServerLock->HeldExclusive());

    if (IsRunningDown() == FALSE && References() == 0)
        {
        // It's in the rundown list, move it to the end.
        CPListElement *pT = Remove();
        ASSERT(pT == &this->_plist);
        Insert();
        }
}

void 
CServerOid::SetPinned(BOOL fPinned)
{
    ASSERT(gpServerLock->HeldExclusive());
    
    // Assert that this is a state switch.
    ASSERT(_fPinned ? !fPinned : fPinned);

    // Set new state
    _fPinned = fPinned;

    // When we are pinned, we take an extra reference to avoid further 
    // rundown attempts.  When unpinned, we remove the reference.
    if (_fPinned)
    {        
        this->Reference();

        // Now we should not be in any list
        ASSERT(_list.NotInList()); 
        ASSERT(_plist.NotInList());
        gpServerPinnedOidList->Insert(&_list);
    }
    else
    {
        // We should be in the gpServerPinnedOidList list, but not the plist
        ASSERT(_list.InList());
        ASSERT(_plist.NotInList());
        gpServerPinnedOidList->Remove(&_list);

        // This Release call may put us in the oidplist
        this->Release();
    }

    ASSERT(gpServerLock->HeldExclusive());

    return;
}


//
// CServerOidPList method
//
CServerOid *
CServerOidPList::MaybeRemoveMatchingOxid(
    IN CTime &when,
    IN CServerOid *pOid
    )
{
    CPListElement *ple;
    CServerOid *poid;

    CMutexLock lock(&this->_lock);

    ple = (CPListElement *)CPList::First();

    while(   ple != 0
          && *ple->GetTimeout() < when)
        {

        poid = CServerOid::ContainingRecord(ple);

        if (poid->Match(pOid))
            {
            Remove(ple);
            return(poid);
            }

        ple = ple->Next();
        }
    return(0);
}



//
// CServerOxid methods
//

void
CServerOxid::ProcessRelease()
/*++

Routine Desciption

    The server process owning this OXID has either died
    or deregistered this oxid.  Releases the oxid and
    nulls the pProcess pointer.

Arguments:

    n/a

Return Value:

    n/a

--*/
{
    ASSERT(gpServerLock->HeldExclusive());
    ASSERT(_pProcess);
    _fRunning = FALSE;

    ScanForOrphanedPinnedOids(this);

    Release();
    // This pointer may now be invalid, _pProcess pointer maybe invalid.
}

CServerOxid::~CServerOxid(void)
{
    ASSERT(gpServerLock->HeldExclusive());
    ASSERT(_pProcess);
    ASSERT(!IsRunning()); // implies that the oxid has been removed from the table
    ASSERT(!_fRundownInProgress);
    _pProcess->Release();
}

ORSTATUS
CServerOxid::GetInfo(
    OUT OXID_INFO *poxidInfo,
    IN  BOOL    fLocal
    )
// Server lock held shared.
{
    ORSTATUS status;
    DUALSTRINGARRAY *psa;

    if (!IsRunning())
        {
        // Server crashed, info is not needed.
        return(OR_NOSERVER);
        }

    if (fLocal)
        {
        psa = _pProcess->GetLocalBindings();
        }
    else
        {
        psa = _pProcess->GetRemoteBindings();
        }

    if (!psa)
        {
        return(OR_NOMEM);
        }

    // copy the data
    memcpy(poxidInfo, &_info, sizeof(_info));
    poxidInfo->psa = psa;

    return(OR_OK);
}

void
CServerOxid::RundownOids(ULONG cOids,
                         CServerOid* aOids[])
// Note: Returns without the server lock held.
{
    RPC_STATUS status = RPC_S_OK;

    ASSERT(cOids > 0);
    ASSERT(cOids <= MAX_OID_RUNDOWNS_PER_CALL);

    ASSERT(gpServerLock->HeldExclusive());

    // We only issue the rundown call if a) we're still running
    // and b) there isn't another rundown call to this oxid 
    // already in progress.
    if (IsRunning() && !_fRundownInProgress)
    {
        // Note: The server lock is released during the callback.
        // Since the OID hasn't rundown yet, it will keep a reference
        // to this OXID which in turn keeps the process object alive.
        
        // Ask our process object to issue an async call to try
        // to rundown the specified oids.  If call was sent ok,
        // return.   Otherwise fall thru and cleanup below.
        _fRundownInProgress = TRUE;

        status = _pProcess->RundownOids(this,
                                        cOids,
                                        aOids);

        ASSERT(!gpServerLock->HeldExclusive());

        if (status == RPC_S_OK)
        {            
            return;
        }
        else
        {
            // Re-take the lock
            gpServerLock->LockExclusive();

            // No rundown in progress now
            _fRundownInProgress = FALSE;
        }
    }

    BYTE aRundownStatus[MAX_OID_RUNDOWNS_PER_CALL];
    
    // If server died or apartment was unregistered, okay to run all 
    // oids down.  Otherwise don't run any down (this is also the 
    // case for when we are still running but another rundown is already
    // in progress).
    for (ULONG i = 0; i < cOids; i++)
    {
        aRundownStatus[i] = IsRunning() ? ORS_DONTRUNDOWN : ORS_OK_TO_RUNDOWN;
    }
	
    // Call the notify function whih will do appropriate 
    // cleanup on the oids
    ProcessRundownResultsInternal(FALSE, cOids, aOids, aRundownStatus);

    gpServerLock->UnlockExclusive();
}


void 
CServerOxid::ProcessRundownResults(ULONG cOids, 
                                   CServerOid* aOids[], 
                                   BYTE aRundownStatus[])
/*++

Routine Desciption

    Takes the appropriate action based on the result of trying
    to rundown one or more oids.

Arguments:

    cOids -- # of oids in aOids

    aOids -- array of CServerOid*'s that we tried to rundown

    aRundownStatus -- array of status values from the 
        OID_RUNDOWN_STATUS enumeration.

Return Value:

    void

--*/
{
    ProcessRundownResultsInternal(TRUE,
                                  cOids,
                                  aOids,
                                  aRundownStatus);

    return;
}

void 
CServerOxid::ProcessRundownResultsInternal(BOOL fAsyncReturn,
                                       ULONG cOids, 
                                       CServerOid* aOids[], 
                                       BYTE aRundownStatus[])
/*++

Routine Desciption

    Takes the appropriate action based on the result of trying
    to rundown one or more oids.

Arguments:
	
    fAsyncReturn -- TRUE if we are processing these results in response
        to a async rundown call returning, FALSE otherwise.

    cOids -- # of oids in aOids

    aOids -- array of CServerOid*'s that we tried to rundown

    aRundownStatus -- array of status values from the 
        OID_RUNDOWN_STATUS enumeration.

Return Value:

    void

--*/
{
    ULONG i;

    ASSERT(gpServerLock->HeldExclusive());

    // Flip the "rundown in progress" flag as necessary.
    if (fAsyncReturn)
    {
        ASSERT(_fRundownInProgress);
        _fRundownInProgress = FALSE;
    }

    for(i = 0; i < cOids; i++)
    {
        CServerOid* pOid;

        pOid = aOids[i];
        ASSERT(pOid);
        ASSERT(this == pOid->GetOxid());

        if (aRundownStatus[i] == ORS_OID_PINNED)
        {
            KdPrintEx((DPFLTR_DCOMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "OR: Randown OID %p but the client says it's pinned\n",
                       pOid));

            // Server says that particular oid is "pinned", ie cannot
            // be rundown until we are told otherwise.  Note that we
            // check for this before we check # of references -- the
            // ORS_OID_PINNED status takes precedence.
            pOid->SetPinned(TRUE);                            
            pOid->SetRundown(FALSE);
        }
        else if (pOid->References() != 0)
        {
            // Added to a set while running down and still referenced.
            pOid->SetRundown(FALSE);
        }
        else if (aRundownStatus[i] == ORS_OK_TO_RUNDOWN)
        {
            delete pOid;
        }
        else
        {
            ASSERT(aRundownStatus[i] == ORS_DONTRUNDOWN);

            KdPrintEx((DPFLTR_DCOMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "OR: Randown OID %p but the client kept it alive\n",
                       pOid));

            // Client want us to keep it alive and is still running.
            pOid->SetRundown(FALSE);
            pOid->Insert();
        }
    }
}


ORSTATUS
CServerOxid::GetRemoteInfo(
    OUT OXID_INFO *pInfo,
    IN  USHORT    cClientProtseqs,
    IN  USHORT    aClientProtseqs[]
    )
// Server lock held shared.
{
    ORSTATUS status;
    USHORT   protseq;

    status = GetInfo(pInfo, FALSE);

    if (OR_OK == status)
        {
        protseq = FindMatchingProtseq(cClientProtseqs,
                                      aClientProtseqs,
                                      pInfo->psa->aStringArray
                                      );
        if (0 == protseq)
            {
            MIDL_user_free(pInfo->psa);
            pInfo->psa = 0;
            status = OR_I_NOPROTSEQ;
            }
        }

    return(status);

}

ORSTATUS
CServerOxid::LazyUseProtseq(
    IN  USHORT    cClientProtseqs,
    IN  USHORT    *aClientProtseqs
    )
// Server lock held shared, returns with the server lock exclusive.
// Note: It is possible, that after this call the OXID has been deleted.
{
    ORSTATUS status;

    if (IsRunning())
        {
        // Keep this OXID process alive while making the callback. If the process
        // crashes and this OXID has no OIDs it could be released by everybody
        // else.  This keeps the OXID and process alive until we finish.

        this->Reference();

        gpServerLock->UnlockShared();

        status = _pProcess->UseProtseqIfNeeded(cClientProtseqs, aClientProtseqs);

        gpServerLock->LockExclusive();

        this->Release();
        }
    else
        {
        gpServerLock->ConvertToExclusive();
        status = OR_NOSERVER;
        }

    // Note: The this poiner maybe BAD now.

    return(status);
}


//
// CServerSet methods.
//

ORSTATUS
CServerSet::AddObject(OID &oid)
{
    ORSTATUS status = OR_OK;
    CServerOid *pOid;

    ASSERT(gpServerLock->HeldExclusive());

    CIdKey key(oid);

    pOid = (CServerOid *)gpServerOidTable->Lookup(key);

    if (pOid)
    {
        ASSERT(_blistOids.Member(pOid) == FALSE);
        
        // Don't add duplicate IDs to the set
        if (_blistOids.Member(pOid) == FALSE) 
        {
           status = _blistOids.Insert(pOid);
           if (status == OR_OK)
           {
               pOid->Reference();
           }
        }
    }
    else
        status = OR_BADOID;

    VALIDATE((status, OR_BADOID, OR_NOMEM, 0));

    return(status);
}

void
CServerSet::RemoveObject(OID &oid)
{
    CServerOid *pOid;

    ASSERT(gpServerLock->HeldExclusive());

    CIdKey key(oid);

    pOid = (CServerOid *)gpServerOidTable->Lookup(key);

    if (pOid)
        {
        CServerOid *pOidTmp = (CServerOid *)_blistOids.Remove(pOid);

        if (pOid == pOidTmp)
            {
            pOid->Release();
            }
        else
            {
            // Set doesn't contain the specified oid, treat this as an
            // add and delete by keeping the oid alive for another timeout
            // period.

            ASSERT(pOidTmp == 0);

            pOid->KeepAlive();
            }
        }
}

BOOL
CServerSet::ValidateObjects(BOOL fShared)
// fShared - Indicates if the server lock is held
//           shared (TRUE) or exclusive (FALSE).
//
// Return  - TRUE the lock is still shared, false
//           the lock is held exclusive.
{
    CServerOid *pOid;
    CBListIterator oids(&_blistOids);

    // Since we own a reference on all the Oids they must still exist.
    // No need to lock exclusive until we find something to delete.

    while(pOid = (CServerOid *)oids.Next())
        {
        if (!pOid->IsRunning())
            {
            if (fShared)
                {
                KdPrintEx((DPFLTR_DCOMSS_ID,
                           DPFLTR_WARNING_LEVEL,
                           "OR: Cleanup in set (%p), removing dead oids.\n",
                           this,
                           pOid));

                gpServerLock->ConvertToExclusive();
                fShared = FALSE;
                oids.Reset(&_blistOids);
                continue;
                }

            CServerOid *pOidTmp = (CServerOid *)_blistOids.Remove(pOid);

            ASSERT(pOidTmp == pOid);
            ASSERT(pOid->IsRunning() == FALSE);

            pOid->Release();
            }
        }

    return(fShared);
}

BOOL
CServerSet::Rundown()
// Rundown the whole set.
{
    CServerOid *poid;
    CTime now;

    ASSERT(gpServerLock->HeldExclusive());

    if (_timeout > now)
        {
        // Don't rundown if we've recieved a late ping.
        return(FALSE);
        }

    if (_fLocal && _blistOids.Size() != 0)
        {
        KdPrintEx((DPFLTR_DCOMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "OR: Premature rundown of local set ignored.\n"));

        return(FALSE);
        }

    KdPrintEx((DPFLTR_DCOMSS_ID,
               DPFLTR_WARNING_LEVEL,
               "OR: Set %p's client appears to have died\n",
               this));

    CBListIterator oids(&_blistOids);

    while(poid = (CServerOid *)oids.Next())
        {
        poid->Release();
        }

    return(TRUE);
}


//
// CServerSetTable implementation
//

CServerSet *
CServerSetTable::Allocate(
    IN USHORT sequence,
    IN PSID   psid,
    IN BOOL   fLocal,
    OUT ID   &setid
    )
/*++

Routine Description:

    Allocates a new CServerSet and returns the setid for the new set.

Arguments:

    sequence - initial sequence number for the new set.

    psid - pointer to an NT SID structure for the new set.

    fLocal - TRUE : set is for the local client,
             FALSE : set is for a remote client

    setid - the setid of the set returned.  Unchanged if return value 0.

Return Value:

    0 - Unable to allocate a resource

    non-zero - A pointer to the newly created set.

--*/
{
    ASSERT(gpServerLock->HeldExclusive());
    UINT i;
    LARGE_INTEGER li;

    ASSERT(_cAllocated <= _cMax);

    if (_cAllocated == _cMax)
        {
        // Table is full, realloc

        // Do this first, if it succeeds great even if
        // a later allocation fails. If not, fail now.

        IndexElement *pNew = new IndexElement[_cMax * 2];

        if (!pNew)
            {
            return(0);
            }

        for (i = 0; i < _cMax; i++)
            {
            pNew[i] = _pElements[i];
            }

        for(i = _cMax; i < _cMax*2; i++)
            {
            pNew[i]._sequence = GetTickCount();
            pNew[i]._pSet = 0;
            }

        delete _pElements;
        _pElements = pNew;
        _cMax *= 2;
        }

    CServerSet *pSet = new CServerSet(sequence, psid, fLocal);

    if (0 == pSet)
        {
        return(0);
        }

    ASSERT(_pElements);
    ASSERT(_cMax > _cAllocated);

    for(i = _iFirstFree; i < _cMax; i++)
        {
        if (0 == _pElements[i]._pSet)
            {
            _pElements[i]._sequence++;
            _pElements[i]._pSet = pSet;
            li.HighPart = i + 1;
            li.LowPart = _pElements[i]._sequence;
            setid = li.QuadPart;
            _iFirstFree = i + 1;
            _cAllocated++;
            return pSet;
            }
        }

    ASSERT(0);
    return(0);
}


CServerSet *
CServerSetTable::Lookup(
    IN ID setid
    )
/*++

Routine Description:

    Looks up an a set given the sets ID.

    Server lock held shared.

Arguments:

    setid - the ID of the set to lookup

Return Value:

    0 - set doesn't exist

    non-zero - the set.

--*/
{
    LARGE_INTEGER li;
    li.QuadPart = setid;
    LONG i = li.HighPart - 1;
    DWORD sequence = (DWORD)(setid & ~((ID)0));

    if (i >= 0 && (DWORD) i < _cMax)
        {
        if (_pElements[i]._sequence == sequence)
            {
            // May still be null if it is free and has not yet be reused.
            return(_pElements[i]._pSet);
            }
        }
    return(0);
}


ID
CServerSetTable::CheckForRundowns(
    )
/*++

Routine Description:

    Used by ping and worker threads to monitor for sets that should
    be rundown.  It is called with the server lock held shared.

Arguments:

    None

Return Value:

    0 - Didn't find a set to rundown

    non-zero - ID of a set which may need to be rundown.

--*/
{
    UINT i, end;
    LARGE_INTEGER id;
    id.QuadPart = 0;
    ASSERT(_iRundown < _cMax);

    if (_cAllocated == 0)
        {
        return(0);
        }

    i = _iRundown;
    do
        {
        ASSERT(_cAllocated);  // loop assumes one or more allocated elements.
        i = (i + 1) % _cMax;
        }
    while(0 == _pElements[i]._pSet);

    ASSERT(_pElements[i]._pSet);

    if (_pElements[i]._pSet->ShouldRundown())
        {
        id.HighPart = i + 1;
        id.LowPart = _pElements[i]._sequence;
        }

    _iRundown = i;

    return(id.QuadPart);
}


BOOL
CServerSetTable::RundownSetIfNeeded(
    IN ID setid
    )
/*++

Routine Description:

    Rundowns down a set (or sets) if needed. Called by
    ping and worker threads.  Server lock held exclusive.

Arguments:

    setid - An ID previously returned from CheckForRundowns.

Return Value:

    TRUE - A set was actually rundown

    FALSE - No sets actually rundown

--*/
{
    ASSERT(gpServerLock->HeldExclusive());

    CServerSet *pSet = Lookup(setid);

    if (0 == pSet || FALSE == pSet->ShouldRundown())
        {
        // Set already randown or has been pinged in the meantime.
        return(FALSE);
        }

    // PERF REVIEW this function has the option of running multiple sets,
    // saving the worker thread from taking and leaving the lock many times
    // when a bunch of sets all rundown.  This feature is not used.

    LARGE_INTEGER li;
    li.QuadPart = setid;

    UINT i = li.HighPart - 1;

     if (pSet->Rundown())
        {
        delete pSet;
        _cAllocated--;
        if (i < _iFirstFree) _iFirstFree = i;
        _pElements[i]._pSet = 0;
        return(TRUE);
        }

    return(FALSE);
}


void 
CServerSetTable::PingAllSets()
/*++

Routine Description:

    Performs a ping of all sets currently in the table.

Arguments:

    none

Return Value:

    void

--*/
{
    ASSERT(gpServerLock->HeldExclusive());

    ULONG i;
    for(i = 0; i < _cMax; i++)
    {
        if (_pElements[i]._pSet)
        {
            _pElements[i]._pSet->Ping(FALSE);
        }
    }	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\objex\plist.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    Plist.cxx

Abstract:

    Implementation of the CPList class.

Author:

    Mario Goertzel    [MarioGo]

Revision History:

    MarioGo     02-24-95    Bits 'n pieces

--*/

#include<or.hxx>

void
CPList::Insert(CPListElement *p)
{
    CMutexLock lock(&this->_lock);
    CTime time;

    time += _timeout;

    p->SetTimeout(time);

    this->CList::Insert(p);
}

BOOL
CPList::PeekMin(CTime &timeout)
    // inline?
{
    CTime *pT;
    CMutexLock lock(&this->_lock);

    CPListElement *first = (CPListElement *)this->First();

    if (first && (pT = first->GetTimeout()))
        {
        timeout = *pT;
        return(TRUE);
        }

    return(FALSE);
}

CPListElement *
CPList::Remove(CPListElement *p)
// It must be safe to remove an element not actually in a list.
{
    CMutexLock lock(&this->_lock);

    return( (CPListElement *)this->CList::Remove(p) );
}

CListElement *
CPList::MaybeRemoveMin(
    IN CTime &when
    )
{
    CMutexLock lock(&this->_lock);

    CPListElement *first = (CPListElement *)this->First();

    if (first && *first->GetTimeout() < when)
        {
        return(Remove(first));
        }

    return(0);
}

void
CPList::Reset(
    IN CPListElement *p
    )
{
    CMutexLock lock(&this->_lock);

    ASSERT(p);

    if (p->Next() == 0 && p->Previous() == 0 && First() != p)
        {
        ASSERT(Last() != p);
        return;
        }

    Remove(p);

    // Update timeout
    CTime now;
    now += _timeout;
    p->SetTimeout(now);

    Insert(p);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\objex\token.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    Token.cxx

Abstract:

    Implementation for Windows NT security interfaces.

Platform:

    Windows NT user mode.

Notes:

    Not portable to non-Windows NT platforms.

Author:

    Mario Goertzel    [MarioGo]

Revision History:

    MarioGo     12/21/1995    Bits 'n pieces

--*/

#include <or.hxx>
#include <aclapi.h>
#include <access.hxx>

CRITICAL_SECTION gcsTokenLock;

extern "C"
{
// The following is a private function provided to try to empiracally
// determine if the two access token have been restricted with comparable
// WinSafer authorization Levels.  When TRUE is returned, the pdwResult
// output parameter will receive any of the following values:
//      -1 = Client's access token is more authorized than Server's.
//       0 = Client's access token is comparable level to Server's.
//       1 = Server's access token is more authorized than Client's.
// BUGBUG: Remove when we discover which private header this thing is in.

WINADVAPI
BOOL WINAPI
SaferiCompareTokenLevels (
        IN HANDLE   ClientAccessToken,
        IN HANDLE   ServerAccessToken,
        OUT PDWORD  pdwResult
        );
}


ORSTATUS
LookupOrCreateToken2(
    IN  HANDLE hClientToken,
    OUT CToken **ppToken
    )
/*++

Routine Description:

    Finds or allocates a new token object for the caller.

Arguments:

    hCaller - RPC binding handle of the caller of RPCSS.

    pToken - Upon a successful return this will hold the token.
             It can be destroyed by calling Release();

Return Value:


    OR_OK - success
    OR_NOACCESS - If the caller is not local, or cannot be impersonated.
    OR_NOMEM - Unable to allocate an object.

--*/
{
    ORSTATUS status;
    UINT type;
    LUID luid;
    PTOKEN_USER ptu;
    TOKEN_STATISTICS ts;
    BOOL fSuccess;
    DWORD needed;
    HANDLE hJobObject = NULL;
    LUID luidMod;
    
    needed = sizeof(ts);
    fSuccess  = GetTokenInformation(hClientToken,
                                    TokenStatistics,
                                    &ts,
                                    sizeof(ts),
                                    &needed
                                    );
    if (!fSuccess)
        {
        KdPrintEx((DPFLTR_DCOMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "OR: GetTokenInfo failed %d\n",
                   GetLastError()));

        ASSERT(GetLastError() != ERROR_INSUFFICIENT_BUFFER);
        status = OR_NOMEM;
        goto Cleanup;
        }

    luid = ts.AuthenticationId;
    luidMod = ts.ModifiedId;
    //
    // Check if the token is already in the list
    //

    {
    CMutexLock lock(&gcsTokenLock);

    CListElement *ple;

    ple = gpTokenList->First();

    fSuccess = FALSE;
    while(ple)
        {
        CToken *pToken = CToken::ContainingRecord(ple);

        if (pToken->MatchLuid(luid) &&
	    (pToken->MatchModifiedLuid(luidMod)) &&
            (S_OK == pToken->MatchToken(hClientToken, TRUE)))
            {
            pToken->AddRef();
            *ppToken = pToken;
            status = OR_OK;
            fSuccess = TRUE;
            break;
            }
        else
            {
            ple = ple->Next();
            }
        }
    }

    if (fSuccess)
        {
        status = OR_OK;
        CloseHandle(hClientToken);
        goto Cleanup;
        }

    //
    // New user, need to allocate a token object.
    //

    // Lookup the SID to store in the new token object.

    needed = DEBUG_MIN(1, 0x2c);

    do
        {
        ptu = (PTOKEN_USER)alloca(needed);
        ASSERT(ptu);

        fSuccess = GetTokenInformation(hClientToken,
                                       TokenUser,
                                       (PBYTE)ptu,
                                       needed,
                                       &needed);

        // If this assert is hit increase the 24 both here and above
        ASSERT(needed <= 0x2c);
        }
    while (   fSuccess == FALSE
           && GetLastError() == ERROR_INSUFFICIENT_BUFFER);

    if (!fSuccess)
        {
        KdPrintEx((DPFLTR_DCOMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "OR: GetTokenInfo (2) failed %d\n",
                   GetLastError()));

        ASSERT(GetLastError() != ERROR_INSUFFICIENT_BUFFER);
        status = OR_NOMEM;
        goto Cleanup;
        }

    PSID psid;
    psid = ptu->User.Sid;
    ASSERT(IsValidSid(psid) == TRUE);

    // Allocate the token object

    needed = GetLengthSid(psid) - sizeof(SID);
    *ppToken = new(needed)  CToken(hClientToken,
                                   hJobObject,
                                   luid,
                                   psid,
                                   needed + sizeof(SID));

    if (*ppToken)
        {
        CMutexLock lock(&gcsTokenLock);

        (*ppToken)->Insert();

        status = OR_OK;

        #if DBG_DETAIL
            {
            DWORD d = 50;
            WCHAR buffer[50];
            GetUserName(buffer, &d);
            KdPrintEx((DPFLTR_DCOMSS_ID,
                       DPFLTR_WARNING_LEVEL,
                       "OR: New user connected: %S (%p)\n",
                       buffer,
                       *ppToken));
            }
        #endif

        }
    else
        {
        status = OR_NOMEM;
        }

Cleanup:

    if (OR_OK != status)
        {
        if (NULL != hJobObject)
            CloseHandle(hJobObject);
        }

    // status contains the result of the operation.

    return(status);
}


ORSTATUS
LookupOrCreateToken(
    IN  handle_t hCaller,
    IN  BOOL fLocal,
    OUT CToken **ppToken
    )
/*++

Routine Description:

    Finds or allocates a new token object for the caller.

Arguments:

    hCaller - RPC binding handle of the caller of RPCSS.

    fLocal - Looking up a local client, check local security.

    pToken - Upon a successful return this will hold the token.
             It can be destroyed by calling Release();

Return Value:


    OR_OK - success
    OR_NOACCESS - If the caller is not local, or cannot be impersonated.
    OR_NOMEM - Unable to allocate an object.

--*/
{
    ORSTATUS status;
    UINT type;
    HANDLE hClientToken = 0;
    BOOL fSuccess;

    if (fLocal)
    {
        status = I_RpcBindingInqTransportType(hCaller, &type);
        
        if (status != RPC_S_OK || type != TRANSPORT_TYPE_LPC)
        {
            return(OR_NOACCESS);
        }
    }
    
    status = RpcImpersonateClient(hCaller);
    if (status != RPC_S_OK)
    {
        return(OR_NOACCESS);
    }
    
    fSuccess = OpenThreadToken(GetCurrentThread(),
                               TOKEN_ALL_ACCESS,
                               TRUE,
                               &hClientToken);

    if (fSuccess)
    {
        status = LookupOrCreateToken2(hClientToken, ppToken);
        if(OR_OK == status)
        {
            // The token object now controls the life of the token handle
            hClientToken = 0;
        }
        else
        {
            CloseHandle(hClientToken);
            hClientToken = 0;
        }
    }
    else
    {
        KdPrintEx((DPFLTR_DCOMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "OR: OpenThreadToken failed %d\n",
                   GetLastError()));
        
        status = OR_NOMEM;
        ASSERT(hClientToken == 0);
        goto Cleanup;
    }
    
    
 Cleanup:
    // status contains the result of the operation.
    
    RPC_STATUS t = RpcRevertToSelfEx(hCaller);
    ASSERT(t == RPC_S_OK);
    
    return(status);
}

CToken::~CToken()
{
    ASSERT(_lHKeyRefs == 0);
    ASSERT(_hHKCRKey == NULL);

    if (_hHKCRKey != NULL)
    {
        // Shouldn't happen...but close it anyway just in
        // case.  Assert above will catch this if it occurs
        RegCloseKey(_hHKCRKey);
    }

    CloseHandle(_hImpersonationToken);

    if (NULL != _hJobObject)
        {
        TerminateJobObject(_hJobObject, 0);
        CloseHandle(_hJobObject);
        }
}

STDMETHODIMP CToken::QueryInterface(REFIID riid, LPVOID* ppv)
{
    if (riid == IID_IUnknown || riid == IID_IUserToken)
    {
        *ppv = this;
        AddRef();
        return S_OK;
    }
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CToken::AddRef()
{
    return InterlockedIncrement(&_lRefs);
}

STDMETHODIMP_(ULONG) CToken::Release()
{
    LONG lNewRefs;

    CMutexLock lock(&gcsTokenLock);

    lNewRefs = InterlockedDecrement(&_lRefs);
    if (lNewRefs == 0)
    {
        Remove();
        delete this;
    }

    return lNewRefs;
}


STDMETHODIMP 
CToken::GetUserClassesRootKey(HKEY* phKey)
{
    CMutexLock lock(&gcsTokenLock);

    if ( _lHKeyRefs++ == 0 )
    {
        ASSERT(_hHKCRKey == NULL);

        // The original IUserToken implementation allowed for not
        // having a token. That should never happen with a CToken.
        ASSERT(_hImpersonationToken);

        // Open per-user hive
        LONG lRet = RegOpenUserClassesRoot(_hImpersonationToken, 
                                           0, 
                                           KEY_READ, 
                                           &_hHKCRKey);
        if (lRet != ERROR_SUCCESS)
        {
            // In case of an error, we fall back on HKCR since that
            // is what the original IUserToken implementation did.  
            _hHKCRKey = HKEY_CLASSES_ROOT;
        }
    }
    
    *phKey = _hHKCRKey;

    ASSERT(*phKey != NULL);

    return S_OK;
}

STDMETHODIMP 
CToken::ReleaseUserClassesRootKey()
{
    CMutexLock lock(&gcsTokenLock);
    
    ASSERT(_lHKeyRefs > 0);
    ASSERT(_hHKCRKey != NULL);

    if (--_lHKeyRefs == 0)
    {
        if (_hHKCRKey != HKEY_CLASSES_ROOT)
        {
            RegCloseKey(_hHKCRKey);
        }

        _hHKCRKey = NULL;
    }

    return S_OK;
}

STDMETHODIMP 
CToken::GetUserSid(BYTE **ppSid, USHORT *pcbSid)
{
    // IUserToken interface assumes that sid lengths always
    // <= USHRT_MAX.  Truncating here on purpose; assert is
    // to catch cases where this is a bad idea.  GetLengthSid
    // is a very cheap call, so there's no need to cache it.
    DWORD dwSidLen = GetLengthSid(&_sid);
    ASSERT(dwSidLen <= USHRT_MAX);

    *pcbSid = (USHORT)dwSidLen;
    *ppSid = (BYTE*)&_sid;

    return S_OK;
}

void
CToken::Impersonate()
{
    ASSERT(_hImpersonationToken);

    BOOL f = SetThreadToken(0, _hImpersonationToken);
    ASSERT(f);

    return;
}

void
CToken::Revert()
{
    BOOL f = SetThreadToken(0, 0);
    ASSERT(f);
    return;
}

ULONG GetSessionId2(
    HANDLE hToken)
{
    BOOL  Result;
    ULONG SessionId = 0;
    ULONG ReturnLength;

    //
    // Use the _HYDRA_ extension to GetTokenInformation to
    // return the SessionId from the token.
    //

    Result = GetTokenInformation(
                 hToken,
                 TokenSessionId,
                 &SessionId,
                 sizeof(SessionId),
                 &ReturnLength
                 );

    if( !Result ) {
        SessionId = 0; // Default to console
    }

    return SessionId;
}

ULONG CToken::GetSessionId()
{
    return GetSessionId2(_hImpersonationToken);
}

BOOL CToken::MatchModifiedLuid(LUID luid)
{
   ASSERT(_hImpersonationToken);

   TOKEN_STATISTICS ts;
   BOOL fSuccess;
   DWORD needed;
   LUID luidMod;
   needed = sizeof(ts);
   fSuccess  = GetTokenInformation(_hImpersonationToken,
                                   TokenStatistics,
                                   &ts,
                                   sizeof(ts),
                                   &needed
                                   );
   if (!fSuccess)
       {
       KdPrintEx((DPFLTR_DCOMSS_ID,
                  DPFLTR_WARNING_LEVEL,
                  "OR: GetTokenInfo failed %d\n",
                  GetLastError()));

       ASSERT(GetLastError() != ERROR_INSUFFICIENT_BUFFER);
       return FALSE;
      }
   luidMod = ts.ModifiedId;
   return(   luidMod.LowPart == luid.LowPart
          && luidMod.HighPart == luid.HighPart);
}

HRESULT CompareRestrictedSids(
    HANDLE hToken1,
    HANDLE hToken2)
{
    HRESULT hr = S_OK;
    PSID pRestrictedSid1 = NULL;
    PSID pRestrictedSid2 = NULL;

#if(_WIN32_WINNT >= 0x0500)
    PTOKEN_GROUPS pSids1;
    PTOKEN_GROUPS pSids2;
    NTSTATUS error;
    ULONG needed;

    //Get restricted SIDs.
    needed = DEBUG_MIN(1, 300);
    do
    {
        pSids1 = (PTOKEN_GROUPS) alloca(needed);

        error = NtQueryInformationToken(hToken1,
                                        TokenRestrictedSids,
                                        pSids1,
                                        needed,
                                        &needed);

    }
    while (error == STATUS_BUFFER_TOO_SMALL);

    if(!error && pSids1->GroupCount > 0)
    {
        pRestrictedSid1 = pSids1->Groups[0].Sid;
    }

    //Get restricted SIDs.
    needed = DEBUG_MIN(1, 300);
    do
    {
        pSids2 = (PTOKEN_GROUPS) alloca(needed);

        error = NtQueryInformationToken(hToken2,
                                        TokenRestrictedSids,
                                        pSids2,
                                        needed,
                                        &needed);

    }
    while (error == STATUS_BUFFER_TOO_SMALL);

    if(!error && pSids2->GroupCount > 0)
    {
        pRestrictedSid2 = pSids2->Groups[0].Sid;
    }

    if(pRestrictedSid1 && pRestrictedSid2)
    {
        //We have two restricted tokens.
        //Compare the first restricted SID.
        if(EqualSid(pRestrictedSid1, pRestrictedSid2))
        {
            hr = S_OK;
        }
        else
        {
            hr = S_FALSE;
        }
    }
    else if(pRestrictedSid1 || pRestrictedSid2)
    {
        //We have one restricted token and one normal token.
        hr = S_FALSE;
    }
    else
    {
        //We have two normal tokens.
        hr = S_OK;
    }

#endif //(_WIN32_WINNT >= 0x0500)
    return hr;
}


HRESULT
CToken::MatchToken(
    IN  HANDLE hToken,
    IN  BOOL bMatchRestricted)
{
    HRESULT hr;
    NTSTATUS error;
    PTOKEN_USER ptu;
    DWORD needed = DEBUG_MIN(1, 0x2c);

    //Get the user SID.
    do
    {
        ptu = (PTOKEN_USER)alloca(needed);

        error = NtQueryInformationToken(hToken,
                                        TokenUser,
                                        (PBYTE)ptu,
                                        needed,
                                        &needed);

        // If this assert is hit increase the 24 both here and above
        ASSERT(needed <= 0x2c);
    }
    while (error == STATUS_BUFFER_TOO_SMALL);

    if (error)
    {
        KdPrintEx((DPFLTR_DCOMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "OR: GetTokenInfo (2) failed %d\n",
                   error));

        return HRESULT_FROM_WIN32(error);
    }

    //Compare the user SID.
    if(!EqualSid(ptu->User.Sid, &_sid))
        return S_FALSE;

    //Compare the Hydra session ID.
    if(GetSessionId2(hToken) != GetSessionId())
        return S_FALSE;

    //Compare the restricted SID.
    if (bMatchRestricted)
        hr = CompareRestrictedSids(hToken, _hImpersonationToken);
    else
        hr = S_OK;

    return hr;
}

HRESULT
CToken::MatchToken2(
    IN  CToken *pToken,
    IN  BOOL bMatchRestricted)
{
    HRESULT hr;

    if(!pToken)
        return S_OK;

    //Compare the user SID.
    if(!EqualSid(&pToken->_sid, &_sid))
        return S_FALSE;

    //Compare the Hydra session id.
    if(GetSessionId2(pToken->_hImpersonationToken) != GetSessionId())
        return S_FALSE;

    //Compare the restricted SID.
    if (bMatchRestricted)
        hr = CompareRestrictedSids(pToken->_hImpersonationToken, _hImpersonationToken);
    else
        hr = S_OK;

    return hr;
}

HRESULT
CToken::CompareSaferLevels(CToken *pToken)
/*++
 
Routine Description:
 
    Compare the safer trust level of the specified token with 
    our own.
 
Arguments:
 
    pToken - token to compare against

Return Value:
 
    S_FALSE: This token is of lesser authorization than the
             other token.
    S_OK: This token is of greater or equal authorization 
          than the other token.

    Anything else: An error occured.
 
--*/
{
    if (!pToken) return S_OK;

    return CompareSaferLevels(pToken->_hImpersonationToken);
}

HRESULT
CToken::CompareSaferLevels(HANDLE hToken)
/*++
 
Routine Description:
 
    Compare the safer trust level of the specified token with 
    our own.
 
Arguments:
 
    hToken - token to compare against

Return Value:
 
    S_FALSE: This token is of lesser authorization than the
             other token.
    S_OK:    This token is of greater or equal authorization 
             than the other token.

    Anything else: An error occured.
 
--*/
{
    HRESULT hr = S_OK;
    DWORD dwResult;
    BOOL bRet = SaferiCompareTokenLevels(_hImpersonationToken, hToken,
                                            &dwResult);
    if (bRet)
    {
        // -1 = Client's access token (_hImpersonationToken) is more authorized 
        //      than Server's (hToken).
        if ( ((LONG)dwResult) > 0 )
            hr = S_FALSE;
    }
    else
        hr = HRESULT_FROM_WIN32(GetLastError());

    return hr;
}

//  NT #307301
//  Sometimes we just need to check the SessionID

HRESULT
CToken::MatchTokenSessionID(CToken *pToken)
{
    //Compare the Hydra session id.
    if(GetSessionId2(pToken->_hImpersonationToken) != GetSessionId())
        return S_FALSE;

    return S_OK;
}

// 
//  MatchTokenLUID
//
//   Compares this token's LUID to that of the passed in token.
//   Returns S_OK on a match, S_FALSE on a mismatch.
//
HRESULT CToken::MatchTokenLuid(CToken* pToken)
{    
    return MatchLuid(pToken->_luid) ? S_OK : S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\objex\process.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    Process.cxx

Abstract:

    Process objects represent local clients and servers.  These
    objects live as context handles.

    There are relatively few of these objects in the universe.

Author:

    Mario Goertzel    [MarioGo]

Revision History:

    MarioGo     02-20-95    Bits 'n pieces
    Ronans      20-02-97    UseProtseqIfNeeded modified for custom endpoints
    Ronans      20-02-97    Added custom endpoints stuff to process object
    TarunA      09-Nov-98   Added process handle

--*/

#include <or.hxx>

CRITICAL_SECTION gcsFastProcessLock;
extern HRESULT FreeSPIFromCProcess(void** ppSCMProcessInfo);

const DWORD BINDINGUPDATESTUFF_SIG = 0xFEDCBA01;

typedef struct _BINDINGS_UPDATE_CALLBACK_STUFF
{
    DWORD dwSig; // see BINDINGUPDATESTUFF_SIG above

    // housekeeping stuff
    CProcess* pProcess;  // has reference while call is in-flight
    RPC_BINDING_HANDLE hBinding;
    RPC_ASYNC_STATE async;

    // out and in-out params
    DWORD64 dwBindingsID;
    DUALSTRINGARRAY* pdsaNewBindings;
    DUALSTRINGARRAY* pdsaNewSecurity;
} BINDINGS_UPDATE_CALLBACK_STUFF;


const DWORD ASYNCRUNDOWNOID_SIG = 0xFEDCBA02;

typedef struct _ASYNCRUNDOWNOID_STUFF
{
    DWORD dwSig; // see ASYNCRUNDOWNOID_SIG above

    // housekeeping stuff
    CProcess* pProcess;  // has reference while call is in-flight
    CServerOxid* pOxid;  // has reference while call is in-flight
    RPC_BINDING_HANDLE hBinding;
    RPC_ASYNC_STATE async;

    // We keep these for when we process the return
    ULONG cOids;
    CServerOid* aOids[MAX_OID_RUNDOWNS_PER_CALL];
    
    // The ORPC params are reference pointers, so they must
    // stay alive for the life of the call
    ORPCTHIS orpcthis;
    LOCALTHIS localthis;
    ORPCTHAT orpcthat;

    INT callIDHint;  // need to free this on return

    // in-out or out params.
    BYTE  aRundownStatus[MAX_OID_RUNDOWNS_PER_CALL];  
} ASYNCRUNDOWNOID_STUFF;


void
CProcess::Rundown()
/*++

Routine Description:

    The client process has rundown.  This means there are no more
    client refernces which means we are free to clean things up
    as long as server OXIDs still holding references won't get
    upset.  They all use the server lock when accessing the process.

Arguments:

    None

Return Value:

    None

--*/
{
    ORSTATUS     status;

    gpServerLock->LockExclusive();

    ASSERT(_cClientReferences == 0);
    KdPrintEx((DPFLTR_DCOMSS_ID,
               DPFLTR_INFO_LEVEL,
               "OR: Rundown of %p: %d oxids, %d oids and %d roxids left\n",
               this,
               _blistOxids.Size(),
               _blistOids.Size()));

    // Release any OXIDs owned by this process. This may destroy the OXID.
    // This will release this CProcess, but won't release the last reference as
    // the client process still owns one.


    if (_blistOxids.Size())
    {
        CServerOxid *poxid;

        CBListIterator oxids(&_blistOxids);

        while (poxid = (CServerOxid *)oxids.Next())
        {
            gpServerOxidTable->Remove(poxid);
            poxid->ProcessRelease();
        }
    }

    // Release any OIDs is use by this processes.

    // Do this now, rather then waiting for the last server oid
    // owned by this process to get invalidated and rundown.

    gpClientLock->LockExclusive();

    // *** Both client and server lock held here. ***

    if (_blistOids.Size())
    {
        CClientOid  *poid;

        CBListIterator oids(&_blistOids);

        while (poid = (CClientOid *)oids.Next())
        {
            ASSERT(NULL != poid->GetClientOxid());

            poid->GetClientOxid()->Release();

            poid->ClientRelease();
        }
    }

    // Cleanup other process state.    Note:  it is important that the 
    // release of the process and token handle never happen any later
    // than rundown time.   If the process handle is released any later, you
    // will see bugs like "can't recompile my com server" after they run
    // it once.   If the token handle is released any later, you will get
    // security bugs from the NT security folks since we will hold onto 
    // the logged-on user's token until many minutes after logoff.  
    //
    // Ask me how I know this...
    //
    if (_hProcHandle)
    {
        CloseHandle(_hProcHandle);
        _hProcHandle = NULL;
    }

    if (_pToken)
    {
        _pToken->Release();
        _pToken = 0;
    }   

    // Free the cached SCMProcessInfo if we have one
    FreeSPIFromCProcess(&_pSCMProcessInfo);

    // Flip the rundown and dirty bit
    _dwFlags |= (PROCESS_RUNDOWN & PROCESS_SPI_DIRTY);

    gpClientLock->UnlockExclusive();

    // Done, release the clients' reference, this may actually delete this
    // process.  (If an OXID still exists and has OIDs it will not be deleted
    // until the OIDs all rundown).

    this->Release();
    

    // The this pointer maybe invalid now.

    gpServerLock->UnlockExclusive();
}


CProcess::CProcess(
                  IN CToken*& pToken,
                  IN WCHAR *pwszWinstaDesktop,
                  IN DWORD procID,
                  IN DWORD dwFlags,
                  OUT ORSTATUS &status
                  ) :
_blistOxids(4),
_blistOids(16),
_listClasses()
/*++

Routine Description:

    Initalized a process object, members and add it to the
    process list.

Arguments:

    pToken - The clients token.  We assume we have a reference.

    pwszWinstaDesktop - The client's windowstation/desktop string.

        procID - The client's process ID.

    status - Sometimes the C'tor can fail with OR_NOMEM.

Return Value:

    None

--*/
{
    _cClientReferences  = 1;
    _hProcess           = NULL;
    _fCacheFree         = FALSE;
    _pdsaLocalBindings  = NULL;
    _pdsaRemoteBindings = NULL;
    _pToken             = NULL;
    _pwszWinstaDesktop  = NULL;
    _pScmProcessReg     = NULL;
    _pvRunAsHandle      = NULL;
    _procID             = 0;
    _fLockValid         = FALSE;
    _hProcHandle        = NULL;
    _dwFlags            = PROCESS_SPI_DIRTY;  // always start out dirty
    _pSCMProcessInfo    = NULL;
    _ulClasses          = 0;
    _dwCurrentBindingsID = 0;
    _dwAsyncUpdatesOutstanding = 0;
    
    // Set 64 bit flag if so indicated
    if (dwFlags & CONNECT_FLAGS_64BIT)
        _dwFlags |= PROCESS_64BIT;

    // Store time of object creation.  Note that this is in UTC time.
    GetSystemTimeAsFileTime(&_ftCreated);
	
    // Generate a unique guid to represent this process
    UuidCreate(&_guidProcessIdentifier);

    // ronans - entries for custom protseqs from server
    // not used for clients
    _fReadCustomProtseqs = FALSE;
    _pdsaCustomProtseqs = NULL;

    status = OR_OK;
    if ( pwszWinstaDesktop == NULL )
    {
        status = OR_BADPARAM;
    }

    if (status == OR_OK)
    {
        status = RtlInitializeCriticalSection(&_csCallbackLock);
        _fLockValid = (status == STATUS_SUCCESS);
    }

    if (status == STATUS_SUCCESS)
    {
        gpProcessListLock->LockExclusive();
        status = gpProcessList->Insert(this);
        gpProcessListLock->UnlockExclusive();
    }

    if (status == OR_OK)
    {
        _pwszWinstaDesktop = new WCHAR[OrStringLen(pwszWinstaDesktop)+1];
        if (! _pwszWinstaDesktop)
            status = OR_NOMEM;
        else
            OrStringCopy(_pwszWinstaDesktop, pwszWinstaDesktop);
    }

    if (status == OR_OK)
    {
        _pToken = pToken;
        pToken = NULL; // We've taken the token
    }


    _procID = procID;

#if DBG
    _cRundowns = 0;
#endif
}

CProcess::~CProcess(void)
// You probably should be looking in the ::Rundown method.
// This process object stays alive until the last server oxid dies.
{
    ASSERT(gpServerLock->HeldExclusive());
    ASSERT(_hProcHandle == 0);
    ASSERT(_pSCMProcessInfo == 0);

    delete _pdsaLocalBindings;
    delete _pdsaRemoteBindings;
    MIDL_user_free( _pdsaCustomProtseqs );

    delete _pwszWinstaDesktop;

    if (_fLockValid)
        DeleteCriticalSection(&_csCallbackLock);

    if (_hProcess)
    {
        RPC_STATUS status = RpcBindingFree(&_hProcess);
        ASSERT(status == RPC_S_OK);
        ASSERT(_hProcess == 0);
    }

#ifndef _CHICAGO_
    extern void RunAsRelease(void*);
    RunAsRelease(_pvRunAsHandle);
#endif // _CHICAGO_

    return;
}

//
//  SetSCMProcessInfo
// 
//  Swaps our old cached SCMProcessInfo* for a new one.
//
HRESULT CProcess::SetSCMProcessInfo(void* pSPI)
{ 
  ASSERT(gpServerLock->HeldExclusive()); 
  ASSERT(!(_dwFlags & PROCESS_RUNDOWN));

  if (_dwFlags & PROCESS_RUNDOWN)
    return E_UNEXPECTED;
  
  FreeSPIFromCProcess(&_pSCMProcessInfo);
    
  // set the new one
  _pSCMProcessInfo = pSPI;  
  
  // this means we're no longer dirty
  _dwFlags &= ~PROCESS_SPI_DIRTY; 

  return S_OK;
}

void CProcess::SetProcessReadyState(DWORD dwState)
{
  ASSERT(_pScmProcessReg);

  gpServerLock->LockExclusive();

  _pScmProcessReg->ReadinessStatus = dwState;

  // we're now dirty
  _dwFlags |= PROCESS_SPI_DIRTY; 

  gpServerLock->UnlockExclusive();
}


void CProcess::Retire()
{
    // A process can (or should be) only retired once
    ASSERT(!IsRetired());

    // Mark ourselves as retired
    _dwFlags |= (PROCESS_RETIRED | PROCESS_SPI_DIRTY);
}


void CProcess::SetRunAsHandle(void *pvRunAsHandle)
{
    ASSERT(!_pvRunAsHandle);
    _pvRunAsHandle = pvRunAsHandle;
}

BOOL CProcess::SetProcessHandle(HANDLE hProcHandle, DWORD dwLaunchedPID)
{
/*++

Routine Description:

    Store the handle of the process only if the process launched by
    us and the process registering back are the same. Otherwise
    we might kill a process not launched by us on receiving certain
    error conditions (notably RPC_E_SERVERFAULT)

Arguments:

    hProcHandle - Handle of the process launched

    dwLaunchedPID - PID of the process launched

Return Value:

    TRUE - If handle is set
    FALSE - otherwise

--*/

    if (dwLaunchedPID == _procID)
    {
        _hProcHandle = hProcHandle;
        return TRUE;
    }

    return FALSE;
}

RPC_STATUS
CProcess::ProcessBindings(
                         IN DUALSTRINGARRAY *pdsaStringBindings,
                         IN DUALSTRINGARRAY *pdsaSecurityBindings
                         )
/*++

Routine Description:

    Updates the string and optionally the security
    bindings associated with this process.

Arguments:

    psaStringBindings - The expanded string bindings of the process

    psaSecurityBindings - compressed security bindings of the process.
        If NULL, the current security bindings are reused.

Environment:

    Server lock held during call or called from an OXID with an extra
    reference owned by the process and keeping this process alive.

Return Value:

    OR_NOMEM - unable to allocate storage for the new string arrays.

    OR_OK - normally.

--*/
{
    CMutexLock lock(&gcsFastProcessLock);
    USHORT wSecSize;
    PWSTR  pwstrSecPointer;

    // NULL security bindings means we should use the existing bindings.
    if (0 == pdsaSecurityBindings)
    {
        ASSERT(_pdsaLocalBindings);
        wSecSize = _pdsaLocalBindings->wNumEntries - _pdsaLocalBindings->wSecurityOffset;
        pwstrSecPointer =   _pdsaLocalBindings->aStringArray
                            + _pdsaLocalBindings->wSecurityOffset;
    }
    else
    {
        wSecSize = pdsaSecurityBindings->wNumEntries - pdsaSecurityBindings->wSecurityOffset;
        pwstrSecPointer = &pdsaSecurityBindings->aStringArray[pdsaSecurityBindings->wSecurityOffset];
    }

    DUALSTRINGARRAY *pdsaT = CompressStringArrayAndAddIPAddrs(pdsaStringBindings);
    if (!pdsaT)
    {
        return(OR_NOMEM);
    }

    // ignore security on string binding parameter
    pdsaT->wNumEntries = pdsaT->wSecurityOffset;

    DUALSTRINGARRAY *pdsaResult = new((pdsaT->wNumEntries + wSecSize) * sizeof(WCHAR)) DUALSTRINGARRAY;

    if (0 == pdsaResult)
    {
        delete pdsaT;
        return(OR_NOMEM);
    }

    pdsaResult->wNumEntries = pdsaT->wNumEntries + wSecSize;
    pdsaResult->wSecurityOffset = pdsaT->wSecurityOffset;

    OrMemoryCopy(pdsaResult->aStringArray,
                 pdsaT->aStringArray,
                 pdsaT->wSecurityOffset*sizeof(WCHAR));

    OrMemoryCopy(pdsaResult->aStringArray + pdsaResult->wSecurityOffset,
                 pwstrSecPointer,
                 wSecSize*sizeof(WCHAR));

    ASSERT(dsaValid(pdsaResult));

    delete pdsaT;

    delete _pdsaLocalBindings;
    _pdsaLocalBindings = pdsaResult;

    delete _pdsaRemoteBindings;
    _pdsaRemoteBindings = 0;

    return(RPC_S_OK);
}

DUALSTRINGARRAY *
CProcess::GetLocalBindings(void)
// Server lock held or called within an
// OXID with an extra reference.
{
    CMutexLock lock(&gcsFastProcessLock);

    if (0 == _pdsaLocalBindings)
    {
        return(0);
    }

    DUALSTRINGARRAY *T = (DUALSTRINGARRAY *)MIDL_user_allocate(sizeof(DUALSTRINGARRAY)
                                                               + sizeof(USHORT) * _pdsaLocalBindings->wNumEntries);

    if (0 != T)
    {
        dsaCopy(T, _pdsaLocalBindings);
    }

    return(T);
}

DUALSTRINGARRAY *
CProcess::GetRemoteBindings(void)
// Server lock held.
{
    CMutexLock lock(&gcsFastProcessLock);

    ORSTATUS Status;

    if (0 == _pdsaRemoteBindings)
    {
        if (0 == _pdsaLocalBindings)
        {
            return(0);
        }

        Status = ConvertToRemote(_pdsaLocalBindings, &_pdsaRemoteBindings);

        if (Status != OR_OK)
        {
            ASSERT(Status == OR_NOMEM);
            return(0);
        }
        ASSERT(dsaValid(_pdsaRemoteBindings));
    }

    DUALSTRINGARRAY *T = (DUALSTRINGARRAY *)MIDL_user_allocate(sizeof(DUALSTRINGARRAY)
                                                               + sizeof(USHORT) * _pdsaRemoteBindings->wNumEntries);

    if (0 != T)
    {
        dsaCopy(T, _pdsaRemoteBindings);
    }

    ASSERT(dsaValid(T));
    return(T);
}


ORSTATUS
CProcess::AddOxid(CServerOxid *pOxid)
{
    ASSERT(gpServerLock->HeldExclusive());

    pOxid->Reference();

    ASSERT(_blistOxids.Member(pOxid) == FALSE);

    ORSTATUS status = _blistOxids.Insert(pOxid);

    if (status != OR_OK)
    {
        pOxid->ProcessRelease();
        return(status);
    }

    gpServerOxidTable->Add(pOxid);

    return(OR_OK);
}

BOOL
CProcess::RemoveOxid(CServerOxid *poxid)
{
    ASSERT(gpServerLock->HeldExclusive());

    CServerOxid *pit = (CServerOxid *)_blistOxids.Remove(poxid);

    if (pit)
    {
        ASSERT(pit == poxid);
        gpServerOxidTable->Remove(poxid);
        poxid->ProcessRelease();
        return(TRUE);
    }

    return(FALSE);
}


BOOL
CProcess::IsOwner(CServerOxid *poxid)
{
    ASSERT(gpServerLock->HeldExclusive());

    return(_blistOxids.Member(poxid));
}

ORSTATUS
CProcess::AddOid(CClientOid *poid)
/*++

Routine Description:

    Adds a new oid to the list of OIDs owned by this process and
    increments the reference count of the associated OXID

Arguments:

    poid - the oid to add.  It's reference is transferred to this
        function.  If this function fails, it must dereference the oid.
        The caller passed a client reference to this process.  The
        process must eventually call ClientRelease() on the parameter.

Return Value:

    OR_OK - normally

    OR_NOMEM - out of memory.

--*/

{
    ORSTATUS status;

    ASSERT(gpClientLock->HeldExclusive());

    status = _blistOids.Insert(poid);

    if (status != OR_OK)
    {
        ASSERT(status == OR_NOMEM);
        poid->ClientRelease();
    }
    else
    {
        ASSERT(NULL != poid->GetClientOxid());
        poid->GetClientOxid()->Reference();
    }

    return(status);
}

CClientOid *
CProcess::RemoveOid(CClientOid *poid)
/*++

Routine Description:

    Removes an OID from this list of OID in use by this process.

Arguments:

    poid - The OID to remove.

Return Value:

    non-zero - the pointer actually remove. (ASSERT(retval == poid))
               It will be released by the process before return,
               so you should not use the pointer unless you know you
               have another reference.

    0 - not in the list

--*/

{
    ASSERT(gpClientLock->HeldExclusive());

    CClientOid *pit = (CClientOid *)_blistOids.Remove(poid);

    if (pit)
    {
        ASSERT(pit == poid);

        pit->ClientRelease();

        ASSERT(NULL != poid->GetClientOxid());

        poid->GetClientOxid()->Release();

        return(pit);
    }

    return(0);
}

void
CProcess::AddClassReg(GUID & Guid, DWORD Reg)
{
    CClassReg * pReg;

    pReg = new CClassReg( Guid, Reg );

    if (pReg)
    {
        gpServerLock->LockExclusive();

        _listClasses.Insert( pReg );
        
        // flip the dirty bit
        _dwFlags |= PROCESS_SPI_DIRTY;
        
        _ulClasses++;

        gpServerLock->UnlockExclusive();
    }
}

void
CProcess::RemoveClassReg(DWORD Reg)
{
    CClassReg * pReg;

    gpServerLock->LockExclusive();

    pReg = (CClassReg *)_listClasses.First();

    while ( (pReg != NULL) && (pReg->_Reg != Reg) )
        pReg = (CClassReg *)pReg->Next();

    if (pReg)
    {
        (void)_listClasses.Remove( pReg );
        delete pReg;

        // flip the dirty bit
        _dwFlags |= PROCESS_SPI_DIRTY;

        _ulClasses--;
    }

    gpServerLock->UnlockExclusive();
}

void
CProcess::Cleanup()
{
    SCMProcessCleanup(this);
}

void
CProcess::RevokeClassRegs()
{

    if (_pScmProcessReg)
    {
        // This is a unified surrogate (COM+) server
        SCMRemoveRegistration(_pScmProcessReg);
        _pScmProcessReg = NULL;
    }

    // This is for legacy local or custom surrogate servers -- however,
    // nothing prevents someone from calling CoRegisterClassObject in
    // user code even in a COM+ (surrogate) server

    CClassReg * pReg;

    // This is only called during rundown so we don't have to take a lock.

    while ( (pReg = (CClassReg *)_listClasses.First()) != 0 )
    {
        (void)_listClasses.Remove((CListElement *)pReg);
        SCMRemoveRegistration( this,
                               pReg->_Guid,
                               pReg->_Reg );
        delete pReg;
    }
}


void CProcess::SetProcessReg(ScmProcessReg *pProcessReg)
/*++

Routine Description:

    Called by SCM to set COM+ process registration.
    This is also used as a cache during the startup protocol
    to query and set the readiness state of the server process.
    There is exactly one such registration per COM+ server process.

  CODEWORK: these should be inlined

Arguments:

    registration struct

Return Value:

    none.

--*/
{
    gpServerLock->LockExclusive();

    _pScmProcessReg = pProcessReg;

    gpServerLock->UnlockExclusive();
}

ScmProcessReg* CProcess::GetProcessReg()
/*++

Routine Description:

    Called by SCM to lookup COM+ process registration.

Arguments:

    None

Return Value:

    registration struct, if any.

--*/
{
    gpServerLock->LockShared();

    ScmProcessReg *pResult = _pScmProcessReg;

    gpServerLock->UnlockShared();

    return pResult;
}

ScmProcessReg*
CProcess::RemoveProcessReg()
/*++

Routine Description:

    Called by SCM when COM+ process revokes its activator registration.

Arguments:

    None

Return Value:

    none.

--*/
{
    gpServerLock->LockExclusive();

    ScmProcessReg *pResult = _pScmProcessReg;
	
    // Even if this process was a new-style surrogate process, _pScmProcessReg
    // may already be NULL here.   See bug 26676.  So we don't assert anymore
    // that _pScmProcessReg is non-NULL.
    // ASSERT(_pScmProcessReg);

    _pScmProcessReg = NULL;

    gpServerLock->UnlockExclusive();

    return pResult;
}

void CProcess::RevokeProcessReg()
/*++

Routine Description:

    Called during rundown to let SCM know that the COM+ process has died.

  CODEWORK: This needs to be defined.

Arguments:

    None

Return Value:

    none.

--*/
{
}

RPC_BINDING_HANDLE
CProcess::GetBindingHandle(
                          void
                          )
/*++

Routine Description:

    If necessary, this function allocates a binding handle
    back to process.  It used either mswmsg or ncalrpc depending
    on the apartmentness of the process.

Arguments:

    None

Return Value:

    Binding Handle, NULL if no valid handle.

--*/
{
    RPC_STATUS status;

    CMutexLock lock(&gcsFastProcessLock);

    // Find ncalrpc binding.
    PWSTR pwstr = _pdsaLocalBindings->aStringArray;
    while (*pwstr)
    {
        if (*pwstr == ID_LPC)
        {
            break;
        }
        pwstr = OrStringSearch(pwstr, 0) + 1;
    }

    if (*pwstr == 0)
    {
        KdPrintEx((DPFLTR_DCOMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "OR: Unable to find ncalrpc binding to server: %p %p\n",
                   _pdsaLocalBindings,
                   this));

        ASSERT(0);
        return NULL;
    }

    return GetBinding(pwstr);
}

void
CProcess::EnsureRealBinding(
                           void
                           )
/*++

Routine Description:

    If necessary, this function allocates a binding handle
    back to process.

    Note: Called with the server lock held -OR- from an OXID
    with and extra reference which keeps this process alive.

Arguments:

    None

Return Value:

    None

--*/
{
    CMutexLock lock(&gcsFastProcessLock);

    if (0 == _hProcess)
    {
        _hProcess = GetBindingHandle();
        _fCacheFree = TRUE;
    }
}

RPC_BINDING_HANDLE
CProcess::AllocateBinding(
                         void
                         )
/*++

Routine Description:

    Allocates a unique binding handle for a call back
    to the process.  This binding handle will not be
    used by another thread until it is freed.

Arguments:

    None

Return Value:

    0 - failure

    non-zero - a binding handle to use.

--*/
{

    EnsureRealBinding();

    if (_hProcess == 0)
    {
        return(0);
    }

    CMutexLock lock(&gcsFastProcessLock);

    ASSERT(_hProcess);

    if (_fCacheFree)
    {
        _fCacheFree = FALSE;
        return(_hProcess);
    }

    RPC_BINDING_HANDLE h;
    RPC_STATUS status;

    status = RpcBindingCopy(_hProcess, &h);

    if (status != RPC_S_OK)
    {
        return(0);
    }

    return(h);
}


void
CProcess::FreeBinding(
                     IN RPC_BINDING_HANDLE hBinding
                     )
/*++

Routine Description:

    Frees a binding back to the process.

Arguments:

    hBinding - A binding back to the process previously
        allocated with AllocateBinding().

Return Value:

    None

--*/
{
    if (hBinding == _hProcess)
    {
        _fCacheFree = TRUE;
    }
    else
    {
        RPC_STATUS status = RpcBindingFree(&hBinding);
        ASSERT(status == RPC_S_OK);
    }
}

RPC_STATUS
CProcess::RundownOids(
                     IN CServerOxid* pOwningOxid,
                     IN ULONG cOids,
                     IN CServerOid* aOids[]
                     )
/*++

Routine Description:

    Issues an async call to the process which will rundown the OIDs.
    This is called from an OXID which will be kept alive during the
    whole call.  Multiple calls maybe made to this function by
    one or more OXIDs at the same time.  The callback itself is
    an ORPC call, ie is must have THIS and THAT pointers.

Arguments:

    pOwningOxid - oxid that owns the specified oids.   This oxid should
        be registered from this process.

    cOids - The number of entries in aOids and afRundownOk

    aOids - An array of CServerOid's to rundown.  The OIDs must
        all be owned by pOwningOxid.  The caller will have already
        called SetRundown(TRUE) on each one.

Return Value:
	
    RPC_S_OK - the async call was issued successfully

    other -- error occurred.  call was not issued.

--*/
{
    ULONG i;
    error_status_t status = OR_OK;
    RPC_BINDING_HANDLE hBinding;
    OID aScalarOids[MAX_OID_RUNDOWNS_PER_CALL];

    ASSERT(cOids > 0 && aOids);
    ASSERT(cOids <= MAX_OID_RUNDOWNS_PER_CALL);
    ASSERT(IsOwner(pOwningOxid));

    // Callers must be aware that the lock will be released upon return
    ASSERT(gpServerLock->HeldExclusive());
    gpServerLock->UnlockExclusive();

    // This process will be held alive by the OXID calling
    // us since it has an extra reference.
	
    //
    // Allocate async structure and zero it out
    //
    ASYNCRUNDOWNOID_STUFF* pArgs = new ASYNCRUNDOWNOID_STUFF;
    if (!pArgs)
        return OR_NOMEM;

    ZeroMemory(pArgs, sizeof(ASYNCRUNDOWNOID_STUFF));

    //
    // Initialize async structure
    //
    pArgs->dwSig = ASYNCRUNDOWNOID_SIG;
    pArgs->pProcess = this;      // will take ref below after issuing call
    pArgs->pOxid = pOwningOxid;  // will take ref below after issuing call
    pArgs->cOids = cOids;
    CopyMemory(pArgs->aOids, aOids, cOids * sizeof(CServerOid*));   
    
    //
    // Fill in the numeric oid values
    // 
    ZeroMemory(aScalarOids, sizeof(OID) * MAX_OID_RUNDOWNS_PER_CALL);
    for (i = 0; i < cOids; i++)
    {
        ASSERT(pArgs->aOids[i]);
        ASSERT(pArgs->aOids[i]->IsRunningDown());
        ASSERT(pArgs->aOids[i]->GetOxid() == pOwningOxid);
        aScalarOids[i] = pArgs->aOids[i]->Id();
    }
    
    //
    // Allocate binding handle
    //
    status = OR_NOMEM;  // assume no mem
    hBinding = AllocateBinding();
    if (hBinding)
    {
        IPID ipidUnk = pOwningOxid->GetIPID();
        status = RpcBindingSetObject(hBinding, &ipidUnk);
        if (status == RPC_S_OK)
        {
            status = RpcAsyncInitializeHandle(&(pArgs->async), 
                                              sizeof(pArgs->async));
        }
    }
    
    //
    // Check for errors
    //
    if (status != RPC_S_OK)
    {
        if (hBinding) FreeBinding(hBinding);
        delete pArgs;
        return status;
    }

    //
    // Save the binding handle
    //
    pArgs->hBinding = hBinding;

    //
    // Init parts of the RPC_ASYNC_STATE struct that we care about
    //
    pArgs->async.UserInfo = pArgs;
    pArgs->async.Event = RpcCallComplete;
    pArgs->async.NotificationType = RpcNotificationTypeCallback;
    pArgs->async.u.NotificationRoutine = CProcess::AsyncRundownReturnNotification;

    //
    // Initialize other params
    //
    pArgs->orpcthis.version.MajorVersion = COM_MAJOR_VERSION;
    pArgs->orpcthis.version.MinorVersion = COM_MINOR_VERSION;
    pArgs->orpcthis.flags                = ORPCF_LOCAL;
    pArgs->orpcthis.reserved1            = 0;
    pArgs->orpcthis.extensions           = NULL;
    pArgs->callIDHint                    = AllocateCallId(pArgs->orpcthis.cid);
    pArgs->localthis.dwClientThread      = 0;
    pArgs->localthis.dwFlags             = LOCALF_NONE;
    pArgs->orpcthat.flags                = 0;
    pArgs->orpcthat.extensions           = 0;

    //
    // Take an extra reference on the owning oxid and ourself.
    // These references will be released either on the call
    // return notification, or on the failure path below.
    //
    pOwningOxid->Reference();
    this->Reference();  // non-client ref, will not stop rundown

    //
    // Finally, issue the call.  Note that this is an async call
    // from our perspective, but is a synchronous ORPC call from
    // the server's perspective.
    //
    status = RawRundownOid(
                          &(pArgs->async),
                          pArgs->hBinding,
                          &(pArgs->orpcthis),
                          &(pArgs->localthis),
                          &(pArgs->orpcthat),
                          pArgs->cOids,
                          aScalarOids,
                          pArgs->aRundownStatus
                          );
    if (status != RPC_S_OK)
    {
        // Call failed, so cleanup before returning.  Caller will
        // handle the failure semantics for the oids.
        FreeBinding(pArgs->hBinding);
        FreeCallId(pArgs->callIDHint);
        delete pArgs;

        //
        // Must hold gpServerLock in order to call Release.
        //
        ASSERT(!gpServerLock->HeldExclusive());
        gpServerLock->LockExclusive();
        
        pOwningOxid->Release();
        this->Release();

        gpServerLock->UnlockExclusive();
        ASSERT(!gpServerLock->HeldExclusive());
    }

    return status;
}

void 
CProcess::RundownOidNotify(RPC_BINDING_HANDLE hBinding,
                           CServerOxid* pOwningOxid,                      
                           ULONG cOids, 
                           CServerOid* aOids[], 
                           BYTE aRundownStatus[],
                           HRESULT hrReturn)
/*++

Routine Description:

    This is the callback notification function that is invoked when
    async oid rundown calls are completed. 

Arguments:

    hBinding -- binding handle used to make the call

    pOwningOxid -- owning oxid of the oids we tried to rundown.

    cOids -- count of oids

    aOids -- array of oids

    aRundownStatus -- array of individual status rundowns for each oid

    hrReturn -- return value from the function

Return Value:
    
    void

--*/
{
    ULONG i;
    error_status_t status = OR_OK;

    ASSERT(hBinding);
    ASSERT(pOwningOxid);
    ASSERT((cOids > 0) && aOids && aRundownStatus);

    //
    // Free the binding
    //
    FreeBinding(hBinding);

    // 
    // If destination oxid\apartment was not found, mark all
    // oids for rundown.
    //
    if (hrReturn == RPC_E_DISCONNECTED)
    {
        KdPrintEx((DPFLTR_DCOMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "OR: Rundown returned disconnected\n"));

        for (i = 0; i < cOids; i++)
        {
            aRundownStatus[i] = ORS_OK_TO_RUNDOWN;
        }
        hrReturn = RPC_S_OK;
    }

    //
    // In case of any other error, don't rundown the oids
    //
    if (hrReturn != RPC_S_OK)
    {
        for (i = 0; i < cOids; i++)
        {
            aRundownStatus[i] = ORS_DONTRUNDOWN;
        }
    }

    //
    // Notify the server oxid of the results
    //

    gpServerLock->LockExclusive();

    pOwningOxid->ProcessRundownResults(
                                cOids,
                                aOids,
                                aRundownStatus
                                );

    gpServerLock->UnlockExclusive();

    return;
}

void RPC_ENTRY
CProcess::AsyncRundownReturnNotification(
                                   IN RPC_ASYNC_STATE* pAsync,
                                   IN void* pContext,
                                   IN RPC_ASYNC_EVENT Event
                                   )
/*++

Routine Description:

    This is the callback notification function that is invoked when
    async rundown calls are completed.  It unpacks the necessary
    stuff from the async args struct, forwards them on to
    RundownOidNotify, and does other necessary cleanup.

Arguments:

    pAsync -- pointer to the async rpc state struct

    pContext -- rpc thingy, we ignore it

    Event -- rpc thingy, we ignore it

Return Value:
    
    void

--*/
{
    RPC_STATUS status;
    HRESULT hrRetVal;
    ASYNCRUNDOWNOID_STUFF* pArgs;

    pArgs = (ASYNCRUNDOWNOID_STUFF*) 
            (((char*)pAsync) - offsetof(ASYNCRUNDOWNOID_STUFF, async));
    
    ASSERT(pArgs->async.UserInfo = pArgs);
    ASSERT(pArgs->dwSig == ASYNCRUNDOWNOID_SIG);
    ASSERT(pArgs->hBinding);
    ASSERT(pArgs->pProcess);
    ASSERT(pArgs->pOxid);
    ASSERT(pArgs->cOids > 0);

    //
    // Free the call id
    //
    FreeCallId(pArgs->callIDHint);
	
    // Complete the call.  Since we've asked for a direct callback upon
    // completion, we should never get back RPC_S_ASYNC_CALL_PENDING, so
    // we assert on this.  hrRetVal is not necessarily S_OK.
    status = RpcAsyncCompleteCall(&(pArgs->async), &hrRetVal);
    ASSERT(status != RPC_S_ASYNC_CALL_PENDING);

    //
    // Notify the process object that the call has returned
    //
    pArgs->pProcess->RundownOidNotify(
                           pArgs->hBinding, // process frees the binding
                           pArgs->pOxid,
                           pArgs->cOids,
                           pArgs->aOids,
                           pArgs->aRundownStatus,
                           (status == RPC_S_OK) ? hrRetVal : status
                           );

    //
    // Cleanup other stuff from the call
    // 
    if (status == RPC_S_OK && pArgs->orpcthat.extensions)
    {
        for (ULONG i = 0; i < pArgs->orpcthat.extensions->size; i++)
        {
            MIDL_user_free(pArgs->orpcthat.extensions->extent[i]);
        }
        MIDL_user_free(pArgs->orpcthat.extensions->extent);
        MIDL_user_free(pArgs->orpcthat.extensions);
    }
                                       
    //
    // Release the references on ourselves and the server  
    // oxid.  Must hold gpServerLock while calling Release.
    // 
    gpServerLock->LockExclusive();

    pArgs->pProcess->Release();
    pArgs->pOxid->Release();
    
    gpServerLock->UnlockExclusive();

    delete pArgs;

    return;
}

ORSTATUS
CProcess::UseProtseqIfNeeded(
                            IN USHORT cClientProtseqs,
                            IN USHORT aClientProtseqs[]
                            )
{
    ORSTATUS status;
    RPC_BINDING_HANDLE hBinding;
    UUID NullUuid = {0};
    USHORT wProtseqTowerId;

    KdPrintEx((DPFLTR_DCOMSS_ID,
               DPFLTR_WARNING_LEVEL,
               "OR: UseProtseqIfNeeded ==> %d\n",
               cClientProtseqs));

    // This process will be held alive by the OXID calling
    // us since it has an extra reference.

    CMutexLock callback(&_csCallbackLock);

    CMutexLock process(&gcsFastProcessLock);

    // Another thread may have used the protseq in the mean time.

    ASSERT(_pdsaLocalBindings);

    KdPrintEx((DPFLTR_DCOMSS_ID,
               DPFLTR_WARNING_LEVEL,
               "OR: FindMatchingProtSeq from local bindings\n"));

    // ronans - initially _pdsaLocalBindings will hold bindings which have been set
    // by when the server called ServerAllocateOxidAndOids .. usually only local
    // protseqs LRPC or WMSG at that point.
    wProtseqTowerId = FindMatchingProtseq(cClientProtseqs,
                                          aClientProtseqs,
                                          _pdsaLocalBindings->aStringArray
                                         );

    if (0 != wProtseqTowerId)
    {
        KdPrintEx((DPFLTR_DCOMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "OR: Found protseq in local bindings\n"));

        return(OR_OK);
    }

    // No protseq shared between the client and the OXIDs' server.
    // Find a matching protseq.

    // check if its a solitary local protocol sequence LRPC or WMSG
    if (cClientProtseqs == 1 && IsLocal(aClientProtseqs[0]))
    {
        // if so - get it
        wProtseqTowerId = aClientProtseqs[0];
        ASSERT(wProtseqTowerId);
    }
    else
    // we have multiple protseqs - presumed to be nonlocal
    {
        // ensure we have custom protseq information
        if (!_fReadCustomProtseqs)
        {
            // use local temporary to avoid holding process lock
            DUALSTRINGARRAY *pdsaCustomProtseqs = NULL;

            // we'll only try this once - so set the flag now to avoid
            // race conditions
            _fReadCustomProtseqs = TRUE;

            process.Unlock();

            hBinding = AllocateBinding();

            if (0 == hBinding)
                return(OR_NOMEM);
            status = RpcBindingSetObject(hBinding, &NullUuid);

            // get the information from the Object server
            if (status == RPC_S_OK)
            {
                status = ::GetCustomProtseqInfo(hBinding,cMyProtseqs, aMyProtseqs, &pdsaCustomProtseqs);
                KdPrintEx((DPFLTR_DCOMSS_ID,
                           DPFLTR_WARNING_LEVEL,
                           "GetCustomProtseqInfo - status : %ld\n",
                           status));
            }

            // relock the process object
            process.Lock();

            if (status == RPC_S_OK)
            {
                if (pdsaCustomProtseqs)
                {
                    ASSERT(dsaValid(pdsaCustomProtseqs));
                }
                _pdsaCustomProtseqs = pdsaCustomProtseqs;
            }
            FreeBinding(hBinding);
        }

        USHORT i,j;

        // if there is custom protseq information - scan it for a match
        if (_pdsaCustomProtseqs)
        {
            KdPrintEx((DPFLTR_DCOMSS_ID,
                       DPFLTR_WARNING_LEVEL,
                       "OR: Using custom protseq information\n"));

            wProtseqTowerId = FindMatchingProtseq(cClientProtseqs,
                                                  aClientProtseqs,
                                                  _pdsaCustomProtseqs->aStringArray);

            if (wProtseqTowerId)
            {
                ASSERT(FALSE == IsLocal(wProtseqTowerId));
            }
        }
        else
        // we don't have custom protseqs so use
        // the standard ones
        {
            KdPrintEx((DPFLTR_DCOMSS_ID,
                       DPFLTR_WARNING_LEVEL,
                       "OR: Using standard protseq information\n"));

            for (i = 0; i < cClientProtseqs && wProtseqTowerId == 0; i++)
            {
                for (j = 0; j < cMyProtseqs; j++)
                {
                    if (aMyProtseqs[j] == aClientProtseqs[i])
                    {
                        ASSERT(FALSE == IsLocal(aMyProtseqs[j]));

                        wProtseqTowerId = aMyProtseqs[j];
                        break;
                    }
                }
            }
        }
    }

    if (0 == wProtseqTowerId)
    {
        // No shared protseq, must be a bug since the client managed to call us.
        ASSERT(0 && "No shared protseq, must be a bug since the client managed to call us");
#if DBG
        if (cClientProtseqs == 0)
            KdPrintEx((DPFLTR_DCOMSS_ID,
                       DPFLTR_WARNING_LEVEL,
                       "OR: Client OR not configured to use remote protseqs\n"));
        else
            KdPrintEx((DPFLTR_DCOMSS_ID,
                       DPFLTR_WARNING_LEVEL,
                       "OR: Client called on an unsupported protocol:"
                       "%d %p %p \n",
                       cClientProtseqs,
                       aClientProtseqs,
                       aMyProtseqs));
#endif

        return(OR_NOSERVER);
    }

    process.Unlock();

    DUALSTRINGARRAY *pdsaBinding = 0;
    DUALSTRINGARRAY *pdsaSecurity = 0;

    hBinding = AllocateBinding();

    if (0 == hBinding)
    {
        return(OR_NOMEM);
    }

    status = RpcBindingSetObject(hBinding, &NullUuid);

    if (status == RPC_S_OK)
    {
        status = ::UseProtseq(hBinding,
                              wProtseqTowerId,
                              &pdsaBinding,
                              &pdsaSecurity);
    }

    KdPrintEx((DPFLTR_DCOMSS_ID,
               DPFLTR_WARNING_LEVEL,
               "OR: Lazy use protseq: %S (from towerid) in process %p - %d\n",
               GetProtseq(wProtseqTowerId),
               this,
               status));

    // Update this process' state to include the new bindings.

    if (!dsaValid(pdsaBinding))
    {
        if (pdsaBinding)
        {
            KdPrintEx((DPFLTR_DCOMSS_ID,
                       DPFLTR_WARNING_LEVEL,
                       "OR: Use protseq returned an invalid dsa: %p\n",
                       pdsaBinding));
        }

        status = OR_NOMEM;
    }
    else
    {
        ASSERT(_pdsaLocalBindings);
        ASSERT(status == RPC_S_OK);
        status = ProcessBindings(pdsaBinding, pdsaSecurity);
    }

    if (pdsaBinding != NULL)
        MIDL_user_free(pdsaBinding);
    if (pdsaSecurity != NULL)
        MIDL_user_free(pdsaSecurity);

    FreeBinding(hBinding);
    return(status);
}


ORSTATUS CProcess::UpdateResolverBindings(DWORD64 dwBindingsID, DUALSTRINGARRAY* pdsaResolverBindings)
/*++

Routine Description:

    This function does the work of calling back into the server process 
    to tell it to update its local OR bindings.   It also updates our
    cached local\remote bindings for this process object.

Arguments:

    dwBindingsID -- unique id of pdsaResolverBindings.  We use this
        to resolve what to do when async calls arrive\return in an 
        out-of-order fashion.

    pdsaResolverBindings -- ptr to the new resolver bindings

Return Value:

    OR_OK -- success
    OR_NOMEM -- out of memory
    other -- unexpected error

--*/
{
    ORSTATUS status;
    RPC_BINDING_HANDLE hBinding;
    UUID NullUuid = {0};
    DUALSTRINGARRAY* pdsaBinding = NULL;
    DUALSTRINGARRAY* pdsaSecurity = NULL;
    BINDINGS_UPDATE_CALLBACK_STUFF* pArgs = NULL;
        
    // undone figure out why we need this callback lock thingy
    CMutexLock callback(&_csCallbackLock);

    if (dwBindingsID <= _dwCurrentBindingsID)
    {
        // The supplied bindings are the same or older than 
        // what we already have, so ignore them.
        return OR_OK;
    }
    
    // if the server has not yet called _ServerAllocateOxidAndOids
    // then we will not yet have cached binding info for them, and
    // hence will be unable to construct a binding handle.  In
    // this case we simply do not update that process.  If this 
    // happens we will give them the new bindings later, if and
    // when they do call _SAOAO.
    if (!_pdsaLocalBindings)
    {
        _dwFlags |= PROCESS_NEEDSBINDINGS;
        return OR_OK;
    }
    
    pArgs = new BINDINGS_UPDATE_CALLBACK_STUFF;
    if (!pArgs)
        return OR_NOMEM;

    ZeroMemory(pArgs, sizeof(BINDINGS_UPDATE_CALLBACK_STUFF));

    // Allocate binding.  We must hold onto the binding handle
    // until the async call has completed.
    status = OR_NOMEM;
    hBinding = AllocateBinding();
    if (hBinding)
    {
        status = RpcBindingSetObject(hBinding, &NullUuid);
        if (status == RPC_S_OK)
        {
            status = RpcAsyncInitializeHandle(&(pArgs->async), sizeof(pArgs->async));
        }
    }
    
    // Check for errors
    if (status != RPC_S_OK)
    {
        if (hBinding) FreeBinding(hBinding);
        delete pArgs;
        return status;
    }
    
    // Init parts of the RPC_ASYNC_STATE struct that we care about
    pArgs->async.UserInfo = pArgs;
    pArgs->async.Event = RpcCallComplete;
    pArgs->async.NotificationType = RpcNotificationTypeCallback;
    pArgs->async.u.NotificationRoutine = CProcess::AsyncRpcNotification;

    // Init other stuff
    pArgs->dwSig = BINDINGUPDATESTUFF_SIG;
    pArgs->pProcess = this;
    pArgs->dwBindingsID = dwBindingsID;
    pArgs->hBinding = hBinding;
    
    // Take a non-client reference (will not stop rundown) on
    // ourselves, to be owned implicitly by the async call
    this->Reference();
    
	// Issue async call
    status = ::UpdateResolverBindings(
                    &(pArgs->async),
                    _hProcess,  
                    pdsaResolverBindings,
                    &(pArgs->dwBindingsID),
                    &(pArgs->pdsaNewBindings),
                    &(pArgs->pdsaNewSecurity));
    if (status != RPC_S_OK)
    {
        // If we get anything other than RPC_S_OK back, that
        // means we will not receive a call completion notif-
        // ication.   So, we need to cleanup everything up
        // right here in that case.
        FreeBinding(hBinding);
        this->Release();
        delete pArgs;
    }
    else
    {
        DWORD dwAUO = (DWORD)InterlockedIncrement((PLONG)&_dwAsyncUpdatesOutstanding);

        // This assert is somewhat arbitrary, if it fires there are
        // one of two things wrong:  1) the machine is so totally
        // overstressed that the async calls are piling up and are not
        // getting enough cpu time to complete; or 2) more likely, the
        // process in question is deadlocked somehow.
        ASSERT(dwAUO < 5000);
    }

    return status;
}

void 
CProcess::BindingsUpdateNotify(RPC_BINDING_HANDLE hBinding,
							   DWORD64 dwBindingsID,
                               DUALSTRINGARRAY* pdsaNewBindings,
                               DUALSTRINGARRAY* pdsaSecBindings)
/*++

Routine Description:

    Private helper function.   This function is used to process a
    successful return from an async call to the process to update
    the bindings.

Arguments:
    
    hBinding -- binding handle used to make the call.  We now own it,
        either to keep or to cleanup.

    dwBindingsID -- unique id of the updated bindings.  We use this
        to resolve what to do when async calls arrive\return in an 
        out-of-order fashion.

    pdsaNewBindings -- new bindings in use by the process.  We now own
         it, either to keep or to cleanup

    pdsaSecBindings -- new security bindings in use by the process.  We 
         now own it, either to keep or to cleanup.

Return Value:

    void

--*/
{
    RPC_STATUS status;
    CMutexLock callback(&_csCallbackLock);

    // Always free the binding
    FreeBinding(hBinding);

    // Only process the out-params if they contain newer bindings
    // than what we currently have cached.
    if ((dwBindingsID > _dwCurrentBindingsID) &&
        pdsaNewBindings && 
        pdsaSecBindings)
    {
        // The process has the right bindings, so update our counter
        // no matter what happens in ProcessBindings.
        _dwCurrentBindingsID = dwBindingsID;

        status = ProcessBindings(pdsaNewBindings, pdsaSecBindings);
    }

    // Cleanup allocated out-params
    if (pdsaNewBindings != NULL)
        MIDL_user_free(pdsaNewBindings);
    if (pdsaSecBindings != NULL)
        MIDL_user_free(pdsaSecBindings);
	
    InterlockedDecrement((PLONG)&_dwAsyncUpdatesOutstanding);

    return;
}


void RPC_ENTRY 
CProcess::AsyncRpcNotification(RPC_ASYNC_STATE* pAsync,
                               void* pContext,
                               RPC_ASYNC_EVENT Event)
/*++

Routine Description:

    RPC calls this static function when an async call to a server 
    process returns.   

Arguments:

    pAsync -- pointer to the async rpc state struct

    pContext -- rpc thingy, we ignore it


Return Value:

    void

--*/
{
    RPC_STATUS status;
    HRESULT hrRetVal;
    BINDINGS_UPDATE_CALLBACK_STUFF* pArgs;

    pArgs = (BINDINGS_UPDATE_CALLBACK_STUFF*) 
            (((char*)pAsync) - offsetof(BINDINGS_UPDATE_CALLBACK_STUFF, async));
    
    ASSERT(pArgs->async.UserInfo = pArgs);
    ASSERT(pArgs->dwSig == BINDINGUPDATESTUFF_SIG);
    ASSERT(pArgs->hBinding); 
    ASSERT(pArgs->pProcess); 
    ASSERT(pArgs->dwBindingsID > 0); 

    // Complete the call.  Since we've asked for a direct callback upon
    // completion, we should never get back RPC_S_ASYNC_CALL_PENDING, so
    // we assert on this.  Otherwise, both RPC and the server need to
    // return success before we do further processing.
    status = RpcAsyncCompleteCall(&(pArgs->async), &hrRetVal);
    ASSERT(status != RPC_S_ASYNC_CALL_PENDING);
    if ((status == RPC_S_OK) && (hrRetVal == S_OK))
    {
        // Deliver notification to process object.  Process may have
        // already been rundown, that's okay.   BindingsUpdateNotify will
        // own/cleanup the params, see code.
        pArgs->pProcess->BindingsUpdateNotify(pArgs->hBinding,
                                    pArgs->dwBindingsID,
                                    pArgs->pdsaNewBindings,
                                    pArgs->pdsaNewSecurity);
    }

    gpServerLock->LockExclusive();

    // This may be the last release on the process object
    pArgs->pProcess->Release(); 

    gpServerLock->UnlockExclusive();
    
    delete pArgs;

    return;
}




CBList *gpProcessList = 0;

CProcess *
ReferenceProcess(
                IN PVOID key,
                IN BOOL fNotContext)
/*++

Routine Description:

    Used to find a CProcess and get a reference on it

Arguments:

    key - The dword key of the process allocated in _Connect.
    fNotContext - Normally the key is stored as a context handle
        which means locking is unnecessary.  There is an extra
        refernce which is released buring context rundown which
        means managers using the key as a context handle
        a) Don't need to lock the process and
        b) Don't need to call ReleaseProcess()

Return Value:

    0 - invalid key
    non-zero - The process.

--*/
{
    ASSERT(gpProcessList != 0);
    CProcess *pProcess;

    gpProcessListLock->LockShared();
    
    if (gpProcessList->Member(key) == FALSE)
    {
      gpProcessListLock->UnlockShared();
      return(0);
    }

    pProcess = (CProcess *)key;

    if (fNotContext)
    {
        pProcess->ClientReference();
    }

    gpProcessListLock->UnlockShared();
    return(pProcess);
}

void ReleaseProcess(CProcess *pProcess)
/*++

Routine Description:

    Releases a pProcess object.  This should only be called when
    a process object has been referenced with the fNotContext == TRUE.

Arguments:

    pProcess - the process to release.  May actually be deleted.

Return Value:

    None

--*/
{
    gpProcessListLock->LockExclusive();

    if (pProcess->ClientRelease() == 0)
    {
        // Process has been completly released the process,
        // we'll remove it from the list now since we
        // already have the lock.  It may not have been added,
        // so this may fail.

        PVOID t = gpProcessList->Remove(pProcess);
        ASSERT(t == pProcess || t == 0);

        gpProcessListLock->UnlockExclusive();

        // The client process owns one real reference which will be
        // released in Rundown().

        pProcess->Rundown();
    }
    else
    {
      gpProcessListLock->UnlockExclusive();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\objex\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Revision History:

!ENDIF

MSC_WARNING_LEVEL=/W3 /WX

C_DEFINES=-DNTENV -DWIN32RPC -DNTWIN32RPC -DUNICODE -DMSWMSG

UMTYPE=console
UMAPPL=
UMTEST=t*uid
UMLIBS=$(SDK_LIB_PATH)\rpcrt4.lib \
       $(SDK_LIB_PATH)\ntdll.lib \
       $(SDK_LIB_PATH)\libcmt.lib \
       $(O)\locks.obj \
       $(O)\callid.obj

UMRES=

INCLUDES=..;..\..
INCLUDES=$(INCLUDES);..\..\..\idl\public\$(DEST_TREE)\$(O)
INCLUDES=$(INCLUDES);..\..\..\idl\internal\$(DEST_TREE)\$(O)
INCLUDES=$(INCLUDES);..\..\..\idl\private\$(DEST_TREE)\$(O)
INCLUDES=$(INCLUDES);..\..\..\ih
INCLUDES=$(INCLUDES);..\..\..\com\rot
INCLUDES=$(INCLUDES);..\..\olescm

TARGETPATH=..\..\lib\$(DEST_TREE)\$(_OBJ_DIR)
TARGETLIBS=

PRECOMPILED_INCLUDE=..\or.hxx

SOURCES=                \
        ..\locks.cxx    \
        ..\misc.cxx     \
        ..\callid.cxx   \
        ..\string.cxx   \
        ..\plist.cxx    \
        ..\blist.cxx    \
        ..\gentable.cxx \
        ..\mid.cxx      \
        ..\token.cxx    \
        ..\process.cxx  \
        ..\objex.cxx    \
        ..\orclnt.cxx   \
        ..\orsvr.cxx    \
        ..\worker.cxx   \
        ..\manager.cxx
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\objex\shrmem\chicago.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    David Plummer (davepl)   19-Mar-94

        Modifed by via awk to include global project include file
        and to wrap precompiled header line within a conditional
        that can be set in this include file.

    Drew Bliss (DrewB) 21-Dec-1993

!ENDIF

TARGETPATH= ..\..\lib\chicago

MAJORCOMP= cairole
MINORCOMP= com

!include ..\..\..\..\..\chicago.inc

INCLUDES= ..\..; \
	  ..\..\dcom95; \
	  $(OLEDIR)\ih; \
	  $(OLEDIR)\com\inc; \
	  $(OLEDIR)\dcom95\inc; \
	  $(OLEDIR)\common\chicago; \
	  $(OLEDIR)\stg\h; \
          $(OLEDIR)\idl\public\chicago\obj; \
	  $(OLEDIR)\idl\internal\chicago\obj; \
	  $(OLEDIR)\stg\exp; \
	  $(OLEDIR)\com\dcomrem; \
	  $(OLEDIR)\dcomss; \
	  $(OLEDIR)\dcomss\olescm

C_DEFINES= \
                $(C_DEFINES)          	\
                -DDCOM                  \
                -DSHRMEM_OBJEX

PRECOMPILED_INCLUDE=  ..\..\or.hxx
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\objex\shrmem\daytona.inc ===
!IF "$(NTDEBUG)" != "ntsd"
CXXCPP_OPTIONS=-DDBG=0
!else
CXXCPP_OPTIONS=-DDBG=1
DEBUG_DEFINES=-DLDEBUG
MSC_OPTIMIZATION=/Od
!endif

MAJORCOMP= cairole
MINORCOMP= dcom95


#
# The following includes a global include file defined at the
# base of the project for all components
#

!include ..\..\..\..\..\daytona.inc

INCLUDES= ..; \
          ..\..; \
          ..\..\dcom95; \
          $(OLEDIR)\ih; \
          $(OLEDIR)\com\inc; \
          $(OLEDIR)\common\daytona; \
          $(OLEDIR)\stg\h; \
          $(OLEDIR)\idl\public\daytona\obj; \
	  $(OLEDIR)\idl\internal\daytona\obj; \
          $(OLEDIR)\stg\exp; \
          $(OLEDIR)\com\dcomrem; \
          $(OLEDIR)\dcomss

C_DEFINES= \
                $(C_DEFINES)          	\
                -D_REMOTE_OR_           \
		-DSHRMEM_OBJEX

PRECOMPILED_INCLUDE=  ..\..\or.hxx
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\objex\worker.cxx ===
/*++

Copyright (c) 1995-1996 Microsoft Corporation

Module Name:

    Worker.cxx

Abstract:

    Backgroup activies releated to running down and cleaning up OR and pinging
    remote OR's are handled here.

Author:

    Mario Goertzel    [MarioGo]

Revision History:

    MarioGo     03-02-95    Bits 'n pieces
    MarioGo     01-18-96    Locally unique IDs

--*/

#include <or.hxx>

static CInterlockedInteger cTaskThreads(0);

#if DBG_DETAIL
extern "C" void printf(char *, ...);
#endif

#define TASKTHREAD_STACK_PAGES  3

#define SECS_BETWEEN_FLUSHES 30

typedef enum {  PWR_SUSPENDED, PWR_RUNNING } PWR_STATE;

PWR_STATE gPowerState = PWR_RUNNING;

void OLESCMBindingHandleFlush();

#if _MSC_FULL_VER >= 13008827
#pragma warning(push)
#pragma warning(disable:4715)			// Not all control paths return (due to infinite loop)
#endif

DWORD WINAPI
ObjectExporterWorkerThread(LPVOID /* ignored */)
/*++

Routine Description:

    Main background thread for the object resolver.  This thread
    manages a number of background tasks:
        Cleaning up the client oxid cache.
        Running down un-pinged sets.
        Starting task threads to rundown server OIDs and ping sets.

    This thread must not block for a long time.  Task threads
    should be used for possibly blocking operations like remote
    pinging and rundown of OIDs.

Arguments:

    Ignored

Return Value:

    None - should never return.

--*/
{
    ORSTATUS status;
    CTime    now(0);
    CTime    timeout(0);
    CTime    delay(0);
    CTime    start(0);
    CTime    lastflush(0);
    BOOL     fCreateThread;
    SYSTEM_INFO si;

    // Retrieve system info so we can start task threads
    // with an appropriate initial stack size
    GetSystemInfo(&si);

    lastflush.SetNow();

    for(;;)
        {
        now.SetNow();
        delay = now;
        delay += BasePingInterval;

        // Cleanup old sets.
        //
        // Sets are usually cleaned up during processing of pings.  (As one set is
        // pinged, the next set will be checked to see if it needs to be rundown.)
        //
        // If there's exactly one set in the table, then it won't be run down except
        // by this thread.
        //
        // NOTE: Similar code in _SimplePing().

        gpServerLock->LockShared();

        ID setid = gpServerSetTable->CheckForRundowns();
        if (setid)
        {
            gpServerLock->ConvertToExclusive();

            if (gpServerSetTable->RundownSetIfNeeded(setid))
            {
                delay.SetNow();
            }

            gpServerLock->UnlockExclusive();
        }
        else
        {
            gpServerLock->UnlockShared();
        }

        //
        // Cleanup old Client OXIDs
        //
        if (gpClientOxidPList->PeekMin(timeout))
        {
            if (timeout < now)
            {
                CClientOxid *pOxid;
                CListElement *ple;

                gpClientLock->LockExclusive();

                while (ple = gpClientOxidPList->MaybeRemoveMin(now))
                {
                    pOxid = CClientOxid::ContainingRecord(ple);
                    delete pOxid;
                }
                gpClientLock->UnlockExclusive();

                delay.SetNow();
            }
            else
            {
                if (delay > timeout)
                {
                    delay = timeout;
                }
            }
        }

        //
        // Make sure pinging and rundowns are proceding
        //
        fCreateThread = FALSE;

        // We want to create an extra task thread if we've fallen
        // behind on pings.  As more threads are created the
        // requirements for "behind" become harder to meet.
        if (gpClientSetPList->PeekMin(timeout))
        {
            start = now;
            start += (BasePingInterval + 10*cTaskThreads);

            if (cTaskThreads == 0 || start < timeout)
            {
                fCreateThread = TRUE;
            }
            else
            {
                if (delay > start)
                {
                    delay = start;
                }
            }
        }

        // We want to create an extra task thread if we've fallen
        // behind in running down local objects.  As more threads are
        // created the requirements for "behind" become harder to meet.
        if (gpServerOidPList->PeekMin(timeout))
        {
            start = now;
            start -= 10*cTaskThreads;
            if (timeout < start)
            {
                fCreateThread = TRUE;
            }
            else
            {
                start = timeout;
                start += 2*10*cTaskThreads;
                if (delay > start)
                {
                    delay = start;
                }
            }
        }

        if (fCreateThread)
        {
            KdPrintEx((DPFLTR_DCOMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "OR: Creating additional task thread, we're behind..\n"));

            cTaskThreads++;

            DWORD tid;
            HANDLE hThread =  CreateThread(0,
                                           (si.dwPageSize * TASKTHREAD_STACK_PAGES),
                                           ObjectExporterTaskThread,
                                           0,
                                           0,
                                           &tid
                                           );
            if (0 != hThread)
            {
                CloseHandle(hThread);
            }
            else
            {
                cTaskThreads--;
            }
        }

#if DBG_DETAIL
        printf("================================================================\n"
               "ServerOxids: %d, ServerOids: %d, ServerSets: %d\n"
               "ClientOxids: %d, ClientOids: %d, ClientSets: %d\n"
               "Mids: %d, Processes %d, worker threads: %d\n"
               "Sleeping for %d seconds...\n",
               gpServerOxidTable->Size(),
               gpServerOidTable->Size(),
               gpServerSetTable->Size(),
               gpClientOxidTable->Size(),
               gpClientOidTable->Size(),
               gpClientSetTable->Size(),
               gpMidTable->Size(),
               gpProcessList->Size(),
               cTaskThreads,
               delay - now + 1
               );
#endif

        delay += 1;

        if (delay - lastflush > SECS_BETWEEN_FLUSHES)
        {       
            // Give olescm a chance to do other work
            OLESCMBindingHandleFlush();
            
            lastflush.SetNow();
        }

        delay.Sleep();
    }

   return(0);
}

#if _MSC_FULL_VER >= 13008827
#pragma warning(pop)
#endif


void 
NotifyCOMOnSuspend()
/*++

Routine Desciption

    Resets state and takes appropriate action when the machine
    goes into a standby (or, hibernate) state.

Arguments:

    none

Return Value:

    void

--*/
{
    ASSERT(gPowerState == PWR_RUNNING);

    // Just set the flag.  This will block any further
    // rundowns from happening from now until we get a
    // resume notification.
    gPowerState = PWR_SUSPENDED;

    return;
}


void 
NotifyCOMOnResume()
/*++

Routine Desciption

    Resets state and takes appropriate action when the machine
    starts running again after being in the standby/hibernate
    state.

Arguments:

    none

Return Value:

    void

--*/
{
    // We cannot assert here that we're suspended, since the machine
    // can suspend in critical situations w/o notifying us

    //
    // First reset all of the server pingset timers.
    //
    gpServerLock->LockExclusive();

    // After a resume, all ping sets get reset to zero
    gpServerSetTable->PingAllSets();

    gpServerLock->UnlockExclusive();

    //
    // Second and last, reset the power state so that future
    // rundowns will not be blocked.
    //
    gPowerState = PWR_RUNNING;

    return;
}



DWORD WINAPI
ObjectExporterTaskThread(LPVOID /* ignored */)
{
    CTime          now(0);
    CTime          delay(0);
    CTime          timeout(0);
    ORSTATUS       status;
    CListElement  *ple;
    CClientSet    *pSet;
    CServerOid    *pOid;

    enum {
         Idle,     // No work to do at all.
         Waiting,  // No work to do yet.
         Busy      // Did work this iteration.
         }     eState;

    for(;;)
	{
        now.SetNow();
        delay = now;
        delay += BasePingInterval;
        eState = Idle;

        // Ping remote sets.

        if (gpClientSetPList->PeekMin(timeout))
        {
            eState = Waiting;

            if (now >= timeout)
            {
                eState = Busy;

                ple = gpClientSetPList->MaybeRemoveMin(now);

                if (ple)
                {
                    // Actually ping the set

                    pSet = CClientSet::ContainingRecord(ple);

                    pSet->PingServer();

                    // Set maybe invalid now.
                }
            }
            else
            {
                // Not ready to ping yet.
                delay = timeout;
            }
        }

        //
        // Process server OID rundowns.  Only do this
        // if there's something to rundown, and the machine 
        // is not in the suspended state.
        //
        if (gPowerState == PWR_RUNNING &&
            gpServerOidPList->PeekMin(timeout))
        {
            if (eState == Idle)
                eState = Waiting;

            if (now >= timeout)
            {
                eState = Busy;

                gpServerLock->LockExclusive();

                CServerOid* apOid[MAX_OID_RUNDOWNS_PER_CALL];
                ULONG       cOids;

                ple = gpServerOidPList->MaybeRemoveMin(now);
				pOid = CServerOid::ContainingRecord(ple);

                if (ple && pOid->IsRunningDown() == FALSE)
                {
                    apOid[0] = pOid;
                    cOids = 1;
                    ASSERT(pOid->IsFreed() == FALSE);
                    ASSERT(pOid->IsPinned() == FALSE);
                    pOid->SetRundown(TRUE);

                    while(cOids < MAX_OID_RUNDOWNS_PER_CALL && pOid)
                    {
                        pOid = gpServerOidPList->MaybeRemoveMatchingOxid(now, apOid[0]);

                        if (pOid && pOid->IsRunningDown() == FALSE)
                        {
                            ASSERT(pOid->IsFreed() == FALSE);
                            ASSERT(pOid->IsPinned() == FALSE);
                            pOid->SetRundown(TRUE);
                            apOid[cOids] = pOid;
                            cOids++;
                        }
                    }

                    ASSERT(cOids < MAX_OID_RUNDOWNS_PER_CALL+1 && cOids >= 1);
                    ASSERT(apOid[0]->GetOxid() == apOid[cOids - 1]->GetOxid());
                
                    // Note: This call will unlock the server lock. While 
                    // this happens the oids maybe added, deleted, added
                    // and deleted, added and rundown from one or more sets.

                    CServerOxid* pOxid = apOid[0]->GetOxid();
                    pOxid->RundownOids(cOids, apOid);

                    // Assert RundownOids released the lock
                    ASSERT(!gpServerLock->HeldExclusive());                 
                }
                else
                {
                    gpServerLock->UnlockExclusive();
                }
            }
            else
            {
                // Not ready to rundown yet.
                if (delay > timeout)
                {
                    delay = timeout;
                }
            }
        }

        // Decide if this task thread should exit or sleep and loop.
        ASSERT(eState == Idle || eState == Busy || eState == Waiting);

        if ((eState == Idle) || (eState == Waiting && cTaskThreads > 2))
        {
            // No work or we're all caught up and have extra threads.
            cTaskThreads--;
            return(0);
        }
        else
        {
            if (eState == Waiting)
            {
                // Sleep until just after the next work item is ready.
                delay += 1;
                delay.Sleep();
            }
        }
    }

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\objex\string.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    String.cxx

Abstract:

    Methods of construction of various kinds of DUALSTRINGARRAYs.

Author:

    Mario Goertzel    [MarioGo]

Revision History:

    MarioGo     04-01-95    Bits 'n pieces
    MarioGO     01-??-96    STRINGARRAYs replaced by DUALSTRINGARRAYs

--*/

#include <or.hxx>
#include <mach.hxx>

static CONST WCHAR aCallbackSecurity[] = L"Security=Identification Dynamic True";
static CONST DWORD dwCallbackSecurityLength = sizeof(aCallbackSecurity)/sizeof(WCHAR);


HRESULT dsaAllocateAndCopy(DUALSTRINGARRAY** ppdsaDest, DUALSTRINGARRAY* pdsaSrc)
{
    ASSERT(ppdsaDest);
    ASSERT(pdsaSrc);
    ASSERT(dsaValid(pdsaSrc));
    
    *ppdsaDest = NULL;

    DWORD dwDSASize = sizeof(USHORT) + 
                      sizeof(USHORT) + 
                      (pdsaSrc->wNumEntries * sizeof(WCHAR));
    
    *ppdsaDest = (DUALSTRINGARRAY*)MIDL_user_allocate(dwDSASize);
    if (*ppdsaDest)
    {
        // copy in the string bindings
        memcpy(*ppdsaDest, pdsaSrc, dwDSASize);
        ASSERT(dsaValid(*ppdsaDest));
        return S_OK;
    }
    return E_OUTOFMEMORY;
}


RPC_BINDING_HANDLE
GetBinding(
          IN PWSTR pCompressedBinding
          )
{
    ASSERT(pCompressedBinding);

    PWSTR       pwstrStringBinding;
    PWSTR       pwstrProtseq = GetProtseq(*pCompressedBinding);
    PWSTR       pwstrT;
    RPC_STATUS  Status;
    RPC_BINDING_HANDLE bhReturn;
    BOOL        fLocal = FALSE;

    if (!pwstrProtseq)
    {
        return(0);
    }

    int size = OrStringLen(pwstrProtseq) + OrStringLen(pCompressedBinding);

    if (*pCompressedBinding == ID_LPC)
    {
        fLocal = TRUE;
        size += dwCallbackSecurityLength + 1; // +1 for ','
    }

    pwstrStringBinding = (PWSTR) alloca(size * sizeof(USHORT));
    if (!pwstrStringBinding)
    {
        return(0);
    }

    OrStringCopy(pwstrStringBinding, pwstrProtseq);
    pwstrT = OrStringSearch(pwstrStringBinding, 0);
    *pwstrT = L':';
    pwstrT++;
    *pwstrT = 0;
    OrStringCopy(pwstrT, pCompressedBinding + 1);

    if (fLocal)
    {
        // We assume we have an endpoint.

        pwstrT = OrStringSearch(pwstrT, 0);
        pwstrT--;
        if (*pwstrT != L']')
        {
            KdPrintEx((DPFLTR_DCOMSS_ID,
                       DPFLTR_WARNING_LEVEL,
                       "OR: Local string binding missing endpoint %S\n",
                       pwstrStringBinding));

            ASSERT(0);
            return(0);
        }

        *pwstrT = L',';
        pwstrT++;
        OrStringCopy(pwstrT, aCallbackSecurity);
        pwstrT = OrStringSearch(pwstrT, 0);
        *pwstrT = L']';
        *(pwstrT + 1) = 0;
    }

    Status =
    RpcBindingFromStringBinding( pwstrStringBinding,
                                 &bhReturn);

#if DBG
    if (Status != RPC_S_OK)
    {
        KdPrintEx((DPFLTR_DCOMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "OR: Unable to create binding for %S = %d\n",
                   pwstrStringBinding,
                   Status));
    }
#endif

    return(bhReturn);
}


RPC_BINDING_HANDLE
GetBindingToOr(
              IN PWSTR pwstrCompressedBinding
              )
/*++

Routine Description:

    Gets an RPC binding to a remote object resolver given
    a compressed string binding to the remote object resolver.

Arguments:

    pwstrCompressedBinding - a compressed string binding without an endpoint.

Return Value:

    0 - failed to allocate memory or RpcBindingFromStringBinding failed.

    non-NULL - completed okay

--*/
{
    PWSTR protseq, endpoint;
    PWSTR strbinding;
    size_t len;
    RPC_BINDING_HANDLE bh = 0;

    ASSERT(pwstrCompressedBinding);
    ASSERT(*pwstrCompressedBinding != 0);

    protseq  = GetProtseq(*pwstrCompressedBinding);
    endpoint = GetEndpoint(*pwstrCompressedBinding);

    if (0 == protseq || 0 == endpoint)
    {
        ASSERT(0);
        return(0);
    }

    len  = 4;  // ':' '[' ']' and '\0'
    len += OrStringLen(protseq);
    len += OrStringLen(endpoint);
    len += OrStringLen(&pwstrCompressedBinding[1]);

    strbinding = new USHORT[len];

    if (strbinding)
    {
        PWSTR pwstrT;

        OrStringCopy(strbinding, protseq);  // protseq

        pwstrT = OrStringSearch(strbinding, 0); // :
        *pwstrT = L':';
        pwstrT++;
        *pwstrT = 0;

        OrStringCat(strbinding, &pwstrCompressedBinding[1]); // network address

        pwstrT = OrStringSearch(strbinding, 0); // [
        *pwstrT = L'[';
        pwstrT++;
        *pwstrT = 0;

        OrStringCat(strbinding, endpoint);  // endpoint

        pwstrT = OrStringSearch(strbinding, 0); // ]
        *pwstrT = L']';
        pwstrT++;
        *pwstrT = 0;

        RPC_STATUS status = RpcBindingFromStringBinding(strbinding, &bh);

        ASSERT(bh == 0 || status == RPC_S_OK);

        delete strbinding;
    }

    if (bh == 0)
    {
        KdPrintEx((DPFLTR_DCOMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "OR: Unable to bind to %S\n",
                   pwstrCompressedBinding + 1));
    }

    return(bh);
}


DUALSTRINGARRAY *
GetStringBinding(
                IN PWSTR pwstrCompressed,
                IN PWSTR pwstrSecurityBindings
                )
/*++

Routine Description:

    Converts the compressed string binding into an expanded
    string binding.  An enpoint maybe optionally specified.

Arguments:

    pwstrCompressed - a compressed string binding

    pwstrSecurityBindings - optional security bindings
        too be tacked onto the end of the expanded string binding.
        Terminated by two nulls.

Return Value:

    NULL - out of memory

    non-NULL - a string binding.  Allocated with MIDL_user_allocate.
--*/
{
    DUALSTRINGARRAY *pT;
    PWSTR protseq;
    USHORT seccount;

    PWSTR t = pwstrSecurityBindings;
    if (t && *t)
    {
        seccount = 0;
        do
        {
            seccount++;
            t++;

            if (*t == 0)
            {
                seccount++;
                t++;
            }
        }
        while (*t);

        seccount++; // final NULL
    }
    else
    {
        // Two nulls only.
        seccount = 2;
    }

    protseq = GetProtseq(*pwstrCompressed);
    if (!protseq)
        return NULL;   // not out of memory -- means bindings contained bogus tower id

    int l = OrStringLen(pwstrCompressed) + OrStringLen(protseq) + seccount + 1 + 1;

    pT =(DUALSTRINGARRAY *)MIDL_user_allocate(sizeof(DUALSTRINGARRAY) + l * sizeof(WCHAR));

    if (!pT)
    {
        return(0);
    }

    pT->wNumEntries = (USHORT) l;
    OrStringCopy(pT->aStringArray, protseq);
    OrStringCat(pT->aStringArray, L":");
    OrStringCat(pT->aStringArray, pwstrCompressed + 1);

    if (pwstrSecurityBindings)
    {
        PWSTR t = pT->aStringArray;
        t = OrStringSearch(t, 0);
        t++;
        *t = 0;  // Second NULL on string bindings.
        t++;
        OrMemoryCopy(t, pwstrSecurityBindings, seccount*sizeof(WCHAR));
    }
    else
    {
        // Add three NULLs, total of four.
        PWSTR t = pT->aStringArray;
        t = OrStringSearch(t, 0);
        t[1] = 0;
        t[2] = 0;
        t[3] = 0;
    }

    pT->wSecurityOffset = pT->wNumEntries - seccount;

    ASSERT(dsaValid(pT));

    return(pT);
}


ORSTATUS
ConvertToRemote(
               IN  DUALSTRINGARRAY  *pdsaLocal,
               OUT DUALSTRINGARRAY **ppdsaRemote
               )
/* ++

Parameters:
    pdsaLocal - An array of string bindings with compressed protseqs.

    ppdsaRemote - Will contain only those string bindings in pdsaLocal
        which are not "IsLocal()".

    Note: *ppdsaRemote maybe used as a flag, don't set it to non-NULL
    until it is valid.

-- */
{
    USHORT iTotalSize;
    USHORT iSize;
    USHORT *p1, *p2;
    DUALSTRINGARRAY *pdsaT;

    // Size remote array

    // Final null terminator
    iSize = 1;

    p1 = pdsaLocal->aStringArray;

    while (*p1)
    {
        if (! IsLocal(*p1) )
        {
            iSize += OrStringLen(p1) + 1;
        }
        p1 = OrStringSearch(p1, 0) + 1;
    }

    if (iSize == 1)
    {
        iSize = 2; // No non-local strings, need two terminators.
    }

    iTotalSize = iSize + (pdsaLocal->wNumEntries - pdsaLocal->wSecurityOffset);

    pdsaT = new(iTotalSize * sizeof(WCHAR)) DUALSTRINGARRAY;

    if (!pdsaT)
    {
        return(OR_NOMEM);
    }

    pdsaT->wNumEntries = iTotalSize;
    pdsaT->wSecurityOffset = iSize;

    p2 = pdsaT->aStringArray;

    // Copy security bindings
    OrMemoryCopy(p2 + iSize,
                 pdsaLocal->aStringArray + pdsaLocal->wSecurityOffset,
                 (iTotalSize - iSize) * sizeof(WCHAR));

    if (iSize == 2)
    {
        // No non-local strings, fill in terminators and return.
        *p2 = 0;
        *(p2 + 1) = 0;
        *ppdsaRemote = pdsaT;

        ASSERT(dsaValid(pdsaT));
        return(OR_OK);
    }

    p1 = pdsaLocal->aStringArray;

    while (*p1)
    {
        if ( ! IsLocal(*p1) )
        {
            OrStringCopy(p2, p1);
            p2 = OrStringSearch(p2, 0) + 1;
        }

        p1 = OrStringSearch(p1, 0) + 1;
    }

    *p2 = 0; // Second terminator.

    *ppdsaRemote = pdsaT;

    ASSERT(dsaValid(pdsaT));
    return(OR_OK);
}


DUALSTRINGARRAY *
CompressStringArrayAndAddIPAddrs(
                   IN DUALSTRINGARRAY *pdsaExpanded
                   )
/*++

Routine Description:

    Converts a stringarray of regular string bindings into a
    compressed (protseq's replaced with WORD id's) array of
    string bindings.

Arguments:

    pdsaExpanded - the string array to compress.
        Security information is copied.

Return Value:

    0 - failed to allocate memory.

    non-0 - compressed string array.

--*/
{
    size_t i, size;
    USHORT *p1, *p2, *p3;
    PWSTR pwstr;
    DUALSTRINGARRAY *pdsaCompressed;
    CIPAddrs* pIPAddrs = gpMachineName->GetIPAddrs();
    ULONG cIPAddrs = 0;
	
    // Possible for gpMachineName->GetIPAddrs to return NULL.
    if (pIPAddrs)
    {
        ASSERT(pIPAddrs->_pIPAddresses);
        cIPAddrs = pIPAddrs->_pIPAddresses->Count;
    }

    // Compute size of result.

    p1 = pdsaExpanded->aStringArray;

    size = pdsaExpanded->wNumEntries - pdsaExpanded->wSecurityOffset;

    if (*p1 == 0)
    {
        size += 2;  // two null terminators ONLY.
    }
    else
    {
        size += 1;  // last null terminator
    }

    while (*p1)
    {
        size_t sizeT = OrStringLen(p1);

        p2 = OrStringSearch(p1, L':');  // ':' is not valid in protseq.
        if (p2)
        {

            // proseq len (p2 - p1) become 1 for Id.
            size_t newLen = (sizeT + 1 - (size_t)(p2 - p1));
            size += newLen;

            *p2 = 0; // subst NULL just for the compare
            if ((lstrcmpW(L"ncacn_ip_tcp", p1) == 0) ||
                (lstrcmpW(L"ncadg_ip_udp", p1) == 0))
            {
                WCHAR *p4 = OrStringSearch(p2+1, L'[');
                size_t nameLen = (size_t)(p4 - p2 - 1);
                newLen = newLen - nameLen + IPMaximumRawName;
                size += newLen * cIPAddrs;
            }
            *p2 = L':'; // put the colon back in

            p1 = OrStringSearch(p2, 0) + 1;
        }
        else
        {
            // Prefix bug:  if we got here, this would mean we found a binding 
            // that did not have a colon, and we would then have passed a NULL 
            // p2 to OrStringSearch.   This code is so old I doubt that this 
            // case ever has been or will be hit, but better to do the right thing.
            ASSERT(0 && "Malformed binding");
            if (pIPAddrs)
                pIPAddrs->DecRefCount();
            return NULL;
        }
    }

    pdsaCompressed = new(size * sizeof(WCHAR)) DUALSTRINGARRAY;

    if (0 == pdsaCompressed)
    {
        if (pIPAddrs)
            pIPAddrs->DecRefCount();
        return(0);
    }

    p3 = pdsaCompressed->aStringArray;
    *p3 = 0;

    p1 = pdsaExpanded->aStringArray;

    if (*p1 == 0)
    {
        // Loop won't be entered, point p3 to second null terminator
        p3++;
    }

    while (*p1)
    {
        p2 = OrStringSearch(p1, L':');
        if (p2)
        {
            USHORT TowerId;

            *p2 = 0;
            *p3 = TowerId = GetProtseqId(p1);
            *p2 = L':';
            if (*p3 != 0)
            {
                p3++;
                p1 = p2 + 1; // Just after ':'
                OrStringCopy(p3, p1);
                // Move p3 to start of next string if any.
                p3 = OrStringSearch(p3, 0) + 1;

                //
                // add in IP addresses for TCP/IP and UDP/IP
                //

                if ((TowerId == ID_TCP) || (TowerId == ID_UDP))
                {
                    ULONG i;
                    p2 = OrStringSearch(p1, L'[');
                    if (p2)
                    {
                        for (i=0; i<cIPAddrs; i++)
                        {
                            // do not include the loopback address in server bindings
                            if (lstrcmpW(L"127.0.0.1", pIPAddrs->_pIPAddresses->NetworkAddresses[i]) != 0)
                            {
                                *p3 = TowerId;
                                p3++;

                                // copy in IP address
                                OrStringCopy(p3, pIPAddrs->_pIPAddresses->NetworkAddresses[i]);
                                p3 = OrStringSearch(p3, 0);

                                // copy in rest of string binding
                                OrStringCopy(p3, p2);

                                // Move p3 to start of next string if any.
                                p3 = OrStringSearch(p3, 0) + 1;
                            }
                        }
                    }
                }
            }
        }

        // Move p1 to start of next string if any.
        p1 = OrStringSearch(p1, 0) + 1;
    }

    // Second terminator, p3 already points to it.
    *p3 = 0;

    pdsaCompressed->wSecurityOffset = (USHORT) (p3 + 1 - pdsaCompressed->aStringArray );
    pdsaCompressed->wNumEntries = pdsaCompressed->wSecurityOffset +
        (pdsaExpanded->wNumEntries - pdsaExpanded->wSecurityOffset);

    // Copy security bindings
    OrMemoryCopy(p3 + 1,
                 pdsaExpanded->aStringArray + pdsaExpanded->wSecurityOffset,
                 (pdsaExpanded->wNumEntries - pdsaExpanded->wSecurityOffset) * sizeof(WCHAR));

    ASSERT(dsaValid(pdsaCompressed));
	
    if (pIPAddrs)
        pIPAddrs->DecRefCount();

    return(pdsaCompressed);
}


USHORT
FindMatchingProtseq(
                   IN USHORT cClientProtseqs,
                   IN USHORT aClientProtseqs[],
                   IN PWSTR  pwstrServerBindings
                   )
/*++

Routine Description:

    Finds the first protseq id in aClientProtseqs which appears in any of
    the server bindings.

Arguments:

    cClientProtseqs - the number of entries in aClientProtseqs.
    aClientProtseqs - Protseq tower id's support by the client.
    pwstrServerBindings - compressed array of bindings supported by the server
        terminated by two NULLs.

Return Value:

    0 - no match found.
    non-0 - the matching protseq id.

--*/

// Called by server oxid's and processes when checking for lazy use protseq.
{
    ULONG i;

    if (0 == cClientProtseqs)
    {
        return(0);
    }

    while (*pwstrServerBindings)
    {
        for (i = 0; i < cClientProtseqs; i++)
        {
            if (aClientProtseqs[i] == *pwstrServerBindings)
            {
                return(aClientProtseqs[i]);
            }
        }
        pwstrServerBindings = OrStringSearch(pwstrServerBindings, 0) + 1;
    }

    return(0);
}



PWSTR
FindMatchingProtseq(
                   IN USHORT protseq,
                   IN PWSTR  pwstrCompressedBindings
                   )
/*++

Routine Description:

    Searches a compressed string array for an entry which
    matches a particular protseq.


Arguments:

    protseq - The protseq to search for.

    pwstrCompressedBindings - The bindings to search.

Return Value:

    0 - not found

    non-0 - a pointer into the pwstrCompressedBindings

--*/
{
    ASSERT(pwstrCompressedBindings);

    while (*pwstrCompressedBindings)
    {
        if (*pwstrCompressedBindings == protseq)
        {
            return(pwstrCompressedBindings);
        }
        pwstrCompressedBindings = OrStringSearch(pwstrCompressedBindings, 0) + 1;
    }
    return(0);
}

PWSTR
FindMatchingProtseq(
                   IN PWSTR  pMachineName,
                   IN USHORT protseq,
                   IN PWSTR  pwstrCompressedBindings
                   )
/*++

Routine Description:

    Searches a compressed string array for an entry which
    matches a particular protseq and machine


Arguments:

    protseq - The protseq to search for.

    pMachine - the machine name to search for.

    pwstrCompressedBindings - The bindings to search.

Return Value:

    0 - not found

    non-0 - a pointer into the pwstrCompressedBindings

--*/
{
    ASSERT(pwstrCompressedBindings);

    while (*pwstrCompressedBindings)
    {
        if (*pwstrCompressedBindings == protseq)
        {
            PWSTR pwstrMachineNameTemp = pMachineName;

            WCHAR* pwstrT = pwstrCompressedBindings + 1;
            BOOL fSkip = FALSE;
            while (*pwstrT && *pwstrMachineNameTemp && ((*pwstrT != L'[') || fSkip))
            {
                fSkip = (*pwstrT == L'\\') && !fSkip;

                if (towupper(*pwstrMachineNameTemp) != towupper(*pwstrT))
                {
                    break;
                }
                pwstrT++;
                pwstrMachineNameTemp++;
            }

            if (!*pwstrMachineNameTemp && (!*pwstrT || (*pwstrT == L'[')))
            {
                return pwstrCompressedBindings;
            }
        }

        pwstrCompressedBindings = OrStringSearch(pwstrCompressedBindings, 0) + 1;
    }
    return(0);
}

WCHAR *
ExtractMachineName(WCHAR *pSB)
{

    pSB++;
    WCHAR* pwstrT = pSB;

    BOOL fSkip = FALSE;
    while (*pwstrT && ((*pwstrT != L'[') || fSkip))
    {
        fSkip = (*pwstrT == L'\\') && !fSkip;
        pwstrT++;
    }
    ULONG len = (ULONG)(pwstrT - pSB);
    if (len)
    {
        WCHAR* pMachineName;
        pMachineName = new WCHAR[len + 1];
        if (pMachineName)
        {
            memcpy(pMachineName, pSB, (UINT)((pwstrT - pSB) * sizeof(WCHAR)));
            pMachineName[len] = 0;
            return pMachineName;
        }
    }

    return NULL;
}



RPC_BINDING_HANDLE
TestBindingGetHandle(
                    IN PWSTR pwstrCompressedBinding
                    )
/*++

Routine Description:

    Tests that an OR can be found on the machine identified by the
    compressed binding.

Arguments:

    pwstrCompressedBiding - A compressed stringing binding to the
        server in question.  May include an endpoint to something
        other then the endpoint mapper.

Return Value:

    None

--*/
{
    PWSTR pwstrT;
    PWSTR pwstrCopy = (PWSTR)alloca(   (OrStringLen(pwstrCompressedBinding) + 1)
                                       * sizeof(WCHAR) );

    if (pwstrCopy == 0)
    {
        return(FALSE);
    }

    OrStringCopy(pwstrCopy, pwstrCompressedBinding);

    // We need to wack the endpoint out of the string binding.
    // Go read the runtime's string parsing stuff if you're not
    // sure what this is doing.  Note: on Win9x this needs to
    // be DBCS enabled...

#ifndef NTENV
    #message "Error: string.cxx(): this won't work"
#endif
    pwstrT = pwstrCopy;

    while (*pwstrT && *pwstrT != L'[')
        pwstrT++;

    if (*pwstrT)
    {
        ASSERT(*pwstrT == L'[');
        *pwstrT = 0;
        // Endpoint gone.
    }

    return  GetBindingToOr(pwstrCopy);
}

//////////////////////////////////////////////////////////////////////////////
//
// CDualStringArray methods
//

DWORD CDualStringArray::AddRef()
{
    ASSERT(_cRef != 0);
    DWORD cRef = InterlockedIncrement(&_cRef);
    return cRef;
}

DWORD CDualStringArray::Release()
{
    ASSERT(_cRef > 0);
    DWORD cRef = InterlockedDecrement(&_cRef);
    if (cRef == 0)
    {
        delete this;
    }
    return cRef;
}

CDualStringArray::~CDualStringArray()
{
    ASSERT(_cRef == 0);

    // free the dual string array
    MIDL_user_free( _pdsa );
}

//
//////////////////////////////////////////////////////////////////////////////

RPC_STATUS CParallelPing::Ping()
/*++

Routine Description:

    Calls ServerAlive2 on all supplied bindings asyncronously.  First binding
    that completles succesfully is chosen. Remaining calls are cancelled.

Arguments:

    None;

Return Value:

    RPC_S_OK
    RPC_S_CALL_FAILED

--*/
{
    ULONG           cHandlesMax = 0;
    const  ULONG    cBlockSize = 10;

    _cCalls = 0;
    _cReceived = 0;
    _arAsyncCallInfo = NULL;

    //
    // First ping that succeeds sets _ndxWinner to it's index + 1
    //
    _ndxWinner = 0;
    
    //
    // send off all the calls
    //

    RPC_STATUS sc;

    ULONG i;
    for (i=0; _ndxWinner == 0; i++)
    {

        //
        // allocate/resize arrays to hold call state
        //

        if (i >= cHandlesMax)
        {
            REALLOC(MIDL_user_allocate, MIDL_user_free,
                     PRPC_ASYNC_STATE,
                     _arAsyncCallInfo, cHandlesMax, cHandlesMax+cBlockSize, sc)
            if (FAILED(sc))
            {
            	break;
            }
            memset(_arAsyncCallInfo+cHandlesMax, 0, (sizeof(PRPC_ASYNC_STATE) * cBlockSize));
            
            cHandlesMax += cBlockSize;
        }
        if (i >= _cProtseqMax)
        {
            REALLOC(MIDL_user_allocate, MIDL_user_free,
                    PROTSEQINFO, _pProtseqInfo,
                    _cProtseqMax, _cProtseqMax+cBlockSize, sc)
            if (FAILED(sc))
            {
                break;
            }
            _cProtseqMax += cBlockSize;
        }

        if (i == _cHandles)
        {
            // get more handles
            if (!NextCall(_pProtseqInfo+i))
            {
                // no more, so we're done
                break;
            }

            _cHandles++;

            //
            // turn off serialization
            //

            sc = RpcBindingSetOption(_pProtseqInfo[i].hRpc, RPC_C_OPT_BINDING_NONCAUSAL, TRUE);
            if (sc != RPC_S_OK)
            {
                break;
            }
        }

        if (_pProtseqInfo[i].hRpc == NULL)
        {
            continue;
        }

        _arAsyncCallInfo[i] = (PRPC_ASYNC_STATE) MIDL_user_allocate(sizeof(RPC_ASYNC_STATE));
        if (_arAsyncCallInfo[i] == NULL)
        {
            sc = RPC_S_OUT_OF_MEMORY;
            break;
        }

        //
        // set up async information
        //

        sc = RpcAsyncInitializeHandle(_arAsyncCallInfo[i],
                                     sizeof(RPC_ASYNC_STATE));
        //
        // If this succeeds we pass the ownership of _arAsyncCallInfo[i] to the callback
        //
        if (sc != RPC_S_OK)
        {
            MIDL_user_free(_arAsyncCallInfo[i]);
            _arAsyncCallInfo[i] = NULL;
            break;
        }
        _arAsyncCallInfo[i]->NotificationType = RpcNotificationTypeApc;
        _arAsyncCallInfo[i]->u.APC.NotificationRoutine = ServerAliveAPC;
        _arAsyncCallInfo[i]->u.APC.hThread = 0;
        _arAsyncCallInfo[i]->UserInfo = (void *)this;


        _cCalls++;
        //
        // begin the call
        //

        RPC_STATUS ret = ServerAlive2( _arAsyncCallInfo[i],
                                       _pProtseqInfo[i].hRpc,
                                       &_tmpComVersion,
                                       &_tmpOrBindings,
                                       &_tmpReserved );

        if (ret != RPC_S_OK)
        {
            ServerAliveWork(_arAsyncCallInfo[i], ret);
        }
        else
        {
            //
            // stagger the calls
            //

            SleepEx(PARALLEL_PING_STAGGER_TIME, TRUE);
        }
    }

    //
    // wait for successful ping or for all calls to
    // return
    //

    while ( (_ndxWinner == 0) && ((_cCalls - _cReceived) > 0) )
    {
        SleepEx(INFINITE, TRUE);
    }

    //
    // Cancel the calls left outstanding if there are any
    //

    if ((_cCalls - _cReceived) > 0)
    {
        for (i = 0; i<_cHandles; i++)
        {
            if (_arAsyncCallInfo[i] != NULL)
            {
                // we purposely ignore the return code here.  Even if it failed
                // there wouldn't be much we could do.
                RPC_STATUS retDontCare = RpcAsyncCancelCall(_arAsyncCallInfo[i], TRUE);
                if (retDontCare != RPC_S_OK)
                {
                    KdPrintEx((DPFLTR_DCOMSS_ID,
                               DPFLTR_WARNING_LEVEL,
                               "OR:  RpcAsyncCancelCall failed - this is non-fatal; ret=%d\n",
                               retDontCare));
                }               
            }
        }

        //
        // wait for cancelled calls to return
        //

        while ( (_cCalls - _cReceived) > 0)
        {
            SleepEx(INFINITE, TRUE);
        }
    }

    // Free call infos
    if (_arAsyncCallInfo)
    {
 #if DBG
        for (i=0; i < cHandlesMax; ++i)
        {
            ASSERT(_arAsyncCallInfo[i] == NULL);
        }
 #endif
    	MIDL_user_free(_arAsyncCallInfo);
    }

    //
    // return results
    //

    _arAsyncCallInfo = NULL;

    if (_ndxWinner != 0)
    {
        _pWinner = _pProtseqInfo + _ndxWinner - 1;
        return RPC_S_OK;
    }
    else
    {
        _pWinner = NULL;

        //
        // give precedence to failure which occured while attempting
        // to make calls.
        //

        if (sc != RPC_S_OK)
        {
            return sc;
        }
        else
        {
            ASSERT(_sc != RPC_S_OK);
            return _sc;
        }
    }
}

void ServerAliveAPC( IN PRPC_ASYNC_STATE pAsyncState,
                     IN void *Context,
                     IN RPC_ASYNC_EVENT Flags)
{
    CParallelPing   *pParallelPing = (CParallelPing *)pAsyncState->UserInfo;
    
    pParallelPing->ServerAliveWork(pAsyncState, RPC_S_OK);
}


void CParallelPing::ServerAliveWork( PRPC_ASYNC_STATE pAsyncState, RPC_STATUS scBegin)
{
    RPC_STATUS tmpStatus;
    _tmpOrBindings = NULL;

    if (scBegin == RPC_S_OK)
    {
        _sc = RpcAsyncCompleteCall(pAsyncState, &tmpStatus);
    }
    else
    {
        _sc = scBegin;
    }

    // If there are no saved bindings, save these.
    if (_pdsaOrBindings == NULL && dsaValid(_tmpOrBindings))
    {
        _pdsaOrBindings = _tmpOrBindings;
        _tmpOrBindings  = NULL;
    }
    else
    {
        MIDL_user_free( _tmpOrBindings );
        _tmpOrBindings = NULL;
    }

    _cReceived++;

    ULONG uMyIndex = 0;

    for (uMyIndex=0; uMyIndex < _cHandles; ++uMyIndex)
    {
        if (_arAsyncCallInfo[uMyIndex] == pAsyncState)
        {
            MIDL_user_free(pAsyncState);
            _arAsyncCallInfo[uMyIndex] = NULL;
            break;
        }
    }

    if (uMyIndex == _cHandles)
    {
        ASSERT(uMyIndex < _cHandles);
        return;
    }

    //
    // First protocol to succeed is the winner
    //
    if (_ndxWinner == 0)
    {
        if ((_sc == RPC_S_OK) || (_sc == RPC_S_PROCNUM_OUT_OF_RANGE))
        {
            _ndxWinner = uMyIndex + 1;
            _sc = RPC_S_OK;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\objex\shrmem\dcomss.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    dcomss.h

Abstract:

    Common services provided by core the orpcss service.

Author:

    Mario Goertzel    [MarioGo]

Revision History:

    MarioGo     06-14-95    Bits 'n pieces

--*/

#ifndef __DCOMSS_H
#define __DCOMSS_H

#ifdef __cplusplus
extern "C" {
#endif

#include <windows.h>

#if DBG && !defined(DEBUGRPC)
#define DEBUGRPC
#endif

// Endpoint related functions

USHORT     GetProtseqId(PWSTR Protseq);
USHORT     GetProtseqIdAnsi(PSTR Protseq);
PWSTR      GetProtseq(USHORT ProtseqId);
PWSTR      GetEndpoint(USHORT ProtseqId);
RPC_STATUS UseProtseqIfNecessary(USHORT id);
RPC_STATUS DelayedUseProtseq(USHORT id);
VOID       CompleteDelayedUseProtseqs();
BOOL       IsLocal(USHORT ProtseqId);
DWORD      RegisterAuthInfoIfNecessary(USHORT authnSvc);


extern BOOL gfRegisteredAuthInfo;

extern BOOL s_fEnableDCOM; // Set by StartObjectExporter.


// Shared by wrapper\epts.c and olescm\clsdata.cxx.

typedef enum {
    STOPPED = 1,
    START,
    STARTED
    } PROTSEQ_STATE;

typedef struct {
    PROTSEQ_STATE state;
    PWSTR         pwstrProtseq;
    PWSTR         pwstrEndpoint;
    } PROTSEQ_INFO;

extern PROTSEQ_INFO gaProtseqInfo[];

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\objex\shrmem\dcom95\dsa.cxx ===
/*++

Copyright (c) 1996-1997 Microsoft Corporation

Module Name:

    dsa.cxx

Abstract:

    This module contains the implementation for the wrapper class for
    DUALSTRINGARRAYs. It could probably be simplified significantly.

Author:

    Satish Thatte    [SatishT]    04-07-96

--*/

#include <or.hxx>

//
//  CBindingIterator methods
//

PWSTR
CBindingIterator::Next()
{
    if (_iCurrentIndex == 0xffff) // fresh iterator, use starting index
    {
        _iCurrentIndex = _iStartingIndex;   // not fresh any more
        return &_dsa->aStringArray[_iStartingIndex];
    }

    PWSTR pwstrT = &_dsa->aStringArray[_iCurrentIndex];

    pwstrT = OrStringSearch(pwstrT, 0) + 1;

    if (*pwstrT == 0)  // the end of the string bindings was reached
    {
        pwstrT = _dsa->aStringArray;   // wrap around
    }

    _iCurrentIndex = pwstrT - _dsa->aStringArray;

    if (_iStartingIndex != _iCurrentIndex)
    {
        return pwstrT;
    }
    else
    {
        return NULL;
    }
}

//
//  CDSA methods
//

ORSTATUS
CDSA::copyDSA(DUALSTRINGARRAY *pdsa)
{
    VALIDATE_METHOD

    DUALSTRINGARRAY *pdsaT = NULL;
    _fOwnDSA = FALSE;

    if (pdsa != NULL)
    {
        pdsaT = (DUALSTRINGARRAY *)
                OrMemAlloc(pdsa->wNumEntries 
                                 * sizeof(WCHAR) + 
                           sizeof(DUALSTRINGARRAY)
                          );

 #if DBG
    OutputDebugPointer("Allocating DSA at ",pdsaT);
#endif

       if (!pdsaT)
        {
            return OR_NOMEM;
        }
    
        dsaCopy(pdsaT, pdsa);
    }

    _pdsa = pdsaT;
    if (_pdsa != NULL) _fOwnDSA = TRUE;

    return OR_OK;
}

ORSTATUS
CDSA::copyDSAEx(DUALSTRINGARRAY *pdsa, BOOL fCompressed)
{
    VALIDATE_METHOD

    ORSTATUS status = OR_OK;

    if (fCompressed)
    {
        status = copyDSA(pdsa);
    }
    else
    {
        DUALSTRINGARRAY *pdsaT = CompressStringArray(pdsa,TRUE);

        if (pdsaT)
        {
            Assign(pdsaT);    // no copying
            _fOwnDSA = TRUE;
        }
        else
        {
            status = OR_NOMEM;
            _pdsa = NULL;
            _fOwnDSA = FALSE;
        }
    }

    return status;
}


ORSTATUS 
CDSA::ExtractRemote(CDSA &dsaLocal)                       // pick out remote protseqs only
                                                          //.this is a kind of assignment
{
    VALIDATE_METHOD

    DUALSTRINGARRAY *pdsaT;
    
    ORSTATUS status = ::ConvertToRemote(
                            dsaLocal._pdsa,
                            &pdsaT
                            );

    if (status == OR_OK)
    {
        status = copyDSA(pdsaT);
        delete pdsaT;
    }
    else
    {
        _pdsa = NULL;
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\objex\shrmem\dcom95\gentable.cxx ===
/*++

Copyright (c) 1996-1997 Microsoft Corporation

Module Name:

    gentable.cxx

Abstract:

    Implementation of the CResolverHashTable and friends.

Author:

    Satish Thatte    [SatishT]   02-12-96

--*/

#include<or.hxx>

// define the static members for page-based allocation
DEFINE_PAGE_ALLOCATOR(CResolverHashTable)

#if DBG

void
CResolverHashTable::IsValid()
{
    ASSERT(_fInitialized == TRUE || _fInitialized == FALSE);
    ASSERT(!_fInitialized || _cBuckets > 0);
    ASSERT(_cBuckets > 0 || _cElements == 0);
    ASSERT(_cBuckets >=0 && _cBuckets < MAX_BUCKETS);

    if (_fInitialized)
    {
        for (USHORT i = 0; i < _cBuckets; i++)
        {
            _buckets[i].IsValid();
        }
    }
}

#endif

ORSTATUS
CResolverHashTable::PrivAdd(        // never called before Init()
    IN CTableElement *pElement
    )
{
    VALIDATE_METHOD

    ORSTATUS status = OR_OK;

    ISearchKey& sk = *pElement;      // auto conversion to ISearchKey

    DWORD hash = sk.Hash() % _cBuckets;

    status = _buckets[hash].Insert(pElement);

    if (status == OR_OK)
    {
        _cElements++;
    }

    return status;
}



CResolverHashTable::CResolverHashTable(UINT start_size)
{
    _cBuckets = start_size;
    _cElements = 0;
    _buckets = NULL;
    _fInitialized = FALSE;

    VALIDATE_METHOD
}


ORSTATUS
CResolverHashTable::Init()
{
    ORSTATUS status;

    ASSERT(!_fInitialized);

    VALIDATE_METHOD

    _buckets = new (InSharedHeap) CTableElementList[_cBuckets];

    if (NULL == _buckets)
    {
        status = OR_NOMEM;
    }
    else
    {
        status = OR_OK;
        _fInitialized = TRUE;
    }

    return status;
}


CResolverHashTable::~CResolverHashTable()
{
    RemoveAll();
    if (_fInitialized)
    {
        ASSERT(_buckets != NULL);
        DELETE_OR_ARRAY(CTableElementList,_buckets,_cBuckets);
    }
}


CTableElement *
CResolverHashTable::Lookup(
    IN ISearchKey &id
    )
{
    VALIDATE_METHOD

    if (!_fInitialized) return NULL;  // nothing to look in

    DWORD hash = id.Hash();
    hash %= _cBuckets;

    return _buckets[hash].Find(id);
}

ORSTATUS
CResolverHashTable::Add(
    IN CTableElement *pElement
    )
{
    VALIDATE_METHOD

    ORSTATUS status = OR_OK;

    if (!_fInitialized) status = Init();     // set up buckets

    if (status != OR_OK) return status;

    status = PrivAdd(pElement);     // do the basic Add

    if (status != OR_OK) return status;

    if (_cElements > _cBuckets)     // now see if the table is overpopulated
        {
        // Try to grow the table.  If the allocation fails no need to worry,
        // everything still works but might be a bit slower.

        CTableElementList * psll;
        psll = new (InSharedHeap) CTableElementList[_cBuckets * 2];


        // The tricky part here is to avoid getting OR_NOMEM error while moving
        // between tables.  We do that by recycling the links in the old lists

        if (psll)
        {
            UINT i, uiBucketsOld = _cBuckets;
            CTableElement *pte;
            CTableElementList::Link *pLink;
            CTableElementList *psllOld = _buckets;

            OrDbgDetailPrint(("OR: Growing table: %p\n", this));

            // Change to the larger array of buckets.
            _cBuckets *= 2;
            _buckets = psll;

            // Move every element from the old table into the large table.

            for(i = 0; i < uiBucketsOld; i++)
            {
                while (pLink = psllOld[i].PopLink())  // uses specialized private operations
                {                                     // to avoid both memory allocation
                                                      // and reference counting problems

                    ISearchKey& sk = *pLink->_pData;  // auto conversion to ISearchKey
                    _buckets[sk.Hash() % _cBuckets].PushLink(pLink);
                }
            }

            DELETE_OR_ARRAY(CTableElementList,psllOld,uiBucketsOld)
        }
    }

    return status;
}

CTableElement *
CResolverHashTable::Remove(
    IN ISearchKey &id
    )
/*++

Routine Description:

    Looks up and removes an element from the table.

Arguments:

    id - The key to match the element to be removed

Return Value:

    NULL - The element was not in the table

    non-NULL - A pointer to the element which was removed.

--*/

{
   VALIDATE_METHOD

   if (!_fInitialized) return NULL;  // nothing to remove

    DWORD hash = id.Hash() % _cBuckets;

    CTableElement *pTE = _buckets[hash].Remove(id);

    if (pTE)
    {
        _cElements--;
    }

    return pTE;
}


void
CResolverHashTable::RemoveAll()
{
    VALIDATE_METHOD

    if (!_fInitialized) return;  // nothing to remove

    ASSERT(_buckets);
    DWORD _currentBucketIndex = 0;
    CTableElement *pTE;

    while (_currentBucketIndex < _cBuckets)
    {
        while (pTE = _buckets[_currentBucketIndex].Pop())
        {
            _cElements--;
        }

        _currentBucketIndex++;
    }

    ASSERT(_cElements==0);

    DELETE_OR_ARRAY(CTableElementList,_buckets,_cBuckets);
    _buckets = NULL;
    _fInitialized = FALSE;
}



IDataItem * 
CResolverHashTableIterator::Next()
{
    if (!_table._fInitialized)
    {
        return NULL;
    }

    while (
           _BucketIter.Finished() 
        && (_currentBucketIndex < _table._cBuckets)
        )
    {
        _BucketIter.Init(_table._buckets[_currentBucketIndex]);
        _currentBucketIndex++;
    }

    return _BucketIter.Next();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\objex\shrmem\dcom95\callid.cxx ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    callid.cxx

Abstract:

    Implements a cache of callids used for running down OIDs

    This is almost twice as fast as UuidCreate() but that doesn't
    mean much.  UuidCreate takes 3 microseconds, this 1.4 (hit) or
    4.2 (miss) on a P90.

    This codes real advantage would be on MP machines.  But it is
    not performance critical and is probably overkill.

Author:

    Mario Goertzel    [MarioGo]

Revision History:

    MarioGo     1/18/1996    Bits 'n pieces

--*/

#include <or.hxx>

enum CacheState { CallidEmpty = 0,
                  CallidAllocated = 1,
                  CallidFree = -1 };
                  
struct CacheElement
    {
    CacheState  _state;
    UUID        _callid;
    };

CacheElement CallidCache[4] = { CallidEmpty, {0},
                                CallidEmpty, {0},
                                CallidEmpty, {0},
                                CallidEmpty, {0} };


INT
AllocateCallId(
    OUT UUID &Callid
    )
{
    INT i;
    LONG l;
    RPC_STATUS status;

    for (i = 0; i < 4; i++)
        {
        if (CallidCache[i]._state != CallidAllocated)
            {
            l = InterlockedExchange((PLONG)&CallidCache[i]._state, CallidAllocated);

            switch(l)
                {
                case CallidAllocated:
                    continue;

                case CallidFree:
                    Callid = CallidCache[i]._callid;
                    return(i);

                case CallidEmpty:
                    status = UuidCreate(&Callid);
                    VALIDATE((status, RPC_S_OK, RPC_S_UUID_LOCAL_ONLY, 0));
                    CallidCache[i]._callid = Callid;
                    return(i);
                }
            }
        }
    status = UuidCreate(&Callid);
    VALIDATE((status, RPC_S_OK, RPC_S_UUID_LOCAL_ONLY, 0));
    return(-1);
    }


void
FreeCallId(
    IN INT hint
    )
/*++

Routine Description:

    Frees a callid previously allcoated with AllocateCallId().

Arguments:

    hint - The hint value returned by the previous call to AllocateCallId().

Return Value:

    None

--*/
{
    ASSERT(hint > -2 & hint < 4);

    if (hint >= 0)
        {
        CallidCache[hint]._state = CallidFree;;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\objex\shrmem\or.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    or.h

Abstract:

    General include file for C things the OR.  This file is pre-compiled.

Author:

    Mario Goertzel    [mariogo]       Feb-10-95
    Satish Thatte     [SatishT]       Feb-22-96     modified for DCOM95

Revision History:

--*/

#ifndef __OR_H
#define __OR_H

#include <ole2int.h>    // ComDebOut, etc

#ifdef __cplusplus
extern "C" {
#endif

#include <dcomss.h>

#include <stddef.h>
#include <debnot.h>     // debugging stuff

#include <objex.h>      // Remote OR if from private\dcomidl
#include <orcb.h>       // Callback if from private\dcomidl
#include <resolve.h>    // Remote resolve OXID interface for RPCSS
#include <olerem.h>     // MOXID, REFMOXID, etc
#include <tls.h>        // OLE thread local storage
#include <rpcdcep.h>    // for I_RpcBindingSetAsync etc.

#define IN
#define OUT
#define CONST const

#define WSTR(s) L##s

//
// Security and related data stored in shared memory
//

typedef struct tagSharedSecVals 
{
    BOOL       s_fEnableDCOM;
    BOOL       s_fEnableRemoteLaunch;
    BOOL       s_fEnableRemoteConnect;
    DWORD      s_lAuthnLevel;
    DWORD      s_lImpLevel;
    BOOL       s_fMutualAuth;
    BOOL       s_fSecureRefs;
    DWORD      s_cServerSvc;
    USHORT    *s_aServerSvc;
    DWORD      s_cClientSvc;
    USHORT    *s_aClientSvc;
    DWORD      s_cChannelHook;
    GUID      *s_aChannelHook;
} SharedSecVals;


#define OrStringCompare(str1, str2) wcscmp((str1), (str2))
#define OrStringLen(str) wcslen(str)
#define OrStringCat(str1, str2) wcscat((str1), (str2))
#define OrStringCopy(str1, str2) wcscpy((str1), (str2))
#define OrMemorySet(p, value, len) memset((p), (value), (len))
#define OrMemoryCompare(p1, p2, len) memcmp((p1), (p2), (len))
#define OrMemoryCopy(dest, src, len) memcpy((dest), (src), (len))
// OrStringSearch in or.hxx

//
// The OR uses Win32 (RPC) error codes.
//

typedef LONG ORSTATUS;

// When the OR code asigns and error it uses
// one of the following mappings:
// There are no internal error codes.

#define OR_OK               RPC_S_OK
#define OR_NOMEM            RPC_S_OUT_OF_MEMORY
#define OR_NORESOURCE       RPC_S_OUT_OF_RESOURCES
#define OR_NOACCESS         ERROR_ACCESS_DENIED
#define OR_BADOXID          OR_INVALID_OXID
#define OR_BADOID           OR_INVALID_OID
#define OR_BADSET           OR_INVALID_SET
#define OR_BAD_SEQNUM       OR_INVALID_SET
#define OR_NOSERVER         RPC_S_SERVER_UNAVAILABLE
#define OR_BADPARAM         ERROR_INVALID_PARAMETER

// Should NEVER be seen outside the OR.
#define OR_BUGBUG           RPC_S_INTERNAL_ERROR
#define OR_INTERNAL_ERROR   RPC_S_INTERNAL_ERROR
#define OR_BAD_LOAD_ADDR    RPC_S_INTERNAL_ERROR

// Internal codes used to indicate a special event.
#define OR_I_RETRY          0xC0210051UL
#define OR_I_NOPROTSEQ      0xC0210052UL
#define OR_I_REPEAT_START   0xC0210053UL
#define OR_I_PURE_LOCAL     0xC0210054UL
#define OR_I_DUPLICATE      RPC_S_DUPLICATE_ENDPOINT

#define UNUSED(_x_) ((void *)(_x_))

#if DBG

extern int __cdecl ValidateError(
    IN ORSTATUS Status,
    IN ...);


#define VALIDATE(X) if (!ValidateError X) ASSERT(0);

#define OrDbgPrint(X)
#define OrDbgDetailPrint(X)

#undef ASSERT
#define ASSERT( exp )  if (! (exp) ) DebugBreak();
    

#else  // DBG
#define ASSERT(X)
    
#define VALIDATE(X)
#define OrDbgPrint(X)
#define OrDbgDetailPrint(X)
#endif // DBG


#ifdef __cplusplus
}
#endif

#endif // __OR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\objex\shrmem\dcom95\iface.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       iface.cxx
//
//  Contents:   Resolver entry points and thread definitions.
//
//  Functions:
//
//  History:	24-May-96 SatishT    Created
//
//--------------------------------------------------------------------------

#include <or.hxx>

extern "C"
{
void FakeSapAdvertiseIfNecessary();
extern BOOL gfSapAdvertiseFailed;
}

 error_status_t Connect(
    OUT HPROCESS       *pProcess,
    OUT ULONG           *pdwTimeoutInSeconds,
    OUT DUALSTRINGARRAY **ppdsaOrBindings,
    OUT MID             *pLocalMid,
    IN long              cIdsToReserve,
    OUT ID              *pidReservedBase,
    OUT ULONG           *pfConnectFlags,
    OUT DWORD           *pAuthnLevel,
    OUT DWORD           *pImpLevel,
    OUT DWORD           *pcServerSvc,
    OUT USHORT          **aServerSvc,
    OUT DWORD           *pcClientSvc,
    OUT USHORT          **aClientSvc,
    OUT LONG            *pcChannelHook,
    OUT GUID            **paChannelHook,
    OUT DWORD           *pThreadID,
    OUT DWORD           *pdwRpcssProcessId
    )
 {
     ORSTATUS status;

     status =  ConnectDCOM(
                    pProcess,
                    pdwTimeoutInSeconds,
                    pLocalMid,
                    pfConnectFlags,
                    pAuthnLevel,
                    pImpLevel,
                    pThreadID
                    );

     CProtectSharedMemory protector; // locks through rest of lexical scope

     if (status == OR_OK)
     {
        // Fill in channel hooks.
        UpdateChannelHooks( pcChannelHook, paChannelHook );
     }

     if (status == OR_OK)
     {
         status = AllocateReservedIds(
                         cIdsToReserve,
                         pidReservedBase
                         );
     }

     if (status == OR_OK)
     {
         status = RemoteConnect(
                        ppdsaOrBindings,
                        pcServerSvc,
                        aServerSvc,
                        pcClientSvc,
                        aClientSvc,
                        pdwRpcssProcessId
                        );
     }

     if ( status != OR_OK && *pProcess != NULL)         // Connect failure
         {
                gpProcessTable->Remove(**pProcess);        // this drops the refcount to zero
                pProcess = NULL;
         }

         return status;
}




//+-------------------------------------------------------------------------
//
//  Method:     RemoteConnect
//
//  Purpose:    Synchronize with the security and remote protocol 
//              initialization performed by RPCSS once lazily launched
//
//--------------------------------------------------------------------------
error_status_t
RemoteConnect(
    OUT DUALSTRINGARRAY **ppdsaOrBindings,
    OUT DWORD           *pcServerSvc,
    OUT USHORT          **aServerSvc,
    OUT DWORD           *pcClientSvc,
    OUT USHORT          **aClientSvc,
    OUT DWORD           *pdwRpcssProcessId

    )
{
    ORSTATUS status;

    *pcServerSvc   = gpSecVals->s_cServerSvc;
    *aServerSvc    = CopyArray(gpSecVals->s_cServerSvc,gpSecVals->s_aServerSvc,&status);
    *pcClientSvc   = gpSecVals->s_cClientSvc;
    *aClientSvc    = CopyArray(gpSecVals->s_cClientSvc,gpSecVals->s_aClientSvc,&status);

    if (NULL != gpPingProcess)
    {
        *pdwRpcssProcessId = gpPingProcess->GetProcessID();
    }
    else
    {
        *pdwRpcssProcessId = 0;
    }

    if (status == OR_OK)
    {
        *ppdsaOrBindings = (DUALSTRINGARRAY *) MIDL_user_allocate(
                                gpLocalDSA->wNumEntries * sizeof(WCHAR)
                              + sizeof(DUALSTRINGARRAY) );

        if (*ppdsaOrBindings)
        {
            dsaCopy(*ppdsaOrBindings, gpLocalDSA);
        }
        else
        {
            status = OR_NOMEM;
        }
    }

    return status;
}

 error_status_t ClientResolveOXID(
    IN HPROCESS phProcess,
    IN OXID  *poxidServer,
    IN DUALSTRINGARRAY  *pssaServerObjectResolverBindings,
    IN long fApartment,
    OUT OXID_INFO  *poxidInfo,
    OUT MID  *pLocalMidOfRemote)
 {
     return GetOXID(
                 phProcess,
                 *poxidServer,
                 pssaServerObjectResolverBindings,
                 fApartment,
                 0,             // wProtseqId not specified
                 *poxidInfo,
                 *pLocalMidOfRemote
                 );
 }



 error_status_t ServerAllocateOXIDAndOIDs(
    IN HPROCESS         hProcess,
    OUT OXID            *poxidServer,
    IN long              fApartment,
    IN unsigned long     cOids,
    OUT OID              aOid[  ],
    OUT unsigned long   *pcOidsAllocated,
    IN OXID_INFO        *pOxidInfo,
    IN DUALSTRINGARRAY  *pdsaStringBindings,
    IN DUALSTRINGARRAY  *pdsaSecurityBindings)
 {
      ComDebOut((DEB_OXID, "Calling ServerAllocateOXIDAndOIDs\n"));

      ASSERT(pdsaStringBindings != NULL);

      if (NULL == pdsaSecurityBindings)
      {
          pdsaSecurityBindings = (DUALSTRINGARRAY*) &dsaNullBinding;
      }

      DUALSTRINGARRAY *pdsaMergedBindings;

      ORSTATUS status = MergeBindings(
                            pdsaStringBindings,
                            pdsaSecurityBindings,
                            &pdsaMergedBindings
                            );

      if (status != OR_OK) return status;

      status = ServerAllocateOXID(
                        hProcess,
                        fApartment,
                        pOxidInfo,
                        pdsaMergedBindings,
                        *poxidServer
                        );

      if (status == OR_OK)
      {
          ComDebOut((DEB_OXID, "Calling ServerAllocateOIDs\n"));

          status = ServerAllocateOIDs(
                             hProcess,
                             poxidServer,
                             cOids,
                             aOid,
                             pcOidsAllocated
                             );
      }
      else
      {
        ComDebOut((DEB_OXID, "Not Calling ServerAllocateOIDs, status = %d\n",
                                   status));
      }

      return status;
 }



 error_status_t ServerAllocateOIDs(
    IN HPROCESS hProcess,
    IN OXID  *poxidServer,
    IN unsigned long cOids,
    OUT OID  aOid[  ],
    OUT unsigned long  *pcOidsAllocated)
 {
     ComDebOut((DEB_ITRACE, "Entering ServerAllocateOIDs\n"));

     ORSTATUS status;

     *pcOidsAllocated = 0;

     for (ULONG i = 0; i < cOids; i++)
     {
        status = ServerAllocateOID(
                        hProcess,
                        *poxidServer,
                        aOid[i]
                        );

        if (status != OR_OK)
        {
            *pcOidsAllocated = i;
            break;
        }
        else
        {
            (*pcOidsAllocated)++;
        }
     }

     return status;
 }



 error_status_t ServerFreeOXIDAndOIDs(
    IN HPROCESS hProcess,
    IN OXID oxidServer,
    IN unsigned long cOids,
    IN OID  aOids[  ])
 {
     return ServerFreeOXID(
                     hProcess,
                     oxidServer,
                     cOids,
                     aOids
                     );
 }



VOID CALLBACK RundownTimerProc(
    HWND hwnd,  // handle of window for timer messages
    UINT uMsg,  // WM_TIMER message
    UINT idEvent,       // timer identifier
    DWORD dwTime        // current system time
   )
{     
    if (idEvent != IDT_DCOM_RUNDOWN) return;    // shouldn't happen -- this is only
                                                // used as callback for one timer

    // find the OXID for this thread

    COleTls tls;

    ASSERT(((OXIDEntry *)tls->pOXIDEntry)->dwTid == GetCurrentThreadId());
    ASSERT(((OXIDEntry *)tls->pOXIDEntry)->dwPid == GetCurrentProcessId());

    // disable rundown proc if we are inside CoUnitialize(),
    // to avoid 16 bit DLLs hang on exit
    //
    if (tls->dwFlags & OLETLS_THREADUNINITIALIZING)
        return;

    MOXID Moxid = ((OXIDEntry *)tls->pOXIDEntry)->moxid;

    OXID Oxid;
    MID Mid;

    OXIDFromMOXID(Moxid,&Oxid);
    MIDFromMOXID(Moxid,&Mid);

    CProtectSharedMemory protector; // locks through rest of lexical scope

    COxid *pOxid = gpOxidTable->Lookup(CId2Key(Oxid, Mid));

    ASSERT(pOxid);

    ComDebOut((DEB_OXID, "Attempting Rundown in apartment OXID = %08x PID = %d\n",
                         Oxid,GetCurrentProcessId()));

    // find the RemUnk for this OXID -- we want only the IRundown interface

    IRundown *pRemUnk = tls->pRemoteUnk;

    // If there is no RemUnk, nothing is marshalled, so forget about rundown
    if (!pRemUnk) return;

    ComDebOut((DEB_OXID, "There is a RemUnk for apartment OXID = %08x PID = %d\n",
                         Oxid,GetCurrentProcessId()));

    // go and check your OIDs here

    pOxid->RundownOidsIfNecessary(pRemUnk);
}


DWORD _stdcall
RundownThread(void *pInfo)
{
    DWORD dwLoopCount = 0;

    SRundownThreadInfo *pRundownInfo = (SRundownThreadInfo*)pInfo;

    COxid *pSelf = pRundownInfo->pSelf;               // store away "this" pointer
    BOOL& fKeepRunning = pRundownInfo->fKeepRunning;  // and run signal

    ASSERT(!IsBadWritePtr(pSelf,sizeof(COxid)));

    HRESULT hr = InitChannelIfNecessary(); // initialize thread local storage

    if (FAILED(hr)) return OR_INTERNAL_ERROR; // can't run if there is no thread local storage

    while (TRUE)
    {
        ::Sleep(RUNDOWN_TIMER_INTERVAL);

        CProtectSharedMemory protector; // locks through rest of lexical scope

        if (FALSE == fKeepRunning)  // we have been told to terminate ourselves
        {
            PrivMemFree(pRundownInfo);
            return OR_OK;
        }

        dwLoopCount++;

        ComDebOut((DEB_OXID, "Attempting Rundown in PID = %d\n",
                             GetCurrentProcessId()));

        IRundown *pRemUnk = gpMTARemoteUnknown;

        // If there is no RemUnk, nothing is marshalled, so go back to sleep.
        if (!pRemUnk) continue;

        ComDebOut((DEB_OXID, "There is a RemUnk for free OXID = %08x PID = %d\n",
                             pSelf->GetOXID(),GetCurrentProcessId()));

        ASSERT(!IsBadWritePtr(pRemUnk,sizeof(CRemoteUnknown)));

        pSelf->RundownOidsIfNecessary(pRemUnk);
    }

    return OR_OK;
}

//
// This variable keeps track of the last time the ping thread woke up.
// If the thread is blocked doing a ping, the time will remain unchanged
// and after the BaseTimeoutInterval the ping thread will be restarted 
//  
CTime gLastPingTime;


DWORD _stdcall
PingThread(void)    
{
    DWORD SapCount = SapFreqPerPing - 1;

    while (TRUE)      // don't use a continue in this loop!
    {
        BOOL fSappingEnabled = gfSapAdvertiseFailed;
        DWORD dwSleepInterval = fSappingEnabled ? BasePingInterval * 1000 / SapFreqPerPing
                                                : BasePingInterval * 1000;

        BOOL fPingNow = !fSappingEnabled;

        gLastPingTime.SetNow();

        if (fSappingEnabled)
        {
            fPingNow = (++SapCount % SapFreqPerPing == 0);
            FakeSapAdvertiseIfNecessary();
        }

        if (fPingNow)
        {
            CProtectSharedMemory protector; // locks through rest of scope except where
                                            // temporarily released

            ORSTATUS status;

            // First do rundown detection -- this may cause deletes from ping sets

            COxidTableIterator OxidIter(gpPingProcess->_MyOxids);

            for (COxid *pOxid = OxidIter.Next(); pOxid != NULL; pOxid = OxidIter.Next())
            {
                if (pOxid->HasExpired())
                {
                    // the FALSE signifies that the Oxid does not belong to this thread
                    gpPingProcess->DisownOxid(pOxid,FALSE);
                }
                else
                {
                    pOxid->RundownOidsIfNecessary(NULL); // No IRundown param needed
                }
            }

            // Then do pinging

            CMidTableIterator MidIter(*gpMidTable);

            for (CMid *pMid = MidIter.Next(); pMid != NULL; pMid = MidIter.Next())
            {
                if (pMid->HasExpired())
                {
                    gpMidTable->Remove(*pMid);
                }
                else if (!pMid->IsLocal())
                {
                    status = pMid->PingServer();
                }
            }

            // finally, rundown any server-side ping sets that have timed out

            CPingSetTableIterator PingIter(gSetTable);

            for (CPingSet *pSet = PingIter.Next(); pSet != NULL; pSet = PingIter.Next())
            {
                if (pSet->HasExpired())
                {
                    // The remove will drop the refcount for the set to 0
                    // which will call the destructor for the set which will
                    // call the destructor for the set of COids in it which
                    // will remove all the COids from that table which will
                    // drop all their respective ref counts by one as required
                    gSetTable.Remove(*pSet);
                }
            }

        }

        ::Sleep(dwSleepInterval);  // ping interval is in seconds
    }

    return OR_OK;
}

    
error_status_t
ResolveClientOXID(
    handle_t hClient,
    void *hProcess,
    OXID *poxidServer,
    DUALSTRINGARRAY *pdsaServerBindings,
    LONG fApartment,
    USHORT wProtseqId,
    OXID_INFO *poxidInfo,
    MID *pDestinationMid
    )
{
    return GetOXID(
            (CProcess*)hProcess,
            *poxidServer,
            pdsaServerBindings,
            fApartment,
            wProtseqId,
            *poxidInfo,
            *pDestinationMid,
            TRUE                // This is a SCM request
            );
}


// This function resets the local OR data after RPCSS is launched
void SyncLocalResolverData()
{
    CProtectSharedMemory protector; // locks through rest of scope
    gpGlobalBlock->ResetGlobals();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\objex\shrmem\dcom95\globals.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       globals.cxx
//
//  Contents:   Implementation of Class used to encapsulate shared global
//              data structures for DCOM95.
//
//  History:	13-Feb-96 SatishT    Created
//
//--------------------------------------------------------------------------
#include    <or.hxx>

#include <winsock.h>


//--------------------------------------------------------------------------
//
// some helper stuff for calling winsock functions dynamically
//
// CODEWORK - move this into dynload.cxx and dynload.hxx in ole32\common
// 
//--------------------------------------------------------------------------

extern "C" {
    // implemented in epts.c 
    BOOL LoadWSockIfNecessary();
    struct hostent * COMgethostbyname(const char *name);
    char *  COMinet_ntoa(struct in_addr addr);
};


//
//  Helper function which initializes local DSA and string of protocol
//  sequences, and as a side effect, starts all remote protocols
//

static CONST PWSTR gpwstrProtocolsPath  = L"Software\\Microsoft\\Rpc";
static CONST PWSTR gpwstrProtocolsValue = L"DCOM Protocols";

//
// Helper function for local only situation
//

void
SetDefaultSecurity(SharedSecVals *gpSecVals)
{
    // init security part for pure local operation

    gpSecVals->s_fEnableDCOM            = FALSE;
    gpSecVals->s_fEnableRemoteLaunch    = FALSE;
    gpSecVals->s_fEnableRemoteConnect   = FALSE;
    gpSecVals->s_lAuthnLevel            = RPC_C_AUTHN_LEVEL_NONE;
    gpSecVals->s_lImpLevel              = RPC_C_IMP_LEVEL_ANONYMOUS;
    gpSecVals->s_fMutualAuth            = FALSE;
    gpSecVals->s_fSecureRefs            = FALSE;
    gpSecVals->s_cServerSvc             = 0;
    gpSecVals->s_aServerSvc             = NULL;
    gpSecVals->s_cClientSvc             = 0;
    gpSecVals->s_aClientSvc             = NULL;
    gpSecVals->s_cChannelHook           = 0;
    gpSecVals->s_aChannelHook           = NULL;
}


ORSTATUS
SetPureLocal(
      OUT PWSTR &pwstrProtseqs,
      OUT DUALSTRINGARRAY * &pdsaProtseqs,
      OUT USHORT &cRemoteProtseqs,
      OUT USHORT * &aRemoteProtseqs
      )
{
    // init protocol sequence part for pure local operation

    cRemoteProtseqs = 0;
    aRemoteProtseqs = NULL;

    pwstrProtseqs = (WCHAR*) OrMemAlloc(2*sizeof(WCHAR));
    if (NULL == pwstrProtseqs)
    {
        return OR_NOMEM;
    }

    pwstrProtseqs[0] = pwstrProtseqs[1] = 0;

    pdsaProtseqs = (DUALSTRINGARRAY*)
                   OrMemAlloc(sizeof(DUALSTRINGARRAY) + 3 * sizeof(WCHAR));
    if (NULL == pdsaProtseqs)
    {
        OrMemFree(pwstrProtseqs);
        return OR_NOMEM;
    }

    memset(pdsaProtseqs, 0, sizeof(DUALSTRINGARRAY) + 3 * sizeof(WCHAR));
    pdsaProtseqs->wNumEntries = 4;
    pdsaProtseqs->wSecurityOffset = 2;

    return OR_OK;
}

//
//  Helper functions to query registry and initialize
//  variables for remote protocol info
//

ORSTATUS
ListenOnRemoteProtocols(
      OUT PWSTR &pwstrProtseqs
      )
{
    ORSTATUS status = OR_OK;

    // Initialize out parameter
    pwstrProtseqs = NULL;

    DWORD  dwType;
    DWORD  dwLenBuffer = InitialProtseqBufferLength;
    HKEY hKey;

    status =
    RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                 gpwstrProtocolsPath,
                 0,
                 KEY_READ,
                 &hKey);

    if (status == ERROR_SUCCESS)
    {
        do
        {
            OrMemFree(pwstrProtseqs);
            pwstrProtseqs = (WCHAR*) OrMemAlloc(dwLenBuffer);
            if (pwstrProtseqs)
            {
                status = RegQueryValueEx(hKey,
                                         gpwstrProtocolsValue,
                                         0,
                                         &dwType,
                                         (PBYTE)pwstrProtseqs,
                                         &dwLenBuffer
                                         );
            }
            else
            {
                RegCloseKey(hKey);
                return OR_NOMEM;
            }
        }
        while (status == ERROR_MORE_DATA);
    }

    RegCloseKey(hKey);

    if (status != ERROR_SUCCESS)
    {
        OrMemFree(pwstrProtseqs);
        return status;
    }

    PWSTR pwstr = pwstrProtseqs;

    while(*pwstr)
    {
        // skip leading whitespace
        while ((*pwstr == L'\t') || (*pwstr == L' '))
            pwstr++;

        USHORT id = GetProtseqId(pwstr);

        if ((0 != id) && (ID_NP != id) && !IsLocal(id))
        {
            status = UseProtseqIfNecessary(id);

            // ronans - DCOMHTTP:
            if (id == ID_DCOMHTTP)
            {
                *gpfClientHttp = TRUE;
            }

        }

        pwstr = OrStringSearch(pwstr, 0) + 1;
    }

    return OR_OK;
}

const int MAX_IP_BINDINGS = 100;

void
SetInetBindings(
      IN USHORT id,
      IN OUT PWSTR * const &aBindings,
      IN OUT USHORT * const &aProtseqs,
      IN OUT USHORT &cRemoteProtseqs,
      IN OUT USHORT &psaLen
      )
{
    PWSTR pwstrStringBinding = NULL;

    if (!LoadWSockIfNecessary())
    {
        // ronans: CODEWORK we should have better failure reporting here
        return;
    }

    struct hostent *hostentry = COMgethostbyname( NULL );  // get local IP addresses

    if (hostentry == (struct hostent *) 0)
    {
        return;
    }

    char * szAddress = NULL;

    for (int NumNetworkAddress = 0;
             hostentry->h_addr_list[NumNetworkAddress] != 0;
             NumNetworkAddress++
        )
    {
        szAddress =  COMinet_ntoa(*((struct in_addr*)hostentry->h_addr_list[NumNetworkAddress]));
        USHORT cAddrLen = lstrlenA(szAddress) + 1;

        WCHAR *pwstrAddr = (WCHAR*) alloca(sizeof(WCHAR)*cAddrLen);

        if(!(MultiByteToWideChar(CP_ACP,
                                0,
                                szAddress,
                                -1,
                                pwstrAddr,
                                cAddrLen)))
        {
            return;
        }
                                
	    RPC_STATUS status = RpcStringBindingComposeW(
								    NULL,
								    gaProtseqInfo[id].pwstrProtseq,
								    pwstrAddr,
								    GetEndpoint(id),
								    NULL,
								    &pwstrStringBinding 
								    );

        aProtseqs[cRemoteProtseqs] = id;
        aBindings[cRemoteProtseqs] = pwstrStringBinding;
        cRemoteProtseqs++;
        psaLen += OrStringLen(pwstrStringBinding) + 1;
        pwstrStringBinding = NULL;
    }
}



ORSTATUS
GetResolverBindings(
      OUT DUALSTRINGARRAY *&pdsaProtseqs,
      OUT USHORT &cRemoteProtseqs,
      OUT USHORT * &aRemoteProtseqs
      )
{
    ORSTATUS status = OR_OK;
    DUALSTRINGARRAY *pdsaPS = NULL;

    // Initialize out parameters
    pdsaProtseqs =NULL;
    cRemoteProtseqs = 0;
    aRemoteProtseqs = NULL;
	
    RPC_BINDING_VECTOR *pbv = NULL;
    PWSTR pwstrT;
    USHORT psaLen = 0;
    DWORD i;

    status = RpcServerInqBindings(&pbv);

    ASSERT(status == RPC_S_NO_BINDINGS || pbv != NULL);

	// ronans - DCOMHTTP
    if (status == RPC_S_NO_BINDINGS)
    {
        // No registered remote protocol available
        return status;
    }

    PWSTR aBindings[MAX_PROTSEQ_IDS];
    USHORT aProtseqs[MAX_PROTSEQ_IDS];

    // this is for internet protocols only
    BOOL protseqs_done[2] = {FALSE,FALSE};

    // Build array of protseqs id's and addresses we're listening to.

    for(i = 0; i < pbv-> Count; i++)
    {
        PWSTR pwstrStringBinding;

        status = RpcBindingToStringBinding(pbv->BindingH[i], &pwstrStringBinding);
        if (status != RPC_S_OK)
        {
            break;
        }

        ASSERT(pwstrStringBinding);

        status = RpcStringBindingParse(
								   pwstrStringBinding,
                                   NULL,
                                   &pwstrT,
                                   NULL,
                                   NULL,
                                   NULL
								   );

        if (status != RPC_S_OK)
        {
            break;
        }

		USHORT id = GetProtseqId(pwstrT);

        if (!IsLocal(id))
        {
            if ((id == ID_TCP)  || (id == ID_UDP)) // an IP protocol
            {
            // We need a special dispensation for IP bindings since these
            // may change as a result of RAS connection/disconnection
            // The changes are not reflected in InqBindings since the
            // socket(s) are acquired before the change occurred

            // IP protocols may have multiple addresses and may get into aProtseqs,
            // etc, multiple times and are counted multiple times.  This seems
            // benign, but needs to be watched.

            // if we do show multiple bindings per protocol, we only want to process
            // each protocol once using the standard SetInetBindings code path
                if (protseqs_done[id-ID_TCP])
                {
                    continue;
                }
                else
                {
                    protseqs_done[id-ID_TCP] = TRUE;
                }

                SetInetBindings(id,aBindings,aProtseqs,cRemoteProtseqs,psaLen);
            }
            else
            {
                aProtseqs[cRemoteProtseqs] = id;
                aBindings[cRemoteProtseqs] = pwstrStringBinding;
                cRemoteProtseqs++;
                psaLen += OrStringLen(pwstrStringBinding) + 1;

                // ronans - DCOMHTTP:
                // treat http as a normal case as it shows up in the bindings
                // (this shouldn't happen under windows 95 with the current RPC implementation)
                // but it may in future
                if (id == ID_DCOMHTTP)
                {
                    *gpfClientHttp = FALSE;
                }
            }
        }
        else
        {
            RpcStringFree(&pwstrStringBinding);
        }

        status = RpcStringFree(&pwstrT);
        ASSERT(status == RPC_S_OK && pwstrT == 0);
    }

    if (pbv)
		status = RpcBindingVectorFree(&pbv);

    ASSERT(pbv == 0 && status == RPC_S_OK);

    if (cRemoteProtseqs == 0)
    {
        // No remote bindings
        return RPC_S_NO_BINDINGS;
    }

    // for non NT networks accessed through NT security client, get the default
    // server principal name -- this works primarily for Netware right now.
    // See BUGBUG below for generality problem

    WCHAR *  pwszPrincName;

    status = RpcServerInqDefaultPrincNameW(
                                RPC_C_AUTHN_WINNT, 	
                                &pwszPrincName 	
                                );

    if (status != RPC_S_OK)
    {
		pwszPrincName = L"";  // No name, nothing in DSA
    }

    // string bindings final null, authn and authz service, principal name and two final nulls

    USHORT cPrincNameLen = lstrlenW(pwszPrincName);

    psaLen += 1 + 2 + cPrincNameLen + 2;

    pdsaPS = new (psaLen * sizeof(WCHAR)) DUALSTRINGARRAY;

    aRemoteProtseqs = (USHORT *) OrMemAlloc(sizeof(USHORT)*cRemoteProtseqs);

    if (pdsaPS == NULL || aRemoteProtseqs == NULL)
    {
        for ( i = 0; i < cRemoteProtseqs; i++ )
        {
            status = RpcStringFree(&aBindings[i]);
            ASSERT(status == RPC_S_OK);
        }

        return OR_NOMEM;
    }

    pdsaPS->wNumEntries = psaLen;
    pdsaPS->wSecurityOffset = psaLen - (4 + cPrincNameLen);
    pwstrT = pdsaPS->aStringArray;

    for ( i = 0; i < cRemoteProtseqs; i++ )
    {
        OrStringCopy(pwstrT, aBindings[i]);
        pwstrT += OrStringLen(aBindings[i]) + 1;
        aRemoteProtseqs[i] = aProtseqs[i];
        status = RpcStringFree(&aBindings[i]);
        ASSERT(status == RPC_S_OK);
    }

    if (psaLen == 6)
    {
        // No remote bindings, put in first null.
        pdsaPS->aStringArray[0] = 0;
        pwstrT++;
    }

    // Zero final terminator
    *pwstrT = 0;

    // Security authn service
    pwstrT++;
    *pwstrT = RPC_C_AUTHN_WINNT;    // BUGBUG: need fix for generality

    // Authz service, -1 means none // BUGBUG: -1 causes errors
    pwstrT++;
    *pwstrT = 0;

    // Copy Principal name
    pwstrT++;
    OrStringCopy(pwstrT, pwszPrincName);

    // Final, final NULLS
    pwstrT += cPrincNameLen;
    pwstrT[0] = 0;
    pwstrT[1] = 0;

    ASSERT(dsaValid(pdsaPS));

    pdsaProtseqs = CompressStringArray(pdsaPS,TRUE);
    delete pdsaPS;

    if (pdsaProtseqs == NULL)
    {
        return OR_NOMEM;
    }

    return OR_OK;
}

//+-------------------------------------------------------------------------
//
//  Helper:     InitRemoteProtocols
//
//  Synopsis:   Initializing remote protocols either 
//              as part of shared memory initialization or
//              in response to an RPCSS wakeup event
//
//  Return Value:  OR_OK if remote protocols were successfully initialized
//                 Error returned by one of the subsidiary helpers otherwise
//
//  History:	08-Nov-96 SatishT    Created
//
//--------------------------------------------------------------------------
ORSTATUS
InitRemoteProtocols(
      OUT PWSTR &pwstrProtseqs,
      OUT DUALSTRINGARRAY * &pdsaProtseqs,
      OUT USHORT &cRemoteProtseqs,
      OUT USHORT * &aRemoteProtseqs
      )
{
    ORSTATUS status;

    {
        //
        // It is OK to release the lock here because the only memory structure
        // we are using is the gaProtseqInfo array, which is local to this (RPCSS)
        // process, and since this happens on the main RPCSS thread before other 
        // threads are started for listening, there is no chance of interference
        // 
        CTempReleaseSharedMemory temp;

        status = ListenOnRemoteProtocols(pwstrProtseqs);
    }

    if (status == OR_OK)
    {
        status = GetResolverBindings(
                            pdsaProtseqs,
                            cRemoteProtseqs,
                            aRemoteProtseqs
                            );
    }

    if (status != OR_OK)
    {
        status = OR_I_PURE_LOCAL;

        ORSTATUS local_status = SetPureLocal(
                                      pwstrProtseqs,
                                      pdsaProtseqs,
                                      cRemoteProtseqs,
                                      aRemoteProtseqs
                                      );

        if (local_status != OR_OK) status = local_status;
    }

    ASSERT(dsaValid(pdsaProtseqs));
    return status;
}



//
//  Helper Macros for constructor below only
//

#define AssignAndAdvance(Var,Type)  \
    Type **Var = (Type **) pb;      \
    pb += sizeof(Type *);

#define CopySharedPointer(Var,Type)     \
    Var = *((Type **) pb);              \
    pb += sizeof(Type *);

// prototypes for functions defined in objex.cxx
HRESULT ReadRegistry();
RPC_STATUS ComputeSecurityPackages();


//+-------------------------------------------------------------------------
//
//  Member:     CSharedGlobals::ResetGlobals
//
//  Synopsis:   ReRead Shared Memory Values,
//              They Have Changed because RPCSS was Launched
//
//  History:	13-Feb-96 SatishT    Created
//
//--------------------------------------------------------------------------
void CSharedGlobals::ResetGlobals()
{
    ASSERT((_hSm != NULL) || (_pb != NULL));

    BYTE * pb = _pb;

    HWND *RpcssWindow = (HWND *) pb;
    pb += sizeof(HWND);

    gpIdSequence = (LONG *) pb;
    pb += sizeof(LONG);

    gpdwLastCrashedProcessCheckTime = (DWORD *) pb;
    pb += sizeof(DWORD);

    gpNextThreadID = (DWORD *) pb;
    pb += sizeof(DWORD);

    gpcRemoteProtseqs = (USHORT *) pb;
    pb += sizeof(USHORT);

    gpfRemoteInitialized = (USHORT *) pb;
    pb += sizeof(USHORT);

    gpfSecurityInitialized = (USHORT *) pb;
    pb += sizeof(USHORT);

    gpfClientHttp  = (USHORT *) pb;
    pb += sizeof(USHORT);

    gpSecVals = (SharedSecVals *) pb;
    pb += sizeof(SharedSecVals);

    CopySharedPointer(gpRemoteProtseqIds,USHORT)         // see macro above
    CopySharedPointer(gpwstrProtseqs,WCHAR)
    CopySharedPointer(gpLocalDSA,DUALSTRINGARRAY)
    CopySharedPointer(gpLocalMid,CMid)
    CopySharedPointer(gpPingProcess,CProcess)
    CopySharedPointer(gpOidTable,COidTable)
    CopySharedPointer(gpOxidTable,COxidTable)
    CopySharedPointer(gpMidTable,CMidTable)
    CopySharedPointer(gpProcessTable,CProcessTable)
}



//+-------------------------------------------------------------------------
//
//  Member:     CSharedGlobals::InitGlobals
//
//  Synopsis:   Setup Shared Memory Values,
//              This may involve initializing remote protocols
//              in response to an RPCSS wakeup event
//
//  History:	08-Nov-96 SatishT    Created
//              23-May-97 SatishT    Added fRpcssReinit for RAS reinit
//
//--------------------------------------------------------------------------
ORSTATUS 
CSharedGlobals::InitGlobals(BOOL fCreated, BOOL fRpcssReinit)
{
    ASSERT((_hSm != NULL) || (_pb != NULL));

    ORSTATUS status = OR_OK;

    BYTE * pb = _pb;

    // We assume that the RPCSS window is the first thing in the 
    // shared memory block.  Don't change its position!

    HWND *RpcssWindow = (HWND *) pb;
    pb += sizeof(HWND);

    gpIdSequence = (LONG *) pb;
    pb += sizeof(LONG);

    gpdwLastCrashedProcessCheckTime = (DWORD *) pb;
    pb += sizeof(DWORD);

    gpNextThreadID = (DWORD *) pb;
    pb += sizeof(DWORD);

    gpcRemoteProtseqs = (USHORT *) pb;
    pb += sizeof(USHORT);

    gpfRemoteInitialized = (USHORT *) pb;
    pb += sizeof(USHORT);

    gpfSecurityInitialized = (USHORT *) pb;
    pb += sizeof(USHORT);

    gpfClientHttp  = (USHORT *) pb;
    pb += sizeof(USHORT);
    
    gpSecVals = (SharedSecVals *) pb;
    pb += sizeof(SharedSecVals);

    AssignAndAdvance(DCOMProtseqIds,USHORT)         // see macro above
    AssignAndAdvance(DCOMProtseqs,WCHAR)
    AssignAndAdvance(LocalDSA,DUALSTRINGARRAY)
    AssignAndAdvance(LocalMid,CMid)
    AssignAndAdvance(PingProcess,CProcess)
    AssignAndAdvance(OidTable,COidTable)
    AssignAndAdvance(OxidTable,COxidTable)
    AssignAndAdvance(MidTable,CMidTable)
    AssignAndAdvance(ProcessTable,CProcessTable)

    // The remainder of the shared memory block contains 
    // page allocators for the various shared memory structures

    _aPageAllocators = (CPageAllocator*) pb;

    if (fCreated)  // if we got here first, so create the tables
    {
        memset(_pb, 0, GLOBALS_TABLE_SIZE);

        // Initialize the sequence number for AllocateId, the last time crashed
        // processes were detected and the thread ID sequence in shared memory
        *gpIdSequence = 1;
        *gpdwLastCrashedProcessCheckTime = 0;
        *gpNextThreadID = GetTickCount();
        *gpfRemoteInitialized = FALSE;
        *gpfSecurityInitialized = FALSE;
        *gpfClientHttp = FALSE;

        // I know this is paranoid but I have been bitten before ..
        gpRemoteProtseqIds = NULL;
        gpwstrProtseqs = NULL;
        gpLocalDSA = NULL;
        gpLocalMid = NULL;
        gpPingProcess = NULL;
        gpOxidTable = NULL;
        gpOidTable = NULL;
        gpMidTable = NULL;
        gpProcessTable = NULL;

        // Compute Default Security -- services and flags
        SetDefaultSecurity(gpSecVals);

        // Get standard DCOM flags from registry
        ReadRegistry();

        // Initialize local MID object to NULL
        *LocalMid = NULL;

        // initialize RPCSS's process object in shared memory
        // to NULL.  This will be reset by RPCSS when launched.
        *PingProcess = NULL;

        // initialize RPCSS's messaging window in shared memory
        // to NULL.  This will be reset by RPCSS when launched.
        *RpcssWindow = NULL;

        // Initialize the page-based allocators for all shared
        // memory data structures -- and do it before allocating
        // the hash tables in shared memory!
        for (USHORT i = 0; i < NUM_PAGE_ALLOCATORS; i++)
        {
            _aPageAllocators[i].Initialize(                                            
                        AllocatorEntrySize[i],                                       
                        AllocatorPageSize[i],                                        
                        OrMemAlloc,                                         
                        OrMemFree,                                          
                        FALSE                                               
                        );
        }

        // Need to assign this here before use
        ASSIGN_PAGE_ALLOCATOR(CResolverHashTable)

        // Assume 16 exporting processes/threads.
        *OxidTable = (COxidTable*) new CResolverHashTable(OXID_TABLE_SIZE);

        // Assume 11 exported OIDs per process/thread.
        *OidTable = (COidTable*) new CResolverHashTable(OID_TABLE_SIZE);

        // Assume 16 machine locations for OXIDs.
        *MidTable = (CMidTable*) new CResolverHashTable(MID_TABLE_SIZE);

        // Assume 16 simultaneouly active local processes.
        *ProcessTable = (CProcessTable*) new CResolverHashTable(PROCESS_TABLE_SIZE);
    }

    // set up page allocators
    ASSIGN_PAGE_ALLOCATOR(COid)
    ASSIGN_PAGE_ALLOCATOR(COxid)
    ASSIGN_PAGE_ALLOCATOR(CMid)
    ASSIGN_PAGE_ALLOCATOR(CProcess)
    ASSIGN_PAGE_ALLOCATOR(CClassReg)

    // This is not strictly necessary since these tables are allocated
    // only when the shared file mapping is created, but the (possibly duplicate)
    // initialization does no harm
    ASSIGN_PAGE_ALLOCATOR(CResolverHashTable)

    // Can't use ASSIGN_PAGE_ALLOCATOR for this one: 
    // CLinkList::Link_ALLOCATOR_INDEX won't work the same way

    CLinkList::Link::_pAlloc = &_aPageAllocators[Link_ALLOCATOR_INDEX]; 
    CLinkList::Link::_fPageAllocatorInitialized = TRUE;


    if (gfThisIsRPCSS)
    {
        // initialize RPCSS's HWND for messages in shared memory
        *RpcssWindow = ghRpcssWnd;
        ASSERT(ghRpcssWnd);  // it should be initialized by the time we get here
    }

    PWSTR pwstr = NULL;
    DUALSTRINGARRAY *pdsa = NULL;
    USHORT *aProtseqIds = NULL;

    if (*gpfRemoteInitialized == FALSE || fRpcssReinit == TRUE)
    {
        BOOL fNewDSA = FALSE;
		MID SavedMID = 0;
        RPC_STATUS remote_status = RPC_S_OK;

        // Remote protocol and security package init happens only in RPCSS
        if (gfThisIsRPCSS)
        {
            // initialize RPCSS's process object in shared memory if necessary
            if (*PingProcess == NULL)
            {
                *PingProcess = new CProcess(0);
            }

            if (*gpfSecurityInitialized == FALSE)
            {
                // initialize installed security package info
                remote_status = ComputeSecurityPackages();

                if (remote_status == RPC_S_OK)
                {
                    *gpfSecurityInitialized = TRUE;
                }
            }

			if (remote_status == RPC_S_OK)
            {
                // initialize remote protocol strings and
                // the DSA bindings of local OR in shared memory
                remote_status = InitRemoteProtocols(
                                        pwstr,
                                        pdsa,
                                        *gpcRemoteProtseqs,
                                        aProtseqIds
                                        );
            }

            if (remote_status == RPC_S_OK)
            {
                *gpfRemoteInitialized = TRUE;
                fNewDSA = !gpLocalDSA || !dsaCompare(gpLocalDSA,pdsa);
            }
            else if (remote_status == OR_I_PURE_LOCAL) 
            // InitRemoteProtocols failed or only http is registered, 
            // but we set pure local
            {
                if (*gpfClientHttp)
                    *gpfRemoteInitialized = TRUE;
                fNewDSA = (*LocalMid == NULL);
            }

            if (!fNewDSA)  
            // we aren't going to use the output of InitRemoteProtocols 
            {
                OrMemFree(pwstr);
                OrMemFree(pdsa);
                OrMemFree(aProtseqIds);
            }
            
            if (remote_status != RPC_S_OK && remote_status != OR_I_PURE_LOCAL)
            {
                return remote_status;
            }

            // delete the bogus stuff, if new DSA, but steal the old MID
            if (fNewDSA && *LocalMid != NULL)
            {
                SavedMID = (*LocalMid)->GetMID();
                (*MidTable)->Remove(**LocalMid);
            }
        }
        else if (*LocalMid == NULL)
        {
            // set up some bogus stuff temporarily
            status = SetPureLocal(
                                    pwstr,
                                    pdsa,
                                    *gpcRemoteProtseqs,
                                    aProtseqIds
                                    );

            if (status == OR_OK)
            {
                fNewDSA = TRUE;
            }
        }

        if (fNewDSA)
        {
            // Need to initialize gpRemoteProtseqIds here because the CMid
            // constructor uses this value
            gpRemoteProtseqIds = *DCOMProtseqIds = aProtseqIds;
            *DCOMProtseqs = pwstr;
            *LocalDSA = pdsa;
            ASSERT(dsaValid(pdsa));

            // initialize local Mid object in shared memory

            ORSTATUS MidOK;

			MID NewMID = SavedMID ? SavedMID : AllocateId();
			*LocalMid = new CMid(*LocalDSA,MidOK,0,NewMID,FALSE);

            if (MidOK != OR_OK)
            {
                delete *LocalMid;
                *LocalMid = NULL;
            }

            // Add local CMid object to global shared table
            if (*LocalMid && *MidTable)
                status = (*MidTable)->Add(*LocalMid);
        }
    }

    gpRemoteProtseqIds = *DCOMProtseqIds;
    gpwstrProtseqs = *DCOMProtseqs;
    gpLocalDSA = *LocalDSA;
    gpLocalMid = *LocalMid;
    gpPingProcess = *PingProcess;
    gpOxidTable = *OxidTable;
    gpOidTable = *OidTable;
    gpMidTable = *MidTable;
    gpProcessTable = *ProcessTable;

    ASSERT(dsaValid(gpLocalDSA));
    return status;
}


//+-------------------------------------------------------------------------
//
//  Member:     CSharedGlobals::CSharedGlobals
//
//  Synopsis:   Create table of globals for DCOM95
//
//  Arguments:  [pwszName] - name for shared memory
//
//  Algorithm:  Create and map in shared memory for the table
//
//  History:	13-Feb-96 SatishT    Created
//
//--------------------------------------------------------------------------
CSharedGlobals::CSharedGlobals(WCHAR *pwszName, ORSTATUS &status)
/*---

  NOTE:  This constructor uses the shared allocator.  Objects of this class
         should not be created before the shared allocator is initialized.

---*/
{
    BOOL  fCreated = FALSE;

    status = OR_OK;

    _hSm = CreateSharedFileMapping(
                          pwszName,
                          GLOBALS_TABLE_SIZE,
                          GLOBALS_TABLE_SIZE,
                          NULL,
                          NULL,
                          PAGE_READWRITE,
                          (void **) &_pb,
                          &fCreated
                          );

    Win4Assert(_hSm && _pb && "CSharedGlobals create shared file mapping failed");

    if ((_hSm == NULL) || (_pb == NULL))
    {
        status = OR_INTERNAL_ERROR;
        return;
    }

    status = InitGlobals(fCreated);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\objex\shrmem\dcom95\linklist.cxx ===
/*++

Microsoft Windows NT RPC Name Service
Copyright (c) 1996-1997 Microsoft Corporation

Module Name:

    linklist.cxx

Abstract:

	This module contains definitions of non inline member functions for the
	basic implementation class CLinkList.
	
Author:

    Satish Thatte (SatishT) 08/16/95  

--*/

#include <or.hxx>

// define the static members for page-based allocation
DEFINE_PAGE_ALLOCATOR(CLinkList::Link)


#if DBG

void 
CLinkList::Link::IsValid()
{
    if (_pNext)
    {
        ASSERT(!IsBadWritePtr(_pNext,sizeof(Link)));
        _pNext->IsValid();
    }

    ASSERT(_pData);
    ASSERT(!IsBadWritePtr(_pData,sizeof(IDataItem)));
}

#endif



USHORT 
CLinkList::Size()
{
    VALIDATE_METHOD

    USHORT result = 0;

    for (Link *pL = _pLnkFirst; pL != NULL; pL = pL->_pNext)
    {
        result++;
    }

    return result;
}



// this throws away duplicates
ORSTATUS 
CLinkList::Merge(CLinkList& source)
{
    IDataItem *pItem;
    ORSTATUS status = OR_OK;

    while ((status == OR_OK) && (pItem = source.Pop()))
    {
        status = Insert(pItem);

        if (status == OR_I_DUPLICATE)
        {
            status = OR_OK;
        }
    }

    return status;
}


void 
CLinkList::Remove(CLinkList& NotWanted)
{
    CLinkListIterator RemoveIter;
    RemoveIter.Init(NotWanted);

    for (
         IDataItem *pItem = RemoveIter.Next(); 
         pItem != NULL; 
         pItem = RemoveIter.Next()
        )
    {
        Remove(*pItem);
    }
}




ORSTATUS  
CLinkList::Push(IDataItem * pData) 
{
    ASSERT(pData != NULL);  // do not allow inssertion of NULL pointers

    ORSTATUS status = OR_OK;
    Link *pOldFirst = _pLnkFirst;

	_pLnkFirst = new Link(pData, _pLnkFirst);

    if (!_pLnkFirst) 
    {
        _pLnkFirst = pOldFirst;
        status = OR_NOMEM;
    }
    else 
    {
        pData->Reference();
    }

    return status;
}

ORSTATUS  
CLinkList::Insert(IDataItem * pData) 
{
    VALIDATE_METHOD

    ASSERT(pData != NULL);  // do not allow inssertion of NULL pointers

    IDataItem *pTemp;

    ORSTATUS status = OR_OK;

    if (NULL != (pTemp = Find(*pData))) // Is item with this key already in list?
    {               
        return OR_I_DUPLICATE;          // We do not allow insertion of duplicate keys
    }

    return Push(pData);
}


IDataItem* 
CLinkList::Pop() 

/*++
Routine Description:

	Delete first item in the CLinkList and return it
	
--*/

{
    VALIDATE_METHOD

	if (!_pLnkFirst) return NULL;
		
	IDataItem* pResult = _pLnkFirst->_pData;
	Link * oldFirst = _pLnkFirst;
	_pLnkFirst = _pLnkFirst->_pNext;
	delete oldFirst;

    pResult->Release();
	return pResult;
}
		
IDataItem *
CLinkList::Remove(ISearchKey& di)  

/*++
Routine Description:

	Remove the specified item and return it. 
	
--*/

{
    VALIDATE_METHOD

	if (!_pLnkFirst) return NULL;			// empty list

	if (di == *(_pLnkFirst->_pData)) // Remove first item
    {
		return Pop();
	}

	Link * pLnkPrev = _pLnkFirst, 
         * pLnkCurr = _pLnkFirst->_pNext;

	while (pLnkCurr && di != *(pLnkCurr->_pData)) 
    {
		pLnkPrev = pLnkCurr; 
        pLnkCurr = pLnkCurr->_pNext;
	}

	if (!pLnkCurr) return NULL;			// not found

	/* pLnkCurr contains the item to be removed and it is not the only 
	   item in the list since it is not the first item */

	pLnkPrev->_pNext = pLnkCurr->_pNext;

    IDataItem * pResult = pLnkCurr->_pData;
	delete pLnkCurr;

    pResult->Release();
	return pResult;
}

	
IDataItem* 
CLinkList::Find(ISearchKey& di)			// item to Find
			   

/*++
Routine Description:

	Unlike Remove, this method is designed to use a client-supplied
	comparison function instead of pointer equality.  The comparison
	function is expected to behave like strcmp (returning <0 is less,
	0 if equal and >0 if greater).
	
--*/

{
    VALIDATE_METHOD

	if (!_pLnkFirst) return NULL;			// empty list

	Link  * pLnkCurr = _pLnkFirst;

	while (pLnkCurr && di != *(pLnkCurr->_pData))
		pLnkCurr = pLnkCurr->_pNext;

	if (!pLnkCurr) return NULL;			// not found
	else return pLnkCurr->_pData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\objex\shrmem\dcom95\epts.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    Epts.c

Abstract:

    Common code to listen to endpoints in the DCOM service.

Author:

    Mario Goertzel    [MarioGo]

Revision History:

    MarioGo     6/16/1995    Bits 'n pieces
    SatishT                  Various modifications for Chicago

--*/

#if (DBG == 1)
#define ASSERT( exp )  if (! (exp) ) DebugBreak();
#else
#define ASSERT( exp )
#endif

#define WSTR(s) L##s

#include <dcomss.h>
#include <winsvc.h>
#include <winsock.h>
#include <wsipx.h>
#include <nspapi.h>

// Prototypes

void _cdecl AdvertiseNameWithSap(BOOL fServiceCheck);
void FakeSapAdvertiseIfNecessary();
BOOL LoadWSockIfNecessary();

// Globals

BOOL gfDelayedAdvertiseSaps = FALSE;
BOOL gfSapAdvertiseFailed = FALSE;

typedef enum
    {
    SapStateUnknown,
    SapStateNoServices,
    SapStateEnabled
    } SAP_STATE;

SAP_STATE SapState = SapStateUnknown;

// BUGBUG - this info should be read from the registry.

// The index is the protseq tower id.

PROTSEQ_INFO
gaProtseqInfo[] =
    {
    /* 0x00 */ { STOPPED, 0, 0 },
    /* 0x01 */ { STOPPED, WSTR("mswmsg"),         WSTR("endpoint mapper") },
    /* 0x02 */ { STOPPED, 0, 0 },
    /* 0x03 */ { STOPPED, 0, 0 },
    /* 0x04 */ { STOPPED, WSTR("ncacn_dnet_dsp"), WSTR("#69") },
    /* 0x05 */ { STOPPED, 0, 0 },
    /* 0x06 */ { STOPPED, 0, 0 },
    /* 0x07 */ { STOPPED, WSTR("ncacn_ip_tcp"),   WSTR("135") },
    /* 0x08 */ { STOPPED, WSTR("ncadg_ip_udp"),   WSTR("135") },
    /* 0x09 */ { STOPPED, WSTR("ncacn_nb_tcp"),   WSTR("135") },
    /* 0x0a */ { STOPPED, 0, 0 },
    /* 0x0b */ { STOPPED, 0, 0 },
    /* 0x0c */ { STOPPED, WSTR("ncacn_spx"),      WSTR("34280") },
    /* 0x0d */ { STOPPED, WSTR("ncacn_nb_ipx"),   WSTR("135") },
    /* 0x0e */ { STOPPED, WSTR("ncadg_ipx"),      WSTR("34281") },  // BUGBUG: tmp hack for wsock bug (PCHIU)
    /* 0x0f */ { STOPPED, WSTR("ncacn_np"),       WSTR("\\pipe\\epmapper") },
    /* 0x10 */ { STOPPED, WSTR("ncalrpc"),        WSTR("epmapper") },
    /* 0x11 */ { STOPPED, 0, 0 },
    /* 0x12 */ { STOPPED, 0, 0 },
    /* 0x13 */ { STOPPED, WSTR("ncacn_nb_nb"),    WSTR("135") },
    /* 0x14 */ { STOPPED, 0, 0 },
    /* 0x15 */ { STOPPED, 0, 0 }, // was ncacn_nb_xns - unsupported.
    /* 0x16 */ { STOPPED, WSTR("ncacn_at_dsp"),   WSTR("Endpoint Mapper") },
    /* 0x17 */ { STOPPED, WSTR("ncadg_at_ddp"),   WSTR("Endpoint Mapper") },
    /* 0x18 */ { STOPPED, 0, 0 },
    /* 0x19 */ { STOPPED, 0, 0 },
    /* 0x1A */ { STOPPED, WSTR("ncacn_vns_spp"),  WSTR("385")},
    /* 0x1B */ { STOPPED, 0, 0 },
    /* 0x1C */ { STOPPED, 0, 0 },
    /* 0x1D */ { STOPPED, 0, 0 },
    /* 0x1E */ { STOPPED, 0, 0 },
    /* 0x1F */ { STOPPED, WSTR("ncacn_http"), WSTR("593") },
    /* 0x20 */ { STOPPED, 0, 0 },
    };

#define PROTSEQ_IDS (sizeof(gaProtseqInfo)/sizeof(PROTSEQ_INFO))

#define ID_LPC  (0x10)
#define ID_WMSG (0x01)
#define ID_IPX  (0x0E)
#define ID_SPX  (0x0C)
#define ID_HTTP (0x1F)

typedef struct _sap_packet
{
    unsigned short response_type;
    unsigned short service_type;
    char           server_name[48];
    unsigned long  network;
    char           node[6];
    unsigned short socket;
    unsigned short hops;
} SAP_PACKET;

// We dynamically load wsock32.dll
typedef SOCKET
  (*WSocksocketFn) (
    int af,
    int type,
    int protocol
   );

typedef int
  (*WSockbindFn) (
    SOCKET s,
    const struct sockaddr FAR*  name,
    int namelen
   );

typedef int
  (*WSockgetsocknameFn) (
    SOCKET s,
    struct sockaddr FAR*  name,
    int FAR*  namelen
   );

typedef int
  (*WSockclosesocketFn) (
    SOCKET s
   );

typedef int
(*WSocksetsockoptFn) (
    SOCKET s, int level, int optname, const char FAR * optval, int optlen);

typedef int
(*WSocksendtoFn) (SOCKET s, const char FAR * buf, int len, int flags,
                       const struct sockaddr FAR *to, int tolen);

typedef INT
  (*WSockSetServiceAFn) (
    DWORD dwNameSpace,  // specifies name space(s) to operate within
    DWORD dwOperation,  // specifies operation to perform
    DWORD dwFlags,      // set of bit flags that modify function operation
    LPSERVICE_INFO lpServiceInfo,       // points to structure containing service information
    LPSERVICE_ASYNC_INFO lpServiceAsyncInfo,    // reserved for future use, must be NULL
    LPDWORD lpdwStatusFlags     // points to set of status bit flags
   );

typedef int (*WSockWSAStartupFn)(WORD wVersionRequired, LPWSADATA lpWSAData);

typedef int (*WSockWSACleanupFn)(void);

typedef int (*WSockgethostnameFn) (char * name, int namelen);

typedef struct hostent *
  (*WSockgethostbynameFn) (
    const char *name    // specifies name to resolve address
  );

typedef char *
  (*WSockinet_ntoaFn) (
    struct in_addr addr    // specifies address to convert
  );


HINSTANCE               hwsock32 = NULL;
WSocksocketFn           fpsocket;
WSockbindFn             fpbind;
WSockgetsocknameFn      fpgetsockname;
WSockclosesocketFn      fpclosesocket;
WSockSetServiceAFn      fpSetServiceA;
WSocksetsockoptFn       fpsetsockopt;
WSocksendtoFn           fpsendto;
WSockWSAStartupFn       fpWSAStartup;
WSockWSACleanupFn       fpWSACleanup;
WSockgethostnameFn      fpgethostname;
WSockgethostbynameFn    fpgethostbyname;
WSockinet_ntoaFn        fpinet_ntoa;


RPC_STATUS
UseProtseqIfNecessary(
    IN USHORT id
    )
/*++

Routine Description:

    Listens to the well known RPC endpoint mapper endpoint
    for the protseq.  Returns very quickly if the process
    is already listening to the protseq.

Arguments:

    id - the tower id of protseq.  See GetProtseqId() if you don't
         already have this valud.

Return Value:

    RPC_S_OK - no errors occured.
    RPC_S_OUT_OF_RESOURCES - when we're unable to setup security for the endpoint.
    RPC_S_INVALID_RPC_PROTSEQ - if id is unknown/invalid.

    Any error from RpcServerUseProtseqEp.

--*/
{
    RPC_STATUS status = RPC_S_OK;
    SECURITY_DESCRIPTOR sd, *psd;

    ASSERT(id);

    if (id == 0 || id >= PROTSEQ_IDS)
        {
        ASSERT(0);
        return(RPC_S_INVALID_RPC_PROTSEQ);
        }

    if (gaProtseqInfo[id].state == STARTED)
        {
        return(RPC_S_OK);
        }

    if (id == ID_LPC)
        {
        // ncalrpc needs a security descriptor.

        psd = &sd;

        InitializeSecurityDescriptor(
                        psd,
                        SECURITY_DESCRIPTOR_REVISION
                        );

        if ( FALSE == SetSecurityDescriptorDacl (
                            psd,
                            TRUE,                 // Dacl present
                            NULL,                 // NULL Dacl
                            FALSE                 // Not defaulted
                            ) )
            {
            status = RPC_S_OUT_OF_RESOURCES;
            }
        }
    else
        {
        psd = 0;
        }

    if (status == RPC_S_OK )
        {
        status = RpcServerUseProtseqEpW(gaProtseqInfo[id].pwstrProtseq,
                                       RPC_C_PROTSEQ_MAX_REQS_DEFAULT + 1,
                                       gaProtseqInfo[id].pwstrEndpoint,
                                       psd);

        // No locking is done here, the RPC runtime may return duplicate
        // endpoint if two threads call this at the same time.
        if (status == RPC_S_DUPLICATE_ENDPOINT)
            {
            ASSERT(gaProtseqInfo[id].state == STARTED);
            status = RPC_S_OK;
            }

        if (status == RPC_S_OK)
            {
            gaProtseqInfo[id].state = STARTED;
            if (id == ID_IPX || id == ID_SPX )
                {
                AdvertiseNameWithSap(TRUE);
                }
            }
        }

    return(status);
}


PWSTR
GetProtseq(
    IN USHORT ProtseqId
    )
/*++

Routine Description:

    Returns the unicode protseq give the protseqs tower id.

Arguments:

    ProtseqId - Tower id of the protseq in question.

Return Value:

    NULL if the id is invalid.

    non-NULL if the id is valid - note the pointer doesn't need to be freed.

--*/

{
    ASSERT(ProtseqId);

    if (ProtseqId < PROTSEQ_IDS)
        {
        return(gaProtseqInfo[ProtseqId].pwstrProtseq);
        }
    return(0);
}


PWSTR
GetEndpoint(
    IN USHORT ProtseqId
    )
/*++

Routine Description:

    Returns the well known endpoint associated with the protseq.

Arguments:

    ProtseqId - the id (See GetProtseqId()) of the protseq in question.

Return Value:

    0 - Unknown/invalid id.

    !0 - The endpoint associated with the protseq.
         note: should not be freed.

--*/
{
    ASSERT(ProtseqId);

    if (ProtseqId < PROTSEQ_IDS)
        {
        return(gaProtseqInfo[ProtseqId].pwstrEndpoint);
        }
    return(0);
}


USHORT
GetProtseqId(
    IN PWSTR Protseq
    )
/*++

Routine Description:

    Returns the tower id for a protseq.

    This could be changed to a faster search, but remember that
    eventually the table will NOT be static.  (ie. we can't just
    create a perfect hash based on the static table).

Arguments:

    Protseq - a unicode protseq to lookup.  It is assumed
              to be non-null.

Return Value:

    0 - unknown/invalid protseq
    non-zero - the id.

--*/
{
    int i;
    ASSERT(Protseq);

    for(i = 1; i < PROTSEQ_IDS; i++)
        {
        if (    0 != gaProtseqInfo[i].pwstrProtseq
             && 0 == wcscmp(gaProtseqInfo[i].pwstrProtseq, Protseq))
            {
            return(i);
            }
        }
    return(0);
}


USHORT
GetProtseqIdAnsi(
    IN PSTR pstrProtseq
    )
/*++

Routine Description:

    Returns the tower id for a protseq.

    This could be changed to a faster search, but remember that
    eventually the table will NOT be static.  (ie. we can't just
    create a perfect hash based on the static table).

Arguments:

    Protseq - an ansi (8 bit char) protseq to lookup.  It is assumed
              to be non-null.

Return Value:

    0 - unknown/invalid protseq
    non-zero - the id.

--*/
{
    int i;
    ASSERT(pstrProtseq);

    for(i = 1; i < PROTSEQ_IDS; i++)
        {
        if (0 != gaProtseqInfo[i].pwstrProtseq)
            {
            PWSTR pwstrProtseq = gaProtseqInfo[i].pwstrProtseq;
            PSTR  pstrT = pstrProtseq;

            while(*pstrT && *pwstrProtseq && *pstrT == *pwstrProtseq)
                {
                pstrT++;
                pwstrProtseq++;
                }
            if (*pstrT == *pwstrProtseq)
                {
                return(i);
                }
            }
        }
    return(0);
}


RPC_STATUS
InitializeEndpointManager(
    VOID
    )
/*++

Routine Description:

    Called when the dcom service starts.

    BUGBUG: Should read the protseqs, tower IDs and endpoints from the registry.

Arguments:

    None

Return Value:

    RPC_S_OUT_OF_MEMORY - if needed

    RPC_S_OUT_OF_RESOURCES - usually on registry failures.

--*/
{
    return(RPC_S_OK);
}


BOOL
IsLocal(
    IN USHORT ProtseqId
    )
/*++

Routine Description:

    Determines if the protseq id is local-only.
    (ncalrpc or mswmsg).

Arguments:

    ProtseqId - The id of the protseq in question.

Return Value:

    TRUE - if the protseq id is local-only
    FALSE - if the protseq id invalid or available remotely.

--*/
{
    return(ProtseqId == ID_LPC  || ProtseqId == ID_WMSG);
}


RPC_STATUS
DelayedUseProtseq(
    IN USHORT id
    )
/*++

Routine Description:

    If the protseq is not being used its state is changed
    so that a callto CompleteDelayedUseProtseqs() will actually
    cause the server to listen to the protseq.

Arguments:

    id - the id of the protseq you wish to listen to.

Return Value:

    0 - normally

    RPC_S_INVALID_RPC_PROTSEQ - if id is invalud.

--*/
{
    // For IPX and SPX
    if (id == ID_IPX || id == ID_SPX)
        {
        gfDelayedAdvertiseSaps = TRUE;
        }

    if (id < PROTSEQ_IDS)
        {
        if (gaProtseqInfo[id].pwstrProtseq != 0)
            {
            if (gaProtseqInfo[id].state == STOPPED)
                gaProtseqInfo[id].state = START;
            return(RPC_S_OK);
            }
        }
    return(RPC_S_INVALID_RPC_PROTSEQ);
}


VOID
CompleteDelayedUseProtseqs(
    VOID
    )
/*++

Routine Description:

    Start listening to any protseqs previously passed
    to DelayedUseProtseq().  No errors are returned,
    but informationals are printed on debug builds.

Arguments:

    None

Return Value:

    None

--*/
{
    USHORT i;

    for(i = 1; i < PROTSEQ_IDS; i++)
        {
        if (START == gaProtseqInfo[i].state)
            {
            RPC_STATUS status = UseProtseqIfNecessary(i);
#ifdef DEBUGRPC
            if (RPC_S_OK == status)
                ASSERT(gaProtseqInfo[i].state == STARTED);
#endif
            }
        }
    if (gfDelayedAdvertiseSaps)
        {
        gfDelayedAdvertiseSaps = FALSE;
        AdvertiseNameWithSap(FALSE);
        }
}


const GUID RPC_SAP_SERVICE_TYPE = { 0x000b0640, 0, 0, { 0xC0,0,0,0,0,0,0,0x46 } };

void _cdecl
AdvertiseNameWithSap(
    BOOL fServiceCheck
    )
/*++

Routine Description:

    Is this server is listening to IPX/SPX then, depending
    on what services are enabled on this machine, this
    function will enable SAPs on this machines address.  This
    allows RPC clients to resolve the pretty name of this
    server to a raw ipx address.


Arguments:

    fServiceCheck - If true, this function will only advertise
    with SAP if various services are installed.  If false,
    this will always turn on SAP.

Return Value:

    None

--*/
{
    DWORD status;
    DWORD ignore;

    // GetComputerName parameters
    CHAR        buffer[MAX_COMPUTERNAME_LENGTH + 1];

    // winsock (socket, bind, getsockname) parameters
    SOCKADDR_IPX ipxaddr;
    SOCKET       s;
    int          err;
    int          size;

    // SetService params
    SERVICE_INFOA     info;
    SERVICE_ADDRESSES addresses;

    // Only RPCSS does sapping

    if (   SapState == SapStateEnabled
        || (fServiceCheck && (SapState == SapStateNoServices)) )
        {
        return;
        }

    if (fServiceCheck)
        {
        HKEY        hKey;
        DWORD       lType;
        DWORD       lData;
        DWORD       lDataSize;
        HRESULT     hr;

        // Open the security key.
        hr = RegOpenKeyExA( HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Rpc",
                               0, KEY_QUERY_VALUE, &hKey );
        if (hr != ERROR_SUCCESS)
            return;

        lDataSize = sizeof(lData );
        hr = RegQueryValueExA( hKey, "EnableSapService", NULL, &lType,
                              (unsigned char *) &lData, &lDataSize );

        if (hr == ERROR_SUCCESS && lType == REG_SZ && lDataSize != 0 &&
            (*((char *) &lData) == 'y' || *((char *) &lData) == 'Y'))
            {
            // Close the registry key.
            RegCloseKey( hKey );
            }
        else
            {
            SapState = SapStateNoServices;
            // Close the registry key.
            RegCloseKey( hKey );
            return;
            }
        }

    if (FALSE == LoadWSockIfNecessary())
        {
        return;
        }

    // Get this server's name
    ignore = MAX_COMPUTERNAME_LENGTH + 1;
    if (!GetComputerNameA(buffer, &ignore))
        {
        return;
        }

    // Get this server's IPX address..blech..
    s = fpsocket( AF_IPX, SOCK_DGRAM, NSPROTO_IPX );
    if (s != -1)
        {
        size = sizeof(ipxaddr);

        memset(&ipxaddr, 0, sizeof(ipxaddr));
        ipxaddr.sa_family = AF_IPX;

        err = fpbind(s, (struct sockaddr *)&ipxaddr, sizeof(ipxaddr));
        if (err == 0)
            {
            err = fpgetsockname(s, (struct sockaddr *)&ipxaddr, &size);
            }
        }
    else
        {
        err = -1;
        }

    if (err != 0)
        {
        return;
        }

    if (s != -1)
        {
        fpclosesocket(s);
        }

    // We'll register only for the endpoint mapper port.  The port
    // value is not required but should be the same to avoid
    // confusing routers keeping track of SAPs...

    ipxaddr.sa_socket = 34280;

    // Fill in the service info structure.
    info.lpServiceType              = (GUID *)&RPC_SAP_SERVICE_TYPE;
    info.lpServiceName              = buffer;
    info.lpComment                  = "RPC Services";
    info.lpLocale                   = "";
    info.dwDisplayHint              = 0;
    info.dwVersion                  = 0;
    info.dwTime                     = 0;
    info.lpMachineName              = buffer;
    info.lpServiceAddress           = &addresses;
    info.ServiceSpecificInfo.cbSize = 0;

    // Fill in the service addresses structure.
    addresses.dwAddressCount                 = 1;
    addresses.Addresses[0].dwAddressType     = AF_IPX;
    addresses.Addresses[0].dwAddressLength   = sizeof(SOCKADDR_IPX);
    addresses.Addresses[0].dwPrincipalLength = 0;
    addresses.Addresses[0].lpAddress         = (PBYTE)&ipxaddr;
    addresses.Addresses[0].lpPrincipal       = NULL;

    // Set the service.
    status = fpSetServiceA(NS_SAP,
                         SERVICE_REGISTER,
                         0,
                         &info,
                         NULL,
                         &ignore);

    ASSERT(status == SOCKET_ERROR || status == 0);
    if (status == SOCKET_ERROR)
        {
        status = GetLastError();
        gfSapAdvertiseFailed = TRUE;
        FakeSapAdvertiseIfNecessary();
        }

    if (status == 0)
        {
        SapState = SapStateEnabled;
        }

    return;
}

void FakeSapAdvertiseIfNecessary(
    )
{
    DWORD status;
    DWORD ignore;
    BOOL Broadcast = TRUE;

    CHAR        buffer[MAX_COMPUTERNAME_LENGTH + 1];

    SOCKADDR_IPX ipxaddr;
    SOCKET       s;
    int          err;
    int          size;

    SAP_PACKET SapPacket;

    if (FALSE == LoadWSockIfNecessary())
        {
        return;
        }

    ignore = MAX_COMPUTERNAME_LENGTH + 1;
    if (!GetComputerNameA(buffer, &ignore))
        {
        return;
        }

    // Get this server's IPX address..blech..
    s = fpsocket( AF_IPX, SOCK_DGRAM, NSPROTO_IPX );
    if (s != -1)
        {
        size = sizeof(ipxaddr);
        memset(&ipxaddr, 0, sizeof(ipxaddr));
        ipxaddr.sa_family = AF_IPX;

        err = fpbind(s, (struct sockaddr *)&ipxaddr, sizeof(ipxaddr));
        if (err == 0)
            {
            err = fpgetsockname(s, (struct sockaddr *)&ipxaddr, &size);
            }
        }
    else
        {
        err = -1;
        }

    if (err != 0)
        {
        return;
        }

    if (-1 == (err = fpsetsockopt(s, SOL_SOCKET, SO_BROADCAST,(const char *)&Broadcast,sizeof(BOOL))))
        {
        err = -1;
        }

    if (err != -1)
        {
        ipxaddr.sa_socket = 0x5204;

        memset(&SapPacket,0,sizeof(SAP_PACKET));
        SapPacket.response_type = 0x0200;
        SapPacket.service_type = 0x04006;
        lstrcpy(SapPacket.server_name,buffer);
        CopyMemory((PVOID)&(SapPacket.network),
                   (CONST PVOID) ipxaddr.sa_netnum, 4);
        CopyMemory((PVOID)SapPacket.node, ipxaddr.sa_nodenum,6);
        SapPacket.socket = 0xe885;
        SapPacket.hops = 0x100;

        memset(ipxaddr.sa_nodenum,0xff,6);

        err = fpsendto( s, (const char FAR *)&SapPacket, 66, 0,
                    (PSOCKADDR)&ipxaddr, sizeof(SOCKADDR_IPX));
        if ( err == SOCKET_ERROR)
            {
            gfSapAdvertiseFailed = FALSE;
            }
        }

    fpclosesocket(s);
}

BOOL LoadWSockIfNecessary()
{
    // Load wsock32.dll
    if (hwsock32 == NULL)
    {
        hwsock32 = LoadLibraryA( "wsock32.dll" );
        ASSERT(hwsock32);
        if (hwsock32 == NULL)
            {
            return FALSE;
            }

        // Get the function addresses
        fpsocket = (WSocksocketFn) GetProcAddress( hwsock32, "socket");
        ASSERT(fpsocket);
        fpbind = (WSockbindFn) GetProcAddress( hwsock32, "bind");
        ASSERT(fpbind);
        fpgetsockname = (WSockgetsocknameFn) GetProcAddress( hwsock32, "getsockname");
        ASSERT(fpgetsockname);
        fpclosesocket = (WSockclosesocketFn) GetProcAddress( hwsock32, "closesocket");
        ASSERT(fpclosesocket);
        fpSetServiceA = (WSockSetServiceAFn) GetProcAddress( hwsock32, "SetServiceA");
        ASSERT(fpSetServiceA);
        fpsetsockopt = (WSocksetsockoptFn) GetProcAddress( hwsock32, "setsockopt");
        ASSERT(fpsetsockopt);
        fpsendto = (WSocksendtoFn) GetProcAddress( hwsock32, "sendto");
        ASSERT(fpsendto);
        fpWSAStartup = (WSockWSAStartupFn) GetProcAddress( hwsock32, "WSAStartup");
        ASSERT(fpWSAStartup);
        fpWSACleanup = (WSockWSACleanupFn) GetProcAddress( hwsock32, "WSACleanup");
        ASSERT(fpWSACleanup);
        fpgethostname = (WSockgethostnameFn)GetProcAddress( hwsock32, "gethostname");
        ASSERT(fpgethostname);
        fpgethostbyname = (WSockgethostbynameFn)GetProcAddress( hwsock32, "gethostbyname");
        ASSERT(fpgethostbyname);
        fpinet_ntoa = (WSockinet_ntoaFn)GetProcAddress( hwsock32, "inet_ntoa");
        ASSERT(fpinet_ntoa);
        

        if ((fpsocket == NULL) ||
            (fpbind == NULL) ||
            (fpgetsockname == NULL) ||
            (fpclosesocket == NULL) ||
            (fpsetsockopt == NULL) ||
            (fpsendto == NULL) ||
            (fpSetServiceA == NULL) || 
            (fpWSAStartup == NULL) ||
            (fpWSACleanup == NULL) ||
            (fpgethostname == NULL) ||
            (fpgethostbyname == NULL) ||
            (fpinet_ntoa == NULL))
            {
            FreeLibrary(hwsock32);
            hwsock32 = NULL;
            return FALSE;
            }
    }
    return TRUE;
}

int COMWSAStartup(WORD wVersionRequired, LPWSADATA lpWSAData)
{
    if (hwsock32 && fpWSAStartup)
    {
        return fpWSAStartup(wVersionRequired, lpWSAData);
    }
    return SOCKET_ERROR;
}

int COMWSACleanup(void)
{
    if (hwsock32 && fpWSACleanup)
    {
        return fpWSACleanup();
    }
    return SOCKET_ERROR;
}

int COMgethostname(char * name, int namelen)
{
    if (hwsock32 && fpgethostname)
    {
        return fpgethostname(name, namelen);
    }
    return SOCKET_ERROR;
}

struct hostent * COMgethostbyname(const char *name)
{
    if (hwsock32 && fpgethostbyname)
    {
        return fpgethostbyname(name);
    }
    return NULL;
}

char *  COMinet_ntoa(struct in_addr addr)
{
    if (hwsock32 && fpinet_ntoa)
    {
        return fpinet_ntoa(addr);
    }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\objex\shrmem\dcom95\mutex.cxx ===
/*++

Microsoft Windows NT RPC Name Service
Copyright (c) 1996-1997 Microsoft Corporation

Module Name:

    mutex.cxx

Abstract:

    This file contains the implementations for non inline member functions of
    class CGlobalMutex, which implements a multi-owner mutex to protect the
    resolver's shared memory data structures.

Author:

    Satish Thatte (SatishT) 09/01/96

--*/

#define NULL 0

extern "C" {
#include <windows.h>
}

#include <mutex.hxx> 


CGlobalMutex::CGlobalMutex(
							long lMaxCount
							) 
/*++

Routine Description:

    create a semaphore and initialize the handle member pNTSem.

--*/
{	
    hGlobalMutex = CreateMutex(
            NULL,                 //  LPSECURITY_ATTRIBUTES   lpsa
            FALSE,               //  BOOL                    fInitialOwner
            GLOBAL_CS           //  LPCTSTR                 lpszMutexName
            );

    //
    // If the mutex create/open failed, then bail
    //

    if ( !hGlobalMutex )
    {
        return LAST_SCODE;
    }

    if ( GetLastError() == ERROR_ALREADY_EXISTS ) 
    {
    }
}



CGlobalMutex::~CGlobalMutex() 
/*++

Routine Description:

    close the semaphore handle.

--*/
{
	CloseHandle(pNTSem);
}


void
CGlobalMutex::Enter() 
/*++

Routine Description:

    Wait for the semaphore count to become nonzero.

--*/
{
	WaitForSingleObject(pNTSem,INFINITE);
}


void
CGlobalMutex::Leave(long lIncrement) 
/*++

Routine Description:

    Increment the semaphore count by lIncrement to release lIncrement "slots".

--*/
{
	ReleaseSemaphore(pNTSem,lIncrement,NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\objex\shrmem\dcom95\mid.cxx ===
/*++

Copyright (c) 1996-1997 Microsoft Corporation

Module Name:

    Mid.cxx

Abstract:

    Implements the CMid class.

Author:

    SatishT     04-13-96

--*/

#include<or.hxx>

//
// declare the resolver handle cache privately held by COrBindingIterator
//

TCSafeResolverHashTable<CResolverHandle> 
    COrBindingIterator::ResolverHandles(ResolverHandleCacheSize);


//
// CRpcssHandle methods
//

BOOL
CRpcssHandle::TryDynamic()
{
    if (_fDynamic)
    {
        return FALSE;
    }
    else
    {
        RPC_STATUS status = RpcBindingReset(_hOR);
        if (status == RPC_S_OK)
        {
            _fDynamic = TRUE;
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }
}


BOOL
CRpcssHandle::TryUnsecure()
{
    if (!_fSecure)
    {
        return FALSE;
    }
    else
    {
        RPC_STATUS status = RpcBindingSetAuthInfoA(_hOR,
                                                   NULL,
                                                   RPC_C_AUTHN_LEVEL_NONE,
                                                   0,
                                                   0,
                                                   0);
        if (status == RPC_S_OK)
        {
            _fSecure = FALSE;
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }
}


ORSTATUS
CRpcssHandle::Reset(RPC_BINDING_HANDLE hIn)
{
    ASSERT(hIn != NULL);
    Clear();

    RPC_STATUS status = RpcBindingCopy(hIn,&_hOR);

    if (status == RPC_S_OK)
    {
        // BUGBUG:  As usual, this is very NT specific
        status = RpcBindingSetAuthInfoA(_hOR,
                                       (UCHAR*)"Default",
                                       RPC_C_AUTHN_LEVEL_CONNECT,
                                       RPC_C_AUTHN_WINNT,
                                       0,
                                       0);

        if (status != RPC_S_OK)
        {
            ComDebOut((DEB_OXID,"OR: RpcBindingSetAuthInfo failed for OR handle with %d\n",
                       status));

            // Just fall back on unsecure.
            TryUnsecure();
            status = RPC_S_OK;
        }
    }

    return status;
}


//
// BindingIterator methods
//


COrBindingIterator::COrBindingIterator(CMid *pMid )
: _pMid(pMid), _bIter(pMid->_iStringBinding,pMid->_dsa)
{
    ASSERT(!_pMid->IsLocal());      // should never call for local
    _pCurrentHandle = ResolverHandles.Lookup(CIdKey(pMid->GetMID()));
}


CResolverHandle *   COrBindingIterator::First()
/*++

Method Description:

    Gets the first possible RPC binding handle to the remote machine.
    This is successful only if we have an uncleared (and hence presumably
    working) resolver handle in the static table of handles in this class.
    If not, we defer to COrBindingIterator::Next().

Arguments:

    None

Return Value:

    NULL - resource allocation or connection failure

    non-NULL - A binding to the machine.

--*/
{
    if (_pCurrentHandle && !_pCurrentHandle->IsEmpty())
    {
        return _pCurrentHandle;    // Already have one, so try it
    }
    else
    {
        return Next();
    }
}


CResolverHandle *   COrBindingIterator::Next()
/*++

Method Description:

    Gets the next possible RPC binding handle to the remote machine.
    We get here only if First finds no usable handle in ResolverHandles
    which happens only if

    1.  At the first contact with this OR.

    2.  At subsequent contacts, a current handle failed (some service needed by
        that protseq may have failed, or we have a network partition).
        This includes the possibility that we never successfully talk to this OR.

Arguments:

    None

Return Value:

    NULL - resource allocation or connection failure

    non-NULL - A binding to the machine.

--*/
{
    _pMid->_fBindingWorking = FALSE;     // no, just to be double sure

    if (_pCurrentHandle)  // get rid of it since it is apparently not working
    {
        ResolverHandles.Remove(*_pCurrentHandle);
        _pCurrentHandle = NULL;
    }

    PWSTR pwstrT;
    RPC_BINDING_HANDLE hMachine = NULL;

    while((hMachine == NULL) && (pwstrT = _bIter.Next()) != NULL)
    {
        // ronans - dcomhttp CODEWORK - generalize this to make list of client side protocols
        // which may be used even if machine cannot act as server on these protocols
        if (IsMemberOf(*pwstrT,*gpcRemoteProtseqs,gpRemoteProtseqIds) || 
            ((*pwstrT == ID_DCOMHTTP) && gpfClientHttp && *gpfClientHttp))
        {
            hMachine = GetBindingToOr(pwstrT);
        }
    }

    if (NULL != hMachine)    // did we get anything?
    {
        ComDebOut((DEB_OXID,"OR: COrBindingIterator::Next %ls\n", pwstrT));

        _pCurrentHandle = new CResolverHandle(_pMid->GetMID());
        if (_pCurrentHandle != NULL)
        {
            _pCurrentHandle->Reset(hMachine);     // OK we have it, copy it in
            RpcBindingFree(&hMachine);            // and free the original
            _pMid->_iStringBinding = _bIter.Index(); // remember where we are
            ResolverHandles.Add(_pCurrentHandle); // cache the handle in table

        }
    }

    return _pCurrentHandle;
}


//
//  CMid methods
//

// private method used in the constructor and elsewhere to try
// contacting the target resolver to establish the correct binding to use

void CMid::ResetBinding()
{
    ComDebOut((DEB_OXID,"OR: enter CMid::ResetBinding\n"));

    COrBindingIterator bindIter(this);
    CResolverHandle *pOrHandle;

    for (pOrHandle = bindIter.First();
         pOrHandle != NULL;
         pOrHandle = bindIter.Next()
        )
    {
        RPC_BINDING_HANDLE hRemoteOr = pOrHandle->GetRpcHandle();

        // Use unsecure handle since this is address resolution
        // we are not spoofing proof anyway
        RPC_STATUS status = RpcBindingSetAuthInfoA(
                                            hRemoteOr,
                                            NULL,
                                            RPC_C_AUTHN_LEVEL_NONE,
                                            0,
                                            0,
                                            0
                                            );
         {
            CTempReleaseSharedMemory temp;

            status = ::ServerAlive(hRemoteOr);    // try a ping
         }

         if (status == RPC_S_OK)
         {
             _fBindingWorking = TRUE;   // mark this Mid as functional
             break;
         }

         _fBindingWorking = FALSE;      // mark this Mid as NOT functional
     }

     if (!gfThisIsRPCSS && pOrHandle)   // don't stick RPCSS with this handle
     {
         pOrHandle->Clear();
     }
}


// define the static members for page-based allocation
DEFINE_PAGE_ALLOCATOR(CMid)

CMid::CMid(
  DUALSTRINGARRAY *pdsa,
  ORSTATUS& status,
  USHORT wProtSeq,        // if the SCM tells us what to use  
  MID mid,                // sometimes needed for the local MID
  BOOL fCheckNetAddress   // Should I ping for multinet resolver?
  ) :
    _id(mid),
    _iStringBinding(0),
    _iSecurityBinding(0),
    _fBindingWorking(FALSE),
    _dsa(pdsa,TRUE,status),
    _dwExpirationTime(0),
    _sequenceNum(0),
    _setID(0),
    _cFailedPings(0),
    _fPingThreadIsInside(FALSE)
 {
        if (wProtSeq > 0)
        {
            PWSTR pwstr = FindMatchingProtseq(wProtSeq,pdsa->aStringArray);

            if (NULL != pwstr)
            {
                _iStringBinding = pwstr - pdsa->aStringArray;
            }
        }

        if (fCheckNetAddress)
        {
            //  We need to figure out which address works for us
			ResetBinding();
        }
 }


BOOL
CMid::HasExpired()
{
    BOOL fResult = FALSE;

    // First check if a ping thread died while calling PingServer
    // on this MID, or pinging has been unsuccessful long enough
    if (_fPingThreadIsInside || _cFailedPings >= 3)
    {
        fResult = TRUE;           // this isn't working
    }
    else
    {
        BOOL fUseless =
               !IsLocal() &&                  // not local
               References() == 1 &&           // no Oxids
               _pingSet.IsEmpty() &&          // nothing to ping
               _addOidList.IsEmpty() &&       // nothing to add
               _dropOidList.IsEmpty();        // nothing to drop

        if (fUseless && _dwExpirationTime > 0)
        {
            fResult =   (CTime() - CTime(_dwExpirationTime)) > BaseTimeoutInterval;
        }
        else if (fUseless)
        {
            _dwExpirationTime = GetTickCount();
        }
        else
        {
            _dwExpirationTime = 0;
        }
    }

    // If the CMid has expired, it will be removed from the MidTable and Oids
    // and Oxids in it will never be run down, so they should be run down here
    // As far as the resolver is concerned, the Oids and Oxids belonging
    // to this Mid no longer exist

    if (fResult)
    {
        COxidList DisownList;
        COxidTableIterator OxidTableIter(*gpOxidTable);
        COxid *pOxid;

        // First gather all Oxids at this Mid
        while (pOxid = OxidTableIter.Next())
        {
            if (pOxid->GetMid() == this)
            {
                DisownList.Insert(pOxid);
            }
        }

        // Now disown them
        COxidListIterator DisownIter;
        DisownIter.Init(DisownList);

        while (pOxid = DisownIter.Next())
        {
            ASSERT(!pOxid->IsLocal());
            ASSERT(pOxid->GetProcess() == gpPingProcess);
            gpPingProcess->DisownOxid(pOxid,FALSE);
        }


        // Now we can clean up the _dropOidList
        COidListIterator OidListIter;
        OidListIter.Init(_dropOidList);
        COid *pOid, *pOidRemoved;

        while (pOid = OidListIter.Next())
        {
            // every Oid in this has been Disowned by its Oxid
            // as the following ASSERT says
            ASSERT(pOid->GetOxid()->DisownOid(pOid) == NULL);

            pOidRemoved = gpOidTable->Remove(*pOid);

            // the pOid should still have been in the gpOidTable
            ASSERT(pOid==pOidRemoved || NULL==pOidRemoved);
        }

        // OK, now get rid of all these Oids
        _pingSet.RemoveAll();
        _addOidList.Clear();
        _dropOidList.Clear();

        // And release other resources, if any
        COrBindingIterator::ResolverHandles.Remove(CIdKey(GetMID()));
    }

    return fResult;
}


// The invariant is that each remote Oid is in exactly one of the
// corresponding Mid's data structures: _pingSet, _addOidList, _dropOidList

// Remember that it is possible for a COid object to be run down and
// another COid object with the same OID/MID combination to be created
// and used later if the ping following the rundown fails.  In order to avoid
// getting two COid objects with the same OID/MID, we do not remove a remote COid
// from the gpOidTable until it has been dropped from the Mid's data structures


ORSTATUS
CMid::AddClientOid(COid *pOid)
{
    ORSTATUS status = OR_OK;

    // this way, we have the same number of refs on the Oid
    // as we would if we were already pinging it.  The ref is
    // held by the _addOidList instead of the _pingSet

    if (_pingSet.Lookup(*pOid) == NULL)
    {
        status = _addOidList.Insert(pOid);
    }

    if (status == OR_I_DUPLICATE)
    {
        status = OR_OK;
    }

    // if we were planning to drop it, cease and desist
    // this should only happen if a _dropOidList gets carried over to
    // the next ping period because a ping fails

    // If this is in the _dropOidList it was not in the _pingSet
    // and therefore must have gotten added to the _addOidList

    if (status == OR_OK)  // be cautious
    {
        _dropOidList.Remove(*pOid);
    }

    return status;
}


ORSTATUS
CMid::DropClientOid(COid *pOid)
{
    ORSTATUS status = _dropOidList.Insert(pOid);

    if (status == OR_I_DUPLICATE)
    {
        status = OR_OK;
    }

    // The only way this is called is if the PingThread decided to
    // run this Oid down, which means no one is using it, and in fact
    // hasn't been using it for a BaseTimeoutInterval

    if (status == OR_OK)  // be cautious
    {
        COid *pAdd = _addOidList.Remove(*pOid);         // at most one of these ops
        COid *pPing = _pingSet.Remove(*pOid);           // will actually work

        ASSERT(pAdd==NULL || pPing==NULL);
    }

    return status;
}



RPC_STATUS
NegotiateDCOMVersion(
    IN OUT  COMVERSION *pVersion
    )
/*++

Routine Description:

    // Called when we receive a COMVERSION from a remote machine
    // to determine which DCOM protocol level to talk.

Arguments:

    pVersion - version of the remote machine. Modified if necessary
               by this routine to be the lower of the two versions.

Return Value:

    OR_OK

--*/
{
    if (pVersion->MajorVersion == COM_MAJOR_VERSION)
    {
        if (pVersion->MinorVersion > COM_MINOR_VERSION)
        {
           // since the client has a lower minor version number,
           // use the lower of the two.
           pVersion->MinorVersion = COM_MINOR_VERSION;
        }

        return OR_OK;
    }
    return RPC_E_VERSION_MISMATCH;
}



ORSTATUS
CMid::ResolveRemoteOxid(
    IN OXID Oxid,
    OUT OXID_INFO *poxidInfo
    )
{
    ComDebOut((DEB_OXID,"OR: enter CMid::ResolveRemoteOxid\n"));

    // Remote OXID, call ResolveOxid

    ORSTATUS status = RPC_S_INVALID_BINDING;

    USHORT   tmpProtseq;
    RPC_BINDING_HANDLE hRemoteOr;

    poxidInfo->psa = NULL;

    COrBindingIterator bindIter(this);
    CResolverHandle *pOrHandle;

    for (pOrHandle = bindIter.First();
         pOrHandle != NULL;
         pOrHandle = bindIter.Next()
        )
    {
        RPC_BINDING_HANDLE hRemoteOr = pOrHandle->GetRpcHandle();

        tmpProtseq = ProtseqOfServer();
        if (tmpProtseq == 0)
        {
            status = RPC_S_INVALID_BINDING;
            break;
        }

        poxidInfo->dwTid = poxidInfo->dwPid = 0;    // marks a remote OXID

        BOOL fRetry = FALSE;

        do
        {
             {
                CTempReleaseSharedMemory temp;

                // try calling ResolveOxid2 first, if that fails,
                // try ResolveOxid.
                status = ResolveOxid2(
                                 hRemoteOr,
                                 &Oxid,
                                 1,
                                 &tmpProtseq,
                                 &poxidInfo->psa,
                                 &poxidInfo->ipidRemUnknown,
                                 &poxidInfo->dwAuthnHint,
                                 &poxidInfo->version
                                 );

                if (status == RPC_S_PROCNUM_OUT_OF_RANGE)
                {
                    // must be a downlevel server (COMVERSION == 5.1), try calling on
                    // the old ResolveOXID method.
                    poxidInfo->version.MajorVersion = COM_MAJOR_VERSION;
                    poxidInfo->version.MinorVersion = COM_MINOR_VERSION_1;
                    poxidInfo->dwFlags   = 0;

                    status = ::ResolveOxid(
                                     hRemoteOr,
                                     &Oxid,
                                     1,
                                     &tmpProtseq,
                                     &poxidInfo->psa,
                                     &poxidInfo->ipidRemUnknown,
                                     &poxidInfo->dwAuthnHint
                                     );
                }

                if (status == OR_OK)
                {
                    status = NegotiateDCOMVersion(&poxidInfo->version);
                }
             }

             switch (status)
             {
             case RPC_S_UNKNOWN_IF:
                 fRetry = pOrHandle->TryDynamic();
                 hRemoteOr = pOrHandle->GetRpcHandle();
                 continue;

             case ERROR_ACCESS_DENIED:
             case RPC_S_UNKNOWN_AUTHN_SERVICE:
             case RPC_S_UNKNOWN_AUTHN_LEVEL:
             case RPC_S_INVALID_AUTH_IDENTITY:
             case RPC_S_SEC_PKG_ERROR:

                 fRetry = pOrHandle->TryUnsecure();
                 hRemoteOr = pOrHandle->GetRpcHandle();
                 continue;

             default:
                 fRetry = FALSE;
             }

        }
        while (fRetry);

        if ((status == OR_OK) || (status == OR_BADOXID))
        {
            _fBindingWorking = TRUE;    // mark this Mid as functional
            break;
        }

        _fBindingWorking = FALSE;       // mark this Mid as NOT functional
    }

    if (status == OR_OK)
    {
        ASSERT(poxidInfo->psa && "Remote resolve succeeded but no bindings returned");
    }

    return status;
}



void
CMid::ClearSet(COidList &dropList)
{
    COid *pOid;

    // This set is no longer valid -- clear current set
    // but remove only dropped Oids from the global table
    // because we know those have been run down and are
    // not in use on this machine

    _pingSet.RemoveAll();

    // Since this is called only from Pingserver, the ping thread
    // should not have been able to add anything to the _dropOidList
    ASSERT(_dropOidList.IsEmpty());

    COidListIterator Oids;
    Oids.Init(dropList);

    while(pOid = Oids.Next())
    {
        // every Oid in this has been Disowned by its Oxid
        // as the following ASSERT says
        ASSERT(pOid->GetOxid()->DisownOid(pOid) == NULL);

        COid* pOidRemoved = gpOidTable->Remove(*pOid);
        ASSERT(pOidRemoved==pOid || NULL==pOidRemoved);
    }

    dropList.Clear();

    _setID = 0;
    _sequenceNum = 0;
    _cFailedPings = 0;
}


ORSTATUS
CMid::PingServer()
{
    ComDebOut((DEB_OXID,"OR: enter CMid::PingServer\n"));

    // Setting this flag lets us detect the situation
    // where the PingThread terminates abnormally
    SetFlagForScope PingThread(_fPingThreadIsInside);

    if (_addOidList.IsEmpty() && _dropOidList.IsEmpty() && _pingSet.IsEmpty())
    {
        return OR_OK;     // nothing to do
    }

    ORSTATUS status;
    RPC_BINDING_HANDLE hRemoteOr;

    COrBindingIterator bindIter(this);
    CResolverHandle *pOrHandle;

    if (!_addOidList.IsEmpty() || !_dropOidList.IsEmpty())
    {
        // need complex ping

        USHORT cAddToSet = _addOidList.Size();
        USHORT cDelFromSet = _dropOidList.Size();
        COidList addOidListSent, dropOidListSent;

        OID *aAddToSet = (OID*) alloca(sizeof(OID)*cAddToSet);
        OID *aDelFromSet = (OID*) alloca(sizeof(OID)*cDelFromSet);

        COidListIterator AddIter;
        AddIter.Init(_addOidList);
        USHORT i;
        COid *pOid;

        for (pOid = AddIter.Next(), i=0; pOid != NULL; pOid = AddIter.Next())
        {
            aAddToSet[i++] = pOid->GetOID();
            ASSERT(_pingSet.Lookup(*pOid)==NULL);  // should not be already in Ping set
        }

        COidListIterator DropIter;
        DropIter.Init(_dropOidList);

        for (pOid = DropIter.Next(), i=0; pOid != NULL; pOid = DropIter.Next())
        {
            aDelFromSet[i++] = pOid->GetOID();
        }

        // Transfer the current _addOidList and _dropOidList and set them to
        // empty since we are releasing the shared memory lock.

        _addOidList.Transfer(addOidListSent);
        _dropOidList.Transfer(dropOidListSent);

        // Now release the lock and ping.

        status = RPC_S_INVALID_BINDING;  // In case bindIter fails to deliver

        for (pOrHandle = bindIter.First();
             pOrHandle != NULL;
             pOrHandle = bindIter.Next()
            )
        {
            RPC_BINDING_HANDLE hRemoteOr = pOrHandle->GetRpcHandle();

            BOOL fRetry = FALSE;

            do
            {
                {
                    CTempReleaseSharedMemory temp;

                    status = ::ComplexPing(
                                        hRemoteOr,
                                        &_setID,
                                        ++_sequenceNum,
                                        cAddToSet,
                                        cDelFromSet,
                                        aAddToSet,
                                        aDelFromSet,
                                        &_pingBackoffFactor
                                        );
                 }

                 switch (status)
                 {
                 case RPC_S_UNKNOWN_IF:
                     fRetry = pOrHandle->TryDynamic();
                     hRemoteOr = pOrHandle->GetRpcHandle();
                     continue;

                 case ERROR_ACCESS_DENIED:
                 case RPC_S_UNKNOWN_AUTHN_SERVICE:
                 case RPC_S_UNKNOWN_AUTHN_LEVEL:
                 case RPC_S_INVALID_AUTH_IDENTITY:
                 case RPC_S_SEC_PKG_ERROR:

                     fRetry = pOrHandle->TryUnsecure();
                     hRemoteOr = pOrHandle->GetRpcHandle();
                     continue;

                 default:
                     fRetry = FALSE;
                 }
            }
            while (fRetry);

            if (status == OR_OK || status == OR_BADOID || status == OR_BADSET)
            {
                _fBindingWorking = TRUE;    // mark this Mid as functional
                break;
            }

            _fBindingWorking = FALSE;       // mark this Mid as NOT functional
        }

        // If we added some Oids while we were dropping them, we want
        // to keep the Oids around in the gpOidTable and elsewhere
        dropOidListSent.Remove(_addOidList);

        switch (status)
        {
        case OR_OK:
        case OR_BADOID: // we don't know which one, and anyway, it doesn't matter

            {   // this scope is just for OidListIter

                // use an iterator instead of Pop to avoid the situation
                // where the Pop causes the ref count to drop to zero
                // causing a crash immediately thereafter

                // We need this defensive change because all the race
                // conditions involved here are not yet understood

                COidListIterator OidListIter;
                OidListIter.Init(addOidListSent);

                while (pOid = OidListIter.Next())
                {
                    status = _pingSet.Add(pOid);
                    ASSERT(status != OR_I_DUPLICATE);
                    if (status != OR_OK)
                    {
                        break;
                    }
                }

                // If we added some Oids during this ping that were already
                // added as part of the ping, we don't want to add them again
                _addOidList.Remove(addOidListSent);

                // we can finally get rid of these Oids altogether

                OidListIter.Init(dropOidListSent);

                while (pOid = OidListIter.Next())
                {
                    COid* pOidRemoved = gpOidTable->Remove(*pOid);
                    ASSERT(pOidRemoved==pOid || NULL==pOidRemoved);
                }

                _cFailedPings = 0;
            }
            break;

        case OR_BADSET:
            // this ping set is invalid, clear it.
            ClearSet(dropOidListSent);
            _cFailedPings = 0;
            break;

        default:              // RPC failure
            // we could not have dropped anything new since
            // this is the thread that does rundown for remote Oids
            ASSERT(_dropOidList.IsEmpty());
            dropOidListSent.Transfer(_dropOidList); // try again next time
            _addOidList.Merge(addOidListSent);      // try again next time
            _cFailedPings++;
        }


        // the addOidListSent and dropOidListSent will be cleared automagically
        // at the end of this scope by their destructors

        if (_pingSet.IsEmpty())
        {
            _setID = 0;     // server OR will delete the set
            _sequenceNum = 0;
        }
    }

    else if (_setID != 0)
    {
        // need simple ping
        {
            // no retries for simple pinging
            CResolverHandle *_pCurrentHandle = 
                  COrBindingIterator::ResolverHandles.Lookup(CIdKey(GetMID()));

            RPC_BINDING_HANDLE hRemoteOr = _pCurrentHandle ? 
                                           _pCurrentHandle->GetRpcHandle() : 
                                           NULL;

            if (hRemoteOr != NULL)
            {
                 CTempReleaseSharedMemory temp;

                 status = ::SimplePing(
                                hRemoteOr,
                                &_setID
                                );
            }
            else
            {
                status = OR_BADSET;
            }
        }

        switch (status)
        {
        case OR_BADSET:
            // this ping set is invalid, clear it.
            ClearSet(COidList());

            // fall through

        case OR_OK:
            _cFailedPings = 0;
            _fBindingWorking = TRUE;    // mark this Mid as functional
            break;

        default:                        // RPC failure
            _cFailedPings++;
            _fBindingWorking = FALSE;   // mark this Mid as NOT functional
        }
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\objex\shrmem\dcom95\manager.cxx ===
/*++

Copyright (c) 1996-1997 Microsoft Corporation

Module Name:

    Manager.cxx

Abstract:

    InProc OR entry points

Author:

    Satish Thatte    [SatishT]       Feb-07-1996

--*/


#include <or.hxx>


//
// Update the channel hook list if it has changed in the registry.
//

void UpdateChannelHooks( LONG *pcChannelHook, GUID **paChannelHook )
{
    DWORD cChannelHook = gpSecVals->s_cChannelHook;

    if (cChannelHook == 0)
    {
        *pcChannelHook = 0;
        *paChannelHook = NULL;
        return;
    }

    GUID * aChannelHook = gpSecVals->s_aChannelHook;

    // Return the channel hook list.
    *paChannelHook = (GUID *) MIDL_user_allocate(cChannelHook * sizeof(GUID));
    if (*paChannelHook != NULL)
    {
        *pcChannelHook = cChannelHook;
        memcpy(*paChannelHook, aChannelHook, cChannelHook * sizeof(GUID));
    }
    else
        *pcChannelHook = 0;
}

//
//    Manager (server-side) calls to the local OR interface. lclor.idl
//

error_status_t
ConnectDCOM(
    IN OUT HPROCESS *phProcess,
    OUT ULONG       *pdwTimeoutInSeconds,
    OUT MID         *pLocalMid,
    OUT ULONG       *pfConnectFlags,
    OUT DWORD       *pAuthnLevel,
    OUT DWORD       *pImpLevel,
    OUT DWORD       *pThreadID
    )
{
    CProcess *hProcess;

    *phProcess = NULL;  // in case of failure

    ORSTATUS status = StartDCOM();

    if (status != OR_OK)
    {
		if (status != OR_I_REPEAT_START)	
		{
			return status;
		}
		else
		{
			status = OR_OK;
		}
    }

    *pdwTimeoutInSeconds = BaseTimeoutInterval;
    *pLocalMid = gLocalMID;

    // Fill in security parameters.

    *pfConnectFlags = 0;

    if (gpSecVals->s_fEnableDCOM == FALSE) *pfConnectFlags |= CONNECT_DISABLEDCOM;
    if (gpSecVals->s_fMutualAuth) *pfConnectFlags |= CONNECT_MUTUALAUTH;
    if (gpSecVals->s_fSecureRefs) *pfConnectFlags |= CONNECT_SECUREREF;

    *pAuthnLevel   = gpSecVals->s_lAuthnLevel;
    *pImpLevel     = gpSecVals->s_lImpLevel;

    if (status != OR_OK) return status;

    CProtectSharedMemory protector; // locks through rest of lexical scope

    *pThreadID = (*gpNextThreadID)++;

    hProcess = new CProcess(
        AllocateId()
        );

    if (hProcess)
    {
        gpProcess = *phProcess = hProcess;
        status = gpProcessTable->Add(hProcess);     // BUGBUG: and rundown an old process,
                                           // if there is one, with the same _processID
    }
    else
    {
        status = OR_NOMEM;
    }

    OrDbgDetailPrint(("OR: Client connected\n"));

    CheckORdata();

    return(status);
}



void UninitializeGlobals();  // private routine for resources release

error_status_t Disconnect(
    IN OUT HPROCESS       *phProcess
    )
{
    ASSERT(*phProcess!=NULL);
    CProcess *hProcess = *phProcess;

	{
		CProtectSharedMemory protector; // locks through rest of lexical scope
										// special scope needed since we delete
										// the global mutex immediately after

		CheckORdata(); // DBG only

		// run down context handle for current process
		hProcess->Rundown();
		gpProcessTable->Remove(*hProcess);
		*phProcess = NULL;

        // Do this before uninitializing globals!
		CheckORdata(); // DBG only

        // this does not delete gpMutex since we are holding it
        // however, it sets gpMutex to NULL so no other thread can 
        // take it in this process
        UninitializeGlobals();   // release global resources
	}

    return OR_OK;
}



error_status_t
AllocateReservedIds(
    IN LONG cIdsToReserve,
    OUT ID *pidReservedBase
    )
/*++

Routine Description:

    Called by local clients to reserve a range of IDs which will
    not conflict with any other local IDs.

Arguments:

    cIdsToReserve - Number of IDs to reserve.

    pidReservedBase - Starting value of the reserved IDs.  The
        lower DWORD of this can be increatmented to generate
        cIdsToReserve unique IDs.

Return Value:

    OR_OK

--*/
{
    UINT type;

    if (cIdsToReserve > 10 || cIdsToReserve < 0)
    {
        cIdsToReserve = 10;
    }

    CProtectSharedMemory protector; // locks through rest of lexical scope

    CheckORdata();

    *pidReservedBase = AllocateId(cIdsToReserve);

    CheckORdata();

    return(OR_OK);
}

//
// simple helper
//
// this is needed because if a 16 bit app is the first to initialize DCOM,
// a temporary empty DSA for the local OR is created because remote protocols
// cannot be initialized.  The temporary DSA must still be honored after a
// 32 bit app has reinitialized the DSA for the local OR to its true value
//

BOOL IsLocalDSA(
		DUALSTRINGARRAY *pdsaServerObjectResolverBindings
		)
{
    // special case the NULL binding -- this may be left over from before
    // remote init and thus may not be in the table
    if (dsaCompare(gpLocalDSA,pdsaServerObjectResolverBindings) ||
		pdsaServerObjectResolverBindings->wNumEntries == 4)	  // NULL DSA grandfathered in
	{ 
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}


handle_t remote_resolve_handle; // handle for RPCSS RemoteResolveOXID call
UCHAR * RpcssStringBinding = (UCHAR *) "ncalrpc:[epmapper]\0";

// Helper to initialize the remote_resolve_handle
RPC_STATUS
InitResolveHandleIfNecessary()
{
    static BOOL fBindingInitialized = FALSE;

    if (fBindingInitialized) return RPC_S_OK;

    RPC_STATUS status = RpcBindingFromStringBindingA(
                                            RpcssStringBinding,
                                            &remote_resolve_handle
                                            );

    if (status == RPC_S_OK)
    {
        fBindingInitialized = TRUE;
    }

    return status;
}


// Assumes that the gpMutex is held

ORSTATUS
FindOrCreateMid(
   DUALSTRINGARRAY *pdsaObjectResolverBindings,
   USHORT wProtseqId,
   CMid * &pMid
   )
{
    ORSTATUS status = OR_OK;

    if (IsLocalDSA(pdsaObjectResolverBindings))
    {
        pMid = gpLocalMid;
        return OR_OK;
    }

    // Attempt to lookup MID

    CMidKey midkey(pdsaObjectResolverBindings);

    pMid = gpMidTable->Lookup(midkey);

    if (NULL == pMid)   // must create one
    {
        // The CMid constructor releases the shared memory lock, so someone else
        // might get in and create the very same MID object at the same time
        pMid = new CMid(pdsaObjectResolverBindings, status, wProtseqId);

        // We initialize local MID autologically,
        // therefore this has to be a remote MID

        if (pMid && status == OR_OK)
        {
            status = gpMidTable->Add(pMid);

            if (status == OR_I_DUPLICATE)
            {
                // someone beat us to the punch, use theirs
                delete pMid;    // can't use this one
                pMid = gpMidTable->Lookup(midkey);
                ASSERT(pMid != NULL);
                status = OR_OK;
            }
            else if (status != OR_OK)
            {
                delete pMid;
                pMid = NULL;
                return status;
            }


            ASSERT(status == OR_OK);
        }
        else
        {
            status = (status == OR_OK) ? OR_NOMEM : status;
        }
    }

    return status;
}


// Assumes that the gpMutex is held

ORSTATUS
CallRpcssToResolveOxid(
        IN OXID Oxid,
        IN CMid *pMid,
        OUT COxid * &pOxid
        )
{
    ORSTATUS status = OR_OK;

    {
        CTempReleaseSharedMemory temp;  // release mutex before taking gComLock
        HRESULT hr = StartRPCSS();

        if (FAILED(hr))
        {
            return OR_INTERNAL_ERROR;
        }
    }

    status = InitResolveHandleIfNecessary();

    // call RPCSS
    if (status == RPC_S_OK)
    {
        CTempReleaseSharedMemory temp;
        status = RemoteResolveOXID(Oxid,(DWORD)pMid);

        if (status != RPC_S_OK)
        {
            return status;
        }
    }

    // if OK, then the Oxid is in the table now

    pOxid = gpOxidTable->Lookup(CId2Key(Oxid, pMid->GetMID()));

    ASSERT(pOxid);
    return OR_OK;
}

// Assumes that the gpMutex is held

ORSTATUS
FindOrCreateOxid(
    IN OXID Oxid,
    IN CMid *pMid,
    IN long fApartment,
    IN OUT OXID_INFO& OxidInfo,
    IN USHORT wProtseqId,
    IN BOOL fSCMRequest,    // is this a register request from SCM?
    OUT COxid * &pOxid
   )

{
    ORSTATUS status = OR_OK;

    MID Mid = pMid->GetMID();

    pOxid = gpOxidTable->Lookup(CId2Key(Oxid, Mid));

    if (pOxid != NULL) 
    {
        if (fSCMRequest)
        {
            if (gfThisIsRPCSS)
            {
                MIDL_user_free(OxidInfo.psa);         // free the original 
            }
            else
            {
                CoTaskMemFree(OxidInfo.psa);          // ORPC uses CoTaskMemAlloc
            }
        }

        return OR_OK;
    }
    else if (pMid->IsLocal())
    {
        return OR_BADOXID;   // local OXID should be registered by server
    }

    // Not found, and not local MID

    // Need to allocate the OXID.  First step is to resolve it remotely

    if ( !fSCMRequest )  // genuine resolve request
    {
        if ( !gfThisIsRPCSS )
        {
            return CallRpcssToResolveOxid(Oxid,pMid,pOxid);
        }
        else   // we are RPCSS
        {
            OxidInfo.psa = NULL;   // just to be sure

            // Call remote resolver to resolve the OXID
            // This call releases the shared memory lock, so someone else
            // might get in and create the very same OXID object at the same time
            status = pMid->ResolveRemoteOxid( // This op will also replace the
                                Oxid,         // psa with one in shared memory
                                &OxidInfo
                                );

            if (status != OR_OK)
            {
                MIDL_user_free(OxidInfo.psa);
                return OR_BADOXID;
            }
        }
    }

    ASSERT(status == OR_OK);

    DUALSTRINGARRAY *pdsaT = dsaSMCopy(OxidInfo.psa);

    if (!pdsaT)
    {
        return OR_NOMEM;
    }

    if (gfThisIsRPCSS)
    {
        MIDL_user_free(OxidInfo.psa);         // free the original and replace
    }
    else
    {
        CoTaskMemFree(OxidInfo.psa);          // ORPC uses CoTaskMemAlloc
    }

    OxidInfo.psa = pdsaT;                 // with shared memory compressed copy

    wProtseqId = fSCMRequest ? wProtseqId : pMid->ProtseqOfServer();

    pOxid = new COxid(
                    Oxid,
                    pMid,
                    wProtseqId,
                    OxidInfo
                    );

    if (pOxid == NULL) return OR_NOMEM;

    // remote OXID belongs to ping process ..
    if ((status = gpPingProcess->OwnOxid(pOxid)) == OR_OK)
    {
        status = gpOxidTable->Add(pOxid);
    }

    if (status == OR_I_DUPLICATE)
    {
        // this never got inserted anywhere, so we must delete it 
        // explicitly because refcounting never got involved
        delete pOxid;

        // someone beat us to the punch, use theirs
        pOxid = gpOxidTable->Lookup(CId2Key(Oxid, Mid));
        ASSERT(pOxid != NULL);
        status = OR_OK;
    }
    else if (status != OR_OK) 
    {
        // something else went wrong, back out of the whole thing
        OrMemFree(OxidInfo.psa);
        gpPingProcess->DisownOxid(pOxid,FALSE);
        gpOxidTable->Remove(*pOxid);
        pOxid = NULL;
    }

    return status;
}


error_status_t
GetOXID(
    IN HPROCESS hProcess,
    IN OXID Oxid,
    IN DUALSTRINGARRAY *pdsaServerObjectResolverBindings,
    IN long fApartment,
    IN USHORT wProtseqId,
    IN OUT OXID_INFO& OxidInfo,
    OUT MID &Mid,
    OPTIONAL IN BOOL fSCMRequest    // is this a register request from SCM?
    )
/*++

Routine Description:

    Discovers the OXID_INFO for an oxid.  Will find local
    OXIDs without any help from resolver process.

    It needs OR bindings in order to resolve remote OXIDs.
    REVIEW: Should the resolver process be involved in this?

Arguments:

    hProcess - The context handle of the process.

    Oxid - The OXID (a uuid) to resolve.

    pdsaServerObjectResolverBindings - Compressed string bindings to
        the OR on the server's machine.

    fApartment - non-zero if the client is aparment model.

    OxidInfo - If successful this will contain information about the oxid and
        an expanded string binding to the server oxid's process.

    Mid - The machine ID assigned locally for the remote machine.
        This is obviously meaningful only for remote OXIDs.

Return Value:

    OR_NOMEM - Common.

    OR_BADOXID - Unable to resolve it.

    OR_OK - Success.

--*/
{
    ComDebOut((DEB_OXID, "GetOXID OXID = %08x\n",Oxid));

    COxid       *pOxid;
    CMid        *pMid;
    ORSTATUS     status = OR_OK;

    if (!pdsaServerObjectResolverBindings)
        pdsaServerObjectResolverBindings = gpLocalDSA;

    ASSERT(dsaValid(pdsaServerObjectResolverBindings));

    CProtectSharedMemory protector; // locks through rest of lexical scope

    CheckORdata();

#if DBG
    if (hProcess) hProcess->IsValid();   // don't validate for fake SCM calls
#endif

    status = FindOrCreateMid(
                        pdsaServerObjectResolverBindings,
                        wProtseqId,
                        pMid
                        );

    if (status != OR_OK) return status;

    ASSERT(pMid);   // otherwise we would have returned by now

    Mid = pMid->GetMID();

    status = FindOrCreateOxid(
                        Oxid,
                        pMid,
                        fApartment,
                        OxidInfo,
                        wProtseqId,
                        fSCMRequest,
                        pOxid
                        );

    ASSERT( (status != OR_OK) || pOxid );

    CheckORdata();

    if (status == OR_OK)
    {
        return pOxid->GetInfo(&OxidInfo);
    }
    else
    {
        return status;
    }
}


error_status_t
ClientAddOID(
    IN HPROCESS hProcess,
    IN OID Oid,
    IN OXID Oxid,
    IN MID Mid
    )

/*++

Routine Description:

    Updates the set of OIDs in use by a process.


Arguments:

    hProcess - Context handle for the process.

    Oid - OID to add.

    Oxid - OXID to which OID belongs.

    Mid - MID for location of OXID server.

Return Value:

    OR_OK - All updates completed ok.

    OR_BADOXID - The Oxid was not found

    OR_BADOID - The Oid could not be created or found

Notes:

  Unlike the NT resolver, there is no possibility that the Oxid
  is not in the gpOxidTable (since client and server Oxid objects
  are in the same table).

--*/
{
    ComDebOut((DEB_OXID, "ClientAddOID\nOID = %08x\nOXID = %08x\nMID = %08x\n",
                          Oid,Oxid,Mid));

    ORSTATUS    status = OR_OK;

    BOOL fNeedRpcss = FALSE;

    CProtectSharedMemory protector; // locks through rest of lexical scope

    CheckORdata();

#if DBG
    hProcess->IsValid();
#endif

    // Lookup up the oxid owning this new oid.

    COxid *pOxid = gpOxidTable->Lookup(CId2Key(Oxid,Mid));

    if (NULL == pOxid)
    {
        return OR_BADOXID;
    }

    CMid *pMid = pOxid->GetMid();

    // Find or create the oid.

    COid  *pOid = gpOidTable->Lookup(CId2Key(Oid,Mid));

    if (NULL == pOid)
    {
        if (pMid->IsLocal())   // Local OID should be registered by server
        {
            return OR_BADOID;
        }

        pOid = new COid(pOxid,Oid);

        if (NULL == pOid)
        {
            return OR_NOMEM;
        }

        status = gpOidTable->Add(pOid);

        if (status != OR_OK)
        {
            delete pOid;
            return status;
        }

        // Need to lazy start RPCSS
        fNeedRpcss = TRUE;
    }

    ASSERT(status == OR_OK);

    // We need to call OwnOid irrespective of whether we found the Oid
    // in the gpOidTable because this Oid may be remote, and it may have 
    // been DisOwned by its Oxid but is now being used by a new client
    status = pOxid->OwnOid(pOid);

    if (status == OR_OK  && !pMid->IsLocal())
    {
        status = pMid->AddClientOid(pOid);
    }

    if (status == OR_OK || status == OR_I_DUPLICATE) 
    {
        status = hProcess->AddOid(pOid);
        if (status == OR_I_DUPLICATE) 
        {
            status = OR_OK;
        }
    }
    else
    {
        pOxid->DisownOid(pOid);
    }

    if ((status == OR_OK) && fNeedRpcss)
    {
        CTempReleaseSharedMemory temp;     // release mutex before taking gComLock
        HRESULT hr = StartRPCSS();

        if (FAILED(hr))
        {
            status = OR_INTERNAL_ERROR;
        }
    }

    CheckORdata();

    return status;
}


error_status_t
ClientDropOID(
    IN HPROCESS hProcess,
    IN OID Oid,
    IN MID Mid
    )

/*++

Routine Description:

    Updates the set of remote OIDs in use by a process.


Arguments:

    hProcess - Context handle for the process.

    Oid - OID to be removed.

    Mid - MID to which Oid belongs.

Return Value:

    OR_OK - All updates completed ok.

    OR_BADOID - The Oid could not be found


--*/
{
    ComDebOut((DEB_OXID, "ClientDropOID\nOID = %08x\nMID = %08x\n",
                          Oid,Mid));

    CProtectSharedMemory protector; // locks through rest of lexical scope

    CheckORdata();

#if DBG
    hProcess->IsValid();
#endif

    COid * pOid = gpOidTable->Lookup(CId2Key(Oid,Mid));

    if (pOid)
    {
        COid *pRemove = hProcess->DropOid(pOid);

        if (pRemove == NULL)
        {

#if DBG
            {
                GUID Moid;
                MOIDFromOIDAndMID(Oid,Mid,&Moid);
                ComDebOut((DEB_OXID,"OR: Client process %d tried to remove moid %I which \
                            it didn't own\n", hProcess->GetProcessID(), &Moid));
            }
#endif // DBG

            return OR_BADOID;
        }
        else
        {
            ASSERT(pRemove == pOid);
            CheckORdata();
            return OR_OK;
        }
    }
    else
    {

#if DBG
        {
            GUID Moid;
            MOIDFromOIDAndMID(Oid,Mid,&Moid);
            ComDebOut((DEB_OXID,"OR: Client process %d tried to remove moid %I which \
                        doesn't exist\n", hProcess->GetProcessID(), &Moid));
        }
#endif // DBG

        return OR_BADOID;
    }
}


error_status_t
ServerAllocateOXID(
    IN HPROCESS hProcess,
    IN long fApartment,
    IN OXID_INFO *pOxidInfo,
    IN DUALSTRINGARRAY *pdsaStringBindings,
    OUT OXID &Oxid
    )
/*++

Routine Description:

    Allocates an OXID and 0 or more OIDs from the OR.

Arguments:

    hProcess - The context handle of the process containing the OXID.

    fApartment - is the server threading model apartment or free

    OxidInfo - The OXID_INFO structure for the OXID without bindings.

    pdsaStringBindings - Expanded string binding of the server.

    Oxid - The OXID registered and returned.

Return Value:

    OR_OK - success.

    OR_NOMEM - Allocation of OXID failed.

--*/
{
    ComDebOut((DEB_OXID, "ServerAllocateOXID\n"));

    ORSTATUS status = OR_OK;

    COxid *pNewOxid;

    // Save the string bindings back to the process

    ASSERT(dsaValid(pdsaStringBindings));

    CProtectSharedMemory protector; // locks through rest of lexical scope

    CheckORdata();

#if DBG
    hProcess->IsValid();
#endif

    status = hProcess->ProcessBindings(pdsaStringBindings);

    if (status != OR_OK)
    {
        return(status);
    }

    pNewOxid = new COxid(
                      hProcess,
                      *pOxidInfo,
                      fApartment
                      );

    if (NULL == pNewOxid)
    {
        return(OR_NOMEM);
    }

    Oxid = pNewOxid->GetOXID();

    // Add to process and lookup table.

    status = hProcess->OwnOxid(pNewOxid);

    VALIDATE((status, OR_NOMEM, 0));

    if (OR_OK == status)
    {
        status = gpOxidTable->Add(pNewOxid);
        if (status != OR_OK)
        {
            delete pNewOxid;
            return status;
        }

        ComDebOut((DEB_OXID, "OXID successfully allocated: %08x\n", Oxid));
    }

    CheckORdata();

    return(status);
}


error_status_t
ServerAllocateOID(
    IN HPROCESS hProcess,
    IN OXID Oxid,
    OUT OID &Oid
    )
/*++

Routine Description:

    Registers an OID on behalf of an existing OXID.

Arguments:

    hProcess - The context handle of the process containing the OXID and OIDs.

    Oxid - The OXID associated with the OID (assumed local of course).

    Oid - The OID to be allocated and returned.

Return Value:

    OR_OK (0) - Success.

    OR_NOMEM - OXID or one or more OIDs

--*/
{
    ComDebOut((DEB_OXID, "ServerAllocateOID, OXID = %08x\n", Oxid));

    CProtectSharedMemory protector; // locks through rest of lexical scope

    CheckORdata();

#if DBG
    hProcess->IsValid();
#endif

    COxid *pOxid = gpOxidTable->Lookup(CId2Key(Oxid,gLocalMID));

    ORSTATUS status;

    if (NULL == pOxid)
    {
        return(OR_BADOXID);
    }

    COid *pOid = new COid(pOxid);

    if (NULL == pOid)
    {
        return OR_NOMEM;
    }

    status = pOxid->OwnOid(pOid);

    if (status == OR_OK)
    {
        Oid = pOid->GetOID();     // out parameter

        status = gpOidTable->Add(pOid);
        if (status != OR_OK)
        {
            COid *pTemp = pOxid->DisownOid(pOid);
            ASSERT(pTemp != NULL);
            return status;
        }

        // If the server doesn't want to keep the OID alive,
        // this OID may rundown in six minutes unless
        // someone references it in the meantime...

        ComDebOut((DEB_OXID, "OID successfully allocated: %08x at offset = %x\n",
                              Oid,pOid));

        pOxid->StartRundownThreadIfNecessary();

        CheckORdata();

        return OR_OK;
    }
    else
    {
        return OR_NOMEM;
    }
}

error_status_t
ServerFreeOXID(
    IN HPROCESS hProcess,
    IN OXID Oxid,
    IN ULONG cOids,
    IN OID aOids[])
/*++

Routine Description:

    Delete an OXID registered by the server, and all OIDs belonging to this OXID.

Arguments:

    hProcess - The context handle of the process containing the OXID and OIDs.

    Oxid - The OXID to be deleted (assumed local).

    cOids - The number of OIDs to be deleted.

    aOids - array of OIDs to be deleted.

Return Value:

    OR_OK (0) - Success.

    OR_BADOXID - OXID does not exist.

    OR_NOACCESS - OXID does not belong to this process.

    OR_BADOID - OID does not exist or does not belong to this OXID.

--*/
{
    ComDebOut((DEB_OXID, "ServerFreeOXID: %08x MID = %x\n",
                              Oxid,gLocalMID));

    CProtectSharedMemory protector; // locks through rest of lexical scope

    CheckORdata();

#if DBG
    hProcess->IsValid();
#endif

    COxid *pOxid = gpOxidTable->Lookup(CId2Key(Oxid,gLocalMID));

    if (NULL != pOxid)
    {
#if DBG
        OXID Oxid = pOxid->GetOXID();   // get this before pOxid potentially disappears
#endif

        hProcess->DisownOxid(pOxid,TRUE);   // this call is on the server's thread
                                            // in the apartment case and in the server's
                                            // process in both threading cases

        ComDebOut((DEB_OXID, "OXID successfully removed: %08x\n",
                              Oxid));

        CheckORdata();

        return OR_OK;
    }
    else
    {
        return OR_BADOXID;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\objex\shrmem\dcom95\misc.cxx ===
/*++

Copyright (c) 1996-1997 Microsoft Corporation

Module Name:

    Misc.cxx

Abstract:

    Miscellaneous helper routines

Author:

    Satish Thatte    [SatishT]    02-11-96

--*/

#include <or.hxx>

WCHAR* 
catenate(
	WCHAR* pszPrefix, 
	WCHAR* pszSuffix
	) 
/*++

Routine Description:

    Concatenate the two given strings into a new string

Arguments:

	pszPrefix	- prefix of result
	
	pszSuffix	- suffix of result

Returns:

    A newly allocated string.

--*/
{
	long prefixLen = wcslen(pszPrefix);
	long suffixLen = wcslen(pszSuffix);

	WCHAR* pszResult = new WCHAR[(prefixLen+suffixLen+1)*sizeof(WCHAR)];
	wcscpy(pszResult,pszPrefix);
	wcscpy(pszResult+prefixLen,pszSuffix);
	return pszResult;
}


//
// Local ID allocation
//


ID
AllocateId(
    IN LONG cRange
    )
/*++

Routine Description:

    Allocates a unique local ID.

    This id is 64bits.  The low 32 bits are a sequence number which
    is incremented with each call.  The high 32bits are seconds
    since 1980.  The ID of 0 is not used.

Limitations:

    No more then 2^64 IDs can be generated in a given second without
    a duplicate.  After 2^32 there becomes a much higher change of
    overflow.

    When the time stamp overflows, once every >126 years, the sequence
    numbers are likely to be generated in such a way as to collide
    with those from 126 years ago.

    There is no prevision in the code to deal with duplications.

Arguments:

    cRange -  Number to allocate in sequence, default is 1.

Return Value:

    A 64bit id.

Note:  This must be called under shared memory lock!

--*/
{
    FILETIME ft;
    LARGE_INTEGER id;

    ASSERT(cRange > 0 && cRange < 11);
 
    do
        {
        id.HighPart = GetTickCount();
        id.LowPart = *gpIdSequence;
        *gpIdSequence += cRange;
        }
    while (id.QuadPart == 0 );

    return(id.QuadPart);
}

//
// Debug helper(s)
//

#if DBG

int __cdecl __RPC_FAR ValidateError(
    IN ORSTATUS Status,
    IN ...)
/*++
Routine Description

    Tests that 'Status' is one of an expected set of error codes.
    Used on debug builds as part of the VALIDATE() macro.

Example:

    VALIDATE( (Status,
               OR_BADSET,
               // more error codes here
               OR_OK,
               0)  // list must be terminated with 0
               );

     This function is called with the OrStatus and expected errors codes
     as parameters.  If OrStatus is not one of the expected error
     codes and it not zero a message will be printed to the debugger
     and the function will return false.  The VALIDATE macro ASSERT's the
     return value.

Arguments:

    Status - Status code in question.

    ... - One or more expected status codes.  Terminated with 0 (OR_OK).

Return Value:

    TRUE - Status code is in the list or the status is 0.

    FALSE - Status code is not in the list.

--*/
{
    RPC_STATUS CurrentStatus;
    va_list(Marker);

    if (Status == 0) return(TRUE);

    va_start(Marker, Status);

    while(CurrentStatus = va_arg(Marker, RPC_STATUS))
        {
        if (CurrentStatus == Status)
            {
            return(TRUE);
            }
        }

    va_end(Marker);

    OrDbgPrint(("OR Assertion: unexpected failure %lu (0lx%08x)\n",
                    (unsigned long)Status, (unsigned long)Status));

    return(FALSE);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\objex\shrmem\dcom95\oxid.cxx ===
/*++

Copyright (c) 1996-1997 Microsoft Corporation

Module Name:

    oxid.cxx

Abstract:

    Object resolver class implementations.  COxid, COid, and other auxiliary
    classes are implemented here.

Author:

    Satish Thatte    [SatishT]   03-27-96

--*/

#include<or.hxx>


// 
// The CPID class is used for storing process IDs enumerated using the
// snapshot generated by CreateToolhelp32Snapshot for use in
// the function CheckForCrashedProcessesIfNecessary.  
// The purpose is to avoid confusing the debug kernel by 
// calling OpenProcess with a nonexistent process ID 
//

#include <tlhelp32.h>

class CPID : public CTableElement
{
private:

    // declare the members needed for a page static allocator
    DECL_PAGE_ALLOCATOR

public :

    CIdKey   _pid;

    CPID( DWORD pid ) : _pid(pid) {}

    virtual DWORD   // dummy method in this class
    Hash() 
    {
        return _pid.Hash();
    }

    virtual operator ISearchKey&()
    {
        return _pid;
    }

    DWORD GetPID()
    {
        ID id = _pid.Id();    
        DWORD* pdw = (DWORD*) &id;
        return *(++pdw);
    }
};


DEFINE_TABLE(CPID)



//
// COid methods and static members
//

// define the static members for page-based allocation
DEFINE_PAGE_ALLOCATOR(COid)

void
COid::Rundown()
{
    if (!_pOxid->IsLocal())
    {
        // We don't want to remove it from the gpOidTable at this point 
        // because some other client may come along and want to use
        // this before it gets dropped from the ping set if the ping fails
        _pOxid->_pMid->DropClientOid(this);
    }
    else
    {
        COid *pRemoved = gpOidTable->Remove(*this);
        ASSERT(pRemoved==this || pRemoved==NULL);
    }
}


BOOL 
COid::OkToRundown()
{
    DWORD dwRefs = References();
    ASSERT(dwRefs >= 2);

    BOOL fLocal = _pOxid->IsLocal();

    DWORD dwBaseRefs = fLocal ? 2 : 3; // extra pingset ref

    if (dwRefs > dwBaseRefs)
    {
        return FALSE;
    }
    else
    {
        // the resolver on the server machine will take care of the delay
        // in rundown if this is a non-local OID

        // Check if the time since creation or last release is less
        // than timeout
        // Warning: removing the check will fail the middle-man cases
        // because the middle-man's access time will not be counted.
        //
        if (fLocal && ((CTime() - *this) < BaseTimeoutInterval))
        {
            return FALSE;
        }
    }

    return TRUE;
}


//
// COxidInfo methods
//


ORSTATUS        // BUGBUG: perhaps this should have OXID_INFO as the parameter type
COxidInfo::Assign(
    const OXID_INFO& Info
    )
/*++

Routine Desciption

    Makes a copy of the incoming info, including the DUALSTRINGARRAY.

Arguments:

    Info -  COxidInfo object to be cpied

Return Values:

    OR_OK
    OR_NOMEM

--*/
{
    _oxidInfo = Info;  // all except bindings taken care of
    return _dsaBindings.Assign(Info.psa,TRUE);  // already compressed
}


//
// COxid methods and static members.
//

// define the static members for page-based allocation
DEFINE_PAGE_ALLOCATOR(COxid)


COxid::COxid(
          OXID Oxid,    // constructor for remote OXIDs
          CMid *pMid,
          USHORT wProtseq,
          OXID_INFO &OxidInfo
         ) :
        _Key(Oxid, pMid->GetMID()),
        _pProcess(gpPingProcess),
        _protseq(wProtseq),
        _fApartment(FALSE),
        _fRunning(TRUE),
        _pMid(pMid),
        _fLocal(FALSE),
        _info(OxidInfo)
    {
        _pMid->Reference();
        _optional._remote._dwTimeStamp = 0;
    }


COxid::COxid(              // constructor for local OXIDs
          CProcess *pProcess,
          OXID_INFO &OxidInfo,
          BOOL fApartment
         ) :
        _Key(AllocateId(), gLocalMID),
        _pProcess(pProcess),
        _pMid(gpLocalMid),
        _protseq(0),
        _fApartment(fApartment),
        _fRunning(TRUE),
        _fLocal(TRUE),
        _info(OxidInfo)
    {
        _optional._local._fRundownThreadStarted = FALSE;
        _optional._local._hRundownThread = NULL;
        _optional._local._pfRundownThreadKeepRunning = NULL;
        _pProcess->Reference();
    }


COxid::~COxid()
{
    // this works even if executed by nonowner thread
    StopRundownThreadIfNecessary();
    StopRunning();

    DUALSTRINGARRAY *pdsaBindings = _info._dsaBindings;
    OrMemFree(pdsaBindings);

    if (!IsLocal())  // Don't release the local CMid!
    {
        _pMid->Release();
    }
    else             // Don't release the PingProcess!
    {
        _pProcess->Release();
    }
}


ORSTATUS 
COxid::OwnOid(COid *pOid)
{
    if (!IsLocal())
    {
        _optional._remote._dwTimeStamp = NULL;
    }

    ORSTATUS status = _MyOids.Add(pOid);   // acquires a reference

    if (status == OR_I_DUPLICATE)
    {
        status = OR_OK;
    }

    return status;
}


BOOL 
COxid::HasExpired()
{
    BOOL result = FALSE;

    ASSERT(!IsLocal());

    if (_MyOids.IsEmpty())
    {
        // if we are not running, we are gone
        if (!_fRunning)
        {
            result = TRUE;
        }
        else if (_optional._remote._dwTimeStamp == 0) 
        {
            // Maybe we haven't acquired our first Oid yet
            // Or someone has been asking for our bindings
            result = FALSE;
        }
        else
        {
            // have we been idle long enough?
            result =    (CTime() - CTime(_optional._remote._dwTimeStamp)) 
                     >= (BaseTimeoutInterval);
        }
    }

    return result;
}



COid *
COxid::DisownOid(COid *pOid)
{
    // Rundown is idempotent
    pOid->Rundown();

    COid *pMyOid = _MyOids.Remove(*pOid);// releases our reference

    // The Oid may have been run down and removed already
    ASSERT(pMyOid == pOid || pMyOid == NULL);

    // If this is a non-local Oxid and it has no Oids registered
    // then it becomes a candidate for being eliminated
    if (!IsLocal() && _MyOids.IsEmpty())
    {
        _optional._remote._dwTimeStamp = GetTickCount();
    }

    return pMyOid;
}


void
COxid::StopRunning()
{
    ReleaseAllOids();
    _fRunning = FALSE;
}


void
COxid::ReleaseAllOids()
{
    if (_MyOids.Size())
    {
        COidTableIterator Oids(_MyOids);
        COid *pOid;

        while(pOid = Oids.Next())
        {
            DisownOid(pOid);
        }
    }
}


ORSTATUS
COxid::GetInfo(
    OUT OXID_INFO *pInfo
    )
/*++

Routine Description:

    Returns the OXID_INFO structure for this oxid for local.

Arguments:

    pInfo - Will contain the standard info, a single _expanded_
        string binding and complete security bindings.

Return Value:

    OR_NOMEM - Unable to allocate a parameter.

    OR_OK - Normally.

--*/

{
    USHORT protseq;
    PWSTR  pwstrT;
    CDSA dsaBindings;

    if (!IsRunning())
    {
        return OR_NOSERVER;
    }

    if (_fLocal)
    {
        dsaBindings.Assign(_pProcess->GetLocalBindings());

        protseq = ID_WMSG;
    }
    else
    {
        protseq = _protseq;  // use the one we set when this was created
        DUALSTRINGARRAY *pdsa = _info._dsaBindings;  // auto conversion
        dsaBindings.Assign(pdsa);                    // noncopying assignment
    }

    if (_pMid->IsLocal())
    {
        pwstrT = FindMatchingProtseq(protseq, dsaBindings->aStringArray);
    }
    else
    {
        protseq = _pMid->ProtseqOfServer();
        PWSTR pwstrAddress = _pMid->AddressOfServer();

        if (protseq==0)             // there is no working binding
        {
            return OR_NOSERVER;
        }

        if (pwstrAddress==NULL)     // we failed to allocate the string
        {
            return OR_NOMEM;
        }

        pwstrT = FindMatchingProtseqAndAddr(
                                        protseq, 
                                        pwstrAddress, 
                                        dsaBindings->aStringArray
                                        );

        RpcStringFree(&pwstrAddress);
    }

    ASSERT(pwstrT != NULL && "OR: Didn't find a matching binding for oxid");

    // the memcpy gets everything except the bindings
    memcpy(pInfo,&_info._oxidInfo,sizeof(_info._oxidInfo));

    if (pwstrT)
    {
        pInfo->psa =
            GetStringBinding(
                pwstrT,
                dsaBindings->aStringArray + dsaBindings->wSecurityOffset
                );
    }
    else
    {
        // BUGBUG - ronans - can be due to null pwstrT - in this 
        // case OR_NOMEM is not the correct return value.
        
        pInfo->psa = NULL;
        return OR_NOSERVER;
    }

    if (0 == pInfo->psa)
    {
        return OR_NOMEM;
    }

    return(OR_OK);
}



ORSTATUS
COxid::GetRemoteInfo(
    IN  USHORT     cClientProtseqs,
    IN  USHORT    *aClientProtseqs,
    IN  USHORT     cInstalledProtseqs,
    IN  USHORT    *aInstalledProtseqs,
    OUT OXID_INFO *pInfo
    )
/*++

Routine Description:

    Returns the OXID_INFO structure for this oxid for remote clients.

Arguments:

    pInfo - Will contain the standard info, a single _expanded_
        string binding and complete security bindings.

Return Value:

    OR_NOMEM - Unable to allocate a parameter.

    OR_OK - Normally.

--*/

{
    PWSTR  pwstrT;
    ORSTATUS status = OR_OK;

    if (!IsRunning())
    {
        return OR_NOSERVER;
    }

    ASSERT(_fLocal);       // Do not resolve remote servers for remote clients!

    DUALSTRINGARRAY * pdsaBindings = _pProcess->GetLocalBindings();

    pwstrT = FindMatchingProtseq(
                        cClientProtseqs,
                        aClientProtseqs,
                        pdsaBindings->aStringArray
                        );

    if ( pwstrT == NULL )   // try lazy use of protseq(s)
    {
        status = _pProcess->UseProtseqIfNeeded(
                                  cClientProtseqs,
                                  aClientProtseqs,
                                  cInstalledProtseqs,
                                  aInstalledProtseqs,
				  _info._oxidInfo.dwTid // so we know where to call over WMSG
                                  );

        pdsaBindings = _pProcess->GetLocalBindings();
    }

    // the memcpy gets everything except the bindings
    memcpy(pInfo,&_info._oxidInfo,sizeof(_info._oxidInfo));

    pInfo->psa = GetMatchingDSA(
                            cClientProtseqs,
                            aClientProtseqs,
                            pdsaBindings
                            );

    if (NULL == pInfo->psa)
    {
        return OR_NOMEM;
    }

    return(status);
}



ORSTATUS
COxid::StartRundownThreadIfNecessary()
{
    DWORD dwThrdId;

    if (_fApartment || !IsLocal())    // rundown timer is attached to window
                                      // or rundown handled by ping server
    {
        return OR_OK;
    }

    if (_optional._local._fRundownThreadStarted)
    {
        ASSERT(_optional._local._hRundownThread);
        ASSERT(*_optional._local._pfRundownThreadKeepRunning == TRUE);
        return OR_OK;
    }

    SRundownThreadInfo *pInfo = (SRundownThreadInfo*)
                                PrivMemAlloc(sizeof(SRundownThreadInfo));

    pInfo->pSelf = this;
    pInfo->fKeepRunning = TRUE;
    _optional._local._pfRundownThreadKeepRunning = &(pInfo->fKeepRunning);

    _optional._local._hRundownThread = 
                            CreateThread(
                                      NULL, 0,
			                          RundownThread,
			                          pInfo, 0, &dwThrdId);

    if (_optional._local._hRundownThread)
    {
        _optional._local._fRundownThreadStarted = TRUE;
        return OR_OK;
    }
    else
    {
        return GetLastError();
    }
}




ORSTATUS
COxid::StopRundownThreadIfNecessary()
{
    if (!IsLocal() || _pProcess->IsCurrentProcess() != TRUE)
    {
        return OR_OK;
    }

    if (_optional._local._fRundownThreadStarted)
    {
        ASSERT(_optional._local._hRundownThread);

        CloseHandle(_optional._local._hRundownThread);
        _optional._local._hRundownThread = NULL;
        _optional._local._fRundownThreadStarted = FALSE;
        // signal the rundown thread to terminate itself
        *_optional._local._pfRundownThreadKeepRunning = FALSE; 
        return OR_OK;
    }
    else
    {
        ASSERT(!_optional._local._hRundownThread);
        return OR_OK;
    }
}


ORSTATUS
COxid::StopTimerIfNecessary()  // must be called by owner thread
{
    ORSTATUS status = OR_OK;

    if (_fApartment)
    {
         // find the HWND for this thread

        COleTls tls;
		OXIDEntry *pOXIDEntry = (OXIDEntry *)tls->pOXIDEntry;
        HWND hWindow = (HWND) pOXIDEntry->hServerSTA;

        if (!KillTimer(hWindow,pOXIDEntry->uiTimer))
        {
            status = GetLastError();
        }
    }

    return status;
}

void
CheckForCrashedProcessesIfNecessary()
{
    CTime CurrentTime;

    // don't check too often -- note that the subtraction returns a result
    // denominated in seconds, not in ticks

    DWORD dwTimeSinceLastCheckInSeconds = 
                        CurrentTime - CTime(*gpdwLastCrashedProcessCheckTime);

    if (dwTimeSinceLastCheckInSeconds < BasePingInterval)
    {
        return;
    }

    // timestamp the check -- this time in ticks
    *gpdwLastCrashedProcessCheckTime = CurrentTime;

#if DBG
    {
         OutputDebugString("Checked For Crashed Processes at:");
         CHAR buffer[20];
         wsprintfA(buffer, " %d\n", (*gpdwLastCrashedProcessCheckTime)/1000);                            
         OutputDebugString(buffer);
         OutputDebugString("Time Since Last Check:");
         wsprintfA(buffer, " %d\n", dwTimeSinceLastCheckInSeconds);                            
         OutputDebugString(buffer);
    }
#endif

    // now get together the table of currebntly running processes

    CPIDTable PidTable;

    HANDLE hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS,0);

    if ((LONG)hSnap == -1)
    {
        ComDebOut((DEB_OXID,"CreateToolhelp32Snapshot failed with error %x",
                            GetLastError()));

        return;
    }

    PROCESSENTRY32 processEntry;
    processEntry.dwSize = sizeof(processEntry);

    BOOL fContinue = FALSE;

    for (
         fContinue = Process32First(hSnap,&processEntry);
         fContinue;
         fContinue = Process32Next(hSnap,&processEntry)
        )
    {
         // These objects are ref counted and will be destroyed
         // when the table is destroyed at the end of the scope
         CPID *pPid = new CPID(processEntry.th32ProcessID);

         if (pPid==NULL)
         {
            CloseHandle(hSnap);
            return;                 // not much else we can do here
         }

         PidTable.Add(pPid);

#if DBG
         OutputDebugString("Snapshot contains ");
         CHAR buffer[20];
         wsprintfA(buffer, "%x ", processEntry.th32ProcessID);                            
         OutputDebugString(buffer);
         OutputDebugString(processEntry.szExeFile);
         OutputDebugString("\n");
#endif
    }

    CloseHandle(hSnap);

    // now iterate through our table of registered processes to
    // see if any of them are gone

    CProcessTableIterator procIter(*gpProcessTable);

    CProcess *pNextProcess;

    while (pNextProcess = procIter.Next())
    {
        CPID Pid(pNextProcess->GetProcessID());

        if (PidTable.Lookup(Pid) == NULL) // not running
        {
            ComDebOut((DEB_OXID,"Process PID = %x has crashed\n",
                                pNextProcess->GetProcessID()));

            // run the process down before removing it -- removal may cause
            // its ref count to drop to zero leading to premature deletion
            pNextProcess->Rundown();
            gpProcessTable->Remove(*pNextProcess);
        }
        else
        {
            ComDebOut((DEB_OXID,"Process PID = %d is running\n",
                                pNextProcess->_processID));
        }
    }
}


#define RUNDOWN_BATCH_SIZE  100

// This helper assumes that the gpMutex is held, 
// and releases it for the duration of the function call
// The algorithm:  Look through all candidate Oids to be
// run down and try to run them down -- put the ones that
// the Rundown interface OKs on the aRundownOids array.
inline void
RundownHelper(
        IRundown *pRemUnk,
        COid *  aRundownOidCandidates[],
        DWORD   cRundownOidCandidates,
        COid *  aRundownOids[],
        DWORD  &cRundownOids
        )
{
    unsigned char afOkToRundown[RUNDOWN_BATCH_SIZE];
    OID aOIDs[RUNDOWN_BATCH_SIZE];
    USHORT i;

    for (i =0; i < cRundownOidCandidates; i++)
    {
        aOIDs[i] = aRundownOidCandidates[i]->GetOID();
    }

    {
        // Release shared memory so we can try real rundown without deadlock
        CTempReleaseSharedMemory temp;

        HRESULT hr = pRemUnk->RundownOid(
                                cRundownOidCandidates,
                                aOIDs,
                                afOkToRundown
                                );

        ASSERT(hr == S_OK);
    }

    cRundownOids = 0;

    for (i = 0; i < cRundownOidCandidates; i++)
    {
        // the optimizer will take the hr == S_OK out of the loop, right?
        if (afOkToRundown[i])
        {
            aRundownOids[cRundownOids++] = aRundownOidCandidates[i];
        }
        else
        {
            // We don't care what happens to this any more
            // even though the shared mutex is not held right now
            aRundownOidCandidates[i]->Release();
        }
    }
}


void
COxid::RundownOidsIfNecessary(
                IRundown *pRemUnk
                )
{
    ::CheckForCrashedProcessesIfNecessary();

    if (_MyOids.Size() == 0) return;

    COidTableIterator Oids(_MyOids);
    COid *pOid;

    // Hold a reference to self temorarily so we are not destroyed
    // during this call -- in spite of giving up the shared mutex

    CTempHoldRef tempRef(this);

    COid* aRundownOidCandidates[RUNDOWN_BATCH_SIZE];
    DWORD cRundownOidCandidates;
    BOOL  fCheckedAllOids = FALSE;

    // Find Oids that look ready to run down
    do
    {
        cRundownOidCandidates = 0;

        while (cRundownOidCandidates < RUNDOWN_BATCH_SIZE)
        {
            if ((pOid = Oids.Next()) == NULL)   // We've been through all OIDs
            {
                fCheckedAllOids = TRUE;
                break;
            }

            if (pOid->OkToRundown())
            {
                aRundownOidCandidates[cRundownOidCandidates++] = pOid;

                // We don't want to lose these, so hold a reference
                pOid->Reference();
            }
        }

        if (cRundownOidCandidates == 0)
        {
            return;     // No more work, just return
        }

        COid* bufRundownOids[RUNDOWN_BATCH_SIZE];
        COid** aRundownOids;
        DWORD cRundownOids;

        if (IsLocal())
        {
            aRundownOids = bufRundownOids;

            RundownHelper(
                pRemUnk,
                aRundownOidCandidates,
                cRundownOidCandidates,
                aRundownOids,
                cRundownOids
                );
        }
        else
        {
            aRundownOids = aRundownOidCandidates;
            cRundownOids = cRundownOidCandidates;
        }


        // If while the lock was released, we stopped running, just return
        // The refs we are holding temporarily will be released by destructors
        if (!_fRunning)
        {
            return;
        }

        for (USHORT i = 0; i < cRundownOids; i++)
        {
            pOid = aRundownOids[i];
            DisownOid(pOid);
            pOid->Release(); // release our private reference
        }

    } while (! fCheckedAllOids);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\objex\shrmem\dcom95\objex.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    objex.cxx

Abstract:

    Initialization routines for the resolver service.

Author:

    Satish Thatte    [SatishT]

--*/


#include <or.hxx>

#if DBG
#include <fstream.h>
#endif

extern "C"
{
#define SECURITY_WIN32 // Used by sspi.h
#include <security.h>      // EnumerateSecurityPackages
}

//
// Process globals - read-only except during init.
//

// MID of the string bindings for this machine -- the bindings are phoney
// for this shared memory version of the resolver.

DUALSTRINGARRAY *gpLocalDSA;
MID              gLocalMID;
CMid            *gpLocalMid;
CProcess        *gpProcess;     // pointer to our process object
CProcess        *gpPingProcess; // pointer to pinging process
//
// Process globals - read-write
//

void * pSharedBase = NULL;
CSharedGlobals *gpGlobalBlock = NULL;

COxidTable  * gpOxidTable;
COidTable   * gpOidTable;
CMidTable   * gpMidTable;
CProcessTable * gpProcessTable;

USHORT *gpfRemoteInitialized;
USHORT *gpfSecurityInitialized;
USHORT *gpfClientHttp = NULL;
USHORT *gpcRemoteProtseqs;          // count of remote protseqs
USHORT *gpRemoteProtseqIds;         // array of remote protseq ids
PWSTR gpwstrProtseqs;               // remote protseqs strings catenated
DUALSTRINGARRAY *gpdsaMyBindings;   // DUALSTRINGARRAY of local OR's bindings

LONG        * gpIdSequence;

FILETIME MyCreationTime;
DWORD MyProcessId;

DWORD *gpdwLastCrashedProcessCheckTime;
DWORD *gpNextThreadID;

// This global flag is used to signal remote protocol initialization
BOOL gfThisIsRPCSS = FALSE;


CGlobalMutex *gpMutex = NULL;           // global mutex to protect shared memory
CRITICAL_SECTION gRpcssLock; // global critsec to protect Rpcss structures

BOOL DCOM_Started = FALSE;
ID ProcessMarker;        // sanity checking marker for the process object

CResolverHashTable  *gpClientSetTable = 0;


//+-------------------------------------------------------------------------
//
//  Function:   LoadSecur32 and UnloadSecur32
//
//  Synopsis:   helper functions to load and unload secur32.dll
//
//--------------------------------------------------------------------------

#define SECUR32_DLL TEXT("secur32.dll")
#define ENUMERATE_SECPKG TEXT("EnumerateSecurityPackagesA")
#define FREE_CXTBUF TEXT("FreeContextBuffer")


ENUMERATE_SECURITY_PACKAGES_FN_A pEnumerateSecurityPackages;
FREE_CONTEXT_BUFFER_FN pFreeContextBuffer;

HINSTANCE hinstSecur32;

RPC_STATUS 
LoadSecur32()
{
    // Get a handle to secur32.dll

    hinstSecur32 = LoadLibraryT(SECUR32_DLL);

    // Get our functions.

    if (hinstSecur32 != NULL)
    {
        pEnumerateSecurityPackages = (ENUMERATE_SECURITY_PACKAGES_FN_A) 
                                     GetProcAddress(hinstSecur32, ENUMERATE_SECPKG);

        pFreeContextBuffer = (FREE_CONTEXT_BUFFER_FN) 
                             GetProcAddress(hinstSecur32, FREE_CXTBUF);
    }
    else
    {
        ComDebOut((DEB_ERROR,"Secur32.DLL LoadLibrary Failed With Error=%d\n",
                             GetLastError()));

        return RPC_S_INTERNAL_ERROR;
    }

    if (!pEnumerateSecurityPackages || !pFreeContextBuffer)
    {
        ComDebOut((DEB_ERROR,"Secur32.DLL GetProcAddress Failed With Error=%d\n",
                             GetLastError()));

        return RPC_S_INTERNAL_ERROR;
    }

    return RPC_S_OK;
}

RPC_STATUS 
UnloadSecur32()
{
    if (hinstSecur32 && !FreeLibrary(hinstSecur32))
    {
        ComDebOut((DEB_ERROR,"Secur32.DLL FreeLibrary Failed With Error=%d\n",
                             GetLastError()));

        return RPC_S_INTERNAL_ERROR;
    }

    return RPC_S_OK;
}


//+-------------------------------------------------------------------------
//
//  Function:   ReadRegistry
//
//  Synopsis:   Looks up DCOM related registry keys.
//
//--------------------------------------------------------------------------

SharedSecVals *gpSecVals;   // the repository for shared security data

HRESULT ReadRegistry()
{
    // These variables hold values read out of the registry and cached.
    // s_fEnableDCOM is false if DCOM is disabled.  The others contain
    // authentication information for legacy applications.
    BOOL &s_fEnableRemoteLaunch     = gpSecVals->s_fEnableRemoteLaunch;
    BOOL &s_fEnableRemoteConnect    = gpSecVals->s_fEnableRemoteConnect;
    BOOL &s_fEnableDCOM     = gpSecVals->s_fEnableDCOM;
    DWORD &s_lAuthnLevel    = gpSecVals->s_lAuthnLevel;
    DWORD &s_lImpLevel      = gpSecVals->s_lImpLevel;
    BOOL  &s_fMutualAuth    = gpSecVals->s_fMutualAuth;
    BOOL  &s_fSecureRefs    = gpSecVals->s_fSecureRefs;


    HRESULT     hr = S_OK;
    HKEY        hKey;
    DWORD       lType;
    DWORD       lData;
    DWORD       lDataSize;

    if (*gpfRemoteInitialized) return S_OK; 

    // Set all the security flags to their default values.
    s_fEnableDCOM   = FALSE;
	s_fEnableRemoteLaunch = FALSE;
	s_fEnableRemoteConnect = FALSE;

    s_lAuthnLevel   = RPC_C_AUTHN_LEVEL_CONNECT;
    s_lImpLevel     = RPC_C_IMP_LEVEL_IDENTIFY;
    s_fMutualAuth   = FALSE;
    s_fSecureRefs   = FALSE;

    // Open the security key.
    hr = RegOpenKeyExA( HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\OLE",
                           NULL, KEY_QUERY_VALUE, &hKey );
    if (hr != ERROR_SUCCESS)
        return hr;

    // Query the value for EnableDCOM.
    lDataSize = sizeof(lData );
    hr = RegQueryValueExA( hKey, "EnableDCOM", NULL, &lType,
                          (unsigned char *) &lData, &lDataSize );
    if (hr == ERROR_SUCCESS && lType == REG_SZ && lDataSize != 0)
    {
	if (*((char *) &lData) == 'y' ||
	    *((char *) &lData) == 'Y')
	    s_fEnableDCOM = TRUE;
    }

    if (s_fEnableDCOM)    // don't bother to read the rest if
                          // DCOM is not enabled
    {
        // Query the value for EnableRemoteLaunch.
        lDataSize = sizeof(lData );
        hr = RegQueryValueExA( hKey, "EnableRemoteLaunch", NULL, &lType,
                              (unsigned char *) &lData, &lDataSize );
        if (hr == ERROR_SUCCESS && lType == REG_SZ && lDataSize != 0)
        {
	    if (*((char *) &lData) == 'y' ||
	        *((char *) &lData) == 'Y')
	        s_fEnableRemoteLaunch = TRUE;
        }
        // Query the value for EnableRemoteConnect.
        lDataSize = sizeof(lData );
        hr = RegQueryValueExA( hKey, "EnableRemoteConnect", NULL, &lType,
                              (unsigned char *) &lData, &lDataSize );
        if (hr == ERROR_SUCCESS && lType == REG_SZ && lDataSize != 0)
        {
	    if (*((char *) &lData) == 'y' ||
	        *((char *) &lData) == 'Y')
	        s_fEnableRemoteConnect = TRUE;
        }

        // Query the value for the authentication level.
        lDataSize = sizeof(lData );
        hr = RegQueryValueExA( hKey, "LegacyAuthenticationLevel", NULL,
                              &lType, (unsigned char *) &lData, &lDataSize );
        if (hr == ERROR_SUCCESS && lType == REG_DWORD)
        {
	    s_lAuthnLevel = lData;
        }

        // Query the value for the impersonation level.
        lDataSize = sizeof(lData );
        hr = RegQueryValueExA( hKey, "LegacyImpersonationLevel", NULL,
                              &lType, (unsigned char *) &lData, &lDataSize );
        if (hr == ERROR_SUCCESS && lType == REG_DWORD)
        {
	    s_lImpLevel = lData;
        }

        // Query the value for mutual authentication.
        lDataSize = sizeof(lData );
        hr = RegQueryValueExA( hKey, "LegacyMutualAuthentication", NULL,
                              &lType, (unsigned char *) &lData, &lDataSize );
        if (hr == ERROR_SUCCESS && lType == REG_SZ && lDataSize != 0)
        {
	    if (*((char *) &lData) == 'y' ||
	        *((char *) &lData) == 'Y')
	        s_fMutualAuth = TRUE;
        }

        // Query the value for secure interface references.
        lDataSize = sizeof(lData );
        hr = RegQueryValueExA( hKey, "LegacySecureReferences", NULL,
                              &lType, (unsigned char *) &lData, &lDataSize );
        if (hr == ERROR_SUCCESS && lType == REG_SZ && lDataSize != 0)
        {
	    if (*((char *) &lData) == 'y' ||
	        *((char *) &lData) == 'Y')
	        s_fSecureRefs = TRUE;
        }

        //
        // Load the channel hook list
        //
    
        HKEY hKeyHook;
    
        // Open the channel hook key.
        hr = RegOpenKeyEx(hKey, L"ChannelHook",
                               NULL, KEY_QUERY_VALUE, &hKeyHook );
        if (hr == ERROR_SUCCESS)
        {
            DWORD cChannelHook = 0;
            GUID  *aChannelHook;
    
            // Find out how many values exist.
            RegQueryInfoKey( hKeyHook, NULL, NULL, NULL, NULL, NULL, NULL,
                             (DWORD *) &cChannelHook, NULL, NULL, NULL, NULL );
    
            // If there are no channel hooks, throw away the old data.
            if (cChannelHook != 0)
            {
                aChannelHook = (GUID*) OrMemAlloc(sizeof(GUID) * cChannelHook);
    
                // If there is not enough memory, don't make changes.
                if (aChannelHook != NULL)
                {
                    // Enumerate over the channel hook ids.
                    DWORD j = 0;
                    for (DWORD i = 0; i < cChannelHook; i++)
                    {
                        // Get the next key.
                        DWORD lType;
                        CHAR  aExtent[39];
                        WCHAR wExtent[39];
                        DWORD lExtent = sizeof(aExtent);
    
                        hr = RegEnumValueA(hKeyHook, i, aExtent, &lExtent,
                                          NULL, &lType, NULL, NULL);

                        if (hr == ERROR_SUCCESS &&
                            lExtent == 38 && lType == REG_SZ &&
                            MultiByteToWideChar(CP_ACP, 0,
                                    aExtent, -1, wExtent, 39) != 0)
                        {
                            // Convert it to a GUID.
                            if (GUIDFromString(wExtent, &aChannelHook[j]))
                                j += 1;
                        }
                    }
    
                    // Save what we find in shared memory
                    // WARNING - gpSecVals->s_aChannelHook will leak 
                    //
                    gpSecVals->s_cChannelHook = j;
                    gpSecVals->s_aChannelHook = aChannelHook;
                }
            }
            // Close the registry key.
            RegCloseKey(hKeyHook);
        }
    }

    // Close the registry key.
    RegCloseKey( hKey );

    return S_OK;     // failure to read values is not failure (yet)
}


//+-------------------------------------------------------------------------
//
//  Function:   ComputeSecurityPackages
//
//  Synopsis:   Loads Secur32.dll and discovers client and server capable
//              security providers installed on the machine
//
//  Returns:    status
//
//  History:    8-September-96   SatishT Created
//
//  Notes:      This allows default loading of secur32 to be limited to RPCSS
//
//--------------------------------------------------------------------------


RPC_STATUS 
ComputeSecurityPackages()
{
    // s_sServerSvc is a list of security providers that OLE servers can use.
    // s_aClientSvc is a list of security providers that OLE clients can use.
    // The difference is that Chicago only supports the client side of some
    // security providers and OLE servers must know how to determine the
    // principal name for the provider.  Clients get the principal name from
    // the server.
    DWORD  &s_cServerSvc = gpSecVals->s_cServerSvc;
    USHORT *&s_aServerSvc = gpSecVals->s_aServerSvc;
    DWORD  &s_cClientSvc = gpSecVals->s_cClientSvc;
    USHORT *&s_aClientSvc = gpSecVals->s_aClientSvc;

    SecPkgInfo *pAllPkg = NULL;
    SecPkgInfo *pNext = NULL;
    DWORD       lMaxLen = 0;

    DWORD       i;

    SECURITY_STATUS status = LoadSecur32();

    if (status == SEC_E_OK)
    {
        // Get the list of security packages.
        status = pEnumerateSecurityPackages( &lMaxLen, &pAllPkg );
    }

    // It appears that on Nashville this might be the Explorer
    // calling into us during login/initialization.  At that
    // time the EnumerateSecurityPackages succeeds but no
    // package info is filled in!!!
    // Since this info is per process that just means that
    // the Explorer won't be able to do remote stuff???
    if (
        (status != SEC_E_OK) ||
        (lMaxLen == 0) ||        // making sure
        (pAllPkg == NULL)
       )
    {
        return RPC_E_NO_GOOD_SECURITY_PACKAGES;
    }

    // Free original service lists
    OrMemFree(s_aServerSvc);
    OrMemFree(s_aClientSvc);

	// Allocate memory for new service lists.
	s_aServerSvc = (USHORT*) OrMemAlloc(lMaxLen * sizeof(USHORT));
	s_aClientSvc = (USHORT*) OrMemAlloc(lMaxLen * sizeof(USHORT));

	if (s_aServerSvc == NULL || s_aClientSvc == NULL)
    {
        OrMemFree(s_aServerSvc);
        OrMemFree(s_aClientSvc);
	    s_aServerSvc = NULL;
	    s_aClientSvc = NULL;
        return RPC_E_OUT_OF_RESOURCES;
    }
	else
    {
        ASSERT((s_cClientSvc == 0) && (s_cServerSvc == 0));
	    pNext = pAllPkg;

        // Check all packages.

	    for (i = 0; i < lMaxLen; i++)
        {
            // Determine if clients can use the package.
            if ((pNext->fCapabilities & (SECPKG_FLAG_DATAGRAM |
                                         SECPKG_FLAG_CONNECTION)))
            {
                s_aClientSvc[s_cClientSvc++] = pNext->wRPCID;
            }

           // Determine if servers can use the package.

            if ( (pNext->fCapabilities & (SECPKG_FLAG_DATAGRAM |
                                          SECPKG_FLAG_CONNECTION)) &&
                ~(pNext->fCapabilities & (SECPKG_FLAG_CLIENT_ONLY)))
            {
                if (pNext->wRPCID != 11)  // BUGBUG: this horrible hack eliminates 
                                          // msnsspc.dll which should set 
                                          // SECPKG_FLAG_CLIENT_ONLY but does not
                    s_aServerSvc[s_cServerSvc++] = pNext->wRPCID;
            }

            pNext++;
        }
    }

	// Release the list of security packages.
	pFreeContextBuffer( pAllPkg );

    UnloadSecur32();

    return RPC_S_OK;
}


//+-------------------------------------------------------------------------
//
//  Function:   UninitializeGlobals
//
//  Synopsis:   releases all process local resources initialized for DCOM use.
//
//  Returns:    none
//
//  History:    8-July-96   SatishT Created
//
//  Notes:      This routine is called only by Disconnect
//
//--------------------------------------------------------------------------

void
UninitializeGlobals()
{
	// delete process local resources
	delete gpGlobalBlock;
	gpGlobalBlock = NULL;

	// release shared memory allocator
	gSharedAllocator.Release();

	// reset flags
	DCOM_Started = FALSE;

	// forget shared memory pointers
    gpOxidTable = NULL;
    gpOidTable = NULL;
    gpMidTable = NULL;
    gpLocalDSA = NULL;
    gpLocalMid = NULL;
    gpPingProcess = NULL;
    gpIdSequence = NULL;
	gpRemoteProtseqIds = NULL;
    gpwstrProtseqs = NULL;
	gpNextThreadID = NULL;
	gpcRemoteProtseqs = NULL;
	gpfRemoteInitialized = NULL;
}



//
// Startup
//

//+-------------------------------------------------------------------------
//
//  Function:   InitDCOMSharedAllocator
//
//  Synopsis:   Initialises a shared memory region for this process for DCOM use.
//
//  Returns:    status code
//
//  History:    20-Nov-95   HenryLee Created	 (SatishT modifiied)
//
//  Notes:      This routine is called indirectly by DfCreateSharedAllocator
//      such a way that in most circumstances it will be executed
//      exactly once per docfile open.
//
//--------------------------------------------------------------------------

HRESULT InitDCOMSharedAllocator(ULONG DCOMSharedHeapName, void * &pSharedBase)
{
    HRESULT hr = S_OK;

    CSmAllocator *pMalloc = &gSharedAllocator;

    if (pSharedBase == NULL)   // allocate a new heap
    {
        hr = pMalloc->Init (
                    L"DCOMResolverSharedHeap"
                   );
        if ( SUCCEEDED(hr) )
        {
            pMalloc->AddRef();
			pSharedBase = pMalloc->GetBase();
        }
    }

    return hr;
}

static CONST PWSTR gpwstrProtocolsPath  = L"Software\\Microsoft\\Rpc";
static CONST PWSTR gpwstrProtocolsValue = L"DCOM Protocols";
HRESULT MallocInitialize(BOOL fForceLocalAlloc);

ORSTATUS StartDCOM(
    void
    )
/*++

Routine Description:

    Primes the distributed object mechanisms, in particular by initializing
    shared memory access and structures.

Arguments:

    None

Return Value:

    None

--*/

{
    ORSTATUS status = OR_OK;

    if (DCOM_Started)
    {
        return OR_I_REPEAT_START;
    }

    // initialize process identity variables
    MyProcessId = GetCurrentProcessId();

    // create or find the global mutex
    gpMutex = new CGlobalMutex(status);

    // initialize the RPCSS private lock if we are RPCSS
    if (gfThisIsRPCSS)
    {
        InitializeCriticalSection(&gRpcssLock);
    }

    Win4Assert((status == OR_OK) && "CSharedGlobals create global mutex failed");

   {
        CProtectSharedMemory protector; // locks throughout lexical scope

        WCHAR *SharedGlobalBlockName = DCOMSharedGlobalBlockName;

        // Allocate tables, but only if we are in first

        ComDebOut((DEB_ITRACE,"DCOMSharedHeapName = %d\n", DCOMSharedHeapName));
        ComDebOut((DEB_ITRACE,"SharedGlobalBlockName = %ws\n", SharedGlobalBlockName));

	    InitDCOMSharedAllocator(DCOMSharedHeapName,pSharedBase);

        gpGlobalBlock = new CSharedGlobals(SharedGlobalBlockName,status);
    }

    if (gpGlobalBlock == NULL)
    {
        status = OR_NOMEM;
    }

    if (status != OR_OK)
    {
        UninitializeGlobals();
        return status;
    }

    // Allocate lists
    gLocalMID = gpLocalMid->GetMID();

    if (   status != OR_OK
        || !gpOxidTable
        || !gpOidTable
        || !gpMidTable
        || !gpLocalDSA
        || !gpLocalMid
        || !gpIdSequence
        )
        {
        return(OR_NOMEM);
        }


    DCOM_Started = TRUE;
    return(OR_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\objex\shrmem\dcom95\process.cxx ===
/*++

Copyright (c) 1996-1997 Microsoft Corporation

Module Name:

    Process.cxx

Abstract:

    Process objects represent local clients and servers.

    These objects are also polled by rundown threads to detect crashed processes.

Author:

    Satish Thatte    [SatishT]

--*/

#include <or.hxx>

// define the static members for page-based allocation
DEFINE_PAGE_ALLOCATOR(CProcess)

// define the static members for page-based allocation
DEFINE_PAGE_ALLOCATOR(CClassReg)

#if DBG

void CProcess::IsValid()
{
    _MyOxids.IsValid();
    _UsedOids.IsValid();
    _dsaLocalBindings.IsValid();
    _dsaRemoteBindings.IsValid();
    References() > 0;
}

#endif // DBG


CProcess::CProcess(ID ConnectId) 
    :
    _MyOxids(4),     // BUGBUG: these constants should be declared elsewhere
    _UsedOids(16)
{
    _processID = GetCurrentProcessId();
    _Key.Init(ConnectId);
}


// This handle should be freed by the recepient
        
RPC_BINDING_HANDLE 
CProcess::GetBindingHandle()
{
    VALIDATE_METHOD

    USHORT protseq;
    RPC_BINDING_HANDLE hProc;

    PWSTR pwstrMatch = FindMatchingProtseq(ID_WMSG, _dsaLocalBindings->aStringArray);
    ASSERT(pwstrMatch);

    PWSTR pwstrProtseq = GetProtseq(*pwstrMatch);
    
    int l = OrStringLen(pwstrMatch) + OrStringLen(pwstrProtseq) + 2;

    PWSTR pwstrBinding = (WCHAR *) PrivMemAlloc(l * sizeof(WCHAR));

    if (!pwstrBinding)
    {
        return (NULL);
    }

    OrStringCopy(pwstrBinding, pwstrProtseq);
    OrStringCat(pwstrBinding, L":");
    OrStringCat(pwstrBinding, pwstrMatch + 1);

    RPC_STATUS status = RpcBindingFromStringBinding(
                                            pwstrBinding,
                                            &hProc
                                            );

    ASSERT(status == RPC_S_OK);
    PrivMemFree(pwstrBinding);
    return hProc;
}

void
CProcess::Rundown()
// The process has crashed or disconnected and this object is being cleaned up.
{
    COxid *pOxid;
    COid  *pOid;
    ORSTATUS     status;

    CClassReg * pReg;

    TCSafeLinkListIterator<CClassReg> RegIter;
    RegIter.Init(_RegClasses);

    for (pReg = RegIter.Next(); pReg != NULL; pReg = RegIter.Next())
    {
        SCMRemoveRegistration(
                            pReg->GetClsid(),
                            pReg->GetReg() 
                            );
    }

    _RegClasses.Clear();    // this should drop all refcounts for CClassReg objects
                            // in this list to 0 and thus cause them to self-destruct

    if (_MyOxids.Size())
    {
        COxidTableIterator Oxids(_MyOxids);

        while(pOxid = Oxids.Next())
        {
            DisownOxid(pOxid,FALSE);   // not the server thread
        }
    }

    _UsedOids.RemoveAll();
}




RPC_STATUS
CProcess::ProcessBindings(
    IN DUALSTRINGARRAY *pdsaStringBindings
    )
/*++

Routine Description:

    Updates the string bindings associated with this process.

Arguments:

    psaStringBindings - The expanded string bindings of the process
         assumed to be allocated with "new" in local (not shared) memory

Return Value:

    OR_NOMEM - unable to allocate storage for the new string arrays.

    OR_OK - normally.

--*/

{
    VALIDATE_METHOD

    ORSTATUS status = OR_OK;
    
    ASSERT(pdsaStringBindings && dsaValid(pdsaStringBindings)
           && "Process given invalid bindings to store");

    status = _dsaLocalBindings.Assign(pdsaStringBindings, FALSE);  // FALSE = uncompressed

    delete [] (char*)pdsaStringBindings;  // Assign makes a compressed copy

    ASSERT(_dsaLocalBindings.Valid());

    _dsaRemoteBindings.Assign(NULL,TRUE);  // wipes it out -- filled again when needed

    return(OR_OK);
}



DUALSTRINGARRAY *
CProcess::GetRemoteBindings(void)
{
    VALIDATE_METHOD

    ORSTATUS Status;

    if (_dsaRemoteBindings.Empty() && !_dsaLocalBindings.Empty())
    {
        Status = _dsaRemoteBindings.ExtractRemote(_dsaLocalBindings);

        if (Status != OR_OK)
        {
            ASSERT(Status == OR_NOMEM);
            return(NULL);
        }
    }

    if (!_dsaRemoteBindings.Empty())
    {
        return _dsaRemoteBindings;
    }
    else return(NULL);
}



void
CProcess::DisownOxid(COxid *pOxid, BOOL fOxidThreadCalling)
{
    VALIDATE_METHOD

    pOxid->StopRunning();

    ORSTATUS status = pOxid->StopRundownThreadIfNecessary();
    ASSERT(status == OR_OK);

    if (fOxidThreadCalling) 
    {
        pOxid->StopTimerIfNecessary();
    }

    COxid *pIt = gpOxidTable->Remove(*pOxid);
    ASSERT(pIt==pOxid);

    pIt = _MyOxids.Remove(*pOxid);
    ASSERT(pIt==pOxid);

    // pOxid may be an invalid pointer now
}




COid *
CProcess::DropOid(COid *pOid)

/*++

Routine Description:

    Removes an OID from this list of OID in use by this process.

Arguments:

    pOid - The OID to remove.

Return Value:

    non-NULL - the pointer actually removed. (ASSERT(retval == pOid))
               It will be released by the process before return,
               so you should not use the pointer unless you know you
               have another reference.

    NULL - not in the list

--*/

{
    VALIDATE_METHOD

    COid *pIt = _UsedOids.Remove(*pOid);   // releases our reference

    if (pIt)
    {
        ASSERT(pIt == pOid);
        return(pIt);
    }
    
    return(NULL);
}


void
CProcess::AddClassReg(GUID Clsid, DWORD Reg)
{
    VALIDATE_METHOD

    CRegKey newReg(Clsid,Reg);

    CClassReg * pReg = new CClassReg( Clsid, Reg );

    if (pReg)
    {
        ORSTATUS status;

        status = _RegClasses.Insert(pReg);

        if (status == OR_I_DUPLICATE)
        {
            delete pReg;
        }
    }
}

void
CProcess::RemoveClassReg(GUID Clsid, DWORD Reg)
{
    VALIDATE_METHOD

    CClassReg * pReg = _RegClasses.Remove(CRegKey(Clsid,Reg));
}



ORSTATUS                                // called only within the SCMOR process
CProcess::UseProtseqIfNeeded(
    IN USHORT cClientProtseqs,
    IN USHORT aClientProtseqs[],
    IN USHORT cInstalledProtseqs,
    IN USHORT aInstalledProtseqs[],
	IN DWORD dwServerTID				// so we know where to call over WMSG
    )
{
    VALIDATE_METHOD

    ORSTATUS status;
    PWSTR pwstrProtseq = NULL;

    // Hold a reference to self temorarily so we are not destroyed
    // during this call -- in spite of giving up the shared mutex

    CTempHoldRef tempRef(this);

    // Another thread may have used the protseq in the mean time.

    ASSERT(!_dsaLocalBindings.Empty());

    pwstrProtseq = FindMatchingProtseq(cClientProtseqs,
                                       aClientProtseqs,
                                       _dsaLocalBindings->aStringArray
                                       );

    if (NULL != pwstrProtseq)
    {
        return(OR_OK);
    }

    // No protseq shared between the client and the OXIDs' server.
    // Find a matching protseq.

    USHORT i,j;

    for(i = 0; i < cClientProtseqs && pwstrProtseq == NULL; i++)
    {
        for(j = 0; j < cInstalledProtseqs; j++)
        {
            if (aInstalledProtseqs[j] == aClientProtseqs[i])
            {
                ASSERT(FALSE == IsLocal(aInstalledProtseqs[j]));

                pwstrProtseq = GetProtseq(aInstalledProtseqs[j]);
                break;
            }
        }
    }

    if (NULL == pwstrProtseq)
    {
        // No shared protseq, must be a bug since the client managed to call us.
#if DBG
        if (cClientProtseqs == 0)
        {
            ComDebOut((DEB_OXID,"OR: Client OR not configured to use remote protseqs\n"));
        }
        else
        {
            ComDebOut((DEB_OXID,"OR: Client called on an unsupported protocol:   \
                        %d %p %p \n", cClientProtseqs, aClientProtseqs, aInstalledProtseqs));
            ASSERT(0);
        }
#endif

        return(OR_NOSERVER);
    }

    DUALSTRINGARRAY *pdsaStringBindings = NULL, 
                    *pdsaSecurityBindings = NULL,
                    *pdsaMergedBindings = NULL;

    RPC_BINDING_HANDLE hProc;

    if ((hProc = GetBindingHandle()) != NULL)
    {
        // set free threaded client flags and server TID for WMSG calls
        status = I_RpcBindingSetAsync(hProc,NULL,dwServerTID);
        status = I_RpcSetThreadParams(
							TRUE,  // Free threaded client
							NULL,  // no blocking hook
							NULL   // No Hwnd for reply
							);

        if (status == RPC_S_OK)
        {
            CTempReleaseSharedMemory temp;

            // call the server to force use of pwstrProtseq
            status = ::UseProtseq(hProc,
                                  pwstrProtseq,
                                  &pdsaStringBindings,
                                  &pdsaSecurityBindings
                                  );
        }

        RpcBindingFree(&hProc);
    }
    else
    {
        return OR_NOSERVER;
    }

    if (status != RPC_S_OK) return status;

    OrDbgPrint(("OR: Lazy use protseq: %S in process %p - %d\n",
               pwstrProtseq, this, status));

    // Update this process' state to include the new bindings.

    status = MergeBindings(
                    pdsaStringBindings,
                    pdsaSecurityBindings,
                    &pdsaMergedBindings
                    );

    ASSERT(status == OR_OK);
    status = ProcessBindings(pdsaMergedBindings);
    MIDL_user_free(pdsaStringBindings);
    MIDL_user_free(pdsaSecurityBindings);

    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\objex\shrmem\dcom95\scmfuns.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:
//      scmfuns.cxx
//
//  Contents:
//
//      A number of functions called mainly by the SCM, including
//      methods of the CScmBindingIterator class
//
//  History:	Created		24 June 96		SatishT
//
//--------------------------------------------------------------------------

#include <or.hxx>
#include <scmfuns.hxx>
#include <actmisc.hxx>


TCCacheList<CScmHandle> ScmHandleList(ScmHandleCacheLimit);

void
ScmProcessAddClassReg(void * hProcess, REFCLSID rclsid, DWORD dwReg)
{
    CProtectSharedMemory protector; // locks through rest of lexical scope

        ASSERT(hProcess==gpProcess);
        ((CProcess*)hProcess)->AddClassReg( rclsid, dwReg );
}

void
ScmProcessRemoveClassReg(void * hProcess, REFCLSID rclsid, DWORD dwReg)
{
    CProtectSharedMemory protector; // locks through rest of lexical scope

        ASSERT(hProcess==gpProcess);
        ((CProcess*)hProcess)->RemoveClassReg( rclsid, dwReg );
}

void
ScmObjexGetThreadId(LPDWORD pThreadID) 
{
    CProtectSharedMemory protector; // locks through rest of lexical scope

        *pThreadID = (*gpNextThreadID)++;
}

RPC_BINDING_HANDLE
SCMGetBindingHandle(long Id)
{
    RPC_BINDING_HANDLE hResult = NULL;
    CIdKey Key(Id);
    CProcess *pProcess = gpProcessTable->Lookup(Key);
    ASSERT(pProcess);
    RPC_BINDING_HANDLE hTemp = pProcess->GetBindingHandle();

    if (hTemp != NULL)
    {
        RPC_STATUS status = RpcBindingCopy(hTemp,&hResult);

        if (status != RPC_S_OK)
        {
            return NULL;
        }
        else
        {
            return hResult;
        }
    }
    else
    {
        return NULL;
    }
}

void
SCMRemoveClassReg(
                long Id,
                GUID Clsid, 
                DWORD Reg
                )
{
    CIdKey Key(Id);
    CProcess *pProcess = gpProcessTable->Lookup(Key);
    ASSERT(pProcess);
    pProcess->RemoveClassReg(Clsid,Reg);
}

void
SCMAddClassReg(
            long Id,
            GUID Clsid, 
            DWORD Reg
            )
{
    CIdKey Key(Id);
    CProcess *pProcess = gpProcessTable->Lookup(Key);
    ASSERT(pProcess);
    pProcess->AddClassReg(Clsid,Reg);
}



void GetLocalORBindings(
        DUALSTRINGARRAY * &pdsaMyBindings
        )
{
    pdsaMyBindings = gpLocalDSA;
}

void
GetRegisteredProtseqs(
            USHORT &cMyProtseqs,
            USHORT * &aMyProtseqs
            )
{
    cMyProtseqs = *gpcRemoteProtseqs;
    aMyProtseqs = gpRemoteProtseqIds;
}


//
// CScmBindingIterator methods
//

    
void 
CScmBindingIterator::DeleteFromCache()
{
     ASSERT(_pScmHandle != NULL);

    CProtectSharedMemory protector; // locks through rest of lexical scope

     // This Remove call will only actually remove if the item in the list
     // matches the second parameter as a pointer
     CScmHandle *pRemHandle = ScmHandleList.Remove(_pwstrServer,_pScmHandle);

     _pScmHandle->Release();     // Ordinary release for the ref taken 
                                 // in the ctor

     if (pRemHandle != NULL)     // actually removed it
     {
         ASSERT(pRemHandle == _pScmHandle);
         _pScmHandle->Release(); // this release will destroy the handle eventually
     }
}

    
void
CScmBindingIterator::AddToCache()
{
    ORSTATUS status = OR_OK;

    CProtectSharedMemory protector; // locks through rest of lexical scope

    // The ref count will not drop to zero by doing a remove
    // This is because CScmHandles hold an extra self reference
    CScmHandle *pHandle = ScmHandleList.Remove(_pwstrServer);

    // we do not reuse cached CScmHandles to avoid problems with race conditions
    // A handle we are about to destroy or Reset may have been retrieved
    // by another thread, and in that case we may do RpcBindingFree
    // on a handle it is trying to use
    if (pHandle != NULL)
    {
        pHandle->Release(); // this should delete it, eventually
    }

    CScmHandle *pRemovedHandle = NULL;

    status = ScmHandleList.Insert(_pScmHandle,pRemovedHandle);
    ASSERT(status != OR_I_DUPLICATE);

    if (status != OR_OK) 
    {
        _pScmHandle->Release(); // this should delete it, eventually
    }

    if (pRemovedHandle != NULL)
    {
        // we replaced the least recently used handle pRemovedHandle 
        pRemovedHandle->Release();  // we don't want to leak this
    }
}



CScmBindingIterator::CScmBindingIterator(PWSTR pwstrServer) 
: _pwstrServer((PWSTR)NULL)
{
     ASSERT(pwstrServer != NULL);

     HRESULT hr;

     hr = _pwstrServer.Init(pwstrServer);
     
     _ProtseqIndex = -1;

    CProtectSharedMemory protector; // locks through rest of lexical scope

     _pScmHandle = ScmHandleList.Find(_pwstrServer);
     
     if (NULL != _pScmHandle) 
     {
         _fCached = TRUE;
         _pScmHandle->Reference();  // hold a ref so this doesn't go away
     }
     else
     {
         _fCached = FALSE;
     }
}

    
CScmBindingIterator::~CScmBindingIterator()
{
    CProtectSharedMemory protector; // locks through rest of lexical scope

    if (_pScmHandle != NULL)
    {
        if (!_fCached)
        {
            // we have a new handle that worked
            AddToCache();
        }
        else
        {
            // Release the ref we acquired in the ctor
            _pScmHandle->Release();
        }
    }
}

    
RPC_BINDING_HANDLE 
CScmBindingIterator::First(USHORT &wProtseq, HRESULT& hr)
{
    hr = S_OK;

    if (_fCached)
    {
        wProtseq = _pScmHandle->GetProtseq();
        return _pScmHandle->GetRpcHandle();
    }
    else
    {
        return Next(wProtseq, hr);
    }
}

    
RPC_BINDING_HANDLE 
CScmBindingIterator::Next(USHORT &wProtseq, HRESULT& hr)
{
    hr = S_OK;      // be optimistic

    if (_fCached)
    {
        DeleteFromCache();
        _fCached = FALSE;
        _pScmHandle = NULL;
    }

    if (_pScmHandle == NULL) // first call to Next()
    {
        // Create a candidate CScmHandle.  This will be Reset to house the
        // successively tried RPC_BINDING_HANDLEs and cached if successful
        _pScmHandle = new CScmHandle((PWSTR)_pwstrServer,hr);

        if ((_pScmHandle == NULL) || FAILED(hr))
        {
            if (hr == S_OK)
            {
                hr = E_OUTOFMEMORY;
            }

            return NULL;
        }
    }

    ASSERT(!_fCached && _pScmHandle != NULL);

    LPWSTR   pwstrStringBinding = NULL, pwstrProtseq = NULL;
    BOOL     bUsingHttp = *gpfClientHttp;

    while (TRUE)
    {
        _ProtseqIndex += 1;

        if (_ProtseqIndex >= *gpcRemoteProtseqs)
        {
            // try http as last resort
            if (bUsingHttp && (_ProtseqIndex == *gpcRemoteProtseqs)) {
                bUsingHttp = FALSE;
                wProtseq = ID_DCOMHTTP;
            }
            else
            {
                _ProtseqIndex = -1;
                if (_pScmHandle != NULL)    // this handle failed
                {
                    _pScmHandle->Release(); // release it so it will go away
                    _pScmHandle = NULL;     // let the dtor know we have nothing to cache
                }

                return NULL;
            }
        }
        else
        {
            wProtseq = gpRemoteProtseqIds[_ProtseqIndex];
            if (IsLocal(wProtseq)) 
                continue;
        }

        pwstrProtseq = GetProtseq(wProtseq);

        if (pwstrProtseq == NULL) continue;

        PWSTR pBaseServerName = ::GetBaseServerName((PWSTR)_pwstrServer);

	    RPC_STATUS status = RpcStringBindingCompose(
								    NULL,
								    pwstrProtseq,
								    pBaseServerName,
								    GetEndpoint(wProtseq),
								    NULL,
								    &pwstrStringBinding 
								    );

        RPC_BINDING_HANDLE hRemoteSCM;

        status = RpcBindingFromStringBinding(
                                    pwstrStringBinding,
                                    &hRemoteSCM
                                    );

        if (status != RPC_S_OK)
        {
            hr = HRESULT_FROM_WIN32(status);
            return NULL;
        }

        RpcStringFree( &pwstrStringBinding );
        pwstrStringBinding = NULL;

        // Save the handle in case it works 
        // we can then cache it in the dtor
        _pScmHandle->Reset(wProtseq,hRemoteSCM);
        RpcBindingFree(&hRemoteSCM);    // this has been copied into _pScmHandle

        return _pScmHandle->GetRpcHandle();
    }
}


BOOL
CScmBindingIterator::TryUnsecure(RPC_BINDING_HANDLE& hScmHandle)
{
    // This can't be happening if the handle is NULL
    ASSERT(_pScmHandle != NULL);

    if (_UnSecureScmHandle.IsUninitialized())
    {
        _UnSecureScmHandle = *_pScmHandle;  // use assignment operator
    }

    BOOL fResult = _UnSecureScmHandle.TryUnsecure();
    hScmHandle = _UnSecureScmHandle.GetRpcHandle();
    return fResult;
}

BOOL
CScmBindingIterator::TryDynamic()
{
    // This can't be happening if the handle is cached or NULL
    ASSERT(!_fCached && _pScmHandle != NULL);

    return _pScmHandle->TryDynamic();
}

    
RPC_BINDING_HANDLE CScmBindingIterator::SetAuthInfo(COAUTHINFO  *pAuthInfo)
{
    // This can't be happening if the handle is NULL or pAuthInfo is NULL
    ASSERT(_pScmHandle != NULL);
    ASSERT(pAuthInfo != NULL);

    RPC_STATUS status = RPC_S_OK;

    // Assignment does cleanup of previous LHS handle, if any,
    // and makes a copy of the RHS handle.  The destructor for 
    // CRpcssHandle will free the handle when the iterator is destroyed
    _AuthenticatedHandle = *_pScmHandle;
    RPC_BINDING_HANDLE hAuthHandle = _AuthenticatedHandle.GetRpcHandle();

    if (status == RPC_S_OK)
    {
        RPC_SECURITY_QOS    Qos;

        Qos.Version = RPC_C_SECURITY_QOS_VERSION;
        Qos.Capabilities = pAuthInfo->dwCapabilities;
        Qos.ImpersonationType = pAuthInfo->dwImpersonationLevel;
        Qos.IdentityTracking = RPC_C_QOS_IDENTITY_STATIC;

        BOOL fServerPrincNameReset = FALSE;

        if (
            pAuthInfo->pwszServerPrincName == NULL &&
            pAuthInfo->dwAuthnSvc == RPC_C_AUTHN_WINNT
           )
        {
            // The usual hack to avoid calling RpcMgmtInqServerPrincName
            pAuthInfo->pwszServerPrincName = L"Default";
            fServerPrincNameReset = TRUE;
        }


        status = RpcBindingSetAuthInfoExW(
                                    hAuthHandle,
                                    pAuthInfo->pwszServerPrincName,
                                    pAuthInfo->dwAuthnLevel,
                                    pAuthInfo->dwAuthnSvc,
                                    pAuthInfo->pAuthIdentityData,
                                    pAuthInfo->dwAuthzSvc,
                                    &Qos );

        if (fServerPrincNameReset)
        {
            pAuthInfo->pwszServerPrincName = NULL;
        }
    }

    if (status == RPC_S_OK)
    {
        return hAuthHandle;
    }
    else
    {

        return NULL;
    }
}


//
// This function is called by RPCSS when a user logs off
//

void ClearRPCSSHandles()
{
    ASSERT(gfThisIsRPCSS);

    CScmHandle *pScmHandle = NULL;

    while (pScmHandle = ScmHandleList.Pop())
    {
        ASSERT(pScmHandle->References() == 1);
        pScmHandle->Release();  // release the ref acquired when this was constructed
    }

    COrBindingIterator::ResolverHandles.RemoveAll();
}

//
//  This function wakes RPCSS up for reinitialization of remote protocols
//

BOOL PostWakeupMessageToRpcss()
{
    // (Re)initialize ghRpcssWnd from shared memory
    ghRpcssWnd = gpGlobalBlock->GetRpcssWindow();
    ASSERT(gpProcess != NULL);

    if (ghRpcssWnd == NULL)
    {
        // If ghRpcssWnd == NULL there is a race with multiple threads trying to 
        // start RPCSS simultaneously -- someone else started RPCSS but it hasn't had
        // a chance to initialize the window yet.  So let us just act like we launched 
        // RPCSS by doing nothing and waiting for RPCSS to signal an event
        return TRUE;
    }
    else
    {
        // Otherwise post the message and send our PID as wParam
        return PostMessage(ghRpcssWnd, WM_RPCSS_MSG, gpProcess->GetProcessID(), NULL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\objex\shrmem\dcom95\set.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:
//      set.cxx
//
//  Contents:
//
//      Implements the server-side pingset class
//
//  History:	Created		24 August 96		SatishT
//
//--------------------------------------------------------------------------

#include <or.hxx>

ORSTATUS
CPingSet::ComplexPing(
        USHORT sequenceNum,
        USHORT cAddToSet,
        USHORT cDelFromSet,
        OID aAddToSet[],
        OID aDelFromSet[]
        )
{
    ORSTATUS status = OR_OK;

    if (CheckAndUpdateSequenceNumber(sequenceNum))   // if in correct sequence
    {
        USHORT i;
        COid *pOid;

        _LastPingTime.SetNow();

        for (i = 0; i < cDelFromSet; i++)
        {
            CId2Key OidKey(aDelFromSet[i], gLocalMID);
            pOid = _pingSet.Remove(OidKey);

            if (NULL == pOid)
            {
                // This object may have been passed on by a middleman
                // we must make sure to keep it alive for the timeout interval
                pOid = gpOidTable->Lookup(OidKey);

                if (NULL == pOid)
                {
                    status = OR_BADOID;
                }
                else
                {
                    // reset the last release time, used in COid::OkToRundown
                    pOid->SetNow();
                }
            }
        }

        for (i = 0; i < cAddToSet; i++)
        {
            pOid = gpOidTable->Lookup(CId2Key(aAddToSet[i], gLocalMID));

            if (NULL == pOid)
            {
                status = OR_BADOID;
                continue;
            }

            status = _pingSet.Add(pOid);

            if (status == OR_I_DUPLICATE)
            {
                status = OR_OK;
            }

            if (status == OR_NOMEM)
            {
                return status;
            }
        }

        return status;
    }
    else
    {
        return OR_BAD_SEQNUM;
    }
}




//
//  Incoming remote OR requests
//


CPingSetTable gSetTable;


error_status_t _SimplePing(
    IN handle_t hRpc,
    IN SETID *pSetId
    )
{
    CProtectSharedMemory protect; // Locks throu rest of lexical scope

    CPingSet *pSet = gSetTable.Lookup(CIdKey(*pSetId));

    if (pSet == NULL)
    {
        return OR_BADSET;
    }

    RPC_AUTHZ_HANDLE hClient;

    ULONG AuthnLevel, AuthnSvc, AuthzSvc;

    RPC_STATUS status = RpcBindingInqAuthClient(
                                            hRpc,
                                            &hClient,
                                            NULL,
                                            &AuthnLevel,
                                            &AuthnSvc,
                                            &AuthzSvc
                                            );

    // BUGBUG: need Auth check here -- after figuring out what gets returned

    pSet->SimplePing();


    return RPC_S_OK;
}

error_status_t _ComplexPing(
    IN handle_t hRpc,
    IN OUT SETID *pSetId,
    IN USHORT sequenceNum,
    IN USHORT cAddToSet,
    IN USHORT cDelFromSet,
    IN OID aAddToSet[],
    IN OID aDelFromSet[],
    OUT USHORT *pPingBackoffFactor
    )
{
    RPC_AUTHZ_HANDLE hClient;

    ULONG AuthnLevel, AuthnSvc, AuthzSvc;

    RPC_STATUS status = RpcBindingInqAuthClient(
                                            hRpc,
                                            &hClient,
                                            NULL,
                                            &AuthnLevel,
                                            &AuthnSvc,
                                            &AuthzSvc
                                            );

    CPingSet *pSet;

    CProtectSharedMemory protect; // Locks throu rest of lexical scope

    if (*pSetId == 0)   // new set
    {
        *pSetId = AllocateId();

        pSet = new CPingSet(
                        *pSetId,
                        hClient,
                        AuthnLevel,
                        AuthnSvc,
                        AuthzSvc
                        );

        if (pSet == NULL)
        {
            return OR_NOMEM;
        }
        else
        {
            status = gSetTable.Add(pSet);
            if (status != RPC_S_OK)
            {
                return status;
            }
        }
    }
    else
    {
        pSet = gSetTable.Lookup(CIdKey(*pSetId));

        if (pSet == NULL)
        {
             return OR_BADSET;
        }

    // BUGBUG: need Auth check here -- after figuring out what gets returned
    }


    *pPingBackoffFactor = 0;

    return pSet->ComplexPing(
                        sequenceNum,
                        cAddToSet,
                        cDelFromSet,
                        aAddToSet,
                        aDelFromSet
                        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\objex\shrmem\remote\sources.inc ===
!IF 0

Copyright (c) 1995  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

Revision History:

!ENDIF

TARGETNAME=rpcss
TARGETTYPE=PROGRAM
TARGETLIBS= \
	   $(SDK_LIB_PATH)\user32.lib \
           $(SDK_LIB_PATH)\advapi32.lib \
	   $(SDK_LIB_PATH)\kernel32.lib \
	   $(SDK_LIB_PATH)\security.lib \

NTPROFILEINPUT=yes

USE_MSVCRT=1
MSC_WARNING_LEVEL=/WX /W3

UMTYPE=console
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\objex\shrmem\dcom95\string.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    String.cxx

Abstract:

    Methods of construction of various kinds of DUALSTRINGARRAYs.

Author:

    Mario Goertzel    [MarioGo]

Revision History:

    MarioGo     04-01-95    Bits 'n pieces
    MarioGO     01-??-96    STIRNGARRYs replaced by DUALSTRINGARRAYs

--*/

#include <or.hxx>
#include <dcomss.h> // GetProtseq et al

static CONST WCHAR aCallbackSecurity[] = L"Security=Identification Static True";
static CONST DWORD dwCallbackSecurityLength = sizeof(aCallbackSecurity)/sizeof(WCHAR);

RPC_BINDING_HANDLE
GetBinding(
    IN PWSTR pCompressedBinding
    )
{
    ASSERT(pCompressedBinding);

    PWSTR       pwstrStringBinding;
    PWSTR       pwstrProtseq = GetProtseq(*pCompressedBinding);
    PWSTR       pwstrT;
    RPC_STATUS  Status;
    RPC_BINDING_HANDLE bhReturn;
    BOOL        fLocal = FALSE;

    if (!pwstrProtseq)
        {
        return(0);
        }

    int size = OrStringLen(pwstrProtseq) + OrStringLen(pCompressedBinding);

    if (*pCompressedBinding == ID_LPC || *pCompressedBinding == ID_WMSG)
        {
        fLocal = TRUE;
        size += dwCallbackSecurityLength + 1; // +1 for ','
        }

    pwstrStringBinding = (PWSTR) new WCHAR[size];
    if (!pwstrStringBinding)
        {
        return(0);
        }

    OrStringCopy(pwstrStringBinding, pwstrProtseq);
    pwstrT = OrStringSearch(pwstrStringBinding, 0);
    *pwstrT = L':';
    pwstrT++;
    *pwstrT = 0;
    OrStringCopy(pwstrT, pCompressedBinding + 1);

    if (fLocal)
        {
        // We assume we have an endpoint.

        pwstrT = OrStringSearch(pwstrT, 0);
        pwstrT--;
        if (*pwstrT != L']')
            {
            OrDbgPrint(("OR: Local string binding missing endpoint %S\n",
                       pwstrStringBinding));
            ASSERT(0);
            return(0);
            }

        *pwstrT = L',';
        pwstrT++;
        OrStringCopy(pwstrT, aCallbackSecurity);
        pwstrT = OrStringSearch(pwstrT, 0);
        *pwstrT = L']';
        *(pwstrT + 1) = 0;
        }

    Status =
    RpcBindingFromStringBinding( pwstrStringBinding,
                                &bhReturn);

#if DBG
    if (Status != RPC_S_OK)
        {
        OrDbgPrint(("OR: Unable to create binding for %S = %d\n",
                   pwstrStringBinding,
                   Status));
        }
#endif

    return(bhReturn);
}


RPC_BINDING_HANDLE
GetBindingToOr(
    IN PWSTR pwstrCompressedBinding
    )
/*++

Routine Description:

    Gets an RPC binding to a remote object resolver given
    a compressed string binding to the remote object resolver.

Arguments:

    pwstrCompressedBinding - a compressed string binding without an endpoint.

Return Value:

    0 - failed to allocate memory or RpcBindingFromStringBinding failed.

    non-NULL - completed okay

--*/
{
    PWSTR protseq, endpoint;
    PWSTR strbinding;
    USHORT len;
    RPC_BINDING_HANDLE bh = 0;

    ASSERT(pwstrCompressedBinding);
    ASSERT(*pwstrCompressedBinding != 0);

    protseq  = GetProtseq(*pwstrCompressedBinding);
    endpoint = GetEndpoint(*pwstrCompressedBinding);

    if (0 == protseq || 0 == endpoint)
        {
        ASSERT(0);
        return(0);
        }

    len  = 4;  // ':' '[' ']' and '\0'
    len += OrStringLen(protseq);
    len += OrStringLen(endpoint);
    len += OrStringLen(&pwstrCompressedBinding[1]);

    strbinding = new USHORT[len];

    if (strbinding)
        {
        PWSTR pwstrT;

        OrStringCopy(strbinding, protseq);  // protseq

        pwstrT = OrStringSearch(strbinding, 0); // :
        *pwstrT = L':';
        pwstrT++;
        *pwstrT = 0;

        OrStringCat(strbinding, &pwstrCompressedBinding[1]); // network address

        pwstrT = OrStringSearch(strbinding, 0); // [
        *pwstrT = L'[';
        pwstrT++;
        *pwstrT = 0;

        OrStringCat(strbinding, endpoint);  // endpoint

        pwstrT = OrStringSearch(strbinding, 0); // ]
        *pwstrT = L']';
        pwstrT++;
        *pwstrT = 0;

        RPC_STATUS status = RpcBindingFromStringBinding(strbinding, &bh);

        ASSERT(bh == 0 || status == RPC_S_OK);

        delete strbinding;
        }

    if (bh == 0)
        {
        OrDbgDetailPrint(("OR: Unable to bind to %S\n", pwstrCompressedBinding + 1));
        }

    return(bh);
}


DUALSTRINGARRAY *
GetStringBinding(
    IN PWSTR pwstrCompressed,
    IN PWSTR pwstrSecurityBindings
    )
/*++

Routine Description:

    Converts the compressed string binding into an expanded
    string binding.  An enpoint maybe optionally specified.

Arguments:

    pwstrCompressed - a compressed string binding

    pwstrSecurityBindings - optional security bindings
        to be tacked onto the end of the expanded string binding.
        Terminated by two nulls.

Return Value:

    NULL - out of memory

    non-NULL - a string binding.
--*/
{
    DUALSTRINGARRAY *pT;
    PWSTR protseq;
    USHORT seccount;

    PWSTR t = pwstrSecurityBindings;
    if (t && *t)
        {
        seccount = 0;
        do
            {
            seccount++;
            t++;

            if (*t == 0)
                {
                seccount++;
                t++;
                }
            }
        while(*t);

        seccount++; // final NULL
        }
    else
        {
        // Two nulls only.
        seccount = 2;
        }

    protseq = GetProtseq(*pwstrCompressed);

    int l = OrStringLen(pwstrCompressed) + OrStringLen(protseq) + seccount + 1 + 1;

    pT =(DUALSTRINGARRAY *)midl_user_allocate(sizeof(DUALSTRINGARRAY) + l * sizeof(WCHAR));

    if (!pT)
        {
        return (0);
        }

    pT->wNumEntries = l;
    OrStringCopy(pT->aStringArray, protseq);
    OrStringCat(pT->aStringArray, L":");
    OrStringCat(pT->aStringArray, pwstrCompressed + 1);

    if (pwstrSecurityBindings)
        {
        PWSTR t = pT->aStringArray;
        t = OrStringSearch(t, 0);
        t++;
        *t = 0;  // Second NULL on string bindings.
        t++;
        OrMemoryCopy(t, pwstrSecurityBindings, seccount*sizeof(WCHAR));
        }
    else
        {
        // Add three NULLs, total of four.
        PWSTR t = pT->aStringArray;
        t = OrStringSearch(t, 0);
        t[1] = 0;
        t[2] = 0;
        t[3] = 0;
        }

    pT->wSecurityOffset = pT->wNumEntries - seccount;

    ASSERT(dsaValid(pT));

    return(pT);
}


ORSTATUS
ConvertToRemote(
    IN  DUALSTRINGARRAY  *pdsaLocal,
    OUT DUALSTRINGARRAY **ppdsaRemote
    )
/* ++

Parameters:
    pdsaLocal - An array of string bindings with compressed protseqs.

    ppdsaRemote - Will contain only those string bindings in pdsaLocal
        which are not "IsLocal()".

    Note: *ppdsaRemote maybe used as a flag, don't set it to non-NULL
    until it is valid.

-- */
{
    int iTotalSize;
    int iSize;
    USHORT *p1, *p2;
    DUALSTRINGARRAY *pdsaT;

    // Size remote array

    // Final null terminator
    iSize = 1;

    p1 = pdsaLocal->aStringArray;

    while(*p1)
        {
        if (! IsLocal(*p1) )
            {
            iSize += OrStringLen(p1) + 1;
            }
        p1 = OrStringSearch(p1, 0) + 1;
        }

    if (iSize == 1)
        {
        iSize = 2; // No non-local strings, need two terminators.
        }

    iTotalSize = iSize + (pdsaLocal->wNumEntries - pdsaLocal->wSecurityOffset);

    pdsaT = new(iTotalSize * sizeof(WCHAR)) DUALSTRINGARRAY;

    if (!pdsaT)
        {
        return(OR_NOMEM);
        }

    pdsaT->wNumEntries = iTotalSize;
    pdsaT->wSecurityOffset = iSize;

    p2 = pdsaT->aStringArray;

    // Copy security bindings
    OrMemoryCopy(p2 + iSize,
                 pdsaLocal->aStringArray + pdsaLocal->wSecurityOffset,
                 (iTotalSize - iSize) * sizeof(WCHAR));

    if (iSize == 2)
        {
        // No non-local strings, fill in terminators and return.
        *p2 = 0;
        *(p2 + 1) = 0;
        *ppdsaRemote = pdsaT;

        ASSERT(dsaValid(pdsaT));
        return(OR_OK);
        }

    p1 = pdsaLocal->aStringArray;

    while(*p1)
        {
        if ( ! IsLocal(*p1) )
            {
            OrStringCopy(p2, p1);
            p2 = OrStringSearch(p2, 0) + 1;
            }

        p1 = OrStringSearch(p1, 0) + 1;
        }

    *p2 = 0; // Second terminator.

    *ppdsaRemote = pdsaT;

    ASSERT(dsaValid(pdsaT));
    return(OR_OK);
}

DUALSTRINGARRAY *
CompressStringArray(
    IN DUALSTRINGARRAY *pdsaExpanded,
    IN BOOL fSharedMem
    )
/*++

Routine Description:

    Converts a stringarray of regular string bindings into a
    compressed (protseq's replaced with WORD id's) array of
    string bindings.

Arguments:

    pdsaExpanded - the string array to compress.
        Security information is copied.

Return Value:

    0 - failed to allocate memory.

    non-0 - compressed string array.

--*/
{
    int i, size;
    USHORT *p1, *p2, *p3;
    PWSTR pwstr;
    DUALSTRINGARRAY *pdsaCompressed;

    // Compute size of result.

    p1 = pdsaExpanded->aStringArray;

    size = pdsaExpanded->wNumEntries - pdsaExpanded->wSecurityOffset;

    if (*p1 == 0)
        {
        size += 2;  // two null terminators ONLY.
        }
    else
        {
        size += 1;  // last null terminator
        }

    while(*p1)
        {
        int sizeT = OrStringLen(p1);

        p2 = OrStringSearch(p1, L':');  // ':' is not valid in protseq.
        if (p2)
            {
            size += sizeT + 1 - (p2 - p1);  // proseq len (p2 - p1) become 1 for Id.
            }
        else
            {
            ASSERT(p2);
            }

        p1 = OrStringSearch(p1, 0) + 1;
        }

    if (fSharedMem)
    {
        pdsaCompressed = (DUALSTRINGARRAY*)
                         OrMemAlloc(sizeof(DUALSTRINGARRAY) + size * sizeof(WCHAR));
    }
    else
    {
        pdsaCompressed = (DUALSTRINGARRAY*)
                         midl_user_allocate(sizeof(DUALSTRINGARRAY) + size * sizeof(WCHAR));
    }

    if (0 == pdsaCompressed)
        {
        return(0);
        }

    pdsaCompressed->wNumEntries = size;
    pdsaCompressed->wSecurityOffset = size - (pdsaExpanded->wNumEntries - pdsaExpanded->wSecurityOffset);
    p3 = pdsaCompressed->aStringArray;
    *p3 = 0;

    p1 = pdsaExpanded->aStringArray;

    if (*p1 == 0)
        {
        // Two null terminators only.
          p3++;
        }

    while(*p1)
        {
        p2 = OrStringSearch(p1, L':');
        if (p2)
            {
            *p2 = 0;
            *p3 = GetProtseqId(p1);
            *p2 = L':';
            if (*p3 != 0)
                {
                p3++;
                p1 = p2 + 1; // Just after ':'
                OrStringCopy(p3, p1);

                // Move p3 to start of next string if any.
                p3 = OrStringSearch(p3, 0) + 1;
                }
            }

        // Move p1 to start of next string if any.
        p1 = OrStringSearch(p1, 0) + 1;
        }

    // Second terminator, p3 already points to it.
    *p3 = 0;

    // Copy security bindings
    OrMemoryCopy(p3 + 1,
                 pdsaExpanded->aStringArray + pdsaExpanded->wSecurityOffset,
                 (pdsaExpanded->wNumEntries - pdsaExpanded->wSecurityOffset) * sizeof(WCHAR));

    ASSERT(dsaValid(pdsaCompressed));

    return(pdsaCompressed);
}


PWSTR
FindMatchingProtseq(
    IN USHORT cClientProtseqs,
    IN USHORT aClientProtseqs[],
    IN PWSTR  pwstrServerBindings
    )
/*++

Routine Description:

    Finds the first protseq id in aClientProtseqs which appears in any of
    the server bindings.

Arguments:

    cClientProtseqs - the number of entries in aClientProtseqs.
    aClientProtseqs - Protseq tower id's support by the client.
    pwstrServerBindings - compressed array of bindings supported by the server
        terminated by two NULLs.

Return Value:

    0 - no match found.
    non-0 - a pointer into the pwstrCompressedBindings.

--*/

// Called by server oxid's and processes when checking for lazy use protseq.
{
    ULONG i;

    if (0 == cClientProtseqs)
        {
        return(0);
        }

    while(*pwstrServerBindings)
        {
        for(i = 0; i < cClientProtseqs; i++)
            {
            if (aClientProtseqs[i] == *pwstrServerBindings)
                {
                return(pwstrServerBindings);
                }
            }
        pwstrServerBindings = OrStringSearch(pwstrServerBindings, 0) + 1;
        }

    return(NULL);
}



PWSTR
FindMatchingProtseq(
    IN USHORT protseq,
    IN PWSTR  pwstrCompressedBindings
    )
/*++

Routine Description:

    Searches a compressed string array for an entry which
    matches a particular protseq.


Arguments:

    protseq - The protseq to search for.

    pwstrCompressedBindings - The bindings to search.

Return Value:

    0 - not found

    non-0 - a pointer into the pwstrCompressedBindings

--*/
{
    ASSERT(pwstrCompressedBindings);

    while(*pwstrCompressedBindings)
        {
        if (*pwstrCompressedBindings == protseq)
            {
            return(pwstrCompressedBindings);
            }
        pwstrCompressedBindings = OrStringSearch(pwstrCompressedBindings, 0) + 1;
        }
    return(0);
}




USHORT
CountBindings(
    IN USHORT protseq,
    IN PWSTR  pwstrCompressedBindings
    )
/*++

Routine Description:

    Searches a compressed string array for bindings which
    match a particular protseq.  Returns the count of bindings found.


Arguments:

    protseq - The protseq to search for.

    pwstrCompressedBindings - The bindings to search.

Return Value:

    number of matches found


--*/
{
    ASSERT(pwstrCompressedBindings);

    USHORT count = 0;

    while(*pwstrCompressedBindings)
    {
        if (*pwstrCompressedBindings == protseq)
        {
            count++;
        }

        pwstrCompressedBindings = OrStringSearch(pwstrCompressedBindings, 0) + 1;
    }

    return count;
}



BOOL
IsMultiNetwork(
    IN USHORT cClientProtseqs,
    IN USHORT aClientProtseqs[],
    IN PWSTR  pwstrCompressedBindings
    )
/*++

Routine Description:

    Searches a compressed string array for the number of bindings 
    for each given protseq.


Arguments:

    cClientProtseqs - the number of entries in aClientProtseqs.
    aClientProtseqs - Protseq tower id's support by the client.

    pwstrCompressedBindings - The bindings to search.

Return Value:

    TRUE - some supported protseq has > 1 bindings

    FALSE - no supported protseq has > 1 bindings


--*/
{
    ASSERT(pwstrCompressedBindings);
    ASSERT(aClientProtseqs);

    for (int i = 0; i < cClientProtseqs; i++)
    {
        if (CountBindings(aClientProtseqs[i],pwstrCompressedBindings) > 1)
        {
            return TRUE;
        }
    }

    return FALSE;
}



PWSTR
GetAddressFromCompressedBinding(
    IN PWSTR pwstrCompressed
    )
/*++

Routine Description:

    Converts a compressed string to a string binding, parses it and returns 
    the network address as a string. The returned string must be freed with 
    RpcStringFree.


Arguments:

    pwstrCompressed - The binding to parse.

Return Value:

    Network address string

--*/
{
    PWSTR protseq = GetProtseq(*pwstrCompressed);

    int len = OrStringLen(pwstrCompressed) + OrStringLen(protseq) + 1;

    PWSTR pwstrStringBinding = (PWSTR) PrivMemAlloc(len * sizeof(WCHAR));

    if (!pwstrStringBinding)
    {
        return NULL;
    }

    OrStringCopy(pwstrStringBinding, protseq);
    OrStringCat(pwstrStringBinding, L":");
    OrStringCat(pwstrStringBinding, pwstrCompressed + 1);

    PWSTR pwstrAddr = NULL;

    RPC_STATUS status = RpcStringBindingParse(
							   pwstrStringBinding,
                               NULL,
                               NULL,
                               &pwstrAddr,
                               NULL,
                               NULL
							   );

    PrivMemFree(pwstrStringBinding);

    if (status != RPC_S_OK)
    {
        return NULL;
    }
    else
    {
        return pwstrAddr;
    }
}






PWSTR
FindMatchingProtseqAndAddr(
    IN USHORT protseq,
    IN PWSTR pwstrAddr,
    IN PWSTR  pwstrCompressedBindings
    )
/*++

Routine Description:

    Searches a compressed string array for an entry which
    matches a particular protseq and network address.


Arguments:

    protseq - The protseq to search for.

    pwstrAddr -- The network address to search for

    pwstrCompressedBindings - The bindings to search.

Return Value:

    0 - not found

    non-0 - a pointer into the pwstrCompressedBindings

--*/
{
    ASSERT(pwstrCompressedBindings);
    ASSERT(pwstrAddr);

    PWSTR pwstrA = NULL;

    while(*pwstrCompressedBindings)
    {
        if (*pwstrCompressedBindings == protseq)
        {
            pwstrA = GetAddressFromCompressedBinding(pwstrCompressedBindings);

            if (pwstrA==NULL)
            {
                return NULL;
            }

            BOOL fGoodAddr = (OrStringCompare(pwstrA,pwstrAddr) == 0);

            RpcStringFree(&pwstrA);

            if (fGoodAddr)
            {
                return pwstrCompressedBindings;
            }
        }

        pwstrCompressedBindings = OrStringSearch(pwstrCompressedBindings, 0) + 1;
    }

    return NULL;
}



DUALSTRINGARRAY *
GetMatchingDSA(
    IN USHORT  cClientProtseqs,
    IN USHORT  aClientProtseqs[],
    IN DUALSTRINGARRAY *pdsaServerBindings
    )
/*++

Routine Description:

    Finds all protseq ids in aClientProtseqs which appears in any of
    the server bindings.  Then cobbles together a sequence of 
    matching compressed bindings into a DUALSTRINGARRAY.

Arguments:

    cClientProtseqs - the number of entries in aClientProtseqs.
    aClientProtseqs - Protseq tower id's support by the client.
    pwstrServerBindings - compressed array of bindings supported by the server
        terminated by two NULLs.

Return Value:

    NULL - no match found.
    non-0 - A dualstringarray of expanded matching bindings.

--*/

// Called by server oxid's and processes when checking for lazy use protseq
// on multinetwork machines.
{
    ULONG i;
    USHORT matchingProtseq = 0;

    if (0 == cClientProtseqs)
    {
        return NULL;
    }

    USHORT len = 0;

    PWSTR pwstrServerBindings = pdsaServerBindings->aStringArray;

    while(*pwstrServerBindings)
    {
        if (IsMemberOf(*pwstrServerBindings,cClientProtseqs,aClientProtseqs))
        {
            len += OrStringLen(pwstrServerBindings) + 1;
        }

        pwstrServerBindings = OrStringSearch(pwstrServerBindings, 0) + 1;
    }

    if (len == 0)
    {
        return NULL;    // nothing found to match
    }

    USHORT wSecuritySize = pdsaServerBindings->wNumEntries -
                           pdsaServerBindings->wSecurityOffset;

    // add one terminating NULL for the strings and the security binding size    
    len += wSecuritySize + 1; 

    DUALSTRINGARRAY *pdsaResult = (DUALSTRINGARRAY*)
                                  MIDL_user_allocate(sizeof(DUALSTRINGARRAY) + 
                                               len * sizeof(WCHAR));

    if (pdsaResult == NULL)
    {
        return NULL;
    }

    pdsaResult->wNumEntries = len;
    pdsaResult->wSecurityOffset = len - wSecuritySize;

    PWSTR pwstrStringBinding = pdsaResult->aStringArray;

    // reset pwstrServerBindings
    pwstrServerBindings = pdsaServerBindings->aStringArray;

    while (*pwstrServerBindings)
    {
        if (IsMemberOf(*pwstrServerBindings,cClientProtseqs,aClientProtseqs))
        {
            OrStringCopy(pwstrStringBinding, pwstrServerBindings);
            pwstrStringBinding = OrStringSearch(pwstrStringBinding, 0) + 1;
        }

        pwstrServerBindings = OrStringSearch(pwstrServerBindings, 0) + 1;
    }
    
    *pwstrStringBinding++ = 0;  // terminate string bindings

    memcpy(
        pdsaResult->aStringArray + pdsaResult->wSecurityOffset,
        pdsaServerBindings->aStringArray + pdsaServerBindings->wSecurityOffset,
        sizeof(WCHAR) * wSecuritySize
        );

    return pdsaResult;
}



ORSTATUS
MergeBindings(
    IN  DUALSTRINGARRAY  *pdsaStringBindings,
    IN  DUALSTRINGARRAY  *pdsaSecurityBindings,
    OUT DUALSTRINGARRAY **ppdsaMergedBindings
    )
/*++

Routine Description:

    Merges the string bindings from the first param with the security
    bindings from the second param to create a new dualstring array.


Arguments:

    pdsaStringBindings      --  The string bindings supplier

    pdsaSecurityBindings    --  The security bindings supplier

    ppdsaMergedBindings     -- the merged result

Return Value:

    OR_OK (0)   - success

    OR_NOMEM    - memory allocation failed

--*/
{

    ASSERT(dsaValid(pdsaStringBindings));
    ASSERT(dsaValid(pdsaSecurityBindings));

    USHORT wBindingsSize = pdsaStringBindings->wSecurityOffset;

    USHORT wSecuritySize = pdsaSecurityBindings->wNumEntries -
                           pdsaSecurityBindings->wSecurityOffset;

    USHORT wNumEntries = wBindingsSize + wSecuritySize;

    DUALSTRINGARRAY *pdsa =  (DUALSTRINGARRAY *)
                             new char[
                                sizeof(DUALSTRINGARRAY) +
                                (wNumEntries - 1) * sizeof(WCHAR)
                                ];

    if (!pdsa)
    {
        return OR_NOMEM;
    }

    *ppdsaMergedBindings = pdsa;

    pdsa->wNumEntries = wNumEntries;
    pdsa->wSecurityOffset = wBindingsSize;

    memcpy(
        pdsa->aStringArray,
        pdsaStringBindings->aStringArray,
        wBindingsSize * sizeof(WCHAR)
        );

    memcpy(
        pdsa->aStringArray + pdsa->wSecurityOffset,
        pdsaSecurityBindings->aStringArray + pdsaSecurityBindings->wSecurityOffset,
        sizeof(WCHAR) * wSecuritySize
        );

    return OR_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\objex\shrmem\remote\bridge.cxx ===
/*++

Copyright (c) 1996-1997 Microsoft Corporation

Module Name:

    bridge.cxx

Abstract:

    This module contains miscellaneous functions needed for the RPCSS
    service on Chicago, including manager routines for a number of RPC calls.

Author:

    Satish Thatte    [SatishT]    06-19-96

--*/

#include <or.hxx>
#include <rawforward.h>


DWORD
RegisterAuthInfoIfNecessary(USHORT authnSvc)
{
    DWORD Status;

    UCHAR *pszPrincName;

    Status = RpcServerInqDefaultPrincNameA(
                                    authnSvc,
                                    &pszPrincName
                                    );
    if (Status != RPC_S_OK)
    {
        pszPrincName = NULL;
    }

    Status = RpcServerRegisterAuthInfoA(
                                    pszPrincName,
                                    authnSvc,
                                    NULL,
                                    NULL);

	// ....\ih\widewrap.h defines RpcStringFree to be RpcStringFreeW
    RpcStringFreeA(&pszPrincName);

    return Status;
}

void __RPC_USER PHPROCESS_rundown(LPVOID hProcess)
{
    return;
}



//
// stuff we will have to take over to DCOM95
//

USHORT cMyProtseqs = 0;
USHORT *aMyProtseqs = 0;
DUALSTRINGARRAY *pdsaMyBindings = NULL;

typedef LONG ORSTATUS;

ORSTATUS StartDCOM(void);

void                                                                              
GetRegisteredProtseqs(
            USHORT &cMyProtseqs,
            USHORT * &aMyProtseqs
            );

void GetLocalORBindings(
        DUALSTRINGARRAY * &pdsaMyBindings
        );

HRESULT ScmCoInitChannel();

// see com\dcomrem\riftbl.cxx
// this is used to imitate standard ORPC server interface registration
extern const RPC_SERVER_INTERFACE gServerIf;
EXTERN_C const IID IID_IRemoteActivator;

DWORD StartObjectExporter()
{
    RPC_STATUS status;

    // On Chicago we need to call ScmCoInitChannel as part of
    // SCM startup since the SCM is written for in process use
    // This means it assumes initialization of a bunch of variables
    // accomplished by this call in order to successfully activate

    // We do it here instead to avoid a duplicate StartDCOM call
    // This causes the waste of a process object in shared memory

    // signal to StartDCOM that remote protocols should be initialized
    gfThisIsRPCSS = TRUE;

	HRESULT hr = ScmCoInitChannel();  // see com\dcomrem\resolver.cxx
    if (hr != S_OK)
    {
        Win4Assert(!"ScmCoInitChannel failed in ");
        return(RPC_S_INTERNAL_ERROR);
    }

   // this initializes aMyProtseqs, cMyProtseqs
    GetRegisteredProtseqs(cMyProtseqs,aMyProtseqs);
    GetLocalORBindings(pdsaMyBindings);

    status = RpcServerRegisterIf(_IObjectExporter_ServerIfHandle, 0, 0);

    if (status == RPC_S_OK)
    {
        status = RpcServerRegisterIf(_IOxidResolver_ServerIfHandle, 0, 0);

        if (status == RPC_S_OK)
        {
            // The process of registering an ORPC WMSG local interface is
            // somewhat more involved than raw RPC interfaces!  The version
            // number must be changed because COM interfaces arenot versioned.
            // And we must make a copy of _IRemoteActivator_ServerIfHandle
            // since it is declared as a static const

            RPC_SERVER_INTERFACE If;

            memcpy(&If,_IRemoteActivator_ServerIfHandle,sizeof(RPC_SERVER_INTERFACE));
            
            memcpy(
                &If.InterfaceId.SyntaxVersion, 
                &gServerIf.InterfaceId.SyntaxVersion, 
                sizeof(RPC_VERSION)
                );

            status = RpcServerRegisterIfEx(
                                          &If, 
                                          NULL,
                                          NULL,
                                          RPC_IF_AUTOLISTEN,
                                          0xffff, 
                                          NULL
                                          );
        }
    }

    if (status != RPC_S_OK)
    {
        ComDebOut((DEB_ERROR,"RpcServerRegisterIf for Resolver Failed With Error=%d",
                              status));
        return(status);
    }

    ASSERT(status == RPC_S_OK);

    return status;
}



ORSTATUS 
OrResolveOxid(
    IN  OXID Oxid,
    IN  USHORT cRequestedProtseqs,
    IN  USHORT aRequestedProtseqs[],
    IN  USHORT cInstalledProtseqs,
    IN  USHORT aInstalledProtseqs[],
    OUT OXID_INFO& OxidInfo
    )
{
    ComDebOut((DEB_OXID, "_ResolveOxid OXID = %08x\n",Oxid));

    COxid       *pOxid;
    ORSTATUS     status = OR_OK;

    CProtectSharedMemory protector; // locks through rest of lexical scope

    pOxid = gpOxidTable->Lookup(CId2Key(Oxid, gLocalMID));

    if (pOxid)
    {
        status = pOxid->GetRemoteInfo(
                            cRequestedProtseqs,
                            aRequestedProtseqs,
                            cInstalledProtseqs,
                            aInstalledProtseqs,
                            &OxidInfo
                            );

        return status;
    }
    else        // the OXID should already be registered by server
    {
        return OR_BADOXID;
    }
}


// the following are wrapped in extern "C" because the linker dislikes 
// _ResolveOxid2 otherwise

extern "C" {


error_status_t _ResolveOxid2( 
    IN handle_t hRpc,
    IN OXID *pOxid,
    IN USHORT cRequestedProtseqs,
    USHORT arRequestedProtseqs[  ],
    OUT DUALSTRINGARRAY **ppdsaOxidBindings,
    OUT IPID *pipidRemUnknown,
    OUT DWORD *pAuthnHint,
    OUT COMVERSION *pComVersion
    )
{
    OXID_INFO OxidInfo;

    ORSTATUS status = OrResolveOxid(
                            *pOxid,
                            cRequestedProtseqs,
                            arRequestedProtseqs,
                            cMyProtseqs,
                            aMyProtseqs,
                            OxidInfo
                            );

    if (status != OR_OK)
    {
        return status;
    }

    *ppdsaOxidBindings = OxidInfo.psa;
    *pipidRemUnknown = OxidInfo.ipidRemUnknown;
    *pAuthnHint = OxidInfo.dwAuthnHint;
    *pComVersion = OxidInfo.version;

    return RPC_S_OK;
}


error_status_t _ResolveOxid(
    IN handle_t hRpc,
    IN OXID *pOXID,
    IN USHORT cRequestedProtseqs,
    IN USHORT aRequestedProtseqs[],
    OUT DUALSTRINGARRAY **ppdsaOxidBindings,
    OUT IPID *pipidRemUnknown,
    OUT DWORD *pAuthnHint
    )
{
    COMVERSION comversion;

    // just forward to new manager

    return _ResolveOxid2(
                        hRpc,
                        pOXID,
                        cRequestedProtseqs,
                        aRequestedProtseqs,
                        ppdsaOxidBindings,
                        pipidRemUnknown,
                        pAuthnHint,
                        &comversion
                        );
}


error_status_t
_ServerAlive(
    RPC_BINDING_HANDLE hServer
    )
/*++

Routine Description:

    Pign API for the client to validate a binding.  Used when the client
    is unsure of the correct binding for the server.  (Ie. If the server
    has multiple IP addresses).

Arguments:

    hServer - RPC call binding

Return Value:

    RPC_S_OK

--*/
{
    return(RPC_S_OK);
}


error_status_t _RemoteResolveOXID( 
    IN OXID OxidServer,
    IN DWORD pointerToMidObject)
/*++

Routine Description:

    Clients call this local RPCSS API to resolve a remote OXID.
    We do not return the OXID_INFO through this API.
    We simply resolve the OXID and register it in shared memory.

Arguments:

    OxidServer - OXID to be resolved
    pdsaObjectResolverBindings - bindings for resolver on server machine

Return Value:

    OR_OK, OR_BADOXID

--*/
{
    OXID_INFO OxidInfo;
    COxid *pDummy;

    CProtectSharedMemory protector; // locks through rest of lexical scope

    return FindOrCreateOxid(
                        OxidServer,
                        (CMid*) pointerToMidObject,
                        FALSE,
                        OxidInfo,
                        0,
                        FALSE, 
                        pDummy  // we don't care about the output here
                        );
}


// dummy functions for IRemoteActivator interface

HRESULT _DummyQueryInterfaceRemact( 
    IN handle_t rpc,
    /* [ref][in] */ ORPCTHIS *orpcthis,
    /* [ref][in] */ LOCALTHIS *localthis,
    OUT ORPCTHAT *orpcthat,
    IN DWORD dummy)
{
    return RPC_S_CANNOT_SUPPORT;
}


HRESULT _DummyAddRefRemact( 
    IN handle_t rpc,
    /* [ref][in] */ ORPCTHIS *orpcthis,
    /* [ref][in] */ LOCALTHIS *localthis,
    OUT ORPCTHAT *orpcthat,
    IN DWORD dummy)
{
    return RPC_S_CANNOT_SUPPORT;
}


HRESULT _DummyReleaseRemact( 
    IN handle_t rpc,
    /* [ref][in] */ ORPCTHIS *orpcthis,
    /* [ref][in] */ LOCALTHIS *localthis,
    OUT ORPCTHAT *orpcthat,
    IN DWORD dummy)
{
    return RPC_S_CANNOT_SUPPORT;
}

} // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\objex\shrmem\remote\remote.cxx ===
/*++

Copyright (c) 1996-1997 Microsoft Corporation

Module Name:

    remote.cxx

Abstract:

    Process initialization for RPCSS.EXE

Author:

    Satish Thatte    [SatishT]

--*/

#include <or.hxx>
#include <remact.h>
#include <userapis.h>  // bypass stack switching for USER APIs

// Starts the ping thread and rundown thread for remote objects
DWORD StartObjectExporter();

// Inits the shared memory SCM data structures
HRESULT CheckAndStartSCM(void);

extern "C" {
    DWORD StartEndpointMapper(void);  // Starts the end point mapper.
    DWORD StartMqManagement(void);    // Start MQ Manager Interface.
};

// Declarations for RegisterServiceProcess -- since we don't want to include
// the 16bit version of windows.h which is the only place this seems to be declared


#define RSP_UNREGISTER_SERVICE	0x00000000
#define RSP_SIMPLE_SERVICE	0x00000001

typedef DWORD
(APIENTRY *pfRegisterServiceProcess_ROUTINE) ( DWORD dwProcessId,
                                               DWORD dwType ) ;

BOOL StartWin95Service()
{
    //
    // See KB Q125714 for details about the calls below.
    //

    //
    // We dynamically load Kernel32.dll to avoid dependence on private libs 
    // which export the "internal" RegisterServiceProcess API.
    //

    HMODULE hMod = LoadLibraryA("kernel32.dll");
    BOOL fResult = FALSE;

    ASSERT(hMod != NULL);

    if (hMod)
    {
       pfRegisterServiceProcess_ROUTINE
        pfRegisterServiceProcess = (pfRegisterServiceProcess_ROUTINE)
                            GetProcAddress (hMod,"RegisterServiceProcess") ;
       ASSERT(pfRegisterServiceProcess) ;

       if (pfRegisterServiceProcess)
       {
          fResult = pfRegisterServiceProcess(NULL, RSP_SIMPLE_SERVICE);
          ASSERT(fResult == TRUE) ;
       }

       FreeLibrary(hMod) ;
    }

    return fResult;
}

// 
// Window for messages to RPCSS
//

HWND ghRpcssWnd = NULL;

//
// Handle for RPCSS sync event
//

HANDLE ghSyncEvent = NULL;

//
// paraphernalia for the ping thread
//

HANDLE ghPingThread;
DWORD gdwThrdId;
DWORD _stdcall PingThread(void);
RPC_STATUS StartPingThread();
BOOL fPingThreadStarted = FALSE;

// 
// Window procedure for END session messages
//

LRESULT RpcssWndProc(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    switch(message)
    {
        // this case allows RPCSS to clear RPC handles during logoff so that
        // one user's credentials are not used for another -- this should be handled
        // only by the RPCSS process 
        case WM_ENDSESSION:
                ClearRPCSSHandles();
                return 0;

        case WM_RPCSS_MSG:
            {
                CProtectSharedMemory protector; // locks through rest of lexical scope
                
                // Init this again 
                gpGlobalBlock->InitGlobals(
                                    FALSE, // we are not creating shared memory 
                                    TRUE   // we are reiniting globals from RPCSS
                                    );

                BOOL fResult = SetEvent(ghSyncEvent);

                if (fResult == FALSE)
                {
                    ComDebOut((DEB_ERROR,
                               "Failed Signalling RPCSS Sync Event, GetLastError()=%d\n", 
                               GetLastError()));
                }

                return 0;
            }

        case WM_TIMER:
            // check on status of ping thread -- but make sure the ping thread was
            // started at least once to avoid a race at initialization 
            if (fPingThreadStarted && (CTime() - gLastPingTime) > BaseTimeoutInterval)
            {
                // The ping thread is blocked in a ping
                TerminateThread(ghPingThread,0);
                ghPingThread = NULL;
                StartPingThread();
            }

            return 0;
    }

    // We don't process the message so pass it on to the default window proc
    return DefWindowProc(hWnd, message, wParam, lParam);
}


// 
// Register Window Class and Create Window for END session messages
//

DWORD InitRpcssWindow()
{
    DWORD dwResult = RPC_S_INTERNAL_ERROR;

    // Register windows class.
    WNDCLASST        xClass;
    xClass.style         = 0;
    xClass.lpfnWndProc   = RpcssWndProc;
    xClass.cbClsExtra    = 0;
    xClass.cbWndExtra    = 0;
    xClass.hInstance     = g_hinst;
    xClass.hIcon         = NULL;
    xClass.hCursor       = NULL;
    xClass.hbrBackground = (HBRUSH) (COLOR_BACKGROUND + 1);
    xClass.lpszMenuName  = NULL;
    xClass.lpszClassName = "RpcssLogoffWindowClass";


        
    LPTSTR pszRpcssWindowClass = (LPTSTR) RegisterClassT(&xClass);

    if (pszRpcssWindowClass == 0)
    {
        ComDebOut((DEB_ERROR, "RegisterClass failed in InitRpcssWindow\n"));
    }
    else
    {
        ghRpcssWnd = CreateWindowExA(0,
                          pszRpcssWindowClass,
                          "RPCSSWindow",
                          // must use WS_POPUP so the window does not get
                          // assigned a hot key by user.
                          (WS_DISABLED | WS_POPUP),
                          CW_USEDEFAULT,
                          CW_USEDEFAULT,
                          CW_USEDEFAULT,
                          CW_USEDEFAULT,
                          NULL,
                          NULL,
                          g_hinst,  // OLE32 DLL's hInstance
                          NULL
                          );
    }

    if (IsWindow(ghRpcssWnd))
    {
        // set timer for checking ping thread
        UINT ui = SetTimer(ghRpcssWnd, 1234, BaseTimeoutInterval * 1000, NULL);

        if (ui > 0)
        {
            dwResult = RPC_S_OK;
        }
    }

    return dwResult;
}

RPC_STATUS
StartPingThread()
{
    ghPingThread = CreateThread(
                              NULL, 0,
			                  (LPTHREAD_START_ROUTINE)PingThread,
			                  NULL, 0, &gdwThrdId);



    if (NULL == ghPingThread)
    {
        ComDebOut((DEB_ERROR,"Creation of Pinging Thread Failed With Error=%d",
                             GetLastError()));
        return(RPC_S_INTERNAL_ERROR);
    }
    else
    {
        fPingThreadStarted = TRUE;
    }

    return RPC_S_OK;
}


DWORD  __declspec(dllexport) I_RemoteMain(
    )
/*++

Routine Description:

    Main entry point for RPCSS on Win9x.

Arguments:

    None

Return Value:

    None

--*/
{
    DWORD DcomStatus = RPC_S_INTERNAL_ERROR, 
          EndpointMapperStatus = RPC_S_INTERNAL_ERROR,
          MqStatus = RPC_S_INTERNAL_ERROR,
          RpcssServiceStatus = RPC_S_INTERNAL_ERROR;

    // Register Authentication Info -- this should be done first before
    // starting the resolver so that the resolver's security initialization
    // is done with this info available

	// see .\bridge.cxx for implementation

	// CODEWORK: needs generalization -- probably by eliminating parameter
	// Actually, this needs to be integrated into Connect again

    // we don't care much about the status returned -- bash on regardless
    RegisterAuthInfoIfNecessary(RPC_C_AUTHN_WINNT);

    // Register RPCSS as a Win95 service so it will not shut down
    // when the user logs off.  This routime will also call InitRpcssWindow
    // to register a window class and create a window to receive the logoff message

    // This is mainly needed for the MQ Service started below, but we do the registration here
    // since we will shut down naturally if DCOM or the EP mapper does not start properly

    BOOL fGoodStart = StartWin95Service();
    ASSERT(fGoodStart);  // this ought not to fail

    if (fGoodStart)
    {
        RpcssServiceStatus = RPC_S_OK;
    }

    // initialize the RPCSS window -- this must succeed for RPCSS 
    // to be useful to DCOM, and must be done before starting resolver      
    // The window should be destroyed if DCOM fails to start properly
    DcomStatus = InitRpcssWindow();

    // .\bridge.cxx
    // start the resolver before starting EP mapper so we only get DCOM protocols
    // in the resolver's bindings
    if (DcomStatus == ERROR_SUCCESS)
    {
        DcomStatus = StartObjectExporter();
    }

    // Start OLESCM
    if (DcomStatus == ERROR_SUCCESS)
    {
        // ..\..\..\olescm\scmsvc.cxx
        DcomStatus = CheckAndStartSCM();
    }

    // we register the remote activation interface here because
    // Win95's SCM startup does not do it, unlike NT
    if (DcomStatus == ERROR_SUCCESS)
    {
        DcomStatus = RpcServerRegisterIf(_IActivation_ServerIfHandle, 0, 0);
    }

    // Start endpoint mapper -- this is independent of DcomStatus
    MqStatus = EndpointMapperStatus = StartEndpointMapper();

    // Start MQ Manager Interface
    if (EndpointMapperStatus == ERROR_SUCCESS)
    {
        // MSMQ depends on the endpoint mapper
        MqStatus = StartMqManagement();
    }


    // Start listening for RPC requests -- we start whether or not
    // the resolver and SCM started successfully.  This is to avoid
    // failing in situations like: EnableDCOM=Y but Access Control
    // is set to share level.  This makes DCOM unusable but not RPC.
    if (EndpointMapperStatus == ERROR_SUCCESS)
    {
        // Always listen to local protocols.
        // If this fails, the EP Mapper service should fail,
        // and RPCSS isn't much use for DCOM either.

        EndpointMapperStatus = UseProtseqIfNecessary(ID_LPC);

        if (EndpointMapperStatus != RPC_S_OK)
        {
            return(EndpointMapperStatus);
        }

        EndpointMapperStatus = UseProtseqIfNecessary(ID_WMSG);

        if (EndpointMapperStatus != RPC_S_OK)
        {
            return(EndpointMapperStatus);
        }
        else // need special listen for WMSG
        {
            I_RpcServerStartListening(NULL);
        }

        EndpointMapperStatus = RpcServerListen(1, 1234, TRUE);
    }

    if (DcomStatus == ERROR_SUCCESS)  // resolver/scm started properly
    {
        // start pinging service
        DcomStatus = StartPingThread();    
    }

    if (DcomStatus == ERROR_SUCCESS)
    {
    // We initialized outselves successfully.  We can now signal to all 
    // interested OLE processes that new values of gpLocalResolver and
    // the security packages

        ghSyncEvent = CreateEventA(
                            NULL,       // no security
                            TRUE,       // stays signalled
                            FALSE,      // initially, not signalled
                            RPCSS_SYNC_EVENT
                            );
         
        if (ghSyncEvent == NULL) 
        {
            DcomStatus = GetLastError();

            ComDebOut((DEB_ERROR,
                       "Failed Creating RPCSS Sync Event, GetLastError()=%d\n", 
                       DcomStatus));
        }
        else
        {
            BOOL fResult = SetEvent(ghSyncEvent);

            if (fResult == FALSE)
            {
                DcomStatus = GetLastError();

                ComDebOut((DEB_ERROR,
                           "Failed Signalling RPCSS Sync Event, GetLastError()=%d\n", 
                           DcomStatus));
            }
        }
    }

    if (EndpointMapperStatus != ERROR_SUCCESS ||
        DcomStatus != ERROR_SUCCESS ||
        MqStatus != ERROR_SUCCESS ||
        RpcssServiceStatus != ERROR_SUCCESS)
    {
        ComDebOut((DEB_OXID,"RPCSS startup failed\n"));
        ComDebOut((DEB_OXID,"EndpointMapperStatus = %08x\n", EndpointMapperStatus)); 
        ComDebOut((DEB_OXID,"DcomStatus = %08x\n", DcomStatus));
        ComDebOut((DEB_OXID,"MqStatus = %08x\n", MqStatus));
        ComDebOut((DEB_OXID,"RpcssServiceStatus = %08x\n", RpcssServiceStatus));
    }

    if (DcomStatus == ERROR_SUCCESS)
    {
        // we need the message loop for the RPCSS window
        MSG Msg;

        while (GetMessage(&Msg, NULL, 0, 0))
        {
            TranslateMessage(&Msg);
            DispatchMessage(&Msg);
        }
    }
    else if (EndpointMapperStatus == ERROR_SUCCESS)
    {
        // All we have is the EP mapper, so just wait after we
        // destroy the RPCSS window if it was successfully created
        if (IsWindow(ghRpcssWnd))
        {
            DestroyWindow(ghRpcssWnd);
            ghRpcssWnd = NULL;
        }

        EndpointMapperStatus = RpcMgmtWaitServerListen();
    }


    return EndpointMapperStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\olescm\activate.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  activate.cxx
//
//  Main dcom activation service routines.
//
//  History:                VinayKr     Created
//              06-Nov-98   TarunA      Changed remote/local activation logic
//
//--------------------------------------------------------------------------

#include "act.hxx"

HRESULT GetProcessInfoFromActProps(IActivationPropertiesIn* pActPropsIn, DWORD* ppid, DWORD* pdwProcessReqType);
LPWSTR GetOrigSrvrName( PACTIVATION_PARAMS pActParams );

// Global counter
LONG gThreadToken = 0;

//-------------------------------------------------------------------------
//
// Activation
//
// Main entry point for both local and remote activations.
//
//-------------------------------------------------------------------------
HRESULT
Activation(
    IN OUT PACTIVATION_PARAMS pActParams
    )
{
    CServerTableEntry*  pServerTableEntry = NULL;
    CClsidData*         pClsidData = NULL;
    CServerListEntry*   pServerListEntry;
    HANDLE              hLaunchMutex = 0;
    HRESULT             hr;
    RPC_STATUS          Status;
    BOOL                bStatus;
    BOOL                bFirstTime = TRUE;
	CToken*             pTkn;

    //  NT #294385
    //  If REMOTE_SERVER is set, and LOCAL_SERVER is not,
    //  and we have a server name, and the server name is us,
    //  then we need to turn the LOCAL_SERVER flag on
    
    if ( (CLSCTX_REMOTE_SERVER == (pActParams->ClsContext & ( CLSCTX_REMOTE_SERVER | CLSCTX_LOCAL_SERVER ))) &&
            pActParams->pwszServer != NULL &&
            gpMachineName->Compare (pActParams->pwszServer) )
    {
        pActParams->ClsContext |= CLSCTX_LOCAL_SERVER;
    }
    
#ifdef SECURITY_DBG
    {
        WCHAR dbgwszUser[MAX_PATH];
        if ( pActParams->pToken != NULL )
        {
            pActParams->pToken->Impersonate();
            ULONG cchSize = MAX_PATH;
            GetUserName( dbgwszUser, &cchSize );
            pActParams->pToken->Revert();
        }
        else
        {
            lstrcpyW( dbgwszUser, L"Anonymous" );
        }
    }
#endif
        
    if ( pActParams->pwszServer )
    {
        //
        // Some apps may unnecessarily put slashes before their
        // server names.  We'll allow this and strip them off.
        //
        if ( pActParams->pwszServer[0] == L'\\' &&
            pActParams->pwszServer[1] == L'\\' )
            pActParams->pwszServer += 2;
        
        if ( 0 == *pActParams->pwszServer )
        {
            hr = CO_E_BAD_SERVER_NAME;
            goto ActivationDone;
        }
        
        if ( ! gpMachineName->Compare( pActParams->pwszServer ) )
        {
            //
            // When a client specifies a remote server name we go straight to the
            // source, there is no need to check local configuration information.
            //
            // The CLSCTX_REMOTE_SERVER bit does not need to be specified by the
            // client, it is implied.
            //
            
            //
            // the remote activation call will null out the pointer in the ActivationPropertiesIn
            // object which caused the memory that pActParams->pwszServer is pointing to to be
            // freed.  We need this name later on to pass to the oxid resoluton phase, so
            // we copy it to some memory on the stack
            //
            
            WCHAR *pszTemp = (WCHAR *)_alloca( ( lstrlenW(pActParams->pwszServer) + 1 ) * sizeof(WCHAR) );
            lstrcpyW(pszTemp, pActParams->pwszServer);
            hr = RemoteActivationCall( pActParams, pActParams->pwszServer );
            pActParams->pwszServer = pszTemp;
            
            goto ActivationDone;
        }
    }
    
    //
    // First search for a running object.
    //
    if ( pActParams->pwszPath )
    {
        //
        // This call returns TRUE if we found a ROT object and are now done.
        // When handling a remote activation it's possible we'll find a ROT
        // object, but we still need to continue in this case to get a remote
        // marshalled interface.
        //
        if ( LookupObjectInROT( pActParams, &hr ) )
            goto ActivationDone;
    }
    
	//
	//  Try to get a CClsidData using the supplied pComClassInfo 
	// 
    pTkn =  pActParams->RemoteActivation ? NULL : pActParams->pToken;

    hr = LookupClsidData( pActParams->Clsid,
                          pActParams->pComClassInfo,
                          pTkn,
                          LOAD_NORMAL,
                          &pClsidData );   
    if (hr == REGDB_E_CLASSNOTREG)
    {
        ASSERT(!pClsidData);
        
        // No registration info for this clsid.   If the client is interested
		// in a local server activation, we still need to check the class 
        // table in case of unsolicited registrations.   For COM+ components 
        // we should never get here.
		if(pActParams->ClsContext & CLSCTX_LOCAL_SERVER)
		{
			pServerTableEntry = gpClassTable->Lookup(pActParams->Clsid);
			if (pServerTableEntry)
			{
				// Somebody on the machine registered a classfac for this
				// clsid; give it a shot:
				bStatus = pServerTableEntry->CallRunningServer( pActParams,
																0,
																0,
                                                                NULL,
																&hr);
				if (bStatus)
					goto ActivationDone;
			}
		}
		
        //
        // As a last resort we always try an atstorage activation.
        //
        ActivateAtStorage( pActParams, NULL, &hr );
        goto ActivationDone;
    }
    else if (FAILED(hr))
        goto ActivationDone;
        
    Win4Assert(pClsidData && "Registration lookup succeeded but returned nothing");

    // Look up an appropriate table entry if the client is interested in a
    // local activation
    if(pActParams->ClsContext & CLSCTX_LOCAL_SERVER)
    {
        if (pClsidData->DllHostOrComPlusProcess())
        {
            GUID* pAppidGuid = pClsidData->AppidGuid();
            ASSERT(pAppidGuid);
            pServerTableEntry = gpProcessTable->Lookup(*pAppidGuid);
        }
        else
            pServerTableEntry = gpClassTable->Lookup( pActParams->Clsid );
    }

    if ( !pServerTableEntry )
    {
        // At this point we have the class data but no running servers. If the 
        // client wants remote activation only then go straight to do a remote activation
        // NOTE We '&' with flags CLSCTX_REMOTE_SERVER | CLSCTX_LOCAL_SERVER to
        // filter out any other bits like CLSCTX_INPROC etc        
        if( (pActParams->ClsContext & (CLSCTX_REMOTE_SERVER | CLSCTX_LOCAL_SERVER)) == CLSCTX_REMOTE_SERVER)
        {
            // This call returns TRUE if a remote ActivateAtStorage call was
            // made, whether successful or not.
            if ( ActivateAtStorage( pActParams, pClsidData, &hr ) )
                goto ActivationDone;
            else
                goto ActivationDoneLocal;
        }
        
        // Figure out which table to create the table entry in
        if (pClsidData->DllHostOrComPlusProcess())
        {
            GUID* pAppidGuid = pClsidData->AppidGuid();
            ASSERT(pAppidGuid);
            pServerTableEntry = gpProcessTable->Create(*pAppidGuid);
        }
        else
            pServerTableEntry = gpClassTable->Create(pActParams->Clsid);
                        
        if (!pServerTableEntry)
        {
            hr = E_OUTOFMEMORY;
            goto ActivationDone;
        }
    }
    
    Win4Assert(pServerTableEntry);
    
    hr = GetProcessInfoFromActProps(pActParams->pActPropsIn, &(pActParams->dwPID), &(pActParams->dwProcessReqType));
    if (FAILED(hr))
        goto ActivationDone;
    
    for (;;)
    {        
        //
        // Now check for a running server for the CLSID
        // NOTE: The fact that we reached here implies that the client wants at least a
        // local activation
        //
        CairoleDebugOut((DEB_SCM, "Calling ServerTableEntry at 0x%p\n", pServerTableEntry));
                
        // We reach here only when we are interested in at least a local activation
        Win4Assert(pActParams->ClsContext & CLSCTX_LOCAL_SERVER);
        
        // We always try to use an existing running server, unless a custom 
        // activator has told us specifically to create a new server.
        if (pActParams->dwProcessReqType != PRT_CREATE_NEW)
        {
            bStatus = pServerTableEntry->CallRunningServer( pActParams,
                                                            0,
                                                            0,
                                                            pClsidData,
                                                            &hr);            
            if ( bStatus )
                goto ActivationDone;
            else
            {
                if (pActParams->dwProcessReqType == PRT_USE_THIS_ONLY)
                {
                    // A custom activator specified a specific server which was not 
                    // found.  No need to continue further.
                    hr = E_UNEXPECTED;   // REVIEW for better error code! 
                    goto ActivationDone;
                }
                else if(pActParams->dwProcessReqType == PRT_USE_THIS)
                {
                    // A custom activator hinted at a specific process, which was not
                    // found.  Eg, the process in question was killed, died, etc.  Although
                    // this should not happen much in the normal case, it would be nice if 
                    // we could somehow save the client from getting an error.   So what we
                    // do is re-try the activation using any compatible server.   If it works
                    // great, if not then we're done (we won't start a new server).
                    
                    // note we're only resetting the pertinent flags in the actparams struct,
                    // not the actprops object, but everybody downstream from here only looks 
                    // at the actparams so this is okay.
                    pActParams->dwProcessReqType = PRT_IGNORE;
                    pActParams->dwPID = 0;
                    bStatus = pServerTableEntry->CallRunningServer( pActParams,
                                                                    0,
                                                                    0,
                                                                    pClsidData,
                                                                    &hr);
                    goto ActivationDone;
                }
                // else { keep going }
            }
        }
        
        if (bFirstTime)
        {
            bFirstTime = FALSE;

            //
            //  Try to do at-storage first
            //
            if (ActivateAtStorage(pActParams, pClsidData, &hr))
                goto ActivationDone;

            // Try a remote activation if
            // (1a) Class is configured to be activated remotely
            // AND
            // (1b) Client will accept a remote activation
            // OR
            // (2)SERVERTYPE_NONE
            if( (((pClsidData->GetAcceptableContext() & (CLSCTX_REMOTE_SERVER | CLSCTX_LOCAL_SERVER)) == CLSCTX_REMOTE_SERVER)
                    &&
                    (pActParams->ClsContext & CLSCTX_REMOTE_SERVER)) 
                    ||
                    (pClsidData->ServerType() == SERVERTYPE_NONE) )
                goto ActivationDoneLocal;      
        }
        
        if ( ! hLaunchMutex )
        {
            hLaunchMutex = pClsidData->ServerLaunchMutex();
            
            if (!hLaunchMutex)
            {
                hr = E_UNEXPECTED;
                goto ActivationDone;
            }
        }
        else
            WaitForSingleObject( hLaunchMutex, INFINITE );
        
		// At this point we now hold the launch mutex

        //  If we've been told explicitly to launch a new server process, then
        //  there's no reason to check for one already running.
        if (pActParams->dwProcessReqType != PRT_CREATE_NEW)
        {
            // If server exists, release launch mutex and try
            // to call server
            BOOL fExists;
            hr = pServerTableEntry->ServerExists(pActParams, &fExists);
            if (hr != S_OK)
            {
                ReleaseMutex( hLaunchMutex );
                goto ActivationDone;
            }
            
            if (fExists)
            {
                ReleaseMutex( hLaunchMutex );
                continue;
            }
        }
        
        ASSERT(pActParams->dwProcessReqType == PRT_IGNORE ||
               pActParams->dwProcessReqType == PRT_CREATE_NEW);
        
        RpcTryExcept
        {
            LONG lLaunchThreadToken;
            //
            // This returns when the server has registered the requested CLSID or
            // we give up.
            //
            CairoleDebugOut((DEB_SCM, "Starting ServerTableEntry at 0x%p\n", pServerTableEntry));
                        
            // Grab a non-zero token for the launch that we will
            // use to associate the server with on the call
            do {
                lLaunchThreadToken = InterlockedIncrement(&gThreadToken);
            }
            while (lLaunchThreadToken == 0);
            
            // Use the token to launch
            // Note that StartServerAndWait could reset the token
            // to zero in some cases.
            hr = pServerTableEntry->StartServerAndWait( pActParams,
                                                        pClsidData,
                                                        lLaunchThreadToken);
            
            // Now call the server with the LaunchMutex held but
            // with the threadtoken to guarantee first access to
            // the class in the server we launched. This takes
            // care of SINGLEUSE as well as transient error cases.
            if (SUCCEEDED(hr))
            {
                // NOTE:    if the server we just launched was an "extra" one (ie, on 
                // behalf of some custom activator), it's not guaranteed that this
                // activation will use the just-launched server.  It may get an old one.
                bStatus = pServerTableEntry->CallRunningServer(pActParams,
                                                               0,
                                                               lLaunchThreadToken,
                                                               pClsidData,
                                                               &hr);        
                if (!bStatus)
                    hr = CO_E_SERVER_EXEC_FAILURE;
            }
        }    
        RpcExcept(TRUE)
        {
            Win4Assert(NULL && "Unexpected exception thrown");
            Status = RpcExceptionCode();
            hr = HRESULT_FROM_WIN32(Status);
        }   
        RpcEndExcept
            
        ReleaseMutex( hLaunchMutex );
        
        break;
        
    }// end for(;;)
    
    goto ActivationDone;
    
ActivationDoneLocal:
    
    hr = REGDB_E_CLASSNOTREG;
    
    //
    // Server name will only be non-null if its our machine name.
    //
    if ( !pActParams->pwszServer &&
         pClsidData->RemoteServerNames() )
    {
        //
        // the remote activation call will null out the pointer in the ActivationPropertiesIn
        // object which caused the memory that pActParams->pwszServer is pointing to to be
        // freed.  We need this name later on to pass to the oxid resoluton phase, so
        // we copy it to some memory on the stack
        //
        // We don't care here since pActParams->pwszServer==NULL if we are here.
        
        if (!ActivateRemote( pActParams, pClsidData, &hr ))
        {
            hr = (CLSCTX_REMOTE_SERVER == pActParams->ClsContext) ?
                    CO_E_CANT_REMOTE : REGDB_E_CLASSNOTREG;
        }
    }
    
ActivationDone:
    
    if (hLaunchMutex)
        CloseHandle( hLaunchMutex );
    
    // Registry data is not cached in any way.
    if ( pClsidData )
        delete pClsidData;
    
    if ( pServerTableEntry )
        pServerTableEntry->Release();
    
    // Don't need to resolve if we're return an inproc server.
    if ( (S_OK == hr) && ! *pActParams->ppwszDllServer )
        hr = ResolveORInfo( pActParams);
    
    return hr;
}

//-------------------------------------------------------------------------
//
// ResolveORInfo
//
// On the server side of a remote activation, gets the OXID in the
// marshalled interface pointer.
//
// For a client side activation (local or remote), calls revolve OXID.
//
//-------------------------------------------------------------------------
HRESULT
ResolveORInfo(
    IN OUT PACTIVATION_PARAMS   pActParams
    )
{
    MInterfacePointer *     pIFD;
    OBJREF *                pObjRef;
    STDOBJREF *             pStdObjRef;
    DUALSTRINGARRAY *       pORBindings;
    DWORD                   DataSize;
    RPC_STATUS              sc;
    DWORD                   n;
    BOOL                    ActivatedRemote = pActParams->activatedRemote;

    // Don't resolve if we are servicing a remote activation and
    // we also did a remote activation(i.e LB router)
    if (pActParams->RemoteActivation && ActivatedRemote)
        return S_OK;

    //
    // This routine probes the interface data returned from the server's
    // OLE during a successfull activation, but we're still going to
    // protect ourself from bogus data.
    //

    if (pActParams->pActPropsOut)
    {
        HRESULT hr;
        pActParams->pIIDs = 0;
        pActParams->pResults = 0;
        pActParams->ppIFD = 0;
        hr = pActParams->pActPropsOut->GetMarshalledResults(&pActParams->Interfaces,
                                                            &pActParams->pIIDs,
                                                            &pActParams->pResults,
                                                            &pActParams->ppIFD);
        if (hr != S_OK)
            return hr;
    }

    pIFD = 0;
    for ( n = 0; n < pActParams->Interfaces; n++ )
    {
        pIFD = pActParams->ppIFD[n];
        if ( pIFD )
            break;
    }

    Win4Assert( pIFD );

    if ( pIFD->ulCntData < 2*sizeof(ULONG) )
    {
        Win4Assert( !"Bad interface data returned from server" );
        return S_OK;
    }

    pObjRef = (OBJREF *)pIFD->abData;

    if ( (pObjRef->signature != OBJREF_SIGNATURE) ||
         (pObjRef->flags & ~(OBJREF_STANDARD | OBJREF_HANDLER |
                             OBJREF_CUSTOM | OBJREF_EXTENDED)) ||
         (pObjRef->flags == 0) )
    {
        Win4Assert( !"Bad interface data returned from server" );
        return S_OK;
    }

    // No OR info sent back for custom marshalled interfaces.
    if ( pObjRef->flags == OBJREF_CUSTOM )
        return S_OK;

    DataSize = 2*sizeof(ULONG) + sizeof(GUID);
    pStdObjRef = (STDOBJREF *)(pIFD->abData + DataSize);

    DataSize += sizeof(STDOBJREF);
    if ( pObjRef->flags == OBJREF_HANDLER )
        DataSize += sizeof(CLSID);
    else if( pObjRef->flags == OBJREF_EXTENDED)
        DataSize += sizeof(DWORD);

    pORBindings = (DUALSTRINGARRAY *)(pIFD->abData + DataSize);
    DataSize += 2 * sizeof(USHORT);

    if ( pIFD->ulCntData < DataSize )
    {
        Win4Assert( !"Bad interface data returned from server" );
        return S_OK;
    }

    // If we activated the server on this machine, we need the OXID of the server.
    if ( ! ActivatedRemote )
        *pActParams->pOxidServer = *((OXID UNALIGNED *)&pStdObjRef->oxid);

    //
    // If we're servicing a remote activation, all we need is the server's OXID.
    // The client will call ResolveClientOXID from its ResolveORInfo.
    //
    if ( pActParams->RemoteActivation )
        return S_OK;

    DataSize += pORBindings->wNumEntries * sizeof(USHORT);

    if ( (pIFD->ulCntData < DataSize) ||
         (pORBindings->wNumEntries != 0 &&
         (pORBindings->wSecurityOffset >= pORBindings->wNumEntries)) )
    {
        Win4Assert( !"Bad interface data returned from server" );
        return S_OK;
    }

    //
    // If empty OR bindings were supplied then the server and client are
    // both local to this machine, so use the local OR bindings.
    //
    if (pORBindings->wNumEntries == 0)
    {
        sc = CopyMyOrBindings(pActParams->ppServerORBindings, NULL);
        if (sc != RPC_S_OK)
            return HRESULT_FROM_WIN32(sc);
    }
    else
    {
#if 0 // #ifdef _CHICAGO_
        if (pORBindings->wNumEntries == 0)
            pORBindings = gpLocalDSA;
#endif // _CHICAGO_

        //
        // This was a local activation so use our string bindings for the OR
        // binding string.
        //
        *pActParams->ppServerORBindings = (DUALSTRINGARRAY *)
                MIDL_user_allocate( sizeof(DUALSTRINGARRAY) +
                                    pORBindings->wNumEntries*sizeof(USHORT) );

        if ( ! *pActParams->ppServerORBindings )
            return E_OUTOFMEMORY;

        dsaCopy( *pActParams->ppServerORBindings, pORBindings );
    }

    //
    // If we did a remote activation then we already have the server's OXID and
    // OR string bindings from the RemoteActivation call and pieces of the OXID
    // info have been filled in.
    //

    // Could we optimize this at all for the local case?

#if 0 // #ifdef _CHICAGO_
    sc = ScmResolveClientOXID(
                              *pActParams->pOxidServer,
                              *pActParams->ppServerORBindings,
                              pActParams->Apartment,
                              pActParams->ProtseqId,
                              *pActParams->pOxidInfo,
                              *pActParams->pLocalMidOfRemote
                              );
#else
    USHORT usAuthnSvc;
    sc = ResolveClientOXID( pActParams->hRpc,
                            (PVOID)pActParams->pProcess,
                            pActParams->pOxidServer,
                            *pActParams->ppServerORBindings,
                            pActParams->Apartment,
                            pActParams->ProtseqId,
                            pActParams->pwszServer,
                            pActParams->pOxidInfo,
                            pActParams->pLocalMidOfRemote,
                            pActParams->UnsecureActivation,
                            pActParams->AuthnSvc,
                            &pActParams->IsLocalOxid,
                            &usAuthnSvc);
#endif

    return HRESULT_FROM_WIN32(sc);
}

//-------------------------------------------------------------------------
//
// ActivateAtStorage
//
// If the given CLSID is marked with ActivateAtStorage, do a remote
// activation to the machine where the path points.
//
// Returns TRUE if a remote activation was tried or a wierd error was
// encoutered.  Returns FALSE if the CLSID is not marked with
// ActivateAtStorage or the file path is determined to be local.
//
//-------------------------------------------------------------------------
BOOL
ActivateAtStorage(
    IN OUT ACTIVATION_PARAMS *  pActParams,
    IN  CClsidData *            pClsidData,
    OUT HRESULT *               phr
    )
{
    //
    // See if we need to do a remote ActivateAtStorage activation.  If
    // a server name is given, then we either made a remote activation
    // already or the server name is for the local machine in which case
    // ActivateAtStorage is ignored.
    LPWSTR              pwszOrigSrvrName=NULL;
    pwszOrigSrvrName = GetOrigSrvrName(pActParams);

    if ( pActParams->RemoteActivation ||
         pActParams->pwszServer ||
         pwszOrigSrvrName ||
         !pActParams->pwszPath )
        return FALSE;

    // Note that if we have no information at all for a CLSID, we try a
    // atstorage activation.  Part of initial dcom spec.
    //
    if ( pClsidData && ! pClsidData->ActivateAtStorage() )
        return FALSE;


    HRESULT hr;
    WCHAR   wszMachineName[MAX_COMPUTERNAME_LENGTH+1];

    //

#ifdef DFSACTIVATION
    //
    // This is for DFS support.  If the file hasn't been opened yet, we must
    // open it before trying to resolve the DFS pathname in GetMachineName.
    // This is just how DFS works.  FindFirstFile results in the fewest number
    // of network packets.
    //
    if ( ! pActParams->FileWasOpened )
    {
        HANDLE          hFile;
        WIN32_FIND_DATA Data;

        if (pActParams->pToken != NULL)
            pActParams->pToken->Impersonate();

        hFile = FindFirstFile( pActParams->pwszPath, &Data );

        if ( hFile != INVALID_HANDLE_VALUE )
            (void) FindClose( hFile );

        if (pActParams->pToken != NULL)
            pActParams->pToken->Revert();

        if ( INVALID_HANDLE_VALUE == hFile )
        {
            *phr = CO_E_BAD_PATH;
            return TRUE;
        }
    }
#endif

    hr = GetMachineName(
                pActParams->pwszPath,
                wszMachineName
#ifdef DFSACTIVATION
                ,TRUE
#endif
                );

    if ( hr == S_FALSE )
    {
        // We couldn't get the machine name, path must be local.
        return FALSE;
    }
    else if ( hr != S_OK )
    {
        // We got an error while trying to find the UNC machine name.
        *phr = hr;
        return TRUE;
    }

    if ( gpMachineName->Compare( wszMachineName ) )
        return FALSE;

    *phr = RemoteActivationCall( pActParams, wszMachineName );

    return TRUE;
}

//-------------------------------------------------------------------------
//
// ActivateRemote
//
// Does a remote activation based off of the RemoteServerName registry key
// for the given CLSID.
//
// Returns TRUE if a remote activation was tried, FALSE if not.
//
//-------------------------------------------------------------------------
BOOL
ActivateRemote(
    IN OUT ACTIVATION_PARAMS *  pActParams,
    IN  CClsidData *            pClsidData,
    OUT HRESULT *               phr
    )
{
    WCHAR * pwszServerName;
    BOOL    bBadServerName;
    BOOL    bMyServerName;

    *phr = S_OK;

    //
    // The CClsidData class puts the remote server name(s) into a REG_MULTI_SZ
    // format.
    //
    pwszServerName = pClsidData->RemoteServerNames();

    // jsimmons 3/11/00 prefix bug fix.    We would crash below if RemoteServerNames
    // returned NULL (which is possible).   The only caller of this function checks 
    // that before calling us, though.   However, it doesn't hurt to make sure.
    if (!pwszServerName)
    {
        ASSERT(0);
        *phr = E_UNEXPECTED;
        return FALSE;
    }

    bBadServerName = TRUE;
    bMyServerName = TRUE;

    for ( ; *pwszServerName; pwszServerName += lstrlenW(pwszServerName) + 1 )
    {
        if ( pwszServerName[0] == L'\\' && pwszServerName[1] == L'\\' )
            pwszServerName += 2;

        while ( *pwszServerName &&
                (*pwszServerName == L' ' || *pwszServerName == L'\t') )
            pwszServerName++;

        if ( pwszServerName[0] == L'\0' )
            continue;

        bBadServerName = FALSE;

        if ( gpMachineName->Compare( pwszServerName ) )
            continue;

        bMyServerName = FALSE;

        *phr = RemoteActivationCall( pActParams, pwszServerName );

        if ( S_OK == *phr )
            break;
    }

    if ( bBadServerName || bMyServerName )
        return FALSE;

    return TRUE;
}

//-------------------------------------------------------------------------
//
// CheckLocalCall
//
// Verifies that the handle for our current call is for a local transport.
// Raises an exception if it's not.
//
//-------------------------------------------------------------------------
void
CheckLocalCall(
    IN  handle_t hRpc
    )
{
#if 1 // #ifndef _CHICAGO_
    UINT    Type;

    if ( (I_RpcBindingInqTransportType( hRpc, &Type) != RPC_S_OK) ||
         ((Type != TRANSPORT_TYPE_LPC) && (Type != TRANSPORT_TYPE_WMSG)) )
        RpcRaiseException( ERROR_ACCESS_DENIED );
#endif

    //
    // We probably want to enable this on Chicago now too.
    //
}

//-------------------------------------------------------------------------
//
// LookupObjectInROT
//
// Looks for an object (file path in this activation) in the Running Object
// Table.
//
// Returns TRUE if we found the object in the ROT and can pass its
// marshalled interface pointer directly back to the client.
//
//-------------------------------------------------------------------------
BOOL
LookupObjectInROT(
    IN  PACTIVATION_PARAMS  pActParams,
    OUT HRESULT *           phr )
{
    SCMREGKEY   Key;
    MNKEQBUF *  pMnkEqBuf;
    BYTE        Buffer[sizeof(DWORD)+ROT_COMPARE_MAX];

    pMnkEqBuf = (MNKEQBUF *) Buffer;

    *phr = CreateFileMonikerComparisonBuffer(
            pActParams->pwszPath,
            &pMnkEqBuf->abEqData[0],
            ROT_COMPARE_MAX,
            &pMnkEqBuf->cdwSize );

    if ( *phr != S_OK )
        return FALSE;

    *phr = gpscmrot->GetObject(
            pActParams->pToken,
            pActParams->pProcess ? pActParams->pProcess->WinstaDesktop() : NULL,
            0,
            pMnkEqBuf,
            &Key,
            (InterfaceData **)&pActParams->pIFDROT );

    if ( *phr != S_OK )
        return FALSE;

    //
    // If our activation call is from a local client and for a single
    // interface then we can return success.  Otherwise we return failure
    // because we must call the server either to get more interface
    // pointers or because we are servicing a remote activation and must get
    // a normal marshalled interface pointer rather than the table marshalled
    // interface pointer sitting in the ROT.
    //
    if ( ! pActParams->RemoteActivation && (1 == pActParams->Interfaces) )
    {
        // Return the marshaled interface from the ROT to the caller.
        pActParams->ppIFD = (MInterfacePointer **)
                                MIDL_user_allocate(sizeof(MInterfacePointer *));
        pActParams->pResults = (HRESULT*) MIDL_user_allocate(sizeof(HRESULT));

        if ((pActParams->ppIFD==NULL) || (pActParams->pResults==NULL))
        {
            MIDL_user_free(pActParams->ppIFD);
            MIDL_user_free(pActParams->pResults);
            *phr = E_OUTOFMEMORY;
            return FALSE;
        }

        *pActParams->ppIFD = pActParams->pIFDROT;
        pActParams->pResults[0] = S_OK;

        // So we remember not to clean up the buffer
        pActParams->pIFDROT = NULL;

        // Let caller know that we got this from the ROT so
        // if it doesn't work they should try again.
        pActParams->FoundInROT = TRUE;
        *pActParams->pFoundInROT = TRUE;

        return TRUE;
    }

    //
    // REVIEW REVIEW.  Can we return success if the ROT object was marshalled
    // strong?  Do we really have to call the server if the object was
    // marshalled weak?  Is the resulting race condition any worse then for a
    // normal activation?
    //

    //
    // We can't use a tabled marshalled interface pointer to send back to a
    // remote client, so we return failure here, but keep the ROT interface
    // data in pIFDROT.
    //

    return FALSE;
}


//+---------------------------------------------------------------------------
//
// Get the COSERVERINFO supplied by the client.  We'll use this to decide
// whether we want to do remote ActivateAtStorage.
//
//+---------------------------------------------------------------------------
LPWSTR GetOrigSrvrName(
    PACTIVATION_PARAMS pActParams
    )
{
    LPWSTR pwszOrigSrvrName = NULL;

    if (pActParams->pActPropsIn)
    {
        SecurityInfo* pLegacyInfo = pActParams->pActPropsIn->GetSecurityInfo();
        if (pLegacyInfo)
        {
            COSERVERINFO* pServerInfo = NULL;
            pLegacyInfo->GetCOSERVERINFO(&pServerInfo);
            if (pServerInfo)
            {
                pwszOrigSrvrName = pServerInfo->pwszName;
            }
        }
    }

    return pwszOrigSrvrName;
}


//
//  Helper function.    ppid and pdwProcessReqType may be NULL if caller does not care about them.
// 
HRESULT GetProcessInfoFromActProps(IActivationPropertiesIn* pActPropsIn, DWORD* ppid, DWORD* pdwProcessReqType)
{
  HRESULT hr = E_INVALIDARG;

  ASSERT(pActPropsIn);

  if (pActPropsIn != NULL)
  {
    IServerLocationInfo *pSLInfo = NULL;

    hr = pActPropsIn->QueryInterface(IID_IServerLocationInfo, (void**) &pSLInfo);
    ASSERT(SUCCEEDED(hr) && pSLInfo);
    if (SUCCEEDED(hr) && pSLInfo != NULL)
    {
      DWORD dwPRT;
      DWORD dwPid;
      hr = pSLInfo->GetProcess(&dwPid, &dwPRT);
      ASSERT(SUCCEEDED(hr));
      ASSERT(dwPRT == PRT_IGNORE ||
             dwPRT == PRT_CREATE_NEW || 
             dwPRT == PRT_USE_THIS ||
             dwPRT == PRT_USE_THIS_ONLY);
      if (SUCCEEDED(hr))
      {
        if (ppid)
          *ppid = dwPid;

        if (pdwProcessReqType)
          *pdwProcessReqType = dwPRT;
      }
      pSLInfo->Release();
      pSLInfo = NULL;
    }
  }
  return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\olescm\addrrefresh.cxx ===
//+-------------------------------------------------------------------
//
//  File:       addrrefresh.cxx
//
//  Contents:   Implements classes for handling dynamic TCP/IP address
//              changes
//
//  Classes:    CAddrRefreshMgr
//
//  History:    26-Oct-00   jsimmons      Created
//
//--------------------------------------------------------------------

#include "act.hxx"

// The single instance of this object
CAddrRefreshMgr gAddrRefreshMgr;

// Constructor
CAddrRefreshMgr::CAddrRefreshMgr() :
	_hEventIPAddressChange(NULL),
	_hWaitObject(NULL),
	_IPChangeNotificationSocket(INVALID_SOCKET),
	_bWaitRegistered(FALSE),
	_bListenedOnTCP(FALSE),
	_bRegisteredForNotifications(FALSE)
{
	ZeroMemory(&_WSAOverlapped, sizeof(_WSAOverlapped));
}

// 
//  RegisterForAddressChanges
//
//  Method to tell us to register with the network
//  stack to be notified of address changes.  This is
//  a best-effort, if it fails we simply return; if
//  that happens, DCOM will not handle dynamic address
//  changes.  Once this method succeeds, calling it
//  is a no-op until an address change notification
//  is signalled.
//
//  Caller must be holding gpClientLock.
//
void CAddrRefreshMgr::RegisterForAddressChanges()
{
	ASSERT(gpClientLock->HeldExclusive());
	
	// If we haven't yet listened on TCP, there is
	// no point in any of this
	if (!_bListenedOnTCP)
		return;

	if (!_hEventIPAddressChange)
	{
		_hEventIPAddressChange = CreateEvent(NULL, FALSE, FALSE, NULL);
		if (!_hEventIPAddressChange)
			return;
	}

	// We do not call WSAStartup, it is the responsibility of the caller
	// to make sure WSAStartup has already been been called successfully.
	// In practice, not calling this function until after we have 
	// successfully listened on TCP satisfies this requirement.
	if (_IPChangeNotificationSocket == INVALID_SOCKET)
	{
        _IPChangeNotificationSocket = socket(AF_INET, SOCK_STREAM, 0);
        if (_IPChangeNotificationSocket == INVALID_SOCKET)
		{
			KdPrintEx((DPFLTR_DCOMSS_ID,
					   DPFLTR_WARNING_LEVEL,
					   "Failed to create notification socket\n"));
			return;
		}
	}

	// First make sure we have successfully registered for a 
	// wait on the notification event with the NT thread pool
	if (!_bWaitRegistered)
	{
		_bWaitRegistered = RegisterWaitForSingleObject(
									&_hWaitObject,
									_hEventIPAddressChange,
									CAddrRefreshMgr::TimerCallbackFn,
									this,
									INFINITE,
									WT_EXECUTEINWAITTHREAD);
		if (!_bWaitRegistered)
		{
			KdPrintEx((DPFLTR_DCOMSS_ID,
					   DPFLTR_WARNING_LEVEL,
					   "RegisterWaitForSingleObject failed\n"));
			return;
		}
	}
	
	// Setup the notification again if we failed to register last time, 
	// or if this is the first time we've ever been here
	if (!_bRegisteredForNotifications)
	{
		// Initialize overlapped structure
		ZeroMemory(&_WSAOverlapped, sizeof(_WSAOverlapped));
	    _WSAOverlapped.hEvent = _hEventIPAddressChange;

		int err;
		DWORD dwByteCnt;
		err = WSAIoctl(
					_IPChangeNotificationSocket,
					SIO_ADDRESS_LIST_CHANGE,
					NULL,
					0,
					NULL,
					0,
					&dwByteCnt,
					&_WSAOverlapped,
					NULL
					);
		_bRegisteredForNotifications = (err == 0) || (WSAGetLastError() == WSA_IO_PENDING);
		if (!_bRegisteredForNotifications)
		{
			KdPrintEx((DPFLTR_DCOMSS_ID,
					   DPFLTR_WARNING_LEVEL,
					   "Failed to request ip change notification on socket (WSAGetLastError=%u)\n",
					   WSAGetLastError()));
			return;
		}
	}

	// Success
	KdPrintEx((DPFLTR_DCOMSS_ID,
			   DPFLTR_INFO_LEVEL,
			   "DCOM: successfully registered for address change notifications\n"));

	return;
}

	
// 
//  TimerCallbackFnHelper
//
//  Helper function to handle address change notifications.
//
//  Does the following tasks:
//   1) re-registers for further address changes
//   2) recomputes current resolver bindings
//   3) pushes new bindings to currently running processes; note
//      that this is done async, so we don't tie up the thread.
//
void CAddrRefreshMgr::TimerCallbackFnHelper()
{
	RPC_STATUS status;

	gpClientLock->LockExclusive();
	ASSERT(gpClientLock->HeldExclusive());

	// The fact that we we got this callback means that our
	// previous registration has been consumed.  Remember
	// that fact so we can re-register down below.
	_bRegisteredForNotifications = FALSE;

	// re-register for address changes.  The ordering of when
	// we do this and when we query for the new list is impt, 
	// see docs for WSAIoctl that talk about proper ordering
	// of SIO_ADDRESS_LIST_CHANGE and SIO_ADDRESS_LIST_QUERY.
	RegisterForAddressChanges();

	// Tell machine address object that addresses have changed
	gpMachineName->IPAddrsChanged();

	// Compute new resolver bindings
	status = ComputeNewResolverBindings();

	// Release lock now, so we don't hold it across PushCurrentBindings
	ASSERT(gpClientLock->HeldExclusive());
	gpClientLock->UnlockExclusive();

	if (status == RPC_S_OK)
	{
		// Push new bindings to running processes
		PushCurrentBindings();
	}

	return;
}


// 
//  TimerCallbackFn
//
//  Static entry point that gets called by NT thread pool whenever
//  our notification event is signalled.
//
void CALLBACK CAddrRefreshMgr::TimerCallbackFn(void* pvParam, BOOLEAN TimerOrWaitFired)
{
	ASSERT(!TimerOrWaitFired);  // should always be FALSE, ie event was signalled
	
	CAddrRefreshMgr* pThis = (CAddrRefreshMgr*)pvParam;

	ASSERT(pThis == &gAddrRefreshMgr);  // should always be ptr to the singleton

	pThis->TimerCallbackFnHelper();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\olescm\class.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       class.cxx
//
//  Contents:   Server table entry implementation
//
//  History:                VinayKr     Created
//              06-Nov-98   TarunA      Launch and shutdown logic change
//              24-Feb-99   TarunA      Fix custom surrogate launch
//              17-Jun-99   a-sergiv    Support for filtering RPCSS event logs
//
//--------------------------------------------------------------------------

#include "act.hxx"

CServerTable * gpClassTable = NULL;
CServerTable * gpProcessTable = NULL;

CSharedLock * gpClassLock = 0;
CSharedLock * gpProcessLock = 0;

CInterlockedInteger gRegisterKey( 1 );

//
// Default number of milliseconds to wait for a server to register its
// class factory before giving up and forcefully terminating it.
//
DWORD gServerStartTimeout = 120000;

//
// Default number of milliseconds to wait for a class factory registration
// after we detect that the launched server has died (for supporting cases
// where the server we launch turns around and launches another, then dies
// immediately)
//
DWORD gServerStartSecondChanceTimeout = 30000;

//
// Default number of milliseconds to wait for an NT service server to register 
// before we wake up and query its status.  At most we wait for 
// gNTServiceMaxTimeouts of these periods (see code in WaitForService below).
//
DWORD gNTServiceInterrogatePeriod = 30000;
DWORD gNTServiceMaxTimeouts = 4;

//
// Default number of milliseconds that we block while waiting for a dllhost
// server to register.    There is a startup protocol here - we block for 
// thirty seconds, then check the state of the launched process. 
//
DWORD gDllhostServerStartTimeout = 30000;

//
// Maxiumum number of milliseconds we will wait while waiting for a dllhost
// server to register.  There is a protocol yes, but this is the upper time
// bound no matter what. 
//
DWORD gDllhostMaxServerStartTimeout = 90000;

//
// Default number of milliseconds to wait for a dllhost to finish 
// long-running initialization.
//
DWORD gDllhostInitializationTimeout = 90000;

void GetSessionIDFromActParams(IActivationPropertiesIn* pActPropsIn, LONG* plSessionID)
{
    *plSessionID = INVALID_SESSION_ID;

    if (pActPropsIn != NULL)
    {
        ISpecialSystemProperties *pSp = NULL;
        HRESULT hr;

        hr = pActPropsIn->QueryInterface(IID_ISpecialSystemProperties, (void**) &pSp);
        if (SUCCEEDED(hr) && pSp != NULL)
        {
            ULONG ulSessionID;
            BOOL bUseConsole;

            hr = pSp->GetSessionId(&ulSessionID, &bUseConsole);
            if (SUCCEEDED(hr))
            {
                if (!bUseConsole && (ulSessionID != INVALID_SESSION_ID))
                {
                    // Just use whatever was there
                    *plSessionID = (LONG) ulSessionID;
                }
                else if (bUseConsole)
                {
                    // Little bit of magic here regarding how to find the
                    // currently active NT console session ID.
                    *plSessionID = (USER_SHARED_DATA->ActiveConsoleId);
                }
            }

            pSp->Release();
            pSp = NULL;
        }
    }
}

//+-------------------------------------------------------------------------
//
// CServerTable::GetOrCreate
//
// A somewhat degenerate combination of Lookup and Create -- only creates
// empty entries -- in particular without hooking up process entry if the
// entry being created is a class entry -- used only to create process entries
// and to create class entries for unsolicited CoRegisterClassObject calls
//
//--------------------------------------------------------------------------
CServerTableEntry *
CServerTable::GetOrCreate(
    IN  GUID & ServerGuid
    )
{
    CServerTableEntry *  pEntry;

    pEntry = Lookup( ServerGuid );

    if ( pEntry )
        return pEntry;
    else
        return Create(ServerGuid);
}

//+-------------------------------------------------------------------------
//
// CServerTable::Create
//
//  Creates a new CServerTableEntry, or returns an existing one.
//
//--------------------------------------------------------------------------
CServerTableEntry *
CServerTable::Create(
    IN  GUID   &  ServerGuid
    )
{
    BOOL fEntryFoundInTable = FALSE;

    _pServerTableLock->LockExclusive();

    // Must use CGuidTable::Lookup method because it doesn't take
    // a shared lock. Already have the exclusive lock.
    CServerTableEntry *pNewEntry = (CServerTableEntry *) CGuidTable::Lookup( &ServerGuid );

    if (pNewEntry)
    {
        pNewEntry->Reference();     // Found an entry, take a reference on it
        fEntryFoundInTable = TRUE;
    }
    else
    {
        LONG Status;
        pNewEntry = new CServerTableEntry( Status, &ServerGuid, _EntryType );

        if ( ! pNewEntry )
        {
            _pServerTableLock->UnlockExclusive();
            return NULL;
        }

        if ( Status != ERROR_SUCCESS )
        {
            _pServerTableLock->UnlockExclusive();
            // release using base class method because the entry is not
            // in the table yet and we don't want to try to remove it
            pNewEntry->CReferencedObject::Release();
            return NULL;
        }
    }

    if (!fEntryFoundInTable)
    {
        Add( pNewEntry );
    }

    _pServerTableLock->UnlockExclusive();
    return pNewEntry;
}


//+-------------------------------------------------------------------------
//
// CServerTable::Lookup
//
//--------------------------------------------------------------------------
CServerTableEntry *
CServerTable::Lookup(
    IN  GUID & ServerGuid
    )
{
    CServerTableEntry *  pServerTableEntry;

    _pServerTableLock->LockShared();
    pServerTableEntry = (CServerTableEntry *) CGuidTable::Lookup( &ServerGuid );
    if ( pServerTableEntry )
        pServerTableEntry->Reference();
    _pServerTableLock->UnlockShared();

    return pServerTableEntry;
}

//+-------------------------------------------------------------------------
//
// CServerTableEntry::CServerTableEntry
//
//--------------------------------------------------------------------------
CServerTableEntry::CServerTableEntry(
    OUT LONG&   Status,
    IN  GUID * pServerGUID,
    IN  EnumEntryType EntryType
    ) :
    CGuidTableEntry( pServerGUID ), _EntryType(EntryType)
    ,_ServerLock( Status ), _lThreadToken(0), _hProcess(0), _pProcess(NULL)
    ,_pvRunAsHandle(NULL), _bSuspendedClsid(FALSE), _bSuspendedApplication(FALSE),
    _dwProcessId(0)
{
	Status = ERROR_SUCCESS;

    switch (_EntryType)
    {
    case ENTRY_TYPE_CLASS:
        _pParentTable = gpClassTable;
        break;

    case ENTRY_TYPE_PROCESS:
        _pParentTable = gpProcessTable;
        break;

    default:
        Status = E_INVALIDARG;
    }

    if (Status == ERROR_SUCCESS)
    {
        _pParentTableLock = _pParentTable->_pServerTableLock;
    }
}

//+-------------------------------------------------------------------------
//
// CServerTableEntry::~CServerTableEntry
//
//--------------------------------------------------------------------------
CServerTableEntry::~CServerTableEntry()
{
    ASSERT(_pParentTableLock->HeldExclusive());
	
    // Remove ourselves from the table
    _pParentTable->Remove(this);

    if(NULL != _pProcess)
    {
        ReleaseProcess(_pProcess);
    }

    ASSERT(_pvRunAsHandle == NULL);
    ASSERT(_hProcess == NULL);
}


//+-------------------------------------------------------------------------
//
// CServerTableEntry::Release
//
//--------------------------------------------------------------------------
DWORD
CServerTableEntry::Release()
{
    DWORD Refs;
    CSharedLock* pParentTableLock = _pParentTableLock;

    CairoleDebugOut((DEB_SCM, "Releasing ServerTableEntry at 0x%p\n", this));

    pParentTableLock->LockExclusive();

    Dereference();
    if ( 0 == (Refs = References()) )
    {
        delete this;
    }

    pParentTableLock->UnlockExclusive();

    return Refs;
}

//+-------------------------------------------------------------------------
//
// CServerTableEntry::RegisterServer
//
//--------------------------------------------------------------------------
HRESULT
CServerTableEntry::RegisterServer(
    IN  CProcess *      pServerProcess,
    IN  IPID            ipid,
    IN  CClsidData *    pClsidData, OPTIONAL
    IN  CAppidData *    pAppidData,
    IN  UCHAR           ServerState,
    OUT DWORD *         pRegistrationKey )
{
    CServerListEntry *      pEntry;
    CSurrogateListEntry *   pSurrogateEntry;

    UCHAR Context = 0;
    UCHAR SubContext = 0;

    if (pClsidData)
    {
        if ( (pClsidData->ServerType() == SERVERTYPE_SERVICE) ||
             (pClsidData->ServerType() == SERVERTYPE_COMPLUS_SVC) )
        {
            Context = SERVER_SERVICE;
        }
        else if ( pClsidData->HasRunAs() )
        {
            Context = SERVER_RUNAS;

            if ( pClsidData->IsInteractiveUser() )
                SubContext = SUB_CONTEXT_RUNAS_INTERACTIVE;
            else
                SubContext = SUB_CONTEXT_RUNAS_THIS_USER;
        }
        // Special case of COM+ library class being loaded by VB for debugging
        else if ( pClsidData->ServerType() == SERVERTYPE_COMPLUS && pClsidData->IsInprocClass() )
        {
            Context = SERVER_RUNAS;
        }
    }

    if ( _EntryType == ENTRY_TYPE_PROCESS )
    {
        // This is the COM+/COM surrogate case
        Win4Assert(NULL == pClsidData  && "Process Entry Given Clsid data");
        Win4Assert(NULL != pAppidData  && "Process Entry Not Given Appid data");
        if (pAppidData->Service())
        {
            Context = SERVER_SERVICE;
        }
        else if ((pAppidData->IsInteractiveUser()) || pAppidData->RunAsUser())
        {
            Context = SERVER_RUNAS;
        }
    }

    // If none of the above applied, Context will be zero at this point -- this
    // essentially means the server should be treated as an activate-as-activator
    // server.   However, if Context is zero SubContext had better also be zero,
    // and so we assert that here.   
    if (Context == 0)
    {
        Context = SERVER_ACTIVATOR;
        ASSERT(SubContext == 0);
    }

    pEntry = new CServerListEntry(
                    this,
                    pServerProcess,
                    ipid,
                    Context,
                    ServerState,
					SubContext);

    if ( ! pEntry )
        return E_OUTOFMEMORY;

    // Add registration to the process object -- but only if we are a class entry;
    // otherwise this is a registration for a surrogate server
    if ( _EntryType == ENTRY_TYPE_CLASS )
    {
      pEntry->AddToProcess( Guid() );
    }
    
    // 
    SetSuspendedFlagOnNewServer(pServerProcess);

    //
    // NOTE: The entry should be inserted in the lists only after
    // all the registration specific stuff has been done. This will
    // ensure that anyone outside this procedure sees the complete
    // entry and not some half-baked one
    //

    ServerLock()->LockExclusive();
    // Check if process handle exists implying that a
    // launch is in progress for this class.  Try to
    // register runas,process, and threadtoken with
    // the newly created entry
    // Note that it is essential for the server lock to
    // be held since _hProcess can change otherwise.
    if (_hProcess || _pProcess)
        RegisterHandles(pEntry, pServerProcess);
    _ServerList.Insert( pEntry );
    ServerLock()->UnlockExclusive();

    //
    // It's possible that a process could register itself as a surrogate but
    // there's no CLSID info in the registry.  We might want to disallow
    // this kind of register.
    //
    // Note: We allow class registration if appid is not present but don't
    // allow surrogate registration since it'll never be found
    // The right thing to do would be to reject the call completely when
    // an appid is not present but we will take the path of least resistance
    // and preserve legacy
    if ( pClsidData && (ServerState & SERVERSTATE_SURROGATE) && pClsidData->AppidString() )
    {
        pSurrogateEntry = new CSurrogateListEntry( pClsidData->AppidString(), pEntry );

        if ( ! pSurrogateEntry )
        {
            pEntry->CReferencedObject::Release();
            return E_OUTOFMEMORY;
        }

        gpSurrogateList->Insert( pSurrogateEntry );
    }

    *pRegistrationKey = pEntry->RegistrationKey();

    return S_OK;
}

//+-------------------------------------------------------------------------
//
// CServerTableEntry::RevokeServer -- version 1 for class entries
//
// CODE WORK: Consider defining two separate classes for class and
//            process entries so we can avoid this sort of thing
//
//--------------------------------------------------------------------------
void
CServerTableEntry::RevokeServer(
    IN  CProcess *      pServerProcess,
    IN  DWORD           RegistrationKey
    )
{
    Win4Assert(_EntryType == ENTRY_TYPE_CLASS);

    ServerLock()->LockExclusive();

    CServerListEntry *  pEntry = (CServerListEntry *) _ServerList.First();

    for ( ; pEntry; pEntry = (CServerListEntry *) pEntry->Next() )
    {
        if ( (RegistrationKey == pEntry->_RegistrationKey)
#if 1 // #ifndef _CHICAGO_
             && (pServerProcess == pEntry->_pServerProcess)
#endif
           )
            break;
    }

    if ( pEntry )
        _ServerList.Remove( pEntry );

    ServerLock()->UnlockExclusive();

    if ( pEntry )
    {
        pEntry->RemoveFromProcess();
        pEntry->Release();
    }
}

//+-------------------------------------------------------------------------
//
// CServerTableEntry::RevokeServer -- version 2 for process entries
//
//--------------------------------------------------------------------------
void
CServerTableEntry::RevokeServer(
    IN  ScmProcessReg * pScmProcessReg
    )
{
    Win4Assert(_EntryType == ENTRY_TYPE_PROCESS);

    ServerLock()->LockExclusive();

    CServerListEntry * pEntry = (CServerListEntry *) _ServerList.First();

    for ( ; pEntry; pEntry = (CServerListEntry *) pEntry->Next() )
    {
        if ( (pScmProcessReg->RegistrationToken == pEntry->_RegistrationKey)
           )
            break;
    }

    if ( pEntry )
        _ServerList.Remove( pEntry );

    ServerLock()->UnlockExclusive();

    if ( pEntry )
    {
        pEntry->RemoveFromProcess();
        pEntry->Release();
    }
}

//+-------------------------------------------------------------------------
//
// CServerTableEntry::LookupServer
//
//--------------------------------------------------------------------------
BOOL
CServerTableEntry::LookupServer(
    IN  CToken *            pClientToken,
    IN  BOOL                bRemoteActivation,
	IN  BOOL                bClientImpersonating,
    IN  WCHAR             * pwszWinstaDesktop,
    IN  DWORD               dwFlags,
    IN  LONG                lThreadToken,
    IN  LONG                lSessionID,
    IN  DWORD               pid,
    IN  DWORD               dwProcessReqType,
    OUT CServerListEntry ** ppServerListEntry)
{
    CServerListEntry * pEntry;
    
    *ppServerListEntry = NULL;

    // If we are suspended, no need to go any further
    if (IsSuspended())
      return FALSE;

    ServerLock()->LockShared();

    pEntry = (CServerListEntry *) _ServerList.First();

    for ( ; pEntry; pEntry = (CServerListEntry *) pEntry->Next() )
    {
        if ( pEntry->Match( pClientToken,
                            bRemoteActivation,
							bClientImpersonating,
							pwszWinstaDesktop,
                            FALSE,
                            lThreadToken,
                            lSessionID,
                            pid,
                            dwProcessReqType,
                            dwFlags ) )
        {
            pEntry->Reference();
            break;
        }
    }

    ServerLock()->UnlockShared();

    *ppServerListEntry = pEntry;
    return (pEntry != 0);
}

//+-------------------------------------------------------------------------
//
// CServerTableEntry::LookupServer
//
//--------------------------------------------------------------------------
BOOL
CServerTableEntry::LookupServer(
    IN  DWORD           RegistrationKey,
    CServerListEntry ** ppServerListEntry )
{
    CServerListEntry * pEntry;

    ServerLock()->LockShared();

    pEntry = (CServerListEntry *) _ServerList.First();

    for ( ; pEntry; pEntry = (CServerListEntry *) pEntry->Next() )
    {
        if ( RegistrationKey == pEntry->_RegistrationKey )
            break;
    }

    if ( pEntry )
        pEntry->Reference();

    ServerLock()->UnlockShared();

    *ppServerListEntry = pEntry;
    return (pEntry != 0);
}

//+-------------------------------------------------------------------------
//
// CServerTableEntry::UnsuspendServer
//
//--------------------------------------------------------------------------
void
CServerTableEntry::UnsuspendServer(
    IN  DWORD   RegistrationKey
    )
{
    CServerListEntry * pEntry;

    LookupServer( RegistrationKey, &pEntry );

    if ( pEntry )
    {
        pEntry->_State &= ~SERVERSTATE_SUSPENDED;
        pEntry->Release();
    }
}

//+-------------------------------------------------------------------------
// CServerTableEntry::ServerExists
//+-------------------------------------------------------------------------
HRESULT
CServerTableEntry::ServerExists(
    IN  ACTIVATION_PARAMS * pActParams, BOOL *pfExist)
{
    LONG lSessionID = INVALID_SESSION_ID;
    ServerLock()->LockShared();

    GetSessionIDFromActParams(pActParams->pActPropsIn, &lSessionID);

    CServerListEntry *pEntry = (CServerListEntry *) _ServerList.First();

    for ( ; pEntry; pEntry = (CServerListEntry *) pEntry->Next() )
    {
        if ( pEntry->Match(
               pActParams->pToken,
               pActParams->RemoteActivation,
               pActParams->bClientImpersonating,
               pActParams->pProcess ? pActParams->pProcess->WinstaDesktop() : NULL ,
               FALSE,
               0,
               lSessionID ))
        {
            break;
        }
    }

    ServerLock()->UnlockShared();

    *pfExist = (pEntry != NULL);
    return S_OK;
}


//+-------------------------------------------------------------------------
//
// CServerTableEntry::CallRunningServer
// Synopsis: The behavior of CallRunningServer is best described by this matrix
//
// If the call is made successfully then we return
// If CallServer() returns error then we take the following action
// ----------------------------------------------------------------------------
// |     | RPC_E_SERVERFAULT     |  CO_E_SERVER_STOPPING | Other Errors        |
// ----------------------------------------------------------------------------
// | COM | Kill the process      | Remove the list entry |Remove the list entry|
// |     | Remove the list entry | Try launching another |Try launching another|
// |     | Try launching another | process               |process              |
// |     | process               |                       |                     |
// |     |                       |                       |                     |
// -----------------------------------------------------------------------------
// | COM+| Kill the process      | Set a timeout period  |If process exists    |
// |     | Remove the list entry | If the server         |then                 |
// |     | Return the error      | stops before timeout  | return error        |
// |     |                       | then                  |else                 |
// |     |                       |  try launching        | Remove the entry    |
// |     |                       |  another process      | try launching       |
// |     |                       | else                  | another process     |
// |     |                       |   return error        |                     |
// -----------------------------------------------------------------------------

//--------------------------------------------------------------------------
BOOL
CServerTableEntry::CallRunningServer(
    IN  ACTIVATION_PARAMS * pActParams,
    IN  DWORD               dwFlags,
    IN  LONG                lLaunchThreadToken,
    IN  CClsidData *        pClsidData,
    OUT HRESULT *           phr
    )
{
    BOOL              bStatus;
    LONG              lSessionID = INVALID_SESSION_ID;
    CServerListEntry* pEntry;
    
    GetSessionIDFromActParams(pActParams->pActPropsIn, &lSessionID);

    for (;;)
    {
        BOOL bTerminatedServer;

        bStatus = LookupServer(
                    pActParams->pToken,
                    pActParams->RemoteActivation,
                    pActParams->bClientImpersonating,
                    pActParams->pProcess ? pActParams->pProcess->WinstaDesktop() : NULL ,
                    dwFlags,
                    lLaunchThreadToken,
                    lSessionID,
                    pActParams->dwPID,
                    pActParams->dwProcessReqType,
                    &pEntry);
        if (!bStatus)
        {
            Win4Assert(!pEntry);
            return FALSE;
        }

        *phr = S_OK;

        //
        // If the entry is "initializing", then it isn't really ready yet.
        // Wait for it to become so.
        //
        if (pEntry->IsInitializing())
        {            
            *phr = WaitForInitCompleted(pEntry, pClsidData);
            if (FAILED(*phr))
            {
                if (*phr == CO_E_SERVER_STOPPING)
                    bStatus = FALSE;
                else
                    bStatus = TRUE;
            }
        }

        //
        // Returns TRUE if we successfully make a call to this server, or
        // if an unrecoverable non-server-related error is encountered 
        // (e.g, an out-of-mem failure while allocating data before or 
        // after the call).
        //
        // The final HRESULT is not necessarily S_OK.
        //
        if (SUCCEEDED(*phr))
            bStatus = pEntry->CallServer(pActParams, phr);
        if (!bStatus)
        {
            // We were unable to talk to the server, or got back
            // CO_E_SERVER_STOPPING.
            
            // Retrieve the process handle, if we have one
            HANDLE hProcess = pEntry->GetProcess()->GetProcessHandle();

            bTerminatedServer = FALSE;

            // Try to kill the server if it returned RPC_E_SERVERFAULT (this
            // means that we caught an unhandled exception somewhere in the 
            // server, which we don't really appreciate.)
            if(*phr == RPC_E_SERVERFAULT)
            {
                if(hProcess)
                {
                    bTerminatedServer = TerminateProcess(hProcess, 0);
                }

                // Remember that the server blew up on us.  This is mostly
                // for debugging purposes
                pEntry->IncServerFaults();
            }
			            
            //
            // Determine if we need to remove the server entry.  We will do this if
            // a) we killed the server process up above; or b) the server returned
            // CO_E_SERVER_STOPPING; or c) the server process is dead already.
            //
            if (bTerminatedServer || 
                (*phr == CO_E_SERVER_STOPPING) ||
                pEntry->ServerDied())
            {
                BOOL bRemoved;

                //
                // Remove this server entry if it's still in the list.
                //
                ServerLock()->LockExclusive();

                bRemoved = _ServerList.InList(pEntry);
                if (bRemoved)
                    _ServerList.Remove(pEntry);

                ServerLock()->UnlockExclusive();

                if (bRemoved)
                {
                    pEntry->RemoveFromProcess();
                    pEntry->Release();
                }
            }
        }

        // Now allow threads other than launching one to access
        // this entry. Exit since we matched launched server
        // regardless of result since we know that we will
        // not get any more matches.
        if (lLaunchThreadToken)
        {
            pEntry->SetThreadToken(0);
            pEntry->Release();
            return bStatus;
        }

        pEntry->Release();

        if ( bStatus )
            return TRUE;
    }
}


//+-------------------------------------------------------------------------
//
// CServerTableEntry::StartServerAndWait
//
//--------------------------------------------------------------------------
HRESULT
CServerTableEntry::StartServerAndWait(
    IN  ACTIVATION_PARAMS * pActParams,
    IN  CClsidData *        pClsidData,
    IN  LONG                &lLaunchThreadToken
    )
{
    SC_HANDLE       hService;
    HRESULT         hr;
    BOOL            bStatus;
    BOOL            bServiceAlreadyRunning = FALSE;
    DWORD           dwActvFlags;

    if ( ! pClsidData->LaunchAllowed( pActParams->pToken, pActParams->ClsContext ) )
        return E_ACCESSDENIED;

    // Check CreateProcessMemoryGate
    // [a-sergiv (Sergei O. Ivanov)  11/1/99  Implemented Memory Gates in COM Base
    if(pActParams->pActPropsIn)
    {
        BOOL bResult = TRUE;
        IClassClassicInfo *pClassicInfo = NULL;     
        hr = pActParams->pActPropsIn->GetClassInfo(IID_IClassClassicInfo, (void**) &pClassicInfo);

        if(SUCCEEDED(hr) && pClassicInfo)
        {
            IResourceGates *pResGates = NULL;
            hr = pClassicInfo->GetProcess(IID_IResourceGates, (void**) &pResGates);
            pClassicInfo->Release();

            if(SUCCEEDED(hr) && pResGates)
            {
                hr = pResGates->Test(CreateProcessMemoryGate, &bResult);
                pResGates->Release();

                if(SUCCEEDED(hr) && !bResult)
                {
                    // The gate said NO!
                    return E_OUTOFMEMORY;
                }
            }
        }
    }

    hService = 0;

    // NOTE: _hProcess, _dwProcessId, _pProcess and all other process specific
    // variables that are part of CServerTableEntry are used only during the
    // launch. Once the launch is completed either they are transferred to
    // process specific entries or discarded. See CServerTableEntry::RegisterHandles
    // for an example.
    _dwProcessId = 0;

    // _hProcess and _pProcess variables are released and set to
    // null whether
    // (1) This is the first launch
    // OR
    // (2) We succeeded in an earlier launch or failed
    Win4Assert((0 == _hProcess) && (NULL == _pProcess));

    //
    // Get the register event for the server we're about to launch.  Note
    // there exists a problem in that we may launch a server, but another
    // server may register the desired clsid\appid at about the same time.
    // I think this is just something we have to live with, especially since
    // there are servers in the world that don't register with us, but instead
    // turn around and launch another process to do the registration.  So, 
    // even if we have a process handle it would be impossible to always 
    // correlate from register event back to the launching table entry.
    //
    HANDLE hRegisterEvent = pClsidData->ServerRegisterEvent();
    if (!hRegisterEvent)
      return E_OUTOFMEMORY;

    if (pClsidData->ServerType() == SERVERTYPE_SURROGATE)
    {
        Win4Assert(_EntryType == ENTRY_TYPE_CLASS);

        LPWSTR pwszAppidString = pClsidData->AppidString();
        CSurrogateListEntry * pSurrogateListEntry = NULL;

        if(pwszAppidString)
        {
            pSurrogateListEntry = gpSurrogateList->Lookup(
                                        pActParams->pToken,
                                        pActParams->RemoteActivation,
                                        pActParams->bClientImpersonating,
                                        pActParams->pProcess ? pActParams->pProcess->WinstaDesktop() : NULL ,                                    
                                        pwszAppidString );
        }

        if ( pSurrogateListEntry )
        {
            // If we find a surrogate entry and we are inside a launch
            // server then that implies that a surrogate was launched for
            // a different class' activation. We have a process entry for
            // this surrogate and we set it here. Later when RegisterServer
            // gets called we use the process object to set the state.
            // For all other cases, the state is set using the process handle.
            _pProcess =  pSurrogateListEntry->Process();
            Win4Assert(NULL !=_pProcess);
            // We will release this on every path below
            ReferenceProcess( _pProcess, TRUE );

            // Remember the launching thread's token
            _lThreadToken = lLaunchThreadToken;

            // Load the dll that will service the activation request
            bStatus = pSurrogateListEntry->LoadDll( pActParams, &hr );
            pSurrogateListEntry->Release();

            // A status of TRUE implies that we successfully talked to the
            // server
            if (bStatus)
            {
                // A successful hresult implies that the server was able to
                // load the dll successfully and hence we expect it to
                // register back
                if(SUCCEEDED(hr))
                {
                    // Wait for the loaded object server to register back
                    bStatus = WaitForSingleObject( hRegisterEvent, 30000 );
                }
                // If the server failed to load the dll or it registered back
                // within the timeout then we return immediately
                if ( FAILED(hr) || (bStatus == WAIT_OBJECT_0) )
                {
                    ReleaseProcess(_pProcess);
                    _pProcess = NULL;
					CloseHandle(hRegisterEvent);
                    return hr;
                }
            }
            // If a launched server failed to register back in the given
            // timeout or we were not able to talk to the server then we
            // continue and try to launch a new process
            ReleaseProcess(_pProcess);
            _pProcess = NULL;
        }
    }

    if ((pClsidData->ServerType() == SERVERTYPE_SERVICE) ||
        (pClsidData->ServerType() == SERVERTYPE_COMPLUS_SVC))
    {
#ifndef _CHICAGO_
        // Set the token here as service does not register back
        // with us and so it cannot be set at registration time
        // unlike the activator server case below

        hr = pClsidData->LaunchService( pActParams->pToken, pActParams->ClsContext, &hService );

        if (hr == HRESULT_FROM_WIN32(ERROR_SERVICE_ALREADY_RUNNING))
        {
            hr = S_OK;
            bServiceAlreadyRunning = TRUE;
        }
#endif // _CHICAGO_
    }
    else
    {
        //When a "RunAs Interactive User" server is launched from a Hydra session,
        //the server runs in the Hydra session of the caller.  In this case,
        //we want to call LaunchActivator server instead of LaunchRunAsServer
        //so that the server runs in the appropriate Hydra session.

        //if ( pClsidData->HasRunAs() &&
        //   (!pClsidData->IsInteractiveUser() || !pActParams->pToken ||!pActParams->pToken->GetSessionId()))

        _lThreadToken = lLaunchThreadToken;

        if ( pClsidData->HasRunAs())
        {
#ifndef _CHICAGO_
            hr = pClsidData->LaunchRunAsServer(
                                pActParams->pToken,
                                pActParams->RemoteActivation,
                                pActParams->pActPropsIn,
                                pActParams->ClsContext,
                                &_hProcess,
                                &_dwProcessId,
                                &_pvRunAsHandle);
#endif // _CHICAGO_
        }
        else
        {
            // Check to see if the client requested "protected" activation. If
            // so, we refuse to launch a server using their token.
            hr = pActParams->pActPropsIn->GetActivationFlags(&dwActvFlags);
            
            if (FAILED(hr) || (dwActvFlags & ACTVFLAGS_DISABLE_AAA))
            {
                hr = E_ACCESSDENIED;
            }
            
            if (SUCCEEDED(hr))
            {
                hr = pClsidData->LaunchActivatorServer(
                                    pActParams->pToken,
                                    pActParams->pEnvBlock,
                                    pActParams->EnvBlockLength,
                                    pActParams->RemoteActivation,
                                    pActParams->bClientImpersonating,
                                    pActParams->pProcess ? pActParams->pProcess->WinstaDesktop() : NULL,
                                    pActParams->ClsContext,
                                    &_hProcess,
                                    &_dwProcessId);
            }
        }
    }

    if (FAILED(hr))
    {
#ifndef _CHICAGO_
        Win4Assert(_pvRunAsHandle == NULL);
#endif
        _lThreadToken = 0;
		CloseHandle(hRegisterEvent);
        return hr;
    }


    // we got this far so it is time to wait for the server/service we just
    // launched to register itself with us appropriately and in a timely fashion

    // Retry once if we fail to get desktop resources the first time
    BOOL fSuccessful;
    for (int i=0; i<2; i++) {

        ULONG winerr=0;
        fSuccessful = FALSE;

        switch (pClsidData->ServerType())
        {
        case SERVERTYPE_SERVICE:
        case SERVERTYPE_COMPLUS_SVC:
            Win4Assert(hService && "Waiting for service with NULL handle");
            fSuccessful = WaitForService(hService, hRegisterEvent,
                                         bServiceAlreadyRunning);
            CloseServiceHandle( hService );
            hService = 0;
            break;

        case SERVERTYPE_COMPLUS:
        case SERVERTYPE_DLLHOST:
            fSuccessful = WaitForDllhostServer(hRegisterEvent,
                                               pActParams,
                                               winerr,
                                               lLaunchThreadToken);
            break;

        default:
            fSuccessful = WaitForLocalServer(hRegisterEvent,
                                             winerr);
            break;
        }

#ifndef _CHICAGO_
        if ( (i==0) && _pvRunAsHandle && (!fSuccessful ) &&
             (winerr == ERROR_WAIT_NO_CHILDREN))
        {
            RunAsInvalidateAndRelease(_pvRunAsHandle);
            _pvRunAsHandle = NULL;
            hr = pClsidData->LaunchRunAsServer(
                                pActParams->pToken,
                                pActParams->RemoteActivation,
                                pActParams->pActPropsIn,
                                pActParams->ClsContext,
                                &_hProcess,
                                &_dwProcessId,
                                &_pvRunAsHandle);

            if (FAILED(hr))
            {
                Win4Assert(_pvRunAsHandle == NULL);
                CloseHandle(hRegisterEvent);
                return hr;
            }

            continue;
        }
#endif // _CHICAGO_

        break;
    }

    if ( !fSuccessful )
    {
        GUID ServerGuid = Guid();
        LogRegisterTimeout( &ServerGuid, pActParams->ClsContext, pActParams->pToken );
        hr = CO_E_SERVER_EXEC_FAILURE;
    }
    else
    {
        hr = S_OK;
    }

    // Ensure that we are serializing around
    // registration which takes an exclusive
    // before modifying this and is the only
    // one that needs to look at or modify it.
    if (_hProcess)
    {

        ServerLock()->LockShared();

        if (_hProcess)
        {
            CloseHandle(_hProcess);
            _hProcess = 0;
        }

        ServerLock()->UnlockShared();

    }


    // If we still have the token set the callers also to
    // NULL because we might have succeeded the launch but
    // the server registering back was different from
    // the one launched(this should be very rare).
    if (_lThreadToken)
    {
        _lThreadToken = 0;
        lLaunchThreadToken = 0;
    }

#ifndef _CHICAGO_
    if (_pvRunAsHandle)
    {
        Win4Assert(pClsidData->HasRunAs());
        RunAsRelease(_pvRunAsHandle);
        _pvRunAsHandle = NULL;
    }
#endif // _CHICAGO_

    CloseHandle(hRegisterEvent);

    return hr;
}

//+-------------------------------------------------------------------------
//
// CServerTableEntry::RegisterHandles
//
// Synopsis         Register either the RunAs or the process handle with the
//                  CProcess object. Also register Single use Thread token.
//
//                  NOTE: this is called by RegisterServer
//--------------------------------------------------------------------------
BOOL CServerTableEntry::RegisterHandles(IN CServerListEntry *  pEntry,
                                        IN CProcess *pServerProcess)
{
    BOOL bStatus = TRUE;

    // Are we interested in registering the process handle
    if(_hProcess || _pProcess)
    {
        Win4Assert(pServerProcess);
        // We can have either a process handle if this entry is the one
        // which was the first to launch the server or we can have a process
        // object if the server has already been launched. The two cases are
        // mutually exclusive and we assert that here.
        Win4Assert((_hProcess && (NULL == _pProcess)) ||
                    (0 == _hProcess && (NULL != _pProcess)));
        if(_hProcess)
            bStatus = pServerProcess->SetProcessHandle(_hProcess,_dwProcessId);

        // If a FALSE status is returned then the PID of the process launched
        // by us did not match the PID of the process registered.
        // The only cases where this will be FALSE are if a server is
        // started by hand at the same time as a system launch or the
        // process registering was launched by the one we launched.
        // This should almost never happen
        if (!bStatus)
            goto ExitRegisterHandles;

        // If the PID matched then we are sure that this register event
        // matches the server we launched

        // Given process handle away so remove our reference
        _hProcess = 0;

        // If we had a process match save thread token if
        // it was passed since this thread launched the server
        if (_lThreadToken)
        {
            pEntry->SetThreadToken(_lThreadToken);
            _lThreadToken = NULL;
        }

        // Are we interested in registering the RunAs handle ?
#ifndef _CHICAGO_
        if (_pvRunAsHandle)
        {
        // Pass our winsta reference over to process entry which will
        // release it when it goes away so we can be rid of
        // responsibilities for it.
            RunAsSetWinstaDesktop(_pvRunAsHandle,
                                  pServerProcess->WinstaDesktop());
            pServerProcess->SetRunAsHandle(_pvRunAsHandle);

            // Given Handle away so remove our reference
            _pvRunAsHandle = NULL;
        }
#endif
    }

ExitRegisterHandles:

    return bStatus;
}

//+-------------------------------------------------------------------------
//
// CServerTableEntry::WaitForLocalServer
//
//--------------------------------------------------------------------------
BOOL
CServerTableEntry::WaitForLocalServer(
    IN HANDLE       hRegisterEvent,
    IN ULONG        &winerr
    )
{
    DWORD           Status = WAIT_OBJECT_0+1;
    BOOL            bStatus = FALSE;

    HANDLE  Handles[2];

    Handles[0] = hRegisterEvent;
    Handles[1] = _hProcess;

    // Wait for process and register events
    Status = WaitForMultipleObjects( 2, Handles, FALSE, gServerStartTimeout );

    if ( Status == (WAIT_OBJECT_0 + 1) )
    {
        // Launched Process went away but this could be the case
        // where we have a launched server that starts another server
        // which registers back(Lotus or something ??)
        // So null the handle and wait for the register event for
        // a much shorter time
        GetExitCodeProcess(_hProcess, &winerr);

        HANDLE hProcess;

        CloseHandle( _hProcess );
        _hProcess = 0;

        Status = WaitForSingleObject( hRegisterEvent, gServerStartSecondChanceTimeout );
    }

    if ( Status != WAIT_OBJECT_0 && _hProcess )
        TerminateProcess( _hProcess, 0 );

    if ( Status == WAIT_OBJECT_0 )
        return TRUE;
    else
        return FALSE;
}


//+-------------------------------------------------------------------------
//
// CServerTableEntry::WaitForDllhostServer
//
//--------------------------------------------------------------------------

BOOL
CServerTableEntry::WaitForDllhostServer(
    IN HANDLE               hRegisterEvent,
    IN ACTIVATION_PARAMS    *pActParams,
    IN ULONG        &winerr,
    IN  LONG                lThreadToken
    )
{
    DWORD  Status = WAIT_OBJECT_0+1;
    DWORD WaitedMilliSecondsToStart = 0;

    CServerListEntry *  pEntry = NULL;
    BOOL                bStatus;
    CProcess            *pProcess=NULL;

    HANDLE  Handles[2];

    Handles[0] = hRegisterEvent;
    Handles[1] = _hProcess;

    LONG lSessionID = INVALID_SESSION_ID;
    GetSessionIDFromActParams(pActParams->pActPropsIn, &lSessionID);

    for (;;)
    {
        // Wait for process and register events
        Status = WaitForMultipleObjects( 2, Handles,
                                        FALSE, gDllhostServerStartTimeout );

        if ( ( Status == WAIT_OBJECT_0 ) ||
             ( Status == (WAIT_OBJECT_0 + 1 )))
            break;

        if (pEntry == NULL)
        {
            bStatus = LookupServer(
                        pActParams->pToken,
                        pActParams->RemoteActivation,
                        pActParams->bClientImpersonating,
                        pActParams->pProcess ? pActParams->pProcess->WinstaDesktop() : NULL ,
                        MATCHFLAG_ALLOW_SUSPENDED, // Dllhost is suspended now, we still want to find it!
                        lThreadToken,
                        lSessionID,
                        0,             // no need for a pid here
                        PRT_IGNORE,    // no need for prt here
                        &pEntry);  

            if (!bStatus)
                pEntry = NULL;
            else
            {
                pProcess = pEntry->_pServerProcess;
                Win4Assert(pProcess != NULL);
            }
        }

        ScmProcessReg *pScmProcessReg=NULL;
        if (pProcess)
        {
            pScmProcessReg = pProcess->GetProcessReg();
            Win4Assert(pScmProcessReg != NULL);
        }

        if (! pScmProcessReg )
        {
            // ProcessActivatorStarted not called yet
            WaitedMilliSecondsToStart += gDllhostServerStartTimeout;
            if (WaitedMilliSecondsToStart >= gDllhostMaxServerStartTimeout)
                break;
            else
                continue;
        }

        // ProcessActivatorStarted has been called, how long since last call from
        // initial process activator?

        // handles wraparound
        CTime CurrentTime;
        DWORD WaitedMilliSecondsToReady = CurrentTime - pScmProcessReg->TimeOfLastPing;

        if (WaitedMilliSecondsToReady >= gDllhostMaxServerStartTimeout)
            break;
        else
            continue;
    }

    if (pEntry)
        pEntry->Release();

    if ( Status == WAIT_OBJECT_0 )
        return TRUE;
    else
    {
        GetExitCodeProcess(_hProcess, &winerr);
        TerminateProcess( _hProcess, 0 );
        return FALSE;
    }
}


//+-------------------------------------------------------------------------
//
// CServerTableEntry::WaitForService
//
//--------------------------------------------------------------------------

BOOL
CServerTableEntry::WaitForService(
    IN SC_HANDLE    hService,
    IN HANDLE       hRegisterEvent,
    IN BOOL         bServiceAlreadyRunning
    )
{
    SERVICE_STATUS  ServiceStatus;
    DWORD           Status;
    BOOL            bStatus;
    BOOL            bKeepLooping;
    BOOL            bStopService = FALSE;

    for (DWORD i = 0; i < gNTServiceMaxTimeouts; i++)
    {
        Status = WaitForSingleObject( hRegisterEvent, gNTServiceInterrogatePeriod );
        if (Status == WAIT_OBJECT_0)
        {
			// register event was signalled, just return
            break;
        }
        else
        {
            // Assume we are done
            bKeepLooping = FALSE;

            bStatus = ControlService( hService,
                                      SERVICE_CONTROL_INTERROGATE,
                                      &ServiceStatus );
            if (bStatus)
            {
                switch ( ServiceStatus.dwCurrentState )
                {
                case SERVICE_STOPPED :
                case SERVICE_STOP_PENDING :
                    // weirdness
                    break;

                case SERVICE_RUNNING :
                case SERVICE_START_PENDING :
                case SERVICE_CONTINUE_PENDING :
                    // the service is taking its own sweet time.  Keep
                    // looping to give it more time.
                    bKeepLooping = TRUE;
                    break;

                case SERVICE_PAUSE_PENDING :
                case SERVICE_PAUSED :
                    // more weirdness
                    if (!bServiceAlreadyRunning)
                        bStopService = TRUE;
                    break;
                }
            }
            //else quit

            if (!bKeepLooping)
                break;
        }
    }

    if ( bStopService )
    {
        (void) ControlService( hService,
                               SERVICE_CONTROL_STOP,
                               &ServiceStatus );
    }

    if ( Status == WAIT_OBJECT_0 )
        return TRUE;
    else
        return FALSE;
}



//+-------------------------------------------------------------------------
//
// CServerTableEntry::WaitForInitCompleted
//
// Wait for an initializing server (dllhost) to finish initialization.
//
//--------------------------------------------------------------------------
HRESULT
CServerTableEntry::WaitForInitCompleted(
    IN CServerListEntry *pEntry,
    IN CClsidData       *pClsidData
)
{ 
    Win4Assert(pClsidData); // Should NOT call this without registration info.
    if (NULL == pClsidData)
    {
        // If no clsid data, then we'll just need to return the 
        // "I'm initializing still" error code, since we have no
        // way of waiting.  I don't think this should ever happen,
        // though.
        return CO_E_SERVER_INIT_TIMEOUT;
    }

    HANDLE hInitEvent = pClsidData->ServerInitializedEvent();
    if (!hInitEvent)
    {
        return E_OUTOFMEMORY;
    }
    
    HRESULT hr = S_OK;
    if (pEntry->IsInitializing())
    {
        HANDLE hProcess = pEntry->_pServerProcess->GetProcessHandle();

        DWORD dwRet;            
        if (hProcess)
        {
            HANDLE handles[2] = {hInitEvent, hProcess};
            dwRet = WaitForMultipleObjects(2, handles, FALSE, gDllhostInitializationTimeout);
        }
        else
        {
            dwRet = WaitForSingleObject(hInitEvent, gDllhostInitializationTimeout);
        }
        
        if (dwRet == WAIT_TIMEOUT)
        {
            hr = CO_E_SERVER_INIT_TIMEOUT;
        }
        else if (dwRet == WAIT_OBJECT_0)
        {
            hr = S_OK;
        }
        else if (dwRet == WAIT_OBJECT_0+1)
        {
            hr = CO_E_SERVER_STOPPING;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    CloseHandle(hInitEvent);
    
    return hr;
}

//+-------------------------------------------------------------------------
//
// CServerTableEntry::GetServerListWithLock
//
// Returns a pointer to this entry's server list.   Takes shared lock before
// returning.    Caller is expected to call ReleaseSharedListLock to release
// the lock
//
//--------------------------------------------------------------------------
CServerList* CServerTableEntry::GetServerListWithSharedLock()
{
  ServerLock()->LockShared();
  return &_ServerList;
}

//+-------------------------------------------------------------------------
//
// CServerTableEntry::ReleaseSharedListLock
//
//   Releases a shared lock on this entry's list lock.
//
//--------------------------------------------------------------------------
void CServerTableEntry::ReleaseSharedListLock()
{
  ServerLock()->UnlockShared();
}


//
//  CServerTableEntry::SuspendClass
//
//  Turns on the suspended flag for this entry.
// 
void CServerTableEntry::SuspendClass()
{
  ASSERT(!_bSuspendedClsid &&   
         !_bSuspendedApplication &&  
         _EntryType == ENTRY_TYPE_CLASS);

  _bSuspendedClsid = TRUE;  

  SetSuspendOnAllServers(TRUE);
}

//
//  CServerTableEntry::UnsuspendClass
//
//  Turns off the suspended flag for this entry.
// 
void CServerTableEntry::UnsuspendClass()
{
  ASSERT(_bSuspendedClsid &&   
         !_bSuspendedApplication &&
         _EntryType == ENTRY_TYPE_CLASS);

  _bSuspendedClsid = FALSE;  

  SetSuspendOnAllServers(FALSE);
}

//
//  CServerTableEntry::RetireClass
//
//  Retires all currently registered servers for 
//  this clsid.
// 
void CServerTableEntry::RetireClass()
{
  ASSERT(_EntryType == ENTRY_TYPE_CLASS);

  RetireAllServers();
}

//
//  CServerTableEntry::SuspendApplication
//
//  Turns on the suspended flag for this entry.
// 
void CServerTableEntry::SuspendApplication()
{
  ASSERT(!_bSuspendedClsid &&   
         !_bSuspendedApplication && 
		 _EntryType == ENTRY_TYPE_PROCESS);

  _bSuspendedClsid = TRUE;  
}

//
//  CServerTableEntry::UnsuspendApplication
//
//  Turns on the suspended flag for this entry.
// 
void CServerTableEntry::UnsuspendApplication()
{
  ASSERT(!_bSuspendedClsid &&   
         _bSuspendedApplication && 
         _EntryType == ENTRY_TYPE_PROCESS);

  _bSuspendedClsid = FALSE;  
}

//
//  CServerTableEntry::RetireApplication
//
//  Marks as retired all servers registered with
//  this entry.
// 
void CServerTableEntry::RetireApplication()
{
  ASSERT(_EntryType == ENTRY_TYPE_PROCESS);
  
  RetireAllServers();
}

//
//  CServerTableEntry::IsSuspended
//
//  Returns TRUE if servers of this type are 
//  currently suspended, FALSE otherwise.
// 
BOOL CServerTableEntry::IsSuspended()
{
  ASSERT(_EntryType == ENTRY_TYPE_CLASS ||
         _EntryType == ENTRY_TYPE_PROCESS);

  if (_EntryType == ENTRY_TYPE_CLASS)
    return _bSuspendedClsid;
  else
    return _bSuspendedApplication;
}


//
//  CServerTableEntry::SetSuspendOnAllServers
//
//  Sets the suspended bit on all currently registered servers.
// 
void CServerTableEntry::SetSuspendOnAllServers(BOOL bSuspended)
{
  CServerListEntry * pEntry;

  ServerLock()->LockShared();
  
  for (pEntry = (CServerListEntry *) _ServerList.First(); 
       pEntry; 
       pEntry = (CServerListEntry *) pEntry->Next() )
  {
    if (bSuspended)
      pEntry->Suspend();
    else
      pEntry->Unsuspend();
  }

  ServerLock()->UnlockShared();
}

//
//  CServerTableEntry::RetireAllServers
//
//  Marks as retired all currently registered servers.
// 
void CServerTableEntry::RetireAllServers()
{
  CServerListEntry * pEntry;

  ServerLock()->LockShared();
  
  for (pEntry = (CServerListEntry *) _ServerList.First(); 
       pEntry; 
       pEntry = (CServerListEntry *) pEntry->Next() )
  {
    pEntry->Retire();
  }

  ServerLock()->UnlockShared();
}

//
//  CServerTableEntry::SetSuspendedFlagOnNewServer
//
//  Helper function for when a new class factory registration/app 
//  comes along.   If we are currently suspended, then we need to 
//  pass that state on to the new server.   If we're not suspended,
//  then there's nothing to do.
// 
void CServerTableEntry::SetSuspendedFlagOnNewServer(CProcess* pprocess)
{
  if ( (_EntryType == ENTRY_TYPE_CLASS) && _bSuspendedClsid)
  {
    pprocess->Suspend();
  }
  else if ( (_EntryType == ENTRY_TYPE_PROCESS) && _bSuspendedApplication)
  {
    pprocess->Suspend();
  }
}

//+-------------------------------------------------------------------------
//
// SCMRemoveRegistration Version 1: for class entries representing traditional
//      local servers including custom surrogate servers.
//
//  Called from CProcess::RevokeClassRegs() in the resolver.
//
//--------------------------------------------------------------------------


void
SCMRemoveRegistration(
    CProcess *  pProcess,
    GUID &      Guid,
    DWORD       Reg
    )
{
    CServerTableEntry * pClassTableEntry = NULL;

    pClassTableEntry = gpClassTable->Lookup( Guid );

    if ( pClassTableEntry )
    {
        pClassTableEntry->RevokeServer( pProcess, Reg );
        pClassTableEntry->Release();
    }
}





//+-------------------------------------------------------------------------
//
// SCMRemoveRegistration Version 2: for process entries representing
//      new unified surrogate servers.
//
//  Called from CProcess::RevokeClassRegs() in the resolver.
//
//--------------------------------------------------------------------------

void
SCMRemoveRegistration(
    ScmProcessReg  * pScmProcessReg
    )
{
    CServerTableEntry * pProcessTableEntry = NULL;

    pProcessTableEntry = gpProcessTable->Lookup( pScmProcessReg->ProcessGUID );

    if ( pProcessTableEntry )
    {
        pProcessTableEntry->RevokeServer( pScmProcessReg );
        pProcessTableEntry->Release();
    }
}


void
SCMProcessCleanup(
    const CProcess *pProcess
    )
{
#ifndef _CHICAGO_
    CSurrogateListEntry *pSurrogateEntry = gpSurrogateList->Lookup(pProcess);
    if (pSurrogateEntry)
    {
        gpSurrogateList->Remove(pSurrogateEntry);
        pSurrogateEntry->Release();
    }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\olescm\dbgprt.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       dbgprt.hxx
//
//  Contents:   Routines to make printing trace info for debugging easier
//
//  History:    31-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------

#include "act.hxx"

// This file only produces code for the debug version of the SCM

#if DBG == 1

//+-------------------------------------------------------------------------
//
//  Function:   FormatGuid
//
//  Synopsis:   Format a binary guid for display on debugger
//
//  Arguments:  [rguid] - guid to display
//              [pwszGuid] - where to put displayable form
//
//  Returns:    pointer to guid string
//
//  History:    01-May-93 Ricksa    Created
//
//--------------------------------------------------------------------------
WCHAR *FormatGuid(const GUID& rguid, WCHAR *pwszGuid)
{

    wsprintf(pwszGuid, L"%08lX-%04X-%04X-%02X%02X%02X%02X%02X%02X%02X%02X",
        rguid.Data1, rguid.Data2, rguid.Data3, (int) rguid.Data4[0],
        (int) rguid.Data4[1], (int) rguid.Data4[2], (int) rguid.Data4[3],
        (int) rguid.Data4[4], (int) rguid.Data4[5],
        (int) rguid.Data4[6], (int) rguid.Data4[7]);

    return pwszGuid;
}



void DbgPrintFileTime(char *pszDesc, FILETIME *pfiletime)
{
    CairoleDebugOut((DEB_SCM, "%s Low: %04X High: %04X\n",
        pszDesc, pfiletime->dwLowDateTime, pfiletime->dwHighDateTime));
}

void DbgPrintGuid(char *pszDesc, const GUID *pguid)
{
    WCHAR aszGuidStr[48];

    CairoleDebugOut((DEB_SCM, "%s %ws\n", pszDesc,
        FormatGuid(*pguid, &aszGuidStr[0])));
}

void DbgPrintIFD(char *pszDesc, InterfaceData *pifd)
{

    if (pifd != NULL)
    {
        BYTE *pb = &pifd->abData[0];

        CairoleDebugOut((DEB_SCM,
            "%s Addr %04X Len: %04X Data: %02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X\n",
                pszDesc, pifd, pifd->ulCntData, pb[0], pb[1], pb[2], pb[3],
                    pb[4], pb[5], pb[6], pb[7], pb[8], pb[9], pb[10], pb[11]));
    }
    else
    {
        CairoleDebugOut((DEB_SCM, "%s Addr %04X", pszDesc, pifd));
    }
}

void DbgPrintMkIfList(char *pszDesc, MkInterfaceList **ppMkIFList)
{
    CairoleDebugOut((DEB_SCM, "%s Addr: %l04X Count: %04X\n",
        pszDesc, *ppMkIFList, (*ppMkIFList)->dwSize));
}

void DbgPrintMnkEqBuf(char *pszDesc, MNKEQBUF *pmkeqbuf)
{
    GUID *pguid = (GUID *) &pmkeqbuf->abEqData[0];
    WCHAR aszGuidStr[48];

    CairoleDebugOut((DEB_SCM, "%s Addr %04X Len: %04X Clsid: %ws\n",
        pszDesc, pmkeqbuf, pmkeqbuf->cdwSize,
            FormatGuid(*pguid, &aszGuidStr[0])));
}

void DbgPrintRegIn(char *pszDesc, RegInput *pregin)
{
    CairoleDebugOut((DEB_SCM, "%s Count: %04X\n", pszDesc, pregin->dwSize));

    // Loop printing the registrations
    for (DWORD i = 0; i < pregin->dwSize; i++)
    {
        DbgPrintGuid("CLSID: ", &pregin->rginent[i].clsid);
#ifdef DCOM
        ULARGE_INTEGER *puint = (ULARGE_INTEGER *)&pregin->rginent[i].oxid;
        CairoleDebugOut((DEB_SCM, "OXID: %08x %08x\n",
            puint->HighPart, puint->LowPart));
        DbgPrintGuid("IPID: ", &pregin->rginent[i].ipid);
#else
        CairoleDebugOut((DEB_SCM, "EndPoint: %ws\n",
            pregin->rginent[i].pwszEndPoint));
#endif
        CairoleDebugOut((DEB_SCM, "Flags: %04X\n",
            pregin->rginent[i].dwFlags));
    }
}

void DbgPrintRevokeClasses(char *pszDesc, RevokeClasses *prevcls)
{
    CairoleDebugOut((DEB_SCM, "%s Count: %04X\n", pszDesc, prevcls->dwSize));

    // Loop printing the registrations
    for (DWORD i = 0; i < prevcls->dwSize; i++)
    {
        DbgPrintGuid("CLSID: ", &prevcls->revent[i].clsid);
        CairoleDebugOut((DEB_SCM, "Reg: %04X\n",
            prevcls->revent[i].dwReg));
    }
}

void DbgPrintScmRegKey(char *pszDesc, SCMREGKEY *psrkRegister)
{
    CairoleDebugOut((DEB_SCM, "%s EntryLoc: %04X ScmId: %04X\n", pszDesc,
        psrkRegister->dwEntryLoc, psrkRegister->dwScmId));
}


#endif // DBG == 1

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\olescm\actmisc.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       actmisc.cxx
//
//  Contents:   Miscellaneous functions.
//
//  Functions:
//
//  History:
//
//--------------------------------------------------------------------------

#include "act.hxx"

//-------------------------------------------------------------------------
//
// GetSystemDir
//
// Returns the system directory path.
//
// ppwszSystemDir is allocated by this routine and should be freed by the
// caller.
//
//-------------------------------------------------------------------------
HRESULT
GetSystemDir(
    OUT WCHAR ** ppwszSystemDir
    )
{
    DWORD   PathChars;
    WCHAR * pszSystemDir;

    *ppwszSystemDir = 0;

    PathChars = GetSystemDirectory( NULL, 0 );

    if ( ! PathChars )
        return HRESULT_FROM_WIN32( GetLastError() );

    // I don't trust these APIs to include the null.
    PathChars++;

    pszSystemDir = (WCHAR *) PrivMemAlloc( PathChars * sizeof(WCHAR) );

    if ( ! pszSystemDir )
        return E_OUTOFMEMORY;

    PathChars = GetSystemDirectoryW( pszSystemDir, PathChars );

    if ( ! PathChars )
    {
        PrivMemFree( pszSystemDir );
        return HRESULT_FROM_WIN32( GetLastError() );
    }

#if 1 // #ifndef _CHICAGO_
    *ppwszSystemDir = pszSystemDir;
    return S_OK;
#else
    *ppwszSystemDir = (WCHAR *) PrivMemAlloc( PathChars * sizeof(WCHAR) );

    PathChars = MultiByteToWideChar(
                    CP_ACP,
                    0,
                    pszSystemDir,
                    -1,
                    *ppwszSystemDir,
                    PathChars );

    PrivMemFree( pszSystemDir );

    if ( ! PathChars )
    {
        PrivMemFree( *ppwszSystemDir );
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    else
    {
        return S_OK;
    }
#endif
}

HRESULT GetMachineName(
    WCHAR * pwszPath,
    WCHAR   wszMachineName[MAX_COMPUTERNAME_LENGTH+1]
#ifdef DFSACTIVATION
    ,BOOL   bDoDfsConversion
#endif
    )
{
    WCHAR * pwszServerName;
    BYTE    Buffer[sizeof(REMOTE_NAME_INFO)+MAX_PATH*sizeof(WCHAR)];
    DWORD   BufferSize = sizeof(Buffer);
    WCHAR   Drive[4];
    DWORD   Status;

    //
    // Extract the server name from the file's path name.
    //
    if ( pwszPath[0] != L'\\' || pwszPath[1] != L'\\' )
    {
        lstrcpynW(Drive, pwszPath, 3);
        Drive[2] = L'\\';
        Drive[3] = NULL;

        // We must impersonate around the call to GetDriveType as well, 
        // so that we have the same access to the mapped drive as the 
        // calling client.

        if ( RpcImpersonateClient((RPC_BINDING_HANDLE)0) != ERROR_SUCCESS )
            return CO_E_SCM_RPC_FAILURE;

        if (GetDriveType(Drive) != DRIVE_REMOTE )
        {
            RpcRevertToSelf();
            return S_FALSE;
        }

        Status =  ScmWNetGetUniversalName( pwszPath,
                                           UNIVERSAL_NAME_INFO_LEVEL,
                                           Buffer,
                                           &BufferSize );

        RpcRevertToSelf();

        if ( Status != NO_ERROR )
        {
            return CO_E_BAD_PATH;
        }

        pwszPath = ((UNIVERSAL_NAME_INFO *)Buffer)->lpUniversalName;

        if ( ! pwszPath || pwszPath[0] != L'\\' || pwszPath[1] != L'\\' )
        {
            // Must be a local path.
            return S_FALSE;
        }
    }

#ifdef DFSACTIVATION
    WCHAR   wszDfsPath[MAX_PATH];
    WCHAR * pwszDfsPath = wszDfsPath;

    if ( bDoDfsConversion && ghDfs )
    {
        DWORD   DfsPathLen;

        DfsPathLen = sizeof(wszDfsPath);

        for (;;)
        {
            Status = DfsFsctl(
                        ghDfs,
                        FSCTL_DFS_GET_SERVER_NAME,
                        (PVOID) &pwszPath[1],
                        lstrlenW(&pwszPath[1]) * sizeof(WCHAR),
                        (PVOID) pwszDfsPath,
                        &DfsPathLen );

            if ( Status == STATUS_BUFFER_OVERFLOW )
            {
                Win4Assert( pwszDfsPath == wszDfsPath );

                pwszDfsPath = (WCHAR *) PrivMemAlloc( DfsPathLen );
                if ( ! pwszDfsPath )
                    return E_OUTOFMEMORY;
                continue;
            }

            break;
        }

        if ( Status == STATUS_SUCCESS )
            pwszPath = pwszDfsPath;
    }
#endif

    // Skip the "\\".
    LPWSTR pwszTemp = pwszPath + 2;

    pwszServerName = wszMachineName;

    while ( *pwszTemp != L'\\' )
        *pwszServerName++ = *pwszTemp++;
    *pwszServerName = 0;

#ifdef DFSACTIVATION
    if ( pwszDfsPath != wszDfsPath )
        PrivMemFree( pwszDfsPath );
#endif

    return S_OK;
}

HRESULT GetPathForServer(
    WCHAR * pwszPath,
    WCHAR wszPathForServer[MAX_PATH+1],
    WCHAR ** ppwszPathForServer )
{
    BYTE    Buffer[sizeof(REMOTE_NAME_INFO)+MAX_PATH*sizeof(WCHAR)];
    WCHAR   Drive[4];
    DWORD   BufferSize = sizeof(Buffer);
    DWORD   PathLength;
    DWORD   Status;
    UINT    uiDriveType;

    *ppwszPathForServer = 0;

    if ( pwszPath &&
         (lstrlenW(pwszPath) >= 3) &&
         (pwszPath[1] == L':') && (pwszPath[2] == L'\\') )
    {
        lstrcpynW(Drive, pwszPath, 3);
        Drive[2] = L'\\';
        Drive[3] = NULL;

        // We must impersonate around the call to GetDriveType as well, 
        // so that we have the same access to the mapped drive as the 
        // calling client.
        if ( RpcImpersonateClient((RPC_BINDING_HANDLE)0) != ERROR_SUCCESS )
            return CO_E_SCM_RPC_FAILURE;

        uiDriveType = GetDriveType( Drive );

        RpcRevertToSelf();

        switch ( uiDriveType )
        {
        case 0 : // Drive type can not be determined
        case 1 : // The root directory does not exist
        case DRIVE_CDROM :
        case DRIVE_RAMDISK :
        case DRIVE_REMOVABLE :
            //
            // We can't convert these to file names that the server will be
            // able to access.
            //
            return CO_E_BAD_PATH;

        case DRIVE_FIXED :
            if ( 0 == gpMachineName )
            {
                return E_OUTOFMEMORY;
            }
            wszPathForServer[0] = wszPathForServer[1] = L'\\';
            lstrcpyW( &wszPathForServer[2], gpMachineName->Name() );
            PathLength = lstrlenW( wszPathForServer );
            wszPathForServer[PathLength] = L'\\';
            wszPathForServer[PathLength+1] = pwszPath[0];
            wszPathForServer[PathLength+2] = L'$';
            wszPathForServer[PathLength+3] = L'\\';
            lstrcpyW( &wszPathForServer[PathLength+4], &pwszPath[3] );
            *ppwszPathForServer = wszPathForServer;
            break;

        case DRIVE_REMOTE :
            if ( RpcImpersonateClient((RPC_BINDING_HANDLE)0) != ERROR_SUCCESS )
                return CO_E_SCM_RPC_FAILURE;

            Status =  ScmWNetGetUniversalName( pwszPath,
                                               UNIVERSAL_NAME_INFO_LEVEL,
                                               Buffer,
                                               &BufferSize );

            RpcRevertToSelf();

            if ( Status != NO_ERROR )
            {
                return CO_E_BAD_PATH;
            }

            Win4Assert( ((UNIVERSAL_NAME_INFO *)Buffer)->lpUniversalName );

            lstrcpyW( wszPathForServer, ((UNIVERSAL_NAME_INFO *)Buffer)->lpUniversalName );

            *ppwszPathForServer = wszPathForServer;

            Win4Assert( wszPathForServer[0] == L'\\' &&
                        wszPathForServer[1] == L'\\' );
            break;
        }
    }
    else
    {
        *ppwszPathForServer = pwszPath;
    }

    return S_OK;
}


//
// Finds an exe name by looking for the first .exe sub string which
// is followed by any of the given delimiter chars or a null.
//
BOOL
FindExeComponent(
    IN  WCHAR *     pwszString,
    IN  WCHAR *     pwszDelimiters,
    OUT WCHAR **    ppwszStart,
    OUT WCHAR **    ppwszEnd
    )
{
    WCHAR * pwszLast;
    WCHAR * pwszSearch;
    WCHAR   wszStr[4];
    DWORD   Delimiters;

    Delimiters = lstrlenW( pwszDelimiters ) + 1;

    pwszSearch = pwszString;
    pwszLast = pwszSearch + lstrlenW( pwszSearch );

    for ( ; pwszSearch <= (pwszLast - 4); pwszSearch++ )
    {
        if ( pwszSearch[0] != L'.' )
            continue;

        for ( DWORD n = 0; n < Delimiters; n++ )
        {
            if ( pwszDelimiters[n] == pwszSearch[4] )
            {
                // Note that there is no lstrnicmpW, so we use memcpy/lstrcmpiW.

                memcpy( wszStr, &pwszSearch[1], 3 * sizeof(WCHAR) );
                wszStr[3] = 0;

                if ( lstrcmpiW( wszStr, L"exe" ) == 0 )
                    goto FoundExe;
            }
        }
    }

FoundExe:

    if ( pwszSearch > (pwszLast - 4) )
        return FALSE;

    *ppwszEnd = &pwszSearch[4];

    for ( ; pwszSearch != pwszString && pwszSearch[-1] != L'\\'; pwszSearch-- )
        ;

    *ppwszStart = pwszSearch;

    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function:   HexStringToDword
//
//  Synopsis:   Convert a character string hex digits to a DWORD
//
//  Arguments:  [lpsz] - string to convert
//              [Value] - where to put the value
//              [cDigits] - number of digits expected
//              [chDelim] - delimiter for end of string
//
//  Returns:    TRUE - string converted to a DWORD
//              FALSE - string could not be converted
//
//  Algorithm:  For each digit in the string, shift the value and
//              add the value of the digit to the output value. When
//              all the digits are processed, if a delimiter is
//              provided, make sure the last character is the delimiter.
//
//  History:    22-Apr-93 Ricksa    Created
//
//  Notes:      Lifted from CairOLE sources so that SCM will have no
//              dependency on compobj.dll.
//
//--------------------------------------------------------------------------

#if 1 // #ifndef _CHICAGO_
BOOL HexStringToDword(
    LPCWSTR FAR& lpsz,
    DWORD FAR& Value,
    int cDigits,
    WCHAR chDelim)
{
    int Count;

    Value = 0;

    for (Count = 0; Count < cDigits; Count++, lpsz++)
    {
        if (*lpsz >= '0' && *lpsz <= '9')
        {
            Value = (Value << 4) + *lpsz - '0';
        }
        else if (*lpsz >= 'A' && *lpsz <= 'F')
        {
            Value = (Value << 4) + *lpsz - 'A' + 10;
        }
        else if (*lpsz >= 'a' && *lpsz <= 'f')
        {
            Value = (Value << 4) + *lpsz - 'a' + 10;
        }
        else
        {
            return FALSE;
        }
    }

    if (chDelim != 0)
    {
        return *lpsz++ == chDelim;
    }

    return TRUE;
}
#endif

//+-------------------------------------------------------------------------
//
//  Function:   GUIDFromString
//
//  Synopsis:   Convert a string in Registry to a GUID.
//
//  Arguments:  [lpsz] - string from registry
//              [pguid] - where to put the guid.
//
//  Returns:    TRUE - GUID conversion successful
//              FALSE - GUID conversion failed.
//
//  Algorithm:  Convert each part of the GUID string to the
//              appropriate structure member in the guid using
//              HexStringToDword. If all conversions work return
//              TRUE.
//
//  History:    22-Apr-93 Ricksa    Created
//
//  Notes:      Lifted from CairOLE sources so that SCM will have no
//              dependency on compobj.dll.
//
//--------------------------------------------------------------------------

#if 1 // #ifndef _CHICAGO_
BOOL GUIDFromString(LPCWSTR lpsz, LPGUID pguid)
{
    DWORD dw;

    if (*lpsz++ != '{')
    {
        return FALSE;
    }

    if (!HexStringToDword(lpsz, pguid->Data1, sizeof(DWORD)*2, '-'))
    {
        return FALSE;
    }

    if (!HexStringToDword(lpsz, dw, sizeof(WORD)*2, '-'))
    {
        return FALSE;
    }

    pguid->Data2 = (WORD)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(WORD)*2, '-'))
    {
        return FALSE;
    }

    pguid->Data3 = (WORD)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))
    {
        return FALSE;
    }

    pguid->Data4[0] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, '-'))
    {
        return FALSE;
    }

    pguid->Data4[1] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))
    {
        return FALSE;
    }

    pguid->Data4[2] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))
    {
        return FALSE;
    }

    pguid->Data4[3] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))
    {
        return FALSE;
    }

    pguid->Data4[4] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))
    {
        return FALSE;
    }

    pguid->Data4[5] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, 0))
    {
        return FALSE;
    }

    pguid->Data4[6] = (BYTE)dw;

    if (!HexStringToDword(lpsz, dw, sizeof(BYTE)*2, /*(*/ '}'))
    {
        return FALSE;
    }

    pguid->Data4[7] = (BYTE)dw;

    return TRUE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\olescm\dscmif.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995.
//
//  File:
//      dscmif.cxx
//
//  Contents:
//      Entry points for remote activation SCM interface.
//
//  Functions:
//      SCMActivatorGetClassObject
//      SCMActivatorCreateInstance
//
//  History:  SatishT   2/10/98    Rewrote for use with ISCMActivator
//  History:  Vinaykr   3/1/98     Modified To Add Activation Properties,
//                                 SCM Stage handling and Remote handling
//
//--------------------------------------------------------------------------

#include "act.hxx"


// forward defn
HRESULT GetClassInfoFromClsid(REFCLSID rclsid, IComClassInfo **ppClassInfo);

/*********************************************************************/
/** Entry point for local GetClassObject activation requests        **/
/*********************************************************************/
HRESULT SCMActivatorGetClassObject(
    IN  handle_t              hRpc,
    IN  ORPCTHIS            * ORPCthis,
    IN  LOCALTHIS           * LOCALthis,
    OUT ORPCTHAT            * ORPCthat,
    IN  MInterfacePointer   * pInActProperties,
    OUT MInterfacePointer  ** ppOutActProperties
    )
{
    ACTIVATION_PARAMS       ActParams;

    if (ORPCthis == NULL || LOCALthis == NULL || ORPCthat == NULL)
    	return E_INVALIDARG;

    memset(&ActParams, 0, sizeof(ActParams));
    ActParams.MsgType = GETCLASSOBJECT;
    ActParams.hRpc = hRpc;
    ActParams.ORPCthis = ORPCthis;
    ActParams.Localthis = LOCALthis;
    ActParams.ORPCthat = ORPCthat;
    ActParams.oldActivationCall = FALSE;


    return PerformScmStage(CLIENT_MACHINE_STAGE,
                           &ActParams,
                           pInActProperties,
                           ppOutActProperties);
}

/*********************************************************************/
/** Entry point for local CreateInstance activation requests        **/
/*********************************************************************/
HRESULT SCMActivatorCreateInstance(
    IN  handle_t              hRpc,
    IN  ORPCTHIS            * ORPCthis,
    IN  LOCALTHIS           * LOCALthis,
    OUT ORPCTHAT            * ORPCthat,
    IN  MInterfacePointer   * pUnkOuter,
    IN  MInterfacePointer   * pInActProperties,
    OUT MInterfacePointer  ** ppOutActProperties
    )
{
    ACTIVATION_PARAMS       ActParams;

    if (ORPCthis == NULL || LOCALthis == NULL || ORPCthat == NULL)
    	return E_INVALIDARG;

    memset(&ActParams, 0, sizeof(ActParams));
    ActParams.MsgType = CREATEINSTANCE;
    ActParams.hRpc = hRpc;
    ActParams.ORPCthis = ORPCthis;
    ActParams.Localthis = LOCALthis;
    ActParams.ORPCthat = ORPCthat;
    ActParams.oldActivationCall = FALSE;

    return PerformScmStage(CLIENT_MACHINE_STAGE,
                           &ActParams,
                           pInActProperties,
                           ppOutActProperties);
}


/*********************************************************************/
/** Dummy IUnknown functions                                        **/
/*********************************************************************/
HRESULT DummyQueryInterfaceISCMActivator(
    IN  handle_t              rpc,
    IN  ORPCTHIS            * ORPCthis,
    IN  LOCALTHIS           * localthis,
    OUT ORPCTHAT            * ORPCthat,
    IN  DWORD                 dummy
    )
{
    CairoleDebugOut((DEB_ERROR, "SystemActivator Dummy function should never be called!\n"));
    ORPCthat->flags = 0;
    ORPCthat->extensions = NULL;
    return E_FAIL;
}


/*********************************************************************/
/** Dummy IUnknown functions                                        **/
/*********************************************************************/
HRESULT DummyAddRefISCMActivator(
    IN  handle_t              rpc,
    IN  ORPCTHIS            * ORPCthis,
    IN  LOCALTHIS           * LOCALthis,
    OUT ORPCTHAT            * ORPCthat,
    IN  DWORD                 dummy
    )
{
    CairoleDebugOut((DEB_ERROR, "SystemActivator Dummy function should never be called!\n"));
    ORPCthat->flags = 0;
    ORPCthat->extensions = NULL;
    return E_FAIL;
}


/*********************************************************************/
/** Dummy IUnknown functions                                        **/
/*********************************************************************/
HRESULT DummyReleaseISCMActivator(
    IN  handle_t              rpc,
    IN  ORPCTHIS            * ORPCthis,
    IN  LOCALTHIS           * localthis,
    OUT ORPCTHAT            * ORPCthat,
    IN  DWORD                 dummy
    )
{
    CairoleDebugOut((DEB_ERROR, "SystemActivator Dummy function should never be called!\n"));
    ORPCthat->flags = 0;
    ORPCthat->extensions = NULL;
    return E_FAIL;
}


/*
  ActivateFromPropertiesPreamble

  Does various stuff, loads custom activators, delegates.

*/
HRESULT ActivateFromPropertiesPreamble(
ActivationPropertiesIn *pActPropsIn,
IActivationPropertiesOut **ppActOut,
PACTIVATION_PARAMS pActParams
)
{
    HRESULT rethr;
    ILegacyInfo             * pLegacyInfo = NULL;
    InstantiationInfo       * pInstantiationInfo = NULL;
    IServerLocationInfo*      pISLInfo = NULL;
	ISpecialSystemProperties* pISSP = NULL;
    BOOL                      IsGetPersist = FALSE;
    DWORD destCtx;
    IInstanceInfo *pInstanceInfo = NULL;
    BOOL bTookRefOnCProcess = FALSE;
    int nRetries = 0;
    IComClassInfo*	     pComClassInfo = NULL;
     
    *ppActOut = NULL;

    // Fill up ActParams for Generic Activation Path
    pActParams->pAuthInfo = NULL;

    rethr = pActPropsIn->QueryInterface(IID_IScmRequestInfo, (LPVOID*)&pActParams->pInScmResolverInfo);
    if (FAILED(rethr))
        goto exit_Activation;

    rethr = pActPropsIn->QueryInterface(IID_ILegacyInfo, (LPVOID*)&pLegacyInfo);

    if (FAILED(rethr))
        goto exit_Activation;

    pInstantiationInfo = pActPropsIn->GetInstantiationInfo();
    ASSERT(pInstantiationInfo != NULL);

    pActParams->pInstantiationInfo = pInstantiationInfo;

    if (pActParams->RemoteActivation)
    {
        pActParams->ProcessSignature = 0;
        pActParams->pEnvBlock = NULL;
        pActParams->pwszWinstaDesktop = NULL;
        pActParams->Apartment = FALSE;
        pActParams->pAuthInfo = 0;
        pActParams->pwszServer = NULL;
    }
    else
    {
        PRIV_SCM_INFO *pPrivScmInfo;

        rethr = pActParams->pInScmResolverInfo->GetScmInfo(&pPrivScmInfo);
        ASSERT(SUCCEEDED(rethr));
        if (FAILED(rethr))
            goto exit_Activation;
        CheckLocalCall( pActParams->hRpc );
        pActParams->RemoteActivation = FALSE;
        pActParams->ProcessSignature = (PVOID)pPrivScmInfo->ProcessSignature;
        pActParams->pEnvBlock = pPrivScmInfo->pEnvBlock;
        pActParams->EnvBlockLength = pPrivScmInfo->EnvBlockLength;
        pActParams->pwszWinstaDesktop = pPrivScmInfo->pwszWinstaDesktop;
        pActParams->Apartment = pPrivScmInfo->Apartment;
        COSERVERINFO *pServerInfo;
        rethr = pLegacyInfo->GetCOSERVERINFO(&pServerInfo);
        ASSERT(SUCCEEDED(rethr));
        if (FAILED(rethr))
            goto exit_Activation;
        if (pServerInfo)
        {

            rethr = CopyAuthInfo(pServerInfo->pAuthInfo, &pActParams->pAuthInfo);
            SecurityInfo::freeCOAUTHINFO(pServerInfo->pAuthInfo);
            pServerInfo->pAuthInfo = NULL;

            if (FAILED(rethr))
                goto exit_Activation;
        }
    }

    pActParams->pProcess = 0;
    pActParams->pToken = 0;
    
    // Make sure process request info is set to defaults before calling any custom activators
    if (pActPropsIn->QueryInterface(IID_IServerLocationInfo, (void**)&pISLInfo) == S_OK)
    {
      HRESULT hr;
      hr = pISLInfo->SetProcess(0, PRT_IGNORE);
      Win4Assert(hr == S_OK);
      pISLInfo->Release();
    }

    // Remember if client was impersonating or not
    if (pActPropsIn->QueryInterface(IID_ISpecialSystemProperties, (void**)&pISSP) == S_OK)
    {
      HRESULT hr;
      hr = pISSP->GetClientImpersonating(&pActParams->bClientImpersonating);
      Win4Assert(hr == S_OK);
      pISSP->Release();
    }

    // QI will only work if persistent activation is happening
    if (pActPropsIn->QueryInterface(IID_IInstanceInfo,
                                    (LPVOID*)&pInstanceInfo) == S_OK)

    {
        pActParams->pInstanceInfo = pInstanceInfo;

        // The only case where msgtype will already be GETPERSISTENTINSTANCE
        // is during an incoming nt4 client remote activation(see remactif)
        if (pActParams->MsgType == CREATEINSTANCE)
        {
            pActParams->MsgType = GETPERSISTENTINSTANCE;
            WCHAR *pwszObjectName;
            pInstanceInfo->GetFile(&pwszObjectName, &pActParams->Mode);
            if (pActParams->RemoteActivation)
            {
                WCHAR *pwszObjectName2;
                rethr = GetServerPath( pwszObjectName, &pwszObjectName2 );
                if (pwszObjectName != pwszObjectName2)
                {
                    pInstanceInfo->SetFile(pwszObjectName2, pActParams->Mode);
                    pInstanceInfo->GetFile(&pActParams->pwszPath, &pActParams->Mode);
                    MIDL_user_free(pwszObjectName2);
                }
            }
            else
            {
                pActParams->pwszPath = pwszObjectName;
            }

            if ( FAILED(rethr) )
              goto exit_Activation;

            pInstanceInfo->GetStorageIFD(&pActParams->pIFDStorage);
            IsGetPersist = TRUE;
        }

        Win4Assert(pActParams->MsgType == GETPERSISTENTINSTANCE);
    }
    else
    {
        Win4Assert(pActParams->MsgType != GETPERSISTENTINSTANCE);
        if (pActParams->MsgType == GETCLASSOBJECT)
            pActParams->Mode = MODE_GET_CLASS_OBJECT;

#ifdef DFSACTIVATION
        pActParams->FileWasOpened = FALSE;
#endif
    }

    rethr = pInstantiationInfo->GetClsid(&pActParams->Clsid);

    if (pActParams->RemoteActivation)
        pActParams->ClsContext = CLSCTX_LOCAL_SERVER;
    else
        rethr = pInstantiationInfo->GetClsctx(&pActParams->ClsContext);

    ASSERT(!FAILED(rethr));

    rethr = pInstantiationInfo->GetRequestedIIDs(
                            &pActParams->Interfaces,
                            &pActParams->pIIDs);

    /* only one requested interface allowed for GetClassObject */
    if ((pActParams->MsgType == GETCLASSOBJECT) &&
         (pActParams->Interfaces != 1))
    {
        rethr = E_INVALIDARG;
        goto exit_Activation;
    }

    pActParams->UnsecureActivation = FALSE;
    pActParams->ORPCthis->flags = ORPCF_LOCAL;
    pActParams->Localthis->dwFlags = LOCALF_NONE;
    pActParams->ORPCthat->flags = 0;
    pActParams->ORPCthat->extensions = NULL;

    //
    // Get a CProcess for local callers.
    //
    if ( ! pActParams->RemoteActivation )
    {
        //
        // A local activation passes the "magic" signature from CRpcResolver.
        // Because ORPC calls cannot have context handles, the signature
        // is just a pointer to the process object.
        //
        pActParams->pProcess = ReferenceProcess( pActParams->ProcessSignature,
                                                 TRUE );

        if ( ! pActParams->pProcess )
        {
            rethr = E_ACCESSDENIED;
            goto exit_Activation;
        }
        bTookRefOnCProcess = TRUE;
    }

    //
    // Get a CToken for all callers.
    //
    RPC_STATUS          Status;
    Status = LookupOrCreateToken( pActParams->hRpc,
                                  FALSE,
                                  &pActParams->pToken );

    //
    // ERROR_ACCESS_DENIED is returned if RpcImpersonateClient fails.
    // We will take this to mean that the remote activation is coming
    // in unsecure.  In this case we have no Token object and must do
    // permission checks manually.  We set the winsta/desktop to an
    // empty string to distinguish this case during some ROT lookups.
    //
    // Unsecure remote clients can only connect to services or RunAs
    // servers.
    //
    if ( Status == ERROR_ACCESS_DENIED )
    {
        pActParams->pToken = 0;
        pActParams->pwszWinstaDesktop = L"";
        pActParams->UnsecureActivation = TRUE;
        Status = RPC_S_OK;
    }

    if ( Status != RPC_S_OK )
    {
        rethr = HRESULT_FROM_WIN32(Status);
        goto exit_Activation;
    }

    // Look up the (per-user) classinfo here before 
    // the partition activators run.  
    if (pActParams->pToken)
    {
        pActPropsIn->SetClientToken(pActParams->pToken->GetToken());
        if (!(pActParams->ClsContext & CLSCTX_INPROC_SERVER)) 
        {
            rethr = gpCatalogSCM->GetClassInfo ( pActParams->ClsContext,
                pActParams->pToken,
                pActParams->Clsid,
                IID_IComClassInfo,
                (void**) &pComClassInfo );            
        }
    }
    else
        rethr = gpCatalog->GetClassInfo ( pActParams->Clsid,
                                          IID_IComClassInfo,
                                          (void**) &pComClassInfo );
		
    // catalog will return S_FALSE if the class is not
    // registered. 
    if ( pComClassInfo == NULL || rethr != S_OK )
        rethr = REGDB_E_CLASSNOTREG;

    // Careful here:   the lookup above may have failed registration info
    // for a local server activation, but we need to keep going since the 
    // activation may still end up being sent to a remote machine.
    if (FAILED(rethr) && rethr != REGDB_E_CLASSNOTREG) 
        goto exit_Activation;

    if (pComClassInfo) 
    {
        pActPropsIn->SetClassInfo(pComClassInfo);
        pComClassInfo->Release();pComClassInfo=NULL;
    }
    
    // Set Activation Params "Local Blob"
    pActPropsIn->SetLocalBlob((void*)pActParams);
    pActParams->pActPropsIn = pActPropsIn;

RETRY_ACTIVATION:    
    //
    // Set the stage.  For now, all scm-level activators must be 
    //   SERVER_MACHINE_STAGE activators, since more work needs to be
    //   done to properly define the semantic/other differences 
    //   between "client" and "server" scm activators.
    //   
    rethr = pActPropsIn->SetStageAndIndex(SERVER_MACHINE_STAGE, 0);
    if (FAILED (rethr)) goto exit_Activation;

    //  Delegate onwards....
    if (pActParams->MsgType == GETCLASSOBJECT)
        rethr = pActPropsIn->DelegateGetClassObject(ppActOut);
    else
        rethr = pActPropsIn->DelegateCreateInstance(NULL, ppActOut);
    
    // Sajia - support for partitions
    // If the delegated activation returns ERROR_RETRY,
    // we walk the chain again, but AT MOST ONCE.
    if (ERROR_RETRY == rethr) {
       Win4Assert(!nRetries);
       if (!nRetries)
       {
	  nRetries++;
	  goto RETRY_ACTIVATION;
       }
    }
    
exit_Activation:

    if (IsGetPersist)
    {
        if ( pActParams->pIFDROT )
            MIDL_user_free( pActParams->pIFDROT );
    }

    if (pActParams->pInScmResolverInfo)
        pActParams->pInScmResolverInfo->Release();
    if (pLegacyInfo)
        pLegacyInfo->Release();
    if (pActParams->pInstanceInfo)
        pActParams->pInstanceInfo->Release();
    if (pActParams->pAuthInfo)
        FreeAuthInfo(pActParams->pAuthInfo);
    if (pActParams->pToken)
    	pActParams->pToken->Release();
    if (bTookRefOnCProcess)
    {
       ASSERT(pActParams->pProcess);
       ReleaseProcess(pActParams->pProcess);
    }
    if (pComClassInfo) 
    {
       pComClassInfo->Release();
    }
    return rethr;
}



#if DBG == 1
LONG ActivationExceptionFilter( DWORD lCode,
                               LPEXCEPTION_POINTERS lpep )
{
    Win4Assert(NULL && "Unexpected exception thrown");
    return TRUE;
}
#endif

/*********************************************************************/
/** Real Work of SCM Activation begins here After Custom Activators **/
/** have been called. This will be called during all activations    **/
/** occuring in the SCM, local and remote                           **/
/*********************************************************************/
HRESULT ActivateFromProperties(
IActivationPropertiesIn *pActIn,
IActivationPropertiesOut **ppActOut
)
{
    HRESULT rethr;
    REMOTE_REQUEST_SCM_INFO * pScmRequestInfo=NULL;
    IScmReplyInfo           * pOutScmResolverInfo = NULL;
    DWORD destCtx;
    REMOTE_REPLY_SCM_INFO *pScmReplyInfo=NULL;
    PRIV_RESOLVER_INFO *pPrivActOutInfo=NULL;
    ActivationPropertiesIn *pActPropsIn=NULL;
    WCHAR *             pwszDummy;

    *ppActOut = NULL;

    // Get Activation Params "Local Blob"
    rethr = pActIn->QueryInterface(CLSID_ActivationPropertiesIn, (void**)&pActPropsIn);
    PACTIVATION_PARAMS pActParams;
    pActPropsIn->GetLocalBlob((void**)&pActParams);
    Win4Assert(pActParams != NULL);

    // This could have already been set in the lb rerouting case
    pActParams->activatedRemote = FALSE;


    if (pActParams->RemoteActivation)
    {
        Win4Assert(pActParams->pInScmResolverInfo);
        rethr = pActParams->pInScmResolverInfo->GetRemoteRequestInfo(&pScmRequestInfo);
        if (pScmRequestInfo == NULL)
        {
            if (SUCCEEDED(rethr))
                rethr = E_FAIL;
            goto exit_Activation;
        }

        pScmReplyInfo = (REMOTE_REPLY_SCM_INFO*)
                          MIDL_user_allocate(sizeof(REMOTE_REPLY_SCM_INFO));

        if (pScmReplyInfo == NULL)
        {
            rethr = E_OUTOFMEMORY;
            goto exit_Activation;
        }

        memset(pScmReplyInfo, 0, sizeof(REMOTE_REPLY_SCM_INFO));

        pActParams->pOxidServer = &pScmReplyInfo->Oxid;

        //
        // The following OR fields are not used while servicing a
        // remote activation.
        //
        pActParams->ppServerORBindings = (DUALSTRINGARRAY **)NULL;
        pActParams->pOxidInfo = NULL;
        pActParams->pLocalMidOfRemote = NULL;
        pActParams->pDllServerModel = NULL;
        pActParams->ppwszDllServer = &pwszDummy;
    }
    else
    {
        pPrivActOutInfo = (PRIV_RESOLVER_INFO*)
                               MIDL_user_allocate(sizeof(PRIV_RESOLVER_INFO));

        if (pPrivActOutInfo == NULL)
        {
            rethr = E_OUTOFMEMORY;
            goto exit_Activation;
        }

        memset(pPrivActOutInfo, 0, sizeof(PRIV_RESOLVER_INFO));

        pActParams->pFoundInROT = &pPrivActOutInfo->FoundInROT;
        pActParams->pOxidServer = &pPrivActOutInfo->OxidServer;
        pActParams->ppServerORBindings = &pPrivActOutInfo->pServerORBindings;
        *pActParams->ppServerORBindings = 0;
        pActParams->pOxidInfo = &pPrivActOutInfo->OxidInfo;
        pActParams->pOxidInfo->psa = 0;
        pActParams->pLocalMidOfRemote = &pPrivActOutInfo->LocalMidOfRemote;
        pActParams->pDllServerModel = &pPrivActOutInfo->DllServerModel;
        pActParams->ppwszDllServer = &pPrivActOutInfo->pwszDllServer;
    }

    {
        IServerLocationInfo *pServerLocationInfo = NULL;
        pServerLocationInfo = pActPropsIn->GetServerLocationInfo();
        Win4Assert(pServerLocationInfo != NULL);
        pServerLocationInfo->GetRemoteServerName(&pActParams->pwszServer);
    }

    pActPropsIn->GetClassInfo(IID_IComClassInfo, (void**)&pActParams->pComClassInfo);
    pActParams->ProtseqId = 0;
    *pActParams->pOxidServer = 0;
    *pActParams->ppwszDllServer = 0;

    RpcTryExcept
    {
        // Generic SCM Activation Path
        rethr = Activation( pActParams );
    }

#if DBG == 1
    RpcExcept(ActivationExceptionFilter(GetExceptionCode(),
                                        GetExceptionInformation()) )
#else
    RpcExcept(TRUE)
#endif
    {
        rethr = HRESULT_FROM_WIN32(RpcExceptionCode());
    }

    RpcEndExcept

    if (rethr != S_OK)
        goto exit_ActWithoutResolvingInfo;


    if (pActParams->activatedRemote)
    {
        // if did remote activation for an incoming one
        // just exit
        if (pActParams->RemoteActivation)
        {
            *ppActOut = pActParams->pActPropsOut;
            goto exit_ActWithoutResolvingInfo;
        }

        if(!pActParams->IsLocalOxid)
        {
            //Set Tid/Pid to 0 for remote server
            Win4Assert(pActParams->pOxidInfo);
            pActParams->pOxidInfo->dwTid = 0;
            pActParams->pOxidInfo->dwPid = 0;
        }
    }

    ActivationPropertiesOut *pActPropsOut;

    pActPropsOut = pActParams->pActPropsOut;

    if (pActPropsOut == NULL)
    {
        rethr = pActPropsIn->GetReturnActivationProperties(&pActPropsOut);

        if (FAILED(rethr))
            goto exit_ActWithoutResolvingInfo;


        rethr = pActPropsOut->SetMarshalledResults(pActParams->Interfaces,
                                                pActParams->pIIDs,
                                                pActParams->pResults,
                                                pActParams->ppIFD);
        MIDL_user_free(pActParams->pIIDs);
        MIDL_user_free(pActParams->pResults);
        MIDL_user_free(pActParams->ppIFD);

        if (FAILED(rethr))
            goto exit_ActWithoutResolvingInfo;

        pActParams->pActPropsOut = pActPropsOut;
    }


    rethr = pActPropsOut->QueryInterface(
                            IID_IScmReplyInfo,
                            (LPVOID*)&pOutScmResolverInfo
                            );

    if (FAILED(rethr))
        goto exit_ActWithoutResolvingInfo;

    if (pActParams->RemoteActivation)
    {
        RPC_STATUS          sc;
        if (*pActParams->pOxidServer != 0)
        {
            sc = _ResolveOxid2(pActParams->hRpc,
                       pActParams->pOxidServer,
                       pScmRequestInfo->cRequestedProtseqs,
                       pScmRequestInfo->pRequestedProtseqs,
                       &pScmReplyInfo->pdsaOxidBindings,
                       &pScmReplyInfo->ipidRemUnknown,
                       &pScmReplyInfo->authnHint,
                       &pScmReplyInfo->serverVersion );
            rethr = HRESULT_FROM_WIN32(sc);
        }
        pOutScmResolverInfo->SetRemoteReplyInfo(pScmReplyInfo);
    }
    else
        pOutScmResolverInfo->SetResolverInfo(pPrivActOutInfo);

    pOutScmResolverInfo->Release();

    *ppActOut = pActPropsOut;


exit_Activation:
    if (pActParams->pComClassInfo) 
    {
       pActParams->pComClassInfo->Release();
    }
    return rethr;

// Go here if ActivationPropertiesOut is not created
exit_ActWithoutResolvingInfo:
    MIDL_user_free(pScmReplyInfo);
    MIDL_user_free(pPrivActOutInfo);
    goto exit_Activation;
}

//
//   GetClassInfoFromClsid
//
//   On success, returns a IComClassInfo for the requested class
//
//   FUTURE:  this function is basically a duplicate of one linked into 
//     ole32.   We should find a way to centralize all of this catalog
//     stuff and do away with this funky "this function is just here to 
//     satisfy the linker" crud.
//
HRESULT GetClassInfoFromClsid(REFCLSID rclsid, IComClassInfo **ppClassInfo)
{
    HRESULT hr = InitializeCatalogIfNecessary();
    if ( FAILED(hr) )
    {
        return hr;
    }
    else
    {
        // get the information object for the requested class
        // this may translate the CLSID via TreatAs and other mappings
        hr = gpCatalog->GetClassInfo(rclsid, IID_IComClassInfo, (void**)ppClassInfo);
    }
    return hr;
}

//This should never be called. It is mainly to link with actprops which
//uses it to load persistent objects and should only do so in a server.
HRESULT LoadPersistentObject(IUnknown *punk, IInstanceInfo *pInstanceInfo)
{
    return E_NOTIMPL;
}

//This should never be called. It is mainly to link with actprops which
//uses it for marshalling of returns
void *GetDestCtxPtr(COMVERSION *pComVersion)
{
    return NULL;
}

//
// These should never be called. It is mainly to link with actprops which
// uses it creating contexts
//

HRESULT CObjectContextCF_CreateInstance(IUnknown *pUnkOuter,
                                        REFIID riid,
                                        void** ppv)
{
    return E_NOTIMPL;
}

HRESULT CObjectContext::QueryInterface(REFIID riid, void **ppv)
{
    return E_NOTIMPL;
}

ULONG CObjectContext::AddRef()
{
    return E_NOTIMPL;
}

ULONG CObjectContext::Release()
{
    return E_NOTIMPL;
}

HRESULT CObjectContext::InternalQueryInterface(REFIID riid, void **ppv)
{
    return E_NOTIMPL;
}

ULONG CObjectContext::InternalAddRef()
{
    return E_NOTIMPL;
}

ULONG CObjectContext::InternalRelease()
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\olescm\events.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       events.cxx
//
//  Contents:
//
//  History:    ?-??-??   ???       Created
//              6-17-99   a-sergiv  Added event filtering
//
//--------------------------------------------------------------------------

#include "act.hxx"

BOOL
GetTextualSid(
    PSID pSid,          // binary Sid
    LPTSTR TextualSid,  // buffer for Textual representaion of Sid
    LPDWORD cchSidSize  // required/provided TextualSid buffersize
    )
{
    PSID_IDENTIFIER_AUTHORITY psia;
    DWORD dwSubAuthorities;
    DWORD dwCounter;
    DWORD cchSidCopy;

    //
    // test if Sid passed in is valid
    //
    if(!IsValidSid(pSid)) return FALSE;

    // obtain SidIdentifierAuthority
    psia = GetSidIdentifierAuthority(pSid);

    // obtain sidsubauthority count
    dwSubAuthorities = *GetSidSubAuthorityCount(pSid);

    //
    // compute approximate buffer length
    // S-SID_REVISION- + identifierauthority- + subauthorities- + NULL
    //
    cchSidCopy = (15 + 12 + (12 * dwSubAuthorities) + 1) * sizeof(TCHAR);

    //
    // check provided buffer length.
    // If not large enough, indicate proper size and setlasterror
    //
    if(*cchSidSize < cchSidCopy) {
        *cchSidSize = cchSidCopy;
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    //
    // prepare S-SID_REVISION-
    //
    cchSidCopy = wsprintf(TextualSid, TEXT("S-%lu-"), SID_REVISION );

    //
    // prepare SidIdentifierAuthority
    //
    if ( (psia->Value[0] != 0) || (psia->Value[1] != 0) ) {
        cchSidCopy += wsprintf(TextualSid + cchSidCopy,
                    TEXT("0x%02hx%02hx%02hx%02hx%02hx%02hx"),
                    (USHORT)psia->Value[0],
                    (USHORT)psia->Value[1],
                    (USHORT)psia->Value[2],
                    (USHORT)psia->Value[3],
                    (USHORT)psia->Value[4],
                    (USHORT)psia->Value[5]);
    } else {
        cchSidCopy += wsprintf(TextualSid + cchSidCopy,
                    TEXT("%lu"),
                    (ULONG)(psia->Value[5]      )   +
                    (ULONG)(psia->Value[4] <<  8)   +
                    (ULONG)(psia->Value[3] << 16)   +
                    (ULONG)(psia->Value[2] << 24)   );
    }

    //
    // loop through SidSubAuthorities
    //
    for(dwCounter = 0 ; dwCounter < dwSubAuthorities ; dwCounter++) {
        cchSidCopy += wsprintf(TextualSid + cchSidCopy, TEXT("-%lu"),
                    *GetSidSubAuthority(pSid, dwCounter) );
    }

    //
    // tell the caller how many chars we provided, not including NULL
    //
    *cchSidSize = cchSidCopy;

    return TRUE;
}
void
LogRegisterTimeout(
    GUID *      pClsid,
    DWORD       clsctx,
    CToken *    pClientToken
    )
{
    // Apply event filters
    DWORD dwActLogLvl = GetActivationFailureLoggingLevel();
    if(dwActLogLvl == 2)
        return;
    if(dwActLogLvl != 1 && clsctx & CLSCTX_NO_FAILURE_LOG)
        return;

    // %1 is the clsid
    HANDLE  LogHandle;
    LPWSTR  Strings[1]; // array of message strings.
    WCHAR   wszClsid[GUIDSTR_MAX];

    // Get the clsid
    wStringFromGUID2( *pClsid, wszClsid, sizeof(wszClsid) );
    Strings[0] = wszClsid;

    // Get the log handle, then report then event.
    LogHandle = RegisterEventSource( NULL,
                                      SCM_EVENT_SOURCE );

    if ( LogHandle )
    {
        ReportEvent( LogHandle,
                     EVENTLOG_ERROR_TYPE,
                     0,             // event category
                     EVENT_RPCSS_SERVER_START_TIMEOUT,
                     pClientToken ? pClientToken->GetSid() : NULL, // SID
                     1,             // 1 strings passed
                     0,             // 0 bytes of binary
                     (LPCTSTR *)Strings, // array of strings
                     NULL );        // no raw data

        // clean up the event log handle
        DeregisterEventSource(LogHandle);
    }

}

void
LogServerStartError(
    GUID *      pClsid,
    DWORD       clsctx,
    CToken *    pClientToken,
    WCHAR *     pwszCommandLine
    )
{
    // Apply event filters
    DWORD dwActLogLvl = GetActivationFailureLoggingLevel();
    if(dwActLogLvl == 2)
        return;
    if(dwActLogLvl != 1 && clsctx & CLSCTX_NO_FAILURE_LOG)
        return;

    HANDLE  LogHandle;
    LPWSTR  Strings[3]; // array of message strings.
    WCHAR   wszErrnum[20];
    WCHAR   wszClsid[GUIDSTR_MAX];

    // Save the command line
    Strings[0] = pwszCommandLine;

    // Save the error number
    wsprintf(wszErrnum, L"%lu",GetLastError() );
    Strings[1] = wszErrnum;

    // Get the clsid
    wStringFromGUID2( *pClsid, wszClsid, sizeof(wszClsid) );
    Strings[2] = wszClsid;

    // Get the log handle, then report then event.
    LogHandle = RegisterEventSource( NULL,
                                      SCM_EVENT_SOURCE );

    if ( LogHandle )
    {
        ReportEvent( LogHandle,
                     EVENTLOG_ERROR_TYPE,
                     0,             // event category
                     EVENT_RPCSS_CREATEPROCESS_FAILURE,
                     pClientToken->GetSid(), // SID
                     3,             // 3 strings passed
                     0,             // 0 bytes of binary
                     (LPCTSTR *)Strings, // array of strings
                     NULL );        // no raw data

        // clean up the event log handle
        DeregisterEventSource(LogHandle);
    }
}

void
LogRunAsServerStartError(
    GUID *      pClsid,
    DWORD       clsctx,
    CToken *    pClientToken,
    WCHAR *     pwszCommandLine,
    WCHAR *     pwszRunAsUser,
    WCHAR *     pwszRunAsDomain
    )
{
    // Apply event filters
    DWORD dwActLogLvl = GetActivationFailureLoggingLevel();
    if(dwActLogLvl == 2)
        return;
    if(dwActLogLvl != 1 && clsctx & CLSCTX_NO_FAILURE_LOG)
        return;

    HANDLE  LogHandle;
    LPWSTR  Strings[5];
    WCHAR   wszErrnum[20];
    WCHAR   wszClsid[GUIDSTR_MAX];

    // for this message,
    // %1 is the command line, and %2 is the error number string
    // %3 is the CLSID, %4 is the RunAs domain name, %5 is the RunAs Userid

    // Save the command line
    Strings[0] = pwszCommandLine;

    // Save the error number
    wsprintf(wszErrnum, L"%lu",GetLastError() );
    Strings[1] = wszErrnum;

    // Get the clsid
    wStringFromGUID2(*pClsid, wszClsid, sizeof(wszClsid));
    Strings[2] = wszClsid;

    // Put in the RunAs identity
    Strings[3] = pwszRunAsDomain;
    Strings[4] = pwszRunAsUser;

    // Get the log handle, then report then event.
    LogHandle = RegisterEventSource( NULL,
                                      SCM_EVENT_SOURCE );

    if ( LogHandle )
        {
        ReportEvent( LogHandle,
                     EVENTLOG_ERROR_TYPE,
                     0,             // event category
                     EVENT_RPCSS_RUNAS_CREATEPROCESS_FAILURE,
                     pClientToken ? pClientToken->GetSid() : NULL, // SID
                     5,             // 5 strings passed
                     0,             // 0 bytes of binary
                     (LPCTSTR *)Strings, // array of strings
                     NULL );        // no raw data

        // clean up the event log handle
        DeregisterEventSource(LogHandle);
        }
}

void
LogServiceStartError(
    GUID *      pClsid,
    DWORD       clsctx,
    CToken *    pClientToken,
    WCHAR *     pwszServiceName,
    WCHAR *     pwszServiceArgs,
    DWORD       err
    )
{
    // Apply event filters
    DWORD dwActLogLvl = GetActivationFailureLoggingLevel();
    if(dwActLogLvl == 2)
        return;
    if(dwActLogLvl != 1 && clsctx & CLSCTX_NO_FAILURE_LOG)
        return;

    HANDLE  LogHandle;
    LPWSTR  Strings[4];
    WCHAR   wszClsid[GUIDSTR_MAX];
    WCHAR   wszErrnum[20];

    // %1 is the error number
    // %2 is the service name
    // %3 is the serviceargs
    // %4 is the clsid

    // Save the error number
    wsprintf(wszErrnum, L"%lu",err );
    Strings[0] = wszErrnum;

    Strings[1] = pwszServiceName;
    Strings[2] = pwszServiceArgs;

    // Get the clsid
    wStringFromGUID2(*pClsid, wszClsid, sizeof(wszClsid));
    Strings[3] = wszClsid;

    // Get the log handle, then report then event.
    LogHandle = RegisterEventSource( NULL,
                                      SCM_EVENT_SOURCE );

    if ( LogHandle )
    {
        ReportEvent( LogHandle,
                     EVENTLOG_ERROR_TYPE,
                     0,             // event category
                     EVENT_RPCSS_START_SERVICE_FAILURE,
                     pClientToken ? pClientToken->GetSid() : NULL, // SID
                     4,             // 4 strings passed
                     0,             // 0 bytes of binary
                     (LPCTSTR *)Strings, // array of strings
                     NULL );        // no raw data

        // clean up the event log handle
        DeregisterEventSource(LogHandle);
    }
}


void
LogLaunchAccessFailed(
    GUID *      pClsid,
    DWORD       clsctx,
    CToken *    pClientToken,
    BOOL        bDefaultLaunchPermission
    )
{
    // Apply event filters
    DWORD dwActLogLvl = GetActivationFailureLoggingLevel();
    if(dwActLogLvl == 2)
        return;
    if(dwActLogLvl != 1 && clsctx & CLSCTX_NO_FAILURE_LOG)
        return;

    HANDLE  LogHandle;
    LPWSTR  Strings[4];
    PSID    pSid = pClientToken ? pClientToken->GetSid() : NULL;
    WCHAR   wszClsid[GUIDSTR_MAX];

    // for this message, %1 is the clsid
    //                   %2 is username
    //                   %3 is domainname
    //                   %4 is textual SID


    ///////////////////////////////////////////////////
    //
    // Get the clsid
    //

    wStringFromGUID2(*pClsid, wszClsid, sizeof(wszClsid));
    Strings[0] = wszClsid;

    ///////////////////////////////////////////////////
    //
    // Get the user name, domain name
    //

#define NAMELEN 256

    DWORD unamelen = NAMELEN;
    DWORD dnamelen = NAMELEN;
    SID_NAME_USE sidNameUse;
    WCHAR username[NAMELEN] = L"Unavailable";
    WCHAR domainname[NAMELEN] = L"Unavailable";

    Strings[1] = username;
    Strings[2] = domainname;

    if (pSid != NULL)
    {
        LookupAccountSid (NULL, pSid, 
                          username, &unamelen, 
                          domainname, &dnamelen,
                          &sidNameUse);
    }
    

    ///////////////////////////////////////////////////
    //
    // Get SID as text
    //

    BOOL worked = FALSE;
    DWORD sidLen = NAMELEN;
    WCHAR sidAsText[NAMELEN];

    if (pSid != NULL)
    {
        worked = GetTextualSid (pSid, sidAsText, &sidLen);
    }        
    
    Strings[3] = worked ? sidAsText : L"Unavailable";        
    

    // Get the log handle, then report then event.
    LogHandle = RegisterEventSource( NULL,
                                      SCM_EVENT_SOURCE );

    if ( LogHandle )
    {
        ReportEvent( LogHandle,
                     EVENTLOG_ERROR_TYPE,
                     0,             // event category
                     bDefaultLaunchPermission ? EVENT_RPCSS_DEFAULT_LAUNCH_ACCESS_DENIED : EVENT_RPCSS_LAUNCH_ACCESS_DENIED,
                     pClientToken ? pClientToken->GetSid() : NULL, // SID
                     4,             // 1 strings passed
                     0,             // 0 bytes of binary
                     (LPCTSTR *)Strings, // array of strings
                     NULL );        // no raw data

        // clean up the event log handle
        DeregisterEventSource(LogHandle);
    }
}


void
LogRemoteSideUnavailable(
    DWORD   clsctx,
    WCHAR * pwszServerName )
{
    // Apply event filters
    DWORD dwActLogLvl = GetActivationFailureLoggingLevel();
    if(dwActLogLvl == 2)
        return;
    if(dwActLogLvl != 1 && clsctx & CLSCTX_NO_FAILURE_LOG)
        return;

    HANDLE      LogHandle;
    LPWSTR      Strings[1];
    CToken *    pToken;
    RPC_STATUS  Status;

    // %1 is the remote machine name

    Strings[0] = pwszServerName;

    // Get the log handle, then report then event.
    LogHandle = RegisterEventSource( NULL, SCM_EVENT_SOURCE );

    if ( ! LogHandle )
        return;

    Status = LookupOrCreateToken( NULL, FALSE, &pToken );

    if ( Status != RPC_S_OK )
        return;

    ReportEvent( LogHandle,
                 EVENTLOG_ERROR_TYPE,
                 0,             // event category
                 EVENT_RPCSS_REMOTE_SIDE_UNAVAILABLE,
                 pToken->GetSid(),
                 1,             // 1 strings passed
                 0,             // 0 bytes of binary
                 (LPCTSTR *)Strings, // array of strings
                 NULL );        // no raw data

    // clean up the event log handle
    DeregisterEventSource(LogHandle);

    pToken->Release();
}

void
LogRemoteSideFailure(
    CLSID *             pClsid,
    DWORD               clsctx,
    WCHAR *             pwszServerName,
    WCHAR *             pwszPathForServer,
    HRESULT             hr )
{
    // Apply event filters
    DWORD dwActLogLvl = GetActivationFailureLoggingLevel();
    if(dwActLogLvl == 2)
        return;
    if(dwActLogLvl != 1 && clsctx & CLSCTX_NO_FAILURE_LOG)
        return;

    HANDLE      LogHandle;
    LPWSTR      Strings[4];
    WCHAR       wszClsid[GUIDSTR_MAX];
    WCHAR       wszErrnum[20];
    CToken *    pToken;
    RPC_STATUS  Status;

    // %1 is the error number
    // %2 is the remote machine name
    // %3 is the clsid
    // %4 is the PathForServer

    // Save the error number
    wsprintf(wszErrnum, L"%lu",hr );
    Strings[0] = wszErrnum;

    Strings[1] = pwszServerName;

    // Get the clsid
    wStringFromGUID2( *pClsid, wszClsid, sizeof(wszClsid) );
    Strings[2] = wszClsid;

    Strings[3] = pwszPathForServer;

    // Get the log handle, then report then event.
    LogHandle = RegisterEventSource( NULL, SCM_EVENT_SOURCE );

    if ( ! LogHandle )
        return;

    Status = LookupOrCreateToken( NULL, FALSE, &pToken );

    if ( Status != RPC_S_OK )
        return;

    if ( pwszPathForServer )
        {
        ReportEvent( LogHandle,
                     EVENTLOG_ERROR_TYPE,
                     0,             // event category
                     EVENT_RPCSS_REMOTE_SIDE_ERROR_WITH_FILE,
                     pToken->GetSid(),
                     4,             // 4 strings passed
                     0,             // 0 bytes of binary
                     (LPCTSTR *)Strings, // array of strings
                     NULL );        // no raw data
        }
    else
        {
        ReportEvent( LogHandle,
                     EVENTLOG_ERROR_TYPE,
                     0,             // event category
                     EVENT_RPCSS_REMOTE_SIDE_ERROR,
                     pToken->GetSid(),
                     3,             // 3 strings passed
                     0,             // 0 bytes of binary
                     (LPCTSTR *)Strings, // array of strings
                     NULL );        // no raw data
        }

    // clean up the event log handle
    DeregisterEventSource(LogHandle);

    pToken->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\olescm\dfsext.cxx ===
//+----------------------------------------------------------------------------
//
//  Copyright (C) 1996, Microsoft Corporation
//
//  File:       dfsext.cxx
//
//  Contents:   Code to see if a path refers to a Dfs path.
//
//  Classes:    None
//
//  Functions:  TranslateDfsPath
//
//  History:    June 17, 1996  Milans Created
//
//-----------------------------------------------------------------------------

#include "act.hxx"

#ifdef DFSACTIVATION

NTSTATUS
DfsFsctl(
    IN  HANDLE DfsHandle,
    IN  ULONG FsControlCode,
    IN  PVOID InputBuffer OPTIONAL,
    IN  ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN  OUT PULONG OutputBufferLength);

NTSTATUS
DfsOpen(
    IN  OUT PHANDLE DfsHandle);


//+-------------------------------------------------------------------------
//
//  Function:   DfsOpen, private
//
//  Synopsis:   Opens a handle to the Dfs driver for fsctl purposes.
//
//  Arguments:  [DfsHandle] -- On successful return, contains handle to the
//                      driver.
//
//  Returns:    NTSTATUS of attempt to open the Dfs driver.
//
//--------------------------------------------------------------------------
NTSTATUS
DfsOpen(
    IN  OUT PHANDLE DfsHandle)
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatus;
    UNICODE_STRING name = {
        sizeof(DFS_DRIVER_NAME)-sizeof(UNICODE_NULL),
        sizeof(DFS_DRIVER_NAME)-sizeof(UNICODE_NULL),
        DFS_DRIVER_NAME};

    InitializeObjectAttributes(
        &objectAttributes,
        &name,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
    );

    status = NtCreateFile(
        DfsHandle,
        SYNCHRONIZE,
        &objectAttributes,
        &ioStatus,
        NULL,
        FILE_ATTRIBUTE_NORMAL,
        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
        FILE_OPEN_IF,
        FILE_CREATE_TREE_CONNECTION | FILE_SYNCHRONOUS_IO_NONALERT,
        NULL,
        0);

    if (NT_SUCCESS(status))
        status = ioStatus.Status;

    return status;
}


//+-------------------------------------------------------------------------
//
//  Function:   DfsFsctl, public
//
//  Synopsis:   Fsctl's to the Dfs driver.
//
//  Arguments:  [DfsHandle] -- Handle to the Dfs driver, usually obtained by
//                      calling DfsOpen.
//              [FsControlCode] -- The FSCTL code (see private\inc\dfsfsctl.h)
//              [InputBuffer] -- InputBuffer to the fsctl.
//              [InputBufferLength] -- Length, in BYTES, of InputBuffer
//              [OutputBuffer] -- OutputBuffer to the fsctl.
//              [OutputBufferLength] -- Length, in BYTES, of OutputBuffer
//
//  Returns:    NTSTATUS of Fsctl attempt.
//
//--------------------------------------------------------------------------
NTSTATUS
DfsFsctl(
    IN  HANDLE DfsHandle,
    IN  ULONG FsControlCode,
    IN  PVOID InputBuffer OPTIONAL,
    IN  ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN OUT PULONG OutputBufferLength
)
{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatus;

    status = NtFsControlFile(
        DfsHandle,
        NULL,       // Event,
        NULL,       // ApcRoutine,
        NULL,       // ApcContext,
        &ioStatus,
        FsControlCode,
        InputBuffer,
        InputBufferLength,
        OutputBuffer,
        *OutputBufferLength
    );

    if(NT_SUCCESS(status))
        status = ioStatus.Status;

    if (status == STATUS_BUFFER_OVERFLOW)
        *OutputBufferLength = *((PULONG) OutputBuffer);

    return status;
}

#endif // DFSACTIVATION
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\olescm\clsid.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  clsid.cxx
//
//  Classes for managing CLSID and APPID registry settings.
//
//--------------------------------------------------------------------------

#include "act.hxx"
#include <catalog.h>
#include <ole2com.h>
#include "registry.hxx"

// The domain name to use if no domain name is specified in the RunAs key.
// We use . instead  of the local machine name because the local machine name
// does not work if we are on a Domain Controller, . works in all cases.

WCHAR *gpwszLocalMachineDomain = L".";

extern "C"
{
    HANDLE
        GetCurrentUserTokenW(
                             WCHAR Winsta[],
                             DWORD DesiredAccess
                             );
};

//+-------------------------------------------------------------------------
//
// LookupClsidData
//
//  Loads the registry configuration for the given CLSID.  Option can be any
//  of the LOAD_* values defined in clsid.hxx, or 0 for no special handling.
//
//--------------------------------------------------------------------------
HRESULT
LookupClsidData(
               IN  GUID &          Clsid,
               IN  IComClassInfo*  pComClassInfo,
               IN  CToken *        pToken,
               IN  DWORD           Option,
               IN OUT CClsidData **ppClsidData
               )
{
    HRESULT hr;

    if ( ! *ppClsidData )
       *ppClsidData = new CClsidData( Clsid, pToken, pComClassInfo );

    if ( ! *ppClsidData )
        return (E_OUTOFMEMORY);

    hr = (*ppClsidData)->Load( Option );

    if ( hr != S_OK )
    {
        delete *ppClsidData;
        *ppClsidData = 0;
    }
    else
    {
        // In case of Treat As
        Clsid = *(*ppClsidData)->ClsidGuid();
    }

    return (hr);
}

//+-------------------------------------------------------------------------
//
// LookupAppidData
//
//  Loads the registry configuration for the given APPID.
//
//--------------------------------------------------------------------------
HRESULT
LookupAppidData(
               IN  GUID &        AppidGuid,
               IN  CToken      * pToken,
               IN  DWORD         Option,          
               OUT CAppidData ** ppAppidData
               )
{
    HRESULT hr = S_OK;

    WCHAR   wszAppid[GUIDSTR_MAX];
    wStringFromGUID2( AppidGuid, wszAppid, sizeof(wszAppid) );

    *ppAppidData = new CAppidData( wszAppid, pToken );

    if ( ! *ppAppidData )
        hr = E_OUTOFMEMORY;
    else
        hr = (*ppAppidData)->Load( Option );

    return (hr);
}

//
// CClsidData
//

CClsidData::CClsidData(
                      IN  GUID &      Clsid,
                      IN  CToken *    pToken,
                      IN  IComClassInfo*  pComClassInfo
                      )
{
    if ( pToken )
        pToken->AddRef();

    _pToken = pToken;

    _Clsid = Clsid;
    _pAppid = NULL;
    _ServerType = SERVERTYPE_NONE;
    _DllThreadModel = SINGLE_THREADED;
    _pwszServer = NULL;
    _pIComCI = pComClassInfo;
    if (pComClassInfo)
    {
        pComClassInfo->AddRef();
        pComClassInfo->Lock();
    }
    _pIClassCI = NULL;
    _pICPI = NULL;
    _pwszDarwinId = NULL;
    _pwszDllSurrogate = NULL;
    _hSaferLevel = NULL;
    _dwAcceptableCtx = 0;
    _bIsInprocClass = FALSE;
	memset(_wszClsid, 0, sizeof(_wszClsid));
}

CClsidData::~CClsidData()
{
    Purge();

#ifndef _CHICAGO_
    if ( _pToken )
        _pToken->Release();

    _pToken = 0;
#endif

    if ( _pIComCI != NULL )
    {
        _pIComCI->Unlock();
        _pIComCI->Release();
    }
    if ( _pIClassCI != NULL )
        _pIClassCI->Release();
    if ( _pICPI != NULL )
        _pICPI->Release();
}

//-------------------------------------------------------------------------
//
// CClsidData::Load
//
//  Forces a load of all registry keys and values for this clsid and its
//  associated APPID.
//
//-------------------------------------------------------------------------
HRESULT
CClsidData::Load(
                IN  DWORD   Option
                )
{
    HRESULT hr = E_FAIL;
    LocalServerType lsType = LocalServerType32;
    ProcessType pType = ProcessTypeNormal;
    ThreadingModel tModel = SingleThreaded;
    DWORD dwAcceptableClsCtx = 0;
    IComServices *pServices = NULL;
    IComClassInfo2 *pIComCI2 = NULL;

    //
    // Catalog cruft
    //

    hr = InitializeCatalogIfNecessary();
    if ( FAILED(hr) )
    {
        goto cleanup;
    }

    if ( _pIComCI == NULL )
    {
        if ( _pToken )
        {
            // Ok, here's the deal.
            // First we need to make sure we've exhausted all of the LocalServer
            // options on the machine before turning to a remote server option,
            // because the classinfo will always say yes to remote server.
            hr = gpCatalogSCM->GetClassInfo ( CLSCTX_LOCAL_SERVER,
                                              _pToken,
                                              _Clsid,
                                              IID_IComClassInfo,
                                              (void**) &_pIComCI );
            
            if ( _pIComCI == NULL || hr != S_OK )
            {
                // Exhaustive search for localserver failed, or we just want
                // the first thing we find.  Just do a normal search.
                // REVIEW: Will the do the right thing for 32bit CLSID?
                //         What about Darwin?
                hr = gpCatalogSCM->GetClassInfo ( 0,
                                                  _pToken,
                                                  _Clsid,
                                                  IID_IComClassInfo,
                                                  (void**) &_pIComCI );
            }
        }
        else
        {
            hr = gpCatalog->GetClassInfo ( _Clsid,
                                           IID_IComClassInfo,
                                           (void**) &_pIComCI );
        }

        if ( _pIComCI == NULL || hr != S_OK )
        {
            hr = REGDB_E_CLASSNOTREG;
            goto cleanup;
        }

        _pIComCI->Lock();
    }

    hr = _pIComCI->QueryInterface(IID_IComClassInfo2, (void **)&pIComCI2);
    if(SUCCEEDED(hr))
    {
    	BOOL bClassEnabled;
		pIComCI2->IsEnabled(&bClassEnabled);
		pIComCI2->Release();

		if(bClassEnabled == FALSE)
		{
			hr = CO_E_CLASS_DISABLED;
			goto cleanup;
		}
    }

    // Treat As possible so read clsid
    GUID *pguid;
    hr = _pIComCI->GetConfiguredClsid(&pguid);
    _Clsid = *pguid;
	
    wStringFromGUID2(_Clsid, _wszClsid, sizeof(_wszClsid));	

    if ( _pIClassCI == NULL )
    {
        hr = _pIComCI->QueryInterface (IID_IClassClassicInfo, (void**) &_pIClassCI );
        if ( _pIClassCI == NULL || hr != S_OK )
        {
            hr = REGDB_E_CLASSNOTREG;
            goto cleanup;
        }
    }

    if ( _pICPI == NULL )
    {
        hr = _pIClassCI->GetProcess ( IID_IComProcessInfo, (void**) &_pICPI );
        if ( hr != S_OK && _pICPI != NULL )
        {
            _pICPI->Release();
            _pICPI = NULL;
        }
        hr = S_OK;
    }

    Purge();

    //
    // Load Surrogate command line

    hr = _pIClassCI->GetSurrogateCommandLine(&_pwszDllSurrogate);
    if ( hr != S_OK )
    {
        // GetSurrogateCommandLine can fail for two reasons:  1) out-of-memory;
        // or 2) the class is not configured to run as a surrogate.  It is 
        // somewhat difficult to tell at this point which is which.   Therefore,
        // we don't let a failure here doesn't stop us; instead we check further 
        // below for the case where we are supposedly a surrogate but don't have
        // a surrogate cmd line.
        _pwszDllSurrogate = NULL;
        hr = S_OK;
    }

    //
    // Load APPID settings before other non-Darwin CLSID settings.
    //

    if ( _pICPI != NULL )
    {
        GUID* pGuidProcessId;
        WCHAR wszAppid[GUIDSTR_MAX];

        hr = _pICPI->GetProcessId (&pGuidProcessId);
        if ( hr != S_OK )
        {
            hr = REGDB_E_CLASSNOTREG;
            goto cleanup;
        }
        wStringFromGUID2( *pGuidProcessId, wszAppid, sizeof(wszAppid) );

#ifndef _CHICAGO_
        _pAppid = new CAppidData( wszAppid, _pToken );
#else
        _pAppid = new CAppidData( wszAppid, NULL );
#endif

        if ( _pAppid == NULL )
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = _pAppid->Load( _pICPI );
        }

        if ( hr != S_OK )
        {
            goto cleanup;
        }

        hr = _pICPI->GetProcessType (&pType);
        if ( hr != S_OK )
        {
            pType = ProcessTypeNormal;
            hr = S_OK;
        }
    }

    //
    //  See if we can find a LocalServer
    //

    hr = _pIClassCI->GetLocalServerType (&lsType);
    if ( hr != S_OK )
    {
        hr = S_OK;
    }
    else if ( (pType != ProcessTypeService) &&
			  (pType != ProcessTypeComPlusService) )
    {
        if ( lsType == LocalServerType16 )
        {
            _ServerType = SERVERTYPE_EXE16;
        }
        else
        {
            _ServerType = SERVERTYPE_EXE32;
        }

        hr = _pIClassCI->GetModulePath(CLSCTX_LOCAL_SERVER, &_pwszServer);
        if ( hr != S_OK )
        {
            hr = REGDB_E_CLASSNOTREG;
            goto cleanup;
        }
        else
        {
            pType = ProcessTypeNormal;
        }
    }

    //
    //  Set up process type information
    //

    // Determine the acceptable context of creation
    hr = _pIComCI->GetClassContext((CLSCTX)(CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER),
                                   (CLSCTX*) &dwAcceptableClsCtx);
    
    if ( SUCCEEDED(hr) )
    {
        if ( !dwAcceptableClsCtx )
        {
            if (Option == LOAD_APPID)
            {
                _bIsInprocClass = TRUE;
            }
            else
            {
                hr = REGDB_E_CLASSNOTREG;
            }
        }
    }

    if ( FAILED(hr) )
        goto cleanup;

    // Set the acceptable context of creation
    _dwAcceptableCtx = dwAcceptableClsCtx;


    switch ( pType )
    {
    case ProcessTypeNormal:
        break;

    case ProcessTypeService:
        _ServerType = SERVERTYPE_SERVICE;
        break;

    case ProcessTypeComPlusService:
        _ServerType = SERVERTYPE_COMPLUS_SVC;
        break;

    case ProcessTypeComPlus:
        //See if services configured, else normal dllhost
        if (_pICPI->QueryInterface(IID_IComServices,
                                   (void**) &pServices) == S_OK )
        {
            _ServerType = SERVERTYPE_COMPLUS;
            pServices->Release();
        }
        else
            _ServerType = SERVERTYPE_DLLHOST;

        break;

    case ProcessTypeLegacySurrogate:
        _ServerType = SERVERTYPE_SURROGATE;

        hr = _pIClassCI->GetModulePath(CLSCTX_INPROC_SERVER, &_pwszServer);
        if ( hr != S_OK )
        {
            hr = REGDB_E_CLASSNOTREG;
            goto cleanup;
        }
        break;
    default:
        hr = REGDB_E_CLASSNOTREG;
        goto cleanup;
        break;
    }


    //
    //  Other process info
    //

	if ( S_OK != _pIClassCI->GetThreadingModel (&tModel) )
	{
	    hr = REGDB_E_BADTHREADINGMODEL;
	}
	else
	{
	    switch ( tModel )
	    {
	    case ApartmentThreaded:
	        _DllThreadModel = APT_THREADED;
	        break;
	    case FreeThreaded:
	        _DllThreadModel = FREE_THREADED;
	        break;
	    case SingleThreaded:
	    default:
	    _DllThreadModel = SINGLE_THREADED;
	        break;
	    case BothThreaded:
	    case NeutralThreaded:
	    _DllThreadModel = BOTH_THREADED;
	        break;
	    }
	}

    //
    // Safer Level.
    //
    hr = CalculateSaferLevel();

    cleanup:

    if ( _ServerType == SERVERTYPE_SURROGATE ||
         _ServerType == SERVERTYPE_COMPLUS ||
         _ServerType == SERVERTYPE_DLLHOST)
    {
        if (!_pwszDllSurrogate)
        {
            // we're supposed to be a surrogate, but don't have a cmd line for such
            if (SUCCEEDED(hr))
                hr = E_OUTOFMEMORY;
        }
    }

    if ( FAILED(hr) )
    {
        Purge();

        if ( _pIComCI != NULL )
        {
            _pIComCI->Unlock();
            _pIComCI->Release();
            _pIComCI = NULL;
        }

        if ( _pIClassCI != NULL )
        {
            _pIClassCI->Release();
            _pIClassCI = NULL;
        }

        if ( _pICPI != NULL )
        {
            _pICPI->Release();
            _pICPI = NULL;
        }
    }

    return (hr);
}

//-------------------------------------------------------------------------
//
// CClsidData::Purge
//
//  Frees and clears all member data except for clsid registry key and
//  Darwin ID values.
//
//-------------------------------------------------------------------------
void
CClsidData::Purge()
{
    if ( _pAppid )
    {
        delete _pAppid;
    }

    _pAppid = NULL;
    _ServerType = SERVERTYPE_NONE;
    _DllThreadModel = SINGLE_THREADED;
    _pwszServer = NULL;
    _pwszDarwinId = NULL;
    _pwszDllSurrogate = NULL;

    if (_hSaferLevel)
    {
        SaferCloseLevel(_hSaferLevel);
        _hSaferLevel = NULL;
    }
}

//-------------------------------------------------------------------------
//
// CClsidData::CalculateSaferLevel
//
//  Determine (and open) the safer level for this CLSID.  The decision
//  process is as follows:
//
//  - If a SAFER level is configured on the application, use that.
//  - Otherwise, if automatic enforcement is ON:
//     - If we can get a SAFER level from the file, use that.
//     - Otherwise, if there's a default SAFER level, use that.
//     - Otherwise, don't use SAFER.
//  - Otherwise, don't use SAFER.
//
//-------------------------------------------------------------------------
HRESULT
CClsidData::CalculateSaferLevel()
{
    HRESULT hr = S_OK;

    // 
    // One has already been calculated, return it.
    //
    if (_hSaferLevel)
    {
        return S_OK;
    }

    //
    // Get the configured safer level...
    //
    if (_pAppid)
    {
        DWORD dwSaferLevel;
        
        // GetSaferLevel returns TRUE if we have a configured safer level....
        BOOL fSaferConfigured = _pAppid->GetSaferLevel(&dwSaferLevel);
        if (fSaferConfigured)
        {   
            if (!SaferCreateLevel(SAFER_SCOPEID_MACHINE,
                                  dwSaferLevel,
                                  SAFER_LEVEL_OPEN,
                                  &_hSaferLevel,
                                  NULL))
            {
                _hSaferLevel = NULL;
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
            else
            {
                hr = S_OK;
            }
        }
    }

    return hr;
}


//
// CAppidData
//
CAppidData::CAppidData(
                      IN  WCHAR *     pwszAppid,
                      IN  CToken *    pToken
                      )
{
    ASSERT( lstrlenW( pwszAppid ) == GUIDSTR_MAX - 1 );

    lstrcpyW( _wszAppid, pwszAppid );
    BOOL bGuidConv = wGUIDFromString(_wszAppid,&_GuidAppid);

    Win4Assert(bGuidConv && "AppID is not a well-formed GUID");

#ifndef _CHICAGO_
    if ( pToken )
        pToken->AddRef();

    _pToken = pToken;
#endif

    _bActivateAtStorage = FALSE;

#ifndef _CHICAGO_
    _pwszService = 0;
    _pwszServiceParameters = 0;
    _pwszRunAsUser = 0;
    _pwszRunAsDomain = 0;
    _pLaunchPermission = 0;
#endif

    _pwszRemoteServerNames = 0;
    _bComPlusProcess = FALSE;

    _pICPI = NULL;

    _dwSaferLevel = 0;
    _fSaferLevelValid = FALSE;
}

CAppidData::~CAppidData()
{
    Purge();

#ifndef _CHICAGO_
    if ( _pToken )
        _pToken->Release();
#endif

    if ( _pICPI != NULL )
        _pICPI->Release();
}

//-------------------------------------------------------------------------
//
// CAppidData::Load
//
//  Reads all named value settings for this APPID.
//
//-------------------------------------------------------------------------
HRESULT
CAppidData::Load( IN DWORD Option )
{
    HRESULT hr;
    IComProcessInfo *pICPI = NULL;

    hr = InitializeCatalogIfNecessary();
	if (FAILED(hr))
		return hr;

	// 
	// Ok, if we don't already have a IComProcesssInfo object, and somebody
	// has passed an Option in to us, then we will get a special IComProcessInfo
	// based on the option passed in.
	//
    if ((_pICPI == NULL) && (Option))
    {
		//BUGBUG: Either pull out the if or pull out the assert.
		ASSERT(_pToken && "Asked for a special ICPI without a token!");
		if (_pToken)
		{
			hr = gpCatalogSCM->GetProcessInfo(Option,
											  _pToken,
											  _GuidAppid,
											  IID_IComProcessInfo,
											  (void **)&pICPI);
		}

        if (( hr != S_OK ) || ( pICPI == NULL )) 
            return REGDB_E_CLASSNOTREG;
    }
   
    return Load ( pICPI );
}

HRESULT
CAppidData::Load( IN IComProcessInfo *pICPI )
{
    HRESULT hr;
    IComProcessInfo2 *pICPI2 = NULL;
    ProcessType pType = ProcessTypeNormal;
    WCHAR* pwszTmpValue = NULL;
    WCHAR* pwszRunAsDomain = NULL;
    int len = 0;
    DWORD dwJunk;    


    hr = InitializeCatalogIfNecessary();
    if ( FAILED(hr) )
    {
        goto cleanup;
    }

    if ( _pICPI == NULL )
    {
        if ( pICPI != NULL )
        {
            _pICPI = pICPI;
            _pICPI->AddRef();
        }
#ifndef _CHICAGO_
        else if ( _pToken )
            hr = gpCatalogSCM->GetProcessInfo (0,
                                               _pToken,
                                               _GuidAppid,
                                               IID_IComProcessInfo,
                                               (void**) &_pICPI );
        else
#endif // _CHICAGO_
            hr = gpCatalog->GetProcessInfo ( _GuidAppid,
                                             IID_IComProcessInfo,
                                             (void**) &_pICPI );

        if ( _pICPI == NULL || hr != S_OK )
        {
            hr = REGDB_E_CLASSNOTREG;
            goto cleanup;
        }
    }

    //
    // ActivateAtStorage
    //

    hr = _pICPI->GetActivateAtStorage (&_bActivateAtStorage);
    if ( hr != S_OK )
    {
        _bActivateAtStorage = FALSE;
        hr = S_OK;
    }

    //
    //  ProcessType
    //

    hr = _pICPI->GetProcessType (&pType);
    if ( hr != S_OK )
    {
        pType = ProcessTypeNormal;
        hr = S_OK;
    }

    //
    //  ComPlus?
    //
    // NOTE!!!!:: This is true for normal dllhost.exe regardless of
    //            whether they are really complus or not.  We won't
    //            distinguish this in here in AppidData but in
    //            ClsidData

    _bComPlusProcess = pType == ProcessTypeComPlus;

    //
    // RemoteServerName
    //
    hr = _pICPI->GetRemoteServerName (&_pwszRemoteServerNames);
    if ( hr != S_OK )
    {
        _pwszRemoteServerNames = NULL;
        hr = S_OK;
    }

    //
    // LaunchPermision
    //
    hr = _pICPI->GetLaunchPermission ( (void**) &_pLaunchPermission, &dwJunk );
    if ( hr != S_OK )
    {
        _pLaunchPermission = NULL;
        hr = S_OK;
    }

    //
    // LocalService and ServiceParameters
    //

    hr = _pICPI->GetServiceName (&_pwszService);
    if ( hr != S_OK )
    {
        _pwszService = NULL;
        hr = S_OK;
    }
    hr = _pICPI->GetServiceParameters (&_pwszServiceParameters);
    if ( hr != S_OK )
    {
        _pwszServiceParameters = NULL;
        hr = S_OK;
    }

    //
    // RunAs
    //

    hr = _pICPI->GetRunAsUser (&pwszTmpValue);
    if ( hr != S_OK )
    {
        _pwszRunAsUser = NULL;
        _pwszRunAsDomain = NULL;
        hr = S_OK;
    }
    else
    {
        len = lstrlenW(pwszTmpValue)+1;
        _pwszRunAsUser = new WCHAR[len];
        if (!_pwszRunAsUser)
        {
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }

        lstrcpyW(_pwszRunAsUser, pwszTmpValue);

        pwszTmpValue = _pwszRunAsUser;

        while ( *pwszTmpValue && *pwszTmpValue != L'\\' )
            pwszTmpValue++;

        if ( ! *pwszTmpValue )
        {
            // user name, no domain name, use the machine name
            _pwszRunAsDomain = gpwszLocalMachineDomain;
        }
        else
        {
            // domain\user
            Win4Assert( L'\\' == *pwszTmpValue );
            *pwszTmpValue = 0;
            _pwszRunAsDomain = _pwszRunAsUser;
            _pwszRunAsUser = pwszTmpValue + 1;

            if ( ! *_pwszRunAsUser )
            {
                hr = E_FAIL;
                goto cleanup;
            }
        }
    }

    //
    // Safer trust level.
    //
    hr = _pICPI->QueryInterface(IID_IComProcessInfo2, (void **)&pICPI2);
    if (SUCCEEDED(hr))
    {
        hr = pICPI2->GetSaferTrustLevel(&_dwSaferLevel);
        
        pICPI2->Release();
    }
    
    // If we couldn't get a configured trust level, make
    // sure we remember that.
    if (FAILED(hr))
    {
        _fSaferLevelValid = FALSE;
        hr = S_OK;
    }
    else
    {
        _fSaferLevelValid = TRUE;
    }

    cleanup:
    if ( FAILED(hr) )
    {
        Purge();
        if ( _pICPI != NULL )
        {
            _pICPI->Release();
            _pICPI = NULL;
        }
    }

    return (hr);
}


//-------------------------------------------------------------------------
//
// CAppidData::Purge
//
//  Frees and clears all named value settings for this APPID.
//
//-------------------------------------------------------------------------
void
CAppidData::Purge()
{
    _pwszService = 0;
    _pwszServiceParameters = 0;
    _pLaunchPermission = 0;

    //  This is too tricky, so it goes. If we've assigned RunAsDomain
    //  the address of the global local machine name, then the buffer
    //  we allocated is pointed at by _pwszRunAsUser. Otherwise, it's
    //  pointed at by _pwszRunAsDomain ('cause if both user and domain
    //  are in the string, domain is first).

    if ( _pwszRunAsUser != NULL )
    {
        if ( _pwszRunAsDomain == gpwszLocalMachineDomain )
        {
            delete [] _pwszRunAsUser;
        }
        else
        {
            delete [] _pwszRunAsDomain;
        }
    }
    _pwszRunAsUser = 0;
    _pwszRunAsDomain = 0;

    _fSaferLevelValid = FALSE;
    _dwSaferLevel = 0;

    _pwszRemoteServerNames = 0;
    _bActivateAtStorage = 0;
}


BOOL
CAppidData::CertifyServer(
                         CProcess *  pProcess
                         )
{
    PSID    pRequiredSid = NULL;
    HANDLE  hToken = 0;
    BOOL    bStatus;

    if ( _pwszService )
    {
        SERVICE_STATUS  ServiceStatus;
        SC_HANDLE       hService;
		
        ASSERT(g_hServiceController);
        hService = OpenService( g_hServiceController,
                                _pwszService,
                                GENERIC_READ );

        if ( ! hService )
            return (FALSE);

        bStatus = QueryServiceStatus( hService, &ServiceStatus );

        if ( bStatus )
        {
            if ( (ServiceStatus.dwCurrentState == SERVICE_STOPPED) ||
                 (ServiceStatus.dwCurrentState == SERVICE_STOP_PENDING) )
                bStatus = FALSE;
        }

        CloseServiceHandle(hService);

        return (bStatus);
    }

    if ( ( ! _pwszRunAsUser ) && ( ! IsInteractiveUser() ) )
        return (TRUE);

    if ( IsInteractiveUser() )
    {
        ULONG ulSessionId = pProcess->GetToken()->GetSessionId();
        if ( ulSessionId )
        {
            hToken = GetShellProcessToken( ulSessionId );
        }
        else
        {
            //        hToken = GetShellProcessToken();
            hToken = GetCurrentUserTokenW(L"WinSta0", TOKEN_ALL_ACCESS);
        }
    }
    else
        hToken = GetRunAsToken( 0,    // CLSCTX isn't always available here
                                _wszAppid,
                                _pwszRunAsDomain,
                                _pwszRunAsUser );

    if (hToken)
    {
        DWORD dwSaferLevel;
        if (GetSaferLevel(&dwSaferLevel))
        {
            //
            // If a safer level is configured, then the person being launched
            // must have the same safer restrictions as we expected put on them.
            //
            SAFER_LEVEL_HANDLE hSaferLevel = NULL;
            HANDLE      hSaferToken = NULL; 

            bStatus = SaferCreateLevel(SAFER_SCOPEID_MACHINE,
                                       dwSaferLevel,
                                       SAFER_LEVEL_OPEN,
                                       &hSaferLevel,
                                       NULL);
            if (bStatus)
            {
                bStatus = SaferComputeTokenFromLevel(hSaferLevel,
                                                     hToken,
                                                     &hSaferToken,
                                                     0,
                                                     NULL);
                SaferCloseLevel(hSaferLevel);
            }

            if (bStatus)
            {
                NtClose(hToken);
                hToken = hSaferToken;
            }
        }
        else
            bStatus = TRUE;

        if (bStatus)
        {
            if (S_OK != pProcess->GetToken()->MatchToken(hToken, TRUE))
                bStatus = FALSE;
        }
    }
    else
        bStatus = FALSE;


    if ( hToken )
        NtClose( hToken );

    return (bStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\olescm\excladdr.cxx ===
//+-------------------------------------------------------------------
//
//  File:       excladdr.cxx
//
//  Contents:   Implements classes for managing the current address 
//              exclusion list
//
//  Classes:    CAddrExclusionMgr 
//
//  History:    07-Oct-00   jsimmons      Created
//--------------------------------------------------------------------

#include "act.hxx"


// The single instance of this object
CAddrExclusionMgr gAddrExclusionMgr;

CAddrExclusionMgr::CAddrExclusionMgr() :
                _dwNumStrings(0),
                _ppszStrings(NULL),
                _bInitRegistry(FALSE)
{
}

// 
// GetExclusionList
//
// Returns the current exclusion list.
//
HRESULT CAddrExclusionMgr::GetExclusionList(
                DWORD* pdwNumStrings,
                LPWSTR** pppszStrings)
{
        gpClientLock->LockExclusive();
        
        // Handle easy case
        if (_dwNumStrings == 0)
        {
                *pdwNumStrings = 0;
                *pppszStrings = NULL;
                gpClientLock->UnlockExclusive();
                return S_OK;
        }

        DWORD i;
        DWORD dwCopiedStrings;
        LPWSTR* ppszCopiedStrings;      

        ppszCopiedStrings = (LPWSTR*)MIDL_user_allocate(sizeof(WCHAR*) * _dwNumStrings);
        if (!ppszCopiedStrings)
        {
            gpClientLock->UnlockExclusive();
                return E_OUTOFMEMORY;
        }

        dwCopiedStrings = 0;
        for (i = 0; i < _dwNumStrings; i++)
        {
                if (_ppszStrings[i])
                {
                        ppszCopiedStrings[i] = (LPWSTR)MIDL_user_allocate(
                                               sizeof(WCHAR) * (lstrlen(_ppszStrings[i]) + 1));
                        if (!ppszCopiedStrings[i])
                        {
                                // failure in the middle.  cleanup previous allocations and return
                                for (i = 0; i < _dwNumStrings; i++)
                                {
                                        if (ppszCopiedStrings[i])
                                                MIDL_user_free(ppszCopiedStrings[i]);
                                }
                                MIDL_user_free(ppszCopiedStrings);
                                gpClientLock->UnlockExclusive();
                                return E_OUTOFMEMORY;
                        }

                        lstrcpy(ppszCopiedStrings[i], _ppszStrings[i]);
                        dwCopiedStrings++;
                }
        }

        *pdwNumStrings = dwCopiedStrings;
        *pppszStrings = ppszCopiedStrings;

        gpClientLock->UnlockExclusive();

        return S_OK;
}

// 
// SetExclusionList
//
// Sets the current exclusion list, and pushes the
// new bindings to all current running processes 
// registered with COM.
//
HRESULT CAddrExclusionMgr::SetExclusionList(
                DWORD dwNumStrings,
                LPWSTR* ppszStrings)
{
        HRESULT hr = S_OK;
        RPC_STATUS status;
        DWORD i, j;
        LPWSTR* ppszStringsNew = NULL;

        gpClientLock->LockExclusive();

        if (dwNumStrings > 0)
        {
                ppszStringsNew = (LPWSTR*)PrivMemAlloc(sizeof(WCHAR*) * dwNumStrings);
                if (!ppszStringsNew)
                {
                        gpClientLock->UnlockExclusive();
                        return E_OUTOFMEMORY;
                }

                for (i = 0; i < dwNumStrings; i++)
                {
                        // Skip any null entries.  Assert in debug builds since
                        // this is likely a sign of a broken app
                        ASSERT(ppszStrings[i]);
                        if (!ppszStrings[i])
                                continue;

                        ppszStringsNew[i] = (LPWSTR)PrivMemAlloc(
                                    sizeof(WCHAR) * (lstrlen(ppszStrings[i]) + 1));
                        if (!ppszStringsNew[i])
                        {
                                // free up any earlier allocations that succeeded
                                for (j = 0; j < i; j++)
                                        PrivMemFree(ppszStringsNew[j]);

                                PrivMemFree(ppszStringsNew);
                                
                                gpClientLock->UnlockExclusive();

                                // and return error
                                return E_OUTOFMEMORY;
                        }

                        lstrcpy(ppszStringsNew[i], ppszStrings[i]);
                }
        }

        // Get rid of the old list
        FreeCurrentBuffers();

        // Save off the new one
        _dwNumStrings = dwNumStrings;
        _ppszStrings = ppszStringsNew;

        // Recompute the bindings
        status = ComputeNewResolverBindings();
        if (status == RPC_S_OK)
        {
                // Update currently running processes   
                PushCurrentBindings();
        }
        else
                hr = E_OUTOFMEMORY;

        gpClientLock->UnlockExclusive();

        return hr;
}

// 
// EnableDisableDynamicTracking
//
// Turns on\off the dynamic address binding feature, and updates
// the registry key accordingly.
//
HRESULT CAddrExclusionMgr::EnableDisableDynamicTracking(BOOL fEnable)
{
        HRESULT hr = S_OK;
    LONG error;
    HKEY hOle;
    WCHAR* szY = L"Y";
    WCHAR* szN = L"N";

        gpClientLock->LockExclusive();

    // Open the registry key and change the value
    error = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                         L"SOFTWARE\\Microsoft\\OLE", 
                         NULL, 
                         KEY_WRITE,
                         &hOle);
    if (error == ERROR_SUCCESS)
    {   
        error = RegSetValueEx(hOle,
                              L"EnableSystemDynamicIPTracking",
                              0,
                              REG_SZ,
                              (BYTE*)(fEnable ? szY : szN),
                              4); // 4 = one wchar + null
        if (error == ERROR_SUCCESS)
        {
            // Reset the global.  Will be seen immediately
            gbDynamicIPChangesEnabled = fEnable ? TRUE : FALSE;
        }
        else
            hr = HRESULT_FROM_WIN32(GetLastError());

        CloseHandle(hOle);
    }
    else
        hr = HRESULT_FROM_WIN32(GetLastError());
        
        gpClientLock->UnlockExclusive();

        return hr;
}


//
//  IsExcludedAddress
//
//  Checks to see if the specified address is in our
//  current exclusion list.
//
BOOL CAddrExclusionMgr::IsExcludedAddress(LPWSTR pszAddress)
{
        DWORD i;
        
        ASSERT(gpClientLock->HeldExclusive());
        ASSERT(_ppszStrings);

        for (i = 0; i < _dwNumStrings; i++)
        {       
                if (_ppszStrings[i])
                {
                        if (lstrcmpi(_ppszStrings[i], pszAddress) == 0)
                        {
                                // found it in the list
                                return TRUE;
                        }
                }
        }
        return FALSE;
}

// 
// BuildExclusionDSA
//
// Constructs a new dsa and puts it in *ppdsaOut; the new 
// dsa is the same as pdsaSrc, minus any addresses that are
// currently in the exclusion list.
//
HRESULT CAddrExclusionMgr::BuildExclusionDSA(                                                                                   
                                DUALSTRINGARRAY* pdsaSrc,
                                DUALSTRINGARRAY** ppdsaOut
                                )
{
        ASSERT(pdsaSrc && ppdsaOut);
        ASSERT(dsaValid(pdsaSrc));

        ASSERT(gpClientLock->HeldExclusive());

        SCMVDATEHEAP();

        DWORD i;
        BOOL bDone;
        USHORT* pStart;
        USHORT* pCurrent;
        USHORT* pCurrentNew;
        DWORD dwBindingsToExclude = 0;
        USHORT usNewDSALen = 0;
        DUALSTRINGARRAY* pdsaNew;
        BOOL* afIsExcludedAddress;
        
        *ppdsaOut = NULL;

        // If our list is empty, nothing to do
        if (_dwNumStrings == 0)
                return dsaAllocateAndCopy(ppdsaOut, pdsaSrc);

        // Allocate an array of bools on the stack.  This 
        // will be used to remember if an address is excluded
        // or not on the first pass, so we don't have to be
        // figure that out again on the second pass.
        //
        // Note that I will almost always allocate too much stack
        // memory -- better that than not enough.   To be exact
        // I'd have to make an extra pass thru the dsa to see how 
        // many string bindings there are - which sorta defeats
        // the purpose.
        afIsExcludedAddress = (BOOL*)_alloca(sizeof(BOOL) * pdsaSrc->wSecurityOffset);

        // First make one pass thru the incoming dsa to 
        // see how many addresses we should retain, and
        // calculate how much space they will need.
        bDone = FALSE;
        pStart = pCurrent = &(pdsaSrc->aStringArray[0]);
        i = 0;
        do
        {
                // Find end of the current string binding.  Be careful
                // to handle cases where there are no string bindings.
                while (*pCurrent != 0)
                        pCurrent++;

                if ((i > 0) && (pCurrent == pStart) ||
                        ((i == 0) && (*(pCurrent+1) == 0)))
                {
                        // either found a zero after the previous
                        // binding, or we found two zeroes in a row
                        // at the beginning of pdsaSrc->aStringArray.
                        bDone = TRUE;
                }
                else
                {               
                        i++;  // count total # of strings found
                        
                        STRINGBINDING* psb = (STRINGBINDING*)pStart;
                        
                        // We only exclude addresses if they are using tcp
                        if (psb->wTowerId == ID_TCP &&
                                IsExcludedAddress(&(psb->aNetworkAddr)))
                        {
                                dwBindingsToExclude++;
                                afIsExcludedAddress[i] = TRUE;
                        }
                        else
                        {
                                // Add string len plus 2 (space for towerid + null terminator)
                                usNewDSALen += (lstrlen(&(psb->aNetworkAddr)) + 2);
                                afIsExcludedAddress[i] = FALSE;
                        }
                        // advance to next string binding
                        pCurrent++; 
                        pStart = pCurrent;
                }
        } while (!bDone);
        
        // If there are no addresses that need excluding, just copy
        // and return the incoming bindings.
        if (dwBindingsToExclude == 0)
                return dsaAllocateAndCopy(ppdsaOut, pdsaSrc);

        // If we didn't find any string bindings to use at all, then we 
        // need to manually add a word for the initial NULL.
        if (usNewDSALen == 0)
                usNewDSALen = 1;

        // Add space for wNumEntries + wSecurityOffset
        usNewDSALen += (sizeof(USHORT) * 2);

        // Add size of all security bindings
        usNewDSALen += ((pdsaSrc->wNumEntries - pdsaSrc->wSecurityOffset));

        // Add one for the string bindings terminating NULL.
        usNewDSALen++;

        // Allocate the memory
        pdsaNew = (DUALSTRINGARRAY*)MIDL_user_allocate(usNewDSALen * sizeof(USHORT));
        if (!pdsaNew)
                return E_OUTOFMEMORY;

        ZeroMemory(pdsaNew, usNewDSALen * sizeof(USHORT));

        // Set length
        pdsaNew->wNumEntries = usNewDSALen - 2; // don't count wNumEntries\wSecOffset

        // Initialize ptr into the new dsa
        pCurrentNew = &(pdsaNew->aStringArray[0]);

        // If we are excluding all of the string bindings in pdsaSrc, then 
        // there's no need to make a second pass
        if (dwBindingsToExclude == i)
        {
                // No string bindings left at all.  Not a very useful 
                // situation.  Need to add the initial NULL:
                *pCurrentNew = NULL;
                pCurrentNew++;
        }
        else
        {
                // Make a second pass, copying the non-excluded addresses
                // over to the new dsa as we go.
                bDone = FALSE;
                pStart = pCurrent = &(pdsaSrc->aStringArray[0]);
                i = 0;          
                do              
                {
                        // Find end of the current string binding
                        while (*pCurrent != 0)
                                pCurrent++;

                        if ((i > 0) && (pCurrent == pStart) ||
                                ((i == 0) && (*(pCurrent+1) == 0)))
                        {
                                // either found a zero after the previous
                                // binding, or we found two zeroes in a row
                                // at the beginning of pdsaSrc->aStringArray.
                                bDone = TRUE;
                        }
                        else
                        {
                                i++;  // count total # of strings found

                                if (!afIsExcludedAddress[i]) // remembered from first pass above
                                {
                                        STRINGBINDING* psb = (STRINGBINDING*)pStart;
                                        STRINGBINDING* psbNew = (STRINGBINDING*)pCurrentNew;

                                        // Copy tower id
                                        psbNew->wTowerId = psb->wTowerId;
                                        // Copy address
                                        lstrcpy(&(psbNew->aNetworkAddr), &(psb->aNetworkAddr));
                                        // Move cursor for new dsa (2=towerid + null terminator)
                                        pCurrentNew += (2 + lstrlen(&(psbNew->aNetworkAddr)));
                                }
                                pCurrent++;
                                pStart = pCurrent;
                        }
                } while (!bDone);
        }

        // Add final null terminator for string bindings
        *pCurrentNew = NULL;   // points to after last string binding, NULL it out
        pCurrentNew++;         // now points to first security binding
        
        // Set security offset
        pdsaNew->wSecurityOffset = (unsigned short)(pCurrentNew - &(pdsaNew->aStringArray[0]));

        // Copy security bindings en masse
        memcpy(pCurrentNew, 
                   &(pdsaSrc->aStringArray[pdsaSrc->wSecurityOffset]),
                   (pdsaSrc->wNumEntries - pdsaSrc->wSecurityOffset) * sizeof(USHORT));

        ASSERT(dsaValid(pdsaNew));

        // Success
        *ppdsaOut = pdsaNew;

        SCMVDATEHEAP();

        return S_OK;
}

//
//  InitializeFromRegistry
//  
//  Reads initial address list from registry.  Can only
//  be called once, after that subsequent calls will be
//  ignored.
//
void CAddrExclusionMgr::InitializeFromRegistry()
{
        ASSERT(gpClientLock->HeldExclusive());  

        if (_bInitRegistry)
                return;
        
        _bInitRegistry = TRUE; // this is it, success or fail

        // UNDONE -- if we wanted to, we could support persisting
        // the exclusion list in the registry, and read it out
        // here shortly after boot.

        return;
}

// Private function, no lock needed
void CAddrExclusionMgr::FreeCurrentBuffers()
{
        ASSERT((_dwNumStrings == 0 && _ppszStrings == 0) ||
                   (_dwNumStrings != 0 && _ppszStrings != 0));
                
        DWORD i;

        for (i = 0; i < _dwNumStrings; i++)
        {
                PrivMemFree(_ppszStrings[i]);
        }

        if (_ppszStrings)
                PrivMemFree(_ppszStrings);
        
        _dwNumStrings = 0;
        _ppszStrings = NULL;

        return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\olescm\guidtbl.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       guidtbl.cxx
//
//  Contents:
//
//--------------------------------------------------------------------------

#include "act.hxx"

CGuidTable::CGuidTable( OUT LONG& Status ) :
    CHashTable( Status )
{
}

CGuidTable::~CGuidTable()
{
}

CGuidTableEntry *
CGuidTable::Lookup(
    IN  CLSID * pClsid )
{
    //
    // GUID structures are not 8-byte aligned.  Therefore the UNALIGNED
    // modifier is required when referencing the contents of a GUID via
    // a pointer to an 8-byte type.
    // 

    CId2Key Key( ((ID UNALIGNED *)pClsid)[0], ((ID UNALIGNED *)pClsid)[1] );

    return (CGuidTableEntry *) CHashTable::Lookup( Key );
}

CGuidTableEntry::CGuidTableEntry(
    IN  CLSID * pClsid
    ) :
    CId2TableElement( ((ID UNALIGNED *)pClsid)[0], ((ID UNALIGNED *)pClsid)[1] )
{
}

CGuidTableEntry::~CGuidTableEntry()
{
}

GUID
CGuidTableEntry::Guid()
{
    GUID    Guid;

    ((ID UNALIGNED *)&Guid)[0] = Id();
    ((ID UNALIGNED *)&Guid)[1] = Id2();

    return Guid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\olescm\execclt.cxx ===
/*************************************************************************
*
* execclt.c
*
* Exec service client.
*
* This allows the starting of a program on any Terminal Server Session under
* the account of the logged on user, or the SYSTEM account for services.
*
* copyright notice: Copyright 1998, Microsoft Corporation
*
*
*
*************************************************************************/

#include "act.hxx"
extern "C" {
#include <execsrv.h>
}



//
// Forward references
//

PWCHAR
MarshallString(
    PWCHAR pSource,
    PCHAR  pBase,
    ULONG  MaxSize,
    PCHAR  *ppPtr,
    PULONG pCount,
    BOOL   bMulti = FALSE
    );





/*****************************************************************************
 *
 *  CreateRemoteSessionProcess
 *
 *   Create a process on the given Terminal Server Session
 *
 * ENTRY:
 *   SessionId (input)
 *     SessionId of Session to create process on
 *
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOL
CreateRemoteSessionProcess(
    ULONG  SessionId,
    HANDLE hSaferToken,
    BOOL   System,
    PWCHAR lpszImageName,
    PWCHAR lpszCommandLine,
    PSECURITY_ATTRIBUTES psaProcess,
    PSECURITY_ATTRIBUTES psaThread,
    BOOL   fInheritHandles,
    DWORD  fdwCreate,
    LPVOID lpvEnvironment,
    LPWSTR lpszCurDir,
    LPSTARTUPINFOW pStartInfo,
    LPPROCESS_INFORMATION pProcInfo
    )
{
    BOOL   Result;
    HANDLE hPipe = NULL;
    WCHAR  szPipeName[MAX_PATH];
    PCHAR  ptr;
    ULONG  Count, AmountWrote, AmountRead;
    DWORD  MyProcId;
    PEXECSRV_REQUEST pReq;
    EXECSRV_REPLY    Rep;
    CHAR Buf[EXECSRV_BUFFER_SIZE];
    ULONG  MaxSize = EXECSRV_BUFFER_SIZE;

    if( lpszImageName )
        CairoleDebugOut((DEB_TRACE, "EXECCLIENT: lpszImageName %ws\n",lpszImageName));

    if( lpszCommandLine )
        CairoleDebugOut((DEB_TRACE, "EXECCLIENT: lpszCommandLine %ws\n",lpszCommandLine));

    // Winlogon handles all now. System flag tells it what to do
    swprintf(szPipeName, EXECSRV_SYSTEM_PIPE_NAME, SessionId);

    while (TRUE) {

        hPipe = CreateFileW(
                    szPipeName,
                    GENERIC_READ|GENERIC_WRITE,
                    0,    // File share mode
                    NULL, // default security
                    OPEN_EXISTING,
                    0,    // Attrs and flags
                    NULL  // template file handle
                    );

        if( hPipe == INVALID_HANDLE_VALUE ) {

            if (GetLastError() == ERROR_PIPE_BUSY) {

                if (!WaitNamedPipe( szPipeName, 30000 )) { // 30 sec

                    CairoleDebugOut((DEB_ERROR, "EXECCLIENT: Waited too long for pipe name %ws\n", szPipeName));
                    return(FALSE);
                }
            } else {

                CairoleDebugOut((DEB_ERROR, "EXECCLIENT: Could not create pipe name %ws\n", szPipeName));
                return(FALSE);
            }
        } else {

            break;
        }
    }

    /*
     * Get the handle to the current process
     */
    MyProcId = GetCurrentProcessId();

    /*
     * setup the marshalling
     */
    ptr = Buf;
    Count = 0;

    pReq = (PEXECSRV_REQUEST)ptr;
    ptr   += sizeof(EXECSRV_REQUEST);
    Count += sizeof(EXECSRV_REQUEST);

    // set the basic parameters
    pReq->hToken = hSaferToken;
    pReq->System = System;
    pReq->RequestingProcessId = MyProcId;
    pReq->fInheritHandles = fInheritHandles;
    pReq->fdwCreate = fdwCreate;

    // marshall the ImageName string
    if( lpszImageName ) {
        pReq->lpszImageName = MarshallString( lpszImageName, Buf, MaxSize, &ptr, &Count );
    }
    else {
        pReq->lpszImageName = NULL;
    }

    // marshall in the CommandLine string
    if( lpszCommandLine ) {
        pReq->lpszCommandLine = MarshallString( lpszCommandLine, Buf, MaxSize, &ptr, &Count );
    }
    else {
        pReq->lpszCommandLine = NULL;
    }

    // marshall in the CurDir string
    if( lpszCurDir ) {
        pReq->lpszCurDir = MarshallString( lpszCurDir, Buf, MaxSize, &ptr, &Count );
    }
    else {
        pReq->lpszCurDir = NULL;
    }

    // marshall in the StartupInfo structure
    RtlMoveMemory( &pReq->StartInfo, pStartInfo, sizeof(STARTUPINFO) );

    // Now marshall the strings in STARTUPINFO
    if( pStartInfo->lpDesktop ) {
        pReq->StartInfo.lpDesktop = MarshallString( pStartInfo->lpDesktop, Buf, MaxSize, &ptr, &Count );
    }
    else {
        pReq->StartInfo.lpDesktop = NULL;
    }

    if( pStartInfo->lpTitle ) {
        pReq->StartInfo.lpTitle = MarshallString( pStartInfo->lpTitle, Buf, MaxSize, &ptr, &Count );
    }
    else {
        pReq->StartInfo.lpTitle = NULL;
    }

    if( lpvEnvironment ) {
        pReq->lpvEnvironment = MarshallString( (PWCHAR)lpvEnvironment, Buf, MaxSize, &ptr, &Count, TRUE );
    }
    else {
        pReq->lpvEnvironment = NULL;
    }

    //
    // WARNING: This version does not pass the following:
    //
    //  Also saProcess and saThread are ignored right now and use
    //  the users default security on the remote WinStation
    //
    // Set things that are always NULL
    //
    pReq->StartInfo.lpReserved = NULL;  // always NULL

    // now fill in the total count
    pReq->Size = Count;

    /*
     * Now send the buffer out to the server
     */
    Result = WriteFile(
                 hPipe,
                 Buf,
                 Count,
                 &AmountWrote,
                 NULL
                 );

    if( !Result ) {
        CairoleDebugOut((DEB_ERROR, "EXECCLIENT: Error %d sending request\n",GetLastError()));
        goto Cleanup;
    }

    /*
     * Now read the reply
     */
    Result = ReadFile(
                 hPipe,
                 &Rep,
                 sizeof(Rep),
                 &AmountRead,
                 NULL
                 );

    if( !Result ) {
        CairoleDebugOut((DEB_ERROR, "EXECCLIENT: Error %d reading reply\n",GetLastError()));
        goto Cleanup;
    }

    /*
     * Check the result
     */
    if( !Rep.Result ) {
        CairoleDebugOut((DEB_ERROR, "EXECCLIENT: Error %d in reply\n",Rep.LastError));
        // set the error in the current thread to the returned error
        Result = Rep.Result;
        SetLastError( Rep.LastError );
        goto Cleanup;
    }

    /*
     * We copy the PROCESS_INFO structure from the reply
     * to the caller.
     *
     * The remote site has duplicated the handles into our
     * process space for hProcess and hThread so that they will
     * behave like CreateProcessW()
     */

     RtlMoveMemory( pProcInfo, &Rep.ProcInfo, sizeof( PROCESS_INFORMATION ) );

Cleanup:
    CloseHandle(hPipe);

    CairoleDebugOut((DEB_TRACE, "EXECCLIENT: Result 0x%x\n", Result));

    return(Result);
}

/*****************************************************************************
 *
 *  MarshallString
 *
 *   Marshall in a UNICODE_NULL terminated WCHAR string
 *
 * ENTRY:
 *   pSource (input)
 *     Pointer to source string
 *
 *   pBase (input)
 *     Base buffer pointer for normalizing the string pointer
 *
 *   MaxSize (input)
 *     Maximum buffer size available
 *
 *   ppPtr (input/output)
 *     Pointer to the current context pointer in the marshall buffer.
 *     This is updated as data is marshalled into the buffer
 *
 *   pCount (input/output)
 *     Current count of data in the marshall buffer.
 *     This is updated as data is marshalled into the buffer
 *
 *   bMulti (optional input)
 *     If TRUE then marshall in a multi UNICODE string. Each string are
 *     UNICODE_NULL terminated and the multi string is terminated with a double
 *     UNICODE_NULL. The default value is FALSE.
 *
 * EXIT:
 *   NULL - Error
 *   !=NULL "normalized" pointer to the string in reference to pBase
 *
 ****************************************************************************/

PWCHAR
MarshallString(
    PWCHAR pSource,
    PCHAR  pBase,
    ULONG  MaxSize,
    PCHAR  *ppPtr,
    PULONG pCount,
    BOOL   bMulti
    )
{
    ULONG Len;
    PCHAR ptr;

    if (bMulti) {

        Len = 0;

        for (PWCHAR pStr = pSource; *pStr; ) {

            ULONG StrLen = wcslen( pStr ) + 1; // include the NULL

            Len += StrLen;
            pStr += StrLen;

            // bail out if too long
            if( (*pCount + (Len * sizeof(WCHAR))) > MaxSize ) {
                return( NULL );
            }
        }

        Len++; // include last NULL

    } else {
        Len = wcslen( pSource );
        Len++; // include the NULL
    }

    Len *= sizeof(WCHAR); // convert to bytes

    if( (*pCount + Len) > MaxSize ) {
        return( NULL );
    }

    RtlMoveMemory( *ppPtr, pSource, Len );

    // the normalized ptr is the current count - Sundown: zero-extended value.
    ptr = (PCHAR)ULongToPtr(*pCount);

    *ppPtr += Len;
    *pCount += Len;

    return((PWCHAR)ptr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\olescm\mach.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:   mach.cxx
//
//  Contents:
//      Machine naming helper objects
//
//  History:
//--------------------------------------------------------------------------

#include    "act.hxx"
#include    <mach.hxx>
#include    <misc.hxx>

// Singleton instance:
CMachineName gMachineName;

// Defn of global ptr external parties use:
CMachineName * gpMachineName = &gMachineName;

CIPAddrs::CIPAddrs() :
    _lRefs(1),  // constructed with non-zero refcount!
    _pIPAddresses(NULL)
{
}

CIPAddrs::~CIPAddrs()
{
    ASSERT(_lRefs == 0);

    if (_pIPAddresses)
    {
        PrivMemFree(_pIPAddresses);
    }
}

void CIPAddrs::IncRefCount()
{
    InterlockedIncrement(&_lRefs);
}

void CIPAddrs::DecRefCount()
{
    LONG lRefs = InterlockedDecrement(&_lRefs);
    if (lRefs == 0)
    {
        delete this;
    }
}


CMachineName::CMachineName()
{
    _socket = INVALID_SOCKET;
    _pAddrQueryBuf = NULL;
    _dwAddrQueryBufSize = 0;
    _bIPAddrsChanged = FALSE;
    _dwcResets = 0;
    _wszMachineName[0] = 0;
    _bInitialized = FALSE;
    _pwszDNSName = 0;
    _pIPAddresses = 0;
    _pAliases = NULL;

    NTSTATUS status;

    // Initialize lock
    status = RtlInitializeCriticalSection(&_csMachineNameLock); 
    _bInitialized = NT_SUCCESS(status);
}

DWORD CMachineName::Initialize()
{
    NTSTATUS status = NO_ERROR;
    
    ASSERT(gpClientLock->HeldExclusive());
	
    // Get computer name if we haven't done so already:
    if (!_wszMachineName[0])
    {
        SetName();
    }
    
    // Get DNS name if we haven't done so already.   Note that we 
    // currently have no way of knowing when the DNS name changes 
    // (unlike IP address changes), so it is left alone once set.    
    if (!_pwszDNSName)
    {
        SetDNSName();
    }

    return status;
}

BOOL
CMachineName::Compare( IN WCHAR * pwszName )
{
    CIPAddrs* pIPAddrs = NULL;

    ASSERT(_bInitialized);

    if ( lstrcmpiW( pwszName, _wszMachineName ) == 0 )
        return TRUE;

    if ( lstrcmpiW( pwszName, L"localhost" ) == 0 )
        return TRUE;

    if ( lstrcmpiW( pwszName, L"127.0.0.1" ) == 0 )
        return TRUE;

    if (! _pwszDNSName )
        SetDNSName();
    
    if ( _pwszDNSName && lstrcmpiW( pwszName, _pwszDNSName ) == 0 )
        return TRUE;
	
    pIPAddrs = GetIPAddrs();
    if (pIPAddrs)
    {
        NetworkAddressVector* pNetworkAddrVector = pIPAddrs->_pIPAddresses;
        for ( DWORD n = 0; n < pNetworkAddrVector->Count; n++ )
        {
            if ( lstrcmpiW( pwszName, pNetworkAddrVector->NetworkAddresses[n] ) == 0 )
            {
                pIPAddrs->DecRefCount();
                return TRUE;
            }
        }
        pIPAddrs->DecRefCount();
    }
    
    if (_pAliases)
    {
        for (DWORD n=0; _pAliases[n]; n++)
        {
            if ( lstrcmpiW( pwszName, _pAliases[n] ) == 0 )
                return TRUE;
        }
    }

    return FALSE;
}

//
//  CMachineName::GetIPAddrs()
//
//  Returns a pointer to a refcounted CIPAddrs for this 
//  machine.    If we don't yet have a non-localhost ip, 
//  then we keep trying to get one.
// 
CIPAddrs* CMachineName::GetIPAddrs()
{
    ASSERT(_bInitialized);

    CMutexLock lock(&_csMachineNameLock);
    
    // _bIPAddrsChanged will TRUE if we were notified of 
    // an address change
    if (_bIPAddrsChanged || !_pIPAddresses)
    {       
        CIPAddrs* pIPAddrs = NULL;
        NetworkAddressVector* pNewAddrVector = NULL;
        
        // Create a new wrapper object
        pIPAddrs = new CIPAddrs;  // refcount starts as 1
        if (!pIPAddrs)
            return NULL;
        
        // Build a new IP address vector:
        pNewAddrVector = COMMON_IP_BuildAddressVector();
        if (!pNewAddrVector)
        {
            pIPAddrs->DecRefCount();
            return NULL;
        }
        
        // Store the new vector in the wrapper object:
        pIPAddrs->_pIPAddresses = pNewAddrVector;
        
        _dwcResets++;  // debug counter 
        
        // Clear dirty flag
        _bIPAddrsChanged = FALSE;

        // Release old copy
        if (_pIPAddresses)
            _pIPAddresses->DecRefCount();

        // Update our cached copy
        _pIPAddresses = pIPAddrs;
        
        // Bump refcount and return
        _pIPAddresses->IncRefCount();
        return _pIPAddresses;
    }  
    else
    {
        // Don't need to recalculate our ip's.  Just refcount the cached object and 
        // return it.
        ASSERT(_pIPAddresses);
        _pIPAddresses->IncRefCount();
        return _pIPAddresses;
    }
}

void
CMachineName::SetName()
{
    DWORD   Size;

    Size = sizeof(_wszMachineName);

    (void) GetComputerNameW( _wszMachineName, &Size );
}

void
CMachineName::SetDNSName()
{
    char        hostname[IPMaximumPrettyName];
    HOSTENT *   HostEnt = 0;
    DWORD       Length;
    int         Status;

    if (gethostname(hostname, IPMaximumPrettyName) != 0)
        return;

    HostEnt = gethostbyname(hostname);
    if ( ! HostEnt )
        return;

    Length = lstrlenA( HostEnt->h_name ) + 1;
    _pwszDNSName = (WCHAR *) PrivMemAlloc( Length * sizeof(WCHAR) );

    if ( ! _pwszDNSName )
        return;

    Status = MultiByteToWideChar(
                    CP_ACP,
                    0,
                    HostEnt->h_name,
                    Length,
                    _pwszDNSName,
                    Length );

    if ( ! Status )
    {
        PrivMemFree( _pwszDNSName );
		_pwszDNSName = 0;
    }
    
    SetHostAliases(HostEnt);
}

void CMachineName::SetHostAliases(HOSTENT *pHostEnt)
{
    if (!pHostEnt->h_aliases)
    {
        return;
    }
    
    //
    // sum up the number of bytes needed for allocation
    //
    
    ULONG cAliases = 0;
    ULONG cbAliases = 0;
    while (pHostEnt->h_aliases[cAliases])
    {
        cbAliases += sizeof(WCHAR) * (lstrlenA(pHostEnt->h_aliases[cAliases]) + 1);
        cAliases++;
    }
    
    if (cAliases == 0)
    {
        return;
    }
    

    //
    // allocate one chunk of memory
    //
    
    _pAliases = (WCHAR **) PrivMemAlloc(((cAliases+1) * sizeof(WCHAR*)) + cbAliases);
    
    if (!_pAliases)
    {
        return;
    }
    
    WCHAR *pStrings = (WCHAR *) ( _pAliases + cAliases + 1 );
    
    ULONG i;
    
    // 
    // copy the strings
    //
    
    for (i=0; i<cAliases; i++)
    {
        MultiByteToWideChar(
                CP_ACP,
                0,
                pHostEnt->h_aliases[i],
                -1,
                pStrings,
                IPMaximumPrettyName
                );
        _pAliases[i] = pStrings;
        
        pStrings += (wcslen(pStrings) + 1);
    }
    
    // null terminator
    _pAliases[cAliases] = NULL;
    
    
    return;
}

NetworkAddressVector*
CMachineName::COMMON_IP_BuildAddressVector()
/*++

Routine Description:

    Builds a vector of IP addresses supported by this machine.

Arguments:

    None

Return Value:

    non-NULL -- a valid NetworkAddressVector
    NULL - error occurred

--*/
{
    int ret;
    DWORD dwBytesReturned;
    int i;
    DWORD dwVectMemNeeded = 0;
    LPSOCKET_ADDRESS_LIST pSocketAddrList = NULL;
    NetworkAddressVector* pVector = NULL;
    char* pszIPAddress;

    // Allocate socket if we haven't already
    if (_socket == INVALID_SOCKET)
    {
        _socket = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
        if (_socket == INVALID_SOCKET)
            return NULL;

        // else we got a socket, which we keep forever.
    }
    
    while (TRUE)
    {
        ret = WSAIoctl(_socket,
                       SIO_ADDRESS_LIST_QUERY,
                       NULL,
                       0,
                       _pAddrQueryBuf,
                       _dwAddrQueryBufSize,
                       &dwBytesReturned,
                       NULL,
                       NULL);
        if (ret == 0)
        {
            // Success, break out and keep going
            break;
        }
        else
        {
            // Failed.  If need bigger buffer, allocate it
            // and try again. Otherwise fail.
            if (WSAGetLastError() == WSAEFAULT)
            {
                ASSERT(dwBytesReturned > _dwAddrQueryBufSize);

                delete _pAddrQueryBuf;
                _dwAddrQueryBufSize = 0;

                _pAddrQueryBuf = new BYTE[dwBytesReturned];
                if (!_pAddrQueryBuf)
                    return NULL;

                _dwAddrQueryBufSize = dwBytesReturned;              
            }
            else
            {
                // some other error
                return NULL;
            }
        }
    }

    // Okay, we now have successfully queried the socket for 
    // the latest and greatest IP addresses assigned to this
    // machine.  Now we need to allocate and fill in a 
    // NetworkAddressVector structure.
    
    pSocketAddrList = (LPSOCKET_ADDRESS_LIST)_pAddrQueryBuf;

    // Handle case with no addresses
    if (pSocketAddrList->iAddressCount == 0)
    {
        // Allocate an empty vector
        pVector = (NetworkAddressVector*)PrivMemAlloc(sizeof(NetworkAddressVector));
        if (pVector)
        {
            pVector->Count = 0;
            pVector->NetworkAddresses = NULL;
        }
        return pVector;
    }

    // Calculate how much memory needed
    dwVectMemNeeded = sizeof(NetworkAddressVector) + 
                      (pSocketAddrList->iAddressCount * sizeof(WCHAR*));

    for (i = 0; i < pSocketAddrList->iAddressCount; i++)
    {        
        pszIPAddress = inet_ntoa(((SOCKADDR_IN*)pSocketAddrList->Address[i].lpSockaddr)->sin_addr);
        ASSERT(pszIPAddress);

        dwVectMemNeeded += ((lstrlenA(pszIPAddress) + 1) * sizeof(WCHAR));
    }
    
    pVector = (NetworkAddressVector*)PrivMemAlloc(dwVectMemNeeded);
    if (!pVector)
        return NULL;
	
    // Init struct
    pVector->Count = pSocketAddrList->iAddressCount;
    pVector->NetworkAddresses = (WCHAR**)&pVector[1];
    pVector->NetworkAddresses[0] = (WCHAR*)&pVector->NetworkAddresses[pSocketAddrList->iAddressCount];

    // Copy in addresses
    for (i = 0; i < pSocketAddrList->iAddressCount; i++)
    {
        pszIPAddress = inet_ntoa(((SOCKADDR_IN*)pSocketAddrList->Address[i].lpSockaddr)->sin_addr);
        ASSERT(pszIPAddress);
                    
        ret = MultiByteToWideChar(
                        CP_ACP,
                        0,
                        pszIPAddress,
                        -1,
                        pVector->NetworkAddresses[i],
                        IPMaximumPrettyName
                        );      
        if (ret == 0)
        {
            PrivMemFree(pVector);
            return NULL;
        }
    
        if (i != (pSocketAddrList->iAddressCount - 1))
        {
            // Setup for next address, if any
            pVector->NetworkAddresses[i+1] = pVector->NetworkAddresses[i];
            pVector->NetworkAddresses[i+1] += lstrlenW(pVector->NetworkAddresses[i]) + 1;
        }
    }

    return pVector;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\olescm\net.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:   net.cxx
//
//  Contents:
//      Net helper functions.
//
//  History:
//--------------------------------------------------------------------------

#include "act.hxx"

#if 1 // #ifndef _CHICAGO_

DWORD APIENTRY ScmWNetGetUniversalName(
    LPCWSTR lpLocalPath,
    DWORD    dwInfoLevel,
    LPVOID   lpBuffer,
    LPDWORD  lpBufferSize
    )
{
    static GET_UNIVERSAL_NAME_FUNC pfnWNetGetUniversalName = 0;

    HINSTANCE   hLib;

    if ( pfnWNetGetUniversalName == 0 )
    {
        hLib = LoadLibraryT( TEXT("mpr.dll") );
        if ( ! hLib )
            return GetLastError();

        pfnWNetGetUniversalName =
            (GET_UNIVERSAL_NAME_FUNC) GetProcAddress( hLib, "WNetGetUniversalNameW" );

        if ( pfnWNetGetUniversalName == 0 )
            return GetLastError();
    }

    return (*pfnWNetGetUniversalName)( lpLocalPath, dwInfoLevel, lpBuffer, lpBufferSize );
}


NET_API_STATUS NET_API_FUNCTION ScmNetShareGetInfo(
    LPTSTR  servername,
    LPTSTR  netname,
    DWORD   level,
    LPBYTE  *bufptr
    )
{
    static NET_SHARE_GET_INFO_FUNC pfnNetShareGetInfo = 0;

    HINSTANCE   hLib;

    if ( pfnNetShareGetInfo == 0 )
    {
        hLib = LoadLibraryT( TEXT("netapi32.dll") );
        if ( ! hLib )
            return GetLastError();

        pfnNetShareGetInfo =
            (NET_SHARE_GET_INFO_FUNC) GetProcAddress( hLib, "NetShareGetInfo" );

        if ( pfnNetShareGetInfo == 0 )
            return GetLastError();
    }

    return (*pfnNetShareGetInfo)( servername, netname, level, bufptr );
}

HRESULT ScmGetUniversalName(
    LPCWSTR lpLocalPath,        // original path
    LPWSTR   lpBuffer,          // buffer for UNC path
    LPDWORD  lpBufferSize       // size of buffer in WCHARs
    )
{
    // The local path is assumed to be absolute -- either UNC or drive-based

    if (lpLocalPath[0] == L'\\' && lpLocalPath[1] == L'\\') // UNC path
    {
        DWORD dwLocal = lstrlenW(lpLocalPath);

        if (*lpBufferSize - dwLocal > 0)
        {
            lstrcpyW(lpBuffer,lpLocalPath);
            return NO_ERROR;
        }
        else
        {
            *lpBufferSize = dwLocal + 1;
            return ERROR_MORE_DATA;
        }
    }
    else if (lpLocalPath[1] == L':' && lpLocalPath[2] == L'\\') // drive-based path
    {
        WCHAR drive[3];
        drive[0] = lpLocalPath[0];
        drive[1] = L':';
        drive[2] = 0;

        WCHAR remConnection[MAX_PATH+1];
        WCHAR *pszPath = remConnection;
        DWORD dwSize = (MAX_PATH+1) * sizeof(WCHAR);

        DWORD Status = OleWNetGetConnection(drive, pszPath, &dwSize);
        if (Status != NO_ERROR)
        {
            return CO_E_BAD_PATH;
        }

        lpLocalPath += 2;
        DWORD dwNetLength = lstrlenW(pszPath);
        DWORD dwFullLength =  dwNetLength + lstrlenW(lpLocalPath);

        if (*lpBufferSize - dwFullLength > 0)
        {
            lstrcpyW(lpBuffer,pszPath);
            lpBuffer += dwNetLength;
            lstrcpyW(lpBuffer,lpLocalPath);
            return NO_ERROR;
        }
        else
        {
            *lpBufferSize = dwFullLength + 1;
            return ERROR_MORE_DATA;
        }
    }
    else
    {
        return CO_E_BAD_PATH;
    }
}

#else // _CHICAGO_

// From objex, which doesn't have shared source code for NT & win9x.
RPC_STATUS
IP_BuildAddressVector(
    OUT NETWORK_ADDRESS_VECTOR **ppAddressVector
    )
/*++

Routine Description:

    Builds a vector of IP addresses supported by this machine.

Arguments:

    ppAddressVector - A place to store the vector.

Return Value:

    RPC_S_OK
    RPC_S_OUT_OF_MEMORY
    RPC_S_OUT_OF_RESOURCES

--*/
{
    // Figure out all of our IP addresses
    CHAR hostname[IP_MAXIMUM_PRETTY_NAME];
    PHOSTENT phostent;
    UINT i;

    if (gethostname(hostname, IP_MAXIMUM_PRETTY_NAME) != 0)
        {
        return(RPC_S_OUT_OF_RESOURCES);
        }

    if ( (phostent = gethostbyname(hostname)) == 0)
        {
        return(RPC_S_OUT_OF_RESOURCES);
        }

    // Count ip addresses
    UINT cAddrs = 0;

    while(phostent->h_addr_list[cAddrs])
        cAddrs++;

    NETWORK_ADDRESS_VECTOR *pVector;

    pVector = (NETWORK_ADDRESS_VECTOR *)
              PrivMemAlloc( sizeof(NETWORK_ADDRESS_VECTOR)
                            + (cAddrs * sizeof(WCHAR *))
                            + (cAddrs * IP_MAXIMUM_RAW_NAME * sizeof(WCHAR)) );

    if (pVector == NULL)
        {
        return(RPC_S_OUT_OF_MEMORY);
        }

    pVector->Count = 0;
    pVector->NetworkAddresses = (WCHAR **) &pVector[1];
    pVector->NetworkAddresses[0] = (WCHAR *)&pVector->NetworkAddresses[cAddrs];

    char * pszAddress;
    int Status;

    for ( i = 0; (i < cAddrs) && (phostent->h_addr_list[i]); i++ )
    {
        pszAddress = inet_ntoa(*(struct in_addr *)phostent->h_addr_list[i]);

        Status = MultiByteToWideChar(
                CP_ACP,
                0,
                pszAddress,
                -1,
                pVector->NetworkAddresses[i],
                IP_MAXIMUM_RAW_NAME
                );

        if ( 0 == Status )
        {
            PrivMemFree(pVector);
            return(RPC_S_OUT_OF_RESOURCES);
        }

        pVector->Count++;

        if (i != cAddrs - 1)
        {
            // Setup for next address, if any
            pVector->NetworkAddresses[i+1] = pVector->NetworkAddresses[i];
            pVector->NetworkAddresses[i+1] += lstrlenW(pVector->NetworkAddresses[i]) + 1;
        }
    }

    *ppAddressVector = pVector;

    return(RPC_S_OK);
}

#endif // _CHICAGO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\olescm\install.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       install.cxx
//
//  Contents:   Routines for queries/install of application state in the DS.
//
//  Functions:
//
//  History:    Feb-97  DKays   Created
//              Nov-97  DebiM   Changed for Beta2
//
//--------------------------------------------------------------------------

#include "act.hxx"

#ifdef DIRECTORY_SERVICE

HRESULT DarwinPackageAssign( LPCWSTR pwszScript, BOOL InstallNow );

//+-------------------------------------------------------------------------
//
//  CSGetClass
//
//  Attempts to lookup and possibly install a class.
//
//--------------------------------------------------------------------------
HRESULT CSGetClass(
    DWORD               dwFlags,
    uCLSSPEC *          pClassSpec,
    QUERYCONTEXT *      pQueryContext,
    CLSID *             pClsid,
    INSTALLINFO  **     ppInstallInfo
    )
{
    HRESULT         hr;
    INSTALLINFO     InstallInfo;

    *pClsid = CLSID_NULL;
    *ppInstallInfo = 0;


/*
    if ( ! gpClassAccess )
        return CS_E_NO_CLASSSTORE;

    hr = gpClassAccess->GetAppInfo( pClassSpec, &QueryContext, &InstallInfo );

*/
    
    //
    // Impersonate as calling user 
    // Do ClassStore Lookup
    //
    hr = RpcImpersonateClient( NULL );
    if (hr != RPC_S_OK)
        return hr;

    hr = CsGetAppInfo( pClassSpec, pQueryContext, &InstallInfo );

    RevertToSelf();

    if ( hr != S_OK )
        return hr;

    //
    // Only one package is returned.
    //

    if ( DrwFilePath == InstallInfo.PathType )
    {
        hr = DarwinPackageAssign( InstallInfo.pszScriptPath, FALSE );
    }
    else
    {
        //
        // Return one of the ClassIDs. This is for IE use only.
        //
        if ( pClassSpec->tyspec != TYSPEC_CLSID )
        {
            if ( InstallInfo.pClsid )
                 *pClsid = *(InstallInfo.pClsid);
        }

    }

    *ppInstallInfo = (INSTALLINFO *) CoTaskMemAlloc (sizeof(INSTALLINFO));
    memcpy( *ppInstallInfo, &InstallInfo, sizeof(INSTALLINFO) );

    return hr;
}


HRESULT
DarwinPackageAssign(
    IN  LPCWSTR pwszScript,
    IN  BOOL    InstallNow )
{
    BOOL    bStatus;
    HRESULT hr;

    hr = RpcImpersonateClient( NULL );
    if (hr != RPC_S_OK) {
        return hr;
    }

    bStatus = AssignApplication( pwszScript, InstallNow );

    RevertToSelf();

    if ( ! bStatus )
        return HRESULT_FROM_WIN32( GetLastError() );

    return S_OK;
}
#endif // DIRECTORY_SERVICE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\olescm\launch.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       launch.cxx
//
//  Contents:
//
//  History:    ?-??-??   ???       Created
//              6-17-99   a-sergiv  Added event log filtering
//
//--------------------------------------------------------------------------

#include "act.hxx"

#include <winbasep.h> // For CreateProcessInternalW

extern "C" {
#include <execsrv.h>
}
#include "execclt.hxx"

const ULONG MAX_SERVICE_ARGS = 16;

const WCHAR REGEVENT_PREFIX[] = L"RPCSS_REGEVENT:";
const DWORD REGEVENT_PREFIX_STRLEN = sizeof(REGEVENT_PREFIX) / sizeof(WCHAR) - 1;

const WCHAR INITEVENT_PREFIX[] = L"RPCSS_INITEVENT:";
const DWORD INITEVENT_PREFIX_STRLEN = sizeof(INITEVENT_PREFIX) / sizeof(WCHAR) - 1;

extern "C"
{
    HANDLE
    GetCurrentUserTokenW(WCHAR Winsta[],
                         DWORD DesiredAccess);
};

//
// Small wrapper class around userenv.dll, so we don't have to link to it.
//
class CUserEnv
{
    typedef BOOL (WINAPI *PFNCREATEENVBLOCK)  (LPVOID *, HANDLE, BOOL);
    typedef BOOL (WINAPI *PFNDESTROYENVBLOCK) (LPVOID);

  public:
    CUserEnv()
    {
        // Load the DLL, null out the function pointers.
        _hUserEnv = LoadLibrary(L"userenv.dll");
        _pfnCreateEnvironmentBlock = NULL;
        _pfnDestroyEnvironmentBlock = NULL;
    }

    ~CUserEnv()
    {
        // Null the function pointers, unload the DLL.
        _pfnCreateEnvironmentBlock = NULL;
        _pfnDestroyEnvironmentBlock = NULL;
        if (_hUserEnv)
            FreeLibrary(_hUserEnv);
    }

    void Init()
    {
        // If we loaded the DLL ok, go get the function pointers.
        if (_hUserEnv)
        {
            _pfnCreateEnvironmentBlock  = (PFNCREATEENVBLOCK)GetProcAddress(_hUserEnv,
                                                                            "CreateEnvironmentBlock");
            _pfnDestroyEnvironmentBlock = (PFNDESTROYENVBLOCK)GetProcAddress(_hUserEnv,
                                                                             "DestroyEnvironmentBlock");
        }
    }

    BOOL CreateEnvironmentBlock(LPVOID *lpEnvironment,
                                HANDLE  hToken,
                                BOOL    bInherit)
    {
        // Initialize on demand.
        if (!_pfnCreateEnvironmentBlock)
            Init();

        if (_pfnCreateEnvironmentBlock)
        {
            return _pfnCreateEnvironmentBlock(lpEnvironment,
                                              hToken,
                                              bInherit);
        }
        else
        {
            SetLastError(ERROR_PROC_NOT_FOUND);
            return FALSE;
        }
    }

    BOOL DestroyEnvironmentBlock(LPVOID lpEnvironment)
    {
        // Initialize on demand.
        if (!_pfnDestroyEnvironmentBlock)
            Init();
        
        if (_pfnDestroyEnvironmentBlock)
        {
            return _pfnDestroyEnvironmentBlock(lpEnvironment);
        }
        else
        {
            SetLastError(ERROR_PROC_NOT_FOUND);
            return FALSE;
        }
    }

  private:
    HMODULE            _hUserEnv;
    PFNCREATEENVBLOCK  _pfnCreateEnvironmentBlock;
    PFNDESTROYENVBLOCK _pfnDestroyEnvironmentBlock;

} g_UserEnv;


HRESULT
CClsidData::GetAAASaferToken(
    IN  CToken *pClientToken,
    OUT HANDLE *pTokenOut
)
/*++
 
Routine Description:
 
    Get the token that will be used in an Activate As Activator
    launch.  This token is the more restricted of the incoming
    token and the configured safer level.
 
Arguments:
 
    pClientToken - token of the user doing the activation

    pTokenOut - out parameter that will recieve the handle to use
                in the activation.

Return Value:
 
    S_OK: Everything went fine.  The caller owns a reference on
          pTokenOut and must close it.
    S_FALSE: Everything went fine.  The caller does not own a 
          reference on pToken out and does not need to close it.

    Anything else: An error occured.
 
--*/
{
    HANDLE  hSaferToken = NULL;
    HRESULT hr = S_OK;
    BOOL    bStatus = TRUE;

    *pTokenOut = NULL;

    Win4Assert(SaferLevel() && "Called GetAAASaferToken with SAFER disabled!");
    if (!SaferLevel()) return E_UNEXPECTED;

    // Get the safer token for this configuration.
    bStatus = SaferComputeTokenFromLevel(SaferLevel(),
                                         pClientToken->GetToken(),
                                         &hSaferToken,
                                         0,
                                         NULL);
    if (bStatus)
    {
        hr = pClientToken->CompareSaferLevels(hSaferToken);

        if (hr == S_OK)
        {
            CloseHandle(hSaferToken);
            hSaferToken = pClientToken->GetToken(); 

            // Shared reference, return S_FALSE.
            hr = S_FALSE;
        }
        else
        {
            hr = S_OK;
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    *pTokenOut = hSaferToken;            

    return hr;
}
                    
HRESULT
CClsidData::LaunchActivatorServer(
    IN  CToken *    pClientToken,
    IN  WCHAR *     pEnvBlock,
    IN  DWORD       EnvBlockLength,
    IN  BOOL        fIsRemoteActivation,
    IN  BOOL        fClientImpersonating,
    IN  WCHAR*      pwszWinstaDesktop,
    IN  DWORD       clsctx,
    OUT HANDLE *    phProcess,
    OUT DWORD *     pdwProcessId
    )
{    
    WCHAR *                 pwszCommandLine;
    WCHAR *                 pFinalEnvBlock;
    STARTUPINFO             StartupInfo;
    PROCESS_INFORMATION     ProcessInfo;
    SECURITY_ATTRIBUTES     saProcess;
    PSECURITY_DESCRIPTOR    psdNewProcessSD;
    HRESULT                 hr;
    DWORD                   CreateFlags;
    BOOL                    bStatus;
    ULONG                   SessionId = 0;
    HANDLE                  hSaferToken = NULL;
    BOOL                    bCloseSaferToken = TRUE;

    *phProcess = NULL;
    *pdwProcessId = 0;

    if ( ! pClientToken )
        return (E_ACCESSDENIED);

    pFinalEnvBlock = NULL;
    StartupInfo.cb = sizeof(StartupInfo);
    StartupInfo.lpReserved = NULL;

    // Choose desktop for new server:
    //   client remote  ->  system chooses desktop
    //   client local, not impersonating ->  we pick client's desktop
    //   client local, impersonating ->  system chooses desktop
    StartupInfo.lpDesktop = (fIsRemoteActivation || fClientImpersonating) ? L"" : pwszWinstaDesktop;
    StartupInfo.lpTitle = (SERVERTYPE_SURROGATE == _ServerType) ? NULL : _pwszServer;
    StartupInfo.dwX = 40;
    StartupInfo.dwY = 40;
    StartupInfo.dwXSize = 80;
    StartupInfo.dwYSize = 40;
    StartupInfo.dwFlags = 0;
    StartupInfo.wShowWindow = SW_SHOWNORMAL;
    StartupInfo.cbReserved2 = 0;
    StartupInfo.lpReserved2 = NULL;

    ProcessInfo.hThread = 0;
    ProcessInfo.hProcess = 0;
    ProcessInfo.dwProcessId = 0;

    hr = GetLaunchCommandLine( &pwszCommandLine );
    if ( hr != S_OK )
        return (hr);

    if ( pEnvBlock )
    {
        hr = AddAppPathsToEnv( pEnvBlock, EnvBlockLength, &pFinalEnvBlock );
        if ( hr != S_OK )
        {
            PrivMemFree( pwszCommandLine );
            return (hr);
        }
    }

    CreateFlags = CREATE_NEW_CONSOLE | CREATE_SUSPENDED;

    if ( pFinalEnvBlock )
        CreateFlags |= CREATE_UNICODE_ENVIRONMENT;

    CAccessInfo AccessInfo( pClientToken->GetSid() );

    //
    // Apply configured safer restrictions to the token we're using to launch.
    // SAFER might not be enabled at all, in which case we don't need to do this.
    //
    if ( gbSAFERAAAChecksEnabled && SaferLevel() )
    {
        hr = GetAAASaferToken( pClientToken, &hSaferToken );
        if ( FAILED(hr) ) goto LaunchServerEnd;
        if ( hr == S_FALSE )
        {
            // GetAAASaferToken has returned a shared reference
            // to pClientToken.
            bCloseSaferToken = FALSE;
            hr = S_OK;
        }
        else
            bCloseSaferToken = TRUE;
    }
    else
    {
        hSaferToken = pClientToken->GetToken();
        bCloseSaferToken = FALSE;
    }

    //
    // This should never fail here, but if it did that would be a really,
    // really bad security breach, so check it anyway.
    //
    if ( ! ImpersonateLoggedOnUser( hSaferToken ) )
    {
        hr = E_ACCESSDENIED;
        goto LaunchServerEnd;
    }

    //
    // Initialize process security info (SDs).  We need both SIDs to
    // do this, so here is the 1st time we can.  We Delete the SD right
    // after the CreateProcess call, no matter what happens.
    //
    psdNewProcessSD = AccessInfo.IdentifyAccess(
                                               FALSE,
                                               PROCESS_ALL_ACCESS,
                                               PROCESS_SET_INFORMATION |          // Allow primary token to be set
                                               PROCESS_TERMINATE | SYNCHRONIZE    // Allow screen-saver control
                                               );

    if ( ! psdNewProcessSD )
    {
        RevertToSelf();
        hr = E_OUTOFMEMORY;
        goto LaunchServerEnd;
    }

    saProcess.nLength = sizeof(SECURITY_ATTRIBUTES);
    saProcess.lpSecurityDescriptor = psdNewProcessSD;
    saProcess.bInheritHandle = FALSE;

    SessionId = fIsRemoteActivation ? 0 : pClientToken->GetSessionId();

    if( SessionId != 0 ) {

        //
        // We must send the request to the remote WinStation
        // of the requestor
        //
        // NOTE: The current WinStationCreateProcessW() does not use
        //       the supplied security descriptor, but creates the
        //       process under the account of the logged on user.
        //
        // We do not stuff the security descriptor, so clear the suspend flag
        CreateFlags &= ~CREATE_SUSPENDED;
#if DBGX
        CairoleDebugOut((DEB_TRACE, "SCM: Sending CreateProcess to SessionId %d\n",SessionId));
#endif

        // Non-zero sessions have only one winstation/desktop which is
        // the default one. We will ignore the winstation/desktop passed
        // in and use the default one.
        // review: Figure this out TarunA 05/07/99
        //StartupInfo.lpDesktop = L"WinSta0\\Default";

        // jsimmons 4/6/00 -- note that if the client was impersonating, then we won't
        // launch the server under the correct identity.   More work needed to determine
        // if we can fully support this.

        //
        // Stop impersonating before doing the WinStationCreateProcess.
        // The remote winstation exec thread will launch the app under
        // the users context. We must not be impersonating because this
        // call only lets SYSTEM request the remote execute.
        //
        RevertToSelf();
	
	HANDLE hDuplicate = NULL;
	
	// We need to pass in the SAFER blessed token to TS so that the 
	// server can use that token
	
	// TS code will call CreateProcessAsUser, so we need to get a primary token
	
	if (DuplicateTokenForSessionUse(hSaferToken, &hDuplicate)) 
	{
	   if (bCloseSaferToken)
	   {
	       CloseHandle(hSaferToken);
	   }
	   hSaferToken = hDuplicate;
	   bCloseSaferToken = TRUE;
	   bStatus = CreateRemoteSessionProcess(
					       SessionId,
					       hSaferToken,
					       FALSE,               // Run as Logged on USER
					       NULL,                // application name
					       pwszCommandLine,     // command line
					       &saProcess,          // process sec attributes
					       NULL,                // default thread sec attributes
					       // (this was &saThread, but isn't needed)
					       FALSE,               // dont inherit handles
					       CreateFlags,         // creation flags
					       pFinalEnvBlock,      // use same enviroment block as the client
					       NULL,                // use same directory
					       &StartupInfo,        // startup info
					       &ProcessInfo         // proc info returned
					       );
	}

    }
    else
    {
        //
        // Do the exec while impersonating so the file access gets ACL
        // checked correctly.  Create the app suspended so we can stuff
        // a new token and resume the process.
        //        
        HANDLE hNewSaferToken = NULL;

        //
        // We need to use CreateProcessInternalW so that SAFER gets a chance
        // to play with the token (some more).
        //
        bStatus = CreateProcessInternalW(
                               hSaferToken,
                               NULL,
                               pwszCommandLine,
                               &saProcess,
                               NULL,
                               FALSE,
                               CreateFlags,
                               pFinalEnvBlock,
                               NULL,
                               &StartupInfo,
                               &ProcessInfo,
                               &hNewSaferToken);

        //
        // Everything else we do as ourself.
        //

        RevertToSelf();

        if (bStatus && hNewSaferToken)
        {
            if (bCloseSaferToken)
            {
                CloseHandle(hSaferToken);
            }

            hSaferToken = hNewSaferToken;
            bCloseSaferToken = TRUE;
        }
    }

    if ( ! bStatus )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        LogServerStartError( &_Clsid, clsctx, pClientToken, pwszCommandLine );
        goto LaunchServerEnd;
    }

    //
    // If the process was "started" in the shared WOW, we don't stuff the token
    // or attempt to resume the thread.  When a created process is in the shared
    // WOW its hThread is NULL.
    //
    //
    // We also only set it for the console. Remote Winstations always
    // launch under user security
    //
    if ( (SessionId == 0) && ( ProcessInfo.hThread ) )
    {
        // Set the primary token for the app
        bStatus = CreateAndSetProcessToken(
                                          &ProcessInfo,
                                          hSaferToken,
                                          pClientToken->GetSid() );

        if ( bStatus )
        {
            if ( ResumeThread( ProcessInfo.hThread ) == -1 )
                TerminateProcess( ProcessInfo.hProcess, 0 );
        }

        if ( ! bStatus )
            hr = HRESULT_FROM_WIN32( GetLastError() );
    }

LaunchServerEnd:

    if ( pFinalEnvBlock && pFinalEnvBlock != pEnvBlock )
        PrivMemFree( pFinalEnvBlock );

    if ( ProcessInfo.hThread )
        CloseHandle( ProcessInfo.hThread );

    if ( ProcessInfo.hProcess && ! bStatus )
    {
        CloseHandle( ProcessInfo.hProcess );
        ProcessInfo.hProcess = 0;
    }
    
    if ( hSaferToken && bCloseSaferToken )    
    {
        CloseHandle( hSaferToken );
    }

    *phProcess = ProcessInfo.hProcess;
    *pdwProcessId = ProcessInfo.dwProcessId;

    PrivMemFree( pwszCommandLine );

    return (hr);
}

//+-------------------------------------------------------------------------
//
//  LaunchRunAsServer
//
//--------------------------------------------------------------------------
HRESULT
CClsidData::LaunchRunAsServer(
    IN  CToken *    pClientToken,
    IN  BOOL        fIsRemoteActivation,
    IN  ActivationPropertiesIn *pActIn,
    IN  DWORD       clsctx,
    OUT HANDLE *    phProcess,
    OUT DWORD  *    pdwProcessId,
    OUT void**      ppvRunAsHandle
    )
{
    WCHAR *                 pwszCommandLine;
    STARTUPINFO             StartupInfo;
    PROCESS_INFORMATION     ProcessInfo;
    HANDLE                  hToken;
    SECURITY_ATTRIBUTES     saProcess;
    PSECURITY_DESCRIPTOR    psdNewProcessSD;
    PSID                    psidUserSid;
    HRESULT                 hr;
    BOOL                    bStatus;
    ULONG                   ulSessionId;
    BOOL                    bFromRunAsCache = FALSE;

    hr = GetLaunchCommandLine( &pwszCommandLine );
    if ( hr != S_OK )
        return (hr);
    
    *phProcess = NULL;
    
    *pdwProcessId = 0;
    
    hToken = NULL;
    bStatus = FALSE;
    
    StartupInfo.cb = sizeof(STARTUPINFO);
    StartupInfo.lpReserved  = NULL;
    StartupInfo.lpDesktop = NULL;
    StartupInfo.lpTitle = (SERVERTYPE_SURROGATE == _ServerType) ? NULL : _pwszServer;
    StartupInfo.dwFlags = 0;
    StartupInfo.cbReserved2 = 0;
    StartupInfo.lpReserved2 = NULL;
    
    ulSessionId = 0;
    
    if( IsInteractiveUser() )
    {
        if (!fIsRemoteActivation)
        {
            if ( !ImpersonateLoggedOnUser( pClientToken->GetToken() ) )
            {
                PrivMemFree(pwszCommandLine);
                return E_ACCESSDENIED;
            }
            
            RevertToSelf();
        }
        
        Win4Assert(pActIn);
        LONG lSessIdTemp;

        // Query for incoming session
        GetSessionIDFromActParams(pActIn, &lSessIdTemp);
        if (lSessIdTemp != INVALID_SESSION_ID)
        {
            ulSessionId = lSessIdTemp;
        }
        
        // Right now force all complus to
        // session 0. Session based activation
        // is still ill defined for complus
        // servers.
        if (_ServerType == SERVERTYPE_COMPLUS)
        {
            ulSessionId = 0;
        }
        
        if ( ulSessionId )
        {
            //
            // for a session, hToken is used only to build the psdNewProcessSD
            // and hToken must be closed
            //
            hToken = GetShellProcessToken( ulSessionId );
        }
        else
        {
            // hToken = GetShellProcessToken();
            hToken = GetCurrentUserTokenW(L"WinSta0", TOKEN_ALL_ACCESS);
        }
    }
    else
    {
        hToken = GetRunAsToken( clsctx,
                                AppidString(),
                                RunAsDomain(),
                                RunAsUser() );

        if (hToken)
        {
            hr = RunAsGetTokenElem(&hToken,
                                   ppvRunAsHandle);
            if (SUCCEEDED(hr))
                bFromRunAsCache = TRUE;
            else
            {
                Win4Assert((*ppvRunAsHandle == NULL) && "RunAsGetTokenElem failed but *ppvRunAsHandle is non-NULL");            
                PrivMemFree( pwszCommandLine );
                CloseHandle(hToken);
                return hr;
            }
        }
    }

    if ( ! hToken )
    {
        PrivMemFree( pwszCommandLine );
        return (CO_E_RUNAS_LOGON_FAILURE);
    }

    psdNewProcessSD = 0;

    psidUserSid = GetUserSid(hToken);

    CAccessInfo AccessInfo(psidUserSid);

    // We have to get past the CAccessInfo before we can use a goto.

    if ( psidUserSid )
    {
        psdNewProcessSD = AccessInfo.IdentifyAccess(
                                                   FALSE,
                                                   PROCESS_ALL_ACCESS,
                                                   PROCESS_SET_INFORMATION |          // Allow primary token to be set
                                                   PROCESS_TERMINATE | SYNCHRONIZE    // Allow screen-saver control
                                                   );
    }

    if ( ! psdNewProcessSD )
    {
        hr = E_OUTOFMEMORY;
        goto LaunchRunAsServerEnd;
    }

    saProcess.nLength = sizeof(SECURITY_ATTRIBUTES);
    saProcess.lpSecurityDescriptor = psdNewProcessSD;
    saProcess.bInheritHandle = FALSE;

    {
        //
        // Get the environment block of the user
        //
        LPVOID lpEnvBlock = NULL;

        bStatus = g_UserEnv.CreateEnvironmentBlock(&lpEnvBlock,hToken,FALSE);
        
        HANDLE hSaferToken = NULL;
        if(bStatus && SaferLevel())
        {
            bStatus = SaferComputeTokenFromLevel(SaferLevel(),
                                                 hToken,
                                                 &hSaferToken,
                                                 0,
                                                 NULL);
        }
        else
        {
            hSaferToken = hToken;
        }
        
        if (bStatus && (ulSessionId != 0))
        {
            bStatus = SetTokenInformation(hSaferToken,
                                          TokenSessionId,
                                          &ulSessionId,
                                          sizeof(ulSessionId));
        }
        
        if(bStatus)
        {
            //
            // This allows the process create to work with paths to remote machines.
            //
            (void) ImpersonateLoggedOnUser( hSaferToken );
            
            bStatus = CreateProcessAsUser(hSaferToken,
                                          NULL,
                                          pwszCommandLine,
                                          &saProcess,
                                          NULL,
                                          FALSE,
                                          CREATE_NEW_CONSOLE | CREATE_UNICODE_ENVIRONMENT,
                                          lpEnvBlock,
                                          NULL,
                                          &StartupInfo,
                                          &ProcessInfo);
            
            (void) RevertToSelf();
        }
    
        //
        // Free the environment block buffer
        //
        if (lpEnvBlock)
            g_UserEnv.DestroyEnvironmentBlock(lpEnvBlock);
        
        if (hSaferToken && SaferLevel())
            CloseHandle(hSaferToken);
    }

    if ( ! bStatus )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );

        LogRunAsServerStartError(
                                &_Clsid,
                                clsctx,
                                pClientToken,
                                pwszCommandLine,
                                RunAsUser(),
                                RunAsDomain() );
        goto LaunchRunAsServerEnd;
    }

    *phProcess = ProcessInfo.hProcess;
    *pdwProcessId = ProcessInfo.dwProcessId;

    NtClose( ProcessInfo.hThread );

LaunchRunAsServerEnd:

    if ( hToken )
    {
        NtClose( hToken );
    }

    if ( psidUserSid )
    {
        PrivMemFree(psidUserSid);
    }

    PrivMemFree( pwszCommandLine );

    if (!bFromRunAsCache)
        *ppvRunAsHandle = NULL;
    else
    if (!SUCCEEDED(hr))
    {
        RunAsRelease(*ppvRunAsHandle);
        *ppvRunAsHandle = NULL;
    }
    return (hr);
}

//+-------------------------------------------------------------------------
//
//  Member:     LaunchService
//
//--------------------------------------------------------------------------
HRESULT
CClsidData::LaunchService(
                         IN  CToken *    pClientToken,
                         IN  DWORD       clsctx,
                         OUT SC_HANDLE * phService
                         )
{
    WCHAR  *pwszArgs = NULL;
    ULONG   cArgs = 0;
    WCHAR  *apwszArgs[MAX_SERVICE_ARGS];
    BOOL    bStatus;
    HRESULT hr;

    ASSERT(g_hServiceController);
    *phService = OpenService( g_hServiceController,
                              _pAppid->Service(),
                              GENERIC_EXECUTE | GENERIC_READ );

    if ( ! *phService )
        return (HRESULT_FROM_WIN32( GetLastError() ));

    // Formulate the arguments (if any)
    if ( ServiceArgs() )
    {
        UINT   k = 0;

        // Make a copy of the service arguments
        pwszArgs = (WCHAR *) PrivMemAlloc(
                                         (lstrlenW(ServiceArgs()) + 1) * sizeof(WCHAR));
        if ( pwszArgs == NULL )
        {
            CloseServiceHandle(*phService);
            *phService = 0;
            return (E_OUTOFMEMORY);
        }
        lstrcpyW(pwszArgs, ServiceArgs());

        // Scan the arguments
        do
        {
            // Scan to the next non-whitespace character
            while ( pwszArgs[k]  &&
                    (pwszArgs[k] == L' '  ||
                     pwszArgs[k] == L'\t') )
            {
                k++;
            }

            // Store the next argument
            if ( pwszArgs[k] )
            {
                apwszArgs[cArgs++] = &pwszArgs[k];
            }

            // Scan to the next whitespace char
            while ( pwszArgs[k]          &&
                    pwszArgs[k] != L' '  &&
                    pwszArgs[k] != L'\t' )
            {
                k++;
            }

            // Null terminate the previous argument
            if ( pwszArgs[k] )
            {
                pwszArgs[k++] = L'\0';
            }
        } while ( pwszArgs[k] );
    }

    bStatus = StartService( *phService,
                            cArgs,
                            cArgs > 0 ? (LPCTSTR  *) apwszArgs : NULL);

    PrivMemFree(pwszArgs);

    if ( bStatus )
        return (S_OK);

    DWORD dwErr = GetLastError();

    hr = HRESULT_FROM_WIN32( dwErr );

    if ( dwErr == ERROR_SERVICE_ALREADY_RUNNING )
        return (hr);

    CairoleDebugOut((DEB_ERROR,
                     "StartService %ws failed, error = %#x\n",_pAppid->Service(),GetLastError()));
    CloseServiceHandle(*phService);
    *phService = 0;

    LogServiceStartError(
                        &_Clsid,
                        clsctx,
                        pClientToken,
                        _pAppid->Service(),
                        ServiceArgs(),
                        dwErr );

    return (hr);
}

//+-------------------------------------------------------------------------
//
//  LaunchAllowed
//
//--------------------------------------------------------------------------
BOOL
CClsidData::LaunchAllowed(
                         IN  CToken * pClientToken,
                         IN  DWORD    clsctx
                         )
{
    BOOL    bStatus;

#if DBG
    WCHAR wszUser[MAX_PATH];
    ULONG cchSize = MAX_PATH;

    if (pClientToken != NULL)
    {
        pClientToken->Impersonate();
        GetUserName( wszUser, &cchSize );
        pClientToken->Revert();
    }
    else
    {
        lstrcpyW( wszUser, L"Anonymous" );
    }
    CairoleDebugOut((DEB_TRACE, "RPCSS : CClsidData::LaunchAllowed on %ws\n", wszUser));
#endif

    if ( LaunchPermission() )
        bStatus = CheckForAccess( pClientToken, LaunchPermission() );
    else
    {
        CSecDescriptor* pSD = GetDefaultLaunchPermissions();
        if (pSD)
        {
            bStatus = CheckForAccess( pClientToken, pSD->GetSD() );

            pSD->DecRefCount();
        }
        else
            bStatus = FALSE;
    }

    if ( ! bStatus )
    {
        LogLaunchAccessFailed(
                             &_Clsid,
                             clsctx,
                             pClientToken,
                             0 == LaunchPermission() );
    }

    return (bStatus);
}

HRESULT
CClsidData::GetLaunchCommandLine(
                                OUT WCHAR ** ppwszCommandLine
                                )
{
    DWORD   AllocBytes;

    *ppwszCommandLine = 0;

    if ( (SERVERTYPE_EXE16 == _ServerType) || (SERVERTYPE_EXE32 == _ServerType) )
    {
        AllocBytes = ( 1 + lstrlenW( L"-Embedding" ) +
                       1 + lstrlenW( _pwszServer ) ) * sizeof(WCHAR);
        *ppwszCommandLine = (WCHAR *) PrivMemAlloc( AllocBytes );
        if ( *ppwszCommandLine != NULL )
        {
            lstrcpyW( *ppwszCommandLine, _pwszServer );
            lstrcatW( *ppwszCommandLine, L" -Embedding" );
        }
    }
    else
    {
        ASSERT(    SERVERTYPE_SURROGATE == _ServerType
                   || SERVERTYPE_COMPLUS == _ServerType
                   || SERVERTYPE_DLLHOST == _ServerType );

        AllocBytes = ( 1 + lstrlenW( DllSurrogate() ) ) * sizeof(WCHAR);
        *ppwszCommandLine = (WCHAR *) PrivMemAlloc( AllocBytes );
        if ( *ppwszCommandLine != NULL )
        {
            lstrcpyW( *ppwszCommandLine, DllSurrogate() );
        }
    }

    return (*ppwszCommandLine ? S_OK : E_OUTOFMEMORY);
}

#define EXENAMELEN  32

HANDLE
CClsidData::ServerLaunchMutex()
{
    HANDLE  hMutex;
    WCHAR   wszMutex[EXENAMELEN+1];
    WCHAR * pwszPath = NULL;
    WCHAR * pwszExeName = NULL;

    if ( SERVERTYPE_SURROGATE == _ServerType )
    {
        pwszPath = DllSurrogate();

        //  Will never be called any more, ever
        if ( ! pwszPath || ! *pwszPath )
        {
            Win4Assert(_pAppid);
            pwszPath = _pAppid->AppidString();
            //pwszPath = L"dllhost.exe";
        }
    }
    else if ( DllHostOrComPlusProcess() )
    {
        Win4Assert(_pAppid);
        pwszPath = _pAppid->AppidString();
        //pwszPath = L"dllhost.exe";
    }
    else
    {
        pwszPath = Server();
    }


    if ( !pwszPath )
        return (NULL);

    pwszExeName = pwszPath + lstrlenW( pwszPath );

    while ( (pwszExeName != pwszPath) && (pwszExeName[-1] != L'\\') )
        pwszExeName--;

    for ( int i = 0;
        pwszExeName[i] && (pwszExeName[i] != L' ') && (pwszExeName[i] != L'\t') && (i < EXENAMELEN);
        i++ )
    {
        wszMutex[i] = pwszExeName[i];

        if ( L'a' <= wszMutex[i] && wszMutex[i] <= L'z' )
            wszMutex[i] = (WCHAR) (L'A' + (wszMutex[i] - L'a'));
    }
    wszMutex[i] = 0;

#ifndef _CHICAGO_

    hMutex = CreateMutex(NULL, FALSE, wszMutex);

#else
    char    szMutex[EXENAMELEN+1];
    int     Status;

    Status = WideCharToMultiByte(
                                CP_ACP,
                                0,
                                wszMutex,
                                lstrlenW( wszMutex ),
                                szMutex,
                                sizeof(szMutex),
                                NULL,
                                NULL );

    if ( ! Status )
        return (0);
	
    hMutex = CreateMutex( NULL, FALSE, szMutex );
#endif

    if ( hMutex )
        WaitForSingleObject( hMutex, INFINITE );

    return (hMutex);
}

//
//  CClsidData::ServerRegisterEvent
//
//  Returns a handle to the appropriate register  
//  event for the server in question.   
//
HANDLE
CClsidData::ServerRegisterEvent()
{
    if ( DllHostOrComPlusProcess() )
    {
		// For dllhost\com+ surrogates, we delegate to the appid
        ASSERT(_pAppid);
		return _pAppid->ServerRegisterEvent();
    }
	
    // Prefix the string with a special string; objects with guid
    // names are just a touch too common for me to feel comfortable
    // otherwise.
    WCHAR wszEventName[GUIDSTR_MAX + sizeof(REGEVENT_PREFIX)];	
	memcpy(wszEventName, REGEVENT_PREFIX, sizeof(REGEVENT_PREFIX));
	memcpy(wszEventName + REGEVENT_PREFIX_STRLEN, _wszClsid, sizeof(_wszClsid));

    return CreateEvent(NULL, FALSE, FALSE, wszEventName);
}

//
//  CClsidData::ServerInitializedEvent
//
//  Returns a handle to the appropriate register
//  event for the server in question.  This event is
//  signaled when initialization is finished.
//
HANDLE
CAppidData::ServerInitializedEvent()
{
    // Prefix the string with a special string; objects with guid
    // names are just a touch too common for me to feel comfortable
    // otherwise.
    WCHAR wszEventName[GUIDSTR_MAX + sizeof(INITEVENT_PREFIX)];
	memcpy(wszEventName, INITEVENT_PREFIX, sizeof(INITEVENT_PREFIX));
	memcpy(wszEventName + INITEVENT_PREFIX_STRLEN, _wszAppid, sizeof(_wszAppid));

	return CreateEvent(NULL, FALSE, FALSE, wszEventName);
}

//
//  CClsidData::ServerInitializedEvent
//
//  Returns a handle to the appropriate register
//  event for the server in question.  This event is
//  signaled when initialization is finished.
//
//  NOTE: The non-DllHost path is currently not used here.
//
HANDLE
CClsidData::ServerInitializedEvent()
{
    if ( DllHostOrComPlusProcess() )
    {
		// For dllhost\com+ surrogates, we delegate to the appid
        ASSERT(_pAppid);
		return _pAppid->ServerInitializedEvent();
    }
	
    // Prefix the string with a special string; objects with guid
    // names are just a touch too common for me to feel comfortable
    // otherwise.
    WCHAR wszEventName[GUIDSTR_MAX + sizeof(INITEVENT_PREFIX)];	
	memcpy(wszEventName, INITEVENT_PREFIX, sizeof(INITEVENT_PREFIX));
	memcpy(wszEventName + INITEVENT_PREFIX_STRLEN, _wszClsid, sizeof(_wszClsid));

    return CreateEvent(NULL, FALSE, FALSE, wszEventName);
}

//
//  CAppidData::ServerRegisterEvent
//
//  Returns a handle to the appropriate register  
//  event for the server in question.   
//
HANDLE
CAppidData::ServerRegisterEvent()
{
    // Prefix the string with a special string; objects with guid
    // names are just a touch too common for me to feel comfortable
    // otherwise.
    WCHAR wszEventName[GUIDSTR_MAX + sizeof(REGEVENT_PREFIX)];
	memcpy(wszEventName, REGEVENT_PREFIX, sizeof(REGEVENT_PREFIX));
	memcpy(wszEventName + REGEVENT_PREFIX_STRLEN, _wszAppid, sizeof(_wszAppid));

	return CreateEvent(NULL, FALSE, FALSE, wszEventName);
}


//+-------------------------------------------------------------------------
//
//  CClsidData::AddAppPathsToEnv
//
//  Constructs a new environment block with an exe's AppPath value from the
//  registry appended to the Path environment variable.  Simply returns the
//  given environment block if the clsid's server is not a 32 bit exe or if
//  no AppPath is found for the exe.
//
//--------------------------------------------------------------------------
HRESULT
CClsidData::AddAppPathsToEnv(
                            IN  WCHAR *     pEnvBlock,
                            IN  DWORD       EnvBlockLength,
                            OUT WCHAR **    ppFinalEnvBlock
                            )
{
    HKEY        hAppKey;
    WCHAR *     pwszExe;
    WCHAR *     pwszExeEnd;
    WCHAR *     pwszAppPath;
    WCHAR *     pPath;
    WCHAR *     pNewEnvBlock;
    WCHAR       wszStr[8];
    WCHAR       wszKeyName[APP_PATH_LEN+MAX_PATH];
    DWORD       AppPathLength;
    DWORD       EnvFragLength;
    DWORD       Status;
    BOOL        bFoundPath;

    pwszAppPath = 0;
    pNewEnvBlock = 0;

    *ppFinalEnvBlock = pEnvBlock;

    if ( _ServerType != SERVERTYPE_EXE32 )
        return (S_OK);

    //
    // Find the exe name by looking for the first .exe sub string which
    // is followed by a space or null.  Only servers registered with a
    // .exe binary are supported.  Otherwise the parsing is ambiguous since
    // the LocalServer32 can contain paths with spaces as well as optional
    // arguments.
    //
    if ( ! FindExeComponent( _pwszServer, L" ", &pwszExe, &pwszExeEnd ) )
        return (S_OK);

    //
    // pwszExe points to the beginning of the binary name
    // pwszExeEnd points to one char past the end of the binary name
    //
    memcpy( wszKeyName, APP_PATH, APP_PATH_LEN * sizeof(WCHAR) );
    memcpy( &wszKeyName[APP_PATH_LEN], pwszExe, (ULONG) (pwszExeEnd - pwszExe) * sizeof(WCHAR) );
    wszKeyName[APP_PATH_LEN + (pwszExeEnd - pwszExe)] = 0;

    Status = RegOpenKeyEx(
                         HKEY_LOCAL_MACHINE,
                         wszKeyName,
                         0,
                         KEY_READ,
                         &hAppKey );

    if ( ERROR_SUCCESS == Status )
    {
        Status = ReadStringValue( hAppKey, L"Path", &pwszAppPath );
        RegCloseKey( hAppKey );
    }

    if ( Status != ERROR_SUCCESS )
        return (S_OK);

    AppPathLength = lstrlenW(pwszAppPath);

    // New env block size includes space for a new ';' separator in the path.
    pNewEnvBlock = (WCHAR *) PrivMemAlloc( (EnvBlockLength + 1 + AppPathLength) * sizeof(WCHAR) );

    if ( ! pNewEnvBlock )
    {
        PrivMemFree( pwszAppPath );
        return (E_OUTOFMEMORY);
    }

    pPath = pEnvBlock;
    bFoundPath = FALSE;

    for ( ; *pPath; )
    {
        memcpy( wszStr, pPath, 5 * sizeof(WCHAR) );
        wszStr[5] = 0;

        pPath += lstrlenW( pPath ) + 1;

        if ( lstrcmpiW( wszStr, L"Path=" ) == 0 )
        {
            bFoundPath = TRUE;
            break;
        }
    }

    if ( bFoundPath )
    {
        pPath--;

        EnvFragLength = (ULONG) (pPath - pEnvBlock);

        memcpy( pNewEnvBlock,
                pEnvBlock,
                EnvFragLength * sizeof(WCHAR) );

        pNewEnvBlock[EnvFragLength] = L';';

        memcpy( &pNewEnvBlock[EnvFragLength + 1],
                pwszAppPath,
                AppPathLength * sizeof(WCHAR) );

        memcpy( &pNewEnvBlock[EnvFragLength + 1 + AppPathLength],
                pPath,
                (EnvBlockLength - EnvFragLength) * sizeof(WCHAR) );

        *ppFinalEnvBlock = pNewEnvBlock;
    }
    else
    {
        PrivMemFree( pNewEnvBlock );
    }

    PrivMemFree( pwszAppPath );
    return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\olescm\macif.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  activate.cxx
//
//  Main dcom activation service routines.
//
//--------------------------------------------------------------------------

#include "act.hxx"

HRESULT MakeProcessActive(CProcess *pProcess);
HRESULT ProcessInitializationFinished(CProcess *pProcess);


HRESULT ProcessActivatorStarted( 
    IN  handle_t hRpc,
    IN  PHPROCESS phProcess,
    IN  ProcessActivatorToken *pActToken,
    OUT error_status_t *prpcstat)
{
    CheckLocalCall( hRpc ); // raises exception if not

    *prpcstat = 0;          // we got here so we are OK

    CProcess *pProcess = ReferenceProcess( phProcess, TRUE );
    if ( ! pProcess )
        return E_ACCESSDENIED;

    HRESULT hr = S_OK;
    CServerTableEntry *pProcessEntry = NULL;
    CAppidData *pAppidData = NULL;
    ScmProcessReg *pScmProcessReg = NULL;
    DWORD RegistrationToken = 0;
    BOOL fCallerOK = FALSE;

    DWORD AppIDFlags = 0;

    // Lookup appid info from appropriate registry side
#if defined(_WIN64)
    AppIDFlags = pProcess->Is64Bit() ? CAT_REG64_ONLY : CAT_REG32_ONLY;
#endif

    hr = LookupAppidData(
                pActToken->ProcessGUID,
                pProcess->GetToken(),
                AppIDFlags,
                &pAppidData );
    if (FAILED(hr)) 
    {
        goto exit;
    }

    Win4Assert(pAppidData && "LookupAppidData returned NULL AppidData");
    //
    // Check that the caller is allowed to register this CLSID.
    //
    fCallerOK = pAppidData->CertifyServer(pProcess);

    if (!fCallerOK)
    {
        hr = CO_E_WRONG_SERVER_IDENTITY;
        goto exit;
    }

    pProcessEntry = gpProcessTable->GetOrCreate( pActToken->ProcessGUID );

    if ( ! pProcessEntry )
    {
        hr = E_UNEXPECTED;
        goto exit;
    }

    pScmProcessReg = new ScmProcessReg;
    if (!pScmProcessReg)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }
    pScmProcessReg->TimeOfLastPing = GetTickCount();
    pScmProcessReg->ProcessGUID = pActToken->ProcessGUID;
    pScmProcessReg->ReadinessStatus = SERVERSTATE_SUSPENDED;
	pScmProcessReg->AppIDFlags = AppIDFlags;
    pProcess->SetProcessReg(pScmProcessReg);

    hr = pProcessEntry->RegisterServer(
                                pProcess,
                                pActToken->ActivatorIPID,
                                NULL,
                                pAppidData,
                                SERVERSTATE_SUSPENDED,
                                &RegistrationToken );

    pScmProcessReg->RegistrationToken = RegistrationToken;

exit:

    if (pProcessEntry) pProcessEntry->Release();
    if (pProcess) ReleaseProcess( pProcess );
    if (pAppidData) delete pAppidData;

    return hr;
}

HRESULT ProcessActivatorInitializing( 
    IN  handle_t hRpc,
    IN  PHPROCESS phProcess,
    OUT error_status_t *prpcstat)
{
    CheckLocalCall( hRpc ); // raises exception if not

    *prpcstat = 0;          // we got here so we are OK

    CProcess *pProcess = ReferenceProcess( phProcess, TRUE );

    if ( ! pProcess )
        return E_ACCESSDENIED;

    ScmProcessReg *pScmProcessReg = pProcess->GetProcessReg();
    ASSERT(pScmProcessReg);
    if ( ! pScmProcessReg )
    {
      ReleaseProcess( pProcess );
      return E_UNEXPECTED;
    }

    pScmProcessReg->TimeOfLastPing = GetTickCount();

    ReleaseProcess( pProcess );
    return S_OK;
}

HRESULT ProcessActivatorReady( 
    IN  handle_t hRpc,
    IN  PHPROCESS phProcess,
    OUT error_status_t *prpcstat)
{
    CheckLocalCall( hRpc ); // raises exception if not

    *prpcstat = 0;          // we got here so we are OK

    CProcess *pProcess = ReferenceProcess( phProcess, TRUE );
    if ( ! pProcess )
        return E_ACCESSDENIED;

    HRESULT hr;
    if (pProcess->IsInitializing())
    {
        // Process was running user initializaiton code, 
        // so signal that we've finished with that.
        hr = ProcessInitializationFinished(pProcess);
    }
    else
    {
        // Normal case-- simply mark the process as 
        // ready-to-go.
        hr = MakeProcessActive(pProcess);
    }

    if (pProcess) ReleaseProcess( pProcess );

    return hr;
}

HRESULT ProcessActivatorStopped( 
    IN  handle_t hRpc,
    IN  PHPROCESS phProcess,
    OUT error_status_t *prpcstat)
{
    CheckLocalCall( hRpc ); // raises exception if not

    *prpcstat = 0;          // we got here so we are OK

    CProcess *pProcess = ReferenceProcess( phProcess, TRUE );

    if ( ! pProcess )
        return E_ACCESSDENIED;


    ScmProcessReg *pScmProcessReg = pProcess->RemoveProcessReg();
    ASSERT(pScmProcessReg);
    if ( ! pScmProcessReg )
    {
      ReleaseProcess( pProcess );
      return E_UNEXPECTED;
    }

    HRESULT hr = S_OK;

    CServerTableEntry *pProcessEntry 
                        = gpProcessTable->Lookup( pScmProcessReg->ProcessGUID );

    if ( !pProcessEntry )
    {
        hr = E_UNEXPECTED;
        goto exit;
    }

    pProcessEntry->RevokeServer( pScmProcessReg );

exit:

    if (pScmProcessReg) delete pScmProcessReg;
    if (pProcessEntry) pProcessEntry->Release();
    if (pProcess) ReleaseProcess( pProcess );

    return hr;
}


//
//  ProcessActivatorPaused
//
//  A process activator is telling us to turn on the "paused" bit
//  for its process.
//
HRESULT ProcessActivatorPaused(
        IN handle_t                hRpc,
        IN PHPROCESS               phProcess,
        OUT error_status_t        * prpcstat)
{
	CheckLocalCall( hRpc ); // raises exception if not

	*prpcstat = 0;          // we got here so we are OK

	CProcess *pProcess = ReferenceProcess( phProcess, TRUE );
	if ( ! pProcess )
		return E_ACCESSDENIED;

	pProcess->Pause();

	ReleaseProcess(pProcess);

	return S_OK;
}

//
//  ProcessActivatorResumed
//
//  A process activator is telling us to turn off the "paused" bit
//  for its process.
//
HRESULT ProcessActivatorResumed(
        IN handle_t                hRpc,
        IN PHPROCESS               phProcess,
        OUT error_status_t        * prpcstat)
{
	CheckLocalCall( hRpc ); // raises exception if not

	*prpcstat = 0;          // we got here so we are OK

	CProcess *pProcess = ReferenceProcess( phProcess, TRUE );
	if ( ! pProcess )
		return E_ACCESSDENIED;

	pProcess->Resume();

	ReleaseProcess(pProcess);

	return S_OK;
}


//
//  ProcessActivatorUserInitializing
//
//  A process activator is telling us that it's running long-running
//  code and that we might have to wait for a long time on it.
//
HRESULT ProcessActivatorUserInitializing(
        IN handle_t                hRpc,
        IN PHPROCESS               phProcess,
        OUT error_status_t        * prpcstat)
{
    CheckLocalCall( hRpc ); // raises exception if not
    
    *prpcstat = 0;          // we got here so we are OK
    
    CProcess *pProcess = ReferenceProcess( phProcess, TRUE );
    
    if ( ! pProcess )
        return E_ACCESSDENIED;
    
    //
    // Make this process active, but mark it as initializing so that
    // attempts to call into it will block...
    //
    pProcess->BeginInit();
    HRESULT hr = MakeProcessActive(pProcess);

    ReleaseProcess( pProcess );
    return hr;
}

HRESULT MakeProcessActive(
    IN CProcess      *pProcess
)
{
    CServerTableEntry *pProcessEntry = NULL;
    CAppidData        *pAppidData = NULL;
    HANDLE             hRegisterEvent = NULL;
    HRESULT            hr = S_OK;

    ScmProcessReg *pScmProcessReg = pProcess->GetProcessReg();
    ASSERT(pScmProcessReg);
    if ( !pScmProcessReg )
        return E_UNEXPECTED;    
    
    pProcessEntry = gpProcessTable->Lookup( pScmProcessReg->ProcessGUID );
    if ( !pProcessEntry )
    {
        hr = E_UNEXPECTED;
        goto exit;
    }

    pProcessEntry->UnsuspendServer( pScmProcessReg->RegistrationToken );

	// Lookup an appiddata, from which we will get the register event
    hr = LookupAppidData(pScmProcessReg->ProcessGUID,
                         pProcess->GetToken(),
                         pScmProcessReg->AppIDFlags,
                         &pAppidData);
    if (FAILED(hr))
        goto exit;

    Win4Assert(pAppidData && "LookupAppidData returned NULL AppidData");

    hRegisterEvent = pAppidData->ServerRegisterEvent();
    if ( hRegisterEvent )
    {
        SetEvent( hRegisterEvent );
        CloseHandle( hRegisterEvent );        
        pProcess->SetProcessReadyState(SERVERSTATE_READY);
    }
    else
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

exit:
    
    if ( FAILED(hr) && pProcess && pProcessEntry )
        pProcessEntry->RevokeServer( pScmProcessReg );

    if (pProcessEntry) pProcessEntry->Release();
	if (pAppidData) delete pAppidData;

    return hr;
}

HRESULT ProcessInitializationFinished(
    IN CProcess *pProcess
)
{
    CAppidData *pAppidData = NULL;

    ScmProcessReg *pScmProcessReg = pProcess->GetProcessReg();
    ASSERT(pScmProcessReg);
    if ( !pScmProcessReg )
        return E_UNEXPECTED;

    // Initialization is finished... set the initialization event...
    HRESULT hr = LookupAppidData(pScmProcessReg->ProcessGUID,
                                 pProcess->GetToken(),
                                 pScmProcessReg->AppIDFlags,
                                 &pAppidData );
    if (FAILED(hr)) 
        goto exit;
    
    // Signal the initialized event.
    HANDLE hInitializedEvent = pAppidData->ServerInitializedEvent();
    if (!hInitializedEvent)
    {
        hr = E_OUTOFMEMORY;
        goto exit;
    }

    // The order of the following is important:
    //
    // Clear the initializing flag...
    pProcess->EndInit();
    
    // Set the initialized event...
    SetEvent(hInitializedEvent);
    CloseHandle(hInitializedEvent);
    
    hr = S_OK;
    
exit:
    delete pAppidData;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\olescm\remact.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995.
//
//  File:
//      remact.cxx
//
//  Contents:
//
//      Implementation of binding handle cache to remote activation services.
//
//  History:
//
//--------------------------------------------------------------------------

#include "act.hxx"
#include "misc.hxx"

CRemoteMachineList * gpRemoteMachineList = NULL;
CSharedLock * gpRemoteMachineLock = NULL;

// These globals are set to their defaults here, but can be overridden at boot
// time via registry knobs.  See ReadRemoteBindingHandleCacheKeys in registry.cxx.

// Also note that gdwRemoteBindingHandleCacheMaxSize cannot be adjusted after boot,
// but gdwRemoteBindingHandleCacheMaxLifetime and gdwRemoteBindingHandleCacheIdleTimeout can
// be played with in the debugger at will for those so inclined.
DWORD gdwRemoteBindingHandleCacheMaxSize = 16;      // in # of cache elements
DWORD gdwRemoteBindingHandleCacheMaxLifetime = 0;   // in minutes
DWORD gdwRemoteBindingHandleCacheIdleTimeout = 15;  // in minutes


class CRemActPPing : public CParallelPing
{
public:
    CRemActPPing(WCHAR          *pMachine) :
        _ndx(0),
        _pMachine(pMachine)
        {}


    BOOL NextCall(PROTSEQINFO *pProtseqInfo)
    {
        RPC_STATUS status;
        if (_ndx < cMyProtseqs)
        {
            status = CreateRemoteBinding(_pMachine,
                                         _ndx,
                                         &pProtseqInfo->hRpc);
            if (status != RPC_S_OK)
            {
                pProtseqInfo->hRpc = NULL;
            }
            pProtseqInfo->dwUserInfo = _ndx;
            _ndx++;
            return TRUE;
        }
        else
        {
            return FALSE;
        }
    }

    void ReleaseCall(PROTSEQINFO *pProtseqInfo)
    {
        if (pProtseqInfo->hRpc)
        {
            RpcBindingFree(&pProtseqInfo->hRpc);
        }
    }
private:
    DWORD           _ndx;
    WCHAR          *_pMachine;
};


//+---------------------------------------------------------------------------
//
//  Function:   RemoteActivationCall
//
//  Synopsis:   Finds or creates a machine object to cache binding handles
//              to the server machine and forwards the activation request
//              to it.
//
//----------------------------------------------------------------------------

HRESULT
RemoteActivationCall(
                    ACTIVATION_PARAMS * pActParams,
                    WCHAR *             pwszServerName )
{
    CRemoteMachine *    pRemoteMachine;
    WCHAR               wszPathForServer[MAX_PATH+1];
    WCHAR *             pwszPathForServer;
    HRESULT             hr;
    
    pActParams->activatedRemote = TRUE;
    
    Win4Assert( pwszServerName );
    
    pwszPathForServer = 0;
    
    if ( pActParams->pwszPath )
    {
        hr = GetPathForServer( pActParams->pwszPath, wszPathForServer, &pwszPathForServer );
        if ( hr != S_OK )
            return hr;
    }
    
    pRemoteMachine = gpRemoteMachineList->GetOrAdd( pwszServerName );
    if ( ! pRemoteMachine )
        return E_OUTOFMEMORY;
    
    Win4Assert(pActParams->pActPropsIn);
    BOOL fUseSystemId;
    pActParams->pActPropsIn->GetRemoteActivationFlags(&pActParams->fComplusOnly,
                                                      &fUseSystemId);    
    if (!fUseSystemId)
    {
        if (pActParams->pToken != NULL)
            pActParams->pToken->Impersonate();
        else
        {
            pRemoteMachine->Release();
            return HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED );
        }
    }
    
    IServerLocationInfo *pServerLocationInfo = NULL;
    ISpecialSystemProperties* pSSP = NULL;
    ULONG ulCurrentSessionId = 0;
    BOOL bUseConsole = FALSE;
    BOOL fRemoteThisSessionId = FALSE;
    pServerLocationInfo = pActParams->pActPropsIn->GetServerLocationInfo();
    Win4Assert(pServerLocationInfo != NULL);
    pServerLocationInfo->SetRemoteServerName(NULL);
    
    //
    // Session id's should flow off-machine only when explicitly told to; make sure
    // this is the case:
    //
    hr = pActParams->pActPropsIn->QueryInterface(IID_ISpecialSystemProperties, (void**)&pSSP);
    if (SUCCEEDED(hr))
    {
        pSSP->GetSessionId2(&ulCurrentSessionId, &bUseConsole, &fRemoteThisSessionId);
        if (!fRemoteThisSessionId)
        {
            hr = pSSP->SetSessionId(INVALID_SESSION_ID, FALSE, FALSE);
            ASSERT(SUCCEEDED(hr) && "SetSessionId failed");
        }
    }
    
    //
    // Try the activation:
    //
    hr = pRemoteMachine->Activate( pActParams, pwszPathForServer );
    
    //
    // Restore session id just in case the activation ends up being re-tried (for
    // whatever reason) on this machine (eg, if a load-balancing activator is loaded)
    //
    if (!fRemoteThisSessionId)
    {
        HRESULT hrLocal;
        hrLocal = pSSP->SetSessionId(ulCurrentSessionId, bUseConsole, FALSE);
        ASSERT(SUCCEEDED(hrLocal) && "SetSessionId failed");
    }
    
    if (pSSP)
        pSSP->Release();
    
    pRemoteMachine->Release();
    
    if (!fUseSystemId)
        pActParams->pToken->Revert();
    
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CRemoteMachineList::GetOrAdd
//
//  Synopsis:   Scans the machine list for a matching name.  Returns it if
//              found.  Otherwise, creates a machine list entry.   Returned
//              object is refcounted.
//
//  Changes:    jsimmons    4/6/00      Fix for bug 22803 -- cap cache size
//
//----------------------------------------------------------------------------

CRemoteMachine *
CRemoteMachineList::GetOrAdd(
                            IN  WCHAR * pwszMachine
                            )
{
    CRemoteMachine *    pMachine;
    WCHAR *             pwszMachineCopy;
    WCHAR *             pwszScmSPNCopy;

    gpRemoteMachineLock->LockExclusive();

    for ( pMachine = (CRemoteMachine *) First();
        pMachine;
        pMachine = (CRemoteMachine *) pMachine->Next() )
    {
        if ( lstrcmpiW( pMachine->_pwszMachine, pwszMachine ) == 0 )
        {
            pMachine->_dwLastUsedTickCount = GetTickCount();
            pMachine->AddRef();  // add caller reference
            break;
        }
    }
	
    if ( ! pMachine )
    {
        pwszMachineCopy = (WCHAR *) PrivMemAlloc( (lstrlenW( pwszMachine ) + 1) * sizeof(WCHAR) );
        if (pwszMachineCopy)
        {
            pwszScmSPNCopy = (WCHAR *) PrivMemAlloc( (lstrlenW( pwszMachine ) +
                                                     (sizeof(RPCSS_SPN_PREFIX) / sizeof(WCHAR))
                                                      + 1) * sizeof(WCHAR) );
            if (pwszScmSPNCopy)
            {
                lstrcpyW( pwszMachineCopy, pwszMachine );

                // Form server principal name for the remote scm
                lstrcpyW( pwszScmSPNCopy, RPCSS_SPN_PREFIX);
                lstrcatW( pwszScmSPNCopy, pwszMachine);

                pMachine = new CRemoteMachine( pwszMachineCopy, pwszScmSPNCopy);
                // constructed with refcount of 1, don't addref it again
                if ( pMachine )
                {
                    // Only attempt to save new object in cache if cache size > 0:
                    if (_dwMaxCacheSize > 0)
                    {
                        ASSERT(_dwCacheSize <= _dwMaxCacheSize);
                        if (_dwCacheSize == _dwMaxCacheSize)
                        {
                            // Cache has no more room.  Dump the oldest one
                            RemoveOldestCacheElement();

                            ASSERT(_dwCacheSize < _dwMaxCacheSize);
                        }

                        Insert( pMachine );
                        pMachine->AddRef();  
                        _dwCacheSize++;
                        ASSERT(_dwCacheSize <= _dwMaxCacheSize);
                    }
                }
                else
                {
                    PrivMemFree( pwszMachineCopy );
                    PrivMemFree( pwszScmSPNCopy );
                }
            }
            else
            {
                PrivMemFree(pwszMachineCopy);
            }
        }
    }
    
    gpRemoteMachineLock->UnlockExclusive();
	
    return pMachine;
}


//+---------------------------------------------------------------------------
//
//  Function:   CRemoteMachineList::CRemoteMachine
//
//  Synopsis:   Looks thru the cache for the lru element and removes it.
//
//----------------------------------------------------------------------------
void CRemoteMachineList::RemoveOldestCacheElement()
{
    ASSERT(_dwCacheSize > 0);
    ASSERT(gpRemoteMachineLock->HeldExclusive());

    CRemoteMachine* pLRUMachine = (CRemoteMachine*)First();
    CRemoteMachine* pMachine = (CRemoteMachine*)pLRUMachine->Next();

    while (pMachine)
    {
        if (pMachine->_dwLastUsedTickCount < pLRUMachine->_dwLastUsedTickCount)
        {
            pLRUMachine = pMachine;
        }
        pMachine = (CRemoteMachine*)pMachine->Next();
    }

    Remove(pLRUMachine);
    pLRUMachine->Release();
    _dwCacheSize--;
    
    return;
}


//+---------------------------------------------------------------------------
//
//  Function:   CRemoteMachineList::FlushSpecificBindings
//
//  Synopsis:   Looks thru the cache for the specified element and removes it
//              from the cache if found.
//
//  Arguments:  [pszMachine] -- name of the machine to flush from the cache.  Can
//                be ""; this means all bindings should be flushed
//
//  Returns:    S_OK -- the specified bindings were found and flushed
//              CO_S_MACHINENAMENOTFOUND -- if "" was passed, means the cache was 
//                 empty; otherwise means that the specified machine name was not
//                 found in the cache.
//
//----------------------------------------------------------------------------
HRESULT CRemoteMachineList::FlushSpecificBindings(WCHAR* pszMachine)
{
    HRESULT hr = CO_S_MACHINENAMENOTFOUND;
    BOOL bFlushAll = (0 == lstrcmpW(pszMachine, L""));
    CRemoteMachine* pMachine;
    CRemoteMachine* pNextMachine;

    gpRemoteMachineLock->LockExclusive();
    
    if (bFlushAll)
    {
        // Loop thru and release all of them
        while (pMachine = (CRemoteMachine*)First())
        {
            Remove(pMachine);
            pMachine->Release();
            _dwCacheSize--;
            hr = S_OK;  // there was at least one item in the cache, so return S_OK
        }
    }
    else
    {
        // Loop thru looking for the specified machine name
        pMachine = (CRemoteMachine*)First();

        while (pMachine)
        {
            if (lstrcmpiW(pszMachine, pMachine->_pwszMachine) == 0)
            {
                // Found it
                Remove(pMachine);
                pMachine->Release();
                _dwCacheSize--;
                hr = S_OK;  // found it so return S_OK
                break;
            }
            pMachine = (CRemoteMachine*)pMachine->Next();
        }
    }
    
    gpRemoteMachineLock->UnlockExclusive();

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CRemoteMachineList::TryToFlushIdleOrTooOldElements
//
//  Synopsis:   Looks thru the cache for elements which have either 1) not been
//     used for a period than the idle timeout period; or 2) been in the cache
//     longer than the maximum allowable period.    If any are found they are
//     deleted from the cache.
//
//  Arguments:  none
//
//  Returns:    void
//
//----------------------------------------------------------------------------
void CRemoteMachineList::TryToFlushIdleOrTooOldElements()
{
    CRemoteMachine* pMachine;
    CRemoteMachine* pNextMachine;
    DWORD dwNow = GetTickCount();
    DWORD dwIdleTimeout = gdwRemoteBindingHandleCacheIdleTimeout * 1000 * 60;
    DWORD dwLifetimeTimeout = gdwRemoteBindingHandleCacheMaxLifetime * 1000 * 60;
	
    if (!dwIdleTimeout && !dwLifetimeTimeout)
        return; // nothing to do

    gpRemoteMachineLock->LockExclusive();
        
    pMachine = (CRemoteMachine*)First();

    while (pMachine)
    {
        BOOL bRemoveCurrentItem;

        bRemoveCurrentItem = FALSE;

        // Check if it's been idle too long
        if (dwIdleTimeout > 0)
        {
            if (dwNow - pMachine->_dwLastUsedTickCount > dwIdleTimeout)
            {
                bRemoveCurrentItem = TRUE;
            }
        }
        
        // Check if it's been around too long, period
        if (dwLifetimeTimeout > 0)
        {
            if (dwNow - pMachine->_dwTickCountAtCreate > dwLifetimeTimeout)
            {
                bRemoveCurrentItem = TRUE;
            }
        }

        pNextMachine = (CRemoteMachine*)pMachine->Next();

        if (bRemoveCurrentItem)
        {
            Remove(pMachine);
            pMachine->Release();
            _dwCacheSize--;
        }
    
        pMachine = pNextMachine;
    }
                    
    gpRemoteMachineLock->UnlockExclusive();
}

//+---------------------------------------------------------------------------
//
//  Function:   OLESCMBindingHandleFlush
//
//  Synopsis:   This function gets called periodically by objex's worker 
//     thread.  It gives us a chance to flush idle or too-old cache elements
//     in the remote binding handle cache.
//
//----------------------------------------------------------------------------
void OLESCMBindingHandleFlush()
{
    gpRemoteMachineList->TryToFlushIdleOrTooOldElements();
}

//+---------------------------------------------------------------------------
//
//  Function:   CRemoteMachine::CRemoteMachine
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CRemoteMachine::CRemoteMachine(
                              IN WCHAR * pwszMachine,
                              IN WCHAR * pwszScmSPN
                              )
{
    _pwszMachine = pwszMachine;
    _pwszScmSPN  = pwszScmSPN;
    _dsa         = NULL;
    _ulRefCount  = 1;  // starts with non-zero refcount
    _dwLastUsedTickCount = GetTickCount();
    _dwTickCountAtCreate = _dwLastUsedTickCount;
}

//+---------------------------------------------------------------------------
//
//  Function:   CRemoteMachine::CRemoteMachine
//
//  Synopsis:   Destructor
//  
//----------------------------------------------------------------------------
CRemoteMachine::~CRemoteMachine()
{
    ASSERT(_ulRefCount == 0);
    
    // We don't need to hold a lock to flush the bindings, 
    // since no one else has a reference to us.
    FlushBindingsNoLock();

    if (_pwszMachine)
        PrivMemFree(_pwszMachine);
    if (_pwszScmSPN)
        PrivMemFree(_pwszScmSPN);
    if (_dsa)
        _dsa->Release();
}

// AddRef function
ULONG CRemoteMachine::AddRef()
{
    return InterlockedIncrement((PLONG)&_ulRefCount);
}

// Release function
ULONG CRemoteMachine::Release()
{
    ULONG ulNewRefCount = InterlockedDecrement((PLONG)&_ulRefCount);
    if (ulNewRefCount == 0)
    {
        delete this;
    }
    return ulNewRefCount;
}

//+---------------------------------------------------------------------------
//
//  Function:   CRemoteMachine::Activate
//
//  Synopsis:   Picks a protocol and authentication service to use to call
//              the server machine.  Forwards the activation request to
//              CallRemoteMachine.
//
//  Description:
//
//  This method tries several different methods to get a binding handle.
//      Look for auth info match in cache
//      Look for any binding handle in cache
//      Ping server to find valid protocol sequence
//
//  After it gets a binding handle, it tries to pick auth info.
//      Use client params if specified
//      Use cached params if they exist
//      Try all auth svc valid on client and server
//      Try unsecure
//
//  This function maintains a cache of binding handles with the following
//  rules.
//      - All binding handles in the cache at any point in time use the same
//      protocol sequence.
//      - The best non-custom authentication info is before any other
//      non-custom authentication info.
//      - The cache is flushed if the protocol is competely invalid.
//      - If a cached entry gets a non security error, it is discarded
//      (security errors may be due to the current credentials rather then
//      the binding handle itself).
//      - Only binding handles that actually worked once are cached.
//
//----------------------------------------------------------------------------
HRESULT
CRemoteMachine::Activate(
                        IN  ACTIVATION_PARAMS * pActParams,
                        IN  WCHAR *             pwszPathForServer
                        )
{
    CMachineBinding *   pMachineBinding;
    handle_t            hBinding = NULL;
    BOOL                bNoEndpoint;
    BOOL                bStatus;
    HRESULT             hr;
    USHORT              AuthnSvc;
    USHORT              ProtseqId;
    RPC_STATUS          Status = RPC_S_INTERNAL_ERROR;

    // Try to use a cached handle first.
    if (pActParams->pAuthInfo != NULL)
        AuthnSvc = (USHORT) pActParams->pAuthInfo->dwAuthnSvc;
    else
        AuthnSvc = AUTHN_ANY;

    pMachineBinding = LookupBinding( AuthnSvc, pActParams->pAuthInfo );

    if ( pMachineBinding )
    {
        AuthnSvc = pMachineBinding->_AuthnSvc;
        Status = CallRemoteMachine(
                                    pMachineBinding->_hBinding,
                                    pMachineBinding->_ProtseqId,
                                    pActParams,
                                    pwszPathForServer,
                                    _pwszMachine,
                                    &hr );
        if (Status == RPC_S_OK)
        {
            pActParams->AuthnSvc = AuthnSvc;
            pMachineBinding->Release();
            return hr;
        }

        // Throw away the binding if it is unlikely to work again in the
        // future.
        else if (Status != RPC_S_ACCESS_DENIED &&
                 Status != RPC_S_SEC_PKG_ERROR)
        {
            RemoveBinding( pMachineBinding );
        }
        pMachineBinding->Release();
    }

    // Throw away all bindings if the protocol is unlikely to work
    // again.
    if (Status == RPC_S_SERVER_UNAVAILABLE ||
        Status == EPT_S_NOT_REGISTERED)
    {
        FlushBindings();
    }

    // Get any binding handle from the cache.
    else
    {
        gpRemoteMachineLock->LockShared();
        pMachineBinding = (CMachineBinding *) _BindingList.First();
        if (pMachineBinding != NULL)
        {
            Status = RpcBindingCopy( pMachineBinding->_hBinding, &hBinding );
            if (Status == RPC_S_OK)
            {
                ASSERT(hBinding != NULL);
                ProtseqId = pMachineBinding->_ProtseqId;
            }
            else
                hBinding = NULL;
        }
        gpRemoteMachineLock->UnlockShared();

        // Try to find auth info that will work.
        if (hBinding != NULL)
        {
            Status = PickAuthnAndActivate( pActParams, pwszPathForServer,
                                           &hBinding, AuthnSvc, ProtseqId,
                                           &hr );
            if (Status == RPC_S_OK)
            {
                Assert( hBinding == NULL );
                return hr;
            }
            else
            {
              // Stop if the activation failed but the protocol was
              // probably good.
              Assert( hBinding != NULL );
              RpcBindingFree( &hBinding );
              hBinding = NULL;
              if (Status != RPC_S_SERVER_UNAVAILABLE &&
                Status != EPT_S_NOT_REGISTERED)
              {
                if (Status == RPC_S_ACCESS_DENIED)
                {
                  // Don't map security errors as this is just confusing.
                  return HRESULT_FROM_WIN32(RPC_S_ACCESS_DENIED);
                }
                else
                {
                  LogRemoteSideUnavailable( pActParams->ClsContext, _pwszMachine );
                  return HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE);
                }
              }
            }
        }
    }

    // No cached binding handles worked.  Try to ping for one.
    {
        CRemActPPing ping(_pwszMachine);

        // This loop only executes twice if we need to try the call without
        // an endpoint specified.
        //
        bNoEndpoint = FALSE;
        for (;;)
        {
            Status = ping.Ping();
            if ( RPC_S_UNKNOWN_IF == Status )
            {
                if ( ! bNoEndpoint )
                {
                    for ( ULONG ProtseqIndex = 0; ProtseqIndex < ping.HandleCount(); ProtseqIndex++ )
                    {
                        RPC_BINDING_HANDLE tmpBinding;
                        Status = RpcBindingCopy( ping.Info(ProtseqIndex)->hRpc, &tmpBinding);

                        if (Status != RPC_S_OK)
                            break;

                        RpcBindingFree( &(ping.Info(ProtseqIndex)->hRpc));

                        if (Status != RPC_S_OK)
                        {
                            RpcBindingFree(&tmpBinding);
                            break;
                        }

                        RpcBindingReset(tmpBinding);
                        if (Status != RPC_S_OK)
                        {
                            RpcBindingFree(&tmpBinding);
                            break;
                        }

                        ping.Info(ProtseqIndex)->hRpc = tmpBinding;
                    }
                    if (Status == RPC_S_OK)
                    {
                        bNoEndpoint = TRUE;
                        continue;
                    }
                }
            }
            break;
        }
        if (Status == RPC_S_OK)
        {
            gpRemoteMachineLock->LockExclusive();
            if (_dsa != NULL)
                _dsa->Release();
            hBinding               = ping.GetWinner()->hRpc;
            ping.GetWinner()->hRpc = NULL;
            _dsa                   = ping.TakeOrBindings();
            ProtseqId              = aMyProtseqs[ping.GetWinner()->dwUserInfo];
            ASSERT( hBinding != NULL );
            gpRemoteMachineLock->UnlockExclusive();
        }

        ping.Reset();

    }

    // Try auth info with the new binding.
    if (hBinding != NULL)
    {
        Status = PickAuthnAndActivate( pActParams, pwszPathForServer,
                                       &hBinding, RPC_C_AUTHN_NONE, ProtseqId,
                                       &hr );
        if (Status == RPC_S_OK)
        {
          // asserts that in success cases binding was added to the cache
          Assert( hBinding == NULL );
        }
    }


    // If the call never worked, return a nice error code.
    // except for security errors.
    if (Status != RPC_S_OK)
    {
        if (Status == RPC_S_ACCESS_DENIED)
            hr = HRESULT_FROM_WIN32(RPC_S_ACCESS_DENIED);
        else
        {
            hr = HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE);
            LogRemoteSideUnavailable( pActParams->ClsContext, _pwszMachine );
        }
    }

    // Clean up resources.
    if (hBinding != NULL)
        RpcBindingFree( &hBinding );
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CRemoteMachine::PickAuthnAndActivate
//
//  Synopsis:   Determine what authentication information to use for the
//              activation.  The AuthnSvc parameter indicates an
//              authentication service that was already tried.
//
//----------------------------------------------------------------------------
RPC_STATUS CRemoteMachine::PickAuthnAndActivate(
                        IN  ACTIVATION_PARAMS * pActParams,
                        IN  WCHAR *             pwszPathForServer,
                        IN  handle_t          * pBinding,
                        IN  USHORT              AuthnSvc,
                        IN  USHORT              ProtseqId,
                        OUT HRESULT           * phr )
{
    RPC_SECURITY_QOS    Qos;
    DWORD               i;
    void               *pAuthId = NULL;
    RPC_STATUS          Status;
    CMachineBinding    *pMachineBinding;
    BOOL                fTry;
    CDualStringArray   *pdsa    = NULL;
    COAUTHIDENTITY     *pAuthIdentityFinalCopy = NULL;
    HRESULT             hr = S_OK;
    
    // If the client specified security, try exactly the settings requested.
    Qos.Version                    = RPC_C_SECURITY_QOS_VERSION;
    pActParams->UnsecureActivation = FALSE;
    if (pActParams->pAuthInfo)
    {
        // Set the requested authentication information.
        AuthnSvc              = (USHORT) pActParams->pAuthInfo->dwAuthnSvc;
        pActParams->AuthnSvc  = (USHORT) pActParams->pAuthInfo->dwAuthnSvc;
        Qos.Capabilities      = pActParams->pAuthInfo->dwCapabilities;
        Qos.ImpersonationType = pActParams->pAuthInfo->dwImpersonationLevel;
        if (pActParams->pAuthInfo->pAuthIdentityData != NULL)
            Qos.IdentityTracking = RPC_C_QOS_IDENTITY_STATIC;
        else
            Qos.IdentityTracking = RPC_C_QOS_IDENTITY_DYNAMIC;
        
        // If using RPC_C_QOS_IDENTITY_DYNAMIC, we need to make a saveable copy of the 
        // client's authidentity struct.
        if (Qos.IdentityTracking == RPC_C_QOS_IDENTITY_DYNAMIC &&
            pActParams->pAuthInfo->pAuthIdentityData)
        {
            hr = CopyAuthIdentity(pActParams->pAuthInfo->pAuthIdentityData, &pAuthIdentityFinalCopy);
        }
        
        if (SUCCEEDED(hr))
        {
            Status = RpcBindingSetAuthInfoExW(
                *pBinding,
                pActParams->pAuthInfo->pwszServerPrincName,
                pActParams->pAuthInfo->dwAuthnLevel,
                pActParams->pAuthInfo->dwAuthnSvc,
                (Qos.IdentityTracking == RPC_C_QOS_IDENTITY_DYNAMIC) ? 
                        pAuthIdentityFinalCopy : 
                        pActParams->pAuthInfo->pAuthIdentityData,
                pActParams->pAuthInfo->dwAuthzSvc,
                &Qos );
            
            // Try the activation.
            if (Status == RPC_S_OK)
            {
                Status = CallRemoteMachine(
                                    *pBinding,
                                    ProtseqId,
                                    pActParams,
                                    pwszPathForServer,
                                    _pwszMachine,
                                    phr );
                if (Status != RPC_S_OK)
                {
                    // we won't be caching this handle, so free the COAUTHIDENTITY copy
                    FreeAuthIdentity(pAuthIdentityFinalCopy);
                    pAuthIdentityFinalCopy = NULL;
                }
            }
        }
        else
        {
            // couldn't get enough memory to copy the user's COAUTHIDENTITY
            *phr = E_OUTOFMEMORY;
            Status = RPC_S_OUT_OF_RESOURCES;  
        }
    }
    // Try all authentication services and then try unsecure.
    else
    {
        // Get a reference to the dual string array.
        gpRemoteMachineLock->LockShared();
        pdsa = _dsa;
        if (pdsa) pdsa->AddRef();
        gpRemoteMachineLock->UnlockShared();
        
        // Initialize the QOS structure.
        Qos.Capabilities      = RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH;
        Qos.ImpersonationType = RPC_C_IMP_LEVEL_IMPERSONATE;
        Qos.IdentityTracking  = RPC_C_QOS_IDENTITY_DYNAMIC;
        
        // Loop over the authentication services.
        Status = RPC_S_INTERNAL_ERROR;
        for (i = 0; i < s_cRpcssSvc; i++)
        {
            // Skip the authentication service that was already tried.
            if (s_aRpcssSvc[i].wId == AuthnSvc)
                continue;
            
            // If there are no security bindings, only try NTLM.
            if (pdsa == NULL)
            {
                fTry = s_aRpcssSvc[i].wId == RPC_C_AUTHN_WINNT;
            }            
            else
            {
                // If there are security bindings, try the next authentication
                // service if both machines use it.
                fTry = ValidAuthnSvc( pdsa->DSA(), s_aRpcssSvc[i].wId );
            }
            
            if (fTry)
            {
                BOOL   bSetSecurityCallBack = FALSE;
                USHORT usAuthSvcFromCallback;
                
                // Set the security.
                Status = RPC_S_OK;
                if (s_aRpcssSvc[i].wId == RPC_C_AUTHN_GSS_NEGOTIATE)
                {
                    // Using snego, compute list of compatible authnsvcs:
                    ASSERT(pdsa);
                    pAuthIdentityFinalCopy = (COAUTHIDENTITY*) ComputeSvcList( pdsa->DSA() );
                    if (pAuthIdentityFinalCopy)
                    {
                        // if using snego, we need to know what sec pkg is eventually negotiated:
                        if (gpCRpcSecurityCallbackMgr->RegisterForRpcAuthSvcCallBack(*pBinding))
                            bSetSecurityCallBack = TRUE;
                    }
                    else
                    {
                        // Using snego, but ComputeSvcList returned NULL (out of memory)
                        *phr = E_OUTOFMEMORY;
                        Status = RPC_S_OUT_OF_RESOURCES;  
                    }
                }
                
                if (Status == RPC_S_OK)
                {
                    Status = RpcBindingSetAuthInfoEx(
                                            *pBinding,
                                            _pwszScmSPN,
                                            RPC_C_AUTHN_LEVEL_CONNECT,
                                            s_aRpcssSvc[i].wId,
                                            pAuthIdentityFinalCopy,
                                            0,
                                            &Qos );
                }
                
                if (Status != RPC_S_OK)
                {
                    if (bSetSecurityCallBack)
                        gpCRpcSecurityCallbackMgr->GetAuthSvcAndTurnOffCallback(*pBinding, NULL);
                    
                    // Free our authident copy if we have one
                    FreeAuthIdentity(pAuthIdentityFinalCopy);
                    pAuthIdentityFinalCopy = NULL;
                }
                
                // Try the activation.
                if (Status == RPC_S_OK)
                {
                    Status = CallRemoteMachine(
                                        *pBinding,
                                        ProtseqId,
                                        pActParams,
                                        pwszPathForServer,
                                        _pwszMachine,
                                        phr );
                    if (Status != RPC_S_OK)
                    {
                        // call didn't work;  we definitely won't be caching this handle, 
                        // so free the authidentity copy
                        FreeAuthIdentity(pAuthIdentityFinalCopy);
                        pAuthIdentityFinalCopy = NULL;
                    }
                    
                    if (bSetSecurityCallBack)
                    {
                        //
                        //  Only ask for the result of the callback if the call went through; otherwise
                        //  just cancel the registration.
                        //
                        if (Status == RPC_S_OK)
                        {
                            if (!gpCRpcSecurityCallbackMgr->GetAuthSvcAndTurnOffCallback(*pBinding,
                                &usAuthSvcFromCallback))
                            {
                                // something went wrong.  In this case we don't trust what the callback
                                // told us.   Fall back on the original behavior
                                bSetSecurityCallBack = FALSE;
                            }
                        }
                        else
                        {
                            // the call did not go through
                            if (bSetSecurityCallBack)
                            {
                                // cancel the callback
                                gpCRpcSecurityCallbackMgr->GetAuthSvcAndTurnOffCallback(*pBinding, NULL);
                                bSetSecurityCallBack = FALSE;
                            }
                        }
                    }
                    
                    if (Status == RPC_S_OK                 ||
                        Status == RPC_S_SERVER_UNAVAILABLE ||
                        Status == EPT_S_NOT_REGISTERED)
                    {
                        if (bSetSecurityCallBack)
                        {
                            // snego call, and we succesfully got a callback telling us
                            // what the real authentication service was
                            if (usAuthSvcFromCallback == RPC_C_AUTHN_GSS_KERBEROS)
                            {
                                // if we got back kerberos we're going to cache snego anyway; this
                                // helps NTLM-only clients who can't use kerberos
                                pActParams->AuthnSvc = AuthnSvc = RPC_C_AUTHN_GSS_NEGOTIATE;
                            }
                            else
                                pActParams->AuthnSvc = AuthnSvc = usAuthSvcFromCallback;
                        }
                        else
                        {
                            // non-snego, or something went wrong with security callback
                            // on a snego call
                            pActParams->AuthnSvc = AuthnSvc = s_aRpcssSvc[i].wId;
                        }
                        break;
                    }
                }
            }
        }
        
        if (pdsa)
        {
            pdsa->Release();
            pdsa = NULL;
        }
        
        // If no authentication services worked and the protocol doesn't
        // look bad, try no authentication
        if (Status != RPC_S_OK                 &&
            Status != RPC_S_SERVER_UNAVAILABLE &&
            Status != EPT_S_NOT_REGISTERED)
        {
            // remember that unsecure activation was done.
            // This will be used later when creating the MID
            // so we do unsecure pinging also.
            pActParams->UnsecureActivation = TRUE;
            
            // Look for a cached unsecure binding handle.
            pMachineBinding = LookupBinding( RPC_C_AUTHN_NONE, NULL );
            if ( pMachineBinding )
            {
                Status = CallRemoteMachine(
                                pMachineBinding->_hBinding,
                                pMachineBinding->_ProtseqId,
                                pActParams,
                                pwszPathForServer,
                                _pwszMachine,
                                phr );
                
                // Throw away the binding handle received as a parameter so
                // it doesn't get cached.
                if (Status == RPC_S_OK)
                {
                    RpcBindingFree( pBinding );
                    *pBinding = NULL;
                }
                
                // Throw away the binding if it is unlikely to work again in the
                // future.
                else
                {
                    RemoveBinding( pMachineBinding );
                }
                pMachineBinding->Release();
            }
            
            // Make the current binding handle unsecure.
            else
            {
                // Set the authentication information.
                Status =  RpcBindingSetAuthInfoEx(
                                    *pBinding,
                                    NULL,
                                    RPC_C_AUTHN_LEVEL_NONE,
                                    RPC_C_AUTHN_NONE,
                                    NULL,
                                    0,
                                    &Qos );
                if (Status == RPC_S_OK)
                {
                    AuthnSvc = RPC_C_AUTHN_NONE;
                    Status = CallRemoteMachine(
                                        *pBinding,
                                        ProtseqId,
                                        pActParams,
                                        pwszPathForServer,
                                        _pwszMachine,
                                        phr );
                }
            }
        }
    }
    
    if (Status == RPC_S_OK && *pBinding != NULL)
    {
        //
        // The call completed.  We now cache this binding handle.
        // Caching is just an optimization so we don't care if this
        // insert fails.
        //
        InsertBinding(
                    *pBinding,
                    ProtseqId,
                    AuthnSvc,
                    pActParams->pAuthInfo,
                    pAuthIdentityFinalCopy);
        *pBinding = NULL;
    }
    
    // Throw away all bindings if the protocol is unlikely to work
    // again.
    else if (Status == RPC_S_SERVER_UNAVAILABLE ||
             Status == EPT_S_NOT_REGISTERED)
    {
        FlushBindings();
    }
    return Status;
}


//+---------------------------------------------------------------------------
//
//  Function:   CRemoteMachine::LookupBinding
//
//  Synopsis:   Scan the binding list for a binding with matching
//              authentication information
//
//----------------------------------------------------------------------------
CMachineBinding *
CRemoteMachine::LookupBinding(
                             IN  USHORT              AuthnSvc,
                             IN  COAUTHINFO *        pAuthInfo OPTIONAL
                             )
{
    CMachineBinding * pMachineBinding;

    gpRemoteMachineLock->LockShared();

    for ( pMachineBinding = (CMachineBinding *) _BindingList.First();
        pMachineBinding;
        pMachineBinding = (CMachineBinding *) pMachineBinding->Next() )
    {
        if ( pMachineBinding->Equal( AuthnSvc, pAuthInfo ) )
        {
            pMachineBinding->Reference();
            break;
        }
    }

    gpRemoteMachineLock->UnlockShared();

    return pMachineBinding;
}

//+---------------------------------------------------------------------------
//
//  Function:   CRemoteMachine::FlushBindings
//
//  Synopsis:   Release all entries under a lock
//
//----------------------------------------------------------------------------
void
CRemoteMachine::FlushBindings()
{
    gpRemoteMachineLock->LockExclusive();
	
    FlushBindingsNoLock();

    gpRemoteMachineLock->UnlockExclusive();
}

//+---------------------------------------------------------------------------
//
//  Function:   CRemoteMachine::FlushBindingsNoLock
//
//  Synopsis:   Release all entries without taking a lock first.
//
//----------------------------------------------------------------------------
void CRemoteMachine::FlushBindingsNoLock()
{
    CMachineBinding * pMachineBinding;
    
    while ( pMachineBinding = (CMachineBinding *) _BindingList.First() )
    {
        _BindingList.Remove( pMachineBinding );
        pMachineBinding->Release();
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   CRemoteMachine::InsertBinding
//
//  Synopsis:   Add the specified binding handle to the cache of binding
//              handles for this machine.  Free it if the insertion fails.
//
//----------------------------------------------------------------------------
void
CRemoteMachine::InsertBinding(
                             IN  handle_t            hBinding,
                             IN  USHORT              ProtseqId,
                             IN  USHORT              AuthnSvc,
                             IN  COAUTHINFO *        pAuthInfo OPTIONAL,
                             IN  COAUTHIDENTITY*     pAuthIdentityFinal
                             )
{
    CMachineBinding *   pMachineBinding;
    CMachineBinding *   pExistingBinding;
    COAUTHINFO *        pAuthInfoCopy;

    pAuthInfoCopy = 0;
    pMachineBinding = 0;

    if ( ! pAuthInfo || (CopyAuthInfo( pAuthInfo, &pAuthInfoCopy ) == S_OK) )
    {
        pMachineBinding = new CMachineBinding(
                                             hBinding,
                                             ProtseqId,
                                             AuthnSvc,
                                             pAuthInfoCopy,
                                             pAuthIdentityFinal);
    }

    if ( ! pMachineBinding )
    {
        FreeAuthIdentity(pAuthIdentityFinal);
        RpcBindingFree( &hBinding );
        return;
    }

    gpRemoteMachineLock->LockExclusive();

    for ( pExistingBinding = (CMachineBinding *) _BindingList.First();
        pExistingBinding;
        pExistingBinding = (CMachineBinding *) pExistingBinding->Next() )
    {
        if ( pExistingBinding->Equal( AuthnSvc, pAuthInfoCopy ) )
            break;
    }

    if ( ! pExistingBinding )
        _BindingList.Insert( pMachineBinding );

    gpRemoteMachineLock->UnlockExclusive();

    if ( pExistingBinding )
    {
        // Will delete the new binding we created above.
        pMachineBinding->Release();
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   CRemoteMachine::RemoveBinding
//
//  Synopsis:   Remove the specified binding handle from the cache for
//              this machine.
//
//----------------------------------------------------------------------------
void
CRemoteMachine::RemoveBinding(
                             IN  CMachineBinding * pMachineBinding
                             )
{
    CMachineBinding * pBinding;

    gpRemoteMachineLock->LockExclusive();

    for ( pBinding = (CMachineBinding *) _BindingList.First();
        pBinding;
        pBinding = (CMachineBinding *) pBinding->Next() )
    {
        if ( pBinding == pMachineBinding )
        {
            _BindingList.Remove( pMachineBinding );
            pMachineBinding->Release();
            break;
        }
    }

    gpRemoteMachineLock->UnlockExclusive();
}

//+---------------------------------------------------------------------------
//
//  Function:   CMachineBinding::CMachineBinding
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------

//
// CMachineBinding
//
CMachineBinding::CMachineBinding(
                                IN  handle_t        hBinding,
                                IN  USHORT          ProtseqId,
                                IN  USHORT          AuthnSvc,
                                IN  COAUTHINFO *    pAuthInfo OPTIONAL,
                                IN  COAUTHIDENTITY* pAuthIdentityFinal
                                )
{
    _hBinding  = hBinding;
    _ProtseqId = ProtseqId;
    _AuthnSvc  = AuthnSvc;
    _pAuthInfo = pAuthInfo;
    _pAuthIdentity = pAuthIdentityFinal;  // the only reason to hold on to this
                                          // is because in some situations it 
                                          // must not be released until the binding
                                          // handle is gone
}

//+---------------------------------------------------------------------------
//
//  Function:   CMachineBinding::~CMachineBinding
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CMachineBinding::~CMachineBinding()
{
    if ( _hBinding )
        RpcBindingFree( &_hBinding );

    if ( _pAuthInfo )
    {
        PrivMemFree( _pAuthInfo->pwszServerPrincName );

        if ( _pAuthInfo->pAuthIdentityData )
        {
            FreeAuthIdentity(_pAuthInfo->pAuthIdentityData);
        }

        PrivMemFree( _pAuthInfo );
    }

    if (_pAuthIdentity)
        FreeAuthIdentity(_pAuthIdentity);
}

//+---------------------------------------------------------------------------
//
//  Function:   CMachineBinding::Equal
//
//  Synopsis:   Return TRUE if the specified authentication information
//              matches this binding handle.  If the AUTHN_ANY flag is
//              specified, do not check the authentication service but do
//              check the authentication info.
//
//----------------------------------------------------------------------------
BOOL
CMachineBinding::Equal(
                      IN  USHORT          AuthnSvc,
                      IN  COAUTHINFO *    pAuthInfo OPTIONAL
                      )
{
    return( (AuthnSvc == _AuthnSvc ||
             (AuthnSvc == AUTHN_ANY && _AuthnSvc != RPC_C_AUTHN_NONE)) &&
            EqualAuthInfo( pAuthInfo, _pAuthInfo ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   CallRemoteMachine
//
//  Synopsis:   Marshal/Unmarshal the activation parameters.  Call the right
//              remote activation interface.
//
//----------------------------------------------------------------------------
RPC_STATUS
CallRemoteMachine(
                 handle_t            hBinding,
                 USHORT              ProtseqId,
                 ACTIVATION_PARAMS * pActParams,
                 WCHAR *             pwszPathForServer,
                 WCHAR *             pwszMachine,
                 HRESULT *           phr
                 )
{
    RPC_STATUS  Status=RPC_S_OK;

    // jsimmons 2/15/00 -- we explicitly don't cache the COM version of the target server; if
    // we did this would allow us on subsequent calls to know in advance which RPC interface
    // to use while calling.  However, PM decision was to leave the current behavior alone.

    // First try new interface

    if (pwszPathForServer && (pwszPathForServer != pActParams->pwszPath))
    {
        ASSERT(pActParams->pInstanceInfo != NULL);
        pActParams->pInstanceInfo->SetFile(pwszPathForServer, pActParams->Mode);
    }

    ASSERT(pActParams->pActPropsIn != NULL);

    IScmRequestInfo *pRequestInfo;
    *phr = pActParams->pActPropsIn->QueryInterface(IID_IScmRequestInfo,
                                                   (void**) &pRequestInfo);

    if (*phr != S_OK)
        return Status;


    REMOTE_REQUEST_SCM_INFO *pRequest;
    pRequest = (REMOTE_REQUEST_SCM_INFO *)
               MIDL_user_allocate(sizeof(REMOTE_REQUEST_SCM_INFO));

    if (pRequest == NULL)
    {
        pRequestInfo->Release();
        *phr = E_OUTOFMEMORY;
        return Status;
    }

    pRequest->ClientImpLevel = RPC_C_IMP_LEVEL_IDENTIFY;


    pRequest->cRequestedProtseqs = cMyProtseqs;
    pRequest->pRequestedProtseqs = (unsigned short*)
                                   MIDL_user_allocate(sizeof(short)*pRequest->cRequestedProtseqs);

    if (pRequest->pRequestedProtseqs==NULL)
    {
        *phr = E_OUTOFMEMORY;
        MIDL_user_free(pRequest);
        pRequestInfo->Release();
        return RPC_S_OK;
    }

    memcpy(pRequest->pRequestedProtseqs, aMyProtseqs, sizeof(short)*cMyProtseqs);

    pRequestInfo->SetRemoteRequestInfo(pRequest);

    pRequestInfo->Release();

    MInterfacePointer *pIFDIn, *pIFDOut=NULL;
    *phr = ActPropsMarshalHelper(pActParams->pActPropsIn,
                                 IID_IActivationPropertiesIn,
                                 MSHCTX_DIFFERENTMACHINE,
                                 MSHLFLAGS_NORMAL,
                                 &pIFDIn);

    if (*phr != S_OK)
    {
        return RPC_S_OK;
    }

    RpcTryExcept
    {
        if (pActParams->MsgType == GETCLASSOBJECT)
        {
            *phr = RemoteGetClassObject(
                                       hBinding,
                                       pActParams->ORPCthis,
                                       pActParams->ORPCthat,
                                       pIFDIn,
                                       &pIFDOut);
        }
        else
        {
            *phr = RemoteCreateInstance(
                                       hBinding,
                                       pActParams->ORPCthis,
                                       pActParams->ORPCthat,
                                       NULL,
                                       pIFDIn,
                                       &pIFDOut);
        }
    }

    RpcExcept(TRUE)
    {
        Status = RpcExceptionCode();
    }

    RpcEndExcept

    MIDL_user_free(pIFDIn);

    if ((Status == RPC_S_OK) ||
        (!((Status == RPC_S_UNKNOWN_IF) ||
           (Status == RPC_S_INTERFACE_NOT_FOUND) ||
           (Status == RPC_S_NO_INTERFACES) ||
           (Status == RPC_E_NOT_REGISTERED))))
    {

        if (Status != RPC_S_OK)
        {
            *phr = HRESULT_FROM_WIN32(Status);
            return Status;
        }

        if (*phr != S_OK)
        {
            // a-sergiv (Sergei O. Ivanov), 6-17-99
            // Fix for com+ 14808/nt 355212

            LogRemoteSideFailure( &pActParams->Clsid, pActParams->ClsContext, pwszMachine, pwszPathForServer, *phr);
            return RPC_S_OK;
        }

        // AWFUL HACK ALERT:  This is too hacky even for the SCM
        ActivationStream ActStream((InterfaceData*)
                                   (((BYTE*)pIFDOut)+48));

        pActParams->pActPropsOut = new ActivationPropertiesOut(FALSE /* fBrokenRefCount */);

        if (pActParams->pActPropsOut==NULL)
        {
            *phr = E_OUTOFMEMORY;
            return RPC_S_OK;
        }


        if (pActParams->pActPropsOut==NULL)
        {
            *phr = E_OUTOFMEMORY;
            return RPC_S_OK;
        }

        IScmReplyInfo *pReplyInfo;
        *phr = pActParams->pActPropsOut->UnmarshalInterface(&ActStream,
                                                            IID_IScmReplyInfo,
                                                            (LPVOID*)&pReplyInfo);

        if (*phr != S_OK)
        {
            pReplyInfo->Release();
            pActParams->pActPropsOut->Release();
            pActParams->pActPropsOut=NULL;
            MIDL_user_free(pIFDOut);
            return RPC_S_OK;
        }

        // If in a remote LB router, just return
        if (pActParams->RemoteActivation)
        {
            pReplyInfo->Release();
            MIDL_user_free(pIFDOut);
            return RPC_S_OK;
        }

        REMOTE_REPLY_SCM_INFO *pReply;

        pReplyInfo->GetRemoteReplyInfo(&pReply);
        Win4Assert(pReply!=NULL);

        *pActParams->pOxidServer = pReply->Oxid;

        //We will not have protocol bindings for custom marshalled objrefs
        if ((pReply->pdsaOxidBindings) && (pReply->pdsaOxidBindings->wNumEntries))
        {
            Win4Assert(pActParams->pOxidInfo != NULL);
            pActParams->pOxidInfo->psa =  (DUALSTRINGARRAY *)
                                          MIDL_user_allocate(pReply->pdsaOxidBindings->wNumEntries
                                                             * sizeof(WCHAR) +
                                                             sizeof(DUALSTRINGARRAY));

            if (pActParams->pOxidInfo->psa == NULL)
            {
                pReplyInfo->Release();
                pActParams->pActPropsOut->Release();
                pActParams->pActPropsOut=NULL;
                *phr = E_OUTOFMEMORY;
                return RPC_S_OK;
            }

            dsaCopy(pActParams->pOxidInfo->psa,
                    pReply->pdsaOxidBindings);
        }
        else
            pActParams->pOxidInfo->psa = NULL;

        pActParams->ProtseqId = ProtseqId;
        pActParams->pOxidInfo->ipidRemUnknown = pReply->ipidRemUnknown;
        pActParams->pOxidInfo->dwAuthnHint = pReply->authnHint;
        pActParams->pOxidInfo->version = pReply->serverVersion;

        pActParams->pIIDs = 0;
        pActParams->pResults = 0;
        pActParams->ppIFD = 0;

        MIDL_user_free(pIFDOut);
        pReplyInfo->Release();

        return RPC_S_OK;
    }

    if ( pActParams->fComplusOnly )
    {
        *phr = HRESULT_FROM_WIN32(Status);
        return Status;
    }

    // Use Old Down-level interface

    // all remote activations on this interface have to be made with
    // minor version 1, since remote downlevel (version 5.1) servers
    // refuse any other version.
    pActParams->ORPCthis->version.MinorVersion = COM_MINOR_VERSION_1;
    pActParams->ORPCthis->flags = ORPCF_NULL;


    pActParams->ppIFD = (MInterfacePointer **)
                        MIDL_user_allocate(sizeof(MInterfacePointer *) *
                                           pActParams->Interfaces);

    pActParams->pResults = (HRESULT*) MIDL_user_allocate(sizeof(HRESULT) *
                                                         pActParams->Interfaces);

    if ((pActParams->ppIFD == NULL) || (pActParams->pResults == NULL))
    {
        MIDL_user_free(pActParams->ppIFD);
        MIDL_user_free(pActParams->pResults);
        *phr = E_OUTOFMEMORY;
        return RPC_S_OK;
    }

    for (DWORD i=0; i<pActParams->Interfaces;i++)
    {
        pActParams->ppIFD[i] = NULL;
        pActParams->pResults[i] = E_FAIL;
    }



    Status = RemoteActivation(
                             hBinding,
                             pActParams->ORPCthis,
                             pActParams->ORPCthat,
                             &pActParams->Clsid,
                             pwszPathForServer,
                             pActParams->pIFDStorage,
                             RPC_C_IMP_LEVEL_IDENTIFY,
                             pActParams->Mode,
                             pActParams->Interfaces,
                             pActParams->pIIDs,
                             cMyProtseqs,
                             aMyProtseqs,
                             pActParams->pOxidServer,
                             &pActParams->pOxidInfo->psa,
                             &pActParams->pOxidInfo->ipidRemUnknown,
                             &pActParams->pOxidInfo->dwAuthnHint,
                             &pActParams->pOxidInfo->version,
                             phr,
                             pActParams->ppIFD,
                             pActParams->pResults );

    //
    // Note that this will only give us a bad status is there is a
    // communication failure.
    //
    if ( Status != RPC_S_OK )
        return Status;

    // Tweak the COMVERSION to be the lower of the two.
    Status = NegotiateDCOMVersion( &pActParams->pOxidInfo->version );

    if ( Status != RPC_S_OK )
        return Status;

    if ( (RPC_S_OK == Status) && FAILED(*phr) )
        LogRemoteSideFailure( &pActParams->Clsid, pActParams->ClsContext, pwszMachine, pwszPathForServer, *phr );

    if ((pActParams->MsgType == GETCLASSOBJECT) && (*phr == S_OK))
    {
#if 0
        *phr = *pActParams->pResults;
#else
        *pActParams->pResults = *phr;
#endif
    }


    //
    // If the activation fails we return success for the communication
    // status, but the overall operation has failed and the error will
    // be propogated back to the client.
    //
    if ( FAILED(*phr) )
        return RPC_S_OK;


    pActParams->ProtseqId = ProtseqId;

    ASSERT(pActParams->pActPropsIn != NULL);
    *phr =
    pActParams->pActPropsIn->GetReturnActivationProperties((ActivationPropertiesOut **)
                                                           &pActParams->pActPropsOut);

    *phr = pActParams->pActPropsOut->SetMarshalledResults(pActParams->Interfaces,
                                                          pActParams->pIIDs,
                                                          pActParams->pResults,
                                                          pActParams->ppIFD);
    //pActParams->pIIDs belongs to ActPropsIn
    MIDL_user_free(pActParams->pResults);
    for (i=0;i<pActParams->Interfaces ; i++)
        MIDL_user_free(pActParams->ppIFD[i]);
    MIDL_user_free(pActParams->ppIFD);
    pActParams->pResults = NULL;
    pActParams->ppIFD = NULL;

    return RPC_S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   CreateRemoteBinding
//
//  Synopsis:   Create a binding handle for the specified machine and protseq.
//
//----------------------------------------------------------------------------
RPC_STATUS
CreateRemoteBinding(
                   IN  WCHAR *             pwszMachine,
                   IN  int                 ProtseqIndex,
                   OUT handle_t *          phBinding
                   )
{
    WCHAR *             pwszStringBinding;
    RPC_STATUS          Status;

    *phBinding = 0;

    Status = RpcStringBindingCompose(
                                    NULL,
                                    gaProtseqInfo[aMyProtseqs[ProtseqIndex]].pwstrProtseq,
                                    pwszMachine,
                                    gaProtseqInfo[aMyProtseqs[ProtseqIndex]].pwstrEndpoint,
                                    NULL,
                                    &pwszStringBinding );

    if ( Status != RPC_S_OK )
        return Status;

    Status = RpcBindingFromStringBinding( pwszStringBinding, phBinding );

    RpcStringFree( &pwszStringBinding );

    return Status;
}

//+---------------------------------------------------------------------------
//
//  Function:   CopyAuthIdentity
//
//  Synopsis:   Copy an auth identity structure and all its strings.
//
//----------------------------------------------------------------------------
HRESULT
CopyAuthIdentity(
                IN  COAUTHIDENTITY *    pAuthIdentSrc,
                IN  COAUTHIDENTITY **   ppAuthIdentDest
                )
{
    ULONG ulBufSize;
    COAUTHIDENTITY* pAuthIdentTemp;
    ULONG ulUserLen;
    ULONG ulDomainLen;
    ULONG ulPwdLen;

    *ppAuthIdentDest = NULL;
    
    // Guard against both being set, although presumably this would have
    // caused grief before we got to this point.
    if ((pAuthIdentSrc->Flags & SEC_WINNT_AUTH_IDENTITY_UNICODE) &&
        (pAuthIdentSrc->Flags & SEC_WINNT_AUTH_IDENTITY_ANSI))
    {
        ASSERT(0 && "Both string type flags were set!");
        return E_UNEXPECTED;
    }

    if (pAuthIdentSrc->Flags & SEC_WINNT_AUTH_IDENTITY_UNICODE)
    {
        // Copy Unicode version of the struct
        WCHAR* pEnd;

        // Calculate size of the individual strings, with terminating nulls
        ulUserLen = pAuthIdentSrc->User ? lstrlenW(pAuthIdentSrc->User) + 1 : 0;
        ulDomainLen = pAuthIdentSrc->Domain ? lstrlenW(pAuthIdentSrc->Domain) + 1 : 0;
        ulPwdLen = pAuthIdentSrc->Password ? lstrlenW(pAuthIdentSrc->Password) + 1 : 0;

        // Calculate size of the entire buffer, in bytes
        ulBufSize = sizeof(COAUTHIDENTITY) + ((ulUserLen + ulDomainLen + ulPwdLen) * sizeof(WCHAR));
    
        // Allocate one buffer to hold struct+strings
        pAuthIdentTemp = (COAUTHIDENTITY*) PrivMemAlloc(ulBufSize);
        if (!pAuthIdentTemp)
            return E_OUTOFMEMORY;

        // Copy string lengths.   These exclude the null.
        pAuthIdentTemp->UserLength = (ulUserLen != 0) ? ulUserLen - 1 : 0;
        pAuthIdentTemp->DomainLength = (ulDomainLen != 0) ? ulDomainLen - 1 : 0;
        pAuthIdentTemp->PasswordLength = (ulPwdLen != 0) ? ulPwdLen - 1 : 0;

        // Copy flags
        pAuthIdentTemp->Flags = pAuthIdentSrc->Flags;

        // Copy strings
        pEnd = (WCHAR*)(pAuthIdentTemp + 1);  // point to buffer just past end of struct
    
        if (pAuthIdentSrc->User)
        {
            pAuthIdentTemp->User = pEnd;
            lstrcpyW(pEnd, pAuthIdentSrc->User);
            pEnd += ulUserLen;
        }
        else
            pAuthIdentTemp->User = NULL;

        if (pAuthIdentSrc->Domain)
        {
            pAuthIdentTemp->Domain = pEnd;
            lstrcpyW(pEnd, pAuthIdentSrc->Domain);
            pEnd += ulDomainLen;
        }
        else
            pAuthIdentTemp->Domain = NULL;

        if (pAuthIdentSrc->Password)
        {
            pAuthIdentTemp->Password = pEnd;
            lstrcpyW(pEnd, pAuthIdentSrc->Password);
            pEnd += ulPwdLen;
        }
        else
            pAuthIdentTemp->Password = NULL;
    }
    else if (pAuthIdentSrc->Flags & SEC_WINNT_AUTH_IDENTITY_ANSI )
    {
        // Copy ANSI version of the struct
        CHAR* pEnd;

        // Calculate size of the individual strings, with terminating nulls
        ulUserLen = pAuthIdentSrc->User ? lstrlenA((LPCSTR)pAuthIdentSrc->User) + 1 : 0;
        ulDomainLen = pAuthIdentSrc->Domain ? lstrlenA((LPCSTR)pAuthIdentSrc->Domain) + 1 : 0;
        ulPwdLen = pAuthIdentSrc->Password ? lstrlenA((LPCSTR)pAuthIdentSrc->Password) + 1 : 0;

        // Calculate size of the entire buffer, in bytes
        ulBufSize = sizeof(COAUTHIDENTITY) + ((ulUserLen + ulDomainLen + ulPwdLen) * sizeof(CHAR));
    
        // Allocate one buffer to hold struct+strings
        pAuthIdentTemp = (COAUTHIDENTITY*) PrivMemAlloc(ulBufSize);
        if (!pAuthIdentTemp)
            return E_OUTOFMEMORY;

        // Copy string lengths.   These exclude the null.
        pAuthIdentTemp->UserLength = (ulUserLen != 0) ? ulUserLen - 1 : 0;
        pAuthIdentTemp->DomainLength = (ulDomainLen != 0) ? ulDomainLen - 1 : 0;
        pAuthIdentTemp->PasswordLength = (ulPwdLen != 0) ? ulPwdLen - 1 : 0;

        // Copy flags
        pAuthIdentTemp->Flags = pAuthIdentSrc->Flags;

        // Copy strings
        pEnd = (CHAR*)(pAuthIdentTemp + 1);  // point to buffer just past end of struct
    
        if (pAuthIdentSrc->User)
        {
            pAuthIdentTemp->User = (USHORT*)pEnd;
            lstrcpyA(pEnd, (LPCSTR)pAuthIdentSrc->User);
            pEnd += ulUserLen;
        }
        else
            pAuthIdentTemp->User = NULL;

        if (pAuthIdentSrc->Domain)
        {
            pAuthIdentTemp->Domain = (USHORT*)pEnd;
            lstrcpyA(pEnd, (LPCSTR)pAuthIdentSrc->Domain);
            pEnd += ulDomainLen;
        }
        else
            pAuthIdentTemp->Domain = NULL;

        if (pAuthIdentSrc->Password)
        {
            pAuthIdentTemp->Password = (USHORT*)pEnd;
            lstrcpyA(pEnd, (LPCSTR)pAuthIdentSrc->Password);
            pEnd += ulPwdLen;
        }
        else
            pAuthIdentTemp->Password = NULL;
    }
    else
    {
        // The user didn't specify either string bit? How did we get here?
        ASSERT(0 && "String type flag was not set!");
        return E_UNEXPECTED;
    }

    *ppAuthIdentDest = pAuthIdentTemp;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   FreeAuthInfo
//
//  Synopsis:   Free an auth info structure and all its substructures.
//
//----------------------------------------------------------------------------
void FreeAuthInfo(COAUTHINFO *pAuthInfo)
{
    if (pAuthInfo)
    {
        if (pAuthInfo->pwszServerPrincName)
            PrivMemFree(pAuthInfo->pwszServerPrincName);

        if (pAuthInfo->pAuthIdentityData)
            FreeAuthIdentity(pAuthInfo->pAuthIdentityData);

        PrivMemFree(pAuthInfo);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   FreeAuthIdentity
//
//  Synopsis:   Free an auth identity structure and all its sub strings.
//
//  Note:  because of the way the various activation paths work, we may be 
//     freeing one of two different structs here:  either a COAUTHIDENTITY 
//     or a SEC_WINNT_AUTH_IDENTITY_EXW.   COAUTHIDENTITY's are created\copied
//     in CopyAuthIdentity above; SEC_WINNT_AUTH_IDENTITY_EXW's are created in
//     ComputeSvcList.  In both cases they are constructed as one contiguous
//     buffer, so we don't have to care about the details here; just free it.
// 
//----------------------------------------------------------------------------
void FreeAuthIdentity(void* pAuthIdentity)
{
    if (pAuthIdentity)
    {
        PrivMemFree(pAuthIdentity);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   CopyAuthInfo
//
//  Synopsis:   Copy an auth info structure and all its sub structures.
//
//----------------------------------------------------------------------------
HRESULT
CopyAuthInfo(
            IN  COAUTHINFO *    pAuthInfoSrc,
            IN  COAUTHINFO **   ppAuthInfoDest
            )
{
    HRESULT hr = E_OUTOFMEMORY;
    *ppAuthInfoDest = NULL;

    if (pAuthInfoSrc == NULL)
    {
        *ppAuthInfoDest = NULL;
        return S_OK;
    }
    if ( !(*ppAuthInfoDest = (COAUTHINFO*)PrivMemAlloc(sizeof(COAUTHINFO))) )
    {
        goto COPY_AUTHINFO_EXIT;
    }

    // only alloc space for  pwszServerPrincName if its non-null
    if (pAuthInfoSrc->pwszServerPrincName)
    {
        if ( !((*ppAuthInfoDest)->pwszServerPrincName =
               (LPWSTR)PrivMemAlloc((lstrlenW(pAuthInfoSrc->pwszServerPrincName) + 1) *
                                    sizeof(WCHAR))) )
        {
            goto COPY_AUTHINFO_EXIT;
        }
    }
    else
    {
        (*ppAuthInfoDest)->pwszServerPrincName = NULL;
    }

    // copy the AuthIdentity if its non-null
    if (pAuthInfoSrc->pAuthIdentityData)
    {
        if ( FAILED(CopyAuthIdentity(pAuthInfoSrc->pAuthIdentityData,
                                     &((*ppAuthInfoDest)->pAuthIdentityData))) )
        {
            goto COPY_AUTHINFO_EXIT;
        }
    }
    else
    {
        (*ppAuthInfoDest)->pAuthIdentityData = NULL;
    }

    (*ppAuthInfoDest)->dwAuthnSvc = pAuthInfoSrc->dwAuthnSvc;
    (*ppAuthInfoDest)->dwAuthzSvc = pAuthInfoSrc->dwAuthzSvc;
    (*ppAuthInfoDest)->dwAuthnLevel = pAuthInfoSrc->dwAuthnLevel;
    (*ppAuthInfoDest)->dwImpersonationLevel = pAuthInfoSrc->dwImpersonationLevel;
    (*ppAuthInfoDest)->dwCapabilities = pAuthInfoSrc->dwCapabilities;

    if (pAuthInfoSrc->pwszServerPrincName)
    {
        lstrcpyW((*ppAuthInfoDest)->pwszServerPrincName,pAuthInfoSrc->pwszServerPrincName);
    }

    return S_OK;

    COPY_AUTHINFO_EXIT:

    if ( *ppAuthInfoDest )
    {
        if ( (*ppAuthInfoDest)->pwszServerPrincName )
        {
            PrivMemFree( (*ppAuthInfoDest)->pwszServerPrincName );
        }
        PrivMemFree( *ppAuthInfoDest );
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   EqualAuthIdentity
//
//  Synopsis:   Compare two auth identity structures by member.
//
//----------------------------------------------------------------------------
BOOL
EqualAuthIdentity(
                 COAUTHIDENTITY*     pAuthIdent,
                 COAUTHIDENTITY*     pAuthIdentOther )
{
    if ( pAuthIdent->Flags != pAuthIdentOther->Flags )
    {
        return FALSE;
    }

    ULONG cch;

    if ( pAuthIdent->User && pAuthIdentOther->User )
    {
        if ( (cch = pAuthIdent->UserLength) != pAuthIdentOther->UserLength )
        {
            return FALSE;
        }

        if ( memcmp(pAuthIdent->User,pAuthIdentOther->User,(cch+1) * sizeof(WCHAR)) != 0 )
        {
            return FALSE;
        }
    }
    else if ( pAuthIdent->User || pAuthIdentOther->User )
        return FALSE;

    if ( pAuthIdent->Domain && pAuthIdentOther->Domain )
    {
        if ( (cch = pAuthIdent->DomainLength) != pAuthIdentOther->DomainLength )
        {
            return FALSE;
        }

        if ( memcmp(pAuthIdent->Domain,pAuthIdentOther->Domain,(cch+1) * sizeof(WCHAR)) != 0 )
        {
            return FALSE;
        }
    }
    else if ( pAuthIdent->Domain || pAuthIdentOther->Domain )
        return FALSE;

    if ( pAuthIdent->Password && pAuthIdentOther->Password )
    {
        if ( (cch = pAuthIdent->PasswordLength) != pAuthIdentOther->PasswordLength )
        {
            return FALSE;
        }

        if ( memcmp(pAuthIdent->Password,pAuthIdentOther->Password,(cch+1) * sizeof(WCHAR)) != 0 )
        {
            return FALSE;
        }
    }
    else if ( pAuthIdent->Password || pAuthIdentOther->Password )
        return FALSE;

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   EqualAuthInfo
//
//  Synopsis:   Compare two auth info structures and their sub structures.
//
//----------------------------------------------------------------------------
BOOL
EqualAuthInfo(
             COAUTHINFO*         pAuthInfo,
             COAUTHINFO*         pAuthInfoOther)
{
    if ( pAuthInfo && pAuthInfoOther )
    {
        if ( (pAuthInfo->dwAuthnSvc != pAuthInfoOther->dwAuthnSvc) ||
             (pAuthInfo->dwAuthzSvc != pAuthInfoOther->dwAuthzSvc) ||
             (pAuthInfo->dwAuthnLevel != pAuthInfoOther->dwAuthnLevel) ||
             (pAuthInfo->dwImpersonationLevel != pAuthInfoOther->dwImpersonationLevel) ||
             (pAuthInfo->dwCapabilities != pAuthInfoOther->dwCapabilities) )
        {
            return FALSE;
        }

        // only compare pwszServerPrincName's if they're both specified
        if (pAuthInfo->pwszServerPrincName && pAuthInfoOther->pwszServerPrincName)
        {
            if ( lstrcmpW(pAuthInfo->pwszServerPrincName,
                          pAuthInfoOther->pwszServerPrincName) != 0 )
            {
                return FALSE;
            }
        }
        else
        {
            // if one was NULL, both should be NULL for equality
            if (pAuthInfo->pwszServerPrincName != pAuthInfoOther->pwszServerPrincName)
            {
                return FALSE;
            }
        }

        if (pAuthInfo->pAuthIdentityData && pAuthInfoOther->pAuthIdentityData)
        {
            if (!(EqualAuthIdentity(pAuthInfo->pAuthIdentityData,
                                    pAuthInfoOther->pAuthIdentityData)) )
            {
                return FALSE;
            }
        }
        else
        {
            // if either authident was NULL, they should both be NULL for equality
            if (pAuthInfo->pAuthIdentityData != pAuthInfoOther->pAuthIdentityData)
            {
                return FALSE;
            }
        }
    }
    else
    {
        if ( pAuthInfo != pAuthInfoOther )
        {
            return FALSE;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\olescm\remactif.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995.
//
//  File:
//      objexif.cxx
//
//  Contents:
//      Entry point for remote activation call to SCM/OR.
//
//  Functions:
//      RemoteActivation
//
//  History:
//
//--------------------------------------------------------------------------

#include "act.hxx"

//+---------------------------------------------------------------------------
//
//  Function:   _RemoteActivation
//
//  Synopsis:   Entry point for old style activations from off machine.
//              Creates new stype activation properties and forwards to
//              ActivateFromPropertiesPreamble.
//
//----------------------------------------------------------------------------
error_status_t _RemoteActivation(
    handle_t            hRpc,
    ORPCTHIS           *ORPCthis,
    ORPCTHAT           *ORPCthat,
    GUID               *Clsid,
    WCHAR              *pwszObjectName,
    MInterfacePointer  *pObjectStorage,
    DWORD               ClientImpLevel,
    DWORD               Mode,
    DWORD               Interfaces,
    IID                *pIIDs,
    unsigned short      cRequestedProtseqs,
    unsigned short      aRequestedProtseqs[],
    OXID               *pOxid,
    DUALSTRINGARRAY   **ppdsaOxidBindings,
    IPID               *pipidRemUnknown,
    DWORD              *pAuthnHint,
    COMVERSION         *pServerVersion,
    HRESULT            *phr,
    MInterfacePointer **ppInterfaceData,
    HRESULT            *pResults )
{
    RPC_STATUS          sc;
    ACTIVATION_PARAMS   ActParams;
    LOCALTHIS           Localthis;
    WCHAR *             pwszDummy;
    error_status_t rpcerror= RPC_S_OK;
    IID *newIIDs = 0;
    DWORD count;
    DWORD i;
    IComClassInfo* pClassInfo = NULL;
    IInitActivationPropertiesIn* pInitActPropsIn = NULL;

    // check for valid parameters
    if (ORPCthis == NULL	  ||
       ORPCthat == NULL      	  ||
       Clsid == NULL		  ||
       pOxid == NULL           	  ||
       ppdsaOxidBindings == NULL  ||
       pipidRemUnknown == NULL	  ||
       pAuthnHint == NULL	  ||
       pServerVersion == NULL	  ||
       phr == NULL             	  ||
       ppInterfaceData == NULL	  ||
       pResults == NULL)       
    {
    	return E_INVALIDARG;
    }

    *ppInterfaceData = NULL;
    *pOxid = 0;
    *ppdsaOxidBindings = NULL;

    memset(&ActParams, 0, sizeof(ActParams));

    /** Old Functionality **/

    Localthis.dwClientThread = 0;
    Localthis.dwFlags        = LOCALF_NONE;
    ORPCthis->flags         |= ORPCF_DYNAMIC_CLOAKING;
    ORPCthat->flags          = 0;
    ORPCthat->extensions     = NULL;

    // Determine what version to use for the returned interface.  Fail
    // if the client wants a version we don't support.
    *pServerVersion = ORPCthis->version;
    *phr = NegotiateDCOMVersion( pServerVersion );
    if (*phr != OR_OK)
    {
        pServerVersion->MajorVersion = COM_MAJOR_VERSION;
        pServerVersion->MinorVersion = COM_MINOR_VERSION;
        return RPC_S_OK; 
    }

    if ( ! s_fEnableDCOM )
    {
        *phr = E_ACCESSDENIED;
        return RPC_S_OK;
    }

    RegisterAuthInfoIfNecessary();

    /** Set up Actparams **/
    ActParams.hRpc = hRpc;
    ActParams.ORPCthis = ORPCthis;
    ActParams.Localthis = &Localthis;
    ActParams.ORPCthat = ORPCthat;
    ActParams.oldActivationCall = TRUE;
    ActParams.RemoteActivation = TRUE;

    if ( pwszObjectName || pObjectStorage )
        ActParams.MsgType = GETPERSISTENTINSTANCE;
    else
        ActParams.MsgType = (Mode == MODE_GET_CLASS_OBJECT) ?
                            GETCLASSOBJECT : CREATEINSTANCE;

    /** Set up Activation Properties **/
    ActivationPropertiesIn   * pInActivationProperties=NULL;
    ActivationPropertiesOut  * pOutActivationProperties=NULL;
    InstantiationInfo      * pInstantiationInfo=NULL;
    IScmRequestInfo        * pInScmRequestInfo=NULL;
    IInstanceInfo *pInstanceInfo=NULL;
    ISpecialSystemProperties* pISpecialSystemProps = NULL;
    REMOTE_REQUEST_SCM_INFO *pReqInfo;
    IScmReplyInfo        * pScmReplyInfo = NULL;
    REMOTE_REPLY_SCM_INFO *pReply;

    pInActivationProperties = new ActivationPropertiesIn;
    if (NULL == pInActivationProperties)
    {
        *phr = E_OUTOFMEMORY;
        return RPC_S_OK;
    }

    HRESULT hr;

    // Incoming session id from down-level clients is implicitly INVALID_SESSION_ID; make it so
    *phr = pInActivationProperties->QueryInterface(IID_ISpecialSystemProperties, (void**)&pISpecialSystemProps);
    if (FAILED(*phr))
      goto exit_oldremote;

    hr = pISpecialSystemProps->SetSessionId(INVALID_SESSION_ID, FALSE, FALSE);
    Win4Assert(hr == S_OK);

    // pISpecialSystemProps will be released just before returning

    pInstantiationInfo = pInActivationProperties->GetInstantiationInfo();
    Win4Assert(pInstantiationInfo != NULL);

    *phr = pInActivationProperties->QueryInterface(IID_IScmRequestInfo,
                                                 (LPVOID*)&pInScmRequestInfo);
    if (FAILED(*phr))
        goto exit_oldremote;

    hr = pInstantiationInfo->SetClsid(*Clsid);
    Win4Assert(hr == S_OK);

    hr = pInstantiationInfo->SetClsctx(CLSCTX_LOCAL_SERVER);
    Win4Assert(hr == S_OK);

    hr = pInstantiationInfo->SetClientCOMVersion(ORPCthis->version);
    Win4Assert(hr == S_OK);

    *phr = pInActivationProperties->AddRequestedIIDs(Interfaces,pIIDs);
    if ( FAILED(*phr) )
        goto exit_oldremote;

    if (ActParams.MsgType == GETPERSISTENTINSTANCE)
    {
        *phr = pInActivationProperties->QueryInterface(IID_IInstanceInfo,
                                  (LPVOID*)&pInstanceInfo);
        if (FAILED(*phr))
            goto exit_oldremote;

        if ( pwszObjectName )
        {
            WCHAR *oldName = pwszObjectName;
            *phr = GetServerPath( pwszObjectName, &pwszObjectName);
            if ( FAILED(*phr) )
                goto exit_oldremote;

            *phr = pInstanceInfo->SetFile(pwszObjectName, Mode);
            if ( FAILED(*phr) )
                goto exit_oldremote;
            pInstanceInfo->GetFile(&ActParams.pwszPath, &ActParams.Mode);
            if (pwszObjectName != oldName)
                PrivMemFree(pwszObjectName);
        }
        else
        {
            ActParams.pwszPath = 0;
        }

        if (pObjectStorage)
        {
            MInterfacePointer* newStorage;
            newStorage = (MInterfacePointer*)
                            AllocateAndCopy((InterfaceData*)pObjectStorage);
            if (newStorage)
            {
                *phr = pInstanceInfo->SetStorageIFD(newStorage);
                ActParams.pIFDStorage = pObjectStorage;
            }
            else
                *phr = E_OUTOFMEMORY;
        }

        if ( FAILED(*phr) )
            goto exit_oldremote;
    }


    pReqInfo = (REMOTE_REQUEST_SCM_INFO *)MIDL_user_allocate(sizeof(REMOTE_REQUEST_SCM_INFO));
    if (pReqInfo)
    {
        memset(pReqInfo, 0, sizeof(REMOTE_REQUEST_SCM_INFO));
        pReqInfo->ClientImpLevel = ClientImpLevel;
        if (pReqInfo->cRequestedProtseqs = cRequestedProtseqs)
        {
            pReqInfo->pRequestedProtseqs = (unsigned short*)
                                    MIDL_user_allocate(sizeof(unsigned short) *
                                                            cRequestedProtseqs);
            if (pReqInfo->pRequestedProtseqs == NULL)
            {
                *phr = E_OUTOFMEMORY;
                MIDL_user_free(pReqInfo);
            }
        }
    }
    else
        *phr = E_OUTOFMEMORY;

    if ( FAILED(*phr) )
        goto exit_oldremote;

    for (i=0; i<cRequestedProtseqs; i++)
        pReqInfo->pRequestedProtseqs[i] = aRequestedProtseqs[i];

    pInScmRequestInfo->SetRemoteRequestInfo(pReqInfo);

    //Set up for marshalling
    pInActivationProperties->SetDestCtx(MSHCTX_DIFFERENTMACHINE);
    
    //
    // Get/set class info for the requested class;  ActivateFromPropertiesPreamble 
    // expects that actpropsin will already have had this done.
    //
    *phr = GetClassInfoFromClsid(*Clsid, &pClassInfo);
    if (FAILED(*phr))
      goto exit_oldremote;

    *phr = pInActivationProperties->QueryInterface(IID_IInitActivationPropertiesIn, (void**)&pInitActPropsIn);
    if (FAILED(*phr))
      goto exit_oldremote;
    
    *phr = pInitActPropsIn->SetClassInfo(pClassInfo);
    if (FAILED(*phr))
      goto exit_oldremote;
   
    //Mark properties object as having been delegated from by
    //client which is implicitly true even though it's created here
    //for first time
    pInActivationProperties->SetDelegated();

    //Delegate through activation properties
    IActivationPropertiesOut *pActPropsOut;
    *phr = ActivateFromPropertiesPreamble(pInActivationProperties,
                                          &pActPropsOut,
                                          &ActParams);


    pOutActivationProperties = ActParams.pActPropsOut;
    if ((*phr != S_OK) || (pOutActivationProperties == NULL))
        goto exit_oldremote;

    *phr = pOutActivationProperties->QueryInterface(IID_IScmReplyInfo,
                                                 (LPVOID*)&pScmReplyInfo);
    if ( FAILED(*phr) )
        goto exit_oldremote;

    pScmReplyInfo->GetRemoteReplyInfo(&pReply);

    *pOxid = pReply->Oxid;
    *ppdsaOxidBindings = pReply->pdsaOxidBindings;
    pReply->pdsaOxidBindings = NULL;        // so it won't be freed twice

    *pipidRemUnknown = pReply->ipidRemUnknown;
    *pAuthnHint = pReply->authnHint;

    // For custom marshalled interfaces the reply is not set.  Don't
    // clear the version number in that case.
    if (pReply->serverVersion.MajorVersion != 0)
        *pServerVersion = pReply->serverVersion;

    *phr = pOutActivationProperties->GetMarshalledResults(&count,
                                                          &newIIDs,
                                                          &pResults,
                                                          &ppInterfaceData);

//  ********************
//  ** Begin fix for NT Bug 312637
//  ** April 1, 1999 -- stevesw
//  **
//  ** GetMarshalledResults puts a pointer to an empty MInterfacePointer
//  ** in the ppInterfaceData array. NT4 expects the values to be NULL.
//  ** Here we translate from NT5 to NT4 by freeing and nulling out these
//  ** array values.
//  **

    for (i = 0; i < count; i++ )
    {
        if ( !SUCCEEDED(pResults[i]) ||
             ppInterfaceData[i]->ulCntData < 2*sizeof(ULONG) )
        {
            ActMemFree (ppInterfaceData[i]);
            ppInterfaceData[i] = NULL;
        }
    }

//  **
//  ** End fix for NT Bug 312637
//  ********************

    pScmReplyInfo->Release();
    count = pOutActivationProperties->Release();
    Win4Assert(count == 0);



exit_oldremote:
    if (pInstanceInfo)
        pInstanceInfo->Release();
    if (pClassInfo)
        pClassInfo->Release();
    if (pInitActPropsIn)
        pInitActPropsIn->Release();

    if (pISpecialSystemProps)
    {
      pISpecialSystemProps->Release();
    }

    if (pInScmRequestInfo)
    {
        count = pInScmRequestInfo->Release();
        Win4Assert(count == 1);
    }

    if (pInActivationProperties)
    {
        count = pInActivationProperties->Release();
        Win4Assert(count == 0);
    }

    return rpcerror;
}

//+---------------------------------------------------------------------------
//
//  Function:    GetServerPath
//
//  Synopsis:    Computes file name of executable with drive name instead of
//               UNC name.
//
//  Description: This is to work around limitations in NT's current
//               security/rdr.  If we get a UNC path to this machine,
//               convert it into a drive based path.  A server activated as
//               the client can not open any UNC path file, even if local,
//               so we make it drive based.
//
//               On Chicago, we neither have this problem nor do we have
//               the NetGetShareInfo entrypoint in the relevant DLL
//
//----------------------------------------------------------------------------
HRESULT GetServerPath(
    WCHAR *     pwszPath,
    WCHAR **    pwszServerPath )
{
    WCHAR * pwszFinalPath;

    ASSERT(pwszPath != NULL);
    ASSERT(pwszServerPath != NULL);
    	
    pwszFinalPath = pwszPath;
    *pwszServerPath = pwszPath;

    if ( (pwszPath[0] == L'\\') && (pwszPath[1] == L'\\') )
    {
        WCHAR           wszMachineName[MAX_COMPUTERNAME_LENGTH+1];
        WCHAR *         pwszShareName;
        WCHAR *         pwszShareEnd;
        PSHARE_INFO_2   pShareInfo;
        NET_API_STATUS  Status;
        HRESULT         hr;

        // It's already UNC so this had better succeed.
        hr = GetMachineName(
                    pwszPath,
                    wszMachineName
#ifdef DFSACTIVATION
                    ,FALSE
#endif
                    );

        if ( FAILED(hr) )
            return hr;

        if ( gpMachineName->Compare( wszMachineName ) )
        {
            pwszShareName = pwszPath + 2;
            while ( *pwszShareName++ != L'\\' )
                ;

            pwszShareEnd = pwszShareName;
            while ( *pwszShareEnd != L'\\' )
                pwszShareEnd++;

            // This is OK, we're just munching on the string the RPC stub passed us.
            *pwszShareEnd = 0;

            pShareInfo = 0;
            Status = ScmNetShareGetInfo(
                            NULL,
                            pwszShareName,
                            2,
                            (LPBYTE *)&pShareInfo );

            if ( Status != STATUS_SUCCESS )
                return (ULONG) CO_E_BAD_PATH;

            pwszFinalPath = (WCHAR *) PrivMemAlloc( sizeof(WCHAR) * (MAX_PATH+1) );

            if ( ! pwszFinalPath )
            {
                LocalFree( pShareInfo );
                return (ULONG) E_OUTOFMEMORY;
            }

            lstrcpyW( pwszFinalPath, pShareInfo->shi2_path );
            *pwszShareEnd = L'\\';
            lstrcatW( pwszFinalPath, pwszShareEnd );

            //
            // Netapi32.dll midl_user_allocate calls LocalAlloc, so use
            // LocalFree to free up the stuff the stub allocated.
            //
            LocalFree( pShareInfo );
        }
    }

    *pwszServerPath = pwszFinalPath;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\olescm\remactpx.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995.
//
//  File:
//      remact.cxx, Chicago version
//
//  Contents:
//
//  History:    Created         24 June 96              SatishT
//
//--------------------------------------------------------------------------

#include "act.hxx"

// Cached RPCSS proxies
static IRemoteActivator *gpRpcssSTAProxy = NULL;
static IRemoteActivator *gpRpcssMTAProxy = NULL;

// flag to remind us whether gRpcssLock was initialized

static gfRpcssLockInitialized = FALSE;

//
// Helper function to release RPCSS proxy -- in ChannelProcessUninitialize
//

INTERNAL ReleaseRPCSSProxy()
{
    HRESULT hr = S_OK;

    if (NULL != gpRpcssSTAProxy)
    {
        hr = gpRpcssSTAProxy->Release();
        gpRpcssSTAProxy = NULL;
    }

    if (NULL != gpRpcssMTAProxy)
    {
        hr = gpRpcssMTAProxy->Release();
        gpRpcssMTAProxy = NULL;
    }

    return hr;
}


//
// Helper function to initialize RPCSS proxy
// This does a song-and-dance to avoid leaking proxies
// in a multithreaded environment
//

inline IRemoteActivator*&
SelectProxy()
{
    if (IsSTAThread())
    {
        return gpRpcssSTAProxy;
    }
    else
    {
        return gpRpcssMTAProxy;
    }
}



inline
void InitRpcssLockIfNecessary()
{
    if (!gfRpcssLockInitialized)
    {
        NTSTATUS status = RtlInitializeCriticalSection(&gRpcssLock);
        if (NT_SUCCESS(status))
            gfRpcssLockInitialized = TRUE;
        else
        {
            ASSERT(FALSE);
            gfRpcssLockInitialized = FALSE;
        }
    }
}


HRESULT InitRPCSSProxyIfNecessary()
{
    IRemoteActivator* &pRpcssProxy = SelectProxy();

    if (pRpcssProxy != NULL) return S_OK;

    IRemoteActivator *pTempProxy = NULL;

    HRESULT hr = MakeRPCSSProxy((LPVOID*) &pTempProxy);

    if (SUCCEEDED(hr))
    {
        LOCK(gComLock)

        if (IsSTAThread())
        {
            InitRpcssLockIfNecessary();
        }

        if (pRpcssProxy == NULL)
        {
            pRpcssProxy = pTempProxy;
        }

        UNLOCK(gComLock)

        if (pRpcssProxy != pTempProxy)
        {
            hr = pTempProxy->Release();
        }

    }

    return hr;
}


//
// Helper function for outgoing remote activation calls.
//

HRESULT
ForwardToRPCSS(
    ACTIVATION_PARAMS * pActParams,
    WCHAR *             pwszServerName,
    WCHAR *             pwszPathForServer )
{
    HRESULT hr = StartRPCSS();

    if (FAILED(hr))
    {
        return hr;
    }

    hr = InitRPCSSProxyIfNecessary();

    if (FAILED(hr))
    {
        return hr;
    }

    COMVERSION          ServerVersion;

    // We need a lock to prevent multiple STA threads from simultaneously
    // using the same STA proxy
    if (IsSTAThread())
    {
                EnterCriticalSection(&gRpcssLock);
    }

    // need different status since hr is being used as a parameter

    HRESULT status = SelectProxy()->ActivateOnRemoteMachine(
                                            &pActParams->Clsid,
                                            pwszServerName,
                                            pwszPathForServer,
                                            pActParams->pAuthInfo,
                                            pActParams->pIFDStorage,
                                            RPC_C_IMP_LEVEL_IDENTIFY,
                                            pActParams->Mode,
                                            pActParams->Interfaces,
                                            pActParams->pIIDs,
                                            &pActParams->ProtseqId,
                                            pActParams->pOxidServer,
                                            &pActParams->pOxidInfo->psa,
                                            &pActParams->pOxidInfo->ipidRemUnknown,
                                            &pActParams->pOxidInfo->dwAuthnHint,
                                            &hr,
                                            pActParams->ppIFD,
                                            pActParams->pResults );

    if (IsSTAThread())
    {
                LeaveCriticalSection(&gRpcssLock);
    }

    // This is a remote OXID -- no Tid or Pid is relevant --
    // in fact, if these are nonzero, the channel will treat
    // it as local, with unfortunate consequences.
        pActParams->pOxidInfo->dwTid = 0;
        pActParams->pOxidInfo->dwPid = 0;

    if (SUCCEEDED(status))
    {
        return hr;
    }
    else
    {
        return status;
    }
}


//
// Helper function that decides if a remote activation failed
// due to security problems
//

inline BOOL
SecurityError(RPC_STATUS status)
{
    switch (status)
    {
        case RPC_S_UNKNOWN_AUTHN_SERVICE:
        case RPC_S_UNKNOWN_AUTHZ_SERVICE:
        case RPC_S_UNKNOWN_AUTHN_LEVEL:
        case RPC_S_INVALID_AUTH_IDENTITY:
        case RPC_S_SEC_PKG_ERROR:
        case ERROR_ACCESS_DENIED:
        case SEC_E_UNSUPPORTED_FUNCTION:
        case SEC_E_INVALID_TOKEN:
        case SEC_E_NO_IMPERSONATION:
        case SEC_E_LOGON_DENIED:
        case SEC_E_UNKNOWN_CREDENTIALS:
        case SEC_E_NO_CREDENTIALS:
        case SEC_E_NO_AUTHENTICATING_AUTHORITY:

            return TRUE;
    }

    return FALSE;

}


//
// Function that actually makes the call to the SCM on the remote machine
//

RPC_STATUS CallRemoteSCM(
    handle_t                hRemoteSCM,
    USHORT              ProtseqId,
    ACTIVATION_PARAMS * pActParams,
    WCHAR *             pwszPathForServer,
    HRESULT *           phr
        )
{
    RPC_STATUS          Status;                 //BUGBUG: type mismatch?
    COMVERSION          ServerVersion;

    pActParams->ORPCthis->flags = ORPCF_NULL;

    Status = RemoteActivation(
                    hRemoteSCM,
                    pActParams->ORPCthis,
                    pActParams->ORPCthat,
                    &pActParams->Clsid,
                    pwszPathForServer,
                    pActParams->pIFDStorage,
                    RPC_C_IMP_LEVEL_IDENTIFY,
                    pActParams->Mode,
                    pActParams->Interfaces,
                    pActParams->pIIDs,
                    1,
                    &ProtseqId,
                    pActParams->pOxidServer,
                    &pActParams->pOxidInfo->psa,
                    &pActParams->pOxidInfo->ipidRemUnknown,
                    &pActParams->pOxidInfo->dwAuthnHint,
                    &ServerVersion,
                    phr,
                    pActParams->ppIFD,
                    pActParams->pResults );


    //
    // Note that this will only give us a bad status if there is a
    // communication failure. If the binding handle is stale (the
    // SCM on the other side has been restarted for instance), we
    // will get HRESULT_FROM_WIN32(RPC_S_UNKNOWN_IF) in *phr.
    //

    pActParams->ProtseqId = ProtseqId;

    return Status;
}

//
// Entry point for outgoing remote activation calls.
//

HRESULT
RemoteActivationCall(
    ACTIVATION_PARAMS * pActParams,
    WCHAR *             pwszServerName )
{
    COAUTHINFO    * pAuthInfo = pActParams->pAuthInfo;
    WCHAR           wszPathForServer[MAX_PATH+1];
    WCHAR *         pwszPathForServer;
    int             ProtseqIndex;
    USHORT          Protseq;
    BOOL            NoEndpoint;
    RPC_STATUS      Status = RPC_S_OK;
    HRESULT         hr = S_OK;

    // No remote activation for 16-bit apps
    // We can do this check here because on Win95 we're inproc
    if (IsWOWProcess())
    {
        return HRESULT_FROM_WIN32(RPC_E_REMOTE_DISABLED);
    }

    Win4Assert( pwszServerName );

    pwszPathForServer = 0;

    if ( pActParams->pwszPath )
    {
        // BUGBUG : this stuff needs to be re-examined.
        hr = GetPathForServer( pActParams->pwszPath, wszPathForServer, &pwszPathForServer );

        if ( hr != S_OK )
            return hr;
    }

    // if we are not RPCSS, forward the call to RPCSS
    if (!gfThisIsRPCSS)
    {
        return ForwardToRPCSS(pActParams,pwszServerName,pwszPathForServer);
    }

    RPC_BINDING_HANDLE hRemoteSCM = NULL;

    // The iterator object, including its ctor and dtor, manages
    // the cache of SCM binding handles, setting, removing and
    // replacing handles as necessary
    CScmBindingIterator BindIter(pwszServerName);

    for (
         hRemoteSCM = BindIter.First(Protseq, hr);
         hRemoteSCM != NULL && SUCCEEDED(hr);
         hRemoteSCM = BindIter.Next(Protseq, hr)
        )
    {   // try talking to remote scm on each protseq in order

        if (pAuthInfo)
        {
            // This makes a copy of the binding handle
            // so that the cached handle never has
            // specialized authentication info
            hRemoteSCM = BindIter.SetAuthInfo(pAuthInfo);

            if (hRemoteSCM == NULL) continue;
        }

        BOOL fRetry;

        do
        {
            fRetry = FALSE;

            Status = CallRemoteSCM( hRemoteSCM,
                                    Protseq,
                                    pActParams,
                                    pwszPathForServer,
                                    &hr );

            if (Status == RPC_S_OK)
            {
                break;
            }
            else if (Status == RPC_S_UNKNOWN_IF)
            {
                fRetry = BindIter.TryDynamic();
            }
            else if (SecurityError(Status))
            {
                 // this make a copy of the binding
                fRetry = BindIter.TryUnsecure(hRemoteSCM);
            }
        }
        while (fRetry);

        if (
            Status != RPC_S_OK   ||                    // comm problems
            HRESULT_CODE(hr) == RPC_S_UNKNOWN_IF       // Server-side problems
           )
                {
            continue;   //  try next protseq
        }
        else
        {
            return hr;
        }
    }

    // None of the bindings worked, we could not reach the remote server
    if (hr == S_OK)
    {
        return HRESULT_FROM_WIN32(RPC_S_SERVER_UNAVAILABLE);
    }
    else
    {
        return hr;
    }
}


extern "C"
{

error_status_t
_ActivateOnRemoteMachine(
    IN handle_t hRpc,
    IN ORPCTHIS *ORPCthis,
    IN LOCALTHIS *localthis,
    OUT ORPCTHAT *ORPCthat,
    IN const GUID *Clsid,
    IN WCHAR *pwszServerName,
    IN WCHAR *pwszPathForServer,
    IN COAUTHINFO *pAuthInfo,
    IN MInterfacePointer *pObjectStorage,
    IN DWORD ClientImpLevel,
    IN DWORD Mode,
    IN DWORD Interfaces,
    IN IID *pIIDs,
    OUT USHORT *pProtseqId,
    OUT OXID *pOxid,
    OUT DUALSTRINGARRAY **ppdsaOxidBindings,
    OUT IPID *pipidRemUnknown,
    OUT DWORD *pAuthnHint,
    OUT HRESULT *phr,
    OUT MInterfacePointer **ppInterfaceData,
    OUT HRESULT *pResults
    )
/*++

Routine Description:

    Local API for the client to perform a remote activation.

Return Value:

    RPC_S_OK

--*/
{
    PACTIVATION_PARAMS pActParams = (PACTIVATION_PARAMS)
                                    PrivMemAlloc(sizeof(ACTIVATION_PARAMS));

    if (NULL == pActParams)
    {
        return RPC_S_OUT_OF_RESOURCES;
    }

    OXID_INFO info;

    pActParams->ORPCthis = ORPCthis;
    pActParams->ORPCthat = ORPCthat;
    pActParams->pAuthInfo = pAuthInfo;
    pActParams->Clsid = *Clsid;
    pActParams->pIFDStorage = pObjectStorage;
    pActParams->Mode = Mode;
    pActParams->pwszPath = pwszPathForServer;
    pActParams->Interfaces = Interfaces;
    pActParams->pIIDs = pIIDs;
    pActParams->pOxidServer = pOxid;
    pActParams->ppIFD = ppInterfaceData;
    pActParams->pResults = pResults;
    pActParams->pOxidInfo = &info;
    pActParams->pOxidInfo->psa = NULL;

    *phr = RemoteActivationCall(
                        pActParams,
                        pwszServerName );

    *pProtseqId = pActParams->ProtseqId;
    *ppdsaOxidBindings = pActParams->pOxidInfo->psa;
    *pipidRemUnknown = pActParams->pOxidInfo->ipidRemUnknown;
    *pAuthnHint = pActParams->pOxidInfo->dwAuthnHint;

    PrivMemFree(pActParams);

    return RPC_S_OK;
}

}  // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\olescm\registry.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  registry.cxx
//
//  Registry related routines
//
//--------------------------------------------------------------------------

#include "act.hxx"

HKEY    ghClsidMachine = 0;
HKEY    ghAppidMachine = 0;

#ifdef _CHICAGO_
// Global flags set to default values
BOOL gbEnableRemoteLaunch    = FALSE;
BOOL gbEnableRemoteConnect   = FALSE;
#endif // _CHICAGO_

#ifdef SERVER_HANDLER
BOOL gbDisableEmbeddingServerHandler = FALSE;
#endif // SERVER_HANDLER

BOOL gbSAFERROTChecksEnabled = TRUE;
BOOL gbSAFERAAAChecksEnabled = TRUE;

BOOL gbDynamicIPChangesEnabled = TRUE;  // On in whistler; was off by default in W2K
DWORD gdwTimeoutPeriodForStaleMids = 10 * 60 * 1000; // ten minutes

//-------------------------------------------------------------------------
//
// ReadStringValue
//
//  Returns the named value string under the specified open registry key.
//
// Returns :
//
//  ERROR_SUCCESS, ERROR_FILE_NOT_FOUND, ERROR_BAD_FORMAT, ERROR_OUTOFMEMORY,
//  ERROR_BAD_PATHNAME, or other more esoteric win32 error code.
//
//-------------------------------------------------------------------------
DWORD
ReadStringValue(
    IN  HKEY        hKey,
    IN  WCHAR *     pwszValueName,
    OUT WCHAR **    ppwszString )
{
    DWORD   Status;
    DWORD   Type;
    DWORD   StringSize;
    WCHAR * pwszScan;
    WCHAR * pwszSource;
    WCHAR   wszString[64];

    *ppwszString = 0;

    StringSize = sizeof(wszString);

    Status = RegQueryValueEx(
                hKey,
                pwszValueName,
                NULL,
                &Type,
                (BYTE *) wszString,
                &StringSize );

    if ( (ERROR_SUCCESS == Status) &&
         (Type != REG_SZ) && (Type != REG_MULTI_SZ) && (Type != REG_EXPAND_SZ) )
        Status = ERROR_BAD_FORMAT;

    if ( (Status != ERROR_SUCCESS) && (Status != ERROR_MORE_DATA) )
        return Status;

    // Allocate one extra WCHAR for an extra null at the end.
    *ppwszString = (WCHAR *) PrivMemAlloc( StringSize + sizeof(WCHAR) );

    if ( ! *ppwszString )
        return ERROR_OUTOFMEMORY;

    if ( ERROR_MORE_DATA == Status )
    {
        Status = RegQueryValueEx(
                    hKey,
                    pwszValueName,
                    NULL,
                    &Type,
                    (BYTE *) *ppwszString,
                    &StringSize );

        if ( Status != ERROR_SUCCESS )
        {
            PrivMemFree( *ppwszString );
            *ppwszString = 0;
            return Status;
        }
    }
    else
    {
        memcpy( *ppwszString, wszString, StringSize );
    }

    //
    // Put an extra null at the end.  This allows using identical logic for both
    // REG_SZ and REG_MULTI_SZ values like RemoteServerNames instead of special
    // casing it.
    //
    (*ppwszString)[StringSize/sizeof(WCHAR)] = 0;

    //
    // Don't bother with any of the following conversions for multi strings.
    // They better be in the correct format.
    //
    if ( REG_MULTI_SZ == Type )
        return Status;

    pwszScan = pwszSource = *ppwszString;

    //
    // The original OLE sources had logic for stripping out a quoted
    // value.  I have no idea on the origin of this or if it is still
    // important.  It shouldn't hurt anything to keep it in to save
    // us from some nasty compatability problem.
    // - DKays, 8/96
    //

    if ( L'\"' == *pwszScan )
    {
        pwszScan++;

        // Copy everything between the quotes.
        while ( *pwszScan && (*pwszScan != L'\"') )
            *pwszSource++ = *pwszScan++;

        *pwszSource = 0;
    }

    //
    // Leading and trailing whitespace would hose us for some values, like
    // RemoteServerName or RunAs.  These are stripped here.  Once again, only
    // good things can happen if we put this logic in.
    //

    pwszScan = *ppwszString;

    while ( *pwszScan && ((L' ' == *pwszScan) || (L'\t' == *pwszScan)) )
        pwszScan++;

    if ( ! *pwszScan )
    {
        PrivMemFree( *ppwszString );
        *ppwszString = 0;
        return ERROR_BAD_PATHNAME;
    }

    if ( *ppwszString < pwszScan )
        lstrcpyW( *ppwszString, pwszScan );

    pwszScan = *ppwszString + lstrlenW(*ppwszString);

    while ( (pwszScan != *ppwszString) &&
            ((L' ' == pwszScan[-1]) || (L'\t' == pwszScan[-1])) )
        pwszScan--;

    *pwszScan = 0;

    //
    // Finally, handle environment string expansion if necessary.
    // Remember to add the extra trailing null again.
    //
#ifndef _CHICAGO_
    if ( REG_EXPAND_SZ == Type )
    {
        WCHAR * pwszExpandedString;
        DWORD   ExpandedStringSize;

        pwszExpandedString = 0;
        StringSize /= sizeof(WCHAR);

        for (;;)
        {
            PrivMemFree( pwszExpandedString );
            pwszExpandedString = (WCHAR *) PrivMemAlloc( (StringSize + 1) * sizeof(WCHAR) );

            if ( ! pwszExpandedString )
            {
                Status = ERROR_OUTOFMEMORY;
                break;
            }

            ExpandedStringSize = ExpandEnvironmentStrings(
                                    *ppwszString,
                                    pwszExpandedString,
                                    StringSize );

            if ( ! ExpandedStringSize )
            {
                Status = GetLastError();
                break;
            }

            if ( ExpandedStringSize > StringSize )
            {
                StringSize = ExpandedStringSize;
                continue;
            }

            Status = ERROR_SUCCESS;
            break;
        }

        PrivMemFree( *ppwszString );

        if ( ERROR_SUCCESS == Status )
        {
            pwszExpandedString[lstrlenW(pwszExpandedString)+1] = 0;
            *ppwszString = pwszExpandedString;
        }
        else
        {
            PrivMemFree( pwszExpandedString );
            *ppwszString = 0;
        }
    }
#endif

    return Status;
}

//-------------------------------------------------------------------------
//
// ReadStringKeyValue
//
//  Reads the unnamed named value string for the specified subkey name
//  under the given open registry key.
//
//-------------------------------------------------------------------------
DWORD
ReadStringKeyValue(
    IN  HKEY        hKey,
    IN  WCHAR *     pwszKeyName,
    OUT WCHAR **    ppwszString )
{
    DWORD   Status;
    HKEY    hSubKey;

    Status = RegOpenKeyEx(
                hKey,
                pwszKeyName,
                NULL,
                KEY_READ,
                &hSubKey );

    if ( Status != ERROR_SUCCESS )
        return Status;

    Status = ReadStringValue( hSubKey, L"", ppwszString );

    RegCloseKey( hSubKey );

    return Status;
}

#ifndef _CHICAGO_
//-------------------------------------------------------------------------
//
// ReadSecurityDescriptor
//
//  Converts a security descriptor from self relative to absolute form.
//  Stuffs in an owner and a group.
//
// Notes :
//
//  REGDB_E_INVALIDVALUE is returned when there is something
//  at the specified value, but it is not a security descriptor.
//
//-------------------------------------------------------------------------
DWORD
ReadSecurityDescriptor(
    IN  HKEY                    hKey,
    IN  WCHAR *                 pwszValue,
    OUT CSecDescriptor **  ppCSecDescriptor )

{
    PSID    pGroupSid;
    PSID    pOwnerSid;
    DWORD   Size;
    DWORD   Type;
    DWORD   Status;
    DWORD   Size2;
    SECURITY_DESCRIPTOR* pSD = NULL;
    CSecDescriptor* pCSecDescriptor = NULL;

    // Find put how much memory to allocate for the security descriptor.

    Size = 0;
    *ppCSecDescriptor = NULL;

    Status = RegQueryValueEx( hKey, pwszValue, 0, &Type, 0, &Size );
    
    Size2 = Size;

    if ( Status != ERROR_SUCCESS )
        return Status;

    if ( Type != REG_BINARY || (Size < sizeof(SECURITY_DESCRIPTOR)) )
        return ERROR_BAD_FORMAT;

    //
    // Allocate memory for the security descriptor plus the owner and
    // group SIDs.
    //

#ifdef _WIN64
    {
        DWORD deltaSize = sizeof( SECURITY_DESCRIPTOR ) - sizeof( SECURITY_DESCRIPTOR_RELATIVE );
        ASSERT( deltaSize < sizeof( SECURITY_DESCRIPTOR ) );
        deltaSize = OLE2INT_ROUND_UP( deltaSize, sizeof(PVOID) );

        Size2 += deltaSize;
    }
#endif // _WIN64
    
    // Allocate sd buffer and wrapper class
    pSD = (SECURITY_DESCRIPTOR *) PrivMemAlloc( Size2 );
    if (!pSD)
        return ERROR_OUTOFMEMORY;

    // Read the security descriptor.
    Status = RegQueryValueEx( hKey, pwszValue, 0, &Type, (PBYTE) pSD, &Size );

    if ( Status != ERROR_SUCCESS )
        goto ReadSecurityDescriptorEnd;

    if ( Type != REG_BINARY )
    {
        Status = ERROR_BAD_FORMAT;
        goto ReadSecurityDescriptorEnd;
    }

    //
    // Fix up the security descriptor.
    //

#ifdef _WIN64
    if ( MakeAbsoluteSD2( pSD, &Size2 ) == FALSE )   {
        Status = ERROR_BAD_FORMAT;
        goto ReadSecurityDescriptorEnd;
    }
#else  // !_WIN64

    pSD->Control &= ~SE_SELF_RELATIVE;
    pSD->Sacl = NULL;

    if ( pSD->Dacl != NULL )
    {
        if ( (Size < sizeof(ACL) + sizeof(SECURITY_DESCRIPTOR)) ||
             ((ULONG) pSD->Dacl > Size - sizeof(ACL)) )
        {
            Status = ERROR_BAD_FORMAT;
            goto ReadSecurityDescriptorEnd;
        }

        pSD->Dacl = (ACL *) (((char *) pSD) + ((ULONG) pSD->Dacl));

        if ( pSD->Dacl->AclSize + sizeof(SECURITY_DESCRIPTOR) > Size )
        {
            Status = ERROR_BAD_FORMAT;
            goto ReadSecurityDescriptorEnd;
        }
    }

    // Set up the owner and group SIDs.
    if ( pSD->Group == 0 ||
         ((ULONG)pSD->Group) + sizeof(SID) > Size ||
         pSD->Owner == 0 ||
         ((ULONG)pSD->Owner) + sizeof(SID) > Size )
    {
        Status = ERROR_BAD_FORMAT;
        goto ReadSecurityDescriptorEnd;
    }

    pSD->Group = (SID *) (((BYTE *) pSD) + (ULONG) (pSD)->Group);
    pSD->Owner = (SID *) (((BYTE *) pSD) + (ULONG) (pSD)->Owner);

#endif // !_WIN64

ReadSecurityDescriptorEnd:

    if ( Status != ERROR_SUCCESS )
    {
        if ( pSD )
            PrivMemFree( pSD );

        return Status;
    }
	
    // Allocate wrapper class for refcount semantics
    pCSecDescriptor = new CSecDescriptor(pSD);
    if (!pCSecDescriptor)
    {
        PrivMemFree(pSD);
        return ERROR_OUTOFMEMORY;
    }

    ASSERT( IsValidSecurityDescriptor( pCSecDescriptor->GetSD()) );
	
    // New class has refcount of 1, owned by the caller
    *ppCSecDescriptor = pCSecDescriptor;

    return ERROR_SUCCESS;
}
#endif

LONG
OpenClassesRootKeys()
{
    LONG    RegStatus;
    DWORD   Disposition;

    if ( ! ghClsidMachine )
    {
        // This may fail during GUI mode setup.
        RegStatus = RegOpenKeyEx(
                            HKEY_CLASSES_ROOT,
                            L"ClsID",
                            0,
                            KEY_READ,
                            &ghClsidMachine );

        if ( RegStatus != ERROR_SUCCESS )
            return RegStatus;
    }

    if ( ! ghAppidMachine )
    {
        // This may fail during GUI mode setup.
        RegStatus = RegCreateKeyEx(
                            HKEY_CLASSES_ROOT,
                            TEXT("AppID"),
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &ghAppidMachine,
                            &Disposition );

        if ( RegStatus != ERROR_SUCCESS )
            return RegStatus;
    }

    return ERROR_SUCCESS;
}

//-------------------------------------------------------------------------
//
// InitSCMRegistry
//
//   Opens global registry keys and settings.
//
//-------------------------------------------------------------------------
HRESULT
InitSCMRegistry()
{
    HRESULT hr;
    LONG    err;
    DWORD   dwDisp;

    ReadRemoteActivationKeys();

    ReadRemoteBindingHandleCacheKeys();
	
	ReadSAFERKeys();

    ReadDynamicIPChangesKeys();

    (void) OpenClassesRootKeys();

    // Now read the actual values from the registry
    // Check if Embedding Server Handler is enabled
#ifdef SERVER_HANDLER
    HKEY    hkeyOle;
    err = RegOpenKeyExA( HKEY_LOCAL_MACHINE,
                        "SOFTWARE\\Microsoft\\OLE\\DisableEmbeddingServerHandler",
                         NULL,
                         KEY_QUERY_VALUE,
                         &hkeyOle );

    if (err == ERROR_SUCCESS)
    {
        gbDisableEmbeddingServerHandler=TRUE;
        RegCloseKey(hkeyOle);
    }
#endif // SERVER_HANDLER

    return S_OK;
}


//-------------------------------------------------------------------------
//
// ReadRemoteActivationKeys
//
//-------------------------------------------------------------------------
void ReadRemoteActivationKeys()
{
    DWORD err;
    HKEY  hOle;

    // Read the DefaultLaunchPermission value (if present) from the registry
    if ((err = RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\OLE", NULL, KEY_READ,
                            &hOle)) == ERROR_SUCCESS)
    {
        DWORD dwStatus;
        CSecDescriptor* pSecDescriptor = NULL;

        dwStatus = ReadSecurityDescriptor( hOle,
                                           L"DefaultLaunchPermission",
                                           &pSecDescriptor);
        if (dwStatus == ERROR_SUCCESS)
        {
            ASSERT(pSecDescriptor);
            SetDefaultLaunchPermissions(pSecDescriptor);
            pSecDescriptor->DecRefCount();
        }
        else
        {
            // In case of a non-existent or malformed descriptor, reset 
            // current perms to NULL - this blocks everybody.
            ASSERT(!pSecDescriptor);
            SetDefaultLaunchPermissions(NULL);
        }

        RegCloseKey(hOle);
    }
}

//-------------------------------------------------------------------------
//
// GetActivationFailureLoggingLevel
//
//  Returns current activation failure logging level as specified
//  by a certain key in the Registry.
//
// History: 
//
//  a-sergiv    6-17-99    Created
//
// Returns :
//
//  0 = Discretionary logging. Log by default, client can override
//  1 = Always log. Log all errors no matter what client specified
//  2 = Never log. Never log error no matter what client speciied
//
//-------------------------------------------------------------------------

DWORD
GetActivationFailureLoggingLevel()
{
    DWORD err;
    DWORD dwSize;
    DWORD dwType;
    HKEY hOle;
    DWORD dwLevel = 0;

    if ((err = RegOpenKeyEx(HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft\\OLE", NULL, KEY_READ,
                            &hOle)) == ERROR_SUCCESS)
    {
        dwSize = sizeof(DWORD);

        if ((err = RegQueryValueEx(hOle, L"ActivationFailureLoggingLevel",
                                   NULL, &dwType, (BYTE *) &dwLevel, &dwSize))
            == ERROR_SUCCESS)
        {
            // Valid values are 0, 1 and 2. The variable is unsigned.
            // Assume 0 if invalid value is specified.

            if(dwLevel > 2)
                dwLevel = 0;
        }
	else
        {
            // Assume 0 if not specified

            dwLevel = 0;
        }

        RegCloseKey(hOle);
    }

    return dwLevel;
}

//
//  ReadRegistryIntegerValue
//
//  Tries to read a numeric value from the specified value under the key.
//  Returns FALSE if it doesn't exist or is of the wrong type, TRUE
//  otherwise.
//
BOOL ReadRegistryIntegerValue(HKEY hkey, WCHAR* pwszValue, DWORD* pdwValue)
{
    BOOL bResult = FALSE;
    DWORD error;
    DWORD dwSize = sizeof(DWORD);
    DWORD dwType;
    DWORD dwValue;

    error = RegQueryValueExW(hkey, 
                             pwszValue,
                             NULL,
                             &dwType,
                             (BYTE*)&dwValue,
                             &dwSize);
    if (error == ERROR_SUCCESS &&
        dwType == REG_DWORD)
    {
        *pdwValue = dwValue;
        bResult = TRUE;
    }
    
    return bResult;
}

//-------------------------------------------------------------------------
//
// ReadRemoteBindingHandleCacheKeys
//
// Reads optional values from the registry to control the behavior of the
// remote binding handle cache (gpRemoteMachineList).
//
//-------------------------------------------------------------------------
void
ReadRemoteBindingHandleCacheKeys()
{
    HKEY hOle;
    DWORD error;

    error = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                         L"SOFTWARE\\Microsoft\\OLE", 
                         NULL, 
                         KEY_READ,
                         &hOle);
    if (error == ERROR_SUCCESS)
    {
        DWORD dwValue;

        if (ReadRegistryIntegerValue(hOle, L"RemoteHandleCacheMaxSize", &dwValue))
        {
            gdwRemoteBindingHandleCacheMaxSize = dwValue;
        }

        if (ReadRegistryIntegerValue(hOle, L"RemoteHandleCacheMaxLifetime", &dwValue))
        {
            gdwRemoteBindingHandleCacheMaxLifetime = dwValue;
        }

        if (ReadRegistryIntegerValue(hOle, L"RemoteHandleCacheMaxIdleTimeout", &dwValue))
        {
            gdwRemoteBindingHandleCacheIdleTimeout = dwValue;
        }

        // This one not really a "binding handle cache" knob.  
        // CODEWORK:  all of this registry knob reading code needs to be
        // cleaned-up and rewritten.
        if (ReadRegistryIntegerValue(hOle, L"StaleMidTimeout", &dwValue))
        {
            gdwTimeoutPeriodForStaleMids = dwValue;
        }
           
        RegCloseKey(hOle);
    }

    return;
}

//-------------------------------------------------------------------------
//
// ReadSAFERKeys
//
// Reads optional values from the registry to control aspects of our 
// SAFER windows support
//
//-------------------------------------------------------------------------
void
ReadSAFERKeys()
{
    HKEY hOle;
    DWORD error;
    DWORD dwType;
    DWORD dwSize;
    WCHAR wszYN[5];

    error = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                         L"SOFTWARE\\Microsoft\\OLE", 
                         NULL, 
                         KEY_READ,
                         &hOle);
    if (error == ERROR_SUCCESS)
    {
        dwSize = sizeof(wszYN) / sizeof(WCHAR);

        error = RegQueryValueEx(hOle, 
                                L"SRPRunningObjectChecks",
                                NULL,
                                &dwType,
                                (BYTE*)wszYN,
                                &dwSize);
        if (error == ERROR_SUCCESS && (wszYN[0] == L'n'  ||  wszYN[0] == L'N'))
        {
            gbSAFERROTChecksEnabled = FALSE;
        }

        dwSize = sizeof(wszYN) / sizeof(WCHAR);

        error = RegQueryValueEx(hOle, 
                                L"SRPActivateAsActivatorChecks",
                                NULL,
                                &dwType,
                                (BYTE*)wszYN,
                                &dwSize);
        if (error == ERROR_SUCCESS && (wszYN[0] == L'n'  ||  wszYN[0] == L'N'))
        {
            gbSAFERAAAChecksEnabled = FALSE;
        }

        CloseHandle(hOle);
    }
    return;
}


//-------------------------------------------------------------------------
//
// ReadDynamicIPChangesKeys
//
// Reads optional values from the registry to control aspects of our
// dynamic IP change support.
//
//-------------------------------------------------------------------------
void
ReadDynamicIPChangesKeys()
{
    HKEY hOle;
    DWORD error;
    DWORD dwType;
    DWORD dwSize;
    WCHAR wszYN[5];

    error = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                         L"SOFTWARE\\Microsoft\\OLE", 
                         NULL, 
                         KEY_READ,
                         &hOle);
    if (error == ERROR_SUCCESS)
    {
        dwSize = sizeof(wszYN) / sizeof(WCHAR);

        error = RegQueryValueEx(hOle, 
                                L"EnableSystemDynamicIPTracking",
                                NULL,
                                &dwType,
                                (BYTE*)wszYN,
                                &dwSize);
        // note: in w2k, this code turned the flag on only if the registry
        // value was "y" or "Y".  In whistler I have reversed these semantics.
        if (error == ERROR_SUCCESS && (wszYN[0] == L'n'  ||  wszYN[0] == L'N'))
        {
            gbDynamicIPChangesEnabled = FALSE;
        }

        CloseHandle(hOle);
    }
    return;
}


//-------------------------------------------------------------------------
//
// CRegistryWatcher::CRegistryWatcher
//
// Constructor for CRegistryWatcher.
//
// If allocation of the event fails, or opening the key fails, or registering
// for the notify fails, then Changed() always returns S_OK (yes, it changed).
// This doesn't affect correctness, only speed.
//
//-------------------------------------------------------------------------
CRegistryWatcher::CRegistryWatcher(HKEY hKeyRoot, const WCHAR *wszSubKey)
{
    _fValid = FALSE;

    _hEvent = CreateEvent(NULL, FALSE, TRUE, NULL);
    if (!_hEvent)
        return;
    
    LONG res = RegOpenKeyEx(hKeyRoot, wszSubKey, 0, KEY_NOTIFY, &_hWatchedKey);
    if (res != ERROR_SUCCESS)
    {
        Cleanup();
        return;
    }
       
    _fValid = TRUE;
}

//-------------------------------------------------------------------------
//
// CRegistryWatcher::CRegistryWatcher
//
// Determine if the registry key being watched has changed.  Returns
// S_OK if it has changed, S_FALSE if not, and an error if something
// failed.
//
//-------------------------------------------------------------------------
HRESULT CRegistryWatcher::Changed()
{
    if (!_fValid)
        return S_OK;

    // _hEvent is auto-reset, so only one thread will re-register.
    if (WAIT_OBJECT_0 == WaitForSingleObject(_hEvent, 0))
    {
        LONG res = RegNotifyChangeKeyValue(_hWatchedKey,
                                           TRUE, 
                                           REG_NOTIFY_CHANGE_NAME | REG_NOTIFY_CHANGE_LAST_SET,
                                           _hEvent,
                                           TRUE);
        if (res != ERROR_SUCCESS)
        {
            // Could not re-register, so we can't watch the key anymore.
            _fValid = FALSE;
            return HRESULT_FROM_WIN32(res);
        }
        else
            return S_OK;            
    }
    else
        return S_FALSE;
}

void CRegistryWatcher::Cleanup()
{
    if (_hEvent)
    {
        CloseHandle(_hEvent);      
        _hEvent = NULL;
    }

    if (_hWatchedKey)
    {
        RegCloseKey(_hWatchedKey); 
        _hWatchedKey = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\olescm\rotif.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       rotif.cxx
//
//  Contents:   Initialization for SCM ROT and RPC interface
//
//  Functions:  InitScmRot
//              IrotRegister
//              IrotRevoke
//              IrotIsRunning
//              IrotGetObject
//              IrotNoteChangeTime
//              IrotGetTimeOfLastChange
//              IrotEnumRunning
//              GetObjectFromRot
//
//  History:    24-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------

#include "act.hxx"

#ifdef DCOM95_ON_NT
extern CToken * tokenlist[];
#endif // DCOM95_ON_NT

CScmRot *gpscmrot = NULL;

extern void CheckLocalCall( handle_t hRpc );

//+-------------------------------------------------------------------------
//
//  Function:   InitScmRot
//
//  Synopsis:   Initialize ROT Directory for the SCM
//              NOTE:  if InitRotDir is ever called by any process other than the
//              SCM then the RpcServerRegisterIf may fail with RPC_S_TYPE_ALREADY_REGISTERED
//              in some unusal cases.  Change the error checking code to ignore that error.
//
//  Returns:    S_OK - Created ROT directory successfully
//
//  History:    17-Nov-93 Ricksa    Created
//              26-Jul-94 AndyH     Added warning above while bug hunting.
//              25-Jan-95 Ricksa    New rot
//
//  Notes:      This routine is only in non-chicago builds
//
//--------------------------------------------------------------------------
HRESULT InitScmRot()
{
    CairoleDebugOut((DEB_ROT, "%p _IN InitScmRot \n", NULL));

    HRESULT hr = E_OUTOFMEMORY;

    gpscmrot = new CScmRot(hr, ROTHINT_NAME);

    if (SUCCEEDED(hr))
    {
        SCODE sc = RpcServerRegisterIf(IROT_ServerIfHandle, 0, 0);

        Win4Assert((sc == 0) && "RpcServerRegisterIf for IRotDir failed!");

        if ( sc == ERROR_SUCCESS )
        {
            hr = S_OK;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(sc);
            delete gpscmrot;
        }
    }

    CairoleDebugOut((DEB_ROT, "%p OUT InitScmRot ( %lx )\n", NULL, hr));

    return  hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   IrotRegister
//
//  Synopsis:   Main entry point for registering an item in the ROT
//
//  Arguments:  [hRpc] - rpc handle to SCM
//              [pmkeqbuf] - moniker equality buffer
//              [pifdObject] - marshaled object
//              [pifdObjectName] - marshaled moniker
//              [pfiletime] - time of last change
//              [dwProcessID] - process ID for object
//              [psrkRegister] - SCM registration ID
//              [prpcstat] - RPC communication status
//
//  Returns:    NOERROR
//
//  History:    30-Jan-95 Ricksa    Created
//
//  Notes:      The purpose of this routine is really just to make the
//              code more readable.
//
//--------------------------------------------------------------------------
extern "C" HRESULT IrotRegister(
    handle_t hRpc,
    PHPROCESS phProcess,
    WCHAR *pwszWinstaDesktop,
    MNKEQBUF *pmkeqbuf,
    InterfaceData *pifdObject,
    InterfaceData *pifdObjectName,
    FILETIME *pfiletime,
    DWORD dwProcessID,
    WCHAR *pwszServerExe,
    SCMREGKEY *psrkRegister,
    error_status_t *prpcstat)
{
    CheckLocalCall( hRpc );

    VDATEHEAP();

    *prpcstat = RPC_S_OK;

#if DBG == 1

    CairoleDebugOut((DEB_SCM, "%p _IN IrotRegister\n", NULL));
    DbgPrintMnkEqBuf("_IN Moinker Compare Buffer:", pmkeqbuf);
    DbgPrintIFD("_IN Object Interface Data:", pifdObject);
    DbgPrintIFD("_IN Moniker Interface Data:", pifdObject);
    DbgPrintFileTime("_IN FileTime: ", pfiletime);
    CairoleDebugOut((DEB_SCM, "_IN Process ID: %lX\n", dwProcessID));

#endif // DBG == 1

    HRESULT hr = E_OUTOFMEMORY;
    CProcess* pProcess;

    pProcess = ReferenceProcess(phProcess);
    if (!pProcess)
        return E_ACCESSDENIED;

    if (gpscmrot != NULL)
    {
        hr = gpscmrot->Register(
                pProcess,
                pwszWinstaDesktop,
                pmkeqbuf,
                pifdObject,
                pifdObjectName,
                pfiletime,
                dwProcessID,
                pwszServerExe,
                psrkRegister);
    }

#if DBG == 1

    CairoleDebugOut((DEB_SCM, "%p OUT IrotRegister\n", NULL));
    CairoleDebugOut((DEB_SCM, "OUT Hresult %lX\n", hr));

    if (SUCCEEDED(hr))
    {
        DbgPrintScmRegKey("OUT Register Key: ", psrkRegister);
    }

#endif // DBG == 1

    VDATEHEAP();
    return hr;

}

//+-------------------------------------------------------------------------
//
//  Function:   IrotRevoke
//
//  Synopsis:   Main entry point for revoking an item from the ROT
//
//  Arguments:  [hRpc] - rpc handle to SCM
//              [psrkRegister] - SCM registration ID
//              [fServer] - whether object server is deregistering
//              [ppifdObject] - returned marshaled object
//              [ppifdObjectName] - returned marshaled moniker
//              [prpcstat] - RPC communication status
//
//  Returns:    NOERROR
//
//  History:    30-Jan-95 Ricksa    Created
//
//  Notes:      The purpose of this routine is really just to make the
//              code more readable.
//
//--------------------------------------------------------------------------
extern "C" HRESULT  IrotRevoke(
    handle_t hRpc,
    SCMREGKEY *psrkRegister,
    BOOL fServer,
    InterfaceData **ppifdObject,
    InterfaceData **ppifdName,
    error_status_t *prpcstat)
{
    CheckLocalCall( hRpc );

    VDATEHEAP();

    *prpcstat = RPC_S_OK;

#if DBG == 1

    CairoleDebugOut((DEB_SCM, "%p _IN IrotRevoke\n", NULL));
    DbgPrintScmRegKey("_IN Revoke Key: ", psrkRegister);
    CairoleDebugOut((DEB_SCM, "_IN Server Flag: %s\n",
        fServer ? "Server" : "Client"));
    CairoleDebugOut((DEB_SCM, "_IN Object Interface Data Ptr: %lx\n",
        ppifdObject));
    CairoleDebugOut((DEB_SCM, "_IN Moniker Interface Data Ptr: %lx\n",
        ppifdName));

#endif // DBG == 1

    HRESULT hr = E_OUTOFMEMORY;

    if (gpscmrot != NULL)
    {
        hr = gpscmrot->Revoke(psrkRegister, fServer, ppifdObject, ppifdName);
    }

#if DBG == 1

    CairoleDebugOut((DEB_SCM, "%p OUT IrotRevoke\n", NULL));
    CairoleDebugOut((DEB_SCM, "OUT Hresult : %lx\n", hr));

    if (*ppifdObject != NULL)
    {
        DbgPrintIFD("OUT Object Interface Data:", *ppifdObject);
    }

    if (*ppifdName != NULL)
    {
        DbgPrintIFD("OUT Moniker Interface Data:", *ppifdName);
    }

#endif // DBG == 1

    VDATEHEAP();
    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   IrotIsRunning
//
//  Synopsis:   Main entry point for determining if an entry is in the ROT
//
//  Arguments:  [hRpc] - rpc handle to SCM
//              [pmkeqbuf] - moniker equality buffer
//              [prpcstat] - RPC communication status
//
//  Returns:    NOERROR
//
//  History:    30-Jan-95 Ricksa    Created
//
//  Notes:      The purpose of this routine is really just to make the
//              code more readable.
//
//--------------------------------------------------------------------------
extern "C" HRESULT  IrotIsRunning(
    handle_t hRpc,
    PHPROCESS phProcess,
    WCHAR *pwszWinstaDesktop,
    MNKEQBUF *pmkeqbuf,
    error_status_t *prpcstat)
{
    CheckLocalCall( hRpc );

    VDATEHEAP();

    *prpcstat = RPC_S_OK;

#if DBG == 1

    CairoleDebugOut((DEB_SCM, "%p _IN IrotIsRunning\n", NULL));
    DbgPrintMnkEqBuf("_IN Moniker Compare Buffer:", pmkeqbuf);

#endif // DBG == 1

    HRESULT hr = E_OUTOFMEMORY;
    CProcess* pProcess;

    pProcess = ReferenceProcess(phProcess);
    if (!pProcess)
        return E_ACCESSDENIED;

    if (gpscmrot != NULL)
    {
        hr = gpscmrot->IsRunning(
                pProcess->GetToken(),
                pwszWinstaDesktop,
                pmkeqbuf);
    }

#if DBG == 1

    CairoleDebugOut((DEB_SCM, "%p OUT IrotIsRunning\n", NULL));
    CairoleDebugOut((DEB_SCM, "OUT Hresult : %lx\n", hr));

#endif // DBG == 1

    VDATEHEAP();
    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   IrotGetObject
//
//  Synopsis:   Main entry point for getting an object from the ROT
//
//  Arguments:  [hRpc] - rpc handle to SCM
//              [dwProcessID] - process id for object
//              [pmkeqbuf] - moniker equality buffer
//              [psrkRegister] - Registration ID of returned Object
//              [ppifdObject] - returned marshaled object
//              [prpcstat] - RPC communication status
//
//  Returns:    NOERROR
//
//  History:    30-Jan-95 Ricksa    Created
//
//  Notes:
//
//--------------------------------------------------------------------------
extern "C" HRESULT  IrotGetObject(
    handle_t hRpc,
    PHPROCESS phProcess,
    WCHAR *pwszWinstaDesktop,
    DWORD dwProcessID,
    MNKEQBUF *pmkeqbuf,
    SCMREGKEY *psrkRegister,
    InterfaceData **ppifdObject,
    error_status_t *prpcstat)
{
    CheckLocalCall( hRpc );

    VDATEHEAP();

    *prpcstat = RPC_S_OK;

#if DBG == 1

    CairoleDebugOut((DEB_SCM, "%p _IN IrotGetObject\n", NULL));
    CairoleDebugOut((DEB_SCM, "_IN Process ID: %lX\n", dwProcessID));
    DbgPrintMnkEqBuf("_IN Moniker Compare Buffer:", pmkeqbuf);

#endif // DBG == 1

    HRESULT hr = E_OUTOFMEMORY;
    CProcess* pProcess;

    pProcess = ReferenceProcess(phProcess);
    if (!pProcess)
        return E_ACCESSDENIED;

    if (gpscmrot != NULL)
    {
        hr = gpscmrot->GetObject(
                pProcess->GetToken(),
                pwszWinstaDesktop,
                dwProcessID,
                pmkeqbuf,
                psrkRegister,
                ppifdObject);
    }

#if DBG == 1

    CairoleDebugOut((DEB_SCM, "%p OUT IrotGetObject\n", NULL));
    CairoleDebugOut((DEB_SCM, "OUT Hresult : %lx\n", hr));

    if (SUCCEEDED(hr))
    {
        DbgPrintScmRegKey("OUT Register Key: ", psrkRegister);
        DbgPrintIFD("OUT Object Interface Data:", *ppifdObject);
    }

#endif // DBG == 1

    VDATEHEAP();
    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   IrotNoteChangeTime
//
//  Synopsis:   Main entry point for setting the change time of an object
//              int the ROT.
//
//  Arguments:  [hRpc] - rpc handle to SCM
//              [psrkRegister] - Registration ID of Object to update
//              [pfiletime] - new change time for the object
//              [prpcstat] - RPC communication status
//
//  Returns:    NOERROR
//
//  History:    30-Jan-95 Ricksa    Created
//
//  Notes:
//
//--------------------------------------------------------------------------
extern "C" HRESULT  IrotNoteChangeTime(
    handle_t hRpc,
    SCMREGKEY *psrkRegister,
    FILETIME *pfiletime,
    error_status_t *prpcstat)
{
    CheckLocalCall( hRpc );

    VDATEHEAP();

    *prpcstat = RPC_S_OK;

#if DBG == 1

    CairoleDebugOut((DEB_SCM, "%p _IN IrotNoteChangeTime\n", NULL));
    DbgPrintScmRegKey("_IN Revoke Key: ", psrkRegister);
    DbgPrintFileTime("_IN FileTime: ", pfiletime);

#endif // DBG == 1

    HRESULT hr = E_OUTOFMEMORY;

    if (gpscmrot != NULL)
    {
        hr = gpscmrot->NoteChangeTime(psrkRegister, pfiletime);
    }

#if DBG == 1

    CairoleDebugOut((DEB_SCM, "%p OUT IrotRevoke\n", NULL));
    CairoleDebugOut((DEB_SCM, "OUT Hresult : %lx\n", hr));

#endif // DBG == 1

    VDATEHEAP();
    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   IrotGetTimeOfLastChange
//
//  Synopsis:   Main entry point for getting the change time of an object
//              int the ROT.
//
//  Arguments:  [hRpc] - rpc handle to SCM
//              [pmkeqbuf] - Moniker for object
//              [pfiletime] - new change time for the object
//              [prpcstat] - RPC communication status
//
//  Returns:    NOERROR
//
//  History:    30-Jan-95 Ricksa    Created
//
//  Notes:
//
//--------------------------------------------------------------------------
extern "C" HRESULT  IrotGetTimeOfLastChange(
    handle_t hRpc,
    PHPROCESS phProcess,
    WCHAR *pwszWinstaDesktop,
    MNKEQBUF *pmkeqbuf,
    FILETIME *pfiletime,
    error_status_t *prpcstat)
{
    CheckLocalCall( hRpc );

    VDATEHEAP();

    *prpcstat = RPC_S_OK;

#if DBG == 1

    CairoleDebugOut((DEB_SCM, "%p _IN IrotGetTimeOfLastChange\n", NULL));
    DbgPrintMnkEqBuf("_IN Moniker Compare Buffer:", pmkeqbuf);

#endif // DBG == 1

    HRESULT hr = E_OUTOFMEMORY;
    CProcess* pProcess;

    pProcess = ReferenceProcess(phProcess);
    if (!pProcess)
        return E_ACCESSDENIED;

    if (gpscmrot != NULL)
    {
        hr = gpscmrot->GetTimeOfLastChange(
                pProcess->GetToken(),
                pwszWinstaDesktop,
                pmkeqbuf,
                pfiletime);
    }

#if DBG == 1

    CairoleDebugOut((DEB_SCM, "%p OUT IrotGetTimeOfLastChange\n", NULL));
    CairoleDebugOut((DEB_SCM, "OUT Hresult : %lx\n", hr));
    DbgPrintFileTime("OUT FileTime: ", pfiletime);

#endif // DBG == 1

    VDATEHEAP();
    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   IrotEnumRunning
//
//  Synopsis:   Main entry point for getting all monikers to running objects
//              int the ROT.
//
//  Arguments:  [hRpc] - rpc handle to SCM
//              [ppMKIFList] - list of marshaled monikers to running objects
//              [prpcstat] - RPC communication status
//
//  Returns:    NOERROR
//
//  History:    30-Jan-95 Ricksa    Created
//
//  Notes:
//
//--------------------------------------------------------------------------
extern "C" HRESULT  IrotEnumRunning(
    handle_t hRpc,
    PHPROCESS phProcess,
    WCHAR *pwszWinstaDesktop,
    MkInterfaceList **ppMkIFList,
    error_status_t *prpcstat)
{
    CheckLocalCall( hRpc );

    VDATEHEAP();

    *prpcstat = RPC_S_OK;

    CairoleDebugOut((DEB_SCM, "%p _IN IrotEnumRunning\n", NULL));

    HRESULT hr = E_OUTOFMEMORY;
    CProcess* pProcess;

    pProcess = ReferenceProcess(phProcess);
    if (!pProcess)
        return E_ACCESSDENIED;

    if (gpscmrot != NULL)
    {
        hr = gpscmrot->EnumRunning(
                pProcess->GetToken(),
                pwszWinstaDesktop,
                ppMkIFList);
    }

#if DBG == 1

    CairoleDebugOut((DEB_SCM, "%p OUT IrotEnumRunning\n", NULL));
    CairoleDebugOut((DEB_SCM, "OUT Hresult : %lx\n", hr));

    if (SUCCEEDED(hr))
    {
        DbgPrintMkIfList("OUT Moniker IF List: ", ppMkIFList);
    }

#endif // DBG == 1

    VDATEHEAP();
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetObjectFromRot
//
//  Synopsis:   Helper for binding to locate an object in the ROT
//
//  Arguments:  [pwszPath] - path for bind
//              [ppifdObject] - marshaled output buffer
//
//  Returns:    NOERROR
//
//  Algorithm:  Get the ROT. Create a moniker comparison buffer for searching
//              the ROT. Then try to get the object out of the ROT.
//
//  History:    30-Jan-95 Ricksa    Created
//
//  Notes:
//
//--------------------------------------------------------------------------
HRESULT GetObjectFromRot(
    CToken *pToken,
    WCHAR *pwszWinstaDesktop,
    WCHAR *pwszPath,
    InterfaceData **ppifdObject)
{
    VDATEHEAP();

    CairoleDebugOut((DEB_ROT, "%p _IN GetObjectFromRot "
        "( %p , %p )\n", NULL, pwszPath, ppifdObject));

    HRESULT hr = E_OUTOFMEMORY;

    if (gpscmrot != NULL)
    {
        // Create a moniker equality buffer from path
        CTmpMkEqBuf tmeb;

        hr = CreateFileMonikerComparisonBuffer(pwszPath, tmeb.GetBuf(),
            tmeb.GetSize(), tmeb.GetSizeAddr());

        if (hr == NOERROR)
        {
            // SCMREGKEY which we won't really use
            SCMREGKEY srkRegister;

            hr = gpscmrot->GetObject(
                    pToken,
                    pwszWinstaDesktop,
                    0,
                    tmeb.GetMkEqBuf(),
                    &srkRegister,
                    ppifdObject );
        }
    }

    CairoleDebugOut((DEB_ROT, "%p OUT GetObjectFromRot ( %lx ) [ %p ]\n",
        NULL, hr, *ppifdObject));

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\olescm\remsysif.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995.
//
//  File:
//      objexif.cxx
//
//  Contents:
//      Entry point for remote activation call to SCM/OR.
//
//  Functions:
//      RemoteGetClassObject
//      RemoteCreateInstance
//
//  History:
//
//--------------------------------------------------------------------------

#include "act.hxx"

//-------------------------------------------------------------------------
//
//  Function:   _RemoteGetClassObject
//
//  Synopsis:   Entry point for 5.6 get class object activations.  Forwards to
//              PerformScmStage.
//
//-------------------------------------------------------------------------

HRESULT _RemoteGetClassObject(
    handle_t            hRpc,
    ORPCTHIS           *ORPCthis,
    ORPCTHAT           *ORPCthat,
    IN  MInterfacePointer   * pInActProperties,
    OUT MInterfacePointer  ** ppOutActProperties
    )
{
    RPC_STATUS          sc;
    LOCALTHIS           Localthis;
    HRESULT             hr;

    if (ORPCthis == NULL || ORPCthat == NULL)
    	return E_INVALIDARG;
    
    Localthis.dwClientThread = 0;
    Localthis.dwFlags        = LOCALF_NONE;
    ORPCthis->flags         |= ORPCF_DYNAMIC_CLOAKING;
    ORPCthat->flags          = 0;
    ORPCthat->extensions     = NULL;

    if ( ! s_fEnableDCOM )
    {
        return E_ACCESSDENIED;
    }

    // Determine what version to use for the returned interface.  Fail
    // if the client wants a version we don't support.
    hr = NegotiateDCOMVersion( &ORPCthis->version );
    if (hr != OR_OK)
    {
        return hr;
    }

    RegisterAuthInfoIfNecessary();

    ACTIVATION_PARAMS       ActParams;
    memset(&ActParams, 0, sizeof(ActParams));

    ActParams.MsgType = GETCLASSOBJECT;
    ActParams.hRpc = hRpc;
    ActParams.ORPCthis = ORPCthis;
    ActParams.Localthis = &Localthis;
    ActParams.ORPCthat = ORPCthat;
    ActParams.oldActivationCall = FALSE;
    ActParams.RemoteActivation = TRUE;


    return PerformScmStage(SERVER_MACHINE_STAGE,
                           &ActParams,
                           pInActProperties,
                           ppOutActProperties);
}


//-------------------------------------------------------------------------
//
//  Function:   _RemoteGetCreateInstance
//
//  Synopsis:   Entry point for 5.6 create instance activations.  Forwards to
//              PerformScmStage.
//
//-------------------------------------------------------------------------

HRESULT _RemoteCreateInstance(
    handle_t            hRpc,
    ORPCTHIS           *ORPCthis,
    ORPCTHAT           *ORPCthat,
    IN  MInterfacePointer   * pUnk,
    IN  MInterfacePointer   * pInActProperties,
    OUT MInterfacePointer  ** ppOutActProperties
    )
{
    RPC_STATUS          sc;
    LOCALTHIS           Localthis;
    HRESULT             hr;

    if (ORPCthis == NULL || ORPCthat == NULL)
    	return E_INVALIDARG;
    
    Localthis.dwClientThread = 0;
    Localthis.dwFlags        = LOCALF_NONE;
    ORPCthis->flags         |= ORPCF_DYNAMIC_CLOAKING;
    ORPCthat->flags          = 0;
    ORPCthat->extensions     = NULL;

    if ( ! s_fEnableDCOM )
    {
        return E_ACCESSDENIED;
    }

    // Determine what version to use for the returned interface.  Fail
    // if the client wants a version we don't support.
    hr = NegotiateDCOMVersion( &ORPCthis->version );
    if (hr != OR_OK)
    {
        return hr;
    }

    RegisterAuthInfoIfNecessary();

    ACTIVATION_PARAMS       ActParams;
    memset(&ActParams, 0, sizeof(ActParams));

    ActParams.MsgType = CREATEINSTANCE;
    ActParams.hRpc = hRpc;
    ActParams.ORPCthis = ORPCthis;
    ActParams.Localthis = &Localthis;
    ActParams.ORPCthat = ORPCthat;
    ActParams.oldActivationCall = FALSE;
    ActParams.RemoteActivation = TRUE;

    return PerformScmStage(SERVER_MACHINE_STAGE,
                           &ActParams,
                           pInActProperties,
                           ppOutActProperties);
}

//-------------------------------------------------------------------------
//
//  Function:   _DummyQueryInterfaceIRemoteSCMActivator
//
//  Synopsis:   Unused function required by linker.  This function exists
//              to make the activation interface wire compatible with a
//              COM interface.
//
//-------------------------------------------------------------------------

HRESULT _DummyQueryInterfaceIRemoteSCMActivator(handle_t rpc,
                                                ORPCTHIS *orpcthis,
                                                ORPCTHAT *orpcthat,
                                                DWORD dummy )
{
    return E_NOTIMPL;
}

//-------------------------------------------------------------------------
//
//  Function:   _DummyAddRefIRemoteSCMActivator
//
//  Synopsis:   Unused function required by linker.  This function exists
//              to make the activation interface wire compatible with a
//              COM interface.
//
//-------------------------------------------------------------------------

HRESULT _DummyAddRefIRemoteSCMActivator(handle_t rpc,
                                        ORPCTHIS *orpcthis,
                                        ORPCTHAT *orpcthat,
                                        DWORD dummy )
{
    return E_NOTIMPL;
}

//-------------------------------------------------------------------------
//
//  Function:   _DummyReleaseIRemoteSCMActivator
//
//  Synopsis:   Unused function required by linker.  This function exists
//              to make the activation interface wire compatible with a
//              COM interface.
//
//-------------------------------------------------------------------------

HRESULT _DummyReleaseIRemoteSCMActivator(handle_t rpc,
                                         ORPCTHIS *orpcthis,
                                         ORPCTHAT *orpcthat,
                                         DWORD dummy )
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\olescm\scmhash.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       scmhash.cxx
//
//  Contents:   Class definitions used for SCM hash table.
//
//  History:    20-Jan-93 Ricksa    Created from map_kv.cpp
//
//  Notes:      The reason for creating this file rather than using the
//              original class is that the SCM has different memory allocation
//              needs depending on whether it is built for Win95 or NT.
//
//--------------------------------------------------------------------------

#include "act.hxx"

//+-------------------------------------------------------------------------
//
//  Member:     CScmHashEntry::~CScmHashEntry
//
//  Synopsis:   Clean up hash entry
//
//  History:    16-Feb-96 Ricksa    Created
//
//--------------------------------------------------------------------------
CScmHashEntry::~CScmHashEntry(void)
{
    // Just exists hopefully to save some space
}






//+-------------------------------------------------------------------------
//
//  Member:     CScmHashTable::~CScmHashTable
//
//  Synopsis:   Free resources held by the hash table
//
//  Algorithm:  For each hash bucket, delete all member of the collison
//              list.
//
//  History:    16-Feb-95 Ricksa    Created
//
//--------------------------------------------------------------------------
CScmHashTable::~CScmHashTable(void)
{
    // Free all the objects in the table.

    // Loop through each hash bucket
    for (DWORD i = 0; i < _ndwHashTableSize; i++)
    {
        // For each entry in the hash bucket list delete it.
        CScmHashEntry *pshe = _apsheHashTable[i];

        while (pshe != NULL)
        {
            CScmHashEntry *psheNext = pshe->GetNext();

            delete pshe;

            pshe = psheNext;
        }

    }

    // Free the table itself
    PrivMemFree (_apsheHashTable);
}




//+-------------------------------------------------------------------------
//
//  Member:     CScmHashTable::Lookup
//
//  Synopsis:   Look up entry by hash and key
//
//  Arguments:  [dwHash] - hash value to use
//              [pKey] - key to use
//              [cbKey] - count of bytes in the key
//
//  Returns:    NULL - no matching entry was found
//              Pointer to first matching entry found
//
//  Algorithm:  If there is an entry for the hash bucket, search
//              through the collision entries for the first entry
//              that matches.
//
//  History:    20-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
CScmHashEntry * CScmHashTable::Lookup(
    DWORD dwHash,
    LPVOID pKey,
    UINT cbKey) const
{
    CairoleDebugOut((DEB_ROT, "%p _IN CScmHashTable::Lookup "
        "( %lx , %p , %lx )\n", this, dwHash, pKey, cbKey));

    CScmHashEntry *psheFound = NULL;

    // Are there any entries for this bucket?
    if (_apsheHashTable[dwHash] != NULL)
    {
        CScmHashEntry *psheToSearch = _apsheHashTable[dwHash];

        // Loop searching for a match
        do
        {
            if (psheToSearch->IsEqual(pKey, cbKey))
            {
                psheFound = psheToSearch;
                break;
            }
        } while ((psheToSearch = psheToSearch->GetNext()) != NULL);
    }

    CairoleDebugOut((DEB_ROT, "%p OUT CScmHashTable::Lookup ( %p )\n",
        this, psheFound));
    return psheFound;
}



//+-------------------------------------------------------------------------
//
//  Member:     CScmHashTable::SetAt
//
//  Synopsis:   Add a new entry
//
//  Arguments:  [dwHash] - hash value to use
//              [psheToAdd] - hash entry to add
//
//  Algorithm:  If there are no entries for the bucket, make the bucket
//              point to this entry. Otherwise, put this entry on the
//              end of the list of collisions.
//
//  History:    20-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
void CScmHashTable::SetAt(
    DWORD dwHash,
    CScmHashEntry *psheToAdd)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CScmHashTable::SetAt "
        "( %lx , %p )\n", this, dwHash, psheToAdd));

    // Are there entries that has to this bucket?
    if (_apsheHashTable[dwHash] != NULL)
    {
        // Yes -- then put this one on the end of the list

        CScmHashEntry *psheToSearch = _apsheHashTable[dwHash];
        CScmHashEntry *psheLast;

        do
        {

            psheLast = psheToSearch;

        } while ((psheToSearch = psheToSearch->GetNext()) != NULL);

        psheLast->SetNext(psheToAdd);
    }
    else
    {
        // No entries on the list so put this one first
        _apsheHashTable[dwHash] = psheToAdd;
    }

    _ndwCount++;

    CairoleDebugOut((DEB_ROT, "%p OUT CScmHashTable::SetAt \n", this));
}


//+-------------------------------------------------------------------------
//
//  Member:     CScmHashTable::RemoveEntry
//
//  Synopsis:   Remove an entry from the list
//
//  Arguments:  [dwHash] - hash value to use
//              [psheToRemove] - hash entry to add
//
//  Returns:    TRUE - entry removed.
//              FALSE - no such entry found
//
//  Algorithm:  If bucket is not empty, if this is the first entry replace
//              it with its next. Otherwise, loop through the list searching
//              for the entry and make its previous point to the current
//              one's next.
//
//  History:    20-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
BOOL CScmHashTable::RemoveEntry(
    DWORD dwHash,
    CScmHashEntry *psheToRemove)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CScmHashTable::RemoveEntry "
        "( %lx , %p )\n", this, dwHash, psheToRemove));

    BOOL fFound = FALSE;

    // Are there any entries for this bucket?
    if (_apsheHashTable[dwHash] != NULL)
    {
        CScmHashEntry *psheToSearch = _apsheHashTable[dwHash];
        CScmHashEntry *pshePrev = NULL;

        while (psheToSearch != NULL)
        {
            if (psheToSearch == psheToRemove)
            {
                if (pshePrev == NULL)
                {
                    // First entry matches so update the head of the list
                    _apsheHashTable[dwHash] = psheToSearch->GetNext();
                }
                else
                {
                    // Found entry in the middle of the list so delete
                    // the previous item's next pointer
                    pshePrev->SetNext(psheToSearch->GetNext());
                }

                // Tell the caller we found the item
                fFound = TRUE;
                break;
            }

            pshePrev = psheToSearch;
            psheToSearch = psheToSearch->GetNext();
        }

        if (fFound)
        {
            _ndwCount--;
        }
    }

    CairoleDebugOut((DEB_ROT, "%p OUT CScmHashTable::RemoveEntry ( %lx )\n",
        this, fFound));

    return fFound;
}




//+-------------------------------------------------------------------------
//
//  Member:     CScmHashIter::FindNextBucketWithEntry
//
//  Synopsis:   Find next hash bucket that has an entry
//
//  Returns:    Entry for bucket or NULL if there are none/
//
//  Algorithm:  Beginning with the current bucket loop through the list
//              of buckets till one is not null or there are no more
//              buckets.
//
//  History:    20-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
CScmHashEntry *CScmHashIter::FindNextBucketWithEntry(void)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CScmHashIter::FindNextBucketWithEntry\n",
        this));

    for (; _dwBucket < _psht->_ndwHashTableSize; _dwBucket++)
    {
        if ((_psheNext =_psht->_apsheHashTable[_dwBucket]) != NULL)
        {
            break;
        }
    }

    // Point to the next bucket
    _dwBucket++;

    CairoleDebugOut((DEB_ROT, "%p OUT CScmHashIter::FindNextBucketWithEntry "
        "( %p )\n", this, _psheNext));

    return _psheNext;
}




//+-------------------------------------------------------------------------
//
//  Member:     CScmHashIter::GetNext
//
//  Synopsis:   Find next hash bucket that has an entry
//
//  Returns:    Next entry in the iteration
//
//  Algorithm:  Get the next pointer from the object and then update
//              the next pointer if there are still entries to be
//              iterated.
//
//  History:    20-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
CScmHashEntry *CScmHashIter::GetNext(void)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CScmHashIter::GetNext \n", this));

    CScmHashEntry *psheToReturn = _psheNext;

    // Search for the next entry to return
    if (_psheNext != NULL)
    {
        _psheNext = _psheNext->GetNext();

        if (_psheNext == NULL)
        {
            FindNextBucketWithEntry();
        }
    }

    CairoleDebugOut((DEB_ROT, "%p OUT CScmHashIter::GetNext "
        "( %p )\n", this, psheToReturn));

    return psheToReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\olescm\rpcalloc.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       rpcalloc.cxx
//
//  Contents:   functions for RPC memory allocation
//
//  Functions:  MIDL_user_allocate
//              MIDL_user_free
//
//  History:    24-Apr-93 Ricksa    Created
//
//--------------------------------------------------------------------------

#include "act.hxx"

//+-------------------------------------------------------------------------
//
//  Function:   MIDL_user_allocate
//
//  Synopsis:   Allocate memory for RPC
//
//  Arguments:  [cNeeded] - bytes needed
//
//  Returns:    Pointer to block allocated
//
//  History:    24-Apr-93 Ricksa    Created
//              17-Feb-94 AlexT     Use PrivMemAlloc
//
//--------------------------------------------------------------------------

extern "C" void * __RPC_API MIDL_user_allocate(size_t cb)
{
    return(PrivMemAlloc8(cb));
}

//+-------------------------------------------------------------------------
//
//  Function:   MIDL_user_free
//
//  Synopsis:   Free memory allocated by call above
//
//  Arguments:  [pv] - memory block to free
//
//  History:    24-Apr-93 Ricksa    Created
//              17-Feb-94 AlexT     Use PrivMemFree
//
//--------------------------------------------------------------------------

extern "C" void __RPC_API MIDL_user_free(void *pv)
{
    PrivMemFree(pv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\olescm\scmrot.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       scmrot.hxx
//
//  Contents:   Implementation of classes for the ROT in the SCM
//
//  Functions:  RoundTo8 - round size to 8 byte boundary
//              CalcIfdSize - calculate size needed for marhaled interface
//              SizeMnkEqBufForRotEntry - calculate size for moniker eq buffer
//              AllocateAndCopy - create copy of a marshaled interface
//              GetEntryFromScmReg - convert SCMREGKEY to ROT entry ptr
//
//  History:    20-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------

#include "act.hxx"

#if 0 // #ifdef _CHICAGO_
CStaticPortableMutex CScmRot::_mxs;           //  mutex semaphore
#endif

//+-------------------------------------------------------------------------
//
//  Function:   RoundTo8
//
//  Synopsis:   Round size to next 8 byte boundary
//
//  Arguments:  [sizeToRound] - Size to round
//
//  Returns:    Input rounded to the next 8 byte boundary
//
//  History:    20-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
inline size_t RoundTo8(size_t sizeToRound)
{
    return (sizeToRound + 7) & ~7;
}

//+-------------------------------------------------------------------------
//
//  Function:   CalcIfdSize
//
//  Synopsis:   Calculate size required by a marshaled interface
//
//  Arguments:  [pifd] - interface whose size to calculate
//
//  Returns:    size required for interface
//
//  Algorithm:  Get size from the interface and round to next 8 bytes so
//              data packed following this buffer will be nicely aligned.
//
//  History:    20-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
size_t CalcIfdSize(InterfaceData *pifd)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CalcIfdSize ( %p )\n", NULL,
        pifd));

    size_t sizeRet = RoundTo8(IFD_SIZE(pifd));

    CairoleDebugOut((DEB_ROT, "%p OUT CalcIfdSize ( %lx )\n", NULL,
        sizeRet));

    return sizeRet;
}

//+-------------------------------------------------------------------------
//
//  Function:   SizeMnkEqBufForRotEntry
//
//  Synopsis:   Calculate 8 byte aligned size for moniker equality buffer
//
//  Arguments:  [pmnkeqbuf] - Moniker equality buffer
//
//  Returns:    8 byte aligned size of moniker buffer.
//
//  Algorithm:  Calculate size for the moniker equality buffer from input
//              buffer and then round to next 8 byte boundary
//
//  History:    20-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
size_t SizeMnkEqBufForRotEntry(MNKEQBUF *pmnkeqbuf)
{
    CairoleDebugOut((DEB_ROT, "%p _IN SizeMnkEqBufForRotEntry ( %p )\n", NULL,
        pmnkeqbuf));

    size_t sizeRet = RoundTo8((sizeof(MNKEQBUF) - 1) + pmnkeqbuf->cdwSize);

    CairoleDebugOut((DEB_ROT, "%p OUT SizeMnkEqBufForRotEntry ( %lx )\n", NULL,
        sizeRet));

    return sizeRet;
}



//+-------------------------------------------------------------------------
//
//  Function:   AllocateAndCopy
//
//  Synopsis:   Make a copy of the input marshaled interface
//
//  Arguments:  [pifdIn] - input marshaled interface.
//
//  Returns:    Copy of input marshaled interface.
//
//  Algorithm:  Calculate size required for marshaled interface. Allocate
//              memory for the interface and then copy input interface into
//              the new buffer.
//
//  History:    20-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
InterfaceData *AllocateAndCopy(InterfaceData *pifdIn)
{
    CairoleDebugOut((DEB_ROT, "%p _IN AllocateAndCopy ( %p )\n", NULL, pifdIn));

    DWORD dwSizeObj = CalcIfdSize(pifdIn);

    InterfaceData *pifd = (InterfaceData *) MIDL_user_allocate(dwSizeObj);

    if (pifd)
    {
        // Copy all the data. Remember that pifdIn was allocated rounded
        // to an 8 byte boundary so we will not run off the end of the
        // memory buffer
        memcpy(pifd, pifdIn, dwSizeObj);
    }

    CairoleDebugOut((DEB_ROT, "%p OUT AllocateAndCopy ( %lx )\n", NULL, pifd));

    return pifd;
}




//+-------------------------------------------------------------------------
//
//  Function:   GetEntryFromScmReg
//
//  Synopsis:   Convert SCMREGKEY into a pointer to a ROT entry if possible
//
//  Arguments:  [psrk] - Pointer to a SCMREGKEY
//
//  Returns:    NULL - psrk not valid
//              ROT entry for the given input key
//
//  Algorithm:  Take the pointer portion of the key and make sure that
//              it points to enough memory so that we can validate the
//              signiture in the object. Then validate the signiture in
//              the object and return a pointer to the object.
//
//  History:    20-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
CScmRotEntry *GetEntryFromScmReg(SCMREGKEY *psrk)
{
    CairoleDebugOut((DEB_ROT, "%p _IN GetEntryFromScmReg ( %p )\n",
        NULL, psrk));

    CScmRotEntry *psreRet = NULL;

    CScmRotEntry *psre = (CScmRotEntry *) psrk->dwEntryLoc;

    // Make sure pointer is pointer to valid memory - it s/b read write
    // memory since we allocated it and updated it.
    if (!IsBadReadPtr(psre, sizeof(*psre))
        && !IsBadWritePtr(psre, sizeof(*psre)))
    {
        // Make sure signitures are valid
        if (psre->IsValid(psrk->dwScmId))
        {
            psreRet = psre;
        }
    }

    CairoleDebugOut((DEB_ROT, "%p OUT GetEntryFromScmReg ( %lx )\n",
        NULL, psreRet));

    return psreRet;
}


//+-------------------------------------------------------------------------
//
//  Member:     CScmRotEntry::CScmRotEntry
//
//  Synopsis:   Create a ROT entry for a registration
//
//  Arguments:  [dwScmRotId] - signiture for item
//              [pmkeqbuf] - moniker equality buffer to use
//              [pfiletime] - file time to use
//              [dwProcessID] - process id to use
//              [pifdObject] - marshaled interface for the object
//              [pifdObjectName] - marshaled moniker for the object
//
//  Algorithm:  Initialize data and calcualte offsets into the object for
//              the variable length data.
//
//  History:    20-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
CScmRotEntry::CScmRotEntry(
    DWORD dwScmRotId,
    MNKEQBUF *pmkeqbuf,
    FILETIME *pfiletime,
    DWORD dwProcessID,
#if 1 // #ifndef _CHICAGO_
    CToken *pToken,
#endif
    WCHAR *pwszWinstaDesktop,
    InterfaceData *pifdObject,
    InterfaceData *pifdObjectName)
        :   _dwSig(SCMROT_SIG),
            _dwScmRotId(dwScmRotId),
            _dwProcessID(dwProcessID),
            _filetimeLastChange(*pfiletime),
            _pifdObject((InterfaceData *) &_ab[0])
{
    CairoleDebugOut((DEB_ROT, "%p _IN CScmRotEntry::CScmRotEntry "
        "( %lx , %p , %p , %lx , %p , %p )\n", this, pmkeqbuf, pfiletime,
            dwProcessID, pifdObject, pifdObjectName));

#ifndef _CHICAGO_
    _pToken = pToken;
    if ( _pToken )
        _pToken->AddRef();
#endif

    // Copy data for object to preallocated area
    _pifdObject->ulCntData = pifdObject->ulCntData;
    memcpy(&_pifdObject->abData[0], &pifdObject->abData[0],
        _pifdObject->ulCntData);

    // Calculate the location of the equality buffer in the allocated data
    DWORD dwOffsetMnkEqBuf = CalcIfdSize(_pifdObject);
    _pmkeqbufKey = (MNKEQBUF *) &_ab[dwOffsetMnkEqBuf];

    // Copy data for moniker equality buffer into preallocated area
    _pmkeqbufKey->cdwSize = pmkeqbuf->cdwSize;
    memcpy(&_pmkeqbufKey->abEqData[0], &pmkeqbuf->abEqData[0],
        _pmkeqbufKey->cdwSize);

    // Calculate the location of the moniker name buffer
    _pifdObjectName = (InterfaceData *)
        &_ab[dwOffsetMnkEqBuf + SizeMnkEqBufForRotEntry(_pmkeqbufKey)];

    // Copy in the data for the moniker name
    _pifdObjectName->ulCntData = pifdObjectName->ulCntData;
    memcpy(&_pifdObjectName->abData[0], &pifdObjectName->abData[0],
        _pifdObjectName->ulCntData);

    if ( pwszWinstaDesktop )
    {
        _pwszWinstaDesktop = (WCHAR *)
            &_ab[dwOffsetMnkEqBuf + SizeMnkEqBufForRotEntry(_pmkeqbufKey) + CalcIfdSize(_pifdObjectName)];
        lstrcpyW( _pwszWinstaDesktop, pwszWinstaDesktop );
    }
    else
    {
        _pwszWinstaDesktop = NULL;
    }

    CairoleDebugOut((DEB_ROT, "%p OUT CScmRotEntry::CScmRotEntry \n",
        this));
}

//+-------------------------------------------------------------------------
//
//  Member:     CScmRotEntry::IsEqual
//
//  Synopsis:   Determine if input key is equal to the ROT entry's key
//
//  Arguments:  [pKey] - Key to use for the test
//              [cbKey] - Count of bytes in key
//
//  Returns:    TRUE - input key equals this object's key
//              FALSE - keys are not equal
//
//  Algorithm:  If the two sizes are equal then compare the actual data
//              buffers and return the result of that compare.
//
//  History:    20-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
BOOL CScmRotEntry::IsEqual(LPVOID pKey, UINT cbKey)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CScmRotEntry::IsEqual "
        "( %p , %lx )\n", this, pKey, cbKey));

    BOOL fRet = FALSE;

    if (cbKey == _pmkeqbufKey->cdwSize)
    {
        fRet = memcmp(pKey, &_pmkeqbufKey->abEqData[0], cbKey) == 0;
    }

    CairoleDebugOut((DEB_ROT, "%p OUT CScmRotEntry::IsEqual ( %lx )\n",
        this, fRet));

    return fRet;
}


//+-------------------------------------------------------------------------
//
//  Member:     CScmRot::Register
//
//  Synopsis:   Add entry to the ROT
//
//  Arguments:  [pmkeqbuf] - moniker equality buffer to use
//              [pfiletime] - file time to use
//              [dwProcessID] - process id to use
//              [pifdObject] - marshaled interface for the object
//              [pifdObjectName] - marshaled moniker for the object
//
//  Returns:    NOERROR - successfully registered
//              E_OUTOFMEMORY
//
//  Algorithm:  Lock the ROT from all other threads. The create a new
//              entry and determine if there is an eqivalent entry in
//              the ROT. Calculate the hash value and then put the
//              entry into our hash table. Finally, build a registration
//              key to return to the caller.
//
//  History:    20-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT CScmRot::Register(
#if 1 // #ifndef _CHICAGO_
    CProcess *pProcess,
#endif
    WCHAR *pwszWinstaDesktop,
    MNKEQBUF *pmnkeqbuf,
    InterfaceData *pifdObject,
    InterfaceData *pifdObjectName,
    FILETIME *pfiletime,
    DWORD dwProcessID,
    WCHAR *pwszServerExe,
    SCMREGKEY *psrkRegister)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CScmRot::Register "
        "( %p , %p , %p , %p , %lx , %p )\n", this, pmnkeqbuf, pifdObject,
            pifdObjectName, pfiletime, dwProcessID, psrkRegister));

    // Assume that there is a memory problem
    HRESULT hr = E_OUTOFMEMORY;

    CToken * pToken;

    pToken = pProcess->GetToken();

    if ( pwszServerExe )
    {
        HKEY    hKey;
        LONG    RegStatus;
        WCHAR   wszAppid[40];
        DWORD   Size;

        RegStatus = ERROR_SUCCESS;

        // The pwszServerExe string may contain an AppId string or
        // a module name. If it looks like a GUID string, we can bypass
        // the AppId lookup. Otherwise, we go to the Registry to
        if ( pwszServerExe[0] == L'{' )
        {
            // Use the given string as the AppId

            lstrcpyn(wszAppid, pwszServerExe, sizeof(wszAppid)/sizeof(WCHAR));
        }
        else
        {
            // Try to map the Exe name to an AppId

            if ( ! ghAppidMachine )
                RegStatus = OpenClassesRootKeys();

            if ( ERROR_SUCCESS == RegStatus )
            {
                RegStatus = RegOpenKeyEx( ghAppidMachine,
                                          pwszServerExe,
                                          NULL,
                                          KEY_READ,
                                          &hKey );
            }

            if ( ERROR_SUCCESS == RegStatus )
            {
                Size = sizeof(wszAppid);
                RegStatus = RegQueryValueEx( hKey,
                                             L"AppId",
                                             NULL,
                                             NULL,
                                             (BYTE *)wszAppid,
                                             &Size );

                RegCloseKey( hKey );
            }

            if ( RegStatus != ERROR_SUCCESS )
                return CO_E_WRONG_SERVER_IDENTITY;
        }

        CAppidData  Appid( wszAppid, pToken );
        BOOL        Access;

        Access = FALSE;

        // Load appid info from the matching side of the registry
        DWORD dwAppidFlags = 0;

#if defined(_WIN64)
        dwAppidFlags = pProcess->Is64Bit() ? CAT_REG64_ONLY : CAT_REG32_ONLY;
#endif

        hr = Appid.Load(dwAppidFlags);
        if ( S_OK == hr )
            Access = Appid.CertifyServer( pProcess );

        if ( ! Access )
            return CO_E_WRONG_SERVER_IDENTITY;

        //
        // NULL these to indicate that any client can connect to this
        // registration.
        //
        pwszWinstaDesktop = NULL;
        pToken = NULL;
    }

    // Lock for the duration of the call
    CPortableLock lck(_mxs);

    // Bump the id
    _dwIdCntr++;

    // Build a record to put into the table
    CScmRotEntry *psreNew = new(
        pwszWinstaDesktop ? (lstrlenW(pwszWinstaDesktop)+1)*sizeof(WCHAR) : 0,
        CalcIfdSize(pifdObject),
        SizeMnkEqBufForRotEntry(pmnkeqbuf),
        CalcIfdSize(pifdObjectName))
            CScmRotEntry(_dwIdCntr, pmnkeqbuf, pfiletime, dwProcessID,
#ifndef _CHICAGO_
                pToken,
#else
                NULL,
#endif
                pwszWinstaDesktop, pifdObject, pifdObjectName);

    if (psreNew != NULL)
    {
        DWORD           dwHash;
        CScmRotEntry *  psreRunning;

#ifndef _CHICAGO_
        psreRunning = GetRotEntry( pToken, pwszWinstaDesktop, pmnkeqbuf );
#else
        psreRunning = GetRotEntry( NULL, pwszWinstaDesktop, pmnkeqbuf );
#endif

        dwHash = ScmRotHash(&pmnkeqbuf->abEqData[0], pmnkeqbuf->cdwSize, 0);

        // Put record into the hash table
        _sht.SetAt(dwHash, psreNew);

#if 1 // #ifndef _CHICAGO_

        // Update the hint table
        _rht.SetIndicator(dwHash);

#endif // !_CHICAGO_

        // Build return value
        psreNew->SetScmRegKey(psrkRegister);

        // Map return result based on prior existence of the object.
        hr = (psreRunning == NULL)
            ? NOERROR : MK_S_MONIKERALREADYREGISTERED;
    }

    CairoleDebugOut((DEB_ROT, "%p OUT CScmRot::Register "
        " ( %lx )\n", this, hr));

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CScmRot::Revoke
//
//  Synopsis:   Remove entry from the ROT
//
//  Arguments:  [psrkRegister] - registration to revoke
//              [fServer] - whether this is the object server
//              [ppifdObject] - output marshaled interface (optional)
//              [ppifdName] - output marshaled moniker (optional)
//
//  Returns:    NOERROR - successfully removed.
//              E_INVALIDARG
//
//  Algorithm:  Convert SCMREGKEY to anentry in the ROT. Remove the
//              entry from the hash table. If this is the object server
//              for the entry, then return the marshaled interfaces
//              so the object server can release them.
//
//  History:    20-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT CScmRot::Revoke(
    SCMREGKEY *psrkRegister,
    BOOL fServer,
    InterfaceData **ppifdObject,
    InterfaceData **ppifdName)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CScmRot::Revoke "
        "( %p , %lx , %p , %p )\n", this, fServer, ppifdObject, ppifdName));

    HRESULT hr = E_INVALIDARG;

    // Lock for the duration of the call
    CPortableLock lck(_mxs);

    // Verify registration key
    CScmRotEntry *psreToRemove = GetEntryFromScmReg(psrkRegister);

    if (psreToRemove != NULL)
    {
        // Get the has value
        DWORD dwHash = ScmRotHash(psreToRemove->Key(), psreToRemove->cKey(), 0);

        // Remove object from the list
        _sht.RemoveEntry(dwHash, psreToRemove);

        // Is this a server doing a revoke?
        if (fServer)
        {
            // Error handling here - suppose these allocations fail, what
            // can we do? The bottom line is nothing. This will cause a
            // memory leak in the server because they can't release the
            // marshaled data. However, this is assumed to be a rare
            // occurance and will really only cause the moniker to live
            // longer than it ought to which should not be too serious.
            *ppifdObject = AllocateAndCopy(psreToRemove->GetObject());
            *ppifdName = AllocateAndCopy(psreToRemove->GetMoniker());
        }

        // Free the entry
        delete psreToRemove;

#if 1 // #ifndef _CHICAGO_

        // See if bucket is empty
        if (_sht.IsBucketEmpty(dwHash))
        {
            // Update the hint table.
            _rht.ClearIndicator(dwHash);
        }

#endif // !_CHICAGO_

        hr = S_OK;
    }

    CairoleDebugOut((DEB_ROT, "%p OUT CScmRot::Revoke "
        " ( %lx ) [ %p, %p ] \n", this, hr,
            (ppifdObject != NULL) ? *ppifdObject : NULL,
            (ppifdName != NULL) ? *ppifdName : NULL));

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CScmRot::IsRunning
//
//  Synopsis:   Determine if there is a registered entry for an item
//
//  Arguments:  [pmnkeqbuf] - Moniker equality buffer to search for
//
//  Returns:    NOERROR - moniker is registered as running
//              S_FALSE - moniker is not running.
//
//  Algorithm:  Get the entry for the moniker equality buffer if there is
//              one. If there is one, then return NOERROR otherwise return
//              S_FALSE.
//
//  History:    20-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT CScmRot::IsRunning(
#if 1 // #ifndef _CHICAGO_
    CToken *pToken,
#endif
    WCHAR *pwszWinstaDesktop,
    MNKEQBUF *pmnkeqbuf)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CScmRot::IsRunning "
        "( %p )\n", this, pmnkeqbuf));

    // Lock for the duration of the call
    CPortableLock lck(_mxs);

#if 1 // #ifndef _CHICAGO_
    CScmRotEntry *psreRunning = GetRotEntry( pToken, pwszWinstaDesktop, pmnkeqbuf );
#else
    CScmRotEntry *psreRunning = GetRotEntry(pwszWinstaDesktop, pmnkeqbuf);
#endif

    HRESULT hr = (psreRunning != NULL) ? S_OK : S_FALSE;

    CairoleDebugOut((DEB_ROT, "%p OUT CScmRot::IsRunning "
        " ( %lx ) \n", this, hr));

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CScmRot::GetObject
//
//  Synopsis:   Get running object for input
//
//  Arguments:  [dwProcessID] - process id of object (optional)
//              [pmnkeqbuf] - moniker equality buffer
//              [psrkRegister] - output registration id.
//              [ppifdObject] - marshaled interface for registration
//
//  Returns:    NOERROR - got object
//              MK_E_UNAVAILABLE - registration could not be found
//
//  Algorithm:  If not process ID is input, then search for the first
//              matching entry that we can find. Otherwise, search the
//              hash for the entry with both the same key and the same
//              process id.
//
//  History:    20-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT CScmRot::GetObject(
#if 1 // #ifndef _CHICAGO_
    CToken *pToken,
#endif
    WCHAR *pwszWinstaDesktop,
    DWORD dwProcessID,
    MNKEQBUF *pmnkeqbuf,
    SCMREGKEY *psrkRegister,
    InterfaceData **ppifdObject)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CScmRot::GetObject "
        "( %lx , %p , %p , %p )\n", this, dwProcessID, pmnkeqbuf, psrkRegister,
            ppifdObject));

    HRESULT hr = MK_E_UNAVAILABLE;

    // Lock for the duration of the call
    CPortableLock lck(_mxs);

    CScmRotEntry *psreRunning;

    if (dwProcessID == 0)
    {
        psreRunning = GetRotEntry( pToken, pwszWinstaDesktop, pmnkeqbuf );
    }
    else
    {
        // Special search based on process ID - get the head of the list
        // for the bucket
        psreRunning = (CScmRotEntry *) _sht.GetBucketList(
            ScmRotHash(&pmnkeqbuf->abEqData[0], pmnkeqbuf->cdwSize, 0));

        // Search list for a matching entry
        while (psreRunning != NULL)
        {
            if ((psreRunning->GetProcessID() == dwProcessID)
                && psreRunning->IsEqual(&pmnkeqbuf->abEqData[0],
                    pmnkeqbuf->cdwSize))
            {
                // We found a match so we are done.
                break;
            }

            // Try the next item in the bucket.
            psreRunning = (CScmRotEntry *) psreRunning->GetNext();
        }
    }
	
    if (psreRunning != NULL)
    {
        hr = E_OUTOFMEMORY;

        *ppifdObject = AllocateAndCopy(psreRunning->GetObject());

        if (*ppifdObject != NULL)
        {
            hr = NOERROR;
        }

        // Build return registration key
        psreRunning->SetScmRegKey(psrkRegister);
    }

    CairoleDebugOut((DEB_ROT, "%p OUT CScmRot::GetObject "
        " ( %lx ) [ %p ] \n", this, hr, *ppifdObject));

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CScmRot::NoteChangeTime
//
//  Synopsis:   Set the time of last change for a ROT entry
//
//  Arguments:  [psrkRegister] - ID of entry to change
//              [pfiletime] - new time for the entry.
//
//  Returns:    NOERROR - time set
//              E_INVALIDARG - ROT entry could not be found
//
//  Algorithm:  Convert SCMREGKEY into a pointer to a ROT entry and then
//              update the time of that entry.
//
//  History:    20-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT CScmRot::NoteChangeTime(
    SCMREGKEY *psrkRegister,
    FILETIME *pfiletime)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CScmRot::NoteChangeTime "
        "( %p , %p )\n", this, psrkRegister, pfiletime));

    HRESULT hr = E_INVALIDARG;

    // Lock for the duration of the call
    CPortableLock lck(_mxs);

    CScmRotEntry *psre = GetEntryFromScmReg(psrkRegister);

    if (psre != NULL)
    {
        psre->SetTime(pfiletime);
        hr = S_OK;
    }

    CairoleDebugOut((DEB_ROT, "%p OUT CScmRot::NoteChangeTime "
        " ( %lx ) \n", this, hr));

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CScmRot::GetTimeOfLastChange
//
//  Synopsis:   Get time of last change for a moniker in the ROT
//
//  Arguments:  [pmnkeqbuf] - Moniker equality buffer
//              [pfiletime] - Where to put the time
//
//  Returns:    NOERROR - got the time
//              MK_E_UNAVAILABLE - couldn't find an entry/
//
//  Algorithm:  Search the hash for an entry with the same moniker. If
//              found, then copy out the time.
//
//  History:    20-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT CScmRot::GetTimeOfLastChange(
#if 1 // #ifndef _CHICAGO_
    CToken *pToken,
#endif
    WCHAR *pwszWinstaDesktop,
    MNKEQBUF *pmnkeqbuf,
    FILETIME *pfiletime)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CScmRot::GetTimeOfLastChange "
        "( %p , %p )\n", this, pmnkeqbuf, pfiletime));

    HRESULT hr = MK_E_UNAVAILABLE;

    // Lock for the duration of the call
    CPortableLock lck(_mxs);

#if 1 // #ifndef _CHICAGO_
    CScmRotEntry *psreRunning = GetRotEntry( pToken, pwszWinstaDesktop, pmnkeqbuf );
#else
    CScmRotEntry *psreRunning = GetRotEntry(pwszWinstaDesktop, pmnkeqbuf);
#endif

    if (psreRunning != NULL)
    {
        psreRunning->GetTime(pfiletime);
        hr = S_OK;
    }

    CairoleDebugOut((DEB_ROT, "%p OUT CScmRot::GetTimeOfLastChange "
        " ( %lx ) \n", this, hr));

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CScmRot::EnumRunning
//
//  Synopsis:   Get a list of all the monikers that are currently running
//
//  Arguments:  [ppMkIFList] - Where to put list of monikers running
//
//  Returns:    NOERROR - got list
//              E_OUTOFMEMORY - couldn't allocate space for the list
//
//  Algorithm:  Loop through the ROT copying out the marshaled moniker buffers
//
//  History:    20-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT CScmRot::EnumRunning(
#if 1 // #ifndef _CHICAGO_
    CToken *pToken,
#endif
    WCHAR *pwszWinstaDesktop,
    MkInterfaceList **ppMkIFList)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CScmRot::EnumRunning "
        "( %p )\n", this, ppMkIFList));

    HRESULT hr = E_OUTOFMEMORY;

    // Lock for the duration of the call
    CPortableLock lck(_mxs);

    *ppMkIFList = NULL;

    MkInterfaceList *pMkIFList = NULL;

    // This is the upper limit on how much space we'll need.
    DWORD dwSize = sizeof(MkInterfaceList) +
                   (_sht.GetCount() - 1) * sizeof(InterfaceData *);

    // Allocate buffer
    pMkIFList = (MkInterfaceList *) MIDL_user_allocate(dwSize);

    // We use this to keep track fof the number of monikers we are returning
    DWORD dwOffset = 0;

    if (pMkIFList != NULL)
    {
        // Iterate list getting the pointers
        CScmHashIter shi(&_sht);
        CScmRotEntry *psre;

        while ((psre = (CScmRotEntry *) shi.GetNext()) != NULL)
        {
            InterfaceData *pifdForOutput;

            if ( psre->WinstaDesktop() &&
                 (lstrcmpW( pwszWinstaDesktop, psre->WinstaDesktop() ) != 0) )
                continue;

#ifndef _CHICAGO_
            if ( S_OK != pToken->MatchToken2(psre->Token(), FALSE) )
                continue;

            if ( gbSAFERROTChecksEnabled )
            {
                HRESULT hr = pToken->CompareSaferLevels(psre->Token());
                // S_FALSE: pToken is of lesser authorization, i.e., this
                //          is untrusted code calling into trusted code.
                if (hr == S_FALSE)
                {
                    DbgPrint("RPCSS: SCMROT: SAFER level did not match.\n");

                    continue;
                }
            }
#endif

            pifdForOutput = AllocateAndCopy(psre->GetMoniker());

            if (pifdForOutput == NULL)
            {
                goto Exit;
            }

            // Put copy in the array
            pMkIFList->apIFDList[dwOffset] = pifdForOutput;

            // We bump the count because it makes clean up easier
            dwOffset++;
        }

        // Teller caller and cleanup that everything went ok.
        hr = S_OK;

        // Set the output buffer to the buffer we have allocated.
        *ppMkIFList = pMkIFList;

        // Set the size of the object to return
        pMkIFList->dwSize = dwOffset;
    }

Exit:

    if (FAILED(hr))
    {
        // We failed so clean up
        if (pMkIFList != NULL)
        {
            // Clean up the moniker interfaces that were allocated
            for (DWORD i = 0; i < dwOffset; i++)
            {
                MIDL_user_free(pMkIFList->apIFDList[i]);
            }

            // Clean up the table structure itself
            MIDL_user_free(pMkIFList);
        }
    }

    CairoleDebugOut((DEB_ROT, "%p OUT CScmRot::EnumRunning "
        " ( %lx ) [ %p ]\n", this, hr, *ppMkIFList));

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Member:     CScmRot::GetRotEntry
//
//  Synopsis:   Search ROT for entry that matches the equality buffer input.
//
//  Arguments:  [pmnkeqbuf] - Moniker equality buffer to search for.
//
//  Returns:    NULL - no entry could be found
//              Pointer to ROT entry with matching key
//
//  Algorithm:  Calculate the hash value for the input buffer. The search
//              the hash table for the matching value.
//
//  History:    20-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
CScmRotEntry *CScmRot::GetRotEntry(
#if 1 // #ifndef _CHICAGO_
    CToken *pToken,
#endif
    WCHAR *pwszWinstaDesktop,
    MNKEQBUF *pmnkeqbuf)
{
    CairoleDebugOut((DEB_ROT, "%p _IN CScmRot::GetRotEntry "
        "( %p )\n", this, pmnkeqbuf));

    DWORD           dwHash;
    CScmRotEntry *  psre;

    dwHash = ScmRotHash(&pmnkeqbuf->abEqData[0], pmnkeqbuf->cdwSize, 0);
    psre = (CScmRotEntry *) _sht.GetBucketList( dwHash );

    for ( ; psre != NULL; psre = (CScmRotEntry *) psre->GetNext() )
    {
        if ( psre->IsEqual(&pmnkeqbuf->abEqData[0], pmnkeqbuf->cdwSize) )
        {
            //
            // Note that this routine is actually called during a Register
            // to see if there is a duplicate moniker and also during a
            // client Lookup.  This makes things a little complicated.
            //
            // The winsta\desktop param can only be null in two instances.
            // + While doing a Register from a service or RunAs server.  The
            //   pToken will also be null.
            // + While doing a ROT lookup during a secure remote activation.
            //   The pToken will be non-null.  We only check that the SIDs
            //   match in this case.
            //
            // During an usecure activation the pToken will be NULL.  The
            // winsta/desktop will actually be "" in this case (see
            // Activation) to allow us to distinguish just this case.
            //
            // The ROT entry's winsta\desktop can be null if a service or RunAs
            // server registered a globally available object.
            //

            // Existing registration is globally available.
            if ( ! psre->WinstaDesktop() )
                break;

            //
            // NULL token and winsta/desktop means a server is doing a register
            // for a globally available object, return the match.
            // NULL token but non-null ("") winsta/desktop is a lookup from a
            // remote unsecure client, no match.
            //
            if ( ! pToken )
            {
                if ( ! pwszWinstaDesktop )
                    break;
                else
                    continue;
            }

            Win4Assert( psre->Token() );

            if ( pwszWinstaDesktop &&
                 (lstrcmpW( pwszWinstaDesktop, psre->WinstaDesktop() ) != 0) )
                continue;

            // Check to make sure the token matches
            if(S_OK != pToken->MatchToken2(psre->Token(), FALSE))
                continue;

            // Check to make sure that the safer token matches
            if ( gbSAFERROTChecksEnabled )
            {
                HRESULT hr = pToken->CompareSaferLevels(psre->Token());
                // S_FALSE: pToken is of lesser authorization, i.e., this
                //          is untrusted code calling into trusted code.
                if (hr == S_FALSE)
                {
                    DbgPrint("RPCSS: SCMROT: SAFER level did not match.\n");

                    continue;
                }
            }

            break;
        }
    }

    CairoleDebugOut((DEB_ROT, "%p OUT CScmRot::GetRotEntry "
        " ( %p )\n", this, psre));

    return psre;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\olescm\scminfo.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999.
//
//  File:       scminfo.cxx
//
//  Contents:   Definitions/objects for use by scm-level activators
//
//  History:    05-Sep-99  JSimmons    Created
//
//--------------------------------------------------------------------------

#include "act.hxx"
#include "scminfo.hxx"
#include "initguid.h"

// Macros to index into special members of the SCMProcessInfo struct
#define SPI_TO_SIZE(pSPI)     (ULONG*)(((BYTE*)pSPI) + sizeof(SCMProcessInfo))
#define SPI_TO_REFCOUNT(pSPI) (LONG*)(((BYTE*)pSPI) + sizeof(SCMProcessInfo) + sizeof(ULONG))
#define SPI_TO_CPROCESS(pSPI) (CProcess**)(((BYTE*)pSPI) + sizeof(SCMProcessInfo) + sizeof(ULONG) + sizeof(ULONG))
#define SPI_TO_WINSTA(pSPI)   (WCHAR*)(((BYTE*)pSPI) + sizeof(SCMProcessInfo) + sizeof(ULONG) + sizeof(ULONG) + sizeof(CProcess*))

// Rounding constant for ptr sizes
#if defined(_X86_) && !defined(_CHICAGO_)
	#define MEM_ALIGN_SIZE   4
#else 
#ifdef _WIN64
	#define MEM_ALIGN_SIZE   16
#else
	#define MEM_ALIGN_SIZE   8		
#endif
#endif

//+-------------------------------------------------------------------------
//
//  Implementation of CSCMProcessControl begins here
//
//--------------------------------------------------------------------------

// Constructor
CSCMProcessControl::CSCMProcessControl() :
  _lRefs(0),
  _bInitializedEnum(FALSE)
{
}

// Destructor
CSCMProcessControl::~CSCMProcessControl()
{
	ASSERT(_lRefs == 0);
}

//+-------------------------------------------------------------------------
//
//  Function:   FindApplication
//
//  Synopsis:   Creates an enumerator for enumerating over all running com+
//              processes that have registered for the specified application.
//
//  Arguments:  rappid -- the appid they want to know about
//              ppESPI -- out param to store the resulting IEnumSCMProcessInfo
//
//  Returns:    S_OK - life is good;  *ppESPI will be non-NULL if at least 
//                one suitable server was found
//              E_INVALIDARG -- one or more parameters was incorrect  
//              E_OUTOFMEMORY 
//
//--------------------------------------------------------------------------
STDMETHODIMP CSCMProcessControl::FindApplication(REFGUID rappid, IEnumSCMProcessInfo** ppESPI)
{
	return FindAppOrClass(rappid, gpProcessTable, ppESPI);
}

//+-------------------------------------------------------------------------
//
//  Function:   FindClass
//
//  Synopsis:   Creates an enumerator for enumerating over all running 
//              processes that have registered a class factory for the 
//              specified clsid.
//
//  Arguments:  rclsid -- the clsid they want to know about
//              ppESPI -- out param to store the resulting IEnumSCMProcessInfo
//
//  Returns:    S_OK - life is good;  *ppESPI will be non-NULL if at least 
//                one suitable server was found
//              E_INVALIDARG -- one or more parameters was incorrect  
//              E_OUTOFMEMORY 
//
//--------------------------------------------------------------------------
STDMETHODIMP CSCMProcessControl::FindClass(REFCLSID rclsid, IEnumSCMProcessInfo **ppESPI)
{ 
	return FindAppOrClass((GUID&)rclsid, gpClassTable, ppESPI);
}

//+-------------------------------------------------------------------------
//
//  Function:   FindProcess
//
//  Synopsis:   Tries to find the specified process (by pid) in the the process
//              list;  if found, then calls FillInSCMProcessInfo.
//
//  Arguments:  pid -- process id of the process they're interested in
//              ppSPI -- out param to store a ptr to new SCMProcessInfo struct
//
//  Returns:    S_OK - life is good; *ppSPI will be non-NULL if the process was found
//              E_INVALIDARG -- didn't find that pid
//              E_OUTOFMEMORY
//
//--------------------------------------------------------------------------
STDMETHODIMP CSCMProcessControl::FindProcess(DWORD pid, SCMProcessInfo** ppSPI)
{
	HRESULT hr = S_OK;
	
	if (!ppSPI)
		return E_INVALIDARG;
	
	*ppSPI = NULL;
	
	//if (pid == gRPCSSPid)  // we don't talk about ourselves?
	//return E_INVALIDARG;
	
	gpProcessListLock->LockShared();
	
	// look through list of processes
	CBListIterator all_procs(gpProcessList);  
	CProcess* pprocess;
	while (pprocess = (CProcess*)all_procs.Next())
	{
		if (pprocess->GetPID() == pid)
		{
			// found it      
			pprocess->ClientReference();
			break;
		}
	}
	
	gpProcessListLock->UnlockShared();
	
	if (pprocess)
	{  
		// REVIEW:  we assume blindly here that the process in question has
		// finished all registration activities.   However, it is possible I 
		// guess for an activator to query about a process before it had 
		// finished registration.   This would not be a very smart activator.
		hr = FillInSCMProcessInfo(pprocess, TRUE, ppSPI);
		ReleaseProcess(pprocess);
	}
	
	return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   SuspendApplication
//
//  Synopsis:   Marks as suspended all applications that match the specified
//              appid.   No other applications of this type will be started
//              by RPCSS.   If any applications of this type are started
//              manually, they also will be marked as suspended.
//
//  Arguments:  rappid -- appid to suspend
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
STDMETHODIMP CSCMProcessControl::SuspendApplication(REFGUID rappid)
{
	CServerTableEntry *pProcessEntry;
	
	pProcessEntry = gpProcessTable->Lookup( (GUID&)rappid );
	
	if (pProcessEntry)
	{
		pProcessEntry->SuspendApplication();
		pProcessEntry->Release();
	}
	
	return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   SuspendClass
//
//  Synopsis:   Marks as suspended all class factories that have been
//              registered for the specified clsid.   If any new class 
//              factory registrations are encountered after the suspend has
//              been issued, the new registrations will also be suspended.  
//              No new servers will be launched by RPCSS on behalf of this
//              clsid.
//
//  Arguments:  rclsid -- clsid to suspend
//
//  Returns:    S_OK
//              E_INVALIDARG
//
//--------------------------------------------------------------------------
STDMETHODIMP CSCMProcessControl::SuspendClass(REFCLSID rclsid)
{
	CServerTableEntry *pClassEntry;
	
	pClassEntry = gpClassTable->Lookup( (GUID&)rclsid );
	
	if (pClassEntry)
	{
		pClassEntry->SuspendClass();
		pClassEntry->Release();
	}
	
	return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Function:   SuspendProcess
//
//  Synopsis:   Tries to find the specified process (by pid) in the the process
//              list;  if found, then marks that process as suspended (unavailable
//              for further activations).
//
//  Arguments:  pid -- process id of the process callers wants to suspend
//
//  Returns:    S_OK - process was suspended
//              E_INVALIDARG -- didn't find that pid
//
//--------------------------------------------------------------------------
STDMETHODIMP CSCMProcessControl::SuspendProcess(DWORD pid)
{
	HRESULT hr = E_INVALIDARG;
	
	//if (pid == gRPCSSPid)  // we don't talk about ourselves?
    //return E_INVALIDARG;
	
	gpProcessListLock->LockShared();
	
	// look through list of processes
	CBListIterator all_procs(gpProcessList);  
	CProcess* pprocess;
	while (pprocess = (CProcess*)all_procs.Next())
	{
		if (pprocess->GetPID() == pid)
		{
			// found it
			pprocess->Suspend();
			hr = S_OK;
			break;
		}
	}
	
	gpProcessListLock->UnlockShared();
	
	return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   ResumeApplication
//
//  Synopsis:   Marks as available for activations all applications previously
//              suspended.
//
//  Arguments:  rappid -- application id the caller wants to un-suspend
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
STDMETHODIMP CSCMProcessControl::ResumeApplication(REFGUID rappid)
{
	CServerTableEntry *pProcessEntry;
	
	pProcessEntry = gpProcessTable->Lookup( (GUID&)rappid );
	
	if (pProcessEntry)
	{
		pProcessEntry->UnsuspendApplication();
		pProcessEntry->Release();
	}
	
	return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   ResumeClass
//
//  Synopsis:   Marks all servers supporting the specified clsid as available
//              for activation.
//
//  Arguments:  rclsid -- clsid of the object the caller wants to un-suspend
//
//  Returns:    S_OK
//
//--------------------------------------------------------------------------
STDMETHODIMP CSCMProcessControl::ResumeClass(REFCLSID rclsid)
{
	CServerTableEntry *pClassEntry;
	
	pClassEntry = gpClassTable->Lookup( (GUID&)rclsid );
	
	if (pClassEntry)
	{
		pClassEntry->UnsuspendClass();
		pClassEntry->Release();
	}
	
	return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   ResumeProcess
//
//  Synopsis:   Tries to find the specified process (by pid) in the the process
//              list;  if found, then marks that process as unsuspended (ie, 
//              available for further activations).
//
//  Arguments:  pid -- process id of the process callers wants to suspend
//
//  Returns:    S_OK - process was suspended
//              E_INVALIDARG -- didn't find that pid
//
//--------------------------------------------------------------------------
STDMETHODIMP CSCMProcessControl::ResumeProcess(DWORD pid)
{
	HRESULT hr = E_INVALIDARG;
	
	//if (pid == gRPCSSPid)  // we don't talk about ourselves?
    //return E_INVALIDARG;
	
	gpProcessListLock->LockShared();
	
	// look through list of processes
	CBListIterator all_procs(gpProcessList);  
	CProcess* pprocess;
	while (pprocess = (CProcess*)all_procs.Next())
	{
		if (pprocess->GetPID() == pid)
		{
			// found it
			pprocess->ClientReference();
			break;
		}
	}
	
	gpProcessListLock->UnlockShared();
	
	if (pprocess)
	{
		pprocess->Unsuspend();
		ReleaseProcess(pprocess);
		hr = S_OK;
	}
	
	return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   RetireApplication
//
//  Synopsis:   Marks as "retired" all currently running applications with 
//              the specified appid.
//
//  Arguments:  appid -- appid to retire
//
//  Returns:    S_OK - all running applications that matched the appid were
//                retired            
//              E_INVALIDARG
//
//--------------------------------------------------------------------------
STDMETHODIMP CSCMProcessControl::RetireApplication(REFGUID rappid)
{
	CServerTableEntry *pProcessEntry;
	
	pProcessEntry = gpProcessTable->Lookup( (GUID&)rappid );
	
	if (pProcessEntry)
	{
		pProcessEntry->RetireApplication();
		pProcessEntry->Release();
	}
	
	return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   RetireClass
//
//  Synopsis:   Marks as "retired" all currently running processes which 
//              have registered a class factory for the specified clsid.
//
//  Arguments:  rclsid -- clsid to retire
//
//  Returns:    S_OK
//              E_INVALIDARG
//
//--------------------------------------------------------------------------
STDMETHODIMP CSCMProcessControl::RetireClass(REFCLSID rclsid)
{
	CServerTableEntry *pClassEntry;
	
	pClassEntry = gpClassTable->Lookup( (GUID&)rclsid );
	
	if (pClassEntry)
	{
		pClassEntry->RetireClass();
		pClassEntry->Release();
	}
	
	return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   RetireProcess
//
//  Synopsis:   Tries to find the specified process (by pid) in the the process
//              list;  if found, then marks that process as retired (ie, 
//              unavailable for further activations until the end of time).
//
//  Arguments:  pid -- process id of the process callers wants to retire
//
//  Returns:    S_OK - process was suspended
//              E_INVALIDARG -- didn't find that pid
//
//--------------------------------------------------------------------------
STDMETHODIMP CSCMProcessControl::RetireProcess(DWORD pid)
{
	HRESULT hr = E_INVALIDARG;
	
	//if (pid == gRPCSSPid)  // we don't talk about ourselves
    //return E_INVALIDARG;
	
	gpProcessListLock->LockShared();
	
	// look through list of processes
	CBListIterator all_procs(gpProcessList);  
	CProcess* pprocess;
	while (pprocess = (CProcess*)all_procs.Next())
	{
		if (pprocess->GetPID() == pid)
		{
			// found it
			pprocess->Retire();
			hr = S_OK;
			break;
		}
	}
	
	gpProcessListLock->UnlockShared();
	
	return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   FreeSCMProcessInfo
//
//  Synopsis:   Method that knows how to free a SCMProcessInfo structure, 
//              including of course its constituent members.
//
//  Arguments:  ppSPI -- ptr-ptr to the SCMProcessInfo struct
//
//  Returns:    S_OK - life is good
//              E_INVALIDARG -- bad parameter
//
//--------------------------------------------------------------------------
STDMETHODIMP CSCMProcessControl::FreeSCMProcessInfo(SCMProcessInfo** ppSPI)
{
	return CSCMProcessControl::FreeSCMProcessInfoPriv(ppSPI);
}

//+-------------------------------------------------------------------------
//
//  Private CSCMProcessControl methods below here
//
//--------------------------------------------------------------------------


//+-------------------------------------------------------------------------
//
//  Function:   FillInSCMProcessInfo 
//
//  Synopsis:   Allocates and fills in a SCMProcessInfo structure for the 
//              given CProcess object.
//
//  Arguments:  pprocess -- ptr to the CProcess object
//              bProcessReady -- whether the process in question is ready to 
//                receive activations
//              ppSPI -- out param to store a ptr to new SCMProcessInfo struct
//
//  Returns:    S_OK - life is good
//              E_OUTOFMEMORY
//
//  Notes:      assumes that at least a read lock is held by the caller for
//              the duration of the call.
//
//    The SCMProcessInfo memory is layed out as follows:
//
//      <SCMProcessInfo>
//      <size of entire allocation>
//      <ref count on this struct>
//      <CProcess*>
//      <winsta string if any>
//      <array of clsids if any>
//
//    (note that the size and refcount combined make 8 bytes, thus maintaining ptr alignment on Win64)
//    (the winsta string is also padded out to a multiple of the platform ptr size)
//
//    The pointer members of the SCMProcessInfo struct point beyond the 
//    SCMProcessInfo struct proper to the appropriate data.   The saved CProcess*
//    object has an added refcount.    The # of users using the struct is counted
//    by the ref count field.    We don't free the struct until this falls to zero
//    (done in FreeSCMProcessInfoPriv below).     Use the macros in scminfo.hxx to
//    access these undoc'd members.
//
//    If you modify this layout watch out for Win64 alignment issues.
//
HRESULT CSCMProcessControl::FillInSCMProcessInfo(CProcess* pprocess, BOOL bProcessReady, SCMProcessInfo** ppSPI)
{
	HRESULT hr = S_OK;
	ULONG ulWinstaStrlen = 0;
	SCMProcessInfo* pSPI = NULL;
	
	ASSERT(pprocess);
	ASSERT(ppSPI);
	
	*ppSPI = NULL;
	
	// Try to take fast path.  We can do this if the process in question has not added or
	// removed any class registrations.
	gpServerLock->LockShared();
	
	if (!pprocess->SPIDirty())
	{
		// great; make a copy of the struct that we previously cached in the process 
		// object; this struct won't be messed with while we're holding the read lock
		hr = CopySCMProcessInfo((SCMProcessInfo*)pprocess->GetSCMProcessInfo(), ppSPI);    
		gpServerLock->UnlockShared();
		return hr;
	}
	
	gpServerLock->UnlockShared();
	
	// Darn, the process changed its set of registrations, or this is the first time we've ever
	// done this.  Take a write lock and do it the hard way
	gpServerLock->LockExclusive();
	
	if (!pprocess->SPIDirty())
	{
		// we got beat to the lock
		hr = CopySCMProcessInfo((SCMProcessInfo*)pprocess->GetSCMProcessInfo(), ppSPI);    
		gpServerLock->UnlockExclusive();
		return hr;
	}
	
	// Find length of the winsta string
	if (pprocess->_pwszWinstaDesktop)
	{
		ulWinstaStrlen = lstrlenW(pprocess->_pwszWinstaDesktop) + sizeof(WCHAR);
		
		// Need for the string buffer to be a even multiple of the ptr size
		ulWinstaStrlen = (ulWinstaStrlen + MEM_ALIGN_SIZE - 1) & ~(MEM_ALIGN_SIZE - 1);
	}
    
	// Allocate one buffer to hold the struct, the winsta string, and the CLSIDs:
	ULONG ulBufSizeNeeded = sizeof(SCMProcessInfo) + 
		sizeof(ULONG) +
		sizeof(ULONG) +
		sizeof(CProcess*) +
		(ulWinstaStrlen * sizeof(WCHAR)) +
		(pprocess->_ulClasses * sizeof(CLSID));
	
	pSPI = (SCMProcessInfo*) new BYTE[ ulBufSizeNeeded ];
	if (!pSPI)
	{
		gpServerLock->UnlockExclusive();
		return E_OUTOFMEMORY;
	}
	
	ZeroMemory(pSPI, ulBufSizeNeeded);   
	
	// Store the allocation size.   This takes up an extra dword , but saves
	// a lot of time when we have to copy the struct
	*SPI_TO_SIZE(pSPI)= ulBufSizeNeeded;
	
	// Store a pointer to the CProcess* object itself and take a reference on it
	*SPI_TO_CPROCESS(pSPI) = pprocess;
	pprocess->Reference();
	
	// Mark the initial refcount as one.   This refcount belongs to the CProcess object
	// when we cache it below
	*SPI_TO_REFCOUNT(pSPI) = 1;
	
	CLSID* pCLSIDs;
	WCHAR* pwszWinSta;
	
	// Copy the winsta string
	if (ulWinstaStrlen > 0)
	{
		pwszWinSta = SPI_TO_WINSTA(pSPI);
		lstrcpyW(pwszWinSta, pprocess->_pwszWinstaDesktop);
		pSPI->pwszWinstaDesktop = pwszWinSta;
	}
	
	// Copy the clsids
	ULONG ulCLSID = 0;
	if (pprocess->_ulClasses > 0)
	{
		pSPI->ulNumClasses = pprocess->_ulClasses;
		pSPI->pCLSIDs = (CLSID*) (pwszWinSta + ulWinstaStrlen);
		
		CClassReg* pReg = (CClassReg*)pprocess->_listClasses.First();
		while (pReg)
		{
			pSPI->pCLSIDs[ulCLSID] = pReg->_Guid;
			pReg = (CClassReg*)pReg->Next();
			ulCLSID++;
		}
	}
	
	ASSERT(ulCLSID == pprocess->_ulClasses);
	
	pSPI->pidProcess = pprocess->GetPID();
	
	// We hold a reference on the CProcess object, which owns the process handle until
	// it goes away.  So it's safe to store the handle directly like this.
    // The handle may be NULL if we didn't launch the process, callers have the responsibility
    // of checking for this.
    pSPI->hProcess = pprocess->GetProcessHandle();
	
	// We hold a reference on the CProcess object, which holds a reference on it's CToken
	// object.  So it's safe to store the token directly like this, it won't go away.
	pSPI->hImpersonationToken = pprocess->GetToken()->GetToken();   
	
	// The process will only have a ScmProcessReg if it is a COM+ app      
	if (pprocess->_pScmProcessReg)
	{
		pSPI->dwState |= SPIF_COMPLUS;
		pSPI->AppId = pprocess->_pScmProcessReg->ProcessGUID;
		
		// flip the ready bit
		if (pprocess->_pScmProcessReg->ReadinessStatus & SERVERSTATE_READY)
		{
			pSPI->dwState |= SPIF_READY;
		}
	}
	else
	{
		// Legacy-style server.  We consider the process to be "ready" if it's
		// not in the midst of doing class registrations.  The caller tells us this.
		if (bProcessReady)
		{
			pSPI->dwState |= SPIF_READY;
		}
	}
	
	if (pprocess->IsSuspended())
		pSPI->dwState |= SPIF_SUSPENDED;
	
	if (pprocess->IsRetired())
		pSPI->dwState |= SPIF_RETIRED;
	
	if (pprocess->IsPaused())
		pSPI->dwState |= SPIF_PAUSED;
	
	pSPI->ftCreated = *(pprocess->GetFileTimeCreated());
	
	// UNDONE:  server type and identity.  Still working on the exact details of this
	
	//pSPI->ServerType = 
	//if (pSPI->ServerType != SET_SERVICE_
	//  pSPI->ServerIdent = 
	
	// Before we leave the lock, we need to replace the cached struct in the process object
	// with the new one; this also clears the dirty bit on the process  
	pprocess->SetSCMProcessInfo((void*)pSPI);
	
	// Lastly, make a new copy to return to the caller
	hr = CopySCMProcessInfo(pSPI, ppSPI);    
	
	gpServerLock->UnlockExclusive();
	
	return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   FreeSCMProcessInfoPriv
//
//  Synopsis:   Method that knows how to free a SCMProcessInfo structure, 
//              including of course its constituent members.
//
//  Arguments:  ppSCMProcessInfo -- ptr-ptr to the SCMProcessInfo struct
//
//  Returns:    S_OK - life is good
//              E_INVALIDARG -- bad parameter
//
//  Note:   refer to the header comments for FillInSCMProcessInfo for info 
//          on the extended layout of a SCMProcessInfo struct.
//  
//--------------------------------------------------------------------------
HRESULT CSCMProcessControl::FreeSCMProcessInfoPriv(SCMProcessInfo** ppSCMProcessInfo)
{
	if (!ppSCMProcessInfo)
		return E_INVALIDARG;
	
	if (*ppSCMProcessInfo)
	{
		// Decrement the struct ref count; it will not fall to zero until the CProcess*
		// object releases its reference, which will not happen unless it is either
		// a) rundown; or b) replacing a previous dirty SPI with a new one
		LONG lRefs = InterlockedDecrement(SPI_TO_REFCOUNT(*ppSCMProcessInfo));
		if (lRefs == 0)
		{
			(*SPI_TO_CPROCESS(*ppSCMProcessInfo))->Release();
			
			delete (*ppSCMProcessInfo);
		}
		*ppSCMProcessInfo = NULL;
	}
	return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   CopySCMProcessInfo
//
//  Synopsis:   Allocates and fills in a SCMProcessInfo structure for the 
//              given CProcess server.
//
//  Arguments:  pSPISrc -- ptr to the SCMProcessInfo struct that is to be copied 
//              ppSPIDest -- ptrptr to store the copied struct
//
//  Returns:    S_OK - success
//              E_OUTOFMEMORY
//
//--------------------------------------------------------------------------
HRESULT CSCMProcessControl::CopySCMProcessInfo(SCMProcessInfo* pSPISrc, SCMProcessInfo** ppSPIDest)
{
	ASSERT(pSPISrc && ppSPIDest);
	
	if (!pSPISrc || !ppSPIDest)
		return E_INVALIDARG;
	
	LONG lNewRefs = InterlockedIncrement(SPI_TO_REFCOUNT(pSPISrc));
	
	*ppSPIDest = pSPISrc;
	
	return S_OK;
};


//+-------------------------------------------------------------------------
//
//  Function:   FindAppOrClass
//
//  Synopsis:   This is a generic helper function used by the FindApplication
//              and FindClass methods.    The logic is the same for either.
//
//  Arguments:  rguid -- the appid or clsid to use in the query
//              pServerTable - the table to use in the query
//              ppESPI -- the place to store the resulting enumerator object
//
//  Returns:    S_OK - success
//              E_OUTOFMEMORY
//
//--------------------------------------------------------------------------
HRESULT CSCMProcessControl::FindAppOrClass(const GUID& rguid, CServerTable* pServerTable, IEnumSCMProcessInfo** ppESPI)
{
	HRESULT hr;
	CSCMProcessEnumerator* pSPEnum = NULL;
	CServerTableEntry* pSTE = NULL;
	
	if (!ppESPI)
		return E_INVALIDARG;
	
	*ppESPI = NULL;
	
	pSTE = pServerTable->Lookup((GUID&)rguid);
	if (!pSTE)
	{
		return S_OK;
	}
	
	pSPEnum = new CSCMProcessEnumerator();
	if (!pSPEnum)
	{
		pSTE->Release();
		return E_OUTOFMEMORY;
	}
    
	CServerList* pServerList = pSTE->GetServerListWithSharedLock();
	ASSERT(pServerList && "unexpected NULL pServerList");
	
	// For each server that has registered for this appid/clsid, add a 
	// SCMProcessInfo to the enumerator object
	CServerListEntry* pSLE = (CServerListEntry*)pServerList->First();
	while (pSLE)
	{
		SCMProcessInfo* pSPI;
		
		CProcess* pprocess = pSLE->GetProcess(); // not refcounted
		ASSERT(pprocess);
		
		hr = FillInSCMProcessInfo(pprocess, pSLE->IsReadyForActivations(), &pSPI);
		if (SUCCEEDED(hr))
		{
			// add it to the enumerator; on success, the enumerator owns it
			hr = pSPEnum->AddProcess(pSPI);
			if (FAILED(hr)) 
			{
				FreeSCMProcessInfoPriv(&pSPI);  // we still own it, so free the memory
				break;
			}
		}
		else
			break;
		
		pSLE = (CServerListEntry*) pSLE->Next();
	}
	
	pSTE->ReleaseSharedListLock();
	
	if (SUCCEEDED(hr))
	{
		hr = pSPEnum->QueryInterface(__uuidof(IEnumSCMProcessInfo), (void**)ppESPI);
	}
	
	pSPEnum->Release();
	pSTE->Release();
	
	return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   InitializeEnumerator
//
//  Synopsis:   Initializes the aggregated enumerator object for use.  Mainly
//              this consists of adding SCMProcessInfo's for all known servers
//              to the enumerator.
//
//  Arguments:  none
//
//  Returns:    S_OK
//              E_OUTOFMEMORY
//
//--------------------------------------------------------------------------
HRESULT CSCMProcessControl::InitializeEnumerator()
{
	return E_NOTIMPL;
}

// IUnknown implementation for CSCMProcessControl
STDMETHODIMP CSCMProcessControl::QueryInterface(REFIID riid, void** ppv)
{
	HRESULT hr = S_OK;
	if (!ppv)
		return E_POINTER;
	
	*ppv = NULL;
	
	if (riid == IID_IUnknown || riid == IID_ISCMProcessControl)
	{
		*ppv = (void*)this;
		AddRef();
		return S_OK;
	}
	/*
	else if (riid == IID_IEnumSCMProcessInfo)
	{
    if (!_bInitializedEnum)
    {
	// First time we've been QI'd for this interface; create an 
	// enumerator object to aggregate over.
	hr = InitializeEnumerator();
	_bInitializedEnum = TRUE;
    }
	
	  if (SUCCEEDED(hr))
	  {
      hr = _SPEnum.QueryInterface(riid, ppv);
	  }
	  return hr;
	  }
	*/
	return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CSCMProcessControl::AddRef()
{
	return InterlockedIncrement(&_lRefs);
}

STDMETHODIMP_(ULONG) CSCMProcessControl::Release()
{
	LONG lRefs = InterlockedDecrement(&_lRefs);
	if (lRefs == 0)
	{
		delete this;
	}
	return lRefs;
}

//+-------------------------------------------------------------------------
//
//  Implementation of CSCMProcessEnumerator begins here
//
//--------------------------------------------------------------------------

//
// ctor used by the CSCMProcessControl object
//
CSCMProcessEnumerator::CSCMProcessEnumerator() :
	_lRefs(1),
	_dwNumSPInfos(0),
	_dwMaxSPInfos(SPENUM_INITIAL_SIZE),
	_dwCurSPInfo(0),
	_ppSPInfos(NULL),
	_ppSPInfosForReal(_pSPInfosInitial),
	_pOuterUnk(NULL)
{
	  ZeroMemory(_pSPInfosInitial, sizeof(SCMProcessInfo*) * SPENUM_INITIAL_SIZE);
}

//
// ctor used by the Clone method to create new copies of an enumerator
//
CSCMProcessEnumerator::CSCMProcessEnumerator(CSCMProcessEnumerator* pCSPEOrig,
                                             HRESULT* phrInit) :
	_lRefs(1),
	_dwNumSPInfos(0),  // this gets adjusted in the loop below
	_dwMaxSPInfos(pCSPEOrig->_dwMaxSPInfos),
	_dwCurSPInfo(pCSPEOrig->_dwCurSPInfo),
	_pOuterUnk(NULL)
{  
	ZeroMemory(_pSPInfosInitial, sizeof(SCMProcessInfo*) * SPENUM_INITIAL_SIZE);
	
	if (_dwMaxSPInfos == SPENUM_INITIAL_SIZE)
	{
		// The src enumerator did not grown beyond SPENUM_INITIAL_SIZE
		_ppSPInfosForReal = _pSPInfosInitial;
	}
	else
	{
		// The src enumerator did grow, so we need to create an array 
		// to hold everything
		_ppSPInfos = new SCMProcessInfo*[_dwMaxSPInfos];
		if (!_ppSPInfos)
		{
			*phrInit = E_OUTOFMEMORY;
			return;
		}
		ZeroMemory(_ppSPInfos, sizeof(SCMProcessInfo*) * _dwMaxSPInfos);
		_ppSPInfosForReal = _ppSPInfos;
	}
	
	// Make copies of each of the original enumerator's SCMProcessInfo structs
	DWORD dwNumSPInfosInOriginal = pCSPEOrig->_dwNumSPInfos;
	for (DWORD i = 0; i < dwNumSPInfosInOriginal; i++)
	{
		*phrInit = CSCMProcessControl::CopySCMProcessInfo(pCSPEOrig->_ppSPInfos[i], &(_ppSPInfosForReal[i]));
		if (FAILED(*phrInit))
			return;
		
		_dwNumSPInfos++;
	}     
}

//
// ctor used when we are aggregated by the CSCMProcessControl object
//
CSCMProcessEnumerator::CSCMProcessEnumerator(CSCMProcessControl* pOuterUnk) :
	_lRefs(-1),        // don't use refcount when we are aggregated
	_dwNumSPInfos(0), 
	_dwMaxSPInfos(SPENUM_INITIAL_SIZE),
	_dwCurSPInfo(0),
	_ppSPInfosForReal(_pSPInfosInitial),
	_pOuterUnk(pOuterUnk)  // not refcounted!
{  
}

//
// dtor
//
CSCMProcessEnumerator::~CSCMProcessEnumerator()
{
#ifdef DBG
	if (_pOuterUnk)
		ASSERT(_lRefs == -1);
	else
		ASSERT(_lRefs == 0);
#endif
  
	for (DWORD i = 0; i < _dwNumSPInfos; i++)
	{
		CSCMProcessControl::FreeSCMProcessInfoPriv(&(_ppSPInfosForReal[i]));
	}
  
#ifdef DBG
	for (DWORD j = i; j < _dwMaxSPInfos; j++)
	{
		ASSERT(_ppSPInfosForReal[j] == NULL);
	}
#endif

	if (_ppSPInfos)
	{
		ASSERT(_dwMaxSPInfos > SPENUM_INITIAL_SIZE);
		delete _ppSPInfos;
	}
}

//+-------------------------------------------------------------------------
//
//  Function:   Next
//
//  Synopsis:   Returns to the caller the requested # of SCMProcessInfo
//              ptrs.    
//
//  Arguments:  cElems -- # of requested structs
//              ppSPI -- ptr to an array of size cElems
//              pcFetched -- out param containg # of elements actually
//                fetched; can be NULL.
//
//  Returns:    S_OK - the requested # of elements were returned
//              S_FALSE -- only some of the requested # of elements were returned
//              E_INVALIDARG -- one or more parameters were bogus
//
//  Notes:      the caller's ppSPI array, on success, will contain ptrs to the 
//              enumerator's SPI structs.    The caller may only use his ptrs while
//              he holds a reference on the enumerator.
// 
//--------------------------------------------------------------------------
STDMETHODIMP CSCMProcessEnumerator::Next(ULONG cElems, SCMProcessInfo** ppSPI, ULONG* pcFetched)
{
	if (!ppSPI)
		return E_INVALIDARG;
    
	ZeroMemory(ppSPI, sizeof(SCMProcessInfo*) * cElems);
	
	DWORD dwFetched = 0;
	for (DWORD i = _dwCurSPInfo; (i < _dwNumSPInfos) && (dwFetched < cElems); i++, dwFetched++)
	{
		ppSPI[dwFetched] = _ppSPInfosForReal[i];
	}
	
	// tell the caller how many he's getting, if he cared
	if (pcFetched)
		*pcFetched = dwFetched;
	
	// Advance the cursor
	_dwCurSPInfo += dwFetched;
	
	return (dwFetched == cElems) ? S_OK : S_FALSE;
}

//+-------------------------------------------------------------------------
//
//  Function:   Skip
//
//  Synopsis:   Advances the enumerator's "cursor"/ptr by the specified #
//              of elements
//
//  Arguments:  cElems -- the # of elements to advance the cursor by
//
//  Returns:    S_OK - success
//              S_FALSE - there were not a sufficient # of elements to advance
//                that many by.  The cursor now points to the last element.
//
//--------------------------------------------------------------------------
STDMETHODIMP CSCMProcessEnumerator::Skip(ULONG cElems)
{
	_dwCurSPInfo += cElems;
	if (_dwCurSPInfo > _dwNumSPInfos)
	{
		_dwCurSPInfo = _dwNumSPInfos;
		return S_FALSE;
	}
	else
		return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   Reset
//
//  Synopsis:   Resets the enumerator "cursor"/ptr to the initial element
//
//  Arguments:  none
//
//  Returns:    S_OK
//
STDMETHODIMP CSCMProcessEnumerator::Reset()
{
	_dwCurSPInfo = 0;
	return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   Clone
//
//  Synopsis:   Creates a copy of this enumerator and returns it.
//
//  Arguments:  ppESPI -- out-param for newly created copy
//
//  Returns:    S_OK - life is good
//              E_INVALIDARG - bad input parameter
//              E_OUTOFMEMORY
//
//--------------------------------------------------------------------------
STDMETHODIMP CSCMProcessEnumerator::Clone(IEnumSCMProcessInfo **ppESPI)
{
	HRESULT hr;
	
	if (!ppESPI)
		return E_INVALIDARG;
	
	*ppESPI = NULL;
	
	CSCMProcessEnumerator* pNewEnum = new CSCMProcessEnumerator(this, &hr);
	if (!pNewEnum)
		return E_OUTOFMEMORY;
	
	if (SUCCEEDED(hr))
	{
		hr = pNewEnum->QueryInterface(IID_IEnumSCMProcessInfo, (void**)ppESPI);
	}
	
	pNewEnum->Release();
	
	return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   AddProcess
//
//  Synopsis:   Adds the supplied SCMProcessInfo struct to the list managed
//              by this enumerator.
//
//  Arguments:  pSPI -- SCMProcessInfo struct to be added
//
//  Returns:    S_OK - new struct was successfully added
//              E_OUTOFMEMORY
//
//  Notes:      the list of SCMProcessInfo's managed by this enumerator is
//              implemented as a fixed-size array which is grown on demand.
//              This enumerator owns freeing the pSPI struct once added.
//
//--------------------------------------------------------------------------
HRESULT CSCMProcessEnumerator::AddProcess(SCMProcessInfo* pSPI)
{
	ASSERT(pSPI);
	
	if (!pSPI)
		return E_INVALIDARG;
    
	// Time to grow the array?
	if (_dwNumSPInfos == _dwMaxSPInfos)
	{
		DWORD dwNewArraySize = _dwMaxSPInfos + SPENUM_GROWTH_SIZEADD;  // 10,20,30, etc
		SCMProcessInfo** ppSPInfosNew = new SCMProcessInfo*[dwNewArraySize];
		if (!ppSPInfosNew)
			return E_OUTOFMEMORY; 
		
		// Zero everything out
		ZeroMemory(ppSPInfosNew, sizeof(SCMProcessInfo*) * dwNewArraySize);
		
		// Copy over the contents of the old array
		CopyMemory(ppSPInfosNew, _ppSPInfosForReal, sizeof(SCMProcessInfo*) * _dwMaxSPInfos);
    
#ifdef DBG
		// Fill in the old array with a dummy value
		FillMemory(_pSPInfosInitial, sizeof(SCMProcessInfo*) * _dwMaxSPInfos, 0xba);
#endif

		if (_dwMaxSPInfos > SPENUM_INITIAL_SIZE)
		{
			// We're growing larger than a previous dynamic array; cleanup
			// the old memory
			ASSERT(_ppSPInfos);
			delete _ppSPInfos;
		}
		
		_ppSPInfos = ppSPInfosNew;
		_ppSPInfosForReal = _ppSPInfos;
		_dwMaxSPInfos = dwNewArraySize;
	}
	
	// Store the new SCMProcessInfo struct
	_ppSPInfosForReal[_dwNumSPInfos] = pSPI;
	_dwNumSPInfos++;
	
	return S_OK;
}

// IUnknown implementation for CSCMProcessEnumerator
STDMETHODIMP CSCMProcessEnumerator::QueryInterface(REFIID riid, void** ppv)
{
	if (!ppv)
		return E_POINTER;
	
	if (riid == IID_IUnknown || riid == IID_IEnumSCMProcessInfo)
	{
		if (_pOuterUnk && riid == IID_IUnknown)
			return _pOuterUnk->QueryInterface(riid, ppv);
		
		*ppv = (void*)this;
		AddRef();
		return S_OK;
	}
	else if (_pOuterUnk)
	{
		// Unknown interface, let punkouter take care of it
		return _pOuterUnk->QueryInterface(riid, ppv);
	}
	return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CSCMProcessEnumerator::AddRef()
{
	if (_pOuterUnk)
		return _pOuterUnk->AddRef();
	
	return InterlockedIncrement(&_lRefs);
}

STDMETHODIMP_(ULONG) CSCMProcessEnumerator::Release()
{
	if (_pOuterUnk)
		return _pOuterUnk->Release();
	
	LONG lRefs = InterlockedDecrement(&_lRefs);
	if (lRefs == 0)
	{
		delete this;
	}
	return lRefs;
}

//+-------------------------------------------------------------------------
//
//  Function:  FreeSPIFromCProcess
//
//  Synopsis:  CProcess's don't know about CSCMProcessControl stuff.  This is
//             helper function which CProcess extern's in order to call
//
//--------------------------------------------------------------------------
HRESULT FreeSPIFromCProcess(void** ppSCMProcessInfo)
{
  return CSCMProcessControl::FreeSCMProcessInfoPriv((SCMProcessInfo**)ppSCMProcessInfo);
}



//+-------------------------------------------------------------------------
//
//  Function:  PrivGetRPCSSInfo
//
//  Synopsis:  Activators that call GetRPCSSInfo (exported from rpcss.dll) 
//             end up in this function; they call here in order to get an 
//             interface on which they can query & adjust the scm activation state. 
//
//  History:   05-Sep-99   JSimmons   Created
//
//--------------------------------------------------------------------------
HRESULT PrivGetRPCSSInfo(REFCLSID rclsid, REFIID riid, void** ppv)
{
	HRESULT hr = E_INVALIDARG;
	
	if (!ppv)
		return E_POINTER;

	if (rclsid == CLSID_RPCSSInfo)
	{
		CSCMProcessControl* pSPC = NULL;
		pSPC = new CSCMProcessControl();
		if (pSPC)
		{
			hr = pSPC->QueryInterface(riid, ppv);
			if (FAILED(hr))
				delete pSPC;
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}

	return hr;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\olescm\scmstage.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995.
//
//  File:       scmstage.cxx
//
//  Contents:   Implements a stateless object that implements ISystemActivator
//
//  Functions:               
//              CScmActivator::GetClassObject
//              CScmActivator::CreateInstance
//              GetComActivatorForStage
//              PerformScmStage
//
//  History:    Vinaykr   3/11/98     Created
//
//--------------------------------------------------------------------------

#include "act.hxx"

// Global (only) instance of the default SCM-level activator
CScmActivator gScmActivator;

//+---------------------------------------------------------------------------
//
//  Function:   CScmActivator::QueryInterface
//
//  Synopsis:   Dummy method
//
//----------------------------------------------------------------------------
STDMETHODIMP CScmActivator::QueryInterface( REFIID riid, LPVOID* ppv)
{
    ASSERT(0 && "This QI function should never be used");

    return E_NOINTERFACE;
}

//+---------------------------------------------------------------------------
//
//  Function:   CScmActivator::AddRef
//
//  Synopsis:   Dummy method
//
//----------------------------------------------------------------------------
ULONG CScmActivator::AddRef(void)
{
    return 1;
}

//+---------------------------------------------------------------------------
//
//  Function:   CScmActivator::Release
//
//  Synopsis:   Dummy method
//
//----------------------------------------------------------------------------
ULONG CScmActivator::Release(void)
{
    return 1;
}

//+---------------------------------------------------------------------------
//
//  Function:   CScmActivator::GetClassObject
//
//  Synopsis:   Forwards to ActivateFromProperties.
//
//----------------------------------------------------------------------------
STDMETHODIMP CScmActivator::GetClassObject(
    IN  IActivationPropertiesIn   * pActIn,
    OUT IActivationPropertiesOut  ** ppActOut
    )
{
    return ActivateFromProperties(pActIn, ppActOut);
}

//+---------------------------------------------------------------------------
//
//  Function:   CScmActivator::CreateInstance
//
//  Synopsis:   Forwards to ActivateFromProperties.
//
//----------------------------------------------------------------------------
STDMETHODIMP CScmActivator::CreateInstance(
    IN  IUnknown                  * pUnk,
    IN  IActivationPropertiesIn   * pActIn,
    OUT IActivationPropertiesOut  ** ppActOut
    )
{
    return ActivateFromProperties(pActIn, ppActOut);
}


//+---------------------------------------------------------------------------
//
//  Function:   GetComActivatorForStage
//
//  Synopsis:   Returns default activator.
//
//----------------------------------------------------------------------------
ISystemActivator *GetComActivatorForStage(ACTIVATION_STAGE stage)
{
    ASSERT(stage == SERVER_MACHINE_STAGE && "Only SCM stage currently supported is SERVER");
    return &gScmActivator;
}


//+---------------------------------------------------------------------------
//
//  Function:   PerformScmStage
//
//  Synopsis:   Marshals and unmarshals activation properties and forwards to
//              ActivateFromPropertiesPreamble.   
//
//  Notes:      Currently this function doesn't look at the ACTIVATION_STAGE 
//              parameter; of course a SCM-level activator must be a 
//              SERVER_MACHINE_STAGE activator, if it's going to run at all.
//
//----------------------------------------------------------------------------
HRESULT PerformScmStage(ACTIVATION_STAGE stage,
                        PACTIVATION_PARAMS pActParams,
                        MInterfacePointer   * pInActProperties,
                        MInterfacePointer  ** ppOutActProperties
)
{
    if (pActParams == NULL || pInActProperties == NULL || ppOutActProperties == NULL)
        return E_INVALIDARG;
    
    if ( (pActParams->ORPCthis->version.MajorVersion != COM_MAJOR_VERSION) ||
         (pActParams->ORPCthis->version.MinorVersion > COM_MINOR_VERSION) )
        RpcRaiseException( RPC_E_VERSION_MISMATCH );

    HRESULT hr;

    ActivationPropertiesIn *pActPropsIn = new ActivationPropertiesIn();

    if (NULL == pActPropsIn)
    {
        return E_OUTOFMEMORY;
    }

    // AWFUL HACK ALERT:  This is too hacky even for the SCM
    ActivationStream ActStream((InterfaceData*)(((BYTE*)pInActProperties)+48));

    IActivationStageInfo *pStage;
    
    //
    // The UnmarshalInterface call will obtain an IComClassInfo for the requested
    // clsid;  this isn't the most obvious place to do it, but there it is....
    //
    // WARNING:  DO NOT REMOVE THIS.  It has a side-effect (gets the IComClassInfo)
    //
    hr = pActPropsIn->UnmarshalInterface(&ActStream, IID_IActivationStageInfo,
                                          (LPVOID*)&pStage);
    if (FAILED(hr))
    {
        pActPropsIn->Release();
        return hr;
    }

    // Set SCM Stage
/*  jjs -- this will get done in ActFromPropsPreamble....no need to do it twice...
    pStage->SetStageAndIndex(SERVER_MACHINE_STAGE, 0);
*/
    pStage->Release();

    // 
    //  Now call ActivateFromPropertiesPreamble....it will do some further processing,
    //    then kick off the activation delegation.    
    // 
    IActivationPropertiesOut *pActPropsOut;
    hr = ActivateFromPropertiesPreamble(pActPropsIn, &pActPropsOut, pActParams);

    //
    //  Do return processing...
    //
    *ppOutActProperties = NULL;

    DWORD relCount;
    if ((hr==S_OK) && (pActPropsOut))
    {
        DWORD destCtx;

        if (pActParams->RemoteActivation)
            destCtx = MSHCTX_DIFFERENTMACHINE;
        else
            destCtx = MSHCTX_LOCAL;

        if (pActParams->pActPropsOut == NULL)
        {
            pActPropsOut->QueryInterface(CLSID_ActivationPropertiesOut,
                                        (void**) &pActParams->pActPropsOut);
        }

        hr = ActPropsMarshalHelper(pActParams->pActPropsOut, IID_IActivationPropertiesOut,
                                   destCtx, MSHLFLAGS_NORMAL, ppOutActProperties);

        relCount = pActPropsOut->Release();
        Win4Assert(relCount == 0);
    }

    relCount = pActPropsIn->Release();
    Win4Assert(relCount == 0);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\olescm\scmsvc.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1991 - 1992
//
// File:        scmsvc.cxx
//
// Contents:    Initialization for win32 service controller.
//
// History:     14-Jul-92 CarlH     Created.
//              31-Dec-93 ErikGav   Chicago port
//              25-Aug-99 a-sergiv  Fixed ScmCreatedEvent vulnerability
//
//------------------------------------------------------------------------

#include "act.hxx"

#ifdef DFSACTIVATION
HANDLE  ghDfs = 0;
#endif

#define SCM_CREATED_EVENT  TEXT("ScmCreatedEvent")

DECLARE_INFOLEVEL(Cairole);

extern CRITICAL_SECTION ShellQueryCS;

SC_HANDLE   g_hServiceController = 0;
PSID        psidMySid = NULL;

#if DBG
//+-------------------------------------------------------------------------
//
//  Function:   SetScmDefaultInfoLevel
//
//  Synopsis:   Sets the default infolevel for the SCM
//
//  History:    07-Jan-94 Ricksa    Created
//
//  Notes:      Uses standard place in win.ini defined by KevinRo but
//              does not use the same value as compob32.dll so you don't
//              have to get all the debugging in the universe just to
//              get the SCM's debug output.
//
//              A second point is that we don't use unicode here because
//              it is just easier to avoid the unicode headache with
//              mulitple builds between chicago and nt
//
//--------------------------------------------------------------------------
char *pszInfoLevelSectionName = "Cairo InfoLevels";
char *pszInfoLevelName = "scm";
char *pszInfoLevelDefault = "$";

#define INIT_VALUE_SIZE 16
void SetScmDefaultInfoLevel(void)
{
    char aszInitValue[INIT_VALUE_SIZE];

    ULONG ulRet;

    ulRet = GetProfileStringA(pszInfoLevelSectionName,
                             pszInfoLevelName,
                             pszInfoLevelDefault,
                             aszInitValue,
                             INIT_VALUE_SIZE);

    if ((ulRet != INIT_VALUE_SIZE - 1) && (aszInitValue[0] != L'$'))
    {
        if((ulRet = strtoul(aszInitValue, NULL, 16)) == 1)
        {
            CairoleInfoLevel = ulRet;
        }
    }
}
#endif // DBG

//+-------------------------------------------------------------------------
//
//  Function:   InitializeSCMBeforeListen
//
//  Synopsis:   Initializes OLE side of rpcss.  Put things in here that do
//              not depend on RPC being initialized, etc.
//
//  Arguments:  None.
//
//  Returns:    Status of initialization.    Note that this function is a bit
//    weak on cleanup in the face of errors, but this is okay since if this
//    function fails, RPCSS will not start.     
//
//--------------------------------------------------------------------------
DWORD
InitializeSCMBeforeListen( void )
{
    LONG        Status;
    SCODE       sc;
    RPC_STATUS  rs;

    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    UpdateState(SERVICE_START_PENDING);

    Status = RtlInitializeCriticalSection(&gTokenCS);
    if (!NT_SUCCESS(Status))
        return Status;

    Status = RtlInitializeCriticalSection(&ShellQueryCS);
    if (!NT_SUCCESS(Status))
        return Status;

    // Allocate locks
    Status = OR_NOMEM;
    gpClientLock = new CSharedLock(Status);
    if (OR_OK != Status)
        return(Status);

    Status = OR_NOMEM;
    gpServerLock = new CSharedLock(Status);
    if (OR_OK != Status)
        return(Status);

    Status = OR_NOMEM;
    gpIPCheckLock = new CSharedLock(Status);
    if (OR_OK != Status)
        return(Status);

    g_hServiceController = OpenSCManager(NULL, NULL, GENERIC_EXECUTE);
    if (!g_hServiceController)
        return GetLastError();

    //
    // Get my sid
    // This is simplified under the assumption that SCM runs as LocalSystem.
    // We should remove this code when we incorporate OLE service into the
    // Service Control Manager since this becomes duplicated code then.
    //
    Status = RtlAllocateAndInitializeSid (
        &NtAuthority,
        1,
        SECURITY_LOCAL_SYSTEM_RID,
        0, 0, 0, 0, 0, 0, 0,
        &psidMySid
        );
    if (!NT_SUCCESS(Status))
        return Status;

    UpdateState(SERVICE_START_PENDING);

    HRESULT hr = S_OK;

    hr = InitSCMRegistry();
    if (FAILED(hr))
        return ERROR_NOT_ENOUGH_MEMORY;

    //Initialize runas cache
    InitRunAsCache();  // returns void

    gpClassLock = new CSharedLock(Status);
    if (!gpClassLock)
        return ERROR_NOT_ENOUGH_MEMORY;

    gpProcessLock = new CSharedLock(Status);
    if (!gpProcessLock)
        return ERROR_NOT_ENOUGH_MEMORY;

    gpProcessListLock = new CSharedLock(Status);
    if (!gpProcessListLock)
        return ERROR_NOT_ENOUGH_MEMORY;

    gpClassTable = new CServerTable(Status, ENTRY_TYPE_CLASS);
    if (!gpClassTable)
        return ERROR_NOT_ENOUGH_MEMORY;

    gpProcessTable = new CServerTable(Status, ENTRY_TYPE_PROCESS);
    if (!gpProcessTable)
        return ERROR_NOT_ENOUGH_MEMORY;

    gpSurrogateList = new CSurrogateList();
    if (!gpSurrogateList)
        return ERROR_NOT_ENOUGH_MEMORY;

    gpRemoteMachineLock = new CSharedLock(Status);
    if (!gpRemoteMachineLock)
        return ERROR_NOT_ENOUGH_MEMORY;

    gpRemoteMachineList = new CRemoteMachineList();
    if (!gpRemoteMachineList)
        return ERROR_NOT_ENOUGH_MEMORY;

    UpdateState(SERVICE_START_PENDING);

#ifdef DFSACTIVATION
    DfsOpen( &ghDfs );
#endif

    return 0;
}


//+-------------------------------------------------------------------------
//
//  Function:   InitializeSCM
//
//  Synopsis:   Initializes OLE side of rpcss.
//
//  Arguments:  None.
//
//  Returns:    ERROR_SUCCESS
//
//              (REVIEW: should we be returning an error whenever any of
//              the stuff in this function fails?)
//
//--------------------------------------------------------------------------
DWORD
InitializeSCM( void )
{
    LONG        Status;
    SCODE       sc;
    RPC_STATUS  rs;
    HRESULT     hr;

    // start the RPC service
    hr = InitScmRot();
    if (FAILED(hr))
        return ERROR_NOT_ENOUGH_MEMORY;

    sc = RpcServerRegisterIf(ISCM_ServerIfHandle, 0, 0);
    Win4Assert((sc == 0) && "RpcServerRegisterIf failed!");

    sc = RpcServerRegisterIf(ISCMActivator_ServerIfHandle, 0, 0);
    Win4Assert((sc == 0) && "RpcServerRegisterIf failed!");

    sc = RpcServerRegisterIf(IMachineActivatorControl_ServerIfHandle, 0, 0);
    Win4Assert((sc == 0) && "RpcServerRegisterIf failed!");

    sc = RpcServerRegisterIf(_IActivation_ServerIfHandle, 0, 0);
    Win4Assert((sc == 0) && "RpcServerRegisterIf failed!");

    sc = RpcServerRegisterIf(_IRemoteSCMActivator_ServerIfHandle, 0, 0);
    Win4Assert((sc == 0) && "RpcServerRegisterIf failed!");

    UpdateState(SERVICE_START_PENDING);

    return ERROR_SUCCESS;
}


void
InitializeSCMAfterListen()
{
    //
    // This is for the OLE apps which start during boot.  They must wait for
    // rpcss to start before completing OLE calls that talk to rpcss.
    //
    // Need to do this work to make sure the DACL for the event doesn't have
    // WRITE_DAC and WRITE_OWNER on it.
    //
    SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_WORLD_SID_AUTHORITY;
    PSID pSidEveryone        = NULL;
    PACL pAcl                = NULL;
    DWORD cbAcl              = 0;

    AllocateAndInitializeSid(&SidAuthority, 1, SECURITY_WORLD_RID,
                             0, 0, 0, 0, 0, 0, 0, &pSidEveryone);

    if(pSidEveryone)
    {
        cbAcl = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) + GetLengthSid(pSidEveryone);
        pAcl = (PACL) LocalAlloc(LMEM_FIXED, cbAcl);

        if(pAcl)
        {
            InitializeAcl(pAcl, cbAcl, ACL_REVISION);
            AddAccessAllowedAce(pAcl, ACL_REVISION, EVENT_QUERY_STATE|EVENT_MODIFY_STATE|SYNCHRONIZE|READ_CONTROL, pSidEveryone);
        }
    }

    // Create security descriptor and attach the DACL to it
    SECURITY_DESCRIPTOR sd;
    InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);
    SetSecurityDescriptorDacl(&sd, TRUE, pAcl, FALSE);

    SECURITY_ATTRIBUTES sa;
    sa.nLength = sizeof(sa);
    sa.bInheritHandle = FALSE;
    sa.lpSecurityDescriptor = &sd;

    HANDLE  EventHandle;
    RPC_STATUS rpcstatus;

    EventHandle = CreateEventT( &sa, TRUE, FALSE, SCM_CREATED_EVENT );

    if ( !EventHandle && GetLastError() == ERROR_ACCESS_DENIED )
        EventHandle = OpenEvent(EVENT_MODIFY_STATE | SYNCHRONIZE, FALSE, SCM_CREATED_EVENT);

    if ( EventHandle )
        SetEvent( EventHandle );
    else
        ASSERT(0 && "Unable to get ScmCreatedEvent");

    if (pSidEveryone)
        FreeSid(pSidEveryone);
    if (pAcl)
        LocalFree(pAcl);

    // Tell RPC to enable cleanup of idle connections.  This function only needs to be 
    // called one time.
    rpcstatus = RpcMgmtEnableIdleCleanup();
    ASSERT(rpcstatus == RPC_S_OK && "unexpected failure from RpcMgmtEnableIdleCleanup");
    // don't fail in free builds, this is an non-essential optimization

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\olescm\secdesc.cxx ===
/****************************** Module Header ******************************\
* Module Name: secdesc.cxx
*
* Copyright (c) 1991, Microsoft Corporation
*
* Routines that support creation and deletion of security descriptors
*
* History:
* 02-06-92 Davidc       Created.
* 04-14-92 RichardW     Changed ACE_HEADER
* 04-01-94 AndyH        Copied from winlogon.  Changed to .CXX
\***************************************************************************/

#include "act.hxx"

//
// Private prototypes
//

PACCESS_ALLOWED_ACE
CreateAccessAllowedAce(
    PSID  Sid,
    ACCESS_MASK AccessMask,
    UCHAR AceFlags,
    UCHAR InheritFlags
    );

VOID
DestroyAce(
    PVOID   Ace
    );


//
// Memory macros
//

#define Alloc(c)        ((PVOID)LocalAlloc(LPTR, c))
#define ReAlloc(p, c)   ((PVOID)LocalReAlloc(p, c, LPTR | LMEM_MOVEABLE))
#define Free(p)         ((VOID)LocalFree(p))


/***************************************************************************\
* CreateSecurityDescriptor
*
* Creates a security descriptor containing an ACL containing the specified ACEs
*
* A SD created with this routine should be destroyed using
* DeleteSecurityDescriptor
*
* Returns a pointer to the security descriptor or NULL on failure.
*
* 02-06-92 Davidc       Created.
\***************************************************************************/

PSECURITY_DESCRIPTOR
CreateSecurityDescriptor(
    PMYACE  MyAce,
    ACEINDEX AceCount
    )
{
    NTSTATUS Status;
    ACEINDEX AceIndex;
    PACCESS_ALLOWED_ACE *Ace;
    PACL    Acl = NULL;
    PSECURITY_DESCRIPTOR SecurityDescriptor = NULL;
    ULONG   LengthAces;
    ULONG   LengthAcl;
    ULONG   LengthSd;

    //
    // Allocate space for the ACE pointer array
    //

    Ace = (PACCESS_ALLOWED_ACE *)Alloc(sizeof(PACCESS_ALLOWED_ACE) * AceCount);
    if (Ace == NULL) {
        CairoleDebugOut((DEB_ERROR, "Failed to allocated ACE array\n"));
        return(NULL);
    }

    //
    // Create the ACEs and calculate total ACE size
    //

    LengthAces = 0;
    for (AceIndex=0; AceIndex < AceCount; AceIndex ++) {
        Ace[AceIndex] = CreateAccessAllowedAce(MyAce[AceIndex].Sid,
                                               MyAce[AceIndex].AccessMask,
                                               0,
                                               MyAce[AceIndex].InheritFlags);
        if (Ace[AceIndex] == NULL) {
            CairoleDebugOut((DEB_ERROR, "Failed to allocated ACE\n"));
        } else {
            LengthAces += Ace[AceIndex]->Header.AceSize;
        }
    }

    //
    // Calculate ACL and SD sizes
    //

    LengthAcl = sizeof(ACL) + LengthAces;
    LengthSd  = SECURITY_DESCRIPTOR_MIN_LENGTH;

    //
    // Create the ACL
    //

    Acl = (PACL) Alloc(LengthAcl);

    if (Acl != NULL) {

        Status = RtlCreateAcl(Acl, LengthAcl, ACL_REVISION);
        Win4Assert(NT_SUCCESS(Status));

        //
        // Add the ACES to the ACL and destroy the ACEs
        //

        for (AceIndex = 0; AceIndex < AceCount; AceIndex ++) {

            if (Ace[AceIndex] != NULL) {

                Status = RtlAddAce(Acl, ACL_REVISION, 0, Ace[AceIndex],
                                   Ace[AceIndex]->Header.AceSize);

                if (!NT_SUCCESS(Status)) {
                    CairoleDebugOut((DEB_ERROR, "AddAce failed, status = 0x%lx\n", Status));
                }

                DestroyAce(Ace[AceIndex]);
            }
        }

    } else {
        CairoleDebugOut((DEB_ERROR, "Failed to allocated ACL\n"));
    }

    //
    // Free the ACE pointer array
    //
    Free(Ace);

    //
    // Create the security descriptor
    //

    SecurityDescriptor = Alloc(LengthSd);

    if (SecurityDescriptor != NULL) {

        Status = RtlCreateSecurityDescriptor(SecurityDescriptor, SECURITY_DESCRIPTOR_REVISION);
        Win4Assert(NT_SUCCESS(Status));

        //
        // Set the DACL on the security descriptor
        //
        Status = RtlSetDaclSecurityDescriptor(SecurityDescriptor, TRUE, Acl, FALSE);
        if (!NT_SUCCESS(Status)) {
            // BUGBUG CairoleDebugOut WLPrint(("SetDACLSD failed, status = 0x%lx", Status));
        }
    } else {
        // BUGBUG CairoleDebugOut WLPrint(("Failed to allocate security descriptor"));
    }

    //
    // Return with our spoils
    //
    return(SecurityDescriptor);
}


/***************************************************************************\
* DeleteSecurityDescriptor
*
* Deletes a security descriptor created using CreateSecurityDescriptor
*
* Returns TRUE on success, FALSE on failure
*
* 02-06-92 Davidc       Created.
\***************************************************************************/

BOOL
DeleteSecurityDescriptor(
    PSECURITY_DESCRIPTOR SecurityDescriptor
    )
{
    NTSTATUS Status;
    PACL    Acl;
    BOOLEAN Present;
    BOOLEAN Defaulted;

    Win4Assert(SecurityDescriptor != NULL);

    //
    // Get the ACL
    //
    Status = RtlGetDaclSecurityDescriptor(SecurityDescriptor,
                                          &Present, &Acl, &Defaulted);
    if (NT_SUCCESS(Status)) {

        //
        // Destroy the ACL
        //
        if (Present && (Acl != NULL)) {
            Free(Acl);
        }
    } else {
        // BUGBUG CairoleDebugOut WLPrint(("Failed to get DACL from security descriptor being destroyed, Status = 0x%lx", Status));
    }

    //
    // Destroy the Security Descriptor
    //
    Free(SecurityDescriptor);

    return(TRUE);
}


/***************************************************************************\
* CreateAccessAllowedAce
*
* Allocates memory for an ACCESS_ALLOWED_ACE and fills it in.
* The memory should be freed by calling DestroyACE.
*
* Returns pointer to ACE on success, NULL on failure
*
* History:
* 12-05-91 Davidc       Created
* 04-05-94 AndyH        Changed return to ACE
\***************************************************************************/
PACCESS_ALLOWED_ACE
CreateAccessAllowedAce(
    PSID  Sid,
    ACCESS_MASK AccessMask,
    UCHAR AceFlags,
    UCHAR InheritFlags
    )
{
    ULONG   LengthSid = RtlLengthSid(Sid);
    ULONG   LengthACE = sizeof(ACE_HEADER) + sizeof(ACCESS_MASK) + LengthSid;
    PACCESS_ALLOWED_ACE Ace;

    Ace = (PACCESS_ALLOWED_ACE)Alloc(LengthACE);
    if (Ace == NULL) {
        // BUGBUG CairoleDebugOut WLPrint(("CreateAccessAllowedAce : Failed to allocate ace"));
        return NULL;
    }

    Ace->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
    Ace->Header.AceSize = (UCHAR)LengthACE;
    Ace->Header.AceFlags = AceFlags | InheritFlags;
    Ace->Mask = AccessMask;
    RtlCopySid(LengthSid, (PSID)(&(Ace->SidStart)), Sid );

    return(Ace);
}


/***************************************************************************\
* DestroyAce
*
* Frees the memory allocate for an ACE
*
* History:
* 12-05-91 Davidc       Created
\***************************************************************************/
VOID
DestroyAce(
    PVOID   Ace
    )
{
    Free(Ace);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\olescm\scmif.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       scmif.cxx
//
//  Contents:   Entry points for scm interface.
//
//  Functions:  StartObjectService
//              SvcActivateObject
//              SvcCreateActivateObject
//              ObjectServerStarted
//              StopServer
//
//  History:    01-May-93 Ricksa    Created
//              31-Dec-93 ErikGav   Chicago port
//
//--------------------------------------------------------------------------

#include "act.hxx"

//+-------------------------------------------------------------------------
//
//  Function:   Dummy1
//
//  Synopsis:   Needed for IDL hack.  Never called.
//
//  Arguments:  [hRpc] - RPC handle
//              [orpcthis] - ORPC handle
//              [localthis] - ORPC call data
//              [orpcthat] - ORPC reply data
//
//  Returns:    HRESULT
//
//  History:    14 Apr 95   AlexMit    Created
//
//--------------------------------------------------------------------------
extern "C" HRESULT DummyQueryInterfaceIOSCM(
    handle_t  hRpc,
    ORPCTHIS  *orpcthis,
    LOCALTHIS *localthis,
    ORPCTHAT *orpcthat,
    DWORD     dummy )
{
    CairoleDebugOut((DEB_ERROR, "SCM Dummy function should never be called!\n" ));
    orpcthat->flags      = 0;
    orpcthat->extensions = NULL;
    return E_FAIL;
}

//+-------------------------------------------------------------------------
//
//  Function:   Dummy2
//
//  Synopsis:   Needed for IDL hack.  Never called.
//
//  Arguments:  [hRpc] - RPC handle
//              [orpcthis] - ORPC handle
//              [localthis] - ORPC call data
//              [orpcthat] - ORPC reply data
//
//  Returns:    HRESULT
//
//  History:    14 Apr 95   AlexMit    Created
//
//--------------------------------------------------------------------------
extern "C" HRESULT DummyAddRefIOSCM(
    handle_t  hRpc,
    ORPCTHIS  *orpcthis,
    LOCALTHIS *localthis,
    ORPCTHAT *orpcthat,
    DWORD     dummy )
{
    CairoleDebugOut((DEB_ERROR, "SCM Dummy function should never be called!\n" ));
    orpcthat->flags      = 0;
    orpcthat->extensions = NULL;
    return E_FAIL;
}

//+-------------------------------------------------------------------------
//
//  Function:   Dummy3
//
//  Synopsis:   Needed for IDL hack.  Never called.
//
//  Arguments:  [hRpc] - RPC handle
//              [orpcthis] - ORPC handle
//              [localthis] - ORPC call data
//              [orpcthat] - ORPC reply data
//
//  Returns:    HRESULT
//
//  History:    14 Apr 95   AlexMit    Created
//
//--------------------------------------------------------------------------
extern "C" HRESULT DummyReleaseIOSCM(
    handle_t  hRpc,
    ORPCTHIS  *orpcthis,
    LOCALTHIS *localthis,
    ORPCTHAT *orpcthat,
    DWORD     dummy )
{
    CairoleDebugOut((DEB_ERROR, "SCM Dummy function should never be called!\n" ));
    orpcthat->flags      = 0;
    orpcthat->extensions = NULL;
    return E_FAIL;
}

//+-------------------------------------------------------------------------
//
//  Function:   ServerRegisterClsid
//
//  Synopsis:   Notifies SCM that server is started for a class
//
//  Arguments:  [hRpc] - RPC handle
//              [phProcess] - context handle
//              [lpDeskTop] - caller's desktop
//              [pregin] - array of registration entries
//              [ppregout] - array of registration cookies to return
//              [rpcstat] - status code
//
//  Returns:    HRESULT
//
//  History:    01-May-93 Ricksa    Created
//
//--------------------------------------------------------------------------
extern "C" HRESULT ServerRegisterClsid(
    handle_t hRpc,
    PHPROCESS phProcess,
    RegInput *pregin,
    RegOutput **ppregout,
    error_status_t *rpcstat)
{
    CProcess *          pProcess;
    RegOutput *         pregout;
    CServerTableEntry *  pClassTableEntry;
    CClsidData *        pClsidData = NULL;
    DWORD               Size, Entries, i;
    UCHAR               ServerState;
    LONG                Status;
    HRESULT             hr;
	HANDLE*             phRegisterEvents = NULL; 

    CheckLocalCall( hRpc );
	
    // Parameter validation
    if (!pregin || !ppregout || !rpcstat)
        return E_INVALIDARG;

    *rpcstat = 0;
    *ppregout = 0;

    pProcess = ReferenceProcess( phProcess, TRUE );
    if ( ! pProcess )
        return E_ACCESSDENIED;

	// Allocate an array of handles to hold the register events.
    phRegisterEvents = (HANDLE*)alloca(sizeof(HANDLE) * pregin->dwSize);
    memset(phRegisterEvents, 0, sizeof(HANDLE) * pregin->dwSize);

    Size = sizeof(RegOutput) + (pregin->dwSize - 1) * sizeof(DWORD);
    *ppregout = (RegOutput *) PrivMemAlloc(Size);

    if ( ! *ppregout )
    {
        ReleaseProcess( pProcess );
        return E_OUTOFMEMORY;
    }

    pregout = *ppregout;
    memset( pregout, 0, Size );
    pregout->dwSize = pregin->dwSize;

    Entries = pregin->dwSize;

    //
    // First loop, we add all of the registrations.
    //
    for ( i = 0; i < Entries; i++ )
    {
        pClsidData = 0;

#ifndef _CHICAGO_
        // This path taken by non-COM+ servers, ergo 
	// no IComClassinfo 
	(void) LookupClsidData(
                    pregin->rginent[i].clsid,
		    NULL,
                    pProcess->GetToken(),
                    LOAD_APPID,
                    &pClsidData );

        //
        // Check that the caller is allowed to register this CLSID.
        //
        if ( pClsidData && ! pClsidData->CertifyServer( pProcess ) )
        {
            delete pClsidData;
            hr = CO_E_WRONG_SERVER_IDENTITY;
            break;
        }
#endif
		
        //
        // Get the register event for this clsid, to be signalled later on
        // in the second loop below.   If we couldn't find a pClsidData for
		// this clsid, that's fine it just means it was a registration for
		// an unknown clsid (which is legal).
        //
		if (pClsidData)
		{
			phRegisterEvents[i] = pClsidData->ServerRegisterEvent();
			if (!phRegisterEvents[i])
			{
				delete pClsidData;
				hr = E_OUTOFMEMORY;
				break;
			}
		}

        ServerState = SERVERSTATE_SUSPENDED;

        // Note:  REGCLS_SINGLEUSE is *not* a bitflag, it's zero!
        // Therefore, it is incompatible with all other flags
        if ( pregin->rginent[i].dwFlags == REGCLS_SINGLEUSE )
            ServerState |= SERVERSTATE_SINGLEUSE;

        if ( pregin->rginent[i].dwFlags & REGCLS_SURROGATE )
            ServerState |= SERVERSTATE_SURROGATE;

#if 0 // #ifdef _CHICAGO_
        //
        // On Win9x, we use a notification window to do lazy registers from a
        // single threaded apartment.  We don't use the notification window if
        // this register is coming in from a resumed suspended registration.
        // This is when the overloaded REGCLS_SUSPENDED flag is set.
        //
        if ( ! (pregin->rginent[i].dwFlags | REGCLS_SUSPENDED) && IsSTAThread() )
            ServerState |= SERVERSTATE_USENOTIFYWIN;
#endif

        pClassTableEntry = gpClassTable->GetOrCreate( pregin->rginent[i].clsid );

        if ( ! pClassTableEntry )
            hr = E_OUTOFMEMORY;

        if ( pClassTableEntry )
        {
            hr = pClassTableEntry->RegisterServer(
                                        pProcess,
                                        pregin->rginent[i].ipid,
                                        pClsidData,
                                        NULL,
                                        ServerState,
                                        &pregout->RegKeys[i] );

            pClassTableEntry->Release();
        }

        if ( pClsidData )
		{
            delete pClsidData;
            pClsidData = NULL;
		}

        if ( hr != S_OK )
            break;
    }

    //
    // If we encountered any errors then we remove any entries which were
    // successfully added.
    //
    // On success, we now signal all of the class table events.
    //
    // This loop restarts itself in removal mode if it encounters an errors
    // while trying to signal the register events.
    //
    for ( i = 0; i < Entries; i++ )
    {
        HANDLE  hRegisterEvent;

        pClassTableEntry = gpClassTable->Lookup( pregin->rginent[i].clsid );

        if ( S_OK == hr )
        {
            ASSERT( pClassTableEntry );

            pClassTableEntry->UnsuspendServer( pregout->RegKeys[i] );
			
			//
			//  Signal to waiting client (if any) that this clsid is registered
			// 
			if (phRegisterEvents[i])
			{
				SetEvent(phRegisterEvents[i]);
				CloseHandle(phRegisterEvents[i]);
				phRegisterEvents[i] = 0;
			}
        }

        if ( (hr != S_OK) && pregout->RegKeys[i] )
        {
            if ( pClassTableEntry )
                pClassTableEntry->RevokeServer( pProcess, pregout->RegKeys[i] );
        }

        if ( pClassTableEntry )
            pClassTableEntry->Release();
    }

    if ( hr != S_OK )
        memset( pregout->RegKeys, 0, pregout->dwSize * sizeof(DWORD) );
	
	//
	// Release all of the registration event handles
	//
	for (i = 0; i < Entries; i++)
	{
        if (phRegisterEvents[i])
            CloseHandle(phRegisterEvents[i]);
	}

    ReleaseProcess( pProcess );

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   StopServer
//
//  Synopsis:   Get notification that class server is stopping
//
//  Arguments:  [hRpc] - RPC handle
//              [prevcls] - list of classes/registrations to stop
//
//  History:    01-May-93 Ricksa    Created
//
//--------------------------------------------------------------------------
extern "C" void ServerRevokeClsid(
    handle_t hRpc,
    PHPROCESS phProcess,
    RevokeClasses *prevcls,
    error_status_t *rpcstat)
{
    CServerTableEntry*  pClassTableEntry;
    RevokeEntry*        prevent;
    DWORD               Entries;
    CProcess*           pProcess;

    CheckLocalCall( hRpc );
	
    // Parameter validation
    if (!prevcls || !rpcstat)
        return;

    pProcess = ReferenceProcess(phProcess);
    if (!pProcess)
        return;  
		
    *rpcstat = 0;

    Entries = prevcls->dwSize;
    prevent = prevcls->revent;

    for ( ; Entries--; prevent++ )
    {
        pClassTableEntry = gpClassTable->Lookup( prevent->clsid );

        if ( pClassTableEntry )
        {
            pClassTableEntry->RevokeServer( pProcess, prevent->dwReg );
            pClassTableEntry->Release();
        }
    }
}

void GetThreadID(
    handle_t    hRpc,
    DWORD *     pThreadID,
    error_status_t *prpcstat)
{
    CheckLocalCall( hRpc );
	
    // Parameter validation
    if (!pThreadID || !prpcstat)
        return;

    *prpcstat = 0;
    *pThreadID = InterlockedExchangeAdd((long *)&gNextThreadID,1);
}

//+-------------------------------------------------------------------------
//
//  Function:   UpdateActivationSettings
//
//  Synopsis:   Re-read default activation settings.
//
//  Arguments:  [hRpc] - RPC handle
//              [prpcstat] - communication status
//
//--------------------------------------------------------------------------

#ifdef _CHICAGO_
extern HRESULT ReadRegistry();
#else
extern void ComputeSecurity();
#endif _CHICAGO_

extern "C" void UpdateActivationSettings(
    handle_t hRpc,
    error_status_t *prpcstat)
{
    CheckLocalCall( hRpc );

    // Parameter validation
    if (!prpcstat)
        return;

    *prpcstat = 0;
    ReadRemoteActivationKeys();
    ComputeSecurity();
}


//+-------------------------------------------------------------------------
//
//  Function:   VerifyCallerIsAdministrator
//
//  Synopsis:   Verifies that the specified user is an administrator
//
//  Returns:    S_OK  -- success, *pbAdmin is valid
//              other -- error occurred
//
//  Arguments:  [pToken] - token of the user
//              [pbAdmin] - out param denoting admin status
//
//--------------------------------------------------------------------------
HRESULT VerifyCallerIsAdministrator(CToken* pToken, BOOL* pbAdmin)
{
    BOOL fSuccess;
    PSID psidAdmin;
    SID_IDENTIFIER_AUTHORITY SystemSidAuthority = SECURITY_NT_AUTHORITY;
        
    // Allocate sid for Administrators
    fSuccess = AllocateAndInitializeSid(&SystemSidAuthority, 2, 
                                        SECURITY_BUILTIN_DOMAIN_RID, 
                                        DOMAIN_ALIAS_RID_ADMINS,
                                        0, 0, 0, 0, 0, 0, &psidAdmin);
    if (!fSuccess)
        return HRESULT_FROM_WIN32(GetLastError());

    // Check that caller is an admin
    fSuccess = CheckTokenMembership(pToken->GetToken(), psidAdmin, pbAdmin);
	
    FreeSid(psidAdmin);

    if (!fSuccess)
        return HRESULT_FROM_WIN32(GetLastError());

	return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   EnableDisableDynamicIPTracking
//
//  Synopsis:   Writes a "Y" or "N" to the HKLM\Software\MS\Ole\
//              EnableSystemDynamicIPTracking string value, and sets the 
//              global variable gbDynamicIPChangesEnabled accordingly.
//
//  Arguments:  [hRpc] - RPC handle
//              [phProcess] - context handle
//              [fEnable] - whether to enable or disable
//              [prpcstat] - communication status
//
//--------------------------------------------------------------------------
extern "C"
HRESULT EnableDisableDynamicIPTracking(
    handle_t hRpc,
    PHPROCESS phProcess,
    BOOL fEnable,
    error_status_t* prpcstat)
{
    HRESULT hr = S_OK;
    BOOL bAdmin;
    ORSTATUS status;

    CheckLocalCall( hRpc ); // raises exception if not

    // Parameter validation
    if (!prpcstat)
        return E_INVALIDARG;

    *prpcstat = 0;          // we got here so we are OK

    // Make sure we know who's calling
    CProcess* pProcess = ReferenceProcess(phProcess);
    if (!pProcess)
        return E_ACCESSDENIED;

    // Get token for the caller
    CToken* pToken;
    status = LookupOrCreateToken(hRpc, TRUE, &pToken);
    if (status != ERROR_SUCCESS)
        return E_ACCESSDENIED;
    
    hr = VerifyCallerIsAdministrator(pToken, &bAdmin);
    pToken->Release();
    if (FAILED(hr))
        return hr;

    if (!bAdmin)
        return E_ACCESSDENIED;

    SCMVDATEHEAP();
    
    hr = gAddrExclusionMgr.EnableDisableDynamicTracking(fEnable);

    SCMVDATEHEAP();

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetCurrentIPExclusionList
//
//  Synopsis:   Passes the contents of the current address exclusion list
//              back to the caller
//
//  Arguments:  [hRpc] - RPC handle
//              [phProcess] - context handle
//              [pdwNumStrings] - size of the pppszStrings array
//              [pppszStrings] - array of pointers to NULL-term'd strings
//              [prpcstat] - communication status
//
//--------------------------------------------------------------------------
extern "C"
HRESULT GetCurrentAddrExclusionList(
    handle_t hRpc,
    PHPROCESS phProcess,
    DWORD* pdwNumStrings,
    LPWSTR** pppszStrings,
    error_status_t* prpcstat)
{
    HRESULT hr = S_OK;
    BOOL bAdmin;
    ORSTATUS status;

    CheckLocalCall( hRpc ); // raises exception if not

    // Parameter validation
    if (!pdwNumStrings || !pppszStrings || !prpcstat)
        return E_INVALIDARG;

    *prpcstat = 0;          // we got here so we are OK

    // Make sure we know who's calling
    CProcess* pProcess = ReferenceProcess(phProcess);
    if (!pProcess)
        return E_ACCESSDENIED;

    // Get token for the caller
    CToken* pToken;
    status = LookupOrCreateToken(hRpc, TRUE, &pToken);
    if (status != ERROR_SUCCESS)
        return E_ACCESSDENIED;
    
    hr = VerifyCallerIsAdministrator(pToken, &bAdmin);
    pToken->Release();
    if (FAILED(hr))
        return hr;

    if (!bAdmin)
        return E_ACCESSDENIED;
	
    SCMVDATEHEAP();

    hr = gAddrExclusionMgr.GetExclusionList(
                    pdwNumStrings,
                    pppszStrings);         
    
    SCMVDATEHEAP();

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   SetAddrExclusionList
//
//  Synopsis:   Re-sets the contents of the address exclusion list, and updates
//              all currently running processes with the new bindings.
//
//  Arguments:  [hRpc] - RPC handle
//              [phProcess] - context handle
//              [dwNumStrings] - size of the ppszStrings array
//              [ppszStrings] - array of pointers to NULL-term'd strings
//              [prpcstat] - communication status
//
//--------------------------------------------------------------------------
extern "C"
HRESULT SetAddrExclusionList(
    handle_t hRpc,
    PHPROCESS phProcess,
    DWORD dwNumStrings,
    LPWSTR* ppszStrings,
    error_status_t* prpcstat)
{
    HRESULT hr = S_OK;
    BOOL bAdmin;
    ORSTATUS status;

    CheckLocalCall( hRpc ); // raises exception if not

    // Parameter validation
    if (!ppszStrings || !prpcstat)
        return E_INVALIDARG;

    *prpcstat = 0;          // we got here so we are OK

    // Make sure we know who's calling
    CProcess* pProcess = ReferenceProcess(phProcess);
    if (!pProcess)
        return E_ACCESSDENIED;

    // Get token for the caller
    CToken* pToken;
    status = LookupOrCreateToken(hRpc, TRUE, &pToken);
    if (status != ERROR_SUCCESS)
        return E_ACCESSDENIED;
    
    hr = VerifyCallerIsAdministrator(pToken, &bAdmin);
    pToken->Release();
    if (FAILED(hr))
        return hr;

    if (!bAdmin)
        return E_ACCESSDENIED;

    SCMVDATEHEAP();

    hr = gAddrExclusionMgr.SetExclusionList(
                    dwNumStrings,
                    ppszStrings);                             

    SCMVDATEHEAP();

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   FlushSCMBindings
//
//  Synopsis:   Remove the specified machine bindings from our remote binding
//              handle cache
//
//  Arguments:  [hRpc] - RPC handle
//              [prpcstat] - communication status
//
//--------------------------------------------------------------------------
extern "C" 
HRESULT FlushSCMBindings(
    handle_t hRpc,
    PHPROCESS phProcess,
    WCHAR* pszMachineName,
    error_status_t* prpcstat)
{
    HRESULT hr;
    BOOL bAdmin;
    ORSTATUS status;

    CheckLocalCall( hRpc ); // raises exception if not

    // Parameter validation
    if (!pszMachineName || !prpcstat)
        return E_INVALIDARG;

    *prpcstat = 0;          // we got here so we are OK

    // Make sure we know who's calling
    CProcess* pProcess = ReferenceProcess(phProcess);
    if (!pProcess)
        return E_ACCESSDENIED;

    // Get token for the caller
    CToken* pToken;
    status = LookupOrCreateToken(hRpc, TRUE, &pToken);
    if (status != ERROR_SUCCESS)
        return E_ACCESSDENIED;
    
    hr = VerifyCallerIsAdministrator(pToken, &bAdmin);
    pToken->Release();
    if (FAILED(hr))
        return hr;

    if (!bAdmin)
        return E_ACCESSDENIED;
    
    SCMVDATEHEAP();

    hr = gpRemoteMachineList->FlushSpecificBindings(pszMachineName);

    SCMVDATEHEAP();

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   RetireServer
//
//  Synopsis:   Marks the specified server as being no longer eligible for 
//              component activations of any type.   Currently only used
//              to support COM+'s process recycling feature.
//
//  Arguments:  [hRpc] - RPC handle
//              [pguidProcessIdentifier] - guid which identifies the server
//              [prpcstat] - communication status
//
//--------------------------------------------------------------------------
extern "C" 
HRESULT RetireServer(
    handle_t hRpc,
    PHPROCESS phProcess,
    GUID* pguidProcessIdentifier,
    error_status_t* prpcstat)
{
    CheckLocalCall( hRpc ); // raises exception if not

    // Parameter validation
    if (!pguidProcessIdentifier || !prpcstat)
        return E_INVALIDARG;

    *prpcstat = 0;          // we got here so we are OK

    if (!pguidProcessIdentifier)
        return E_INVALIDARG;

    // Make sure we know who's calling
    CProcess* pProcess = ReferenceProcess(phProcess);
    if (!pProcess)
        return E_ACCESSDENIED;

    // Get token for the caller
    CToken* pToken;
    ORSTATUS status;
    status = LookupOrCreateToken(hRpc, TRUE, &pToken);
    if (status != ERROR_SUCCESS)
        return E_ACCESSDENIED;

    // Make sure they're an administrator
    HRESULT hr;
    BOOL bAdmin;
    hr = VerifyCallerIsAdministrator(pToken, &bAdmin);
    pToken->Release();
    if (FAILED(hr))
        return hr;

    if (!bAdmin)
        return E_ACCESSDENIED;

    // Okay, see if we know which process they're talking about
    gpProcessListLock->LockShared();
    
    hr = E_INVALIDARG;  // review for better code when we don't find the process

    CBListIterator all_procs(gpProcessList);  
    CProcess* pprocess;
    while (pprocess = (CProcess*)all_procs.Next())
    {
        if (*pprocess->GetGuidProcessIdentifier() == *pguidProcessIdentifier)
        {
            // Found it.   Mark it as retired
            pprocess->Retire();
            hr = S_OK;
            break;
        }
    }
    
    gpProcessListLock->UnlockShared();

    return hr;
}


CWIPTable gWIPTbl;  // global instance of the class
CWIPTable * gpWIPTbl = &gWIPTbl;

//+-------------------------------------------------------------------------
//
//  Function:   CopyDualStringArray
//
//  Synopsis:   makes a copy of the given string array
//
//  History:    22-Jan-96 Rickhi    Created
//
//--------------------------------------------------------------------------
HRESULT CopyDualStringArray(DUALSTRINGARRAY *psa, DUALSTRINGARRAY **ppsaNew)
{
    ULONG ulSize = sizeof(DUALSTRINGARRAY) + (psa->wNumEntries * sizeof(WCHAR));

    *ppsaNew = (DUALSTRINGARRAY *) PrivMemAlloc(ulSize);

    if (*ppsaNew == NULL)
    {
        return E_OUTOFMEMORY;
    }

    memcpy(*ppsaNew, psa, ulSize);
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Member:     CWIPTable::AddEntry, public
//
//  Synopsis:   Adds a WIPEntry to the table.
//
//  Arguments:  [hWnd] - window handle
//              [pStd] - standard marshaled interface STDOBJREF
//              [pOxidInfo] - info needed to resolve the OXID
//              [pdwCookie] - cookie to return (to be placed on the window)
//
//  History:    22-Jan-96 Rickhi    Created
//
//--------------------------------------------------------------------------
HRESULT CWIPTable::AddEntry(
    DWORD_PTR  hWnd, 
    STDOBJREF *pStd, 
    OXID_INFO *pOxidInfo,
    DWORD_PTR *pdwCookie
    )
{
    // make a copy of the string array in the OxidInfo since MIDL will
    // delete it on the way back out of the call.

    DUALSTRINGARRAY *psaNew;
    HRESULT hr;

    if (m_fCsInitialized == FALSE)
    {
    	ASSERT(FALSE);
    	return E_OUTOFMEMORY;
    }
    
    psaNew = (DUALSTRINGARRAY *) PrivMemAlloc(sizeof(DUALSTRINGARRAY) + (pOxidInfo->psa->wNumEntries * sizeof(WCHAR)));

    if (psaNew == NULL)
    {
        return E_OUTOFMEMORY;
    }

    memcpy(psaNew, pOxidInfo->psa, sizeof(DUALSTRINGARRAY) + (pOxidInfo->psa->wNumEntries * sizeof(WCHAR)));

#if 0 // #ifdef _CHICAGO_
    CLockSmMutex lck(gWIPmxs);
#else
    CLock2 lck(s_mxs);
#endif

    // find a free slot in the table
    DWORD_PTR dwpIndex = s_iNextFree;

    if (dwpIndex == (DWORD_PTR)-1)
    {
        // grow the table
        dwpIndex = Grow();
    }

    if (dwpIndex != (DWORD_PTR)-1)
    {
        // get the pointer to the entry,
        WIPEntry *pEntry = s_pTbl + dwpIndex;

        // update the next free index.
        s_iNextFree = pEntry->hWnd;

        // copy in the data
        memcpy(&pEntry->std, pStd, sizeof(STDOBJREF));
        memcpy(&pEntry->oxidInfo, pOxidInfo, sizeof(OXID_INFO));

        pEntry->oxidInfo.psa = psaNew;
        pEntry->hWnd         = hWnd;
        pEntry->dwFlags      = WIPF_OCCUPIED;

        // set the cookie to return
        *pdwCookie = dwpIndex+5000;

        // return success
        hr = S_OK;
    }
    else
    {
        // free the allocated string array
        PrivMemFree(psaNew);
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CWIPTable::GetEntry, public
//
//  Synopsis:   Retrieves and optionally delets a WIPEntry from the table.
//
//  Arguments:  [hWnd] - window handle
//              [dwCookie] - cookie from the window
//              [pStd] - place to return STDOBJREF data
//              [pOxidInfo] - place to return info needed to resolve the OXID
//
//  History:    22-Jan-96 Rickhi    Created
//
//--------------------------------------------------------------------------
HRESULT CWIPTable::GetEntry(
    DWORD_PTR  hWnd, 
    DWORD_PTR  dwCookie, 
    BOOL       fRevoke,
    STDOBJREF *pStd,
    OXID_INFO *pOxidInfo)
{
    HRESULT hr = E_INVALIDARG;

    // validate the cookie
    DWORD_PTR dwpIndex = dwCookie - 5000;
    if (dwpIndex >= s_cEntries)
    {
        return hr;
    }

    if (m_fCsInitialized == FALSE)
    {
        ASSERT(FALSE);
    	return E_OUTOFMEMORY;
    }
    
#if 0 // #ifdef _CHICAGO_
    CLockSmMutex lck(gWIPmxs);
#else
    CLock2 lck(s_mxs);
#endif

    // get the pointer to the entry,
    WIPEntry *pEntry = s_pTbl + dwpIndex;

    // make sure the entry is occupied
    if (pEntry->dwFlags & WIPF_OCCUPIED)
    {
        DUALSTRINGARRAY *psaNew;
        psaNew = (DUALSTRINGARRAY *) PrivMemAlloc(sizeof(DUALSTRINGARRAY) + (pEntry->oxidInfo.psa->wNumEntries * sizeof(WCHAR)));

        if (psaNew == NULL)
        {
            return E_OUTOFMEMORY;
        }

        memcpy(psaNew, pEntry->oxidInfo.psa, sizeof(DUALSTRINGARRAY) + (pEntry->oxidInfo.psa->wNumEntries * sizeof(WCHAR)));

        // copy out the data to return
        memcpy(pStd, &pEntry->std, sizeof(STDOBJREF));
        memcpy(pOxidInfo, &pEntry->oxidInfo, sizeof(OXID_INFO));
        pOxidInfo->psa = psaNew;

        if (fRevoke)
        {
            // free the entry by updating the flags and the next free index
            PrivMemFree(pEntry->oxidInfo.psa);

            pEntry->dwFlags = WIPF_VACANT;
            pEntry->hWnd    = s_iNextFree;
            s_iNextFree     = dwpIndex;
        }

        // return success
        hr = S_OK;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CWIPTable::Grow, private
//
//  Synopsis:   grows the WIPTable size.
//
//  History:    22-Jan-96 Rickhi    Created
//
//--------------------------------------------------------------------------
DWORD_PTR CWIPTable::Grow()
{
    // compute the size and allocate a new table
    DWORD_PTR dwSize = (s_cEntries + WIPTBL_GROW_SIZE) * sizeof(WIPEntry);
    WIPEntry *pNewTbl = (WIPEntry *) PrivMemAlloc((size_t)dwSize);

    if (pNewTbl != NULL)
    {
        // copy the old table in
        memcpy(pNewTbl, s_pTbl, (size_t)(s_cEntries * sizeof(WIPEntry)));

        // free the old table
        if (s_pTbl)
        {
            PrivMemFree(s_pTbl);
        }

        // replace the old table ptr
        s_pTbl = pNewTbl;

        // update the free list and mark the new entries as vacant
        s_iNextFree = s_cEntries;

        WIPEntry *pNext = s_pTbl + s_cEntries;

        for (ULONG i=0; i< WIPTBL_GROW_SIZE; i++)
        {
            pNext->hWnd    = ++s_cEntries;
            pNext->dwFlags = WIPF_VACANT;
            pNext++;
        }

        (pNext-1)->hWnd = (DWORD_PTR)-1;   // last entry has END_OF_LIST marker
    }

    return s_iNextFree;
}

//+-------------------------------------------------------------------------
//
//  Function:   RegisterWindowPropInterface
//
//  Synopsis:   Associate a window property with a (standard) marshaled
//              interface.
//
//  Arguments:  [hRpc] - RPC handle
//              [hWnd] - window handle
//              [pStd] - standard marshaled interface STDOBJREF
//              [pOxidInfo] - info needed to resolve the OXID
//              [pdwCookie] - cookie to return (to be placed on the window)
//              [prpcstat] - communication status
//
//  History:    22-Jan-96 Rickhi    Created
//
//--------------------------------------------------------------------------
extern "C" HRESULT RegisterWindowPropInterface(
    handle_t       hRpc,
    DWORD_PTR      hWnd,
    STDOBJREF      *pStd,
    OXID_INFO      *pOxidInfo,
    DWORD_PTR      *pdwCookie,
    error_status_t *prpcstat)
{
    CheckLocalCall( hRpc );

    // Parameter validation
    if (!pStd || !pOxidInfo || !pOxidInfo->psa || !pdwCookie || !prpcstat)
        return E_INVALIDARG;

    *prpcstat = 0;
    CairoleDebugOut((DEB_SCM,
        "_IN RegisterWindowPropInterface hWnd:%x pStd:%x pOxidInfo:%x\n",
         hWnd, pStd, pOxidInfo));
    VDATEHEAP();

    HRESULT hr = gpWIPTbl->AddEntry(hWnd, pStd, pOxidInfo, pdwCookie);

    CairoleDebugOut((DEB_SCM, "_OUT RegisterWindowPropInterface dwCookie:%x\n",
                    *pdwCookie));
    VDATEHEAP();
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetWindowPropInterface
//
//  Synopsis:   Get the marshaled interface associated with a window property.
//
//  Arguments:  [hRpc] - RPC handle
//              [hWnd] - window handle
//              [dwCookie] - cookie from the window
//              [fRevoke] - whether to revoke entry or not
//              [pStd] - standard marshaled interface STDOBJREF to return
//              [pOxidInfo] - info needed to resolve the OXID
//              [prpcstat] - communication status
//
//  History:    22-Jan-96 Rickhi    Created
//
//--------------------------------------------------------------------------
extern "C" HRESULT GetWindowPropInterface(
    handle_t       hRpc,
    DWORD_PTR      hWnd,
    DWORD_PTR      dwCookie,
    BOOL           fRevoke,
    STDOBJREF      *pStd,
    OXID_INFO      *pOxidInfo,
    error_status_t *prpcstat)
{
    CheckLocalCall( hRpc );

    // Parameter validation
    if (!pStd || !pOxidInfo || !prpcstat)
        return E_INVALIDARG;

    *prpcstat = 0;
    CairoleDebugOut((DEB_SCM,
        "_IN GetWindowPropInterface hWnd:%x dwCookie:%x fRevoke:%x\n",
             hWnd, dwCookie, fRevoke));
    VDATEHEAP();

    HRESULT hr = gpWIPTbl->GetEntry(hWnd, dwCookie, fRevoke, pStd, pOxidInfo);

    CairoleDebugOut((DEB_SCM,
        "_OUT GetWindowPropInterface pStd:%x pOxidInfo:%x\n", pStd, pOxidInfo));
    VDATEHEAP();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\olescm\security.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       security.cxx
//
//  Contents:
//
//--------------------------------------------------------------------------

#include "act.hxx"

// the constant generic mapping structure
GENERIC_MAPPING  sGenericMapping = {
        READ_CONTROL,
        READ_CONTROL,
        READ_CONTROL,
        READ_CONTROL};

//-------------------------------------------------------------------------
//
// CheckForAccess
//
// Checks whether the given token has COM_RIGHTS_EXECUTE access in the
// given security descriptor.
//
//-------------------------------------------------------------------------
BOOL
CheckForAccess(
    IN  CToken *                pToken,
    IN  SECURITY_DESCRIPTOR *   pSD
    )
{
    // if we have an empty SD, deny everyone
    if ( ! pSD )
        return FALSE;

    //
    // pToken is NULL during an unsecure activation, in which case we check
    // if EVERYONE is granted access in the security descriptor.
    //
    if ( pToken )
    {
        HANDLE           hToken   = pToken->GetToken();
        BOOL             fAccess  = FALSE;
        BOOL             fSuccess = FALSE;
        DWORD            dwGrantedAccess;
        PRIVILEGE_SET    sPrivilegeSet;
        DWORD            dwSetLen = sizeof( sPrivilegeSet );

        sPrivilegeSet.PrivilegeCount = 1;
        sPrivilegeSet.Control        = 0;

        fSuccess = AccessCheck( (PSECURITY_DESCRIPTOR) pSD,
                                hToken,
                                COM_RIGHTS_EXECUTE,
                                &sGenericMapping,
                                &sPrivilegeSet,
                                &dwSetLen,
                                &dwGrantedAccess,
                                &fAccess );

        if ( fSuccess && fAccess )
            return TRUE;

        if ( !fSuccess )
        {
            CairoleDebugOut((DEB_ERROR, "Bad Security Descriptor 0x%08x, Access Check returned 0x%x\n", pSD, GetLastError() ));
        }

        return FALSE;
    }
    else
    {
        BOOL                bStatus;
        BOOL                bDaclPresent;
        BOOL                bDaclDefaulted;
        DWORD               Index;
        HRESULT             hr;
        PACL                pDacl;
        PACCESS_ALLOWED_ACE pAllowAce;
        SID                 SidEveryone = { SID_REVISION,
                                            1,
                                            SECURITY_WORLD_SID_AUTHORITY,
                                            0 };

        pDacl = 0;

        bStatus = GetSecurityDescriptorDacl(
                        (void *)pSD,
                        &bDaclPresent,
                        &pDacl,
                        &bDaclDefaulted );

        if ( ! bStatus )
            return FALSE;

        // Bug 95306: Can assume dacl exists only if both
        //            bDaclPresent is TRUE and pDacl is not NULL
        if ( (!pDacl) || (!bDaclPresent) )
            return TRUE;

        bStatus = FALSE;

        for ( Index = 0; Index < pDacl->AceCount; Index++ )
        {
            if ( ! GetAce( pDacl, Index, (void **) &pAllowAce ) )
                break;

            if ( pAllowAce->Header.AceType != ACCESS_ALLOWED_ACE_TYPE )
                continue;

            if ( ! (pAllowAce->Mask & COM_RIGHTS_EXECUTE) )
                continue;

            if ( EqualSid( (PSID)(&pAllowAce->SidStart), &SidEveryone ) )
            {
                bStatus = TRUE;
                break;
            }
        }

        return bStatus;
    }
}


HANDLE
GetRunAsToken(
    DWORD   clsctx,
    WCHAR   *pwszAppID,
    WCHAR   *pwszRunAsDomainName,
    WCHAR   *pwszRunAsUserName )
{
    LSA_OBJECT_ATTRIBUTES sObjAttributes;
    HANDLE                hPolicy = NULL;
    LSA_UNICODE_STRING    sKey;
    WCHAR                 wszKey[CLSIDSTR_MAX+5];
    PLSA_UNICODE_STRING   psPassword;
    HANDLE                hToken;


    if ( !pwszAppID )
    {
        // if we have a RunAs, we'd better have an appid....
        return 0;
    }

    // formulate the access key
    lstrcpyW(wszKey, L"SCM:");
    lstrcatW(wszKey, pwszAppID );

    // UNICODE_STRING length fields are in bytes and include the NULL
    // terminator
    sKey.Length              = (USHORT)((lstrlenW(wszKey) + 1) * sizeof(WCHAR));
    sKey.MaximumLength       = (CLSIDSTR_MAX + 5) * sizeof(WCHAR);
    sKey.Buffer              = wszKey;

    // Open the local security policy
    InitializeObjectAttributes(&sObjAttributes, NULL, 0L, NULL, NULL);
    if (!NT_SUCCESS(LsaOpenPolicy(NULL, &sObjAttributes,
                                  POLICY_GET_PRIVATE_INFORMATION, &hPolicy)))
    {
        return 0;
    }

    // Read the user's password
    if (!NT_SUCCESS(LsaRetrievePrivateData(hPolicy, &sKey, &psPassword)))
    {
        LsaClose(hPolicy);
        return 0;
    }

    // Close the policy handle, we're done with it now.
    LsaClose(hPolicy);

    // Possible for LsaRetrievePrivateData to return success but with a NULL
    // psPassword.   If this happens we fail.
    if (!psPassword)
    {
        return 0;
    }

    // Log the specifed user on
    if (!LogonUserW(pwszRunAsUserName, pwszRunAsDomainName, psPassword->Buffer,
                   LOGON32_LOGON_BATCH, LOGON32_PROVIDER_DEFAULT, &hToken))
    {
        memset(psPassword->Buffer, 0, psPassword->Length);
        LsaFreeMemory( psPassword );

        // a-sergiv (Sergei O. Ivanov), 6-17-99
        // Fix for com+ 9383/nt 272085

        // Apply event filters
        DWORD dwActLogLvl = GetActivationFailureLoggingLevel();
        if(dwActLogLvl == 2)
            return 0;
        if(dwActLogLvl != 1 && clsctx & CLSCTX_NO_FAILURE_LOG)
            return 0;

        // for this message,
        // %1 is the error number string
        // %2 is the domain name
        // %3 is the user name
        // %4 is the CLSID
        HANDLE  LogHandle;
        LPWSTR  Strings[4]; // array of message strings.
        WCHAR   wszErrnum[20];
        WCHAR   wszClsid[GUIDSTR_MAX];

        // Save the error number
        wsprintf(wszErrnum, L"%lu",GetLastError() );
        Strings[0] = wszErrnum;

        // Put in the RunAs identity
        Strings[1] = pwszRunAsDomainName;
        Strings[2] = pwszRunAsUserName;

        // Get the clsid
        Strings[3] = pwszAppID;

        // Get the log handle, then report then event.
        LogHandle = RegisterEventSource( NULL,
                                          SCM_EVENT_SOURCE );

        if ( LogHandle )
            {
            ReportEvent( LogHandle,
                         EVENTLOG_ERROR_TYPE,
                         0,             // event category
                         EVENT_RPCSS_RUNAS_CANT_LOGIN,
                         NULL,          // SID
                         4,             // 4 strings passed
                         0,             // 0 bytes of binary
                         (LPCTSTR *)Strings, // array of strings
                         NULL );        // no raw data

            // clean up the event log handle
            DeregisterEventSource(LogHandle);
            }

        return 0;
    }

    // Clear the password
    memset(psPassword->Buffer, 0, psPassword->Length);
    LsaFreeMemory( psPassword );

    return hToken;
}


/***************************************************************************\
* CreateAndSetProcessToken
*
* Set the primary token of the specified process
* If the specified token is NULL, this routine does nothing.
*
* It assumed that the handles in ProcessInformation are the handles returned
* on creation of the process and therefore have all access.
*
* Returns TRUE on success, FALSE on failure.
*
* 01-31-91 Davidc   Created.
* 31-Mar-94 AndyH   Started from Winlogon; added SetToken
\***************************************************************************/

BOOL
CreateAndSetProcessToken(
    PPROCESS_INFORMATION ProcessInformation,
    HANDLE hUserToken,
    PSID psidUserSid
    )
{
    NTSTATUS NtStatus, NtAdjustStatus;
    PROCESS_ACCESS_TOKEN PrimaryTokenInfo;
    HANDLE hTokenToAssign;
    OBJECT_ATTRIBUTES ObjectAttributes;
    BOOLEAN fWasEnabled;
    PSECURITY_DESCRIPTOR psdNewProcessTokenSD;

    //
    // Check for a NULL token. (No need to do anything)
    // The process will run in the parent process's context and inherit
    // the default ACL from the parent process's token.
    //
    if (hUserToken == NULL) {
        return(TRUE);
    }

    //
    // Create the security descriptor that we want to put in the Token.
    // Need to destroy it before we leave this function.
    //

    CAccessInfo     AccessInfo(psidUserSid);

    psdNewProcessTokenSD = AccessInfo.IdentifyAccess(
            FALSE,
            TOKEN_ADJUST_PRIVILEGES | TOKEN_ADJUST_GROUPS |
            TOKEN_ADJUST_DEFAULT | TOKEN_QUERY |
            TOKEN_DUPLICATE | TOKEN_IMPERSONATE | READ_CONTROL,
            TOKEN_QUERY
            );

    if (psdNewProcessTokenSD == NULL)
    {
        CairoleDebugOut((DEB_ERROR, "Failed to create SD for process token\n"));
        return(FALSE);
    }

    //
    // A primary token can only be assigned to one process.
    // Duplicate the logon token so we can assign one to the new
    // process.
    //

    InitializeObjectAttributes(
                 &ObjectAttributes,
                 NULL,
                 0,
                 NULL,
                 psdNewProcessTokenSD
                 );


    NtStatus = NtDuplicateToken(
                 hUserToken,         // Duplicate this token
                 TOKEN_ASSIGN_PRIMARY, // Give me this access to the resulting token
                 &ObjectAttributes,
                 FALSE,             // EffectiveOnly
                 TokenPrimary,      // TokenType
                 &hTokenToAssign     // Duplicate token handle stored here
                 );

    if (!NT_SUCCESS(NtStatus)) {
        CairoleDebugOut((DEB_ERROR, "CreateAndSetProcessToken failed to duplicate primary token for new user process, status = 0x%lx\n", NtStatus));
        return(FALSE);
    }

    //
    // Set the process's primary token
    //


    //
    // Enable the required privilege
    //

    NtStatus = RtlAdjustPrivilege(SE_ASSIGNPRIMARYTOKEN_PRIVILEGE, TRUE,
                                FALSE, &fWasEnabled);
    if (NT_SUCCESS(NtStatus)) {

        PrimaryTokenInfo.Token  = hTokenToAssign;
        PrimaryTokenInfo.Thread = ProcessInformation->hThread;

        NtStatus = NtSetInformationProcess(
                    ProcessInformation->hProcess,
                    ProcessAccessToken,
                    (PVOID)&PrimaryTokenInfo,
                    (ULONG)sizeof(PROCESS_ACCESS_TOKEN)
                    );

        //
        // if we just started the Shared WOW, the handle we get back
        // is really just a handle to an event.
        //

        if (STATUS_OBJECT_TYPE_MISMATCH == NtStatus)
        {
            HANDLE hRealProcess = OpenProcess(
                PROCESS_SET_INFORMATION | PROCESS_TERMINATE | SYNCHRONIZE,
                FALSE,
                ProcessInformation->dwProcessId);

            if (hRealProcess)
            {
                NtStatus = NtSetInformationProcess(
                            hRealProcess,
                            ProcessAccessToken,
                            (PVOID)&PrimaryTokenInfo,
                            (ULONG)sizeof(PROCESS_ACCESS_TOKEN)
                            );
               CloseHandle(hRealProcess);
            }
        }

        //
        // Restore the privilege to its previous state
        //

        NtAdjustStatus = RtlAdjustPrivilege(SE_ASSIGNPRIMARYTOKEN_PRIVILEGE,
                                          fWasEnabled, FALSE, &fWasEnabled);
        if (!NT_SUCCESS(NtAdjustStatus)) {
            CairoleDebugOut((DEB_ERROR, "failed to restore assign-primary-token privilege to previous enabled state\n"));
        }

        if (NT_SUCCESS(NtStatus)) {
            NtStatus = NtAdjustStatus;
        }
    } else {
        CairoleDebugOut((DEB_ERROR, "failed to enable assign-primary-token privilege\n"));
    }

    //
    // We're finished with the token handle and the SD
    //

    CloseHandle(hTokenToAssign);


    if (!NT_SUCCESS(NtStatus)) {
        CairoleDebugOut((DEB_ERROR, "CreateAndSetProcessToken failed to set primary token for new user process, Status = 0x%lx\n", NtStatus));
    }

    return (NT_SUCCESS(NtStatus));
}


BOOL
DuplicateTokenForSessionUse(
    HANDLE hUserToken,
    HANDLE *hDuplicate
    )

{
    OBJECT_ATTRIBUTES ObjectAttributes;
    PSECURITY_DESCRIPTOR psdNewProcessTokenSD;
    NTSTATUS NtStatus;

    if (hUserToken == NULL) {
        return(TRUE);
    }

    *hDuplicate = NULL;
    

    InitializeObjectAttributes(
                 &ObjectAttributes,
                 NULL,
                 0,
                 NULL,
                 NULL
                 );


    NtStatus = NtDuplicateToken(
                 hUserToken,         // Duplicate this token
                 TOKEN_ALL_ACCESS, //Give me this access to the resulting token
                 &ObjectAttributes,
                 FALSE,             // EffectiveOnly
                 TokenPrimary,      // TokenType
                 hDuplicate     // Duplicate token handle stored here
                 );

    if (!NT_SUCCESS(NtStatus)) {
        CairoleDebugOut((DEB_ERROR, "CreateAndSetProcessToken failed to duplicate primary token for new user process, status = 0x%lx\n", NtStatus));
        return(FALSE);
    }
    return TRUE;
}

/***************************************************************************\
* GetUserSid
*
* Allocs space for the user sid, fills it in and returns a pointer.
* The sid should be freed by calling DeleteUserSid.
*
* Note the sid returned is the user's real sid, not the per-logon sid.
*
* Returns pointer to sid or NULL on failure.
*
* History:
* 26-Aug-92 Davidc      Created.
* 31-Mar-94 AndyH       Copied from Winlogon, changed arg from pGlobals
\***************************************************************************/
PSID
GetUserSid(
    HANDLE hUserToken
    )
{
    BYTE achBuffer[100];
    PTOKEN_USER pUser = (PTOKEN_USER) &achBuffer;
    PSID pSid;
    DWORD dwBytesRequired;
    NTSTATUS NtStatus;
    BOOL fAllocatedBuffer = FALSE;

    NtStatus = NtQueryInformationToken(
                 hUserToken,                // Handle
                 TokenUser,                 // TokenInformationClass
                 pUser,                     // TokenInformation
                 sizeof(achBuffer),         // TokenInformationLength
                 &dwBytesRequired           // ReturnLength
                 );

    if (!NT_SUCCESS(NtStatus))
    {
        if (NtStatus != STATUS_BUFFER_TOO_SMALL)
        {
            Win4Assert(NtStatus == STATUS_BUFFER_TOO_SMALL);
            return NULL;
        }

        //
        // Allocate space for the user info
        //

        pUser = (PTOKEN_USER) PrivMemAlloc(dwBytesRequired);
        if (pUser == NULL)
        {
            CairoleDebugOut((DEB_ERROR, "Failed to allocate %d bytes\n", dwBytesRequired));
            Win4Assert(pUser != NULL);
            return NULL;
        }

        fAllocatedBuffer = TRUE;

        //
        // Read in the UserInfo
        //

        NtStatus = NtQueryInformationToken(
                     hUserToken,                // Handle
                     TokenUser,                 // TokenInformationClass
                     pUser,                     // TokenInformation
                     dwBytesRequired,           // TokenInformationLength
                     &dwBytesRequired           // ReturnLength
                     );

        if (!NT_SUCCESS(NtStatus))
        {
            CairoleDebugOut((DEB_ERROR, "Failed to query user info from user token, status = 0x%lx\n", NtStatus));
            Win4Assert(NtStatus == STATUS_SUCCESS);
            PrivMemFree((HANDLE)pUser);
            return NULL;
        }
    }


    // Alloc buffer for copy of SID

    dwBytesRequired = RtlLengthSid(pUser->User.Sid);
    pSid = (PSID) PrivMemAlloc(dwBytesRequired);
    if (pSid == NULL)
    {
        CairoleDebugOut((DEB_ERROR, "Failed to allocate %d bytes\n", dwBytesRequired));
        if (fAllocatedBuffer == TRUE)
        {
            PrivMemFree((HANDLE)pUser);
        }
        return NULL;
    }

    // Copy SID

    NtStatus = RtlCopySid(dwBytesRequired, pSid, pUser->User.Sid);
    if (fAllocatedBuffer == TRUE)
    {
        PrivMemFree((HANDLE)pUser);
    }


    if (!NT_SUCCESS(NtStatus))
    {
        CairoleDebugOut((DEB_ERROR, "RtlCopySid failed, status = 0x%lx\n", NtStatus));
        Win4Assert(NtStatus != STATUS_SUCCESS);
        PrivMemFree(pSid);
        pSid = NULL;
    }


    return pSid;
}

// Initialzed in InitializeSCM during boot.
CRITICAL_SECTION    ShellQueryCS;

HANDLE GetShellProcessToken(
    ULONG ulSessionId
    )
{
    NTSTATUS            NtStatus;
    BOOL                bStatus;
    HKEY                hReg;
    LONG                RegStatus;
    DWORD               RegSize, RegType;
    WCHAR *             pwszImageName;
    WCHAR *             pwszSearch;
    WCHAR *             pwszNext;
    WCHAR *             pNull;
    DWORD               Pid;
    DWORD               n;
    BYTE                StackInfoBuffer[4096];
    PBYTE               pProcessInfoBuffer;
    ULONG               ProcessInfoBufferSize;
    ULONG               TotalOffset;
    HANDLE              hProcess;
    HANDLE              hToken;
    PSYSTEM_PROCESS_INFORMATION pProcessInfo;

    static HANDLE       hShellProcess = 0;
    static HANDLE       hShellProcessToken = 0;
    static WCHAR *      pwszShellRegValue = 0;
    static WCHAR **     apwszShells = 0;
    static DWORD        nShells = 0;

    EnterCriticalSection( &ShellQueryCS );

    if ( ! pwszShellRegValue )
    {
        nShells = 0;

        //
        // This code follows logic similar to userinit for finding the name of
        // the shell process.
        //

        RegStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                  L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon",
                                  0,
                                  KEY_READ,
                                  &hReg );

        if ( ERROR_SUCCESS == RegStatus )
        {
            RegStatus = ReadStringValue( hReg, L"Shell", &pwszShellRegValue );
            RegCloseKey( hReg );
        }

        if ( RegStatus != ERROR_SUCCESS )
            pwszShellRegValue = L"explorer.exe";

        pwszSearch = pwszShellRegValue;

        for ( ;; )
        {
            if ( ! FindExeComponent( pwszSearch, L" ,", &pNull, &pwszNext ) )
                break;

            nShells++;

            while ( *pwszNext && *pwszNext != L',' )
                pwszNext++;

            pwszSearch = pwszNext;
        }

        apwszShells = (WCHAR **) PrivMemAlloc( nShells * sizeof(WCHAR **) );

        if ( ! apwszShells )
        {
            LeaveCriticalSection( &ShellQueryCS );
            return NULL;
        }

        for ( pwszSearch = pwszShellRegValue, n = 0; n < nShells; n++ )
        {
            FindExeComponent( pwszSearch, L" ,", &apwszShells[n], &pwszNext );

            pNull = pwszNext;

            while ( *pwszNext && *pwszNext != L',' )
                pwszNext++;

            //
            // When using the const string L"explorer.exe" we can't
            // automatically write a null or we'll AV on the read only memory.
            //
            if ( *pNull )
                *pNull = 0;

            pwszSearch = pwszNext;
        }
    }

    //
    // Make sure the shell process is still alive before using its token.
    //
    if ( hShellProcess && !ulSessionId )
    {
        if ( WaitForSingleObject( hShellProcess, 0 ) == WAIT_TIMEOUT )
        {
            LeaveCriticalSection( &ShellQueryCS );
            return hShellProcessToken;
        }

        CloseHandle( hShellProcessToken );
        CloseHandle( hShellProcess );

        hShellProcessToken = 0;
        hShellProcess = 0;
    }

    Pid = 0;

    pProcessInfoBuffer = StackInfoBuffer;
    ProcessInfoBufferSize = sizeof(StackInfoBuffer);

    for (;;)
    {
        NtStatus = NtQuerySystemInformation( SystemProcessInformation,
                                             pProcessInfoBuffer,
                                             ProcessInfoBufferSize,
                                             NULL );

        if ( NtStatus == STATUS_INFO_LENGTH_MISMATCH )
        {
            ProcessInfoBufferSize += 4096;
            if ( pProcessInfoBuffer != StackInfoBuffer )
                PrivMemFree( pProcessInfoBuffer );
            pProcessInfoBuffer = (PBYTE) PrivMemAlloc( ProcessInfoBufferSize );
            if ( ! pProcessInfoBuffer )
                goto AllDone;
            continue;
        }

        if ( ! NT_SUCCESS(NtStatus) )
            goto AllDone;

        break;
    }

    pProcessInfo = (PSYSTEM_PROCESS_INFORMATION) pProcessInfoBuffer;
    TotalOffset = 0;

    for (;;)
    {
        if ( pProcessInfo->ImageName.Buffer &&
             ( pProcessInfo->SessionId == ulSessionId ) )
        {
            pwszImageName = &pProcessInfo->ImageName.Buffer[pProcessInfo->ImageName.Length / sizeof(WCHAR)];

            while ( (pwszImageName != pProcessInfo->ImageName.Buffer) &&
                    (pwszImageName[-1] != '\\') )
                pwszImageName--;

            for ( n = 0; n < nShells; n++ )
            {
                if ( lstrcmpiW( apwszShells[n], pwszImageName ) == 0 )
                {
                    Pid = PtrToUlong(pProcessInfo->UniqueProcessId);
                    break;
                }
            }
        }

        if ( pProcessInfo->NextEntryOffset == 0 )
            break;

        TotalOffset += pProcessInfo->NextEntryOffset;
        pProcessInfo = (PSYSTEM_PROCESS_INFORMATION) &pProcessInfoBuffer[TotalOffset];
    }

AllDone:

    if ( pProcessInfoBuffer != StackInfoBuffer )
        PrivMemFree( pProcessInfoBuffer );

    hProcess = 0;
    hToken = 0;

    if ( Pid != 0 )
    {
        hProcess = OpenProcess( PROCESS_ALL_ACCESS,
                                FALSE,
                                Pid );

        if ( hProcess )
        {
            bStatus = OpenProcessToken( hProcess,
                                        TOKEN_ALL_ACCESS,
                                        &hToken );
            if ( !bStatus ) {
                CloseHandle( hProcess );
                hProcess = 0;
                hToken = 0;
            }
        }
    }

    if ( ulSessionId )
    {
        if ( hProcess )
            CloseHandle( hProcess );

        LeaveCriticalSection( &ShellQueryCS );

        return hToken;
    }

    hShellProcess = hProcess;
    hShellProcessToken = hToken;

    LeaveCriticalSection( &ShellQueryCS );

    // Callers should not close this token unless they want to hose us!
    return hShellProcessToken;
}


// Global default launch permissions
CSecDescriptor* gpDefaultLaunchPermissions;


CSecDescriptor*
GetDefaultLaunchPermissions()
{
    CSecDescriptor* pSD = NULL;

    gpClientLock->LockShared();
    
    pSD = gpDefaultLaunchPermissions;
    if (pSD)
        pSD->IncRefCount();

    gpClientLock->UnlockShared();

    return pSD;
}

void
SetDefaultLaunchPermissions(CSecDescriptor* pNewLaunchPerms)
{
    CSecDescriptor* pOldSD = NULL;

    gpClientLock->LockExclusive();
    
    pOldSD = gpDefaultLaunchPermissions;
    gpDefaultLaunchPermissions = pNewLaunchPerms;
    if (gpDefaultLaunchPermissions)
        gpDefaultLaunchPermissions->IncRefCount();

    gpClientLock->UnlockExclusive();

    if (pOldSD)
        pOldSD->DecRefCount();

    return;
}

    
CSecDescriptor::CSecDescriptor(SECURITY_DESCRIPTOR* pSD) : _lRefs(1)
{
    ASSERT(pSD);
    _pSD = pSD;   // we own it now
}

CSecDescriptor::~CSecDescriptor()
{
    ASSERT(_lRefs == 0);
    ASSERT(_pSD);
    PrivMemFree(_pSD);
}

void CSecDescriptor::IncRefCount()
{
    ASSERT(_lRefs > 0);
    LONG lRefs = InterlockedIncrement(&_lRefs);
}

void CSecDescriptor::DecRefCount()
{
    ASSERT(_lRefs > 0);
    LONG lRefs = InterlockedDecrement(&_lRefs);
    if (lRefs == 0)
    {
        delete this;
    }
}

SECURITY_DESCRIPTOR* CSecDescriptor::GetSD() 
{
    ASSERT(_pSD);
    ASSERT(_lRefs > 0);
    return _pSD;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\olescm\srothint.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       srothint.cxx
//
//  Contents:   Implementation of classes used in implementing the ROT hint
//              table in the SCM.
//
//  History:    20-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------

#include "act.hxx"

//+-------------------------------------------------------------------------
//
//  Member:     CScmRotHintTable::CScmRotHintTable
//
//  Synopsis:   Create SCM ROT hint table
//
//  Arguments:  [pwszName] - name for shared memory
//              [psid] - security ID
//
//  Algorithm:  Create and map in shared memory for the hint table
//
//  History:    20-Jan-95 Ricksa    Created
//
//--------------------------------------------------------------------------
CScmRotHintTable::CScmRotHintTable(WCHAR *pwszName)
{
#ifndef _CHICAGO_
    BOOL fCreated;
    PSECURITY_DESCRIPTOR pRotSecurityDescriptor = NULL;
    SID_IDENTIFIER_AUTHORITY SidAuthWorld = SECURITY_WORLD_SID_AUTHORITY;
    PSID pSid;

    pSid = 0;

    fCreated = AllocateAndInitializeSid(
                &SidAuthWorld, 1, 0, 0, 0, 0, 0, 0, 0, 0, &pSid );

    Win4Assert(fCreated && "CRotHintTable::CRotHintTable No SID");

    if ( ! fCreated || ! pSid )
        return;

    CAccessInfo AccessInfo(pSid);

    pRotSecurityDescriptor = AccessInfo.IdentifyAccess (
        TRUE,
        FILE_MAP_READ,
        FILE_MAP_ALL_ACCESS
        );

    _hSm = CreateSharedFileMapping(pwszName,
          SCM_HASH_SIZE,
          SCM_HASH_SIZE,
          NULL,
          pRotSecurityDescriptor,
          PAGE_READWRITE,
          (void **) &_pbHintArray,
          &fCreated);

    Win4Assert(_hSm && "CRotHintTable::CRotHintTable create SM failed");
    Win4Assert(fCreated && "CRotHintTable::CRotHintTable Memory not created");

    FreeSid( pSid );

    if (_pbHintArray != NULL)
    {
        memset(_pbHintArray, 0, SCM_HASH_SIZE);
    }
#endif // _CHICAGO_
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\olescm\servers.cxx ===
/*++

Copyright (c) 1995-1997 Microsoft Corporation

Module Name:

    servers.cxx

Abstract:


Author:


Revision History:

--*/

#include "act.hxx"

// Maximum number of times we will let the server tell us we are busy
#define MAX_BUSY_RETRIES 3

// Maximum number of times we will let the server tell us it has rejected
// the call, and the sleep time between retries.
#define MAX_REJECT_RETRIES  10
#define DELAYTIME_BETWEEN_REJECTS   1500    // 1.5 seconds

extern InterfaceData *AllocateAndCopy(InterfaceData *pifdIn);


BOOL
CServerList::InList(
    IN  CServerListEntry *  pServerListEntry
    )
{
    CListElement * pEntry;

    for ( pEntry = First(); pEntry; pEntry = pEntry->Next() )
        if ( pEntry == (CListElement *) pServerListEntry )
            return TRUE;

    return FALSE;
}

CServerListEntry::CServerListEntry(
    IN  CServerTableEntry *  pServerTableEntry,
    IN  CProcess *          pServerProcess,
    IN  IPID                ipid,
    IN  UCHAR               Context,
    IN  UCHAR               State,
	IN  UCHAR               SubContext
    )
{
    _pServerTableEntry = pServerTableEntry;
    _pServerTableEntry->Reference();

    // This process was already validated in ServerRegisterClsid.
    _pServerProcess = ReferenceProcess( pServerProcess, TRUE );

    _ipid = ipid;
    _hRpc = 0;
    _hRpcAnonymous = 0;
    _Context = Context;
    _SubContext = SubContext;
    _State = State;
    _NumCalls = 0;
    _lThreadToken = 0;
    _lSingleUseStatus = SINGLE_USE_AVAILABLE;  
    _dwServerFaults = 0;

    //
    // Get a unique registration number without taking a global lock.
    // Remember that gRegisterKey uses interlocked increment for ++.
    //
    for (;;)
    {
        _RegistrationKey = (DWORD) gRegisterKey;
        gRegisterKey++;
        if ( (_RegistrationKey + 1) == (DWORD) gRegisterKey )
            break;
    }
}

CServerListEntry::~CServerListEntry()
{
    ASSERT( (Previous() == NULL) && (Next() == NULL) );
	
    ASSERT(_lSingleUseStatus == SINGLE_USE_AVAILABLE || 
           _lSingleUseStatus == SINGLE_USE_TAKEN);
	
    ReleaseProcess( _pServerProcess );
    _pServerTableEntry->Release();

    if ( _hRpc )
        RpcBindingFree( &_hRpc );

    if ( _hRpcAnonymous )
        RpcBindingFree( &_hRpcAnonymous );
}

HANDLE
CServerListEntry::RpcHandle(
    IN  BOOL bAnonymous
    )
{
    HANDLE  hRpc;
    DWORD   Status;

    if ( ! bAnonymous && _hRpc )
        return _hRpc;

    if ( bAnonymous && _hRpcAnonymous )
        return _hRpcAnonymous;

    hRpc = _pServerProcess->GetBindingHandle();

    if ( ! hRpc )
        return 0;

    Status = RpcBindingSetObject( hRpc, (GUID *) &_ipid );

    if ( bAnonymous && (ERROR_SUCCESS == Status) )
    {
        RPC_SECURITY_QOS    Qos;

        //
        // Note that we indicate impersonation level of identify because
        // anonymous is not supported.  However specifing no authentication
        // in SetAuthInfo will keep the server from impersonating us.
        //
        Qos.Version = RPC_C_SECURITY_QOS_VERSION;
        Qos.Capabilities = RPC_C_QOS_CAPABILITIES_DEFAULT;
        Qos.ImpersonationType = RPC_C_IMP_LEVEL_IDENTIFY;
        Qos.IdentityTracking = RPC_C_QOS_IDENTITY_STATIC;

        Status = RpcBindingSetAuthInfoEx(
                        hRpc,
                        NULL,
                        RPC_C_AUTHN_LEVEL_NONE,
                        RPC_C_AUTHN_WINNT,
                        NULL,
                        0,
                        &Qos );
    }

    if ( Status != ERROR_SUCCESS)
    {
        RpcBindingFree( &hRpc );
        hRpc = 0;
    }
    else
    {
        if ( ! bAnonymous )
            _hRpc = hRpc;
        else
            _hRpcAnonymous = hRpc;
    }

    return hRpc;
}

BOOL
CServerListEntry::Match(
    IN  CToken *    pToken,
    IN  BOOL        bRemoteActivation,
	IN  BOOL        bClientImpersonating,
	IN  WCHAR*      pwszWinstaDesktop,
    IN  BOOL        bSurrogate,
    IN  LONG        lThreadToken,
    IN  LONG        lSessionID,
    IN  DWORD       pid,
    IN  DWORD       dwProcessReqType,
    IN  DWORD       dwFlags
    )
{
    ASSERT(_lSingleUseStatus == SINGLE_USE_AVAILABLE || 
           _lSingleUseStatus == SINGLE_USE_TAKEN);

    // If server is suspended, don't use it.
    if ((_State & SERVERSTATE_SUSPENDED) && !(dwFlags & MATCHFLAG_ALLOW_SUSPENDED))
        return FALSE;

    // Is the process represented by this entry retired or suspended?
    if (!_pServerProcess->AvailableForActivations())
        return FALSE;
	
    // If looking for a surrogate, only allow surrogates
    if (bSurrogate && !(_State & SERVERSTATE_SURROGATE))
        return FALSE;
    
    // Did a custom activator specify a specific process to use? 
    if (dwProcessReqType == PRT_USE_THIS)
    {
        // The rule here is, if we are not the specified process, then we
        // bail.   If we are the right guy, then that's great but then we 
        // still need to perform all subsequent checks below.   A custom
        // activator may not override our normal security checks.  
        if (_pServerProcess->GetPID() != pid)
            return FALSE;      
    }
	
    // Is this a single-use registration that has already been
    // consumed - if so, don't use.   We will check this again
    // at the bottom after all other checks have been made.  But 
    // doing so here saves us time if there are a lot of these
    // servers coming and going.
    if (_State & SERVERSTATE_SINGLEUSE)
    {
        if (_lSingleUseStatus == SINGLE_USE_TAKEN)
            return FALSE;
    }

    // If server is running as a service, no need to go further
    if (SERVER_SERVICE == _Context)
        return TRUE;
	    
    // If server is a runas, might need to do more checking (ie, for
    // interactive user servers) below
    if (SERVER_RUNAS == _Context)
        goto EndMatch;
    
    //
    // If we reached here then we are an activate-as-activator server (at
    // least til we pass the EndMatch label down below)
    //
    ASSERT(_Context == SERVER_ACTIVATOR && "Unexpected server context");
    
    //
    // If the client is anonymous, then forget it
    //
    if (!pToken)
        return FALSE;
    
    // Notes on activator-as-activator client\server identity & desktop matching:
    //
    // -- If client was remote, then only client & server identity needs to match
    // -- If client was local, and not impersonating, then both client & server
    //    identity and client\server desktop need to match
    // -- If client was local, and impersonating, then client & server identity
    //    need to match, and token luid's need to match.  
    //
    // The reason for this is that apps from NT4 and before expect that act-as-
    // activator servers will always run on the client's desktop.   If the server
    // has the same identity as the client, this is fine.   Trouble arises when the
    // client is impersonating, and we put the server on the client's desktop -
    // sometimes the newly-launched server will not have permissions to the client's
    // desktop, and hence dies a quick death.    The above rules are meant to 
    // work around this, and allow us to simulataneously accommodate both legacy apps 
    // and new apps that activate objects while impersonating.
    
    if (!bRemoteActivation && !bClientImpersonating)
    {
        ASSERT(pwszWinstaDesktop);
        if (!pwszWinstaDesktop)
            return FALSE;
		
        if (lstrcmpW(pwszWinstaDesktop, _pServerProcess->WinstaDesktop()) != 0 )
            return FALSE;
    }
    else if (!bRemoteActivation)
    {
        // By matching luids in the local\impersonation case, we can 
        // indirectly try to enforce desktops that way.
        if (S_OK != pToken->MatchTokenLuid(_pServerProcess->GetToken()))
            return FALSE;
    }

    //
    // If the client isn't us, then forget it (remember, at this point we're still
    // an activate-as-activator server)
    //
    if ( S_OK != pToken->MatchToken2(_pServerProcess->GetToken(), FALSE) )
    {
        //DbgPrint("RPCSS: ServerListEntry %p: Token did not match.\n", this);
        return FALSE;
    }

    //
    // If the client is less trusted than us, then forget it as well.
    //
    if ( gbSAFERAAAChecksEnabled )
    {
        if (S_FALSE == pToken->CompareSaferLevels(_pServerProcess->GetToken()))
        {
            DbgPrint("RPCSS: ServerListEntry %p: SAFER level did not match.\n", this);
            
            return FALSE;
        }
    }
    
EndMatch:
    BOOL bRet = FALSE;

    if (lThreadToken == _lThreadToken)
    {
        CToken* pServerToken = _pServerProcess->GetToken();
        ASSERT(pServerToken && "_pServerProcess did not have an associated token reference");
        
        if (pServerToken != NULL)
        {
            if (_SubContext == SUB_CONTEXT_RUNAS_INTERACTIVE)
            {
                if (lSessionID != INVALID_SESSION_ID)
                {
                    // User specified a destination session to use; check that this
                    // server is in that session
                    bRet = (pServerToken->MatchSessionID(lSessionID) == S_OK);
                }
                else
                {
                    // No dest. session specified.   The only thing left to check is
                    // if the user is local then the server we select should be in 
                    // that user's session.   If the user is not local, then this
                    // server must be in session 0 to be a match
                    if (pToken == NULL)
                    {
                        // anonymous client;  only thing to make sure is that server
                        // is running in session zero
                        bRet = (pServerToken->GetSessionId() == 0);
                    }
                    else
                    {
                        // else the server and client better be in the same session; note
                        // that if the client is from off-machine, then his session will
                        // be zero.    
                        bRet = (S_OK == pToken->MatchTokenSessionID(pServerToken));
                    }
                }
            }
            else
            {
                // Else the server is either a pure run-as server, or an activate-as-activator
                // server.   In either case, it is adequate for the activation.
                bRet = TRUE;
            }
        }
    }
	
    // If this server registered as single-use, we need to make sure 
    // no one else uses it.   The previous implementation would take
    // a write lock here and completely remove the entry from the list,
    // but I like this method better since it's more concurrent.
    if (bRet && (_State & SERVERSTATE_SINGLEUSE))
    {
        LONG lICERet;
        lICERet = InterlockedCompareExchange(&_lSingleUseStatus, 
                                             SINGLE_USE_TAKEN, 
                                             SINGLE_USE_AVAILABLE);
        if (lICERet != SINGLE_USE_AVAILABLE)                 
        {
            // Can't use this one, somebody else grabbed it
            bRet = FALSE;
        }
    }

    return bRet;
}

BOOL
CServerListEntry::CallServer(
    IN      PACTIVATION_PARAMS  pActParams,
    OUT     HRESULT *           phr )
/*--

  Notes:  jsimmons 02/10/01 -- I changed this function to return TRUE on
            most error paths.  The semantic meaning of this function's
            return value is "TRUE if we called a server or encountered a
            fatal error trying to do so".  Return values of FALSE are interpreted
            by the caller to mean "it's okay if I do a retry".   My belief
            is that we should not be doing retrys of any kind after most
            errors -- ie, a memory allocation failure should stop us dead 
            in our tracks.

--*/
{
    HANDLE          hRpc;
    DWORD           BusyRetries;
    DWORD           RejectRetries;
    BOOL            fDone;
    DWORD           CreateInstanceFlags;
    error_status_t  RpcStatus;
    
    HRESULT hr;
    
    hRpc = RpcHandle( pActParams->UnsecureActivation );
    if (!hRpc)
    {
        *phr = E_OUTOFMEMORY;
        return TRUE;
    }
    
    BusyRetries = 0;
    RejectRetries = 0;
    
    CreateInstanceFlags = 0;
#ifdef SERVER_HANDLER
    if ( pActParams->ClsContext & CLSCTX_ESERVER_HANDLER )
    {
        CreateInstanceFlags |= CREATE_EMBEDDING_SERVER_HANDLER;
        
        if ( gbDisableEmbeddingServerHandler )
        {
            CreateInstanceFlags |= DISABLE_EMBEDDING_SERVER_HANDLER;
            pActParams->pInstantiationInfo->SetInstFlag(CreateInstanceFlags);
        }
    }
#endif // SERVER_HANDLER
    
    if (!pActParams->UnsecureActivation)
    {
        BOOL fSuccess = ImpersonateLoggedOnUser( pActParams->pToken->GetToken() );
        if (!fSuccess)
        {
            *phr = HRESULT_FROM_WIN32(GetLastError());
            return TRUE;
        }
    }
    
    // Tell the server that we are using dynamic cloaking.
    pActParams->ORPCthis->flags |= ORPCF_DYNAMIC_CLOAKING;
    
    if (_State & SERVERSTATE_SURROGATE)
    {
        pActParams->pInstantiationInfo->SetIsSurrogate();
    }
    
    if (pActParams->MsgType == GETPERSISTENTINSTANCE)
    {
        Win4Assert(pActParams->pInstanceInfo != NULL);
        if (pActParams->pIFDROT)
        {
            InterfaceData *newIfd = AllocateAndCopy((InterfaceData*)pActParams->pIFDROT);
            if (newIfd == NULL)
            {                               
                if (!pActParams->UnsecureActivation)
                    RevertToSelf();
                
                *phr = E_OUTOFMEMORY;
                return TRUE;
            }
            pActParams->pInstanceInfo->SetIfdROT((MInterfacePointer*)newIfd);
        }
    }
    
    // In case treat as changed the clsid set it now
    Win4Assert(pActParams->pInstantiationInfo);
    pActParams->pInstantiationInfo->SetClsid(pActParams->Clsid);
    
    do
    {
        MInterfacePointer *pIFDIn, *pIFDOut=NULL;
        DWORD destCtx = MSHCTX_LOCAL;
        *phr = ActPropsMarshalHelper(pActParams->pActPropsIn,
                                     IID_IActivationPropertiesIn,
                                     destCtx,
                                     MSHLFLAGS_NORMAL,
                                     &pIFDIn);
        
        if (FAILED(*phr))
        {
            if (!pActParams->UnsecureActivation)
                RevertToSelf();
            return TRUE;
        }
        
        switch (pActParams->MsgType)
        {
        case GETCLASSOBJECT:
            
            *phr = LocalGetClassObject(
                            hRpc,
                            pActParams->ORPCthis,
                            pActParams->Localthis,
                            pActParams->ORPCthat,
                            pIFDIn,
                            &pIFDOut,
                            &RpcStatus );                        
            break;
            
        case GETPERSISTENTINSTANCE:
        case CREATEINSTANCE:
            
            *phr = LocalCreateInstance(
                            hRpc,
                            pActParams->ORPCthis,
                            pActParams->Localthis,
                            pActParams->ORPCthat,
                            NULL, //No punk outer from here
                            pIFDIn,
                            &pIFDOut,
                            &RpcStatus);            
            break;

        default:
            ASSERT(0 && "Unknown activation type");
            *phr = E_UNEXPECTED;
            break;           

        } //Switch
        
        MIDL_user_free(pIFDIn);
        
        if ((*phr == S_OK) && (RpcStatus == RPC_S_OK ))
        {
            // AWFUL HACK ALERT:  This is too hacky even for the SCM
            ActivationStream ActStream((InterfaceData*)
                (((BYTE*)pIFDOut)+48));
            
            pActParams->pActPropsOut = new ActivationPropertiesOut(FALSE /* fBrokenRefCount */ );
            if (pActParams->pActPropsOut != NULL)
            {
                IActivationPropertiesOut *dummy;
                hr = pActParams->pActPropsOut->UnmarshalInterface(&ActStream,
                    IID_IActivationPropertiesOut,
                    (LPVOID*)&dummy);
                if (FAILED(hr))
                {
                    pActParams->pActPropsOut->Release();
                    pActParams->pActPropsOut = NULL;
                    *phr = hr;
                }
                else
                    dummy->Release();
            }
            else
                *phr = E_OUTOFMEMORY;

            MIDL_user_free(pIFDOut);
        }
                
        // Determine if we need to retry the call. Assume not.
        fDone = TRUE;
        if (RpcStatus == RPC_S_SERVER_TOO_BUSY)
        {
            // server RPC was busy, should we retry?
            if (BusyRetries++ < MAX_BUSY_RETRIES)
                fDone = FALSE;
        }
        else if (RpcStatus == RPC_E_CALL_REJECTED)
        {
            // Take Note: this is somewhat broken, but was added as a hotfix for
            // Word Insert Excel'97 with Addins, where Excel registers it's CF
            // early then rejects calls until the addin's are ready, which could
            // take any amount of time. We give 3 tries, with a sleep between them
            // to give the app some CPU time and emulate the delay than a client
            // message filter would do.
            if (RejectRetries++ < MAX_REJECT_RETRIES)
            {
                Sleep(DELAYTIME_BETWEEN_REJECTS);
                fDone = FALSE;
            }
        }
    }
    while ( !fDone );
    
    if ( ! pActParams->UnsecureActivation )
        RevertToSelf();
    
    // A RpcStatus of ERROR_ACCESS_DENIED means the server will never
    // accept calls from this user.  Don't retry the activation.
    if (RpcStatus == ERROR_ACCESS_DENIED || RpcStatus == E_ACCESSDENIED)
    {
        *phr = HRESULT_FROM_WIN32(RpcStatus);
        return TRUE;
    }
    
    //
    // We get a non-zero rpcstat if there was a communication problem
    // with the server.  We get CO_E_SERVER_STOPPING if a server
    // consumes its own single use registration or was in the process of
    // revoking its registration when we called.
    //
    else if ( (RpcStatus != RPC_S_OK) || (*phr == CO_E_SERVER_STOPPING) )
    {
        if ( RpcStatus != RPC_S_OK )
        {
            //
            // Some rpc errors are of the 8001xxxx variety.  We shouldn't do
            // the hresult conversion of these.
            //
            if ( HRESULT_FACILITY( RpcStatus ) == FACILITY_RPC )
                *phr = RpcStatus;
            else
                *phr = HRESULT_FROM_WIN32(RpcStatus);
        }
        
        // Decide whether to retry the activation.
        return RetryableError(*phr) ? FALSE : TRUE;
    }
    
    return TRUE;
}

BOOL 
CServerListEntry::ServerDied()
/*--

    ServerDied

    Used by callers to determine if the server process handle
    has been signalled.

--*/
{
    BOOL fServerDied = FALSE;

    HANDLE hProcess = _pServerProcess->GetProcessHandle();
    if (hProcess)
    {
        DWORD dwRet = WaitForSingleObject(hProcess, 0);
        if (dwRet == WAIT_OBJECT_0)
        {
            fServerDied = TRUE;
        }
        // else assume still alive on all other return values
    }

    return fServerDied;
}	

BOOL 
CServerListEntry::RetryableError(HRESULT hr)
/*--

    Returns TRUE if the error is such that the caller should attempt
    a retry of the activation, or FALSE otherwise.

--*/
{
    BOOL fRetry = TRUE;

    switch (hr)
    {
    case RPC_E_SYS_CALL_FAILED:
        // RPC_E_SYS_CALL_FAILED is not used by rpc, only ole32, and it
        // is not one we should be doing retrys on.
        fRetry = FALSE;
        break;

    default:
        fRetry = TRUE;
        break;
    }

    return fRetry;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\olescm\stub_irot_s.c ===
/* Stub for generated file irot_s.c */
#include <irot_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\olescm\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME=   olescm
TARGETPATH=   ..\..\lib\$(DEST_TREE)\$(_OBJ_DIR)
TARGETTYPE=   LIBRARY

INCLUDES=     ..\..\..\common\$(DEST_TREE);..\..\..\ih;..;..\..\..\common;
INCLUDES=     $(INCLUDES);..\..\..\com\inc;..\..\..\com\rot;..\..;..\..\objex
INCLUDES=     $(INCLUDES);..\..\..\idl\public\$(DEST_TREE)\$(O)
INCLUDES=     $(INCLUDES);..\..\..\idl\internal\$(DEST_TREE)\$(O)
INCLUDES=     $(INCLUDES);..\..\..\idl\private\$(DEST_TREE)\$(O)
INCLUDES=     $(INCLUDES);..\..\..\cs\inc
INCLUDES=     $(INCLUDES);$(COMP_OLE32_DIR)\actprops
INCLUDES=     $(INCLUDES);$(TERMSRV_INC_PATH)
INCLUDES=     $(INCLUDES);$(BASE_INC_PATH)

!if $(386) || $(WIN64)
C_DEFINES=    -DPERUSER_REGISTRY $(C_DEFINES)
!else
C_DEFINES=    -DPERUSER_REGISTRY -DWX86OLE $(C_DEFINES)
!endif
C_DEFINES=    -DOLESCM $(C_DEFINES)

PRECOMPILED_INCLUDE=..\act.hxx

SOURCES=      \
              ..\activate.cxx      \
              ..\actmisc.cxx       \
              ..\addrrefresh.cxx   \
              ..\class.cxx         \
              ..\clsid.cxx         \
              ..\dbgprt.cxx        \
              ..\dfsext.cxx        \
              ..\dscmif.cxx        \
              ..\events.cxx        \
              ..\excladdr.cxx      \
              ..\macif.cxx         \
              ..\guidtbl.cxx       \
              ..\launch.cxx        \
              ..\mach.cxx          \
              ..\net.cxx           \
              ..\registry.cxx      \
              ..\rpcalloc.cxx      \
              ..\rotif.cxx         \
              ..\scmhash.cxx       \
              ..\scmif.cxx         \
              ..\scminfo.cxx       \
              ..\scmrot.cxx        \
              ..\scmstage.cxx      \
              ..\scmsvc.cxx        \
              ..\servers.cxx       \
              ..\srothint.cxx      \
              ..\remact.cxx        \
              ..\remactif.cxx      \
              ..\remsysif.cxx      \
              ..\security.cxx      \
              ..\surrogat.cxx      \
              ..\execclt.cxx       \
              ..\winsta.cxx        \
              ..\stub_irot_s.c     \
              ..\stub_scm_s.c      \
              ..\stub_scm_z.c      \
              ..\stub_srgtprot_s.c \
              ..\stub_privact_s.c  \
              ..\stub_objsrv_c.c

UMTYPE=console
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\olescm\stub_scm_s.c ===
/* Stub for generated file scm_s.c */
#include <scm_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\olescm\stub_scm_z.c ===
/* Stub for generated file scm_z.c */
#include <scm_z.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\olescm\stub_objsrv_c.c ===
/* Stub for generated file objsrv_c.c */
#include <objsrv_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\olescm\stub_privact_s.c ===
/* Stub for generated file privact_s.c */
#include <rawprivact_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\olescm\stub_srgtprot_s.c ===
/* Stub for generated file srgtprot_s.c */
#include <srgtprot_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\wrapper\sap.h ===
#ifdef __cplusplus
extern "C" {
#endif

enum SAP_CONTROL_TYPE
{
    SAP_CTRL_FORCE_REGISTER,
    SAP_CTRL_MAYBE_REGISTER,
    SAP_CTRL_UPDATE_ADDRESS,
    SAP_CTRL_UNREGISTER
};

void
UpdateSap(
    enum SAP_CONTROL_TYPE action
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\olescm\surrogat.cxx ===
/*++

Copyright (c) 1995-1997 Microsoft Corporation

Module Name:

    surrogat.cxx

Abstract:


Author:


Revision History:

--*/

#include "act.hxx"

CSurrogateList * gpSurrogateList;

//
// CSurrogateList
//

CSurrogateListEntry *
CSurrogateList::Lookup(
    IN  CToken *                pToken,
    IN  BOOL                    bRemoteActivation,
    IN  BOOL                    bClientImpersonating,
    IN  WCHAR *                 pwszWinstaDesktop,
    IN  WCHAR *                 pwszAppid
    )
{
    CSurrogateListEntry * pEntry;

    gpClassLock->LockShared();

    for ( pEntry = (CSurrogateListEntry *) First();
          pEntry;
          pEntry = (CSurrogateListEntry *) pEntry->Next() )
    {
        if ( pEntry->Match(pToken, 
			               bRemoteActivation, 
						   bClientImpersonating,
						   pwszWinstaDesktop,
						   pwszAppid ) )
        {
            pEntry->Reference();
            break;
        }
    }

    gpClassLock->UnlockShared();

    return pEntry;
}

CSurrogateListEntry *
CSurrogateList::Lookup(
    IN  const CProcess * pProcess
    )
{
    CSurrogateListEntry * pEntry;

    gpClassLock->LockShared();

    for ( pEntry = (CSurrogateListEntry *) First();
          pEntry;
          pEntry = (CSurrogateListEntry *) pEntry->Next() )
    {
        if ( pEntry->Process() == pProcess )
            break;
    }

    gpClassLock->UnlockShared();

    return pEntry;
}

void
CSurrogateList::Insert(
    IN  CSurrogateListEntry *  pSurrogateListEntry
    )
{
    CSurrogateListEntry *   pEntry;
    CProcess *              pProcess;

    pProcess = pSurrogateListEntry->Process();

    gpClassLock->LockShared();

    for ( pEntry = (CSurrogateListEntry *) First();
          pEntry;
          pEntry = (CSurrogateListEntry *) pEntry->Next() )
    {
        if ( pEntry->Match( pProcess->GetToken(), 
			                FALSE, 
							FALSE, 
							pProcess->WinstaDesktop(), 
							pSurrogateListEntry->_wszAppid ) )
        {
            pSurrogateListEntry->Release();
            pSurrogateListEntry = 0;
            break;
        }
    }

    if ( pSurrogateListEntry )
        CList::Insert( pSurrogateListEntry );

    gpClassLock->UnlockShared();
}


BOOL
CSurrogateList::InList(
    IN  CSurrogateListEntry *   pSurrogateListEntry
    )
{
    CListElement * pEntry;

    for ( pEntry = First(); pEntry; pEntry = pEntry->Next() )
        if ( pEntry == (CListElement *) pSurrogateListEntry )
            return TRUE;

    return FALSE;
}

//
// CSurrogateListEntry
//

CSurrogateListEntry::CSurrogateListEntry(
    IN  WCHAR *             pwszAppid,
    IN  CServerListEntry *  pServerListEntry
    )
{
    pServerListEntry->Reference();
    _pServerListEntry = pServerListEntry;
    lstrcpyW( _wszAppid, pwszAppid );
}

CSurrogateListEntry::~CSurrogateListEntry()
{
    _pServerListEntry->Release();
}

BOOL
CSurrogateListEntry::Match(
    IN  CToken *    pToken,
    IN  BOOL        bRemoteActivation,
	IN  BOOL        bClientImpersonating,
    IN  WCHAR *     pwszWinstaDesktop,
    IN  WCHAR *     pwszAppid
    )
{
    if ( lstrcmpW( pwszAppid, _wszAppid ) != 0 )
        return FALSE;

    return _pServerListEntry->Match( pToken, 
		                             bRemoteActivation, 
									 bClientImpersonating, 
									 pwszWinstaDesktop, 
									 TRUE );
}

BOOL
CSurrogateListEntry::LoadDll(
    IN  ACTIVATION_PARAMS * pActParams,
    OUT HRESULT *           phr
    )
{
    DWORD           BusyRetries;
    HRESULT         hr;
    BOOL            bRemove;
    error_status_t  RpcStatus;

    HANDLE      hBinding;

    hBinding = _pServerListEntry->RpcHandle( pActParams->UnsecureActivation );

    if ( ! hBinding )
        return FALSE;

    if ( ! pActParams->UnsecureActivation &&
         pActParams->pToken != NULL )
        pActParams->pToken->Impersonate();
        

    BusyRetries = 0;

    do
    {
        hr = ObjectServerLoadDll(
                hBinding,
                pActParams->ORPCthis,
                pActParams->Localthis,
                pActParams->ORPCthat,
                &pActParams->Clsid,
                &RpcStatus );
    } while ( (RPC_S_SERVER_TOO_BUSY == RpcStatus) &&
              (BusyRetries++ < 5) );

    if ( ! pActParams->UnsecureActivation &&
         pActParams->pToken != NULL )
        pActParams->pToken->Revert();

    if ( (RpcStatus != RPC_S_OK) || (CO_E_SERVER_STOPPING == hr) )
    {
        gpClassLock->LockExclusive();

        bRemove = gpSurrogateList->InList( this );
        if ( bRemove )
            gpSurrogateList->Remove( this );

        gpClassLock->UnlockExclusive();

        if ( bRemove )
            Release();

        return FALSE;
    }

    *phr = hr;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\olescm\chicago\w95.cxx ===
]//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       w95.cxx
//
//  Contents:   Win9x specific routines.
//
//  Classes:
//
//  Functions:
//
//
//
//  History:    17-Mar-93   BillMo      Created.
//
//  Notes:
//
//  Codework:
//
//--------------------------------------------------------------------------

#include "act.hxx"

extern CSmMutex * gpWIPmxs;
CWIPTable * gpWIPTbl = NULL;

extern HRESULT (*DfCreateSharedAllocator)( IMalloc **ppm );
IMalloc *       g_pStgAlloc;

//+-------------------------------------------------------------------
//
//  Function:   ScmMemAlloc for Chicago
//
//  Synopsis:   Allocate some shared memory from the storage heap.
//
//  Notes:      Temporary until we have our own shared heap.
//
//--------------------------------------------------------------------
void *ScmMemAlloc(size_t size)
{
    return g_pStgAlloc->Alloc(size);
}

//+-------------------------------------------------------------------
//
//  Function:   ScmMemFree
//
//  Synopsis:   Free shared memory from the storage heap.
//
//  Notes:      Temporary until we have our own shared heap.
//
//--------------------------------------------------------------------
void ScmMemFree(void * pv)
{
    g_pStgAlloc->Free(pv);
}


//+-------------------------------------------------------------------
//
//  Function:   InitSharedLists
//
//  Synopsis:   If need be, create class cache list, handler list,
//              inproc list, local server list
//
//  Returns:    TRUE if successful, FALSE otherwise.
//
//--------------------------------------------------------------------
BOOL InitSharedLists()
{
    HRESULT hr = S_OK;
    LONG    Status;

    if (FAILED(hr = DfCreateSharedAllocator(&g_pStgAlloc)))
    {
        CairoleDebugOut((DEB_ERROR,
                        "DfCreateSharedAllocator failed %08x\n", hr));
        return(FALSE);
    }

    if (g_post->gpClassTable == NULL)
    {
        gpClassTable = g_post->gpClassTable = new CClassTable(Status);
    }
    else
    {
        gpClassTable = g_post->gpClassTable;
    }

    if (g_post->gpSurrogateList == NULL)
    {
        gpSurrogateList = g_post->gpSurrogateList = new CSurrogateList();
    }
    else
    {
        gpSurrogateList = g_post->gpSurrogateList;
    }

    if (g_post->pscmrot == NULL)
    {
        gpscmrot = g_post->pscmrot = new CScmRot(hr, NULL);
    }
    else
    {
        gpscmrot = g_post->pscmrot;
    }

    if (g_post->gpWIPTbl == NULL)
    {
        gpWIPTbl = g_post->gpWIPTbl = new CWIPTable();
    }
    else
    {
        gpWIPTbl = g_post->gpWIPTbl;
    }

    if (gpClassTable == NULL ||
        gpscmrot == NULL ||
        gpWIPTbl == NULL ||
        FAILED(hr))
    {
        CairoleDebugOut((DEB_ERROR, "InitSharedLists failed.\n"));

        delete gpClassTable;
        delete gpscmrot;
        delete gpWIPTbl;

        g_post->gpClassTable = gpClassTable = NULL;
        g_post->pscmrot = gpscmrot = NULL;
        g_post->gpWIPTbl = gpWIPTbl = NULL;

        return(FALSE);
    }

    gpWIPmxs->Init(TEXT("ScmWIPMutex"), FALSE);

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\olescm\chicago\wclass.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       wclass.cxx
//
//  Contents:
//
//--------------------------------------------------------------------------

#include "act.hxx"

//+-------------------------------------------------------------------------
//
// CClassTableEntry::StartServerAndWait
//
//--------------------------------------------------------------------------
HRESULT
CClassTableEntry::StartServerAndWait(
    IN  ACTIVATION_PARAMS * pActParams,
    IN  CClsidData *        pClsidData
    )
{
    GUID            Clsid;
    HANDLE          hProcess;
    HANDLE          hRegisterEvent;
    HRESULT         hr;
    DWORD           Status;
    BOOL            bStatus;

    Clsid = Guid();

    hRegisterEvent = GetRegisterEvent();

    if ( ! hRegisterEvent )
        return E_OUTOFMEMORY;

    hProcess = 0;

    if ( SERVERTYPE_SURROGATE == pClsidData->ServerType() )
    {
        CSurrogateListEntry * pSurrogateListEntry;

        pSurrogateListEntry = gpSurrogateList->Lookup(
                                    NULL,
                                    NULL,
                                    pClsidData->Appid() );

        if ( pSurrogateListEntry )
        {
            bStatus = pSurrogateListEntry->LoadDll( pActParams, &hr );
            pSurrogateListEntry->Release();

            if ( bStatus )
                goto WaitForServer;
        }
    }

    hr = pClsidData->LaunchActivatorServer( &hProcess );

WaitForServer:

    for (;;)
    {
        MSG     Msg;

        //
        // Some wonder win9x code.  Since we're running in the client's process
        // we have to let SendMessages in.
        //
        Status = SSMsgWaitForMultipleObjects(
                        1,
                        &hRegisterEvent,
                        FALSE,
                        gServerStartTimeout,
                        QS_SENDMESSAGE );

        //
        // If the Status index is beyond the array, then there is a
        // message available.
        //
        if ( Status != (DWORD)(WAIT_OBJECT_0 + 1) )
            break;

        (void) SSPeekMessage( &Msg, 0, 0, 0, PM_NOREMOVE );
    }

    if ( (Status != WAIT_OBJECT_0) && hProcess )
        TerminateProcess( hProcess, 0 );

    if ( hProcess )
        CloseHandle( hProcess );

    if ( Status != WAIT_OBJECT_0 )
        return CO_E_SERVER_EXEC_FAILURE;

    return S_OK;
}

#define EVENTNAMEPREFIX "ACTSERVEREVENT"

//+-------------------------------------------------------------------------
//
// CClassTableEntry::GetRegisterEvent
//
//--------------------------------------------------------------------------
HANDLE
CClassTableEntry::GetRegisterEvent()
{
    HANDLE  hEvent;
    char    szEvent[sizeof(EVENTNAMEPREFIX)+GUIDSTR_MAX+1];

    memcpy( szEvent, EVENTNAMEPREFIX, sizeof(EVENTNAMEPREFIX) );
    wStringFromGUID2A( Guid(), &szEvent[sizeof(EVENTNAMEPREFIX)], GUIDSTR_MAX + 1 );

    hEvent = CreateEventA( NULL, FALSE, FALSE, szEvent );

    return hEvent;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\olescm\chicago\wlaunch.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       launch.cxx
//
//  Contents:
//
//--------------------------------------------------------------------------

#include "act.hxx"

HRESULT
CClsidData::LaunchActivatorServer(
    OUT HANDLE * phProcess
    )
{
    WCHAR *                 pwszCommandLine;
    STARTUPINFO             StartupInfo;
    PROCESS_INFORMATION     ProcessInfo;
    HRESULT                 hr;
    BOOL                    bStatus;

    hr = GetLaunchCommandLine( &pwszCommandLine );

    StartupInfo.cb = sizeof(StartupInfo);
    StartupInfo.lpReserved = NULL;
    StartupInfo.lpDesktop = NULL;
    StartupInfo.lpTitle = (SERVERTYPE_SURROGATE == _ServerType) ? NULL : _pwszServer;
    StartupInfo.dwX = 40;
    StartupInfo.dwY = 40;
    StartupInfo.dwXSize = 80;
    StartupInfo.dwYSize = 40;
    StartupInfo.dwFlags = 0;
    StartupInfo.wShowWindow = SW_SHOWNORMAL;
    StartupInfo.cbReserved2 = 0;
    StartupInfo.lpReserved2 = NULL;

    ProcessInfo.hThread = 0;
    ProcessInfo.hProcess = 0;

    bStatus = CreateProcess(
                    NULL,
                    pwszCommandLine,
                    NULL,
                    NULL,
                    FALSE,
                    CREATE_NEW_CONSOLE,
                    NULL,
                    NULL,
                    &StartupInfo,
                    &ProcessInfo );

    if ( ProcessInfo.hThread )
        CloseHandle( ProcessInfo.hThread );

    if ( ProcessInfo.hProcess && ! bStatus )
    {
        CloseHandle( ProcessInfo.hProcess );
        ProcessInfo.hProcess = 0;
    }

    *phProcess = ProcessInfo.hProcess;

    PrivMemFree( pwszCommandLine );

    return bStatus ? S_OK : HRESULT_FROM_WIN32( GetLastError() );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\olescm\winsta.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       winsta.cxx
//
//  Contents:   winstation caching code
//
//--------------------------------------------------------------------------

#include "act.hxx"

#ifndef _CHICAGO_

//
// Private Types.
//

//-------------------------------------------------------------------------
// Definitions for Runas Cache
// NOTE: This exists to overcome limitation on NT Winstations of 15
//       Reusing same token will map to same winstation. We also cache
//       winstation once we get it.
//-------------------------------------------------------------------------
const DWORD RUN_AS_TIMEOUT = 360000;

#define RUNAS_CACHE_SIZE 200

// The pUser and pGroups fields are assumed to point to one contiguous memory
// block that can be freed by a single call to Free(pUser).
WCHAR wszRunAsWinstaDesktop[RUNAS_CACHE_SIZE][100];
typedef struct SRunAsCache
{
    HANDLE              hToken;
    WCHAR                *pwszWinstaDesktop;
    WCHAR                *pwszWDStore;
    LONG                dwRefCount;
    DWORD               lHash;
    TOKEN_USER         *pUser;
    TOKEN_GROUPS       *pGroups;
    TOKEN_GROUPS       *pRestrictions;
    DWORD               lBirth;
    struct SRunAsCache *pNext;
    SRunAsCache()
    {
        hToken = NULL;
        pwszWinstaDesktop = NULL;
        pwszWDStore = NULL;
        dwRefCount = 0;
        lHash = 0;
        pUser = NULL;
        pGroups = NULL;
        pRestrictions = NULL;
        lBirth = 0;
        pNext = NULL;
    }
} SRunAsCache;


#define RUNAS_CACHECTRL_CREATENOTFOUND  1
#define RUNAS_CACHECTRL_REFERENCE       2
#define RUNAS_CACHECTRL_GETTOKEN        4

//Macro to invalidate an entry -- must be idempotent
#define INVALIDATE_RUNAS_ENTRY(pEntry) pEntry->lHash = 0

// Lock for LogonUser cache.
CRITICAL_SECTION gTokenCS;

// The run as cache is an array of entries divided into 2 circular lists.
// The gRunAsHead list contains cache entries in use with the most
// frequently used entries first.  The gRunAsFree list  contains free
// entries.
extern SRunAsCache gRunAsFree;

static SRunAsCache gRunAsCache[RUNAS_CACHE_SIZE];

#if 0
// Make the table smaller in debug to test the cache full case.
SRunAsCache gRunAsCache[] =
{
    { NULL, NULL, &wszRunAsWinstaDesktop[0][0], 0, 0, NULL, NULL, NULL, 0, &gRunAsCache[1] },
    { NULL, NULL, &wszRunAsWinstaDesktop[1][0], 0, 0, NULL, NULL, NULL, 0, &gRunAsCache[2] },
    { NULL, NULL, &wszRunAsWinstaDesktop[2][0], 0, 0, NULL, NULL, NULL, 0, &gRunAsCache[3] },
    { NULL, NULL, &wszRunAsWinstaDesktop[3][0], 0, 0, NULL, NULL, NULL, 0, &gRunAsCache[4] },
    { NULL, NULL, &wszRunAsWinstaDesktop[4][0], 0, 0, NULL, NULL, NULL, 0, &gRunAsCache[5] },
#if DBG == 1
    { NULL, NULL, &wszRunAsWinstaDesktop[5][0], 0, 0, NULL, NULL, NULL, 0, &gRunAsFree }
#else
    { NULL, NULL, &wszRunAsWinstaDesktop[5][0], 0, 0, NULL, NULL, NULL, 0, &gRunAsCache[6] },
    { NULL, NULL, &wszRunAsWinstaDesktop[6][0], 0, 0, NULL, NULL, NULL, 0, &gRunAsCache[7] },
    { NULL, NULL, &wszRunAsWinstaDesktop[7][0], 0, 0, NULL, NULL, NULL, 0, &gRunAsCache[8] },
    { NULL, NULL, &wszRunAsWinstaDesktop[8][0], 0, 0, NULL, NULL, NULL, 0, &gRunAsCache[9] },
    { NULL, NULL, &wszRunAsWinstaDesktop[9][0], 0, 0, NULL, NULL, NULL, 0, &gRunAsCache[10] },
    { NULL, NULL, &wszRunAsWinstaDesktop[10][0], 0, 0, NULL, NULL, NULL, 0, &gRunAsCache[11] },
    { NULL, NULL, &wszRunAsWinstaDesktop[11][0], 0, 0, NULL, NULL, NULL, 0, &gRunAsCache[12] },
    { NULL, NULL, &wszRunAsWinstaDesktop[12][0], 0, 0, NULL, NULL, NULL, 0, &gRunAsCache[13] },
    { NULL, NULL, &wszRunAsWinstaDesktop[13][0], 0, 0, NULL, NULL, NULL, 0, &gRunAsCache[14] },
    { NULL, NULL, &wszRunAsWinstaDesktop[14][0], 0, 0, NULL, NULL, NULL, 0, &gRunAsCache[15] },
    { NULL, NULL, &wszRunAsWinstaDesktop[15][0], 0, 0, NULL, NULL, NULL, 0, &gRunAsFree }
#endif
};

SRunAsCache gRunAsHead = { NULL, NULL, NULL, 0, 0, NULL, NULL, NULL, 0, &gRunAsHead };
SRunAsCache gRunAsFree = { NULL, NULL, NULL, 0, 0, NULL, NULL, NULL, 0, &gRunAsCache[0] };
#endif

SRunAsCache gRunAsHead;
SRunAsCache gRunAsFree;


//+-------------------------------------------------------------------------
//
//  Function: InitRunAsCache
//
//  Synopsis:       One time initialization of runas cache
//
//+-------------------------------------------------------------------------
void InitRunAsCache()
{
    for (int i=0; i < (RUNAS_CACHE_SIZE-1); i++)
    {
        gRunAsCache[i].pNext = &gRunAsCache[i+1];
        gRunAsCache[i].pwszWDStore = &wszRunAsWinstaDesktop[i][0];
    }

    gRunAsCache[i].pNext = &gRunAsFree;
    gRunAsCache[i].pwszWDStore = &wszRunAsWinstaDesktop[i][0];

    gRunAsHead.pNext = &gRunAsHead;
    gRunAsFree.pNext = &gRunAsCache[0];
}

//+-------------------------------------------------------------------------
//
//  Function:       HashSid
//
//  Synopsis:       Compute a DWORD hash for a SID.
//
//--------------------------------------------------------------------------
DWORD HashSid( PSID pVoid )
{
    SID *pSID   = (SID *) pVoid;
    DWORD lHash = 0;
    DWORD i;

    // Hash the identifier authority.
    for (i = 0; i < 6; i++)
        lHash ^= pSID->IdentifierAuthority.Value[i];

    // Hash the sub authority.
    for (i = 0; i < pSID->SubAuthorityCount; i++)
        lHash ^= pSID->SubAuthority[i];
    return lHash;
}

//+-------------------------------------------------------------------------
//
//  Function:       RunAsCache
//
//  Synopsis:       Return a token from the cache if present.  Otherwise
//                  return the original token.
//
//  Description:    This function caches LogonUser tokens because each
//                  token has its own windowstation.  Since there are
//                  a limited number of windowstations, by caching tokens
//                  we can reduce the number of windowstations used and thus
//                  allow more servers to be created.  The cache moves the
//                  most frequently used tokens to the head of the list and
//                  discards tokens from the end of the list when full.
//                  When the cache is full, alternating requests for different
//                  tokens will prevent the last token from having a chance
//                  to advance in the list.
//                  [vinaykr - 9/1/98]
//                  Token caching alone is not enough because Tokens time out.
//                  So we cache winstations and reference count them to 
//                  ensure proper allocation to a window station.
//
//  Notes:          Tokens in the cache must be timed out so that changes to
//                  the user name, user groups, user privileges, and user
//                  password take effect.  The timeout must be balanced
//                  between the need to cache as many tokens as possible and
//                  the fact that cached tokens are useless when the password
//                  changes.
//                  [vinaykr - 9/1/98]
//                  Time out removed in favour of reference counting.
//                  Entry cleaned up when reference count goes to 0.
//--------------------------------------------------------------------------
HRESULT RunAsCache(IN DWORD dwCacheCtrl,
                   IN HANDLE &hToken,
                   OUT SRunAsCache** ppRunAsCache)
{
    HRESULT       hr;
    BOOL          fSuccess;
    DWORD         cbUser         = 0;
    DWORD         cbGroups       = 0;
    DWORD         cbRestrictions = 0;
    TOKEN_USER   *pUser          = NULL;
    TOKEN_GROUPS *pGroups;
    TOKEN_GROUPS *pRestrictions;
    DWORD         lHash;
    DWORD         i;
    HANDLE        hCopy;
    DWORD         lNow;
    SRunAsCache  *pCurr = NULL;
    SRunAsCache  *pPrev;
    SRunAsCache   sSwap;
	
    *ppRunAsCache = NULL;

    // Find out how large the user SID is.
    GetTokenInformation( hToken, TokenUser, NULL, 0, &cbUser );
    if (cbUser == 0) { hr = E_UNEXPECTED; goto Cleanup; }

    // Find out how large the group SIDs are.
    GetTokenInformation( hToken, TokenGroups, NULL, 0, &cbGroups );

    // Find out how large the restricted SIDs are.
    GetTokenInformation( hToken, TokenRestrictedSids, NULL, 0, &cbRestrictions );

    // Allocate memory to hold the SIDs.
    cbUser        = (cbUser + 7) & ~7;
    cbGroups      = (cbGroups + 7) & ~7;
    pUser         = (TOKEN_USER *) PrivMemAlloc( cbUser + cbGroups + cbRestrictions );
    pGroups       = (TOKEN_GROUPS *) (((BYTE *) pUser) + cbUser);
    pRestrictions = (TOKEN_GROUPS *) (((BYTE *) pGroups) + cbGroups);
    if (pUser == NULL) { hr = E_OUTOFMEMORY; goto Cleanup; }

    // Get the user SID.
    fSuccess = GetTokenInformation( hToken, TokenUser, pUser, cbUser, &cbUser );
    if (!fSuccess) { hr = HRESULT_FROM_WIN32(GetLastError()); goto Cleanup; }

    // Get the group SIDs.
    fSuccess = GetTokenInformation( hToken, TokenGroups, pGroups, cbGroups, &cbGroups );
    if (!fSuccess) { hr = HRESULT_FROM_WIN32(GetLastError()); goto Cleanup; }

    // Get the restricted SIDs.
    fSuccess = GetTokenInformation( hToken, TokenRestrictedSids, pRestrictions,
                                    cbRestrictions, &cbRestrictions );
    if (!fSuccess) { hr = HRESULT_FROM_WIN32(GetLastError()); goto Cleanup; }

    // Get the SID hash but skip the logon group that is unique for every
    // call to logon user.
    lHash = HashSid( pUser->User.Sid );
    for (i = 0; i < pGroups->GroupCount; i++)
        if ((pGroups->Groups[i].Attributes & SE_GROUP_LOGON_ID) == 0)
            lHash ^= HashSid( pGroups->Groups[i].Sid );
    for (i = 0; i < pRestrictions->GroupCount; i++)
        lHash ^= HashSid( pRestrictions->Groups[i].Sid );

    // Take lock.
    EnterCriticalSection( &gTokenCS );

    // Look for an existing token.
    lNow  = GetTickCount();
    pPrev = &gRunAsHead;
    pCurr = pPrev->pNext;
    while (pPrev->pNext != &gRunAsHead)
    {
        // If the current entry is too old, delete it.
        //    (lNow - pCurr->lBirth >= RUN_AS_TIMEOUT))
        // [vinaykr 9/1] Changed to use refcount
        // If refcount is 0 delete entry
        if (!pCurr->dwRefCount)
        {
            CloseHandle( pCurr->hToken );
            PrivMemFree( pCurr->pUser );
            pPrev->pNext = pCurr->pNext;
            pCurr->pNext = gRunAsFree.pNext;
            gRunAsFree.pNext = pCurr;
        }
        else
        {
            // If the current entry matches, break.
            if (pCurr->lHash == lHash &&
                pCurr->pGroups->GroupCount == pGroups->GroupCount)
            {
                // Check the user SID.
                if (EqualSid(pCurr->pUser->User.Sid, pUser->User.Sid))
                {
                    // Check the group SIDs.
                    for (i = 0; i < pGroups->GroupCount; i++)
                        if ((pGroups->Groups[i].Attributes & SE_GROUP_LOGON_ID) == 0)
                            if (!EqualSid( pCurr->pGroups->Groups[i].Sid,
                                           pGroups->Groups[i].Sid ))
                                break;

                    // If those matched, check the restricted SIDs
                    if (i >= pGroups->GroupCount)
                    {
                        for (i = 0; i < pRestrictions->GroupCount; i++)
                            if (!EqualSid( pCurr->pRestrictions->Groups[i].Sid,
                                           pRestrictions->Groups[i].Sid ))
                                    break;

                        if (i >= pRestrictions->GroupCount)
                            break;
                    }
                }
            }
            pPrev = pPrev->pNext;
        }
        pCurr = pPrev->pNext;
    }

    
    fSuccess = (pCurr != &gRunAsHead);

    // Found a token
    if (fSuccess)
    {
        // Duplicate this token if token requested
        if (dwCacheCtrl & RUNAS_CACHECTRL_GETTOKEN)
        {
            fSuccess = DuplicateTokenEx( pCurr->hToken, MAXIMUM_ALLOWED,
                                     NULL, SecurityDelegation, TokenPrimary,
                                     &hCopy );
        }

        if (fSuccess)
        {
            // Discard the passed in token and return a copy of the cached
            // token.
            CloseHandle( hToken );
            hToken = hCopy;
        }
    }

    // If not found, find an empty slot only if we are trying to 
    // set into this.  Note this can also be taken if unable to 
    // duplicate found token above.
    if ((!fSuccess) &&
        (dwCacheCtrl & RUNAS_CACHECTRL_CREATENOTFOUND))
    {
        // Duplicate this token.
        fSuccess = DuplicateTokenEx( hToken, MAXIMUM_ALLOWED, NULL,
                                     SecurityDelegation, TokenPrimary, &hCopy );

        if (fSuccess)
        {
            // Get an entry from the free list.
            if (gRunAsFree.pNext != &gRunAsFree)
            {
                pCurr            = gRunAsFree.pNext;
                gRunAsFree.pNext = pCurr->pNext;
                pCurr->pNext     = &gRunAsHead;
                pPrev->pNext     = pCurr;
            }

            // If no empty slot, release the last used entry.
            else
            {
                pCurr = pPrev;
                CloseHandle( pCurr->hToken );
                PrivMemFree( pCurr->pUser );
            }

            // Save the duplicate.
            pCurr->hToken        = hCopy;
            pCurr->lHash         = lHash;
            pCurr->pUser         = pUser;
            pCurr->pGroups       = pGroups;
            pCurr->pRestrictions = pRestrictions;
            pCurr->lBirth        = lNow;
            pCurr->dwRefCount    = 0;
            pCurr->pwszWinstaDesktop = NULL;
            pUser                = NULL;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    // If an entry was computed and a reference
    // to it was requested, refcount it.
    if (fSuccess)
    {
        if (dwCacheCtrl & RUNAS_CACHECTRL_REFERENCE)
            pCurr->dwRefCount++;
    }

    // Release lock.
    LeaveCriticalSection( &gTokenCS );

    // Free any resources allocated by the function.
Cleanup:
    if (pUser != NULL)
        PrivMemFree(pUser);

    if (SUCCEEDED(hr))
    {
        ASSERT(pCurr);
        *ppRunAsCache = pCurr;
    }

    return hr;
}


//+-------------------------------------------------------------------------
//+
//+ Function: RunAsGetTokenElem
//+
//+ Synopsis: Gets token and/or Winstationdesktop string given a token 
//+           Assumption is that if an entry is found in the cache a handle
//+           to the entry is returned with a reference being taken on the
//+           entry. This handle can then be used for other operations and
//+           needs to be explicitly released to release the entry.
//+
//+-------------------------------------------------------------------------
HRESULT RunAsGetTokenElem(IN OUT HANDLE *pToken, 
                         OUT void **ppvElemHandle)
{
    HRESULT hr;
    SRunAsCache* pElem = NULL;

    *ppvElemHandle = NULL;

    hr = RunAsCache(RUNAS_CACHECTRL_REFERENCE |
                    RUNAS_CACHECTRL_GETTOKEN |
                    RUNAS_CACHECTRL_CREATENOTFOUND,
                    *pToken,
                    &pElem);
    if (SUCCEEDED(hr))
    {
        *ppvElemHandle = (void*)pElem;
    }
    
    return hr;
}


//+-------------------------------------------------------------------------
//+
//+ Function:   RunAsSetWinstaDesktop
//+
//+ Synopsis:   Given a handle to an entry, sets the desktop string
//+             Assumption is that entry is referenced and therefore
//+             a valid one.
//+
//+-------------------------------------------------------------------------
void RunAsSetWinstaDesktop(void *pvElemHandle, WCHAR *pwszWinstaDesktop)
{
    if (!pvElemHandle)
        return;

    SRunAsCache* pElem = (SRunAsCache*) pvElemHandle;
    Win4Assert( (!pElem->pwszWinstaDesktop) ||
                (lstrcmpW(pElem->pwszWinstaDesktop, pwszWinstaDesktop) 
                ==0) );
    if (!pElem->pwszWinstaDesktop)
    {
        lstrcpyW(pElem->pwszWDStore, pwszWinstaDesktop);
        pElem->pwszWinstaDesktop = pElem->pwszWDStore;
    }
}

//+-------------------------------------------------------------------------
//+
//+ Function:   RunAsRelease
//+
//+ Synopsis:   Given a handle to an entry, releases reference on it
//+             Assumption is that entry is referenced and therefore
//+             a valid one.
//+
//+-------------------------------------------------------------------------
void RunAsRelease(void *pvElemHandle)
{
    if (!pvElemHandle)
        return;

    SRunAsCache* pElem = (SRunAsCache*) pvElemHandle;

    // When refcount goes to 0 allow lazy clean up based on token
    // time out

    // Take lock.
    EnterCriticalSection( &gTokenCS );

    if ((--pElem->dwRefCount) == 0)
    {
        INVALIDATE_RUNAS_ENTRY(pElem);
    }

    LeaveCriticalSection( &gTokenCS );
    // Release lock.
}

//+-------------------------------------------------------------------------
//+
//+ Function:   RunAsInvalidateAndRelease
//+
//+ Synopsis:   Given a handle to an entry, invalidates it and releases 
//+             reference on it in response to some error.
//+             Assumption is that entry is referenced and therefore
//+             a valid one.
//+
//+-------------------------------------------------------------------------
void RunAsInvalidateAndRelease(void *pvElemHandle)
{
    if (!pvElemHandle)
        return;

    SRunAsCache* pElem = (SRunAsCache*) pvElemHandle;

    // Take lock.
    EnterCriticalSection( &gTokenCS );

    INVALIDATE_RUNAS_ENTRY(pElem);

    // Release lock.
    LeaveCriticalSection( &gTokenCS );

    RunAsRelease(pvElemHandle);
}

WCHAR *RunAsGetWinsta(void *pvElemHandle)
{
    if (!pvElemHandle)
        return NULL;

    SRunAsCache* pElem = (SRunAsCache*) pvElemHandle;

    return pElem->pwszWinstaDesktop;
}

#endif // _CHICAGO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\wrapper\epts.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    Epts.c

Abstract:

    Common code to listen to endpoints in the DCOM service.

Author:

    Mario Goertzel    [MarioGo]

Revision History:

    MarioGo     6/16/1995    Bits 'n pieces
    Edwardr     7/17/1996    Added ncadg_mq
    Edwardr     5/01/1997    Added ncacn_http
    MazharM    10-12.98      Add pnp stuff
    KamenM     Oct 2000      Removed ncadg_mq

--*/

//#define NCADG_MQ_ON
//#define NETBIOS_ON
#if !defined(_M_IA64)
#define SPX_ON
#endif
//#define IPX_ON

#if !defined(SPX_ON) && !defined(IPX_ON)
#define SPX_IPX_OFF
#endif

#include <dcomss.h>
#include <winsvc.h>
#include <winsock2.h>

#if !defined(SPX_IPX_OFF)
#include <wsipx.h>
#include <svcguid.h>
#include "sap.h"
#endif

// Globals

#if !defined(SPX_IPX_OFF)
const IPX_BOGUS_NETWORK_NUMBER = 0xefcd3412;

BOOL gfDelayedAdvertiseSaps = FALSE;

typedef enum
    {
    SapStateUnknown,
    SapStateNoServices,
    SapStateEnabled,
    SapStateDisabled
    } SAP_STATE;

SAP_STATE SapState = SapStateUnknown;
#endif

enum RegistryState
{
    RegStateUnknown,
    RegStateMissing,
    RegStateYes,
    RegStateNo

} RegistryState = RegStateUnknown;

// Prototypes

#if !defined(SPX_IPX_OFF)
void  AdvertiseNameWithSap(void);
void  CallSetService( SOCKADDR_IPX * pipxaddr, BOOL fRegister );
#endif

//
// The index is the protseq tower id.
//

PROTSEQ_INFO
gaProtseqInfo[] =
    {
    /* 0x00 */ { STOPPED, 0, 0 },
    /* 0x01 */ { STOPPED, 0, 0 },
    /* 0x02 */ { STOPPED, 0, 0 },
    /* 0x03 */ { STOPPED, 0, 0 },
    /* 0x04 */ { STOPPED, L"ncacn_dnet_nsp", L"#69" },
    /* 0x05 */ { STOPPED, 0, 0 },
    /* 0x06 */ { STOPPED, 0, 0 },
    /* 0x07 */ { STOPPED, L"ncacn_ip_tcp",   L"135" },
    /* 0x08 */ { STOPPED, L"ncadg_ip_udp",   L"135" },

#ifdef NETBIOS_ON
    /* 0x09 */ { STOPPED, L"ncacn_nb_tcp",   L"135" },
#else
    /* 0x09 */ { STOPPED, 0, 0 },
#endif

    /* 0x0a */ { STOPPED, 0, 0 },
    /* 0x0b */ { STOPPED, 0, 0 },
#if defined(SPX_ON)
    /* 0x0c */ { STOPPED, L"ncacn_spx",      L"34280" },
#else
    /* 0x0c */ { STOPPED, 0, 0 },
#endif

#ifdef NETBIOS_ON
    /* 0x0d */ { STOPPED, L"ncacn_nb_ipx",   L"135" },
#else
    /* 0x0d */ { STOPPED, 0, 0 },
#endif

    /* 0x0e */ { STOPPED, L"ncadg_ipx",      L"34280" },
    /* 0x0f */ { STOPPED, L"ncacn_np",       L"\\pipe\\epmapper" },
    /* 0x10 */ { STOPPED, L"ncalrpc",        L"epmapper" },
    /* 0x11 */ { STOPPED, 0, 0 },
    /* 0x12 */ { STOPPED, 0, 0 },
#ifdef NETBIOS_ON
    /* 0x13 */ { STOPPED, L"ncacn_nb_nb",    L"135" },
#else
    /* 0x13 */ { STOPPED, 0, 0 },
#endif

    /* 0x14 */ { STOPPED, 0, 0 },
    /* 0x15 */ { STOPPED, 0, 0 }, // was ncacn_nb_xns - unsupported.
    /* 0x16 */ { STOPPED, L"ncacn_at_dsp", L"Endpoint Mapper" },
    /* 0x17 */ { STOPPED, L"ncadg_at_ddp", L"Endpoint Mapper" },
    /* 0x18 */ { STOPPED, 0, 0 },
    /* 0x19 */ { STOPPED, 0, 0 },
    /* 0x1A */ { STOPPED, 0, 0 },
    /* 0x1B */ { STOPPED, 0, 0 },
    /* 0x1C */ { STOPPED, 0, 0 },

#ifdef NCADG_MQ_ON
    /* 0x1D */ { STOPPED, L"ncadg_mq",  L"EpMapper"},
#else
    /* 0x1D */ { STOPPED, 0, 0 },
#endif

    /* 0x1E */ { STOPPED, 0, 0 },
    /* 0x1F */ { STOPPED, L"ncacn_http", L"593" },  // dcomhttp port assigned by IANA
    /* 0x20 */ { STOPPED, 0, 0 },
    };

#define PROTSEQ_IDS (sizeof(gaProtseqInfo)/sizeof(PROTSEQ_INFO))

#define ID_LPC (0x10)
#define ID_IPX (0x0E)

#if defined(SPX_ON)
#define ID_SPX (0x0C)
#endif

#define ID_HTTP (0x1F)

BOOL fListenOnInternet = TRUE;    // see bug 69332 (in old nt raid db)


BOOL
CreateSids(
    PSID*	ppsidBuiltInAdministrators,
    PSID*	ppsidSystem,
    PSID*	ppsidWorld
)
/*++

Routine Description:

    Creates and return pointers to three SIDs one for each of World,
    Local Administrators, and System.

Arguments:

    ppsidBuiltInAdministrators - Receives pointer to SID representing local
        administrators; 
    ppsidSystem - Receives pointer to SID representing System;
    ppsidWorld - Receives pointer to SID representing World.

Return Value:

    BOOL indicating success (TRUE) or failure (FALSE).

    Caller must free returned SIDs by calling FreeSid() for each returned
    SID when this function return TRUE; pointers should be assumed garbage
    when the function returns FALSE.

--*/
{
    //
    // An SID is built from an Identifier Authority and a set of Relative IDs
    // (RIDs).  The Authority of interest to us SECURITY_NT_AUTHORITY.
    //

    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY WorldAuthority = SECURITY_WORLD_SID_AUTHORITY;

    //
    // Each RID represents a sub-unit of the authority.  Local
    // Administrators is in the "built in" domain.  The other SIDs, for
    // Authenticated users and system, is based directly off of the
    // authority. 
    //     
    // For examples of other useful SIDs consult the list in
    // \nt\public\sdk\inc\ntseapi.h.
    //

    if (!AllocateAndInitializeSid(&NtAuthority,
                                  2,            // 2 sub-authorities
                                  SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS,
                                  0,0,0,0,0,0,
                                  ppsidBuiltInAdministrators)) {

        // error

    } else if (!AllocateAndInitializeSid(&NtAuthority,
                                         1,            // 1 sub-authorities
                                         SECURITY_LOCAL_SYSTEM_RID,
                                         0,0,0,0,0,0,0,
                                         ppsidSystem)) {

        // error

        FreeSid(*ppsidBuiltInAdministrators);
        *ppsidBuiltInAdministrators = NULL;

    } else if (!AllocateAndInitializeSid(&WorldAuthority,
                                         1,            // 1 sub-authority
                                         SECURITY_WORLD_RID,
                                         0,0,0,0,0,0,0,
                                         ppsidWorld)) {

        // error

        FreeSid(*ppsidBuiltInAdministrators);
        *ppsidBuiltInAdministrators = NULL;

        FreeSid(*ppsidSystem);
        *ppsidSystem = NULL;

    } else {
        return TRUE;
    }

    return FALSE;
}


PSECURITY_DESCRIPTOR
CreateSd(
    VOID
)
/*++

Routine Description:

    Creates and return a SECURITY_DESCRIPTOR with a DACL granting
    (GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | SYNCHRONIZE) to World,
    and GENERIC_ALL to Local Administrators and System.

Arguments:

    None

Return Value:

    Pointer to the created SECURITY_DESCRIPTOR, or NULL if an error occurred.

    Caller must free returned SECURITY_DESCRIPTOR back to process heap by
    a call to HeapFree.

--*/
{
    PSID	psidWorld;
    PSID	psidBuiltInAdministrators;
    PSID	psidSystem;

    if (!CreateSids(&psidBuiltInAdministrators,
                    &psidSystem,
                    &psidWorld)) {

        // error

    } else {

        // 
        // Calculate the size of and allocate a buffer for the DACL, we need
        // this value independently of the total alloc size for ACL init.
        //

        PSECURITY_DESCRIPTOR    Sd = NULL;
        ULONG                   AclSize;

        //
        // "- sizeof (ULONG)" represents the SidStart field of the
        // ACCESS_ALLOWED_ACE.  Since we're adding the entire length of the
        // SID, this field is counted twice.
        //

        AclSize = sizeof (ACL) +
            (3 * (sizeof (ACCESS_ALLOWED_ACE) - sizeof (ULONG))) +
            GetLengthSid(psidWorld) +
            GetLengthSid(psidBuiltInAdministrators) +
            GetLengthSid(psidSystem);

        Sd = HeapAlloc(GetProcessHeap(),
                       0,
                       SECURITY_DESCRIPTOR_MIN_LENGTH + AclSize);

        if (!Sd) {

            // error

        } else {

            ACL                     *Acl;

            Acl = (ACL *)((BYTE *)Sd + SECURITY_DESCRIPTOR_MIN_LENGTH);

            if (!InitializeAcl(Acl,
                               AclSize,
                               ACL_REVISION)) {

                // error

            } else if (!AddAccessAllowedAce(Acl,
                                            ACL_REVISION,
                                            SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE,
                                            psidWorld)) {

                // Failed to build the ACE granting "WORLD"
                // (SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE) access.

            } else if (!AddAccessAllowedAce(Acl,
                                            ACL_REVISION,
                                            GENERIC_ALL,
                                            psidBuiltInAdministrators)) {

                // Failed to build the ACE granting "Built-in Administrators"
                // (GENERIC_ALL) access.

            } else if (!AddAccessAllowedAce(Acl,
                                            ACL_REVISION,
                                            GENERIC_ALL,
                                            psidSystem)) {

                // Failed to build the ACE granting "System"
                // GENERIC_ALL access.

            } else if (!InitializeSecurityDescriptor(Sd,
                                                     SECURITY_DESCRIPTOR_REVISION)) {

                // error

            } else if (!SetSecurityDescriptorDacl(Sd,
                                                  TRUE,
                                                  Acl,
                                                  FALSE)) {

                // error

            } else {
                FreeSid(psidWorld);
                FreeSid(psidBuiltInAdministrators);
                FreeSid(psidSystem);

                return Sd;
            }

            HeapFree(GetProcessHeap(),
                     0,
                     Sd);
        }

        FreeSid(psidWorld);
        FreeSid(psidBuiltInAdministrators);
        FreeSid(psidSystem);
    }

    return NULL;
}


RPC_STATUS
UseProtseqIfNecessary(
    IN USHORT id
    )
/*++

Routine Description:

    Listens to the well known RPC endpoint mapper endpoint
    for the protseq.  Returns very quickly if the process
    is already listening to the protseq.

Arguments:

    id - the tower id of protseq.  See GetProtseqId() if you don't
         already have this value.

Return Value:

    RPC_S_OK - no errors occured.
    RPC_S_OUT_OF_RESOURCES - when we're unable to setup security for the endpoint.
    RPC_S_INVALID_RPC_PROTSEQ - if id is unknown/invalid.

    Any error from RpcServerUseProtseqEp.

--*/
{
    RPC_STATUS status = RPC_S_OK;
    SECURITY_DESCRIPTOR *psd = NULL;
    RPC_POLICY Policy;

    Policy.Length = sizeof(RPC_POLICY);
    Policy.EndpointFlags = 0;

    if (fListenOnInternet)
        {
        Policy.NICFlags = RPC_C_BIND_TO_ALL_NICS;
        }
    else
        {
        Policy.NICFlags = 0;
        }

    ASSERT(id);

    if (id == 0 || id >= PROTSEQ_IDS)
        {
        ASSERT(0);
        return(RPC_S_INVALID_RPC_PROTSEQ);
        }

    if (gaProtseqInfo[id].state == STARTED)
        {
        return(RPC_S_OK);
        }

    if (id == ID_LPC)
        {
        // ncalrpc needs a security descriptor.

        psd = CreateSd();            

        if ( NULL == psd )
            {
            status = RPC_S_OUT_OF_RESOURCES;
            }
        }
    else
        {
        psd = NULL;
        }

    if (status == RPC_S_OK )
        {
        status = RpcServerUseProtseqEpEx(gaProtseqInfo[id].pwstrProtseq,
                                       RPC_C_PROTSEQ_MAX_REQS_DEFAULT + 40,
                                       gaProtseqInfo[id].pwstrEndpoint,
                                       psd,
                                       &Policy);

        if ( NULL != psd )
            {
            HeapFree(GetProcessHeap(),
                     0,
                     psd);

            psd = NULL;
            }

        // No locking is done here, the RPC runtime may return duplicate
        // endpoint if two threads call this at the same time.
        if (status == RPC_S_DUPLICATE_ENDPOINT)
            {
            status = RPC_S_OK;
            }

#ifdef DEBUGRPC
        if (status != RPC_S_OK)
            {
            KdPrintEx((DPFLTR_DCOMSS_ID,
                       DPFLTR_WARNING_LEVEL,
                       "DCOMSS: Unable to listen to %S (0x%x)\n",
                       gaProtseqInfo[id].pwstrProtseq,
                       status));
            }
#endif

        if (status == RPC_S_OK)
            {
            gaProtseqInfo[id].state = STARTED;

#if !defined(SPX_IPX_OFF)
            if (
#if defined(IPX_ON)
                (id == ID_IPX) 
                  || 
#endif
#if defined(SPX_ON)
                (id == ID_SPX)
#endif
               )
                {
                UpdateSap(SAP_CTRL_MAYBE_REGISTER);
                }
#endif
            }
        }

    return(status);
}


PWSTR
GetProtseq(
    IN USHORT ProtseqId
    )
/*++

Routine Description:

    Returns the unicode protseq give the protseqs tower id.

Arguments:

    ProtseqId - Tower id of the protseq in question.

Return Value:

    NULL if the id is invalid.

    non-NULL if the id is valid - note the pointer doesn't need to be freed.

--*/

{
    ASSERT(ProtseqId);

    if (ProtseqId < PROTSEQ_IDS)
        {
        return(gaProtseqInfo[ProtseqId].pwstrProtseq);
        }
    return(0);
}


PWSTR
GetEndpoint(
    IN USHORT ProtseqId
    )
/*++

Routine Description:

    Returns the well known endpoint associated with the protseq.

Arguments:

    ProtseqId - the id (See GetProtseqId()) of the protseq in question.

Return Value:

    0 - Unknown/invalid id.

    !0 - The endpoint associated with the protseq.
         note: should not be freed.

--*/
{
    ASSERT(ProtseqId);

    if (ProtseqId < PROTSEQ_IDS)
        {
        return(gaProtseqInfo[ProtseqId].pwstrEndpoint);
        }
    return(0);
}


USHORT
GetProtseqId(
    IN PWSTR Protseq
    )
/*++

Routine Description:

    Returns the tower id for a protseq.

    This could be changed to a faster search, but remember that
    eventually the table will NOT be static.  (ie. we can't just
    create a perfect hash based on the static table).

Arguments:

    Protseq - a unicode protseq to lookup.  It is assumed
              to be non-null.

Return Value:

    0 - unknown/invalid protseq
    non-zero - the id.

--*/
{
    int i;
    ASSERT(Protseq);

    for(i = 1; i < PROTSEQ_IDS; i++)
        {
        if (    0 != gaProtseqInfo[i].pwstrProtseq
             && 0 == lstrcmpW(gaProtseqInfo[i].pwstrProtseq, Protseq))
            {
            return((USHORT)i);
            }
        }
    return(0);
}


USHORT
GetProtseqIdAnsi(
    IN PSTR pstrProtseq
    )
/*++

Routine Description:

    Returns the tower id for a protseq.

    This could be changed to a faster search, but remember that
    eventually the table will NOT be static.  (ie. we can't just
    create a perfect hash based on the static table).

Arguments:

    Protseq - an ansi (8 bit char) protseq to lookup.  It is assumed
              to be non-null.

Return Value:

    0 - unknown/invalid protseq
    non-zero - the id.

--*/
{
    int i;
    ASSERT(pstrProtseq);

    for(i = 1; i < PROTSEQ_IDS; i++)
        {
        if (0 != gaProtseqInfo[i].pwstrProtseq)
            {
            PWSTR pwstrProtseq = gaProtseqInfo[i].pwstrProtseq;
            PSTR  pstrT = pstrProtseq;

            while(*pstrT && *pwstrProtseq && *pstrT == *pwstrProtseq)
                {
                pstrT++;
                pwstrProtseq++;
                }
            if (*pstrT == *pwstrProtseq)
                {
                return((USHORT)i);
                }
            }
        }
    return(0);
}

const PWSTR NICConfigKey = L"System\\CurrentControlSet\\Services\\RpcSs";
const PWSTR ListenOnInternet = L"ListenOnInternet";


RPC_STATUS
InitializeEndpointManager(
    VOID
    )
/*++

Routine Description:

    Called when the dcom service starts.

Arguments:

    None

Return Value:

    RPC_S_OUT_OF_MEMORY - if needed

    RPC_S_OUT_OF_RESOURCES - usually on registry failures.

--*/
{
    HKEY hkey;
    DWORD size, type, value;
    RPC_STATUS status;

    status = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                           (PWSTR)NICConfigKey,
                           0,
                           KEY_READ,
                           &hkey);

    if (status != RPC_S_OK)
        {
        ASSERT(status == ERROR_FILE_NOT_FOUND);
        return(RPC_S_OK);
        }

    size = sizeof(value);
    status = RegQueryValueExW(hkey,
                              (PWSTR)ListenOnInternet,
                              0,
                              &type,
                              (PBYTE)&value,
                              &size);

    if ( status == RPC_S_OK )
    {
        if ((type != REG_SZ)
        || (*(PWSTR)&value != 'Y'
             && *(PWSTR)&value != 'y'
             && *(PWSTR)&value != 'N'
             && *(PWSTR)&value != 'n'))
            {
            goto Cleanup;
            }

    if (*(PWSTR)&value == 'Y'
       || *(PWSTR)&value == 'y')
       {
       fListenOnInternet = TRUE;
       }
    else
       {
       fListenOnInternet = FALSE;
       }
    }

Cleanup:
    RegCloseKey(hkey);
    return(RPC_S_OK);
}


BOOL
IsLocal(
    IN USHORT ProtseqId
    )
/*++

Routine Description:

    Determines if the protseq id is local-only. (ncalrpc)

Arguments:

    ProtseqId - The id of the protseq in question.

Return Value:

    TRUE - if the protseq id is local-only
    FALSE - if the protseq id invalid or available remotely.

--*/
{
    return(ProtseqId == ID_LPC);
}


RPC_STATUS
DelayedUseProtseq(
    IN USHORT id
    )
/*++

Routine Description:

    If the protseq is not being used its state is changed
    so that a callto CompleteDelayedUseProtseqs() will actually
    cause the server to listen to the protseq.

    This is called when an RPC server registers an dynamic
    endpoint on this protocol.

Arguments:

    id - the id of the protseq you wish to listen to.

Return Value:

    0 - normally

    RPC_S_INVALID_RPC_PROTSEQ - if id is invalid.

--*/
{
#if !defined(SPX_IPX_OFF)
    // For IPX and SPX
    if ( 
#if defined(IPX_ON)
        (id == ID_IPX) 
          || 
#endif
#if defined(SPX_ON)
        (id == ID_SPX) 
#endif
       )
        {
        gfDelayedAdvertiseSaps = TRUE;
        }
#endif

    if (id < PROTSEQ_IDS)
        {
        if (gaProtseqInfo[id].pwstrProtseq != 0)
            {
            if (gaProtseqInfo[id].state == STOPPED)
                gaProtseqInfo[id].state = START;
            return(RPC_S_OK);
            }

        }
    return(RPC_S_INVALID_RPC_PROTSEQ);
}


VOID
CompleteDelayedUseProtseqs(
    VOID
    )
/*++

Routine Description:

    Start listening to any protseqs previously passed
    to DelayedUseProtseq().  No errors are returned,
    but informationals are printed on debug builds.

Arguments:

    None

Return Value:

    None

--*/
{
    USHORT i;

    for(i = 1; i < PROTSEQ_IDS; i++)
        {
        if (START == gaProtseqInfo[i].state)
            {
            RPC_STATUS status = UseProtseqIfNecessary(i);
#ifdef DEBUGRPC
            if (RPC_S_OK == status)
                ASSERT(gaProtseqInfo[i].state == STARTED);
#endif
            }
        }

#if !defined(SPX_IPX_OFF)
    if (gfDelayedAdvertiseSaps)
        {
        gfDelayedAdvertiseSaps = FALSE;
        UpdateSap(SAP_CTRL_MAYBE_REGISTER);
        }
#endif
}

#if !defined(SPX_IPX_OFF)

RPC_STATUS
ServiceInstalled(
    PWSTR ServiceName
    )
/*++

Routine Description:

    Tests if a service is installed.

Arguments:

    ServiceName - The unicode name (short or long) of the service
        to check.

Return Value:

    0 - service installed
    ERROR_SERVICE_DOES_NOT_EXIST - service not installed
    other - parameter or resource problem

--*/
{
    SC_HANDLE ScHandle;
    SC_HANDLE ServiceHandle;

    ScHandle = OpenSCManagerW(0, 0, GENERIC_READ);

    if (ScHandle == 0)
        {
        return(ERROR_SERVICE_DOES_NOT_EXIST);
        }

    ServiceHandle = OpenService(ScHandle, ServiceName, GENERIC_READ);

    if (ServiceHandle == 0)
        {
        #if DBG
        if (GetLastError() != ERROR_SERVICE_DOES_NOT_EXIST)
            {
            KdPrintEx((DPFLTR_DCOMSS_ID,
                       DPFLTR_WARNING_LEVEL,
                       "OR: Failed %d opening the %S service\n",
                       GetLastError(),
                       ServiceName));
            }
        #endif

        CloseServiceHandle(ScHandle);
        return(ERROR_SERVICE_DOES_NOT_EXIST);
        }

    // Service installed

    CloseServiceHandle(ScHandle);
    CloseServiceHandle(ServiceHandle);

    return(RPC_S_OK);
}



const GUID RPC_SAP_SERVICE_TYPE = SVCID_NETWARE(0x640);

void
UpdateSap(
    enum SAP_CONTROL_TYPE action
    )
/*++

Routine Description:

    Starts, stops, or updates the periodic SPX SAP broadcasts that allow an RPC
    client to map the server name to an IPX address. To understand IPX and SAP,
    read "IPX Router Specification", Novell part # 107-000029-001.

    A SAP broadcast will be processed by several categories of machines
    - all machines in the local subnet(s) will have to read and discard the packet
    - routers connected to the local subnet(s) will add the data to the info they
      periodically exchange with other routers
    - Netware-compatible servers will add the info to their Bindery tables.

    That is why not all NT machines should SAP.

Arguments:

    action:

        SAP_CTRL_FORCE_REGISTER: begin sapping

        SAP_CTRL_MAYBE_REGISTER: begin sapping only if the Netware-compatible
                                 workstation and/or the SAP Agent service is
                                 installed. File/Print Svcs for Netware forces the
                                 SAP Agent, so it too will enable sapping.

        SAP_CTRL_UPDATE_ADDRESS: a net card was added or subtracted, or the network
                                 address changed.  Re-register if sapping is already
                                 active.

        SAP_CTRL_UNREGISTER:     stop sapping

--*/
{
    DWORD status;
    HKEY hKey;

    // Service paramaters
    NT_PRODUCT_TYPE type;

    if (RegistryState == RegStateUnknown)
        {
        // The registry key has absolute control of SAPing

        status = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                              TEXT("Software\\Microsoft\\Rpc"),
                              0,
                              KEY_READ,
                              &hKey);

        if (status == ERROR_SUCCESS)
            {
            WCHAR pwstrValue[8];
            DWORD dwType, dwLenBuffer;
            dwLenBuffer = sizeof(pwstrValue);


            status = RegQueryValueEx(hKey,
                                     TEXT("AdvertiseRpcService"),
                                     0,
                                     &dwType,
                                     (PBYTE)pwstrValue,
                                     &dwLenBuffer
                                    );

            if (   status == ERROR_SUCCESS
                && dwType == REG_SZ)
                {
                if (   pwstrValue[0] == 'y'
                    || pwstrValue[0] == 'Y' )
                    {
                    RegistryState = RegStateYes;
                    }
                else if (   pwstrValue[0] == 'n'
                         || pwstrValue[0] == 'N' )
                    {
                    RegistryState = RegStateNo;
                    }
                else
                    {
                    // Value in the registry is wrong, pretend it doesn't exist.
                    RegistryState = RegStateMissing;
                    }
                }
            else
                {
                // Bad or missing value in the registry, pretend is doesn't exist.
                RegistryState = RegStateMissing;
                }

            RegCloseKey(hKey);
            }
        }

    switch (action)
        {
        case SAP_CTRL_FORCE_REGISTER:
            if (RegistryState == RegStateNo)
                {
                // "no" in registry trumps any registration
                return;
                }

            if (SapState == SapStateEnabled)
                {
                // already active
                return;
                }
            break;

        case SAP_CTRL_MAYBE_REGISTER:
            if (RegistryState == RegStateNo)
                {
                // "no" in registry trumps any registration
                return;
                }

            if (SapState == SapStateEnabled)
                {
                // already registered
                return;
                }

            if (RegistryState == RegStateYes)
                {
                // don't check services, just register.
                break;
                }

            if (SapState == SapStateNoServices)
                {
                ASSERT( RegistryState != RegStateYes ); // in case checks are rearranged
                // the appropriate services are not installed
                return;
                }

            //
            // Getting here means we don't know yet whether the proper services are installed.
            //
            // Depending on configuration, this controls if automatic
            // listens (due to DCOM configuration) enable SAPing or not.

            type = NtProductWinNt;
            RtlGetNtProductType(&type);

            status = ERROR_SERVICE_DOES_NOT_EXIST;

            if (type != NtProductWinNt)
                {
                // Server platform, try NWCWorkstation
                status = ServiceInstalled(L"NWCWorkstation");
                }

            if (status == ERROR_SERVICE_DOES_NOT_EXIST)
                {
                status = ServiceInstalled(L"NwSapAgent");
                }

            if (status == ERROR_SERVICE_DOES_NOT_EXIST)
                {
                SapState = SapStateNoServices;
                return;
                }

            //
            // Proper services are installed.
            //
            break;

        case SAP_CTRL_UPDATE_ADDRESS:
            if (SapState != SapStateEnabled)
                {
                return;
                }
            break;

        case SAP_CTRL_UNREGISTER:
            if (SapState == SapStateDisabled ||
                SapState == SapStateNoServices)
                {
                // already not registered
                }
            break;

        default:

            ASSERT( 0 );
        }

    AdvertiseNameWithSap();
}


void
AdvertiseNameWithSap()
/*++

Parameters:

Description:

Returns:

--*/
{
    // winsock (socket, bind, getsockname) parameters
    SOCKADDR_IPX        new_ipxaddr;
    static SOCKADDR_IPX old_ipxaddr = { AF_IPX, { 0 }, { 0 }, 0 } ;
    static CRITICAL_SECTION * pCritsec;

    SOCKET       s;
    int          err;
    int          size;

    //
    // A critical section protects old_ipxaddr since several different events lead to
    // calling this function.  The following code makes sure that the critical
    // section is created, and that all threads are using the same one.
    //
    if (!pCritsec)
        {
        CRITICAL_SECTION * myCritsec = HeapAlloc( GetProcessHeap(), 0, sizeof(CRITICAL_SECTION));
        if (!myCritsec)
            {
            return;
            }

        err = RtlInitializeCriticalSection( myCritsec );
        if (!NT_SUCCESS(err))
            {
            HeapFree(GetProcessHeap(), 0, myCritsec);
            return;
            }

        myCritsec = (CRITICAL_SECTION *) InterlockedExchangePointer( (PVOID *) &pCritsec, myCritsec );
        if (myCritsec)
            {
            HeapFree(GetProcessHeap(), 0, myCritsec);
            }
        }

    //
    // Get this server's IPX address.
    //
    s = socket( AF_IPX, SOCK_DGRAM, NSPROTO_IPX );
    if (s != -1)
        {
        size = sizeof(new_ipxaddr);

        memset(&new_ipxaddr, 0, sizeof(new_ipxaddr));
        new_ipxaddr.sa_family = AF_IPX;

        err = bind(s, (struct sockaddr *)&new_ipxaddr, sizeof(new_ipxaddr));
        if (err == 0)
            {
            err = getsockname(s, (struct sockaddr *)&new_ipxaddr, &size);
            }
        }
    else
        {
        err = -1;
        }

    if (err != 0)
        {
        KdPrintEx((DPFLTR_DCOMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "OR: socket() or getsockname() failed %d, aborting SAP setup\n",
                   GetLastError()));

        return;
        }

    if (s != -1)
        {
        closesocket(s);
        }

    EnterCriticalSection( pCritsec );

    if (0 != memcmp( old_ipxaddr.sa_netnum,  new_ipxaddr.sa_netnum,  sizeof(old_ipxaddr.sa_netnum)) ||
        0 != memcmp( old_ipxaddr.sa_nodenum, new_ipxaddr.sa_nodenum, sizeof(old_ipxaddr.sa_nodenum)))
        {
        memcpy( &old_ipxaddr, &new_ipxaddr, sizeof(old_ipxaddr) );

        LeaveCriticalSection( pCritsec );

        if (*((long *) &new_ipxaddr.sa_netnum) != IPX_BOGUS_NETWORK_NUMBER)
            {
            CallSetService( &new_ipxaddr, TRUE);
            }
        else
            {
            KdPrintEx((DPFLTR_DCOMSS_ID,
                       DPFLTR_WARNING_LEVEL,
                       "OR: SPX net number is bogus.  Not registering until a real address arrives. \n"));

            CallSetService( &new_ipxaddr, FALSE);
            }
        }
    else
        {
        LeaveCriticalSection( pCritsec );
        }
}


void
CallSetService(
    SOCKADDR_IPX * pipxaddr,
    BOOL fRegister
    )
/*++
Function Name:CallSetService

Parameters:

Description:

Returns:

--*/
{
    DWORD ignore;
    DWORD status;

    // SetService params
    WSAQUERYSETW     info;
    CSADDR_INFO      addresses;

    // GetComputerName parameters
    static WCHAR        buffer[MAX_COMPUTERNAME_LENGTH + 1];
    static BOOL         bufferValid = FALSE;

    if (!bufferValid)
        {
        // Get this server's name
        ignore = MAX_COMPUTERNAME_LENGTH + 1;
        if (!GetComputerNameW(buffer, &ignore))
            {
            return;
            }
        bufferValid = TRUE;
        }

    // We'll register only for the endpoint mapper port.  The port
    // value is not required but should be the same to avoid
    // confusing routers keeping track of SAPs...

    pipxaddr->sa_socket = htons(34280);

    // Fill in the service info structure.

    memset(&info, 0, sizeof(info));

    info.dwSize                     = sizeof(info);
    info.lpszServiceInstanceName    = buffer;
    info.lpServiceClassId           = (GUID *)&RPC_SAP_SERVICE_TYPE;
    info.lpszComment                = L"RPC Services";
    info.dwNameSpace                = NS_SAP;
    info.dwNumberOfCsAddrs          = 1;
    info.lpcsaBuffer                = &addresses;

    addresses.LocalAddr.iSockaddrLength = sizeof(SOCKADDR_IPX);
    addresses.LocalAddr.lpSockaddr = (LPSOCKADDR) pipxaddr;
    addresses.RemoteAddr.iSockaddrLength = sizeof(SOCKADDR_IPX);
    addresses.RemoteAddr.lpSockaddr = (LPSOCKADDR) pipxaddr;
    addresses.iSocketType = AF_IPX;
    addresses.iProtocol = NSPROTO_IPX;

    status = WSASetService(&info,
                           fRegister ? RNRSERVICE_REGISTER : RNRSERVICE_DEREGISTER,
                           0);

    ASSERT(status == SOCKET_ERROR || status == 0);
    if (status == SOCKET_ERROR)
        {
        status = GetLastError();
        }

    if (status == 0)
        {
        if (fRegister)
            {
            SapState = SapStateEnabled;
            }
        else
            {
            SapState = SapStateDisabled;
            }
        }
    else
        {
        KdPrintEx((DPFLTR_DCOMSS_ID,
                   DPFLTR_WARNING_LEVEL,
                   "OR: WSASetService(%s) failed %d\n",
                   fRegister ? "ENABLE" : "DISABLE",
                   status));
        }
    return;
}

#endif

extern void
DealWithDeviceEvent();


void RPC_ENTRY
UpdateAddresses( PVOID arg )
{
    // Calls to this function are serialized
    DealWithDeviceEvent();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\wrapper\sources.inc ===
!IF 0

Copyright (c) 1995  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Revision History:

!ENDIF

TARGETNAME=rpcss
TARGETTYPE=DYNLINK
TARGETLIBS= \
           $(SDK_LIB_PATH)\rpcrt4.lib   \
           $(SDK_LIB_PATH)\user32.lib \
           $(SDK_LIB_PATH)\advapi32.lib \
           $(SDK_LIB_PATH)\kernel32.lib \
           $(SDK_LIB_PATH)\secur32.lib \
           $(NET_LIB_PATH)\ndispnp.lib

USE_MSVCRT=1
MSC_WARNING_LEVEL=/W3 /WX
DLLDEF=..\dcomss.def
DLLENTRY=_DllMainCRTStartup

UMTYPE=console
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\wrapper\chicago\rpcss.cxx ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    rpcss.c

Author:

    Rong Chen       [RongC]

Revision History:

    RongC           09-16-98

--*/
#include <dcomss.h>

VOID WINAPI ServiceMain(DWORD, PWSTR[]);

int __cdecl main(int argc, char *argv[])
{
    ServiceMain(0, 0);
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\wrapper\start.cxx ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    Start.c

Abstract:

    Process init and service controller interaction for dcomss.exe

Author:

    Mario Goertzel    [MarioGo]

Revision History:

    MarioGo    06-14-95    Cloned from the old endpoint mapper.
    MazharM    10-12.98    Add pnp stuff
    TarunA     12-11-98    Removed pnpmngr.h
    a-sergiv   25-08-99    Defined gC2Security for process-wide use

--*/

//#define NCADG_MQ_ON

#if !defined(_M_IA64)
#define SPX_ON
#endif

//#define IPX_ON

#if !defined(SPX_ON) && !defined(IPX_ON)
#define SPX_IPX_OFF
#endif

#include <dcomss.h>
#include <debnot.h>
#include <olesem.hxx>
#include <wtypes.h>
#include <objbase.h>
#include <winioctl.h>
#include <ntddndis.h>
#include <ndispnp.h>
#include <dbt.h>
#include <initguid.h>
#include <ndisguid.h>
#include <ndispnp.h>

#ifndef SPX_IPX_OFF
#include "sap.h"
#endif

#include "../../com/inc/secdes.hxx"

extern LONG g_bInSCM;  // from catalog
C2Security  gC2Security;
// Array of service status blocks and pointers to service control
// functions for each component service.

#define SERVICE_NAME L"RPCSS"
#define DEVICE_PREFIX   L"\\\\.\\"

VOID WINAPI ServiceMain(DWORD, PWSTR[]);

extern BOOL CatalogDllMain (
    HINSTANCE hInst,
    DWORD dwReason,
    LPVOID lpReserved
);

void NotifyCOMOnSuspend();
void NotifyCOMOnResume();

extern DWORD gLockTlsIdx;
SERVICE_TABLE_ENTRY gaServiceEntryTable[] = {
    { SERVICE_NAME, (LPSERVICE_MAIN_FUNCTION)ServiceMain},
    { NULL, NULL }
    };

static SERVICE_STATUS        gServiceStatus;
static SERVICE_STATUS_HANDLE ghServiceHandle;


#define OFFSET_TO_PTR(val, start)              \
    (val) = ((val) == NULL) ? NULL : (PWCHAR) ( (PCHAR)(val) + (ULONG_PTR)(start))

EXTERN_C const IID IID_IAssertConfig;  // make the linker happy

void
CookupNodeId(PUCHAR NodeId)
/*++

Routine Description:

    This routine is called when all else fails.  Here we mix a bunch of
    system parameters together for a 47bit node ID.

Arguments:

    NodeId - Will be set to a value unlikly to be duplicated on another
             machine. It is not guaranteed to be unique even on this machine.
             But since UUIDs are (time + sequence) this is okay for
             a local UUID.

             It will be composed of:
             The computer name.
             The value of the performance counter.
             The system memory status.
             The total bytes and free bytes on C:
             The stack pointer (value).
             An LUID (locally unique ID)
             Plus whatever random stuff was in the NodeId to begin with.

             The NodeId returned is explicity made into a Multicast IEEE 802
             address so that it will not conflict with a 'real' IEEE 802
             based UUID.
--*/
{
    unsigned char LocalNodeId[6];                            // NOT initialized.
    unsigned char ComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    BOOL BoolResult;
    ULONG i = MAX_COMPUTERNAME_LENGTH+1;
    LARGE_INTEGER largeInt;
    LUID luid;
    ULONG UNALIGNED *NodeIdPart1 = (ULONG *)&LocalNodeId[0]; // Bytes 0 - 3
    ULONG UNALIGNED *NodeIdPart2 = (ULONG *)&LocalNodeId[2]; // Bytes 2 - 5
    MEMORYSTATUS memStatus;
    ULONG SectorsPerCluster;
    ULONG BytesPerSector;
    ULONG TotalClusters;
    ULONG FreeClusters;

    // Initialize the LocalNodeId.  Seventeen is the most random, random number.

    memset(LocalNodeId, 17, sizeof(LocalNodeId));

    // The computer name is xor'ed in until it runs out.

    BoolResult =
    GetComputerNameA((CHAR *)ComputerName, &i);

    if (BoolResult)
        {
        unsigned char *p = ComputerName;
        i = 0;
        while(*p)
            {
            *( ((unsigned char *)LocalNodeId) + i) ^= *p++;
            if (++i > 6)
                {
                i = 0;
                }
            }
        }
    else
        {
        #if DBG
        DbgPrint ("GetComputerName failed - %d\n", GetLastError());
        #endif
        }

    // The performance counter is xor'ed into the LocalNodeId.

    BoolResult =
    QueryPerformanceCounter(&largeInt);

    if (BoolResult)
        {
        *NodeIdPart2 ^= largeInt.HighPart ^ largeInt.LowPart;
        *NodeIdPart1 ^= largeInt.HighPart ^ largeInt.LowPart;
        }
    else
        {
        #if DBG
        DbgPrint ("QueryPreformanceCount failed - %d\n", GetLastError());
        #endif
        }

    // The current SP is xor'ed into both parts of the LocalNodeId.

    *NodeIdPart1 ^= (ULONG_PTR)&LocalNodeId;
    *NodeIdPart2 ^= (ULONG_PTR)&LocalNodeId;

    // The memory status is Xor's into the LocalNodeId.
    memStatus.dwLength = sizeof(MEMORYSTATUS);

    GlobalMemoryStatus(&memStatus);

    *NodeIdPart1 ^= memStatus.dwMemoryLoad;
    *NodeIdPart2 ^= memStatus.dwTotalPhys;
    *NodeIdPart1 ^= memStatus.dwAvailPhys;
    *NodeIdPart1 ^= memStatus.dwTotalPageFile;
    *NodeIdPart2 ^= memStatus.dwAvailPageFile;
    *NodeIdPart2 ^= memStatus.dwTotalVirtual;
    *NodeIdPart1 ^= memStatus.dwAvailVirtual;

    // LUID's are good on this machine during this boot only.

    BoolResult =
    AllocateLocallyUniqueId(&luid);

    if (BoolResult)
        {
        *NodeIdPart1 ^= luid.LowPart;
        *NodeIdPart2 ^= luid.HighPart;
        }
    else
        {
        #if DBG
        DbgPrint ("Status %d\n", GetLastError());
        #endif
        }

    // Disk parameters and free space

    BoolResult =
    GetDiskFreeSpaceA("c:\\",
                      &SectorsPerCluster,
                      &BytesPerSector,
                      &FreeClusters,
                      &TotalClusters
                     );

    if (BoolResult)
        {
        *NodeIdPart2 ^= TotalClusters * SectorsPerCluster * BytesPerSector;
        *NodeIdPart1 ^= FreeClusters * SectorsPerCluster * BytesPerSector;
        }
    else
        {
        #if DBG
        DbgPrint ("GetDiskFreeSpace failed - %d\n", GetLastError());
        #endif
        }

    // Or in the 'multicast' bit to distinguish this NodeId
    // from all other possible IEEE 802 addresses.

    LocalNodeId[0] |= 0x80;

    memcpy(NodeId, LocalNodeId, 6);
}

BOOLEAN
getMacAddress (
    PUCHAR pMacAddress
    )
/*++
Function Name:getMacAddress

Parameters:

Description:

Returns:

--*/
{
    int i;
    UINT fStatus;
    int Size = 1024*5;
    PNDIS_ENUM_INTF Interfaces;
    UCHAR       OidVendData[16];

    Interfaces = (PNDIS_ENUM_INTF) I_RpcAllocate (Size);
    if (Interfaces == 0)
        {
        return FALSE;
        }

    if (NdisEnumerateInterfaces(Interfaces, Size))
        {
        UINT i;

        for (i = 0; i < Interfaces->TotalInterfaces; i++)
            {
            PUNICODE_STRING pDeviceName= &(Interfaces->Interface[i].DeviceName);
            UCHAR           PermMacAddr[6];

            fStatus = NdisQueryHwAddress(pDeviceName, pMacAddress, PermMacAddr, &OidVendData[0]);
            if (fStatus && (OidVendData[0] != 0xFF
                || OidVendData[1] != 0xFF
                || OidVendData[2] != 0xFF))
                {
                I_RpcFree (Interfaces);

                return TRUE;
                }
            }
        }

    I_RpcFree (Interfaces);

    return FALSE;
}


extern "C" void
DealWithDeviceEvent()
/*++
Function Name: DealWithDeviceEvent

Parameters:

Description:

Returns:

--*/
{
    UCHAR MacAddress[8];
    NTSTATUS NtStatus;

    if (getMacAddress(&MacAddress[0]))
        {
        NtStatus = NtSetUuidSeed((PCHAR) &MacAddress[0]);
        }
    else
        {
        CookupNodeId(&MacAddress[0]);

        ASSERT(MacAddress[0] & 0x80);

        NtStatus = NtSetUuidSeed((PCHAR) &MacAddress[0]);
        }

    if (!NT_SUCCESS(NtStatus))
        {
        #if DBG
        DbgPrint("NtSetUuidSeed failed\n", NtStatus);
        #endif
        }

#if !defined(SPX_IPX_OFF)
    UpdateSap( SAP_CTRL_UPDATE_ADDRESS );
#endif
}


void
DealWithPowerStatusEvent(DWORD dwEvent)
{
    switch (dwEvent)
    {
    //
    // First the events we care about
    // 
    case PBT_APMSUSPEND:             // System is suspending operation.
        NotifyCOMOnSuspend();
        break;

    case PBT_APMRESUMESUSPEND:       // Operation resuming after suspension.
        // This is the normal, user-initiated resume after a suspend.
        NotifyCOMOnResume();
        break;
    
    case PBT_APMRESUMEAUTOMATIC:     // Operation resuming automatically after event.
        // For our purposes this is a regular resume, since we don't have any
        // direct dialogue with the user.  Eg, wake-on-lan might cause this.
        NotifyCOMOnResume();
        break;

    case PBT_APMRESUMECRITICAL:      // Operation resuming after critical suspension. 
        // This means we're resuming w/o previously having had a suspend
        // notification.   May have lost state (ie, ping set timers may have
        // rundown).  Let's process the resume anyway, so that the ping set 
        // timers start from scratch (might save somebody from a transient app
        // error).
        NotifyCOMOnResume();
        break;

    //
    // And then the ones we don't care about.
    // 
    case PBT_APMBATTERYLOW:          // Battery power is low.
    case PBT_APMOEMEVENT:            // OEM-defined event occurred.
    case PBT_APMPOWERSTATUSCHANGE:   // Power status has changed.
    case PBT_APMQUERYSUSPEND:        // Request for permission to suspend.
    case PBT_APMQUERYSUSPENDFAILED:  // Suspension request denied. 
        break;

    default:
        ASSERT(!"Unexpected power event.  Check to see if we should be dealing with it somehow.");
        break;
    }

    return;
}





ULONG WINAPI
ServiceHandler(
    DWORD   dwCode,
    DWORD dwEventType,
    PVOID EventData,
    PVOID pData
    )
/*++

Routine Description:

    Lowest level callback from the service controller to
    cause this service to change our status.  (stop, start, pause, etc).

Arguments:

    opCode - One of the service "Controls" value.
            SERVICE_CONTROL_{STOP, PAUSE, CONTINUE, INTERROGATE, SHUTDOWN}.

Return Value:

    None

--*/
{
    switch(dwCode) {

        case SERVICE_CONTROL_STOP:
        case SERVICE_CONTROL_PAUSE:
        case SERVICE_CONTROL_CONTINUE:
        default:
            #if DBG
            DbgPrint("%S: Unexpected service control message %d.\n", SERVICE_NAME, dwCode);
            #endif
            ASSERT(0);
            break;

        case SERVICE_CONTROL_INTERROGATE:
            // Service controller wants us to call SetServiceStatus.

            UpdateState(gServiceStatus.dwCurrentState);
            break ;

        case SERVICE_CONTROL_SHUTDOWN:
            // The machine is shutting down.  We'll be killed once we return.
            // Note, currently we don't register for these messages.
            break;

        case SERVICE_CONTROL_POWEREVENT:                        
            DealWithPowerStatusEvent(dwEventType);
            break;
        }

    return NO_ERROR;
}


VOID
UpdateState(
    DWORD dwNewState
    )
/*++

Routine Description:

    Updates this services state with the service controller.

Arguments:

    dwNewState - The next start for this service.  One of
            SERVICE_START_PENDING
            SERVICE_RUNNING

Return Value:

    None

--*/
{
    DWORD status = ERROR_SUCCESS;

    ASSERT( (dwNewState == SERVICE_RUNNING) ||
            (gServiceStatus.dwCurrentState != SERVICE_RUNNING) );

    switch (dwNewState)
        {

        case SERVICE_RUNNING:
        case SERVICE_STOPPED:
              gServiceStatus.dwCheckPoint = 0;
              gServiceStatus.dwWaitHint = 0;
              break;

        case SERVICE_START_PENDING:
        case SERVICE_STOP_PENDING:
              ++gServiceStatus.dwCheckPoint;
              gServiceStatus.dwWaitHint = 30000L;
              break;

        default:
              ASSERT(0);
              status = ERROR_INVALID_SERVICE_CONTROL;
              break;
        }

   if (status == ERROR_SUCCESS)
       {
       gServiceStatus.dwCurrentState = dwNewState;
       if (!SetServiceStatus(ghServiceHandle, &gServiceStatus))
           {
           status  = GetLastError();
           }
       }

   #if DBG
   if (status != ERROR_SUCCESS)
       {
       DbgPrint("%S: Failed to update service state: %d\n", SERVICE_NAME, status);
       }
   #endif

   // We could return a status but how would we recover?  Ignore it, the
   // worst thing is that services will kill us and there's nothing
   // we can about it if this call fails.

   return;
}

    
VOID WINAPI
ServiceMain(
    DWORD argc,
    PWSTR argv[]
    )
/*++

Routine Description:

    Callback by the service controller when starting this service.

Arguments:

    argc - number of arguments, usually 1

    argv - argv[0] is the name of the service.
           argv[>0] are arguments passed to the service.

Return Value:

    None

--*/
{
    DWORD status = ERROR_SUCCESS;

    // COM needs power standby\resume events
    const DWORD RPCSS_CONTROLS = SERVICE_ACCEPT_POWEREVENT;

    // set the initial stack to 12K. This ensures enough commit
    // so that server threads don't need to extend their stacks
    RpcMgmtSetServerStackSize(3 * 4096);

    DealWithDeviceEvent();

    ASSERT(   (argc >= 1 && lstrcmpiW(argv[0], SERVICE_NAME) == 0)
           || (argc == 0 && argv == 0));

#if DBG==1

    // Note that we've completed running the static constructors

    ASSERT(g_fDllState == DLL_STATE_STATIC_CONSTRUCTING);

    g_fDllState = DLL_STATE_NORMAL;

#endif

    // Initialize the mutex package
    status = RtlInitializeCriticalSection(&g_OleMutexCreationSem);
    if (!NT_SUCCESS(status))
        return;

    // Initialize TLS
    gLockTlsIdx = TlsAlloc();
    if (gLockTlsIdx == -1)
    {
        return;
    }


    // Initialize catalog
    CatalogDllMain (NULL, DLL_PROCESS_ATTACH, NULL);

    {   // Create a named event for Vista to toggle event logging

        // Check to see if the event logging is installed and enabled
        //
        long cb = 128;
        char szValue[128];
        if (RegQueryValueA(HKEY_CLASSES_ROOT,
                "CLSID\\{6C736DB0-BD94-11D0-8A23-00AA00B58E10}\\EnableEvents",
                szValue, &cb) == ERROR_SUCCESS && !strcmp(szValue, "1"))
        {
            // [Sergei O. Ivanov (a-sergiv), 28-Jun-99]
            // This code here used to grant access to the whole world. But the world
            // tends to try and mess you up. So we'll only grant them limited access.
            SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_WORLD_SID_AUTHORITY;
            PSID pSidEveryone        = NULL;
            PACL pAcl                = NULL;
            DWORD cbAcl              = 0;
            ACCESS_ALLOWED_ACE *pAce = NULL;

            AllocateAndInitializeSid(&SidAuthority, 1, SECURITY_WORLD_RID,
                0, 0, 0, 0, 0, 0, 0, &pSidEveryone);

            if(pSidEveryone)
            {
                cbAcl = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) + GetLengthSid(pSidEveryone);
                pAcl = (PACL) LocalAlloc(LMEM_FIXED, cbAcl);

                if(pAcl)
                {
                     InitializeAcl(pAcl, cbAcl, ACL_REVISION);
                     AddAccessAllowedAce(pAcl, ACL_REVISION, EVENT_QUERY_STATE|EVENT_MODIFY_STATE|SYNCHRONIZE|READ_CONTROL, pSidEveryone);
                }
            }

            // Create security descriptor and attach the DACL to it
            SECURITY_DESCRIPTOR sd;
            InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);
            SetSecurityDescriptorDacl(&sd, TRUE, pAcl, FALSE);

            SECURITY_ATTRIBUTES sa;
            sa.nLength = sizeof(sa);
            sa.bInheritHandle = FALSE;
            sa.lpSecurityDescriptor = &sd;

            // The toggle event, which is signaled by LEC and checked by all.

            // The handle never closes during the process
            HANDLE hLeak1 = CreateEventA(
                        &sa,        /* Security */
                        TRUE,       /* Manual reset */
                        FALSE,      /* InitialState is non-signaled */
                        "MSFT.VSA.IEC.STATUS.6c736db0" /* Name */
                        );

            if(pSidEveryone) FreeSid(pSidEveryone);
            if(pAcl) LocalFree(pAcl);
        }
    }

    // Tell catalog it's running in SCM
    g_bInSCM = TRUE;

    gServiceStatus.dwServiceType             = SERVICE_WIN32_OWN_PROCESS;
    gServiceStatus.dwCurrentState            = SERVICE_START_PENDING;
    gServiceStatus.dwControlsAccepted        = RPCSS_CONTROLS;
    gServiceStatus.dwWin32ExitCode           = 0;
    gServiceStatus.dwServiceSpecificExitCode = 0;
    gServiceStatus.dwCheckPoint              = 0;
    gServiceStatus.dwWaitHint                = 3000L;

    ghServiceHandle = RegisterServiceCtrlHandlerEx(SERVICE_NAME,
                                                     ServiceHandler,
                                                     UIntToPtr(0xCAFECAFE) );

    if (0 == ghServiceHandle)
        {
        status = GetLastError();
        ASSERT(status != ERROR_SUCCESS);
        }

    if (status == ERROR_SUCCESS)
        {
        UpdateState(SERVICE_START_PENDING);
        }

    if (status == ERROR_SUCCESS)
        {
        // epts.c
        status = InitializeEndpointManager();
        }


#ifndef _CHICAGO_
    // Start Ep Mapper.
    if (status == ERROR_SUCCESS)
        {
        // ..\epmap\server.c
        UpdateState(SERVICE_START_PENDING);
        status = StartEndpointMapper();
        }

#ifdef NCADG_MQ_ON
    // Start MQ Manager Interface
    if (status == ERROR_SUCCESS)
        {
        UpdateState(SERVICE_START_PENDING);
        status = StartMqManagement();
        }
#endif  // NCADG_MQ_ON
#endif
	
    // Do pre-listen olescm initialization
    if (status == ERROR_SUCCESS)
        {
        UpdateState(SERVICE_START_PENDING);
        status = InitializeSCMBeforeListen();
        }

    // Start object resolver
    if (status == ERROR_SUCCESS)
        {
        // ..\objex\objex.cxx
        UpdateState(SERVICE_START_PENDING);
        status = StartObjectExporter();
        }

    // Start OLESCM
    if (status == ERROR_SUCCESS)
        {
        UpdateState(SERVICE_START_PENDING);
        status = InitializeSCM();
        }

    // Start listening for RPC requests
    if (status == ERROR_SUCCESS)
        {
        status = RpcServerListen(1, 1234, TRUE);

        if (status == RPC_S_OK)
            {
            while (RpcMgmtIsServerListening(0) == RPC_S_NOT_LISTENING)
                {
                Sleep(100);
                }
            }
        }

    //
    // There is some initialization that must be done after we
    // have done the RpcServerListen.
    //
    if (status == ERROR_SUCCESS)
    {
        // ..\olescm\scmsvc.cxx
        UpdateState(SERVICE_START_PENDING);
        InitializeSCMAfterListen();
    }

    // Trim our working set - free space now at the cost of time later.
    if (status == ERROR_SUCCESS)
        {
        UpdateState(SERVICE_RUNNING);
        }

#ifdef DEBUGRPC
    if (status != ERROR_SUCCESS)
        {
        DbgPrint("RPCSS ServiceMain failed %d (%08x)\n", status, status);
        }
#endif

    if (status == ERROR_SUCCESS)
        {
        ObjectExporterWorkerThread(0);
        ASSERT(0);
        }

    return;
}


extern HRESULT PrivGetRPCSSInfo(REFCLSID rclsid, REFIID riid, void** pIntf);

extern "C"
{

STDAPI GetRPCSSInfo(REFCLSID rclsid, REFIID riid, void** ppv)
{
  return PrivGetRPCSSInfo(rclsid, riid, ppv);
};

STDAPI GetCatalogHelper(REFIID riid, void** ppv);
    
STDAPI CoGetComCatalog(REFIID riid, void** ppv)
{
    return GetCatalogHelper (riid, ppv);
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dll\sources.inc ===
SYNCHRONIZE_DRAIN=1

# define WX86OLE if WX86 hooks are to be included in OLE
!IF $(386) || $(WIN64)
!ELSE
C_DEFINES=    \
	      /DWX86OLE $(C_DEFINES)
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dcomss\wrapper\chicago\rtl.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    rtl.c

Abstract:

    All routines are copied from NT sources tree (NTOS\rtl)

Author:

    Rong Chen       [RONGC]    26-Oct-1998

Environment:

    Pure utility routine

--*/

#define _NTSYSTEM_  1   // see ntdef.h.  We can't use DECLSPEC_IMPORT here

#include <nt.h>
#include <ntdef.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <string.h>
#include <windows.h>


NTSYSAPI NTSTATUS NTAPI
RtlInitializeCriticalSection(PRTL_CRITICAL_SECTION CriticalSection)
{
    // HACK - Win9x might go nuts as we can't check error return (who cares?)
    //
    InitializeCriticalSection(CriticalSection);
    return STATUS_SUCCESS;
}


NTSYSAPI NTSTATUS NTAPI
RtlDeleteCriticalSection(PRTL_CRITICAL_SECTION CriticalSection)
{
    DeleteCriticalSection(CriticalSection);
    return STATUS_SUCCESS;
}


NTSYSAPI VOID NTAPI
RtlInitAnsiString(
    OUT PANSI_STRING DestinationString,
    IN PCSZ SourceString OPTIONAL
    )

/*++

Routine Description:

    The RtlInitAnsiString function initializes an NT counted string.
    The DestinationString is initialized to point to the SourceString
    and the Length and MaximumLength fields of DestinationString are
    initialized to the length of the SourceString, which is zero if
    SourceString is not specified.

Arguments:

    DestinationString - Pointer to the counted string to initialize

    SourceString - Optional pointer to a null terminated string that
        the counted string is to point to.


Return Value:

    None.

--*/

{
    ULONG Length;

    DestinationString->Buffer = (PCHAR)SourceString;
    if (ARGUMENT_PRESENT( SourceString )) {
        Length = strlen(SourceString);
        DestinationString->Length = (USHORT)Length;
        DestinationString->MaximumLength = (USHORT)(Length+1);
        }
    else {
        DestinationString->Length = 0;
        DestinationString->MaximumLength = 0;
        }
}


LARGE_INTEGER SecondsToStartOf1980 = {0xc8df3700, 0x00000002};
LARGE_INTEGER Magic10000000 = {0xe57a42bd, 0xd6bf94d5};
#define SHIFT10000000                    23

#define Convert100nsToSeconds(LARGE_INTEGER) (                              \
    RtlExtendedMagicDivide( (LARGE_INTEGER), Magic10000000, SHIFT10000000 ) \
    )

NTSYSAPI BOOLEAN NTAPI
RtlTimeToSecondsSince1980 (
    IN PLARGE_INTEGER Time,
    OUT PULONG ElapsedSeconds
    )

/*++

Routine Description:

    This routine converts an input 64-bit NT Time variable to the
    number of seconds since the start of 1980.  The NT time must be
    within the range 1980 to around 2115.

Arguments:

    Time - Supplies the Time to convert from

    ElapsedSeconds - Receives the number of seconds since the start of 1980
        denoted by Time

Return Value:

    BOOLEAN - TRUE if the input Time is within a range expressible by
        ElapsedSeconds and FALSE otherwise

--*/

{
    LARGE_INTEGER Seconds;

    //
    //  First convert time to seconds since 1601
    //

    Seconds = Convert100nsToSeconds( *(PLARGE_INTEGER)Time );

    //
    //  Then subtract the number of seconds from 1601 to 1980.
    //

    Seconds.QuadPart = Seconds.QuadPart - SecondsToStartOf1980.QuadPart;

    //
    //  If the results is negative then the date was before 1980 or if
    //  the results is greater than a ulong then its too far in the
    //  future so we return FALSE
    //

    if (Seconds.HighPart != 0) {

        return FALSE;

    }

    //
    //  Otherwise we have the answer
    //

    *ElapsedSeconds = Seconds.LowPart;

    //
    //  And return to our caller
    //

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dll\chicago\makefile.inc ===
obj\$(TARGET_DIRECTORY)\ole32.def: ole32.src
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dll\daytona\makefile.inc ===
BuildComPs: $(O)\ComPs.Lib $(O)\ole32p.lib

##
## Play wacky import libary tricks with lib!
## This generates ComPs.Lib, from ole32.lib.
## If you link your proxy-stub dll with this library,
## you get an interface helper library, which lets
## you do interception on non-oleaut compatible interfaces.
##
COMPSDIR=$(COMP_OLE32_DIR)\com\txf\comps\static\$(O)

$(O)\ComPs.Lib : $(DYNLINK_LIB) $(COMPSDIR)\ComPsStaticLib.Lib
	del $@
	lib /out:$@ $**
	

$(O)\ole32p.def : ..\ole32.def
    @type <<$(ECHO_RSP)
$(ECHO_MSG) /DPRIVATE /EP ..\ole32.def
<<NOKEEP
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /DEXPORT_PRIVATE_API /Tc..\ole32.def > $@
$(CPPXX: =
)
<<NOKEEP

$(O)\ole32p.lib : $(O)\ole32p.def $(IMPLIB_DEPEND)
    -$(LIB_NAME) -out:$(@R).lib @<<
$(LIBRARIAN_FLAGS: =
)
-def:$(O)\ole32p.def
$(LIBRARY_OBJS: =
)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dll\hydra\makefile.inc ===
!include ..\daytona\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dllhost\debug.cxx ===
//
// Debug.cpp -- COM+ Debugging Flags
//
// COM+ 1.0
// Copyright 1998 Microsoft Corporation.  All Rights Reserved.
//
// Jim Lyon, March 1998.
//  

#include <windows.h>
#include "debug.hxx"

#if DBG == 1

// The data returned by this module:
BOOL		DebugFlags::sm_fDebugBreakOnLaunchDllHost = FALSE;

DebugFlags 	DebugFlags::sm_singleton;		// the only object of this class


// Constructor: Its job is to initialize the static members of this class
DebugFlags::DebugFlags()
{
	HKEY hKey;

	if (ERROR_SUCCESS != RegOpenKeyEx (HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\COM3\\Debug"), 0, KEY_READ, &hKey))
		return;			// no further initialization possible

	InitBoolean (hKey, TEXT("DebugBreakOnLaunchDllHost"), &sm_fDebugBreakOnLaunchDllHost);

	RegCloseKey (hKey);
}


// InitBoolean will initialize a boolean depending on a particular value in the registry.
// If the value starts with "Y" or "y", the boolean will be set to TRUE.
// If the value starts with "N" or "n", the boolean will be set to FALSE.
// If the value doesn't exist, or starts with anything else, the boolean will be unchanged.
void DebugFlags::InitBoolean (HKEY hKey, const TCHAR* tszValueName, BOOL* pf)
{
	TCHAR tszValue[20];
	unsigned long cbData = (sizeof tszValue) / (sizeof tszValue[0]);

	if (ERROR_SUCCESS != RegQueryValueEx (hKey, tszValueName, NULL, NULL, (BYTE*)tszValue, &cbData))
		return;

	if (((USHORT)tszValue[0] & 0xFFDF) == 'Y')
		*pf = TRUE;

	if (((USHORT)tszValue[0] & 0xFFDF) == 'N')
		*pf = FALSE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dllhost\csrgt.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       CSurrogate.cxx
//
//  Contents:   Class the implements the ISurrogate interface
//
//
//  History:    21-May-96 t-AdamE    Created
//				09-Apr-98 WilfR		 Updated for Unified Surrogate
//
//--------------------------------------------------------------------------

#include "csrgt.hxx"
#include "srgtdeb.hxx"


//+---------------------------------------------------------------------------
//
//  Function:   CSurrogate::~CSurrogate()
//
//  Synopsis:   destructor for CSurrogate
//
//  History:    4-09-98   WilfR   Created
//
//----------------------------------------------------------------------------
CSurrogate::~CSurrogate()
{
	if( _hEventSurrogateFree )
		CloseHandle( _hEventSurrogateFree );
}

//+---------------------------------------------------------------------------
//
//  Function:   CSurrogate::Init()
//
//  Synopsis:   Initializes data structures with error results
//
//  History:    4-09-98   WilfR		Created
//
//----------------------------------------------------------------------------
BOOL CSurrogate::Init()
{
	// create the event to be signaled when we are freed
	return (_hEventSurrogateFree = 
			  CreateEvent(NULL,FALSE,FALSE,NULL)) != NULL ? TRUE : FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   CSurrogate::QueryInterface
//
//  History:    6-21-96   t-Adame   Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CSurrogate::QueryInterface(REFIID iid, LPVOID FAR * ppv)
{
    if (iid == IID_IUnknown)
    {
		*ppv = (void*)(IUnknown*)this;
		AddRef();
		return S_OK;
    }
    else if (iid == IID_ISurrogate)
    {
		*ppv = (void*)(ISurrogate*)this;
		AddRef();
		return S_OK;
    }

    return E_NOINTERFACE;

}

//+---------------------------------------------------------------------------
//
//  Function:   CSurrogate::AddRef()
//
//  History:    6-21-96   t-Adame   Created
//
//----------------------------------------------------------------------------
ULONG CSurrogate::AddRef()
{
    InterlockedIncrement((LPLONG)&_cref);
    Win4Assert(_cref > 0);
    ULONG cref = _cref;	// NOTE: not thread safe but not worth worrying about
    return cref;
}

//+---------------------------------------------------------------------------
//
//  Function:   CSurrogate::Release()
//
//  Synopsis:   Decrements our Reference count -- note that this
//              implementation of ISurrogate does not delete the object
//              that implements it so that we can allocate it on the stack
//
//  History:    6-21-96   t-Adame   Created
//
//----------------------------------------------------------------------------
ULONG CSurrogate::Release()
{
    Win4Assert(_cref >0);
    InterlockedDecrement((LPLONG)&_cref);
    ULONG cref = _cref; // NOTE: not thread safe but not worth worrying about
    return cref;
}

//+---------------------------------------------------------------------------
//
//  Function:   CSurrogate::LoadDllServer
//
//  Synopsis:   Loads information about the dll corresponding to the specified
//              clsid into our table of loaded dlls, which implicitly
//              loads the dll into the surrogate process
//
//  History:    6-21-96   t-Adame   Created
//				4-09-98	  WilfR		This is never called for the Unified 
//								    Surrogate
//
//----------------------------------------------------------------------------
STDMETHODIMP CSurrogate::LoadDllServer( 
    /* [in] */ REFCLSID rclsid)
{
    SrgtDebugOut(DEB_SRGT_METHODCALL,"ISurrogate::LoadDllServer called\n",0);

	// TODO: I should probably put an assertion in here.
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   CSurrogate::FreeSurrogate
//
//  Synopsis:   called by OLE when there are no external references to clients
//              of dll servers that were loaded by this object.  A call
//              to this function signals the surrogate process that it should
//              terminate
//
//  History:    6-21-96   t-Adame   Created
//				4-09-98	  WilfR		Modified for Unified Surrogate
//
//----------------------------------------------------------------------------
STDMETHODIMP CSurrogate::FreeSurrogate()
{
    SrgtDebugOut(DEB_SRGT_METHODCALL,"ISurrogate::FreeSurrogate called\n",0);
    Win4Assert(_hEventSurrogateFree != NULL);

    return SetEvent(_hEventSurrogateFree) ? S_OK : E_FAIL;
}

//+---------------------------------------------------------------------------
//
//  Function:   CSurrogate::WaitForSurrogateFree
//
//  Synopsis:   sleep the main thread of the surrogate process until OLE
//              signals us via a call to FreeSurrogate that we should terminate.
//
//  History:    6-21-96   t-Adame   Created
//				4-09-98	  WilfR		Changed the name and implementation
//									for new Unified Surrogate. (implementation
//									was copied from 
//
//----------------------------------------------------------------------------
void CSurrogate::WaitForSurrogateFree()
{
    Win4Assert(_hEventSurrogateFree != NULL);

   	// wait for the FreeSurrogate method of ISurrogate to be called
   	// NOTE: in the previous incarnation of the surrogate we use to
   	// 		 timeout every 60 seconds to call CoFreeUnusedLibraries().
   	//       Since this was being done in the MTA and we do nothing to
   	//		 perform a similar tasks in the STAs we create its effectiveness
   	//		 is minimal.
   	
    WaitForSingleObject(_hEventSurrogateFree, INFINITE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dllhost\dllhst3g\assert.c ===
// HACKHACK - 

void _stdcall Win4AssertEx(char const * a, int b, char const * c)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\idl\internal\chicago\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\idl\internal\comhndl.h ===
//+-------------------------------------------------------------------
//
//  File:	comhndl.h
//
//  Contents:	Implicit COM parameters on raw RPCcalls
//
//  History:	24 Apr 95   AlexMit	Created
//
//--------------------------------------------------------------------
#ifndef _COMHNDL_H_
#define _COMHNDL_H_

// Define the implicit COM RPC parameters.

#ifdef RAW
    #define COM_HANDLE \
    [in] handle_t rpc, \
    [in, ref] ORPCTHIS *orpcthis, \
    [in, ref] LOCALTHIS *localthis, \
    [out, ref] ORPCTHAT *orpcthat,
#else
    #define COM_HANDLE
#endif

// Define some extra stuff.

#ifdef DO_NO_IMPORTS
    #define IMPORT_OBASE
#else
    #define IMPORT_OBASE import "obase.idl";
#endif

#ifdef DO_NO_IMPORTS
    #define IMPORT_UNKNOWN
#else
    #define IMPORT_UNKNOWN import "unknwn.idl";
#endif

    // These dummy members adjust the procedure number.
    // Since these exist on the raw side, the names have to be
    // unique in all interfaces.
#ifdef RAW
    #define COM_DEFINES(X)                            \
    IMPORT_OBASE 				   \
    HRESULT DummyQueryInterface##X( COM_HANDLE [in] DWORD dummy ); \
    HRESULT DummyAddRef##X( COM_HANDLE [in] DWORD dummy ); \
    HRESULT DummyRelease##X( COM_HANDLE [in] DWORD dummy );
#else
    #define COM_DEFINES(X) IMPORT_UNKNOWN
#endif

#endif // _COMHNDL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\idl\internal\daytona\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\idl\internal\oleprv.h ===
// oleprv.h - header files matching those needed by oleprv.idl
//

// internal interfaces used by DCOM
// this is private! (for now)

// NOTE: as entries are added to oleprv.idl, corresponding entries should
// be added here

#include "remunk.h"
#include "multqi.h"
#include "activate.h"
#include "catalog.h"
#include "objsrv.h"
#include "getif.h"

#ifdef SERVER_HANDLER
#include "srvhdl.h"
#endif

#include "odeth.h"
#include "host.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\dllhost\surrogat.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       surrogat.cxx
//
//  Contents:   Entry point for dll surrogate process
//
//  Synopsis:	this is the entry point for a surrogate process.  It must
//              perform the following tasks
//				1. Initialize OLE (multithreaded)
//              2. Create an object which implements ISurrogate, and register
//                 it with COM via CoRegisterSurrogateEx
//              3. Wait for all loaded dlls to be unloadable 
//              4. Uninitialize OLE
//
//  Functions:  WinMain
//              GetCommandLineArguments
//
//  History:    21-May-96 t-AdamE    Created
//				09-Apr-98 WilfR		 Modified for Unified Surrogate
//
//--------------------------------------------------------------------------

#include <iostream.h>
#include <windows.h>
#include "csrgt.hxx"
#include "surrogat.hxx"
#include "srgtdeb.hxx"

#include "debug.hxx"

DECLARE_INFOLEVEL(Surrogate); // debug only

// defined in unisrgt.idl (*.h)
STDAPI CoRegisterSurrogateEx( REFGUID rguidProcess, ISurrogate* pSurrogate );


int WINAPI WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow)
{
    GUID 	   	guidProcessID;	// will hold the ProcessID of this surrogate
    CHAR 		rgargv[cCmdLineArguments][MAX_PATH + 1];
    LPSTR 		argv[] = {rgargv[iProcessIDArgument]};
	HRESULT hr;
	LPSTR 		pProcessID;
    WCHAR 		wszProcessID[MAX_GUIDSTR_LEN + 1];

#if DBG == 1
	// check registry flags to break on launch (for debug)
	if( DebugFlags::DebugBreakOnLaunchDllHost() )
	{
		DebugBreak();
	}
#endif
    // command line format should be:
    // New Style: (/ProcessID:<process guid>)
    // Old style: ({appid guid})
    if(GetCommandLineArguments(lpCmdLine, argv,cCmdLineArguments,MAX_PATH) < 1)
    {
		Win4Assert( !"GetCommandLineArguments failed" );
		return 0;
    }

    // First Try new Style 
	// separate the cmdline switch from the cmdline arg (at the ':')
	for( pProcessID = argv[iProcessIDArgument]; *pProcessID != 0; pProcessID++ )
	{
		// this will zap the colon
		if(*pProcessID == ':')
		{
			*pProcessID++ = '\0';
			break;
		}
	}

#if 0
	// verify that the cmdline switch is what we are looking for
	if((*pProcessID == 0) || 
			(lstrcmpiA(argv[iProcessIDArgument], szProcessIDSwitch) != 0))
	{
		Win4Assert( !"Couldn't find /ProcessID:" );
		return 0;
	} 
#else
	if((*pProcessID == 0) || 
			(lstrcmpiA(argv[iProcessIDArgument], szProcessIDSwitch) != 0))
        pProcessID = argv[iProcessIDArgument];
#endif

    // we need a unicode string in order to get a guid, so convert
    // the ansi clsid string to unicode
    if(!(MultiByteToWideChar(CP_ACP, 0, pProcessID, lstrlenA(pProcessID) + 1,
			     			 wszProcessID, MAX_GUIDSTR_LEN + 1)))
    {
		Win4Assert( !"MultiByteToWideChar failed" );
		return 0;
    }

    // convert the ProcessID from a string to a guid
    if(FAILED(CLSIDFromString(wszProcessID,&guidProcessID)))
    {
		Win4Assert( !"CLSIDFromString failed" );
		return 0;
    }

    if(FAILED(CoInitializeEx(NULL,COINIT_MULTITHREADED)))
    {
		Win4Assert( !"CoInitEx failed" );
		return 0;
    }

    // Hand the thread to OLE for the duration
	hr = CoRegisterSurrogateEx(guidProcessID, NULL);

    CoUninitialize();

    // Because some of our threads don't exit cleanly, and can AV
    //  in those situations, we don't die gracefully.
    TerminateProcess(GetCurrentProcess(), 0);
    return 0;
}


//+---------------------------------------------------------------------------
//
//  Function:   GetCommandLineArguments
//
//  Synopsis:   Parses a the application's command line into a format
//              similar to the
//              argv parameter of the entry point main for console apps
//              Spaces are the delimiters
//
//  Arguments:  [rgwszArgs] -- an array of pointers to allocated Unicode
//              buffers
//              [cMaxArgs] -- This is the size of the rgwszArgs array (the
//              maximum number of arguments the array can hold).  
//              [cMaxArgLen] -- The maximum size of each buffer
//
//  Returns:    if successful, the function returns the number of arguments
//              parsed from the command line.  If the length of any argument
//              exceeds cMaxArgLen, the function fails and returns 0.
//
//              The function quits parsing and returns as soon as either of
//              the following conditions is met:
//               1. It reaches the end of the string, or
//               2. It parses cMaxArgs arguments.
//
//  Notes:      does not work with quoted arguments
//
//  History:    6-21-96   t-Adame   Created
//
//----------------------------------------------------------------------------
// REVIEW: when we had several commandline parameters this function was 
// justified, but now that the Surrogate has only one parameter, is all this
// really necessary?
int GetCommandLineArguments(LPSTR szCmdLine, LPSTR rgszArgs[], int cMaxArgs, int cMaxArgLen)
{
    int cchlen = lstrlenA(szCmdLine);
    int cArgsRetrieved = 0;
    int ichStart = 0;

    for(int ich = 0;ich < cchlen; ich++)
    {
		if(ichStart > cMaxArgLen)
		{
	    	return 0;
		}

		CHAR chcur = *(szCmdLine++);
		if(chcur == ' ')// REVIEW: no tab delimiting -- is this good?
		{
	    	if(ichStart)
	    	{
				rgszArgs[cArgsRetrieved++][ichStart] = '\0';
				ichStart = 0;

				if(cArgsRetrieved == cMaxArgs)
				{
					return cArgsRetrieved;
				}	

	    	}
		}
		else
		{
		    rgszArgs[cArgsRetrieved][ichStart++] = chcur;
		}
    }

    if(ichStart)
    {
		rgszArgs[cArgsRetrieved][ichStart] = '\0';
	    cArgsRetrieved++;
    }

    return cArgsRetrieved;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\idl\internal\makefile.inc ===
!ifndef MIDL
MIDL = midl.exe
!endif

# Paths
PUBLIC_IDL=..\..\public\

# Flags

MIDL_FLAGS= \
 $(MIDL_OPTIMIZATION) \
 -Zp8 \
 $(INCPATH0) \
 -oldnames \
 -dlldata nul \
 -proxy nul \
 -char unsigned \
 -ms_ext -c_ext \
 -DMIDL_PASS \
 $(C_DEFINES) \
 $(TARGET_DEFINES) \
 -cpp_cmd $(TARGET_CPP) \

MES_MIDL_FLAGS= \
 -Oicf -no_format_opt -error all \
 -Zp8 -robust \
 $(INCPATH0) \
 -oldnames \
 -dlldata nul \
 -proxy nul \
 -char unsigned \
 -ms_ext -c_ext \
 -DMIDL_PASS \
 $(C_DEFINES) \
 $(TARGET_DEFINES) \
 -cpp_cmd $(TARGET_CPP)



SSWITCH=-prefix sstub _
CSWITCH=-prefix cstub _

# Targets

# Dual (Raw/Object) local RPC interface for forwarding remote activation calls
# in DCOM95 -- RPCSS is the server

# first MIDL invocation makes the object header proxy and stub
# second MIDL invocation makes the client and the '_' prefixed server
# The client/server stubs for the object version are generated by mega.idl

$(O)\forward.h : ..\forward.idl $(SDK_INC_PATH)\obase.idl ..\forward.acf
     $(MIDL) $(MIDL_FLAGS) -header $(O)\forward.h \
        -iid nul -client none -server none ..\forward.idl

$(O)\rawforward.h : ..\forward.idl $(SDK_INC_PATH)\obase.idl ..\forward.acf
     $(MIDL) $(MIDL_FLAGS) -out $(O) -header rawforward.h \
        $(SSWITCH) -D RAW ..\forward.idl

# local resolver interface for DCOM95 (raw RPC only)

$(O)\resolve.h : ..\resolve.idl $(SDK_INC_PATH)\obase.idl ..\resolve.acf
     $(MIDL) $(SSWITCH) $(MIDL_FLAGS) -out $(O) -header resolve.h ..\resolve.idl



# only a header file generated
#$(O)\iface.h:  ..\iface.idl
#     $(MIDL) $(MIDL_FLAGS) -header $@ ..\iface.idl

# Local Resolver Interface for NT

$(O)\lclor.h:  ..\lclor.idl $(SDK_INC_PATH)\obase.idl ..\lclor.acf
     $(MIDL) $(SSWITCH) $(MIDL_FLAGS) -out $(O) -header lclor.h ..\lclor.idl

$(O)\orcb.h:  ..\orcb.idl $(SDK_INC_PATH)\obase.idl ..\orcb.acf
     $(MIDL) $(SSWITCH) $(MIDL_FLAGS) -out $(O) -header orcb.h ..\orcb.idl

# first MIDL invocation makes the object header
# the object proxy and stub are made with mega.idl
# second MIDL invocation makes the server and the '_' prefixed client
$(O)\odeth.h : ..\odeth.idl ..\..\private\iface.idl ..\odeth.acf \
              $(SDK_INC_PATH)\obase.idl $(PUBLIC_IDL)\remunk.idl ..\comhndl.h
     $(MIDL) $(MIDL_FLAGS) -out $(O) -header odeth.h \
        -client none -server none ..\odeth.idl

$(O)\rawodeth.h : ..\odeth.idl ..\..\private\iface.idl ..\odeth.acf \
                 $(SDK_INC_PATH)\obase.idl $(PUBLIC_IDL)\remunk.idl ..\comhndl.h
     $(MIDL) $(MIDL_FLAGS) -out $(O) -header rawodeth.h \
        $(SSWITCH) -D RAW ..\odeth.idl

# only a header file generated
$(O)\irot.h:  ..\irot.idl ..\irot.acf
     $(MIDL) $(MIDL_FLAGS) \
        -cstub $(O)\irot_c.c \
        -sstub $(O)\irot_s.c \
        -header $@ ..\irot.idl

# Only generate a header.  The object proxy and stub are made with
# mega.idl
$(O)\getif.h: ..\getif.idl
     $(MIDL) $(MIDL_FLAGS) \
        -client none -server none -header $@ \
        -iid $(O)\getif_i.c \
        ..\getif.idl


# Only generate a header.  The object proxy and stub are made with
# mega.idl
!ifdef SERVER_HANDLER
$(O)\srvhdl.h: ..\srvhdl.idl
     $(MIDL) $(MIDL_FLAGS) \
        -client none -server none -header $@ \
        -iid $(O)\srvhdl_i.c \
        ..\srvhdl.idl
!endif


# Only generate a header.  The object proxy and stub are made with
# mega.idl
$(O)\host.h: ..\host.idl
     $(MIDL) $(MIDL_FLAGS) \
        -client none -server none -header $@ \
        -iid $(O)\host_i.c \
        ..\host.idl


# Only generate a header.
$(O)\multqi.h: ..\multqi.idl
     $(MIDL) $(MIDL_FLAGS) \
        -client none -server none -header $@ \
        ..\multqi.idl

# Only generate a header.  The object proxy and stub are made with
# mega.idl
$(O)\apart.h: ..\apart.idl
     $(MIDL) $(MIDL_FLAGS) \
        -client none -server none -header $@ \
        -iid $(O)\apart_i.c \
        ..\apart.idl


# Only generate a header.  The object proxy and stub are made with
# mega.idl  --  this should be before actprops.idl
$(O)\custmact.h: ..\custmact.idl  ..\custmact.acf
     $(MIDL) $(MES_MIDL_FLAGS) \
        -cstub $(O)\custmact_c.c \
        -sstub $(O)\custmact_s.c \
        -header $@ \
        ..\custmact.idl


# Only generate a header.  The object proxy and stub are made with
# mega.idl
$(O)\serializ.h: ..\serializ.idl
     $(MIDL) $(MIDL_FLAGS) \
        -client none -server none -header $@ \
        -iid $(O)\serializ_i.c \
        ..\serializ.idl

$(O)\buffer.h:  ..\buffer.idl
     $(MIDL) $(MIDL_FLAGS) \
        -client none -server none -header $@ \
        -iid $(O)\buffer_i.c \
        ..\buffer.idl

# first MIDL invocation makes the object header
# the object proxy and stub are made with mega.idl
# second MIDL invocation makes the server and the '_' prefixed client
$(O)\objsrv.h: ..\objsrv.idl ..\objsrv.acf
     $(MIDL) $(MIDL_FLAGS) \
        -client none -server none -out $(O) -header objsrv.h \
        ..\objsrv.idl

$(O)\rwobjsrv.h: ..\objsrv.idl ..\objsrv.acf
     $(MIDL) $(MIDL_FLAGS) \
        -cstub $(O)\objsrv_c.c \
        -server none -header $@ \
        -D RAW \
        ..\objsrv.idl

# COM+ surrogate protocol interface
$(O)\srgtprot.h: ..\srgtprot.idl ..\srgtprot.acf
     $(MIDL) $(MIDL_FLAGS) \
        -cstub $(O)\srgtprot_c.c \
        -sstub $(O)\srgtprot_s.c \
        -header $@\
        ..\srgtprot.idl

# first MIDL invocation makes the server and the '_' prefixed client
# second MIDL invocation makes proxy for ole32.dll
$(O)\scm.h: ..\scm.idl ..\scm.acf
     $(MIDL) $(MIDL_FLAGS) \
        $(CSWITCH) \
        -cstub $(O)\scm_z.c \
        -sstub $(O)\scm_s.c \
        -header $@\
        ..\scm.idl

     $(MIDL) $(MIDL_FLAGS) \
        -cstub $(O)\scm_c.c \
        -server none -header $@ \
        ..\scm.idl

# first MIDL invocation makes the object header
# the object proxy and stub are made with mega.idl
# second MIDL invocation makes the server
$(O)\dscm.h: ..\dscm.idl
     $(MIDL) $(MIDL_FLAGS) \
        -client none -server none -header $@ \
        -iid $(O)\dscm_i.c \
        ..\dscm.idl

$(O)\rawdscm.h: ..\dscm.idl
     $(MIDL) $(MIDL_FLAGS) \
        -cstub ..\..\..\com\dcomrem\$(DEST_TREE)\dscm_c.c \
        -sstub $(O)\dscm_s.c \
        -header $@ \
        -D RAW \
        ..\dscm.idl

allidl:   $(O)\lclor.h $(O)\odeth.h $(O)\rawodeth.h $(O)\orcb.h \
          $(O)\irot.h $(O)\getif.h $(O)\host.h $(O)\objsrv.h $(O)\rwobjsrv.h  \
          $(O)\scm.h $(O)\apart.h $(O)\multqi.h $(O)\forward.h \
	      $(O)\rawforward.h $(O)\resolve.h $(O)\custmact.h $(O)\serializ.h \
          $(O)\buffer.h $(O)\srgtprot.h
	
clean:
          -erase $(O)\*.h      >NUL 2>NUL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\idl\internal\custmact_c_wrap.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       custmact_c_wrap.c
//
//  Contents:   Wrapper file
//
//  Functions:  Redefines MIDL_user_allocate\MIDL_user_free for the RPC 
//              functions defined in custmact.idl.
//
//  History:    24-Mar-01 JSimmons  Created
//
//--------------------------------------------------------------------------

#include <windows.h>

//--------------------------------------------------------------------------
//
// Why are we doing this?   We are doing this because RPC's pickling 
// functionality (encode, decode) has some issues when errors (typically
// out-of-mem) are encountered.  They do not guarantee the state of the
// out-params when encoding or decoding is ended prematurely.   One 
// suggestion was to modify MIDL_user_allocate to always zero out the 
// contents of any new allocation - this is undesirable from a perf 
// perspective, since it would impose a lot of unnecessary overhead
// for everybody.  Instead, we decided to overload alloc\free for 
// just those functions (encode\decode) that need it.   Our custom
// allocator will zero out any new memory allocations since RPC does
// not.  This will allow us to deterministically cleanup after any
// failed operations.   Fortunately all of the encode\decode functions
// are defined in one idl file, so this change is fairly localized.
//  
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//
//  Function:   CUSTMACT_MIDL_user_allocate
//
//  Purpose:    allocates memory on behalf of midl-generated stubs.  The 
//              memory block is zeroed out before returning.
//
//--------------------------------------------------------------------------
void* __RPC_API CUSTMACT_MIDL_user_allocate(size_t cb)
{
    void* pv = MIDL_user_allocate(cb);
    if (pv)
    {
        ZeroMemory(pv, cb);
    }
    return pv;
}

//+-------------------------------------------------------------------------
//
//  Function:   CUSTMACT_MIDL_user_free
//
//  Purpose:    frees memory allocated by CUSTMACT_MIDL_user_allocate
//
//--------------------------------------------------------------------------
void __RPC_API CUSTMACT_MIDL_user_free(void *pv)
{
    MIDL_user_free(pv);
}

//--------------------------------------------------------------------------
//
// Redefine MIDL_user_allocate and MIDL_user_free
//
// Note: Redefining MIDL_user_free is not strictly necessary since 
//   the regular MIDL_user_free would behave exactly the same as 
//   CUSTMACT_MIDL_user_free. I include it more for completeness 
//   than anything else.
//
//--------------------------------------------------------------------------
#define MIDL_user_allocate   CUSTMACT_MIDL_user_allocate
#define MIDL_user_free       CUSTMACT_MIDL_user_free

//--------------------------------------------------------------------------
// 
// Include the midl-generated code
// 
//--------------------------------------------------------------------------
#include "custmact_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\idl\private\chicago\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\idl\private\daytona\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\idl\private\privguid.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:
//      privguid.c
//
//  Contents:
//      Definition of guids not defined elsewhere, or that are needed by
//    third-parties (eg COM+) via prvidl.lib.
//
//  History:
//              JSimmons    01-03-00        Created
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <initguid.h>

// Note:  these two guids are defined in ole32\ih\privguid.h.

// RPCSS's info object
DEFINE_OLEGUID(CLSID_RPCSSInfo,                     0x000003FF, 0, 0);

// Actpropsin clsid.
DEFINE_OLEGUID(CLSID_ActivationPropertiesIn,		0x00000338, 0, 0);

// ComActivator clsid
DEFINE_OLEGUID(CLSID_ComActivator,                  0x0000033c, 0, 0);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\idl\internal\hydra\makefile.inc ===
DEST_TREE=hydra
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\idl\public\chicago\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\idl\public\daytona\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\idl\internal\sources.inc ===
!IF 0

Copyright (c) 1989-1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    David Plummer (davepl)   19-Mar-94

        Modifed by via awk to include global project include file
        and to wrap precompiled header line within a conditional
        that can be set in this include file.

    Donna Liu (DonnaLi) 19-Dec-1993

!ENDIF

TARGETNAME= priidl
TARGETPATH=   obj
TARGETTYPE=   LIBRARY

MIDL_UUIDDIR=$(O)
PASS0_SOURCEDIR=$(O)
PASS0_HEADERDIR=$(O)
MIDL_TLBDIR=$(O)
MIDL_PROTOCOL=dce

INCLUDES=     $(O);..\..\public;..\..\public\$(DEST_TREE)\$(O);..;$(SDK_INC_PATH)
INCLUDES=     $(INCLUDES);..\..\private;..\..\private\$(DEST_TREE)\$(O);..\..\private\$(DEST_TREE)\$(O)

SOURCES= \
              $(O)\apart_i.c	\
              $(O)\serializ_i.c	\
              $(O)\buffer_i.c	\
              $(O)\lclor_c.c	\
              $(O)\lclor_s.c	\
              $(O)\odeth_c.c	\
              $(O)\orcb_c.c	\
              $(O)\orcb_s.c	\
              $(O)\getif_i.c	\
              $(O)\irot_c.c	\
              $(O)\srgtprot_c.c	\
              $(O)\scm_c.c	\
              custmact_c_wrap.c
	
UMTYPE=       windows

NTTARGETFILE0=allidl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\idl\private\sources.inc ===
!IF 0

Copyright (c) 1989-1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    David Plummer (davepl)   19-Mar-94

        Modifed by via awk to include global project include file
        and to wrap precompiled header line within a conditional
        that can be set in this include file.

    Donna Liu (DonnaLi) 19-Dec-1993

!ENDIF

TARGETNAME= prvidl
TARGETPATH= obj
TARGETTYPE= LIBRARY

PASS0_HEADERDIR=$(O)
PASS0_SOURCEDIR=$(O)

PASS0_PUBLISH= \
	{..\activate.idl=$(PROJECT_INC_PATH)\activate.idl}\
    {$(O)\activate.h=$(PROJECT_INC_PATH)\activate.h}\
	{..\catalog.idl=$(PROJECT_INC_PATH)\catalog.idl}\
	{$(O)\catalog.h=$(PROJECT_INC_PATH)\catalog.h}\
	{..\contxt.idl=$(PROJECT_INC_PATH)\contxt.idl}\
	{$(O)\contxt.h=$(PROJECT_INC_PATH)\contxt.h}\
	{..\iface.idl=$(PROJECT_INC_PATH)\iface.idl}\
	{$(O)\iface.h=$(PROJECT_INC_PATH)\iface.h}\
	{..\partitions.idl=$(PROJECT_INC_PATH)\partitions.idl}\
	{$(O)\partitions.h=$(PROJECT_INC_PATH)\partitions.h}\
	{..\privact.idl=$(PROJECT_INC_PATH)\privact.idl}\
	{$(O)\privact.h=$(PROJECT_INC_PATH)\privact.h}\
	{..\unisrgt.idl=$(PROJECT_INC_PATH)\unisrgt.idl}\
	{$(O)\unisrgt.h=$(PROJECT_INC_PATH)\unisrgt.h}

PASS1_PUBLISH= \
    {$(O)\prvidl.lib=$(PROJECT_LIB_PATH)\prvidl.lib}

MIDL_UUIDDIR=$(O)
MIDL_TLBDIR=$(O)
MIDL_PROTOCOL=dce

INCLUDES=     obj;..\..\public;..\..\public\$(DEST_TREE)\obj;..\..\internal;..;$(SDK_INC_PATH)

SOURCES= \
              $(O)\contxt_i.c \
              $(O)\unisrgt_i.c \
              $(O)\privact_i.c \
              $(O)\activate_i.c \
              $(O)\catalog_i.c  \
              $(O)\partitions_i.c \
			  $(O)\asrtcfg_i.c  \
              privguid.c

UMTYPE=       windows

NTTARGETFILE0=allidl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\idl\private\makefile.inc ===
!ifndef MIDL
MIDL = midl.exe
!endif

# Paths

PUBLIC_IDL=..\..\public\

# Flags

MIDL_FLAGS= \
 $(MIDL_OPTIMIZATION) \
 -no_stamp \
 -Zp8 \
 $(INCPATH0) \
 -oldnames \
 -dlldata nul \
 -char unsigned \
 -ms_ext -c_ext \
 -DMIDL_PASS \
 $(C_DEFINES) \
 -cpp_cmd $(TARGET_CPP) \

MES_MIDL_FLAGS= \
 -Oicf -no_format_opt -error all \
 -no_stamp \
 -Zp8 -robust \
 $(INCPATH0) \
 -oldnames \
 -dlldata nul \
 -char unsigned \
 -ms_ext -c_ext \
 -DMIDL_PASS \
 $(C_DEFINES) \
 -cpp_cmd $(TARGET_CPP)



SSWITCH=-prefix sstub _
CSWITCH=-prefix cstub _

# Targets

# Dual (Raw/Object) local RPC interface for forwarding remote activation calls
# in DCOM95 -- RPCSS is the server

# first MIDL invocation makes the object header proxy and stub
# second MIDL invocation makes the client and the '_' prefixed server
# The client/server stubs for the object version are generated by mega.idl

# Only generate a header.
$(O)\iface.h:  ..\iface.idl
     $(MIDL) $(MIDL_FLAGS) -header $@ ..\iface.idl

$(O)\catalog.h: ..\catalog.idl
     $(MIDL) $(MIDL_FLAGS) \
        -client none -server none -header $@ \
        -proxy nul \
        -iid $(O)\catalog_i.c \
        ..\catalog.idl

$(O)\unisrgt.h: ..\unisrgt.idl
     $(MIDL) $(MIDL_FLAGS) \
        -client none -server none -header $@ \
        -proxy nul \
        -iid $(O)\unisrgt_i.c \
        ..\unisrgt.idl

# the object proxy and stub are made with mega.idl
$(O)\activate.h: ..\activate.idl
     $(MIDL) $(MES_MIDL_FLAGS) \
        -client none -server none -header $@ \
        -proxy nul \
        -iid $(O)\activate_i.c \
        ..\activate.idl

$(O)\partitions.h: ..\partitions.idl
     $(MIDL) $(MIDL_FLAGS) \
        -client none -server none -header $@ \
        -proxy nul \
        -iid $(O)\partitions_i.c \
        ..\partitions.idl

# first MIDL invocation makes the object header
# the object proxy and stub are made with mega.idl
# second MIDL invocation makes the server
$(O)\privact.h: ..\privact.idl
     $(MIDL) $(MES_MIDL_FLAGS) \
        -client none -server none -header $@ \
        -proxy nul \
        -iid $(O)\privact_i.c \
        ..\privact.idl


$(O)\rawprivact.h: ..\privact.idl
     $(MIDL) $(MES_MIDL_FLAGS) \
        -cstub $(O)\rawprivact_c.c \
        -sstub $(O)\rawprivact_s.c \
        -header $@ \
        -D RAW \
        ..\privact.idl

$(O)\contxt.h: ..\contxt.idl
     $(MIDL)  $(MIDL_FLAGS) \
        -client none -server none -header $@ \
        -proxy nul \
        -iid $(O)\contxt_i.c \
        ..\contxt.idl

$(O)\asrtcfg.h: ..\asrtcfg.idl
     $(MIDL)  $(MIDL_FLAGS) \
         -client none -server none -header $@ \
         -proxy nul \
         -iid $(O)\asrtcfg_i.c \
          ..\asrtcfg.idl

allidl:   $(O)\iface.h $(O)\activate.h $(O)\contxt.h $(O)\privact.h $(O)\rawprivact.h $(O)\catalog.h \
	  $(O)\unisrgt.h $(O)\asrtcfg.h $(O)\partitions.h

clean:
          -erase $(O)\*.h      >NUL 2>NUL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\idl\private\hydra\makefile.inc ===
DEST_TREE=hydra
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\idl\public\sources.inc ===
!IF 0

Copyright (c) 1989-1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    David Plummer (davepl)   19-Mar-94

        Modifed by via awk to include global project include file
        and to wrap precompiled header line within a conditional
        that can be set in this include file.

    Donna Liu (DonnaLi) 19-Dec-1993

!ENDIF

TARGETNAME= pubidl
TARGETPATH=   obj
TARGETTYPE=   LIBRARY

PASS0_HEADERDIR=$(O)
PASS0_SOURCEDIR=$(O)
MIDL_UUIDDIR=$(O)
MIDL_PROTOCOL=dce

MIDL_PROTOCOL=dce

INCLUDES= \
    $(O); \
    ..;\
    $(SDK_INC_PATH);

SOURCES= \
	      $(O)\objex_c.c  \
	      $(O)\objex_s.c  \
	      $(O)\remact_c.c \
	      $(O)\remact_s.c
	
UMTYPE=       windows

NTTARGETFILE0=allidl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\idl\public\makefile.inc ===
!ifndef MIDL
MIDL = midl.exe
!endif

MIDL_FLAGS= \
 $(MIDL_OPTIMIZATION) \
 -Zp8 \
 $(INCPATH0) \
 -oldnames \
 -char unsigned \
 -dlldata nul \
 -proxy nul \
 -out $(O)  \
 -ms_ext -c_ext \
 -DMIDL_PASS \
 $(C_DEFINES) \
 -cpp_cmd $(TARGET_CPP) \
 -DMIDL_PASS $(C_DEFINES) $(INCPATH0)

SSWITCH=-prefix sstub _

$(O)\dce.h:      ..\dce.idl
     $(MIDL) $(MIDL_FLAGS) -header dce.h  ..\dce.idl

#$(O)\obase.h:  ..\obase.idl
#     $(MIDL)  $(MIDL_FLAGS) -header obase.h ..\obase.idl

$(O)\objex.h:  ..\objex.idl $(SDK_INC_PATH)\obase.idl ..\objex.acf
     $(MIDL) $(SSWITCH) $(MIDL_FLAGS) -header objex.h ..\objex.idl

$(O)\remact.h : ..\remact.idl $(SDK_INC_PATH)\obase.idl ..\remact.acf
     $(MIDL) $(MIDL_FLAGS) -header remact.h \
        $(SSWITCH) ..\remact.idl

#$(O)\immact.h : ..\immact.idl ..\obase.idl
#     $(MIDL) $(SSWITCH) $(MIDL_FLAGS) -header immact.h ..\immact.idl

# only a header file generated
$(O)\remunk.h : ..\remunk.idl $(SDK_INC_PATH)\obase.idl
     $(MIDL) $(MIDL_FLAGS) -header remunk.h ..\remunk.idl

allidl:  $(O)\objex.h $(O)\remact.h $(O)\remunk.h

clean:
          -erase $(O)\*.h    >NUL 2>NUL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ih\debug.h ===
//+----------------------------------------------------------------------------
//
//	File:
//		debug.h
//
//	Contents:
//		macros and declarations for debug support--all are appropriately
//		defined to nothing when not doing debug build
//
//	Classes:
//
//	Functions:
//
//	History:
//		12/30/93 - ChrisWe - added file prologue; defined _DEBUG when
//			DBG==1; added "const" to ASSERTDATA macro
//
//-----------------------------------------------------------------------------


#ifndef _DEBUG_H_
#define _DEBUG_H_

#include <debnot.h>

#ifndef RC_INVOKED
#ifdef _DEBUG
#define DBGSTATE " Debug is on"
#else
#define DBGSTATE " Debug is off"
#endif
#endif  /* RC_INVOKED */

#ifndef _CAIRO_
#include <ole2dbg.h>
#endif

//these are bogus APIs (they do nothing)
STDAPI_(BOOL) ValidateAllObjects( BOOL fSuspicious );
STDAPI_(void) DumpAllObjects( void );

#ifdef _DEBUG
BOOL InstallHooks(void);
BOOL UnInstallHooks(void);

#undef ASSERTDATA
#define ASSERTDATA

#undef AssertSz
#define AssertSz(a,b) ((a) ? NOERROR : FnAssert(#a, b, __FILE__, __LINE__))
#undef Puts
#define Puts(s) OutputDebugString(TEXT(s))

#else   //  !_DEBUG

#define ASSERTDATA
#define AssertSz(a, b) ((void)0)
#define Puts(s) ((void)0)

#endif  //  _DEBUG


// special Assert for asserts below (since the expression is so large)
// REVIEW, shouldn't these be in the debug.h file?
#ifdef _DEBUG
#define AssertOut(a, b) { if (!(a)) FnAssert(szCheckOutParam, b, __FILE__, __LINE__); }
#else
#define AssertOut(a, b) ((void)0)
#endif

#define AssertOutPtrParam(hr, p) \
	AssertOut(SUCCEEDED(hr) && IsValidPtrIn(p, sizeof(OLECHAR)) || \
	FAILED(hr) && (p) == NULL, \
	szBadOutParam)

#define AssertOutPtrIface(hr, p) \
	AssertOut(SUCCEEDED(hr) && IsValidInterface(p) || \
	FAILED(hr) && (p) == NULL, \
	szBadOutIface)

#define AssertOutPtrFailed(p) \
	AssertOut((p) == NULL, \
	szNonNULLOutPtr)

#define AssertOutStgmedium(hr, pstgm) \
	AssertOut(SUCCEEDED(hr) && (pstgm)->tymed != TYMED_NULL || \
	FAILED(hr) && (pstgm)->tymed == TYMED_NULL, \
	szBadOutStgm)


// assert data for above assert out macros; once per dll
// Note that since these are only used in asserts, we leave them as ANSI
#define ASSERTOUTDATA \
    char szCheckOutParam[] = "check out param"; \
    char szBadOutParam[] = "Out pointer param conventions not followed"; \
    char szBadOutIface[] = "Out pointer interface conventions not followed"; \
    char szNonNULLOutPtr[] = "Out pointer not NULL on error"; \
    char szBadOutStgm[] = "Out stgmed param conventions not followed";

extern char szCheckOutParam[];
extern char szBadOutParam[];
extern char szBadOutIface[];
extern char szNonNULLOutPtr[];
extern char szBadOutStgm[];


#ifdef __cplusplus

interface IDebugStream;

/*
 *  Class CBool wraps boolean values in such a way that they are
 *  readily distinguishable fron integers by the compiler so we can
 *  overload the stream << operator.
 */

class FAR CBool
{
    BOOL value;
public:
    CBool (BOOL& b) {value = b;}
    operator BOOL( void ) { return value; }
};


/*
 *  Class CHwnd wraps HWND values in such a way that they are
 *  readily distinguishable from UINTS by the compiler so we can
 *  overload the stream << operator
 */

class FAR CHwnd
{
	HWND m_hwnd;
	public:
		CHwnd (HWND hwnd) {m_hwnd = hwnd; }
		operator HWND( void ) {return m_hwnd;}
};

/*
 * Class CAtom wraps ATOM values in such a way that they are
 *  readily distinguishable from UINTS by the compiler so we can
 *  overload the stream << operator
 */

class FAR CAtom
{
	ATOM m_atom;
	public:
		CAtom (ATOM atom) {m_atom = atom; }
		operator ATOM( void ) {return m_atom; }
};

/*
 *  IDebugStream is a stream to be used for debug output.  One
 *  implementation uses the OutputDebugString function of Windows.
 *
 *  The style is modeled on that of AT&T streams, and so uses
 *  overloaded operators.  You can write to a stream in the
 *  following ways:
 *
 *    *pdbstm << pUnk;  // calls the IDebug::Dump function to
 *                      display the object, if IDebug is supported.
 *    int n;
 *    *pdbstm << n;     // writes n in decimal
 *
-
 *    *pdbstm << sz;    // writes a string
 *
 *    CBool b(TRUE);
 *    *pdbstm << b;     // writes True or False
 *
 *    void FAR * pv;
 *    *pdbstm << pv;    // writes the address pv in hex
 *
 *    TCHAR ch;
 *    *pdbstm << ch;    // writes the character
 *
 *    ATOM atom;
 *    *pdbstm << CAtom(atom);	// writes the string extracted from the atom
 *
 *    HWND hwnd;
 *    *pdbstm << CHwnd(hwnd);  // writes the info about a window handle
 *
 *  These can be chained together, as such (somewhat artificial
 *  example):
 *
 *    REFCLSID rclsid;
 *    pUnk->GetClass(&rclsid);
 *    *pdbstm << rclsid << " at " << (void FAR *)pUnk <<':' << pUnk;
 *
 *  This produces something like:
 *
 *    CFoo at A7360008: <description of object>
 *
 *  The other useful feature is the Indent and UnIndent functions
 *  which allow an object to print some information, indent, print
 *  the info on its member objects, and unindent.  This gives
 *  nicely formatted output.
 *
 *  WARNING:  do not (while implementing Dump) write
 *
 *    *pdbstm << pUnkOuter
 *
 *  since this will do a QueryInterface for IDebug, and start
 *  recursing!  It is acceptable to write
 *
 *    *pdbstm << (VOID FAR *)pUnkOuter
 *
 *  as this will simply write the address of pUnkOuter.
 *
 */


interface IDebugStream : public IUnknown
{
    STDMETHOD_(IDebugStream&, operator << ) ( IUnknown FAR * pDebug ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( REFCLSID rclsid ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( int n ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( long l ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( ULONG l ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( LPCTSTR sz ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( TCHAR ch ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( void FAR * pv ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( CBool b ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( CHwnd hwnd ) = 0;
    STDMETHOD_(IDebugStream&, operator << ) ( CAtom atom ) = 0;
    STDMETHOD_(IDebugStream&, Tab )( void ) = 0;
    STDMETHOD_(IDebugStream&, Indent )( void ) = 0;
    STDMETHOD_(IDebugStream&, UnIndent )( void ) = 0;
    STDMETHOD_(IDebugStream&, Return )( void ) = 0;
    STDMETHOD_(IDebugStream&, LF )( void ) = 0;
};

STDAPI_(IDebugStream FAR*) MakeDebugStream( short margin=70, short tabsize=4, BOOL fHeader=1);


interface IDebug
{
    STDMETHOD_(void, Dump )( IDebugStream FAR * pdbstm ) = 0;
    STDMETHOD_(BOOL, IsValid )( BOOL fSuspicious = FALSE ) = 0;

#ifdef NEVER
    __export IDebug(void);
    __export ~IDebug(void);
private:

#ifdef _DEBUG
    IDebug FAR * pIDPrev;
    IDebug FAR * pIDNext;

    friend void STDAPICALLTYPE DumpAllObjects( void );
    friend BOOL STDAPICALLTYPE ValidateAllObjects( BOOL fSuspicious );
#endif // _DEBUG
#endif // NEVER
};

/*************************************************************************
** The following functions can be used to log debug messages to a file
**    and simutaneously write them to the dbwin debug window.
**    The CDebugStream implementation automatically writes to a debug
**    log file called "debug.log" in the current working directory.
**    NOTE: The functions are only intended for C programmers. C++
**    programmers should use the "MakeDebugStream" instead.
*************************************************************************/

// Open a log file.
STDAPI_(HFILE) DbgLogOpen(LPCTSTR lpszFile, LPCTSTR lpszMode);

// Close the log file.
STDAPI_(void) DbgLogClose(HFILE fh);

// Write to debug log and debug window (used with cvw.exe or dbwin.exe).
STDAPI_(void) DbgLogOutputDebugString(HFILE fh, LPCTSTR lpsz);

// Write to debug log only.
STDAPI_(void) DbgLogWrite(HFILE fh, LPCTSTR lpsz);

// Write the current Date and Time to the log file.
STDAPI_(void) DbgLogTimeStamp(HFILE fh, LPCTSTR lpsz);

// Write a banner separater to the log to separate sections.
STDAPI_(void) DbgLogWriteBanner(HFILE fh, LPCTSTR lpsz);




/*
 *  STDDEBDECL macro - helper for debug declaration
 *
 */

#ifdef _DEBUG

        #define STDDEBDECL(ignore, classname ) implement CDebug:public IDebug { public: \
            CDebug( C##classname FAR * p##classname ) { m_p##classname = p##classname;} \
            ~CDebug(void) {} \
            STDMETHOD_(void, Dump)(IDebugStream FAR * pdbstm ); \
            STDMETHOD_(BOOL, IsValid)(BOOL fSuspicious ); \
            private: C##classname FAR* m_p##classname; }; \
            DECLARE_NC(C##classname, CDebug) \
            CDebug m_Debug;

    #define CONSTRUCT_DEBUG m_Debug(this),

#else //        _DEBUG

//      no debugging
#define STDDEBDECL(cclassname,classname)
#define CONSTRUCT_DEBUG

#endif  //      _DEBUG

#endif __cplusplus

#endif // !_DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ih\hklogevt.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994.
//
//  File:       hkLogEvt.h
//
//  Contents:   Log an application event
//
//  Functions:  
//
//  History:    28-Sep-94 Don Wright    Created
//  
//--------------------------------------------------------------------------
#ifndef _LOGEVENT_H_
#define _LOGEVENT_H_

inline void LogEvent(LPWSTR pSourceString,LPWSTR pEventText)
{
    HANDLE hEvent = RegisterEventSourceW(NULL,pSourceString);
    LPCWSTR *pEventStr = (LPCWSTR *)&pEventText;
    ReportEventW(hEvent,
		EVENTLOG_INFORMATION_TYPE,
		0,
		0,
		NULL,
		1,
		0,
		pEventStr,
		NULL);
    DeregisterEventSource(hEvent);
}

#endif // _LOGEVENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ih\alocdbg.h ===
//+---------------------------------------------------------------------------
//  File:       alocdbg.h
//
//  Contents:   Heap debugging structures and routines for the heap code
//		in commnot
//
//  History:    28-Oct-92   IsaacHe	Created
//		23-Jan-95   KevinRo	Moved into cairole\ih and renamed
//
//----------------------------------------------------------------------------

//
// We keep a stack backtrace for each allocated block of memory.  DEPTHTRACE
// is the number of frames that we record
//
#define DEPTHTRACE   26			// depth of stack backtraces

//
// The AllocArena structure has this signature at its front.  We put a
// signature on the structure to allow external processes to snapshot the
// debug information and do some minimal check to see they are looking at the
// right stuff
//
const char HEAPSIG[] = { 'H', 'E', 'P', DEPTHTRACE };

// We keep track of the stack backtraces of allocation calls
// in these structues.

struct HeapAllocRec {
	DWORD	sum;		// checksum of stack backtrace
	void *fTrace[ DEPTHTRACE ];	// stack backtrace
	DWORD	count;		// # of un-freed allocs from this place
	size_t	bytes;		// # of un-freed bytes from this place
	struct AllocArena *paa;	// points back to the beginning...
	struct {
		DWORD	count;	// # of allocs from this place
		size_t	bytes;	// # of bytes from this place
	} total;
	union {
		struct HeapAllocRec *next; // next bucket in the hash list
		void *ImageBase; 	// base addr of containing module
	} u;
};

struct AllocArena {

	char Signature [ sizeof(HEAPSIG) ];
	char comment[ 32 ];
	CRITICAL_SECTION csExclusive;	// ensures single writer

	struct {
		int KeepStackTrace:1;	// are stack records being kept?
	} flags;

	ULONG cAllocs;			// # of non zero Alloc calls
	ULONG czAllocs;			// # of Alloc calls w/zero count
	ULONG cFrees;			// # of Free calls
	ULONG cReAllocs;		// # of realloc calls
	ULONG cMissed;			// # of missed stack backtraces
	ULONG cRecords;			// index of next free AllocRec entry
	size_t cBytesNow;		// # of bytes currently allocated
	size_t cBytesTotal;		// # of bytes ever allocated
	ULONG cTotalRecords;		// Total # of AllocRecs
	ULONG cPaths;			// # of distinct allocation paths

	struct {
		ULONG total[ 32 ];	// total number of allocations
		ULONG now[ 32 ];	// current # of simul allocs
		ULONG simul[ 32 ];	// highest # of simul allocs
	} Histogram;

	struct HeapAllocRec AllocRec[1]; // vector of records starts here..
};

/*
 * Allocators may want to associate one of these structures with every
 * allocation...
 */
struct AHeader {
	struct HeapAllocRec FAR *p;
	size_t size;
};

STDAPI_(struct AllocArena ** )
AllocArenaAddr( void );

STDAPI_( struct AllocArena * )
AllocArenaCreate( DWORD memctx, char FAR *comment );

STDAPI_( struct HeapAllocRec FAR * )
AllocArenaRecordAlloc( struct AllocArena *paa, size_t bytes );

STDAPI_(void)
AllocArenaRecordReAlloc( struct HeapAllocRec FAR *vp,
			size_t oldbytes, size_t newbytes );

STDAPI_(void)
AllocArenaRecordFree( struct HeapAllocRec FAR *vp, size_t bytes );

STDAPI_(void)
AllocArenaDump( struct AllocArena *paa, BOOL fDumpSymbols );

STDAPI_( void )
AllocArenaDumpRecord( struct HeapAllocRec FAR *bp, BOOL fDumpSymbols );

// This is our interface to symhelp for address translation
ULONG RealTranslate ( ULONG address, LPSTR name, ULONG maxNameLength);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ih\hkldinp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994.
//
//  File:       hkLdInP.h
//
//  Contents:   Inline function to load the DLL of an inproc server
//
//  Functions:  
//
//  History:    01-Sep-94 Don Wright    Created
//              08-Sep-94 Garry Lenz    Separate into two functions
//              14-Nov-94 Don Wright    Make LogEvent messages more complete
//  
//--------------------------------------------------------------------------
#ifndef _LDINPROC_H_
#define _LDINPROC_H_

#include <Windows.h>
#include <TChar.h>
#include "hkregkey.h"
#include "hkLogEvt.h"
#include "hkole32x.h"

#define MAX_CLSID  39   // Length of CLSID string including zero terminator

enum ELOGEVENT
{
    eDontLogEvents,
    eLogEvents
};

inline HINSTANCE LOADINPROCSERVER(WCHAR* wszClsid, ELOGEVENT eLog=eLogEvents)
{
    WCHAR szEventSource[] = L"HookOleLoadInprocServer";
    CHAR szInProc32[] = "InprocServer32";
    CHAR szClsidKey[MAX_PATH];
    CHAR szDllName[MAX_PATH];
    WCHAR wszDllName[MAX_PATH];
    CHAR szClsid[MAX_CLSID];
    WCHAR szMessageBuff[1024];
    long lSize = sizeof(szDllName);
    LONG lRegResults;
    HINSTANCE hDll = NULL;

    strcpy(szClsidKey,szCLSIDKey);
    strcat(szClsidKey,KEY_SEP);

    WideCharToMultiByte (CP_ACP, WC_COMPOSITECHECK, wszClsid, -01, szClsid, sizeof (szClsid), NULL, NULL);

    strcat(szClsidKey,szClsid);
    strcat(szClsidKey,KEY_SEP);
    strcat(szClsidKey,szInProc32);
    lRegResults = RegQueryValueA(HKEY_CLASSES_ROOT,
				 szClsidKey,
				 szDllName,
				 &lSize);
    if (lRegResults == ERROR_SUCCESS)
    {
	if (hDll == 0)
	{
	    hDll = LoadLibraryA(szDllName);
	    if ((eLog == eLogEvents) && (hDll == 0))
	    {
		lstrcpyW(szMessageBuff,L"Error loading library - ");

                MultiByteToWideChar (CP_ACP, MB_PRECOMPOSED, szDllName, -1, wszDllName, lstrlenA(szDllName)+1);

		lstrcatW(szMessageBuff,wszDllName);
		lstrcatW(szMessageBuff,L" for CLSID ");
		lstrcatW(szMessageBuff,wszClsid);
		LogEvent(szEventSource,szMessageBuff);
	    }
	}
    }
    else if (eLog == eLogEvents)
    {
	lstrcpyW(szMessageBuff,L"Error reading registry for CLSID!");
	lstrcatW(szMessageBuff,wszClsid);
	LogEvent(szEventSource,szMessageBuff);
    }
    return hDll;
}

inline HINSTANCE LOADINPROCSERVER(REFCLSID rclsid, ELOGEVENT eLog=eLogEvents)
{
    WCHAR szClsid[MAX_CLSID];
    HRESULT hResult;
    HINSTANCE hDll = NULL;

    hResult = StringFromGUID2(rclsid,szClsid,sizeof(szClsid));
    if (SUCCEEDED(hResult))
    {
	hDll = LOADINPROCSERVER(szClsid, eLogEvents);
    }
    return hDll;
}

#endif //_LDINPROC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ih\dragopt.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	dragopt.h
//
//  Contents:   Intercomponent definitions to support the Drag/Drop optimization
//
//  Functions:
//
//  History:	dd-mmm-yy Author    Comment
//		08-Nov-94 alexgo    added PrivDragDrop
//              30-Sep-94 ricksa    Created
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifndef _DRAGOPT_H

//+-------------------------------------------------------------------------
//
//  Function:   UnmarshalDragDataObject
//
//  Synopsis:   Handles unmarshaling of a marshaled data object
//
//  Arguments:  [pvMarshaledDataObject] - the marshaled buffer
//
//  Returns:    NULL - could not unmarshal
//              ~NULL - remote IDataObject
//
//  Algorithms: see com\rot\getif.cxx
//
//  History:	dd-mmm-yy Author    Comment
//		30-Sep-94 Ricksa    Created
//
//--------------------------------------------------------------------------
IDataObject *UnmarshalDragDataObject(void *pvMarshaledDataObject);





//+-------------------------------------------------------------------------
//
//  Function:   CreateDragDataObject
//
//  Synopsis:   Handles unmarshaling of a marshaled data object
//
//  Arguments:  [pvMarshaledDataObject] - the marshaled buffer for data object
//              [dwSmId] - id of shared memory for formats.
//              [ppIDataObject] - where to put Drag data object
//
//  Returns:    NOERROR - created a data object
//              E_OUTOFMEMORY - could not allocate the Drag data object
//
//  Algorithms: see ole232\drag\ido.cpp
//
//  History:	dd-mmm-yy Author    Comment
//		30-Sep-94 Ricksa    Created
//
//--------------------------------------------------------------------------
HRESULT CreateDragDataObject(
    void *pvMarshaledDataObject,
    DWORD dwSmId,
    IDataObject **ppIDataObject);

typedef void * DDInfo;

//+-------------------------------------------------------------------------
//
//  Function:  	FreeDragDropInfo
//
//  Synopsis:	frees a DDInfo handle (aka as a SPrivDragDrop struct)
//
//  Effects:
//
//  Arguments:	[hDDInfo]	-- handle to free
//
//  Requires:
//
//  Returns: 	void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//  		07-Jan-95 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

void FreeDragDropInfo( DDInfo hDDInfo );


//
// Drag Drop interpreter op codes
//

typedef enum tagDRAGOP
{
        DRAGOP_ENTER = 1,
        DRAGOP_OVER  = 2,
        DRAGOP_LEAVE = 3,
        DRAGOP_DROP  = 4
} DRAGOP;

//+-------------------------------------------------------------------------
//
//  Function:	PrivDragDrop
//
//  Synopsis:  	Main entry point for the private version of the OLE
//		protocol.  Instead of using IDropTarget proxy/stubs,
//		we use a private rpc and do most of the work on the
//		drop target side.
//
//  Effects:
//
//  Arguments: 	[hwnd]	-- the target hwnd
//		[dop]	-- the drag drop operation to perform
//		[DOBuffer] -- the data object buffer to send
//		[pIDataObject] -- the data object interface (for the
//				  local case)
//		[grfKeyState] -- the keyboard state
//		[ptl]	-- the mouse position
//		[pdwEffect]   -- the drag drop effect
//		[hwndSource]  -- the window of the drag source.  Used
//				 to attach input queues for 16bit targets
//		[phDDInfo]    -- pointer to a DragDropInfo handle, for
//				 caching rpc info about the drop target.
//			         May not be NULL, but on DragEnter,
//				 should be a pointer to NULL.
//
//  Requires:
//
//  Returns:	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:	see getif.cxx
//
//  History:    dd-mmm-yy Author    Comment
//		30-Sep-94 Ricksa    Created
//  		08-Nov-94 alexgo    modified to use DRAGOP's
//		08-Jan-95 alexgo    added caching of RPC binding handles via
//				    DDInfo handles
//  Notes:
//
//--------------------------------------------------------------------------


HRESULT PrivDragDrop( HWND hwnd, DRAGOP dop, IFBuffer DOBuffer, IDataObject *
		pIDataObject,  DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect,
		HWND hwndSource, DDInfo *phDDInfo);

#endif // _DRAGOPT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ih\hkole32.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994.
//
//  File:       hkOle32.h
//
//  Contents:   OLE32 Hook Header File
//
//  Functions:
//
//  History:    29-Nov-94 Ben Lawrence, Don Wright   Created
//
//--------------------------------------------------------------------------
#ifndef _OLE32HK_H_
#define _OLE32HK_H_


#ifndef INITGUID
#define INITGUID
#endif /* INITGUID */

//#include "hkole32x.h"
//#include "hkoleobj.h"
//#include "hkLdInP.h"
#include "tchar.h"      // This is required for _TCHAR to be defined in dllcache.hxx
#include "ictsguid.h"
#include <windows.h>


//
// Prototypes for functions used by	\ole32\com\class\compobj.cxx
//
VOID
InitHookOle(
	VOID
    );

VOID
UninitHookOle(
    VOID
    );


// These should be removed after 4.0 RTM.
//
inline void CALLHOOKOBJECT(HRESULT MAC_hr, REFCLSID MAC_rclsid, REFIID MAC_riid, IUnknown** MAC_ppv)
{
}

inline void CALLHOOKOBJECTCREATE(HRESULT MAC_hr, REFCLSID MAC_rclsid, REFIID MAC_riid, IUnknown** MAC_ppv)
{
}


#ifdef DEFCLSIDS

//these are all undefined in ole32hk because they are private CLSIDs
//we define them here to null
#define GUID_NULL CLSID_HookOleObject //use this for now so it will compile

#define CLSID_ItemMoniker       CLSID_NULL
#define CLSID_FileMoniker       CLSID_NULL
#define CLSID_PointerMoniker    CLSID_NULL
#define CLSID_CompositeMoniker  CLSID_NULL
#define CLSID_AntiMoniker       CLSID_NULL
#define CLSID_PSBindCtx         CLSID_NULL

#endif /* DEFCLSIDS */


#endif  // _OLE32HK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ih\hkunkex.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994.
//
//  File:	khunkex.h
//
//  Contents:   Extended IUnknown Interface Header File
//
//  Functions:	
//
//  History:	13-Oct-94 Garry Lenz    Created
//  
//--------------------------------------------------------------------------

#ifndef _IUNKNOWNEX_H_
#define _IUNKNOWNEX_H_

#include <Windows.h>

interface IUnknownEx : IUnknown
{
  public:
    STDMETHOD (QueryContainedInterface)
     (
        REFIID    riid,
        LPVOID*   ppvObj
     ) = 0;
};

#endif	// _IUNKNOWNEX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ih\hkoleobj.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994.
//
//  File:	hkoleobj.h
//
//  Contents:   IHookOleObject Interface Header File
//
//  Functions:	
//
//  History:	01-Aug-94 Garry Lenz    Created
//              20-Sep-94 Garry Lenz    Added EnableRegistration
//              13-Oct-94 Garry Lenz    Derive from IUnknownEx
//              13-Oct-94 Garry Lenz    Added EnumObjects
//              20-Oct-94 Garry Lenz    Added AssociateInstance
//              14-Dec-94 Don Wright    Added fCreate param to RegisterObject
//
//--------------------------------------------------------------------------

#ifndef _IHOOKOLEOBJECT_H_
#define _IHOOKOLEOBJECT_H_

#include <Windows.h>
#include "hkunkex.h"

interface IHookOleInstance;

enum EHookEnumFlags
{
    HEF_Instances   = 1,
    HEF_Classes     = 2,
    HEF_Interfaces  = 3
};

interface IHookOleObject : IUnknownEx
{
  public:
    STDMETHOD ( EnumObjects )
     (
        DWORD           dwEnumFlags,
        IEnumUnknown**  pIEnum    
     ) = 0;
    STDMETHOD ( RegisterObject )
     (
        REFCLSID       rclsid, 
        REFIID         riid, 
        LPVOID         pvObj,
        BOOL           fCreate
     ) = 0;
    STDMETHOD ( UnregisterObject )
     (
        LPVOID         pvObj
     ) = 0;
    STDMETHOD ( UnregisterAll )
     (
        void
     ) = 0;
    STDMETHOD ( EnableRegistration )
     (
        BOOL           fEnable
     ) = 0;
    STDMETHOD ( AssociateInstance )
     (
        REFIID         riid,
        LPVOID         pvObj,
        IHookOleInstance** ppIHookOleInstance
     ) = 0;
};

#endif //   _IHOOKOLEOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ih\hkregkey.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994.
//
//  File:       hkregkey.h
//
//  Contents:   Defines for accessing the Registry
//
//  Functions:  
//
//  History:    01-Aug-94 Garry Lenz    Created
//              02-Aug-94 Don Wright    Support Ansi/Unicode
//              25-Oct-94 Don Wright    Add Keys for HookOleLog
//  
//--------------------------------------------------------------------------

#ifndef _REGISTRYKEYS_H_
#define _REGISTRYKEYS_H_

#include <Windows.h>

#define KEY_SEP   "\\"
#define WKEY_SEP L"\\"

//Named Event for Global Hooking Flag
#define szHookEventName			"HookSwitchHookEnabledEvent"

// Keys used by OLE32hk.h for finding HookOle dll
#define HookBase         HKEY_LOCAL_MACHINE
#define szHookKey         "Software\\Microsoft\\HookOleObject"
#define wszHookKey       L"Software\\Microsoft\\HookOleObject"

// Keys used by HookOle for finding Wrappers and Filters
#define HookConfigBase   HKEY_LOCAL_MACHINE
#define szHookConfigKey    "Software\\Microsoft\\HookOleObject"
#define wszHookConfigKey  L"Software\\Microsoft\\HookOleObject"

// Keys used by HookOleLog
#define HookLogBase      HKEY_LOCAL_MACHINE
#define szHookLogKey       "Software\\Microsoft\\HookOleLog"
#define wszHookLogKey     L"Software\\Microsoft\\HookOleLog"

// Common sub-keys
#define szWrappersKey      "Wrappers"
#define wszWrappersKey    L"Wrappers"
#define szFiltersKey       "Filters"
#define wszFiltersKey     L"Filters"
#define szStatisticsKey    "Statistics"
#define wszStatisticsKey  L"Statistics"
#define szCLSIDKey         "CLSID"
#define wszCLSIDKey       L"CLSID"
#define szCurrentKey       "Current"
#define wszCurrentKey     L"Current"
#define szIIDKey           "Interface"
#define wszIIDKey         L"Interface"
#define szModuleKey        "Module"
#define wszModuleKey      L"Module"
#define szDefaultKey       "Default"
#define wszDefaultKey     L"Default"
#define szIncludeOnlyKey   "Include Only"
#define wszIncludeOnlyKey L"Include Only"
#define szExcludeKey       "Exclude"
#define wszExcludeKey     L"Exclude"

// Common value names
#define szEnabledValue     "Enabled"
#define wszEnabledValue   L"Enabled"
#define szCLSIDValue       "CLSID"
#define wszCLSIDValue     L"CLSID"
#define szWrapperValue     "Wrapper"
#define wszWrapperValue   L"Wrapper"
#define szFilterValue      "Filter"
#define wszFilterValue    L"Filter"

#endif  // _REGISTRYKEYS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ih\ictsguid.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994.
//
//  File:       ICTGUID.h
//
//  Contents:	CLSIDs and IIDs for ICTS (Interface Conformance Test Suite)
//		Header File
//
//  Functions:	
//
//  History:	15-Jun-94 Garry Lenz    Created
//              12-Oct-94 Garry Lenz    Added IUnknownEx
//              12-Oct-94 Garry Lenz    Added IEnumGUID
//              13-Oct-94 Garry Lenz    Added Wrapper & Filter CLSIDs
//
//--------------------------------------------------------------------------

#ifndef _ICTSGUID_H_
#define _ICTSGUID_H_

#include <Windows.h>

//#ifdef INITGUID
    DEFINE_OLEGUID(IID_IUnknownEx,              0x0002AD00, 0, 0);
    DEFINE_OLEGUID(IID_IEnumGUID,               0x0002AD01, 0, 0);

    DEFINE_OLEGUID(CLSID_HookOleObject,         0x0002AD10, 0, 0);
    DEFINE_OLEGUID(IID_IHookOleObject,          0x0002AD11, 0, 0);
    DEFINE_OLEGUID(IID_IHookOleClass,           0x0002AD12, 0, 0);
    DEFINE_OLEGUID(IID_IHookOleInstance,        0x0002AD13, 0, 0);
    DEFINE_OLEGUID(IID_IHookOleInterface,       0x0002AD14, 0, 0);
    DEFINE_OLEGUID(IID_IHookOleMethod,          0x0002AD15, 0, 0);
    DEFINE_OLEGUID(IID_IHookOleWrapper,         0x0002AD1A, 0, 0);
    DEFINE_OLEGUID(IID_IHookOleFilter,          0x0002AD1B, 0, 0);

    DEFINE_OLEGUID(CLSID_HookOleAPI,            0x0002AD20, 0, 0);

    DEFINE_OLEGUID(CLSID_HookOleLog,            0x0002AD30, 0, 0);
    DEFINE_OLEGUID(IID_IHookOleLog,             0x0002AD31, 0, 0);

    DEFINE_OLEGUID(CLSID_HookOleWrapper,        0x0002ADA0, 0, 0);
    DEFINE_OLEGUID(CLSID_HOW_ComponentObject,   0x0002ADA1, 0, 0);
    DEFINE_OLEGUID(CLSID_HOW_CompoundDocument,  0x0002ADA2, 0, 0);
    DEFINE_OLEGUID(CLSID_HOW_DataTransfer,      0x0002ADA3, 0, 0);
    DEFINE_OLEGUID(CLSID_HOW_Linking,           0x0002ADA4, 0, 0);
    DEFINE_OLEGUID(CLSID_HOW_PersistentStorage, 0x0002ADA5, 0, 0);
    DEFINE_OLEGUID(CLSID_HOW_DragAndDrop,       0x0002ADA6, 0, 0);
    DEFINE_OLEGUID(CLSID_HOW_InPlaceActivation, 0x0002ADA7, 0, 0);
    DEFINE_OLEGUID(CLSID_HOW_Concurrency,       0x0002ADA8, 0, 0);
    DEFINE_OLEGUID(CLSID_HOW_Automation,        0x0002ADA9, 0, 0);

    DEFINE_OLEGUID(CLSID_HookOleFilter,         0x0002ADB0, 0, 0);
    DEFINE_OLEGUID(CLSID_HOF_ComponentObject,   0x0002ADB1, 0, 0);
    DEFINE_OLEGUID(CLSID_HOF_CompoundDocument,  0x0002ADB2, 0, 0);
    DEFINE_OLEGUID(CLSID_HOF_DataTransfer,      0x0002ADB3, 0, 0);
    DEFINE_OLEGUID(CLSID_HOF_Linking,           0x0002ADB4, 0, 0);
    DEFINE_OLEGUID(CLSID_HOF_PersistentStorage, 0x0002ADB5, 0, 0);
    DEFINE_OLEGUID(CLSID_HOF_DragAndDrop,       0x0002ADB6, 0, 0);
    DEFINE_OLEGUID(CLSID_HOF_InPlaceActivation, 0x0002ADB7, 0, 0);
    DEFINE_OLEGUID(CLSID_HOF_Concurrency,       0x0002ADB8, 0, 0);
    DEFINE_OLEGUID(CLSID_HOF_Automation,	0x0002ADB9, 0, 0);
#if 0
//#else
    extern "C"
     {
        extern IID IID_IUnknownEx;
        extern IID IID_IEnumGUID;

        extern CLSID CLSID_HookOleObject;
        extern IID IID_IHookOleObject;
        extern IID IID_IHookOleClass;
        extern IID IID_IHookOleInstance;
        extern IID IID_IHookOleInterface;
        extern IID IID_IHookOleMethod;
        extern IID IID_IHookOleWrapper;
        extern IID IID_IHookOleFilter;

        extern CLSID CLSID_HookOleAPI;

        extern CLSID CLSID_HookOleLog;
        extern IID IID_IHookOleLog;

        extern CLSID CLSID_HookOleWrapper;
        extern CLSID CLSID_HOW_ComponentObject;
        extern CLSID CLSID_HOW_CompoundDocument;
        extern CLSID CLSID_HOW_DataTransfer;
        extern CLSID CLSID_HOW_Linking;
        extern CLSID CLSID_HOW_PersistentStorage;
        extern CLSID CLSID_HOW_DragAndDrop;
        extern CLSID CLSID_HOW_InPlaceActivation;
        extern CLSID CLSID_HOW_Concurrency;

        extern CLSID CLSID_HookOleFilter;
        extern CLSID CLSID_HOF_ComponentObject;
        extern CLSID CLSID_HOF_CompoundDocument;
        extern CLSID CLSID_HOF_DataTransfer;
        extern CLSID CLSID_HOF_Linking;
        extern CLSID CLSID_HOF_PersistentStorage;
        extern CLSID CLSID_HOF_DragAndDrop;
        extern CLSID CLSID_HOF_InPlaceActivation;
        extern CLSID CLSID_HOF_Concurrency;
     }

#endif /* INITGUID */

#endif /* _ICTSGUID_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ih\hkole32x.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994.
//
//  File:       hkOle32x.h
//
//  Contents:   OLE 32 Extensions Header File
//
//  Functions:  
//
//  History:    29-Nov-94 Garry Lenz    Created
//
//--------------------------------------------------------------------------
#ifndef _HKOLE32X_H_
#define _HKOLE32X_H_

#include <Windows.h>
#include <TChar.h>

interface IHookOleObject;

STDAPI CoGetCurrentLogicalThreadId(GUID* pguidLogicalThreadId);
STDAPI GetHookInterface(IHookOleObject** pIHookOleObject);
STDAPI EnableHookObject(BOOL fNewState, BOOL* pfPrevState);

#define GUID_STRING_LENGTH   39
#define CLSID_STRING_LENGTH  39
#define IID_STRING_LENGTH    39
#define PROGID_STRING_LENGTH 40



// used by INITHOOKOBJECT

inline HRESULT CLSIDFromStringA(LPSTR lpsz, LPCLSID lpclsid)
{
    LPWSTR lpwsz = new WCHAR[(strlen(lpsz)+1)];
    MultiByteToWideChar (CP_ACP, MB_PRECOMPOSED, lpsz, -1, lpwsz, lstrlenA(lpsz)+1);
    HRESULT hr = CLSIDFromString(lpwsz, lpclsid);
    delete lpwsz;
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////

#ifdef OLETOOLS
// these are needed only by the tools, not internally by ole32. we ifdef
// it here to maintain source compatibility.

inline BOOL IsOle32ProcDefined(LPCSTR pszProcName)
{
    BOOL fResult = FALSE;
    HINSTANCE hInstOle32 = LoadLibrary(__T("OLE32.DLL"));
    if (hInstOle32)
    {
	if (GetProcAddress(hInstOle32, pszProcName) != NULL)
	    fResult = TRUE;
	FreeLibrary(hInstOle32);
    }
    return fResult;
}

inline HINSTANCE CoLoadLibrary(LPSTR lpszLibName, BOOL bAutoFree)
{
    LPWSTR lpwsz = new WCHAR[(strlen(lpszLibName)+1)];
    MultiByteToWideChar (CP_ACP, MB_PRECOMPOSED, lpszLibName, -1, lpwsz, lstrlenA(lpszLibName)+1);
    HINSTANCE hInstance = CoLoadLibrary(lpwsz, bAutoFree);
    delete lpwsz;
    return hInstance;
}

inline HRESULT IIDFromString(LPSTR lpsz, LPIID lpiid)
{
    LPWSTR lpwsz = new WCHAR[(strlen(lpsz)+1)];
    MultiByteToWideChar (CP_ACP, MB_PRECOMPOSED, lpsz, -1, lpwsz, lstrlenA(lpsz)+1);
    HRESULT hr = IIDFromString(lpwsz, lpiid);
    delete lpwsz;
    return hr;
}

inline HRESULT StringFromIID(REFIID riid, LPSTR FAR* lplpsz)
{
    HRESULT hr = StringFromIID(riid, (LPWSTR*)lplpsz);
    if (hr == S_OK)
    {
	WCHAR wsz[IID_STRING_LENGTH];
	lstrcpyW(wsz, (LPWSTR)*lplpsz);
        WideCharToMultiByte (CP_ACP, WC_COMPOSITECHECK, wsz, -1, *lplpsz, lstrlenW(wsz), NULL, NULL);
    }
    return hr;
}

inline HRESULT StringFromCLSID(REFCLSID rclsid, LPSTR FAR* lplpsz)
{
    HRESULT hr = StringFromCLSID(rclsid, (LPWSTR*)lplpsz);
    if (hr == S_OK)
    {
	WCHAR  wsz[CLSID_STRING_LENGTH];
	lstrcpyW(wsz, (LPWSTR)*lplpsz);
        WideCharToMultiByte (CP_ACP, WC_COMPOSITECHECK, wsz, -1, *lplpsz, lstrlenW(wsz), NULL, NULL);
    }
    return hr;
}

inline HRESULT ProgIDFromCLSID(REFCLSID rclsid, LPSTR FAR* lplpsz)
{
    HRESULT hr = ProgIDFromCLSID(rclsid, (LPWSTR*)lplpsz);
    if (hr == S_OK)
    {
	WCHAR  wsz[PROGID_STRING_LENGTH];
	lstrcpyW(wsz, (LPWSTR)*lplpsz);
        WideCharToMultiByte (CP_ACP, WC_COMPOSITECHECK, wsz, -1, *lplpsz, lstrlenW(wsz), NULL, NULL);
    }
    return hr;
}

inline HRESULT CLSIDFromProgID(LPCSTR lpszProgID, LPCLSID lpclsid)
{
    LPWSTR lpwsz = new WCHAR[(strlen(lpszProgID)+1)];
    MultiByteToWideChar (CP_ACP, MB_PRECOMPOSED, lpszProgID, -1, lpwsz, lstrlenA(lpszProgID)+1);
    HRESULT hr = CLSIDFromProgID(lpwsz, lpclsid);
    delete lpwsz;
    return hr;
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
#endif

#endif // _HKOLE32X_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ih\map_kv.h ===
#ifndef __MAP_KV_H__
#define __MAP_KV_H__

#include    <memapi.hxx>

/////////////////////////////////////////////////////////////////////////////
// class CMapKeyToValue - a mapping from 'KEY's to 'VALUE's, passed in as
// pv/cb pairs.  The keys can be variable length, although we optmizize the
// case when they are all the same.
//
/////////////////////////////////////////////////////////////////////////////

STDAPI_(UINT) MKVDefaultHashKey(LPVOID pKey, UINT cbKey);

#ifdef WIN32
DECLARE_HANDLE(HMAPKEY);
#else
DECLARE_HANDLE32(HMAPKEY);
#endif

typedef UINT (STDAPICALLTYPE FAR* LPFNHASHKEY)(LPVOID, UINT);

class FAR CMapKeyToValue : public CPrivAlloc
{
public:
        CMapKeyToValue(UINT cbValue, UINT cbKey = 0,
                int nBlockSize=10,
                LPFNHASHKEY lpfnHashKey = NULL,
                UINT nHashSize = 17);
        ~CMapKeyToValue();

        // number of elements
        int     GetCount() const { return m_nCount; }
        BOOL    IsEmpty() const { return m_nCount == 0; }

        // Lookup; return FALSE if not found
        BOOL    Lookup(LPVOID pKey, UINT cbKey, LPVOID pValue) const;
        BOOL    LookupHKey(HMAPKEY hKey, LPVOID pValue) const;
        BOOL    LookupAdd(LPVOID pKey, UINT cbKey, LPVOID pValue) const;

        // add a new (key, value) pair; return FALSE if out of memory
        BOOL    SetAt(LPVOID pKey, UINT cbKey, LPVOID pValue);
        BOOL    SetAtHKey(HMAPKEY hKey, LPVOID pValue);

        // removing existing (key, ?) pair; return FALSE if no such key
        BOOL    RemoveKey(LPVOID pKey, UINT cbKey);
        BOOL    RemoveHKey(HMAPKEY hKey);
        void    RemoveAll();

        // iterating all (key, value) pairs
        POSITION GetStartPosition() const
                        { return (m_nCount == 0) ? (POSITION)NULL : BEFORE_START_POSITION; }
        void    GetNextAssoc(POSITION FAR* pNextPosition, LPVOID pKey,
                                UINT FAR* pcbKey, LPVOID pValue) const;

        // return HMAPKEY for given key; returns NULL if not currently in map
        HMAPKEY GetHKey(LPVOID pKey, UINT cbKey) const;

        void    AssertValid() const;

private:
        // abstracts, somewhat, variable and fixed sized keys; size is really
        // m_cbKeyInAssoc.
        union CKeyWrap
        {
                BYTE rgbKey[sizeof(LPVOID) + sizeof(UINT)];
                struct
                {
                        LPVOID pKey;
                        UINT cbKey;
                };
        };

        // Association of one key and one value; NOTE: even though in general
        // the size of the key and value varies, for any given map,
        // the size of an assoc is fixed.
        struct CAssoc
        {
                CAssoc  FAR* pNext;
                UINT    nHashValue; // needed for efficient iteration
                CKeyWrap key;           // size is really m_cbKeyInAssoc
                // BYTE rgbValue[m_cbValue];
        };

        UINT    SizeAssoc() const
                { return sizeof(CAssoc)-sizeof(CKeyWrap) + m_cbKeyInAssoc + m_cbValue; }
        CAssoc  FAR* NewAssoc(UINT hash, LPVOID pKey, UINT cbKey, LPVOID pValue);
        void    FreeAssoc(CAssoc FAR* pAssoc);
        BOOL    CompareAssocKey(CAssoc FAR* pAssoc, LPVOID pKey, UINT cbKey) const;
        CAssoc  FAR* GetAssocAt(LPVOID pKey, UINT cbKey, UINT FAR& nHash) const;

        BOOL    SetAssocKey(CAssoc FAR* pAssoc, LPVOID pKey, UINT cbKey) const;
        void    GetAssocKeyPtr(CAssoc FAR* pAssoc, LPVOID FAR* ppKey,UINT FAR* pcbKey) const;
        void    FreeAssocKey(CAssoc FAR* pAssoc) const;
        void    GetAssocValuePtr(CAssoc FAR* pAssoc, LPVOID FAR* ppValue) const;
        void    GetAssocValue(CAssoc FAR* pAssoc, LPVOID pValue) const;
        void    SetAssocValue(CAssoc FAR* pAssoc, LPVOID pValue) const;

        BOOL    InitHashTable();

        UINT    m_cbValue;
        UINT    m_cbKey;                        // variable length if 0
        UINT    m_cbKeyInAssoc;         // always non-zero

        CAssoc  FAR* FAR* m_pHashTable;
        UINT    m_nHashTableSize;
        LPFNHASHKEY m_lpfnHashKey;

        int     m_nCount;
        CAssoc  FAR* m_pFreeList;
        struct CPlex FAR* m_pBlocks;
        int     m_nBlockSize;
};


#endif // !__MAP_KV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ih\ole1cls.h ===
/*****************************************************************************\
*                                                                             *
* ole1cls.h -   Master definition of GUIDs for OLE1 classes					  *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/

/* This file is the master definition of all GUIDs for OLE1 classes.

   All such GUIDs are of the form:

       0003xxxx-0000-0000-C000-000000000046

    The last parameter to DEFINE_OLE1GUID is the old 1.0 class name,
    i.e., its key in the registration database.

    Do not remove or change GUIDs.

    Do not add anything to this file except comments and DEFINE_OLE1GUID macros.
*/

#ifndef DEFINE_OLE1GUID
#define DEFINE_OLE1GUID(a,b,c,d,e) DEFINE_OLEGUID (a,b,c,d)
#endif

#ifdef WIN32
#define LSTR(x) L##x
#else
#define LSTR(x) x
#endif


DEFINE_OLE1GUID(CLSID_ExcelWorksheet,	0x00030000, 0, 0, LSTR("ExcelWorksheet"));
DEFINE_OLE1GUID(CLSID_ExcelChart,	0x00030001, 0, 0, LSTR("ExcelChart"));
DEFINE_OLE1GUID(CLSID_ExcelMacrosheet,	0x00030002, 0, 0, LSTR("ExcelMacrosheet"));
DEFINE_OLE1GUID(CLSID_WordDocument,	0x00030003, 0, 0, LSTR("WordDocument"));
DEFINE_OLE1GUID(CLSID_MSPowerPoint,	0x00030004, 0, 0, LSTR("MSPowerPoint"));
DEFINE_OLE1GUID(CLSID_MSPowerPointSho,	0x00030005, 0, 0, LSTR("MSPowerPointSho"));
DEFINE_OLE1GUID(CLSID_MSGraph,		0x00030006, 0, 0, LSTR("MSGraph"));
DEFINE_OLE1GUID(CLSID_MSDraw,		0x00030007, 0, 0, LSTR("MSDraw"));
DEFINE_OLE1GUID(CLSID_Note_It,		0x00030008, 0, 0, LSTR("Note-It"));
DEFINE_OLE1GUID(CLSID_WordArt,		0x00030009, 0, 0, LSTR("WordArt"));
DEFINE_OLE1GUID(CLSID_PBrush,		0x0003000a, 0, 0, LSTR("PBrush"));
DEFINE_OLE1GUID(CLSID_Equation, 	0x0003000b, 0, 0, LSTR("Equation"));
DEFINE_OLE1GUID(CLSID_Package,		0x0003000c, 0, 0, LSTR("Package"));
DEFINE_OLE1GUID(CLSID_SoundRec, 	0x0003000d, 0, 0, LSTR("SoundRec"));
DEFINE_OLE1GUID(CLSID_MPlayer,		0x0003000e, 0, 0, LSTR("MPlayer"));

/* test apps */
DEFINE_OLE1GUID(CLSID_ServerDemo,	0x0003000f, 0, 0, LSTR("ServerDemo"));
DEFINE_OLE1GUID(CLSID_Srtest,		0x00030010, 0, 0, LSTR("Srtest"));
DEFINE_OLE1GUID(CLSID_SrtInv,		0x00030011, 0, 0, LSTR("SrtInv"));
DEFINE_OLE1GUID(CLSID_OleDemo,		0x00030012, 0, 0, LSTR("OleDemo"));

/* External ISVs */
// Coromandel / Dorai Swamy / 718-793-7963
DEFINE_OLE1GUID(CLSID_CoromandelIntegra,0x00030013, 0, 0, LSTR("CoromandelIntegra"));
DEFINE_OLE1GUID(CLSID_CoromandelObjServer,0x00030014, 0, 0, LSTR("CoromandelObjServer"));

// 3-d Visions Corp / Peter Hirsch / 310-325-1339
DEFINE_OLE1GUID(CLSID_StanfordGraphics, 0x00030015, 0, 0, LSTR("StanfordGraphics"));

// Deltapoint / Nigel Hearne / 408-648-4000
DEFINE_OLE1GUID(CLSID_DGraphCHART,	0x00030016, 0, 0, LSTR("DGraphCHART"));
DEFINE_OLE1GUID(CLSID_DGraphDATA,	0x00030017, 0, 0, LSTR("DGraphDATA"));

// Corel / Richard V. Woodend / 613-728-8200 x1153
DEFINE_OLE1GUID(CLSID_PhotoPaint,	0x00030018, 0, 0, LSTR("PhotoPaint"));
DEFINE_OLE1GUID(CLSID_CShow,		0x00030019, 0, 0, LSTR("CShow"));
DEFINE_OLE1GUID(CLSID_CorelChart,	0x0003001a, 0, 0, LSTR("CorelChart"));
DEFINE_OLE1GUID(CLSID_CDraw,		0x0003001b, 0, 0, LSTR("CDraw"));

// Inset Systems / Mark Skiba / 203-740-2400
DEFINE_OLE1GUID(CLSID_HJWIN1_0, 	0x0003001c, 0, 0, LSTR("HJWIN1.0"));

// Mark V Systems / Mark McGraw / 818-995-7671
DEFINE_OLE1GUID(CLSID_ObjMakerOLE,	0x0003001d, 0, 0, LSTR("ObjMakerOLE"));

// IdentiTech / Mike Gilger / 407-951-9503
DEFINE_OLE1GUID(CLSID_FYI,		0x0003001e, 0, 0, LSTR("FYI"));
DEFINE_OLE1GUID(CLSID_FYIView,		0x0003001f, 0, 0, LSTR("FYIView"));

// Inventa Corporation / Balaji Varadarajan / 408-987-0220
DEFINE_OLE1GUID(CLSID_Stickynote,	0x00030020, 0, 0, LSTR("Stickynote"));

// ShapeWare Corp. / Lori Pearce / 206-467-6723
DEFINE_OLE1GUID(CLSID_ShapewareVISIO10, 0x00030021, 0, 0, LSTR("ShapewareVISIO10"));
DEFINE_OLE1GUID(CLSID_ImportServer,	0x00030022, 0, 0, LSTR("ImportServer"));


// test app SrTest
DEFINE_OLE1GUID(CLSID_SrvrTest, 	0x00030023, 0, 0, LSTR("SrvrTest"));

// Special clsid for when a 1.0 client pastes an embedded object
// that is a link.
// **This CLSID is obsolete. Do not reuse number.
//DEFINE_OLE1GUID(CLSID_10EmbedObj,	0x00030024, 0, 0, LSTR("OLE2_Embedded_Link"));

// test app ClTest.  Doesn't really work as a server but is in reg db
DEFINE_OLE1GUID(CLSID_ClTest,		0x00030025, 0, 0, LSTR("Cltest"));

// Microsoft ClipArt Gallery   Sherry Larsen-Holmes
DEFINE_OLE1GUID(CLSID_MS_ClipArt_Gallery,0x00030026, 0, 0, LSTR("MS_ClipArt_Gallery"));

// Microsoft Project  Cory Reina
DEFINE_OLE1GUID(CLSID_MSProject,	0x00030027, 0, 0, LSTR("MSProject"));

// Microsoft Works Chart
DEFINE_OLE1GUID(CLSID_MSWorksChart,	0x00030028, 0, 0, LSTR("MSWorksChart"));

// Microsoft Works Spreadsheet
DEFINE_OLE1GUID(CLSID_MSWorksSpreadsheet,0x00030029, 0, 0, LSTR("MSWorksSpreadsheet"));

// AFX apps - Dean McCrory
DEFINE_OLE1GUID(CLSID_MinSvr,		0x0003002A, 0, 0, LSTR("MinSvr"));
DEFINE_OLE1GUID(CLSID_HierarchyList,	0x0003002B, 0, 0, LSTR("HierarchyList"));
DEFINE_OLE1GUID(CLSID_BibRef,		0x0003002C, 0, 0, LSTR("BibRef"));
DEFINE_OLE1GUID(CLSID_MinSvrMI, 	0x0003002D, 0, 0, LSTR("MinSvrMI"));
DEFINE_OLE1GUID(CLSID_TestServ, 	0x0003002E, 0, 0, LSTR("TestServ"));

// Ami Pro
DEFINE_OLE1GUID(CLSID_AmiProDocument,	0x0003002F, 0, 0, LSTR("AmiProDocument"));

// WordPerfect Presentations For Windows
DEFINE_OLE1GUID(CLSID_WPGraphics,	0x00030030, 0, 0, LSTR("WPGraphics"));
DEFINE_OLE1GUID(CLSID_WPCharts, 	0x00030031, 0, 0, LSTR("WPCharts"));


// MicroGrafx Charisma
DEFINE_OLE1GUID(CLSID_Charisma, 	0x00030032, 0, 0, LSTR("Charisma"));
DEFINE_OLE1GUID(CLSID_Charisma_30,	0x00030033, 0, 0, LSTR("Charisma_30"));
DEFINE_OLE1GUID(CLSID_CharPres_30,	0x00030034, 0, 0, LSTR("CharPres_30"));

// MicroGrafx Draw
DEFINE_OLE1GUID(CLSID_Draw,		0x00030035, 0, 0, LSTR("Draw"));

// MicroGrafx Designer
DEFINE_OLE1GUID(CLSID_Designer_40,	0x00030036, 0, 0, LSTR("Designer_40"));


#undef DEFINE_OLE1GUID

/* as we discover OLE 1 servers we will add them to the end of this list;
   there is room for 64K of them!
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ih\ole2ver.h ===
/*****************************************************************************\
*                                                                             *
* ole2ver.h -   OLE 2 Version Number Info                                     *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/

#ifndef _OLE2VER_H_
#define _OLE2VER_H_

#define rmm     23
#define rup     639

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ih\olecoll.h ===
// Microsoft OLE library.
// Copyright (C) 1992 Microsoft Corporation,
// All rights reserved.

// olecoll.h - global defines for collections and element definitions

#ifndef __OLECOLL_H__
#define __OLECOLL_H__


// ---------------------------------------------------------------------------
// general defines for collections

typedef void FAR* POSITION;

#define BEFORE_START_POSITION ((POSITION)LongToPtr(-1L))
#define _AFX_FP_OFF(thing) (*((UINT FAR*)&(thing)))
#define _AFX_FP_SEG(lp) (*((UINT FAR*)&(lp)+1))

#ifdef _DEBUG
#define ASSERT_VALID(p) p->AssertValid()
#else
#define ASSERT_VALID(p)
#endif


#endif //!__OLECOLL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ih\oletemp.h ===
// for OleCreateEmbeddingHelper flags; roles in low word; options in high word
#define EMBDHLP_INPROC_HANDLER   0x0000L
#define EMBDHLP_INPROC_SERVER    0x0001L
#define EMBDHLP_CREATENOW    0x00000000L
#define EMBDHLP_DELAYCREATE  0x00010000L
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ih\ole2com.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       ole2com.h
//
//  Contents:   Common definitions shared by com and ole232
//
//  Classes:
//
//  Functions:
//
//  History:    4-26-94   kevinro   Created
//              06-16-94  AlexT     Add FnAssert prototype
//                        07-26-94  AlexGo    Added CStabilize and CSafeRefCount
//              21-Dec-94 BruceMa   Wrap mbstowcs and wcstombs
//              23-Jan-95 t-ScottH  added Dump method to CSafeRefCount
//              08-Sep-95 murthys   Added declarations for compapi worker
//                                   used by com, stg, scm etc
//
//  Notes:
//      There are two versions of ole2int.h in the project. This is
//      unfortunate, but would be a major pain in the butt to fix.
//      What I have done is to extract the share parts of the two files,
//      and put them in this file. ole2int.h then includes this file.
//
//      Someday, somebody should reconcile all of the differences between the
//      two ole2int.h files, and rename them. Don't have time for that now,
//      so I have gone for the path of least resistance.
//                                                      KevinRo
//----------------------------------------------------------------------------
#ifndef _OLE2COM_H_
#define _OLE2COM_H_

#include <memapi.hxx>

//
// common compobj API worker functions used by com, stg, scm etc
//
// These definitions are shared between all of the components of OLE that
// use the common directory, such as SCM and COMPOBJ
//
//  format for string form of GUID is (leading identifier ????)
//  ????{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}

#define GUIDSTR_MAX (1+ 8 + 1 + 4 + 1 + 4 + 1 + 4 + 1 + 12 + 1 + 1)
#define CLSIDSTR_MAX (GUIDSTR_MAX)
#define IIDSTR_MAX   (GUIDSTR_MAX)

//
// Internal values used between OLE32 and SCM
//

#define APT_THREADED                  0
#define FREE_THREADED                 1
#define SINGLE_THREADED               2
#define BOTH_THREADED                 3
#define NEUTRAL_THREADED              4
#define GOT_FROM_ROT                  0x80000000


//
// Internal CLSCTX used for loading Proxy/Stub DLLs
//
#define CLSCTX_PS_DLL                 0x80000000

//
// The following flags are used to support loading INPROC items into 16-bit DLL's
//
#define CLSCTX_INPROC_HANDLERS (CLSCTX_INPROC_HANDLER16 | CLSCTX_INPROC_HANDLER | CLSCTX_INPROC_HANDLERX86)
#define CLSCTX_INPROC_SERVERS (CLSCTX_INPROC_SERVER16 | CLSCTX_INPROC_SERVER | CLSCTX_INPROC_SERVERX86 | CLSCTX_PS_DLL)

// "common" compapi worker functions

INTERNAL_(int)  wStringFromGUID2(REFGUID rguid, LPWSTR lpsz, int cbMax);
INTERNAL wStringFromUUID(REFGUID rguid, LPWSTR lpsz);
void FormatHexNumW( unsigned long ulValue, unsigned long chChars, WCHAR *pwcStr);
void FormatHexNumA( unsigned long ulValue, unsigned long chChars, char *pchStr);

#ifdef _CHICAGO_
INTERNAL_(int) wStringFromGUID2A(REFGUID rguid, LPSTR lpsz, int cbMax);
#define wStringFromGUID2T wStringFromGUID2A
#else
#define wStringFromGUID2T wStringFromGUID2
#endif

BOOL wThreadModelMatch(DWORD dwCallerThreadModel,DWORD dwDllThreadModel,DWORD dwContext);
LONG wQueryStripRegValue(HKEY hkey,LPCWSTR pwszSubKey,LPTSTR pwszValue, PLONG pcbValue);
LONG wGetDllInfo(HKEY hClsRegEntry,LPCWSTR pwszKey,LPTSTR pwszDllName,LONG *pclDllName,ULONG *pulDllThreadType);
BOOL wCompareDllName(LPCWSTR pwszPath, LPCWSTR pwszDllName, DWORD dwDllNameLen);

// compapi worker functions

INTERNAL wIsInternalProxyStubIID(REFIID riid, LPCLSID lpclsid);
INTERNAL wCoTreatAsClass(REFCLSID clsidOld, REFCLSID clsidNew);
INTERNAL wCLSIDFromOle1Class(LPCWSTR lpsz, LPCLSID lpclsid, BOOL fForceAssign=FALSE);
INTERNAL wCLSIDFromString(LPWSTR lpsz, LPCLSID lpclsid);

#define wCLSIDFromProgID    wCLSIDFromOle1Class

INTERNAL_(int) wOle1ClassFromCLSID2(REFCLSID rclsid, LPWSTR lpsz, int cbMax);
INTERNAL wCoGetTreatAsClass(REFCLSID clsidOld, LPCLSID lpClsidNew);
INTERNAL wRegQueryPSClsid(REFIID riid, LPCLSID lpclsid);
INTERNAL wRegQuerySyncIIDFromAsyncIID(REFIID riid, LPCLSID lpiidSync);
INTERNAL wRegQueryAsyncIIDFromSyncIID(REFIID riid, LPCLSID lpiidAsync);
INTERNAL wCoGetPSClsid(REFIID riid, LPCLSID lpclsid);
INTERNAL wCoGetClassExt(LPCWSTR pwszExt, LPCLSID pclsid);
INTERNAL wRegGetClassExt(LPCWSTR lpszExt, LPCLSID pclsid);
INTERNAL wCoGetClassPattern(HANDLE hfile, CLSID *pclsid);
INTERNAL wCoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter, DWORD dwContext, REFIID riid, LPVOID FAR* ppv);
INTERNAL_(HRESULT) wCoMarshalInterThreadInterfaceInStream(REFIID riid, LPUNKNOWN pUnk, LPSTREAM *ppStm);
INTERNAL_(HRESULT) wCoGetInterfaceAndReleaseStream(LPSTREAM pstm, REFIID riid, LPVOID *ppv);
INTERNAL_(BOOL) wGUIDFromString(LPCWSTR lpsz, LPGUID pguid);
INTERNAL_(BOOL) wUUIDFromString(LPCWSTR lpsz, LPGUID pguid);
INTERNAL wStringFromCLSID(REFCLSID rclsid, LPWSTR FAR* lplpsz);
INTERNAL wStringFromIID(REFIID rclsid, LPWSTR FAR* lplpsz);
INTERNAL wIIDFromString(LPWSTR lpsz, LPIID lpiid);
INTERNAL_(BOOL) wCoIsOle1Class(REFCLSID rclsid);
INTERNAL wkProgIDFromCLSID(REFCLSID rclsid, LPWSTR FAR* ppszProgID);
INTERNAL wRegOpenClassKey(REFCLSID clsid, REGSAM samDesired, HKEY FAR* lphkeyClsid);
INTERNAL wRegOpenClassSubkey(REFCLSID rclsid, LPCWSTR lpszSubkey, HKEY *phkeySubkey);
INTERNAL wRegOpenFileExtensionKey(LPCWSTR pszFileExt, HKEY FAR* lphkeyClsid);
INTERNAL wRegOpenInterfaceKey(REFIID riid, HKEY * lphkeyIID);
INTERNAL wRegOpenProgIDKey(LPCWSTR pszProgID, HKEY FAR* lphkeyClsid);
INTERNAL wRegQueryClassValue(REFCLSID rclsid, LPCWSTR lpszSubKey,
                             LPWSTR lpszValue, int cbMax);

INTERNAL_(LONG) wRegOpenKeyEx(
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD ulOptions,
    REGSAM samDesired,
    PHKEY phkResult);

//
// There are two sets of possible keys. There are the 32 bit, as well as
// the 16 bit
//

#ifdef _KEVINROS_CHICAGO_CHANGES_
const WCHAR wszOle32Dll[] = L"OLE32.DLL";

#define OLE32_DLL wszOle32Dll
#define OLE32_BYTE_LEN sizeof(OLE32_DLL)
#define OLE32_CHAR_LEN (sizeof(OLE32_DLL) / sizeof(WCHAR) - 1)
#endif

const WCHAR wszCLSID[]     =  L"CLSID";

const WCHAR wszInprocServer[]   = L"InprocServer32";
const WCHAR wszInprocHandler[]  = L"InprocHandler32";
const WCHAR wszLocalServer[]    = L"LocalServer32";

const WCHAR wszActivateAtBits[] = L"ActivateAtBits";
const WCHAR wszActivateRemote[] = L"Remote";
const WCHAR wszDebug[]    = L"Debug";

const WCHAR wszLocalServer16[]   = L"LocalServer";
const WCHAR wszInprocServer16[]  = L"InprocServer";
const WCHAR wszInprocHandler16[] = L"InprocHandler";

const WCHAR wszOle2Dll[] = L"OLE2.DLL";

#define OLE2_DLL wszOle2Dll
#define OLE2_BYTE_LEN sizeof(OLE2_DLL)
#define OLE2_CHAR_LEN (sizeof(OLE2_DLL) / sizeof(WCHAR) - 1)


const WCHAR wszCLSIDBACK[] = L"CLSID\\";
#define CLSIDBACK wszCLSIDBACK
#define CLSIDBACK_BYTE_LEN sizeof(CLSIDBACK)
#define CLSIDBACK_CHAR_LEN (sizeof(CLSIDBACK) / sizeof(WCHAR) - 1)

#define KEY_LEN             256     //  max size of registry key
#define VALUE_LEN           256     //  max size of registry value

#ifdef _CAIRO_

#define _DCOM_          // enable definition of Cairo OLE COM extensions
#include <oleext.h>

#else

// These API's are exposed for Cairo but not for Daytona, so we declare
// them here for internal users

WINOLEAPI OleInitializeEx(LPVOID pvReserved, DWORD);
WINOLEAPI CoGetPersistentInstance(
    REFIID riid,
    DWORD dwCtrl,
    DWORD grfMode,
    OLECHAR *pwszName,
    struct IStorage *pstg,
    REFCLSID rclsidOle1,
    BOOL * pfOle1Loaded,
    void **ppvUnk);
#endif


//
// No longer in the Cairo DEF file.  We want to remove this as soon as
// oleutest can be changed to not use it.
//
WINOLEAPI CoNewPersistentInstance(
    REFCLSID rclsid,
    REFIID riid,
    DWORD dwCtrl,
    DWORD grfMode,
    OLECHAR *pwszCreateFrom,
    struct IStorage *pstgCreateFrom,
    OLECHAR *pwszNewName,
    void **ppunk);

#if DBG==1
STDAPI FnAssert(LPSTR lpstrExpr, LPSTR lpstrMsg, LPSTR lpstrFileName, UINT iLine);
ULONG GetInfoLevel(CHAR *pszKey, ULONG *pulValue, CHAR *pszdefval);
void StgDebugInit(void);
#endif

//
// The Storage entry points that are called from OLE entry points.
//
HRESULT Storage32DllGetClassObject(REFCLSID clsid, REFIID riid, void **ppv);
STDAPI  Storage32DllRegisterServer(void);

#if defined(_M_I86SM) || defined(_M_I86MM)
#define _NEARDATA
#endif

#ifdef WIN32
#define HTASK DWORD         // Use Proccess id / Thread id
#endif


#ifdef WIN32
// we have to define these because they have been deleted from
// win32s, where only the ...Ex versions exist anymore.
// Now, that's backward compatibility!
# define SetWindowOrg(h,x,y)       SetWindowOrgEx((h),(x),(y),NULL)
# define SetWindowExt(h,x,y)       SetWindowExtEx((h),(x),(y),NULL)
# define SetViewportOrg(h,x,y)     SetViewportOrgEx((h),(x),(y),NULL)
# define SetViewportExt(h,x,y)     SetViewportExtEx((h),(x),(y),NULL)
# define SetBitmapDimension(h,x,y) SetBitmapDimensionEx((h),(x),(y),NULL)
#endif


#ifdef WIN32

# define _xstrcpy   lstrcpyW
# define _xstrcat   lstrcatW
# define _xstrlen   lstrlenW
# define _xstrchr   wcschr
# define _xstrcmp   lstrcmpW
# define _xstricmp  lstrcmpiW
# define _xstrtok   wcstok
# define _xisdigit(c)  (IsCharAlphaNumericW(c) && !IsCharAlphaW(c))

#else // !WIN32

# define _xstrcpy   _fstrcpy
# define _xstrcat   _fstrcat
# define _xstrlen   _fstrlen
# define _xstrchr   _fstrchr
# define _xstrcmp   _fstrcmp
# define _xstricmp  _fstricmp
# define _xstrtok   _fstrtok
# define _xisdigit(c)  isdigit(c)

#endif // WIN32

//+----------------------------------------------------------------------------
//
//      Macro:
//              GETPPARENT
//
//      Synopsis:
//              Given a pointer to something contained by a struct (or
//              class,) the type name of the containing struct (or class),
//              and the name of the member being pointed to, return a pointer
//              to the container.
//
//      Arguments:
//              [pmemb] -- pointer to member of struct (or class.)
//              [struc] -- type name of containing struct (or class.)
//              [membname] - name of member within the struct (or class.)
//
//      Returns:
//              pointer to containing struct (or class)
//
//      Notes:
//              Assumes all pointers are FAR.
//
//      History:
//              11/10/93 - ChrisWe - created
//
//-----------------------------------------------------------------------------
#define GETPPARENT(pmemb, struc, membname) (\
                (struc FAR *)(((char FAR *)(pmemb))-offsetof(struc, membname)))

//STDSTATIC is intended to be used for static class methods
//only!!
#define STDSTATIC_(type)     static type EXPORT
#define STDSTATICIMP_(type)  type EXPORT

#ifdef WIN32
# define WEP_FREE_DLL 0
# define WEP_SYSTEM_EXIT 1
#endif


#ifdef WIN32

inline UINT GetDriveTypeFromNumber(int i)
{
    TCHAR szDevice[] = TEXT("A:\\");

    // Pick off the drive letter from the input path.
    *szDevice = i + 'A';

#ifdef _UNICODE
    return(GetDriveTypeW(szDevice));
#else
    return(GetDriveTypeA(szDevice));
#endif
}

#endif

#ifndef _MAC

/* dll's instance and module handles */
extern HMODULE   g_hmodOLE2;
extern HINSTANCE g_hinst;

/* Variables for registered clipboard formats */
extern CLIPFORMAT g_cfObjectLink;
extern CLIPFORMAT g_cfOwnerLink;
extern CLIPFORMAT g_cfNative;
extern CLIPFORMAT g_cfLink;
extern CLIPFORMAT g_cfBinary;
extern CLIPFORMAT g_cfFileName;
extern CLIPFORMAT g_cfFileNameW;
extern CLIPFORMAT g_cfNetworkName;
extern CLIPFORMAT g_cfDataObject;
extern CLIPFORMAT g_cfEmbeddedObject;
extern CLIPFORMAT g_cfEmbedSource;
extern CLIPFORMAT g_cfLinkSource;
extern CLIPFORMAT g_cfOleDraw;
extern CLIPFORMAT g_cfLinkSrcDescriptor;
extern CLIPFORMAT g_cfObjectDescriptor;
extern CLIPFORMAT g_cfCustomLinkSource;
extern CLIPFORMAT g_cfPBrush;
extern CLIPFORMAT g_cfMSDraw;
extern CLIPFORMAT g_cfOlePrivateData;
extern CLIPFORMAT g_cfScreenPicture;  // used for XL and Word hack
                                      // see clipapi.cpp
extern CLIPFORMAT g_cfOleClipboardPersistOnFlush;
extern CLIPFORMAT g_cfMoreOlePrivateData;

#endif // _MAC


#include <utstream.h>

/*
 *      Warning disables:
 *
 *      We compile with warning level 4, with the following warnings
 *      disabled:
 *
 *      4355: 'this' used in base member initializer list
 *
 *              We don't see the point of this message and we do this all
 *              the time.
 *
 *      4505: Unreferenced local function has been removed -- the given
 *      function is local and not referenced in the body of the module.
 *
 *              Unfortunately, this is generated for every inline function
 *              seen in the header files that is not used in the module.
 *              Since we use a number of inlines, this is a nuisance
 *              warning.  It would be nice if the compiler distinguished
 *              between inlines and regular functions.
 *
 *      4706: Assignment within conditional expression.
 *
 *              We use this style of programming extensively, so this
 *              warning is disabled.
 */
#pragma warning(disable:4355)
#pragma warning(disable:4068)

/*
 *      MACROS for Mac/PC core code
 *
 *      The following macros reduce the proliferation of #ifdefs.  They
 *      allow tagging a fragment of code as Mac only, PC only, or with
 *      variants which differ on the PC and the Mac.
 *
 *      Usage:
 *
 *
 *      h = GetHandle();
 *      Mac(DisposeHandle(h));
 *
 *
 *      h = GetHandle();
 *      MacWin(h2 = h, CopyHandle(h, h2));
 *
 */
#ifdef _MAC
#define Mac(x) x
#define Win(x)
#define MacWin(x,y) x
#else
#define Mac(x)
#define Win(x) x
#define MacWin(x,y) y
#endif

// Define WX86OLE if WX86 hooks are to be included into ole and scm
#if defined(WX86)
#ifndef WX86OLE
#define WX86OLE
#endif
#endif

#ifdef WX86OLE
const WCHAR wszInprocServerX86[]  = L"InprocServerX86";
const WCHAR wszInprocHandlerX86[]  = L"InprocHandlerX86";
#endif

//
// The following include is for an interface between OLE and Wx86
#ifdef WX86OLE
#include <wx86grpa.hxx>
extern CWx86 gcwx86;
#endif

//
// The following includes an interface that is common between the
// WOW thunk layer, and the 32-bit version of OLE.
//

#include <thunkapi.hxx>         // WOW thunking interfaces

//
// A call to CoInitializeWOW will set the following variable. When set,
// it points to a VTABLE of functions that we can call in the thunk
// DLL. Only used when running in a VDM.
//
extern LPOLETHUNKWOW g_pOleThunkWOW;


// debug versions of interlocked increment/decrement; not accurate
// under multi-threading conditions, but better than the return value
// of the Interlocked increment/decrement functions.
inline DWORD InterlockedAddRef(DWORD *pRefs)
{
#if DBG==1
    DWORD refs = *pRefs + 1;
    InterlockedIncrement((LPLONG)pRefs);
    return refs;
#else
    return InterlockedIncrement((LPLONG)pRefs);
#endif
}

inline DWORD InterlockedRelease(DWORD *pRefs)
{
#if DBG==1
    DWORD refs = *pRefs - 1;
    return InterlockedDecrement((LPLONG)pRefs) == 0 ? 0 : refs;
#else
    return InterlockedDecrement((LPLONG)pRefs);
#endif
}


// helper for getting stable pointers during destruction or other times;
// NOTE: not thread safe; must provide higher level synchronization
inline void SafeReleaseAndNULL(IUnknown **ppUnk)
{
    if (*ppUnk != NULL)
    {
        IUnknown *pUnkSave = *ppUnk;
        *ppUnk = NULL;
        pUnkSave->Release();
    }
}



/***********************************************************************/
/*      FILE FORMAT RELATED INFO                        ****/

// Coponent object stream information

#define COMPOBJ_STREAM                          OLESTR("\1CompObj")
#define BYTE_ORDER_INDICATOR 0xfffe    // for MAC it could be different
#define COMPOBJ_STREAM_VERSION 0x0001

// OLE defines values for different OSs
#define OS_WIN  0x0000
#define OS_MAC  0x0001
#define OS_NT   0x0002

// HIGH WORD is OS indicator, LOW WORD is OS version number
extern DWORD gdwOrgOSVersion;
extern DWORD gdwOleVersion;

// Ole streams information
#define OLE_STREAM OLESTR("\1Ole")
#define OLE_PRODUCT_VERSION 0x0200 /* (HIGH BYTE major version) */
#define OLE_STREAM_VERSION 0x0001

#define OLE10_NATIVE_STREAM OLESTR("\1Ole10Native")
#define OLE10_ITEMNAME_STREAM OLESTR("\1Ole10ItemName")
#define OLE_PRESENTATION_STREAM OLESTR("\2OlePres000")
#define OLE_MAX_PRES_STREAMS 1000
#define OLE_CONTENTS_STREAM OLESTR("CONTENTS")
#define OLE_INVALID_STREAMNUM (-1)

/************************************************************************/
/****           Storage APIs internally used                         ****/
/************************************************************************/

STDAPI  ReadClipformatStm(LPSTREAM lpstream, DWORD FAR* lpdwCf);
STDAPI  WriteClipformatStm(LPSTREAM lpstream, CLIPFORMAT cf);

STDAPI  WriteMonikerStm (LPSTREAM pstm, LPMONIKER pmk);
STDAPI  ReadMonikerStm (LPSTREAM pstm, LPMONIKER FAR* pmk);

STDAPI_(LPSTREAM) CreateMemStm(DWORD cb, LPHANDLE phMem);
STDAPI_(LPSTREAM) CloneMemStm(HANDLE hMem);
STDAPI_(void)     ReleaseMemStm (LPHANDLE hMem, BOOL fInternalOnly = FALSE);

STDAPI GetClassFileEx( LPCWSTR lpszFileName,
                       CLSID FAR *pcid,
                       REFCLSID clsidOle1);

/*************************************************************************/
/***            Initialization code for individual modules             ***/
/*************************************************************************/

INTERNAL_(void) DDEWEP (
    BOOL fSystemExit
);

INTERNAL_(BOOL) DDELibMain (
        HANDLE  hInst,
        WORD    wDataSeg,
        WORD    cbHeapSize,
        LPWSTR  lpszCmdLine
);

BOOL    InitializeRunningObjectTable(void);

HRESULT GetObjectFromRotByPath(
            WCHAR *pwszPath,
            IUnknown **ppvUnk);

void    DestroyRunningObjectTable(void);


/**************************************************************************
                                        'lindex' related macros
***************************************************************************/

#define DEF_LINDEX (-1)

//+-------------------------------------------------------------------------
//
//  Function:   IsValidLINDEX
//
//  Synopsis:   Tests for valid combination of aspect and lindex
//
//  Arguments:  [dwAspect] -- aspect (part of FORMATETC)
//              [lindex]   -- lindex (part of FORMATETC)
//
//  Returns:    TRUE for valid lindex, else FALSE
//
//  History:    20-Jun-94 AlexT     Created
//
//  Notes:      Here is the spec for lindex values:
//
//              dwAspect            lindex values
//              --------            -------------
//              DVASPECT_CONTENT    -1
//              DVASPECT_DOCPRINT   anything
//              DVASPECT_ICON       -1
//              DVASPECT_THUMBNAIL  -1
//
//              So, we test for lindex == -1 or aspect == DOCPRINT
//
//--------------------------------------------------------------------------

inline BOOL IsValidLINDEX(DWORD dwAspect, LONG lindex)
{
    return((DEF_LINDEX == lindex) || (DVASPECT_DOCPRINT == dwAspect));
}

//+-------------------------------------------------------------------------
//
//  Function:   HasValidLINDEX
//
//  Synopsis:   Tests for valid combination of aspect and lindex
//
//  Arguments:  [pFormatEtc] -- pFormatEtc to test
//
//  Returns:    TRUE for valid lindex, else FALSE
//
//  History:    20-Jun-94 AlexT     Created
//
//  Notes:      See IsValidLINDEX, above
//
//--------------------------------------------------------------------------

inline BOOL HasValidLINDEX(FORMATETC const *pFormatEtc)
{
    return(IsValidLINDEX(pFormatEtc->dwAspect, pFormatEtc->lindex));
}

#define INIT_FORETC(foretc) { \
        (foretc).ptd = NULL; \
        (foretc).lindex = DEF_LINDEX; \
        (foretc).dwAspect = DVASPECT_CONTENT; \
}

// Only DDE layer will test for these values. And only for advises on cached
// formats do we use these values

#define ADVFDDE_ONSAVE          0x40000000
#define ADVFDDE_ONCLOSE         0x80000000




// Used in Ole Private Stream
typedef enum tagOBJFLAGS
{
        OBJFLAGS_LINK=1L,
        OBJFLAGS_DOCUMENT=2L,   // this bit is owned by container and is
                                // propogated through saves
        OBJFLAGS_CONVERT=4L,
        OBJFLAGS_CACHEEMPTY=8L  // this bit indicates cache empty status
} OBJFLAGS;


/*****************************************
 Prototypes for dde\client\ddemnker.cpp
******************************************/

INTERNAL DdeBindToObject
        (LPCOLESTR  szFile,
        REFCLSID clsid,
        BOOL       fPackageLink,
        REFIID   iid,
        LPLPVOID ppv);

INTERNAL DdeIsRunning
        (CLSID clsid,
        LPCOLESTR szFile,
        LPBC pbc,
        LPMONIKER pmkToLeft,
        LPMONIKER pmkNewlyRunning);


/**************************************
 Prototypes for moniker\mkparse.cpp
***************************************/

INTERNAL Ole10_ParseMoniker
        (LPMONIKER pmk,
        LPOLESTR FAR* pszFile,
        LPOLESTR FAR* pszItem);

STDAPI CreateOle1FileMoniker(LPWSTR, REFCLSID, LPMONIKER FAR*);

/****************************************************************************/
/*                              Utility APIs, might get exposed later                                           */
/****************************************************************************/

STDAPI  OleGetData(LPDATAOBJECT lpDataObj, LPFORMATETC pformatetcIn,
                                                LPSTGMEDIUM pmedium, BOOL fGetOwnership);
STDAPI  OleSetData(LPDATAOBJECT lpDataObj, LPFORMATETC pformatetc,
                                                STGMEDIUM FAR * pmedium, BOOL fRelease);
STDAPI  OleDuplicateMedium(LPSTGMEDIUM lpMediumSrc, LPSTGMEDIUM lpMediumDest);

STDAPI_(BOOL)    OleIsDcMeta (HDC hdc);

STDAPI SzFixNet( LPBINDCTX pbc, LPOLESTR szUNCName, LPOLESTR FAR * lplpszReturn,
    UINT FAR * pEndServer, BOOL fForceConnection = TRUE);

FARINTERNAL ReadFmtUserTypeProgIdStg
        (IStorage FAR * pstg,
        CLIPFORMAT FAR* pcf,
        LPOLESTR FAR* pszUserType,
        LPOLESTR         szProgID);

//+-------------------------------------------------------------------------
//
//  Function:   IsWOWProcess(), BOOL inline
//
//  Synopsis:   Tests whether or not we are running in a WOW process
//
//  Returns:    TRUE if in WOW process, FALSE otherwise
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              15-Nov-95 murthys   created
//
//  Notes:
//
//--------------------------------------------------------------------------

inline BOOL IsWOWProcess()
{
        return (BOOL) ( NULL == g_pOleThunkWOW ? FALSE : TRUE );
}

//+-------------------------------------------------------------------------
//
//  Function:   IsWOWThread(), BOOL inline
//
//  Synopsis:   Tests whether or not we are running in a 16-bit thread in a
//              WOW process
//
//  Returns:    TRUE if in 16-bit thread in a WOW process, FALSE otherwise
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              15-Nov-95 murthys   created
//
//  Notes:
//
//--------------------------------------------------------------------------

BOOLEAN TLSIsWOWThread();

inline BOOL IsWOWThread()
{
        return (BOOL) ( IsWOWProcess() ? TLSIsWOWThread(): FALSE );
}

//+-------------------------------------------------------------------------
//
//  Function:   IsWOWThreadCallable(), BOOL inline
//
//  Synopsis:   Tests whether or not we can call into OLETHK32.
//
//  Returns:    TRUE if WOW thread is callable, FALSE if not
//
//  Algorithm:  Tests the g_pOleThunkWOW pointer to see if it is non-zero
//              and not set to -1. -1 means we are in wow, but OLETHK32
//              has already been unloaded.  Also, checks to see if we're in
//              amidst a DLL_THREAD_DETACH.  We will not allow calls to 16-bit
//              side in this case as it may have already been cleaned up.
//
//  History:    dd-mmm-yy Author    Comment
//              19-mar-95 KevinRo   Created
//              15-Nov-95 MurthyS   Renamed from IsWowCallable
//              29-Jan-95 MurthyS   Added check for DLL_THREAD_DETACH
//
//  Notes:
//              Assumes that IsWOWThread() was called and returned TRUE!
//
//--------------------------------------------------------------------------

BOOLEAN TLSIsThreadDetaching();

inline BOOL IsWOWThreadCallable()
{
    return (BOOL) (( NULL == g_pOleThunkWOW ? FALSE :
                  ( INVALID_HANDLE_VALUE == g_pOleThunkWOW ? FALSE:TRUE)) &&
                  !(TLSIsThreadDetaching()));
}

/****************************************************************************/
/*                   Stabilization classes                                  */
/*        These are used to stabilize objects during re-entrant calls       */
/****************************************************************************/

#ifndef CO_E_RELEASED
#define CO_E_RELEASED  -2147467246L
#endif

typedef void * IFBuffer;

//+-------------------------------------------------------------------------
//
//  Function:   GetMarshalledInterfaceBuffer
//
//  Synopsis:   marshals the given interface into an allocated buffer.  The
//              buffer is returned
//
//  Effects:
//
//  Arguments:  [refiid]        -- the iid of the interface to marshal
//              [punk]          -- the IUnknown to marshal
//              [pIFBuf]        -- where to return the buffer
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  calls CoMarshalInterface(MSHFLAGS_TABLESTRONG)
//
//  History:    dd-mmm-yy Author    Comment
//              03-Dec-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT GetMarshalledInterfaceBuffer( REFIID riid, IUnknown *punk, IFBuffer
            *pIFBuf);

//+-------------------------------------------------------------------------
//
//  Function:   ReleaseMarshalledInterfaceBuffer
//
//  Synopsis:   releases the buffer allocated by GetMarshalledInterfaceBuffer
//
//  Effects:
//
//  Arguments:  [IFBuf]         -- the interface buffer to release
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  calls CoReleaseMarshalData to undo the TABLE_STRONG
//              marshalling
//
//  History:    dd-mmm-yy Author    Comment
//              03-Dec-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT ReleaseMarshalledInterfaceBuffer( IFBuffer IFBuf );


#define E_UNSPEC        E_FAIL

#include <widewrap.h>

#include <stkswtch.h>
#include <shellapi.h>

#ifdef WIN32 // REVIEW, just using this for tracking
# define OLE_E_NOOLE1 MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, 0x00FE)
#endif // WIN32


/***********************************************************************/
/*        Wrap mbstowcs and wcstombs which are unsafe to use           */
/*        since they rely on crt.dll                                   */
/*                                                                     */
/*   Note: cCh in both cases is the output buffer size, not a          */
/*         string length.                                              */
/*                                                                     */
/***********************************************************************/

#define mbstowcs(x, y, z) DONT_USE_mbstowcs___USE_MultiByteToWideChar_INSTEAD
#define wcstombs(x, y, z) DONT_USE_wcstombs___USE_WideCharToMultiByte_INSTEAD



//------------------------------------------------------------------
//
//  Dynamically Loaded System APIs
//
//  OLEs implementations of these system APIs dynamically load the
//  system DLLs.  Since these are rarely used APIs we dynamically
//  load them to reduce the load time of OLE32.DLL
//
//  The implementations can be found in com\util\dynload.cxx
//
//------------------------------------------------------------------

// Our own load library helper.
BOOL LoadSystemProc(LPSTR szDll, LPCSTR szProc,
                    HINSTANCE *phInst, FARPROC *ppfnProc);

// From MPR.DLL
#undef  WNetGetConnection
#define WNetGetConnection(x,y,z)      USE_OleWNetGetConnection_INSTEAD
DWORD   OleWNetGetConnection(LPCWSTR lpLocalName, LPWSTR lpRemoteName, LPDWORD lpnLength);

#ifndef _CHICAGO_
#undef  WNetGetUniversalName
#define WNetGetUniversalName(w,x,y,z) USE_OleWNetGetUniversalName_INSTEAD
DWORD   OleWNetGetUniversalName(LPCWSTR szLocalPath, DWORD dwInfoLevel, LPVOID lpBuffer, LPDWORD lpBufferSize);
#endif

// From SHELL32.DLL
#undef  ExtractIcon
#define ExtractIcon(x,y,z)            USE_OleExtractIcon_INSTEAD
HICON   OleExtractIcon(HINSTANCE hInst, LPCWSTR lpszFileName, UINT nIconIndex);

#undef  ExtractAssociatedIcon
#define ExtractAssociatedIcon(x,y,z)  USE_OleExtractAssociatedIcon_INSTEAD
HICON   OleExtractAssociatedIcon(HINSTANCE hInst, LPCWSTR lpszFileName, LPWORD
            pIndex);

// From GDI32P.DLL
HBRUSH     OleGdiConvertBrush(HBRUSH hbrush);
HBRUSH     OleGdiCreateLocalBrush(HBRUSH hbrushRemote);


#undef  SHGetFileInfo
#define SHGetFileInfo(v,w,x,y,z)  USE_OleSHGetFileInfo_INSTEAD
DWORD  OleSHGetFileInfo(LPCWSTR pszPath, DWORD dwFileAttributes,
            SHFILEINFO FAR *psfi, UINT cbFileInfo, UINT uFlags);

// HOOK OLE macros for wrapping interface pointers
#include    <hkole32.h>

// ----------------------------------------------------------------------------
// API/Method trace output
// ----------------------------------------------------------------------------

#include <trace.hxx>


// ----------------------------------------------------------------------------
// Catalog related declarations: these are defined in ..\..\common\ccompapi.cxx
// ----------------------------------------------------------------------------

#include <catalog.h>

HRESULT InitializeCatalogIfNecessary();
HRESULT UninitializeCatalog();
extern IComCatalog *gpCatalog;
extern IComCatalogSCM *gpCatalogSCM;


#endif  // _OLE2COM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ih\ole2sp.h ===
/* ole2sp.h - semi-private info; only for test apps within the development group
*/

#if !defined( _OLE2SP_H_ )
#define _OLE2SP_H_

#include <shellapi.h>

// For MAC, M_PROLOG and M_EPILOG are macros which assist us in setting up the A5
// world for a DLL when a method in the DLL is called from outside the DLL.

#ifdef _MAC

#define _MAX_PATH 260

#ifdef __cplusplus

class  CSetA5
{
public:
    CSetA5 (ULONG savedA5){ A5save = SetA5(savedA5);}
    ~CSetA5 (){ SetA5(A5save);}

private:
    ULONG A5save;
};

pascal long     GetA5(void) = 0x2E8D;

#define M_PROLOG(where) CSetA5 Dummy((where)->savedA5)
#define SET_A5          ULONG savedA5
#define GET_A5()        savedA5 = GetA5()

// These macros assist Mac in manually saving/setting/restoring A5 in routines that contain
// goto's.

#define A5_PROLOG(where) ULONG A5save = SetA5(where->savedA5)
#define RESTORE_A5()     SetA5(A5save)

// Lets MAC name our segments without ifdef's.

#define NAME_SEG(x)

#endif // ccplus

#else

#define M_PROLOG(where)
#define SET_A5
#define GET_A5()
#define A5_PROLOG(where)
#define RESTORE_A5()
#define NAME_SEG(x)

//
//  By defining SEG(x) to code_seg(), we make #pragma SEG(x) a nop and
//  eliminate lots of unknown pragma warnings...    02/18/94
//

#define SEG(x)  code_seg()

#define IGetProcAddress(a,b) GetProcAddress((a),(b))

#endif


#define ReportResult(a,b,c,d) ResultFromScode(b)


#ifdef WIN32
#define MAP16(v16)
#define MAP32(v32) v32
#define MAP1632(v16,v32)   v32
#else
#define MAP16(v16) v16
#define MAP32(v32)
#define MAP1632(v16,v32)   v16
#endif


/****** Misc defintions ***************************************************/

#ifdef __TURBOC__
#define implement struct huge
#else
#define implement struct
#endif
#define ctor_dtor private
#define implementations private
#define shared_state private

// helpers for internal methods and functions which follow the same convention
// as the external ones

#ifdef __cplusplus
#define INTERNALAPI_(type) extern "C" type
#else
#define INTERNALAPI_(type) type
#endif

#define INTERNAL HRESULT
#define INTERNAL_(type) type
#define FARINTERNAL HRESULT FAR
#define FARINTERNAL_(type) type FAR
#define NEARINTERNAL HRESULT NEAR
#define NEARINTERNAL_(type) type NEAR



//BEGIN REVIEW: We may not need all the following ones

#define OT_LINK     1L
#define OT_EMBEDDED 2L
#define OT_STATIC   3L


//END REVIEW .....


/****** Old Error Codes    ************************************************/

#define S_OOM               E_OUTOFMEMORY
#define S_BADARG            E_INVALIDARG
#define S_BLANK             E_BLANK
#define S_FORMAT            E_FORMAT
#define S_NOT_RUNNING       E_NOTRUNNING
#define E_UNSPEC            E_FAIL



/****** Macros for nested clases ******************************************/

/* To overcome problems with nested classes on MAC
 *
 * NC(a,b) is used to define a member function of a nested class:
 *
 * STDMETHODIMP_(type) NC(ClassName,NestedClassName)::MemberFunction(...)
 *
 * DECLARE_NC(a,b) is used within a class declaration to let a nested class
 * access it container class:
 *
 * class ClassName {
 *     ..............
 *
 *     class NestedClassName {
 *         .............
 *     };
 *     DECLARE_NC(ClassName,NestedClassName)
 *     ..............
 * };
 */

#ifdef _MAC

#define NESTED_CLASS(a,b) struct a##_##b
#define NC(a,b) a##__##b
#define NC1(a,b) a##_##b
#define DECLARE_NC(a,b) typedef a##::##b a##__##b; friend a##__##b;
#define DECLARE_NC2(a,b) typedef a##::a##_##b a##__##b; friend a##__##b;

#else

#define NC(a,b) a##::##b
#define DECLARE_NC(a,b) friend b;

#endif


/****** More Misc defintions **********************************************/


// LPLPVOID should not be made a typedef.  typedef won't compile; worse
// within complicated macros the compiler generates unclear error messages
//
#define LPLPVOID void FAR * FAR *

#define UNREFERENCED(a) ((void)(a))

#ifndef BASED_CODE
#ifdef WIN32
#define BASED_CODE
#else
#define BASED_CODE __based(__segname("_CODE"))
#endif
#endif


/****** Standard IUnknown Implementation **********************************/

/*
 *      The following macro declares a nested class CUnknownImpl,
 *      creates an object of that class in the outer class, and
 *      declares CUnknownImpl to be a friend of the outer class.  After
 *      writing about 20 class headers, it became evident that the
 *      implementation of CUnknownImpl was very similar in all cases,
 *      and this macro captures the similarity.  The classname
 *      parameter is the name of the outer class WITHOUT the leading
 *      "C"; i.e., for CFileMoniker, classname is FileMoniker.
 */

#define noError return NOERROR

#ifdef _MAC

#define STDUNKDECL(cclassname,classname) NESTED_CLASS(cclassname, CUnknownImpl):IUnknown { public: \
    NC1(cclassname,CUnknownImpl)( cclassname FAR * p##classname ) { m_p##classname = p##classname;} \
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPLPVOID ppvObj); \
    STDMETHOD_(ULONG,AddRef)(THIS); \
    STDMETHOD_(ULONG,Release)(THIS); \
    private: cclassname FAR* m_p##classname; }; \
    DECLARE_NC2(cclassname, CUnknownImpl) \
    NC(cclassname, CUnknownImpl) m_Unknown;

#else  // _MAC

#define STDUNKDECL( ignore, classname ) implement CUnknownImpl:IUnknown { public: \
    CUnknownImpl( C##classname FAR * p##classname ) { m_p##classname = p##classname;} \
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPLPVOID ppvObj); \
    STDMETHOD_(ULONG,AddRef)(THIS); \
    STDMETHOD_(ULONG,Release)(THIS); \
    private: C##classname FAR* m_p##classname; }; \
    DECLARE_NC(C##classname, CUnknownImpl) \
    CUnknownImpl m_Unknown;
#endif

/*
 *      The following macro implements all the methods of a nested
 *      CUnknownImpl class EXCEPT FOR QUERYINTERFACE.  This macro was
 *      written after about 20 classes were written in which the
 *      implementations of CUnknownImpl were all the same.
 */

#ifdef WIN32

#define STDUNKIMPL(classname) \
STDMETHODIMP_(ULONG) NC(C##classname,CUnknownImpl)::AddRef( void )             \
{                                                                              \
    InterlockedIncrement((LONG *)&m_p##classname->m_refs);                     \
                                                                               \
    return m_p##classname->m_refs;                                             \
}                                                                              \
                                                                               \
STDMETHODIMP_(ULONG) NC(C##classname,CUnknownImpl)::Release( void )            \
{                                                                              \
    ULONG culRefs = 0;                                                         \
                                                                               \
    culRefs = InterlockedDecrement((LONG *)&m_p##classname->m_refs);           \
                                                                               \
    if (culRefs == 0)                                                          \
    {                                                                          \
        delete m_p##classname;                                                 \
    }                                                                          \
                                                                               \
    return culRefs;                                                            \
}

#else

#define STDUNKIMPL(classname) \
STDMETHODIMP_(ULONG) NC(C##classname,CUnknownImpl)::AddRef( void ){ \
    return ++m_p##classname->m_refs; } \
STDMETHODIMP_(ULONG) NC(C##classname,CUnknownImpl)::Release( void ){ \
    if (--m_p##classname->m_refs == 0) { delete m_p##classname; return 0; } \
    return m_p##classname->m_refs;}

#endif  //  WIN32


/*
 *      The following macro implements class::CUnknownImpl::QueryInterface IN
 *      THE SPECIAL CASE IN WHICH THE OUTER CLASS PRESENTS ONLY ONE INTERFACE
 *      OTHER THAN IUNKNOWN AND IDEBUG.  This is not universally the case,
 *      but it is common enough that this macro will save time and space.
 */

#ifdef _DEBUG
#define STDDEB_QI(classname) \
    if (IsEqualGUID(iidInterface, IID_IDebug)) \
         {*ppv = (void FAR *)&(m_p##classname->m_Debug); return 0;} else
#else
#define STDDEB_QI(classname)
#endif

#ifdef WIN32

#define STDUNK_QI_IMPL(classname, interfacename) \
STDMETHODIMP NC(C##classname,CUnknownImpl)::QueryInterface                     \
    (REFIID iidInterface, void FAR * FAR * ppv)                                \
{                                                                              \
    HRESULT hres = S_OK;                                                       \
                                                                               \
    if (IsEqualIID(iidInterface,IID_IUnknown))                                 \
    {                                                                          \
        *ppv = (void FAR *)&m_p##classname->m_Unknown;                         \
        AddRef();                                                              \
    }                                                                          \
    else if (IsEqualIID(iidInterface,IID_I##interfacename))                    \
    {                                                                          \
        *ppv = (void FAR *) &(m_p##classname->m_##classname);                  \
        m_p##classname->m_pUnkOuter->AddRef();                                 \
    }                                                                          \
    else STDDEB_QI(classname)                                                  \
    {                                                                          \
        *ppv = NULL;                                                           \
        hres = ResultFromScode(E_NOINTERFACE);                                 \
    }                                                                          \
                                                                               \
    return hres;                                                               \
}

#else

STDMETHODIMP NC(C##classname,CUnknownImpl)::QueryInterface                     \
    (REFIID iidInterface, void FAR * FAR * ppv) { \
    if (IsEqualGUID(iidInterface,IID_IUnknown)) {\
        *ppv = (void FAR *)&m_p##classname->m_Unknown;\
        AddRef(); noError;\
    } else if (IsEqualGUID(iidInterface, IID_I##interfacename)) { \
        *ppv = (void FAR *) &(m_p##classname->m_##classname);                  \
        m_p##classname->m_pUnkOuter->AddRef(); return NOERROR; \
    } else \
        STDDEB_QI(classname) \
        {*ppv = NULL; return ResultFromScode(E_NOINTERFACE);} \
}
#endif


/*
 *      The following macro implements the IUnknown methods inherited
 *      by the implementation of another interface.  The implementation
 *      is simply to delegate all calls to m_pUnkOuter.  Parameters:
 *      ocname is the outer class name, icname is the implementation
 *      class name.
 *
 */

#define STDUNKIMPL_FORDERIVED(ocname, icname) \
 STDMETHODIMP NC(C##ocname,C##icname)::QueryInterface \
(REFIID iidInterface, LPLPVOID ppvObj) { \
    return m_p##ocname->m_pUnkOuter->QueryInterface(iidInterface, ppvObj);} \
 STDMETHODIMP_(ULONG) NC(C##ocname,C##icname)::AddRef(void) { \
    return m_p##ocname->m_pUnkOuter->AddRef(); } \
 STDMETHODIMP_(ULONG) NC(C##ocname,C##icname)::Release(void) { \
    return m_p##ocname->m_pUnkOuter->Release(); }


/****** Debug defintions **************************************************/

#include <debug.h>


/****** Other API defintions **********************************************/

// low level reg.dat access (in compobj.dll)
STDAPI CoGetInProcDll(REFCLSID rclsid, BOOL fServer, LPOLESTR lpszDll, int cbMax);
STDAPI CoGetLocalExe(REFCLSID rclsid, LPOLESTR lpszExe, int cbMax);


// simpler alternatives to public apis
// WINOLEAPI_(int) StringFromGUID2(REFGUID rguid, LPOLESTR lpsz, int cbMax);
#define StringFromCLSID2(rclsid, lpsz, cbMax) \
    StringFromGUID2(rclsid, lpsz, cbMax)

#define StringFromIID2(riid, lpsz, cbMax) \
    StringFromGUID2(riid, lpsz, cbMax)

STDAPI_(int) Ole1ClassFromCLSID2(REFCLSID rclsid, LPOLESTR lpsz, int cbMax);
STDAPI_(BOOL) GUIDFromString(LPCOLESTR lpsz, LPGUID pguid);
STDAPI CLSIDFromOle1Class(LPCOLESTR lpsz, LPCLSID lpclsid, BOOL fForceAssign=FALSE);
STDAPI_(BOOL)  CoIsHashedOle1Class(REFCLSID rclsid);
STDAPI       CoOpenClassKey(REFCLSID clsid, BOOL bOpenForWrite, HKEY FAR* lphkeyClsid);


// were public; now not
STDAPI  SetDocumentBitStg(LPSTORAGE pStg, BOOL fDocument);
STDAPI  GetDocumentBitStg(LPSTORAGE pStg);


INTERNAL CreateStandardMalloc(DWORD memctx, IMalloc FAR* FAR* ppMalloc);


/*
 * Some docfiles stuff
 */

#define STGM_DFRALL (STGM_READWRITE | STGM_TRANSACTED | STGM_SHARE_DENY_WRITE)
#define STGM_DFALL (STGM_READWRITE | STGM_TRANSACTED | STGM_SHARE_EXCLUSIVE)
#define STGM_SALL (STGM_READWRITE | STGM_SHARE_EXCLUSIVE)


/*
 * Some moniker stuff
 */
//REVIEW32:  Should this get exported publicly??

STDAPI Concatenate(LPMONIKER pmkFirst, LPMONIKER pmkRest,
                LPMONIKER FAR * ppmkComposite );

/*
 * Drag and Drop Interface Property Name
 */
#define OLE_DROP_TARGET_PROP    L"OleDropTargetInterface"
#define OLE_DROP_TARGET_PROPA   "OleDropTargetInterface"

#define OLE_DROP_TARGET_MARSHALHWND     L"OleDropTargetMarshalHwnd"
#define OLE_DROP_TARGET_MARSHALHWNDA    "OleDropTargetMarshalHwnd"

 /*
 * Private Clipboard Window IDataObject property name
 */
#define CLIPBOARD_DATA_OBJECT_PROP      L"ClipboardDataObjectInterface"

#endif // _OLE2SP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ih\olerem.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       olerem.h
//
//  Synopsis:   this file contain the base definitions for types and APIs
//              exposed by the ORPC layer to upper layers.
//
//+-------------------------------------------------------------------------
#if !defined( _OLEREM_H_ )
#define _OLEREM_H_

// default transport for same-machine communication
#ifdef _CHICAGO_
  #define LOCAL_PROTSEQ L"mswmsg"
#else
  #define LOCAL_PROTSEQ L"ncalrpc"
#endif


// -----------------------------------------------------------------------
// Internal Interface used by handlers.
//
// NOTE: connect happens during unmarshal
// NOTE: implemented as part of the std identity object
//
//
//  History
//              12-Dec-96   Gopalk      Added new function to obtain
//                                      connection status with the
//                                      server object on the client side
// -----------------------------------------------------------------------
interface IProxyManager : public IUnknown
{
    STDMETHOD(CreateServer)(REFCLSID rclsid, DWORD clsctx, void *pv) = 0;
    STDMETHOD_(BOOL, IsConnected)(void) = 0;
    STDMETHOD(LockConnection)(BOOL fLock, BOOL fLastUnlockReleases) = 0;
    STDMETHOD_(void, Disconnect)(void) = 0;
    STDMETHOD(GetConnectionStatus)(void) = 0;

#ifdef SERVER_HANDLER
    STDMETHOD(CreateServerWithEmbHandler)(REFCLSID rclsid, DWORD clsctx,
                                          REFIID riidEmbedSrvHandler,
                                          void **ppEmbedSrvHandler, void *pv) = 0;
#endif // SERVER_HANDLER
};


STDAPI GetInProcFreeMarshaler(IMarshal **ppIM);


#include <obase.h>  // ORPC base definitions

typedef const IPID &REFIPID;    // reference to Interface Pointer IDentifier
typedef const OID  &REFOID;     // reference to Object IDentifier
typedef const OXID &REFOXID;    // reference to Object Exporter IDentifier
typedef const MID  &REFMID;     // reference to Machine IDentifier

typedef GUID MOXID;             // OXID + MID
typedef const MOXID &REFMOXID;  // reference to OXID + MID
typedef GUID MOID;              // OID + MID
typedef const MOID &REFMOID;    // reference to OID + MID


// flag for default handler to pass to CreateIdentityHandler
#define STDID_CLIENT_DEFHANDLER 0x401

STDAPI CreateIdentityHandler(IUnknown *pUnkOuter, DWORD flags,
                             CObjectContext *pServerCtx, DWORD dwAptId,
                             REFIID riid, void **ppv);


// DDE Init/Cleanup Functions
INTERNAL CheckInitDde(BOOL fServingObject);
void CheckUninitDde(BOOL fLastUninit);


#include <iface.h>

#endif // _OLEREM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ih\map_up.h ===
////////////////////////////////////////////////////////////////////////////



class FAR CMapUintPtr : public CPrivAlloc
{
public:
	// Construction
	CMapUintPtr(UINT nBlockSize=10) 
		: m_mkv(sizeof(void FAR*), sizeof(UINT), nBlockSize) { }

	// Attributes
	// number of elements
	int     GetCount() const
				{ return m_mkv.GetCount(); }
	BOOL    IsEmpty() const
				{ return GetCount() == 0; }

	// Lookup
	BOOL    Lookup(UINT key, void FAR* FAR& value) const
				{ return m_mkv.Lookup((LPVOID)&key, sizeof(UINT), (LPVOID)&value); }

	BOOL    LookupHKey(HMAPKEY hKey, void FAR* FAR& value) const
				{ return m_mkv.LookupHKey(hKey, (LPVOID)&value); }

	BOOL    LookupAdd(UINT key, void FAR* FAR& value) const
				{ return m_mkv.LookupAdd((LPVOID)&key, sizeof(UINT), (LPVOID)&value); }

	// Add/Delete
	// add a new (key, value) pair
	BOOL    SetAt(UINT key, void FAR* value)
				{ return m_mkv.SetAt((LPVOID)&key, sizeof(UINT), (LPVOID)&value); }
	BOOL    SetAtHKey(HMAPKEY hKey, void FAR* value)
				{ return m_mkv.SetAtHKey(hKey, (LPVOID)&value); }

	// removing existing (key, ?) pair
	BOOL    RemoveKey(UINT key)
				{ return m_mkv.RemoveKey((LPVOID)&key, sizeof(UINT)); }

	BOOL    RemoveHKey(HMAPKEY hKey)
				{ return m_mkv.RemoveHKey(hKey); }

	void    RemoveAll()
				{ m_mkv.RemoveAll(); }


	// iterating all (key, value) pairs
	POSITION GetStartPosition() const
				{ return m_mkv.GetStartPosition(); }

	void    GetNextAssoc(POSITION FAR& rNextPosition, UINT FAR& rKey, void FAR* FAR& rValue) const
				{ m_mkv.GetNextAssoc(&rNextPosition, (LPVOID)&rKey, NULL, (LPVOID)&rValue); }

	HMAPKEY GetHKey(UINT key) const
				{ return m_mkv.GetHKey((LPVOID)&key, sizeof(UINT)); }

#ifdef _DEBUG
	void    AssertValid() const
				{ m_mkv.AssertValid(); }
#endif

private:
	CMapKeyToValue m_mkv;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ih\plex.h ===
// This is a part of the Microsoft Foundation Classes C++ library. 
// Copyright (C) 1992 Microsoft Corporation 
// All rights reserved. 
//  
// This source code is only intended as a supplement to the 
// Microsoft Foundation Classes Reference and Microsoft 
// QuickHelp documentation provided with the library. 
// See these sources for detailed information regarding the 
// Microsoft Foundation Classes product. 

#ifndef __PLEX_H__
#define __PLEX_H__

struct FAR CPlex    // warning variable length structure
{
	CPlex FAR* pNext;
	UINT nMax;
	UINT nCur;
	/* BYTE data[maxNum*elementSize]; */

	INTERNAL_(void FAR*) data() { return this+1; }

	static INTERNAL_(CPlex FAR*) Create(CPlex FAR* FAR& head, UINT nMax, UINT cbElement);

	INTERNAL_(void) FreeDataChain();       // free this one and links
};

#endif //__PLEX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ih\resource.h ===
#define CURNONE  1
#define CURMOVE  2
#define CURCOPY  3
#define CURLINK  4
#define CURSCROLLMOVE 5
#define CURSCROLLCOPY 6
#define CURSCROLLLINK 7

// used by "..\src\def\geticon.c"
#define DEFICON 8

// used by the StdProgressIndicator dialog
#define IDD_DIALOG1                     101
#define IDC_TEXT                        102
#define IDC_PROGRESS1                   1000
// text for the cancel message
#define IDS_CAPTION                     201
#define IDS_TEXT                        202
// clipboard format strings
#define IDS_OBJECTLINK                  203
#define IDS_OWNERLINK                   204
#define IDS_NATIVE                      205
#define IDS_BINARY                      206
#define IDS_FILENAME                    207
#define IDS_FILENAMEW                   208
#define IDS_NETWORKNAME                 209
#define IDS_DATAOBJECT                  210
#define IDS_EMBEDDEDOBJECT              211
#define IDS_EMBEDSOURCE                 212
#define IDS_CUSTOMLINKSOURCE            213
#define IDS_LINKSOURCE                  214
#define IDS_OBJECTDESCRIPTOR            215
#define IDS_LINKSOURCEDESCRIPTOR        216
#define IDS_OLEDRAW                     217
#define IDS_PBRUSH                      218
#define IDS_MSDRAW                      219
#define IDS_OLEPRIVATEDATA              220
#define IDS_SCREENPICTURE               221
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ih\stdidx.h ===
#ifndef _STDIDX_H_
#define _STDIDX_H_

#ifdef __cplusplus
extern "C" {
#endif

BOOL IsInterfaceImplementedByProxy(REFIID riid);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ih\privoa.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       privoa.h
//
//  Contents:   Definitions for OleAut32.dll wrappers
//
//  Classes:
//
//  History:    20-Jun-96 MikeHill  Created.
//              06-May-98 MikeHill  Added SafeArray wrappers.
//
//  Notes:
//      This file has macros, function prototypes, and global
//      externs that enable the OleAut32 wrapper functions.
//      These functions load OleAut32.dll if necessary, and forward
//      the call.
//
//----------------------------------------------------------------------------

#ifndef _PRIV_OA_H_
#define _PRIV_OA_H_

// OleAut32 function prototypes

typedef BSTR (STDAPICALLTYPE SYS_ALLOC_STRING)(LPCOLESTR pwsz);
typedef VOID (STDAPICALLTYPE SYS_FREE_STRING)(BSTR bstr);
typedef BOOL (STDAPICALLTYPE SYS_REALLOC_STRING_LEN)(BSTR* pbstr, OLECHAR* pch, UINT cch);
typedef UINT (STDAPICALLTYPE SYS_STRING_BYTE_LEN)(BSTR bstr);
typedef UINT (STDAPICALLTYPE FNTYPE_SysStringLen)(BSTR bstr);

typedef HRESULT (STDAPICALLTYPE SAFE_ARRAY_ACCESS_DATA)(SAFEARRAY * psa, void HUGEP** ppvData);
typedef HRESULT (STDAPICALLTYPE SAFE_ARRAY_GET_L_BOUND)(SAFEARRAY * psa, UINT nDim, LONG * plLbound);
typedef UINT    (STDAPICALLTYPE SAFE_ARRAY_GET_DIM)(SAFEARRAY * psa);
typedef UINT    (STDAPICALLTYPE SAFE_ARRAY_GET_ELEM_SIZE)(SAFEARRAY * psa);
typedef HRESULT (STDAPICALLTYPE SAFE_ARRAY_GET_U_BOUND)(SAFEARRAY * psa, UINT nDim, LONG * plUbound);
typedef HRESULT (STDAPICALLTYPE SAFE_ARRAY_UNACCESS_DATA)(SAFEARRAY * psa);
typedef SAFEARRAY* (STDAPICALLTYPE SAFE_ARRAY_CREATE_EX)(VARTYPE vt, UINT cDims, SAFEARRAYBOUND * rgsabound, PVOID pvExtra);
typedef HRESULT (STDAPICALLTYPE SAFE_ARRAY_GET_VARTYPE)(SAFEARRAY * psa, VARTYPE * pvt);

typedef SAFEARRAY* (STDAPICALLTYPE FNTYPE_SafeArrayCreate)(VARTYPE vt, UINT cDims, SAFEARRAYBOUND * rgsabound);
typedef HRESULT    (STDAPICALLTYPE FNTYPE_SafeArrayPutElement)(SAFEARRAY* psa, long* pIdx, void* pv );
typedef HRESULT    (STDAPICALLTYPE FNTYPE_SafeArrayDestroy)(SAFEARRAY* psa );

typedef void    (STDAPICALLTYPE FNTYPE_VariantInit)(VARIANTARG * pvarg);
typedef HRESULT (STDAPICALLTYPE FNTYPE_VariantClear)(VARIANTARG * pvarg);
typedef HRESULT (STDAPICALLTYPE FNTYPE_VariantCopy)(VARIANTARG * pvargDest, VARIANTARG * pvargSrc);
typedef HRESULT (STDAPICALLTYPE FNTYPE_VariantChangeTypeEx)(VARIANTARG * pvargDest, VARIANTARG * pvarSrc, LCID lcid, USHORT wFlags, VARTYPE vt);


typedef unsigned long             BSTR_USER_SIZE      (     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
typedef unsigned char __RPC_FAR * BSTR_USER_MARSHAL   (  unsigned long __RPC_FAR *, unsigned char __RPC_FAR*, BSTR __RPC_FAR * ); 
typedef unsigned char __RPC_FAR * BSTR_USER_UNMARSHAL (unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
typedef void                      BSTR_USER_FREE      (     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

typedef unsigned long             LPSAFEARRAY_USER_SIZE       (     unsigned long __RPC_FAR *, unsigned long            , LPSAFEARRAY __RPC_FAR * ); 
typedef unsigned char __RPC_FAR * LPSAFEARRAY_USER_MARSHAL    (  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, LPSAFEARRAY __RPC_FAR * ); 
typedef unsigned char __RPC_FAR * LPSAFEARRAY_USER_UNMARSHAL  (unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, LPSAFEARRAY __RPC_FAR * ); 
typedef void                      LPSAFEARRAY_USER_FREE       (     unsigned long __RPC_FAR *, LPSAFEARRAY __RPC_FAR * ); 


// The Wrapper routines, and function pointers for them.

#define DECLARE_OLEAUT_FUNCTION( fname )    \
    FNTYPE_##fname  Load##fname;            \
    EXTERN_C FNTYPE_##fname *pfn##fname;


SYS_ALLOC_STRING  LoadSysAllocString;
EXTERN_C SYS_ALLOC_STRING *pfnSysAllocString;

SYS_FREE_STRING  LoadSysFreeString;
EXTERN_C SYS_FREE_STRING *pfnSysFreeString;

SYS_REALLOC_STRING_LEN  LoadSysReAllocStringLen;
EXTERN_C SYS_REALLOC_STRING_LEN *pfnSysReAllocStringLen;

SYS_STRING_BYTE_LEN LoadSysStringByteLen;
EXTERN_C SYS_STRING_BYTE_LEN *pfnSysStringByteLen;

DECLARE_OLEAUT_FUNCTION( SysStringLen );

SAFE_ARRAY_ACCESS_DATA LoadSafeArrayAccessData;
EXTERN_C SAFE_ARRAY_ACCESS_DATA *pfnSafeArrayAccessData;

SAFE_ARRAY_GET_L_BOUND LoadSafeArrayGetLBound;
EXTERN_C SAFE_ARRAY_GET_L_BOUND *pfnSafeArrayGetLBound;

SAFE_ARRAY_GET_DIM LoadSafeArrayGetDim;
EXTERN_C SAFE_ARRAY_GET_DIM *pfnSafeArrayGetDim;

SAFE_ARRAY_GET_ELEM_SIZE LoadSafeArrayGetElemsize;
EXTERN_C SAFE_ARRAY_GET_ELEM_SIZE *pfnSafeArrayGetElemsize;

SAFE_ARRAY_GET_U_BOUND LoadSafeArrayGetUBound;
EXTERN_C SAFE_ARRAY_GET_U_BOUND *pfnSafeArrayGetUBound;

SAFE_ARRAY_GET_VARTYPE LoadSafeArrayGetVartype;
EXTERN_C SAFE_ARRAY_GET_VARTYPE *pfnSafeArrayGetVartype;

SAFE_ARRAY_UNACCESS_DATA LoadSafeArrayUnaccessData;
EXTERN_C SAFE_ARRAY_UNACCESS_DATA *pfnSafeArrayUnaccessData;

SAFE_ARRAY_CREATE_EX LoadSafeArrayCreateEx;
EXTERN_C SAFE_ARRAY_CREATE_EX *pfnSafeArrayCreateEx;

DECLARE_OLEAUT_FUNCTION( SafeArrayCreate );
DECLARE_OLEAUT_FUNCTION( SafeArrayPutElement );
DECLARE_OLEAUT_FUNCTION( SafeArrayDestroy );

DECLARE_OLEAUT_FUNCTION( VariantClear );
DECLARE_OLEAUT_FUNCTION( VariantInit );
DECLARE_OLEAUT_FUNCTION( VariantCopy );
DECLARE_OLEAUT_FUNCTION( VariantChangeTypeEx );


EXTERN_C BSTR_USER_SIZE LoadBSTR_UserSize;
EXTERN_C BSTR_USER_SIZE *pfnBSTR_UserSize;

EXTERN_C BSTR_USER_MARSHAL LoadBSTR_UserMarshal;
EXTERN_C BSTR_USER_MARSHAL *pfnBSTR_UserMarshal;

EXTERN_C BSTR_USER_UNMARSHAL LoadBSTR_UserUnmarshal;
EXTERN_C BSTR_USER_UNMARSHAL *pfnBSTR_UserUnmarshal;

EXTERN_C BSTR_USER_FREE LoadBSTR_UserFree;
EXTERN_C BSTR_USER_FREE *pfnBSTR_UserFree;

EXTERN_C LPSAFEARRAY_USER_SIZE LoadLPSAFEARRAY_UserSize;
EXTERN_C LPSAFEARRAY_USER_SIZE *pfnLPSAFEARRAY_UserSize;

EXTERN_C LPSAFEARRAY_USER_MARSHAL LoadLPSAFEARRAY_UserMarshal;
EXTERN_C LPSAFEARRAY_USER_MARSHAL *pfnLPSAFEARRAY_UserMarshal;

EXTERN_C LPSAFEARRAY_USER_UNMARSHAL LoadLPSAFEARRAY_UserUnmarshal;
EXTERN_C LPSAFEARRAY_USER_UNMARSHAL *pfnLPSAFEARRAY_UserUnmarshal;

EXTERN_C LPSAFEARRAY_USER_FREE LoadLPSAFEARRAY_UserFree;
EXTERN_C LPSAFEARRAY_USER_FREE *pfnLPSAFEARRAY_UserFree;


// Macros to ease the calling of the above function pointers

#define PrivSysAllocString(pwsz)                    (*pfnSysAllocString)(pwsz)
#define PrivSysFreeString(bstr)                     (*pfnSysFreeString)(bstr)
#define PrivSysReAllocStringLen(pbstr,olestr,ui)    (*pfnSysReAllocStringLen)(pbstr, olestr, ui)
#define PrivSysStringByteLen(pbstr)                 (*pfnSysStringByteLen)(pbstr)
#define PrivSysStringLen(pbstr)                     (*pfnSysStringByteLen)(pbstr)

#define PrivSafeArrayAccessData(psa,ppvData)        (*pfnSafeArrayAccessData)(psa, ppvData )
#define PrivSafeArrayGetLBound(psa,nDim, plLbound)  (*pfnSafeArrayGetLBound)( psa, nDim, plLbound )
#define PrivSafeArrayGetDim(psa)                    (*pfnSafeArrayGetDim)( psa )
#define PrivSafeArrayGetElemsize(psa)               (*pfnSafeArrayGetElemsize)( psa )
#define PrivSafeArrayGetUBound(psa,nDim, plUbound)  (*pfnSafeArrayGetUBound)( psa, nDim, plUbound )
#define PrivSafeArrayGetVartype(psa, pvt)           (*pfnSafeArrayGetVartype)( psa, pvt )
#define PrivSafeArrayUnaccessData(psa)              (*pfnSafeArrayUnaccessData)( psa )
#define PrivSafeArrayCreateEx(vt,cDims,rgsabound,pvExtra) \
                                                    (*pfnSafeArrayCreateEx)(vt, cDims, rgsabound, pvExtra)
#define PrivSafeArrayCreate(vt,cDims,rgsabound)     (*pfnSafeArrayCreate)(vt, cDims, rgsabound)
#define PrivSafeArrayPutElement(psa, pIdx, pv)      (*pfnSafeArrayPutElement)(psa, pIdx, pv)
#define PrivSafeArrayDestroy( psa )                 (*pfnSafeArrayDestroy)(psa)

#define PrivVariantClear(pvarg)                     (*pfnVariantClear)( pvarg )
#define PrivVariantInit(pvarg)                      (*pfnVariantInit)(pvarg)
#define PrivVariantCopy(pvargDest,pvargSrc)         (*pfnVariantCopy)( pvargDest, pvargSrc )
#define PrivVariantChangeTypeEx(pvargDest,pvarSrc,lcid,wFlags,vt)   \
                                                    (*pfnVariantChangeTypeEx)( pvargDest, pvarSrc, lcid, wFlags, vt )

                

#endif // ! _PRIV_OA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ih\thkreg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       thkreg.cxx
//
//  Contents:   Contains constants used to read the registry for modifiable
//              WOW behavior for OLE.
//
//  History:    22-Jul-94 Ricksa    Created
//		09-Jun-95 Susia	    Chicago optimization added
//
//--------------------------------------------------------------------------
#ifndef _THKREG_H_
#define _THKREG_H_


// Name of key for OLE WOW special behavior
#define OLETHK_KEY                  TEXT("OleCompatibility")  
// Factor by which to slow duration of WOW RPC calls
#define OLETHK_SLOWRPCTIME_VALUE    TEXT("SlowRpcTimeFactor")

// Default factor to slow duration of WOW RPC calls
#define OLETHK_DEFAULT_SLOWRPCTIME 4

#endif // _THKREG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ih\privguid.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       privguid.h
//
//  Contents:   This file is the master definition of all OLE2 product
//              GUIDs (public and private).  All GUIDs used by the ole2
//              product are of the form:
//
//              xxxxxxxx-xxxx-xxxY-C000-000000000046
//
//              This range is broken down as follows:
//
//         000000xx-0000-0000-C000-000000000046 compobj IIDs
//         000001xx-0000-0000-C000-000000000046 ole2 IIDs
//         000002xx-0000-0000-C000-000000000046 16bit ole2 smoke test
//         000003xx-0000-0000-C000-000000000046 ole2 CLSIDs
//         000004xx-0000-0000-C000-000000000046 ole2 sample apps (see DouglasH)
//
//              Other interesting ranges are as follows:
//
//         0003xxxx-0000-0000-C000-000000000046 ole1 CLSIDs (ole1cls.h)
//         0004xxxx-0000-0000-C000-000000000046 hashed ole1 CLSIDs
//
//
//
//  Classes:
//
//  Functions:
//
//  History:
//              24-Oct-94 BruceMa   Added this file header
//              24-Oct-94 BruceMa   Added IMallocSpy
//
//  Notes:
//
//--------------------------------------------------------------------------

////////////////////////////////////////////////////////////////////////////
// Range 0x000 - 0x0ff : compobj IIDs -
//             IID_IUnknown,            0x00000000L
//             IID_IClassFactory,       0x00000001L
//             IID_IMalloc,             0x00000002L
//             IID_IMarshal,            0x00000003L

//             IID_ILockBytes,          0x0000000aL
//             IID_IStorage,            0x0000000bL
//             IID_IStream,             0x0000000cL
//             IID_IEnumSTATSTG,        0x0000000dL

//             IID_IBindCtx,            0x0000000eL
//             IID_IMoniker,            0x0000000fL
//             IID_IRunningObjectTable, 0x00000010L
//             IID_IInternalMoniker,    0x00000011L

//             IID_IRootStorage,        0x00000012L
//             IID_IDfReserved1,        0x00000013L
//             IID_IDfReserved2,        0x00000014L
//             IID_IDfReserved3,        0x00000015L

//             IID_IMessageFilter,      0x00000016L

//             CLSID_StdMarshal,        0x00000017L

//             IID_IStdMarshalInfo,     0x00000018L

//             IID_IExternalConnection, 0x00000019L

//             IID_IWeakRef,            0x0000001aL

/* interface for subpieces of standard remoting */
DEFINE_OLEGUID(IID_IStdIdentity,        0x0000001bL, 0, 0);
DEFINE_OLEGUID(IID_IRemoteHdlr,         0x0000001cL, 0, 0);

//             IID_IMallocSpyf,         0x0000001dL, 0, 0);

//             IID_ITrackingMoniker,    0x0000001eL

//             IID_IMultiQI,            0x00000020L
//             IID_IInternalUnknown,    0x00000021L, 0, 0);
//             IID_ISurrogate,          0x00000022L, 0, 0);
//             IID_ISynchronize,        0x00000023L  obsolete
//             IID_IAsyncSetup          0x00000024L  obsolete
//             IID_ISynchronizeMutex,   0x00000025L
//             IID_IUrlMon,             0x00000026L
//             CLSID_AggStdMarshal,     0x00000027L
//             IID_IDebugMalloc,        0x00000028L
//             IID_IAsyncManager        0x0000002AL
//             IID_IWaitMultiple        0x0000002BL  obsolete
//             IID_ISynchronizeEvent    0x0000002CL  obsolete
//             IID_ITypeMarshal         0x0000002DL
//             IID_ITypeFactory         0x0000002EL
//             IID_IRecordInfo          0x0000002FL
//             IID_ISynchronize,        0x00000030L
//             IID_ISynchronizeHandle,  0x00000031L
//             IID_ISynchronizeEvent,   0x00000032L
//             IID_ISynchronizeContainer, 0x00000033L

/* NOTE: LSB values 0x30 through 0xff are unused */

////////////////////////////////////////////////////////////////////////////
// Range 0x100 - 0x1ff : upper layer IIDs -
//             IID_IEnumUnknown,        0x00000100L
//             IID_IEnumString,         0x00000101L
//             IID_IEnumMoniker,        0x00000102L
//             IID_IEnumFORMATETC,      0x00000103L
//             IID_IEnumOLEVERB,        0x00000104L
//             IID_IEnumSTATDATA,       0x00000105L

//             IID_IEnumGeneric,        0x00000106L
//             IID_IEnumHolder,         0x00000107L
//             IID_IEnumCallback,       0x00000108L

//             IID_IPersistStream,      0x00000109L
//             IID_IPersistStorage,     0x0000010aL
//             IID_IPersistFile,        0x0000010bL
//             IID_IPersist,            0x0000010cL

//             IID_IViewObject,         0x0000010dL
//             IID_IDataObject,         0x0000010eL
//             IID_IAdviseSink,         0x0000010fL
//             IID_IDataAdviseHolder,   0x00000110L
//             IID_IOleAdviseHolder,    0x00000111L

//             IID_IOleObject,          0x00000112L
//             IID_IOleInPlaceObject,   0x00000113L
//             IID_IOleWindow,          0x00000114L
//             IID_IOleInPlaceUIWindow, 0x00000115L
//             IID_IOleInPlaceFrame,    0x00000116L
//             IID_IOleInPlaceActiveObject, 0x00000117L

//             IID_IOleClientSite,      0x00000118L
//             IID_IOleInPlaceSite,     0x00000119L

//             IID_IParseDisplayName,   0x0000011aL
//             IID_IOleContainer,       0x0000011bL
//             IID_IOleItemContainer,   0x0000011cL

//             IID_IOleLink,            0x0000011dL
//             IID_IOleCache,           0x0000011eL
//             IID_IOleManager,         0x0000011fL
//             IID_IOlePresObj,         0x00000120L

//             IID_IDropSource,         0x00000121L
//             IID_IDropTarget,         0x00000122L

//             IID_IDebug,              0x00000123L
//             IID_IDebugStream,        0x00000124L

//             IID_IAdviseSink2,        0x00000125L

//             IID_IRunnableObject,     0x00000126L

//             IID_IViewObject2,        0x00000127L
//             IID_IOleCache2,          0x00000128L
//             IID_IOleCacheControl,    0x00000129L
//             IID_IContinue,           0x0000012AL

//             IID_IDocConnect,         0x00000130L
//             IID_IRemUnknown,         0x00000131L
//             IID_ILocalSystemActivator, 0x00000132L
//             IID_IOSCM,               0x00000133L
//             IID_IRundown,            0x00000134L
//             IID_IInterfaceFromWindowProp, 0x00000135L
//             IID_IDSCM                0x00000136L
//             IID_IObjClient           0x00000137L

/* NOTE: LSB values 0x2a through 0xff are unused */

//             IID_IPropertyStorage,    0x00000138L
//             IID_IEnumSTATPROPSTG,    0x00000139L
//             IID_IPropertySetStorage, 0x0000013AL
//             IID_IEnumSTATPROPSETSTG, 0x0000013BL

//             IID_IRemUnknownN,        0x0000013CL
//             IID_INonNDRStub,         0x0000013DL
DEFINE_OLEGUID(IID_INonNDRStub, 0x0000013DL, 0, 0);


//             IID_IClientSecurity      0x0000013DL
//             IID_IServerSecurity      0x0000013EL
//
//             IID_IMacDragHelper       0x0000013FL

//             IID_IClassActivator      0x00000140L
//             IID_IDLLHost             0x00000141L
//             IID_IRemoteQI            0x00000142L
//             IID_IRemUnknown2,        0x00000143L
//             IID_IRPCOptions          0x00000144L


//             IID_IForegroundTransfer  0x00000145L
//             IID_IGlobalInterfaceTable 0x00000146L
//             IID_IPrivateStorage      0x00000147L
DEFINE_OLEGUID(IID_IPrivateStorage, 0x00000147L, 0, 0);
//             Unused                   0x00000148L
//             IID_IRpcHelper           0x00000149L

//             IID_IAsyncRpcBuffer      0x00000148L
//             IID_ICallFactory         0x00000149L
//             IID_AsyncIAdviseSink     0x00000150L
//             IID_AsyncIAdviseSink2    0x00000151L
//             IID_CPPRpcChannelBuffer  0x00000152L
//             IID_IMiniMoniker         0x00000153L
DEFINE_OLEGUID(IID_IStdCallObject,      0x00000154L, 0, 0);
//	       IID_IMacDragObject	0x00000155L
//	       IID_IReserved1,      	0x00000156L

DEFINE_OLEGUID(IID_IStdPolicySet,       0x000001c7L, 0, 0);
DEFINE_OLEGUID(IID_IStdObjectContext,   0x000001c9L, 0, 0);
DEFINE_OLEGUID(IID_IStdWrapper,         0x000001caL, 0, 0);
DEFINE_OLEGUID(IID_IStdCtxChnl,         0x000001ccL, 0, 0);
DEFINE_OLEGUID(IID_IDestInfo,           0x000001cdL, 0, 0);
DEFINE_OLEGUID(IID_IStdFreeMarshal,     0x000001d0L, 0, 0);
DEFINE_OLEGUID(IID_IStdIDObject,        0x000001d1L, 0, 0);

// Range 0x180 - 0x18F is reserved for the category interfaces.
//             IID_?                    0x00000180L
//             IID_?                    0x00000181L
//             IID_?                    0x00000182L
//             IID_?                    0x00000183L
//             IID_?                    0x00000184L
//             IID_?                    0x00000185L
//             IID_?                    0x00000186L
//             IID_?                    0x00000187L
//             IID_?                    0x00000188L
//             IID_?                    0x00000189L
//             IID_?                    0x0000018AL
//             IID_?                    0x0000018BL
//             IID_?                    0x0000018CL
//             IID_?                    0x0000018DL
//             IID_?                    0x0000018EL
//             IID_?                    0x0000018FL

//
// Unified Surrogate interfaces
//
//             IID_IPAControl             0x000001d2L
//             IID_IServicesSink          0x000001d3L
//             IID_ISurrogateService      0x000001d4L
//             IID_IProcessLock           0x000001d5L

//
//  New interface in contxt.idl
//             IID_IObjectIdentity       0x000001d7L

DEFINE_OLEGUID(IID_IPropertyStorage_Old,    0x66600014, 0, 8);
DEFINE_OLEGUID(IID_IEnumSTATPROPSTG_Old,    0x66600015, 0, 8);
DEFINE_OLEGUID(IID_IPropertySetStorage_Old, 0x66650000L, 0, 8);
DEFINE_OLEGUID(IID_IEnumSTATPROPSETSTG_Old, 0x66650001L, 0, 8);


////////////////////////////////////////////////////////////////////////////
// Range 0x300 - 0x3ff : internal CLSIDs

// Don't change this
#define MIN_INTERNAL_CLSID 0x00000300

DEFINE_OLEGUID(CLSID_StdOleLink,        0x00000300, 0, 0);
DEFINE_OLEGUID(CLSID_StdMemStm,         0x00000301, 0, 0);
DEFINE_OLEGUID(CLSID_StdMemBytes,       0x00000302, 0, 0);
DEFINE_OLEGUID(CLSID_FileMoniker,       0x00000303, 0, 0);
DEFINE_OLEGUID(CLSID_ItemMoniker,       0x00000304, 0, 0);
DEFINE_OLEGUID(CLSID_AntiMoniker,       0x00000305, 0, 0);
DEFINE_OLEGUID(CLSID_PointerMoniker,    0x00000306, 0, 0);
// NOT TO BE USED                       0x00000307, 0, 0);
DEFINE_OLEGUID(CLSID_PackagerMoniker,   0x00000308, 0, 0);
DEFINE_OLEGUID(CLSID_CompositeMoniker,  0x00000309, 0, 0);
// NOT TO BE USED                       0x0000030a, 0, 0);
DEFINE_OLEGUID(CLSID_DfMarshal,         0x0000030b, 0, 0);

// NOT TO BE USED 0x30c - 0x315 - old PS CLSID's

//             CLSID_Picture_Metafile,  0x00000315
//             CLSID_Picture_Dib,       0x00000316

DEFINE_OLEGUID(CLSID_RemoteHdlr,        0x00000317, 0, 0);
DEFINE_OLEGUID(CLSID_RpcChannelBuffer,  0x00000318, 0, 0);
//             CLSID_Picture_EnhMetafile,0x00000319
DEFINE_OLEGUID(CLSID_ClassMoniker,      0x0000031A, 0, 0);
DEFINE_OLEGUID(CLSID_ErrorObject,       0x0000031B, 0, 0);
DEFINE_OLEGUID(ERROR_EXTENSION,         0x0000031C, 0, 0);
//             CLSID_DCOMAccessControl, 0x0000031D
DEFINE_OLEGUID(CLSID_MachineMoniker,    0x0000031E, 0, 0);
DEFINE_OLEGUID(CLSID_UrlMonWrapper,     0x0000031F, 0, 0);


DEFINE_OLEGUID(CLSID_PSOlePrx32,        0x00000320, 0, 0);
DEFINE_OLEGUID(IID_ITrackingMoniker,    0x00000321, 0, 0);
DEFINE_OLEGUID(CLSID_StaticMarshal,     0x00000322, 0, 0);
DEFINE_OLEGUID(CLSID_StdGlobalInterfaceTable, 0x00000323, 0, 0);
//DEFINE_OLEGUID(CLSID_Synchronize_AutoComplete,     0x00000324, 0, 0); //obsolete
//DEFINE_OLEGUID(CLSID_Synchronize_ManualResetEvent, 0x00000325, 0, 0); //obsolete
//DEFINE_OLEGUID(CLSID_WaitMultiple,                 0x00000326, 0, 0); //obsolete

DEFINE_OLEGUID(CLSID_ObjrefMoniker,             0x00000327, 0, 0);
DEFINE_OLEGUID(CLSID_ComBinding,                   0x00000328, 0, 0);
DEFINE_OLEGUID(CLSID_StdAsyncManager,              0x00000329, 0, 0);
DEFINE_OLEGUID(CLSID_RpcHelper,                    0x0000032a, 0, 0);


DEFINE_OLEGUID(CLSID_StdEvent,                     0x0000032b, 0, 0);
DEFINE_OLEGUID(CLSID_ManualResetEvent,             0x0000032c, 0, 0);
DEFINE_OLEGUID(CLSID_SynchronizeContainer,         0x0000032d, 0, 0);
DEFINE_OLEGUID(CLSID_PipePSFactory,                0x0000032e, 0, 0);

// CLSID_AllClasses,                               0x00000330
// CLSID_LocalMachineClasses,                      0x00000331
// CLSID_CurrentUserClasses,                       0x00000332
// CLSID_PolicySet                                 0x00000333
DEFINE_OLEGUID(CONTEXT_EXTENSION,                  0x00000334, 0, 0);
DEFINE_OLEGUID(CLSID_ObjectContext,                0x00000335, 0, 0);
DEFINE_OLEGUID(CLSID_StdWrapper,                   0x00000336, 0, 0);

// Activation properties marshalers

DEFINE_OLEGUID(CLSID_ActivationProperties,          0x00000345, 0, 0);
DEFINE_OLEGUID(CLSID_ActivationPropertiesIn,        0x00000338, 0, 0);
DEFINE_OLEGUID(CLSID_ActivationPropertiesOut,       0x00000339, 0, 0);
DEFINE_OLEGUID(CLSID_ContextMarshaler,              0x0000033b, 0, 0);
DEFINE_OLEGUID(CLSID_InprocActpropsUnmarshaller,    0x00000344, 0, 0);
DEFINE_OLEGUID(CLSID_UserContextMarshaler,          0x0000033d, 0, 0);

// Com ImmediateActivator
DEFINE_OLEGUID(CLSID_ComActivator,                  0x0000033c, 0, 0);

DEFINE_OLEGUID(CLSID_RemoteUnknownPSFactory,        0x00000340, 0, 0);
DEFINE_OLEGUID(CLSID_ATHostActivator,               0x00000341, 0, 0);
DEFINE_OLEGUID(CLSID_MTHostActivator,               0x00000342, 0, 0);
DEFINE_OLEGUID(CLSID_NTHostActivator,               0x00000343, 0, 0);

// free threaded marshaler
DEFINE_OLEGUID(CLSID_InProcFreeMarshaler,           0x0000033a, 0, 0);

// Catalog object
DEFINE_OLEGUID(CLSID_COMCatalog,                    0x00000346, 0, 0);

// for the session moniker; created by gilleg
DEFINE_OLEGUID(CLSID_SessionMoniker,                0x00000347, 0, 0);

// for ip addr control object
DEFINE_OLEGUID(CLSID_IPAddrControl,                 0x00000348, 0, 0);

#define MAX_INTERNAL_CLSID              0x00000349

// These guids are not implemented by ole32, so they are not in the 
// "internal clsid" range.  I started them at the top of the reserved
// range, working backwards.
DEFINE_OLEGUID(CLSID_RPCSSInfo,                     0x000003FF, 0, 0);

DEFINE_OLEGUID(CLSID_ServerHandler,     0x00020322, 0, 0);
DEFINE_OLEGUID(CLSID_ClientSiteHandler, 0x00020323, 0, 0);
//CLSID_Reserved for wrappers           0x00000337, 0, 0);
DEFINE_OLEGUID(CLSID_PSDispatch,        0x00020420, 0, 0);


/* NOTE: LSB values 0x1a through 0xff are unused */

DEFINE_OLEGUID(IID_IHookOleObject,      0x0002AD11, 0, 0);

DEFINE_OLEGUID(CLSID_StdComponentCategoriesMgr, 0x0002E005, 0, 0);
DEFINE_OLEGUID(CLSID_GblComponentCategoriesMgr, 0x0002E006, 0, 0);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ih\tls.h ===
//+---------------------------------------------------------------------------
//
//  File:       tls.hxx
//
//  Purpose:    manage thread local storage for OLE
//
//  Notes:      The gTlsIndex is initialized at process attach time.
//              The per-thread data is allocated in CoInitialize in
//              single-threaded apartments or on first use in
//              multi-threaded apartments.
//
//              The non-inline routines are in ..\com\class\tls.cxx
//
//  History:    16-Jun-94   BruceMa    Don't decrement 0 thread count
//              17-Jun-94   Bradloc    Added punkState for VB94
//              20-Jun-94   Rickhi     Commented better
//              06-Jul-94   BruceMa    Support for CoGetCurrentProcess
//              19-Jul-94   CraigWi    Removed TLSGetEvent (used cache instead)
//              21-Jul-94   AlexT      Add TLSIncOleInit, TLSDecOleInit
//              21-Aug-95   ShannonC   Removed TLSSetMalloc, TLSGetMalloc
//              06-Oct-95   Rickhi     Simplified. Made into a C++ class.
//              01-Feb-96   Rickhi     On Nt, access TEB directly
//              30-May-96   ShannonC   Add punkError
//              12-Sep-96   rogerg     Add pDataObjClip
//              26-Nov-96   Gopalk     Add IsOleInitialized
//              13-Jan-97   RichN      Add pContextObj
//              10-Feb-99   TarunA     Add cAsyncSends
//----------------------------------------------------------------------------
#ifndef _TLS_HXX_
#define _TLS_HXX_


#include <rpc.h>                            // UUID


//+---------------------------------------------------------------------------
//
// forward declarations (in order to avoid type casting when accessing
// data members of the SOleTlsData structure).
//
//+---------------------------------------------------------------------------

class  CAptCallCtrl;                        // see callctrl.hxx
class  CSrvCallState;                       // see callctrl.hxx
class  CObjServer;                          // see sobjact.hxx
class  CSmAllocator;                        // see stg\h\smalloc.hxx
class  CMessageCall;                        // see call.hxx
class  CClientCall;                         // see call.hxx
class  CAsyncCall;                          // see call.hxx
class  CClipDataObject;                     // see ole232\clipbrd\clipdata.h
class  CSurrogatedObjectList;               // see com\inc\comsrgt.hxx
class  CCtxCall;                            // see PSTable.hxx
class  CPolicySet;                          // see PSTable.hxx
class  CObjectContext;                      // see context.hxx
class  CComApartment;                       // see aprtmnt.hxx

#ifdef _CHICAGO_
// Chicago uses the Thread Local Storage APIs
extern DWORD  gTlsIndex;                    // global Index for TLS
#endif  // _CHICAGO_

//+-------------------------------------------------------------------
//
//  Struct:     CallEntry
//
//  Synopsis:   Call Table Entry.
//
//+-------------------------------------------------------------------
typedef struct tagCallEntry
{
    void  *pNext;        // ptr to next entry
    void  *pvObject;     // Entry object
} CallEntry;


//+-------------------------------------------------------------------
//
//  Struct:     LockEntry
//
//  Synopsis:   Call Table Entry.
//
//+-------------------------------------------------------------------
#define LOCKS_PER_ENTRY         16
typedef struct tagLockEntry
{
    tagLockEntry  *pNext;                // ptr to next entry
    WORD wReaderLevel[LOCKS_PER_ENTRY];  // reader nesting level
} LockEntry;


//+-------------------------------------------------------------------
//
//  Struct:     ContextStackNode
//
//  Synopsis:   Stack of contexts used with Services Without Components
//
//+-------------------------------------------------------------------
typedef struct tagContextStackNode
{
    tagContextStackNode* pNext;
    CObjectContext* pSavedContext;
    CObjectContext* pServerContext;
    CCtxCall* pClientCall;
    CCtxCall* pServerCall;
    CPolicySet* pPS;
} ContextStackNode;

//+-------------------------------------------------------------------
//
//  Struct:     InitializeSpyNode
//
//  Synopsis:   Node in a linked list of Initialize Spy registrations
//
//+-------------------------------------------------------------------
typedef struct tagInitializeSpyNode
{
    tagInitializeSpyNode *pNext;  
    tagInitializeSpyNode *pPrev;
    DWORD                 dwRefs;
    DWORD                 dwCookie;
    IInitializeSpy       *pInitSpy;
} InitializeSpyNode;

//+---------------------------------------------------------------------------
//
//  Enum:       OLETLSFLAGS
//
//  Synopsys:   bit values for dwFlags field of SOleTlsData. If you just want
//              to store a BOOL in TLS, use this enum and the dwFlag field.
//
//+---------------------------------------------------------------------------
typedef enum tagOLETLSFLAGS
{
    OLETLS_LOCALTID             = 0x01,   // This TID is in the current process.
    OLETLS_UUIDINITIALIZED      = 0x02,   // This Logical thread is init'd.
    OLETLS_INTHREADDETACH       = 0x04,   // This is in thread detach. Needed
                                          // due to NT's special thread detach
                                          // rules.
    OLETLS_CHANNELTHREADINITIALZED = 0x08,// This channel has been init'd
    OLETLS_WOWTHREAD            = 0x10,   // This thread is a 16-bit WOW thread.
    OLETLS_THREADUNINITIALIZING = 0x20,   // This thread is in CoUninitialize.
    OLETLS_DISABLE_OLE1DDE      = 0x40,   // This thread can't use a DDE window.
    OLETLS_APARTMENTTHREADED    = 0x80,   // This is an STA apartment thread
    OLETLS_MULTITHREADED        = 0x100,  // This is an MTA apartment thread
    OLETLS_IMPERSONATING        = 0x200,  // This thread is impersonating
    OLETLS_DISABLE_EVENTLOGGER  = 0x400,  // Prevent recursion in event logger
    OLETLS_INNEUTRALAPT         = 0x800,  // This thread is in the NTA
    OLETLS_DISPATCHTHREAD       = 0x1000, // This is a dispatch thread
    OLETLS_HOSTTHREAD           = 0x2000, // This is a host thread
    OLETLS_ALLOWCOINIT          = 0x4000, // This thread allows inits
    OLETLS_PENDINGUNINIT        = 0x8000, // This thread has pending uninit
    OLETLS_FIRSTMTAINIT         = 0x10000,// First thread to attempt an MTA init
    OLETLS_FIRSTNTAINIT         = 0x20000,// First thread to attempt an NTA init
    OLETLS_APTINITIALIZING      = 0x40000 // Apartment Object is initializing
}  OLETLSFLAGS;


//+---------------------------------------------------------------------------
//
//  Structure:  SOleTlsData
//
//  Synopsis:   structure holding per thread state needed by OLE32
//
//+---------------------------------------------------------------------------
typedef struct tagSOleTlsData
{
    // jsimmons 5/23/2001
    // Alert Alert:  nefarious folks (eg, URT) are looking in our TLS at
    // various stuff.   They expect that pCurrentCtx will be at a certain
    // offset from the beginning of the tls struct. So don't add, delete, or 
    // move any members within this block.

/////////////////////////////////////////////////////////////////////////////////////////
// ********* BEGIN "NO MUCKING AROUND" BLOCK ********* 
/////////////////////////////////////////////////////////////////////////////////////////
    // Docfile multiple allocator support
    void               *pvThreadBase;       // per thread base pointer
    CSmAllocator       *pSmAllocator;       // per thread docfile allocator

    DWORD               dwApartmentID;      // Per thread "process ID"
    DWORD               dwFlags;            // see OLETLSFLAGS above

    LONG                TlsMapIndex;        // index in the global TLSMap
    void              **ppTlsSlot;          // Back pointer to the thread tls slot
    DWORD               cComInits;          // number of per-thread inits
    DWORD               cOleInits;          // number of per-thread OLE inits

    DWORD               cCalls;             // number of outstanding calls
    CMessageCall       *pCallInfo;          // channel call info
    CAsyncCall         *pFreeAsyncCall;     // ptr to available call object for this thread.
    CClientCall        *pFreeClientCall;    // ptr to available call object for this thread.

    CObjServer         *pObjServer;         // Activation Server Object for this apartment.
    DWORD               dwTIDCaller;        // TID of current calling app
    CObjectContext     *pCurrentCtx;        // Current context
/////////////////////////////////////////////////////////////////////////////////////////
//  ********* END "NO MUCKING AROUND" BLOCK ********* 
/////////////////////////////////////////////////////////////////////////////////////////

    CObjectContext     *pEmptyCtx;          // Empty context

    CObjectContext     *pNativeCtx;         // Native context
    ULONGLONG           ContextId;          // Uniquely identifies the current context
    CComApartment      *pNativeApt;         // Native apartment for the thread.
    IUnknown           *pCallContext;       // call context object
    CCtxCall           *pCtxCall;           // Context call object

    CPolicySet         *pPS;                // Policy set
    PVOID               pvPendingCallsFront;// Per Apt pending async calls
    PVOID               pvPendingCallsBack;
    CAptCallCtrl       *pCallCtrl;          // call control for RPC for this apartment

    CSrvCallState      *pTopSCS;            // top server-side callctrl state
    IMessageFilter     *pMsgFilter;         // temp storage for App MsgFilter
    HWND                hwndSTA;            // STA server window same as poxid->hServerSTA
                                            // ...needed on Win95 before oxid registration
    LONG                cORPCNestingLevel;  // call nesting level (DBG only)

    DWORD               cDebugData;         // count of bytes of debug data in call

    UUID                LogicalThreadId;    // current logical thread id

    HANDLE              hThread;            // Thread handle used for cancel
    HANDLE              hRevert;            // Token before first impersonate.
    IUnknown           *pAsyncRelease;      // Controlling unknown for async release
    // DDE data
    HWND                hwndDdeServer;      // Per thread Common DDE server

    HWND                hwndDdeClient;      // Per thread Common DDE client
    ULONG               cServeDdeObjects;   // non-zero if objects DDE should serve
    // ClassCache data
    LPVOID              pSTALSvrsFront;     // Chain of LServers registers in this thread if STA
    // upper layer data
    HWND                hwndClip;           // Clipboard window

    IDataObject         *pDataObjClip;      // Current Clipboard DataObject
    DWORD               dwClipSeqNum;       // Clipboard Sequence # for the above DataObject
    DWORD               fIsClipWrapper;     // Did we hand out the wrapper Clipboard DataObject?
    IUnknown            *punkState;         // Per thread "state" object
    // cancel data
    DWORD              cCallCancellation;   // count of CoEnableCallCancellation
    // async sends data
    DWORD              cAsyncSends;         // count of async sends outstanding

    CAsyncCall*           pAsyncCallList;   // async calls outstanding
    CSurrogatedObjectList *pSurrogateList;  // Objects in the surrogate

    LockEntry             lockEntry;        // Locks currently held by the thread
    CallEntry             CallEntry;        // client-side call chain for this thread

    ContextStackNode* pContextStack;        // Context stack node for SWC.

    InitializeSpyNode  *pFirstSpyReg;       // First registered IInitializeSpy
    InitializeSpyNode  *pFirstFreeSpyReg;   // First available spy registration
    DWORD               dwMaxSpy;           // First free IInitializeSpy cookie

#ifdef WX86OLE
    IUnknown           *punkStateWx86;      // Per thread "state" object for Wx86
#endif
    void               *pDragCursors;       // Per thread drag cursor table.

    IUnknown           *punkError;          // Per thread error object.
    ULONG               cbErrorData;        // Maximum size of error data.

    IUnknown           *punkActiveXSafetyProvider;

#if DBG==1
    LONG                cTraceNestingLevel; // call nesting level for OLETRACE
#endif
} SOleTlsData;



//+---------------------------------------------------------------------------
//
//  class       COleTls
//
//  Synopsis:   class to abstract thread-local-storage in OLE.
//
//  Notes:      To use Tls in OLE, functions should define an instance of
//              this class on their stack, then use the -> operator on the
//              instance to access fields of the SOleTls structure.
//
//              There are two instances of the ctor. One just Assert's that
//              the SOleTlsData has already been allocated for this thread. Most
//              internal code should use this ctor, since we can assert that if
//              the thread made it this far into our code, tls has already been
//              checked.
//
//              The other ctor will check if SOleTlsData exists, and attempt to
//              allocate and initialize it if it does not. This ctor will
//              return an HRESULT. Functions that are entry points to OLE32
//              should use this version.
//
//+---------------------------------------------------------------------------
class COleTls
{
public:
    COleTls();
    COleTls(HRESULT &hr);
    COleTls(BOOL fDontAllocateIfNULL);

    // to get direct access to the data structure
    SOleTlsData * operator->(void) { return _pData; }
    operator SOleTlsData *()       { return _pData; }

    // Helper functions
    BOOL         IsNULL() { return (_pData == NULL) ? TRUE : FALSE; }

private:

    HRESULT      TLSAllocData(); // allocates an SOleTlsData structure

    SOleTlsData * _pData;        // ptr to OLE TLS data
};

extern SOleTlsData *TLSLookupThreadId(DWORD dwThreadId);


#ifndef _CHICAGO_
//+---------------------------------------------------------------------------
//
//  Method:     COleTls::COleTls
//
//  Synopsis:   ctor for OLE Tls object.
//
//  Notes:      Most internal code should use this version of the ctor,
//              assuming that some outer-layer function has already verified
//              the existence of the tls_data.
//
//+---------------------------------------------------------------------------
__forceinline COleTls::COleTls()
{
    _pData = (SOleTlsData *) NtCurrentTeb()->ReservedForOle;
    Win4Assert(_pData && "Illegal attempt to use TLS before Initialized");
}

//+---------------------------------------------------------------------------
//
//  Method:     COleTls::COleTls
//
//  Synopsis:   ctor for OLE Tls object.
//
//  Notes:      Special version for CoUninitialize which will not allocate
//              (or assert) if the TLS is NULL. It can then be checked with
//              IsNULL member function.
//
//+---------------------------------------------------------------------------
__forceinline COleTls::COleTls(BOOL fDontAllocateIfNULL)
{
    _pData = (SOleTlsData *) NtCurrentTeb()->ReservedForOle;
}

//+---------------------------------------------------------------------------
//
//  Method:     COleTls::COleTls
//
//  Synopsis:   ctor for OLE Tls object.
//
//  Notes:      Peripheral OLE code that can not assume that some outer-layer
//              function has already verified the existence of the SOleTlsData
//              structure for the current thread should use this version of
//              the ctor.
//
//+---------------------------------------------------------------------------
__forceinline COleTls::COleTls(HRESULT &hr)
{
    _pData = (SOleTlsData *) NtCurrentTeb()->ReservedForOle;
    if (_pData)
        hr = S_OK;
    else
        hr = TLSAllocData();
}

#else   // _CHICAGO_ versions

//+---------------------------------------------------------------------------
//
//  Method:     COleTls::COleTls
//
//  Synopsis:   ctor for OLE Tls object.
//
//  Notes:      Most internal code should use this version of the ctor,
//              assuming that some outer-layer function has already verified
//              the existence of the tls_data.
//
//+---------------------------------------------------------------------------
inline COleTls::COleTls()
{
    _pData = (SOleTlsData *) TlsGetValue(gTlsIndex);
    Win4Assert(_pData && "Illegal attempt to use TLS before Initialized");
}

//+---------------------------------------------------------------------------
//
//  Method:     COleTls::COleTls
//
//  Synopsis:   ctor for OLE Tls object.
//
//  Notes:      Special version for CoUninitialize which will not allocate
//              (or assert) if the TLS is NULL. It can then be checked with
//              IsNULL member function.
//
//+---------------------------------------------------------------------------
inline COleTls::COleTls(BOOL fDontAllocateIfNULL)
{
    _pData = (SOleTlsData *) TlsGetValue(gTlsIndex);
}

//+---------------------------------------------------------------------------
//
//  Method:     COleTls::COleTls
//
//  Synopsis:   ctor for OLE Tls object.
//
//  Notes:      Peripheral OLE code that can not assume that some outer-layer
//              function has already verified the existence of the SOleTlsData
//              structure for the current thread should use this version of
//              the ctor.
//
//+---------------------------------------------------------------------------
inline COleTls::COleTls(HRESULT &hr)
{
    _pData = (SOleTlsData *) TlsGetValue(gTlsIndex);
    if (_pData)
        hr = S_OK;
    else
        hr = TLSAllocData();
}
#endif  // _CHICAGO_


//+---------------------------------------------------------------------------
//
// Enum:       APTKIND
//
// Synopsis:   These are the apartment models COM understands.  The
//             GetCurrentApartmentKind functions return one of these values
//             identifying which apartment the currently executing thread
//             is in.
//
//-----------------------------------------------------------------------------
typedef enum tagAPTKIND
{
    APTKIND_NEUTRALTHREADED     = 0x01,
    APTKIND_MULTITHREADED       = 0x02,
    APTKIND_APARTMENTTHREADED   = 0x04
} APTKIND;


//+---------------------------------------------------------------------------
//
// Thread IDs for the various apartment types.  STA uses the currently
// executing TID.
//
//----------------------------------------------------------------------------
#define MTATID  0x0             // thread id of the MTA
#define NTATID  0xFFFFFFFF      // thread id of the NTA

typedef DWORD HAPT;
const   HAPT  haptNULL = 0;

//+---------------------------------------------------------------------------
//
//  Function:   GetCurrentApartmentId
//
//  Synopsis:   Returns the apartment id that the current thread is executing
//              in. If this is the Multi-threaded apartment, it returns 0; if
//              it is the Neutral-threaded apartment, it returns 0xFFFFFFFF.
//
//+---------------------------------------------------------------------------
inline DWORD GetCurrentApartmentId()
{
    HRESULT hr;
    COleTls Tls(hr);

    //
    // If TLS is not initialized, this is a MTA apartment.
    //
    if (FAILED(hr))
    {
        return MTATID;
    }
    else
    {
        return (Tls->dwFlags & OLETLS_INNEUTRALAPT) ? NTATID :
               (Tls->dwFlags & OLETLS_APARTMENTTHREADED) ? GetCurrentThreadId() :
               MTATID;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   DoATClassCreate
//
//  Synopsis:   Put a given Class Factory on a new ApartmentModel thread.
//
//+---------------------------------------------------------------------------

HRESULT DoATClassCreate(LPFNGETCLASSOBJECT pfn,
                        REFCLSID rclsid, REFIID riid, IUnknown **ppunk);


//+---------------------------------------------------------------------------
//
//  Function:   IsSTAThread
//
//  Synopsis:   returns TRUE if the current thread is for a
//              single-threaded apartment, FALSE otherwise
//
//+---------------------------------------------------------------------------
inline BOOL IsSTAThread()
{
    COleTls Tls;
    return (Tls->dwFlags & OLETLS_APARTMENTTHREADED) ? TRUE : FALSE;
}


//+---------------------------------------------------------------------------
//
//  Function:   IsMTAThread
//
//  Synopsis:   returns TRUE if the current thread is for a
//              multi-threaded apartment, FALSE otherwise
//
//+---------------------------------------------------------------------------
inline BOOL IsMTAThread()
{
    COleTls Tls;
    return (Tls->dwFlags & OLETLS_APARTMENTTHREADED) ? FALSE : TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   IsOleInitialized
//
//  Synopsis:   returns TRUE if the current thread is for a
//              multi-threaded apartment, FALSE otherwise
//
//+---------------------------------------------------------------------------
inline BOOL IsOleInitialized()
{
    COleTls Tls(FALSE);
    return((!Tls.IsNULL() && Tls->cOleInits>0) ? TRUE : FALSE);
}

BOOL    IsApartmentInitialized();
IID    *TLSGetLogicalThread();
BOOLEAN TLSIsWOWThread();
BOOLEAN TLSIsThreadDetaching();
void    CleanupTlsState(SOleTlsData *pTls, BOOL fSafe);

inline HWND TLSGethwndSTA()
{
    COleTls Tls;

    return(Tls->hwndSTA);
}

inline void TLSSethwndSTA(HWND hwnd)
{
    COleTls Tls;

    Tls->hwndSTA = hwnd;
}

#endif // _TLS_HXX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ih\stkswtch.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       stkswtch.h
//
//  Contents:   Stack Switching proto types and macros
//
//  Classes:
//
//  Functions:
//
//  History:    12-10-94   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#ifndef _STKSWTCH_
#define _STKSWTCH_

#ifdef _CHICAGO_

extern "C" DWORD NEAR _cdecl SSCall(DWORD cbParamBytes,
	                 DWORD flags,
	                 LPVOID lpfnProcAddress,
	                 DWORD param1,...);


#define SSF_BigStack 1
#define SSF_SmallStack 0
extern "C" BOOL WINAPI SSOnBigStack(VOID);

DECLARE_DEBUG(Stack)
#define DEB_STCKSWTCH DEB_USER1
#define SSOnSmallStack() (!SSOnBigStack())
#if DBG==1

extern BOOL fSSOn;
#define SSONBIGSTACK()   (fSSOn && IsWOWThread() && SSOnBigStack())
#define SSONSMALLSTACK() (fSSOn && IsWOWThread() && !SSOnBigStack())
#define StackAssert(x) 	 ((fSSOn && IsWOWThread())? Win4Assert(x): TRUE)
#define StackDebugOut(x) StackInlineDebugOut x

#else

#define SSONBIGSTACK() 	 (IsWOWThread() && SSOnBigStack())
#define SSONSMALLSTACK() (IsWOWThread() && !SSOnBigStack())
#define StackAssert(x)
#define StackDebugOut(x)

#endif

LRESULT WINAPI SSSendMessage(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
BOOL	WINAPI SSReplyMessage(LRESULT lResult);
LRESULT WINAPI SSCallWindowProc(WNDPROC lpPrevWndFunc, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
LRESULT WINAPI SSDefWindowProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
BOOL WINAPI SSPeekMessage(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax,UINT wRemoveMsg);
BOOL WINAPI SSGetMessage(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax);
LONG WINAPI SSDispatchMessage(CONST MSG *lpMsg);
DWORD WINAPI SSMsgWaitForMultipleObjects(DWORD nCount, LPHANDLE pHandles, BOOL fWaitAll, DWORD dwMilliseconds, DWORD dwWakeMask);
BOOL WINAPI SSWaitMessage(VOID);
BOOL WINAPI SSDirectedYield(HTASK htask);
int WINAPI  SSDialogBoxParam(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
int WINAPI  SSDialogBoxIndirectParam(HINSTANCE hInstance, LPCDLGTEMPLATEA hDialogTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);

#define SSDialogBox(a,b,c,d) \
	SSDialogBoxParam(a,b,c,d, 0L)
#define SSDialogBoxIndirect(a,b,c,d) \
	SSDialogBoxIndirectParam(a,b,c,d,e, 0L)

HWND WINAPI SSCreateWindowExA(DWORD dwExStyle,
    LPCSTR lpClassName,LPCSTR lpWindowName,
    DWORD dwStyle,int X,int Y,int nWidth,int nHeight,
    HWND hWndParent ,HMENU hMenu,HINSTANCE hInstance,
    LPVOID lpParam);

HWND WINAPI SSCreateWindowExW(DWORD dwExStyle,
    LPCWSTR lpClassName,LPCWSTR lpWindowName,
    DWORD dwStyle, int X, int Y, int nWidth,int nHeight,
    HWND hWndParent ,HMENU hMenu,HINSTANCE hInstance,
    LPVOID lpParam);

BOOL WINAPI SSDestroyWindow(HWND hWnd);
int WINAPI SSMessageBox(HWND hWnd,LPCSTR lpText,LPCSTR lpCaption, UINT uType);

BOOL 	WINAPI SSOpenClipboard(HWND hWndNewOwner);
BOOL 	WINAPI SSCloseClipboard(VOID);
HWND 	WINAPI SSGetClipboardOwner(VOID);
HANDLE 	WINAPI SSSetClipboardData(UINT uFormat,HANDLE hMem);
HANDLE 	WINAPI SSGetClipboardData(UINT uFormat);
UINT 	WINAPI SSRegisterClipboardFormatA(LPCSTR lpszFormat);
UINT 	WINAPI SSEnumClipboardFormats(UINT format);
int 	WINAPI SSGetClipboardFormatNameA(UINT format,LPSTR lpszFormatName,int cchMaxCount);
BOOL 	WINAPI SSEmptyClipboard(VOID);
BOOL 	WINAPI SSIsClipboardFormatAvailable(UINT format);
BOOL    WINAPI SSCreateProcessA(
                    LPCSTR lpApplicationName,
                    LPSTR lpCommandLine,
                    LPSECURITY_ATTRIBUTES lpProcessAttributes,
                    LPSECURITY_ATTRIBUTES lpThreadAttributes,
                    BOOL bInheritHandles,
                    DWORD dwCreationFlags,
                    LPVOID lpEnvironment,
                    LPCSTR lpCurrentDirectory,
                    LPSTARTUPINFOA lpStartupInfo,
                    LPPROCESS_INFORMATION lpProcessInformation);
BOOL    WINAPI SSInSendMessage(VOID);
DWORD   WINAPI SSInSendMessageEx(LPVOID);


#if 0

#undef SendMessage
#undef ReplyMessage
#undef CallWindowProc
#undef DefWindowProc
#undef PeekMessage
#undef GetMessage
#undef DispatchMessage
#undef WaitMessage
#undef MsgWaitForMultipleObjects
#undef DialogBoxParam
#undef DialogBoxIndirectParam
#undef CreateWindowExA
#undef CreateWindowExW
#undef DestroyWindow
#undef MessageBox
//
#undef OpenClipboard
#undef CloseClipboard
#undef GetClipboardOwner
#undef SetClipboardData
#undef RegisterClipboardFormatA
#undef EnumClipboardFormats
#undef GetClipboardFormatNameA
#undef EmptyClipboard
#undef IsClipboardFormatAvailable
#undef CreateProcessA
#undef InSendMessage
#undef InSendMessageEx

// Define all user APIs to an undefined function to
// force an compiling error.

#define SS_STOP_STR USE_SS_API_INSTEAD /* error: Stack Switching: Please use SSxxx APIS! */
#define SendMessage( hWnd,  Msg,  wParam,  lParam)   SS_STOP_STR
#define ReplyMessage( lResult)   SS_STOP_STR
#define CallWindowProc( lpPrevWndFunc,  hWnd,  Msg,  wParam,  lParam)   SS_STOP_STR
#define DefWindowProc( hWnd,  Msg,  wParam,  lParam)   SS_STOP_STR
#define PeekMessage( lpMsg,  hWnd,  wMsgFilterMin,  wMsgFilterMax, wRemoveMsg)   SS_STOP_STR
#define GetMessage( lpMsg,  hWnd,  wMsgFilterMin,  wMsgFilterMax)   SS_STOP_STR
#define DispatchMessage( lpMsg)   SS_STOP_STR
#define WaitMessage()	SS_STOP_STR
#define MsgWaitForMultipleObjects(nCount, pHandles, fWaitAll, dwMilliseconds, dwWakeMask) SS_STOP_STR
#define DialogBoxParam( hInstance,  lpTemplateName,  hWndParent,  lpDialogFunc,  dwInitParam)   SS_STOP_STR
#define DialogBoxIndirectParam( hInstance, hDialogTemplate,  hWndParent,  lpDialogFunc,  dwInitParam)   SS_STOP_STR
#define CreateWindowExA( dwExStyle,  lpClassName, lpWindowName,  dwStyle, X, Y, nWidth, nHeight, hWndParent , hMenu, hInstance, lpParam)   SS_STOP_STR
#define CreateWindowExW( dwExStyle,  lpClassName, lpWindowName,  dwStyle,  X,  Y,  nWidth, nHeight, hWndParent , hMenu, hInstance, lpParam)   SS_STOP_STR
#define DestroyWindow( hWnd)   SS_STOP_STR
#define MessageBox( hWnd, lpText, lpCaption,  uType)   SS_STOP_STR
//
#define OpenClipboard( hWndNewOwner) SS_STOP_STR
#define CloseClipboard()   SS_STOP_STR
#define GetClipboardOwner()   SS_STOP_STR
#define SetClipboardData( uFormat, hMem)   SS_STOP_STR
#define RegisterClipboardFormatA(lpszFormat)   SS_STOP_STR
#define EnumClipboardFormats( format)   SS_STOP_STR
#define GetClipboardFormatNameA( format, lpszFormatName, cchMaxCount)   SS_STOP_STR
#define EmptyClipboard()   SS_STOP_STR
#define IsClipboardFormatAvailable( format)   SS_STOP_STR
#define CreateProcessA(lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation) SS_STOP_STR
#define InSendMessage() SS_STOP_STR
#define InSendMessageEx(lpResvd) SS_STOP_STR

#endif // 0

#else  // ! _CHICAGO

// For non-chicago platrforms: define all SSxxx APIs
// back to the original user api

#define SSSendMessage                  	SendMessage
#define SSReplyMessage                 	ReplyMessage
#define SSCallWindowProc               	CallWindowProc
#define SSDefWindowProc                	DefWindowProc
#define SSPeekMessage  	    		PeekMessage
#define SSGetMessage		    	GetMessage
#define SSDispatchMessage		DispatchMessage
#define SSWaitMessage			WaitMessage
#define SSMsgWaitForMultipleObjects	MsgWaitForMultipleObjects
#define SSDirectedYield  	    	DirectedYield
#define SSDialogBoxParam		DialogBoxParam
#define SSDialogBoxIndirectParam  	DialogBoxIndirectParam
#define SSCreateWindowExA              	CreateWindowExA
#define SSCreateWindowExW              	CreateWindowExW
#define SSDestroyWindow                	DestroyWindow
#define SSMessageBox			MessageBox

#define SSOpenClipboard             	OpenClipboard
#define SSCloseClipboard              	CloseClipboard
#define SSGetClipboardOwner           	GetClipboardOwner
#define SSSetClipboardData            	SetClipboardData
#define SSGetClipboardData          	GetClipboardData
#define SSRegisterClipboardFormatA    	RegisterClipboardFormatA
#define SSEnumClipboardFormats        	EnumClipboardFormats
#define SSGetClipboardFormatNameA     	GetClipboardFormatNameA
#define SSEmptyClipboard              	EmptyClipboard
#define SSIsClipboardFormatAvailable  	IsClipboardFormatAvailable
#define SSCreateProcessA                CreateProcessA
#define SSInSendMessage                 InSendMessage
#define SSInSendMessageEx               InSendMessageEx

#endif // _CHICAGO_

#ifdef _CHICAGO_

#define SSAPI(x) SS##x

#else

#define SSAPI(x) x
#define StackDebugOut(x)
#define StackAssert(x)
#define SSOnSmallStack()

#endif // _CHICAGO_

#endif // _STKSWTCH_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ih\verole.h ===
#define rmj		1
#define rmm		824
#define rup		1
#define szVerName	""
#define szVerUser	"kevinro"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ih\userapis.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       userapis.h
//
//  Contents:   Prototypes and macors for stack switching
//
//  Classes:
//
//  Functions:
//
//  History:    12-30-94   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------

#ifndef _USERAPIS_
#define _USERAPIS_

#ifdef _CHICAGO_

#undef SendMessage
#undef ReplyMessage
#undef CallWindowProc
#undef DefWindowProc
#undef PeekMessage
#undef GetMessage
#undef DispatchMessage
#undef WaitMessage
#undef MsgWaitForMultipleObjects
#undef DirectedYield
#undef DialogBoxParam
#undef DialogBoxIndirectParam
#undef DestroyWindow
#undef MessageBox
#undef CreateWindowExA
#undef CreateWindowExW
#undef CreateProcessA
#undef InSendMessage

// Clipboard apis
#undef OpenClipboard
#undef CloseClipboard
#undef GetClipboardOwner
#undef SetClipboardData
#undef GetClipboardData
#undef EnumClipboardFormats
#undef EmptyClipboard
#undef RegisterClipboardFormatA
#undef GetClipboardFormatNameA
#undef IsClipboardFormatAvailable

//
// Restore original definitions as in winuser.h
//

#define SendMessage                 SendMessageA
#define CallWindowProc              CallWindowProcA
#define DefWindowProc               DefWindowProcA
#define PeekMessage                 PeekMessageA
#define GetMessage		    GetMessageA
#define MsgWaitForMultipleObjects   MsgWaitForMultipleObjects
#define DispatchMessage             DispatchMessageA
#define DialogBoxParam              DialogBoxParamA
#define DialogBoxIndirectParam      DialogBoxIndirectParamA
#define MessageBox                  MessageBoxA


#undef  DialogBox
#define DialogBox(a,b,c,d) \
	DialogBoxParamA(a,b,c,d, 0L)
#undef  DialogBoxIndirect
#define DialogBoxIndirect(a,b,c,d) \
	DialogBoxIndirectParamA(a,b,c,d,e, 0L)

#endif // _CHICAGO_

#endif // _USERAPIS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ih\valid.h ===
#ifndef __IH_VALID__H__
#define __IH_VALID__H__

#include "apcompat.hxx"

#if DBG==1 && defined(WIN32) && !defined(_CHICAGO_)
#define VDATEHEAP() if( !HeapValidate(GetProcessHeap(),0,0)){ DebugBreak();}
#else
#define VDATEHEAP()
#endif  //  DBG==1 && defined(WIN32) && !defined(_CHICAGO_)

#define IsValidPtrIn(pv,cb)  ((pv == NULL) || !ValidateInPointers() || !IsBadReadPtr ((pv),(cb)))
#define IsValidReadPtrIn(pv,cb)  ((cb == 0 || pv) && (!ValidateInPointers() || !IsBadReadPtr ((pv),(cb))))
#define IsValidPtrOut(pv,cb) ((cb == 0 || pv) && (!ValidateOutPointers() || !IsBadWritePtr((pv),(cb))))
#define IsValidCodePtr(pv) (pv && (!ValidateCodePointers() || !IsBadCodePtr ((pv))))

STDAPI_(BOOL) IsValidInterface( void FAR* pv );


#if DBG==1
// for performance, do not do in retail builds
STDAPI_(BOOL) IsValidIid( REFIID riid );
#else
#define IsValidIid(x) (TRUE)
#endif

#ifdef _DEBUG

DECLARE_DEBUG(VDATE);

#define VdateAssert(exp, msg) \
    VDATEInlineDebugOut( DEB_FORCE, "%s:%s; File: %s Line: %d\n", #exp, msg, __FILE__, __LINE__ )

//** POINTER IN validation macros:
#define VDATEPTRIN( pv, TYPE ) \
        if (!IsValidPtrIn( (pv), sizeof(TYPE))) \
    return (VdateAssert(pv, "Invalid in ptr"),ResultFromScode(E_INVALIDARG))
#define GEN_VDATEPTRIN( pv, TYPE, retval) \
        if (!IsValidPtrIn( (pv), sizeof(TYPE))) \
    return (VdateAssert(pv, "Invalid in ptr"), retval)
#define VOID_VDATEPTRIN( pv, TYPE ) \
        if (!IsValidPtrIn( (pv), sizeof(TYPE))) {\
    VdateAssert(pv, "Invalid in ptr"); return; }

//** POINTER IN validation macros for single entry/single exit functions
//** uses a goto instead of return
#define VDATEPTRIN_LABEL(pv, TYPE, label, retVar) \
        if (!IsValidPtrIn((pv), sizeof(TYPE))) \
        { retVar = (VdateAssert(pv, "Invalid in ptr"), ResultFromScode(E_INVALIDARG)); \
         goto label; }
#define GEN_VDATEPTRIN_LABEL(pv, TYPE, retval, label, retVar) \
        if (!IsValidPtrIn((pv), sizeof(TYPE))) \
        { retVar = (VdateAssert(pv, "Invalid in ptr"), retval); \
         goto label; }
#define VOID_VDATEPTRIN_LABEL(pv, TYPE, label) \
        if (!IsValidPtrIn((pv), sizeof(TYPE))) \
        { VdateAssert(pv, "Invalid in ptr"); goto label; }


//** READ POINTER IN validation macros:
#define VDATEREADPTRIN( pv, TYPE ) \
        if (!IsValidReadPtrIn( (pv), sizeof(TYPE))) \
    return (VdateAssert(pv,"Invalid in read ptr"),ResultFromScode(E_INVALIDARG))
#define GEN_VDATEREADPTRIN( pv, TYPE, retval) \
        if (!IsValidReadPtrIn( (pv), sizeof(TYPE))) \
    return (VdateAssert(pv,"Invalid in read ptr"), retval)
#define VOID_VDATEREADPTRIN( pv, TYPE ) \
        if (!IsValidReadPtrIn( (pv), sizeof(TYPE))) {\
    VdateAssert(pv,"Invalid in read ptr"); return; }

//** READ POINTER IN validation macros for single entry/single exit functions
//** uses a goto instead of return
#define VDATEREADPTRIN_LABEL(pv, TYPE, label, retVar) \
        if (!IsValidReadPtrIn((pv), sizeof(TYPE))) \
        { retVar = (VdateAssert(pv, "Invalid in read ptr"), ResultFromScode(E_INVALIDARG)); \
         goto label; }
#define GEN_VDATEREADPTRIN_LABEL(pv, TYPE, retval, label, retVar) \
        if (!IsValidReadPtrIn((pv), sizeof(TYPE))) \
        { retVar = (VdateAssert(pv, "Invalid in read ptr"), retval); \
         goto label; }
#define VOID_VDATEREADPTRIN_LABEL(pv, TYPE, label) \
        if (!IsValidReadPtrIn((pv), sizeof(TYPE))) \
        { VdateAssert(pv, "Invalid in read ptr"); goto label; }

//** READ POINTER IN validation macros for single entry/single exit functions
//** uses a goto instead of return and a byte count instead of a TYPE
#define VDATESIZEREADPTRIN_LABEL(pv, cb, label, retVar) \
        if (!IsValidReadPtrIn((pv), cb)) \
        { retVar = (VdateAssert(pv, "Invalid in read ptr"), ResultFromScode(E_INVALIDARG)); \
         goto label; }
#define GEN_VDATESIZEREADPTRIN_LABEL(pv, cb, retval, label, retVar) \
        if (!IsValidReadPtrIn((pv), cb)) \
        { retVar = (VdateAssert(pv, "Invalid in read ptr"), retval); \
         goto label; }
#define VOID_VDATESIZEREADPTRIN_LABEL(pv, cb, label) \
        if (!IsValidReadPtrIn((pv), cb)) \
        { VdateAssert(pv, "Invalid in read ptr"); goto label; }


//** POINTER OUT validation macros:
#define VDATEPTROUT( pv, TYPE ) \
        if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
    return (VdateAssert(pv,"Invalid out ptr"),ResultFromScode(E_INVALIDARG))
#define GEN_VDATEPTROUT( pv, TYPE, retval ) \
        if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
    return (VdateAssert(pv,"Invalid out ptr"), retval)

//** POINTER OUT validation macros for single entry/single exit functions
//** uses a goto instead of return
#define VDATEPTROUT_LABEL( pv, TYPE, label, retVar ) \
        if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
        { retVar = (VdateAssert(pv,"Invalid out ptr"),ResultFromScode(E_INVALIDARG)); \
         goto label; }
#define GEN_VDATEPTROUT_LABEL( pv, TYPE, retval, label, retVar ) \
        if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
        { retVar = (VdateAssert(pv,"Invalid out ptr"),retval); \
         goto label; }

//** POINTER OUT validation macros for single entry/single exit functions
//** uses a goto instead of return and a byte count instead of a TYPE
#define VDATESIZEPTROUT_LABEL(pv, cb, label, retVar) \
        if (!IsValidPtrOut((pv), cb)) \
        { retVar = (VdateAssert(pv, "Invalid out ptr"), ResultFromScode(E_INVALIDARG)); \
         goto label; }
#define GEN_VDATESIZEPTROUT_LABEL(pv, cb, retval, label, retVar) \
        if (!IsValidPtrOut((pv), cb)) \
        { retVar = (VdateAssert(pv, "Invalid out ptr"), retval); \
         goto label; }


//** POINTER is NULL validation macros
#define VDATEPTRNULL_LABEL(pv, label, retVar) \
        if ((pv) != NULL) \
        { retVar = (VdateAssert(pv, "Ptr should be NULL"), ResultFromScode(E_INVALIDARG)); \
         goto label; }
#define GEN_VDATEPTRNULL_LABEL(pv, retval, label, retVar) \
        if ((pv) != NULL) \
        { retVar = (VdateAssert(pv, "Ptr should be NULL"), retval); \
         goto label; }

//** INTERFACE validation macro:
#define GEN_VDATEIFACE( pv, retval ) \
        if (!IsValidInterface(pv)) \
    return (VdateAssert(pv,"Invalid interface"), retval)
#define VDATEIFACE( pv ) \
        if (!IsValidInterface(pv)) \
    return (VdateAssert(pv,"Invalid interface"),ResultFromScode(E_INVALIDARG))
#define VOID_VDATEIFACE( pv ) \
        if (!IsValidInterface(pv)) {\
    VdateAssert(pv,"Invalid interface"); return; }

//** INTERFACE validation macros for single entry/single exit functions
//** uses a goto instead of return
#define GEN_VDATEIFACE_LABEL( pv, retval, label, retVar ) \
        if (!IsValidInterface(pv)) \
        { retVar = (VdateAssert(pv,"Invalid interface"),retval); \
         goto label; }
#define VDATEIFACE_LABEL( pv, label, retVar ) \
        if (!IsValidInterface(pv)) \
        { retVar = (VdateAssert(pv,"Invalid interface"),ResultFromScode(E_INVALIDARG)); \
         goto label; }
#define VOID_VDATEIFACE_LABEL( pv, label ) \
        if (!IsValidInterface(pv)) {\
        VdateAssert(pv,"Invalid interface"); goto label; }

//** INTERFACE ID validation macro:
// Only do this in debug build
#define VDATEIID( iid ) if (!IsValidIid( iid )) \
    return (VdateAssert(iid,"Invalid iid"),ResultFromScode(E_INVALIDARG))
#define GEN_VDATEIID( iid, retval ) if (!IsValidIid( iid )) {\
    VdateAssert(iid,"Invalid iid"); return retval; }

//** INTERFACE ID validation macros for single entry/single exit functions
//** uses a goto instead of return
#define VDATEIID_LABEL( iid, label, retVar ) if (!IsValidIid( iid )) \
        {retVar = (VdateAssert(iid,"Invalid iid"),ResultFromScode(E_INVALIDARG)); \
         goto label; }
#define GEN_VDATEIID_LABEL( iid, retval, label, retVar ) if (!IsValidIid( iid )) {\
        VdateAssert(iid,"Invalid iid"); retVar = retval;  goto label; }


#else // _DEBUG


#define VdateAssert(exp, msg)	((void)0)

//  --assertless macros for non-debug case
//** POINTER IN validation macros:
#define VDATEPTRIN( pv, TYPE ) if (!IsValidPtrIn( (pv), sizeof(TYPE))) \
    return (ResultFromScode(E_INVALIDARG))
#define GEN_VDATEPTRIN( pv, TYPE, retval ) if (!IsValidPtrIn( (pv), sizeof(TYPE))) \
    return (retval)
#define VOID_VDATEPTRIN( pv, TYPE ) if (!IsValidPtrIn( (pv), sizeof(TYPE))) {\
    return; }

//** POINTER IN validation macros for single entry/single exit functions
//** uses a goto instead of return
#define VDATEPTRIN_LABEL(pv, TYPE, label, retVar) \
        if (!IsValidPtrIn((pv), sizeof(TYPE))) \
        { retVar = ResultFromScode(E_INVALIDARG); \
         goto label; }
#define GEN_VDATEPTRIN_LABEL(pv, TYPE, retval, label, retVar) \
        if (!IsValidPtrIn((pv), sizeof(TYPE))) \
        { retVar = retval; \
         goto label; }
#define VOID_VDATEPTRIN_LABEL(pv, TYPE, label) \
        if (!IsValidPtrIn((pv), sizeof(TYPE))) \
        { goto label; }

//** POINTER IN validation macros:
#define VDATEREADPTRIN( pv, TYPE ) if (!IsValidReadPtrIn( (pv), sizeof(TYPE))) \
    return (ResultFromScode(E_INVALIDARG))
#define GEN_VDATEREADPTRIN( pv, TYPE, retval ) if (!IsValidReadPtrIn( (pv), sizeof(TYPE))) \
    return (retval)
#define VOID_VDATEREADPTRIN( pv, TYPE ) if (!IsValidReadPtrIn( (pv), sizeof(TYPE))) {\
    return; }

//** POINTER IN validation macros for single entry/single exit functions
//** uses a goto instead of return
#define VDATEREADPTRIN_LABEL(pv, TYPE, label, retVar) \
        if (!IsValidReadPtrIn((pv), sizeof(TYPE))) \
        { retVar = ResultFromScode(E_INVALIDARG); \
         goto label; }
#define GEN_VDATEREADPTRIN_LABEL(pv, TYPE, retval, label, retVar) \
        if (!IsValidReadPtrIn((pv), sizeof(TYPE))) \
        { retVar = retval; \
         goto label; }
#define VOID_VDATEREADPTRIN_LABEL(pv, TYPE, label) \
        if (!IsValidReadPtrIn((pv), sizeof(TYPE))) \
        { goto label; }

//** READ POINTER IN validation macros for single entry/single exit functions
//** uses a goto instead of return and a byte count instead of a TYPE
#define VDATESIZEREADPTRIN_LABEL(pv, cb, label, retVar) \
        if (!IsValidReadPtrIn((pv), cb)) \
        { retVar = ResultFromScode(E_INVALIDARG); \
         goto label; }
#define GEN_VDATESIZEREADPTRIN_LABEL(pv, cb, retval, label, retVar) \
        if (!IsValidReadPtrIn((pv), cb)) \
        { retVar = retval; \
         goto label; }
#define VOID_VDATESIZEREADPTRIN_LABEL(pv, cb, label) \
        if (!IsValidReadPtrIn((pv), cb)) \
        { goto label; }


//** POINTER OUT validation macros:
#define VDATEPTROUT( pv, TYPE ) if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
    return (ResultFromScode(E_INVALIDARG))

#define GEN_VDATEPTROUT( pv, TYPE, retval ) if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
    return (retval)

//** POINTER OUT validation macros for single entry/single exit functions
//** uses a goto instead of return
#define VDATEPTROUT_LABEL( pv, TYPE, label, retVar ) \
        if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
        { retVar = ResultFromScode(E_INVALIDARG); \
         goto label; }
#define GEN_VDATEPTROUT_LABEL( pv, TYPE, retval, label, retVar ) \
        if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
        { retVar = retval; \
         goto label; }

//** POINTER OUT validation macros for single entry/single exit functions
//** uses a goto instead of return and a byte count instead of a TYPE
#define VDATESIZEPTROUT_LABEL(pv, cb, label, retVar) \
        if (!IsValidPtrOut((pv), cb)) \
        { retVar = ResultFromScode(E_INVALIDARG); \
         goto label; }
#define GEN_VDATESIZEPTROUT_LABEL(pv, cb, retval, label, retVar) \
        if (!IsValidPtrOut((pv), cb)) \
        { retVar = retval; \
         goto label; }


//** POINTER is NULL validation macros
#define VDATEPTRNULL_LABEL(pv, label, retVar) \
        if ((pv) != NULL) \
        { retVar = ResultFromScode(E_INVALIDARG); \
         goto label; }
#define GEN_VDATEPTRNULL_LABEL(pv, retval, label, retVar) \
        if ((pv) != NULL) \
        { retVar = retval; \
         goto label; }

//** INTERFACE validation macro:
#define VDATEIFACE( pv ) if (!IsValidInterface(pv)) \
    return (ResultFromScode(E_INVALIDARG))
#define VOID_VDATEIFACE( pv ) if (!IsValidInterface(pv)) \
    return;
#define GEN_VDATEIFACE( pv, retval ) if (!IsValidInterface(pv)) \
    return (retval)

//** INTERFACE validation macros for single entry/single exit functions
//** uses a goto instead of return
#define GEN_VDATEIFACE_LABEL( pv, retval, label, retVar ) \
        if (!IsValidInterface(pv)) \
        { retVar = retval; \
         goto label; }
#define VDATEIFACE_LABEL( pv, label, retVar ) \
        if (!IsValidInterface(pv)) \
        { retVar = ResultFromScode(E_INVALIDARG); \
         goto label; }
#define VOID_VDATEIFACE_LABEL( pv, label ) \
        if (!IsValidInterface(pv)) {\
         goto label; }

//** INTERFACE ID validation macro:
// do not do in retail build. This code USED to call a bogus version of
// IsValidIID that did no work. Now we are faster and no less stable than before.
#define VDATEIID( iid )             ((void)0)
#define GEN_VDATEIID( iid, retval ) ((void)0);

//** INTERFACE ID validation macros for single entry/single exit functions
//** uses a goto instead of return
#define VDATEIID_LABEL( iid, label, retVar ) if (!IsValidIid( iid )) \
        {retVar = ResultFromScode(E_INVALIDARG); \
         goto label; }
#define GEN_VDATEIID_LABEL( iid, retval, label, retVar ) if (!IsValidIid( iid )) {\
        retVar = retval;  goto label; }

#endif

#endif // __IH_VALID_H__


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ih\utils.h ===
//+----------------------------------------------------------------------------
//
//	File:
//		utils.h
//
//	Contents:
//		prototypes and constants for OLE internal utility routines
//
//	Classes:
//
//	Functions:
//
//	History:
//		11/28/93 - ChrisWe - file inspection and cleanup begins
//		11/29/93 - ChrisWe - remove signature for non-existent
//			function UtGlobalHandlCpy; moved manifest constants
//			to be with functions they are used with (OPCODE_*,
//			CONVERT_*); removed default parameters from functions;
//			replace '!' with '~' in STREAMTYPE_OTHER definition
//		04/07/94 - AlexGo  - added UtCreateStorageOnHGlobal
//
//-----------------------------------------------------------------------------

#ifndef _UTILS_H_
#define _UTILS_H_

// We need to serialize the placeable metafile structure in the same format
// that was used by WIN16, since RECT used LONGs under Win32.
// We ensure that no padding is added by using the #pragma pack() calls.

#pragma pack(1)
typedef struct tagWIN16RECT
{
	WORD left;
	WORD top;
	WORD right;
	WORD bottom;
} WIN16RECT;

typedef struct tagPLACEABLEMETAHEADER
{
	DWORD key;	/* must be PMF_KEY */
#define PMF_KEY 0x9ac6cdd7
	WORD hmf;	/* must be zero */
	WIN16RECT bbox;	/* bounding rectangle of the metafile */
	WORD inch;	/* # of metafile units per inch must be < 1440 */
			/* most apps use 576 or 1000 */
	DWORD reserved;	/* must be zero */
	WORD checksum;
} PLACEABLEMETAHEADER;
#pragma pack()

//+-------------------------------------------------------------------------
//
//  Function:   UtGetUNICODEData, PRIVATE INTERNAL
//
//  Synopsis:   Given a string length, and two pointers (one ANSI, one
//              OLESTR), returns the UNICODE version of whichever string
//              is valid.
//
//  Effects:    Memory is allocated on the caller's pointer for new OLESTR
//
//  Arguments:  [ulLength]      -- length of string in CHARACTERS (not bytes)
//                                 (including terminator)
//              [szANSI]        -- candidate ANSI string
//              [szOLESTR]      -- candidate OLESTR string
//              [pstr]          -- OLESTR OUT parameter
//
//  Returns:    NOERROR              on success
//              E_OUTOFMEMORY        on allocation failure
//              E_ANSITOUNICODE      if ANSI cannot be converted to UNICODE
//
//  Algorithm:  If szOLESTR is available, a simple copy is performed
//              If szOLESTR is not available, szANSI is converted to UNICODE
//              and the result is copied.
//
//  History:    dd-mmm-yy Author    Comment
//              08-Mar-94 davepl    Created
//
//  Notes:      Only one of the two input strings (ANSI or UNICODE) should
//              be set on entry.
//
//--------------------------------------------------------------------------

INTERNAL UtGetUNICODEData( ULONG, LPSTR, LPOLESTR, LPOLESTR *);


//+-------------------------------------------------------------------------
//
//  Function:   UtPutUNICODEData, PRIVATE INTERNAL
//
//  Synopsis:   Given an OLESTR and two possible buffer pointer, one ANSI
//              and the other OLESTR, this fn tries to convert the string
//              down to ANSI.  If it succeeds, it allocates memory on the
//              ANSI ptr for the result.  If it fails, it allocates memory
//              on the UNICODE ptr and copies the input string over.  The
//              length of the final result (ANSI or UNICODE) is returned
//              in dwResultLen.
//
//  Arguments:  [ulLength]      -- input length of OLESTR str
//              [str]           -- the OLESTR to store
//              [pszANSI]       -- candidate ANSI str ptr
//              [pszOLESTR]     -- candidate OLESTR str ptr
//              [pdwResultLen]  -- where to store the length of result
//
//  Returns:    NOERROR              on success
//              E_OUTOFMEMORY        on allocation failure
//
//  History:    dd-mmm-yy Author    Comment
//              08-Mar-94 davepl    Created
//
//--------------------------------------------------------------------------

INTERNAL UtPutUNICODEData(
      ULONG        ulLength,
      LPOLESTR     str,
      LPSTR      * pszANSI,
      LPOLESTR   * pszOLESTR,
      DWORD      * pdwResultLen );

//+----------------------------------------------------------------------------
//
//	Function:
//		UtDupGlobal, internal
//
//	Synopsis:
//		Duplicate the contents of an HGlobal into a new HGlobal.  If
//		there is no allocated memory, no new global is allocated.
//
//	Arguments:
//		[hsrc] -- the source HGLobal; need not be locked
//		[uiFlags] -- flags to be passed on to GlobalAlloc()
//
//	Returns:
//		The new HGLOBAL, if successful, or NULL
//
//	History:
//		11/28/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL_(HANDLE) UtDupGlobal(HANDLE hSrc, UINT uiFlags);


//+----------------------------------------------------------------------------
//
//	Function:
//		UtIsFormatSupported, internal
//
//	Synopsis:
//		Checks a data object to see if it will accept
//		IDataObject::SetData() and/or IDataObject::GetData() calls
//		on the specified format.  The direction of transfer is specified
//		with the dwDirection flags.  The function returns TRUE only
//		if all requested transfers are possible.
//
//	Arguments:
//		[lpObj] -- the data object to check for the format
//		[dwDirection] -- a combination of values from DATADIR_*
//		[cfFormat] -- the format to look for
//
//	Returns:
//		TRUE, if transfers of [cfFormat] are supported in [dwDirection],
//		FALSE otherwise
//
//	Notes:
//
//	History:
//		11/29/93 - ChrisWe - file inspection and cleanup; noted that
//			enumerators are expected to be able to return
//			formats for multiple DATADIR_* flags
//
//-----------------------------------------------------------------------------
FARINTERNAL_(BOOL) UtIsFormatSupported(LPDATAOBJECT lpObj, DWORD dwDirection,
		CLIPFORMAT cfFormat);


//+----------------------------------------------------------------------------
//
//	Function:
//		UtDupString, internal
//
//	Synopsis:
//		Copies the argument string into a new string allocated
//		using the task allocator
//
//	Arguments:
//		[lpszIn] -- the string to duplicate
//
//	Returns:
//		a pointer to a copy of [lpszIn], or NULL if the allocator
//		could not be acquired, or was out of memory
//
//	History:
//		11/28/93 - ChrisWe - file cleanup and inspection
//
//-----------------------------------------------------------------------------
FARINTERNAL_(LPOLESTR) UtDupString(LPCOLESTR lpszIn);

//+-------------------------------------------------------------------------
//
//  Function:  	utGetProtseqFromTowerId
//
//  Synopsis: 	Get protseq string from DCE TowerID 
//
//  Effects:
//
//  Arguments: 	[wTowerId]	-- TowerID to retrieve
//
//  Returns:	protseq string - NULL if not found
//
//  History:    dd-mmm-yy Author    Comment
//              28-Oct-96   t-KevinH	Created as findProtseq
//              06-Feb-97   Ronans      Converted to utility fn
//
//--------------------------------------------------------------------------
FARINTERNAL_(LPCWSTR) utGetProtseqFromTowerId(USHORT wTowerId);

//+-------------------------------------------------------------------------
//
//  Function:  	utGetTowerId
//
//  Synopsis: 	Get DCE TowerId for protseq string
//
//  Effects:
//
//  Arguments: 	[pwszProtseq]	-- string to look up
//
//  Returns:	protseq string - NULL if not found
//
//  History:    dd-mmm-yy Author    Comment
//              28-Oct-96   t-KevinH	Created as findProtseq
//              06-Feb-97   Ronans      Converted to utility fn
//
//--------------------------------------------------------------------------
FARINTERNAL_(USHORT) utGetTowerId(LPCWSTR pwszProtseq);


//+-------------------------------------------------------------------------
//
//  Function: 	UtDupStringA
//
//  Synopsis: 	Duplicates an ANSI string using the TASK allocator
//
//  Effects:
//
//  Arguments:	[pszAnsi]	-- the string to duplicate
//
//  Requires:
//
//  Returns:	the newly allocated string duplicate or NULL
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//  		04-Jun-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

LPSTR UtDupStringA( LPCSTR pszAnsi );

//+----------------------------------------------------------------------------
//
//	Function:
//		UtCopyFormatEtc, internal
//
//	Synopsis:
//		Copies a format etc, creating copies of data structures
//		pointed to inside (the target device descriptor.)
//
//	Arguments:
//		[pFetcIn] -- pointer to the FORMATETC to copy
//		[pFetcCopy] -- pointer to where to copy the FORMATETC to
//
//	Returns:
//		FALSE if pointed to data could not be copied because it
//			could not be allocated
//		TRUE otherwise
//
//	Notes:
//
//	History:
//		11/01/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL_(BOOL) UtCopyFormatEtc(FORMATETC FAR* pFetcIn,
		FORMATETC FAR* pFetcCopy);


//+----------------------------------------------------------------------------
//
//	Function:
//		UtCompareFormatEtc, internal
//
//	Synopsis:
//
//	Arguments:
//		[pFetcLeft] -- pointer to a FORMATETC
//		[pFetcRight] -- pointer to a FORMATETC
//
//	Returns:
//		UTCMPFETC_EQ is the two FORMATETCs match exactly
//		UTCMPFETC_NEQ if the two FORMATETCs do not match
//		UTCMPFETC_PARTIAL if the left FORMATETC is a subset of the
//			right: fewer aspects, null target device, or
//			fewer media
//
//	Notes:
//
//	History:
//		11/01/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL_(int) UtCompareFormatEtc(FORMATETC FAR* pFetcLeft,
		FORMATETC FAR* pFetcRight);
#define UTCMPFETC_EQ 0		/* exact match */
#define UTCMPFETC_NEQ 1		/* no match */
#define UTCMPFETC_PARTIAL (-1)	/* partial match; left is subset of right */


//+----------------------------------------------------------------------------
//
//	Function:
//		UtCompareTargetDevice, internal
//
//	Synopsis:
//		Compares two target devices to see if they are the same
//
//	Arguments:
//		[ptdLeft] -- pointer to a target device description
//		[ptdRight] -- pointer to a target device description
//
//	Returns:
//		TRUE if the two devices are the same, FALSE otherwise
//
//	Notes:
//
//	History:
//		11/01/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL_(BOOL) UtCompareTargetDevice(DVTARGETDEVICE FAR* ptdLeft,
		DVTARGETDEVICE FAR* ptdRight);


//+----------------------------------------------------------------------------
//
//	Function:
//		UtCopyStatData, internal
//
//	Synopsis:
//		Copies the contents of one STATDATA into another, including
//		creating a copy of data pointed to, and incrementing the
//		reference count on the advise sink to reflect the copy.
//
//	Arguments:
//		[pSDIn] -- the source STATDATA
//		[pSDCopy] -- where to copy the information to
//
//	Returns:
//		FALSE if memory could not be allocated for the copy of
//		the target device, TRUE otherwise
//
//	Notes:
//
//	History:
//		11/01/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL_(BOOL) UtCopyStatData(STATDATA FAR* pSDIn, STATDATA FAR* pSDCopy);


//+----------------------------------------------------------------------------
//
//	Function:
//		UtReleaseStatData, internal
//
//	Synopsis:
//		Release resources associated with the argument STATDATA; this
//		frees the device description within the FORMATETC, and releases
//		the advise sink, if there is one.
//
//	Arguments:
//		[pStatData] -- The STATDATA to clean up
//
//	Notes:
//
//	History:
//		11/01/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL_(void) UtReleaseStatData(STATDATA FAR* pStatData);


//+----------------------------------------------------------------------------
//
//	Function:
//		UtDupPalette, internal
//
//	Synopsis:
//		Creates a duplicate palette.
//
//	Arguments:
//		[hpalette] -- the palette to duplicate
//
//	Returns:
//		if successful, a handle to the duplicate palette; if any
//		allocations or calls fail during the duplication process, NULL
//
//	History:
//		11/29//93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL_(HPALETTE) UtDupPalette(HPALETTE hpalette);


//+----------------------------------------------------------------------------
//
//	Function:
//		UtPaletteSize, internal
//
//	Synopsis:
//		Returns the size of a color table for a palette given the
//		number of bits of color desired.
//
//	Arguments:
//		[lpHeader] -- ptr to BITMAPINFOHEADER structure
//
//	Returns:
//		Size in bytes of color information
//
//	Notes:
//
//	History:
//		11/29/93 - ChrisWe - change bit count argument to unsigned,
//			and return value to size_t
//
//		07/18/94 - DavePl - Fixed for 16, 24, 32bpp DIBs
//
//-----------------------------------------------------------------------------
FARINTERNAL_(size_t) UtPaletteSize(BITMAPINFOHEADER *);


//+----------------------------------------------------------------------------
//
//	Function:
//		UtFormatToTymed, internal
//
//	Synopsis:
//		Maps a clipboard format to a medium used to transport it.
//
//	Arguments:
//		[cf] -- the clipboard format to map
//
//	Returns:
//		a TYMED_* value
//
//	Notes:
//
//	History:
//		11/29/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL_(DWORD) UtFormatToTymed(CLIPFORMAT cf);


//+----------------------------------------------------------------------------
//
//	Function:
//		UtQueryPictFormat, internal
//
//	Synopsis:
//		Check to see if the argument data object supports one of
//		our preferred data formats for presentations:
//		CF_METAFILEPICT, CF_DIB, CF_BITMAP, in that order.  Returns
//		TRUE, if success, and alters the given format descriptor
//		to match the supported format.  The given format descriptor
//		is not altered if there is no match.
//
//	Arguments:
//		[lpSrcDataObj] -- the data object to query
//		[lpforetc] - the format descriptor
//
//	Returns:
//		TRUE if a preferred format is found, FALSE otherwise
//
//	Notes:
//
//	History:
//		11/09/93 - ChrisWe - modified to not alter the descriptor
//			if no match is found
//		11/09/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL_(BOOL) UtQueryPictFormat(LPDATAOBJECT lpSrcDataObj,
		LPFORMATETC lpforetc);
								

//+----------------------------------------------------------------------------
//
//	Function:
//		UtConvertDibToBitmap, internal
//
//	Synopsis:
//		Converts a DIB to a bitmap, returning a new handle to the
//		bitmap.  The original DIB is left untouched.
//
//	Arguments:
//		[hDib] -- handle to the DIB to convert
//
//	Returns:
//		if successful, and handle to the new bitmap
//
//	Notes:
//		REVIEW, the function uses the screen DC when creating the
//		new bitmap.  It may be the case that the bitmap was intended
//		for another target, in which case this may not be appropriate.
//		It may be necessary to alter this function to take a DC as
//		an argument.
//
//	History:
//		11/29/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL_(HBITMAP) UtConvertDibToBitmap(HANDLE hDib);


//+----------------------------------------------------------------------------
//
//	Function:
//		UtConvertBitmapToDib, internal
//
//	Synopsis:
//		Creates a Device Independent Bitmap capturing the content of
//		the argument bitmap.
//
//	Arguments:
//		[hBitmap] -- Handle to the bitmap to convert
//		[hpal] -- color palette for the bitmap; may be null for
//			default stock palette
//
//	Returns:
//		Handle to the DIB.  May be null if any part of the conversion
//		failed.
//
//	Notes:
//
//	History:
//		11/29/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL_(HANDLE) UtConvertBitmapToDib(HBITMAP hBitmap, HPALETTE hpal);


//+----------------------------------------------------------------------------
//
//	Function:
//		UtGetClassId, internal
//
//	Synopsis:
//		Attempt to find the class id of the object.  First,
//		query for IOleObject, and if successful, call
//		IOleObject::GetUserClassID().  If that fails, query for
//		IPersist, and if successful, call IPersist::GetClassID.
//
//	Arguments:
//		[lpUnk] -- pointer to an IUnknown instance
//		[lpClsid] -- pointer to where to copy the class id to
//
//	Returns:
//		TRUE, if the class id was obtained, or FALSE otherwise
//		If unsuccessful, *[lpClsid] is set to CLSID_NULL
//
//	Notes:
//
//	History:
//		11/29/93 - ChrisWe - change to return BOOL to indicate success
//
//-----------------------------------------------------------------------------
FARINTERNAL_(BOOL) UtGetClassID(LPUNKNOWN lpUnk, CLSID FAR* lpClsid);


//+----------------------------------------------------------------------------
//
//	Function:
//		UtCopyTargetDevice, internal
//
//	Synopsis:
//		Allocates a new target device description, and copies
//		the given one into it
//
//	Arguments:
//		[ptd] -- pointer to a target device
//
//	Returns:
//		NULL, if the no memory can be allocated
//
//	Notes:
//
//	History:
//		11/01/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL_(DVTARGETDEVICE FAR*) UtCopyTargetDevice(DVTARGETDEVICE FAR* ptd);


//+----------------------------------------------------------------------------
//
//	Function:
//		UtGetIconData, internal
//
//	Synopsis:
//		Attempts to get the icon for an object.
//
//	Arguments:
//		[lpSrcDataObj] -- The source data object
//		[rclsid] -- the class id the object is known to be
//			(may be CLSID_NULL)
//		[lpforetc] -- the format of the data to fetch
//		[lpstgmed] -- a place to return the medium it was fetched on
//
//	Returns:
//		E_OUTOFMEMORY, S_OK
//
//	Notes:
//		REVIEW, this method seems to assume that the contents of
//		lpforetc are correct for fetching an icon.  It passes this
//		on to [lpSrcDataObj]->GetData first, and if that fails,
//		calls OleGetIconOfClass, without checking the requested
//		format in lpforetc.  This could fetch anything
//
//	History:
//		11/30/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL UtGetIconData(LPDATAOBJECT lpSrcDataObj, REFCLSID rclsid,
		LPFORMATETC lpforetc, LPSTGMEDIUM lpstgmed);


//+----------------------------------------------------------------------------
//
//	Function:
//		UtDoStreamOperation, internal
//
//	Synopsis:
//		Iterate over the streams in [pstgSrc], performing the
//		operation indicated by [iOpCode] to those that are specified
//		by [grfAllowedStmTypes].
//
//	Arguments:
//		[pstgSrc] -- source IStorage instance
//		[pstgDst] -- destination IStorage instance; may be null for
//			some operations (OPCODE_REMOVE)
//		[iOpCode] -- 1 value from the OPCODE_* values below
//		[grfAllowedStmTypes] -- a logical or of one or more of the
//			STREAMTYPE_* values below
//
//	Returns:
//		HRESULT
//
//	Notes:
//
//	History:
//		11/30/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
STDAPI UtDoStreamOperation(LPSTORAGE pstgSrc, LPSTORAGE pstgDst,
		int iOpCode, DWORD grfAllowedStmTypes);

#define OPCODE_COPY		1 /* copy the stream from pstgSrc to pstgDst */
#define OPCODE_REMOVE		2 /* delete the stream from pstgSrc */
#define OPCODE_MOVE		3 /* move the stream from pstgSrc to pstgDst */
#define OPCODE_EXCLUDEFROMCOPY	4
		 /* unimplemented, undocumented, intent unknown */

#define	STREAMTYPE_CONTROL	0x00000001 /* OLE 0x1 stream (REVIEW const) */
#define	STREAMTYPE_CACHE	0x00000002 /* OLE 0x2 stream (REVIEW const) */
#define	STREAMTYPE_CONTAINER	0x00000004 /* OLE 0x3 stream (REVIEW const) */
#define STREAMTYPE_OTHER \
	(~(STREAMTYPE_CONTROL | STREAMTYPE_CACHE | STREAMTYPE_CONTAINER))
#define	STREAMTYPE_ALL		0xFFFFFFFF /* all stream types are allowed */


//+----------------------------------------------------------------------------
//
//	Function:
//		UtGetPresStreamName, internal
//
//	Synopsis:
//		Modify [lpszName] to be a presentation stream name based
//		on [iStreamNum].
//
//	Arguments:
//		[lpszName] -- a copy of OLE_PRESENTATION_STREAM; see below
//		[iStreamNum] -- the number of the stream
//
//	Notes:
//		The digit field of [lpszName] is always completely overwritten,
//		allowing repeated use of UtGetPresStreamName() on the same
//		string; this removes the need to repeatedly start with a fresh
//		copy of	OLE_PRESENTATION_STREAM each time this is used in a
//		loop.
//
//		The validity of the implementation depends on the values of
//		OLE_PRESENTATION_STREAM and OLE_MAX_PRES_STREAMS; if those
//		change, the implementation must change
//
//	History:
//		11/30/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL_(void)UtGetPresStreamName(LPOLESTR lpszName, int iStreamNum);


//+----------------------------------------------------------------------------
//
//	Function:
//		UtRemoveExtraOlePresStreams, internal
//
//	Synopsis:
//		Deletes presentation streams in [pstg] starting with the
//		presentation numbered [iStart].  All streams after that one
//		(numbered sequentially) are deleted, up to OLE_MAX_PRES_STREAMS.
//
//	Arguments:
//		[pstg] -- the IStorage instance to operate on
//		[iStart] -- the number of the first stream to remove
//
//	Returns:
//
//	Notes:
//		The presentation stream names are generated with
//		UtGetPresStreamName().
//
//	History:
//		11/30/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL_(void) UtRemoveExtraOlePresStreams(LPSTORAGE pstg, int iStart);

//+-------------------------------------------------------------------------
//
//  Function:	UtCreateStorageOnHGlobal
//
//  Synopsis:	creates a storage on top of an HGlobal
//
//  Effects:
//
//  Arguments: 	[hGlobal]	-- the memory on which to create the
//				   storage
//		[fDeleteOnRelease]	-- if TRUE, then delete the memory
//					   ILockBytes once the storage is
//					   released.
//		[ppStg]		-- where to put the storage interface
//		[ppILockBytes]	-- where to put the underlying ILockBytes,
//				   maybe NULL.  The ILB must be released.
//
//  Requires:
//
//  Returns: 	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:	create an ILockBytes on HGLOBAL and then create the docfile
//		on top of the ILockBytes
//
//  History:    dd-mmm-yy Author    Comment
//  		07-Apr-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT UtCreateStorageOnHGlobal( HGLOBAL hGlobal, BOOL fDeleteOnRelease,
		IStorage **ppStg, ILockBytes **ppILockBytes );


//+-------------------------------------------------------------------------
//
//  Function: 	UtGetTempFileName
//
//  Synopsis:	retrieves a temporary filename (for use in GetData, TYMED_FILE
//		and temporary docfiles)
//
//  Effects:
//
//  Arguments: 	[pszPrefix]	-- prefix of the temp filename
//		[pszTempName]	-- buffer that will receive the temp path.
//				   must be MAX_PATH or greater.
//
//  Requires:
//
//  Returns:	HRESULT;
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:	tries to get a file in the temp directory, failing that, in
//		the windows directory
//
//  History:    dd-mmm-yy Author    Comment
// 		07-Apr-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT	UtGetTempFileName( LPOLESTR pszPrefix, LPOLESTR pszTempName );
							

//+----------------------------------------------------------------------------
//
//	Function:
//		UtHGLOBALToStm, internal
//
//	Synopsis:
//		Write the contents of an HGLOBAL to a stream
//
//	Arguments:
//		[hdata] -- handle to the data to write out
//		[dwSize] -- size of the data to write out
//		[pstm] -- stream to write the data out to;  on exit, the
//			stream is positioned after the written data
//
//	Returns:
//		HRESULT
//
//	Notes:
//
//	History:
//		11/30/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
HRESULT UtHGLOBALtoStm(HANDLE hdata, DWORD dwSize, LPSTREAM pstm);

//+-------------------------------------------------------------------------
//
//  Function:	UtHGLOBALtoHGLOBAL, internal
//
//  Synopsis:	Copies the source HGLOBAL into the target HGLOBAL
//
//  Effects:
//
//  Arguments:	[hGlobalSrc] 	-- the source HGLOBAL
//		[dwSize] 	-- the number of bytes to copy
//		[hGlobalTgt] 	-- the target HGLOBAL
//
//  Requires:
//
//  Returns:	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
// 		10-Apr-94 alexgo    author
//
//  Notes: 	this function will fail if the target hglobal is not large
//		enough
//
//--------------------------------------------------------------------------

HRESULT UtHGLOBALtoHGLOBAL( HGLOBAL hGlobalSrc, DWORD dwSize,
		HGLOBAL hGlobalTgt);


//+-------------------------------------------------------------------------
//
//  Function:	UtHGLOBALtoStorage, internal
//
//  Synopsis:	Copies the source HGLOBAL into the target storage
//
//  Effects:
//
//  Arguments:	[hGlobalSrc] 	-- the source HGLOBAL
//		[hpStg] 		-- the target storage
//
//  Requires:
//
//  Returns:	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
// 		10-Apr-94 alexgo    author
//
//  Notes: 	this function will fail if the source HGLOBAL did not
//		originally have a storage layered on top of it.
//
//--------------------------------------------------------------------------

HRESULT UtHGLOBALtoStorage( HGLOBAL hGlobalSrc, IStorage *pStg);


//+-------------------------------------------------------------------------
//
//  Function:	UtHGLOBALtoFile, internal
//
//  Synopsis:	Copies the source HGLOBAL into the target file
//
//  Effects:
//
//  Arguments:	[hGlobalSrc] 	-- the source HGLOBAL
//		[dwSize] 	-- the number of bytes to copy
//		[pszFileName] 	-- the target file
//
//  Requires:
//
//  Returns:	HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
// 		10-Apr-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT UtHGLOBALtoFile( HGLOBAL hGlobalSrc, DWORD dwSize,
		LPCOLESTR pszFileName);


/*** Following routines can be found in convert.cpp *****/

//+----------------------------------------------------------------------------
//
//	Function:
//		UtGetHGLOBALFromStm, internal
//
//	Synopsis:
//		Create a new HGLOBAL, and read [dwSize] bytes into it
//		from [lpstream].
//
//	Arguments:
//		[lpstream] -- the stream to read the content of the new
//			HGLOBAL from;  on exit, points just past the data read
//		[dwSize] -- the amount of material to read from the stream
//		[lphPres] -- pointer to where to return the new handle
//
//	Returns:
//		HRESULT
//
//	Notes:
//		In case of any error, the new handle is freed.  If the
//		amount of material expected from [lpstream] is less than
//		[dwSize], nothing is returned.
//
//	History:
//		11/30/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL UtGetHGLOBALFromStm(LPSTREAM lpstream, DWORD dwSize,
		 HANDLE FAR* lphPres);


//+----------------------------------------------------------------------------
//
//	Function:
//		UtGetHDIBFromDIBFileStm, internal
//
//	Synopsis:
//		Produce a handle to a DIB from a file stream
//
//	Arguments:
//		[pstm] -- the stream to read the DIB from;  on exit, the
//			stream is positioned just past the data read
//		[lphdata] -- pointer to where to return the handle to the data
//
//	Returns:
//		HRESULT
//
//	Notes:
//
//	History:
//		11/30/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL UtGetHDIBFromDIBFileStm(LPSTREAM pstm, HANDLE FAR* lphdata);


//+----------------------------------------------------------------------------
//
//	Function:
//		UtGetHMFPICT, internal
//
//	Synopsis:
//		Given a handle to a METAFILE, conjure up a handle to a
//		METAFILEPICT, based on the metafile
//
//	Arguments:
//		[hMF] -- handle to the METAFILE
//		[fDeleteOnError] -- if TRUE, delete the METAFILE [hMF] in there
//			is any error
//		[xExt] -- the x extent of the desired METAFILEPICT
//		[yExt] -- the y extent of the desired METAFILEPICT
//
//	Returns:
//		Handle to the new METAFILEPICT, if successful, or NULL
//
//	Notes:
//
//	History:
//		11/30/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL_(HANDLE) UtGetHMFPICT(HMETAFILE hMF, BOOL fDeletOnError,
		DWORD xExt, DWORD yExt);


//+----------------------------------------------------------------------------
//
//	Function:
//		UtGetHMFFromMFStm, internal
//
//	Synopsis:
//		Create a handle to a METAFILE, loaded with content from
//		the given stream
//
//	Arguments:
//		[lpstream] -- the source stream to initialize the METAFILE with;
//			on exit, the stream is positioned just past the
//			data read
//		[dwSize] -- the amount of material to read from [lpstream]
//		[fConvert] -- if TRUE, tries to convert a Macintosh QuickDraw
//			file to METAFILE format
//		[lphPres] -- pointer to where to return the new handle to
//			the metafile
//
//	Returns:
//		HRESULT
//
//	Notes:
//		If [dwSize] is too large, and goes past the end of the
//		stream, the error causes everything allocated to be freed,
//		and nothing is returned in [lphPres].
//
//	History:
//		11/30/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL UtGetHMFFromMFStm(LPSTREAM lpstream, DWORD dwSize,
		BOOL fConvert, HANDLE FAR* lphPres);


//+----------------------------------------------------------------------------
//
//	Function:
//		UtGetSizeAndExtentsFromPlaceableMFStm, internal
//
//	Synopsis:
//		Obtain the size, width, and height of the metafile stored
//		in a placeable metafile stream.
//
//	Arguments:
//		[lpstream] -- the stream to read the placeable metafile
//			from;  on exit, the stream is positioned at the
//			beginning of the metafile header, after the
//			placeable metafile header.
//		[pdwSize] -- a pointer to where to return the size of the
//			metafile;  may be NULL
//		[plWidth] -- a pointer to where to return the width of the
//			metafile;  may be NULL
//		[plHeight] -- a pointer to where to return the height of the
//			metafile;  may be NULL
//
//	Returns:
//		HRESULT
//
//	Notes:
//
//	History:
//		11/30/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL UtGetSizeAndExtentsFromPlaceableMFStm(LPSTREAM pstm,
		DWORD FAR* dwSize, LONG FAR* plWidth, LONG FAR* plHeight);


//+----------------------------------------------------------------------------
//
//	Function:
//		UtGetHMFPICTFromPlaceableMFStm, internal
//
//	Synopsis:
//		Create a handle to a METAFILEPICT initialized from a
//		placeable METAFILE stream.
//
//	Arguments:
//		[pstm] -- the stream to load the METAFILE from; on exit
//			points just past the METAFILE data
//		[lphdata] -- pointer to where to return the handle to the
//			new METAFILEPICT
//
//	Returns:
//		HRESULT
//
//	Notes:
//
//	History:
//		11/30/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL UtGetHMFPICTFromPlaceableMFStm(LPSTREAM pstm, HANDLE FAR* lphdata);


//+----------------------------------------------------------------------------
//
//	Function:
//		UtGetDibExtents, internal
//
//	Synopsis:
//		Return the width and height of a DIB, in HIMETRIC units
//		per pixel.
//
//	Arguments:
//		[lpbmi] -- pointer to a BITMAPINFOHEADER
//		[plWidth] -- pointer to where to return the width
//			REVIEW, this should be a DWORD
//		[plHeight] -- pointer to where to return the height
//			REVIEW, this should be a DWORD
//
//	Notes:
//
//	History:
//		12/02/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL_(void) UtGetDibExtents(LPBITMAPINFOHEADER lpbmi,
		LONG FAR* plWidth, LONG FAR* plHeight);
#ifdef LATER
FARINTERNAL_(void) UtGetDibExtents(LPBITMAPINFOHEADER lpbmi,
		DWORD FAR* pdwWidth, DWORD FAR* pdwHeight);
#endif


//+----------------------------------------------------------------------------
//
//	Function:
//		UtHDIBToDIBFileStm, internal
//
//	Synopsis:
//		Given a handle to a DIB, write out out a DIB file stream.
//
//	Arguments:
//		[hdata] -- handle to the DIB
//		[dwSize] -- the size of the DIB
//		[pstm] -- the stream to write the DIB out to;  on exit, the
//			stream is positioned after the DIB data; the DIB
//			data is prepended with a BITMAPFILEHEADER
//
//	Returns:
//		HRESULT
//
//	Notes:
//
//	History:
//		12/02/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL UtHDIBToDIBFileStm(HANDLE hdata, DWORD dwSize, LPSTREAM pstm);


//+----------------------------------------------------------------------------
//
//	Function:
//		UtDIBStmToDIBFileStm, internal
//
//	Synopsis:
//		copy convert a DIB in a stream to a DIB file stream
//
//	Arguments:
//		[pstmDIB] -- the source DIB
//			REVIEW, what does CopyTo do to the stream pointer?
//		[dwSize] -- the size of the source DIB
//		[pstmDIBFile] -- where to write the converted DIB file stream;
//			should not be the same as [pstmDIB]; on exit, the
//			stream is positioned after the DIB file data
//
//	Returns:
//		HRESULT
//
//	Notes:
//
//	History:
//		12/02/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL UtDIBStmToDIBFileStm(LPSTREAM pstmDIB, DWORD dwSize,
		LPSTREAM pstmDIBFile);


//+----------------------------------------------------------------------------
//
//	Function:
//		UtHDIBFileToOlePresStm, internal
//
//	Synopsis:
//		Given a handle to a DIB file, write it out to a stream
//
//	Arguments:
//		[hdata] -- the handle to the DIB file
//		[pstm] -- the stream to write it out to;  on exit, the
//			stream is positioned after the written data
//
//	Returns:
//		HRESULT
//
//	Notes:
//		A small header with size information precedes the DIB file
//		data.
//
//	History:
//		12/02/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL UtHDIBFileToOlePresStm(HANDLE hdata, LPSTREAM pstm);


//+----------------------------------------------------------------------------
//
//	Function:
//		UtHMFToMFStm, internal
//
//	Synopsis:
//		Given a handle to a METAFILE, write it out to a METAFILE stream
//
//	Arguments:
//		[lphMF] -- a *pointer* to a handle to a METAFILE
//			REVIEW, why is this a pointer?
//		[dwSize] -- the size of the METAFILE
//		[lpstream] -- the stream to write the METAFILE out to;  on
//			exit, the stream is positioned after the written data
//
//	Returns:
//		HRESULT
//
//	Notes:
//
//	History:
//		12/02/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL UtHMFToMFStm(HANDLE FAR* lphMF, DWORD dwSize, LPSTREAM lpstream);
							

//+----------------------------------------------------------------------------
//
//	Function:
//		UtHMFToPlaceableMFStm, internal
//
//	Synopsis:
//		Given a handle to a METAFILE, write it to a stream as a
//		placeable METAFILE
//
//	Arguments:
//		[lphMF] -- a *pointer* to a METAFILE handle
//			REVIEW, why is this a pointer?
//		[dwSize] -- size of the METAFILE
//		[lWidth] -- width of the metafile
//			REVIEW, in what units?
//			REVIEW, why isn't this a DWORD?
//		[lHeight] -- height of the metafile
//			REVIEW, in what units?
//			REVIEW, why isn't this a DWORD?
//		[pstm] -- the stream to write the data to;  on exit, the stream
//			is positioned after the written data
//
//	Returns:
//		HRESULT
//
//	Notes:
//
//	History:
//		12/02/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL UtHMFToPlaceableMFStm(HANDLE FAR* lphMF, DWORD dwSize,
		LONG lWidth, LONG lHeight, LPSTREAM pstm);		


//+----------------------------------------------------------------------------
//
//	Function:
//		UtNFStmToPlaceableMFStm, internal
//
//	Synopsis:
//		Copy converts a METAFILE in a stream to a placeable METAFILE
//		in another stream.
//
//	Arguments:
//		[pstmMF] -- the IStream instance from which to read the
//			original METAFILE, positioned at the METAFILE
//			REVIEW, where does CopyTo leave this stream pointer?
//		[dwSize] -- the size of the source METAFILE
//		[lWidth] -- the width of the source METAFILE
//			REVIEW, in what units?
//			REVIEW, why isn't this a DWORD?
//		[lHeight] -- the height of the source METAFILE
//			REVIEW, in what units?
//			REVIEW, why isn't this a DWORD?
//		[pstmPMF] -- the IStream instance to which to write the
//			placeable METAFILE;  on exit, the stream is positioned
//			after the written data
//
//	Returns:
//		HRESULT
//
//	Notes:
//
//	History:
//		12/02/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL UtMFStmToPlaceableMFStm(LPSTREAM pstmMF, DWORD dwSize,
		LONG lWidth, LONG lHeight, LPSTREAM pstmPMF);


//+----------------------------------------------------------------------------
//
//	Function:
//		UtWriteOlePresStmHeader, internal
//
//	Synopsis:
//		Write out the header information for an Ole presentation stream.
//
//	Arguments:
//		[lpstream] -- the stream to write to;  on exit, the stream is
//			positioned after the header information
//		[pforetc] -- pointer to the FORMATETC for the presentation
//			data
//		[dwAdvf] -- the advise control flags for this presentation
//
//	Returns:
//		HRESULT
//
//	Notes:
//		This writes the clipboard information, the target device
//		information, if any, some FORMATETC data, and the advise
//		control flags.
//
//	History:
//		12/02/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL UtWriteOlePresStmHeader(LPSTREAM lppstream, LPFORMATETC pforetc,
		DWORD dwAdvf);


//+----------------------------------------------------------------------------
//
//	Function:
//		UtReadOlePresStmHeader, internal
//
//	Synopsis:
//		Reads the presentation description information from an Ole
//			presentation stream, as written by
//			UtWriteOlePresStmHeader().
//
//	Arguments:
//		[pstm] -- the IStream instance to read the presentation
//			description data from
//		[pforetc] -- pointer to the FORMATETC to initialize based
//			on data in the stream
//		[pdwAdvf] -- pointer to where to put the advise flags for
//			this presentation;  may be NULL
//		[pfConvert] -- pointer to a flag that is set to TRUE if
//			the presentation will require conversion from
//			Macintosh PICT format.
//
//	Returns:
//		HRESULT
//
//	Notes:
//
//	History:
//		12/02/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL UtReadOlePresStmHeader(LPSTREAM pstm, LPFORMATETC pforetc,
		DWORD FAR* pdwAdvf, BOOL FAR* pfConvert);


//+----------------------------------------------------------------------------
//
//	Function:
//		UtOlePresStmToContentsStm, internal
//
//	Synopsis:
//		Copy the content of a presentation stream to a contents stream,
//		adjusting the format as necessary.
//
//	Arguments:
//		[pstg] -- the IStorage instance in which the presentation
//			stream is, and in which to create the contents stream
//		[lpszPresStm] -- the name of the source presentation stream
//		[fDeletePresStm] -- flag that indicates that the presentation
//			stream should be deleted if the copy and convert is
//			successful.  This is ignored if the source was
//			DVASPECT_ICON.
//		[puiStatus] -- pointer to a UINT where status bits from
//			the CONVERT_* values below may be returned.
//
//	Returns:
//		HRESULT
//
//	Notes:
//		The content stream is named by the constant OLE_CONTENTS_STREAM.
//
//	History:
//		12/05/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL UtOlePresStmToContentsStm(LPSTORAGE pstg, LPOLESTR lpszPresStm,
		BOOL fDeletePresStm, UINT FAR* puiStatus);
#define CONVERT_NOSOURCE	0x0001
#define CONVERT_NODESTINATION	0x0002
#define CONVERT_SOURCEISICON	0x0004

// 2nd variation
FARINTERNAL UtOlePresStmToContentsStm(LPSTORAGE pSrcStg, LPOLESTR lpszPresStm,
		LPSTREAM pDestStm, UINT FAR* puiStatus);					

FARINTERNAL UtGetHMFPICTFromMSDrawNativeStm(LPSTREAM pstm, DWORD dwSize,
		HANDLE FAR* lphdata);

FARINTERNAL UtPlaceableMFStmToMSDrawNativeStm(LPSTREAM pstmPMF,
		LPSTREAM pstmMSDraw);
			
FARINTERNAL UtDIBFileStmToPBrushNativeStm(LPSTREAM pstmDIBFile,
		LPSTREAM pstmPBrush);

FARINTERNAL UtContentsStmTo10NativeStm(LPSTORAGE pstg, REFCLSID rclsid,
		BOOL fDeleteContents, UINT FAR* puiStatus);

FARINTERNAL Ut10NativeStmToContentsStm(LPSTORAGE pstg, REFCLSID rclsid,
		BOOL fDeleteSrcStm);
							

//+----------------------------------------------------------------------------
//
//	Function:
//		UtGetHPRESFromNative, internal
//
//	Synopsis:
//		Get a handle to a presentation from a native representation.
//
//	Arguments:
//		[pstg] -- the storage in which the native content is
//		[cfFormat] -- the native format to attempt to read
//		[fOle10Native] -- attempt to read the OLE10_NATIVE_STREAM
//			stream in that format; if this is FALSE, we read the
//			OLE_CONTENTS_STREAM
//
//	Returns:
//		HRESULT
//
//	Notes:
//
//	History:
//		12/05/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL_(HANDLE) UtGetHPRESFromNative(LPSTORAGE pstg,
		LPSTREAM pstm, CLIPFORMAT cfFormat, BOOL fOle10Native);

//+-------------------------------------------------------------------------
//
//  Function:  	ConvertPixelsToHIMETRIC
//
//  Synopsis: 	Converts a pixel dimension to HIMETRIC units
//
//  Effects:
//
//  Arguments: 	[hdcRef]        -- the reference DC
//		[ulPels]	-- dimension in pixel measurement
//		[pulHIMETRIC]	-- OUT param of converted HIMETRIC result
//		[tDimension]	-- indicates XDIMENSION or YDIMENSION of input
//
//  Returns:	S_OK, E_FAIL
//
//  Algorithm:	screen_mm * input_pels	      HIMETRICS/
//              ----------------------    *    	      /    == HIMETRICS
//                    screen_pels		     /mm
//
//  History:    dd-mmm-yy Author    Comment
//   		04-Aug-94 Davepl    Created
//
//  Notes:	We need to know whether the input size is in the X or
//		Y dimension, since the aspect ratio could vary
//
//--------------------------------------------------------------------------

// This enumeration is used to indicate in which diretion a
// dimension, when passed as a parameter, is to be relative to.
// This is needed for our Pixel -> HIMETRIC conversion function,
// since the aspect ratio could vary by dimension.

typedef enum tagDIMENSION
{
	XDIMENSION = 'X',
	YDIMENSION = 'Y'
} DIMENSION;

FARINTERNAL ConvertPixelsToHIMETRIC (HDC hdcRef,
				     ULONG lPels,
				     ULONG * pulHIMETRIC,
				     DIMENSION tDimension);

//+-------------------------------------------------------------------------
//
//  Function:  	IsTaskName
//
//  Synopsis: 	Determines if the passed name is the current task
//
//  Effects:
//
//  Arguments: 	[lpszIn]        -- Task name
//
//  Returns:	TRUE, FALSE
//
//  History:    dd-mmm-yy Author    Comment
//   		03-Mar-95 Scottsk    Created
//
//  Notes:	
//
//--------------------------------------------------------------------------
FARINTERNAL_(BOOL) IsTaskName(LPCWSTR lpszIn);

//+-------------------------------------------------------------------------
//
//  Function:  	utGetModuleName
//
//  Synopsis: 	Get Module Name for current module
//
//  Effects:
//
//  Arguments: 	[lpszModuleName]        -- Buffer to hold module name
//              [dwLength]              -- length in characters
//
//  Returns:	S_OK, E_UNEXPECTED, E_OUTOFMEMORY
//
//  History:    dd-mmm-yy Author    Comment
//              06-Feb-97 Ronans    Created
//
//--------------------------------------------------------------------------
FARINTERNAL utGetModuleName(LPWSTR lpszModuleName, DWORD dwLength);

//+-------------------------------------------------------------------------
//
//  Function:  	utGetAppIdForModule
//
//  Synopsis: 	Get AppID for the current module in string form
//
//  Effects:
//
//  Arguments: 	[lpszAppId]     -- Buffer to hold string represntation of AppId
//              [dwLength]      -- length of buffer in characters
//
//  Returns:	S_OK, E_UNEXPECTED, E_OUTOFMEMORY or error value from 
//              registry functions.
//
//  History:    dd-mmm-yy Author    Comment
//	            06-Feb-97 Ronans	Created
//
//--------------------------------------------------------------------------
FARINTERNAL utGetAppIdForModule(LPWSTR lpszAppId, DWORD dwLength);


//+-------------------------------------------------------------------------
//
//  Function:   UtGetDvtd16Info
//              UtConvertDvtd16toDvtd32
//
//              UtGetDvtd32Info
//              UtConvertDvtd32toDvtd16
//
//  Synopsis:   Utility functions for converting Ansi to Unicode DVTARGETDEVICEs
//
//  Algorithm:  UtGetDvtdXXInfo gets sizing data, which is then passed to
//              UtConvertDvtdXXtoDvtdXX to perform the conversion.
//
//  History:    06-May-94 AlexT     Created
//
//  Notes:      Here's a sample usage of these functions:
//
//              //  pdvtd16 is a Ansi DVTARGETDEVICE
//              DVTDINFO dvtdInfo;
//              DVTARGETDEVICE pdvtd32;
//
//              hr = UtGetDvtd16Info(pdvtd16, &dvtdInfo);
//              // check hr
//              pdvtd32 = CoTaskMemAlloc(dvtdInfo.cbConvertSize);
//              // check pdvtd32
//              hr = UtConvertDvtd16toDvtd32(pdvtd16, &dvtdInfo, pdvtd32);
//              // check hr
//              // pdvtd32 now contains the converted data
//
//--------------------------------------------------------------------------

typedef struct
{
    UINT cbConvertSize;
    UINT cchDrvName;
    UINT cchDevName;
    UINT cchPortName;
} DVTDINFO, *PDVTDINFO;

extern "C" HRESULT UtGetDvtd16Info(DVTARGETDEVICE const UNALIGNED *pdvtd16,
                                   PDVTDINFO pdvtdInfo);
extern "C" HRESULT UtConvertDvtd16toDvtd32(DVTARGETDEVICE const UNALIGNED *pdvtd16,
                                           DVTDINFO const *pdvtdInfo,
                                           DVTARGETDEVICE *pdvtd32);
extern "C" HRESULT UtGetDvtd32Info(DVTARGETDEVICE const *pdvtd32,
                                   PDVTDINFO pdvtdInfo);
extern "C" HRESULT UtConvertDvtd32toDvtd16(DVTARGETDEVICE const *pdvtd32,
                                           DVTDINFO const *pdvtdInfo,
                                           DVTARGETDEVICE UNALIGNED *pdvtd16);
class CStdIdentity;

HRESULT CreateEmbeddingServerHandler(CStdIdentity *pStdId, IUnknown **ppunkServerHandler);

// Number to wide-char conversion routine.  See xtow.c for description.
extern "C" BOOL __cdecl our_ultow(
	unsigned long val,
	wchar_t *buf,
	int bufsize,
	int radix
	);

#endif // _UTILS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ih\utstream.h ===
//+----------------------------------------------------------------------------
//
//	File:
//		utstream.h
//
//	Contents:
//		Ole stream utility routines
//
//	Classes:
//
//	Functions:
//
//	History:
//		12/07/93 - ChrisWe - file inspection and cleanup; removed
//			redeclarations of ReadStringStream, and
//			WriteStringStream which are declared in ole2sp.h;
//			made default params on StSetSize explicit; removed
//			signatures of obsolete (non-existent) atom reading and
//			writing routines
//
//-----------------------------------------------------------------------------

#ifndef _UTSTREAM_H_
#define _UTSTREAM_H_




// REVIEW, isn't this obsolete now, as StWrite is?
FARINTERNAL_(HRESULT) StRead(IStream FAR * lpstream, LPVOID lpBuf, ULONG ulLen);

#define StWrite(lpstream, lpBuf, ulLen) lpstream->Write(lpBuf, ulLen, NULL)

//+----------------------------------------------------------------------------
//
//	Function:
//		StSetSize, internal
//
//	Synopsis:
//		Sets the size of the stream, using IStream::SetSize().  Saves
//		the caller having to deal with the requisite ULARGE_INTEGER
//		parameter, by initializing one from the [dwSize] argument.
//
//	Arguments:
//		[pstm] -- the stream to set the size of
//		[dwSize] -- the size to set
//		[fRelative] -- if TRUE, indicates that the size is [dwSize]
//			plus the current seek position in the stream; if
//			FALSE, sets [dwSize] as the absolute size
//
//	Returns:
//		HRESULT
//
//	Notes:
//		REVIEW, this seems crocked.  When would you ever call
//		this with [fRelative] == TRUE, and a non-zero [dwSize]?
//
//	History:
//		12/07/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
FARINTERNAL StSetSize(LPSTREAM pstm, DWORD dwSize, BOOL fRelative);


// REVIEW, are the the following functions necessary anymore?
FARINTERNAL StSave10NativeData(IStorage FAR* pstgSave, HANDLE hNative,
		BOOL fIsOle1Interop);

FARINTERNAL StRead10NativeData(IStorage FAR* pstgSave, HANDLE FAR *phNative);

FARINTERNAL StSave10ItemName(IStorage FAR* pstg, LPCSTR szItemName);



//+---------------------------------------------------------------------------
//
//  Class:      CStmBuf, Base class.
//
//  Synopsis:   Internal buffered Streams.
//
//  Interfaces: CStmBuf    - Constructor.
//             ~CStmBuf    - Destructor.
//              Release    - Release interface (used with OpenStream).
//
//  History:    20-Feb-95    KentCe     Created.
//
//  Notes:      This is a simple buffered class for internal use only.
//
//----------------------------------------------------------------------------
class CStmBuf
{
public:
            CStmBuf();
            ~CStmBuf();

protected:
    IStream * m_pStm;           // Stream Interface to read/write.

    BYTE  m_aBuffer[256];       // Small read/write buffer.

    PBYTE m_pBuffer;            // Pointer into read/write buffer.
    ULONG m_cBuffer;            // Count of characters in read/write buffer.
};


//+---------------------------------------------------------------------------
//
//  Class:      CStmBufRead
//
//  Synopsis:   Internal buffered read of Streams.
//
//  Interfaces: Init       - Defines stream to read.
//              OpenStream - Opens a stream for reading.
//              Read       - Read from the stream.
//              ReadLong   - Read a long value from the stream.
//              Release    - Release interface (used with OpenStream).
//
//  History:    20-Feb-95    KentCe     Created.
//
//  Notes:      This is a simple buffered read class for internal use only.
//
//----------------------------------------------------------------------------
class CStmBufRead : public CStmBuf
{
public:
    void    Init(IStream * pstm);
    HRESULT OpenStream(IStorage * pstg, const OLECHAR * pwcsName);
    HRESULT Read(PVOID pBuf, ULONG cBuf);
    HRESULT ReadLong(LONG * plValue);
    void    Release();

private:
    void    Reset(void);
};


//+---------------------------------------------------------------------------
//
//  Class:      CStmBufWrite
//
//  Synopsis:   Internal buffered write of Streams.
//
//  Interfaces: Init         - Defines stream to write.
//              OpenOrCreateStream - Opens/Creates a stream for writing.
//              CreateStream - Creates a stream for writing.
//              Write        - Write to the stream.
//              WriteLong    - Write a long value to the stream.
//              Flush        - Flush buffer to the disk subsystem.
//              Release      - Release interface.
//
//  History:    20-Feb-95    KentCe     Created.
//
//  Notes:      This is a simple buffered write class for internal use only.
//
//----------------------------------------------------------------------------
class CStmBufWrite : public CStmBuf
{
public:
    void    Init(IStream * pstm);
    HRESULT OpenOrCreateStream(IStorage * pstg, const OLECHAR * pwcsName);
    HRESULT CreateStream(IStorage * pstg, const OLECHAR * pwcsName);
    HRESULT Write(void const * pBuf, ULONG cBuf);
    HRESULT WriteLong(LONG lValue);
    HRESULT Flush(void);
    void    Release();

private:
    void    Reset(void);
};


//
//  The following was moved from the ole2sp.h file to keep stream related API's
//  in one place.
//

//  Utility function not in the spec; in ole2.dll.
//  Read and write length-prefixed strings.  Open/Create stream.
//  ReadStringStream does allocation, returns length of
//  required buffer (strlen + 1 for terminating null)

STDAPI  ReadStringStream( CStmBufRead & StmRead, LPOLESTR FAR * ppsz );
STDAPI  WriteStringStream( CStmBufWrite & StmWrite, LPCOLESTR psz );
STDAPI  OpenOrCreateStream( IStorage FAR * pstg, const OLECHAR FAR * pwcsName,
                                                      IStream FAR* FAR* ppstm);

//
// The following versions of StringStream are used with ANSI data
//
STDAPI  ReadStringStreamA( CStmBufRead & StmRead, LPSTR FAR * ppsz );


// read and write ole control stream (in ole2.dll)
STDAPI  WriteOleStg (LPSTORAGE pstg, IOleObject FAR* pOleObj,
                     DWORD dwReserved, LPSTREAM FAR* ppstmOut);
STDAPI WriteOleStgEx(LPSTORAGE pstg, IOleObject* pOleObj, DWORD dwReserved, 
                     DWORD dwGivenFlags, LPSTREAM* ppstmOut);
STDAPI  ReadOleStg (LPSTORAGE pstg, DWORD FAR* pdwFlags,
                DWORD FAR* pdwOptUpdate, DWORD FAR* pdwReserved,
                LPMONIKER FAR* ppmk, LPSTREAM FAR* pstmOut);
STDAPI ReadM1ClassStm(LPSTREAM pstm, CLSID FAR* pclsid);
STDAPI WriteM1ClassStm(LPSTREAM pstm, REFCLSID rclsid);
STDAPI ReadM1ClassStmBuf(CStmBufRead & StmRead, CLSID FAR* pclsid);
STDAPI WriteM1ClassStmBuf(CStmBufWrite & StmWrite, REFCLSID rclsid);

#endif // _UTSTREAM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ilib\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME=   uuid
TARGETPATH=   obj
TARGETTYPE=   LIBRARY

INCLUDES=     ..\..\common\$(DEST_TREE);..\..\ih

C_DEFINES=    $(C_DEFINES)

SOURCES=      \
              ..\uuidole.cxx

UMTYPE=       windows
UMAPPL=
UMTEST=
UMLIBS=
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ih\chicago\verolerc.h ===
#ifdef RC_INVOKED

#include <winver.h>

#define VER_FILEVERSION_STR      "2.2\0"
#define VER_FILEVERSION          2,0020,0041,0060

#define VER_PRODUCTNAME_STR      "Microsoft OLE 2.2 for Windows 95(TM) Operating System\0"
#define VER_COMPANYNAME_STR      "Microsoft Corporation\0"
#define VER_LEGALTRADEMARKS_STR  "Microsoft\256 is a registered trademark of Microsoft Corporation. Windows NT(TM) is a trademark of Microsoft Corporation\0"
#define VER_LEGALCOPYRIGHT_STR   "Copyright \251 Microsoft Corp. 1992 - 1995\0"
#define VER_PRODUCTVERSION_STR   "2.2\0"
#define VER_PRODUCTVERSION       2,0020,0041,0060
#define VER_COMMENT_STR          "Microsoft OLE 2.2 for Windows 95(TM) Operating System\0"
#define VER_FILETYPE             VFT_DLL
#define VER_FILESUBTYPE          0
#define VER_FILEFLAGSMASK        VS_FFI_FILEFLAGSMASK
#define VER_FILEFLAGS            0L
#define VER_FILEOS               VOS_DOS_WINDOWS32
#define VER_FILEDESCRIPTION_STR  "Microsoft OLE 2.2 for Windows 95(TM) Operating System\0"

#endif /* RC_INVOKED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ih\widewrap.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:       widewrap.h
//
//  Contents:   Wrapper functions for Win32c API used by 32-bit OLE 2
//
//  History:    12-27-93   ErikGav   Created
//              06-14-94   KentCe    Various Chicago build fixes.
//
//----------------------------------------------------------------------------

#ifndef _WIDEWRAP_H_
#define _WIDEWRAP_H_

#ifndef RC_INVOKED
#pragma message ("INCLUDING WIDEWRAP.H from " __FILE__)
#endif  /* RC_INVOKED */

#ifdef _CHICAGO_

#ifdef __cplusplus
extern "C" {
#endif

#undef  WNDCLASS
#define WNDCLASS WNDCLASSW
#define WNDCLASST WNDCLASSA

#undef  STARTUPINFO
#define STARTUPINFO STARTUPINFOW

#undef  WIN32_FIND_DATA
#define WIN32_FIND_DATA WIN32_FIND_DATAW


int AnsiToUnicodeOem(LPWSTR pwsz, LPCSTR sz, LONG cb);

HANDLE
WINAPI
CreateFileX(
    LPCWSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    );

#undef  CreateFile
#define CreateFile CreateFileX
#define CreateFileT CreateFileA

BOOL
WINAPI
DeleteFileX(
    LPCWSTR lpFileName
    );

#undef  DeleteFile
#define DeleteFile DeleteFileX
#define DeleteFileT DeleteFileA

UINT
WINAPI
RegisterClipboardFormatX(
    LPCWSTR lpszFormat);

#undef  RegisterClipboardFormat
#define RegisterClipboardFormat RegisterClipboardFormatX
#define RegisterClipboardFormatT RegisterClipboardFormatA

int
WINAPI
GetClipboardFormatNameX(
    UINT format,
    LPWSTR lpszFormatName,
    int cchMaxCount);

#undef  GetClipboardFormatName
#define GetClipboardFormatName GetClipboardFormatNameX
#define GetClipboardFormatNameT GetClipboardFormatNameA

LONG
APIENTRY
RegOpenKeyX (
    HKEY hKey,
    LPCWSTR lpSubKey,
    PHKEY phkResult
    );

#undef  RegOpenKey
#define RegOpenKey RegOpenKeyX
#define RegOpenKeyT RegOpenKeyA

LONG
APIENTRY
RegQueryValueX (
    HKEY hKey,
    LPCWSTR lpSubKey,
    LPWSTR lpValue,
    PLONG   lpcbValue
    );

#undef  RegQueryValue
#define RegQueryValue RegQueryValueX
#define RegQueryValueT RegQueryValueA
LONG
APIENTRY
RegSetValueX (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD dwType,
    LPCWSTR lpData,
    DWORD cbData
    );

#undef  RegSetValue
#define RegSetValue RegSetValueX
#define RegSetValueT RegSetValueA

UINT
WINAPI
RegisterWindowMessageX(
    LPCWSTR lpString);

#undef  RegisterWindowMessage
#define RegisterWindowMessage RegisterWindowMessageX
#define RegisterWindowMessageT RegisterWindowMessageA

LONG
APIENTRY
RegOpenKeyExX (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD ulOptions,
    REGSAM samDesired,
    PHKEY phkResult
    );

#undef  RegOpenKeyEx
#define RegOpenKeyEx RegOpenKeyExX
#define RegOpenKeyExT RegOpenKeyExA

LONG
APIENTRY
RegQueryValueExX (
    HKEY hKey,
    LPCWSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    );

#undef  RegQueryValueEx
#define RegQueryValueEx RegQueryValueExX
#define RegQueryValueExT RegQueryValueExA

HWND
WINAPI
CreateWindowExX(
    DWORD dwExStyle,
    LPCWSTR lpClassName,
    LPCWSTR lpWindowName,
    DWORD dwStyle,
    int X,
    int Y,
    int nWidth,
    int nHeight,
    HWND hWndParent ,
    HMENU hMenu,
    HINSTANCE hInstance,
    LPVOID lpParam);

#undef  CreateWindowEx
#define CreateWindowEx CreateWindowExX
#define CreateWindowExT CreateWindowExA

ATOM
WINAPI
RegisterClassX(
    CONST WNDCLASSW *lpWndClass);

#undef  RegisterClass
#define RegisterClass RegisterClassX
#define RegisterClassT RegisterClassA

BOOL
WINAPI
UnregisterClassX(
    LPCWSTR lpClassName,
    HINSTANCE hInstance);

#undef  UnregisterClass
#define UnregisterClass UnregisterClassX
#define UnregisterClassT UnregisterClassA

int WINAPIV wsprintfX(LPWSTR pwszOut, LPCWSTR pwszFormat, ...);

#undef  wsprintf
#define wsprintf wsprintfX
#define wsprintfT wsprintfA

HWND
WINAPI
CreateWindowX(
    LPCWSTR lpClassName,
    LPCWSTR lpWindowName,
    DWORD dwStyle,
    int X,
    int Y,
    int nWidth,
    int nHeight,
    HWND hWndParent ,
    HMENU hMenu,
    HINSTANCE hInstance,
    LPVOID lpParam);

#undef  CreateWindow
#define CreateWindow CreateWindowX
#define CreateWindowT CreateWindowA

HANDLE
WINAPI
GetPropX(
    HWND hWnd,
    LPCWSTR lpString);

#undef  GetProp
#define GetProp GetPropX
#define GetPropT GetPropA

BOOL
WINAPI
SetPropX(
    HWND hWnd,
    LPCWSTR lpString,
    HANDLE hData);

#undef  SetProp
#define SetProp SetPropX
#define SetPropT SetPropA

HANDLE
WINAPI
RemovePropX(
    HWND hWnd,
    LPCWSTR lpString);

#undef  RemoveProp
#define RemoveProp RemovePropX
#define RemovePropT RemovePropA

UINT
WINAPI
GetProfileIntX(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    INT nDefault
    );

#undef  GetProfileInt
#define GetProfileInt GetProfileIntX
#define GetProfileIntT GetProfileIntA

ATOM
WINAPI
GlobalAddAtomX(
    LPCWSTR lpString
    );

#undef  GlobalAddAtom
#define GlobalAddAtom GlobalAddAtomX
#define GlobalAddAtomT GlobalAddAtomA

UINT
WINAPI
GlobalGetAtomNameX(
    ATOM nAtom,
    LPWSTR lpBuffer,
    int nSize
    );

#undef  GlobalGetAtomName
#define GlobalGetAtomName GlobalGetAtomNameX
#define GlobalGetAtomNameT GlobalGetAtomNameA

DWORD
WINAPI
GetModuleFileNameX(
    HMODULE hModule,
    LPWSTR lpFilename,
    DWORD nSize
    );

#undef  GetModuleFileName
#define GetModuleFileName GetModuleFileNameX
#define GetModuleFileNameT GetModuleFileNameA

LPWSTR
WINAPI
CharPrevX(
    LPCWSTR lpszStart,
    LPCWSTR lpszCurrent);

#undef  CharPrev
#define CharPrev CharPrevX
#define CharPrevT CharPrevA

HFONT   WINAPI CreateFontX(int, int, int, int, int, DWORD,
                             DWORD, DWORD, DWORD, DWORD, DWORD,
                             DWORD, DWORD, LPCWSTR);
#undef  CreateFont
#define CreateFont CreateFontX
#define CreateFontT CreateFontA

HMODULE
WINAPI
LoadLibraryX(
    LPCWSTR lpLibFileName
    );

#undef  LoadLibrary
#define LoadLibrary LoadLibraryX
#define LoadLibraryT LoadLibraryA

HMODULE
WINAPI
LoadLibraryExX(
    LPCWSTR lpLibFileName,
    HANDLE hFile,
    DWORD dwFlags
    );

#undef  LoadLibraryEx
#define LoadLibraryEx LoadLibraryExX
#define LoadLibraryExT LoadLibraryExA

LONG
APIENTRY
RegDeleteKeyX (
    HKEY hKey,
    LPCWSTR lpSubKey
    );

#undef  RegDeleteKey
#define RegDeleteKey RegDeleteKeyX
#define RegDeleteKeyT RegDeleteKeyA

#undef  RpcStringBindingCompose
#define RpcStringBindingCompose RpcStringBindingComposeW

#undef  RpcBindingFromStringBinding
#define RpcBindingFromStringBinding RpcBindingFromStringBindingW

#undef  RpcStringFree
#define RpcStringFree RpcStringFreeW

BOOL
WINAPI
CreateProcessX(
    LPCWSTR lpApplicationName,
    LPWSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCWSTR lpCurrentDirectory,
    LPSTARTUPINFOW lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    );

#undef  CreateProcess
#define CreateProcess CreateProcessX
#define CreateProcessT CreateProcessA

LONG
APIENTRY
RegEnumKeyExX (
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    LPDWORD lpcbName,
    LPDWORD lpReserved,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime
    );

#undef  RegEnumKeyEx
#define RegEnumKeyEx RegEnumKeyExX
#define RegEnumKeyExT RegEnumKeyExA

#undef  RpcServerUseProtseqEp
#define RpcServerUseProtseqEp RpcServerUseProtseqEpW

BOOL
WINAPI
AppendMenuX(
    HMENU hMenu,
    UINT uFlags,
    UINT uIDNewItem,
    LPCWSTR lpNewItem
    );

#undef  AppendMenu
#define AppendMenu AppendMenuX
#define AppendMenuT AppendMenuA

HANDLE
WINAPI
OpenEventX(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    );

#undef  OpenEvent
#define OpenEvent OpenEventX
#define OpenEventT OpenEventA

HANDLE
WINAPI
CreateEventX(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCWSTR lpName
    );

#undef  CreateEvent
#define CreateEvent CreateEventX
#define CreateEventT CreateEventA

UINT
WINAPI
GetDriveTypeX(
    LPCWSTR lpRootPathName
    );

#undef  GetDriveType
#define GetDriveType GetDriveTypeX
#define GetDriveTypeT GetDriveTypeA

DWORD
WINAPI
GetFileAttributesX(
    LPCWSTR lpFileName
    );

#undef  GetFileAttributes
#define GetFileAttributes GetFileAttributesX
#define GetFileAttributesT GetFileAttributesA

LONG
APIENTRY
RegEnumKeyX (
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    DWORD cbName
    );

#undef  RegEnumKey
#define RegEnumKey RegEnumKeyX
#define RegEnumKeyT RegEnumKeyA

LONG
APIENTRY
RegEnumValueX(
    HKEY hkey,
    DWORD dwIndex,
    LPWSTR wszName,
    LPDWORD pcbName,
    LPDWORD pReserved,
    LPDWORD ptype,
    LPBYTE  pValue,
    LPDWORD pcbValue
    );

#undef  RegEnumValue
#define RegEnumValue RegEnumValueX
#define RegEnumValueT RegEnumValueA

HANDLE
WINAPI
FindFirstFileX(
    LPCWSTR lpFileName,
    LPWIN32_FIND_DATAW lpFindFileData
    );

#undef  FindFirstFile
#define FindFirstFile FindFirstFileX
#define FindFirstFileT FindFirstFileA

#undef  RegisterProtseq
#define RegisterProtseq RegisterProtseqW

#undef  RpcStringBindingParse
#define RpcStringBindingParse RpcStringBindingParseW

#undef  RpcNetworkIsProtseqValid
#define RpcNetworkIsProtseqValid RpcNetworkIsProtseqValidW

#undef  RpcBindingToStringBinding
#define RpcBindingToStringBinding RpcBindingToStringBindingW

#undef  RpcServerUseProtseq
#define RpcServerUseProtseq RpcServerUseProtseqW

BOOL
WINAPI
GetComputerNameX (
    LPWSTR lpBuffer,
    LPDWORD nSize
    );

#undef  GetComputerName
#define GetComputerName GetComputerNameX
#define GetComputerNameT GetComputerNameA


//The following force Chicago to directly use the ANSI versions

#undef  DefWindowProc
#define DefWindowProc   DefWindowProcA

#undef  CopyMetaFile                       // Currently str ptr is always
#define CopyMetaFile    CopyMetaFileA      // null, write a wrapper if this
                                           // changes
#undef  CreateMetaFile
#define CreateMetaFile  CreateMetaFileA

#undef  PostMessage
#define PostMessage     PostMessageA

#undef  SendMessage
#define SendMessage     SendMessageA

#undef  PeekMessage
#define PeekMessage     PeekMessageA

#undef  DispatchMessage
#define DispatchMessage DispatchMessageA

#undef  GetWindowLong
#define GetWindowLong GetWindowLongA

#undef  SetWindowLong
#define SetWindowLong SetWindowLongA

DWORD
WINAPI
GetShortPathNameX(
    LPCWSTR lpszLongPath,
    LPWSTR lpszShortPath,
    DWORD cchBuffer
    );

#undef  GetShortPathName
#define GetShortPathName GetShortPathNameX
#define GetShortPathNameT GetShortPathNameA

DWORD
WINAPI
GetFullPathNameX(
    LPCWSTR lpFileName,
    DWORD nBufferLength,
    LPWSTR lpBuffer,
    LPWSTR *lpFilePart
    );

#undef  GetFullPathName
#define GetFullPathName GetFullPathNameX
#define GetFullPathNameT GetFullPathNameA

DWORD
WINAPI
SearchPathX(
    LPCWSTR lpPath,
    LPCWSTR lpFileName,
    LPCWSTR lpExtension,
    DWORD nBufferLength,
    LPWSTR lpBuffer,
    LPWSTR *lpFilePart
    );

#undef SearchPath
#define SearchPath SearchPathX
#define SearchPathT SearchPathA

ATOM
WINAPI
GlobalFindAtomX(
    LPCWSTR lpString
    );

#undef GlobalFindAtom
#define GlobalFindAtom GlobalFindAtomX
#define GlobalFindAtomT GlobalFindAtomA

int
WINAPI
GetClassNameX(
    HWND hWnd,
    LPWSTR lpClassName,
    int nMaxCount);

#undef GetClassName
#define GetClassName GetClassNameX
#define GetClassNameT GetClassNameA

LPWSTR
WINAPI
CharLowerX(
    LPWSTR lpsz);

#define CharLowerW CharLowerX

LPWSTR
WINAPI
CharUpperX(
    LPWSTR lpsz);

inline LPWSTR CharUpperW(LPWSTR lpsz)
{
    if (((DWORD)lpsz & 0xffff0000) == 0)
    {
        return (LPWSTR)towupper ((wchar_t)lpsz);
    } else {
        return _wcsupr (lpsz);
    }
}

#define CharLowerBuffW CharLowerBuffW_not_available_on_Win9x

#define CharUpperBuffW CharUpperBuffW_not_available_on_Win9x

BOOL
WINAPI
GetStringTypeX(
    DWORD    dwInfoType,
    LPCWSTR  lpSrcStr,
    int      cchSrc,
    LPWORD   lpCharType);

#define GetStringTypeW GetStringTypeX

BOOL
WINAPI
IsCharAlphaX(
    WCHAR ch);

#define IsCharAlphaW IsCharAlphaX

BOOL
WINAPI
IsCharAlphaNumericX(
    WCHAR ch);

#define IsCharAlphaNumericW IsCharAlphaNumericX

#define IsCharLowerW IsCharLowerW_is_not_available_on_Win9x

#define IsCharUpperW IsCharUpperW_is_not_available_on_Win9x

#define LCMapStringW LCMapStringW_is_not_available_on_Win9x

LPWSTR
WINAPI
lstrcatX(
    LPWSTR lpString1,
    LPCWSTR lpString2
    );

#define lstrcatW lstrcatX

LPWSTR
WINAPI
lstrcpyX(
    LPWSTR lpString1,
    LPCWSTR lpString2
    );

// #define lstrcpyW lstrcpyX

inline LPWSTR lstrcpyW( LPWSTR lpString1, LPCWSTR lpString2 )
{
    LPWSTR lpDest = lpString1;

    while( *lpDest++ = *lpString2++ )
        ;

    return lpString1;
}

LPWSTR
WINAPI
lstrcpynX(
    LPWSTR lpString1,
    LPCWSTR lpString2,
    int iMaxLength
    );

#define lstrcpynW lstrcpynX

int
WINAPI
lstrcmpX(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    );

#define lstrcmpW lstrcmpX

int
WINAPI
lstrcmpiX(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    );

#define lstrcmpiW lstrcmpiX

HANDLE
WINAPI
CreateFileMappingX(
    HANDLE hFile,
    LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
    DWORD flProtect,
    DWORD dwMaximumSizeHigh,
    DWORD dwMaximumSizeLow,
    LPCWSTR lpName
    );

#undef CreateFileMapping
#define CreateFileMapping CreateFileMappingX
#define CreateFileMappingT CreateFileMappingA

HANDLE
WINAPI
OpenFileMappingX(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    );

#undef OpenFileMapping
#define OpenFileMapping OpenFileMappingX
#define OpenFileMappingT OpenFileMappingA

#ifdef __cplusplus
}
#endif

#else
//
// These are the definitions for NT
//
#define CreateFileT CreateFileW
#define DeleteFileT DeleteFileW
#define RegisterClipboardFormatT RegisterClipboardFormatW
#define GetClipboardFormatNameT GetClipboardFormatNameW
#define RegOpenKeyT RegOpenKeyW
#define RegQueryValueT RegQueryValueW
#define RegSetValueT RegSetValueW
#define RegisterWindowMessageT RegisterWindowMessageW
#define RegOpenKeyExT RegOpenKeyExW
#define RegQueryValueExT RegQueryValueExW
#define CreateWindowExT CreateWindowExW
#define RegisterClassT RegisterClassW
#define UnregisterClassT UnregisterClassW
#define wsprintfT wsprintfW
#define CreateWindowT CreateWindowW
#define GetPropT GetPropW
#define SetPropT SetPropW
#define RemovePropT RemovePropW
#define GetProfileIntT GetProfileIntW
#define GlobalAddAtomT GlobalAddAtomW
#define GlobalGetAtomNameT GlobalGetAtomNameW
#define GetModuleFileNameT GetModuleFileNameW
#define CharPrevT CharPrevW
#define CreateFontT CreateFontW
#define LoadLibraryT LoadLibraryW
#define LoadLibraryExT LoadLibraryExW
#define RegDeleteKeyT RegDeleteKeyW
#define CreateProcessT CreateProcessW
#define RegEnumKeyExT RegEnumKeyExW
#define AppendMenuT AppendMenuW
#define OpenEventT OpenEventW
#define CreateEventT CreateEventW
#define GetDriveTypeT GetDriveTypeW
#define GetFileAttributesT GetFileAttributesW
#define RegEnumKeyT RegEnumKeyW
#define RegEnumValueT RegEnumValueW
#define FindFirstFileT FindFirstFileW
#define GetComputerNameT GetComputerNameW
#define GetShortPathNameT GetShortPathNameW
#define GetFullPathNameT GetFullPathNameW
#define SearchPathT SearchPathW
#define GlobalFindAtomT GlobalFindAtomW
#define GetClassNameT GetClassNameW
#define CreateFileMappingT CreateFileMappingW
#define OpenFileMappingT OpenFileMappingW
#define WNDCLASST WNDCLASSW

#endif  // _CHICAGO_

#endif  // _WIDEWRAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ilib\uuidole.cxx ===
/*
	uuid.cpp  Include guid's to produce a GUID lib file.

	THIS IS TEMPORARY!!!

*/

#include <windows.h>
#include <ole2.h>
#include <initguid.h>
#include <privguid.h>
#include <ole1cls.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ilib\chicago\makefile.inc ===
#
#   Get the UUIDs from built directory in common
#
uuid:	proxyb_i.c psfbuf_i.c rchanb_i.c stubb_i.c

proxyb_i.c: ..\..\common\chicago\proxyb_i.c
	copy ..\..\common\chicago\proxyb_i.c

psfbuf_i.c: ..\..\common\chicago\psfbuf_i.c
	copy ..\..\common\chicago\psfbuf_i.c

rchanb_i.c: ..\..\common\chicago\rchanb_i.c
	copy ..\..\common\chicago\rchanb_i.c

stubb_i.c: ..\..\common\chicago\stubb_i.c
	copy ..\..\common\chicago\stubb_i.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ilib\daytona\makefile.inc ===
#
#   Get the UUIDs from built directory in common
#
uuid:	proxyb_i.c psfbuf_i.c rchanb_i.c stubb_i.c

proxyb_i.c: ..\..\common\daytona\proxyb_i.c
	copy ..\..\common\daytona\proxyb_i.c

psfbuf_i.c: ..\..\common\daytona\psfbuf_i.c
	copy ..\..\common\daytona\psfbuf_i.c

rchanb_i.c: ..\..\common\daytona\rchanb_i.c
	copy ..\..\common\daytona\rchanb_i.c

stubb_i.c: ..\..\common\daytona\stubb_i.c
	copy ..\..\common\daytona\stubb_i.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ilib\cairo\makefile.inc ===
#
#   Get the UUIDs from built directory in common
#
uuid:	proxyb_i.c psfbuf_i.c rchanb_i.c stubb_i.c

proxyb_i.c: ..\..\..\types\proxstub\cairo\proxyb_i.c
	copy ..\..\..\types\proxstub\cairo\proxyb_i.c

psfbuf_i.c: ..\..\..\types\proxstub\cairo\psfbuf_i.c
	copy ..\..\..\types\proxstub\cairo\psfbuf_i.c

rchanb_i.c: ..\..\..\types\proxstub\cairo\rchanb_i.c
	copy ..\..\..\types\proxstub\cairo\rchanb_i.c

stubb_i.c:  ..\..\..\types\proxstub\cairo\stubb_i.c
	copy ..\..\..\types\proxstub\cairo\stubb_i.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\log\log.cxx ===
extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
}
#include "log.hxx"

#ifdef DBG

/*
 * Debuggers should not use this value (which is why it's in the source, not
 * the header.  Don't get confused!  Look for g_OleLogLen instead!
 */
#define OLE32_LOG_MAX   (4096)

// The actual log.  Allocated on first access to the log function
DebugEvent *gOleLog     = NULL;

/*
 * The size of the log.  While technically I could just use the define,
 * changing the value would then break debugger extensions that read this
 * stuff, and that would then destroy the whole point of this, now wouldn't
 * it?
 */
DWORD       gOleLogLen  = OLE32_LOG_MAX;

/*
 * This is where the next event is going to go.
 * To read the log, start with the entry g_OleLog[g_OleLogNext], and work your
 * way around to g_OleLog[g_OleLogNext-1].  Ignore every reference to the 
 * subject SU_NOTHING.... those are entries that haven't been used yet. 
 *
 * Don't you DARE try to log an event that has SU_NOTHING as the subject.
 */
long       gOleLogNext = 0;

unsigned char gIgnoreSubject[256] = {0};
unsigned char gIgnoreVerb[256]    = {0};
BOOL          gfDisableLog        = 0;

/*
 * Currently there are a couple issues that this does not attempt to solve.
 * For example, this does nothing in the case of contention of threads for
 * a particular entry in the log.  This only happens when the log wraps
 * WAY over.  The solution requires locking, and I think it's more important
 * to be fast in the majority of cases than correct in the extreme minority.
 */
void __Ole32Log (unsigned char Subject, unsigned char Verb,
                 void *SubjectPtr, void *ObjectPtr, ULONG_PTR UserData,
                 BOOL fGrabStack, int FramesToSkip)
{
    DebugEvent *log;
    DWORD myIndex;

    if (gIgnoreSubject[Subject] || gIgnoreVerb[Verb] || gfDisableLog)
        return;

    // Allocate the log...
    if (gOleLog == NULL)
    {
        log = (DebugEvent *)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
                                      gOleLogLen * sizeof(DebugEvent));
        if (log == NULL)
            return;

        if (InterlockedCompareExchangePointer((void **)&gOleLog, (void *)log, 
                                              NULL) != NULL)
            HeapFree(GetProcessHeap(), 0, log);
    }

    myIndex  = InterlockedIncrement(&gOleLogNext) % gOleLogLen;
    
    gOleLog[myIndex].Time      = GetTickCount();
    gOleLog[myIndex].ThreadID  = GetCurrentThreadId();
    gOleLog[myIndex].Subject   = Subject;
    gOleLog[myIndex].Verb      = Verb;
    gOleLog[myIndex].SubjectPtr= SubjectPtr;
    gOleLog[myIndex].ObjectPtr = ObjectPtr;
    gOleLog[myIndex].UserData  = UserData;

    if (fGrabStack)
    {
        ULONG ignore;
        RtlCaptureStackBackTrace( 1 + FramesToSkip, STACKTRACE_DEPTH,
                                  gOleLog[myIndex].Stack, &ignore );
    } else {
        gOleLog[myIndex].Stack[0] = NULL;
    }
}


#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ole232\advise\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME=   advise
TARGETPATH=   obj
TARGETTYPE=   LIBRARY

INCLUDES=     ..\..\..\common\$(DEST_TREE);..\..\..\ih;..\..\inc

SOURCES=      \
              ..\daholder.cpp \
              ..\oaholder.cpp

UMTYPE=       windows

!include ..\..\precomp2.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ole232\advise\oaholder.cpp ===
//+----------------------------------------------------------------------------
//
//	File:
//		oaholder.cpp
//
//	Contents:
//		COAHolder, a concrete implementation of IOleAdviseHolder,
//		a helper class
//
//	Classes:
//		COAHolder
//
//	Functions:
//		CreateOleAdviseHolder
//
//	History:
//              31-Jan-95 t-ScottH  added _DEBUG only Dump method to the
//                                  COAHolder class and a DumpCOAHolder
//                                  API
//		03/10/94 - RickSa - added call logging and fixed bugs with
//			inserting advises
//		01/24/94 - AlexGo  - first pass at converting to Cairo style
//			memory allocation
//		01/11/93 - AlexGo  - added VDATEHEAP macros to all functions
//			and methods
//		11/22/93 - ChrisWe - replace overloaded ==, != with
//			IsEqualIID and IsEqualCLSID
//		10/28/93 - ChrisWe - file cleanup and inspection for Cairo
//
//-----------------------------------------------------------------------------

#include <le2int.h>
#include <oaholder.h>
#include <limits.h>

#ifdef _DEBUG
#include <dbgdump.h>
#endif // _DEBUG

#pragma SEG(oaholder)

NAME_SEG(OaHolder)
ASSERTDATA

//+----------------------------------------------------------------------------
//
//	Function:
//		CreateDataAdviseHolder, public API
//
//	Synopsis:
//		Creates an instance of the COAHolder
//
//	Arguments:
//		[ppOAHolder] -- place to return pointer to newly allocated
//			advise holder
//
//	Returns:
//		E_INVALIDARG, if ppOAHolder is NULL
//		E_OUTOFMEMORY
//
//	Notes:
//
//	History:
//		10/28/93 - ChrisWe - file cleanup and inspection
//
//-----------------------------------------------------------------------------

#pragma SEG(CreateOleAdviseHolder)
STDAPI CreateOleAdviseHolder(IOleAdviseHolder FAR* FAR* ppOAHolder)
{
	OLETRACEIN((API_CreateOleAdviseHolder, PARAMFMT("ppOAHolder= %p"), ppOAHolder));

	VDATEHEAP();

	HRESULT hr;

	VDATEPTROUT_LABEL(ppOAHolder, IOleAdviseHolder FAR* FAR*, errRtn, hr);

	LEDebugOut((DEB_ITRACE, "%p _IN CreateOleAdviseHolder ( %p )"
		"\n", NULL, ppOAHolder));

	
	*ppOAHolder = new FAR COAHolder(); // task memory; hard coded below

	hr = *ppOAHolder
		? NOERROR : ReportResult(0, E_OUTOFMEMORY, 0, 0);

	LEDebugOut((DEB_ITRACE, "%p OUT CreateOleAdviseHolder ( %lx )\n",
		"[ %p ]\n", NULL, hr, *ppOAHolder));

	CALLHOOKOBJECTCREATE(hr, CLSID_NULL, IID_IOleAdviseHolder,
			     (IUnknown **)ppOAHolder);

errRtn:
	OLETRACEOUT((API_CreateOleAdviseHolder, hr));

	return hr;
}


//+----------------------------------------------------------------------------
//
//	Member:
//		COAHolder::COAHolder, public
//
//	Synopsis:
//		Initializes COAHolder
//
//	Effects:
//		Sets reference count to 1
//
//	Arguments:
//		none
//
//	Notes:
//
//	History:
//		10/28/93 - ChrisWe - file cleanup and inspection
//
//-----------------------------------------------------------------------------

#pragma SEG(COAHolder_ctor)
COAHolder::COAHolder() : CSafeRefCount(NULL)
{
	VDATEHEAP();

	// set reference count to 1
	SafeAddRef();

	// no sink pointers yet
	m_iSize = 0;
	m_ppIAS = NULL;

	GET_A5();
}


//+----------------------------------------------------------------------------
//
//	Member:
//		COAHolder::~COAHolder, private
//
//	Synopsis:
//		destructor, frees managed advise sinks
//
//	Arguments:
//		none
//
//	Requires:
//
//	Notes:
//
//	History:
//		10/28/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

#pragma SEG(COAHolder_dtor)
COAHolder::~COAHolder()
{
	VDATEHEAP();

	int iAdv;
	IAdviseSink FAR *FAR *ppIAS;

	M_PROLOG(this);
	
	// free the array, if there is one
	if (m_ppIAS)
	{
		// walk the array of advise sinks, freeing things
		for (ppIAS = m_ppIAS, iAdv = 0; iAdv < m_iSize; ++ppIAS, ++iAdv)
		{
			SafeReleaseAndNULL((IUnknown **)ppIAS);
		}

		// free the array
		PubMemFree(m_ppIAS);
	}
}



//+----------------------------------------------------------------------------
//
//	Member:
//		COAHolder::QueryInterface, public
//
//	Synopsis:
//		implements IUnknown::QueryInterface
//
//	Arguments:
//		[iid] -- the interface pointer desired
//		[ppv] -- pointer to where to return the requested interface
//			pointer
//
//	Returns:
//		E_NOINTERFACE, if requested interface not available
//		S_OK
//
//	Notes:
//
//	History:
//		10/28/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

#pragma SEG(COAHolder_QueryInterface)
STDMETHODIMP COAHolder::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
	VDATEHEAP();

	M_PROLOG(this);

	VDATEPTROUT(ppv, LPVOID FAR *);

	LEDebugOut((DEB_ITRACE,
		"%p _IN COAHolder::QueryInterface ( %p , %p )"
		"\n", this, iid, ppv));

	HRESULT hr = ReportResult(0, E_NOINTERFACE, 0, 0);

	if (IsEqualIID(iid, IID_IUnknown) ||
			IsEqualIID(iid, IID_IOleAdviseHolder))
	{
		*ppv = (IOleAdviseHolder FAR *)this;
		AddRef();
		hr = NOERROR;
	}
	else
	{
		*ppv = NULL;
	}

	LEDebugOut((DEB_ITRACE, "%p OUT COAHolder::QueryInterface ( %lx )"
		" [ %p ]\n", this, hr, *ppv));

	return hr;
}


//+----------------------------------------------------------------------------
//
//	Member:
//		COAHolder::AddRef, public
//
//	Synopsis:
//		implements IUnknown::AddRef
//
//	Arguments:
//		none
//
//	Notes:
//
//	History:
//		10/28/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

#pragma SEG(COAHolder_AddRef)
STDMETHODIMP_(ULONG) COAHolder::AddRef()
{
	ULONG	cRefs;

	VDATEHEAP();

	M_PROLOG(this);

	LEDebugOut((DEB_ITRACE, "%p _IN COAHolder::AddRef (  )\n", this));

	cRefs = SafeAddRef();

	LEDebugOut((DEB_ITRACE, "%p OUT	COAHolder::AddRef ( %lu )\n", this,
		cRefs));

	return cRefs;
}


//+----------------------------------------------------------------------------
//
//	Member:
//		COAHolder::Release, public
//
//	Synopsis:
//		implements IUnknown::Release
//
//	Arguments:
//		none
//
//	Notes:
//
//	History:
//		10/28/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

#pragma SEG(COAHolder_Release)
STDMETHODIMP_(ULONG) COAHolder::Release()
{
	VDATEHEAP();

	M_PROLOG(this);

	ULONG cRefs;

	LEDebugOut((DEB_ITRACE, "%p _IN COAHolder::Release ( )\n", this ));

	cRefs = SafeRelease();

	LEDebugOut((DEB_ITRACE, "%p OUT COAHolder::Release ( %lu )\n", this,
		cRefs));

	return cRefs;
}



//+----------------------------------------------------------------------------
//
//	Member:
//		COAHolder::Advise, public
//
//	Synopsis:
//		implements IOleAdviseHolder::Advise
//
//	Effects:
//		Adds the newly specified advise sink the the list of
//		advisees that will be notified when a change is indicated
//		via other IOleAdviseHolder methods on this object
//
//	Arguments:
//		[pAdvSink] -- the new advise sink to add the the list
//		[pdwConnection] -- pointer to a DWORD where an identifier will
//			be returned that can be used to identify this sink
//			later
//
//	Returns:
//		E_OUTOFMEMORY, S_OK
//
//	Notes:
//
//	History:
//		10/28/93 - ChrisWe - file inspection and cleanup
//              03/15/94 - AlexT    Zero out new space after a realloc
//		08/02/94 - AlexGo  - stabilized
//
//-----------------------------------------------------------------------------

#pragma SEG(COAHolder_Advise)
STDMETHODIMP COAHolder::Advise(IAdviseSink FAR* pAdvSink,
		DWORD FAR* pdwConnection)
{
	VDATEHEAP();

	int iAdv;  // records the first free entry found, or (-1)
	int iAdvScan; // counts across array entries
	IAdviseSink FAR *FAR *ppIAS; // points at the array entry being examined
	IAdviseSink FAR *pIAS; // the actual entry at *ppIAS

	M_PROLOG(this);
	VDATEIFACE(pAdvSink);
	HRESULT hr = NOERROR;

	LEDebugOut((DEB_ITRACE, "%p _IN COAHolder::Advise ( %p , %p )"
		"\n", this, pAdvSink, pdwConnection));

 	// Validate where to return the connection.
	if (pdwConnection)
	{
		VDATEPTRIN(pdwConnection, DWORD);

		// Default to error case
		*pdwConnection = 0;
	}

	// check our zombie state and stabilize.  If we are in a zombie
	// state, we do not want to be adding new advise sinks.

	CStabilize stabilize((CSafeRefCount *)this);

	if( IsZombie() )
	{
		hr = ResultFromScode(CO_E_RELEASED);
		goto errRtn;
	}


	// find an empty slot and clean up disconnected handlers
	for (iAdv = (-1), ppIAS = m_ppIAS, iAdvScan = 0;
			iAdvScan < m_iSize; ++ppIAS, ++iAdvScan)
	{
		if ((pIAS = *ppIAS) == NULL)
		{
			// NULL entries are handled below, to catch
			// any of the below cases creating new NULL values
			;
		}
		else if (!IsValidInterface(pIAS))
		{
			// not valid; don't try to release
			*ppIAS = NULL;
		}
		else if (!CoIsHandlerConnected(pIAS))
		{
			// advise sink not connected to server anymore; release
			// REVIEW, why do we have to constantly poll these
			// to see if they are ok?
			pIAS->Release();
			*ppIAS = NULL;
		}

		// if first NULL, save rather than extend array
		if ((*ppIAS == NULL) && (iAdv == (-1)))
			iAdv = iAdvScan;
	}

	// if we didn't find an empty slot, we have to add space
	if (iAdv == (-1))
	{

		ppIAS = (IAdviseSink FAR * FAR *)PubMemRealloc(m_ppIAS,
			sizeof(IAdviseSink FAR *)*(m_iSize + COAHOLDER_GROWBY));
				
		if (ppIAS != NULL)
		{
                        // zero out new space
                        _xmemset((void FAR *) (ppIAS + m_iSize), 0,
                                 sizeof(IAdviseSink *) * COAHOLDER_GROWBY);
			// this is the index of the new element to use
			iAdv = m_iSize;

			// replace the old array
			m_ppIAS = ppIAS;
			m_iSize += COAHOLDER_GROWBY;
		}
		else
		{
			// quit if there was an error
			hr = ReportResult(0, E_OUTOFMEMORY, 0, 0);
		}
	}

	if (SUCCEEDED(hr))
	{
		// if we get here, iAdv is the element to use; if the addition
		// was not possible, function would have returned before now
		pAdvSink->AddRef();
		m_ppIAS[iAdv] = pAdvSink;

		// if user wants cookie back, return it
		if (pdwConnection)
		{
			// NOTE: this +1 is balanced by -1 in Unadvise()
			*pdwConnection = iAdv + 1;
		}
	}

errRtn:

	LEDebugOut((DEB_ITRACE, "%p OUT COAHolder::Advise ( %lx )"
		" [ %p ]\n", this, hr,
			(pdwConnection)? *pdwConnection : 0));

	return hr;
}



//+----------------------------------------------------------------------------
//
//	Member:
//		COAHolder::Unadvise, public
//
//	Synopsis:
//		implementat IOleAdviseHolder::Unadvise
//
//	Effects:
//		removes the specified advise sink from the list of sinks that
//		are notified when other IOleAdviseHolder methods are used on
//		this
//
//	Arguments:
//		[dwConnection] -- The token that identifies the connection;
//			this would have been obtained previously from a
//			call to Advise()
//
//	Returns:
//		OLE_E_NOCONNECTION, if the connection token is invalid
//		S_OK
//
//	Notes: 	We do not have to stabilize this call since the only
//		outgoing call is the Release at the end
//
//	History:
//		10/28/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

#pragma SEG(COAHolder_Unadvise)
STDMETHODIMP COAHolder::Unadvise(DWORD dwConnection)
{
	VDATEHEAP();

	M_PROLOG(this);

	HRESULT hr = NOERROR;

	LEDebugOut((DEB_ITRACE, "%p _IN COAHolder::Unadvise ( %lu )"
		"\n", this, dwConnection));

	IAdviseSink FAR* pAdvSink; // the requested advise sink, if there is one
	int iAdv = (int)dwConnection - 1; // adjust connection index

	// check that the connection token is valid, and if so, check that
	// there is a connection for it
	if (((LONG)dwConnection <= 0)
		|| (iAdv >= m_iSize)
		|| ((LONG)dwConnection > INT_MAX)
		|| ((pAdvSink = m_ppIAS[iAdv]) == NULL)
		|| !IsValidInterface(pAdvSink))
	{
		hr = ReportResult(0, OLE_E_NOCONNECTION, 0, 0);
	}
	else
	{
	    // remove the advise sink from the array
	    m_ppIAS[iAdv] = NULL;

	    // release the advise sink; NB, due to circular references, this
	    // may release this advise holder--[this] may not be valid on
	    // return!
	    pAdvSink->Release();
	}

	// NB!!  If any outgoing calls are added, this function will have
	// to be stabilized

	LEDebugOut((DEB_ITRACE, "%p OUT COAHolder::Unadvise ( %lx )"
		" \n", this, hr));

	return hr;
}



//+----------------------------------------------------------------------------
//
//	Member:
//		COAHolder::EnumAdvise, public
//
//	Synopsis:
//		implements IOleAdviseHolder::EnumAdvise()
//
//	Effects:
//		returns an enumerator
//
//	Arguments:
//		[ppenumAdvise] -- pointer to where to return a pointer to
//			an enumerator
//
//	Returns:
//		E_NOTIMPL
//
//	Notes:
//		currently not implemented.
//
//	History:
//		10/28/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

#pragma SEG(COAHolder_EnumAdvise)
STDMETHODIMP COAHolder::EnumAdvise(IEnumSTATDATA FAR* FAR* ppenumAdvise)
{
	VDATEHEAP();

	M_PROLOG(this);

	// This is currently not implemented
	HRESULT hr = ReportResult(0, E_NOTIMPL, 0, 0);

	VDATEPTROUT(ppenumAdvise, IEnumSTATDATA FAR*);
	
	LEDebugOut((DEB_ITRACE, "%p _IN COAHolder::EnumAdvise ( )"
		"\n", this));

	*ppenumAdvise = NULL;

	LEDebugOut((DEB_ITRACE, "%p OUT COAHolder::EnumAdvise ( %lx )"
		"[ %p ]\n", this, hr, *ppenumAdvise));

	return hr;
}



//+----------------------------------------------------------------------------
//
//	Member:
//		COAHolder::SendOnRename(), public
//
//	Synopsis:
//		Multicast the OnRename OLE compound document notification,
//		to all interested parties
//
//	Arguments:
//		[pmk] -- the new name of the object
//
//	Returns:
//		S_OK
//
//	Notes:
//		This may release the advise holder, since some objects may
//		Unadvise() themselves at the time they receive this
//		notification.  To prevent the multicasting code from crashing,
//		the multicast loop is bracketed with AddRef()/Release().  Note
//		that the bracketing Release() may release the advise holder,
//		at which point [this] may no longer be valid.
//
//		In a similar vein, other parties may add new Advise sinks
//		during these notifications.  To avoid getting caught in
//		an infinite loop, we copy the number of advise sinks at the
//		beginning of the function, and do not refer to the current
//		number.  If some parties are removed, and re-added, they may
//		be notified more than once, if they happen to be moved to
//		a later spot in the array of advise sinks.
//		REVIEW, copied this comment from previous stuff, and it
//		sounds BOGUS.  Since new entries are always put in the first
//		empty slot, the current number always has to settle down,
//		and won't grow without bound, unless some bogus app is
//		continually registering itself when it gets a notification
//
//	History:
//		10/28/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

#pragma SEG(COAHolder_SendOnRename)
STDMETHODIMP COAHolder::SendOnRename(IMoniker FAR* pmk)
{
	VDATEHEAP();

	M_PROLOG(this);
	VDATEIFACE(pmk);

	HRESULT hr = NOERROR;
	
	int iAdvLim = m_iSize; // copy the current number of sink entries
	int iAdv;
	IAdviseSink FAR *FAR *ppIAS;

	LEDebugOut((DEB_ITRACE, "%p _IN COAHolder::SendOnRename ( %p )"
		"\n", this, pmk));

	// protect the COAHolder
	CStabilize stabilize((CSafeRefCount *)this);

	for (ppIAS = m_ppIAS, iAdv = 0; iAdv < iAdvLim; ++ppIAS, ++iAdv)
	{
		if (*ppIAS != NULL)
			(*ppIAS)->OnRename(pmk);
	}

	LEDebugOut((DEB_ITRACE, "%p OUT COAHolder::SendOnRename ( %lx )"
		" \n", this, hr));

	return hr;
}

//+----------------------------------------------------------------------------
//
//	Member:
//		COAHolder::SendOnSave(), public
//
//	Synopsis:
//		Multicast the OnSave OLE compound document notification,
//		to all interested parties
//
//	Arguments:
//		none
//
//	Returns:
//		S_OK
//
//	Notes:
//		See notes for COAHolder::SendOnRename().
//
//	History:
//		10/28/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

#pragma SEG(COAHolder_SendOnSave)
STDMETHODIMP COAHolder::SendOnSave(void)
{
	VDATEHEAP();

	M_PROLOG(this);

	HRESULT hr = NOERROR;
	
	LEDebugOut((DEB_ITRACE, "%p _IN COAHolder::SendOnSave (  )"
		"\n", this ));

	int iAdvLim = m_iSize; // copy the current number of sink entries
	int iAdv;
	IAdviseSink FAR *FAR *ppIAS;

	// protect the COAHolder
	CStabilize stabilize((CSafeRefCount *)this);

	for (ppIAS = m_ppIAS, iAdv = 0; iAdv < iAdvLim; ++ppIAS, ++iAdv)
	{
		if (*ppIAS != NULL)
			(*ppIAS)->OnSave();
	}


	LEDebugOut((DEB_ITRACE, "%p OUT COAHolder::SendOnSave ( %lx )"
		" \n", this, hr));

	return hr;
}


//+----------------------------------------------------------------------------
//
//	Member:
//		COAHolder::SendOnClose(), public
//
//	Synopsis:
//		Multicast the OnClose OLE compound document notification,
//		to all interested parties
//
//	Arguments:
//		none
//
//	Returns:
//		S_OK
//
//	Notes:
//		See notes for COAHolder::SendOnRename().
//
//	History:
//		10/28/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

#pragma SEG(COAHolder_SendOnClose)
STDMETHODIMP COAHolder::SendOnClose(void)
{
	VDATEHEAP();

	M_PROLOG(this);

	HRESULT hr = NOERROR;
	
	LEDebugOut((DEB_ITRACE, "%p _IN COAHolder::SendOnClose (  )"
		"\n", this));

	int iAdvLim = m_iSize; // copy the current number of sink entries
	int iAdv;
	IAdviseSink FAR *FAR *ppIAS;

	// protect the COAHolder
	CStabilize stabilize((CSafeRefCount *)this);

	for (ppIAS = m_ppIAS, iAdv = 0; iAdv < iAdvLim; ++ppIAS, ++iAdv)
	{
		if (*ppIAS != NULL)
			(*ppIAS)->OnClose();
	}

	LEDebugOut((DEB_ITRACE, "%p OUT COAHolder::SendOnClose ( %lx )"
		" \n", this, hr));

	return hr;
}


//+----------------------------------------------------------------------------
//
//	Member:
//		COAHolder::SendOnLinkSrcChange, public
//
//	Synopsis:
//		Multicasts IAdviseSink2::OnLinkSrcChange notification to any
//		advise sinks managed by the COAHolder that provide the
//		IAdviseSink2 interface
//
//	Arguments:
//		[pmk] -- the new moniker to the link source
//
//	Returns:
//		S_OK
//
//	Notes:
//
//	History:
//		12/31/93 - ChrisWe - fixed assert
//		11/01/93 - ChrisWe - made a member of COAHolder
//		10/28/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

#pragma SEG(COAHolder_SendOnLinkSrcChange)
HRESULT COAHolder::SendOnLinkSrcChange(IMoniker FAR* pmk)
{
	VDATEHEAP();

	M_PROLOG(this);

	VDATEIFACE(pmk);

	HRESULT hr = NOERROR;
	
	LEDebugOut((DEB_ITRACE, "%p _IN COAHolder::SendOnLinkSrcChange ( %p )"
		"\n", this, pmk));

	int iAdvLim = m_iSize; // records the number of entries at start
	int iAdv; // counts entries
	IAdviseSink FAR *FAR *ppIAS; // walks over the array of advise sinks
	
	// protect this from being released through circular references
      	CStabilize stabilize((CSafeRefCount *)this);

	// multicast notification
	for (ppIAS = m_ppIAS, iAdv = 0; iAdv < iAdvLim; ++ppIAS, ++iAdv)
	{
		IAdviseSink FAR* pAdvSink;
		IAdviseSink2 FAR* pAdvSink2;

		// REVIEW, this seems to require that the number of
		// advisees can only stay the same, or increase.  Why should
		// we care?
		Assert(iAdvLim <= m_iSize);

		// get pointer to current advise sink
		pAdvSink = *ppIAS;

		// if we have an advise sink, and it accepts IAdviseSink2
		// notifications, send one
		if ((pAdvSink != NULL) &&
				pAdvSink->QueryInterface(IID_IAdviseSink2,
				(LPVOID FAR*)&pAdvSink2) == NOERROR)
		{
			pAdvSink2->OnLinkSrcChange(pmk);
			pAdvSink2->Release();
		}
	}

	LEDebugOut((DEB_ITRACE, "%p OUT COAHolder::SendOnLinkSrcChange ( %lx )"
		" \n", this, hr));

	return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     COAHolder::Dump, public (_DEBUG only)
//
//  Synopsis:   return a string containing the contents of the data members
//
//  Effects:
//
//  Arguments:  [ppszDump]      - an out pointer to a null terminated character array
//              [ulFlag]        - flag determining prefix of all newlines of the
//                                out character array (default is 0 - no prefix)
//              [nIndentLevel]  - will add a indent prefix after the other prefix
//                                for ALL newlines (including those with no prefix)
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:   [ppszDump]  - argument
//
//  Derivation:
//
//  Algorithm:  use dbgstream to create a string containing information on the
//              content of data structures
//
//  History:    dd-mmm-yy Author    Comment
//              31-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

HRESULT COAHolder::Dump(char **ppszDump, ULONG ulFlag, int nIndentLevel)
{
    int i;
    char *pszPrefix;
    char *pszCSafeRefCount;
    dbgstream dstrPrefix;
    dbgstream dstrDump;

    // determine prefix of newlines
    if ( ulFlag & DEB_VERBOSE )
    {
        dstrPrefix << this << " _VB ";
    }

    // determine indentation prefix for all newlines
    for (i = 0; i < nIndentLevel; i++)
    {
        dstrPrefix << DUMPTAB;
    }

    pszPrefix = dstrPrefix.str();

    // put data members in stream
    dstrDump << pszPrefix << "No. of Advise Sinks = " << m_iSize << endl;
    for (i = 0; i < m_iSize; i++)
    {
        dstrDump << pszPrefix << "pIAdviseSink [" << i << "]    = " << m_ppIAS[i]  << endl;
    }

    // cleanup and provide pointer to character array
    *ppszDump = dstrDump.str();

    if (*ppszDump == NULL)
    {
        *ppszDump = UtDupStringA(szDumpErrorMessage);
    }

    CoTaskMemFree(pszPrefix);

    return NOERROR;
}

#endif // _DEBUG

//+-------------------------------------------------------------------------
//
//  Function:   DumpCOAHolder, public (_DEBUG only)
//
//  Synopsis:   calls the COAHolder::Dump method, takes care of errors and
//              returns the zero terminated string
//
//  Effects:
//
//  Arguments:  [pESD]          - pointer to COAHolder
//              [ulFlag]        - flag determining prefix of all newlines of the
//                                out character array (default is 0 - no prefix)
//              [nIndentLevel]  - will add a indent prefix after the other prefix
//                                for ALL newlines (including those with no prefix)
//
//  Requires:
//
//  Returns:    character array of structure dump or error (null terminated)
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              20-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

char *DumpCOAHolder(COAHolder *pOAH, ULONG ulFlag, int nIndentLevel)
{
    HRESULT hresult;
    char *pszDump;

    if (pOAH == NULL)
    {
        return UtDupStringA(szDumpBadPtr);
    }

    hresult = pOAH->Dump(&pszDump, ulFlag, nIndentLevel);

    if (hresult != NOERROR)
    {
        CoTaskMemFree(pszDump);

        return DumpHRESULT(hresult);
    }

    return pszDump;
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\log\sources.inc ===
!IF 0

Copyright (c) 1999  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

#
# This is the name of the target built from the source files specified
# below.  The name should include neither the path nor the file extension.
#
TARGETNAME=   dbglog

INCLUDES  =  $(INCLUDES);..\..\ih

#
# This specifies where the target is to be built.  A private target of
# type LIBRARY or DYNLINK should go to obj, whereas a public target of
# type LIBRARY or DYNLINK should go to $(BASEDIR)\public\sdk\lib.
#

TARGETPATH=   obj

#
# This specifies the type of the target, such as PROGRAM, DYNLINK, LIBRARY,
# etc.
#
TARGETTYPE=   LIBRARY

SOURCES=      ..\log.cxx

UMTYPE=       windows
UMAPPL=
UMTEST=
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ole232\precomp2.inc ===
#//+---------------------------------------------------------------
#//
#//  File:	precom2.inc
#//
#//  Contents:	directives for global precompiled include file when the
#//		sources file is two directories below ole232 (or wherever
#//		this file is located.  We could easily have precomp3 and
#//		precomp4 for other areas.  The ole2int.obj\* files should not
#//		otherwise be mentioned in the sources files.
#//
#//  History:	18-May-94   CraigWi	Created
#//             23-May-94   BillMo      Cairo fixed.
#//----------------------------------------------------------------

!ifdef OLE32ROOT
PCH_ROOT=$(OLE32ROOT)\ole232
!else
PCH_ROOT=..\..
!endif

INCLUDES=$(INCLUDES);..\..\..\idl\private\$(DEST_TREE)\$(O)
INCLUDES=$(INCLUDES);..\..\..\idl\public\$(DEST_TREE)\$(O)
INCLUDES=$(INCLUDES);$(BASE_INC_PATH)

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\..\inc\le2int.h
PRECOMPILED_TARGET=..\..\inc\$(GPCH_BUILD)\$(_OBJ_DIR)\*\le2int.pch
PRECOMPILED_OPTION=/Yule2int.h /Fp..\..\inc\$(GPCH_BUILD)\$(_OBJ_DIR)\*\le2int.pch
PRECOMPILED_OBJ=$(PCH_ROOT)\inc\$(GPCH_BUILD)\$(_OBJ_DIR)\*\le2int.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ole232\advise\daholder.cpp ===
//+----------------------------------------------------------------------------
//
//	File:
//		daholder.cpp
//
//	Contents:
//		concrete implementation of IDataAdviseHolder, a helper
//		class for OLE server implementors
//
//	Classes:
//		CDAHolder
//
//	Functions:
//		CreateDataAdviseHolder
//
//	History:
//              01/20/95 - t-ScottH- added Dump methods to CDAHolder and
//                                   CEnumSTATDATA classes
//                                   added DumpCDAHolder & DumpCEnumSTATDATA APIs
//                                   put class definitions in header file daholder.h
//              03/09/94 - AlexGo  - fixed bugs with the enumerator and
//                                   disconnecting of bad advise sinks
//		01/24/94 - AlexGo  - first pass at conversion to Cairo-style
//				     memory allocation
//		01/11/94 - AlexGo  - added VDATEHEAP macros to all functions and
//			methods
//		12/09/93 - ChrisWe - fix test for error code after CoGetMalloc()
//			in CDAHolder::Advise
//		11/22/93 - ChrisWe - replace overloaded ==, != with
//			IsEqualIID and IsEqualCLSID
//		10/29/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

#include <le2int.h>
#include "daholder.h"

#ifdef _DEBUG
#include "dbgdump.h"
#endif // _DEBUG

#pragma SEG(daholder)

NAME_SEG(DaHolder)
ASSERTDATA

//+----------------------------------------------------------------------------
//
//	Function:
//		CreateDataAdviseHolder, public
//
//	Synopsis:
//		Creates an instance of the CDAHolder class
//
//	Arguments:
//		[ppDAHolder] -- pointer to where to return the created
//			IDataAdviseHolder instance
//
//	Returns:
//		E_OUTOFMEMORY, S_OK
//
//	Notes:
//
//	History:
//		10/29/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

#pragma SEG(CreateDataAdviseHolder)
STDAPI CreateDataAdviseHolder(IDataAdviseHolder FAR* FAR* ppDAHolder)
{
	OLETRACEIN((API_CreateDataAdviseHolder, PARAMFMT("ppDAHolder= %p"), ppDAHolder));

        VDATEHEAP();
        VDATEPTROUT(ppDAHolder, IDataAdviseHolder*);

	*ppDAHolder = new FAR CDAHolder(); // task memory; use MEMCTX_TASK below

	CALLHOOKOBJECTCREATE(*ppDAHolder ? NOERROR : E_OUTOFMEMORY,
			     CLSID_NULL,
			     IID_IDataAdviseHolder,
			     (IUnknown **)ppDAHolder);

	HRESULT hr;

	hr = *ppDAHolder ? NOERROR : ReportResult(0, E_OUTOFMEMORY, 0, 0);

	OLETRACEOUT((API_CreateDataAdviseHolder, hr));

	return hr;
}



//+----------------------------------------------------------------------------
//
//	Member:
//		CDAHolder::CDAHolder, public
//
//	Synopsis:
//		constructor
//
//	Effects:
//		returns with reference count set to 1
//
//	Arguments:
//		none
//
//	Notes:
//
//	History:
//		10/29/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

#pragma SEG(CDAHolder_ctor)
CDAHolder::CDAHolder() : CSafeRefCount(NULL)
{
	VDATEHEAP();

	// set reference count
	SafeAddRef();

	// connections run from [1..infinity)
	m_dwConnection = 1;

	// there are no STATDATA entries yet
	m_iSize = 0;
	m_pSD = NULL;

	GET_A5();
}



//+----------------------------------------------------------------------------
//
//	Member:
//		CDAHolder::~CDAHolder, private
//
//	Synopsis:
//		destructor
//
//	Effects:
//		frees resources associated with the CDAHolder
//
//	Notes:
//
//	History:
//		10/29/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

CDAHolder::~CDAHolder()
{
	VDATEHEAP();

	int iData; // counts array entries as we scan the array
	STATDATA FAR *pSD; // used to scan the array of STATDATA

	// release the array, if we've allocated it

	// REVIEW: If we want to be really safe, we should release
	// the stat data's either before or after our destructor.
	// The release of the advise sinks in the statdata elements
	// could possible result in us being re-entered (a potential
	// awkward state for the middle of a class destructor).

	// However, since nobody should be accesssing the advise
	// holder if we get to the destructor (since the reference
	// count would have to be zero), we are going to bag on
	// this modification for Daytona RC1.

	if (m_pSD)
	{
		for(pSD = m_pSD, iData = 0; iData < m_iSize; ++pSD, ++iData)
			UtReleaseStatData(pSD);

		PubMemFree(m_pSD);
	}
}



//+----------------------------------------------------------------------------
//
//	Member:
//		CDAHolder::QueryInterface, public
//
//	Synopsis:
//		implements IUnknown::QueryInterface
//
//	Arguments:
//		[iid] -- IID of the desired interface
//		[ppv] -- pointer to a location to return the interface at
//
//	Returns:
//		E_NOINTERFACE, S_OK
//
//	Notes:
//
//	History:
//		10/29/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

#pragma SEG(CDAHolder_QueryInterface)
STDMETHODIMP CDAHolder::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
	VDATEHEAP();

	M_PROLOG(this);

	if (IsEqualIID(iid, IID_IUnknown) ||
			IsEqualIID(iid, IID_IDataAdviseHolder))
	{
		*ppv = (IDataAdviseHolder FAR *)this;
		AddRef();
		return NOERROR;
	}

	*ppv = NULL;
	return ReportResult(0, E_NOINTERFACE, 0, 0);
}



//+----------------------------------------------------------------------------
//
//	Member:
//		CDAHolder::AddRef, public
//
//	Synopsis:
//		implements IUnknown::AddRef
//
//	Arguments:
//		none
//
//	Notes:
//
//	History:
//		10/29/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

#pragma SEG(CDAHolder_AddRef)
STDMETHODIMP_(ULONG) CDAHolder::AddRef()
{
	VDATEHEAP();

	M_PROLOG(this);

	return SafeAddRef();
}


//+----------------------------------------------------------------------------
//
//	Member:
//		CDAHolder::Release,  public
//
//	Synopsis:
//		implementa IUnknown::Release
//
//	Arguments:
//		none
//
//	Notes:
//
//	History:
//		10/29/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

#pragma SEG(CDAHolder_Release)
STDMETHODIMP_(ULONG) CDAHolder::Release()
{
	VDATEHEAP();

	M_PROLOG(this);

	return SafeRelease();

}


//+----------------------------------------------------------------------------
//
//	Member:
//		CDAHolder::Advise, public
//
//	Synopsis:
//		Add a new advise sink to the list of advise sinks
//		managed by the data advise holder, and which will be notified
//		if a change is indicated using other IDataAdviseHolder
//		methods.  A data format is specified, and new data will be
//		sent to the sink in that format, when a change occurs.
//
//	Arguments:
//		[pDataObject] -- the source data object that presentations
//			should be taken from if an advise is to occur
//			immediately
//		[pFetc] -- The data format the advise sink is interested in
//		[advf] -- control flags
//		[pAdvSink] -- the advise sink being registered
//		[pdwConnection] -- a token that can be used to identify the
//			advise sink later on
//
//	Returns:
//		E_OUTOFMEMORY, S_OK
//
//	Notes:
//
//	History:
//		10/29/93 - ChrisWe - file inspection and cleanup
//		08/02/94 - AlexGo  - stabilized
//
//-----------------------------------------------------------------------------

#pragma SEG(CDAHolder_Advise)
STDMETHODIMP CDAHolder::Advise(LPDATAOBJECT pDataObj, FORMATETC FAR* pFetc,
		DWORD advf, IAdviseSink FAR* pAdvSink,
		DWORD FAR* pdwConnection)
{
	VDATEHEAP();

	M_PROLOG(this);
	int iSDScan; // index of the scan of SD array entries
	int iSDFree; // index of first free SD entry, or (-1)
	STATDATA FAR *pSD; // scans across the array of STATDATA entries

	if( IsZombie() )
	{
		return ResultFromScode(CO_E_RELEASED);
	}

	CStabilize stabilize((CSafeRefCount *)this);

	if (pDataObj)
		VDATEIFACE(pDataObj);
	
	VDATEPTRIN(pFetc, FORMATETC);
	VDATEIFACE(pAdvSink);

        if (!HasValidLINDEX(pFetc))
        {
            return(DV_E_LINDEX);
        }

	// Validate where to return the connection.
	if (pdwConnection)
	{
		VDATEPTRIN(pdwConnection, DWORD);

		// Default to error case
		*pdwConnection = 0;
	}

	// scan and remove all unconnected advise sinks
	for(iSDFree = (-1), pSD = m_pSD, iSDScan = 0; iSDScan < m_iSize;
			++pSD, ++iSDScan)
	{
		// REVIEW, why do we have to go polling these?
		if (!pSD->pAdvSink || !IsValidInterface(pSD->pAdvSink))
		{
			// not valid, don't try to release
			pSD->pAdvSink = NULL;
			goto RemoveBadSD;
		}
		else if (!CoIsHandlerConnected(pSD->pAdvSink))
		{
			// sink no longer connected, release
		RemoveBadSD:
			// release any data.  UtReleaseStatData will
			// zero out the statdata structure.
			UtReleaseStatData(pSD);

		}

		// if we're still looking for a free entry, note if this one
		// is free
		if ((iSDFree == (-1)) && (pSD->dwConnection == 0))
			iSDFree = iSDScan;
	}
	
	// should we send the data immediately?
	if (advf & ADVF_PRIMEFIRST)
	{
		// We are not going to honor ADVF_PRIMEFIRST if pDataObj is
		// NULL, even when ADVF_NODATA is specfied. We want it to be
		// this way so that the apps which don't have any data at
		// startup time, could pass in NULL for pDataObject and
		// prevent us from sending any OnDataChange() notification.
		// Later when they have the data avaliable they can call
		// SendOnDataChange. (SRINIK)
		
		if (pDataObj)
		{
			STGMEDIUM stgmed;

			stgmed.tymed = TYMED_NULL;
			stgmed.pUnkForRelease = NULL;

			if (advf & ADVF_NODATA)
			{
				// don't sent data, send only the notification
				pAdvSink->OnDataChange(pFetc, &stgmed);
			
			}
			else
			{
				// get data from object and send it to sink
				if (pDataObj->GetData(pFetc,
						 &stgmed) == NOERROR)
				{
					pAdvSink->OnDataChange(pFetc, &stgmed);
					ReleaseStgMedium(&stgmed);
				}
			}
		
			// if we only have to advise once, we've done so, and
			// needn't make an entry in the advise array
			if (advf & ADVF_ONLYONCE)
				return NOERROR;
		}
	}	
		
	// remove the ADVF_PRIMEFIRST from flags.
	advf &= (~ADVF_PRIMEFIRST);
			
	// find a free list entry we can use, if we haven't got one
	if (iSDFree == (-1))
	{
		HRESULT hr;

		// REVIEW, can we share array reallocation code with
		// oaholder.cpp?  Why can't we just use realloc?

		// didn't find any free array entries above; since that
		// scanned the whole array, have to allocate new entries
		// here

		pSD = (STATDATA FAR *)PubMemAlloc(sizeof(STATDATA)*(m_iSize+
				CDAHOLDER_GROWBY));

		if (pSD == NULL)
			hr = ReportResult(0, E_OUTOFMEMORY, 0, 0);
		else
		{
			// copy the old data over, if any, and free it
			if (m_pSD)
			{
				_xmemcpy((void FAR *)pSD, (void FAR *)m_pSD,
						sizeof(STATDATA)*m_iSize);

				PubMemFree(m_pSD);
			}

			// initialize newly allocated memory

			_xmemset((void FAR *)(pSD+m_iSize), 0,
					sizeof(STATDATA)*CDAHOLDER_GROWBY);

			// this is the index of the first free element
			iSDFree = m_iSize;

			// set up the STATDATA array
			m_pSD = pSD;
			m_iSize += CDAHOLDER_GROWBY;

			hr = NOERROR;
		}

		if (hr != NOERROR)
		{
			return(hr);
		}
	}

	// if we got here, we can add the new entry, and its index is iSDFree

	// point at the new element
	pSD = m_pSD+iSDFree;

	// Let the advise get added to the list			
	UtCopyFormatEtc(pFetc, &pSD->formatetc);
	pSD->advf = advf;
	pAdvSink->AddRef();
	pSD->pAdvSink = pAdvSink;
	pSD->dwConnection = m_dwConnection++;

	// return connection if user requested it
	if (pdwConnection)
		*pdwConnection = pSD->dwConnection;

	return NOERROR;
}



//+----------------------------------------------------------------------------
//
//	Member:
//		CDAHolder::Unadvise, public
//
//	Synopsis:
//		removes the advise sink specified from the list of those
//		registered to receive notifications from this data advise
//		holder
//
//	Arguments:
//		[dwConnection] -- token that identifies which advise sink
//			to remove; this will have come from Advise().
//
//	Returns:
//		OLE_E_NOCONNECTION, S_OK
//
//	Notes:
//
//	History:
//		10/29/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

#pragma SEG(CDAHolder_Unadvise)
STDMETHODIMP CDAHolder::Unadvise(DWORD dwConnection)
{
	VDATEHEAP();

	M_PROLOG(this);
	int iData; // index into the STATDATA array
	STATDATA FAR *pSD; // pointer into the STATDATA array

	// protect this against being released via a circular reference
	CStabilize stabilize((CSafeRefCount *)this);

	for (pSD = m_pSD, iData = 0; iData < m_iSize; ++pSD, ++iData)
	{
		// is this the entry we're looking for?
		if (pSD->dwConnection == dwConnection)
		{
			// release resources for the entry.  UtReleaseStatData
			// will zero the statdata.

			UtReleaseStatData(pSD);

			return NOERROR;
		}
	}

	// if we found what we were looking for in the loop, we'd return
	// from there, and never get here.  Since we didn't, it must be
	// that there's no such connection
	return ReportResult(0, OLE_E_NOCONNECTION, 0, 0);
}



//+----------------------------------------------------------------------------
//
//	Member:
//		CDAHolder::SendOnDataChange, public
//
//	Synopsis:
//		Send an OnDataChange notification to all advise sinks
//		registered with this data advise holder.
//
//	Arguments:
//		[pDataObject] -- the data object to get data from to send
//			to the advise sinks
//		[dwReserved] --
//		[advf] -- control flags
//
//	Returns:
//		S_OK
//
//	Notes:
//		More than one advise sink may be interested in obtaining
//		data in the same format.  It may be expensive for the data
//		object to create copies of the data in requested formats.
//		Therefore, when a change is signalled, the data formats
//		are cached.  As each advise sink is to be notified, we
//		check to see if the format it is requesting has already been
//		gotten from the data object (with GetData().)  If it has,
//		then we simply send that copy again.  If not, we get the
//		new format, and add that to the cache.
//
//	History:
//		10/29/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

#pragma SEG(CDAHolder_SendOnDataChange)
STDMETHODIMP CDAHolder::SendOnDataChange(IDataObject FAR* pDataObject,
		DWORD dwReserved, DWORD advf)
{
	VDATEHEAP();

	A5_PROLOG(this);
	HRESULT hresult = NOERROR; // error status so far
	UINT cFetcTotal; // maximum number of formats we will cache
	UINT cFetcGotten; // the actual number of formats in the cache
	UINT cFetc; // the index of the format in the cache under consideration
	FORMATETC FAR* rgFetc; // a record of the cached presentations
	STGMEDIUM FAR* rgStgmed; // the cached data presentations
	UINT cStatData; // a counter for the STATDATA array elements
	STATDATA FAR *pSD; // a pointer into the array of STATDATA elements

	VDATEIFACE(pDataObject);
	
	// in the worst case, every advise sink has requested a unique
	// data format, and we won't get any duplicates.  This means that
	// we will wind up caching all of them.
	cFetcTotal = m_iSize;

	// if there are no entries, there's nothing to do
	if (cFetcTotal == 0)
		return NOERROR;

	// some advise sinks may use these notifications to change their
	// requested notifications; due to possible circular references,
	// this could to lead to a release of this holder.  Protect against
	// this here; this is released after most work is done, towards the
	// end of this function
	CStabilize stabilize((CSafeRefCount *)this);

	// alloc rgFetc and rgStgmed to accomodate all the cache entries
	// if either fails to be allocated, we quit
	rgFetc = (FORMATETC FAR *)PubMemAlloc(cFetcTotal * sizeof(FORMATETC));
	rgStgmed = (STGMEDIUM FAR *)PubMemAlloc(cFetcTotal * sizeof(STGMEDIUM));

	if (rgFetc == NULL || rgStgmed == NULL)
	{
		hresult = ReportResult(0, E_OUTOFMEMORY, 0, 0);
		goto FreeExit;
	}

	// zero out STDMEDIUM entries
	_xmemset((void FAR *)rgStgmed, 0, sizeof(STGMEDIUM)*cFetcTotal);
		
	// ensure we have the right data and send to each advise sink
	// note the loop is bounded by cFetcTotal, preventing additional
	// sinks from being notified, if they are registered during these
	// notifications.  cStatData is not used in the loop body, so it
	// counts down

	for (cFetcGotten = 0, pSD = m_pSD, cStatData = cFetcTotal;
			cStatData; ++pSD, --cStatData)
	{
		// if this slot is not in use, skip it
		if (!pSD->dwConnection)
			continue;

		// if the sink is not interested in presentation data,
		// proceed to notify it immediately, unless this notification
		// is announcing the termination of the source
		if ((pSD->advf & ADVF_NODATA) &&
				!(advf & ADVF_DATAONSTOP))
		{
			STGMEDIUM stgmed;

			// don't sent data; use format from collection
			// and null STGMEDIUM.
			// REVIEW, should this be done once, up above?
			stgmed.tymed = TYMED_NULL;
			stgmed.pUnkForRelease = NULL;
			pSD->pAdvSink->OnDataChange(&pSD->formatetc, &stgmed);

			// REVIEW, what does this do for NULL?
			// if nothing, we can share a stdmedNULL, as above
			ReleaseStgMedium(&stgmed);

			// clean up at end of loop
			goto DataSent;
		}
		
		// if the sink is interested in data at the time of
		// termination, and the source is not terminating, OR, the
		// sink is not interested in data at the time of termination,
		// and we are terminating, skip this sink, and proceed
		if ((pSD->advf & ADVF_DATAONSTOP) !=
				(advf & ADVF_DATAONSTOP))
			continue;
		
		// check the requested format against the list of formats
		// for which we've already retrieved the presentation data.
		// if there is a match, proceed to send that data immediately
		// from here on in this loop body, cFetc is the index of the
		// data presentation to send to the current sink
		// REVIEW PERF: this is an n-squared algorithm;
		// we check the array of cached presentations for each
		// advise sink
		for (cFetc = 0; cFetc < cFetcGotten; ++cFetc)
		{
			// if match, continue outer loop
			if (UtCompareFormatEtc(&rgFetc[cFetc],
					&pSD->formatetc) == UTCMPFETC_EQ)
				goto SendThisOne;
		}

		// if we get here, we have not already fetched presentation	
		// data that matches the requested format

		// init FORMATETC (copy of needed one)
		// STDMEDIUM was initialized after its allocation to all NULL
		rgFetc[cFetcGotten] = pSD->formatetc;

		// get the data in the requested format from the data object
		// REVIEW: assume STGMEDIUM untouched if error
		// (i.e., still null)
		hresult = pDataObject->GetData(&rgFetc[cFetcGotten],
				&rgStgmed[cFetcGotten]);

		// REVIEW, what is this checking?
		AssertOutStgmedium(hresult, &rgStgmed[cFetcGotten]);

		// the presentation to send is the newly cached one
		// there is now one more entry in the cache array
		cFetc = cFetcGotten++;

	SendThisOne:
		// when we get here, rgFetc[cFetc] is the format to send to the
		// current advise sink

		// send change notification with requested data

                // The advise sink could have disappeared in the meantime
                // (if the the GetData call above resulted in an Unadvise,
                // for example), so we must validate the pAdvSInk first.
                // pSD will remain a valid regardless, and the advise
                // flags will have been zero'd, so it is safe to proceed
                // through the loop without "continue"ing.

                if (pSD->pAdvSink)
                {
		        pSD->pAdvSink->OnDataChange(&rgFetc[cFetc],
			        	&rgStgmed[cFetc]);
                }


	DataSent:
		// When we get here, something has been sent, possibly
		// an empty storage medium

		// if the sink requested to only be notified once, we
		// can free it here
		if (pSD->advf & ADVF_ONLYONCE)
		{
 			// free the stat data.  UtReleaseStatData will
			// zero the statdata, thus marking the connection
			// as invalid.

			UtReleaseStatData(pSD);

 		}
	}

	// free all stgmeds retrieved; FORMATETC.ptd was not allocated
	for (cFetc =  0; cFetc < cFetcGotten; ++cFetc)
		ReleaseStgMedium(&rgStgmed[cFetc]);
	
	hresult = NOERROR;

FreeExit:
	if (rgFetc != NULL)
		PubMemFree(rgFetc);

	if (rgStgmed != NULL)
		PubMemFree(rgStgmed);

	RESTORE_A5();

	return hresult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDAHolder::Dump, public (_DEBUG only)
//
//  Synopsis:   return a string containing the contents of the data members
//
//  Effects:
//
//  Arguments:  [ppszDump]      - an out pointer to a null terminated character array
//              [ulFlag]        - flag determining prefix of all newlines of the
//                                out character array (default is 0 - no prefix)
//              [nIndentLevel]  - will add a indent prefix after the other prefix
//                                for ALL newlines (including those with no prefix)
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:   [ppsz]  - argument
//
//  Derivation:
//
//  Algorithm:  use dbgstream to create a string containing information on the
//              content of data structures
//
//  History:    dd-mmm-yy Author    Comment
//              20-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

HRESULT CDAHolder::Dump(char **ppszDump, ULONG ulFlag, int nIndentLevel)
{
    int i;
    char *pszPrefix;
    char *pszCSafeRefCount;
    char *pszSTATDATA;
    dbgstream dstrPrefix;
    dbgstream dstrDump(1000);

    // determine prefix of newlines
    if ( ulFlag & DEB_VERBOSE )
    {
        dstrPrefix << this << " _VB ";
    }

    // determine indentation prefix for all newlines
    for (i = 0; i < nIndentLevel; i++)
    {
        dstrPrefix << DUMPTAB;
    }

    pszPrefix = dstrPrefix.str();

    // put data members in stream
    dstrDump << pszPrefix << "Next Connection ID       = " << m_dwConnection << endl;

    dstrDump << pszPrefix << "No. of STATDATA elements = " << m_iSize << endl;

    for (i = 0; i < m_iSize; i++)
    {
        pszSTATDATA = DumpSTATDATA( &m_pSD[i], ulFlag, nIndentLevel + 1) ;
        dstrDump << pszPrefix << "STATDATA element: " << i << endl;
        dstrDump << pszSTATDATA;
        CoTaskMemFree(pszSTATDATA);
    }

    // clean up and provide pointer to character array
    *ppszDump = dstrDump.str();

    if (*ppszDump == NULL)
    {
        *ppszDump = UtDupStringA(szDumpErrorMessage);
    }

    CoTaskMemFree(pszPrefix);

    return NOERROR;
}

#endif //_DEBUG

//+-------------------------------------------------------------------------
//
//  Function:   DumpCDAHolder, public (_DEBUG only)
//
//  Synopsis:   calls the CDAHolder::Dump method, takes care of errors and
//              returns the zero terminated string
//
//  Effects:
//
//  Arguments:  [pIDAH]         - pointer to IDAHolder (which we cast to CDAHolder)
//              [ulFlag]        - flag determining prefix of all newlines of the
//                                out character array (default is 0 - no prefix)
//              [nIndentLevel]  - will add a indent prefix after the other prefix
//                                for ALL newlines (including those with no prefix)
//
//  Requires:
//
//  Returns:    character array of structure dump or error (null terminated)
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              20-Jan-95 t-ScottH  author
//
//  Notes:
//
//  This API !!REQUIRES!! that class CDAHolder inherits from IDataAdviseHolder
//  first in order that we can pass in a parameter as a pointer to an
//  IDataAdviseHolder and then cast it to a CDAHolder.
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

char *DumpCDAHolder(IDataAdviseHolder *pIDAH, ULONG ulFlag, int nIndentLevel)
{
    HRESULT hresult;
    char *pszDump;

    if (pIDAH == NULL)
    {
        return UtDupStringA(szDumpBadPtr);
    }

    CDAHolder *pCDAH = (CDAHolder *)pIDAH;

    hresult = pCDAH->Dump(&pszDump, ulFlag, nIndentLevel);

    if (hresult != NOERROR)
    {
        CoTaskMemFree(pszDump);

        return DumpHRESULT(hresult);
    }

    return pszDump;
}

#endif // _DEBUG

//+----------------------------------------------------------------------------
//
//	Member:
//		CEnumSTATDATA::CEnumSTATDATA, public
//
//	Synopsis:
//		constructor
//
//	Effects:
//		sets reference count to 1
//
//	Arguments:
//		none
//
//	Notes:
//
//	History:
//		10/29/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

#pragma SEG(CEnumSTATDATA_ctor)
CEnumSTATDATA::CEnumSTATDATA(CDAHolder FAR* pHolder, int iDataStart)
{
	VDATEHEAP();

	GET_A5();

	// set reference count
	m_refs = 1;

	// first element to examine for return
	m_iDataEnum = iDataStart;

	// initialize pointer to holder, and addref, so it doesn't go
	// away while enumerator is alive
	(m_pHolder = pHolder)->AddRef();
}


//+----------------------------------------------------------------------------
//
//	Member:
//		CDAHolder::~CDAHolder, private
//
//	Synopsis:
//		destructor
//
//	Notes:
//
//	History:
//		10/29/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

#pragma SEG(CEnumSTATDATA_dtor)
CEnumSTATDATA::~CEnumSTATDATA()
{
	VDATEHEAP();

	M_PROLOG(this);

	m_pHolder->Release();
}


//+----------------------------------------------------------------------------
//
//	Member:
//		CEnumSTATDATA::QueryInterface, public
//
//	Synopsis:
//		implements IUnknown::QueryInterface
//
//	Arguments:
//		[iid] -- IID of the desired interface
//		[ppv] -- pointer to a location to return the interface at
//
//	Returns:
//		E_NOINTERFACE, S_OK
//
//	Notes:
//
//	History:
//		10/29/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

#pragma SEG(CEnumSTATDATA_QueryInterface)
STDMETHODIMP CEnumSTATDATA::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
	VDATEHEAP();

	M_PROLOG(this);

	if (IsEqualIID(iid, IID_IUnknown) ||
			IsEqualIID(iid, IID_IEnumSTATDATA))
	{
		*ppv = (IEnumSTATDATA FAR *)this;
		AddRef();
		return NOERROR;
	}

	*ppv = NULL;
	return ReportResult(0, E_NOINTERFACE, 0, 0);
}


//+----------------------------------------------------------------------------
//
//	Member:
//		CEnumSTATDATA::AddRef, public
//
//	Synopsis:
//		implements IUnknown::AddRef
//
//	Arguments:
//		none
//
//	Notes:
//
//	History:
//		10/29/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
#pragma SEG(CEnumSTATDATA_AddRef)
STDMETHODIMP_(ULONG) CEnumSTATDATA::AddRef()
{
	VDATEHEAP();

	M_PROLOG(this);

	return ++m_refs;
}


//+----------------------------------------------------------------------------
//
//	Member:
//		CEnumSTATDATA::Release, public
//
//	Synopsis:
//		implementa IUnknown::Release
//
//	Arguments:
//		none
//
//	Notes:
//
//	History:
//		10/29/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

#pragma SEG(CEnumSTATDATA_Release)
STDMETHODIMP_(ULONG) CEnumSTATDATA::Release()
{
	VDATEHEAP();

	M_PROLOG(this);

	if (--m_refs == 0)
	{
		delete this;
		return 0;
	}

	return m_refs;
}


//+----------------------------------------------------------------------------
//
//	Member:
//		CEnumSTATDATA::Next, public
//
//	Synopsis:
//		implements IEnumSTATDATA::Next()
//
//	Effects:
//
//	Arguments:
//		[celt] -- number of elements requested on this call
//		[rgelt] -- pointer to an array of STATDATAs where copies of
//			the elements can be returned
//		[pceltFectched] -- a pointer to where to return the number of
//			elements actually fetched.  May be NULL
//
//	Returns:
//		S_FALSE, S_OK
//
//	Notes:
//
//	History:
//              03/09/94 - AlexGo  - the enumerator no longer enumerates
//                                   "empty" statdata's in the m_pSD array.
//		11/01/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

#pragma SEG(CEnumSTATDATA_Next)
STDMETHODIMP CEnumSTATDATA::Next(ULONG celt, STATDATA FAR *rgelt,
		ULONG FAR* pceltFetched)
{
	VDATEHEAP();

	M_PROLOG(this);
	UINT ielt; // count of the number of elements fetched so far

	for (ielt = 0; (ielt < celt) && (m_iDataEnum < m_pHolder->m_iSize);
			m_iDataEnum++)
	{
                if( m_pHolder->m_pSD[m_iDataEnum].dwConnection != 0)
                {
                        ielt++;
                        // copy all bits; AddRef and copy DVTARGETDEVICE
                        // separately
	                UtCopyStatData(&m_pHolder->m_pSD[m_iDataEnum],
                                rgelt++);
                }
  	}

	// return number of elements fetched, if required
	if (pceltFetched)
		*pceltFetched = ielt;

	// no error, if exactly the requested number of elements was fetched
	return ielt == celt ? NOERROR : ReportResult(0, S_FALSE, 0, 0);
}


//+----------------------------------------------------------------------------
//
//	Member:
//		CDAHolder::Skip, public
//
//	Synopsis:
//		implements IEnumSTATDATA::Skip
//
//	Arguments:
//		[celt] -- the number of elements in the collection to skip
//			over
//
//	Returns:
//		S_FALSE, S_OK
//
//	Notes:
//
//	History:
//		11/01/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

#pragma SEG(CEnumSTATDATA_Skip)
STDMETHODIMP CEnumSTATDATA::Skip(ULONG celt)
{
	VDATEHEAP();

	M_PROLOG(this);
	STATDATA FAR *pSD; // scans over the array of STATDATA entries

	// if the enumeration would take us off the end of the array
	// mark the enumeration as complete
	if (m_iDataEnum + celt > (ULONG)m_pHolder->m_iSize)
	{
		m_iDataEnum = m_pHolder->m_iSize;
	
		return ReportResult(0, S_FALSE, 0, 0);
	}


	// skip over valid entries in the array, counting down until
	// we don't have to skip over any more, or until we get to
	// the end of the array
	for(pSD = m_pHolder->m_pSD+m_iDataEnum;
			celt && (m_iDataEnum < m_pHolder->m_iSize);
			++m_iDataEnum)
	{
		// if the connection is valid, count it as a skipped
		// enumerated item
		if (pSD->dwConnection != 0)
			--celt;
	}

	// if we could skip them all, indicate by non-error return
	if (celt == 0)
		return(NOERROR);

	return(ReportResult(0, S_FALSE, 0, 0));
}


//+----------------------------------------------------------------------------
//
//	Member:
//		CDAHolder::Reset, public
//
//	Synopsis:
//		implements IEnumSTATDATA::Reset
//
//	Arguments:
//		none
//
//	Returns:
//		S_OK
//
//	Notes:
//
//	History:
//		11/01/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

#pragma SEG(CEnumSTATDATA_Reset)
STDMETHODIMP CEnumSTATDATA::Reset()
{
	VDATEHEAP();

	M_PROLOG(this);

	// move back to the beginning of the STATDATA array
	m_iDataEnum = 0;

	return NOERROR;
}


//+----------------------------------------------------------------------------
//
//	Member:
//		CDAHolder::Clone, public
//
//	Synopsis:
//		implements IEnumSTATDATA::Clone
//
//	Arguments:
//		none
//
//	Returns:
//		E_OUTOFMEMORY, S_OK
//
//	Notes:
//
//	History:
//		11/01/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

#pragma SEG(CEnumSTATDATA_Clone)
STDMETHODIMP CEnumSTATDATA::Clone(LPENUMSTATDATA FAR* ppenum)
{
	VDATEHEAP();

	M_PROLOG(this);

	*ppenum = new FAR CEnumSTATDATA(m_pHolder, m_iDataEnum);

	return *ppenum ? NOERROR : ReportResult(0, E_OUTOFMEMORY, 0, 0);
}


//+----------------------------------------------------------------------------
//
//	Member:
//		CDAHolder::EnumAdvise, public
//
//	Synopsis:
//		implements IDataAdviseHolder::EnumAdvise
//
//	Effects:
//		creates an enumerator for the registered advise sinks
//
//	Arguments:
//		[ppenumAdvise] -- a pointer to where to return the enumerator
//
//	Returns:
//		E_OUTOFMEMORY, S_OK
//
//	Notes:
//
//	History:
//		11/01/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------

#pragma SEG(CDAHolder_EnumAdvise)
STDMETHODIMP CDAHolder::EnumAdvise(IEnumSTATDATA FAR* FAR* ppenumAdvise)
{
	VDATEHEAP();

	M_PROLOG(this);

	VDATEPTROUT(ppenumAdvise, IEnumSTATDATA FAR*);

	// REVIEW, memory leak if bad ppenumAdvise pointer
	*ppenumAdvise = new FAR CEnumSTATDATA(this, 0);

	return *ppenumAdvise ? NOERROR : ReportResult(0, E_OUTOFMEMORY, 0, 0);
}

//+-------------------------------------------------------------------------
//
//  Member:     CEnumSTATDATA::Dump, public (_DEBUG only)
//
//  Synopsis:   return a string containing the contents of the data members
//
//  Effects:
//
//  Arguments:  [ppszDump]      - an out pointer to a null terminated character array
//              [ulFlag]        - flag determining prefix of all newlines of the
//                                out character array (default is 0 - no prefix)
//              [nIndentLevel]  - will add a indent prefix after the other prefix
//                                for ALL newlines (including those with no prefix)
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:   [ppsz]  - argument
//
//  Derivation:
//
//  Algorithm:  use dbgstream to create a string containing information on the
//              content of data structures
//
//  History:    dd-mmm-yy Author    Comment
//              20-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

HRESULT CEnumSTATDATA::Dump(char **ppszDump, ULONG ulFlag, int nIndentLevel)
{
    int i;
    char *pszPrefix;
    char *pszDAH;
    dbgstream dstrPrefix;
    dbgstream dstrDump(1000);

    // determine prefix of newlines
    if ( ulFlag & DEB_VERBOSE )
    {
        dstrPrefix << this << " _VB ";
    }

    // determine indentation prefix for all newlines
    for (i = 0; i < nIndentLevel; i++)
    {
        dstrPrefix << DUMPTAB;
    }

    pszPrefix = dstrPrefix.str();

    // put data members in stream
    dstrDump << pszPrefix << "No. of References     = " << m_refs       << endl;

    dstrDump << pszPrefix << "Index to next element = " << m_iDataEnum  << endl;

    if (m_pHolder != NULL)
    {
        pszDAH = DumpCDAHolder(m_pHolder, ulFlag, nIndentLevel + 1);
        dstrDump << pszPrefix << "Data Advise Holder: "                 << endl;
        dstrDump << pszDAH;
        CoTaskMemFree(pszDAH);
    }
    else
    {
    dstrDump << pszPrefix << "pCDAHolder            = " << m_pHolder    << endl;
    }

    // cleanup and provide pointer to character array
    *ppszDump = dstrDump.str();

    if (*ppszDump == NULL)
    {
        *ppszDump = UtDupStringA(szDumpErrorMessage);
    }

    CoTaskMemFree(pszPrefix);

    return NOERROR;
}

#endif // _DEBUG

//+-------------------------------------------------------------------------
//
//  Function:   DumpCEnumSTATDATA, public (_DEBUG only)
//
//  Synopsis:   calls the CEnumSTATDATA::Dump method, takes care of errors and
//              returns the zero terminated string
//
//  Effects:
//
//  Arguments:  [pESD]          - pointer to CEnumSTATDATA
//              [ulFlag]        - flag determining prefix of all newlines of the
//                                out character array (default is 0 - no prefix)
//              [nIndentLevel]  - will add a indent prefix after the other prefix
//                                for ALL newlines (including those with no prefix)
//
//  Requires:
//
//  Returns:    character array of structure dump or error (null terminated)
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              20-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

char *DumpCEnumSTATDATA(CEnumSTATDATA *pESD, ULONG ulFlag, int nIndentLevel)
{
    HRESULT hresult;
    char *pszDump;

    if (pESD == NULL)
    {
        return UtDupStringA(szDumpBadPtr);
    }

    hresult = pESD->Dump(&pszDump, ulFlag, nIndentLevel);

    if (hresult != NOERROR)
    {
        CoTaskMemFree(pszDump);

        return DumpHRESULT(hresult);
    }

    return pszDump;
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ole232\base\api.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:   api.cpp
//
//  Contents:   OLE2 api definitions.
//
//  Classes:    none
//
//  Functions:  OleRun
//              OleIsRunning
//              OleLockRunning
//              OleSetContainedObject
//              OleNoteObjectVisible
//              OleGetData
//              OleSetData
//              OleSave
//              ReadClassStg
//              WriteClassStg
//              WriteFmtUserTypeStg
//              ReadFmtUserTypeStg
//              ReadM1ClassStm  (internal)
//              WriteM1ClassStm (internal)
//              ReadClassStm
//              WriteClassStm
//              ReleaseStgMedium
//              OleDuplicateData
//              ReadOleStg  (internal)
//              WriteOleStg (internal)
//              GetDocumentBitStg (internal and unused)
//              GetConvertStg
//              SetConvertStg
//              ReadClipformatStm
//              WriteClipformatStm
//              WriteMonikerStm
//              ReadMonikerStm
//              OleDraw
//              CreateObjectDescriptor (internal (for now))
//
//  History:    dd-mmm-yy Author    Comment
//              20-Feb-95 KentCe    Buffer version of Read/WriteM1ClassStm.
//              04-Jun-94 alexgo    added CreateObjectDescriptor and
//                                  enhanced metafile support
//              25-Jan-94 alexgo    first pass at Cairo-style memory allocation
//              11-Jan-94 chriswe   fixed broken asserts
//              11-Jan-94 alexgo    added VDATEHEAP macros to every function
//                      and fixed compile warnings
//              08-Dec-93 ChrisWe  added necessary casts to GlobalLock() calls
//                      resulting from removing bogus GlobalLock() macros in
//                      le2int.h
//              21-Oct-93 Alex Gounares (alexgo)  32-bit port, commented
//                      and substantial cleanup
//              (curts)  11/01/92   Added OleDuplicateMedium
//              (srinik) 06/22/92   Moved ReadStringStream, WriteStringStream
//                      to "utstream.cpp"
//              (barrym) 06/02/92   Moved OleSave, ReadClassStg,
//                      WriteClassStg, added
//                      OleSaveCompleted, OleIsDirty
//              28-May-92 Srini Koppolu (srinik)  Original Author
//
//--------------------------------------------------------------------------


// REVIEW FINAL: probably want to change all pstm->Read into StRead(pstm...)
// except if spec issue 313 is accepted in which case we change StRead into
// pstm->Read.

#include <le2int.h>
#pragma SEG(api)

#define COMPOBJSTM_HEADER_SIZE  7

#ifndef _MAC
FARINTERNAL_(HBITMAP) BmDuplicate(HBITMAP hold, DWORD FAR* lpdwSize,
    LPBITMAP lpBm);
#endif

NAME_SEG(Api)
ASSERTDATA

#define MAX_STR 512

#ifndef WIN32
// WIN16 uses remove()
#include <stdio.h>
#endif

DWORD gdwFirstDword = (DWORD)MAKELONG(COMPOBJ_STREAM_VERSION,
                BYTE_ORDER_INDICATOR);
DWORD gdwOleVersion = MAKELONG(OLE_STREAM_VERSION, OLE_PRODUCT_VERSION);


//+-------------------------------------------------------------------------
//
//  Function:   OleRun
//
//  Synopsis:   Calls IRunnableObject->Run on a given object
//
//  Effects:    Usually puts on object in the RunningObjectTable
//
//  Arguments:  [lpUnkown]  --  Pointer to the object
//
//  Requires:
//
//  Returns:    The  HRESULT from the Run method.
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      21-Oct-93 alexgo    ported to 32bit
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(OleRun)
STDAPI  OleRun(IUnknown FAR* lpUnknown)
{
    OLETRACEIN((API_OleRun, PARAMFMT("lpUnknown= %p"), lpUnknown));

    VDATEHEAP();

    HRESULT         hresult;
    IRunnableObject FAR*    pRO;

    VDATEIFACE_LABEL(lpUnknown, errRtn, hresult);

    if (lpUnknown->QueryInterface(IID_IRunnableObject, (LPLPVOID)&pRO)
        != NOERROR)
    {
        // if no IRunnableObject, assume already running
        hresult = NOERROR;
        goto errRtn;
    }

    hresult = pRO->Run(NULL);
    pRO->Release();

errRtn:
    OLETRACEOUT((API_OleRun, hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Function:   OleIsRunning
//
//  Synopsis:   calls IRunnableObject->IsRunning on the given object
//
//  Effects:    Usually returns whether or not an object is in the
//      Running Object Table.
//
//  Arguments:  [lpOleObj]  --  pointer to the object
//
//  Requires:
//
//  Returns:    TRUE or FALSE (from IRO->IsRunning)
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      21-Oct-93 alexgo    ported to 32bit
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(OleIsRunning)
STDAPI_(BOOL)  OleIsRunning(IOleObject FAR* lpOleObj)
{
    OLETRACEIN((API_OleIsRunning, PARAMFMT("lpOleObj= %p"), lpOleObj));

    VDATEHEAP();

    IRunnableObject FAR*    pRO;
    BOOL            bRetval;

    GEN_VDATEIFACE_LABEL(lpOleObj, FALSE, errRtn, bRetval);

    if (lpOleObj->QueryInterface(IID_IRunnableObject, (LPLPVOID)&pRO)
        != NOERROR)
    {
        // if no IRunnableObject, assume already running
        bRetval = TRUE;
        goto errRtn;
    }

    bRetval = pRO->IsRunning();
    pRO->Release();

errRtn:
    OLETRACEOUTEX((API_OleIsRunning, RETURNFMT("%B"), bRetval));

    return bRetval;
}


//+-------------------------------------------------------------------------
//
//  Function:   OleLockRunning
//
//  Synopsis:   calls IRunnableObject->LockRunning on the given object
//
//  Effects:    The object usually ends up calling CoLockObjectExternal
//      on itself
//
//  Arguments:  [lpUnknown]           --  pointer to the object
//      [fLock]              --  TRUE == lock running
//                                       FALSE == unlock running
//      [fLastUnlockCloses]  --  if TRUE, IRO->LockRunning
//                                       is supposed to call IOO->Close
//                                       if this was the last unlock
//
//  Requires:
//
//  Returns:    HRESULT from IRunnableObject->LockRunning()
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      21-Oct-93 alexgo    32bit port, changed GEN_VDATEIFACE
//                  to VDATEIFACE to fix a bug
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(OleLockRunning)
STDAPI  OleLockRunning(LPUNKNOWN lpUnknown, BOOL fLock, BOOL fLastUnlockCloses)
{
    OLETRACEIN((API_OleLockRunning, PARAMFMT("lpUnknown= %p, fLock= %B, fLastUnlockCloses= %B"),
                lpUnknown, fLock, fLastUnlockCloses));

    VDATEHEAP();

    IRunnableObject FAR*    pRO;
    HRESULT         hresult;

    VDATEIFACE_LABEL(lpUnknown, errRtn, hresult);

    if (lpUnknown->QueryInterface(IID_IRunnableObject, (LPLPVOID)&pRO)
        != NOERROR)
    {
        // if no IRunnableObject, no locks
        hresult = NOERROR;
        goto errRtn;
    }

        hresult = pRO->LockRunning(fLock, fLastUnlockCloses);
        pRO->Release();

errRtn:
    OLETRACEOUT((API_OleLockRunning, hresult));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Function:   OleSetContainedObject
//
//  Synopsis:   calls IRunnableObject->SetContainedObject on the given object
//
//  Effects:    Usually has the effect of calling CoLockObjectExternal
//      (lpUnkown, !fContained, FALSE).
//
//  Arguments:  [lpUnknown]  --  pointer to the object
//      [fContained] --  if TRUE, the object is an embedding
//
//  Requires:
//
//  Returns:    HRESULT from the IRO->SetContainedObject call
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      21-Oct-92 alexgo    32bit port, changed GEN_VDATEIFACE to
//                  VDATEIFACE to fix a bug
//
//  Notes:  Containers usually call OleSetContainedObject(..,TRUE) after
//      OleLoad or OleCreate.  The basic idea is to tell OLE that
//      the object is an embedding.  The real effect is to unlock
//      the object (since all objects start out locked) so that
//      other connections may determine it's fate while invisible.
//      OleNoteObjectVisible, for instance, would be called to lock
//      the object when it become visible.
//
//
//--------------------------------------------------------------------------

#pragma SEG(OleSetContainedObject)
STDAPI OleSetContainedObject(LPUNKNOWN lpUnknown, BOOL fContained)
{
    OLETRACEIN((API_OleSetContainedObject, PARAMFMT("lpUnknown= %p, fContained= %B"),
                lpUnknown, fContained));

    VDATEHEAP();

    IRunnableObject FAR*    pRO;
    HRESULT         hresult;

    VDATEIFACE_LABEL(lpUnknown, errRtn, hresult);

    if (lpUnknown->QueryInterface(IID_IRunnableObject, (LPLPVOID)&pRO)
        != NOERROR)
    {
        // if no IRunnableObject, assume container-ness doesn't matter
        hresult = NOERROR;
        goto errRtn;
    }

    hresult = pRO->SetContainedObject(fContained);
    pRO->Release();

errRtn:
    OLETRACEOUT((API_OleSetContainedObject, hresult));

    return hresult;
}


//+-------------------------------------------------------------------------
//
//  Function:   OleNoteObjectVisible
//
//  Synopsis:   Simple calls CoLockObjectExternal
//
//  Effects:
//
//  Arguments:  [lpUnknown] --  pointer to the object
//      [fVisible]  --  if TRUE, then lock the object,
//              if false, then unlock
//
//  Requires:
//
//  Returns:    HRESULT from CoLockObjectExternal
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      21-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(OleNoteObjectVisible)
STDAPI OleNoteObjectVisible(LPUNKNOWN pUnknown, BOOL fVisible)
{
    OLETRACEIN((API_OleNoteObjectVisible, PARAMFMT("pUnknown= %p, fVisible= %B"),
                                pUnknown, fVisible));

    VDATEHEAP();

    // NOTE: we as fLastUnlockReleases=TRUE here because there would
    // otherwise be no other way to fully release the stubmgr.  This
    // means that objects can't use this mechanism to hold invisible
    // objects alive.
    HRESULT hr;

    hr = CoLockObjectExternal(pUnknown, fVisible, TRUE);

    OLETRACEOUT((API_OleNoteObjectVisible, hr));

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   OleSave
//
//  Synopsis:   Writes the CLSID to the storage and calls IPersistStorage->
//      Save()
//
//  Effects:
//
//  Arguments:  [pPS]          --  pointer to the IPersistStorage interface
//                                 on the object to be saved
//      [pstgSave]     --  pointer to the storage to which the object
//                                 should be saved
//      [fSameAsLoad]  --  FALSE indicates a SaveAs operation
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      22-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(OleSave)
STDAPI  OleSave(
    IPersistStorage FAR*    pPS,
    IStorage FAR*       pstgSave,
    BOOL            fSameAsLoad
)
{
    OLETRACEIN((API_OleSave, PARAMFMT("pPS= %p, pstgSave= %p, fSameAsLoad= %B"),
                pPS, pstgSave, fSameAsLoad));

    VDATEHEAP();

    HRESULT     hresult;
    CLSID       clsid;

    VDATEIFACE_LABEL(pPS, errRtn, hresult);
    VDATEIFACE_LABEL(pstgSave, errRtn, hresult);

    if (hresult = pPS->GetClassID(&clsid))
    {
        goto errRtn;
    }

    if (hresult = WriteClassStg(pstgSave, clsid))
    {
        goto errRtn;
    }

    if ((hresult = pPS->Save(pstgSave, fSameAsLoad)) == NOERROR)
    {
        hresult = pstgSave->Commit(0);
    }

errRtn:
    OLETRACEOUT((API_OleSave, hresult));

    return hresult;
}


//+-------------------------------------------------------------------------
//
//  Function:   ReadClassStg
//
//  Synopsis:   Calls IStorage->Stat to get the CLSID from the given storage
//
//  Effects:
//
//  Arguments:  [pstg]    -- pointer to the storage
//      [pclsid]  -- place to return the CLSID
//
//  Requires:
//
//  Returns:    HRESULT from the IS->Stat call
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      22-Oct-93 alexgo    32bit port, fixed bug with invalid
//                  [pclsid] and error on IS->Stat
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(ReadClassStg)
STDAPI ReadClassStg( IStorage FAR * pstg, LPCLSID pclsid)
{
    OLETRACEIN((API_ReadClassStg, PARAMFMT("pstg= %p, pclsid= %p"),
                pstg, pclsid));

    VDATEHEAP();

    HRESULT         hresult;
    STATSTG statstg;

    VDATEIFACE_LABEL(pstg, errRtn, hresult);
    VDATEPTROUT_LABEL(pclsid, CLSID, errRtn, hresult);

    if ((hresult = pstg->Stat(&statstg, STATFLAG_NONAME)) != NOERROR)
    {
        *pclsid = CLSID_NULL;
        goto errRtn;
    }

    *pclsid = statstg.clsid;

errRtn:
    OLETRACEOUT((API_ReadClassStg, hresult));

    return hresult;
}


//+-------------------------------------------------------------------------
//
//  Function:   WriteClassStg
//
//  Synopsis:   Calls IStorage->SetClass to store the CLSID in the given
//      storage
//
//  Effects:
//
//  Arguments:  [pstg]  --  pointer to the storage
//      [clsid] --  the CLSID to write into the storage
//
//  Requires:
//
//  Returns:    HRESULT from the IS->SetClass call
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      22-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(WriteClassStg)
STDAPI WriteClassStg( IStorage FAR * pstg, REFCLSID clsid)
{
    OLETRACEIN((API_WriteClassStg, PARAMFMT("pstg= %p, clsid= %I"),
                pstg, &clsid));

    VDATEHEAP();

    HRESULT hr;

    VDATEIFACE_LABEL(pstg, errRtn, hr);

    // write clsid in storage (what is read above)
    hr = pstg->SetClass(clsid);

errRtn:
    OLETRACEOUT((API_WriteClassStg, hr));

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   ReadM1ClassStm
//
//  Synopsis:   Reads -1L, CLSID from the given stream
//
//  Effects:
//
//  Arguments:  [pStm]      --  pointer to the stream
//              [pclsid]    --  where to put the clsid
//
//  Requires:
//
//  Returns:    HRESULT from the ReadM1ClassStm.
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              24-Oct-93 alexgo    32bit port
//              20-Feb-95 KentCe    Convert to buffered stream reads.
//
//  Notes:      Internal API.
//
//              Reads -1L and CLSID from stream swapping bytes on
//              big-endian machines
//
//--------------------------------------------------------------------------

STDAPI ReadM1ClassStm(LPSTREAM pStm, LPCLSID pclsid)
{
    VDATEHEAP();
    CStmBufRead StmRead;
    HRESULT error;


    StmRead.Init(pStm);

    error = ReadM1ClassStmBuf(StmRead, pclsid);

    if (error != NOERROR)
        *pclsid = CLSID_NULL;

    StmRead.Release();

    return error;
}


//+-------------------------------------------------------------------------
//
//  Function:   WriteM1ClassStm
//
//  Synopsis:   Writes -1L, CLSID to the given stream
//
//  Effects:
//
//  Arguments:  [pStm]      --  pointer to the stream
//              [clsid]     --  CLSID to be written
//
//  Requires:
//
//  Returns:    HRESULT from the WriteM1ClassStm
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              11-Jan-84 alexgo    changed dw from a DWORD to a LONG
//              24-Oct-93 alexgo    32bit port
//              20-Feb-95 KentCe    Convert to buffered stream writes.
//
//  Notes:      Internal API.
//
//              Writess -1L and CLSID from stream swapping bytes on
//              big-endian machines
//
//--------------------------------------------------------------------------

STDAPI WriteM1ClassStm(LPSTREAM pStm, REFCLSID clsid)
{
    VDATEHEAP();

    CStmBufWrite StmWrite;
    HRESULT error;

    VDATEIFACE( pStm );


    StmWrite.Init(pStm);

    error = WriteM1ClassStmBuf(StmWrite, clsid);
    if (FAILED(error))
    {
        goto errRtn;
    }

    error = StmWrite.Flush();

errRtn:
    StmWrite.Release();

    return error;
}


//+-------------------------------------------------------------------------
//
//  Function:   ReadM1ClassStmBuf
//
//  Synopsis:   Reads -1L and CLSID from the given buffered stream.
//
//  Arguments:  [StmRead]   --  Stream Read Object.
//              [pclsid]    --  Where to put the clsid
//
//  Returns:    HRESULT from the StmRead.Read's
//
//
//  History:    dd-mmm-yy Author    Comment
//              20-Feb-95 KentCe    Convert to buffered stream reads.
//              24-Oct-93 alexgo    32bit port
//
//  Notes:      Internal API.
//
//              Reads -1L and CLSID from stream swapping bytes on
//              big-endian machines
//
//--------------------------------------------------------------------------

STDAPI ReadM1ClassStmBuf(CStmBufRead & StmRead, LPCLSID pclsid)
{
    VDATEHEAP();

    HRESULT error;
    LONG lValue;


    if ((error = StmRead.ReadLong(&lValue)) != NOERROR)
    {
        goto errRtn;
    }

    if (lValue == -1)
    {
        // have a GUID
        error = StmRead.Read((void FAR *)pclsid, sizeof(CLSID));
    }
    else
    {
        // this is now an error; we don't allow string form
        // of clsid anymore
        error = ResultFromScode(E_UNSPEC);
    }

errRtn:
    if (error != NOERROR)
    {
        *pclsid = CLSID_NULL;
    }

    return error;
}


//+-------------------------------------------------------------------------
//
//  Function:   WriteM1ClassStmBuf
//
//  Synopsis:   Writes -1L and CLSID to the given buffered stream.
//
//  Arguments:  [StmRead]   --  Stream Write Object.
//              [pclsid]    --  Where to read the clsid
//
//  Returns:    HRESULT from the StmWrite.Write's
//
//
//  History:    dd-mmm-yy Author    Comment
//              20-Feb-95 KentCe    Convert to buffered stream reads.
//              24-Oct-93 alexgo    32bit port
//
//  Notes:      Internal API.
//
//              Writess -1L and CLSID from stream swapping bytes on
//              big-endian machines
//
//--------------------------------------------------------------------------

STDAPI WriteM1ClassStmBuf(CStmBufWrite & StmWrite, REFCLSID clsid)
{
    VDATEHEAP();

    HRESULT error;

    // format is -1L followed by GUID
    if ((error = StmWrite.WriteLong(-1)) != NOERROR)
        return error;

    return StmWrite.Write((LPVOID)&clsid, sizeof(clsid));
}


//+-------------------------------------------------------------------------
//
//  Function:   ReadClassStm
//
//  Synopsis:   Reads the CLSID from the given stream
//
//  Effects:
//
//  Arguments:  [pStm]      -- pointer to the stream
//      [pclsid]    -- where to put the clsid
//
//  Requires:
//
//  Returns:    HRESULT from the IStream->Read
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      24-Oct-93 alexgo     32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(ReadClassStm)
// reads CLSID from stream swapping bytes on big-endian machines
STDAPI ReadClassStm(LPSTREAM pStm, LPCLSID pclsid)
{
    OLETRACEIN((API_ReadClassStm, PARAMFMT("pStm= %p, pclsid= %p"), pStm, pclsid));

    VDATEHEAP();
    HRESULT error;

    VDATEIFACE_LABEL( pStm, errRtn, error );
    VDATEPTROUT_LABEL(pclsid, CLSID, errRtn, error);

    if ((error = StRead(pStm, (void FAR *)pclsid, sizeof(CLSID)))
        != NOERROR)
        *pclsid = CLSID_NULL;

errRtn:
    OLETRACEOUT((API_ReadClassStm, error));

    return error;
}


//+-------------------------------------------------------------------------
//
//  Function:   WriteClassStm
//
//  Synopsis:   Writes the class ID to the given stream
//
//  Effects:
//
//  Arguments:  [pStm]      --  pointer to the stream
//      [clsid]     --  CLSID to write to the stream
//
//  Requires:
//
//  Returns:    HRESULT from the IStream->Write call
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      24-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(WriteClassStm)
// writes CLSID to stream swapping bytes on big-endian machines
STDAPI WriteClassStm(LPSTREAM pStm, REFCLSID clsid)
{
    OLETRACEIN((API_WriteClassStm, PARAMFMT("pStm= %p, clsid= %I"), pStm, &clsid));

    VDATEHEAP();

    HRESULT hr;

    VDATEIFACE_LABEL( pStm, errRtn, hr);

    hr = pStm->Write(&clsid, sizeof(clsid), NULL);

errRtn:
    OLETRACEOUT((API_WriteClassStm, hr));

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   ReleaseStgMedium
//
//  Synopsis:   Releases any resources held by a storage medium
//
//  Arguments:  [pMedium]   --  pointer to the storage medium
//
//  Returns:    nothing
//
//  History:    dd-mmm-yy Author    Comment
//              24-Oct-93 alexgo    32-bit port
//              15-May-94 DavePl    Added EMF support
//
//--------------------------------------------------------------------------


#pragma SEG(ReleaseStgMedium)
STDAPI_(void) ReleaseStgMedium( LPSTGMEDIUM pMedium )
{
    OLETRACEIN((API_ReleaseStgMedium, PARAMFMT("pMedium= %p"), pMedium));

    VDATEHEAP();

    if (pMedium) {

        BOOL fPunkRel;

        //VDATEPTRIN rejects NULL
        VOID_VDATEPTRIN_LABEL( pMedium, STGMEDIUM, errRtn);
        fPunkRel = pMedium->pUnkForRelease != NULL;

        switch (pMedium->tymed) {
            case TYMED_HGLOBAL:
                if (pMedium->hGlobal != NULL && !fPunkRel)
                    Verify(GlobalFree(pMedium->hGlobal) == 0);
                break;

            case TYMED_GDI:
                if (pMedium->hGlobal != NULL && !fPunkRel)
                    DeleteObject(pMedium->hGlobal);
                break;

            case TYMED_ENHMF:
                if (pMedium->hEnhMetaFile != NULL && !fPunkRel)
                {
                        Verify(DeleteEnhMetaFile(pMedium->hEnhMetaFile));
                };
                break;

            case TYMED_MFPICT:
                if (pMedium->hGlobal != NULL && !fPunkRel) {
                    LPMETAFILEPICT  pmfp;

                    if ((pmfp = (LPMETAFILEPICT)GlobalLock(pMedium->hGlobal)) == NULL)
                        break;

                    DeleteMetaFile(pmfp->hMF);
                    GlobalUnlock(pMedium->hGlobal);
                    Verify(GlobalFree(pMedium->hGlobal) == 0);
                }
                break;

            case TYMED_FILE:
                if (pMedium->lpszFileName != NULL) {
                    if (!IsValidPtrIn(pMedium->lpszFileName, 1))
                        break;
                    if (!fPunkRel) {
#ifdef WIN32
                        DeleteFile(pMedium->lpszFileName);
#else
#ifdef _MAC
                        // the libraries are essentially small model on the MAC
                        Verify(0==remove(pMedium->lpszFileName));
#else
                    #ifdef OLD_AND_NICE_ASSEMBLER_VERSION
                        // Win 3.1 specific code to call DOS to delete the file
                        // given a far pointer to the file name
                        extern void WINAPI DOS3Call(void);
                        _asm {
                            mov ah,41H
                            push ds
                            lds bx,pMedium
                            lds dx,[bx].lpszFileName
                            call DOS3Call
                            pop ds
                        }
                    #else
                        {
                        OFSTRUCT of;
                        OpenFile(pMedium->lpszFileName, &of, OF_DELETE);
                        }
                    #endif
#endif
#endif
                    }

        //  WARNING: there was a bug in the 16bit code that the filename
        //  string was not being freed if pUnkForRelease was NULL. the
        //  spec says it should delete the string, so we follow the spec
        //  here.

                    PubMemFree(pMedium->lpszFileName);
                    pMedium->lpszFileName = NULL;

                }
                break;

            case TYMED_ISTREAM:
                if (pMedium->pstm != NULL &&
                    IsValidInterface(pMedium->pstm))
                    pMedium->pstm->Release();
                break;

            case TYMED_ISTORAGE:
                if (pMedium->pstg != NULL &&
                    IsValidInterface(pMedium->pstg))
                    pMedium->pstg->Release();
                break;

            case TYMED_NULL:
                break;

            default:
                AssertSz(FALSE, "Invalid medium in ReleaseStgMedium");
        }


        if (pMedium->pUnkForRelease) {
            if (IsValidInterface(pMedium->pUnkForRelease))
                pMedium->pUnkForRelease->Release();
            pMedium->pUnkForRelease = NULL;
        }

        // NULL out to prevent unwanted use of just freed data.
        // Note: this must be done AFTER punkForRelease is called
        // because our special punkForRelease used in remoting
        // needs the tymed value.

        pMedium->tymed = TYMED_NULL;

    }

errRtn:
    OLETRACEOUTEX((API_ReleaseStgMedium, NORETURN));

    return;
}

#ifdef MAC_REVIEW

 This API must be written for MAC and PICT format.
#endif


//+-------------------------------------------------------------------------
//
//  Function:   OleDuplicateData
//
//  Synopsis:   Duplicates data from the given handle and clipboard format
//
//  Effects:
//
//  Arguments:  [hSrc]      --  handle to the data to be duplicated
//              [cfFormat]  --  format of [hSrc]
//              [uiFlags]   --  any flags (such a GMEM_MOVEABLE) for
//                              memory allocation
//
//  Requires:
//
//  Returns:    a HANDLE to the duplicated resource
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              30-May-94 alexgo    added support for enhanced metafiles
//              24-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(OleDuplicateData)
STDAPI_(HANDLE) OleDuplicateData
        (HANDLE hSrc, CLIPFORMAT cfFormat, UINT uiFlags)
{
        HANDLE  hDup;

        OLETRACEIN((API_OleDuplicateData, PARAMFMT("hSrc= %h, cfFormat= %d, uiFlags= %x"),
                        hSrc, cfFormat, uiFlags));

        VDATEHEAP();

        if (!hSrc)
        {
                hDup = NULL;
                goto errRtn;
        }

        switch( cfFormat )
        {
        case CF_BITMAP:
                hDup = (HANDLE) BmDuplicate ((HBITMAP)hSrc, NULL, NULL);
                break;

        case CF_PALETTE:
                hDup = (HANDLE) UtDupPalette ((HPALETTE)hSrc);
                break;

        case CF_ENHMETAFILE:
                hDup = (HANDLE) CopyEnhMetaFile((HENHMETAFILE)hSrc, NULL);
                break;

        case CF_METAFILEPICT:
                if (uiFlags == NULL)
                {
                        uiFlags = GMEM_MOVEABLE;
                }

                LPMETAFILEPICT lpmfpSrc;
                LPMETAFILEPICT lpmfpDst;

                if (!(lpmfpSrc = (LPMETAFILEPICT) GlobalLock (hSrc)))
                {
                        hDup = NULL;
                        goto errRtn;
                }

                if (!(hDup = UtDupGlobal (hSrc, uiFlags)))
                {
                        GlobalUnlock(hSrc);
                        hDup = NULL;
                        goto errRtn;
                }

                if (!(lpmfpDst = (LPMETAFILEPICT) GlobalLock (hDup)))
                {
                        GlobalUnlock(hSrc);
                        GlobalFree (hDup);
                        hDup = NULL;
                        goto errRtn;
                }

                *lpmfpDst = *lpmfpSrc;
                lpmfpDst->hMF = CopyMetaFile (lpmfpSrc->hMF, NULL);
                GlobalUnlock (hSrc);
                GlobalUnlock (hDup);
                break;

        default:
                if (uiFlags == NULL)
                {
                        uiFlags = GMEM_MOVEABLE;
                }

                hDup = UtDupGlobal (hSrc, uiFlags);
        }

errRtn:
        OLETRACEOUTEX((API_OleDuplicateData, RETURNFMT("%h"), hDup));

        return hDup;
}


//+-------------------------------------------------------------------------
//
//  Function:   BmDuplicate
//
//  Synopsis:   Duplicates a bitmap
//
//  Effects:
//
//  Arguments:  [hold]      -- the source bitmap
//      [lpdwSize]  -- where to put the bitmap size
//      [lpBm]      -- where to put the new bitmap
//
//  Requires:
//
//  Returns:    A handle to the new bitmap
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      25-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(BmDuplicate)
FARINTERNAL_(HBITMAP) BmDuplicate
    (HBITMAP hold, DWORD FAR* lpdwSize, LPBITMAP lpBm)
{
    VDATEHEAP();

        HBITMAP     hnew = NULL;
        HANDLE      hMem;
        LPVOID      lpMem;
        DWORD       dwSize;
        BITMAP      bm;
        SIZE        extents;

        extents.cx = extents.cy = 0;

        // REVIEW (davepl): The bitmap pointer here was being cast to LPOLESTR
        // for some reason. It's takes a void pointer!

        GetObject (hold, sizeof(BITMAP), &bm);
        dwSize = ((DWORD) bm.bmHeight) * ((DWORD) bm.bmWidthBytes)  *
            ((DWORD) bm.bmPlanes);

        if (!(hMem = GlobalAlloc (GMEM_MOVEABLE, dwSize)))
            return NULL;

        if (!(lpMem = GlobalLock (hMem)))
        goto errRtn;

    GlobalUnlock (hMem);

        // REVIEW(davepl): This should probably use GetDIBits() instead

        GetBitmapBits (hold, dwSize, lpMem);
        if (hnew = CreateBitmap (bm.bmWidth, bm.bmHeight,
                    bm.bmPlanes, bm.bmBitsPixel, NULL)) {
            if (!SetBitmapBits (hnew, dwSize, lpMem)) {
            DeleteObject (hnew);
            hnew = NULL;
            goto errRtn;
        }
    }

    if (lpdwSize)
        *lpdwSize = dwSize;

    if (lpBm)
        *lpBm = bm;

    if (hnew && GetBitmapDimensionEx(hold, &extents) && extents.cx && extents.cy)
        SetBitmapDimensionEx(hnew, extents.cx, extents.cy, NULL);

errRtn:
    if (hMem)
        GlobalFree (hMem);

    return hnew;
}





//+-------------------------------------------------------------------------
//
//  Function:   ReadOleStg
//
//  Synopsis:   Internal API to read private OLE information from
//      the OLE_STREAM in the given storage
//
//  Effects:
//
//  Arguments:  [pstg]      -- pointer to the storage
//      [pdwFlags]  -- where to put flags stored in the
//                 the stream (may be NULL)
//      [pdwOptUpdate]  -- where to put the update flags
//                 (may be NULL)
//      [pdwReserved]   -- where to put the reserved value
//                 (may be NULL)
//      [ppmk]      -- where to put the moniker
//                 (may be NULL)
//      [ppstmOut]  -- where to put the OLE_STREAM pointer
//                 (may be NULL)
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      27-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(ReadOleStg)
STDAPI ReadOleStg
    (LPSTORAGE pstg, DWORD FAR* pdwFlags, DWORD FAR* pdwOptUpdate,
     DWORD FAR* pdwReserved, LPMONIKER FAR* ppmk, LPSTREAM FAR* ppstmOut)
{
    OLETRACEIN((API_ReadOleStg,
        PARAMFMT("pdwFlags= %p, pdwOptUpdate= %p, pdwReserved= %p, ppmk= %p, ppstmOut= %p"),
        pdwFlags, pdwOptUpdate, pdwReserved, ppmk, ppstmOut));

    VDATEHEAP();

    HRESULT         error;
    IStream FAR *       pstm;
    DWORD           dwBuf[4];
    LPMONIKER       pmk;
    LPOLESTR            szClassName = OLE_STREAM;

    if (ppmk)
    {
        VDATEPTROUT_LABEL( ppmk, LPMONIKER, errNoFreeRtn, error);
        *ppmk = NULL;
    }

    if (ppstmOut){
        VDATEPTROUT_LABEL( ppstmOut, LPSTREAM, errNoFreeRtn, error);
        *ppstmOut = NULL;
    }
    VDATEIFACE_LABEL( pstg, errNoFreeRtn, error);

    if ((error = pstg->OpenStream(szClassName, NULL,
        (STGM_READ | STGM_SHARE_EXCLUSIVE), 0, &pstm)) != NOERROR) {
        // This error is OK for some callers (ex: default handler)
        // of this function. They depend on NOERROR or this error
        // code. So, don't change the error code.
        error = ReportResult(0, STG_E_FILENOTFOUND, 0, 0);
        goto errNoFreeRtn;
    }

    // read Ole version number, flags, Update options, reserved field
    if ((error = StRead (pstm, dwBuf, 4*sizeof(DWORD))) != NOERROR)
        goto errRtn;

    if (dwBuf[0] != gdwOleVersion) {
        error = ResultFromScode(DV_E_CLIPFORMAT);
        goto errRtn;
    }

    if (pdwFlags)
        *pdwFlags = dwBuf[1];

    if (pdwOptUpdate)
        *pdwOptUpdate = dwBuf[2];

    AssertSz(dwBuf[3] == NULL,"Reserved field in OLE STREAM is not NULL");

    if (dwBuf[3] != NULL) {
        error = ResultFromScode(DV_E_CLIPFORMAT);
        goto errRtn;
    }

    if (pdwReserved)
        *pdwReserved = dwBuf[3];

    if ((error = ReadMonikerStm (pstm, &pmk)) != NOERROR)
        goto errRtn;

    if (ppmk)
        *ppmk = pmk;
    else if (pmk)
        pmk->Release();

errRtn:
    if (pstm) {
        if ((error == NOERROR) && (ppstmOut != NULL))
            *ppstmOut = pstm;
        else
            pstm->Release();
    }

errNoFreeRtn:
    OLETRACEOUT((API_ReadOleStg, error));

    return error;
}


//+-------------------------------------------------------------------------
//
//  Function: WriteOleStg
//
//  Synopsis: Writes private OLE info into an OLE_STREAM in the given storage.
//
//  Arguments:  [pstg]       [in]  -- pointer to the storage
//              [pOleObj]    [in]  -- object from which to get info to write
//                                    (may be NULL)
//              [dwReserved] [in]  -- reserved
//              [ppstmOut]   [out] -- pointer to return the private stream
//                                    (may be NULL)
//  Returns:    HRESULT
//
//  History:    dd-mmm-yy    Author    Comment
//              Oct 27, 93   alexgo    32bit port
//              Oct 23, 96   gopalk    Changed to call WriteOleStgEx
//
//--------------------------------------------------------------------------

#pragma SEG(WriteOleStg)
STDAPI WriteOleStg(LPSTORAGE pstg, IOleObject* pOleObj, DWORD dwReserved, 
                   LPSTREAM* ppstmOut)
{
    OLETRACEIN((API_WriteOleStg, 
                PARAMFMT("pstg=%p, pOleObj=%p, dwReserved=%x, ppstmOut=%p, "),
                pstg, pOleObj, dwReserved, ppstmOut));

    // Local variable
    HRESULT error;

    do {
        // Validation Checks
        VDATEHEAP();
        if(ppstmOut && !IsValidPtrOut(ppstmOut, sizeof(LPSTREAM))) {
            error = ResultFromScode(E_INVALIDARG);
            break;
        }
        if(!IsValidInterface(pstg)) {
            error = ResultFromScode(E_INVALIDARG);
            break;
        }
        if(pOleObj && !IsValidInterface(pOleObj)) {
            error = ResultFromScode(E_INVALIDARG);
            break;
        }
        
        // Call WriteOleStgEx
        error = WriteOleStgEx(pstg, pOleObj, dwReserved, 0, ppstmOut);
    } while(FALSE);

    OLETRACEOUT((API_WriteOleStg, error));
    return error;
}

//+-------------------------------------------------------------------------
//
//  Function: WriteOleStgEx (Internal)
//
//  Synopsis: Writes private OLE info into an OLE_STREAM in the given storage.
//
//  Arguments:  [pstg]         [in]  -- pointer to the storage
//              [pOleObj]      [in]  -- object from which to get info to write
//                                      (may be NULL)
//              [dwReserved]   [in]  -- reserved
//              [ppstmOut]     [out] -- pointer to return the private stream
//                                      (may be NULL)
//              [dwGivenFlags] [in]  -- Additional object flags to be set
//
//  Returns:    HRESULT
//
//  History:    dd-mmm-yy    Author    Comment
//              Oct 23, 96   gopalk    Creation
//
//--------------------------------------------------------------------------
STDAPI WriteOleStgEx(LPSTORAGE pstg, IOleObject* pOleObj, DWORD dwReserved, 
                     DWORD dwGivenFlags, LPSTREAM* ppstmOut)
{
    // Local Variables
    HRESULT error = NOERROR;
    IStream* pstm = NULL;
    IOleLink* pLink;
    LPMONIKER pmk;
    DWORD dwUpdOpt;
    ULONG cbRead;
    DWORD objflags;
    ULARGE_INTEGER ularge_integer;
    LARGE_INTEGER large_integer;

    // Initialize out parameter
    if(ppstmOut)
        *ppstmOut = NULL;

    // Open or Create OLE_STREAM
    error = OpenOrCreateStream(pstg, OLE_STREAM, &pstm);
    if(error == NOERROR) {
        // Write Ole version
        error = pstm->Write(&gdwOleVersion, sizeof(DWORD), NULL);
        if(error == NOERROR) {
            // Read existing Objflags to preserve doc bit
            if(pstm->Read(&objflags, sizeof(DWORD), &cbRead) != NOERROR ||
               cbRead != sizeof(DWORD))
                objflags = 0;

            // Only preserve docbit
            objflags &= OBJFLAGS_DOCUMENT;
            // Set the given flags
            objflags |= dwGivenFlags;

            // Obtain link update options 
            dwUpdOpt = 0L;
            if(pOleObj != NULL &&
               pOleObj->QueryInterface(IID_IOleLink, (void **)&pLink) == NOERROR) {
                objflags |= OBJFLAGS_LINK;
                pLink->GetUpdateOptions(&dwUpdOpt);
                pLink->Release();
            }

            // Seek to the Objflags field. We could be off due to the above read
            LISet32(large_integer, sizeof(DWORD));
            error = pstm->Seek(large_integer, STREAM_SEEK_SET, NULL);
            if(error == NOERROR) {
                // Write Objflags and link update options
                DWORD dwBuf[3];

                dwBuf[0] = objflags;
                dwBuf[1] = dwUpdOpt;
                Win4Assert(dwReserved == NULL);
                dwBuf[2] = 0L;

                error = pstm->Write(dwBuf, 3*sizeof(DWORD), NULL);
                if(error == NOERROR) {
                    // Obtain object moniker
                    pmk = NULL;
                    if(pOleObj != NULL) {
                       error = pOleObj->GetMoniker(OLEGETMONIKER_ONLYIFTHERE,
                                                   OLEWHICHMK_OBJREL, &pmk);
                       if(SUCCEEDED(error) && !IsValidInterface(pmk)) {
                           Win4Assert(FALSE);
                           pmk = NULL;
                       }
                       else if(FAILED(error) && pmk) {
                           Win4Assert(FALSE);
                           if(!IsValidInterface(pmk))
                               pmk = NULL;
                       }

                       // Write Object moniker
                       error = WriteMonikerStm(pstm, pmk);
                       if(pmk)
                           pmk->Release();

                       // Truncate the stream to remove any existing data
                       if(error == NOERROR) {
                           LISet32(large_integer, 0);
                           error = pstm->Seek(large_integer, STREAM_SEEK_CUR, 
                                              &ularge_integer);
                           if(error == NOERROR)
                               pstm->SetSize(ularge_integer);
                       }
                    }
                }
            }
        }
        
        if(error==NOERROR && ppstmOut)
            *ppstmOut = pstm;
        else
            pstm->Release();
    }
            
    return error;
}

//+-------------------------------------------------------------------------
//
//  Function:   SetBitOleStg
//
//  Synopsis:   internal function to write private OLE info into
//      OLE_STREAM on the given storage
//
//  Effects:
//
//  Arguments:  [pstg]      -- pointer to the storage
//      [mask]      -- mask for old values
//      [value]     -- values to write
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  writes (old_values & mask ) | value into the stream
//
//  History:    dd-mmm-yy Author    Comment
//      27-Oct-93 alexgo    32-bit port, fixed bugs
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(SetBitOleStg)

static INTERNAL SetBitOleStg(LPSTORAGE pstg, DWORD mask, DWORD value)
{
    VDATEHEAP();

    IStream FAR *       pstm = NULL;
    HRESULT         error;
    DWORD           objflags = 0;
    LARGE_INTEGER       large_integer;

    VDATEIFACE( pstg );

    if (error = pstg->OpenStream(OLE_STREAM, NULL, STGM_SALL, 0, &pstm))
    {
        if (STG_E_FILENOTFOUND != GetScode(error))
            goto errRtn;

        if ((error = pstg->CreateStream(OLE_STREAM, STGM_SALL,
            0, 0, &pstm)) != NOERROR)
            goto errRtn;

        DWORD dwBuf[5];

        dwBuf[0] = gdwOleVersion;
        dwBuf[1] = objflags;
        dwBuf[2] = 0L;
        dwBuf[3] = 0L;
        dwBuf[4] = 0L;

        if ((error = pstm->Write(dwBuf, 5*sizeof(DWORD), NULL))
            != NOERROR)
            goto errRtn;
    }

    // seek directly to word, read, modify, seek back and write.
    LISet32( large_integer, sizeof(DWORD) );
    if ((error =  pstm->Seek(large_integer, STREAM_SEEK_SET, NULL))
        != NOERROR)
        goto errRtn;

    if ((error =  StRead(pstm, &objflags, sizeof(objflags))) != NOERROR)
        goto errRtn;

    objflags = (objflags & mask) | value;

    LISet32( large_integer, sizeof(DWORD) );
    if ((error =  pstm->Seek(large_integer, STREAM_SEEK_SET, NULL))
        != NOERROR)
        goto errRtn;

    error = pstm->Write(&objflags, sizeof(DWORD), NULL);

errRtn:// close and return error code.
    if (pstm)
        pstm->Release();
    return error;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetFlagsOleStg
//
//  Synopsis:   Internal function to get the private ole flags from a
//      given storage
//
//  Effects:
//
//  Arguments:  [pstg]      --  pointer to the storage
//      [lpobjflags]    --  where to put the flags
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      27-Oct-93 alexgo    32bit port, fixed bugs (error return)
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(GetFlagsOleStg)

static INTERNAL GetFlagsOleStg(LPSTORAGE pstg, LPDWORD lpobjflags)
{
    VDATEHEAP();

    IStream FAR *       pstm = NULL;
    HRESULT         error;
    LARGE_INTEGER       large_integer;

    VDATEIFACE( pstg );

    if ((error = pstg->OpenStream(OLE_STREAM, NULL,
                    (STGM_READ | STGM_SHARE_EXCLUSIVE),
                    0, &pstm)) != NOERROR)
        goto errRtn;

    // seek directly to word, read, modify, seek back and write.
    LISet32( large_integer, sizeof(DWORD) );
    if ((error =  pstm->Seek(large_integer, STREAM_SEEK_SET, NULL))
        != NOERROR)
        goto errRtn;

    error =  StRead(pstm, lpobjflags, sizeof(*lpobjflags));

errRtn:
    if (pstm)
        pstm->Release();
    return error;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetDocumentBitStg
//
//  Synopsis:   returns the doc bit from the given storage
//
//  Effects:
//
//  Arguments:  [pStg]      --  pointer to the storage
//
//  Requires:
//
//  Returns:    NOERROR if the doc bit is set, S_FALSE if not
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      27-Oct-93 alexgo    32bit port
//
//  Notes:
//      REVIEW32:: Nobody seems to use this function.  Nuke it.
//
//--------------------------------------------------------------------------


#pragma SEG(GetDocumentBitStg)
// get doc bit; return NOERROR if on; S_FALSE if off
STDAPI GetDocumentBitStg(LPSTORAGE pStg)
{
    OLETRACEIN((API_GetDocumentBitStg, PARAMFMT("pStg= %p"), pStg));

    VDATEHEAP();

    DWORD objflags;
    HRESULT error;

    if ((error = GetFlagsOleStg(pStg, &objflags)) == NOERROR)
    {
        if(!(objflags&OBJFLAGS_DOCUMENT))
        {
                error = ResultFromScode(S_FALSE);
        }
    }

    OLETRACEOUT((API_GetDocumentBitStg, error));

    return error;
}

//+-------------------------------------------------------------------------
//
//  Function:   SetDocumentBitStg
//
//  Synopsis:   Writes the document bit to the given storage
//
//  Effects:
//
//  Arguments:  [pStg]      --  pointer to the storage
//      [fDocument] --  TRUE, storage is a document, false
//                  otherwise
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      27-Oct-93 alexgo    32-bit port
//
//  Notes:
//      REVIEW32: nobody seems to use this function, nuke it
//
//--------------------------------------------------------------------------


#pragma SEG(SetDocumentBitStg)
// set doc bit according to fDocument
STDAPI SetDocumentBitStg(LPSTORAGE pStg, BOOL fDocument)
{
    OLETRACEIN((API_SetDocumentBitStg, PARAMFMT("pStg= %p, fDocument= %B"),
                                pStg, fDocument));

    VDATEHEAP();

    HRESULT hr;

    hr = SetBitOleStg(pStg, fDocument ? -1L : ~OBJFLAGS_DOCUMENT,
        fDocument ? OBJFLAGS_DOCUMENT : 0);

    OLETRACEOUT((API_SetDocumentBitStg, hr));

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetConvertStg
//
//  Synopsis:   Gets the convert bit from the given storage
//
//  Effects:
//
//  Arguments:  [pStg]      -- pointer to the storage
//
//  Requires:
//
//  Returns:    NOERROR if set, S_FALSE if not
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      27-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(GetConvertStg)
STDAPI GetConvertStg(LPSTORAGE pStg)
{
    OLETRACEIN((API_GetConvertStg, PARAMFMT("pStg= %p"), pStg));

    VDATEHEAP();

    DWORD objflags;
    HRESULT error;

    if ((error = GetFlagsOleStg(pStg, &objflags)) != NOERROR)
    {
        goto errRtn;
    }

    if (objflags&OBJFLAGS_CONVERT)
    {
        error = NOERROR;
    }
    else
    {
        error = ResultFromScode(S_FALSE);
    }

errRtn:
    OLETRACEOUT((API_GetConvertStg, error));

    return error;
}

//+-------------------------------------------------------------------------
//
//  Function:   SetConvertStg
//
//  Synopsis:   Sets the convert bit in a storage
//
//  Effects:
//
//  Arguments:  [pStg]      -- pointer to the storage
//      [fConvert]  -- convert bit
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      27-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(SetConvertStg)
STDAPI SetConvertStg(LPSTORAGE pStg, BOOL fConvert)
{
    OLETRACEIN((API_SetConvertStg, PARAMFMT("pStg= %p, fConvert= %B"),
                                pStg, fConvert));

    VDATEHEAP();

    HRESULT hr;

    hr = SetBitOleStg(pStg, fConvert ? -1L : ~OBJFLAGS_CONVERT,
        fConvert ? OBJFLAGS_CONVERT : 0);

    OLETRACEOUT((API_SetConvertStg, hr));

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   ReadClipformatStm
//
//  Synopsis:   Reads the clipboard format from the given stream
//
//  Effects:    If the clipboard format is a length followed by a
//              string, then the string is read and registered as a
//              clipboard format (and the new format number is returned).
//
//  Arguments:  [lpstream]      -- pointer to the stream
//              [lpdwCf]        -- where to put the clipboard format
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  the format of the stream must be one of the following:
//              0           No clipboard format
//              -1 DWORD    predefined windows clipboard format in
//                          the second dword.
//              -2 DWORD    predefined mac clipboard format in the
//                          second dword.  This may be obsolete or
//                          irrelevant for us.  REVIEW32
//              num STRING  clipboard format name string (prefaced
//                          by length of string).
//
//  History:    dd-mmm-yy Author    Comment
//              27-Oct-93 alexgo    32bit port, fixed ifdef and NULL
//                                  pointer bugs
//
//              17-Mar-94 davepl    Revereted to ANSI string reads
//  Notes:
//
//--------------------------------------------------------------------------

STDAPI ReadClipformatStm(LPSTREAM lpstream, DWORD FAR* lpdwCf)
{
    VDATEHEAP();

    HRESULT     error;
    DWORD       dwValue;

    VDATEIFACE(lpstream);
    VDATEPTROUT(lpdwCf, DWORD);

    if (error = StRead(lpstream, &dwValue, sizeof(DWORD)))
    {
        return error;
    }

    if (dwValue == NULL)
    {
        // NULL cf value
        *lpdwCf = NULL;

    }
    else if (dwValue == -1L)
    {
        // Then this is a NON-NULL predefined windows clipformat.
        // The clipformat values follows

        if (error = StRead(lpstream, &dwValue, sizeof(DWORD)))
            return error;

        *lpdwCf = dwValue;

    }
    else if (dwValue == -2L)
    {
        // Then this is a NON-NULL MAC clipboard format.
        // The clipformat value follows. For MAC the CLIPFORMAT
        // is 4 bytes

        if (error = StRead(lpstream, &dwValue, sizeof(DWORD)))
        {
            return error;
        }
        *lpdwCf = dwValue;
        return ResultFromScode(OLE_S_MAC_CLIPFORMAT);
    }
    else
    {
        char szACF[MAX_STR];

        if (error = StRead(lpstream, szACF, dwValue))
        {
            return error;
        }

        if (((*lpdwCf = (DWORD) SSRegisterClipboardFormatA(szACF))) == 0)
        {
            return ResultFromScode(DV_E_CLIPFORMAT);
        }
    }

    return NOERROR;
}


//+-------------------------------------------------------------------------
//
//  Function:   WriteClipformatStm
//
//  Synopsis:   Writes the clipboard format the given stream
//
//  Arguments:  [lpstream]      -- pointer to the stream
//              [cf]            -- the clipboard format
//
//  Returns:    HRESULT
//
//  History:    dd-mmm-yy Author    Comment
//              11-Jan-94 alexgo    cast -1 to a DWORD to remove compile
//                                  warning
//              27-Oct-93 alexgo    32bit port
//              16-Mar-94 davepl    Revereted to ANSI string writes
//
//  Notes:      see ReadClipformatStm for a description of the
//              data layout in the stream
//
//--------------------------------------------------------------------------


#pragma SEG(WriteClipformatStm)
STDAPI WriteClipformatStm(LPSTREAM lpstream, CLIPFORMAT cf)
{
    VDATEHEAP();

#ifdef _MAC

    AssertSz(0,"WriteClipformatStm NYI");
    return ReportResult(0, E_NOTIMPL, 0, 0);

#else

    HRESULT     error;

    VDATEIFACE( lpstream );

    //REVIEW32  where did 0xC000 come from???  Is this
    //portable to NT && Chicago???  Try to replace with a constant.
    //(although there don't seem to be any :( )

    if (cf < 0xC000)
    {
        DWORD dwBuf[2];
        DWORD dwSize = sizeof(DWORD);

        if (cf == NULL)
        {
            dwBuf[0] = NULL;
        }
        else
        {
            // write -1L, to indicate NON NULL predefined
            // clipboard format

            dwBuf[0] = (DWORD)-1L;
            dwBuf[1] = (DWORD)cf;
            dwSize += sizeof(DWORD);
        }

        if (error = StWrite(lpstream, dwBuf, dwSize))
        {
            return error;
        }

    }
    else
    {
        // it is a registerd clipboard format

        char szACF[MAX_STR];
        ULONG len;

        // Get the name of the clipboard format

        len = SSGetClipboardFormatNameA(cf, szACF, sizeof(szACF));
        if (0 == len)
        {
            return ResultFromScode(E_UNSPEC);
        }

        ++len;          // Account for NULL terminator
        if (error = StWrite(lpstream, &len, sizeof(len)))
        {
            return error;
        }

        // Write it (plus terminator) to the stream
        if (error = StWrite(lpstream, szACF, len))
        {
            return error;
        }
    }

    return NOERROR;

#endif  // _MAC
}

//+-------------------------------------------------------------------------
//
//  Function:   WriteMonikerStm
//
//  Synopsis:   Writes the persistent state of the given moniker to the
//      given stream.  Internal
//
//  Effects:
//
//  Arguments:  [pstm]      --  pointer to the stream
//      [pmk]       --  pointer to the moniker
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      27-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(WriteMonikerStm)
// write size long followed by persistent moniker
STDAPI WriteMonikerStm (LPSTREAM pstm, LPMONIKER pmk)
{
    VDATEHEAP();

    DWORD   cb = NULL;
    ULARGE_INTEGER  dwBegin;
    ULARGE_INTEGER  dwEnd;
    HRESULT   error;
    LARGE_INTEGER large_integer;

    VDATEIFACE( pstm );

    if (pmk == NULL)
        return pstm->Write(&cb, sizeof(DWORD), NULL);
    else {
        VDATEIFACE( pmk );
        // get the begining position
        LISet32( large_integer, 0 );
        if ((error =  pstm->Seek (large_integer,
            STREAM_SEEK_CUR, &dwBegin)) != NOERROR)
            return error;

        // skip the moniker size DWORD
        LISet32( large_integer, 4);
        if ((error =  pstm->Seek (large_integer,
            STREAM_SEEK_CUR, NULL)) != NOERROR)
            return error;

        if ((error = OleSaveToStream (pmk, pstm)) != NOERROR)
            return error;

        // get the end position
        LISet32( large_integer, 0);
        if ((error =  pstm->Seek (large_integer,
            STREAM_SEEK_CUR, &dwEnd)) != NOERROR)
            return error;

        // moniker data size
        cb = dwEnd.LowPart - dwBegin.LowPart;

        // seek to the begining position
        LISet32( large_integer, dwBegin.LowPart);
        if ((error =  pstm->Seek (large_integer,
            STREAM_SEEK_SET,NULL)) != NOERROR)
            return error;

        // write moniker info size
        if ((error = pstm->Write(&cb, sizeof(DWORD),
            NULL)) != NOERROR)
            return error;

        // seek to the end position
        LISet32( large_integer, dwEnd.LowPart);
        return pstm->Seek (large_integer, STREAM_SEEK_SET, NULL);
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   ReadMonikerStm
//
//  Synopsis:   Reads a moniker from the given stream (inverse of
//      WriteMonikerStm)
//
//  Effects:
//
//  Arguments:  [pstm]      -- pointer to the stream
//      [ppmk]      -- where to put the moniker
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//      27-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(ReadMonikerStm)
// read size long followed by persistent moniker
STDAPI ReadMonikerStm (LPSTREAM pstm, LPMONIKER FAR* ppmk)
{
    VDATEHEAP();

    HRESULT     error;
    DWORD       cb;

    VDATEPTROUT( ppmk, LPMONIKER );
    *ppmk = NULL;
    VDATEIFACE( pstm );

    if ((error =  StRead (pstm, &cb, sizeof(DWORD))) != NOERROR)
        return error;

    if (cb == NULL)
        return NOERROR;

    return OleLoadFromStream (pstm, IID_IMoniker, (LPLPVOID) ppmk);
}

//+-------------------------------------------------------------------------
//
//  Function:   OleDraw
//
//  Synopsis:   Calls IViewObject->Draw on the given object
//
//  Effects:    Draws something on the screen :)
//
//  Arguments:  [lpUnk]     -- pointer to the object
//              [dwAspect]  -- aspect to draw (NORMAL, ICON, etc)
//              [hdcDraw]   -- the device context to use
//              [lprcBounds]    -- the rectangle in which to draw
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              01-Apr-94 alexgo    fixed usage of MAKELONG (only
//                                  for 16bit)
//              27-Oct-93 alexgo    32bit port
//
//  Notes:
//      On Win32, RECT and RECTL are identical structures, thus there
//      is no need to convert from RECT to RECTL with MAKELONG.
//
//--------------------------------------------------------------------------

#pragma SEG(OleDraw)
STDAPI OleDraw (LPUNKNOWN lpUnk, DWORD dwAspect, HDC hdcDraw,
    LPCRECT lprcBounds)
{
        HRESULT                 error;
        IViewObject FAR*        lpView;

#ifndef WIN32
        RECTL                   rclBounds;
#endif //!WIN32

        OLETRACEIN((API_OleDraw, PARAMFMT("lpUnk= %p, dwAspect= %x, hdcDraw= %h, lprcBounds= %tr"),
                        lpUnk, dwAspect, hdcDraw, lprcBounds));

        VDATEHEAP();


        VDATEIFACE_LABEL( lpUnk, errRtn, error );
        VDATEPTRIN_LABEL( lprcBounds, RECT, errRtn, error);

#ifndef WIN32
        rclBounds.left      = MAKELONG(lprcBounds->left, 0);
        rclBounds.right     = MAKELONG(lprcBounds->right, 0);
        rclBounds.top       = MAKELONG(lprcBounds->top, 0);
        rclBounds.bottom    = MAKELONG(lprcBounds->bottom, 0);

        lprcBounds = &rclBounds;
#endif //!WIN32

        if ((error = lpUnk->QueryInterface (IID_IViewObject,
                (LPLPVOID)&lpView)) != NOERROR)
        {
                error = ResultFromScode(DV_E_NOIVIEWOBJECT);
                goto errRtn;
        }

        error = lpView->Draw (dwAspect, DEF_LINDEX, 0, 0, 0,
                hdcDraw, (LPCRECTL)lprcBounds, 0, 0,0);
        lpView->Release();

errRtn:
        OLETRACEOUT((API_OleDraw, error));

        return error;
}

//+----------------------------------------------------------------------------
//
//      Function:
//              CreateObjectDescriptor, static
//
//      Synopsis:
//              Creates and initializes an OBJECTDESCRIPTOR from the given
//              parameters
//
//      Arguments:
//              [clsid] -- the class ID of the object being transferred
//              [dwAspect] -- the display aspect drawn by the source of the
//                      transfer
//              [psizel] -- pointer to the size of the object
//              [ppointl] -- pointer to the mouse offset in the object that
//                      initiated a drag-drop transfer
//              [dwStatus] -- the OLEMISC status flags for the object
//                      being transferred
//              [lpszFullUserTypeName] -- the full user type name of the
//                      object being transferred
//              [lpszSrcOfCopy] -- a human readable name for the object
//                      being transferred
//
//      Returns:
//              If successful, A handle to the new OBJECTDESCRIPTOR; otherwise
//              NULL.
//
//      Notes:
//              REVIEW, this seems generally useful for anyone using the
//              clipboard, or drag-drop; perhaps it should be exported.
//
//      History:
//              12/07/93 - ChrisWe - file inspection and cleanup
//
//-----------------------------------------------------------------------------
#pragma SEG(CreateObjectDescriptor)
INTERNAL_(HGLOBAL) CreateObjectDescriptor(CLSID clsid, DWORD dwAspect,
                const SIZEL FAR *psizel, const POINTL FAR *ppointl,
                DWORD dwStatus, LPOLESTR lpszFullUserTypeName,
                LPOLESTR lpszSrcOfCopy)
{
        VDATEHEAP();

        DWORD dwFullUserTypeNameBLen; // length of lpszFullUserTypeName in BYTES
        DWORD dwSrcOfCopyBLen; // length of lpszSrcOfCopy in BYTES
        HGLOBAL hMem; // handle to the object descriptor
        LPOBJECTDESCRIPTOR lpOD; // the new object descriptor

        // Get the length of Full User Type Name; Add 1 for the null terminator
        if (!lpszFullUserTypeName)
                dwFullUserTypeNameBLen = 0;
        else
                dwFullUserTypeNameBLen = (_xstrlen(lpszFullUserTypeName) +
                                1) * sizeof(OLECHAR);

        // Get the Source of Copy string and it's length; Add 1 for the null
        // terminator
        if (lpszSrcOfCopy)
                dwSrcOfCopyBLen = (_xstrlen(lpszSrcOfCopy) + 1) *
                                sizeof(OLECHAR);
        else
        {
                // No src moniker so use user type name as source string.
                lpszSrcOfCopy =  lpszFullUserTypeName;
                dwSrcOfCopyBLen = dwFullUserTypeNameBLen;
        }

        // allocate the memory where we'll put the object descriptor
        hMem = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE,
                        sizeof(OBJECTDESCRIPTOR) + dwFullUserTypeNameBLen +
                        dwSrcOfCopyBLen);
        if (hMem == NULL)
                goto error;

        lpOD = (LPOBJECTDESCRIPTOR)GlobalLock(hMem);
        if (lpOD == NULL)
                goto error;

        // Set the FullUserTypeName offset and copy the string
        if (!lpszFullUserTypeName)
        {
                // zero offset indicates that string is not present
                lpOD->dwFullUserTypeName = 0;
        }
        else
        {
                lpOD->dwFullUserTypeName = sizeof(OBJECTDESCRIPTOR);
                _xmemcpy(((BYTE FAR *)lpOD)+lpOD->dwFullUserTypeName,
                                (const void FAR *)lpszFullUserTypeName,
                                dwFullUserTypeNameBLen);
        }

        // Set the SrcOfCopy offset and copy the string
        if (!lpszSrcOfCopy)
        {
                // zero offset indicates that string is not present
                lpOD->dwSrcOfCopy = 0;
        }
        else
        {
                lpOD->dwSrcOfCopy = sizeof(OBJECTDESCRIPTOR) +
                                dwFullUserTypeNameBLen;
                _xmemcpy(((BYTE FAR *)lpOD)+lpOD->dwSrcOfCopy,
                                (const void FAR *)lpszSrcOfCopy,
                                dwSrcOfCopyBLen);
        }

        // Initialize the rest of the OBJECTDESCRIPTOR
        lpOD->cbSize = sizeof(OBJECTDESCRIPTOR) + dwFullUserTypeNameBLen +
                        dwSrcOfCopyBLen;
        lpOD->clsid = clsid;
        lpOD->dwDrawAspect = dwAspect;
        lpOD->sizel = *psizel;
        lpOD->pointl = *ppointl;
        lpOD->dwStatus = dwStatus;

        GlobalUnlock(hMem);
        return(hMem);

error:
        if (hMem)
        {
                GlobalUnlock(hMem);
                GlobalFree(hMem);
        }

        return(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ole232\base\create.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       create.cpp
//
//  Contents:   creation and miscellaneous APIs
//
//  Classes:
//
//  Functions:  OleCreate
//              OleCreateEx
//              OleCreateFromData
//              OleCreateFromDataEx
//              OleCreateLinkFromData
//              OleCreateLinkFromDataEx
//              OleCreateLink
//              OleCreateLinkEx
//              OleCreateLinkToFile
//              OleCreateLinkToFileEx
//              OleCreateFromFile
//              OleCreateFromFileEx
//              OleDoAutoConvert
//              OleLoad
//              OleCreateStaticFromData
//              OleQueryCreateFromData
//              OleQueryLinkFromData
//              CoIsHashedOle1Class     (internal)
//              EnsureCLSIDIsRegistered (internal)
//
//  History:    dd-mmm-yy Author    Comment
//              26-Apr-96 davidwor  Moved validation into separate function.
//              01-Mar-96 davidwor  Added extended create functions.
//              16-Dec-94 alexgo    added call tracing
//              07-Jul-94 KevinRo   Changed RegQueryValue to RegOpenKey in
//                                  strategic places.
//              10-May-94 KevinRo   Reimplemented OLE 1.0 interop
//              24-Jan-94 alexgo    first pass at converting to Cairo-style
//                                  memory allocation
//              11-Jan-94 alexgo    added VDATEHEAP macros to every function
//              10-Dec-93 AlexT     header clean up - include ole1cls.h
//              08-Dec-93 ChrisWe   added necessary casts to GlobalLock() calls
//                      resulting from removing bogus GlobalLock() macros in
//                      le2int.h
//              29-Nov-93 ChrisWe   changed call to UtIsFormatSupported to
//                                      take a single DWORD of direction flags
//              22-Nov-93 ChrisWe   replaced overloaded == with IsEqualxID
//              28-Oct-93 alexgo    32bit port
//              24-Aug-92 srinik    created
//
//--------------------------------------------------------------------------

#include <le2int.h>
#pragma SEG(create)

#include <create.h>
#include <ole1cls.h>    //  Only needed to get CLSID_WordDocument

// HACK ALERT!!  This is needed for the MFC OleQueryCreateFromData hack
#include <clipdata.h>

NAME_SEG(Create)
ASSERTDATA

//used in wCreateObject

#define STG_NONE        0
#define STG_INITNEW     1
#define STG_LOAD        2


#define QUERY_CREATE_NONE               0
#define QUERY_CREATE_OLE                1
#define QUERY_CREATE_STATIC             2

INTERNAL        wDoUpdate(IUnknown FAR* lpUnknown);


//+-------------------------------------------------------------------------
//
//  Function:   wGetEnumFormatEtc
//
//  Synopsis:   retrieves a FormatEtc enumerator
//
//  Effects:
//
//  Arguments:  [pDataObj]      -- the data object
//              [dwDirection]   -- direction
//              [ppenum]        -- where to put the enumerator
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  asks the data object for the enumerator
//              if it returns OLE_S_USEREG, then get try to get the
//              clsid from IOleObject::GetUserClassID and enumerate
//              the formats from the registry.
//
//  History:    dd-mmm-yy Author    Comment
//              24-Apr-94 alexgo    author
//              13-Mar-95 scottsk   Added hack for the Bob Calendar
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT wGetEnumFormatEtc( IDataObject *pDataObj, DWORD dwDirection,
        IEnumFORMATETC **ppIEnum)
{
    HRESULT         hresult;
    IOleObject *    pOleObject;
    CLSID           clsid;

    VDATEHEAP();

    LEDebugOut((DEB_ITRACE, "%p _IN wGetEnumFormatEtc ( %p , %p , %lx )"
        "\n", NULL, pDataObj, ppIEnum, dwDirection));

    hresult = pDataObj->EnumFormatEtc(dwDirection, ppIEnum);

    if( hresult == ResultFromScode(OLE_S_USEREG) )
    {
        hresult = pDataObj->QueryInterface(IID_IOleObject,
                (void **)&pOleObject);

        if( hresult != NOERROR )
        {
            // return E_FAIL vs E_NOINTERFACE
            hresult = ResultFromScode(E_FAIL);
            goto errRtn;
        }

        hresult = pOleObject->GetUserClassID(&clsid);

        if( hresult == NOERROR )
        {
            hresult = OleRegEnumFormatEtc(clsid, dwDirection,
                    ppIEnum);
        }

        pOleObject->Release();
    }
    else if (*ppIEnum == NULL && hresult == NOERROR)
    {
        // HACK ALERT:  NT Bug #8350.   MS Bob Calendar returns success from
        // IDO::EnumFormatEtc and sets *ppIEnum = NULL on the IDO used during
        // drag-drop.  Massage the return value to be failure.
        hresult = E_FAIL;
    }

errRtn:

    LEDebugOut((DEB_ITRACE, "%p OUT wGetEnumFormatEtc ( %lx ) [ %p ]\n",
        NULL, hresult, *ppIEnum));

    return hresult;
}

//+-------------------------------------------------------------------------
//
//  Function:   OleCreate
//
//  Synopsis:   Creates and runs an object of the requested CLSID
//
//  Effects:
//
//  Arguments:  [rclsid]        -- the CLSID of the object to create
//              [iid]           -- the interface to request on the object
//              [renderopt]     -- render options, such as OLERENDER_DRAW
//              [lpFormatEtc]   -- rendering format, if OLERENDER_FORMAT is
//                                 specified in renderopt.
//              [lpClientSite]  -- the client site for the object
//              [lpStg]         -- the object's storage
//              [lplpObj]       -- where to put the pointer to the created
//                                 object
//
//  Requires:   HRESULT
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              16-Dec-94 alexgo    added call tracing
//              05-May-94 alexgo    fixed error case if cache initialization
//                                  fails.
//              28-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(OleCreate)
STDAPI  OleCreate
(
    REFCLSID                rclsid,
    REFIID                  iid,
    DWORD                   renderopt,
    LPFORMATETC             lpFormatEtc,
    IOleClientSite FAR*     lpClientSite,
    IStorage FAR*           lpStg,
    void FAR* FAR*          lplpObj
)
{
    DWORD advf = ADVF_PRIMEFIRST;

    return OleCreateEx(rclsid, iid, 0, renderopt,
        (lpFormatEtc ? 1 : 0), (lpFormatEtc ? &advf : NULL),
        lpFormatEtc, NULL, NULL, lpClientSite, lpStg, lplpObj);
}


//+-------------------------------------------------------------------------
//
//  Function:   OleCreateEx
//
//  Synopsis:   Creates and runs an object of the requested CLSID
//
//  Effects:
//
//  Arguments:  [rclsid]        -- the CLSID of the object to create
//              [iid]           -- the interface to request on the object
//              [dwFlags]       -- object creation flags
//              [renderopt]     -- render options, such as OLERENDER_DRAW
//              [cFormats]      -- the number of elements in rgFormatEtc
//              [rgAdvf]        -- array of advise flags, if OLRENDER_FORMAT
//                                 is specified in renderopt
//              [rgFormatEtc]   -- array of rendering formats, if
//                                 OLERENDER_FORMAT is specified in renderopt
//              [lpAdviseSink]  -- the advise sink for the object
//              [rgdwConnection]-- where to put the connection IDs for the
//                                 advisory connections
//              [lpClientSite]  -- the client site for the object
//              [lpStg]         -- the object's storage
//              [lplpObj]       -- where to put the pointer to the created
//                                 object
//
//  Requires:   HRESULT
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              16-Dec-94 alexgo    added call tracing
//              05-May-94 alexgo    fixed error case if cache initialization
//                                  fails.
//              28-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(OleCreateEx)
STDAPI  OleCreateEx
(
    REFCLSID                rclsid,
    REFIID                  iid,
    DWORD                   dwFlags,
    DWORD                   renderopt,
    ULONG                   cFormats,
    DWORD FAR*              rgAdvf,
    LPFORMATETC             rgFormatEtc,
    IAdviseSink FAR*        lpAdviseSink,
    DWORD FAR*              rgdwConnection,
    IOleClientSite FAR*     lpClientSite,
    IStorage FAR*           lpStg,
    void FAR* FAR*          lplpObj
)
{
    OLETRACEIN((API_OleCreateEx,
                PARAMFMT("rclsid= %I, iid= %I, dwFlags= %x, renderopt= %x, cFormats= %x, rgAdvf= %te, rgFormatEtc= %p, lpAdviseSink= %p, rgdwConnection= %p, lpClientSite= %p, lpStg= %p, lplpObj= %p"),
                &rclsid, &iid, dwFlags, renderopt, cFormats, rgAdvf, rgFormatEtc, lpAdviseSink, rgdwConnection, lpClientSite, lpStg, lplpObj));

    VDATEHEAP();

    HRESULT                 error;
    FORMATETC               formatEtc;
    LPFORMATETC             lpFormatEtc;
    BOOL                    fAlloced = FALSE;

    LEDebugOut((DEB_TRACE, "%p _IN OleCreateEx ( %p , %p , %lx , %lx , %lx ,"
      "%p , %p , %p , %p , %p , %p , %p )\n", 0, &rclsid, &iid, dwFlags,
      renderopt, cFormats, rgAdvf, rgFormatEtc, lpAdviseSink, rgdwConnection,
      lpClientSite, lpStg, lplpObj));

    VDATEPTROUT_LABEL( lplpObj, LPVOID, errRtn, error );
    *lplpObj = NULL;

    VDATEIID_LABEL( iid, errRtn, error);

    error = wValidateCreateParams(dwFlags, renderopt, cFormats, rgAdvf, rgFormatEtc, lpAdviseSink, rgdwConnection, lpClientSite, lpStg);
    if (error != NOERROR)
        goto errRtn;

    if ((error = wValidateFormatEtcEx(renderopt, &cFormats, rgFormatEtc,
        &formatEtc, &lpFormatEtc, &fAlloced)) != NOERROR)
        goto LExit;

    if ((error = wCreateObject(rclsid, FALSE,
                               iid, lpClientSite, lpStg,
                               STG_INITNEW, lplpObj)) != NOERROR)
        goto LExit;

    // No need to Run the object if no caches are requested.
    if ((renderopt != OLERENDER_NONE) && (renderopt != OLERENDER_ASIS))
    {
        if ((error = OleRun((LPUNKNOWN) *lplpObj)) != NOERROR)
            goto LExit;

        if ((error = wInitializeCacheEx(NULL, rclsid, renderopt,
            cFormats, rgAdvf, lpFormatEtc, lpAdviseSink, rgdwConnection,
            *lplpObj))
            != NOERROR)
        {
            // if this fails, we need to call Close
            // to shut down the embedding (the reverse of Run).
            // the final release below will be the final
            // one to nuke the memory image.
            IOleObject *    lpOleObject;

            if( ((IUnknown *)*lplpObj)->QueryInterface(
                IID_IOleObject, (void **)&lpOleObject) == NOERROR )
            {
                Assert(lpOleObject);
                lpOleObject->Close(OLECLOSE_NOSAVE);
                lpOleObject->Release();
            }
        }
    }

LExit:

    if (fAlloced)
        PubMemFree(lpFormatEtc);

    if (error != NOERROR && *lplpObj) {
        ((IUnknown FAR*) *lplpObj)->Release();
        *lplpObj = NULL;
    }

    LEDebugOut((DEB_TRACE, "%p OUT OleCreateEx ( %lx ) [ %p ]\n", 0,
      error, *lplpObj));

    error = wReturnCreationError(error);

errRtn:
    OLETRACEOUT((API_OleCreateEx, error));

    return error;
}


//+-------------------------------------------------------------------------
//
//  Function:   OleCreateFromData
//
//  Synopsis:   Creates an embedded object from an IDataObject pointer
//              (such as an data object from the clipboard or from a drag
//              and drop operation)
//
//  Effects:
//
//  Arguments:  [lpSrcDataObj]  -- pointer to the data object from which
//                                 the object should be created
//              [iid]           -- interface ID to request
//              [renderopt]     -- rendering options (same as OleCreate)
//              [lpFormatEtc]   -- render format options (same as OleCreate)
//              [lpClientSite]  -- client site for the object
//              [lpStg]         -- storage for the object
//              [lplpObj]       -- where to put the object
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              16-Dec-94 alexgo    added call tracing
//              28-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(OleCreateFromData)
STDAPI  OleCreateFromData
(
  IDataObject FAR*            lpSrcDataObj,
  REFIID                      iid,
  DWORD                       renderopt,
  LPFORMATETC                 lpFormatEtc,
  IOleClientSite FAR*         lpClientSite,
  IStorage FAR*               lpStg,
  void FAR* FAR*              lplpObj
)
{
    DWORD advf = ADVF_PRIMEFIRST;

    return OleCreateFromDataEx(lpSrcDataObj, iid, 0, renderopt,
        (lpFormatEtc ? 1 : 0), (lpFormatEtc ? &advf : NULL),
        lpFormatEtc, NULL, NULL, lpClientSite, lpStg, lplpObj);
}


//+-------------------------------------------------------------------------
//
//  Function:   OleCreateFromDataEx
//
//  Synopsis:   Creates an embedded object from an IDataObject pointer
//              (such as an data object from the clipboard or from a drag
//              and drop operation)
//
//  Effects:
//
//  Arguments:  [lpSrcDataObj]  -- pointer to the data object from which
//                                 the object should be created
//              [iid]           -- interface ID to request
//              [dwFlags]       -- object creation flags
//              [renderopt]     -- render options, such as OLERENDER_DRAW
//              [cFormats]      -- the number of elements in rgFormatEtc
//              [rgAdvf]        -- array of advise flags, if OLRENDER_FORMAT
//                                 is specified in renderopt
//              [rgFormatEtc]   -- array of rendering formats, if
//                                 OLERENDER_FORMAT is specified in renderopt
//              [lpAdviseSink]  -- the advise sink for the object
//              [rgdwConnection]-- where to put the connection IDs for the
//                                 advisory connections
//              [lpClientSite]  -- client site for the object
//              [lpStg]         -- storage for the object
//              [lplpObj]       -- where to put the object
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              16-Dec-94 alexgo    added call tracing
//              28-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(OleCreateFromDataEx)
STDAPI  OleCreateFromDataEx
(
    IDataObject FAR*        lpSrcDataObj,
    REFIID                  iid,
    DWORD                   dwFlags,
    DWORD                   renderopt,
    ULONG                   cFormats,
    DWORD FAR*              rgAdvf,
    LPFORMATETC             rgFormatEtc,
    IAdviseSink FAR*        lpAdviseSink,
    DWORD FAR*              rgdwConnection,
    IOleClientSite FAR*     lpClientSite,
    IStorage FAR*           lpStg,
    void FAR* FAR*          lplpObj
)
{
    HRESULT     hresult;
    CLIPFORMAT      cfFormat;
    WORD            wStatus;

    OLETRACEIN((API_OleCreateFromDataEx,
        PARAMFMT("lpSrcDataObj= %p, iid= %I, dwFlags= %x, renderopt= %x, cFormats= %x, rgAdvf= %te, rgFormatEtc= %p, lpAdviseSink= %p, rgdwConnection= %p, lpClientSite= %p, lpStg= %p, lplpObj= %p"),
        lpSrcDataObj, &iid, dwFlags, renderopt, cFormats, rgAdvf, rgFormatEtc, lpAdviseSink, rgdwConnection, lpClientSite, lpStg, lplpObj));

    VDATEHEAP();

    LEDebugOut((DEB_TRACE, "%p _IN OleCreateFromDataEx ( %p , %p , %lx , %lx ,"
        " %lx , %p , %p , %p , %p , %p , %p , %p )\n", 0, lpSrcDataObj, &iid,
        dwFlags, renderopt, cFormats, rgAdvf, rgFormatEtc, lpAdviseSink,
        rgdwConnection, lpClientSite, lpStg, lplpObj));

    VDATEPTROUT_LABEL( lplpObj, LPVOID, safeRtn, hresult );
    *lplpObj = NULL;

    VDATEIFACE_LABEL( lpSrcDataObj, errRtn, hresult );
    VDATEIID_LABEL( iid, errRtn, hresult );

    hresult = wValidateCreateParams(dwFlags, renderopt, cFormats, rgAdvf, rgFormatEtc, lpAdviseSink, rgdwConnection, lpClientSite, lpStg);
    if (hresult != NOERROR)
        goto errRtn;

    wStatus = wQueryEmbedFormats(lpSrcDataObj, &cfFormat);

    if (!(wStatus & QUERY_CREATE_OLE))
    {
        if (wStatus & QUERY_CREATE_STATIC)
        {
            hresult = OLE_E_STATIC;
        }
        else
        {
            hresult = DV_E_FORMATETC;
        }

        goto errRtn;
    }

    // We can create an OLE object.

    // See whether we have to create a package

    if (cfFormat == g_cfFileName || cfFormat == g_cfFileNameW)
    {
        hresult = wCreatePackageEx(lpSrcDataObj, iid, dwFlags, renderopt,
            cFormats, rgAdvf, rgFormatEtc, lpAdviseSink, rgdwConnection,
            lpClientSite, lpStg, FALSE /*fLink*/, lplpObj);
    }
    else
    {
        hresult =  wCreateFromDataEx(lpSrcDataObj, iid, dwFlags, renderopt,
            cFormats, rgAdvf, rgFormatEtc, lpAdviseSink, rgdwConnection,
            lpClientSite, lpStg, lplpObj);
    }

errRtn:

    LEDebugOut((DEB_TRACE, "%p OUT OleCreateFromDataEx ( %lx ) [ %p ]\n",
        0, hresult, *lplpObj));

safeRtn:

    OLETRACEOUT((API_OleCreateFromDataEx, hresult));

    return hresult;
}



//+-------------------------------------------------------------------------
//
//  Function:   OleCreateLinkFromData
//
//  Synopsis:   Creates a link from a data object (e.g. for Paste->Link)
//
//  Effects:
//
//  Arguments:  [lpSrcDataObj]  -- pointer to the data object
//              [iid]           -- requested interface ID
//              [renderopt]     -- rendering options
//              [lpFormatEtc]   -- format to render (if renderopt ==
//                                 OLERENDER_FORMAT)
//              [lpClientSite]  -- pointer to the client site
//              [lpStg]         -- pointer to the storage
//              [lplpObj]       -- where to put the object
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              16-Dec-94 alexgo    added call tracing
//              28-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(OleCreateLinkFromData)
STDAPI  OleCreateLinkFromData
(
  IDataObject FAR*            lpSrcDataObj,
  REFIID                      iid,
  DWORD                       renderopt,
  LPFORMATETC                 lpFormatEtc,
  IOleClientSite FAR*          lpClientSite,
  IStorage FAR*                lpStg,
  void FAR* FAR*               lplpObj
)
{
    DWORD advf = ADVF_PRIMEFIRST;

    return OleCreateLinkFromDataEx(lpSrcDataObj, iid, 0, renderopt,
        (lpFormatEtc ? 1 : 0), (lpFormatEtc ? &advf : NULL),
        lpFormatEtc, NULL, NULL, lpClientSite, lpStg, lplpObj);
}


//+-------------------------------------------------------------------------
//
//  Function:   OleCreateLinkFromDataEx
//
//  Synopsis:   Creates a link from a data object (e.g. for Paste->Link)
//
//  Effects:
//
//  Arguments:  [lpSrcDataObj]  -- pointer to the data object
//              [iid]           -- requested interface ID
//              [dwFlags]       -- object creation flags
//              [renderopt]     -- render options, such as OLERENDER_DRAW
//              [cFormats]      -- the number of elements in rgFormatEtc
//              [rgAdvf]        -- array of advise flags, if OLRENDER_FORMAT
//                                 is specified in renderopt
//              [rgFormatEtc]   -- array of rendering formats, if
//                                 OLERENDER_FORMAT is specified in renderopt
//              [lpAdviseSink]  -- the advise sink for the object
//              [rgdwConnection]-- where to put the connection IDs for the
//                                 advisory connections
//              [lpClientSite]  -- pointer to the client site
//              [lpStg]         -- pointer to the storage
//              [lplpObj]       -- where to put the object
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              16-Dec-94 alexgo    added call tracing
//              28-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(OleCreateLinkFromDataEx)
STDAPI  OleCreateLinkFromDataEx
(
    IDataObject FAR*        lpSrcDataObj,
    REFIID                  iid,
    DWORD                   dwFlags,
    DWORD                   renderopt,
    ULONG                   cFormats,
    DWORD FAR*              rgAdvf,
    LPFORMATETC             rgFormatEtc,
    IAdviseSink FAR*        lpAdviseSink,
    DWORD FAR*              rgdwConnection,
    IOleClientSite FAR*     lpClientSite,
    IStorage FAR*           lpStg,
    void FAR* FAR*          lplpObj
)
{
    OLETRACEIN((API_OleCreateLinkFromDataEx,
        PARAMFMT("lpSrcDataObj= %p, iid= %I, dwFlags= %x, renderopt= %x, cFormats= %x, rgAdvf= %te, rgFormatEtc= %p, lpAdviseSink= %p, rgdwConnection= %p, lpClientSite= %p, lpStg= %p, lplpObj= %p"),
        lpSrcDataObj, &iid, dwFlags, renderopt, cFormats, rgAdvf, rgFormatEtc, lpAdviseSink, rgdwConnection, lpClientSite, lpStg, lplpObj));

    VDATEHEAP();

    HRESULT         error;
    FORMATETC       formatEtc;
    LPFORMATETC     lpFormatEtc;
    BOOL            fAlloced = FALSE;
    CLIPFORMAT      cfFormat;

    LEDebugOut((DEB_TRACE, "%p _IN OleCreateLinkFromDataEx ( %p , %p , %lx,"
        " %lx, %lx , %p , %p , %p, %p , %p , %p, %p )\n", NULL, lpSrcDataObj,
        &iid, dwFlags, renderopt, cFormats, rgAdvf, rgFormatEtc, lpAdviseSink,
        rgdwConnection, lpClientSite, lpStg, lplpObj));

    VDATEPTROUT_LABEL( lplpObj, LPVOID, safeRtn, error );
    *lplpObj = NULL;

    VDATEIFACE_LABEL( lpSrcDataObj, errRtn, error );
    VDATEIID_LABEL( iid, errRtn, error );

    error = wValidateCreateParams(dwFlags, renderopt, cFormats, rgAdvf, rgFormatEtc, lpAdviseSink, rgdwConnection, lpClientSite, lpStg);
    if (error != NOERROR)
        goto errRtn;

    cfFormat = wQueryLinkFormats(lpSrcDataObj);

    if (cfFormat == g_cfLinkSource) {
        CLSID                   clsidLast;
        LPMONIKER               lpmkSrc;
        LPDATAOBJECT    lpBoundDataObj = NULL;

        // we are going to create a normal link
        if ((error = wValidateFormatEtcEx(renderopt, &cFormats, rgFormatEtc,
            &formatEtc, &lpFormatEtc, &fAlloced)) != NOERROR)
        {
            goto errRtn;
        }

        if ((error = wGetMonikerAndClassFromObject(lpSrcDataObj,
            &lpmkSrc, &clsidLast)) != NOERROR)
        {
            goto errRtn;
        }

        if (wQueryUseCustomLink(clsidLast)) {
            // the object supports Custom Link Source, so bind
            // to the object and pass its IDataObject pointer
            // to wCreateLinkEx()

            if (BindMoniker(lpmkSrc, NULL /*grfOpt*/, IID_IDataObject,
                (LPLPVOID) &lpBoundDataObj) == NOERROR)
            {
                lpSrcDataObj = lpBoundDataObj;
            }
        }

        // otherwise continue to use StdOleLink implementation
        error = wCreateLinkEx(lpmkSrc, clsidLast, lpSrcDataObj, iid,
            dwFlags, renderopt, cFormats, rgAdvf, lpFormatEtc, lpAdviseSink,
            rgdwConnection, lpClientSite, lpStg, lplpObj);

        // we don't need the moniker anymore
        lpmkSrc->Release();

        // we would have bound in the custom link source case,
        // release the pointer
        if (lpBoundDataObj)
        {
            if (error == NOERROR && (dwFlags & OLECREATE_LEAVERUNNING))
                OleRun((LPUNKNOWN)*lplpObj);

            lpBoundDataObj->Release();
        }

    } else if (cfFormat == g_cfFileName || cfFormat == g_cfFileNameW) {
        // See whether we have to create a packaged link

        error = wCreatePackageEx(lpSrcDataObj, iid, dwFlags, renderopt,
            cFormats, rgAdvf, rgFormatEtc, lpAdviseSink, rgdwConnection,
            lpClientSite, lpStg, TRUE /*fLink*/, lplpObj);
    }
    else
    {
        error = DV_E_FORMATETC;
    }

errRtn:

    if (fAlloced)
        PubMemFree(lpFormatEtc);

    LEDebugOut((DEB_TRACE, "%p OUT OleCreateLinkFromDataEx ( %lx ) [ %p ]\n",
        NULL, error, *lplpObj));

safeRtn:

    OLETRACEOUT((API_OleCreateLinkFromDataEx, error));

    return error;
}


//+-------------------------------------------------------------------------
//
//  Function:   OleCreateLink
//
//  Synopsis:   Create a link to the object referred to by a moniker
//
//  Effects:
//
//  Arguments:  [lpmkSrc]       -- source of the link
//              [iid]           -- interface requested
//              [renderopt]     -- rendering options
//              [lpFormatEtc]   -- rendering format (if needed)
//              [lpClientSite]  -- pointer to the client site for the link
//              [lpStg]         -- storage for the link
//              [lplpObj]       -- where to put the link object
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              16-Dec-94 alexgo    added call tracing
//              28-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(OleCreateLink)
STDAPI  OleCreateLink
(
    IMoniker FAR*           lpmkSrc,
    REFIID                  iid,
    DWORD                   renderopt,
    LPFORMATETC             lpFormatEtc,
    IOleClientSite FAR*     lpClientSite,
    IStorage FAR*           lpStg,
    void FAR* FAR*          lplpObj
)
{
    DWORD advf = ADVF_PRIMEFIRST;

    return OleCreateLinkEx(lpmkSrc, iid, 0, renderopt,
        (lpFormatEtc ? 1 : 0), (lpFormatEtc ? &advf : NULL),
        lpFormatEtc, NULL, NULL, lpClientSite, lpStg, lplpObj);
}


//+-------------------------------------------------------------------------
//
//  Function:   OleCreateLinkEx
//
//  Synopsis:   Create a link to the object referred to by a moniker
//
//  Effects:
//
//  Arguments:  [lpmkSrc]       -- source of the link
//              [iid]           -- interface requested
//              [dwFlags]       -- object creation flags
//              [renderopt]     -- render options, such as OLERENDER_DRAW
//              [cFormats]      -- the number of elements in rgFormatEtc
//              [rgAdvf]        -- array of advise flags, if OLRENDER_FORMAT
//                                 is specified in renderopt
//              [rgFormatEtc]   -- array of rendering formats, if
//                                 OLERENDER_FORMAT is specified in renderopt
//              [lpAdviseSink]  -- the advise sink for the object
//              [rgdwConnection]-- where to put the connection IDs for the
//                                 advisory connections
//              [lpClientSite]  -- pointer to the client site for the link
//              [lpStg]         -- storage for the link
//              [lplpObj]       -- where to put the link object
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              16-Dec-94 alexgo    added call tracing
//              28-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(OleCreateLinkEx)
STDAPI  OleCreateLinkEx
(
    IMoniker FAR*           lpmkSrc,
    REFIID                  iid,
    DWORD                   dwFlags,
    DWORD                   renderopt,
    ULONG                   cFormats,
    DWORD FAR*              rgAdvf,
    LPFORMATETC             rgFormatEtc,
    IAdviseSink FAR*        lpAdviseSink,
    DWORD FAR*              rgdwConnection,
    IOleClientSite FAR*     lpClientSite,
    IStorage FAR*           lpStg,
    void FAR* FAR*          lplpObj
)
{
    OLETRACEIN((API_OleCreateLinkEx,
        PARAMFMT("lpmkSrc= %p, iid= %I, dwFlags= %x, renderopt= %x, cFormats= %x, rgAdvf= %te, rgFormatEtc= %p, lpAdviseSink= %p, rgdwConnection= %p, lpClientSite= %p, lpStg= %p, lplpObj= %p"),
        lpmkSrc, &iid, dwFlags, renderopt, cFormats, rgAdvf, rgFormatEtc, lpAdviseSink, rgdwConnection, lpClientSite, lpStg, lplpObj));

    VDATEHEAP();

    FORMATETC       formatEtc;
    LPFORMATETC     lpFormatEtc;
    BOOL            fAlloced = FALSE;
    HRESULT         error;

    LEDebugOut((DEB_TRACE, "%p _IN OleCreateLinkEx ( %p , %p , %lx, %lx,"
        " %lx , %p , %p , %p, %p , %p , %p , %p )\n", NULL, lpmkSrc, &iid,
        dwFlags, renderopt, cFormats, rgAdvf, rgFormatEtc, lpAdviseSink,
        rgdwConnection, lpClientSite, lpStg, lplpObj));

    VDATEPTROUT_LABEL( lplpObj, LPVOID, errRtn, error );
    *lplpObj = NULL;

    VDATEIFACE_LABEL( lpmkSrc, errRtn, error);
    VDATEIID_LABEL( iid, errRtn, error );

    error = wValidateCreateParams(dwFlags, renderopt, cFormats, rgAdvf, rgFormatEtc, lpAdviseSink, rgdwConnection, lpClientSite, lpStg);
    if (error != NOERROR)
        goto errRtn;

    if ((error = wValidateFormatEtcEx(renderopt, &cFormats, rgFormatEtc,
        &formatEtc, &lpFormatEtc, &fAlloced)) == NOERROR)
    {
        error = wCreateLinkEx(lpmkSrc, CLSID_NULL, NULL /* lpSrcDataObj */,
            iid, dwFlags, renderopt, cFormats, rgAdvf, lpFormatEtc,
            lpAdviseSink, rgdwConnection, lpClientSite, lpStg, lplpObj);

        if (fAlloced)
            PubMemFree(lpFormatEtc);
    }

    LEDebugOut((DEB_TRACE, "%p OUT OleCreateLinkEx ( %lx ) [ %p ]\n", NULL,
        error, *lplpObj));

errRtn:
    OLETRACEOUT((API_OleCreateLinkEx, error));

    return error;
}


//+-------------------------------------------------------------------------
//
//  Function:   OleCreateLinkToFile
//
//  Synopsis:   Creates a link object to the file specified in [lpszFileName]
//
//  Effects:
//
//  Arguments:  [lpszFileName]  --  the name of the file
//              [iid]           --  interface ID requested
//              [renderopt]     --  rendering options
//              [lpFormatEtc]   --  format in which to render (if [renderopt]
//                                  == OLERENDER_FORMAT);
//              [lpClientSite]  --  pointer to the client site for the link
//              [lpStg]         --  pointer to the storage for the object
//              [lplpObj]       --  where to put a pointer to new link object
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              16-Dec-94 alexgo    added call tracing
//              28-Oct-93 alexgo    32bit port, fixed memory leak in error
//                                      case
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(OleCreateLinkToFile)
STDAPI  OleCreateLinkToFile
(
    LPCOLESTR                       lpszFileName,
    REFIID                  iid,
    DWORD                   renderopt,
    LPFORMATETC             lpFormatEtc,
    IOleClientSite FAR*     lpClientSite,
    IStorage FAR*           lpStg,
    void FAR* FAR*          lplpObj
)
{
    DWORD advf = ADVF_PRIMEFIRST;

    return OleCreateLinkToFileEx(lpszFileName, iid, 0, renderopt,
        (lpFormatEtc ? 1 : 0), (lpFormatEtc ? &advf : NULL),
        lpFormatEtc, NULL, NULL, lpClientSite, lpStg, lplpObj);
}



//+-------------------------------------------------------------------------
//
//  Function:   OleCreateLinkToFileEx
//
//  Synopsis:   Creates a link object to the file specified in [lpszFileName]
//
//  Effects:
//
//  Arguments:  [lpszFileName]  --  the name of the file
//              [iid]           --  interface ID requested
//              [dwFlags]       -- object creation flags
//              [renderopt]     -- render options, such as OLERENDER_DRAW
//              [cFormats]      -- the number of elements in rgFormatEtc
//              [rgAdvf]        -- array of advise flags, if OLRENDER_FORMAT
//                                 is specified in renderopt
//              [rgFormatEtc]   -- array of rendering formats, if
//                                 OLERENDER_FORMAT is specified in renderopt
//              [lpAdviseSink]  -- the advise sink for the object
//              [rgdwConnection]-- where to put the connection IDs for the
//                                 advisory connections
//              [lpClientSite]  --  pointer to the client site for the link
//              [lpStg]         --  pointer to the storage for the object
//              [lplpObj]       --  where to put a pointer to new link object
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              16-Dec-94 alexgo    added call tracing
//              28-Oct-93 alexgo    32bit port, fixed memory leak in error
//                                      case
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(OleCreateLinkToFileEx)
STDAPI  OleCreateLinkToFileEx
(
    LPCOLESTR               lpszFileName,
    REFIID                  iid,
    DWORD                   dwFlags,
    DWORD                   renderopt,
    ULONG                   cFormats,
    DWORD FAR*              rgAdvf,
    LPFORMATETC             rgFormatEtc,
    IAdviseSink FAR*        lpAdviseSink,
    DWORD FAR*              rgdwConnection,
    IOleClientSite FAR*     lpClientSite,
    IStorage FAR*           lpStg,
    void FAR* FAR*          lplpObj
)
{
    OLETRACEIN((API_OleCreateLinkToFileEx,
        PARAMFMT("lpszFileName= %ws, iid= %I, dwFlags= %x, renderopt= %x, cFormats= %x, rgAdvf= %te, rgFormatEtc= %p, lpAdviseSink= %p, rgdwConnection= %p, lpClientSite= %p, lpStg= %p, lplpObj= %p"),
        lpszFileName, &iid, dwFlags, renderopt, cFormats, rgAdvf, rgFormatEtc, lpAdviseSink, rgdwConnection, lpClientSite, lpStg, lplpObj));

    VDATEHEAP();

    LPMONIKER       lpmkFile = NULL;
    LPDATAOBJECT    lpDataObject = NULL;
    HRESULT         error;
    BOOL            fPackagerMoniker = FALSE;
    CLSID           clsidFile;

    LEDebugOut((DEB_TRACE, "%p _IN OleCreateLinkToFileEx ( \"%s\" , %p , %lx ,"
        " %lx , %lx , %p , %p , %p, %p , %p , %p , %p )\n", NULL, lpszFileName,
        &iid, dwFlags, renderopt, cFormats, rgAdvf, rgFormatEtc, lpAdviseSink,
        rgdwConnection, lpClientSite, lpStg, lplpObj));

    VDATEPTROUT_LABEL( lplpObj, LPVOID, safeRtn, error );
    *lplpObj = NULL;

    VDATEPTRIN_LABEL( (LPVOID)lpszFileName, OLECHAR, logRtn, error );
    VDATEIID_LABEL( iid, logRtn, error );

    error = wValidateCreateParams(dwFlags, renderopt, cFormats, rgAdvf, rgFormatEtc, lpAdviseSink, rgdwConnection, lpClientSite, lpStg);
    if (error != NOERROR)
        goto logRtn;

    if (((error = wGetMonikerAndClassFromFile(lpszFileName,
        TRUE /*fLink*/, &lpmkFile, &fPackagerMoniker, &clsidFile,&lpDataObject))
        != NOERROR))
    {
        goto logRtn;
    }

    Verify(lpmkFile);

   if (fPackagerMoniker) {
        // wValidateFormatEtc() will be done in wCreateFromFile()

        Assert(NULL == lpDataObject); // Shouldn't be a BoundDataObject for Packager.

        error =  wCreateFromFileEx(lpmkFile,lpDataObject, iid, dwFlags, renderopt,
            cFormats, rgAdvf, rgFormatEtc, lpAdviseSink, rgdwConnection,
            lpClientSite, lpStg, lplpObj);

    } else {
        FORMATETC       formatEtc;
        LPFORMATETC     lpFormatEtc;
        BOOL            fAlloced = FALSE;

        if ((error = wValidateFormatEtcEx(renderopt, &cFormats, rgFormatEtc,
            &formatEtc, &lpFormatEtc, &fAlloced)) != NOERROR)
        {
            goto ErrRtn;
        }

        error = wCreateLinkEx(lpmkFile, clsidFile, lpDataObject,
            iid, dwFlags, renderopt, cFormats, rgAdvf, lpFormatEtc,
            lpAdviseSink, rgdwConnection, lpClientSite, lpStg, lplpObj);

        if (fAlloced)
            PubMemFree(lpFormatEtc);
    }

ErrRtn:

    if (lpmkFile)
    {
        lpmkFile->Release();
    }

    // if the moniker was bound in CreateFromFile, release it now.
    if (lpDataObject)
    {
        lpDataObject->Release();
    }

    if (error == NOERROR && !lpAdviseSink) {
        wStuffIconOfFileEx(lpszFileName, TRUE /*fAddLabel*/,
            renderopt, cFormats, rgFormatEtc, (LPUNKNOWN) *lplpObj);
    }

logRtn:

    LEDebugOut((DEB_TRACE, "%p OUT OleCreateLinkToFileEx ( %lx ) [ %p ]\n",
        NULL, error, *lplpObj));

safeRtn:
    OLETRACEOUT((API_OleCreateLinkToFileEx, error));

    return error;
}



//+-------------------------------------------------------------------------
//
//  Function:   OleCreateFromFile
//
//  Synopsis:   Creates an ole object for embedding from a file (for
//              InstertObject->From File type things)
//
//  Effects:
//
//  Arguments:  [rclsid]        -- CLSID to use for creating the object
//              [lpszFileName]  -- the filename
//              [iid]           -- the requested interface ID
//              [renderopt]     -- rendering options
//              [lpFormatEtc]   -- rendering format (if needed)
//              [lpClientSite]  -- pointer to the object's client site
//              [lpStg]         -- pointer to the storage for the object
//              [lplpObj]       -- where to put the pointer to the new object
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              16-Dec-94 alexgo    added call tracing
//              28-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(OleCreateFromFile)
STDAPI  OleCreateFromFile
(
    REFCLSID                rclsid,
    LPCOLESTR                       lpszFileName,
    REFIID                  iid,
    DWORD                   renderopt,
    LPFORMATETC             lpFormatEtc,
    IOleClientSite FAR*     lpClientSite,
    IStorage FAR*           lpStg,
    void FAR* FAR*          lplpObj
)
{
    DWORD advf = ADVF_PRIMEFIRST;

    return OleCreateFromFileEx(rclsid, lpszFileName, iid, 0, renderopt,
        (lpFormatEtc ? 1 : 0), (lpFormatEtc ? &advf : NULL),
        lpFormatEtc, NULL, NULL, lpClientSite, lpStg, lplpObj);
}


//+-------------------------------------------------------------------------
//
//  Function:   OleCreateFromFileEx
//
//  Synopsis:   Creates an ole object for embedding from a file (for
//              InstertObject->From File type things)
//
//  Effects:
//
//  Arguments:  [rclsid]        -- CLSID to use for creating the object
//              [lpszFileName]  -- the filename
//              [iid]           -- the requested interface ID
//              [dwFlags]       -- object creation flags
//              [renderopt]     -- render options, such as OLERENDER_DRAW
//              [cFormats]      -- the number of elements in rgFormatEtc
//              [rgAdvf]        -- array of advise flags, if OLRENDER_FORMAT
//                                 is specified in renderopt
//              [rgFormatEtc]   -- array of rendering formats, if
//                                 OLERENDER_FORMAT is specified in renderopt
//              [lpAdviseSink]  -- the advise sink for the object
//              [rgdwConnection]-- where to put the connection IDs for the
//                                 advisory connections
//              [lpClientSite]  -- pointer to the object's client site
//              [lpStg]         -- pointer to the storage for the object
//              [lplpObj]       -- where to put the pointer to the new object
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              16-Dec-94 alexgo    added call tracing
//              28-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(OleCreateFromFileEx)
STDAPI  OleCreateFromFileEx
(
    REFCLSID                rclsid,
    LPCOLESTR               lpszFileName,
    REFIID                  iid,
    DWORD                   dwFlags,
    DWORD                   renderopt,
    ULONG                   cFormats,
    DWORD FAR*              rgAdvf,
    LPFORMATETC             rgFormatEtc,
    IAdviseSink FAR*        lpAdviseSink,
    DWORD FAR*              rgdwConnection,
    IOleClientSite FAR*     lpClientSite,
    IStorage FAR*           lpStg,
    void FAR* FAR*          lplpObj
)
{
    OLETRACEIN((API_OleCreateFromFileEx,
        PARAMFMT("rclsid= %I, lpszFileName= %ws, iid= %I, dwFlags= %x, renderopt= %x, cFormats= %x, rgAdvf= %te, rgFormatEtc= %p, lpAdviseSink= %p, rgdwConnection= %p, lpClientSite= %p, lpStg= %p, lplpObj= %p"),
        &rclsid, lpszFileName, &iid, dwFlags, renderopt, cFormats, rgAdvf, rgFormatEtc, lpAdviseSink, rgdwConnection, lpClientSite, lpStg, lplpObj));

    VDATEHEAP();

    LPMONIKER               lpmkFile = NULL;
    LPDATAOBJECT            lpDataObject = NULL;
    HRESULT                 error;
    CLSID                   clsid;

    LEDebugOut((DEB_TRACE, "%p _IN OleCreateFromFileEx ( %p , \"%s\" , %p ,"
        " %lx , %lx , %lx , %p , %p , %p , %p , %p , %p , %p )\n", NULL,
        &rclsid, lpszFileName, &iid, dwFlags, renderopt, cFormats, rgAdvf,
        rgFormatEtc, lpAdviseSink, rgdwConnection, lpClientSite, lpStg,
        lplpObj));

    VDATEPTROUT_LABEL( lplpObj, LPVOID, safeRtn, error );
    *lplpObj = NULL;

    VDATEPTRIN_LABEL( (LPVOID)lpszFileName, char, errRtn, error );
    VDATEIID_LABEL( iid, errRtn, error );

    error = wValidateCreateParams(dwFlags, renderopt, cFormats, rgAdvf, rgFormatEtc, lpAdviseSink, rgdwConnection, lpClientSite, lpStg);
    if (error != NOERROR)
        goto errRtn;

    if (((error = wGetMonikerAndClassFromFile(lpszFileName,
        FALSE /*fLink*/, &lpmkFile, NULL /*lpfPackagerMoniker*/,
        &clsid,&lpDataObject)) != NOERROR))
    {
        goto errRtn;
    }

    Verify(lpmkFile);

    // wValidateFormatEtc() will be done in wCreateFromFile()
    error = wCreateFromFileEx(lpmkFile,lpDataObject, iid, dwFlags, renderopt, cFormats,
        rgAdvf, rgFormatEtc, lpAdviseSink, rgdwConnection, lpClientSite,
        lpStg, lplpObj);

    if (lpDataObject)
    {
        lpDataObject->Release();
    }

    if (lpmkFile)
    {
        lpmkFile->Release();
    }


    if (error == NOERROR && !lpAdviseSink) {
        wStuffIconOfFileEx(lpszFileName, FALSE /*fAddLabel*/,
            renderopt, cFormats, rgFormatEtc, (LPUNKNOWN) *lplpObj);
    }

errRtn:

    LEDebugOut((DEB_TRACE, "%p OUT OleCreateFromFileEx ( %lx ) [ %p ]\n",
        NULL, error, *lplpObj));

safeRtn:

    OLETRACEOUT((API_OleCreateFromFileEx, error));

    return error;
}


//+-------------------------------------------------------------------------
//
//  Function:   OleDoAutoConvert
//
//  Synopsis:   Converts the storage to use the clsid given in
//              [pClsidNew].  Private ole streams are updated with the new
//              info
//
//  Effects:
//
//  Arguments:  [pStg]          -- storage to modify
//              [pClsidNew]     -- pointer to the new class ID
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              28-Oct-93 alexgo    32bit port
//
//  Notes:      REVIEW32:  this function should be rewritten to use
//              the new internal API for writing to ole-private streams
//
//--------------------------------------------------------------------------

#pragma SEG(OleDoAutoConvert)
STDAPI OleDoAutoConvert(LPSTORAGE pStg, LPCLSID pClsidNew)
{
    OLETRACEIN((API_OleDoAutoConvert, PARAMFMT("pStg= %p, pClsidNew= %I"),
        pStg, pClsidNew));

    VDATEHEAP();

    HRESULT error;
    CLSID clsidOld;
    CLIPFORMAT cfOld;
    LPOLESTR lpszOld = NULL;
    LPOLESTR lpszNew = NULL;

    if ((error = ReadClassStg(pStg, &clsidOld)) != NOERROR) {
        clsidOld = CLSID_NULL;
        goto errRtn;
    }

    if ((error = OleGetAutoConvert(clsidOld, pClsidNew)) != NOERROR)
        goto errRtn;

    // read old fmt/old user type; sets out params to NULL on error
    error = ReadFmtUserTypeStg(pStg, &cfOld, &lpszOld);
    Assert(error == NOERROR || (cfOld == NULL && lpszOld == NULL));

    // get new user type name; if error, set to NULL string
    if ((error = OleRegGetUserType(*pClsidNew, USERCLASSTYPE_FULL,
        &lpszNew)) != NOERROR)
        lpszNew = NULL;

    // write class stg
    if ((error = WriteClassStg(pStg, *pClsidNew)) != NOERROR)
        goto errRtn;

    // write old fmt/new user type;
    if ((error = WriteFmtUserTypeStg(pStg, cfOld, lpszNew)) != NOERROR)
        goto errRewriteInfo;

    // set convert bit
    if ((error = SetConvertStg(pStg, TRUE)) != NOERROR)
        goto errRewriteInfo;

    goto okRtn;

errRewriteInfo:
    (void)WriteClassStg(pStg, clsidOld);
    (void)WriteFmtUserTypeStg(pStg, cfOld, lpszOld);

errRtn:
    *pClsidNew = clsidOld;

okRtn:
    PubMemFree(lpszOld);
    PubMemFree(lpszNew);

    OLETRACEOUT((API_OleDoAutoConvert, error));
    return error;
}


//+-------------------------------------------------------------------------
//
//  Function:   OleLoad
//
//  Synopsis:   Loads an object from the given storage
//
//  Effects:
//
//  Arguments:  [lpStg]         -- the storage to load from
//              [iid]           -- the requested interface ID
//              [lpClientSite]  -- client site for the object
//              [lplpObj]       -- where to put the pointer to the
//                                 new object
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              16-Dec-94 alexgo    added call tracing
//              28-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(OleLoad)
STDAPI  OleLoad
(
    IStorage FAR*           lpStg,
    REFIID                  iid,
    IOleClientSite FAR*     lpClientSite,
    void FAR* FAR*          lplpObj
)
{
    OLETRACEIN((API_OleLoad, PARAMFMT("lpStg= %p, iid= %I, lpClientSite= %p, lplpObj= %p"),
        lpStg, &iid, lpClientSite, lplpObj));

    VDATEHEAP();

    HRESULT error;

    LEDebugOut((DEB_TRACE, "%p _IN OleLoad ( %p , %p , %p , %p )\n",
        NULL, lpStg, &iid, lpClientSite, lplpObj));

    if ((error = OleLoadWithoutBinding(lpStg, FALSE, iid, lpClientSite, lplpObj))
        == NOERROR) {
        // The caller specify that he want a disconnected object by
        // passing NULL for pClientSite
        if (lpClientSite != NULL)
            wBindIfRunning((LPUNKNOWN) *lplpObj);
    }

    LEDebugOut((DEB_TRACE, "%p OUT OleLoad ( %lx ) [ %p ]\n", NULL, error,
        (error == NOERROR ? *lplpObj : NULL)));

    OLETRACEOUT((API_OleLoad, error));

    return error;
}

//+-------------------------------------------------------------------------
//
//  Function:   OleLoadWithoutBinding
//
//  Synopsis:   Internal function to load/create an object from a storage
//              called by OleLoad, etc.
//
//  Effects:
//
//  Arguments:  [lpStg]         -- storage to load from
//              [iid]           -- requested interface ID
//              [lpClientSite]  -- pointer to the client site
//              [lplpObj]       -- where to put the pointer to the object
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              28-Oct-93 alexgo    32bit port
//
//  Notes:      REVIEW32:  this function is only used in a few, known
//              places.  we can maybe get rid of the VDATEPTR's.
//
//--------------------------------------------------------------------------


INTERNAL  OleLoadWithoutBinding
(
    IStorage FAR*           lpStg,
    BOOL                    fPermitCodeDownload,    //new parameter to control whether code download occurs or not      -RahulTh (11/20/97)
    REFIID                  iid,
    IOleClientSite FAR*     lpClientSite,
    void FAR* FAR*          lplpObj
)
{
    VDATEHEAP();

    HRESULT error;
    CLSID   clsid;

    VDATEPTROUT( lplpObj, LPVOID );
    *lplpObj = NULL;
    VDATEIID( iid );
    VDATEIFACE( lpStg );

    if (lpClientSite)
        VDATEIFACE( lpClientSite );

    error = OleDoAutoConvert(lpStg, &clsid);

    // error only used when clsid could not be read (when CLSID_NULL)
    if (IsEqualCLSID(clsid, CLSID_NULL))
        return error;

    return wCreateObject (clsid, fPermitCodeDownload, iid, lpClientSite, lpStg, STG_LOAD,
        lplpObj);
}




//+-------------------------------------------------------------------------
//
//  Function:   OleCreateStaticFromData
//
//  Synopsis:   Creates a static ole object from the data in [lpSrcDataObject]
//              If [lpFormatEtcIn] is NULL, then the best possible
//              presentation is extracted.
//
//  Effects:
//
//  Arguments:  [lpSrcDataObj]  -- pointer to the data object
//              [iid]           -- requested interface ID for the new object
//              [renderopt]     -- redering options
//              [lpClientSite]  -- pointer to the client site
//              [lpStg]         -- pointer to the storage for the object
//              [lplpObj]       -- where to put the pointer to the object
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              16-Dec-94 alexgo    added call tracing
//              08-Jun-94 davepl    Added EMF support
//              28-Oct-93 alexgo    32bit port
//
//--------------------------------------------------------------------------

#pragma SEG(OleCreateStaticFromData)
STDAPI OleCreateStaticFromData(
    IDataObject FAR*        lpSrcDataObj,
    REFIID                  iid,
    DWORD                   renderopt,
    LPFORMATETC             lpFormatEtcIn,
    IOleClientSite FAR*     lpClientSite,
    IStorage FAR*           lpStg,
    void FAR* FAR*          lplpObj
)
{
    OLETRACEIN((API_OleCreateStaticFromData,
        PARAMFMT("lpSrcDataObj= %p, iid= %I, renderopt= %x, lpFormatEtcIn= %te, lpClientSite= %p, lpStg= %p, lplpObj= %p"),
        lpSrcDataObj, &iid, renderopt, lpFormatEtcIn, lpClientSite, lpStg, lplpObj));

    VDATEHEAP();

    IOleObject FAR*         lpOleObj = NULL;
    IOleCache FAR*          lpOleCache = NULL;
    HRESULT                 error;
    FORMATETC               foretc;
    FORMATETC               foretcCache;
    STGMEDIUM               stgmed;
    CLSID                   clsid;
    BOOL                    fReleaseStgMed = TRUE;
    LPOLESTR                        lpszUserType = NULL;


    LEDebugOut((DEB_TRACE, "%p _IN OleCreateStaticFromData ( %p , %p , %lx ,"
        " %p , %p , %p , %p , %p )\n", NULL, lpSrcDataObj, &iid, renderopt,
        lpFormatEtcIn, lpClientSite, lpStg, lplpObj));

    VDATEPTROUT_LABEL(lplpObj, LPVOID, safeRtn, error);
    *lplpObj = NULL;
    VDATEIFACE_LABEL( lpSrcDataObj, logRtn, error );
    VDATEIID_LABEL(iid, logRtn, error);

    //VDATEPTRIN rejects NULL
    if ( lpFormatEtcIn )
        VDATEPTRIN_LABEL( lpFormatEtcIn, FORMATETC, logRtn, error );
    VDATEIFACE_LABEL(lpStg, logRtn, error);
    if (lpClientSite)
        VDATEIFACE_LABEL(lpClientSite, logRtn, error);

    if (renderopt == OLERENDER_NONE || renderopt == OLERENDER_ASIS)
    {
        error = E_INVALIDARG;
        goto logRtn;
    }

    if ((error = wValidateFormatEtc (renderopt, lpFormatEtcIn, &foretc))
            != NOERROR)
    {
        goto logRtn;
    }

    if (renderopt == OLERENDER_DRAW)
    {
        if (!UtQueryPictFormat(lpSrcDataObj, &foretc))
        {
            error = DV_E_CLIPFORMAT;
            goto logRtn;
        }
    }

    // Set the proper CLSID, or return error if that isn't possible

    if (foretc.cfFormat == CF_METAFILEPICT)
    {
        clsid = CLSID_StaticMetafile;
    }
    else if (foretc.cfFormat == CF_BITMAP ||  foretc.cfFormat == CF_DIB)
    {
        clsid = CLSID_StaticDib;
    }
    else if (foretc.cfFormat == CF_ENHMETAFILE)
    {
        clsid = CLSID_Picture_EnhMetafile;
    }
    else
    {
        error = DV_E_CLIPFORMAT;
        goto logRtn;
    }

    error = lpSrcDataObj->GetData(&foretc, &stgmed);
    if (NOERROR != error)
    {
        // We should support the case where the caller wants one of
        // CF_BITMAP and CF_DIB, and the object supports the other
        // one those 2 formats. In this case we should do the proper
        // conversion. Finally the cache that is going to be created
        // would be a DIB cache.

        AssertOutStgmedium(error, &stgmed);

        if (foretc.cfFormat == CF_DIB)
        {
            foretc.cfFormat = CF_BITMAP;
            foretc.tymed = TYMED_GDI;
        }
        else if (foretc.cfFormat == CF_BITMAP)
        {
            foretc.cfFormat = CF_DIB;
            foretc.tymed = TYMED_HGLOBAL;
        }
        else
        {
            goto logRtn;
        }

        error = lpSrcDataObj->GetData(&foretc, &stgmed);
        if (NOERROR != error)
        {
            AssertOutStgmedium(error, &stgmed);
            goto logRtn;
        }
    }

    AssertOutStgmedium(error, &stgmed);

    foretcCache = foretc;
    foretcCache.dwAspect = foretc.dwAspect = DVASPECT_CONTENT;
    foretcCache.ptd = NULL;

    // Even when the caller asks for bitmap cache we create the DIB cache.

    BITMAP_TO_DIB(foretcCache);

    error = wCreateObject (clsid, FALSE,
                           IID_IOleObject, lpClientSite,
                           lpStg, STG_INITNEW, (LPLPVOID) &lpOleObj);

    if (NOERROR != error)
    {
        goto errRtn;
    }

    if (lpOleObj->QueryInterface(IID_IOleCache, (LPLPVOID) &lpOleCache)
            != NOERROR)
    {
        goto errRtn;
    }

    error = lpOleCache->Cache (&foretcCache, ADVF_PRIMEFIRST,
                        NULL /*pdwConnection*/);

    if (FAILED(error))
    {
        goto errRtn;
    }

    //REVIEW32: err, are we sure this is a good idea???
    //clearing out the error, that is

    error = NOERROR;

    // take ownership of the data
    foretc.ptd = NULL;
    if ((error = lpOleCache->SetData (&foretc, &stgmed,
            TRUE)) != NOERROR)
        goto errRtn;

    // Write format and user type
    error = lpOleObj->GetUserType(USERCLASSTYPE_FULL, &lpszUserType);
    AssertOutPtrParam(error, lpszUserType);
    WriteFmtUserTypeStg(lpStg, foretcCache.cfFormat, lpszUserType);
    if (lpszUserType)
        PubMemFree(lpszUserType);

    fReleaseStgMed = FALSE;

    error = lpOleObj->QueryInterface (iid, lplpObj);

errRtn:
    if (fReleaseStgMed)
        ReleaseStgMedium(&stgmed);

    if (lpOleCache)
        lpOleCache->Release();

    if (error != NOERROR && *lplpObj) {
        ((IUnknown FAR*) *lplpObj)->Release();
        *lplpObj = NULL;
    }

    if (lpOleObj)
        lpOleObj->Release();

logRtn:

    LEDebugOut((DEB_TRACE, "%p OUT OleCreateStaticFromData ( %lx ) [ %p ]\n",
        NULL, error, *lplpObj));

safeRtn:
    OLETRACEOUT((API_OleCreateStaticFromData, error));

    return error;
}


//+-------------------------------------------------------------------------
//
//  Function:   OleQueryCreateFromData
//
//  Synopsis:   Finds out what we can create from a data object (if anything)
//
//  Effects:
//
//  Arguments:  [lpSrcDataObj]  -- pointer to the data object of interest
//
//  Requires:
//
//  Returns:    NOERROR         -- an OLE object can be created
//              QUERY_CREATE_STATIC     -- a static object can be created
//              S_FALSE         -- nothing can be created
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              28-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(OleQueryCreateFromData)
STDAPI  OleQueryCreateFromData (LPDATAOBJECT lpSrcDataObj)
{
    OLETRACEIN((API_OleQueryCreateFromData, PARAMFMT("lpSrcDataObj= %p"), lpSrcDataObj));

    VDATEHEAP();
    VDATEIFACE( lpSrcDataObj );
    CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IDataObject,(IUnknown **)&lpSrcDataObj);

    CLIPFORMAT      cfFormat;
    WORD            wStatus = wQueryEmbedFormats(lpSrcDataObj, &cfFormat);
    HRESULT hr;

    if (wStatus & QUERY_CREATE_OLE)
        // OLE object can be created
        hr = NOERROR;
    else if (wStatus & QUERY_CREATE_STATIC)
        // static object can be created
        hr = ResultFromScode(OLE_S_STATIC);
    else    // no object can be created
        hr = ResultFromScode(S_FALSE);

    OLETRACEOUT((API_OleQueryCreateFromData, hr));

    return hr;
}


//+-------------------------------------------------------------------------
//
//  Function:   wQueryEmbedFormats
//
//  Synopsis:   Enumerates the formats of the object and looks for
//              ones that let us create either an embeded or static object
//
//  Effects:
//
//  Arguments:  [lpSrcDataObj]          -- pointer to the data object
//              [lpcfFormat]            -- place to put the clipboard format
//                                         of the object
//  Returns:    WORD -- bit flag of QUERY_CREATE_NONE, QUERY_CREATE_STATIC
//                      and QUERY_CREATE_OLE
//
//  History:    dd-mmm-yy Author    Comment
//              28-Oct-93 alexgo    32bit port
//              08-Jun-94 davepl    Optimized by unwinding while() loop
//              22-Aug-94 alexgo    added MFC hack
//
//--------------------------------------------------------------------------

static const unsigned int MAX_ENUM_STEP = 20;

INTERNAL_(WORD) wQueryEmbedFormats
(
    LPDATAOBJECT    lpSrcDataObj,
    CLIPFORMAT FAR* lpcfFormat
)
{
    VDATEHEAP();

    // This adjusts the number of formats requested per enumeration
    // step.  If we are running in the WOW box, we should only ask
    // for one at a time since it is unknown how well old code will
    // support bulk enumerations.

    ULONG ulEnumSize = IsWOWThread() ? 1 : MAX_ENUM_STEP;

    FORMATETC               fetcarray[MAX_ENUM_STEP];
    IEnumFORMATETC FAR*     penm;
    ULONG                   ulNumFetched;
    HRESULT                 error;
    WORD                    wStatus = QUERY_CREATE_NONE;
                    // no object can be created
    BOOL                    fDone   = FALSE;

    *lpcfFormat = NULL;

    // Grab the enumerator.  If this fails, just return
    // QUERY_CREATE_NONE

    error = wGetEnumFormatEtc(lpSrcDataObj, DATADIR_GET, &penm);
    if (error != NOERROR)
    {
        return QUERY_CREATE_NONE;
    }

    // Enumerate over the formats available in chunks for ulEnumSize.  For
    // each format we were able to grab, check to see if the clipformat
    // indicates that we have a creation candidate (static or otherwise),
    // and set bits in the bitmask as appropriate

    while (!fDone && (SUCCEEDED(penm->Next(ulEnumSize, fetcarray, &ulNumFetched))))
    {
      // We will normally get at least one, unless there are 0,
      // ulEnumSize, 2*ulEnumSize, and so on...

      if (ulNumFetched == 0)
        break;

      for (ULONG c=0; c<ulNumFetched; c++)
      {
        // We care not about the target device

        if (NULL != fetcarray[c].ptd)
        {
          PubMemFree(fetcarray[c].ptd);
        }

        CLIPFORMAT cf = fetcarray[c].cfFormat;

          // In these cases it is an internal
          // format which is a candidate for
          // OLE creation directly.

        if (cf == g_cfEmbedSource       ||
          cf == g_cfEmbeddedObject    ||
          cf == g_cfFileName          ||
          cf == g_cfFileNameW)
        {
          wStatus |= QUERY_CREATE_OLE;
          *lpcfFormat = cf;
          fDone = TRUE;
          break;
        }
          // These formats indicate it is a
          // candidate for static creation.

        else if (cf == CF_METAFILEPICT  ||
            cf == CF_DIB           ||
            cf == CF_BITMAP        ||
            cf == CF_ENHMETAFILE)
        {
          wStatus = QUERY_CREATE_STATIC;
          *lpcfFormat = cf;

        }
      } // end for

      if (fDone)
      {
        // Starting at the _next_ formatetc, free up
        // any remaining target devices among the
        // fetcs we got in the enumeration step.

        for (++c; c<ulNumFetched; c++)
        {
          if(fetcarray[c].ptd)
          {
            PubMemFree(fetcarray[c].ptd);
          }
        }
      }

    } // end while



    if (!(wStatus & QUERY_CREATE_OLE))
    {
        // MFC HACK ALERT!!  MFC3.0 used to re-implement
        // OleQueryCreateFromData themselves because they did not
        // want to make the QI RPC below.  Since they do a great
        // many of these calls, making the RPC can be expensive
        // and destabilising for them (as this hack is being put
        // in just weeks before final release of Windows NT 3.5).
        //
        // Note that this changes the behaviour of clipboard from
        // 16bit.  You will no longer know that you can paste objects
        // that only support IPersistStorage but offer no data in
        // in their IDataOjbect implementation.

        CClipDataObject ClipDataObject; // just allocate one of these
                        // on the stack.  We won't
                        // do any real work with
                        // this except look at the
                        // vtable.
        IPersistStorage FAR* lpPS;


        // MFC HACK (continued):  If we are working with a clipboard
        // data object, then we do not want to make the QI call
        // below.  We determine if the given data object is a
        // clipboard data object by comparing vtable addresses.

        // REVIEW:  this will potentially break if we make all objects
        // use the same IUnknown implementation

        if( (*(DWORD *)lpSrcDataObj) !=
            (*(DWORD *)((IDataObject *)&ClipDataObject)) )
        {

            if (lpSrcDataObj->QueryInterface(IID_IPersistStorage,
                (LPLPVOID)&lpPS) == NOERROR)
            {
                lpPS->Release();
                wStatus |= QUERY_CREATE_OLE;
                    // OLE object can be created
            }
        }
    }

    penm->Release();
    return wStatus;
}


//+-------------------------------------------------------------------------
//
//  Function:   OleQueryLinkFromData
//
//  Synopsis:   Calls wQueryLinkFormats to determine if a link could be
//              created from this data object.
//
//  Arguments:  [lpSrcDataObj]  -- the data object
//
//  Returns:    NOERROR, if a link can be created, S_FALSE otherwise
//
//  History:    dd-mmm-yy Author    Comment
//              28-Oct-93 alexgo    32bit port
//
//--------------------------------------------------------------------------

STDAPI  OleQueryLinkFromData (LPDATAOBJECT lpSrcDataObj)
{
    OLETRACEIN((API_OleQueryLinkFromData, PARAMFMT("lpSrcDataObj= %p"),
                                                                                        lpSrcDataObj));

    VDATEHEAP();
        VDATEIFACE( lpSrcDataObj );
    CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IDataObject,(IUnknown **)&lpSrcDataObj);

    HRESULT hr = NOERROR;

    if(wQueryLinkFormats(lpSrcDataObj) == NULL)
    {
        hr = ResultFromScode(S_FALSE);
    }

    OLETRACEOUT((API_OleQueryLinkFromData, hr));

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   wQueryLinkFormats
//
//  Synopsis:   Enumerates the formats of a data object to see if
//              a link object could be created from one of them
//
//  Arguments:  [lpSrcDataObj]  -- pointer to the data object
//
//  Returns:    CLIPFORMAT of the data in the object that would enable
//              link object creation.
//
//  History:    dd-mmm-yy Author    Comment
//              28-Oct-93 alexgo    32bit port
//              14-Jun-94 davepl    Added bulk enumeration for non-Wow runs
//
//--------------------------------------------------------------------------


INTERNAL_(CLIPFORMAT) wQueryLinkFormats(LPDATAOBJECT lpSrcDataObj)
{
    VDATEHEAP();

    // This adjusts the number of formats requested per enumeration
    // step.  If we are running in the WOW box, we should only ask
    // for one at a time since it is unknown how well old code will
    // support bulk enumerations.

    ULONG ulEnumSize = IsWOWThread() ? 1 : MAX_ENUM_STEP;

    FORMATETC               fetcarray[MAX_ENUM_STEP];
    IEnumFORMATETC FAR*     penm;
    ULONG                   ulNumFetched;
    HRESULT                 error;
    BOOL                    fDone    = FALSE;
    CLIPFORMAT              cf       = 0;


    // Grab the enumerator.  If this fails, just return
    // QUERY_CREATE_NONE

    error = wGetEnumFormatEtc(lpSrcDataObj, DATADIR_GET, &penm);
    if (error != NOERROR)
    {
        return (CLIPFORMAT) 0;
    }

    // Enumerate over the formats available in chunks for ulEnumSize.  For
    // each format we were able to grab, check to see if the clipformat
    // indicates that we have a creation candidate (static or otherwise),
    // and set bits in the bitmask as appropriate

    while (!fDone && (SUCCEEDED(penm->Next(ulEnumSize, fetcarray, &ulNumFetched))))
    {
      // We will normally get at least one, unless there are 0,
      // ulEnumSize, 2*ulEnumSize, and so on...

      if (ulNumFetched == 0)
        break;

      for (ULONG c=0; c<ulNumFetched; c++)
      {
        // We care not about the target device

        if (NULL != fetcarray[c].ptd)
        {
          PubMemFree(fetcarray[c].ptd);
        }

        CLIPFORMAT cfTemp = fetcarray[c].cfFormat;

          // In these cases it is an internal
          // format which is a candidate for
          // OLE creation directly.

        if (cfTemp == g_cfLinkSource       ||
          cfTemp == g_cfFileName         ||
          cfTemp == g_cfFileNameW)
        {
          cf = cfTemp;
          fDone = TRUE;
          break;
        }

      } // end for

      if (fDone)
      {
        // Starting at the _next_ formatetc, free up
        // any remaining target devices among the
        // fetcs we got in the enumeration step.

        for (++c; c<ulNumFetched; c++)
        {
          if(fetcarray[c].ptd)
          {
            PubMemFree(fetcarray[c].ptd);
          }
        }
      }  // end if

    } // end while


    penm->Release();
    return cf;
}


//+-------------------------------------------------------------------------
//
//  Function:   wClearRelativeMoniker
//
//  Synopsis:   Replaces an old relative moniker with the absolute moniker
//              Internal function
//
//  Effects:
//
//  Arguments:  [pInitObj]      -- the original object
//              [pNewObj]       -- the object to which to set the new
//                                 absolute moniker
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              28-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(wClearRelativeMoniker)
INTERNAL_(void) wClearRelativeMoniker
    (LPUNKNOWN      pInitObj,
    LPUNKNOWN       pNewObj)
{
    VDATEHEAP();

    LPOLELINK       pOleLink = NULL;
    LPMONIKER       pmkAbsolute = NULL;
    CLSID           clsidLink = CLSID_NULL;
    LPOLEOBJECT     pOleObj=NULL;

    if (NOERROR==pInitObj->QueryInterface (IID_IOleLink,
                                                (LPLPVOID) &pOleLink))
    {
        // Get absolute moniker ...
        pOleLink->GetSourceMoniker (&pmkAbsolute);
        Assert(pmkAbsolute == NULL || IsValidInterface(pmkAbsolute));
        if (NOERROR==pInitObj->QueryInterface (IID_IOleObject,
                                                    (LPLPVOID) &pOleObj))
        {
            // .. and its class
            pOleObj->GetUserClassID (&clsidLink);
            pOleObj->Release();
            pOleObj = NULL;
        }
        pOleLink->Release();
        pOleLink = NULL;
    }
    if (pmkAbsolute &&
        NOERROR==pNewObj->QueryInterface (IID_IOleLink,
        (LPLPVOID) &pOleLink))
    {
        // Restore the absolute moniker.  This will effectively
        // overwrite the old relative moniker.
        // This is important because when copying and pasting a link
        // object between documents, the relative moniker is never
        // correct.  Sometimes, though, it might happen to bind
        // to a different object, which is confusing to say the least.
        pOleLink->SetSourceMoniker (pmkAbsolute, clsidLink);
    }
    if (pOleLink)
        pOleLink->Release();
    if (pOleObj)
        pOleObj->Release();
    if (pmkAbsolute)
        pmkAbsolute->Release();
}



//+-------------------------------------------------------------------------
//
//  Function:   wCreateFromDataEx
//
//  Synopsis:   This function does the real work of creating from data.
//              Basically, the data is GetData'ed from the data object,
//              copied into a storage, and then loaded
//
//  Effects:
//
//  Arguments:  [lpSrcDataObj]  -- pointer to the data object
//              [iid]           -- requested interface
//              [dwFlags]       -- object creation flags
//              [renderopt]     -- render options, such as OLERENDER_DRAW
//              [cFormats]      -- the number of elements in rgFormatEtc
//              [rgAdvf]        -- array of advise flags, if OLRENDER_FORMAT
//                                 is specified in renderopt
//              [rgFormatEtc]   -- array of rendering formats, if
//                                 OLERENDER_FORMAT is specified in renderopt
//              [lpAdviseSink]  -- the advise sink for the object
//              [rgdwConnection]-- where to put the connection IDs for the
//                                 advisory connections
//              [lpClientSite]  -- pointer to the client site
//              [lpStg]         -- pointer to the storage for the object
//              [lplpObj]       -- where to put the pointer to the object
//
//  Requires:
//
//  Returns:   HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              28-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(wCreateFromDataEx)
INTERNAL wCreateFromDataEx
(
    IDataObject FAR*        lpSrcDataObj,
    REFIID                  iid,
    DWORD                   dwFlags,
    DWORD                   renderopt,
    ULONG                   cFormats,
    DWORD FAR*              rgAdvf,
    LPFORMATETC             rgFormatEtc,
    IAdviseSink FAR*        lpAdviseSink,
    DWORD FAR*              rgdwConnection,
    IOleClientSite FAR*     lpClientSite,
    IStorage FAR*           lpStg,
    void FAR* FAR*          lplpObj
)
{
    VDATEHEAP();

    #define OLE_TEMP_STG    "\1OleTempStg"

    HRESULT                 error = NOERROR;
    IPersistStorage FAR*    lpPS = NULL;
    FORMATETC               formatEtc;
    LPFORMATETC             lpFormatEtc;
    BOOL                    fAlloced = FALSE;
    FORMATETC               foretcTmp;
    STGMEDIUM               medTmp;

    if ((error = wValidateFormatEtcEx(renderopt, &cFormats, rgFormatEtc,
        &formatEtc, &lpFormatEtc, &fAlloced)) != NOERROR)
    {
        return error;
    }

    *lplpObj = NULL;

    INIT_FORETC(foretcTmp);
    medTmp.pUnkForRelease = NULL;


    // try to get "EmbeddedObject" data

    LPSTORAGE       lpstgSrc = NULL;

    foretcTmp.cfFormat      = g_cfEmbeddedObject;
    foretcTmp.tymed         = TYMED_ISTORAGE;

    if (lpSrcDataObj->QueryGetData(&foretcTmp) != NOERROR)
        goto Next;

    if ((error = StgCreateDocfile (NULL,
            STGM_SALL|STGM_CREATE|STGM_DELETEONRELEASE,
            NULL, &lpstgSrc)) != NOERROR)
        goto errRtn;

    medTmp.tymed = TYMED_ISTORAGE;
    medTmp.pstg = lpstgSrc;

    if ((error = lpSrcDataObj->GetDataHere(&foretcTmp, &medTmp))
        == NOERROR)
    {
        // lpSrcDataObj passed to this api is a wrapper object
        // (which offers g_cfEmbeddedObject) for the original
        // embedded object. Now we got the original embedded object
        // data into medTmp.pstg.

        // copy the source data into lpStg.
        if ((error = lpstgSrc->CopyTo (0, NULL, NULL, lpStg))
            != NOERROR)
            goto errEmbeddedObject;

        // By doing the following we will be getting a data object
        // pointer to original embedded object, which we can use to
        // initialize the cache of the object that we are going to
        // create. We can not use the lpSrcDataObj passed to this api,
        // 'cause the presentation data that it may give through the
        // GetData call may be the one that it generated for the
        // object. (ex: the container can create an object with
        // olerender_none an then draw it's own representaion
        // (icon, etc) for the object.

        LPDATAOBJECT lpInitDataObj = NULL;

        // We pass a NULL client site so we know wClearRelativeMoniker
        // will be able to get the absolute moniker, not the relative.
        if ((error = OleLoadWithoutBinding (lpstgSrc, FALSE,
                                            IID_IDataObject,
                                            /*lpClientSite*/NULL, (LPLPVOID) &lpInitDataObj))
            != NOERROR)
            goto errEmbeddedObject;

        if (renderopt != OLERENDER_ASIS )
            UtDoStreamOperation(lpStg,              /* pstgSrc */
                NULL,                           /* pstgDst */
                OPCODE_REMOVE,  /* operation to performed */
                STREAMTYPE_CACHE);
                    /* stream to be operated upon */

        error = wLoadAndInitObjectEx(lpInitDataObj, iid, renderopt,
                cFormats, rgAdvf, lpFormatEtc, lpAdviseSink, rgdwConnection,
                lpClientSite, lpStg, lplpObj);

        if (NOERROR==error)
            wClearRelativeMoniker (lpInitDataObj,
                (LPUNKNOWN)*lplpObj);

        if (lpInitDataObj)
            lpInitDataObj->Release();

        // HACK ALERT!!  If wLoadAndInitObject failed, it may have been
        // because the little trick above with OleLoadWithoutBinding doesn't
        // work with all objects.  Some OLE1 objects (Clipart Gallery in
        // particular) don't like offer presentions without being edited.
        //
        // So if there was an error, we'll just try again with the *real*
        // data object passed into us.  Needless to say, it would be much
        // nicer to do this in the first place, but that breaks the old
        // behavior.

        if( error != NOERROR )
        {
            error = wLoadAndInitObjectEx( lpSrcDataObj, iid, renderopt,
                    cFormats, rgAdvf, lpFormatEtc, lpAdviseSink, rgdwConnection,
                    lpClientSite, lpStg, lplpObj);
        }

    }

errEmbeddedObject:
    if (lpstgSrc)
        lpstgSrc->Release();

    goto errRtn;

Next:

    // try to get "EmbedSource" data

    foretcTmp.cfFormat      = g_cfEmbedSource;
    foretcTmp.tymed         = TYMED_ISTORAGE;

    medTmp.tymed = TYMED_ISTORAGE;
    medTmp.pstg = lpStg;

    if ((error = lpSrcDataObj->GetDataHere(&foretcTmp, &medTmp))
        == NOERROR)
    {
        error = wLoadAndInitObjectEx(lpSrcDataObj, iid, renderopt,
                cFormats, rgAdvf, lpFormatEtc, lpAdviseSink, rgdwConnection,
                lpClientSite, lpStg, lplpObj);
        goto errRtn;
    }

    // If we have come here, and if the object doesn't support
    // IPersistStorage, then we will fail.

    if ((error = wSaveObjectWithoutCommit(lpSrcDataObj, lpStg, FALSE))
            != NOERROR)
        goto errRtn;;

    if (renderopt != OLERENDER_ASIS )
        UtDoStreamOperation(lpStg,      /* pstgSrc */
                    NULL,   /* pstgDst */
                    OPCODE_REMOVE,
                    /* operation to performed */
                    STREAMTYPE_CACHE);
                    /* stream to be operated upon */

    error = wLoadAndInitObjectEx(lpSrcDataObj, iid, renderopt,
            cFormats, rgAdvf, lpFormatEtc, lpAdviseSink, rgdwConnection,
            lpClientSite, lpStg, lplpObj);

errRtn:
    if (fAlloced)
        PubMemFree(lpFormatEtc);

    return error;
}



//+-------------------------------------------------------------------------
//
//  Function:   wCreateLinkEx
//
//  Synopsis:   Creates a link by binding the moniker (if necessary),
//              doing a GetData into a storage, and then loading the
//              object from the storage.
//
//  Effects:
//
//  Arguments:  [lpmkSrc]       -- moniker to the link source
//              [rclsid]        -- clsid of the link source
//              [lpSrcDataObj]  -- pointer to the source data object
//                                 (may be NULL)
//              [iid]           -- requested interface ID
//              [dwFlags]       -- object creation flags
//              [renderopt]     -- render options, such as OLERENDER_DRAW
//              [cFormats]      -- the number of elements in rgFormatEtc
//              [rgAdvf]        -- array of advise flags, if OLRENDER_FORMAT
//                                 is specified in renderopt
//              [rgFormatEtc]   -- array of rendering formats, if
//                                 OLERENDER_FORMAT is specified in renderopt
//              [lpAdviseSink]  -- the advise sink for the object
//              [rgdwConnection]-- where to put the connection IDs for the
//                                 advisory connections
//              [lpClientSite]  -- pointer to the client site
//              [lpStg]         -- storage for the link object
//              [lplpObj]       -- where to put the pointer to the new
//                                 link object
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              29-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(wCreateLinkEx)
INTERNAL wCreateLinkEx
(
    IMoniker FAR*           lpmkSrc,
    REFCLSID                rclsid,
    IDataObject FAR*        lpSrcDataObj,
    REFIID                  iid,
    DWORD                   dwFlags,
    DWORD                   renderopt,
    ULONG                   cFormats,
    DWORD FAR*              rgAdvf,
    LPFORMATETC             rgFormatEtc,
    IAdviseSink FAR*        lpAdviseSink,
    DWORD FAR*              rgdwConnection,
    IOleClientSite FAR*     lpClientSite,
    IStorage FAR*           lpStg,
    void FAR* FAR*          lplpObj
)
{
    VDATEHEAP();

    IPersistStorage FAR *   lpPS = NULL;
    IOleLink FAR*           lpLink = NULL;
    IDataObject FAR*        lpBoundDataObj = NULL;
    HRESULT                 error;
    CLSID                   clsidLast = rclsid;
    BOOL                    fNeedsUpdate = FALSE;

    if (!lpSrcDataObj && ((renderopt != OLERENDER_NONE)
        || (IsEqualCLSID(rclsid,CLSID_NULL))
        || wQueryUseCustomLink(rclsid))) {

        // if renderopt is not OLERENDER_NONE, then we must have
        // a data obj pointer which will be used to initialize cache.

        // We also bind if we are not able to find from regdb whether
        // the class has custom link implementation or not

        if ((error = BindMoniker(lpmkSrc, NULL /* grfOpt */,
            IID_IDataObject, (LPLPVOID) &lpBoundDataObj))
            != NOERROR) {

            if (OLERENDER_NONE != renderopt)
                return ResultFromScode(
                    OLE_E_CANT_BINDTOSOURCE);


        // else we assume StdOleLink and continue with creation
        } else {
            lpSrcDataObj = lpBoundDataObj;

            if (IsEqualCLSID(clsidLast, CLSID_NULL))
                UtGetClassID((LPUNKNOWN)lpSrcDataObj,
                    &clsidLast);
        }
    }

    // Deal with CustomLinkSource
    // (see notes below)
    if (lpSrcDataObj) {
        STGMEDIUM       medTmp;
        FORMATETC       foretcTmp;

        INIT_FORETC(foretcTmp);
        foretcTmp.cfFormat = g_cfCustomLinkSource;
        foretcTmp.tymed = TYMED_ISTORAGE;

        if (lpSrcDataObj->QueryGetData(&foretcTmp) == NOERROR) {
            medTmp.tymed = TYMED_ISTORAGE;
            medTmp.pstg     = lpStg;
            medTmp.pUnkForRelease = NULL;

            if (error = lpSrcDataObj->GetDataHere(&foretcTmp,
                &medTmp))
                goto errRtn;

            error = wLoadAndInitObjectEx(lpSrcDataObj, iid,
                renderopt, cFormats, rgAdvf, rgFormatEtc,
                lpAdviseSink, rgdwConnection, lpClientSite,
                lpStg, lplpObj);

            // This is a really strange peice of logic,
            // spaghetti code at it's finest.  Basically,
            // this says that if there is *NOT* a
            // custom link source, then we want to do the
            // logic of wCreateObject, etc. below.  If we
            // got to this line in the code, then we
            // *did* have a custom link source, so
            // don't do the stuff below (thus the goto).

            // REVIEW32: If there are any bugs in here,
            // then rewrite this in a more sensible fashion.
            // I'm leaving as is for now due to time constraints.

            goto errRtn;
        }
    }

    // Otherwise
    if ((error = wCreateObject (CLSID_StdOleLink, FALSE,
                                iid, lpClientSite,
                                lpStg, STG_INITNEW, lplpObj)) != NOERROR)
        goto errRtn;

    if (lpSrcDataObj)
    {
        BOOL fCacheNodeCreated = FALSE;

        if ((error = wInitializeCacheEx(lpSrcDataObj, clsidLast,
            renderopt, cFormats, rgAdvf, rgFormatEtc, lpAdviseSink,
            rgdwConnection, *lplpObj, &fCacheNodeCreated)) != NOERROR)
        {

            if (error != NOERROR && fCacheNodeCreated)
            {
                fNeedsUpdate = TRUE;
                error = NOERROR;
            }

        }
    }

errRtn:

    if (error == NOERROR && *lplpObj)
        error = ((LPUNKNOWN) *lplpObj)->QueryInterface(IID_IOleLink,
                            (LPLPVOID) &lpLink);

    if (error == NOERROR && lpLink && (dwFlags & OLECREATE_LEAVERUNNING)) {
        // This will connect to the object if it is already running.
        lpLink->SetSourceMoniker (lpmkSrc, clsidLast);
    }

    // We bound to the object to initialize the cache. We don't need
    // it anymore
    if (lpBoundDataObj)
    {
        if (error == NOERROR && (dwFlags & OLECREATE_LEAVERUNNING))
            OleRun((LPUNKNOWN)*lplpObj);

        // this will give a chance to the object to go away, if it can
        wDoLockUnlock(lpBoundDataObj);
        lpBoundDataObj->Release();
    }

    // If the source object started running as a result of BindMoniker,
    // then we would've got rid of it by now.

    if (error == NOERROR && lpLink)
    {
        if ( !(dwFlags & OLECREATE_LEAVERUNNING) ) {
            // This will connect to the object if it is already running.
            lpLink->SetSourceMoniker (lpmkSrc, clsidLast);
        }

        if (fNeedsUpdate) {
            // relevant cache data is not available from the
            // lpSrcDataObj. So do Update and get the right cache
            // data.
            error = wDoUpdate ((LPUNKNOWN) *lplpObj);

            if (GetScode(error) == CACHE_E_NOCACHE_UPDATED)
                error = ReportResult(0, DV_E_FORMATETC, 0, 0);
        }

        // Release on lpLink is necessary only if error == NOERROR
        lpLink->Release();

    }

    if (error != NOERROR && *lplpObj) {
        ((IUnknown FAR*) *lplpObj)->Release();
        *lplpObj = NULL;
    }

    return error;
}


//+-------------------------------------------------------------------------
//
//  Function:   wCreateFromFileEx
//
//  Synopsis:   Creates an ole object from a file by binding the given
//              moniker and creating the object from the IDataObject pointer
//
//  Effects:
//
//  Arguments:  [lpmkFile]      -- moniker to the file
//              [iid]           -- requested interface ID
//              [dwFlags]       -- object creation flags
//              [renderopt]     -- render options, such as OLERENDER_DRAW
//              [cFormats]      -- the number of elements in rgFormatEtc
//              [rgAdvf]        -- array of advise flags, if OLRENDER_FORMAT
//                                 is specified in renderopt
//              [rgFormatEtc]   -- array of rendering formats, if
//                                 OLERENDER_FORMAT is specified in renderopt
//              [lpAdviseSink]  -- the advise sink for the object
//              [rgdwConnection]-- where to put the connection IDs for the
//                                 advisory connections
//              [lpClientSite]  -- pointer to the client site
//              [lpStg]         -- pointer to the storage for the new object
//              [lplpObj]       -- where to put the pointer to the object
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              29-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(wCreateFromFileEx)
INTERNAL wCreateFromFileEx
(
    LPMONIKER               lpmkFile,
    LPDATAOBJECT            lpDataObject,
    REFIID                  iid,
    DWORD                   dwFlags,
    DWORD                   renderopt,
    ULONG                   cFormats,
    DWORD FAR*              rgAdvf,
    LPFORMATETC             rgFormatEtc,
    IAdviseSink FAR*        lpAdviseSink,
    DWORD FAR*              rgdwConnection,
    LPOLECLIENTSITE         lpClientSite,
    LPSTORAGE               lpStg,
    LPLPVOID                lplpObj
)
{
    VDATEHEAP();

    HRESULT         error;
    LPDATAOBJECT    lpLocalDataObj;


    if (!lpDataObject)
    {
        if ((error = BindMoniker(lpmkFile, NULL, IID_IDataObject,
            (LPLPVOID) &lpLocalDataObj)) != NOERROR)
            return error;
    }
    else
    {
        lpLocalDataObj = lpDataObject;
    }

    Verify(lpLocalDataObj);

    error = wCreateFromDataEx(lpLocalDataObj, iid, dwFlags, renderopt, cFormats,
        rgAdvf, rgFormatEtc, lpAdviseSink, rgdwConnection, lpClientSite,
        lpStg, lplpObj);

    if (error == NOERROR && (dwFlags & OLECREATE_LEAVERUNNING))
        OleRun((LPUNKNOWN)*lplpObj);

    // If we bound locally release it now, else it is up to the caller to do the right thing.

    if (!lpDataObject)
    {
        wDoLockUnlock(lpLocalDataObj);
        lpLocalDataObj->Release();
    }

    return error;
}



//+-------------------------------------------------------------------------
//
//  Function:   CoIsHashedOle1Class
//
//  Synopsis:   Determines whether or not a CLSID is an OLE1 class
//
//  Effects:
//
//  Arguments:  [rclsid]        -- the class ID in question
//
//  Requires:
//
//  Returns:    TRUE if ole1.0, FALSE otherwise
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              29-Oct-93 alexgo    32bit port
//
//  Notes:      REVIEW32:  This is a strange function..consider nuking
//              it for 32bit, we may not need it (only used in 1 place)
//
//--------------------------------------------------------------------------


#pragma SEG(CoIsHashedOle1Class)
STDAPI_(BOOL) CoIsHashedOle1Class(REFCLSID rclsid)
{
    VDATEHEAP();

    CLSID clsid = rclsid;
    clsid.Data1 = 0L;
    WORD wHiWord = HIWORD(rclsid.Data1);
    return IsEqualGUID(clsid, IID_IUnknown) && wHiWord==4;
}



//+-------------------------------------------------------------------------
//
//  Function:   EnsureCLSIDIsRegistered
//
//  Synopsis:   Checks to see if the clsid is in the registration database,
//              if not, puts it there
//
//  Effects:
//
//  Arguments:  [clsid]         -- the clsid in question
//              [pstg]          -- storage to get more info about the
//                                 clsid if we need to register it
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              29-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(EnsureCLSIDIsRegistered)
void EnsureCLSIDIsRegistered
    (REFCLSID       clsid,
    LPSTORAGE       pstg)
{
    VDATEHEAP();

    LPOLESTR        szProgId = NULL;

    if (NOERROR == ProgIDFromCLSID (clsid, &szProgId))
    {
        PubMemFree(szProgId);
    }
    else
    {
        // This is the case of getting a hashed CLSID from a file from
        // another machine and the ProgId is not yet in the reg db,
        // so we must get it from the storage.
        // This code should rarely be executed.
        CLIPFORMAT      cf = 0;
        CLSID           clsidT;
        OLECHAR                 szProgId[256];

        if (ReadFmtUserTypeStg (pstg, &cf, NULL) != NOERROR)
            return;
        // Format is the ProgId
        if (0==GetClipboardFormatName (cf, szProgId, 256))
            return;
        // Will force registration of the CLSID if the ProgId (the OLE1
        // classname) is registered
        CLSIDFromProgID (szProgId, &clsidT);
    }
}



//+-------------------------------------------------------------------------
//
//  Function:   wCreateObject
//
//  Synopsis:   Calls CoCreateInstance to create an object, a defhandler
//              is created if necessary and CLSID info is written to
//              the storage.
//
//  Effects:
//
//  Arguments:  [clsid]         -- the class id of the object to create
//              [iid]           -- the requested interface ID
//              [lpClientSite]  -- pointer to the client site
//              [lpStg]         -- storage for the object
//              [wfStorage]     -- flags for the STORAGE, one of
//                                 STG_NONE, STD_INITNEW, STG_LOAD,
//                                 defined at the beginning of this file
//              [ppv]           -- where to put the pointer to the object
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              01-Feb-94 alexgo    fixed memory leak
//              29-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(wCreateObject)
INTERNAL        wCreateObject
(
    CLSID                   clsid,
    BOOL                    fPermitCodeDownload,    //parameter added in order to control whether code download occurs or not  -RahulTh (11/20/97)
    REFIID                  iid,
    IOleClientSite FAR*     lpClientSite,
    IStorage FAR *          lpStg,
    WORD                    wfStorage,
    void FAR* FAR*          ppv
)
{
    VDATEHEAP();

    HRESULT         error;
    DWORD           dwClsCtx;
    IOleObject* pOleObject = NULL;
    DWORD dwMiscStatus = 0;
    DWORD dwAddClsCtx;

    dwAddClsCtx = fPermitCodeDownload?0:CLSCTX_NO_CODE_DOWNLOAD;
    *ppv = NULL;

    CLSID clsidNew;
    if (wfStorage == STG_INITNEW
        && SUCCEEDED(OleGetAutoConvert (clsid, &clsidNew)))
        // Insert an object of the new class
        clsid = clsidNew;


    if (wfStorage == STG_LOAD && CoIsHashedOle1Class (clsid))
        EnsureCLSIDIsRegistered (clsid, lpStg);


    if (IsWOWThread())
    {
        // CLSCTX needs to be turned on for possible 16 bit inproc server
        // such as OLE controls
        dwClsCtx = CLSCTX_INPROC | CLSCTX_INPROC_SERVER16 | dwAddClsCtx;
    }
    else
    {
        dwClsCtx = CLSCTX_INPROC | dwAddClsCtx;
    }

    if ((error = CoCreateInstance (clsid, NULL /*pUnkOuter*/,
            dwClsCtx, iid, ppv)) != NOERROR) {

        // if not OleLoad or error other than class not registered,
        // exit
        if (wfStorage != STG_LOAD || GetScode(error)
            != REGDB_E_CLASSNOTREG)
            goto errRtn;

        // OleLoad and class not registered: use default handler
        // directly
        if ((error = OleCreateDefaultHandler(clsid, NULL, iid, ppv))
                != NOERROR)
            goto errRtn;
    }

    AssertSz(*ppv, "HRESULT is OK, but pointer is NULL");

    // Check if we have client site
    if(lpClientSite) {
        // QI for IOleObject on the server
        error = ((IUnknown *)*ppv)->QueryInterface(IID_IOleObject, (void **)&pOleObject);
        if(error == NOERROR) {
            // Get the MiscStatus bits
            error = pOleObject->GetMiscStatus(DVASPECT_CONTENT, &dwMiscStatus);

            // Set the client site first if OLEMISC_SETCLIENTSITEFIRST bit is set
            if(error == NOERROR && (dwMiscStatus & OLEMISC_SETCLIENTSITEFIRST)) {
                error = pOleObject->SetClientSite(lpClientSite);
                if(error != NOERROR) {
                    pOleObject->Release();
                    goto errRtn;
                }
            }
            else if(error != NOERROR) {
                error = NOERROR;
                dwMiscStatus = 0;
            }
        }
        else
            goto errRtn;
    }

    if (wfStorage != STG_NONE)
    {
        IPersistStorage FAR* lpPS;

        if ((error = ((LPUNKNOWN) *ppv)->QueryInterface(
            IID_IPersistStorage, (LPLPVOID)&lpPS)) != NOERROR)
        {
            goto errRtn;
        }

        if (wfStorage == STG_INITNEW)
        {
            error = WriteClassStg(lpStg, clsid);

            if (SUCCEEDED(error))
            {
                error = lpPS->InitNew (lpStg);
            }
        }
        else
        {
            error = lpPS->Load (lpStg);
        }

        lpPS->Release();

        if (FAILED(error))
        {
            goto errRtn;
        }

    }


    if(lpClientSite) {
        // Assert that pOleObject is set
        Win4Assert(IsValidInterface(pOleObject));

        // Set the client site if it has not been set already
        if(!(dwMiscStatus & OLEMISC_SETCLIENTSITEFIRST))
            error = pOleObject->SetClientSite (lpClientSite);

        // Release the object
        pOleObject->Release();

        if (FAILED(error))
            goto errRtn;
    }

    AssertSz(error == NOERROR, "Invalid code path");

    return NOERROR;

errRtn:

    if (*ppv) {
        ((LPUNKNOWN) *ppv)->Release();
        *ppv = NULL;
    }

    return error;
}



//+-------------------------------------------------------------------------
//
//  Function:   wLoadAndInitObjectEx
//
//  Synopsis:   Loads and binds an object from the given storage.
//              A cacle is initialized from the data object
//
//  Effects:
//
//  Arguments:  [lpSrcDataObj]  -- pointer to the data object to initialize
//                                 the cache with
//              [iid]           -- requested interface ID
//              [renderopt]     -- render options, such as OLERENDER_DRAW
//              [cFormats]      -- the number of elements in rgFormatEtc
//              [rgAdvf]        -- array of advise flags, if OLRENDER_FORMAT
//                                 is specified in renderopt
//              [rgFormatEtc]   -- array of rendering formats, if
//                                 OLERENDER_FORMAT is specified in renderopt
//              [lpAdviseSink]  -- the advise sink for the object
//              [rgdwConnection]-- where to put the connection IDs for the
//                                 advisory connections
//              [lpClientSite]  -- pointer to the client site.
//              [lpStg]         -- storage for the new object
//              [lplpObj]       -- where to put the pointer to the new object
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              29-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(wLoadAndInitObjectEx)
INTERNAL wLoadAndInitObjectEx
(
    IDataObject FAR*        lpSrcDataObj,
    REFIID                  iid,
    DWORD                   renderopt,
    ULONG                   cFormats,
    DWORD FAR*              rgAdvf,
    LPFORMATETC             rgFormatEtc,
    IAdviseSink FAR*        lpAdviseSink,
    DWORD FAR*              rgdwConnection,
    IOleClientSite FAR*     lpClientSite,
    IStorage FAR*           lpStg,
    void FAR* FAR*          lplpObj
)
{
    VDATEHEAP();

    HRESULT                 error;
    CLSID                   clsid;

    if ((error = OleLoadWithoutBinding(lpStg, FALSE, iid, lpClientSite,
            lplpObj)) != NOERROR)
        return error;

    UtGetClassID((LPUNKNOWN) *lplpObj, &clsid);

    error = wInitializeCacheEx(lpSrcDataObj, clsid, renderopt,
        cFormats, rgAdvf, rgFormatEtc, lpAdviseSink, rgdwConnection,
        *lplpObj);

    if (error != NOERROR) {
        // relevant cache data is not available from the lpSrcDataObj.
        // So do Update and get the right cache data.
        error = wDoUpdate ((LPUNKNOWN) *lplpObj);
    }

    if (GetScode(error) == CACHE_E_NOCACHE_UPDATED) {
        error = ReportResult(0, DV_E_FORMATETC, 0, 0);
        goto errRtn;
    }

    if (error == NOERROR)
        wBindIfRunning((LPUNKNOWN) *lplpObj);

errRtn:
    if (error != NOERROR && *lplpObj) {
        ((IUnknown FAR*) *lplpObj)->Release();
        *lplpObj = NULL;
    }

    return error;
}


//+-------------------------------------------------------------------------
//
//  Function:   wInitializeCacheEx
//
//  Synopsis:   Query's for IOleCache on the given object and calls IOC->Cache
//              to initialize a cache node.
//
//  Effects:
//
//  Arguments:  [lpSrcDataObj]  -- pointer to data to initialize the cache
//                                 with
//              [rclsid]        -- CLSID to use if an icon is needed
//              [renderopt]     -- render options, such as OLERENDER_DRAW
//              [cFormats]      -- the number of elements in rgFormatEtc
//              [rgAdvf]        -- array of advise flags, if OLRENDER_FORMAT
//                                 is specified in renderopt
//              [rgFormatEtc]   -- array of rendering formats, if
//                                 OLERENDER_FORMAT is specified in renderopt
//              [lpAdviseSink]  -- the advise sink for the object
//              [rgdwConnection]-- where to put the connection IDs for the
//                                 advisory connections
//              [lpNewObj]      -- the object on which the cache should
//                                 be initialized
//              [pfCacheNodeCreated]    -- where to return a flag indicating
//                                         whether or not a cache node was
//                                         created
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              31-Oct-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


// This routine modifies lpFormatEtc's fields.

#pragma SEG(wInitializeCacheEx)
INTERNAL wInitializeCacheEx
(
    IDataObject FAR*        lpSrcDataObj,
    REFCLSID                rclsid,
    DWORD                   renderopt,
    ULONG                   cFormats,
    DWORD FAR*              rgAdvf,
    LPFORMATETC             rgFormatEtc,
    IAdviseSink FAR*        lpAdviseSink,
    DWORD FAR*              rgdwConnection,
    void FAR*               lpNewObj,
    BOOL FAR*               pfCacheNodeCreated
)
{
    VDATEHEAP();

    IDataObject FAR*        lpNewDataObj = NULL;
    IOleCache FAR*          lpOleCache = NULL;
    HRESULT                 error;
    LPFORMATETC             lpFormatEtc;
    DWORD                   advf;
    STGMEDIUM               stgmed;
    DWORD                   dwConnId = 0;
    BOOL                    fIconCase;

    if (pfCacheNodeCreated)
        *pfCacheNodeCreated = FALSE;

    if (renderopt == OLERENDER_NONE || renderopt == OLERENDER_ASIS)
        return NOERROR;

    if (lpAdviseSink) {
        if ((error = ((IUnknown FAR*)lpNewObj)->QueryInterface(IID_IDataObject,
            (LPLPVOID) &lpNewDataObj)) != NOERROR)
            return error;
    }
    else {
        if (((IUnknown FAR*)lpNewObj)->QueryInterface(IID_IOleCache,
            (LPLPVOID) &lpOleCache) != NOERROR)
            return wQueryFormatSupport(lpNewObj, renderopt, rgFormatEtc);
    }

    for (ULONG i=0; i<cFormats; i++)
    {
        advf = (rgAdvf ? rgAdvf[i] : ADVF_PRIMEFIRST);
        lpFormatEtc = &rgFormatEtc[i];
        fIconCase = FALSE;

        if (lpFormatEtc->dwAspect == DVASPECT_ICON) {
            if (lpFormatEtc->cfFormat == NULL) {
                lpFormatEtc->cfFormat = CF_METAFILEPICT;
                lpFormatEtc->tymed = TYMED_MFPICT;
            }
            fIconCase = (lpFormatEtc->cfFormat == CF_METAFILEPICT);
        }

        if (lpAdviseSink)
        {
            // if icon case, must use these advise flags or the icon
            // data won't get passed back correctly
            if (fIconCase)
                advf |= (ADVF_PRIMEFIRST | ADVF_ONLYONCE);

            // should we send the data immediately?
            if ((advf & ADVF_PRIMEFIRST) && lpSrcDataObj)
            {
                stgmed.tymed = TYMED_NULL;
                stgmed.pUnkForRelease = NULL;

                if (advf & ADVF_NODATA)
                {
                    // don't sent data, send only the notification
                    lpAdviseSink->OnDataChange(lpFormatEtc, &stgmed);
                }
                else
                {
                    if (fIconCase)
                        error = UtGetIconData(lpSrcDataObj, rclsid, lpFormatEtc, &stgmed);
                    else
                        error = lpSrcDataObj->GetData(lpFormatEtc, &stgmed);

                    if (error != NOERROR)
                        goto errRtn;

                    // send data to sink and release stdmedium
                    lpAdviseSink->OnDataChange(lpFormatEtc, &stgmed);
                    ReleaseStgMedium(&stgmed);
                }

                if (advf & ADVF_ONLYONCE)
                    continue;

                // remove the ADVF_PRIMEFIRST from flags.
                advf &= (~ADVF_PRIMEFIRST);
            }

            // setup advisory connection
            if ((error = lpNewDataObj->DAdvise(lpFormatEtc, advf,
                lpAdviseSink, &dwConnId)) != NOERROR)
                goto errRtn;

            // optionally stuff the id in the array
            if (rgdwConnection)
                rgdwConnection[i] = dwConnId;
        }
        else
        {
            if (fIconCase)
                advf = ADVF_NODATA;

            // Create a cache of already specified view format.
            // In case of olerender_draw, lpFormatEtc->cfFormat would have already
            // been set to NULL.

            error = lpOleCache->Cache(lpFormatEtc, advf, &dwConnId);

            if (FAILED(GetScode(error))) {
                if (! ((dwConnId != 0) && fIconCase) )
                    goto errRtn;

                // In icon case we can ignore the cache's QueryGetData failure
            }

            error = NOERROR;
            if (pfCacheNodeCreated)
                *pfCacheNodeCreated = TRUE;

            if (fIconCase) {
                if ((error = UtGetIconData(lpSrcDataObj, rclsid, lpFormatEtc,
                    &stgmed)) == NOERROR) {
                    if ((error = lpOleCache->SetData(lpFormatEtc, &stgmed,
                        TRUE)) != NOERROR)
                        ReleaseStgMedium(&stgmed);
                }
            }
        }
    }

    if (error == NOERROR && !lpAdviseSink && lpSrcDataObj)
        error = lpOleCache->InitCache(lpSrcDataObj);

errRtn:
    if (lpNewDataObj)
        lpNewDataObj->Release();
    if (lpOleCache)
        lpOleCache->Release();
    return error;
}


//+-------------------------------------------------------------------------
//
//  Function:   wReturnCreationError
//
//  Synopsis:   modifies the return code, used internally in creation api's
//
//  Effects:
//
//  Arguments:  [hresult]       -- the original error code
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              01-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


INTERNAL wReturnCreationError(HRESULT hresult)
{
    VDATEHEAP();

    if (hresult != NOERROR) {
        SCODE sc = GetScode(hresult);

        if (sc == CACHE_S_FORMATETC_NOTSUPPORTED
                || sc == CACHE_E_NOCACHE_UPDATED)
            return ReportResult(0, DV_E_FORMATETC, 0, 0);
    }

    return hresult;
}


//+-------------------------------------------------------------------------
//
//  Function:   wGetMonikerAndClassFromFile
//
//  Synopsis:   gets a moniker and class id from the given file
//
//  Effects:
//
//  Arguments:  [lpszFileName]  -- the file
//              [fLink]         -- passed onto CreatePackagerMoniker
//              [lplpmkFile]    -- where to put the pointer to the file
//                                 moniker
//              [lpfPackagerMoniker]    -- where to put a flag indicating
//                                         whether or not a packager moniker
//                                         was created.
//              [lpClsid]       -- where to put the class ID
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              01-Nov-93 alexgo    32bit port
//              10-May-94 KevinRo   Reimplemented OLE 1.0 interop
//              03-Mar-95 ScottSk   Added STG_E_FILENOTFOUND
//
//
//--------------------------------------------------------------------------


INTERNAL wGetMonikerAndClassFromFile
(
    LPCOLESTR               lpszFileName,
    BOOL                    fLink,
    LPMONIKER FAR*          lplpmkFile,
    BOOL FAR*               lpfPackagerMoniker,
    CLSID FAR*              lpClsid,
    LPDATAOBJECT *          lplpDataObject
)
{
HRESULT hrFileMoniker;
HRESULT hresult;
BOOL fHaveBoundClsid = FALSE;
LPMONIKER  lpFileMoniker;

    VDATEHEAP();

     *lplpDataObject = NULL;
     *lplpmkFile = NULL;

     // To ensure the same error codes are returned as before we don't return immediately if CreateFileMoniker fails.
    hrFileMoniker = CreateFileMoniker((LPOLESTR)lpszFileName, &lpFileMoniker);
    Assert( (NOERROR == hrFileMoniker) || (NULL == lpFileMoniker) );

    if (NOERROR == hrFileMoniker)
    {
    LPBINDCTX pbc;

        if (SUCCEEDED(CreateBindCtx( 0, &pbc )))
        {
            if (S_OK == lpFileMoniker->IsRunning(pbc,NULL,NULL))
            {

                // If the Object is Running Bind and get the CLSID
                if (NOERROR == lpFileMoniker->BindToObject(pbc, NULL, IID_IDataObject,
                        (LPLPVOID) lplpDataObject))
                {
                    fHaveBoundClsid = UtGetClassID((LPUNKNOWN)*lplpDataObject,lpClsid);
                    Assert( (TRUE == fHaveBoundClsid) || (IsEqualCLSID(*lpClsid, CLSID_NULL)) );
                }

            }

            pbc->Release();
        }
    }

    if (!fHaveBoundClsid)
    {
        // Call GetClassFileEx directly (rather than going through GetClassFile).
        hresult = GetClassFileEx ((LPOLESTR)lpszFileName, lpClsid, CLSID_NULL);
        Assert( (NOERROR == hresult) || (IsEqualCLSID(*lpClsid, CLSID_NULL)) );

        if (NOERROR == hresult)
            fHaveBoundClsid = TRUE;
    }


    // If have a CLSID at this point see if its insertable.
    if (fHaveBoundClsid)
    {

        Assert(!IsEqualCLSID(*lpClsid, CLSID_NULL));

        // Check whether we need package this file, even though it is an
        // OLE class file.
        if (!wNeedToPackage(*lpClsid))
        {
            if (lpfPackagerMoniker != NULL)
            {
                *lpfPackagerMoniker = FALSE;
            }

            *lplpmkFile = lpFileMoniker;
            return hrFileMoniker;
        }
    }

    //
    // We didnt' find an OLE insertable object or couldn't get the CLSID. Therefore, create a
    // packager moniker for it.
    //

     // If Bound to the DataObject, release it.
    if (*lplpDataObject)
    {
        (*lplpDataObject)->Release();
        *lplpDataObject = NULL;
    }


    // If GetClassFileEx() failed because the file was not found or could not be openned.
    // don't try to bind with Packager.
    if (hresult == MK_E_CANTOPENFILE)
    {
        if (NOERROR == hrFileMoniker)
        {
            lpFileMoniker->Release();
        }

        return STG_E_FILENOTFOUND;
    }

    // If we failed to create the file moniker its finally safe to bail without changing the error code.
    if (NOERROR != hrFileMoniker)
    {
        return hrFileMoniker;
    }

    if (lpfPackagerMoniker != NULL)
    {
        *lpfPackagerMoniker = TRUE;
    }

    hresult =  CreatePackagerMonikerEx(lpszFileName,lpFileMoniker,fLink,lplpmkFile);
    lpFileMoniker->Release();

    return hresult;
}



//+-------------------------------------------------------------------------
//
//  Function:   wCreatePackageEx
//
//  Synopsis:   Internal function, does a IDO->GetData for a filename, and
//              then creates either a link or normal object from that file
//
//  Effects:
//
//  Arguments:  [lpSrcDataObj]  -- the source for the filename
//              [iid]           -- the requested interface ID
//              [dwFlags]       -- object creation flags
//              [renderopt]     -- render options, such as OLERENDER_DRAW
//              [cFormats]      -- the number of elements in rgFormatEtc
//              [rgAdvf]        -- array of advise flags, if OLRENDER_FORMAT
//                                 is specified in renderopt
//              [rgFormatEtc]   -- array of rendering formats, if
//                                 OLERENDER_FORMAT is specified in renderopt
//              [lpAdviseSink]  -- the advise sink for the object
//              [rgdwConnection]-- where to put the connection IDs for the
//                                 advisory connections
//              [lpClientSite]  -- client site for the object
//              [lpStg]         -- storage for the object
//              [fLink]         -- if TRUE, create a link
//              [lplpObj]       -- where to put the pointer to the object
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  Gets a filename from the data object (converting to Unicode
//              if necessary) and then creates either an embedding or link
//              from that filename.
//
//  History:    dd-mmm-yy Author    Comment
//              24-Apr-94 alexgo    rewrote to handle FileNameW
//              01-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(wCreatePackageEx)
INTERNAL wCreatePackageEx
(
    LPDATAOBJECT            lpSrcDataObj,
    REFIID                  iid,
    DWORD                   dwFlags,
    DWORD                   renderopt,
    ULONG                   cFormats,
    DWORD FAR*              rgAdvf,
    LPFORMATETC             rgFormatEtc,
    IAdviseSink FAR*        lpAdviseSink,
    DWORD FAR*              rgdwConnection,
    LPOLECLIENTSITE         lpClientSite,
    LPSTORAGE               lpStg,
    BOOL                    fLink,
    LPLPVOID                lplpObj
)
{
    VDATEHEAP();

    FORMATETC               formatetc;
    STGMEDIUM               medium;
    HRESULT                 hresult;
    CLSID                   clsid = CLSID_NULL;
    LPOLESTR                pszFileName = NULL;
    OLECHAR                 szFileName[MAX_PATH +1];        // in case we
                                // have to
                                // translate

    LEDebugOut((DEB_ITRACE, "%p _IN wCreatePackageEx ( %p , %p , %lx , %lx ,"
        " %lx , %p , %p , %p , %p , %p , %p , %lu , %p )\n", NULL, lpSrcDataObj,
        &iid, dwFlags, renderopt, cFormats, rgAdvf, rgFormatEtc, lpAdviseSink,
        rgdwConnection, lpClientSite, lpStg, fLink, lplpObj));

    INIT_FORETC(formatetc);
    formatetc.cfFormat      = g_cfFileNameW;
    formatetc.tymed         = TYMED_HGLOBAL;

    // zero the medium
    _xmemset(&medium, 0, sizeof(STGMEDIUM));

    // we don't need to do a QueryGetData, because we will have only
    // gotten here on the advice of a formatetc enumerator from the
    // data object (and thus, one of the GetData calls should succeed).


    hresult = lpSrcDataObj->GetData(&formatetc, &medium);

    // if we couldn't get the Unicode filename for some reason, try
    // for the ANSI version

    if( hresult != NOERROR )
    {
        char *          pszAnsiFileName;
        DWORD           cwchSize;

        formatetc.cfFormat = g_cfFileName;
        // re-NULL the medium, just in case it was messed up by
        // the first call above

        _xmemset( &medium, 0, sizeof(STGMEDIUM));

        hresult = lpSrcDataObj->GetData(&formatetc, &medium);

        if( hresult == NOERROR )
        {
            pszAnsiFileName = (char *)GlobalLock(medium.hGlobal);

            cwchSize = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED,
                pszAnsiFileName, -1, szFileName, MAX_PATH);

            if( cwchSize == 0 )
            {
                GlobalUnlock(medium.hGlobal);
                ReleaseStgMedium(&medium);
                hresult = ResultFromScode(E_FAIL);
            }
            else
            {
                pszFileName = szFileName;
            }
            // we will Unlock at the end of the routine
        }
    }
    else
    {
        pszFileName = (LPOLESTR)GlobalLock(medium.hGlobal);
    }

    if( hresult == NOERROR )
    {
        if (fLink)
        {
            hresult = OleCreateLinkToFileEx(pszFileName, iid,
                dwFlags, renderopt, cFormats, rgAdvf, rgFormatEtc,
                lpAdviseSink, rgdwConnection, lpClientSite, lpStg, lplpObj);
        }
        else
        {
            hresult = OleCreateFromFileEx(clsid, pszFileName, iid,
                dwFlags, renderopt, cFormats, rgAdvf, rgFormatEtc,
                lpAdviseSink, rgdwConnection, lpClientSite, lpStg, lplpObj);
        }

        GlobalUnlock(medium.hGlobal);
        ReleaseStgMedium(&medium);
    }

    LEDebugOut((DEB_ITRACE, "%p OUT wCreatePackageEx ( %lx ) [ %p ]\n",
        NULL, hresult, *lplpObj));

    return hresult;
}


//+-------------------------------------------------------------------------
//
//  Function:   wValidateCreateParams
//
//  Synopsis:   Validate the incoming create parameters
//
//  Effects:
//
//  Arguments:  [cFormats]      -- the number of elements in rgAdvf
//              [rgAdvf]        -- array of advise flags
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              26-Apr-96 davidwor  added function
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(wValidateCreateParams)
INTERNAL wValidateCreateParams
(
    DWORD                   dwFlags,
    DWORD                   renderopt,
    ULONG                   cFormats,
    DWORD FAR*              rgAdvf,
    LPFORMATETC             rgFormatEtc,
    IAdviseSink FAR*        lpAdviseSink,
    DWORD FAR*              rgdwConnection,
    IOleClientSite FAR*     lpClientSite,
    IStorage FAR*           lpStg
)
{
    HRESULT     hresult = NOERROR;

    VDATEHEAP();

    if (dwFlags != (dwFlags & OLECREATE_LEAVERUNNING)) {
        VdateAssert(dwFlags, "Invalid creation flags");
        hresult = ResultFromScode(E_INVALIDARG);
        goto errRtn;
    }

    if (renderopt == OLERENDER_DRAW && cFormats > 1) {
        VdateAssert(cFormats, "Multiple formats not allowed with OLERENDER_DRAW");
        hresult = ResultFromScode(E_INVALIDARG);
        goto errRtn;
    }

    if (renderopt != OLERENDER_FORMAT)
        VDATEPTRNULL_LABEL( lpAdviseSink, errRtn, hresult );

    if (cFormats == 0) {
        VDATEPTRNULL_LABEL( rgAdvf, errRtn, hresult );
        VDATEPTRNULL_LABEL( rgFormatEtc, errRtn, hresult );
        VDATEPTRNULL_LABEL( rgdwConnection, errRtn, hresult );
    }
    else {
        VDATESIZEREADPTRIN_LABEL( rgAdvf, cFormats * sizeof(DWORD), errRtn, hresult );
        VDATESIZEREADPTRIN_LABEL( rgFormatEtc, cFormats * sizeof(FORMATETC), errRtn, hresult );
        if ( rgdwConnection ) {
            VDATESIZEPTROUT_LABEL( rgdwConnection, cFormats * sizeof(DWORD), errRtn, hresult );
            _xmemset(rgdwConnection, 0, cFormats * sizeof(DWORD));
        }
    }

    if ((hresult = wValidateAdvfEx(cFormats, rgAdvf)) != NOERROR)
        goto errRtn;

    VDATEIFACE_LABEL( lpStg, errRtn, hresult );
    if ( lpAdviseSink )
        VDATEIFACE_LABEL( lpAdviseSink, errRtn, hresult );
    if ( lpClientSite )
        VDATEIFACE_LABEL( lpClientSite, errRtn, hresult );

errRtn:
    return hresult;
}


//+-------------------------------------------------------------------------
//
//  Function:   wValidateAdvfEx
//
//  Synopsis:   Validate the incoming array of ADVF values
//
//  Effects:
//
//  Arguments:  [cFormats]      -- the number of elements in rgAdvf
//              [rgAdvf]        -- array of advise flags
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              19-Mar-96 davidwor  added function
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(wValidateAdvfEx)
INTERNAL wValidateAdvfEx
(
    ULONG                   cFormats,
    DWORD FAR*              rgAdvf
)
{
    VDATEHEAP();

    if ((cFormats != 0) != (rgAdvf != NULL))
        return ResultFromScode(E_INVALIDARG);

    for (ULONG i=0; i<cFormats; i++)
    {
        if (rgAdvf[i] != (rgAdvf[i] & MASK_VALID_ADVF))
        {
            VdateAssert(rgAdvf, "Invalid ADVF value specified");
            return ResultFromScode(E_INVALIDARG);
        }
    }

    return NOERROR;
}


//+-------------------------------------------------------------------------
//
//  Function:   wValidateFormatEtc
//
//  Synopsis:   Validate the incoming formatetc and initialize the
//              out formatetc with the correct info
//
//  Effects:
//
//  Arguments:  [renderopt]     -- rendering option
//              [lpFormatEtc]   -- the incoming formatetc
//              [lpMyFormatEtc] -- the out formatetc
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              01-Nov-93 alexgo    32bit port
//
//  Notes:  The original comments,
//
// Validate the lpFormatEtc that's been passed to the creation APIs. And then
// initialize our formateEtc structure with the appropriate info.
//
// We allow NULL lpFormatEtc if the render option is olerender_draw
// We ignore lpFormatEtc if the render option is olerender_none
//
//--------------------------------------------------------------------------


#pragma SEG(wValidateFormatEtc)
INTERNAL wValidateFormatEtc
(
    DWORD                   renderopt,
    LPFORMATETC             lpFormatEtc,
    LPFORMATETC             lpMyFormatEtc
)
{
    VDATEHEAP();

    SCODE sc = S_OK;

    if (renderopt == OLERENDER_NONE || renderopt == OLERENDER_ASIS)
        return NOERROR;

    if (renderopt == OLERENDER_FORMAT) {
        if (!lpFormatEtc || !lpFormatEtc->cfFormat) {
            sc = E_INVALIDARG;
            goto errRtn;
        }

        if (lpFormatEtc->tymed !=
            UtFormatToTymed(lpFormatEtc->cfFormat)) {
            sc = DV_E_TYMED;
            goto errRtn;
        }

    } else if (renderopt == OLERENDER_DRAW) {
        if (lpFormatEtc) {
            if (lpFormatEtc->cfFormat != NULL) {
                VdateAssert(lpFormatEtc->cfFormat,"NON-NULL clipformat specified with OLERENDER_DRAW");
                sc = DV_E_CLIPFORMAT;
                goto errRtn;
            }

            if (lpFormatEtc->tymed != TYMED_NULL) {
                VdateAssert(lpFormatEtc->tymed,"TYMED_NULL is not specified with OLERENDER_DRAW");
                sc = DV_E_TYMED;
                goto errRtn;
            }
        }
    } else {
        VdateAssert(renderopt, "Unexpected value for OLERENDER_ option");
        sc = E_INVALIDARG;
        goto errRtn;
    }

    if (lpFormatEtc) {
        if (!HasValidLINDEX(lpFormatEtc))
        {
          sc = DV_E_LINDEX;
          goto errRtn;
        }

        VERIFY_ASPECT_SINGLE(lpFormatEtc->dwAspect)

        *lpMyFormatEtc = *lpFormatEtc;

    } else {
        INIT_FORETC(*lpMyFormatEtc);
        lpMyFormatEtc->tymed    = TYMED_NULL;
        lpMyFormatEtc->cfFormat = NULL;
    }

errRtn:
    return ReportResult(0, sc, 0, 0);
}


//+-------------------------------------------------------------------------
//
//  Function:   wValidateFormatEtcEx
//
//  Synopsis:   Validate the incoming formatetc and initialize the
//              out formatetc with the correct info
//
//  Effects:
//
//  Arguments:  [renderopt]     -- rendering option
//              [lpcFormats]    -- the number of elements in rgFormatEtc
//              [rgFormatEtc]   -- array of rendering formats
//              [lpFormatEtc]   -- place to store valid formatetc if only one
//              [lplpFormatEtc] -- the out array of formatetcs
//              [lpfAlloced]    -- place to store whether array was allocated
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              01-Nov-93 alexgo    32bit port
//
//  Notes:  The original comments,
//
// Validate the lpFormatEtc that's been passed to the creation APIs. And then
// initialize our formateEtc structure with the appropriate info.
//
// We allow NULL lpFormatEtc if the render option is olerender_draw
// We ignore lpFormatEtc if the render option is olerender_none
//
//--------------------------------------------------------------------------


#pragma SEG(wValidateFormatEtcEx)
INTERNAL wValidateFormatEtcEx
(
    DWORD                   renderopt,
    ULONG FAR*              lpcFormats,
    LPFORMATETC             rgFormatEtc,
    LPFORMATETC             lpFormatEtc,
    LPFORMATETC FAR*        lplpFormatEtc,
    LPBOOL                  lpfAlloced
)
{
    LPFORMATETC             lpfmtetc;

    VDATEHEAP();

    SCODE sc = S_OK;

    *lplpFormatEtc = lpFormatEtc;
    *lpfAlloced = FALSE;

    if (renderopt == OLERENDER_NONE || renderopt == OLERENDER_ASIS)
        return NOERROR;

    if (renderopt != OLERENDER_FORMAT && renderopt != OLERENDER_DRAW) {
        VdateAssert(renderopt, "Unexpected value for OLERENDER_ option");
        return ResultFromScode(E_INVALIDARG);
    }

    if ((*lpcFormats != 0) != (rgFormatEtc != NULL))
        return ResultFromScode(E_INVALIDARG);

    if (*lpcFormats <= 1) {
        if (*lpcFormats == 0)
            *lpcFormats = 1;
        return wValidateFormatEtc(renderopt, rgFormatEtc, lpFormatEtc);
    }

    *lplpFormatEtc = (LPFORMATETC)PubMemAlloc(*lpcFormats * sizeof(FORMATETC));
    if (!*lplpFormatEtc)
        return E_OUTOFMEMORY;

    *lpfAlloced = TRUE;

    for (ULONG i=0; i<*lpcFormats; i++)
    {
        lpfmtetc = &rgFormatEtc[i];

        if (renderopt == OLERENDER_FORMAT)
        {
            if (!lpfmtetc->cfFormat) {
                sc = E_INVALIDARG;
                goto errRtn;
            }

            if (lpfmtetc->tymed !=
                UtFormatToTymed(lpfmtetc->cfFormat)) {
                sc = DV_E_TYMED;
                goto errRtn;
            }
        }
        else if (renderopt == OLERENDER_DRAW)
        {
            if (lpfmtetc->cfFormat != NULL) {
                VdateAssert(lpfmtetc->cfFormat,"NON-NULL clipformat specified with OLERENDER_DRAW");
                sc = DV_E_CLIPFORMAT;
                goto errRtn;
            }

            if (lpfmtetc->tymed != TYMED_NULL) {
                VdateAssert(lpfmtetc->tymed,"TYMED_NULL is not specified with OLERENDER_DRAW");
                sc = DV_E_TYMED;
                goto errRtn;
            }
        }

        if (!HasValidLINDEX(lpfmtetc))
        {
            sc = DV_E_LINDEX;
            goto errRtn;
        }

        VERIFY_ASPECT_SINGLE(lpfmtetc->dwAspect)

        (*lplpFormatEtc)[i] = *lpfmtetc;
    }

errRtn:
    if (sc != S_OK) {
        PubMemFree(*lplpFormatEtc);
        *lpfAlloced = FALSE;
    }
    return ReportResult(0, sc, 0, 0);
}


//+-------------------------------------------------------------------------
//
//  Function:   wQueryFormatSupport
//
//  Synopsis:   check to see whether we will be able to Get and SetData of
//              the given format
//
//  Effects:
//
//  Arguments:  [lpObj]         -- pointer to the object
//              [renderopt]     -- rendering options
//              [lpFormatEtc]   -- the formatetc in question
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  Internal function, calls UtIsFormatSupported (which calls
//              EnumFormatEtc and checks all of the formats) if renderopt
//              is OLERENDER_FORMAT
//
//  History:    dd-mmm-yy Author    Comment
//              01-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


#pragma SEG(wQueryFormatSupport)
INTERNAL wQueryFormatSupport
    (LPVOID lpObj, DWORD renderopt, LPFORMATETC lpFormatEtc)
{
    VDATEHEAP();

    IDataObject FAR*        lpDataObj;
    HRESULT                 error = NOERROR;

    if (renderopt == OLERENDER_FORMAT)
    {
        if ((error = ((IUnknown FAR*) lpObj)->QueryInterface(
            IID_IDataObject, (LPLPVOID)&lpDataObj)) == NOERROR)
        {
            if (!UtIsFormatSupported(lpDataObj,
                    DATADIR_GET | DATADIR_SET,
                    lpFormatEtc->cfFormat))
                error = ResultFromScode(DV_E_CLIPFORMAT);

            lpDataObj->Release();
        }
    }

    return error;
}


//+-------------------------------------------------------------------------
//
//  Function:   wGetMonikerAndClassFromObject
//
//  Synopsis:   Gets the moniker and class ID from the given object
//
//  Effects:
//
//  Arguments:  [lpSrcDataObj]  -- the data object
//              [lplpmkSrc]     -- where to put a pointer to the moniker
//              [lpclsidLast]   -- where to put the clsid
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              15-Mar-95 alexgo    added a hack for CorelDraw5
//              01-Nov-93 alexgo    32bit port
//
//  Notes:      see also wGetMonikerAndClassFromFile
//
//--------------------------------------------------------------------------



#pragma SEG(wGetMonikerAndClassFromObject)
INTERNAL wGetMonikerAndClassFromObject(
    LPDATAOBJECT            lpSrcDataObj,
    LPMONIKER FAR*          lplpmkSrc,
    CLSID FAR*              lpclsidLast
)
{
    VDATEHEAP();

    HRESULT                 error;
    FORMATETC               foretcTmp;
    STGMEDIUM               medium;
    LPMONIKER               lpmkSrc = NULL;
    LARGE_INTEGER   large_integer;

    INIT_FORETC(foretcTmp);
    foretcTmp.cfFormat = g_cfLinkSource;
    foretcTmp.tymed    = TYMED_ISTREAM;

    // 16bit OLE had a bug where the medium was uninitialized at this
    // point.  Corel5, when doing a paste-link to itself, actually
    // checked the tymed and compared it with TYMED_NULL.  So here
    // we set the value to something recognizeable.
    //
    // NB!  In the thunk layer, if we are *NOT* in Corel Draw, this
    // value will be reset to TYMED_NULL.

    if( IsWOWThread() )
    {
        medium.tymed = 0x66666666;
    }
    else
    {
        medium.tymed = TYMED_NULL;
    }
    medium.pstm  = NULL;
    medium.pUnkForRelease = NULL;

    if ((error = lpSrcDataObj->GetData(&foretcTmp, &medium)) != NOERROR)
            return ReportResult(0, OLE_E_CANT_GETMONIKER, 0, 0);

    LISet32( large_integer, 0 );
    if ((error = (medium.pstm)->Seek (large_integer, STREAM_SEEK_SET,
        NULL)) != NOERROR)
        goto FreeStgMed;

    // get moniker from the stream
    if ((error = OleLoadFromStream (medium.pstm, IID_IMoniker,
        (LPLPVOID) lplpmkSrc)) != NOERROR)
        goto FreeStgMed;

    // read class stm; if error, use CLSID_NULL (for compatibility with
    // prior times when the clsid was missing).
    ReadClassStm(medium.pstm, lpclsidLast);

FreeStgMed:
    ReleaseStgMedium (&medium);
    if (error != NOERROR)
        return ReportResult(0, OLE_E_CANT_GETMONIKER, 0, 0);

    return NOERROR;
}


//+-------------------------------------------------------------------------
//
//  Function:   wDoLockUnlock
//
//  Synopsis:   tickles an object by locking and unlocking, used to resolve
//              ambiguities with stub manager locks
//
//  Effects:    the object may go away as a result of this call, if the
//              object is invisible and the lock count goes to zero as
//              a result of locking/unlocking.
//
//  Arguments:  [lpUnk]         -- pointer to the object to lock/unlock
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              01-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(wDoLockUnlock)
void wDoLockUnlock(IUnknown FAR* lpUnk)
{
    VDATEHEAP();

    IRunnableObject FAR* pRO;

    if (lpUnk->QueryInterface(IID_IRunnableObject, (LPLPVOID)&pRO)
        == NOERROR)
    {       // increase lock count
        if (pRO->LockRunning(TRUE, FALSE) == NOERROR)
            // decrease lock count
            pRO->LockRunning(FALSE, TRUE);
        pRO->Release();
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   wSaveObjectWithoutCommit
//
//  Synopsis:   Saves an object without committing (to preserve the
//              container's undo state)
//
//  Effects:
//
//  Arguments:  [lpUnk]         -- pointer to the object
//              [pstgSave]      -- storage in which to save
//              [fSameAsLoad]   -- indicates SaveAs operation
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

INTERNAL wSaveObjectWithoutCommit
    (LPUNKNOWN lpUnk, LPSTORAGE pstgSave, BOOL fSameAsLoad)
{
    VDATEHEAP();

    LPPERSISTSTORAGE                pPS;
    HRESULT                         error;
    CLSID                           clsid;

    if (error = lpUnk->QueryInterface(IID_IPersistStorage, (LPLPVOID)&pPS))
        return error;

    if (error = pPS->GetClassID(&clsid))
        goto errRtn;

    if (error = WriteClassStg(pstgSave, clsid))
        goto errRtn;

    if (error = pPS->Save(pstgSave, fSameAsLoad))
        goto errRtn;

    pPS->SaveCompleted(NULL);

errRtn:
    pPS->Release();
    return error;
}


//+-------------------------------------------------------------------------
//
//  Function:   wStuffIconOfFileEx
//
//  Synopsis:   Retrieves the icon if file [lpszFile] and stuffs it into
//              [lpUnk]'s cache
//
//  Effects:
//
//  Arguments:  [lpszFile]      -- the file where the icon is stored
//              [fAddLabel]     -- if TRUE, adds a label to the icon
//                                 presentation
//              [renderopt]     -- must be OLERENDER_DRAW or
//                                 OLERENDER_FORMAT for anything to happen
//              [cFormats]      -- the number of elements in rgFormatEtc
//              [rgFormatEtc]   -- array of rendering formats, aspect must be
//                                 DVASPECT_ICON and the clipboard format
//                                 must be NULL or CF_METAFILE for anything
//                                 to happen
//              [lpUnk]         -- pointer to the object in which the icon
//                                 should be stuffed
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Nov-93 alexgo    32bit port
//
//  Notes:
//              REVIEW32: maybe we should support enhanced metafiles for NT
//
//--------------------------------------------------------------------------


#pragma SEG(wStuffIconOfFileEx)
INTERNAL wStuffIconOfFileEx
(
    LPCOLESTR       lpszFile,
    BOOL            fAddLabel,
    DWORD           renderopt,
    ULONG           cFormats,
    LPFORMATETC     rgFormatEtc,
    LPUNKNOWN       lpUnk
)
{
    VDATEHEAP();

    IOleCache FAR*  lpOleCache;
    HRESULT         error;
    BOOL            fFound = FALSE;
    FORMATETC       foretc;
    STGMEDIUM       stgmed;

    if (renderopt == OLERENDER_NONE || renderopt == OLERENDER_ASIS)
        return NOERROR;

    if (rgFormatEtc == NULL)
        return NOERROR; // in this case we default to DVASPECT_CONTENT

    for (ULONG i=0; i<cFormats; i++)
    {
        if ((rgFormatEtc[i].dwAspect == DVASPECT_ICON) &&
            (rgFormatEtc[i].cfFormat == NULL ||
             rgFormatEtc[i].cfFormat == CF_METAFILEPICT))
        {
           foretc = rgFormatEtc[i];
           fFound = TRUE;
        }
    }

    if (!fFound)
        return NOERROR;

    foretc.cfFormat = CF_METAFILEPICT;
    foretc.tymed = TYMED_MFPICT;

    if ((error = lpUnk->QueryInterface(IID_IOleCache,
        (LPLPVOID) &lpOleCache)) != NOERROR)
        return error;

    stgmed.tymed = TYMED_MFPICT;
    stgmed.pUnkForRelease = NULL;

    // get icon data of file, from registration database
    if (!(stgmed.hGlobal = OleGetIconOfFile((LPOLESTR) lpszFile,
        fAddLabel))) {
        error = ResultFromScode(E_OUTOFMEMORY);
        goto errRtn;
    }

    // take ownership of the data
    if ((error = lpOleCache->SetData(&foretc, &stgmed, TRUE)) != NOERROR)
        ReleaseStgMedium(&stgmed);

errRtn:
    lpOleCache->Release();
    return error;

}


//+-------------------------------------------------------------------------
//
//  Function:   wNeedToPackage
//
//  Synopsis:   Determines whether or not a given CLSID should be
//              packaged.
//
//  Effects:
//
//  Arguments:  [rclsid]        -- the class ID
//
//  Requires:
//
//  Returns:    BOOL
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  Looks for the reg key PackageOnFileDrop, or if it's a
//              Word document, or if it is insertable, or if it's an OLE1
//              class
//
//  History:    dd-mmm-yy Author    Comment
//              02-Nov-93 alexgo    32bit port
//              03-Jun-94 AlexT     Just check for Insertable key (instead
//                                    of requiring a value)
//
//  Notes:
//--------------------------------------------------------------------------



INTERNAL_(BOOL) wNeedToPackage(REFCLSID rclsid)
{
    VDATEHEAP();

    HKEY    hkeyClsid;
    HKEY    hkeyTmp;
    HKEY    hkeyTmp2;
    BOOL    fPackage = FALSE;
    LPOLESTR        lpszProgID;
    DWORD   dw;
    LONG    cbValue = sizeof(dw);
    LONG    lRet;
    CLSID       clsidNew;

    if (NOERROR != OleGetAutoConvert (rclsid, &clsidNew))
    {
        if (NOERROR != CoGetTreatAsClass (rclsid, &clsidNew))
        {
                clsidNew = rclsid;
        }
    }

    if (CoOpenClassKey(clsidNew, FALSE, &hkeyClsid) != NOERROR)
        return TRUE;    // NON-OLE file, package it

    if (ProgIDFromCLSID(clsidNew, &lpszProgID) == NOERROR) {
        // see whether we can open this key

        dw = (DWORD) RegOpenKey(HKEY_CLASSES_ROOT, lpszProgID,
            &hkeyTmp);

        PubMemFree(lpszProgID);

        if (dw == ERROR_SUCCESS) {
            // This is definitely a OLE insertable file.
            lRet = RegOpenKey(hkeyTmp,
                     OLESTR("PackageOnFileDrop"),
                     &hkeyTmp2);
            // Check whether we need to package this file
            if (ERROR_SUCCESS == lRet)
            {
              RegCloseKey(hkeyTmp2);
              fPackage = TRUE;
            }
            else if (IsEqualCLSID(clsidNew, CLSID_WordDocument))
            {
            // Hack to make sure Word documents are always
            // Packaged on file drop.  We write the key here
            // so that we can say that a file is Packaged if
            // and only if its ProgID has the "PackageOnFileDrop"
            // key.
                RegSetValue (hkeyTmp,
                    OLESTR("PackageOnFileDrop"),
                    REG_SZ, (LPOLESTR)NULL, 0);
                fPackage = TRUE;
            }

            RegCloseKey(hkeyTmp);

            if (fPackage) {
                RegCloseKey(hkeyClsid);
                return TRUE;
            }
        }
    }

    // There is no "PackageOnFileDrop" key defined.

    // See whether this is an "Insertable" class by checking for the
    // existence of the Insertable key - we don't require a value

    lRet = RegOpenKey(hkeyClsid, OLESTR("Insertable"), &hkeyTmp);

    if (ERROR_SUCCESS == lRet)
    {
      //  Insertable key exists - close it and return
      RegCloseKey(hkeyTmp);
      goto errRtn;
    }

    //
    // See whether this is a "Ole1Class" class by opening the
    // registry key Ole1Class. We don't require a value
    //
    cbValue = sizeof(dw);
    lRet = RegOpenKey(hkeyClsid,OLESTR("Ole1Class"),&hkeyTmp);
    if (ERROR_SUCCESS == lRet)
    {
      RegCloseKey(hkeyTmp);
      goto errRtn;
    }
    else
    {
      fPackage = TRUE;
    }



errRtn:
    RegCloseKey(hkeyClsid);
    return fPackage;
}

//+-------------------------------------------------------------------------
//
//  Function:   wDoUpdate
//
//  Synopsis:   calls IOleObject->Update() on the given object, internal
//              function
//
//  Effects:
//
//  Arguments:  [lpUnkown]      -- the object to update
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(wDoUpdate)
INTERNAL  wDoUpdate(IUnknown FAR* lpUnknown)
{
    VDATEHEAP();

    HRESULT                 error = NOERROR;
    IOleObject FAR*         lpOle;

    if (lpUnknown->QueryInterface (IID_IOleObject, (LPLPVOID)&lpOle)
        == NOERROR) {
        error = lpOle->Update();
        lpOle->Release();
    }

    return error;
}




//+-------------------------------------------------------------------------
//
//  Function:   wBindIfRunning
//
//  Synopsis:   calls IOleLink->BindIfRunning() on the given object
//
//  Effects:
//
//  Arguments:  [lpUnk]         -- the object
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


INTERNAL_(void) wBindIfRunning(LPUNKNOWN lpUnk)
{
    VDATEHEAP();

    IOleLink FAR* lpLink;

    if (lpUnk->QueryInterface (IID_IOleLink, (LPLPVOID)&lpLink)
        == NOERROR)
    {
        lpLink->BindIfRunning();
        lpLink->Release();
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   wQueryUseCustomLink
//
//  Synopsis:   look at the registry and see if the class ID has a custom
//              link regisetered
//
//  Effects:
//
//  Arguments:  [rclsid]        -- the class ID in question
//
//  Requires:
//
//  Returns:    BOOL
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Nov-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------


INTERNAL_(BOOL) wQueryUseCustomLink(REFCLSID rclsid)
{
    VDATEHEAP();

    // see whether it has Custom Link implementation
    HKEY    hkeyClsid;
    HKEY    hkeyTmp;
    BOOL    bUseCustomLink = FALSE;

    if (SUCCEEDED(CoOpenClassKey(rclsid, FALSE, &hkeyClsid)))
    {
        DWORD   dw;
        dw = RegOpenKey(hkeyClsid,OLESTR("UseCustomLink"),&hkeyTmp);

        if (ERROR_SUCCESS == dw)
        {
          RegCloseKey(hkeyTmp);
          bUseCustomLink = TRUE;
        }

        RegCloseKey(hkeyClsid);
    }

    return bUseCustomLink;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ole232\base\sources.inc ===
!IF 0

Copyright (c) 1998  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

TARGETNAME=   base
TARGETPATH=   obj
TARGETTYPE=   LIBRARY

INCLUDES=     ..\..\..\common\$(DEST_TREE);..\..\..\ih;..\..\inc

SOURCES=      \
              ..\privstm.cpp  \
              ..\api.cpp      \
              ..\create.cpp   \
              ..\lockbyte.cpp \
              ..\memstm.cpp   \
              ..\ole2.cpp

LINKLIBS=     ..\..\common\daytona\$(O)\common.lib
UMTYPE=       windows

!include ..\..\precomp2.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\ole232\base\memstm.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       memstm.cpp
//
//  Contents:   Implementations of IStream and ILockBytes on memory
//              (versus the file system)
//
//  Classes:    CMemStm
//              CMemBytes
//              CMarshalMemStm
//              CMarshalMemBytes
//
//  Functions:  CreateMemStm
//              CloneMemStm
//              ReleaseMemStm
//              CreateStreamOnHGlobal
//              GetHGlobalFromStream
//              CMemStmUnMarshal
//              CMemBytesUnMarshall
//
//  History:    dd-mmm-yy Author    Comment
//              31-Jan-95 t-ScottH  added Dump methods to CMemStm and CMemBytes
//                                  (_DEBUG only)
//                                  added DumpCMemStm and CMemBytes APIs
//              04-Nov-94 ricksa    Made CMemStm class multithread safe.
//              24-Jan-94 alexgo    first pass at converting to Cairo-style
//                                  memory allocation
//              11-Jan-94 alexgo    added VDATEHEAP macros to every function &
//                                  method, fixed compile warnings, removed
//                                  custom marshalling code.  Memory streams
//                                  and ILockBytes now use standard
//                                  marshalling.
//              16-Dec-93 alexgo    fixed memory reference bugs (bad pointer)
//              02-Dec-93 alexgo    32bit port, implement CMemStm::CopyTo
//              11/22/93 - ChrisWe - replace overloaded ==, != with
//                      IsEqualIID and IsEqualCLSID
//
//  Notes:
//
//--------------------------------------------------------------------------

#include <le2int.h>
#pragma SEG(memstm)

#include <nturtl.h>
#include "memstm.h"
#include "sem.hxx"
#include <reterr.h>

#ifdef _DEBUG
#include "dbgdump.h"
#endif // _DEBUG

NAME_SEG(CMemStm)
ASSERTDATA


// CRefMutexSem implementation
//
// Instances of this class are shared among all CMemStm objects 
// cloned from a common CMemStm object, as well as their parent.
//
// This guarantees synchronization between all instances of CMemStm that share common data

CRefMutexSem::CRefMutexSem() : m_lRefs(1)
{
    // Note: we begin life with one reference
}

CRefMutexSem* CRefMutexSem::CreateInstance()
{
    CRefMutexSem* prefMutexSem = NULL;
    prefMutexSem = new CRefMutexSem();
    if (prefMutexSem != NULL)
    {
    	if (prefMutexSem->FInit() == FALSE)
    	{
    	    ASSERT(FALSE);
    	    delete prefMutexSem;
    	    prefMutexSem = NULL;
    	}
    }
    return prefMutexSem;
}

BOOL CRefMutexSem::FInit()
{
    return m_mxs.FInit();	
}

ULONG CRefMutexSem::AddRef()
{
    return InterlockedIncrement (&m_lRefs);    
}

ULONG CRefMutexSem::Release()
{
    LONG lRefs = InterlockedDecrement (&m_lRefs);
    if (lRefs == 0)
    {
        delete this;
    }

    return lRefs;
}

void CRefMutexSem::RequestCS()
{
    m_mxs.Request();
}

void CRefMutexSem::ReleaseCS()
{
    m_mxs.Release();
}   

const CMutexSem2* CRefMutexSem::GetMutexSem()
{
    return &m_mxs;
}


inline CRefMutexAutoLock::CRefMutexAutoLock (CRefMutexSem* pmxs)
{
    Win4Assert (pmxs != NULL);

    m_pmxs = pmxs;
    m_pmxs->RequestCS();

    END_CONSTRUCTION (CRefMutexAutoLock);
}

inline CRefMutexAutoLock::~CRefMutexAutoLock()
{
    m_pmxs->ReleaseCS();
}
    
// Shared memory IStream implementation
//

//+-------------------------------------------------------------------------
//
//  Member:     CMemStm::CMemStm
//
//  Synopsis:   constructor for memory stream
//
//  Arguments:  none
//
//  History:    20-Dec-94   Rickhi      moved from h file
//
//--------------------------------------------------------------------------
CMemStm::CMemStm()
{
    m_hMem = NULL;
    m_pData = NULL;
    m_pos = 0;
    m_refs = 0;
    m_pmxs = NULL;
}

CMemStm::~CMemStm()
{
    if (m_pmxs != NULL)
    {
        m_pmxs->Release();
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     CMemStm::QueryInterface
//
//  Synopsis:   retrieves the requested interface
//
//  Effects:
//
//  Arguments:  [iidInterface]  -- the requested interface ID
//              [ppvObj]        -- where to put the interface pointer
//
//  Requires:
//
//  Returns:    NOERROR, E_OUTOFMEMORY, E_NOINTERFACE
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IStream
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              04-Nov-94 ricksa    Modified for multithreading
//              11-Jan-94 alexgo    removed QI for IMarshal so that
//                                  the standard marshaller is used.
//                                  This is fix marshalling across
//                                  process on 32bit platforms.
//              02-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CMemStm_QueryInterface)
STDMETHODIMP CMemStm::QueryInterface(REFIID iidInterface,
        void FAR* FAR* ppvObj)
{
        VDATEHEAP();

        HRESULT         error;

        VDATEPTROUT( ppvObj, LPVOID );
        *ppvObj = NULL;
        VDATEIID( iidInterface );

        // Two interfaces supported: IUnknown, IStream

        if (m_pData != NULL && (IsEqualIID(iidInterface, IID_IStream) ||
                IsEqualIID(iidInterface, IID_ISequentialStream) ||
                IsEqualIID(iidInterface, IID_IUnknown)))
        {

                AddRef();   // A pointer to this object is returned
                *ppvObj = this;
                error = NOERROR;
        }
#ifndef WIN32
        else if (IsEqualIID(iidInterface, IID_IMarshal))
        {
                *ppvObj = (LPVOID) CMarshalMemStm::Create(this);

                if (*ppvObj != NULL)
                {
                        error = NOERROR;
                }
                else
                {
                        error = ResultFromScode(E_OUTOFMEMORY);
                }
        }
#endif
        else
        {                 // Not accessible or unsupported interface
                *ppvObj = NULL;
                error = ResultFromScode(E_NOINTERFACE);
        }

        return error;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMemStm::AddRef
//
//  Synopsis:   increments the reference count
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    ULONG -- the new reference count
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IStream
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Dec-93 alexgo    32bit port
//              04-Nov-94 ricksa    Modified for multithreading
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CMemStm_AddRef)
STDMETHODIMP_(ULONG) CMemStm::AddRef(void)
{
        VDATEHEAP();

        return InterlockedIncrement((LONG *) &m_refs);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMemStm::Release
//
//  Synopsis:   decrements the reference count
//
//  Effects:    deletes the object when ref count == 0
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    ULONG -- the new ref count
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IStream
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              04-Nov-94 ricksa    Modified for multithreading
//              16-Dec-93 alexgo    added GlobalUnlock of the MEMSTM handle
//              02-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CMemStm_Release)
STDMETHODIMP_(ULONG) CMemStm::Release(void)
{
        VDATEHEAP();

        // The reason for this here is that there is a race when releasing
        // this object. If two threads are trying to release this object
        // at the same time, there is a case where the first one dec's
        // the ref count & then loses the processor to the second thread.
        // This second thread decrements the reference count to 0 and frees
        // the memory. The first thread can no longer safely examine the
        // internal state of the object.
        ULONG ulResult = InterlockedDecrement((LONG *) &m_refs);

        if (ulResult == 0)
        {
                // this MEMSTM handle was GlobalLock'ed in ::Create
                // we unlock it here, as we no longer need it.
                GlobalUnlock(m_hMem);

                ReleaseMemStm(&m_hMem);

                delete this;
        }

        return ulResult;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMemStm::Read
//
//  Synopsis:   reads [cb] bytes from the stream
//
//  Effects:
//
//  Arguments:  [pb]            -- where to put the data read
//              [cb]            -- the number of bytes to read
//              [pcbRead]       -- where to put the actual number of bytes
//                                 read
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IStream
//
//  Algorithm:  uses xmemcpy
//
//  History:    dd-mmm-yy Author    Comment
//              04-Nov-94 ricksa    Modified for multithreading
//              02-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CMemStm_Read)
STDMETHODIMP CMemStm::Read(void HUGEP* pb, ULONG cb, ULONG FAR* pcbRead)
{
        VDATEHEAP();

        HRESULT         error = NOERROR;
        ULONG           cbRead = cb;

        if(cb)
        {
            VDATEPTROUT( pb, char);
        }

        // Single thread
        CRefMutexAutoLock lck(m_pmxs);

        if (pcbRead)
        {
                VDATEPTROUT( pcbRead, ULONG );
                *pcbRead = 0L;
        }

	// cbRead + m_pos could cause roll-over.
        if ( ( (cbRead + m_pos) > m_pData->cb) || ( (cbRead + m_pos) < m_pos) )
        {
                // Caller is asking for more bytes than we have left
                if(m_pData->cb > m_pos)
                    cbRead = m_pData->cb - m_pos;
                else
                    cbRead = 0;
        }

        if (cbRead > 0)
        {
                Assert (m_pData->hGlobal);
                BYTE HUGEP* pGlobal = (BYTE HUGEP *)GlobalLock(
                        m_pData->hGlobal);
                if (NULL==pGlobal)
                {
                        LEERROR(1, "GlobalLock Failed!");

                        return ResultFromScode (STG_E_READFAULT);
                }
                // overlap is currently considered a bug (see the discussion
                // on the Write method
                _xmemcpy(pb, pGlobal + m_pos, cbRead);
                GlobalUnlock (m_pData->hGlobal);
                m_pos += cbRead;
        }

        if (pcbRead != NULL)
        {
                *pcbRead = cbRead;
        }

        return error;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMemStm::Write
//
//  Synopsis:   Writes [cb] bytes into the stream
//
//  Effects:
//
//  Arguments:  [pb]            -- the bytes to write
//              [cb]            -- the number of bytes to write
//              [pcbWritten]    -- where to put the number of bytes written
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IStream
//
//  Algorithm:  resizes the internal buffer (if needed), then uses xmemcpy
//
//  History:    dd-mmm-yy Author    Comment
//              04-Nov-94 ricksa    Modified for multithreading
//              02-Dec-93 alexgo    32bit port, fixed bug dealing with
//                                  0-byte sized memory
//              06-Dec-93 alexgo    handle overlap case.
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CMemStm_Write)
STDMETHODIMP CMemStm::Write(void const HUGEP* pb, ULONG cb,
        ULONG FAR* pcbWritten)
{
        VDATEHEAP();

        HRESULT                 error = NOERROR;
        ULONG                   cbWritten = cb;
        ULARGE_INTEGER          ularge_integer;
        BYTE HUGEP*             pGlobal;

        if(cb)
        {
            VDATEPTRIN( pb , char );
        }

        // Single thread
        CRefMutexAutoLock lck(m_pmxs);

        if (pcbWritten != NULL)
        {
                *pcbWritten = 0;
        }

        if (cbWritten + m_pos > m_pData->cb)
        {
                ULISet32( ularge_integer, m_pos+cbWritten );
                error = SetSize(ularge_integer);
                if (error != NOERROR)
                {
                        goto Exit;
                }
        }

        // we don't write anything if 0 bytes are asked for for two
        // reasons: 1. optimization, 2. m_pData->hGlobal could be a
        // handle to a zero-byte memory block, in which case GlobalLock
        // will fail.

        if( cbWritten > 0 )
        {
                pGlobal = (BYTE HUGEP *)GlobalLock (m_pData->hGlobal);
                if (NULL==pGlobal)
                {
                        LEERROR(1, "GlobalLock Failed!");

                        return ResultFromScode (STG_E_WRITEFAULT);
                }

                // we use memmove here instead of memcpy to handle the
                // overlap case.  Recall that the app originally gave
                // use the memory for the memstm.  He could (either through
                // a CopyTo or through really strange code), be giving us
                // this region to read from, so we have to handle the overlapp
                // case.  The same argument also applies for Read, but for
                // now, we'll consider overlap on Read a bug.
                _xmemmove(pGlobal + m_pos, pb, cbWritten);
                GlobalUnlock (m_pData->hGlobal);

                m_pos += cbWritten;
        }

        if (pcbWritten != NULL)
        {
                *pcbWritten = cbWritten;
        }

Exit:

        return error;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMemStm::Seek
//
//  Synopsis:   Moves the internal seek pointer
//
//  Effects:
//
//  Arguments:  [dlibMoveIN]    -- the amount to move by
//              [dwOrigin]      -- flags to control whether seeking is
//                                 relative to the current postion or
//                                 the begging/end.
//              [plibNewPosition]       -- where to put the new position
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IStream
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              04-Nov-94 ricksa    Modified for multithreading
//              02-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CMemStm_Seek)
STDMETHODIMP CMemStm::Seek(LARGE_INTEGER dlibMoveIN, DWORD dwOrigin,
        ULARGE_INTEGER FAR* plibNewPosition)
{
        VDATEHEAP();

        HRESULT                 error  = NOERROR;
        LONG                    dlibMove = dlibMoveIN.LowPart ;
        ULONG                   cbNewPos = dlibMove;

        // Single thread
        CRefMutexAutoLock lck(m_pmxs);

        if (plibNewPosition != NULL)
        {
                VDATEPTROUT( plibNewPosition, ULONG );
                ULISet32(*plibNewPosition, m_pos);
        }

        switch(dwOrigin)
        {

        case STREAM_SEEK_SET:
                if (dlibMove >= 0)
                {
                        m_pos = dlibMove;
                }
                else
                {
                        error = ResultFromScode(STG_E_SEEKERROR);
                }

                break;

        case STREAM_SEEK_CUR:
                if (!(dlibMove < 0 && ((ULONG) -dlibMove) > m_pos))
                {
                        m_pos += dlibMove;
                }
                else
                {
                        error = ResultFromScode(STG_E_SEEKERROR);
                }
                break;

        case STREAM_SEEK_END:
                if (!(dlibMove < 0 && ((ULONG) -dlibMove) > m_pData->cb))
                {
                        m_pos = m_pData->cb + dlibMove;
                }
                else
                {
                        error = ResultFromScode(STG_E_SEEKERROR);
                }
                break;

        default:
                error = ResultFromScode(STG_E_SEEKERROR);
        }

        if (plibNewPosition != NULL)
        {
                ULISet32(*plibNewPosition, m_pos);
        }

        return error;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMemStm::SetSize
//
//  Synopsis:   Sets the size of our memory
//
//  Effects:
//
//  Arguments:  [cb]    -- the new size
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IStream
//
//  Algorithm:  calls GlobalRealloc
//
//  History:    dd-mmm-yy Author    Comment
//              04-Nov-94 ricksa    Modified for multithreading
//              02-Dec-93 alexgo    32bit port, added assert
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CMemStm_SetSize)
STDMETHODIMP CMemStm::SetSize(ULARGE_INTEGER cb)
{
        VDATEHEAP();

        HANDLE hMemNew;

        // Single thread
        CRefMutexAutoLock lck(m_pmxs);

        // make sure we aren't in overflow conditions.

        AssertSz(cb.HighPart == 0,
                "MemStream::More than 2^32 bytes asked for");

        if (m_pData->cb == cb.LowPart)
        {
                return NOERROR;
        }

        hMemNew = GlobalReAlloc(m_pData->hGlobal, max (cb.LowPart,1),
                        GMEM_SHARE | GMEM_MOVEABLE);

        if (hMemNew == NULL)
        {
                return ResultFromScode (E_OUTOFMEMORY);
        }

        m_pData->hGlobal = hMemNew;
        m_pData->cb = cb.LowPart;

        return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMemStm::CopyTo
//
//  Synopsis:   Copies data from [this] stream to [pstm]
//
//  Effects:
//
//  Arguments:  [pstm]          -- the stream to copy to
//              [cb]            -- the number of bytes to copy
//              [pcbRead]       -- where to return the number of bytes read
//              [pcbWritten]    -- where to return the number of bytes written
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IStream
//
//  Algorithm:  does an IStream->Write to the given stream
//
//  History:    dd-mmm-yy Author    Comment
//              04-Nov-94 ricksa    Modified for multithreading
//              03-Dec-93 alexgo    original implementation
//
//  Notes:      This implementation assumes that the address space
//              is not greater than ULARGE_INTEGER.LowPart (which is
//              for for 32bit operating systems).  64bit NT may need
//              to revisit this code.
//
//--------------------------------------------------------------------------

#pragma SEG(CMemStm_CopyTo)
STDMETHODIMP CMemStm::CopyTo(IStream FAR *pstm, ULARGE_INTEGER cb,
        ULARGE_INTEGER FAR * pcbRead, ULARGE_INTEGER FAR * pcbWritten)
{
        VDATEHEAP();

        ULONG   cbRead          = cb.LowPart;
        ULONG   cbWritten       = 0;
        HRESULT hresult         = NOERROR;

        // pstm cannot be NULL

        VDATEPTRIN(pstm, LPSTREAM);

        // Single thread
        CRefMutexAutoLock lck(m_pmxs);

        // the spec says that if cb is it's maximum value (all bits set,
        // since it's unsigned), then we will simply read the copy of
        // this stream

        if ( ~(cb.LowPart) == 0 && ~(cb.HighPart) == 0 )
        {
                cbRead = m_pData->cb - m_pos;
        }
        else if ( cb.HighPart > 0 )
        {
                // we assume that our memory stream cannot
                // be large enough to accomodate very large (>32bit)
                // copy to requests.  Since this is probably an error
                // on the caller's part, we assert.

                AssertSz(0, "WARNING: CopyTo request exceeds 32 bits");

                // set the Read value to what's left, so that "Ignore"ing
                // the assert works properly.

                cbRead = m_pData->cb - m_pos;
        }
        else if ( cbRead + m_pos > m_pData->cb )
        {
                // more bytes were requested to read than we had left.
                // cbRead is set to the amount remaining.

                cbRead = m_pData->cb - m_pos;
        }

        // now write the data to the stream

        if ( cbRead > 0 )
        {
                BYTE HUGEP* pGlobal = (BYTE HUGEP *)GlobalLock(
                                m_pData->hGlobal);

                if( pGlobal == NULL )
                {
                        LEERROR(1, "GlobalLock failed");

                        return ResultFromScode(STG_E_INSUFFICIENTMEMORY);
                }

                hresult = pstm->Write(pGlobal + m_pos, cbRead, &cbWritten);

                // in the error case, the spec says that the return values
                // may be meaningless, so we do not need to do any special
                // error handling here

                GlobalUnlock(m_pData->hGlobal);
        }

        // increment our seek pointer and set the out parameters

        m_pos += cbRead;

        if( pcbRead )
        {
                ULISet32(*pcbRead, cbRead);
        }

        if( pcbWritten )
        {
                ULISet32(*pcbWritten, cbWritten);
        }

        return hresult;

}

//+-------------------------------------------------------------------------
//
//  Member:     CMemStm::Commit
//
//  Synopsis:   Does nothing, no transactions available on memory streams
//
//  Effects:
//
//  Arguments:  [grfCommitFlags]
//
//  Requires:
//
//  Returns:    NOERROR
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IStream
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              03-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CMemStm_Commit)
STDMETHODIMP CMemStm::Commit(DWORD grfCommitFlags)
{
        VDATEHEAP();

        return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMemStm::Revert
//
//  Synopsis:   does nothing, as no transactions are supported on memory
//              streams
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    NOERROR
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IStream
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              03-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CMemStm_Revert)
STDMETHODIMP CMemStm::Revert(void)
{
        VDATEHEAP();

        return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMemStm::LockRegion
//
//  Synopsis:   not supported in OLE2.01
//
//  Effects:
//
//  Arguments:  [libOffset]
//              [cb]
//              [dwLockType]
//
//  Requires:
//
//  Returns:    STG_E_INVALIDFUNCTION
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IStream
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              03-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CMemStm_LockRegion)
STDMETHODIMP CMemStm::LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb,
        DWORD dwLockType)
{
        VDATEHEAP();

        return ResultFromScode(STG_E_INVALIDFUNCTION);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMemStm::UnlockRegion
//
//  Synopsis:   not implemented for OLE2.01
//
//  Effects:
//
//  Arguments:  [libOffset]
//              [cb]
//              [dwLockType]
//
//  Requires:
//
//  Returns:    STG_E_INVALIDFUNCTION
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IStream
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              03-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CMemStm_UnlockRegion)
STDMETHODIMP CMemStm::UnlockRegion(ULARGE_INTEGER libOffset,
        ULARGE_INTEGER cb, DWORD dwLockType)
{
        VDATEHEAP();

        return ResultFromScode(STG_E_INVALIDFUNCTION);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMemStm::Stat
//
//  Synopsis:   Returns info about this stream
//
//  Effects:
//
//  Arguments:  [pstatstg]      -- the STATSTG to fill with info
//              [statflag]      -- status flags, unused
//
//  Requires:
//
//  Returns:    NOERROR, E_INVALIDARG
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IStream
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              03-Dec-93 alexgo    32bit port
//              01-Jun-94 AlexT     Set type correctly
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CMemStm_Stat)
STDMETHODIMP CMemStm::Stat(STATSTG FAR *pstatstg, DWORD statflag)
{
        VDATEHEAP();

        VDATEPTROUT( pstatstg, STATSTG );

        memset ( pstatstg, 0, sizeof(STATSTG) );

        pstatstg->type                  = STGTY_STREAM;
        pstatstg->cbSize.LowPart        = m_pData->cb;

        return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMemStm::Clone
//
//  Synopsis:   creates a new instance of this stream pointing to the
//              same data at the same position (same seek pointer)
//
//  Effects:
//
//  Arguments:  [ppstm]         -- where to put the new CMemStm pointer
//
//  Requires:
//
//  Returns:    NOERROR, E_OUTOFMEMORY
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IStream
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              03-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CMemStm_Clone)
STDMETHODIMP CMemStm::Clone(IStream FAR * FAR *ppstm)
{
        VDATEHEAP();

        CMemStm FAR*    pCMemStm;

        VDATEPTROUT (ppstm, LPSTREAM);

        *ppstm = pCMemStm = CMemStm::Create(m_hMem, m_pmxs);

        if (pCMemStm == NULL)
        {
                return ResultFromScode(E_OUTOFMEMORY);
        }

        pCMemStm->m_pos = m_pos;

        return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMemStm::Create
//
//  Synopsis:   Creates a new CMemStm.  [hMem] must be a handle to a MEMSTM
//              block.
//
//  Effects:
//
//  Arguments:  [hMem]  -- handle to a MEMSTM block
//
//  Requires:
//
//  Returns:    CMemStm *
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              15-Dec-93 alexgo    fixed memory access bug
//              03-Dec-93 alexgo    32bit port
//              20-Sep-2000 mfeingol Added Mutex inheritance
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CMemStm_Create)
STDSTATICIMP_(CMemStm FAR*) CMemStm::Create(HANDLE hMem, CRefMutexSem* pmxs)
{
        VDATEHEAP();

        CMemStm FAR* pCMemStm = NULL;
        struct MEMSTM FAR* pData;

        pData = (MEMSTM FAR*) GlobalLock(hMem);

        if (pData != NULL)
        {
            pCMemStm = new CMemStm;

            if (pCMemStm != NULL)
            {
                // Initialize CMemStm
                pCMemStm->m_hMem = hMem;
                InterlockedIncrement ((LPLONG) &(pCMemStm->m_pData = pData)->cRef); // AddRefMemStm
                pCMemStm->m_refs = 1;
                pCMemStm->m_dwSig = STREAM_SIG;

                if (pmxs != NULL)
                {
                    // Addref the input
                    pmxs->AddRef();
                }
                else
                {
                    // Create a new mutex (implicit addref)
                    pmxs = CRefMutexSem::CreateInstance();
                }

                if (pmxs != NULL)
                {
                    // Give the CMemStm a mutex
                    pCMemStm->m_pmxs = pmxs;
                }
                else
                {
                    // uh-oh, low on memory
                    delete pCMemStm;
                    pCMemStm = NULL;

                    GlobalUnlock(hMem);
                }
            }
            else
            {
                // uh-oh, low on memory
                GlobalUnlock(hMem);
            }
        }

        // we do *not* unlock the memory now, the memstm structure should
        // be locked for the lifetime of any CMemStm's that refer to it.
        // when the CMemStm is destroyed, we will release our lock on
        // hMem.

        return pCMemStm;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMemStm::Dump, public (_DEBUG only)
//
//  Synopsis:   return a string containing the contents of the data members
//
//  Effects:
//
//  Arguments:  [ppszDump]      - an out pointer to a null terminated character array
//              [ulFlag]        - flag determining prefix of all newlines of the
//                                out character array (default is 0 - no prefix)
//              [nIndentLevel]  - will add a indent prefix after the other prefix
//                                for ALL newlines (including those with no prefix)
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:   [ppsz]  - argument
//
//  Derivation:
//
//  Algorithm:  use dbgstream to create a string containing information on the
//              content of data structures
//
//  History:    dd-mmm-yy Author    Comment
//              20-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

HRESULT CMemStm::Dump(char **ppszDump, ULONG ulFlag, int nIndentLevel)
{
    int i;
    char *pszPrefix;
    char *pszMEMSTM;
    char *pszCMutexSem;
    dbgstream dstrPrefix;
    dbgstream dstrDump(400);

    // determine prefix of newlines
    if ( ulFlag & DEB_VERBOSE )
    {
        dstrPrefix << this << " _VB ";
    }

    // determine indentation prefix for all newlines
    for (i = 0; i < nIndentLevel; i++)
    {
        dstrPrefix << DUMPTAB;
    }

    pszPrefix = dstrPrefix.str();

    // put data members in stream
    dstrDump << pszPrefix << "Impl. Signature   = " << m_dwSig      << endl;

    dstrDump << pszPrefix << "No. of References = " << m_refs       << endl;

    dstrDump << pszPrefix << "Seek pointer      = " << m_pos        << endl;

    dstrDump << pszPrefix << "Memory handle     = " << m_hMem       << endl;

    if (m_pData != NULL)
    {
        pszMEMSTM = DumpMEMSTM(m_pData, ulFlag, nIndentLevel + 1);
        dstrDump << pszPrefix << "MEMSTM:" << endl;
        dstrDump << pszMEMSTM;
        CoTaskMemFree(pszMEMSTM);
    }
    else
    {
        dstrDump << pszPrefix << "MEMSTM            = " << m_pData      << endl;
    }

    pszCMutexSem = DumpCMutexSem ((CMutexSem2*) m_pmxs->GetMutexSem());
    dstrDump << pszPrefix << "Mutex             = " << pszCMutexSem << endl;
    CoTaskMemFree(pszCMutexSem);

    // cleanup and provide pointer to character array
    *ppszDump = dstrDump.str();

    if (*ppszDump == NULL)
    {
        *ppszDump = UtDupStringA(szDumpErrorMessage);
    }

    CoTaskMemFree(pszPrefix);

    return NOERROR;
}

#endif // _DEBUG

//+-------------------------------------------------------------------------
//
//  Function:   DumpCMemStm, public (_DEBUG only)
//
//  Synopsis:   calls the CMemStm::Dump method, takes care of errors and
//              returns the zero terminated string
//
//  Effects:
//
//  Arguments:  [pMS]           - pointer to CMemStm
//              [ulFlag]        - flag determining prefix of all newlines of the
//                                out character array (default is 0 - no prefix)
//              [nIndentLevel]  - will add a indent prefix after the other prefix
//                                for ALL newlines (including those with no prefix)
//
//  Requires:
//
//  Returns:    character array of structure dump or error (null terminated)
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              20-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

char *DumpCMemStm(CMemStm *pMS, ULONG ulFlag, int nIndentLevel)
{
    HRESULT hresult;
    char *pszDump;

    if (pMS == NULL)
    {
        return UtDupStringA(szDumpBadPtr);
    }

    hresult = pMS->Dump(&pszDump, ulFlag, nIndentLevel);

    if (hresult != NOERROR)
    {
        CoTaskMemFree(pszDump);

        return DumpHRESULT(hresult);
    }

    return pszDump;
}

#endif // _DEBUG

//+-------------------------------------------------------------------------
//
//  Function:   CreateMemStm
//
//  Synopsis:   Allocates memory and creates a CMemStm for it.
//
//  Effects:
//
//  Arguments:  [cb]    -- the number of bytes to allocate
//              [phMem] -- where to put a handle to the MEMSTM structure
//
//  Requires:
//
//  Returns:    LPSTREAM to the CMemStream
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              03-Dec-93 alexgo    32bit port
//
//  Notes:      phMem must be free'd with ReleaseMemStm (because of ref
//              counting and the nested handle)
//
//--------------------------------------------------------------------------

#pragma SEG(CreateMemStm)
STDAPI_(LPSTREAM) CreateMemStm(DWORD cb, LPHANDLE phMem)
{
        VDATEHEAP();

        HANDLE          h;
        LPSTREAM        pstm = NULL;

        if (phMem)
        {
                *phMem = NULL;
        }

        h = GlobalAlloc (GMEM_SHARE | GMEM_MOVEABLE, cb);
        if (NULL==h)
        {
                return NULL;
        }

        if (CreateStreamOnHGlobal (h, TRUE, &pstm) != NOERROR)
        {
                GlobalFree(h);	// COM+ 22886
                return NULL;
        }
        if (phMem)
        {
                // retrieve handle from just-created CMemStm
                *phMem = ((CMemStm FAR*)pstm)->m_hMem;

                // use pointer to bump ref count
                Assert(((CMemStm FAR*)pstm)->m_pData != NULL);
                InterlockedIncrement ((LPLONG) &((CMemStm FAR*)pstm)->m_pData->cRef);  // AddRefMemStm
        }
        return pstm;
}


//+-------------------------------------------------------------------------
//
//  Function:   CloneMemStm
//
//  Synopsis:   Clones a memory stream
//
//  Effects:
//
//  Arguments:  [hMem]  -- a handle to the MEMSTM block
//
//  Requires:
//
//  Returns:    LPSTREAM
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              05-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------
#pragma SEG(CloneMemStm)

STDAPI_(LPSTREAM) CloneMemStm(HANDLE hMem)
{
        VDATEHEAP();

        return CMemStm::Create(hMem, NULL); // Create the stream
}

//+-------------------------------------------------------------------------
//
//  Function:   ReleaseMemStm
//
//  Synopsis:   Releases the memory used by a MEMSTM structure (including
//              the nested handle)
//
//  Effects:
//
//  Arguments:  [phMem]         -- pointer the MEMSTM handle
//              [fInternalOnly] -- if TRUE, then only the actual memory
//                                 that MEMSTM refers to is freed
//                                 (not the MEMSTM structure itself)
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   sets *phMem to NULL on success
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              05-Dec-93 alexgo    32bit port and fixed bad memory access
//                                  bug
//
//  Notes:      REVIEW32:  look at taking out the second argument
//
//--------------------------------------------------------------------------

#pragma SEG(ReleaseMemStm)
STDAPI_(void) ReleaseMemStm (LPHANDLE phMem, BOOL fInternalOnly)
{
        VDATEHEAP();

        struct MEMSTM FAR*      pData;

        pData = (MEMSTM FAR*) GlobalLock(*phMem);

        // check for NULL pointer in case handle got freed already
        // decrement ref count and free if no refs left
        if (pData != NULL && InterlockedDecrement ((LPLONG) &pData->cRef) == 0)
        {
                if (pData->fDeleteOnRelease)
                {
                        Verify (0==GlobalFree (pData->hGlobal));
                }

                if (!fInternalOnly)
                {
                        GlobalUnlock(*phMem);
                        Verify (0==GlobalFree(*phMem));
                        goto End;
                }
        }

        GlobalUnlock(*phMem);
End:
        *phMem = NULL;
}

//+-------------------------------------------------------------------------
//
//  Function:   CreateStreamOnHGlobal
//
//  Synopsis:   Creates a CMemStm from the given hGlobal (if [hGlobal] is
//              NULL, we allocate a zero byte one)
//
//  Effects:
//
//  Arguments:  [hGlobal]               -- the memory
//              [fDeleteOnRelease]      -- whether the memory should be
//                                         release on delete
//              [ppstm]                 -- where to put the stream
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              11-Jan-93 alexgo    removed initialization of cbSize to -1
//                                  to fix compile warning
//              05-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CreateStreamOnHGlobal)
STDAPI CreateStreamOnHGlobal(HANDLE hGlobal, BOOL fDeleteOnRelease,
        LPSTREAM FAR* ppstm)
{
        OLETRACEIN((API_CreateStreamOnHGlobal, PARAMFMT("hGlobal= %h, fDeleteOnRelease= %B, ppstm= %p"),
                hGlobal, fDeleteOnRelease, ppstm));

        VDATEHEAP();

        HANDLE                  hMem      = NULL;
        struct MEMSTM FAR*      pData     = NULL;
        LPSTREAM                pstm      = NULL;
        DWORD                   cbSize;
        BOOL                    fAllocated = FALSE;
        HRESULT hresult;

        VDATEPTROUT_LABEL (ppstm, LPSTREAM, SafeExit, hresult);

        *ppstm = NULL;

        if (NULL==hGlobal)
        {
                hGlobal = GlobalAlloc(GMEM_SHARE | GMEM_MOVEABLE, 0);
                if (hGlobal == NULL)
                {
                        goto FreeMem;
                }
                cbSize = 0;
                fAllocated = TRUE;
        }
        else
        {
                cbSize = (ULONG) GlobalSize (hGlobal);
                // Is there a way to verify a zero-sized handle?
                // we currently do no verification for them
                if (cbSize!=0)
                {
                        // verify validity of passed-in handle
                        if (NULL==GlobalLock(hGlobal))
                        {
                                // bad handle
                                hresult = ResultFromScode (E_INVALIDARG);
                                goto SafeExit;
                        }
                        GlobalUnlock (hGlobal);
                }
        }

        hMem = GlobalAlloc (GMEM_SHARE | GMEM_MOVEABLE, sizeof (MEMSTM));
        if (hMem == NULL)
        {
                goto FreeMem;
        }

        pData = (MEMSTM FAR*) GlobalLock(hMem);

        if (pData == NULL)
        {
                GlobalUnlock(hMem);
                goto FreeMem;
        }

        pData->cRef = 0;
        pData->cb = cbSize;
        pData->fDeleteOnRelease = fDeleteOnRelease;
        pData->hGlobal = hGlobal;
        GlobalUnlock(hMem);

        pstm = CMemStm::Create(hMem, NULL);

        if (pstm == NULL)
        {
                goto FreeMem;
        }

        *ppstm = pstm;

        CALLHOOKOBJECTCREATE(S_OK,CLSID_NULL,IID_IStream,(IUnknown **)ppstm);
        hresult = NOERROR;
        goto SafeExit;

FreeMem:
        if (hGlobal && fAllocated)
        {
	        Verify(0==GlobalFree(hGlobal));
        }
        if (hMem)
        {
            Verify(0==GlobalFree(hMem));
        }

        LEERROR(1, "Out of memory!");

        hresult = ResultFromScode(E_OUTOFMEMORY);

SafeExit:

        OLETRACEOUT((API_CreateStreamOnHGlobal, hresult));

        return hresult;
}

//+-------------------------------------------------------------------------
//
//  Function:   GetHGlobalFromStream
//
//  Synopsis:   Retrieves the HGLOBAL to the memory from the given stream
//              pointer (must be a pointer to a CMemByte structure)
//
//  Effects:
//
//  Arguments:  [pstm]          -- pointer to the CMemByte
//              [phglobal]      -- where to put the hglobal
//
//  Requires:
//
//  Returns:    HRESULT (E_INVALIDARG, E_OUTOFMEMORY, NOERROR)
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              05-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(GetHGlobalFromStream)
STDAPI GetHGlobalFromStream(LPSTREAM pstm, HGLOBAL FAR* phglobal)
{
        OLETRACEIN((API_GetHGlobalFromStream, PARAMFMT("pstm= %p, phglobal= %p"),
                pstm, phglobal));

        VDATEHEAP();

        HRESULT hresult;
        CMemStm FAR* pCMemStm;
        MEMSTM FAR* pMem;

        VDATEIFACE_LABEL (pstm, errRtn, hresult);
        VDATEPTROUT_LABEL(phglobal, HANDLE, errRtn, hresult);
        CALLHOOKOBJECT(S_OK,CLSID_NULL,IID_IStream,(IUnknown **)&pstm);

        pCMemStm = (CMemStm FAR*) pstm;

        if (!IsValidReadPtrIn (&(pCMemStm->m_dwSig), sizeof(ULONG))
                || pCMemStm->m_dwSig != STREAM_SIG)
        {
                // we were passed someone else's implementation of ILockBytes
                hresult = ResultFromScode (E_INVALIDARG);
                goto errRtn;
        }

        pMem= pCMemStm->m_pData;
        if (NULL==pMem)
        {
                LEERROR(1, "Out of memory!");

                hresult = ResultFromScode (E_OUTOFMEMORY);
                goto errRtn;
        }
        Assert (pMem->cb <= GlobalSize (pMem->hGlobal));
        Verify (*phglobal = pMem->hGlobal);

        hresult = NOERROR;

errRtn:
        OLETRACEOUT((API_GetHGlobalFromStream, hresult));

        return hresult;
}


//////////////////////////////////////////////////////////////////////////
//
// Shared memory ILockBytes implementation
//

//+-------------------------------------------------------------------------
//
//  Member:     CMemBytes::QueryInterface
//
//  Synopsis:   returns the requested interface pointer
//
//  Effects:    a CMarshalMemBytes will be created if IID_IMarshal is
//              requested
//
//  Arguments:  [iidInterface]  -- the requested interface ID
//              [ppvObj]        -- where to put the interface pointer
//
//  Requires:
//
//  Returns:    NOERROR, E_OUTOFMEMORY, E_NOINTERFACE
//
//  Signals:
//
//  Modifies:
//
//  Derivation: ILockBytes
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              11-Jan-94 alexgo    removed QI for IMarshal so that
//                                  the standard marshaller will be used.
//                                  This is to enable correct operation on
//                                  32bit platforms.
//              05-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CMemBytes_QueryInterface)
STDMETHODIMP CMemBytes::QueryInterface(REFIID iidInterface,
        void FAR* FAR* ppvObj)
{
        VDATEHEAP();

        HRESULT                 error;

        VDATEPTROUT( ppvObj, LPVOID );
        *ppvObj = NULL;
        VDATEIID( iidInterface );

        if (m_pData != NULL && (IsEqualIID(iidInterface, IID_ILockBytes) ||
                IsEqualIID(iidInterface, IID_IUnknown)))
        {
                InterlockedIncrement ((LPLONG) &m_refs);   // A pointer to this object is returned
                *ppvObj = this;
                error = NOERROR;
        }

        // this is not an else if because m_pData can be NULL and we
        // allow creating a CMarshalMemBytes.  REVIEW32:  We may want
        // to remove this behavior.

#ifndef WIN32
        if (IsEqualIID(iidInterface, IID_IMarshal))
        {
                *ppvObj = (LPVOID) CMarshalMemBytes::Create(this);
                if (*ppvObj != NULL)
                {
                        error = NOERROR;
                }
                else
                {
                        error = ReportResult(0, E_OUTOFMEMORY, 0, 0);
                }
        }
#endif
        else
        {
                *ppvObj = NULL;
                error = ResultFromScode(E_NOINTERFACE);
        }

        return error;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMemBytes::AddRef
//
//  Synopsis:   Incrememts the reference count
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    ULONG -- the new reference count
//
//  Signals:
//
//  Modifies:
//
//  Derivation: ILockBytes
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              05-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CMemBytes::AddRef(void)
{
        VDATEHEAP();

        return InterlockedIncrement ((LPLONG) &m_refs);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMemBytes::Release
//
//  Synopsis:   decrements the reference count
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    ULONG -- the new reference count
//
//  Signals:
//
//  Modifies:
//
//  Derivation: ILockBytes
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              16-Dec-93 alexgo    added GlobalUnlock to match the Global
//                                  Lock in Create
//              05-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CMemBytes::Release(void)
{
        VDATEHEAP();

        ULONG ulRefs = InterlockedDecrement ((LPLONG) &m_refs);

        if (ulRefs != 0)
        {
                return ulRefs;
        }

        // GlobalUnlock the m_hMem that we GlobalLocke'd in Create
        GlobalUnlock(m_hMem);

        ReleaseMemStm(&m_hMem);

        delete this;
        return 0;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMemBytes::ReadAt
//
//  Synopsis:   reads [cb] bytes from starting position [ulOffset]
//
//  Effects:
//
//  Arguments:  [ulOffset]      -- the offset to start reading from
//              [pb]            -- where to put the data
//              [cb]            -- the number of bytes to read
//              [pcbRead]       -- where to put the number of bytes actually
//                                 read
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: ILockBytes
//
//  Algorithm:  just calls xmemcpy
//
//  History:    dd-mmm-yy Author    Comment
//              05-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CMemBytes_ReadAt)
STDMETHODIMP CMemBytes::ReadAt(ULARGE_INTEGER ulOffset, void HUGEP* pb,
        ULONG cb, ULONG FAR* pcbRead)
{
        VDATEHEAP();

        HRESULT         error   = NOERROR;
        ULONG           cbRead  = cb;

        VDATEPTROUT( pb, char );

        // make sure we don't offset out of the address space!
        AssertSz(ulOffset.HighPart == 0,
                "CMemBytes: offset greater than 2^32");

        if (pcbRead)
        {
                *pcbRead = 0L;
        }

        if (cbRead + ulOffset.LowPart > m_pData->cb)
        {

                if (ulOffset.LowPart > m_pData->cb)
                {
                        // the offset overruns the size of the memory
                        cbRead = 0;
                }
                else
                {
                        // just read what's left
                        cbRead = m_pData->cb - ulOffset.LowPart;
                }
        }

        if (cbRead > 0)
        {
                BYTE HUGEP* pGlobal = (BYTE HUGEP *)GlobalLock(
                        m_pData->hGlobal);
                if (NULL==pGlobal)
                {
                        LEERROR(1, "GlobalLock failed!");

                        return ResultFromScode (STG_E_READFAULT);
                }
                _xmemcpy(pb, pGlobal + ulOffset.LowPart, cbRead);
                GlobalUnlock (m_pData->hGlobal);
        }

        if (pcbRead != NULL)
        {
                *pcbRead = cbRead;
        }

        return error;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMemBytes::WriteAt
//
//  Synopsis:   writes [cb] bytes at [ulOffset] in the stream
//
//  Effects:
//
//  Arguments:  [ulOffset]      -- the offset at which to start writing
//              [pb]            -- the buffer to read from
//              [cb]            -- the number of bytes to write
//              [pcbWritten]    -- where to put the number of bytes written
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Derivation: ILockBytes
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              05-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CMemBytes_WriteAt)
STDMETHODIMP CMemBytes::WriteAt(ULARGE_INTEGER ulOffset, void const HUGEP* pb,
        ULONG cb, ULONG FAR* pcbWritten)
{
        VDATEHEAP();

        HRESULT         error           = NOERROR;
        ULONG           cbWritten       = cb;
        BYTE HUGEP*     pGlobal;

        VDATEPTRIN( pb, char );

        // make sure the offset doesn't go beyond our address space!

        AssertSz(ulOffset.HighPart == 0, "WriteAt, offset greater than 2^32");

        if (pcbWritten)
        {
                *pcbWritten = 0;
        }

        if (cbWritten + ulOffset.LowPart > m_pData->cb)
        {
                ULARGE_INTEGER ularge_integer;
                ULISet32( ularge_integer, ulOffset.LowPart + cbWritten);
                error = SetSize( ularge_integer );
                if (error != NOERROR)
                {
                        goto Exit;
                }
        }

        // CMemBytes does not allow zero-sized memory handles

        pGlobal = (BYTE HUGEP *)GlobalLock (m_pData->hGlobal);

        if (NULL==pGlobal)
        {
                LEERROR(1, "GlobalLock failed!");

                return ResultFromScode (STG_E_WRITEFAULT);
        }

        _xmemcpy(pGlobal + ulOffset.LowPart, pb, cbWritten);
        GlobalUnlock (m_pData->hGlobal);


        if (pcbWritten != NULL)
        {
                *pcbWritten = cbWritten;
        }

Exit:
        return error;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMemBytes::Flush
//
//  Synopsis:   Flushes internal state to disk
//              Not needed for memory ILockBytes
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    NOERROR
//
//  Signals:
//
//  Modifies:
//
//  Derivation: ILockBytes
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              05-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CMemBytes_Flush)
STDMETHODIMP CMemBytes::Flush(void)
{
        VDATEHEAP();

        return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMemBytes::SetSize
//
//  Synopsis:   Sets the size of the memory buffer
//
//  Effects:
//
//  Arguments:  [cb]    -- the new size
//
//  Requires:
//
//  Returns:    NOERROR, E_OUTOFMEMORY
//
//  Signals:
//
//  Modifies:
//
//  Derivation: ILockBytes
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              05-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CMemBytes_SetSize)
STDMETHODIMP CMemBytes::SetSize(ULARGE_INTEGER cb)
{
        VDATEHEAP();

        HANDLE          hMemNew;

        AssertSz(cb.HighPart == 0,
                "SetSize: trying to set to more than 2^32 bytes");

        if (m_pData->cb == cb.LowPart)
        {
                return NOERROR;
        }

        hMemNew = GlobalReAlloc(m_pData->hGlobal, max (cb.LowPart, 1),
                GMEM_SHARE | GMEM_MOVEABLE);

        if (hMemNew == NULL)
        {
                return ResultFromScode(E_OUTOFMEMORY);
        }

        m_pData->hGlobal = hMemNew;
        m_pData->cb = cb.LowPart;

        return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMemBytes::LockRegion
//
//  Synopsis:   Locks a region.  Since only we have access to the memory,
//              nothing needs to be done (note that the *app* also may
//              access, but there's not much we can do about that)
//
//  Effects:
//
//  Arguments:  [libOffset]     -- offset to start with
//              [cb]            -- the number of bytes in the locked region
//              [dwLockType]    -- the type of lock to use
//
//  Requires:
//
//  Returns:    NOERROR
//
//  Signals:
//
//  Modifies:
//
//  Derivation: ILockBytes
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              05-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CMemBytes_LockRegion)
STDMETHODIMP CMemBytes::LockRegion(ULARGE_INTEGER libOffset,
        ULARGE_INTEGER cb, DWORD dwLockType)
{
        VDATEHEAP();

        return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMemBytes::UnlockRegion
//
//  Synopsis:   Unlocks a region; since only we have access to the memory,
//              nothing needs to be done.
//
//  Effects:
//
//  Arguments:  [libOffset]     -- the offset to start with
//              [cb]            -- the number of bytes in the region
//              [dwLockType]    -- the lock type
//
//  Requires:
//
//  Returns:    NOERROR
//
//  Signals:
//
//  Modifies:
//
//  Derivation: ILockBytes
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              05-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CMemBytes_UnlockRegion)
STDMETHODIMP CMemBytes::UnlockRegion(ULARGE_INTEGER libOffset,
        ULARGE_INTEGER cb, DWORD dwLockType)
{
        VDATEHEAP();

        return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMemBytes::Stat
//
//  Synopsis:   returns status information
//
//  Effects:
//
//  Arguments:  [pstatstg]      -- where to put the status info
//              [statflag]      -- status flags (ignored)
//
//  Requires:
//
//  Returns:    NOERROR, E_INVALIDARG
//
//  Signals:
//
//  Modifies:
//
//  Derivation: ILockBytes
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              05-Dec-93 alexgo    32bit port
//              01-Jun-94 AlexT     Set type correctly
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CMemBytes_Stat)
STDMETHODIMP CMemBytes::Stat(STATSTG FAR *pstatstg, DWORD statflag)
{
        VDATEHEAP();

        VDATEPTROUT( pstatstg, STATSTG );

        memset ( pstatstg, 0, sizeof(STATSTG) );

        pstatstg->type                  = STGTY_LOCKBYTES;
        pstatstg->cbSize.LowPart        = m_pData->cb;

        return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMemBytes::Create
//
//  Synopsis:   Creates an instance of CMemBytes
//
//  Effects:
//
//  Arguments:  [hMem]  -- handle to the memory (must be a MEMSTM block)
//
//  Requires:
//
//  Returns:    CMemBytes *
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              16-Dec-93 alexgo    fixed bad pointer bug (took out
//                                  GlobalUnlock)
//              05-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CMemBytes_Create)
STDSTATICIMP_(CMemBytes FAR*) CMemBytes::Create(HANDLE hMem)
{
        VDATEHEAP();

        CMemBytes FAR*          pCMemBytes = NULL;
        struct MEMSTM FAR*      pData;

        pData = (MEMSTM FAR*) GlobalLock(hMem);

        if (pData != NULL)
        {
                Assert (pData->hGlobal);

                pCMemBytes = new CMemBytes;

                if (pCMemBytes != NULL)
                {
                        // Initialize CMemBytes
                        pCMemBytes->m_dwSig = LOCKBYTE_SIG;
                        pCMemBytes->m_hMem = hMem;
                        InterlockedIncrement ((LPLONG) &(pCMemBytes->m_pData = pData)->cRef); // AddRefMemStm
                        pCMemBytes->m_refs = 1;
                        CALLHOOKOBJECTCREATE(S_OK,CLSID_NULL,IID_ILockBytes,
                                             (IUnknown **)&pCMemBytes);
                }
                else
                {
                        // uh-oh, low on memory
                        GlobalUnlock(hMem);
                }
        }

        // we don't GlobalUnlock(hMem) until we destory this CMemBytes
        return pCMemBytes;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMemBytes::Dump, public (_DEBUG only)
//
//  Synopsis:   return a string containing the contents of the data members
//
//  Effects:
//
//  Arguments:  [ppszDump]      - an out pointer to a null terminated character array
//              [ulFlag]        - flag determining prefix of all newlines of the
//                                out character array (default is 0 - no prefix)
//              [nIndentLevel]  - will add a indent prefix after the other prefix
//                                for ALL newlines (including those with no prefix)
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:   [ppsz]  - argument
//
//  Derivation:
//
//  Algorithm:  use dbgstream to create a string containing information on the
//              content of data structures
//
//  History:    dd-mmm-yy Author    Comment
//              20-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

HRESULT CMemBytes::Dump(char **ppszDump, ULONG ulFlag, int nIndentLevel)
{
    int i;
    char *pszPrefix;
    char *pszMEMSTM;
    dbgstream dstrPrefix;
    dbgstream dstrDump(400);

    // determine prefix of newlines
    if ( ulFlag & DEB_VERBOSE )
    {
        dstrPrefix << this << " _VB ";
    }

    // determine indentation prefix for all newlines
    for (i = 0; i < nIndentLevel; i++)
    {
        dstrPrefix << DUMPTAB;
    }

    pszPrefix = dstrPrefix.str();

    // put data members in stream
    dstrDump << pszPrefix << "Impl. Signature   = " << m_dwSig  << endl;

    dstrDump << pszPrefix << "No. of References = " << m_refs   << endl;

    dstrDump << pszPrefix << "Memory handle     = " << m_hMem   << endl;

    if (m_pData != NULL)
    {
        pszMEMSTM = DumpMEMSTM(m_pData, ulFlag, nIndentLevel + 1);
        dstrDump << pszPrefix << "MEMSTM:"                      << endl;
        dstrDump << pszMEMSTM;
        CoTaskMemFree(pszMEMSTM);
    }
    else
    {
        dstrDump << pszPrefix << "MEMSTM            = " << m_pData  << endl;
    }

    // cleanup and provide pointer to character array
    *ppszDump = dstrDump.str();

    if (*ppszDump == NULL)
    {
        *ppszDump = UtDupStringA(szDumpErrorMessage);
    }

    CoTaskMemFree(pszPrefix);

    return NOERROR;
}

#endif // _DEBUG

//+-------------------------------------------------------------------------
//
//  Function:   DumpCMemBytes, public (_DEBUG only)
//
//  Synopsis:   calls the CMemBytes::Dump method, takes care of errors and
//              returns the zero terminated string
//
//  Effects:
//
//  Arguments:  [pMB]           - pointer to CMemBytes
//              [ulFlag]        - flag determining prefix of all newlines of the
//                                out character array (default is 0 - no prefix)
//              [nIndentLevel]  - will add a indent prefix after the other prefix
//                                for ALL newlines (including those with no prefix)
//
//  Requires:
//
//  Returns:    character array of structure dump or error (null terminated)
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              20-Jan-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

#ifdef _DEBUG

char *DumpCMemBytes(CMemBytes *pMB, ULONG ulFlag, int nIndentLevel)
{
    HRESULT hresult;
    char *pszDump;

    if (pMB == NULL)
    {
        return UtDupStringA(szDumpBadPtr);
    }

    hresult = pMB->Dump(&pszDump, ulFlag, nIndentLevel);

    if (hresult != NOERROR)
    {
        CoTaskMemFree(pszDump);

        return DumpHRESULT(hresult);
    }

    return pszDump;
}

#endif // _DEBUG

// --------------------------------------------------------------------
// EVERYTHING BELOW HERE HAS BEEN REMOVED FROM WIN32 VERSIONS.

#ifndef WIN32

// CMemStm object's IMarshal implementation
//

//+-------------------------------------------------------------------------
//
//  Member:     CMarshalMemStm::QueryInterface
//
//  Synopsis:   returns the requested interface ID
//
//  Effects:
//
//  Arguments:  [iidInterface]  -- the requested interface
//              [ppvObj]        -- where to put the interface pointer
//
//  Requires:
//
//  Returns:    NOERROR, E_NOINTERFACE
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IMarshal
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              05-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CMarshalMemStm_QueryInterface)
STDMETHODIMP CMarshalMemStm::QueryInterface(REFIID iidInterface,
        void FAR* FAR* ppvObj)
{
        VDATEHEAP();

        HRESULT         error;

        VDATEPTROUT( ppvObj, LPVOID );
        *ppvObj = NULL;
        VDATEIID( iidInterface );

        // Two interfaces supported: IUnknown, IMarshal

        if (IsEqualIID(iidInterface, IID_IMarshal) ||
                IsEqualIID(iidInterface, IID_IUnknown))
        {
                InterlockedIncrement (&m_refs);           // A pointer to this object is returned
                *ppvObj = this;
                error = NOERROR;
        }
        else
        {
                // Not accessible or unsupported interface
                *ppvObj = NULL;
                error = ResultFromScode (E_NOINTERFACE);
        }

        return error;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMarshalMemstm::AddRef
//
//  Synopsis:   increments the reference count
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    ULONG -- the new reference count
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IMarshal
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              05-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CMarshalMemStm_AddRef)
STDMETHODIMP_(ULONG) CMarshalMemStm::AddRef(void)
{
        VDATEHEAP();

        return InterlockedIncrement (&m_refs);
}

//+-------------------------------------------------------------------------
//
//  Member:     CMarshalMemStm::Release
//
//  Synopsis:   decrements the reference count
//
//  Effects:
//
//  Arguments:  void
//
//  Requires:
//
//  Returns:    ULONG -- the new reference count
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IMarshal
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              05-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CMarshalMemStm_Release)
STDMETHODIMP_(ULONG) CMarshalMemStm::Release(void)
{
        VDATEHEAP();

        ULONG ulRefs = InterlockedDecrement (&m_refs);

        if (ulRefs != 0)
        {
                return ulRefs;
        }

        if (m_pMemStm != NULL)
        {
                m_pMemStm->Release();
        }

        delete this; // Free storage
        return 0;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMarshalMemStm::GetUnmarshalClass
//
//  Synopsis:   returns the object class that should be used to create
//              the proxy in the unmarshalling process (CLSID_StdMemStm)
//
//  Effects:
//
//  Arguments:  [riid]          -- the interface ID of the object to be
//                                 marshalled
//              [pv]            -- pointer to the object
//              [dwDestContext] -- marshalling context (such a no shared mem)
//              [pvDestContext] -- reserved
//              [mshlfags]      -- marshalling flags (e.g. NORMAL)
//              [pCid]          -- where to put the class ID
//
//  Requires:
//
//  Returns:    NOERROR
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IMarshal
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              05-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CMarshalMemStm_GetUnmarshalClass)
STDMETHODIMP CMarshalMemStm::GetUnmarshalClass(REFIID riid, LPVOID pv,
        DWORD dwDestContext, LPVOID pvDestContext, DWORD mshlflags,
        CLSID FAR* pCid)
{
        VDATEHEAP();

        VDATEPTROUT( pCid, CLSID);

        *pCid = CLSID_StdMemStm;

        return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMarshalMemStm::GetUnmarshalSizeMax
//
//  Synopsis:   returns the amount of memory needed to marshal the data
//              (in this case, the hglobal)
//
//  Effects:
//
//  Arguments:  [riid]          -- the interface of the object
//              [pv]            -- pointer to the object
//              [dwDestContext] -- marshalling context (such a no shared mem)
//              [pvDestContext] -- reserved
//              [mshlfags]      -- marshalling flags (e.g. NORMAL)
//              [pSize]         -- where to put the size
//
//  Requires:
//
//  Returns:    NOERROR, E_INVALIDARG
//
//  Signals:
//
//  Modifies:
//
//  Derivation: IMarshal
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              05-Dec-93 alexgo    32bit port
//
//  Notes:
//
//--------------------------------------------------------------------------

#pragma SEG(CMarshalMemStm_GetMarshalSizeMax)
STDMETHODIMP CMarshalMemStm::GetMarshalSizeMax(REFIID riid, LPVOID pv,
        DWORD dwDestContext, LPVOID pvDestContext, DWORD mshlflags,
        DWORD FAR* pSize)
{
        VDATEHEAP();

        VDATEPTROUT(pSize, DWORD);

        *pSize = sizeof(m_pMemStm->m_hMem);
        return NOERROR;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMarshalMemStm::MarshalInterface
//
//  Synopsis:   marshals a reference of the objects interface into [pStm]
//
//  Effects:
//
//  Arguments:  [pStm]          -- the stream into which the object should
//                                 be marshalled
//              [riid]          -- the interface ID of the object to be
//                                 mars